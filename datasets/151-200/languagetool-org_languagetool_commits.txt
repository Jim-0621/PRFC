File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/SimpleReplaceRule.java
Patch:
@@ -26,6 +26,7 @@
 import java.util.Set;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
 import org.apache.commons.lang3.StringUtils;
 import org.languagetool.AnalyzedSentence;
@@ -186,8 +187,8 @@ private List<String> findInDeriv(String w) {
     List<String> suggestions = 
         derivats.stream()
         .map(d -> getWrongWords().get(d))
-        .flatMap(c -> c.stream())
-        .map(t ->
+          .flatMap(c -> c != null ? c.stream() : Stream.empty())
+          .map(t ->
           CaseGovernmentHelper.DERIVATIVES_MAP.entrySet().stream()
           .filter(e -> e.getValue().contains(t) && e.getKey().endsWith(ending)) // filter -ючи vs -вши
           .map(e -> e.getKey())

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -73,6 +73,9 @@ public final List<AbstractPatternRule> getRules(InputStream is, String filename,
         Tools.setPasswordAuthenticator();
       }
       saxParser.getXMLReader().setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
+      saxParser.getXMLReader().setProperty("jdk.xml.maxGeneralEntitySizeLimit", 0);
+      saxParser.getXMLReader().setProperty("jdk.xml.totalEntitySizeLimit", 0);
+      saxParser.getXMLReader().setProperty("jdk.xml.entityExpansionLimit", 0);
       saxParser.parse(is, handler);
       return handler.getRules();
     } catch (Exception e) {

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationRuleLoader.java
Patch:
@@ -44,6 +44,9 @@ public final List<DisambiguationPatternRule> getRules(InputStream stream, Langua
     DisambiguationRuleHandler handler = new DisambiguationRuleHandler(language, xmlPath);
     SAXParserFactory factory = SAXParserFactory.newInstance();
     SAXParser saxParser = factory.newSAXParser();
+    saxParser.getXMLReader().setProperty("jdk.xml.maxGeneralEntitySizeLimit", 0);
+    saxParser.getXMLReader().setProperty("jdk.xml.totalEntitySizeLimit", 0);
+    saxParser.getXMLReader().setProperty("jdk.xml.entityExpansionLimit", 0);
 
     if (JLanguageTool.isCustomPasswordAuthenticatorUsed()) {
       Tools.setPasswordAuthenticator();

File: languagetool-language-modules/ga/src/main/java/org/languagetool/rules/ga/NoDisambiguationIrishPartialPosTagFilter.java
Patch:
@@ -35,7 +35,7 @@
  */
 public class NoDisambiguationIrishPartialPosTagFilter extends PartialPosTagFilter {
 
-  private final Tagger tagger = new Irish().getTagger();
+  private final Tagger tagger = Irish.getInstance().getTagger();
 
   @Override
   protected List<AnalyzedTokenReadings> tag(String token) {

File: languagetool-language-modules/ga/src/main/java/org/languagetool/tagging/disambiguation/ga/IrishHybridDisambiguator.java
Patch:
@@ -37,7 +37,7 @@
 public class IrishHybridDisambiguator extends AbstractDisambiguator {
 
   private final Disambiguator chunker = MultiWordChunker.getInstance("/ga/multiwords.txt");
-  private final Disambiguator disambiguator = new XmlRuleDisambiguator(new Irish());
+  private final Disambiguator disambiguator = new XmlRuleDisambiguator(Irish.getInstance());
 
   /**
    * Calls two disambiguator classes: (1) a chunker; (2) a rule-based

File: languagetool-language-modules/ga/src/test/java/org/languagetool/rules/ga/DhaNoBeirtRuleTest.java
Patch:
@@ -37,7 +37,7 @@ public class DhaNoBeirtRuleTest {
   @Before
   public void setUp() throws IOException {
     rule = new DhaNoBeirtRule(TestTools.getMessages("ga"));
-    lt = new JLanguageTool(new Irish());
+    lt = new JLanguageTool(Irish.getInstance());
   }
 
   @Test

File: languagetool-language-modules/ga/src/test/java/org/languagetool/rules/ga/MorfologikIrishSpellerRuleTest.java
Patch:
@@ -34,9 +34,9 @@ public class MorfologikIrishSpellerRuleTest {
   @Test
   public void testMorfologikSpeller() throws IOException {
     MorfologikIrishSpellerRule rule =
-      new MorfologikIrishSpellerRule (TestTools.getMessages("ga"), new Irish(), null, Collections.emptyList());
+      new MorfologikIrishSpellerRule (TestTools.getMessages("ga"), Irish.getInstance(), null, Collections.emptyList());
 
-    JLanguageTool lt = new JLanguageTool(new Irish());
+    JLanguageTool lt = new JLanguageTool(Irish.getInstance());
 
     //incorrect sentences:
     RuleMatch[] matches = rule.match(lt.getAnalyzedSentence("botun"));

File: languagetool-language-modules/ga/src/test/java/org/languagetool/tagging/disambiguation/rules/ga/IrishDisambiguationRuleTest.java
Patch:
@@ -42,8 +42,8 @@ public class IrishDisambiguationRuleTest extends DisambiguationRuleTest {
   public void setUp() {
     tagger = new IrishTagger();
     tokenizer = new WordTokenizer();
-    sentenceTokenizer = new SRXSentenceTokenizer(new Irish());
-    disambiguator = new XmlRuleDisambiguator(new Irish());
+    sentenceTokenizer = new SRXSentenceTokenizer(Irish.getInstance());
+    disambiguator = new XmlRuleDisambiguator(Irish.getInstance());
   }
 
   @Test

File: languagetool-language-modules/ga/src/test/java/org/languagetool/tagging/ga/IrishTaggerTest.java
Patch:
@@ -37,7 +37,7 @@ public void setUp() {
   }
 
   public void testDictionary() throws IOException {
-    TestTools.testDictionary(tagger, new Irish());
+    TestTools.testDictionary(tagger, Irish.getInstance());
   }
   
   public void testTagger() throws IOException {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanConfusionProbabilityRule.java
Patch:
@@ -55,6 +55,8 @@ public class GermanConfusionProbabilityRule extends ConfusionProbabilityRule {
   private static final List<String> EXCEPTIONS = Arrays.asList(
     // Use all-lowercase, matches will be case-insensitive.
     // See https://github.com/languagetool-org/languagetool/issues/1516
+    "weist bei interesse auf",
+    "weist bei bedarf auf",
     "wir bei der",
     "seht ihr",
     "seht zu, dass",

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractUnitConversionRule.java
Patch:
@@ -80,7 +80,7 @@ public abstract class AbstractUnitConversionRule extends Rule {
   protected static final String NUMBER_REGEX = "(-?[0-9]{1,32}[0-9,.]{0,32})";
   protected static final String NUMBER_REGEX_WITH_BOUNDARY = "(-?\\b[0-9]{1,32}[0-9,.]{0,32})";
 
-  protected final Pattern numberRangePart = Pattern.compile(NUMBER_REGEX_WITH_BOUNDARY + "$", Pattern.UNICODE_CHARACTER_CLASS);
+  protected final Pattern numberRangePart = Pattern.compile(NUMBER_REGEX_WITH_BOUNDARY + "$");
   
   private static final double DELTA = 1e-2;
   private static final double ROUNDING_DELTA = 0.05;
@@ -196,7 +196,7 @@ protected String formatRounded(String s) {
    */
   protected void addUnit(String pattern, Unit base, String symbol, double factor, boolean metric) {
     Unit unit = base.multiply(factor);
-    unitPatterns.put(Pattern.compile(NUMBER_REGEX_WITH_BOUNDARY + "[\\s\u00A0]{0," + WHITESPACE_LIMIT + "}" + pattern + "\\b", Pattern.UNICODE_CHARACTER_CLASS), unit);
+    unitPatterns.put(Pattern.compile(NUMBER_REGEX_WITH_BOUNDARY + "[\\s\u00A0]{0," + WHITESPACE_LIMIT + "}" + pattern + "\\b"), unit);
     unitSymbols.putIfAbsent(unit, new ArrayList<>());
     unitSymbols.get(unit).add(symbol);
     if (metric && !metricUnits.contains(unit)) {

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -776,8 +776,7 @@ private void createRules(List<PatternToken> elemList,
         rule.setDistanceTokens(distanceTokens);
         rule.setXmlLineNumber(xmlLineNumber);
       } else if (regex.length() > 0) {
-//        int flags = regexCaseSensitive ? 0 : Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE;
-        int flags = regexCaseSensitive ? Pattern.UNICODE_CHARACTER_CLASS : Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CHARACTER_CLASS;
+        int flags = regexCaseSensitive ? 0 : Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE;
         String regexStr = regex.toString();
         if (regexMode == RegexpMode.SMART) {
           // Note: it's not that easy to add \b because the regex might look like '(foo)' or '\d' so we cannot just look at the last character

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/RegexAntiPatternFilter.java
Patch:
@@ -42,7 +42,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     }
     String[] antiPatterns = antiPatternStr.split("\\|");
     for (String antiPattern : antiPatterns) {
-      Pattern p = Pattern.compile(antiPattern, Pattern.UNICODE_CHARACTER_CLASS);
+      Pattern p = Pattern.compile(antiPattern);
       Matcher matcher = p.matcher(sentenceObj.getText());
       while (matcher.find()) {
         // partial overlap is enough to filter out a match:

File: languagetool-core/src/main/java/org/languagetool/tokenizers/SrxTools.java
Patch:
@@ -31,7 +31,6 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.regex.Pattern;
 
 /**
  * Tools for loading an SRX tokenizer file.
@@ -60,8 +59,7 @@ static SrxDocument createSrxDocument(String path) {
 
   static List<String> tokenize(String text, SrxDocument srxDocument, String code) {
     List<String> segments = new ArrayList<>();
-    Map<String, Object> parserParameters = Map.of(SrxTextIterator.DEFAULT_PATTERN_FLAGS_PARAMETER, Pattern.UNICODE_CHARACTER_CLASS);
-    TextIterator textIterator = new SrxTextIterator(srxDocument, code, text, parserParameters);
+    TextIterator textIterator = new SrxTextIterator(srxDocument, code, text);
     while (textIterator.hasNext()) {
       segments.add(textIterator.next());
     }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/PronomsFeblesHelper.java
Patch:
@@ -553,7 +553,7 @@ public static String convertPronounsForIntransitiveVerb(String s) {
   private static Pattern pronoun_wrong_apostrophation = Pattern.compile("([mts])'([^aeiouh].*)",
     Pattern.CASE_INSENSITIVE);
   private static Pattern pronoun_missing_apostrophation = Pattern.compile("(.*)\\be([stm]) (h?[aeiouh].*)",
-    Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CHARACTER_CLASS);
+    Pattern.CASE_INSENSITIVE);
   private static Pattern pronoun_wrong_hypphen = Pattern.compile("(.*)(-[stm])e-(h[oi])",
     Pattern.CASE_INSENSITIVE);
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -61,7 +61,7 @@
  */
 public class German extends Language implements AutoCloseable {
 
-  private static final Pattern TYPOGRAPHY_PATTERN = compile("\\b([a-zA-Z]\\.)([a-zA-Z]\\.)", Pattern.UNICODE_CHARACTER_CLASS);
+  private static final Pattern TYPOGRAPHY_PATTERN = compile("\\b([a-zA-Z]\\.)([a-zA-Z]\\.)");
   private static final Pattern AI_DE_GGEC_MISSING_PUNCT =
     compile("AI_DE_GGEC_MISSING_PUNCTUATION_\\d+_DASH_J(_|AE)HRIG|AI_DE_GGEC_REPLACEMENT_CONFUSION", Pattern.CASE_INSENSITIVE);
   private static final String GERMAN_SHORT_CODE = "de";

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -315,7 +315,7 @@ public boolean hasMinMatchesRules() {
     return true;
   }
   
-  private static final Pattern ES_CONTRACTIONS = Pattern.compile("\\b([Aa]|[Dd]e) e(l)\\b", Pattern.UNICODE_CHARACTER_CLASS);
+  private static final Pattern ES_CONTRACTIONS = Pattern.compile("\\b([Aa]|[Dd]e) e(l)\\b");
   
   @Override
   public String adaptSuggestion(String replacement) {

File: languagetool-language-modules/es/src/main/java/org/languagetool/tokenizers/es/SpanishWordTokenizer.java
Patch:
@@ -43,7 +43,7 @@ public class SpanishWordTokenizer extends WordTokenizer {
   // decimal comma between digits
   private static final Pattern DECIMAL_COMMA= Pattern.compile("([\\d]),([\\d])",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   // ordinals
-  private static final Pattern ORDINAL_POINT= Pattern.compile("\\b([\\d]+)\\.(º|ª|o|a|er|os|as)\\b",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CHARACTER_CLASS);
+  private static final Pattern ORDINAL_POINT= Pattern.compile("\\b([\\d]+)\\.(º|ª|o|a|er|os|as)\\b",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   private static final Pattern PATTERN_1 = Pattern.compile("xxES_DECIMAL_POINTxx", Pattern.LITERAL);
   private static final Pattern PATTERN_2 = Pattern.compile("xxES_DECIMAL_COMMAxx", Pattern.LITERAL);
   private static final Pattern PATTERN_3 = Pattern.compile("xxES_ORDINAL_POINTxx", Pattern.LITERAL);

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -48,9 +48,9 @@
 
 public class French extends Language implements AutoCloseable {
   private static final String BEFORE_APOS = "([cjnmtsldCJNMTSLD]|qu|jusqu|lorsqu|puisqu|quoiqu|Qu|Jusqu|Lorsqu|Puisqu|Quoiqu|QU|JUSQU|LORSQU|PUISQU|QUOIQU)";
-  private static final Pattern BEFORE_APOS_PATTERN_1 = compile("(\\b" + BEFORE_APOS + ")'", Pattern.UNICODE_CHARACTER_CLASS);
-  private static final Pattern BEFORE_APOS_PATTERN_2 = compile("(\\b" + BEFORE_APOS + ")’\"", Pattern.UNICODE_CHARACTER_CLASS);
-  private static final Pattern BEFORE_APOS_PATTERN_3 = compile("(\\b" + BEFORE_APOS + ")’'", Pattern.UNICODE_CHARACTER_CLASS);
+  private static final Pattern BEFORE_APOS_PATTERN_1 = compile("(\\b" + BEFORE_APOS + ")'");
+  private static final Pattern BEFORE_APOS_PATTERN_2 = compile("(\\b" + BEFORE_APOS + ")’\"");
+  private static final Pattern BEFORE_APOS_PATTERN_3 = compile("(\\b" + BEFORE_APOS + ")’'");
 
   private static final Pattern TYPOGRAPHY_PATTERN_1 = compile("\u00a0;");
   private static final Pattern TYPOGRAPHY_PATTERN_2 = compile("\u00a0!");

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tokenizers/fr/FrenchWordTokenizer.java
Patch:
@@ -64,9 +64,9 @@ public class FrenchWordTokenizer extends WordTokenizer {
   private static final Pattern SPACE_DIGITS0 = Pattern.compile("([\\d]{4}) ",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
   private static final Pattern SPACE_DIGITS = Pattern.compile("([\\d]) ([\\d][\\d][\\d])\\b",
-      Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CHARACTER_CLASS);
+      Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
   private static final Pattern SPACE_DIGITS2 = Pattern.compile("([\\d]) ([\\d][\\d][\\d]) ([\\d][\\d][\\d])\\b",
-      Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CHARACTER_CLASS);
+      Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
 
   private static final List<String> doNotSplit = Arrays.asList("mers-cov", "mcgraw-hill", "sars-cov-2", "sars-cov",
       "ph-metre", "ph-metres", "anti-ivg", "anti-uv", "anti-vih", "al-qaïda", "c'est-à-dire", "add-on", "add-ons",

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractUnitConversionRule.java
Patch:
@@ -80,7 +80,7 @@ public abstract class AbstractUnitConversionRule extends Rule {
   protected static final String NUMBER_REGEX = "(-?[0-9]{1,32}[0-9,.]{0,32})";
   protected static final String NUMBER_REGEX_WITH_BOUNDARY = "(-?\\b[0-9]{1,32}[0-9,.]{0,32})";
 
-  protected final Pattern numberRangePart = Pattern.compile(NUMBER_REGEX_WITH_BOUNDARY + "$");
+  protected final Pattern numberRangePart = Pattern.compile(NUMBER_REGEX_WITH_BOUNDARY + "$", Pattern.UNICODE_CHARACTER_CLASS);
   
   private static final double DELTA = 1e-2;
   private static final double ROUNDING_DELTA = 0.05;
@@ -196,7 +196,7 @@ protected String formatRounded(String s) {
    */
   protected void addUnit(String pattern, Unit base, String symbol, double factor, boolean metric) {
     Unit unit = base.multiply(factor);
-    unitPatterns.put(Pattern.compile(NUMBER_REGEX_WITH_BOUNDARY + "[\\s\u00A0]{0," + WHITESPACE_LIMIT + "}" + pattern + "\\b"), unit);
+    unitPatterns.put(Pattern.compile(NUMBER_REGEX_WITH_BOUNDARY + "[\\s\u00A0]{0," + WHITESPACE_LIMIT + "}" + pattern + "\\b", Pattern.UNICODE_CHARACTER_CLASS), unit);
     unitSymbols.putIfAbsent(unit, new ArrayList<>());
     unitSymbols.get(unit).add(symbol);
     if (metric && !metricUnits.contains(unit)) {

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -776,7 +776,8 @@ private void createRules(List<PatternToken> elemList,
         rule.setDistanceTokens(distanceTokens);
         rule.setXmlLineNumber(xmlLineNumber);
       } else if (regex.length() > 0) {
-        int flags = regexCaseSensitive ? 0 : Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE;
+//        int flags = regexCaseSensitive ? 0 : Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE;
+        int flags = regexCaseSensitive ? Pattern.UNICODE_CHARACTER_CLASS : Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CHARACTER_CLASS;
         String regexStr = regex.toString();
         if (regexMode == RegexpMode.SMART) {
           // Note: it's not that easy to add \b because the regex might look like '(foo)' or '\d' so we cannot just look at the last character

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/RegexAntiPatternFilter.java
Patch:
@@ -42,7 +42,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     }
     String[] antiPatterns = antiPatternStr.split("\\|");
     for (String antiPattern : antiPatterns) {
-      Pattern p = Pattern.compile(antiPattern);
+      Pattern p = Pattern.compile(antiPattern, Pattern.UNICODE_CHARACTER_CLASS);
       Matcher matcher = p.matcher(sentenceObj.getText());
       while (matcher.find()) {
         // partial overlap is enough to filter out a match:

File: languagetool-core/src/main/java/org/languagetool/tokenizers/SrxTools.java
Patch:
@@ -31,6 +31,7 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.regex.Pattern;
 
 /**
  * Tools for loading an SRX tokenizer file.
@@ -59,7 +60,8 @@ static SrxDocument createSrxDocument(String path) {
 
   static List<String> tokenize(String text, SrxDocument srxDocument, String code) {
     List<String> segments = new ArrayList<>();
-    TextIterator textIterator = new SrxTextIterator(srxDocument, code, text);
+    Map<String, Object> parserParameters = Map.of(SrxTextIterator.DEFAULT_PATTERN_FLAGS_PARAMETER, Pattern.UNICODE_CHARACTER_CLASS);
+    TextIterator textIterator = new SrxTextIterator(srxDocument, code, text, parserParameters);
     while (textIterator.hasNext()) {
       segments.add(textIterator.next());
     }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/PronomsFeblesHelper.java
Patch:
@@ -553,7 +553,7 @@ public static String convertPronounsForIntransitiveVerb(String s) {
   private static Pattern pronoun_wrong_apostrophation = Pattern.compile("([mts])'([^aeiouh].*)",
     Pattern.CASE_INSENSITIVE);
   private static Pattern pronoun_missing_apostrophation = Pattern.compile("(.*)\\be([stm]) (h?[aeiouh].*)",
-    Pattern.CASE_INSENSITIVE);
+    Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CHARACTER_CLASS);
   private static Pattern pronoun_wrong_hypphen = Pattern.compile("(.*)(-[stm])e-(h[oi])",
     Pattern.CASE_INSENSITIVE);
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -55,7 +55,7 @@
  */
 public class German extends Language implements AutoCloseable {
 
-  private static final Pattern TYPOGRAPHY_PATTERN = compile("\\b([a-zA-Z]\\.)([a-zA-Z]\\.)");
+  private static final Pattern TYPOGRAPHY_PATTERN = compile("\\b([a-zA-Z]\\.)([a-zA-Z]\\.)", Pattern.UNICODE_CHARACTER_CLASS);
   private static final Pattern AI_DE_GGEC_MISSING_PUNCT =
     compile("AI_DE_GGEC_MISSING_PUNCTUATION_\\d+_DASH_J(_|AE)HRIG|AI_DE_GGEC_REPLACEMENT_CONFUSION", Pattern.CASE_INSENSITIVE);
 

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -315,7 +315,7 @@ public boolean hasMinMatchesRules() {
     return true;
   }
   
-  private static final Pattern ES_CONTRACTIONS = Pattern.compile("\\b([Aa]|[Dd]e) e(l)\\b");
+  private static final Pattern ES_CONTRACTIONS = Pattern.compile("\\b([Aa]|[Dd]e) e(l)\\b", Pattern.UNICODE_CHARACTER_CLASS);
   
   @Override
   public String adaptSuggestion(String replacement) {

File: languagetool-language-modules/es/src/main/java/org/languagetool/tokenizers/es/SpanishWordTokenizer.java
Patch:
@@ -43,7 +43,7 @@ public class SpanishWordTokenizer extends WordTokenizer {
   // decimal comma between digits
   private static final Pattern DECIMAL_COMMA= Pattern.compile("([\\d]),([\\d])",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   // ordinals
-  private static final Pattern ORDINAL_POINT= Pattern.compile("\\b([\\d]+)\\.(º|ª|o|a|er|os|as)\\b",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
+  private static final Pattern ORDINAL_POINT= Pattern.compile("\\b([\\d]+)\\.(º|ª|o|a|er|os|as)\\b",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CHARACTER_CLASS);
   private static final Pattern PATTERN_1 = Pattern.compile("xxES_DECIMAL_POINTxx", Pattern.LITERAL);
   private static final Pattern PATTERN_2 = Pattern.compile("xxES_DECIMAL_COMMAxx", Pattern.LITERAL);
   private static final Pattern PATTERN_3 = Pattern.compile("xxES_ORDINAL_POINTxx", Pattern.LITERAL);

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -50,9 +50,9 @@
 public class French extends Language implements AutoCloseable {
 
   private static final String BEFORE_APOS = "([cjnmtsldCJNMTSLD]|qu|jusqu|lorsqu|puisqu|quoiqu|Qu|Jusqu|Lorsqu|Puisqu|Quoiqu|QU|JUSQU|LORSQU|PUISQU|QUOIQU)";
-  private static final Pattern BEFORE_APOS_PATTERN_1 = compile("(\\b" + BEFORE_APOS + ")'");
-  private static final Pattern BEFORE_APOS_PATTERN_2 = compile("(\\b" + BEFORE_APOS + ")’\"");
-  private static final Pattern BEFORE_APOS_PATTERN_3 = compile("(\\b" + BEFORE_APOS + ")’'");
+  private static final Pattern BEFORE_APOS_PATTERN_1 = compile("(\\b" + BEFORE_APOS + ")'", Pattern.UNICODE_CHARACTER_CLASS);
+  private static final Pattern BEFORE_APOS_PATTERN_2 = compile("(\\b" + BEFORE_APOS + ")’\"", Pattern.UNICODE_CHARACTER_CLASS);
+  private static final Pattern BEFORE_APOS_PATTERN_3 = compile("(\\b" + BEFORE_APOS + ")’'", Pattern.UNICODE_CHARACTER_CLASS);
 
   private static final Pattern TYPOGRAPHY_PATTERN_1 = compile("\u00a0;");
   private static final Pattern TYPOGRAPHY_PATTERN_2 = compile("\u00a0!");

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tokenizers/fr/FrenchWordTokenizer.java
Patch:
@@ -64,9 +64,9 @@ public class FrenchWordTokenizer extends WordTokenizer {
   private static final Pattern SPACE_DIGITS0 = Pattern.compile("([\\d]{4}) ",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
   private static final Pattern SPACE_DIGITS = Pattern.compile("([\\d]) ([\\d][\\d][\\d])\\b",
-      Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
+      Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CHARACTER_CLASS);
   private static final Pattern SPACE_DIGITS2 = Pattern.compile("([\\d]) ([\\d][\\d][\\d]) ([\\d][\\d][\\d])\\b",
-      Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
+      Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CHARACTER_CLASS);
 
   private static final List<String> doNotSplit = Arrays.asList("mers-cov", "mcgraw-hill", "sars-cov-2", "sars-cov",
       "ph-metre", "ph-metres", "anti-ivg", "anti-uv", "anti-vih", "al-qaïda", "c'est-à-dire", "add-on", "add-ons",

File: languagetool-server/src/main/java/org/languagetool/server/UserLimits.java
Patch:
@@ -103,6 +103,9 @@ public static UserLimits getLimitsByAddonToken(HTTPServerConfig config, String u
   }
 
   private static UserLimits getUserLimitsFromWhitelistOrDefault(HTTPServerConfig config, String username) {
+    if (config.getRequestLimitWhitelistUsers() == null) {
+      return getDefaultLimits(config);
+    }
     String mailDomain = username.substring(username.indexOf('@') + 1);
     boolean isWhitelisted = false;
     for (String whitelisted : config.getRequestLimitWhitelistUsers()) {

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractUnitConversionRule.java
Patch:
@@ -80,7 +80,7 @@ public abstract class AbstractUnitConversionRule extends Rule {
   protected static final String NUMBER_REGEX = "(-?[0-9]{1,32}[0-9,.]{0,32})";
   protected static final String NUMBER_REGEX_WITH_BOUNDARY = "(-?\\b[0-9]{1,32}[0-9,.]{0,32})";
 
-  protected final Pattern numberRangePart = Pattern.compile(NUMBER_REGEX_WITH_BOUNDARY + "$", Pattern.UNICODE_CHARACTER_CLASS);
+  protected final Pattern numberRangePart = Pattern.compile(NUMBER_REGEX_WITH_BOUNDARY + "$");
   
   private static final double DELTA = 1e-2;
   private static final double ROUNDING_DELTA = 0.05;
@@ -196,7 +196,7 @@ protected String formatRounded(String s) {
    */
   protected void addUnit(String pattern, Unit base, String symbol, double factor, boolean metric) {
     Unit unit = base.multiply(factor);
-    unitPatterns.put(Pattern.compile(NUMBER_REGEX_WITH_BOUNDARY + "[\\s\u00A0]{0," + WHITESPACE_LIMIT + "}" + pattern + "\\b", Pattern.UNICODE_CHARACTER_CLASS), unit);
+    unitPatterns.put(Pattern.compile(NUMBER_REGEX_WITH_BOUNDARY + "[\\s\u00A0]{0," + WHITESPACE_LIMIT + "}" + pattern + "\\b"), unit);
     unitSymbols.putIfAbsent(unit, new ArrayList<>());
     unitSymbols.get(unit).add(symbol);
     if (metric && !metricUnits.contains(unit)) {

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -776,8 +776,7 @@ private void createRules(List<PatternToken> elemList,
         rule.setDistanceTokens(distanceTokens);
         rule.setXmlLineNumber(xmlLineNumber);
       } else if (regex.length() > 0) {
-//        int flags = regexCaseSensitive ? 0 : Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE;
-        int flags = regexCaseSensitive ? Pattern.UNICODE_CHARACTER_CLASS : Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CHARACTER_CLASS;
+        int flags = regexCaseSensitive ? 0 : Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE;
         String regexStr = regex.toString();
         if (regexMode == RegexpMode.SMART) {
           // Note: it's not that easy to add \b because the regex might look like '(foo)' or '\d' so we cannot just look at the last character

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/RegexAntiPatternFilter.java
Patch:
@@ -42,7 +42,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     }
     String[] antiPatterns = antiPatternStr.split("\\|");
     for (String antiPattern : antiPatterns) {
-      Pattern p = Pattern.compile(antiPattern, Pattern.UNICODE_CHARACTER_CLASS);
+      Pattern p = Pattern.compile(antiPattern);
       Matcher matcher = p.matcher(sentenceObj.getText());
       while (matcher.find()) {
         // partial overlap is enough to filter out a match:

File: languagetool-core/src/main/java/org/languagetool/tokenizers/SrxTools.java
Patch:
@@ -31,7 +31,6 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.regex.Pattern;
 
 /**
  * Tools for loading an SRX tokenizer file.
@@ -60,8 +59,7 @@ static SrxDocument createSrxDocument(String path) {
 
   static List<String> tokenize(String text, SrxDocument srxDocument, String code) {
     List<String> segments = new ArrayList<>();
-    Map<String, Object> parserParameters = Map.of(SrxTextIterator.DEFAULT_PATTERN_FLAGS_PARAMETER, Pattern.UNICODE_CHARACTER_CLASS);
-    TextIterator textIterator = new SrxTextIterator(srxDocument, code, text, parserParameters);
+    TextIterator textIterator = new SrxTextIterator(srxDocument, code, text);
     while (textIterator.hasNext()) {
       segments.add(textIterator.next());
     }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/PronomsFeblesHelper.java
Patch:
@@ -553,7 +553,7 @@ public static String convertPronounsForIntransitiveVerb(String s) {
   private static Pattern pronoun_wrong_apostrophation = Pattern.compile("([mts])'([^aeiouh].*)",
     Pattern.CASE_INSENSITIVE);
   private static Pattern pronoun_missing_apostrophation = Pattern.compile("(.*)\\be([stm]) (h?[aeiouh].*)",
-    Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CHARACTER_CLASS);
+    Pattern.CASE_INSENSITIVE);
   private static Pattern pronoun_wrong_hypphen = Pattern.compile("(.*)(-[stm])e-(h[oi])",
     Pattern.CASE_INSENSITIVE);
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -55,7 +55,7 @@
  */
 public class German extends Language implements AutoCloseable {
 
-  private static final Pattern TYPOGRAPHY_PATTERN = compile("\\b([a-zA-Z]\\.)([a-zA-Z]\\.)", Pattern.UNICODE_CHARACTER_CLASS);
+  private static final Pattern TYPOGRAPHY_PATTERN = compile("\\b([a-zA-Z]\\.)([a-zA-Z]\\.)");
   private static final Pattern AI_DE_GGEC_MISSING_PUNCT =
     compile("AI_DE_GGEC_MISSING_PUNCTUATION_\\d+_DASH_J(_|AE)HRIG|AI_DE_GGEC_REPLACEMENT_CONFUSION", Pattern.CASE_INSENSITIVE);
 

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -315,7 +315,7 @@ public boolean hasMinMatchesRules() {
     return true;
   }
   
-  private static final Pattern ES_CONTRACTIONS = Pattern.compile("\\b([Aa]|[Dd]e) e(l)\\b", Pattern.UNICODE_CHARACTER_CLASS);
+  private static final Pattern ES_CONTRACTIONS = Pattern.compile("\\b([Aa]|[Dd]e) e(l)\\b");
   
   @Override
   public String adaptSuggestion(String replacement) {

File: languagetool-language-modules/es/src/main/java/org/languagetool/tokenizers/es/SpanishWordTokenizer.java
Patch:
@@ -43,7 +43,7 @@ public class SpanishWordTokenizer extends WordTokenizer {
   // decimal comma between digits
   private static final Pattern DECIMAL_COMMA= Pattern.compile("([\\d]),([\\d])",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   // ordinals
-  private static final Pattern ORDINAL_POINT= Pattern.compile("\\b([\\d]+)\\.(º|ª|o|a|er|os|as)\\b",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CHARACTER_CLASS);
+  private static final Pattern ORDINAL_POINT= Pattern.compile("\\b([\\d]+)\\.(º|ª|o|a|er|os|as)\\b",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   private static final Pattern PATTERN_1 = Pattern.compile("xxES_DECIMAL_POINTxx", Pattern.LITERAL);
   private static final Pattern PATTERN_2 = Pattern.compile("xxES_DECIMAL_COMMAxx", Pattern.LITERAL);
   private static final Pattern PATTERN_3 = Pattern.compile("xxES_ORDINAL_POINTxx", Pattern.LITERAL);

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -50,9 +50,9 @@
 public class French extends Language implements AutoCloseable {
 
   private static final String BEFORE_APOS = "([cjnmtsldCJNMTSLD]|qu|jusqu|lorsqu|puisqu|quoiqu|Qu|Jusqu|Lorsqu|Puisqu|Quoiqu|QU|JUSQU|LORSQU|PUISQU|QUOIQU)";
-  private static final Pattern BEFORE_APOS_PATTERN_1 = compile("(\\b" + BEFORE_APOS + ")'", Pattern.UNICODE_CHARACTER_CLASS);
-  private static final Pattern BEFORE_APOS_PATTERN_2 = compile("(\\b" + BEFORE_APOS + ")’\"", Pattern.UNICODE_CHARACTER_CLASS);
-  private static final Pattern BEFORE_APOS_PATTERN_3 = compile("(\\b" + BEFORE_APOS + ")’'", Pattern.UNICODE_CHARACTER_CLASS);
+  private static final Pattern BEFORE_APOS_PATTERN_1 = compile("(\\b" + BEFORE_APOS + ")'");
+  private static final Pattern BEFORE_APOS_PATTERN_2 = compile("(\\b" + BEFORE_APOS + ")’\"");
+  private static final Pattern BEFORE_APOS_PATTERN_3 = compile("(\\b" + BEFORE_APOS + ")’'");
 
   private static final Pattern TYPOGRAPHY_PATTERN_1 = compile("\u00a0;");
   private static final Pattern TYPOGRAPHY_PATTERN_2 = compile("\u00a0!");

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tokenizers/fr/FrenchWordTokenizer.java
Patch:
@@ -64,9 +64,9 @@ public class FrenchWordTokenizer extends WordTokenizer {
   private static final Pattern SPACE_DIGITS0 = Pattern.compile("([\\d]{4}) ",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
   private static final Pattern SPACE_DIGITS = Pattern.compile("([\\d]) ([\\d][\\d][\\d])\\b",
-      Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CHARACTER_CLASS);
+      Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
   private static final Pattern SPACE_DIGITS2 = Pattern.compile("([\\d]) ([\\d][\\d][\\d]) ([\\d][\\d][\\d])\\b",
-      Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CHARACTER_CLASS);
+      Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
 
   private static final List<String> doNotSplit = Arrays.asList("mers-cov", "mcgraw-hill", "sars-cov-2", "sars-cov",
       "ph-metre", "ph-metres", "anti-ivg", "anti-uv", "anti-vih", "al-qaïda", "c'est-à-dire", "add-on", "add-ons",

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractUnitConversionRule.java
Patch:
@@ -80,7 +80,7 @@ public abstract class AbstractUnitConversionRule extends Rule {
   protected static final String NUMBER_REGEX = "(-?[0-9]{1,32}[0-9,.]{0,32})";
   protected static final String NUMBER_REGEX_WITH_BOUNDARY = "(-?\\b[0-9]{1,32}[0-9,.]{0,32})";
 
-  protected final Pattern numberRangePart = Pattern.compile(NUMBER_REGEX_WITH_BOUNDARY + "$");
+  protected final Pattern numberRangePart = Pattern.compile(NUMBER_REGEX_WITH_BOUNDARY + "$", Pattern.UNICODE_CHARACTER_CLASS);
   
   private static final double DELTA = 1e-2;
   private static final double ROUNDING_DELTA = 0.05;
@@ -196,7 +196,7 @@ protected String formatRounded(String s) {
    */
   protected void addUnit(String pattern, Unit base, String symbol, double factor, boolean metric) {
     Unit unit = base.multiply(factor);
-    unitPatterns.put(Pattern.compile(NUMBER_REGEX_WITH_BOUNDARY + "[\\s\u00A0]{0," + WHITESPACE_LIMIT + "}" + pattern + "\\b"), unit);
+    unitPatterns.put(Pattern.compile(NUMBER_REGEX_WITH_BOUNDARY + "[\\s\u00A0]{0," + WHITESPACE_LIMIT + "}" + pattern + "\\b", Pattern.UNICODE_CHARACTER_CLASS), unit);
     unitSymbols.putIfAbsent(unit, new ArrayList<>());
     unitSymbols.get(unit).add(symbol);
     if (metric && !metricUnits.contains(unit)) {

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -776,7 +776,8 @@ private void createRules(List<PatternToken> elemList,
         rule.setDistanceTokens(distanceTokens);
         rule.setXmlLineNumber(xmlLineNumber);
       } else if (regex.length() > 0) {
-        int flags = regexCaseSensitive ? 0 : Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE;
+//        int flags = regexCaseSensitive ? 0 : Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE;
+        int flags = regexCaseSensitive ? Pattern.UNICODE_CHARACTER_CLASS : Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CHARACTER_CLASS;
         String regexStr = regex.toString();
         if (regexMode == RegexpMode.SMART) {
           // Note: it's not that easy to add \b because the regex might look like '(foo)' or '\d' so we cannot just look at the last character

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/RegexAntiPatternFilter.java
Patch:
@@ -42,7 +42,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     }
     String[] antiPatterns = antiPatternStr.split("\\|");
     for (String antiPattern : antiPatterns) {
-      Pattern p = Pattern.compile(antiPattern);
+      Pattern p = Pattern.compile(antiPattern, Pattern.UNICODE_CHARACTER_CLASS);
       Matcher matcher = p.matcher(sentenceObj.getText());
       while (matcher.find()) {
         // partial overlap is enough to filter out a match:

File: languagetool-core/src/main/java/org/languagetool/tokenizers/SrxTools.java
Patch:
@@ -31,6 +31,7 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.regex.Pattern;
 
 /**
  * Tools for loading an SRX tokenizer file.
@@ -59,7 +60,8 @@ static SrxDocument createSrxDocument(String path) {
 
   static List<String> tokenize(String text, SrxDocument srxDocument, String code) {
     List<String> segments = new ArrayList<>();
-    TextIterator textIterator = new SrxTextIterator(srxDocument, code, text);
+    Map<String, Object> parserParameters = Map.of(SrxTextIterator.DEFAULT_PATTERN_FLAGS_PARAMETER, Pattern.UNICODE_CHARACTER_CLASS);
+    TextIterator textIterator = new SrxTextIterator(srxDocument, code, text, parserParameters);
     while (textIterator.hasNext()) {
       segments.add(textIterator.next());
     }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/PronomsFeblesHelper.java
Patch:
@@ -553,7 +553,7 @@ public static String convertPronounsForIntransitiveVerb(String s) {
   private static Pattern pronoun_wrong_apostrophation = Pattern.compile("([mts])'([^aeiouh].*)",
     Pattern.CASE_INSENSITIVE);
   private static Pattern pronoun_missing_apostrophation = Pattern.compile("(.*)\\be([stm]) (h?[aeiouh].*)",
-    Pattern.CASE_INSENSITIVE);
+    Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CHARACTER_CLASS);
   private static Pattern pronoun_wrong_hypphen = Pattern.compile("(.*)(-[stm])e-(h[oi])",
     Pattern.CASE_INSENSITIVE);
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -55,7 +55,7 @@
  */
 public class German extends Language implements AutoCloseable {
 
-  private static final Pattern TYPOGRAPHY_PATTERN = compile("\\b([a-zA-Z]\\.)([a-zA-Z]\\.)");
+  private static final Pattern TYPOGRAPHY_PATTERN = compile("\\b([a-zA-Z]\\.)([a-zA-Z]\\.)", Pattern.UNICODE_CHARACTER_CLASS);
   private static final Pattern AI_DE_GGEC_MISSING_PUNCT =
     compile("AI_DE_GGEC_MISSING_PUNCTUATION_\\d+_DASH_J(_|AE)HRIG|AI_DE_GGEC_REPLACEMENT_CONFUSION", Pattern.CASE_INSENSITIVE);
 

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -315,7 +315,7 @@ public boolean hasMinMatchesRules() {
     return true;
   }
   
-  private static final Pattern ES_CONTRACTIONS = Pattern.compile("\\b([Aa]|[Dd]e) e(l)\\b");
+  private static final Pattern ES_CONTRACTIONS = Pattern.compile("\\b([Aa]|[Dd]e) e(l)\\b", Pattern.UNICODE_CHARACTER_CLASS);
   
   @Override
   public String adaptSuggestion(String replacement) {

File: languagetool-language-modules/es/src/main/java/org/languagetool/tokenizers/es/SpanishWordTokenizer.java
Patch:
@@ -43,7 +43,7 @@ public class SpanishWordTokenizer extends WordTokenizer {
   // decimal comma between digits
   private static final Pattern DECIMAL_COMMA= Pattern.compile("([\\d]),([\\d])",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   // ordinals
-  private static final Pattern ORDINAL_POINT= Pattern.compile("\\b([\\d]+)\\.(º|ª|o|a|er|os|as)\\b",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
+  private static final Pattern ORDINAL_POINT= Pattern.compile("\\b([\\d]+)\\.(º|ª|o|a|er|os|as)\\b",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CHARACTER_CLASS);
   private static final Pattern PATTERN_1 = Pattern.compile("xxES_DECIMAL_POINTxx", Pattern.LITERAL);
   private static final Pattern PATTERN_2 = Pattern.compile("xxES_DECIMAL_COMMAxx", Pattern.LITERAL);
   private static final Pattern PATTERN_3 = Pattern.compile("xxES_ORDINAL_POINTxx", Pattern.LITERAL);

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -50,9 +50,9 @@
 public class French extends Language implements AutoCloseable {
 
   private static final String BEFORE_APOS = "([cjnmtsldCJNMTSLD]|qu|jusqu|lorsqu|puisqu|quoiqu|Qu|Jusqu|Lorsqu|Puisqu|Quoiqu|QU|JUSQU|LORSQU|PUISQU|QUOIQU)";
-  private static final Pattern BEFORE_APOS_PATTERN_1 = compile("(\\b" + BEFORE_APOS + ")'");
-  private static final Pattern BEFORE_APOS_PATTERN_2 = compile("(\\b" + BEFORE_APOS + ")’\"");
-  private static final Pattern BEFORE_APOS_PATTERN_3 = compile("(\\b" + BEFORE_APOS + ")’'");
+  private static final Pattern BEFORE_APOS_PATTERN_1 = compile("(\\b" + BEFORE_APOS + ")'", Pattern.UNICODE_CHARACTER_CLASS);
+  private static final Pattern BEFORE_APOS_PATTERN_2 = compile("(\\b" + BEFORE_APOS + ")’\"", Pattern.UNICODE_CHARACTER_CLASS);
+  private static final Pattern BEFORE_APOS_PATTERN_3 = compile("(\\b" + BEFORE_APOS + ")’'", Pattern.UNICODE_CHARACTER_CLASS);
 
   private static final Pattern TYPOGRAPHY_PATTERN_1 = compile("\u00a0;");
   private static final Pattern TYPOGRAPHY_PATTERN_2 = compile("\u00a0!");

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tokenizers/fr/FrenchWordTokenizer.java
Patch:
@@ -64,9 +64,9 @@ public class FrenchWordTokenizer extends WordTokenizer {
   private static final Pattern SPACE_DIGITS0 = Pattern.compile("([\\d]{4}) ",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
   private static final Pattern SPACE_DIGITS = Pattern.compile("([\\d]) ([\\d][\\d][\\d])\\b",
-      Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
+      Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CHARACTER_CLASS);
   private static final Pattern SPACE_DIGITS2 = Pattern.compile("([\\d]) ([\\d][\\d][\\d]) ([\\d][\\d][\\d])\\b",
-      Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
+      Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CHARACTER_CLASS);
 
   private static final List<String> doNotSplit = Arrays.asList("mers-cov", "mcgraw-hill", "sars-cov-2", "sars-cov",
       "ph-metre", "ph-metres", "anti-ivg", "anti-uv", "anti-vih", "al-qaïda", "c'est-à-dire", "add-on", "add-ons",

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SimpleReplaceBalearicRule.java
Patch:
@@ -52,7 +52,7 @@ public Map<String, List<String>> getWrongWords() {
   public SimpleReplaceBalearicRule(ResourceBundle messages, Language language) throws IOException {
     super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
-    super.setLocQualityIssueType(ITSIssueType.Misspelling);
+    super.setLocQualityIssueType(ITSIssueType.Grammar);
     this.setCheckLemmas(false);
     super.useSubRuleSpecificIds();
     //this.setIgnoreTaggedWords();

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SimpleReplaceDiacriticsIEC.java
Patch:
@@ -53,7 +53,7 @@ public Map<String, List<String>> getWrongWords() {
   public SimpleReplaceDiacriticsIEC(ResourceBundle messages, Language language) throws IOException {
     super(messages, language);
     super.setCategory(new Category(new CategoryId("DIACRITICS_IEC"), "Z) Accents diacrítics segons l'IEC"));
-    super.setLocQualityIssueType(ITSIssueType.Misspelling);
+    super.setLocQualityIssueType(ITSIssueType.Grammar);
     super.setDefaultOn();
     this.setCheckLemmas(false);
     super.useSubRuleSpecificIds();

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SimpleReplaceRule.java
Patch:
@@ -51,7 +51,7 @@ public Map<String, List<String>> getWrongWords() {
   public SimpleReplaceRule(ResourceBundle messages, Language language) throws IOException {
     super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
-    super.setLocQualityIssueType(ITSIssueType.Misspelling);
+    super.setLocQualityIssueType(ITSIssueType.Grammar);
     this.setIgnoreTaggedWords();
     this.setCheckLemmas(false);
     super.useSubRuleSpecificIds();

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SimpleReplaceVerbsRule.java
Patch:
@@ -64,7 +64,7 @@ public Map<String, List<String>> getWrongWords() {
   public SimpleReplaceVerbsRule(final ResourceBundle messages, Language language) {
     super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
-    super.setLocQualityIssueType(ITSIssueType.Misspelling);
+    super.setLocQualityIssueType(ITSIssueType.Grammar);
     super.setIgnoreTaggedWords();
     tagger = (CatalanTagger) language.getTagger();
     synth = (CatalanSynthesizer) language.getSynthesizer();

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractCompoundRule.java
Patch:
@@ -42,7 +42,6 @@ public abstract class AbstractCompoundRule extends Rule {
 
   static final int MAX_TERMS = 5;
 
-  private static final Pattern WHITESPACE_DASH = Pattern.compile(" - ", Pattern.LITERAL);
   private static final Pattern WHITESPACE = Pattern.compile("\\s+");
   private static final Pattern DIGIT = Pattern.compile("\\d+");
   private static final Pattern DASHES = Pattern.compile("--+");
@@ -240,7 +239,7 @@ private Map<String, AnalyzedTokenReadings> getStringToTokenMap(Queue<AnalyzedTok
 
   private String normalize(String inStr) {
     String str = inStr.trim();
-    str = WHITESPACE_DASH.matcher(str).replaceAll(" ");
+    str = str.replace(" - ", " ");
     str = str.replace('-', ' ');
     str = WHITESPACE.matcher(str).replaceAll(" ");
     return str;
@@ -259,7 +258,7 @@ private boolean isNotAllUppercase(String str) {
   }
 
   public String mergeCompound(String str, boolean uncapitalizeMidWords) {
-    String[] stringParts = str.replaceAll("-", " ").split(" ");
+    String[] stringParts = str.replace("-", " ").split(" ");
     StringBuilder sb = new StringBuilder();
     for (int k = 0; k < stringParts.length; k++) {  
       if (k == 0) {

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractFindSuggestionsFilter.java
Patch:
@@ -278,7 +278,7 @@ public int compare(String o1, String o2) {
   }
 
   protected String preProcessWrongWord (String word) {
-    return word = word.replaceAll(" ","");
+    return word.replace(" ","");
   }
 
 }

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractNumberInWordFilter.java
Patch:
@@ -45,7 +45,7 @@ protected AbstractNumberInWordFilter(Language language) {
   @Override
   public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments, int patternTokenPos, AnalyzedTokenReadings[] patternTokens, List<Integer> tokenPositions) throws IOException {
     String word = arguments.get("word");
-    String wordReplacingZeroO = word.replaceAll("0","o");
+    String wordReplacingZeroO = word.replace("0","o");
     String wordWithoutNumberCharacter = typoPattern.matcher(word).replaceAll("");
     List<String> replacements = new ArrayList<>();
     

File: languagetool-core/src/main/java/org/languagetool/rules/ConvertToSentenceCaseFilter.java
Patch:
@@ -78,7 +78,7 @@ private boolean isPunctuation(String s) {
   private String normalizedCase(AnalyzedTokenReadings atr) {
     String tokenLowercase = atr.getToken().toLowerCase();
     if (atr.hasTypographicApostrophe()) {
-      tokenLowercase = tokenLowercase.replaceAll("'", "’");
+      tokenLowercase = tokenLowercase.replace("'", "’");
     }
     if (tokenIsException(tokenLowercase)) {
       // exception: the lemma is "I"

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SymSpellRule.java
Patch:
@@ -22,6 +22,7 @@
 package org.languagetool.rules.spelling;
 
 import com.google.common.cache.*;
+import org.apache.commons.lang3.StringUtils;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.languagetool.*;
@@ -140,7 +141,7 @@ protected static SymSpell initDefaultDictSpeller(Language lang) {
     List<String> additional = Arrays.asList(base + "spelling.txt",
       base + "spelling_" + lang.getShortCodeWithCountryAndVariant() + ".txt");
     List<String> dict = Collections.singletonList(
-      base + lang.getShortCodeWithCountryAndVariant().replaceFirst("-", "_") + ".dic");
+      base + StringUtils.replaceOnce(lang.getShortCodeWithCountryAndVariant(), "-", "_") + ".dic");
 
     SuggestionStage stage = new SuggestionStage(100000);
     forEachLineInResources(additional, word -> {

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/CompoundAwareHunspellRule.java
Patch:
@@ -67,7 +67,7 @@ protected static List<InputStream> getStreams(List<String> paths) {
     List<InputStream> streams = new ArrayList<>();
     for (String path : paths) {
       // add separation between streams so that missing newlines at the end don't join the last & first line from two files
-      String separation = "# Start of file " + path.replaceAll("\n", "") + "\n";
+      String separation = "# Start of file " + path.replace("\n", "") + "\n";
       ByteArrayInputStream separationStream = new ByteArrayInputStream(
         Charset.defaultCharset().encode(separation).array());
       streams.add(separationStream);

File: languagetool-core/src/main/java/org/languagetool/synthesis/Soros.java
Patch:
@@ -74,7 +74,7 @@ public Soros(String source, String lang) {
             s2 = s2.replaceAll("^\\[[$](\\d\\d?|\\([^\\)]+\\))", "\\$(\uE00A\uE00A|\\$$1\uE00A") // add "|"
                 .replaceAll("\\[([^$\\[\\\\]*)[$](\\d\\d?|\\([^\\)]+\\))", "\\$(\uE00A$1\uE00A\\$$2\uE00A")
                 .replaceAll("\uE00A\\]$","|\uE00A)") // add "|" in terminating position
-                .replaceAll("\\]", ")")
+                .replace("]", ")")
                 .replaceAll("(\\$\\d|\\))\\|\\$", "$1||\\$"); // $()|$() -> $()||$()
             s2 = translate(s2, c, m, "");       // \uE000..\uE003-> \, ", ;, #
             s2 = translate(s2, m2.substring(0, c.length()), c, "");      // $, (, ), | -> \uE000..\uE003

File: languagetool-core/src/main/java/org/languagetool/tools/StringTools.java
Patch:
@@ -879,10 +879,10 @@ public static boolean isNotWordString(String input) {
   }
 
   /*
-   * Number of ocurreces of string t inside string s
+   * Number of occurrences of string t inside string s
    */
   public static int numberOf(String s, String t) {
-    return s.length() - s.replaceAll(t, "").length();
+    return s.length() - s.replace(t, "").length();
   }
 
   public static String convertToTitleCaseIteratingChars(String text) {

File: languagetool-core/src/test/java/org/languagetool/rules/GRPCRuleTest.java
Patch:
@@ -53,7 +53,7 @@ public void setUp() throws Exception {
     rule = new GRPCRule(new Demo(), JLanguageTool.getMessageBundle(), config, true) {
       @Override
       protected String getMessage(MLServerProto.Match match, AnalyzedSentence sentence) {
-        return "Matched: " + match.toString().replaceAll("\n", " | ");
+        return "Matched: " + match.toString().replace("\n", " | ");
       }
 
       @Override

File: languagetool-dev/src/main/java/org/languagetool/dev/FalseFriendExporter.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.dev;
 
+import org.apache.commons.lang3.StringUtils;
 import org.languagetool.Language;
 import org.languagetool.Languages;
 import org.languagetool.rules.patterns.AbstractPatternRule;
@@ -44,8 +45,8 @@ private static void listRuleMessages(Language l1, Language l2) throws IOExceptio
     List<AbstractPatternRule> rules = ruleLoader.getRules(new File(filename), l2, l1);
     int i = 1;
     for (AbstractPatternRule rule : rules) {
-      System.out.println(i + ". " + rule.getMessage().
-              replaceFirst("Hinweis: ", "").replaceAll("<suggestion>", "'").replaceAll("</suggestion>", "'"));
+      System.out.println(i + ". " +
+        StringUtils.replaceOnce(rule.getMessage(), "Hinweis: ", "").replace("<suggestion>", "'").replace("</suggestion>", "'"));
       i++;
     }
   }

File: languagetool-dev/src/main/java/org/languagetool/dev/GermanOldSpellingFinder.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.dev;
 
+import org.apache.commons.lang3.StringUtils;
 import org.languagetool.AnalyzedToken;
 import org.languagetool.language.GermanyGerman;
 import org.languagetool.synthesis.Synthesizer;
@@ -49,7 +50,7 @@ public static void main(String[] args) throws IOException {
       String[] formsAr = synth.synthesize(new AnalyzedToken(word, "FAKE", word), ".*", true);
       List<String> forms = Arrays.asList(formsAr);
       for (String form : forms) {
-        if (form.matches(".*oß") && !forms.contains(form.replaceFirst("ß", "ss"))) {
+        if (form.matches(".*oß") && !forms.contains(StringUtils.replaceOnce(form, "ß", "ss"))) {
           System.out.println("No 'ss' form found: " + form);
         }
       }

File: languagetool-dev/src/main/java/org/languagetool/dev/NoSuggestionRuleList.java
Patch:
@@ -80,7 +80,7 @@ public static void main(String[] args) throws IOException {
           //System.err.println("Skipping " + rule.getId() + " (no example)");
           continue;
         }
-        String incorrectExample = incorrectExamples.get(0).getExample().replaceAll("<marker>", "").replaceAll("</marker>", "");
+        String incorrectExample = incorrectExamples.get(0).getExample().replace("<marker>", "").replace("</marker>", "");
         lt.enableRule(rule.getId());
         List<RuleMatch> matches = lt.check(incorrectExample);
         for (RuleMatch match : matches) {

File: languagetool-dev/src/main/java/org/languagetool/dev/bigdata/AutomaticConfusionRuleEvaluatorFilter.java
Patch:
@@ -69,7 +69,7 @@ public static void main(String[] args) throws IOException {
       if (!line.startsWith("=>")) {
         continue;
       }
-      String cleanLine = line.replaceFirst("=> ", "").replaceFirst("; \\d.*", "");
+      String cleanLine = StringUtils.replaceOnce(line, "=> ", "").replaceFirst("; \\d.*", "");
       String[] parts;
       boolean bothDirections;
       if (cleanLine.contains("->")) {
@@ -81,7 +81,7 @@ public static void main(String[] args) throws IOException {
       }
       String key = parts[0] + ";" + parts[1];
       Pattern data = Pattern.compile("^(.+?)(?:;| ->) (.+?);.*p=(\\d\\.\\d+), r=(\\d\\.\\d+), f0.5=\\d\\.\\d+, (\\d+)\\+(\\d+),.*");
-      Matcher m = data.matcher(line.replaceFirst("=> ", ""));
+      Matcher m = data.matcher(StringUtils.replaceOnce(line, "=> ", ""));
       m.find();
       String word1 = m.group(1);
       String word2 = m.group(2);

File: languagetool-dev/src/main/java/org/languagetool/dev/eval/TatoebaEvaluator.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.dev.eval;
 
+import org.apache.commons.lang3.StringUtils;
 import org.languagetool.Language;
 import org.languagetool.Languages;
 import org.languagetool.dev.dumpcheck.SentenceSourceChecker;
@@ -41,7 +42,7 @@ private void run() throws IOException {
       //if (!lang.getShortCode().equals("sk")) {
       //  continue;
       //}
-      File file = new File(template.replaceFirst("LANG", lang.getShortCode()));
+      File file = new File(StringUtils.replaceOnce(template, "LANG", lang.getShortCode()));
       if (!file.exists() || file.length() == 0) {
         System.err.println("File not found or empty, skipping: " + file);
         continue;

File: languagetool-dev/src/main/java/org/languagetool/dev/messagechecker/LTMessageChecker.java
Patch:
@@ -106,7 +106,7 @@ private void run(Language lang)
       }
       if (!message.isEmpty()) {
         message = lang.toAdvancedTypography(message);
-        message = message.replaceAll("<suggestion>", lang.getOpeningDoubleQuote()).replaceAll("</suggestion>",
+        message = message.replace("<suggestion>", lang.getOpeningDoubleQuote()).replace("</suggestion>",
             lang.getClosingDoubleQuote());
         message = message.replaceAll("<[^>]+>", "");
       }

File: languagetool-dev/src/test/java/org/languagetool/dev/eval/LangIdentExamples.java
Patch:
@@ -191,7 +191,7 @@ private void eval(String input, String expectedLang) throws IOException {
       System.out.print("BAD  ");
     }
     System.out.printf(Locale.ENGLISH, "%s (expected: %s) with confidence %.2f for: %s\n", bestLang, expectedLang, max,
-            input.replaceAll("\n", "\\\\n"));
+            input.replace("\n", "\\\\n"));
   }
 
   private void printSummary() {

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Tools.java
Patch:
@@ -153,7 +153,7 @@ public static String shortenComment(String comment) {
    * @return String UI element string without mnemonics.
    */
   public static String getLabel(String label) {
-    return label.replaceAll("&([^&])", "$1").replaceAll("&&", "&");
+    return label.replaceAll("&([^&])", "$1").replace("&&", "&");
   }
 
   /**
@@ -278,7 +278,7 @@ static void showRuleInfoDialog(Component parent, String title, String message, R
     textPane.setBackground(new Color(0, 0, 0, 0));
     Tools.addHyperlinkListener(textPane);
     textPane.setSize(dialogWidth, Short.MAX_VALUE);
-    String messageWithBold = message.replaceAll("<suggestion>", "<b>").replaceAll("</suggestion>", "</b>");
+    String messageWithBold = message.replace("<suggestion>", "<b>").replace("</suggestion>", "</b>");
     String exampleSentences = getExampleSentences(rule, messages);
     String url = "http://community.languagetool.org/rule/show/" + encodeUrl(rule)
             + "?lang=" + lang + "&amp;ref=standalone-gui";

File: languagetool-http-client/src/main/java/org/languagetool/remote/CorrectionLoopFinderApi.java
Patch:
@@ -128,8 +128,8 @@ public static void main(String[] args) throws IOException {
     }
     // defaultColor="\u001B[0m"
     // highlightColor="\u001B[97m"
-    cfg.ansiDefault = prop.getProperty("defaultColor", "").trim().replaceAll("\"", "");
-    cfg.ansiHighlight = prop.getProperty("highlightColor", "").trim().replaceAll("\"", "");
+    cfg.ansiDefault = prop.getProperty("defaultColor", "").trim().replace("\"", "");
+    cfg.ansiHighlight = prop.getProperty("highlightColor", "").trim().replace("\"", "");
     cfg.prepareConfiguration();
     run(cfg);
   }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/CatalanNumberSpellerFilter.java
Patch:
@@ -19,12 +19,12 @@ public class CatalanNumberSpellerFilter extends RuleFilter {
   public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments, int patternTokenPos,
                                    AnalyzedTokenReadings[] patternTokens, List<Integer> tokenPositions) {
 
-    String strToSpell = getRequired("number_to_spell", arguments).replaceAll("\\.", "");
+    String strToSpell = getRequired("number_to_spell", arguments).replace(".", "");
     if (getRequired("gender", arguments).contentEquals("feminine")) {
       strToSpell = "feminine " + strToSpell;
     }
     String spelledNumber = synth.getSpelledNumber(strToSpell);
-    if (!spelledNumber.isEmpty() && spelledNumber.replaceAll("-i-", " ").replaceAll("-", " ").split(" ").length < 4) {
+    if (!spelledNumber.isEmpty() && spelledNumber.replace("-i-", " ").replace("-", " ").split(" ").length < 4) {
       String message = match.getMessage();
       RuleMatch ruleMatch = new RuleMatch(match.getRule(), match.getSentence(), match.getFromPos(), match.getToPos(),
           message, match.getShortMessage());

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/FindSuggestionsFilter.java
Patch:
@@ -67,7 +67,7 @@ protected boolean isSuggestionException(AnalyzedTokenReadings analyzedSuggestion
 
   @Override
   protected String preProcessWrongWord (String word) {
-    word = word.replaceAll(" ","");
+    word = word.replace(" ","");
     word = ELA_GEMINADA.matcher(word).replaceAll("$1·$2");
     return word;
   }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tagging/ca/CatalanTagger.java
Patch:
@@ -72,7 +72,7 @@ public List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens) {
       if (originalWord.length() > 1) {
         if (originalWord.contains("’")) {
           containsTypographicApostrophe = true;
-          originalWord = originalWord.replaceAll("’", "'");
+          originalWord = originalWord.replace("’", "'");
         }
       }
       String normalizedWord = StringTools.normalizeNFC(originalWord);
@@ -210,7 +210,7 @@ protected List<AnalyzedToken> additionalTags(String word, IStemmer stemmer) {
     // U+013F LATIN CAPITAL LETTER L WITH MIDDLE DOT
     // U+0140 LATIN SMALL LETTER L WITH MIDDLE DOT
     if (word.contains("\u0140") || word.contains("\u013f")) {
-      final String possibleWord = lowerWord.replaceAll("\u0140", "l·");
+      final String possibleWord = lowerWord.replace("\u0140", "l·");
       return asAnalyzedTokenList(word, dictLookup.lookup(possibleWord));
     }
     

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/SwissGerman.java
Patch:
@@ -117,7 +117,7 @@ public List<RuleMatch> filterRuleMatches(List<RuleMatch> ruleMatches, AnnotatedT
       List<SuggestedReplacement> replacements = rm.getSuggestedReplacementObjects();
       List<SuggestedReplacement> newReplacements = new ArrayList<>();
       for (SuggestedReplacement s : replacements) {
-        String newReplStr = s.getReplacement().replaceAll("ß", "ss");
+        String newReplStr = s.getReplacement().replace("ß", "ss");
         SuggestedReplacement newRepl = new SuggestedReplacement(s);
         newRepl.setReplacement(newReplStr);
         newReplacements.add(newRepl);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -66,7 +66,6 @@ public class CaseRule extends Rule {
   private static final String LOWERCASE_MESSAGE = "Falls es sich um ein substantiviertes Verb handelt, wird es großgeschrieben.";
   private static final String COLON_MESSAGE = "Folgt dem Doppelpunkt weder ein Substantiv noch eine wörtliche Rede oder ein vollständiger Hauptsatz, schreibt man klein weiter.";
   private static final Pattern VERHALTEN = Pattern.compile(".+verhalten");
-  private static final Pattern SOFT_HYPHEN = Pattern.compile("\\u00AD");
   private static final Pattern IRGEND_ETC = Pattern.compile("irgendwelche|irgendwas|irgendein|weniger?|einiger?|mehr|aufs");
   private static final Pattern VER_MOD_AUX = Pattern.compile("VER:(MOD|AUX):[1-3]:.*");
 
@@ -978,7 +977,7 @@ private boolean hasNounReading(AnalyzedTokenReadings readings) {
         return true;
       }
       // "Die Schöne Tür": "Schöne" also has a noun reading but like "SUB:AKK:SIN:FEM:ADJ", ignore that:
-      AnalyzedTokenReadings allReadings = lookup(SOFT_HYPHEN.matcher(readings.getToken()).replaceAll(""));  // unification in disambiguation.xml removes reading, so look up again, removing soft hyphens
+      AnalyzedTokenReadings allReadings = lookup(readings.getToken().replace("\u00AD", ""));  // unification in disambiguation.xml removes reading, so look up again, removing soft hyphens
       if (allReadings != null) {
         for (AnalyzedToken reading : allReadings) {
           String posTag = reading.getPOSTag();

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/LineExpander.java
Patch:
@@ -36,8 +36,6 @@
  */
 public class LineExpander implements org.languagetool.rules.LineExpander {
 
-  private static final Pattern ESCAPE_REGEX = Pattern.compile("\\\\");
-
   private static final LoadingCache<String, String[]> verbFormCache = CacheBuilder.newBuilder()
     .expireAfterAccess(10, TimeUnit.MINUTES)
     .build(new CacheLoader<String, String[]>() {
@@ -166,6 +164,6 @@ private static String cleanTagsAndEscapeChars(String s) {
     if (idx != -1) {
       s = s.substring(0, idx);
     }
-    return ESCAPE_REGEX.matcher(s).replaceAll("").trim();
+    return s.replace("\\", "").trim();
   }
 }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/OldSpellingRule.java
Patch:
@@ -20,6 +20,7 @@
 
 import com.google.common.base.Suppliers;
 import com.hankcs.algorithm.AhoCorasickDoubleArrayTrie;
+import org.apache.commons.lang3.StringUtils;
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.Language;
 import org.languagetool.rules.*;
@@ -114,7 +115,7 @@ private void addMatch(AnalyzedSentence sentence, AhoCorasickDoubleArrayTrie.Hit<
     String[] suggestions = hit.value.split("\\|");
     match.setSuggestedReplacements(Arrays.asList(suggestions));
     String covered = sentence.getText().substring(hit.begin, hit.end);
-    if (suggestions.length > 0 && suggestions[0].replaceFirst("ss", "ß").equals(covered)) {
+    if (suggestions.length > 0 && StringUtils.replaceOnce(suggestions[0], "ss", "ß").equals(covered)) {
       if (language.getShortCodeWithCountryAndVariant().equals("de-AT") && covered.toLowerCase().contains("geschoß")) {
         // special case for Austria: "Geschoß" is correct in both old and new spelling in de-AT (because of the pronunciation)
         return;

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/SpellingData.java
Patch:
@@ -65,12 +65,12 @@ private static Map<String, String> getCoherencyMap(String filePath, boolean sent
       } else {
         coherencyMap.put(oldSpelling, newSpelling);
       }
-      if (oldSpelling.contains("ß") && oldSpelling.replaceAll("ß", "ss").equals(newSpelling)) {
+      if (oldSpelling.contains("ß") && oldSpelling.replace("ß", "ss").equals(newSpelling)) {
         try {
           String[] forms = GermanSynthesizer.INSTANCE.synthesizeForPosTags(oldSpelling, s -> true);
           for (String form : forms) {
             if (!form.contains("ss")) {  // avoid e.g. "Schlüsse" as form of "Schluß", as that's the new spelling
-              coherencyMap.put(form, form.replaceAll("ß", "ss"));
+              coherencyMap.put(form, form.replace("ß", "ss"));
             }
           }
         } catch (IOException e) {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/SwissCompoundRule.java
Patch:
@@ -61,7 +61,7 @@ static class SwissExpander implements LineExpander {
     @Override
     public List<String> expandLine(String line) {
       if (line.contains("ß")) {
-        return Arrays.asList(line, line.replaceAll("ß", "ss"));  // accept both, assuming Swiss users sometimes deal with GermanyGerman text
+        return Arrays.asList(line, line.replace("ß", "ss"));  // accept both, assuming Swiss users sometimes deal with GermanyGerman text
       } else {
         return Arrays.asList(line);
       }

File: languagetool-language-modules/de/src/main/java/org/languagetool/tagging/de/GermanTagger.java
Patch:
@@ -179,7 +179,7 @@ private static ExpansionInfos initExpansionInfos() {
 
   private static List<String> toPA2(List<String> tags) {
     return tags.stream().
-      map(k -> k.replaceAll("ADJ:", "PA2:")).
+      map(k -> k.replace("ADJ:", "PA2:")).
       map(k -> k + ":VER").
       collect(Collectors.toList());
   }

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/translation/BeoLingusTranslator.java
Patch:
@@ -280,7 +280,7 @@ public String cleanTranslationForReplace(String s, String prevWord) {
       .replace("sb.", "")
       .replaceAll("/[A-Z]+/", "")    // e.g. "heavy goods vehicle /HGV/"
       .replaceAll(" /[A-Z][a-z]+\\.?/", "")    // e.g. "Tuesday /Tue/", "station /Sta./"
-      .replaceAll("<> ", "")  // "to fathom out <> sth."
+      .replace("<> ", "")  // "to fathom out <> sth."
       .replaceAll("<(.*)>", "")  // "decease [adm.]; demise [poet.] <death>"
       .replaceAll("\\s+", " ")
       .trim();

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/translation/Inflector.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.rules.en.translation;
 
+import org.apache.commons.lang3.StringUtils;
 import org.jetbrains.annotations.NotNull;
 import org.languagetool.AnalyzedToken;
 import org.languagetool.Languages;
@@ -42,7 +43,7 @@ class Inflector {
    * @param enToken base form of English token (from BeoLingus)
    */
   List<String> inflect(String enToken, String dePosTag) {
-    List<String> parts = Arrays.asList(enToken.replaceFirst("to ", "").split(" "));
+    List<String> parts = Arrays.asList(StringUtils.replaceOnce(enToken, "to ", "").split(" "));
     List<String> lastPartForms = inflectSingleWord(parts.get(parts.size() - 1), dePosTag);
     String startParts = parts.size() > 1 ? String.join(" ", parts.subList(0, parts.size()-1)) : "";
     ArrayList<String> result = new ArrayList<>();

File: languagetool-language-modules/en/src/test/java/org/languagetool/tokenizers/en/TokenizeMultiwordsTest.java
Patch:
@@ -66,7 +66,7 @@ public void testTokenize() {
         throw new RuntimeException(e);
       }
       for (String word : wordList) {
-        if (!multiwords.contains(word.replaceAll("’", "'"))) {
+        if (!multiwords.contains(word.replace("’", "'"))) {
           List<String> tokens = wordTokenizer.tokenize(word);
           List<String> tokensBySpace = Arrays.asList(word.split(" "));
           if (tokens.size() > 1 && !tokens.stream().filter(k -> !k.equals(" ")).collect(Collectors.toList()).equals(tokensBySpace)) {

File: languagetool-language-modules/es/src/main/java/org/languagetool/tagging/es/SpanishTagger.java
Patch:
@@ -83,7 +83,7 @@ public List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens) {
         || nextWord.equalsIgnoreCase("s")) {
         if (word.contains("’")) {
           containsTypographicApostrophe = true;
-          word = word.replaceAll("’", "'");
+          word = word.replace("’", "'");
         }
       }
       final List<AnalyzedToken> l = new ArrayList<>();

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tagging/fr/FrenchTagger.java
Patch:
@@ -90,7 +90,7 @@ public List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens) {
       }
       List<AnalyzedToken> l = tagWord(word, word);
       if (l.isEmpty() && word.toLowerCase().contains("oe")) {
-        l = tagWord(word.replaceAll("oe", "œ").replaceAll("OE", "Œ"), word);
+        l = tagWord(word.replace("oe", "œ").replace("OE", "Œ"), word);
       }
       // emoji
       if (l.isEmpty() && StringTools.isEmoji(word)) {

File: languagetool-language-modules/pl/src/main/java/org/languagetool/synthesis/pl/PolishSynthesizer.java
Patch:
@@ -112,7 +112,7 @@ public final String[] synthesize(AnalyzedToken token, String pos, boolean posTag
       }
 
       if (isNegated) {
-        posTag = posTag.replaceAll(NEGATION_TAG, POTENTIAL_NEGATION_TAG + "?");
+        posTag = posTag.replace(NEGATION_TAG, POTENTIAL_NEGATION_TAG + "?");
       }
 
       try {

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PostReformPortugueseCompoundRule.java
Patch:
@@ -37,7 +37,6 @@
  */
 public class PostReformPortugueseCompoundRule extends AbstractCompoundRule {
 
-  private static final Pattern HYPHEN = compile("-");
   private static final Pattern VOWEL = compile("(?i).+[aeiou]$");
   private static final Pattern RS = compile("(?i)^[rs].+");
 
@@ -88,7 +87,7 @@ public CompoundRuleData getCompoundRuleData() {
   // ultra + som  => ultrassom (with <s> turned into <ss> to keep the sound).
   @Override
   public String mergeCompound(String str, boolean uncapitalizeMidWords) {
-    String[] stringParts = HYPHEN.matcher(str).replaceAll(" ").split(" ");
+    String[] stringParts = str.replace("-", " ").split(" ");
     StringBuilder sb = new StringBuilder();
     for (int k = 0; k < stringParts.length; k++) {
       if (k == 0) {

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/MixedAlphabetsRule.java
Patch:
@@ -171,7 +171,7 @@ else if(LATIN_NUMBER_WITH_CYRILLICS.matcher(tokenString).matches()) {
 
       if( tokenString.indexOf('\u0306') > 0 || tokenString.indexOf('\u0308') > 0 ) {
         if( tokenString.matches(".*(и\u0306|і\u0308).*") ) {
-          String fix = tokenString.replaceAll("и\u0306", "й").replaceAll("і\u0308", "ї");
+          String fix = tokenString.replace("и\u0306", "й").replace("і\u0308", "ї");
 
           String msg = "Вжито комбіновані символи замість українських літер";
           RuleMatch potentialRuleMatch = createRuleMatch(tokenReadings, Arrays.asList(fix), msg, sentence);

File: languagetool-language-modules/uk/src/main/java/org/languagetool/tokenizers/uk/UkrainianWordTokenizer.java
Patch:
@@ -290,11 +290,11 @@ private String adjustTextForTokenizing(String text, HashMap<String, String> urls
     }
 
     if( text.indexOf("с/г") != -1 ) {
-      text = text.replaceAll("с/г", "с" +NON_BREAKING_SLASH_SUBST + "г");
+      text = text.replace("с/г", "с" +NON_BREAKING_SLASH_SUBST + "г");
     }
 
     if( text.indexOf("Л/ДНР") != -1 ) {
-      text = text.replaceAll("Л/ДНР", "Л" +NON_BREAKING_SLASH_SUBST + "ДНР");
+      text = text.replace("Л/ДНР", "Л" +NON_BREAKING_SLASH_SUBST + "ДНР");
     }
 
     if( text.indexOf("р.") != -1 ) {

File: languagetool-server/src/main/java/org/languagetool/server/DBInvite.java
Patch:
@@ -36,8 +36,8 @@ public DBInvite(UserInfoEntry newUser, DBGroup group) {
   public DBInvite(long userId, DBGroup group) {
     user_id = userId;
     group_id = group.id;
-    String randomToken1 = UUID.randomUUID().toString().replaceAll("-", "").substring(0, 32);
-    String randomToken2 = UUID.randomUUID().toString().replaceAll("-", "").substring(0, 32);
+    String randomToken1 = UUID.randomUUID().toString().replace("-", "").substring(0, 32);
+    String randomToken2 = UUID.randomUUID().toString().replace("-", "").substring(0, 32);
     token = randomToken1 + randomToken2;
   }
 }

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -474,10 +474,8 @@ private Map<String, String> parseQuery(String query, HttpExchange httpExchange)
     return parameters;
   }
 
-  private static final Pattern QUERY_PARAM_SPLIT = Pattern.compile("&");
-
   private Map<String, String> getParameterMap(String query, HttpExchange httpExchange) throws UnsupportedEncodingException {
-    String[] pairs = QUERY_PARAM_SPLIT.split(query);
+    String[] pairs = StringUtils.split(query, '&');
     Map<String, String> parameters = new HashMap<>();
     for (String pair : pairs) {
       int delimPos = pair.indexOf('=');

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerDefaultLanguageIdentifierTest.java
Patch:
@@ -74,7 +74,7 @@ void runTestsV2() throws IOException {
     String detectedLangShort = Languages.getLanguageForShortCode(detectedLang).getShortCode();
     boolean correctDetection = detectedLangShort.equals(language.getShortCode());
     if (!correctDetection) {
-      System.out.printf("Expected %s / Detected %s -> %s%n", language.getShortCode(), detectedLangShort, textSubstring.replaceAll("\n", ""));
+      System.out.printf("Expected %s / Detected %s -> %s%n", language.getShortCode(), detectedLangShort, textSubstring.replace("\n", ""));
       synchronized (this) {
         numDetectionFailures.incrementAndGet();
       }

File: languagetool-standalone/src/main/java/org/languagetool/gui/ResultAreaHelper.java
Patch:
@@ -218,8 +218,8 @@ private void getRuleMatchHtml(List<RuleMatch> ruleMatches, String text) {
       String output = org.languagetool.tools.Tools.i18n(messages, "result1", i + 1, match.getLine() + 1, match.getColumn());
       sb.append(output);
       String msg = match.getMessage()
-          .replaceAll("<suggestion>", "<b>").replaceAll("</suggestion>", "</b>")
-          .replaceAll("<old>", "<b>").replaceAll("</old>", "</b>");
+          .replace("<suggestion>", "<b>").replace("</suggestion>", "</b>")
+          .replace("<old>", "<b>").replace("</old>", "</b>");
       sb.append("<b>").append(messages.getString("errorMessage")).append("</b> ");
       sb.append(msg);
       RuleLink ruleLink = RuleLink.buildDeactivationLink(match.getRule());

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/dumpcheck/StdoutHandler.java
Patch:
@@ -72,8 +72,8 @@ protected void handleResult(Sentence sentence, List<RuleMatch> ruleMatches, Lang
         }
         System.out.println(output);
         String msg = match.getMessage();
-        msg = msg.replaceAll("<suggestion>", "'");
-        msg = msg.replaceAll("</suggestion>", "'");
+        msg = msg.replace("<suggestion>", "'");
+        msg = msg.replace("</suggestion>", "'");
         System.out.println("Message: " + msg);
         List<String> replacements = match.getSuggestedReplacements();
         if (!replacements.isEmpty()) {

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/index/Indexer.java
Patch:
@@ -153,7 +153,7 @@ public void indexText(BufferedReader reader) throws IOException {
             if (++addCount % 1000 == 0) {
               System.out.println("(1) Adding item " + addCount);
             }
-            add(sentence.replaceAll(" \n"," "), null, null, -1);
+            add(sentence.replace(" \n"," "), null, null, -1);
           }
         }
         if (paragraph.length() + line.length() >= Integer.MAX_VALUE) {

File: languagetool-core/src/main/java/org/languagetool/rules/LongParagraphRule.java
Patch:
@@ -46,6 +46,7 @@ public LongParagraphRule(ResourceBundle messages, Language lang, UserConfig user
     super.setCategory(Categories.STYLE.getCategory(messages));
     this.lang = lang;
     setDefaultOff();
+    setOfficeDefaultOn();  // Default for LO/OO is always On
     if (defaultWords > 0) {
       this.maxWords = defaultWords;
     }

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractStyleRepeatedWordRule.java
Patch:
@@ -56,6 +56,7 @@ public AbstractStyleRepeatedWordRule(ResourceBundle messages, Language lang, Use
     super.setCategory(Categories.STYLE.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Style);
     setDefaultOff();
+    setOfficeDefaultOn();  // Default for LO/OO is always On
     this.lang = lang;
     if (userConfig != null) {
       linguServices = userConfig.getLinguServices();

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -460,7 +460,6 @@ public LanguageMaintainedState getMaintainedState() {
     id2prio.put("AUSTRIAN_GERMAN_SPELLER_RULE", -3);  // assume most other rules are more specific and helpful than the spelling rule
     id2prio.put("SWISS_GERMAN_SPELLER_RULE", -3);  // assume most other rules are more specific and helpful than the spelling rule
     id2prio.put("DE_VERBAGREEMENT", -4); // prefer more specific rules (e.g DU_WUENSCHT) and speller
-    id2prio.put("DE_SIMPLE_REPLACE_STORIES", -4); // prefer speller (e.g. ignore Kitchen Stories)
     id2prio.put("PUNKT_ENDE_DIREKTE_REDE", -4); // prefer speller
     id2prio.put("LEERZEICHEN_NACH_VOR_ANFUEHRUNGSZEICHEN", -4); // prefer speller
     id2prio.put("ZEICHENSETZUNG_DIREKTE_REDE", -4); // prefer speller

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanUnpairedQuotesRule.java
Patch:
@@ -29,8 +29,8 @@
 
 public class GermanUnpairedQuotesRule extends GenericUnpairedQuotesRule {
 
-  private static final List<String> DE_START_SYMBOLS = Arrays.asList("„", "»", "«", "\"", "'", "›", "‹");
-  private static final List<String> DE_END_SYMBOLS   = Arrays.asList("“", "«", "»", "\"", "'", "‹", "›");
+  private static final List<String> DE_START_SYMBOLS = Arrays.asList("„", "»", "«", "\"", "'", "‚", "›", "‹");
+  private static final List<String> DE_END_SYMBOLS   = Arrays.asList("“", "«", "»", "\"", "'", "‘", "‹", "›");
 
   public GermanUnpairedQuotesRule(ResourceBundle messages, Language language) {
     super(messages, DE_START_SYMBOLS, DE_END_SYMBOLS);

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/SimpleReplaceRule.java
Patch:
@@ -25,6 +25,7 @@
 import java.util.ResourceBundle;
 import java.util.Set;
 import java.util.regex.Pattern;
+import java.util.stream.Collectors;
 
 import org.apache.commons.lang3.StringUtils;
 import org.languagetool.AnalyzedSentence;
@@ -194,7 +195,7 @@ private List<String> findInDeriv(String w) {
           .findAny()
           .orElse(t)
         )
-        .toList();
+        .collect(Collectors.toList());
 
     return suggestions;
   }

File: languagetool-language-modules/uk/src/main/java/org/languagetool/tokenizers/uk/UkrainianWordTokenizer.java
Patch:
@@ -155,7 +155,7 @@ public class UkrainianWordTokenizer implements Tokenizer {
   private static final Pattern ABBR_DOT_NAR_PATTERN_2 = Pattern.compile("\\b(нар)\\.([\\h\\v]+[0-9а-яіїєґ])");
 
   // скорочення що можуть бути в кінці речення
-  private static final Pattern ABBR_DOT_ENDING_PATTERN = Pattern.compile("([^а-яіїєґА-ЯІЇЄҐ'\u0301-]((та|й|і) (інш?|под)|атм|відс|гр|коп|обл|р|рр|РР|руб|ст|стст|стол|стор|чол|шт))\\.(?!\uE120)");
+  private static final Pattern ABBR_DOT_ENDING_PATTERN = Pattern.compile("([^а-яіїєґА-ЯІЇЄҐ'\u0301-]((та|й|і) (інш?|под)|атм|відс|гр|коп|дол|обл|р|рр|РР|руб|ст|стст|стол|стор|чол|шт))\\.(?!\uE120)");
   private static final Pattern ABBR_DOT_I_T_P_PATTERN = Pattern.compile("([ій][\\h\\v]+т\\.)([\\h\\v]*(д|п|ін)\\.)");
   private static final Pattern ABBR_DOT_I_T_CH_PATTERN = Pattern.compile("([ву][\\h\\v]+т\\.)([\\h\\v]*ч\\.)");
   private static final Pattern ABBR_DOT_T_ZV_PATTERN = Pattern.compile("([\\h\\v\\(]+т\\.)([\\h\\v]*зв\\.)");

File: languagetool-language-modules/uk/src/main/java/org/languagetool/tagging/disambiguation/uk/UkrainianHybridDisambiguator.java
Patch:
@@ -489,7 +489,7 @@ private void retagUnknownInitials(AnalyzedSentence input) {
 //          }
         }
 
-        AnalyzedToken newToken = new AnalyzedToken(tokens[i].getToken(), "noninf:abbr", null);
+        AnalyzedToken newToken = new AnalyzedToken(tokens[i].getToken(), "noninfl:abbr", null);
         tokens[i].addReading(newToken, "dis_unknown_initials");
       }
     }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -77,6 +77,8 @@ public void testGetMessage() {
   @Test
   public void testIgnoreMisspelledWord() throws IOException {
     GermanSpellerRule rule = new GermanSpellerRule(TestTools.getMessages("de"), GERMAN_DE);
+    assertTrue(rule.ignorePotentiallyMisspelledWord("Erwachsenenintensivkurse"));
+    assertTrue(rule.ignorePotentiallyMisspelledWord("Horizontalbohrtechnik"));
     assertFalse(rule.ignorePotentiallyMisspelledWord("Bogenschiessen"));
     assertFalse(rule.ignorePotentiallyMisspelledWord("Badefenster"));
     assertFalse(rule.ignorePotentiallyMisspelledWord("Badspaß"));

File: languagetool-core/src/main/java/org/languagetool/rules/WordRepeatBeginningRule.java
Patch:
@@ -103,7 +103,7 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
               shortMsg = "";
             }
             if (!shortMsg.isEmpty()) {
-              String msg = messages.getString("desc_repetition_beginning_thesaurus");
+              String msg = shortMsg + " " + messages.getString("desc_repetition_beginning_thesaurus");
               int startPos = analyzedToken.getStartPos();
               int endPos = startPos + token.length();
               RuleMatch ruleMatch = new RuleMatch(this, sentence, pos + startPos, pos + endPos, msg, shortMsg);

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -258,7 +258,7 @@ void checkText(AnnotatedText aText, HttpExchange httpExchange, Map<String, Strin
     if (Premium.isPremiumStatusCheck(aText)) {
       Language premiumStatusCheckLang = Languages.getLanguageForShortCode("en-US");
       List<RuleMatch> matches = new ArrayList<>();
-      if (limits.hasPremium()) {
+      if (limits.hasPremium() || config.isPremiumAlways()) {
         matches.add(new RuleMatch(new Rule() {
           @Override
           public String getId() {

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -746,7 +746,7 @@ public List<RuleMatch> filterRuleMatches(List<RuleMatch> ruleMatches, AnnotatedT
       RuleMatch newMatch = new RuleMatch(rm, newReplacements);
       if (newMatch.getSpecificRuleId().startsWith("EN_SIMPLE_REPLACE") &&
         (newMatch.getSpecificRuleId().endsWith("GRAMME") || newMatch.getSpecificRuleId().endsWith("GRAMMES"))) {
-        newMatch.getRule().setLocQualityIssueType(ITSIssueType.Style);
+        newMatch.getRule().setLocQualityIssueType(ITSIssueType.LocaleViolation);
       }
       newRuleMatches.add(newMatch);
     }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -140,7 +140,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
   private static final Pattern WECHSELINFIX = compile("(arbeit|dienstag|donnerstag|freitag|montag|mittwoch|link|recht|samstag|sonntag|verband)s?");
   private static final Pattern CONFUSED_PREFIXES = compile("bade?|wi(e)?der");
   private static final Pattern NEEDS_TO_BE_PLURAL = compile("absolvent(in)?|adressat|aktie|antenne|apache|arbeitnehmer(in)?|ärztin|assistent(in)?|astronom(in)?|asylant(in)?|autor(in)?|azteke|bakterie|ballade|bauer|billion|bisexuelle|blume|bonze|börse|bot(e|in)|buche|bürg(e|in)|bürokrat(in)?|chrysantheme|dän(e|in)?|debatte|debitor(in)?|decke|diakon(in)?|diktator(in)?|direktor(in)?|doktorand(in)?|domäne|dozent(in)?|drohne|druid(e|in)?|düne|ehre|eibe|elefant|elektron|ellipse|emittent(in)?|elfe|elle|enge|erbse|eremit|erde|erste|esche|exot(e|in)?|expert(e|in)?|extremist(in)?|fabrikant(in)?|falke|fassade|farbe|fasan|favorit(in)?|felge|ferien|figur|fluor|frage|franz(ose|ösin)|frau|frisur|förde|galle|gatt(e|in)?|gerät|gepard|gezeit|gigant|gilde|göttin|griech(e|in)?|halt|heid(e|in)?|herde|historie|hölle|höhle|hose|hugenott(e|in)?|hund|hündin|immigrant(in)?|investor(in)?|irokes(e|in)|islamist(in)?|jesuit(in)?|jungfer|jungfrau|junggesell(e|in)|juror(in)?|kadett|kante|kaskade|kathode|katholik(in)?|katze|kette|kid|klasse|kirche|klaue|klient(in)?|klinge|knappe|koeffizient|kojote|komet|kommentator(in)?|komödie|kompliz(e|in)|konkurrent(in)?|konfirmand(in)?|konsonant|kontrahent(in)?|krake|kralle|kranke|krähe|kraut|krippe|kurd(e|in)|kuriosität|kurve|kusine|küste|laie|laterne|laute|legende|lehne|leise|lektor(in)?|leopard|lerche|leserin|lieferant(in)?|lippe|loge|lotse|länge|läuse|löwe|lücke|luke|made|mädel|maske|maßnahme|matriarchin|menge|mensch|metapher|methode|metropole|miene|miete|migrant(in)?|million|mitte|maus|moderator(in)?|monarch(in)?|mongol(e|in)|mormone|mücke|mühle|musikant(in)?|mysterium|nerv|niederlage|nixe|nonne|note|obdachlose|ode|organist|panne|papagei|parzelle|pastor(in)?|pate|patient|patriarch(in)?|petze|pfadfinderin|pfanne|pfaffe|pfau|pfeife|platte|polle|pomade|pomeranze|posse|praktikant(in)?|prinz(essin)?|prise|produzent(in)?|prominente|prophet(in)?|prototyp|prälat|psychopath(in)?|puppe|pädophile|pygmäe|rabe|radikale|rakete|rampe|ranke|rassist(in)?|rate|raupe|rendite|repressalie|rest|riese|rinde|rind|robbe|robe|romanist|rose|ross|route|nummer|runde|russ(e|in)?|röhre|rübe|salbe|schabe|schale|scheide|schelle|schenke|schere|sphäre|dicke|kröte|schauspielerin|schimpans(e|in)|schlampe|schlange|schluchte|schmiere|schnake|schnalle|schneide|schnelle|schokolade|schotte|schurke|schwabe|schwalbe|schwede|schwule|seele|seide|seite|senator(in)?|serb(e|in)?|serie|silbe|skulptur|sonne|sorge|sorte|spanne|sparte|spatz|sperre|spitze|sproße|spule|stalaktit|steppe|straße|streife|studie|stunde|stütze|tabelle|therapeut(in)?|tinte|tote|toilette|torte|traube|treffe|treppe|truhe|träne|tunte|tüte|tyrann|urne|utensil|vandal(e|in)|vasall(in)?|vene|versicherte|verwandte|veteran(in)?|virtuose|vorname|waffe|wanne|ware|watte|wehe|welle|welpe|wiese|wirtin|zar(in)?|zentrum|zutat");
-  private static final Pattern SUBNOMPLUFEM_EXCEPTIONS = compile(".+(kratie|lyse|metrie|sophie|omie)|absage|accessoire|allergie|analogie|anästhesie|anatomie|anomalie|archäologie|aufnahme|balance|batterie|creme|deponie|dürre|einlage|energie|folklore|franchise|gemeinde|glu[ck]ose|gülle|hanse|hefe|hirse|infanterie|kolonie|kontrolle|lounge|massage|mathe|melodie|nässe|parfümerie|pharmazie|pipeline|poesie|psychotherapie|regie|renaissance|säure|single|sprache|stärke|suche|teilnahme|theorie|therapie|vanille|wiederaufnahme|wende");
+  private static final Pattern SUBNOMPLUFEM_EXCEPTIONS = compile(".+(atie|lyse|metrie|sophie|omie)|absage|accessoire|allergie|analogie|anästhesie|anatomie|anomalie|archäologie|aufnahme|balance|barriere|batterie|creme|deponie|dürre|einlage|energie|folklore|franchise|gemeinde|glu[ck]ose|gülle|hanse|hefe|hirse|infanterie|kolonie|kontrolle|lounge|massage|mathe|melodie|nässe|parfümerie|pharmazie|pipeline|poesie|psychotherapie|regie|renaissance|säure|single|sprache|stärke|suche|teilnahme|theorie|therapie|vanille|wiederaufnahme|wende");
   private static final Pattern INVALID_COMP_PART = compile("adresse|kontrolle|leuchte|norden|osten|perspektive|schule|sprache|stelle|suche|süden|westen");
   private static final Pattern SUBINF_SINGULAR_OBJECT = compile("putzen|rauchen|sein|spielen");
   private static final Pattern ARBEIT_COMP = compile("(gebe|nehme)(r(s|n|innen|in)?|nde[mnr]?)");

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -211,6 +211,7 @@ public GermanCompoundTokenizer(boolean strictMode) throws IOException {
     wordSplitter.addException("Oligarchen", asList("Oligarchen"));
     wordSplitter.addException("Optimal", asList("Optimal"));
     wordSplitter.addException("Saunieren", asList("Saunieren"));
+    wordSplitter.addException("Schiessen", asList("Schiessen"));
     wordSplitter.addException("Spielgeleier", asList("Spielgeleier"));
     wordSplitter.addException("Halleschen", asList("Halleschen"));
     wordSplitter.addException("Reinigungstab", asList("Reinigungs", "tab"));

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -77,6 +77,7 @@ public void testGetMessage() {
   @Test
   public void testIgnoreMisspelledWord() throws IOException {
     GermanSpellerRule rule = new GermanSpellerRule(TestTools.getMessages("de"), GERMAN_DE);
+    assertFalse(rule.ignorePotentiallyMisspelledWord("Bogenschiessen"));
     assertFalse(rule.ignorePotentiallyMisspelledWord("Badefenster"));
     assertFalse(rule.ignorePotentiallyMisspelledWord("Badspaß"));
     assertFalse(rule.ignorePotentiallyMisspelledWord("Widersachen"));

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/spelling/hunspell/SpellingCheckRuleTest.java
Patch:
@@ -61,7 +61,7 @@ public void testIgnorePhrases() throws IOException {
     assertThat(lt.check("Ein Test mit Auriensis und Fantasiewortus").size(), is(2));  // the words on their own are not ignored
     assertThat(lt.check("fudeldu laberwort").size(), is(0));
     assertThat(lt.check("Fudeldu laberwort").size(), is(0));  // Uppercase at sentence start is okay
-    assertThat(lt.check("Fudeldu Laberwort").size(), is(2));  // Different case somewhere other than at sentence start is not okay
+    assertThat(lt.check("Fudeldu Laberwort").size(), is(1));  // Different case somewhere other than at sentence start is not okay
 
   }
 

File: languagetool-dev/src/main/java/org/languagetool/dev/httpchecker/CheckCallable.java
Patch:
@@ -115,7 +115,6 @@ public File call() throws Exception {
             //  System.out.println(text);
             //}
             ((ObjectNode)jsonNode).put("title", pseudoFileName);  // needed for MatchKey to be specific enough
-            ((ObjectNode)jsonNode).put("server", result.backendServer);
             fw.write(jsonNode + "\n");
             break;
           } catch (ApiErrorException e) {

File: languagetool-dev/src/test/java/org/languagetool/dev/diff/RuleMatchDiffFinderTest.java
Patch:
@@ -95,7 +95,7 @@ public void testModifiedCoveredText() {
 
   @NotNull
   private LightRuleMatch make(String msg, String context, String coveredText, String suggestion) {
-    return new LightRuleMatch(1, 10, "FAKE_ID1", msg, "FakeCategory", context, coveredText, Arrays.asList(suggestion), "grammar.xml", "mytitle", "apiX",
+    return new LightRuleMatch(1, 10, "FAKE_ID1", msg, "FakeCategory", context, coveredText, Arrays.asList(suggestion), "grammar.xml", "mytitle",
       LightRuleMatch.Status.on, Collections.emptyList(), false);
   }
 

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -230,6 +230,7 @@ protected int getPriorityForId(String id) {
       case "HA_A": return 25; //  lower than CA_SIMPLE_REPLACE_VERBS
       case "PASSAT_PERIFRASTIC": return 25; // greater than CONFUSIONS_ACCENT
       case "CONFUSIONS_ACCENT": return 20;
+      case "CONFUSIO_PASSAT_INFINITIU": return 20; // greater than ACCENTUATION_CHECK
       case "DIACRITICS": return 20;
       case "CAP_GENS": return 20; //greater than CAP_ELS_CAP_ALS, CONCORDANCES_DET_NOM
       case "MOTS_SENSE_GUIONETS": return 20; // greater than CONCORDANCES_NUMERALS

File: languagetool-dev/src/main/java/org/languagetool/dev/httpchecker/CheckCallable.java
Patch:
@@ -115,6 +115,7 @@ public File call() throws Exception {
             //  System.out.println(text);
             //}
             ((ObjectNode)jsonNode).put("title", pseudoFileName);  // needed for MatchKey to be specific enough
+            ((ObjectNode)jsonNode).put("server", result.backendServer);
             fw.write(jsonNode + "\n");
             break;
           } catch (ApiErrorException e) {

File: languagetool-dev/src/test/java/org/languagetool/dev/diff/RuleMatchDiffFinderTest.java
Patch:
@@ -95,7 +95,7 @@ public void testModifiedCoveredText() {
 
   @NotNull
   private LightRuleMatch make(String msg, String context, String coveredText, String suggestion) {
-    return new LightRuleMatch(1, 10, "FAKE_ID1", msg, "FakeCategory", context, coveredText, Arrays.asList(suggestion), "grammar.xml", "mytitle",
+    return new LightRuleMatch(1, 10, "FAKE_ID1", msg, "FakeCategory", context, coveredText, Arrays.asList(suggestion), "grammar.xml", "mytitle", "apiX",
       LightRuleMatch.Status.on, Collections.emptyList(), false);
   }
 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/aisupport/AiRemote.java
Patch:
@@ -237,7 +237,7 @@ private String filterOutput (String out, String org, String instruction, boolean
       String[] inst = instruction.split("[-.:!?]");
       String[] parts = out.split("\r");
       String firstPart = parts[0].trim();
-      if (parts.length > 1 && firstPart.endsWith(":") || firstPart.startsWith(inst[0].trim())) {
+      if (parts.length > 1 && (firstPart.endsWith(":") || firstPart.startsWith(inst[0].trim()))) {
         out = parts[1].trim();
       } else {
         out = firstPart;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/CheckRequestAnalysis.java
Patch:
@@ -832,6 +832,7 @@ private void handleChangedPara(int nPara, String chPara, Locale locale, int[] fo
       }
   //    boolean checkOnlyPara = (docCache.getFlatParagraph(nPara).isEmpty() ? false : true);
       docCache.setFlatParagraph(nPara, chPara, locale);
+      MessageHandler.printToLogFile("setFlatParagraph: " + nPara + ", locale: " + OfficeTools.localeToString(locale));
       docCache.setFlatParagraphFootnotes(nPara, footnotePos);
       docCache.setFlatParagraphDeletedCharacters(nPara, deletedChars);
   //    mDocHandler.handleLtDictionary(chPara, locale);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -938,7 +938,7 @@ public QueueEntry getNextAiQueueEntry(TextParagraph nPara) {
     if (!disposed && docCache != null) {
       int nFPara = nPara == null ? 0 : docCache.getFlatParagraphNumber(nPara);
       for (int i = nFPara; i < docCache.size(); i++) {
-        if (docCache.isFinished() && paragraphsCache.get(OfficeTools.CACHE_AI).getCacheEntry(i) == null) {
+        if (docCache.isFinished() && i >= 0 && paragraphsCache.get(OfficeTools.CACHE_AI).getCacheEntry(i) == null) {
           return createAiQueueEntry(i);
         }
       }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/aisupport/AiToken.java
Patch:
@@ -30,12 +30,14 @@ public class AiToken {
   final AnalyzedSentence sentence;
   final int startPos;
   final int endPos;
+  final boolean isNonWord;
   
-  AiToken(String token, int startPos, AnalyzedSentence sentence) {
+  AiToken(String token, int startPos, AnalyzedSentence sentence, boolean isNonWord) {
     this.sentence = sentence;
     this.token = token;
     this.startPos = startPos;
     this.endPos = startPos + token.length();
+    this.isNonWord = isNonWord;
   }
 
 }

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/ConfigurationDialog.java
Patch:
@@ -2247,8 +2247,8 @@ private JPanel getOfficeAiElements() {
     cons.insets = new Insets(6, 6, 6, 6);
     cons.gridx = 0;
     cons.gridy = 0;
-    cons.anchor = GridBagConstraints.WEST;
-    cons.fill = GridBagConstraints.NONE;
+    cons.anchor = GridBagConstraints.NORTHWEST;
+    cons.fill = GridBagConstraints.BOTH;
     cons.weightx = 0.0f;
     cons.weighty = 0.0f;
     

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/CheckRequestAnalysis.java
Patch:
@@ -701,7 +701,7 @@ private boolean handleCacheChanges() {
         }
         if (mDocHandler.getAiCheckQueue() != null) {
           for (int n = changed.from; n < changed.to; n++) {
-            singleDocument.addAiQueueEntry(n);
+            singleDocument.addAiQueueEntry(n, true);
           }
         }
         if (mDocHandler.getTextLevelCheckQueue() != null) {
@@ -843,7 +843,7 @@ private void handleChangedPara(int nPara, String chPara, Locale locale, int[] fo
           singleDocument.addQueueEntry(nPara, i, minToCheckPara.get(i), docID, numLastFlPara.get(numLastFlPara.size() - 1) < 0 ? false : true);
         }
         if (mDocHandler.getAiCheckQueue() != null) {
-          singleDocument.addAiQueueEntry(nPara);
+          singleDocument.addAiQueueEntry(nPara, true);
         }
       } else {
         singleDocument.removeResultCache(nPara, true);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -954,11 +954,11 @@ public QueueEntry getNextAiQueueEntry(TextParagraph nPara) {
   /**
    * Add an new AI entry to queue
    */
-  public void addAiQueueEntry(int nFPara) {
+  public void addAiQueueEntry(int nFPara, boolean next) {
     if (!disposed && mDocHandler.getAiCheckQueue() != null && docCache != null) {
       TextParagraph nTPara = docCache.getNumberOfTextParagraph(nFPara);
       if (nTPara != null) {
-        mDocHandler.getAiCheckQueue().addQueueEntry(nTPara, docID); 
+        mDocHandler.getAiCheckQueue().addQueueEntry(nTPara, docID, next); 
       }
     }
   }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/aisupport/AiErrorDetection.java
Patch:
@@ -167,7 +167,8 @@ private RuleMatch[] getMatchesByAiRule(int nFPara, String paraText, List<Analyze
     }
     SwJLanguageTool lt = document.getMultiDocumentsHandler().getLanguageTool();
     List<AnalyzedSentence> analyzedAiResult =  lt.analyzeText(result.replace("\u00AD", ""));
-    AiDetectionRule aiRule = new AiDetectionRule(result, paraText, analyzedAiResult, messages, config.aiShowStylisticChanges());
+    AiDetectionRule aiRule = new AiDetectionRule(result, paraText, analyzedAiResult, 
+        document.getMultiDocumentsHandler().getLinguisticServices(), locale , messages, config.aiShowStylisticChanges());
     return aiRule.match(analyzedSentences);
   }
     

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -568,7 +568,7 @@ public RuleMatch adjustFrenchRuleMatch(RuleMatch rm, Set<String> enabledRules) {
       rm.getRule().setLocQualityIssueType(ITSIssueType.Typographical);
     }
     // if the typographical apostrophe rule is enabled, use the typographical apostrophe in suggestons
-    if (enabledRules.contains("APOS_TYP")) {
+    if (enabledRules != null && enabledRules.contains("APOS_TYP")) {
       List<String> newReplacements = new ArrayList<>();
       for (String s : rm.getSuggestedReplacements()) {
         if (s.length() > 1) {

File: languagetool-language-modules/fr/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -116,7 +116,7 @@ public void testMergingOfGrammarCorrections() throws IOException {
     ruleMatches.add(ruleMatch2);
 
     // Process the rule matches
-    List<RuleMatch> processedMatches = lang.filterRuleMatches(ruleMatches, null, null);
+    List<RuleMatch> processedMatches = lang.filterRuleMatches(ruleMatches, null, Collections.emptySet());
 
     // Asserts
     assertEquals("des spectateurs", processedMatches.get(0).getSuggestedReplacements().get(0));

File: languagetool-language-modules/ca/src/test/java/org/languagetool/tagging/disambiguation/CatalanDisambiguationRuleTest.java
Patch:
@@ -90,7 +90,7 @@ public void testChunker() throws IOException {
     TestTools
     .myAssert(
         "Las Palmas de Gran Canaria",
-        "/[null]SENT_START Las/[Las Palmas de Gran Canaria]NPCNG00  /[null]null Palmas/[Las Palmas de Gran Canaria]NPCNG00|Palmas/[Palmas]_possible_nompropi  /[null]null de/[Las Palmas de Gran Canaria]NPCNG00  /[null]null Gran/[Gran]_possible_nompropi|Gran/[Las Palmas de Gran Canaria]NPCNG00  /[null]null Canaria/[Canaria]_possible_nompropi|Canaria/[Las Palmas de Gran Canaria]NPCNG00",
+        "/[null]SENT_START Las/[Las Palmas de Gran Canaria]NPCNG00  /[null]null Palmas/[Las Palmas de Gran Canaria]NPCNG00|Palmas/[Palmas]_possible_nompropi  /[null]null de/[Las Palmas de Gran Canaria]NPCNG00  /[null]null Gran/[Las Palmas de Gran Canaria]NPCNG00  /[null]null Canaria/[Canaria]_possible_nompropi|Canaria/[Las Palmas de Gran Canaria]NPCNG00",
         tokenizer, sentenceTokenizer, tagger, disambiguator);
     TestTools
     .myAssert(

File: languagetool-standalone/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -214,7 +214,8 @@ public void testCache() throws IOException {
     assertThat(cache.hitCount(), is(2L));
 
     JLanguageTool ltGerman = new JLanguageTool(new GermanyGerman(), null, cache);
-    assertTrue(ltGerman.check("This is an test").size() >= 3);
+    // only one error because English words are ignored
+    assertTrue(ltGerman.check("This is an test.").size() >= 1);
     assertThat(cache.hitCount(), is(2L));
 
     assertThat(ltEnglish.check("This is an test").size(), is(1));

File: languagetool-core/src/main/java/org/languagetool/rules/UppercaseSentenceStartRule.java
Patch:
@@ -43,6 +43,7 @@ public class UppercaseSentenceStartRule extends TextLevelRule {
   private static final Pattern NUMERALS_EN =
           compile("[a-z]|(m{0,4}(c[md]|d?c{0,3})(x[cl]|l?x{0,3})(i[xv]|v?i{0,3}))$");
   private static final Pattern CONTAINS_DIGIT = compile(".*\\d.*");
+  private static final Pattern ONLY_LOWERCASE_START = compile("[a-z][A-Z].*");
   private static final Pattern WHITESPACE_OR_QUOTE = compile("[ \"'„«»‘’“”\\n]"); //only ending quote is necessary?
   private static final Pattern SENTENCE_END1 = compile("[.?!…]|");
   private static final Set<String> EXCEPTIONS = new HashSet<>(Arrays.asList(
@@ -182,6 +183,7 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
         String capitalized = StringTools.uppercaseFirstChar(checkToken);
         if (!capitalized.equals(checkToken) &&
           !preventError && Character.isLowerCase(firstChar)
+          && !ONLY_LOWERCASE_START.matcher(checkToken).matches()
           && !EXCEPTIONS.contains(checkToken) && !StringTools.isCamelCase(checkToken)) {
           RuleMatch ruleMatch = new RuleMatch(this, sentence,
                   pos+tokens[matchTokenPos].getStartPos(),

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/UppercaseSentenceStartRuleTest.java
Patch:
@@ -47,6 +47,7 @@ public void testRule() throws IOException {
     assertEquals(0, lt.check("Dies ist ein Satz. \"Aber der hier auch!\".").size());
     assertEquals(0, lt.check("\"Dies ist ein Satz!\"").size());
     assertEquals(0, lt.check("'Dies ist ein Satz!'").size());
+    assertEquals(0, lt.check("mRNA-Impfstoffe sind wichtig.").size());
     
     assertEquals(0, lt.check("Sehr geehrte Frau Merkel,\nwie wir Ihnen schon früher mitgeteilt haben...").size());
     //assertEquals(0, lt.check("Dies ist ein Satz. aber das hier noch nicht").size());

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/RegexAntiPatternFilter.java
Patch:
@@ -44,7 +44,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     for (String antiPattern : antiPatterns) {
       Pattern p = Pattern.compile(antiPattern);
       Matcher matcher = p.matcher(sentenceObj.getText());
-      if (matcher.find()) {
+      while (matcher.find()) {
         // partial overlap is enough to filter out a match:
         if (matcher.start() <= match.getToPos() && matcher.end() >= match.getToPos() ||
             matcher.start() <= match.getFromPos() && matcher.end() >= match.getFromPos()) {

File: languagetool-language-modules/es/src/test/java/org/languagetool/rules/es/MorfologikSpanishSpellerRuleTest.java
Patch:
@@ -221,7 +221,7 @@ public void testMorfologikSpeller() throws IOException {
 
     matches = rule.match(lt.getAnalyzedSentence("Martin"));
     assertEquals(1, matches.length);
-    assertEquals("[Martín, Mártir, Martina, Mastín, Marin, Marlín, Marti, Martins, Martiño, Martí, Marvin, Marín, Martini]", matches[0].getSuggestedReplacements().toString());
+    assertEquals("[Martín, Mártir, Martina, Mastín, Marin, Marlín, Marti, Martins, Martiño, Martí, Marvin, Marín, Martini, Martinů]", matches[0].getSuggestedReplacements().toString());
 
     matches = rule.match(lt.getAnalyzedSentence("Dnipro"));
     assertEquals(1, matches.length);

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SynthesizeWithDeterminerFilter.java
Patch:
@@ -85,7 +85,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     // original word form in the first place
     AnalyzedToken originalAT = patternTokens[lemmaFrom].readingWithTagRegex(lemmaSelect);
     if (originalAT == null) {
-      throw new RuntimeException("Cannot find analyzed token readins with postag "+lemmaSelect+" in sentence"+match.getSentence().getText());
+      throw new RuntimeException("Cannot find analyzed token readings with postag "+lemmaSelect+" in sentence"+match.getSentence().getText());
     }
     potentialSuggestions.add(originalAT);
     // second-best suggestion

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/TokenAgreementAdjNounExceptionHelper.java
Patch:
@@ -691,7 +691,7 @@ && hasOverlapIgnoreGender(masterInflections, slaveInflections) ) {
     // найближчі рік-два
     // понаднормові годину-півтори
     // суперкризовими січнем–лютим
-//    if( LemmaHelper.hasLemma(adjAnalyzedTokenReadins, Arrays.asList("найближчий", "минулий"), ":p:") 
+//    if( LemmaHelper.hasLemma(adjAnalyzedTokenReadings, Arrays.asList("найближчий", "минулий"), ":p:")
     if( PosTagHelper.hasPosTag(adjAnalyzedTokenReadings, "adj.*:p:.*") 
         && tokens[nounPos].getToken().matches(".*[\u2014\u2013-].*")
         && (LemmaHelper.TIME_PLUS_LEMMAS.contains(tokens[nounPos].getAnalyzedToken(0).getLemma().split("[\u2014\u2013-]")[0])
@@ -933,7 +933,7 @@ else if( PosTagHelper.hasPosTag(slaveTokenReadings, "noun.*v_dav.*")) {
 
     if( adjPos > 2 ) {
 //      // порівняно з попереднім
-//      if( PosTagHelper.hasPosTag(adjAnalyzedTokenReadins, "adj.*v_oru")
+//      if( PosTagHelper.hasPosTag(adjAnalyzedTokenReadings, "adj.*v_oru")
 //          && LemmaHelper.hasLemma(tokens[adjPos-2], Arrays.asList("порівняно", "аналогічно")) 
 //          && LemmaHelper.hasLemma(tokens[adjPos-1], Pattern.compile("з|із|зі")) ) {
 //        logException();
@@ -1072,7 +1072,7 @@ && genderMatches(masterInflections, slaveInflections, "v_oru", "v_zna") ) {
         // мають бути підпорядковані служінню
         // радий присутності генерала
         if( PosTagHelper.hasPosTag(tokens[nounPos+1], "noun.*v_(rod|oru|naz|dav).*") ) {
-//            && ! PosTagHelper.hasPosTag(adjAnalyzedTokenReadins, "adj.*v_oru.*") ) {
+//            && ! PosTagHelper.hasPosTag(adjAnalyzedTokenReadings, "adj.*v_oru.*") ) {
           logException();
           return true;
         }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SynthesizeWithDeterminerFilter.java
Patch:
@@ -84,6 +84,9 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     List<AnalyzedToken> potentialSuggestions = new ArrayList<>();
     // original word form in the first place
     AnalyzedToken originalAT = patternTokens[lemmaFrom].readingWithTagRegex(lemmaSelect);
+    if (originalAT == null) {
+      throw new RuntimeException("Cannot find analyzed token readins with postag "+lemmaSelect+" in sentence"+match.getSentence().getText());
+    }
     potentialSuggestions.add(originalAT);
     // second-best suggestion
     String secondGenderNumber = "";

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -254,7 +254,7 @@ public boolean isAdvancedTypographyEnabled() {
     id2prio.put("AUX_VERBO", -45);
     id2prio.put("ENSINO_A_DISTANCIA", -45);
     id2prio.put("OQ_O_QUE_ORTHOGRAPHY", -45);
-    id2prio.put("EMAIL_SEM_HIFEN_ORTHOGRAPHY", -45); // HIGHER THAN SPELLER
+    id2prio.put("EMAIL_SEM_HIFEN", -45); // HIGHER THAN SPELLER
     // MORFOLOGIK SPELLER FITS HERE AT -50 ---------------------  // SPELLER (-50)
     id2prio.put("PRETERITO_PERFEITO", -51);  // LOWER THAN SPELLER
     id2prio.put("PT_BR_SIMPLE_REPLACE", -51);

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java
Patch:
@@ -191,6 +191,7 @@ public List<String> getAdditionalSpellingFileNames() {
   private static final Pattern WHEREEVER = compile("[Ww]hereever");
   private static final Pattern WHATSAPP = compile("[Ww]hatsapp");
   private static final Pattern JETLAGGED = compile("jetlagged");
+  private static final Pattern LIKELYHOOD = compile("[Ll]ikelyhood");
   private static final Pattern HUBSPOT = compile("[Hh]ubspot");
   private static final Pattern URL = compile("[Uu]rl");
   private static final Pattern TV = compile("tv");
@@ -1527,6 +1528,7 @@ protected List<SuggestedReplacement> getOnlySuggestions(String word) {
     if (WHEREEVER.matcher(word).matches()) return topMatch(word.replaceFirst("hereever", "herever"));
     if (WHATSAPP.matcher(word).matches()) return topMatch("WhatsApp");
     if (JETLAGGED.matcher(word).matches()) return topMatch("jet-lagged");
+    if (LIKELYHOOD.matcher(word).matches()) return topMatch(word.replaceFirst("ikelyhood", "ikelihood"));
     if (TV.matcher(word).matches()) {
       List<SuggestedReplacement> l = new ArrayList<>();
       l.add(new SuggestedReplacement("TV"));

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LtMenus.java
Patch:
@@ -44,6 +44,7 @@
 import com.sun.star.lang.EventObject;
 import com.sun.star.lang.XComponent;
 import com.sun.star.lang.XMultiServiceFactory;
+import com.sun.star.linguistic2.SingleProofreadingError;
 import com.sun.star.text.XTextRange;
 import com.sun.star.ui.ActionTriggerSeparatorType;
 import com.sun.star.ui.ContextMenuExecuteEvent;
@@ -610,10 +611,10 @@ public ContextMenuInterceptorAction notifyContextMenuExecute(ContextMenuExecuteE
               }
             }
             if (!isSpellError) {
+              document.getErrorAndChangeRange(aEvent);
               if (document.getCurrentNumberOfParagraph() >= 0) {
                 props.setPropertyValue("CommandURL", LT_IGNORE_ONCE_COMMAND);
               }
-
               XPropertySet xNewMenuEntry3 = UnoRuntime.queryInterface(XPropertySet.class,
                   xMenuElementFactory.createInstance("com.sun.star.ui.ActionTrigger"));
               xNewMenuEntry3.setPropertyValue("Text", MESSAGES.getString("loContextMenuIgnorePermanent"));

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SwJLanguageTool.java
Patch:
@@ -76,6 +76,7 @@ public SwJLanguageTool(Language language, Language motherTongue, UserConfig user
       lt = null;
       mlt = null;
       rlt = new LORemoteLanguageTool(language, motherTongue, config, extraRemoteRules, userConfig);
+      //  TODO: CleanOverlappingMatches
       if (!rlt.remoteRun()) {
         MessageHandler.showMessage(MESSAGES.getString("loRemoteSwitchToLocal"));
         isRemote = false;
@@ -85,9 +86,11 @@ public SwJLanguageTool(Language language, Language motherTongue, UserConfig user
     } else if (isMultiThread) {
       lt = null;
       mlt = new MultiThreadedJLanguageToolLo(language, motherTongue, userConfig);
+      mlt.setCleanOverlappingMatches(false);
       rlt = null;
     } else {
       lt = new JLanguageToolLo(language, motherTongue, null, userConfig);
+      lt.setCleanOverlappingMatches(false);
       mlt = null;
       rlt = null;
     }

File: languagetool-core/src/test/java/org/languagetool/rules/LongParagraphRuleTest.java
Patch:
@@ -45,15 +45,15 @@ public void testRule() throws IOException {
     String text1 = "This is a short paragraph.\n\nHere's some text as filler. This is a long paragraph by unit test standards.";
     RuleMatch[] matches1 = rule.match(lt.analyzeText(text1));
     assertThat(matches1.length, is(1));
-    assertThat(matches1[0].getFromPos(), is(48));  // "filler"
+    assertThat(matches1[0].getFromPos(), is(45));  // "filler"
     assertThat(matches1[0].getToPos(), is(54));
 
     String text2 = "Here's some text as filler. This is a long paragraph by unit test standards.\n\nAnother paragraph.\n\nHere's some text as morefiller - this is a long paragraph by unit test standards.";
     RuleMatch[] matches2 = rule.match(lt.analyzeText(text2));
     assertThat(matches2.length, is(2));
-    assertThat(matches2[0].getFromPos(), is(20));  // "filler"
+    assertThat(matches2[0].getFromPos(), is(17));  // "filler"
     assertThat(matches2[0].getToPos(), is(26));
-    assertThat(matches2[1].getFromPos(), is(118));  // "morefiller"
+    assertThat(matches2[1].getFromPos(), is(115));  // "morefiller"
     assertThat(matches2[1].getToPos(), is(128));
   }
 

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/SpanishRepeatedWordsRule.java
Patch:
@@ -117,7 +117,7 @@ protected boolean isException(AnalyzedTokenReadings[] tokens, int i, boolean sen
     if (isAllUppercase || (isCapitalized && !sentStart)) {
       return true;
     }
-    if (tokens[i].hasPosTagStartingWith("NP")) {
+    if (tokens[i].hasPosTagStartingWith("NP") || tokens[i].hasPosTag("_english_ignore_")) {
       return true;
     }
     return false;

File: languagetool-language-modules/es/src/test/java/org/languagetool/rules/es/QuestionMarkRuleTest.java
Patch:
@@ -115,6 +115,9 @@ public void test() throws IOException {
     RuleMatch[] matches19 = check("Hola, Marco: Puedes darme tu dirección de correo?");
     assertThat(matches19[0].getSuggestedReplacements().toString(), is("[¿Puedes]"));
 
+    RuleMatch[] matches33 =check("Están aquí: https://gtlb.com/smll-cued-datasets/hu[…]nitized/-/tree/main/beling?ref_type=heads");
+    assertThat(matches33.length, is(0));
+
     // Exclamation marks:
     List<RuleMatch> matches20 = lt.check("Qué irritante!");
     assertThat(matches20.size(), is(1));

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseProclisisFilter.java
Patch:
@@ -5,11 +5,9 @@
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.rules.patterns.RuleFilter;
 import org.languagetool.synthesis.pt.PortugueseSynthesizer;
-import org.languagetool.tools.StringTools;
 
 import java.io.IOException;
 import java.util.*;
-import java.util.function.Predicate;
 
 public class PortugueseProclisisFilter extends RuleFilter {
   protected PortugueseSynthesizer getSynthesizer() {
@@ -23,8 +21,10 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     HashSet<String> suggestions = new HashSet<>(Collections.emptyList());
     for (AnalyzedToken at : encliticVerbTokenReadings.getReadings()) {
       String posTag = at.getPOSTag();
+      if (posTag == null || !posTag.startsWith("V") || !posTag.contains(":")) {
+        continue;
+      }
       String oldToken = at.getToken();
-      assert posTag != null;
       String[] tagParts = posTag.split(":");
       String verbTag = tagParts[0];
       String newVerb = getSynthesizer().synthesize(at, verbTag)[0];

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -231,7 +231,7 @@ private boolean initSpellers() throws IOException {
       } else {
         // should not happen, as we only configure this rule (or rather its subclasses)
         // when we have the resources:
-        return true;
+        throw new RuntimeException("Cannot find dictionary file " + getFileName());
       }
     }
     return false;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/CatalanSuppressMisspelledSuggestionsFilter.java
Patch:
@@ -36,7 +36,7 @@ public CatalanSuppressMisspelledSuggestionsFilter() throws IOException {
   public boolean isMisspelled(String s, Language language) throws IOException {
     SpellingCheckRule spellerRule = language.getDefaultSpellingRule();
     if (spellerRule == null) {
-      return false;
+      return true;
     }
     List<AnalyzedSentence> sentences = language.createDefaultJLanguageTool().analyzeText(s);
     return spellerRule.match(sentences.get(0)).length > 0;

File: languagetool-language-modules/uk/src/test/java/org/languagetool/tokenizers/uk/UkrainianWordTokenizerTest.java
Patch:
@@ -126,6 +126,9 @@ public void testNumbers() {
 
     testList = w.tokenize("відбулася 17.8.1245");
     assertEquals(Arrays.asList("відбулася", " ", "17.8.1245"), testList);
+    
+    testList = w.tokenize("1814.03.09");
+    assertEquals(Arrays.asList("1814.03.09"), testList);
   }
 
   @Test

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/MorfologikPortugueseSpellerRuleTest.java
Patch:
@@ -18,14 +18,12 @@
  */
 package org.languagetool.rules.pt;
 
-import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
 import org.languagetool.JLanguageTool;
 import org.languagetool.Languages;
 import org.languagetool.TestTools;
 import org.languagetool.rules.RuleMatch;
-import org.languagetool.rules.patterns.PatternRuleXmlCreatorTest;
 
 
 import java.io.IOException;
@@ -257,6 +255,7 @@ public void testPortugueseSpellerDoesNotAcceptVerbFormsWithElidedConsonants() th
   public void testPortugueseSpellerAcceptsVerbsWithProductivePrefixes() throws Exception {
     assertNoErrors("soto-pôr", ltBR, ruleBR);     // exists in speller, ignoreSpelling() from tagger
     assertNoErrors("soto-trepar", ltBR, ruleBR);  // NOT in speller, ignoreSpelling() from tagger
+    assertSingleError("reune", ltBR, ruleBR, "reúne");  // no 're' + 'unir'
   }
 
   @Test

File: languagetool-language-modules/pt/src/test/java/org/languagetool/tagging/pt/PortugueseTaggerTest.java
Patch:
@@ -100,9 +100,9 @@ public void testTaggerTagsCompoundsRegardlessOfLetterCase() throws IOException {
   public void testTagProductivePrefixesNotPresentInSpeller() throws IOException {
     // not a real prefix, must be null
     TestTools.myAssert("xoxotrepei", "xoxotrepei/[null]null", tokenizer, tagger);
-    // auto- and re- are Tiago's original prefixes
-    TestTools.myAssert("autotrepei", "autotrepei/[autotrepar]VMIS1S0", tokenizer, tagger);
-    TestTools.myAssert("retrepei", "retrepei/[retrepar]VMIS1S0", tokenizer, tagger);
+    // auto- and re- are Tiago's original prefixes; these were removed because of issues like 'reune' and 'autosabotar'
+//    TestTools.myAssert("autotrepei", "autotrepei/[autotrepar]VMIS1S0", tokenizer, tagger);
+//    TestTools.myAssert("retrepei", "retrepei/[retrepar]VMIS1S0", tokenizer, tagger);
     // new prefixes, to work with dict v0.13
     // include prefixes that always require a hyphen, like 'soto-'
     TestTools.myAssert("soto-trepei", "soto-trepei/[soto-trepar]VMIS1S0", tokenizer, tagger);

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleMatcher.java
Patch:
@@ -349,7 +349,8 @@ private String formatMatches(AnalyzedTokenReadings[] tokenReadings,
 
   private static String concatWithoutExtraSpace(String leftSide, String rightSide) {
     // can't do \\p{Punct} as it catches \2 placeholder
-    if (leftSide.endsWith(" ") && WHITESPACE_OR_PUNCT.matcher(rightSide).matches()) {
+    if ((leftSide.endsWith(" ") && rightSide.startsWith("</suggestion>"))
+      || (leftSide.endsWith(" ") && WHITESPACE_OR_PUNCT.matcher(rightSide).matches())) {
       return leftSide.substring(0, leftSide.length()-1) + rightSide;
     }
     if (leftSide.endsWith("suggestion>") && rightSide.startsWith(" ")) {

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractAdvancedSynthesizerFilter.java
Patch:
@@ -163,7 +163,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     return match;
   }
 
-  private String getCompositePostag(String lemmaSelect, String postagSelect, String originalPostag,
+  public String getCompositePostag(String lemmaSelect, String postagSelect, String originalPostag,
       String desiredPostag, String postagReplace) {
     Pattern aPattern = Pattern.compile(lemmaSelect, Pattern.UNICODE_CASE);
     Pattern bPattern = Pattern.compile(postagSelect, Pattern.UNICODE_CASE);

File: languagetool-language-modules/pt/src/main/java/org/languagetool/tokenizers/pt/PortugueseWordTokenizer.java
Patch:
@@ -144,7 +144,7 @@ public List<String> tokenize(final String text) {
       String token = tokeniserMatcher.group();
       // 0xFE00-0xFE0F are non-spacing marks
       if (!tokenList.isEmpty() && token.length() == 1 && token.codePointAt(0)>=0xFE00 && token.codePointAt(0)<=0xFE0F) {
-        tokenList.set(tokenList.size() - 1, tokenList.get(tokenList.size() - 1) + tokenList);
+        tokenList.set(tokenList.size() - 1, tokenList.get(tokenList.size() - 1) + token);
         continue;
       }
       token = token.replace(DECIMAL_COMMA_SUBST, ',');

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/PortugueseWordRepeatRuleTest.java
Patch:
@@ -37,7 +37,8 @@ public void testIgnore() throws IOException {
     assertTrue(ignore("blá blá", lt, rule, 2));
     assertTrue(ignore("Aaptos aaptos", lt, rule, 2));
     assertTrue(ignore("Logo logo vamos ao mercado", lt, rule, 2));
-    assertTrue(ignore("Coloquem-na na sala.", lt, rule, 4)); // the hyphen is a token
+    // as of the v0.13 dict, the following is not a repetition, since 'coloquem-na' is a single token <3
+    assertFalse(ignore("Coloquem-na na sala.", lt, rule, 2));
   }
 
   private boolean ignore(String input, JLanguageTool lt, PortugueseWordRepeatRule rule, int position) throws IOException {

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishUnpairedQuotesRule.java
Patch:
@@ -48,15 +48,15 @@ public String getId() {
 
   @Override
   protected boolean isNotBeginningApostrophe(AnalyzedTokenReadings[] tokens, int i) {
-    if (tokens[i].hasPosTag("_apostrophe_contraction_") || tokens[i].hasPosTag("POS")) {
+    if (tokens[i].hasPosTag("_apostrophe_contraction_") || tokens[i].hasPosTag("POS") || tokens[i].hasPosTag("NNP")) {
       return false;
     }
     return true;
   }
 
   @Override
   protected boolean isNotEndingApostrophe(AnalyzedTokenReadings[] tokens, int i) {
-    if (tokens[i].hasPosTag("_apostrophe_contraction_") || tokens[i].hasPosTag("POS")) {
+    if (tokens[i].hasPosTag("_apostrophe_contraction_") || tokens[i].hasPosTag("POS") || tokens[i].hasPosTag("NNP")) {
       return false;
     }
     return true;

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/EnglishUnpairedQuotesRuleTest.java
Patch:
@@ -94,6 +94,7 @@ public void testRule() throws IOException {
     assertCorrect("Côte d’Ivoire");
     assertCorrect("Côte d'Ivoire");
     assertCorrect("Colonel d’Aubigni");
+    assertCorrect("They are members of the Bahá'í Faith.");
     
     
     // test for a case that created a false alarm after disambiguation

File: languagetool-language-modules/fr/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -102,7 +102,7 @@ public void testMailRule() throws IOException {
     Set<String> enabledRules = Collections.emptySet();
     List<RuleMatch> processedMatches = lang.adaptSuggestions(ruleMatches, enabledRules);
     assertEquals("AI_FR_GGEC_MAIL_EMAIL", processedMatches.get(0).getSpecificRuleId());
-    assertEquals("Rule should be marked as picky", processedMatches.get(0).getRule().getTags().contains(Tag.picky));
+    assertEquals(true, processedMatches.get(0).getRule().getTags().contains(Tag.picky));
     assertEquals("Dans un contexte formel, « e-mail » semble plus approprié.", processedMatches.get(0).getMessage());
     assertEquals("Forme préférée : « e-mail ».", processedMatches.get(0).getShortMessage());
   }
@@ -116,7 +116,7 @@ public void testQuotes() throws IOException {
     ruleMatches.add(ruleMatch);
     Set<String> enabledRules = Collections.emptySet();
     List<RuleMatch> processedMatches = lang.adaptSuggestions(ruleMatches, enabledRules);
-    assertEquals("Rule should be marked as picky", processedMatches.get(0).getRule().getTags().contains(Tag.picky));
+    assertEquals(true, processedMatches.get(0).getRule().getTags().contains(Tag.picky));
     assertEquals("AI_FR_GGEC_QUOTES", processedMatches.get(0).getSpecificRuleId());
   }
 }

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishWordRepeatRule.java
Patch:
@@ -99,10 +99,12 @@ public boolean ignore(AnalyzedTokenReadings[] tokens, int position) {
         (position + 1 < tokens.length) && SINGLE_CHAR.matcher(tokens[position + 1].getToken()).matches()) {
       // spelling with spaces in between: "b a s i c a l l y"
       return true;
+    } else if (repetitionOf("aye", tokens, position)) {
+      return true;   // "aye aye"
     } else if (repetitionOf("blah", tokens, position)) {
       return true;   // "blah blah"
     } else if (repetitionOf("mau", tokens, position)) {
-      return true;   // "blah blah"
+      return true;   // "mau mau"
     } else if (repetitionOf("uh", tokens, position)) {
       return true;   // "uh uh"
     } else if (repetitionOf("paw", tokens, position)) {

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/EnglishWordRepeatRuleTest.java
Patch:
@@ -72,6 +72,7 @@ public void testRepeatRule() throws IOException {
     assertBad("I I am the best.");
     assertGood("In a land far far away.");
     assertGood("I love you so so much.");
+    assertGood("Aye aye, sir!");
     assertGood("What Tom did didn't seem to bother Mary at all.");
     assertGood("Whatever you do don't leave the lid up on the toilet!");
     assertGood("Keep your chin up and whatever you do don't doubt yourself or your actions.");

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleCheck.java
Patch:
@@ -174,7 +174,7 @@ public SingleProofreadingError[] getCheckResults(String paraText, int[] footnote
   }
   
   /**
-   *   check for number of Paragraphs > 0, chapter wide or full text
+   *   check for number of Paragraphs &gt; 0, chapter wide or full text
    *   is also called by text level queue
    */
   public void addParaErrorsToCache(int nFPara, SwJLanguageTool lt, int cacheNum, int parasToCheck, 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/stylestatistic/UsedWordRule.java
Patch:
@@ -291,8 +291,7 @@ public void setWord(String word) {
   
   /**
    * set the Cache for one paragraph
-   * @throws IOException 
-   */  
+   */
   public void setCacheForParagraph(int nFPara, int nTPara, StatAnCache cache) {
     ResultCache statAnalysisCache = new ResultCache();
     List<AnalyzedSentence> analyzedSentences = cache.getAnalysedParagraph(nTPara);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -2322,7 +2322,7 @@ protected boolean ignorePotentiallyMisspelledWord(String word) throws IOExceptio
         !isMisspelled(part1) &&
         isNoun(part2uc) // don't accept e.g. "Azubikommt"
       ) {
-      System.out.println("compound: " + part1 + " " + part2 + " (" + word + ")");
+      //System.out.println("compound: " + part1 + " " + part2 + " (" + word + ")");
       return true;
     }
     return false;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -338,7 +338,7 @@ private void refreshWriterCache(SingleDocument document, Locale fixedLocale, Loc
 //        document.getMultiDocumentsHandler().handleLtDictionary(getDocAsString(), locale);
 //      }
       document.getMultiDocumentsHandler().runShapeCheck(hasUnsupportedText(), fromWhere);
-      if (fromWhere != 2 || debugModeTm) { //  do not write time to log for text level queue
+      if (debugModeTm) {
         long endTime = System.currentTimeMillis();
         MessageHandler.printToLogFile("Time to generate cache(" + fromWhere + "): " + (endTime - startTime));
       }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/EndOfParagraphPunctuationRule.java
Patch:
@@ -56,6 +56,7 @@ public String getDescription() {
   @Override
   public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
     List<RuleMatch> ruleMatches = new ArrayList<>();
+    int pos = 0;
     int sentencesInParagraph = 0;
     for (AnalyzedSentence sentence : sentences) {
       AnalyzedTokenReadings[] tokens = sentence.getTokensWithoutWhitespace();
@@ -65,7 +66,7 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
       if (lastToken.hasPosTag("PARA_END")) {
         if (sentencesInParagraph > 0) {
           if (!StringTools.isPunctuationMark(lastTokenStr) || lastTokenStr.equals(",") || lastTokenStr.equals(";")) {
-            RuleMatch ruleMatch = new RuleMatch(this, sentence, lastToken.getStartPos(), lastToken.getEndPos(),
+            RuleMatch ruleMatch = new RuleMatch(this, sentence, pos + lastToken.getStartPos(), pos + lastToken.getEndPos(),
               ruleMessage, shortMessage);
             if (!StringTools.isPunctuationMark(lastTokenStr)) {
               ruleMatch.setSuggestedReplacement(lastTokenStr + ".");
@@ -79,6 +80,7 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
       } else {
         sentencesInParagraph++;
       }
+      pos += sentence.getCorrectedTextLength();
     }
     return ruleMatches.toArray(new RuleMatch[0]);
   }

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/EndOfParagraphPunctuationRuleTest.java
Patch:
@@ -45,16 +45,17 @@ public void testRule() throws IOException {
     matches = rule.match(lt.analyzeText("Això és un paràgraf amb una frase només. Això és la segona frase"));
     assertEquals(1, matches.length);
     assertEquals("frase.", matches[0].getSuggestedReplacements().get(0));
+    assertEquals(59, matches[0].getFromPos());
 
     matches = rule.match(lt.analyzeText("Això és un paràgraf amb una frase només. Això és la segona frase,"));
     assertEquals(1, matches.length);
     assertEquals(".", matches[0].getSuggestedReplacements().get(0));
+    assertEquals(64, matches[0].getFromPos());
 
     matches = rule.match(lt.analyzeText("Això és un paràgraf amb una frase només.\\n"
     +"Això és una única frase en un paràgraf"));
     assertEquals(0, matches.length);
 
-
   }
 
 }

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/SimpleReplaceVerbsRuleTest.java
Patch:
@@ -73,7 +73,7 @@ public void testRule() throws IOException {
     
     matches = rule.match(lt.getAnalyzedSentence("pringava"));
     assertEquals(1, matches.length);
-    assertEquals("enllardava", matches[0].getSuggestedReplacements().get(0));
+    assertEquals("enfangava", matches[0].getSuggestedReplacements().get(0));
     assertEquals("empastifava", matches[0].getSuggestedReplacements().get(1));
     assertEquals("llepava", matches[0].getSuggestedReplacements().get(2));
     assertEquals("cagava", matches[0].getSuggestedReplacements().get(3));

File: languagetool-language-modules/fr/src/test/java/org/languagetool/tagging/fr/FrenchTaggerTest.java
Patch:
@@ -90,7 +90,7 @@ public void testTagger() throws IOException {
       "Pen/[null]null", tokenizer, tagger);
     TestTools.myAssert("Saint-Côme-Le Mesnil", "Saint-Côme/[Saint-Côme]Z e sp -- Le/[le]D m s|Le/[le]R pers obj 3 m s" +
       " -- Mesnil/[null]null", tokenizer, tagger);
-    TestTools.myAssert("Dieppe-Le Tréport", "Dieppe/[Dieppe]Z e sp|Dieppe/[Dieppe]Z e sp -- Le/[le]D m s|Le/[le]R " +
+    TestTools.myAssert("Dieppe-Le Tréport", "Dieppe/[Dieppe]Z e sp -- Le/[le]D m s|Le/[le]R " +
       "pers obj 3 m s -- Tréport/[null]null", tokenizer, tagger);
     TestTools.myAssert("Caricaturistes-Les fantassins de la démocratie", "Caricaturistes/[caricaturiste]N e p -- " +
       "Les/[le]D e p|Les/[les]R pers obj 3 e p -- fantassins/[fantassin]N m p -- de/[de]D e sp|de/[de]P -- la/[la]N m" +

File: languagetool-language-modules/fr/src/test/java/org/languagetool/tagging/fr/FrenchTaggerTest.java
Patch:
@@ -90,7 +90,7 @@ public void testTagger() throws IOException {
       "Pen/[null]null", tokenizer, tagger);
     TestTools.myAssert("Saint-Côme-Le Mesnil", "Saint-Côme/[Saint-Côme]Z e sp -- Le/[le]D m s|Le/[le]R pers obj 3 m s" +
       " -- Mesnil/[null]null", tokenizer, tagger);
-    TestTools.myAssert("Dieppe-Le Tréport", "Dieppe/[Dieppe]Z e sp|Dieppe/[Dieppe]Z e sp -- Le/[le]D m s|Le/[le]R " +
+    TestTools.myAssert("Dieppe-Le Tréport", "Dieppe/[Dieppe]Z e sp -- Le/[le]D m s|Le/[le]R " +
       "pers obj 3 m s -- Tréport/[null]null", tokenizer, tagger);
     TestTools.myAssert("Caricaturistes-Les fantassins de la démocratie", "Caricaturistes/[caricaturiste]N e p -- " +
       "Les/[le]D e p|Les/[les]R pers obj 3 e p -- fantassins/[fantassin]N m p -- de/[de]D e sp|de/[de]P -- la/[la]N m" +

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/EnglishUnpairedBracketsRuleTest.java
Patch:
@@ -70,6 +70,8 @@ public void testRule() throws IOException {
     //some more cases
     assertCorrect("(Ketab fi Isti'mal al-'Adad al-Hindi)");
     assertCorrect("(al-'Adad al-Hindi)");
+    assertCorrect("will-o'-the-wisp");
+    assertCorrect("cat-o’-nine-tails");
     //TODO: ambiguous
     assertCorrect("a) item one\nb) item two\nc) item three");
     assertCorrectText("\n\n" +

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -257,7 +257,6 @@ public boolean isAdvancedTypographyEnabled() {
     id2prio.put("EMAIL_SEM_HIFEN_ORTHOGRAPHY", -45); // HIGHER THAN SPELLER
     // MORFOLOGIK SPELLER FITS HERE AT -50 ---------------------  // SPELLER (-50)
     id2prio.put("PRETERITO_PERFEITO", -51);  // LOWER THAN SPELLER
-    id2prio.put("AI_PT_GGEC_REPLACEMENT_ORTHOGRAPHY_SPELL", -51);  // gGEC speller is lower than the Java speller
     id2prio.put("PT_BR_SIMPLE_REPLACE", -51);
     id2prio.put("CRASE_CONFUSION", -54);
     id2prio.put("NAO_MILITARES", -54);
@@ -292,6 +291,9 @@ protected int getPriorityForId(String id) {
     if (id.startsWith("MORFOLOGIK_RULE")) {
       return -50;
     }
+    if (id.startsWith("AI_PT_GGEC_REPLACEMENT_ORTHOGRAPHY_SPELL")) {
+      return -49;
+    }
     if (id.startsWith("PT_MULTITOKEN_SPELLING")) {
       return -49;
     }

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/ContractionSpellingRuleTest.java
Patch:
@@ -49,6 +49,7 @@ public void testRule() throws IOException {
     assertEquals(0, rule.match(lt.getAnalyzedSentence("I'm ill.")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Staatszerfall im südlichen Afrika.")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("by IVE")).length);
+    assertEquals(0, rule.match(lt.getAnalyzedSentence("Never mind the whys and wherefores.")).length);
     
     // incorrect sentences:
 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -553,7 +553,9 @@ public Language getLanguage() {
   void setLanguage(Language language) {
     docLanguage = language;
     docLocale = LinguisticServices.getLocale(language);
-    ltToolbar.makeToolbar(language);
+    if (ltToolbar != null) {
+      ltToolbar.makeToolbar(language);
+    }
   }
   
   /** 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -603,6 +603,9 @@ public SingleProofreadingError[] getSpellErrors(int nPara, String text, Locale l
               if (locale == null) {
                 locale = lang;
               }
+              if (linguServices == null) {
+                linguServices = new LinguisticServices(xContext);
+              }
               if (!linguServices.isCorrectSpell(sToken, locale)) {
                 SingleProofreadingError aError = new SingleProofreadingError();
                 if (debugMode) {

File: languagetool-language-modules/nl/src/main/java/org/languagetool/rules/nl/DutchMultitokenSpeller.java
Patch:
@@ -36,7 +36,7 @@ protected DutchMultitokenSpeller() {
   protected boolean isException(String original, String candidate) {
     if (original.length()>2) {
       if (original.substring(0, original.length()-1).equals(candidate)) {
-        if (original.endsWith("s")) {
+        if (original.endsWith("s") || original.endsWith("-")) {
           return true;
         }
       }

File: languagetool-server/src/main/java/org/languagetool/server/Server.java
Patch:
@@ -140,7 +140,7 @@ protected static void printCommonConfigFileOptions() {
     System.out.println("                 'fasttextBinary' - compiled fasttext executable for language detection (optional), see");
     System.out.println("                                    https://fasttext.cc/docs/en/support.html");
     System.out.println("                 'maxWorkQueueSize' - reject request if request queue gets larger than this (optional)");
-    System.out.println("                 'rulesFile' - a file containing rules configuration, such as .langugagetool.cfg (optional)");
+    System.out.println("                 'rulesFile' - a file containing rules configuration, such as .languagetool.cfg (optional)");
     System.out.println("                 'blockedReferrers' - a comma-separated list of HTTP referrers (and 'Origin' headers) that are blocked and will not be served (optional)");
     System.out.println("                 'premiumOnly' - activate only the premium rules (optional)");
     System.out.println("                 'disabledRuleIds' - a comma-separated list of rule ids that are turned off for this server (optional)");

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LtMenus.java
Patch:
@@ -79,6 +79,7 @@ public class LtMenus {
   public final static String LT_CHECKDIALOG_COMMAND = "service:org.languagetool.openoffice.Main?checkDialog";
   public final static String LT_CHECKAGAINDIALOG_COMMAND = "service:org.languagetool.openoffice.Main?checkAgainDialog";
   public static final String LT_STATISTICAL_ANALYSES_COMMAND = "service:org.languagetool.openoffice.Main?statisticalAnalyses";   
+  public static final String LT_OFF_STATISTICAL_ANALYSES_COMMAND = "service:org.languagetool.openoffice.Main?offStatisticalAnalyses";   
   public static final String LT_RESET_IGNORE_PERMANENT_COMMAND = "service:org.languagetool.openoffice.Main?resetIgnorePermanent";   
   public static final String LT_TOGGLE_BACKGROUND_CHECK_COMMAND = "service:org.languagetool.openoffice.Main?toggleNoBackgroundCheck";
   public static final String LT_BACKGROUND_CHECK_ON_COMMAND = "service:org.languagetool.openoffice.Main?backgroundCheckOn";

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServerConfig.java
Patch:
@@ -343,9 +343,6 @@ private void parseConfigFile(File file, boolean loadLangModel) {
         String ruleIdToConfidence = getOptionalProperty(props, "ruleIdToConfidenceFile", null);
         if (ruleIdToConfidence != null) {
           ruleIdToConfidenceFile = new File(ruleIdToConfidence);
-          if (!ruleIdToConfidenceFile.exists() || !ruleIdToConfidenceFile.isFile()) {
-            throw new RuntimeException("ruleIdToConfidenceFile cannot be found: " + ruleIdToConfidenceFile);
-          }
         }
         String langModel = getOptionalProperty(props, "languageModel", null);
         if (langModel != null && loadLangModel) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/LongSentenceRuleTest.java
Patch:
@@ -36,9 +36,10 @@ public void testMatch() throws Exception {
     assertNoMatch("Ich zähle jetzt: \"Eins zwei drei vier fünf sechs.\"", rule, lt);
     assertNoMatch("Peter, bist du bereit?” Er nickte nur.\n", rule, lt);
     assertNoMatch("Peter, du bist bereit.” Er nickte nur.\n", rule, lt);
+    assertNoMatch("Eins zwei drei vier fünf (sechs sieben) acht.", rule, lt);
 
     assertMatch("Eins zwei drei vier fünf sechs sieben.", 0, 38, rule, lt);
-    assertMatch("Eins zwei drei vier fünf (sechs sieben) acht.", 0, 45, rule, lt);
+    assertMatch("Eins zwei drei vier fünf (sechs sieben) acht neun.", 0, 50, rule, lt);
     assertMatch("Ich zähle jetzt: Eins zwei drei vier fünf sechs sieben.", 0, 55, rule, lt);
     assertMatch("Ein Satz. Eins zwei drei vier fünf sechs sieben.", 10, 48, rule, lt);
   }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LtToolbar.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.ResourceBundle;
 
 import org.languagetool.JLanguageTool;
-import org.languagetool.gui.Configuration;
 
 import com.sun.star.awt.Point;
 import com.sun.star.awt.XWindow;
@@ -42,7 +41,6 @@
 import com.sun.star.lang.XMultiComponentFactory;
 import com.sun.star.ui.ItemStyle;
 import com.sun.star.ui.ItemType;
-import com.sun.star.ui.UIElementType;
 import com.sun.star.ui.XModuleUIConfigurationManagerSupplier;
 import com.sun.star.ui.XUIConfigurationManager;
 import com.sun.star.uno.Exception;
@@ -204,7 +202,7 @@ public void makeToolbar() {
         isLocked = layoutManager.isElementLocked(toolbarName);
         pos = layoutManager.getElementPos(toolbarName);
         isVisible = layoutManager.isElementVisible(toolbarName);
-        MessageHandler.printToLogFile("LtToolbar: makeToolbar: name: " + toolbarName + ", isVisible: " + isVisible + ", isLocked: " + isLocked);
+//        MessageHandler.printToLogFile("LtToolbar: makeToolbar: name: " + toolbarName + ", isVisible: " + isVisible + ", isLocked: " + isLocked);
       }
       layoutManager.destroyElement(toolbarName);
       layoutManager.createElement(toolbarName);

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Tools.java
Patch:
@@ -300,15 +300,15 @@ static void showRuleInfoDialog(Component parent, String title, String message, R
             JOptionPane.INFORMATION_MESSAGE);
   }
 
-  private static String encodeUrl(Rule rule) {
+  public static String encodeUrl(Rule rule) {
     try {
       return URLEncoder.encode(rule.getId(), "utf-8");
     } catch (UnsupportedEncodingException e) {
       throw new RuntimeException(e);
     }
   }
 
-  private static String getExampleSentences(Rule rule, ResourceBundle messages) {
+  public static String getExampleSentences(Rule rule, ResourceBundle messages) {
     StringBuilder examples = new StringBuilder(200);
     List<IncorrectExample> incorrectExamples = rule.getIncorrectExamples();
     if (incorrectExamples.size() > 0) {
@@ -337,7 +337,7 @@ private static String getExampleSentences(Rule rule, ResourceBundle messages) {
     return examples.toString();
   }
 
-  private static String formatURL(URL url) {
+  public static String formatURL(URL url) {
     if (url == null) {
       return "";
     }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -1998,7 +1998,7 @@ public static String fixLinebreak(String text) {
   }
 
   /**
-   * Change manual linebreak to distinguish from end of paragraph
+   * remove zero width space
    */
   public static String removeZeroWidthSpace(String text) {
     return text.replaceAll(OfficeTools.ZERO_WIDTH_SPACE, "");
@@ -2396,7 +2396,7 @@ public List<AnalyzedSentence> createAnalyzedParagraph(int nFPara, SwJLanguageToo
   }
 
   private List<AnalyzedSentence> createAnalyzedParagraph(int nFPara, String paraText, SwJLanguageTool lt) throws IOException {
-    List<AnalyzedSentence> analyzedParagraph = lt.analyzeText(paraText);
+    List<AnalyzedSentence> analyzedParagraph = lt.analyzeText(paraText.replace("\u00AD", ""));
     putAnalyzedParagraph(nFPara, analyzedParagraph);
     return analyzedParagraph;
   }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/OfficeTools.java
Patch:
@@ -110,6 +110,7 @@ public enum LoErrorType {
   public static final String MULTILINGUAL_LABEL = "99-";  // Label added in front of variant to indicate a multilingual paragraph (returned is the main language)
   public static final int CHECK_MULTIPLIKATOR = 40;       //  Number of minimum checks for a first check run
   public static final int CHECK_SHAPES_TIME = 1000;       //  time interval to run check for changes in text inside of shapes
+  public static final int SPELL_CHECK_MIN_HEAP = 850;     //  Minimal heap space to run LT spell check
   public static int TIME_TOLERANCE = 100;                 //  Minimal milliseconds to show message in TM debug mode
   
   public static int DEBUG_MODE_SD = 0;            //  Set Debug Mode for SingleDocument

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleCheck.java
Patch:
@@ -864,7 +864,7 @@ static String removeFootnotes(String paraText, int[] footnotes, List<Integer> de
    * Correct SingleProofreadingError by footnote positions
    * footnotes before is the sum of all footnotes before the checked paragraph
    */
-  private static SingleProofreadingError correctRuleMatchWithFootnotes(SingleProofreadingError pError, int[] footnotes, List<Integer> deletedChars) {
+  protected static SingleProofreadingError correctRuleMatchWithFootnotes(SingleProofreadingError pError, int[] footnotes, List<Integer> deletedChars) {
     if (deletedChars == null || deletedChars.isEmpty()) {
       if (footnotes == null || footnotes.length == 0) {
         return pError;

File: languagetool-standalone/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -510,6 +510,7 @@ public void testIgnoringEnglishWordsInCatalan() throws IOException {
     assertEquals(1, matches.size());
     matches = lt.check("My son is tall.");
     assertEquals(0, matches.size());
-
+    matches = lt.check("The event was successful.");
+    assertEquals(0, matches.size());
   }
 }

File: languagetool-core/src/main/java/org/languagetool/rules/GenericUnpairedQuotesRule.java
Patch:
@@ -27,7 +27,7 @@
 import java.util.regex.Pattern;
 
 /**
- * Rule that finds unpaired quotes, brackets etc.
+ * Rule that finds unpaired quotes
  * 
  * @author Fred Kruse
  * @since 6.4

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -143,6 +143,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
                     Example.fixed("Die Partei<marker>,</marker> die die letzte Wahl gewann."),
                     Tools.getUrl("https://languagetool.org/insights/de/beitrag/grammatik-leerzeichen/#fehler-1-leerzeichen-vor-und-nach-satzzeichen")),
             new GermanUnpairedBracketsRule(messages, this),
+            new GermanUnpairedQuotesRule(messages, this),
             new UppercaseSentenceStartRule(messages, this,
                     Example.wrong("Das Haus ist alt. <marker>es</marker> wurde 1950 gebaut."),
                     Example.fixed("Das Haus ist alt. <marker>Es</marker> wurde 1950 gebaut."),

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -192,6 +192,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
         new ConsistentApostrophesRule(messages),
         new EnglishSpecificCaseRule(messages),
         new EnglishUnpairedBracketsRule(messages, this),
+        new EnglishUnpairedQuotesRule(messages, this),
         new EnglishWordRepeatRule(messages, this),
         new AvsAnRule(messages),
         new EnglishWordRepeatBeginningRule(messages, this),

File: languagetool-language-modules/en/src/test/java/org/languagetool/DynamicMorfologikLanguageTest.java
Patch:
@@ -27,12 +27,13 @@
 public class DynamicMorfologikLanguageTest {
 
   // in English package as DynamicMorfologikLanguage needs the English messages
-  @Test
+  //FIXME: It fails on Windows
+  /*@Test
   public void test() throws IOException {
     URL url = JLanguageTool.getDataBroker().getFromResourceDirAsUrl("/en/hunspell/en_US.dict");
     DynamicMorfologikLanguage lang = new DynamicMorfologikLanguage("Testlang", "zz", new File(url.getFile()));
     JLanguageTool lt = new JLanguageTool(lang);
     lt.check("test");  // just make sure we don't crash
-  }
+  }*/
 
 }

File: languagetool-language-modules/pt/src/test/java/org/languagetool/tokenizers/pt/PortugueseWordTokenizerTest.java
Patch:
@@ -77,6 +77,9 @@ public void testTokeniseHyphenatedSplitRegardlessOfLetterCase() {
     testTokenise("Jiu-jitsu", "Jiu-jitsu");
     testTokenise("JIU-JITSU", "JIU-JITSU");
     testTokenise("Jiu-Jitsu", "Jiu-Jitsu");
+    testTokenise("franco-prussiano", "franco-prussiano");
+    testTokenise("Franco-prussiano", "Franco-prussiano");
+    testTokenise("Franco-Prussiano", "Franco-Prussiano");
   }
 
   @Test

File: languagetool-server/src/main/java/org/languagetool/server/V2TextChecker.java
Patch:
@@ -60,7 +60,7 @@ class V2TextChecker extends TextChecker {
 
   private void loadConfidenceMap() throws IOException {
     if (config.getRuleIdToConfidenceFile() != null) {
-      logger.info("Loading confidence map for rules from " + ruleIdToConfidence);
+      logger.info("Loading confidence map for rules from " + config.getRuleIdToConfidenceFile());
       List<String> lines = Files.readAllLines(Paths.get(config.getRuleIdToConfidenceFile().getAbsolutePath()), UTF_8);
       for (String line : lines) {
         if (line.startsWith("#")) {

File: languagetool-language-modules/nl/src/main/java/org/languagetool/rules/nl/CompoundAcceptor.java
Patch:
@@ -97,7 +97,7 @@ boolean acceptCompound(String word) {
       String part1 = word.substring(0, i);
       String part2 = word.substring(i);
       if (!part1.equals(part2) && acceptCompound(part1, part2)) {
-        System.out.println(part1+part2 + " -> accepted");
+        //System.out.println(part1+part2 + " -> accepted");
         return true;
       }
     }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -1345,11 +1345,11 @@ public List<Integer> getFlatParagraphDeletedCharacters(int n) {
   /**
    * get deleted characters (report changes) of Flat Paragraph by Index
    */
-  public boolean isAutomaticGenerated(int n) {
+  public boolean isAutomaticGenerated(int n, boolean alsoIgnore) {
     rwLock.readLock().lock();
     try {
       if (n >= 0 && n < toTextMapping.size()) {
-        if (locales.get(n).Language.equals(OfficeTools.IGNORE_LANGUAGE)) {
+        if (alsoIgnore && locales.get(n).Language.equals(OfficeTools.IGNORE_LANGUAGE)) {
           return true;
         }
         TextParagraph tPara = toTextMapping.get(n);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleCheck.java
Patch:
@@ -187,7 +187,7 @@ public void addParaErrorsToCache(int nFPara, SwJLanguageTool lt, int cacheNum, i
       return;
     }
     DocumentCache docCache = new DocumentCache(this.docCache);
-    if (debugMode > 0 && lt == null && !docCache.isAutomaticGenerated(nFPara)) {
+    if (debugMode > 0 && lt == null && !docCache.isAutomaticGenerated(nFPara, true)) {
       MessageHandler.printToLogFile("SingleCheck: addParaErrorsToCache: return: lt is null");
     }
     try {
@@ -222,7 +222,7 @@ public void addParaErrorsToCache(int nFPara, SwJLanguageTool lt, int cacheNum, i
       //  NOTE: lt == null if language is not supported by LT
       //        but empty proof reading errors have added to cache to satisfy text level queue
       if (lt != null && mDocHandler.isSortedRuleForIndex(cacheNum)) {
-        if (!docCache.isAutomaticGenerated(nFPara)) {
+        if (!docCache.isAutomaticGenerated(nFPara, true)) {
           int startText = docCache.getStartOfParaCheck(tPara, parasToCheck, checkOnlyParagraph, useQueue, true);
           int endText = docCache.getEndOfParaCheck(tPara, parasToCheck, checkOnlyParagraph, useQueue, true);
           paragraphMatches = lt.check(new TextParagraph(tPara.type, startText), new TextParagraph(tPara.type, endText), textToCheck,
@@ -568,7 +568,7 @@ public SingleProofreadingError[] checkParaRules(String paraText, Locale locale,
         }
         List<Integer> nextSentencePositions = getNextSentencePositions(paraText, mLt);
         List<Integer> deletedChars = isTextParagraph ? docCache.getFlatParagraphDeletedCharacters(nFPara): null;
-        if (mLt == null || (nFPara >= 0 && docCache != null && docCache.isAutomaticGenerated(nFPara))) {
+        if (mLt == null || (nFPara >= 0 && docCache != null && docCache.isAutomaticGenerated(nFPara, true))) {
           paragraphMatches = null;
         } else {
           paraText = removeFootnotes(paraText, footnotePos, deletedChars);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -338,6 +338,9 @@ ProofreadingResult getCheckResults(String paraText, Locale locale, ProofreadingR
             proofInfo, numParasToCheck, fixedLanguage, docLanguage, this, paragraphsCache, changedParas, runningParas);
         paraNum = requestAnalysis.getNumberOfParagraph(nPara, paraText, locale, paRes.nStartOfSentencePosition, footnotePositions);
       }
+      if (docCache.isAutomaticGenerated(paraNum, true)) {
+        return paRes;
+      }
       if (debugModeTm) {
         long runTime = System.currentTimeMillis() - startTime;
         if (runTime > OfficeTools.TIME_TOLERANCE) {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/TextLevelCheckQueue.java
Patch:
@@ -252,7 +252,7 @@ Language getLanguage(String docId, TextParagraph nStart) {
     if (document != null) {
       docCache = document.getDocumentCache();
       if (docCache != null && nStart.number < docCache.textSize(nStart)) {
-        if (docCache.isAutomaticGenerated(docCache.getFlatParagraphNumber(nStart))) {
+        if (docCache.isAutomaticGenerated(docCache.getFlatParagraphNumber(nStart), true)) {
           return null;
         }
         Locale locale = docCache.getTextParagraphLocale(nStart);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/OfficeTools.java
Patch:
@@ -92,6 +92,7 @@ public enum LoErrorType {
     
   public static final String EXTENSION_MAINTAINER = "Fred Kruse";
   public static final String LT_SERVICE_NAME = "org.languagetool.openoffice.Main";
+  public static final String LT_SPELL_SERVICE_NAME = "org.languagetool.openoffice.LanguageToolSpellChecker";
   public static final int PROOFINFO_UNKNOWN = 0;
   public static final int PROOFINFO_GET_PROOFRESULT = 1;
   public static final int PROOFINFO_MARK_PARAGRAPH = 2;
@@ -564,7 +565,7 @@ public static File getCacheDir(XComponentContext xContext) {
     return cacheDir;
   }
   
-  private static double getMaxHeapSpace() {
+  public static double getMaxHeapSpace() {
     if(MAX_HEAP_SPACE < 0) {
       MAX_HEAP_SPACE = Runtime.getRuntime().maxMemory();
     }

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tagging/fr/FrenchTagger.java
Patch:
@@ -116,6 +116,7 @@ private List<AnalyzedToken> tagWord(String word, String originalWord) {
     final boolean isStartUpper = StringTools.isCapitalizedWord(word);
     final boolean isAllUpper = StringTools.isAllUppercase(word);
     final boolean isHyphenatedTitleCase = !originalWord.equals("-Le") && !originalWord.equals("-Les") &&
+      !originalWord.equals("-Ce") &&
       originalWord.contains("-") && originalWord.equals(StringTools.convertToTitleCaseIteratingChars(lowerWord));
     List<AnalyzedToken> taggerTokens = asAnalyzedTokenListForTaggedWords(originalWord, getWordTagger().tag(word));
     // normal case:

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tagging/fr/FrenchTagger.java
Patch:
@@ -115,7 +115,7 @@ private List<AnalyzedToken> tagWord(String word, String originalWord) {
     final String lowerWord = word.toLowerCase(locale);
     final boolean isStartUpper = StringTools.isCapitalizedWord(word);
     final boolean isAllUpper = StringTools.isAllUppercase(word);
-    final boolean isHyphenatedTitleCase = !originalWord.equals("-Le") &&
+    final boolean isHyphenatedTitleCase = !originalWord.equals("-Le") && !originalWord.equals("-Les") &&
       originalWord.contains("-") && originalWord.equals(StringTools.convertToTitleCaseIteratingChars(lowerWord));
     List<AnalyzedToken> taggerTokens = asAnalyzedTokenListForTaggedWords(originalWord, getWordTagger().tag(word));
     // normal case:

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tagging/fr/FrenchTagger.java
Patch:
@@ -115,7 +115,7 @@ private List<AnalyzedToken> tagWord(String word, String originalWord) {
     final String lowerWord = word.toLowerCase(locale);
     final boolean isStartUpper = StringTools.isCapitalizedWord(word);
     final boolean isAllUpper = StringTools.isAllUppercase(word);
-    final boolean isHyphenatedTitleCase =
+    final boolean isHyphenatedTitleCase = !originalWord.equals("-Le") &&
       originalWord.contains("-") && originalWord.equals(StringTools.convertToTitleCaseIteratingChars(lowerWord));
     List<AnalyzedToken> taggerTokens = asAnalyzedTokenListForTaggedWords(originalWord, getWordTagger().tag(word));
     // normal case:

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/MorfologikUkrainianSpellerRule.java
Patch:
@@ -73,7 +73,7 @@ public String getId() {
   protected List<RuleMatch> getRuleMatches(String word, int startPos, AnalyzedSentence sentence,
       List<RuleMatch> ruleMatchesSoFar, int idx, AnalyzedTokenReadings[] tokens) throws IOException {
     List<RuleMatch> ruleMatches = super.getRuleMatches(word, startPos, sentence, ruleMatchesSoFar, idx, tokens);
-    
+
     // disambig may remove v_kly leaving token with no good tags
     if( ruleMatches.isEmpty() && ! hasGoodTag(tokens[idx]) ) {
       ruleMatches.add(new RuleMatch(this, sentence, startPos, startPos+word.length(), startPos, startPos+word.length(), 
@@ -153,9 +153,9 @@ private static boolean hasGoodTag(AnalyzedTokenReadings tokens) {
       String posTag = analyzedToken.getPOSTag();
       if( posTag != null 
             && ! posTag.equals(JLanguageTool.SENTENCE_END_TAGNAME) 
-            && ! posTag.equals(JLanguageTool.PARAGRAPH_END_TAGNAME) 
+            && ! posTag.equals(JLanguageTool.PARAGRAPH_END_TAGNAME) ) 
 //            && (! posTag.contains(IPOSTag.bad.getText()) || posTag.contains(":latin"))  
-            && ! (posTag.contains(":inanim") && posTag.contains(":v_kly")) )
+//            && ! (posTag.contains(":inanim") && posTag.contains(":v_kly")) )
         return true;
     }
     return false;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/MorfologikCatalanSpellerRule.java
Patch:
@@ -309,6 +309,9 @@ private String findSuggestionMultiplePronouns(String suggestion, String word) {
     if (matchPostagRegexp(newatr, VERB_INFGERIMP)) {
       return verb + PronomsFeblesHelper.transformDarrere(pronouns, verb);
     }
+    if (verb.length() < 6) {
+      return "";
+    }
     if (lcword.startsWith("d") || lcword.startsWith("l")) {
       verb = verb.substring(1, verb.length());
       newatr = tagger.tag(Arrays.asList(verb)).get(0);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LtSpellChecker.java
Patch:
@@ -173,7 +173,7 @@ public boolean isValid(String word, Locale locale, PropertyValue[] Properties) t
         return false;
       }
 //      MessageHandler.printToLogFile("LanguageToolSpellChecker: isValid: check word: " + (word == null ? "null" : word));
-      if (word == null || word.isBlank() || word.contains("==")) {
+      if (word == null || word.trim().isEmpty() || word.contains("==")) {
 //        MessageHandler.printToLogFile("LtSpellChecker: isValid: Problematic word found: " + (word == null ? "null" : word));
         return false;
       }
@@ -289,7 +289,7 @@ class LTSpellAlternatives implements XSpellAlternatives {
           return;
         }
         String localeStr = OfficeTools.localeToString(locale);
-        if (word == null || word.isBlank() || localeStr == null || localeStr.isEmpty()) {
+        if (word == null || word.trim().isEmpty() || localeStr == null || localeStr.isEmpty()) {
           alternatives = new String[0];
           return;
         }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRuleAntiPatterns1.java
Patch:
@@ -899,6 +899,7 @@ class AgreementRuleAntiPatterns1 {
     ),
     asList(
       // In einer entzückend chaotischen Partie zwischen A und B kam es zum Unentschieden.
+      posRegex("ART.*"),
       posRegex("VER:PA[12]"),
       posRegex("ADJ.*"),
       posRegex("SUB.*")

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -155,6 +155,8 @@ public GermanCompoundTokenizer(boolean strictMode) throws IOException {
     wordSplitter.addException("Festigung", asList("Festigung"));
     wordSplitter.addException("Allerheiligen", asList("Allerheiligen"));
     wordSplitter.addException("Druckerpressen", asList("Drucker", "pressen"));
+    wordSplitter.addException("Habitat", asList("Habitat"));
+    wordSplitter.addException("Damast", asList("Damast"));
   }
 
   @Override

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/AvsAnRuleTest.java
Patch:
@@ -44,6 +44,7 @@ public void setUp() throws IOException {
   public void testRule() throws IOException {
 
     // correct sentences:
+    assertCorrect("Import an Xcode project.");
     assertCorrect("This is a oncer.");
     assertCorrect("She was a Oaxacan chef.");
     assertCorrect("The doctor requested a urinalysis.");

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/AvsAnRuleTest.java
Patch:
@@ -44,6 +44,7 @@ public void setUp() throws IOException {
   public void testRule() throws IOException {
 
     // correct sentences:
+    assertCorrect("Import an Xcode project.");
     assertCorrect("This is a oncer.");
     assertCorrect("She was a Oaxacan chef.");
     assertCorrect("The doctor requested a urinalysis.");

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -528,7 +528,7 @@ public Language getLanguage() {
       return docLanguage;
     }
     Language lang = MultiDocumentsHandler.getLanguage(locale);
-    if (!lang.equals(docLanguage)) {
+    if (lang != null && !lang.equals(docLanguage)) {
       docLanguage = lang;
     }
     return docLanguage;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tokenizers/ca/CatalanWordTokenizer.java
Patch:
@@ -39,7 +39,7 @@
  */
 public class CatalanWordTokenizer extends WordTokenizer {
 
-  private static final String wordCharacters = "§©#@€£\\$_\\p{L}\\d·\\-\u0300-\u036F\u00A8\u2070-\u209F°%‰‱&\uFFFD\u00AD";
+  private static final String wordCharacters = "§©#@€£\\$_\\p{L}\\d·\\-\u0300-\u036F\u00A8\u2070-\u209F°%‰‱&\uFFFD\u00AD\u00AC";
   private static final Pattern tokenizerPattern = Pattern.compile("[" + wordCharacters + "]+|[^" + wordCharacters + "]");
   //all possible forms of "pronoms febles" after a verb.
   private static final String PF = "(['’]en|['’]hi|['’]ho|['’]l|['’]ls|['’]m|['’]n|['’]ns|['’]s|['’]t|-el|-els|-em|-en|-ens|-hi|-ho|-l|-la|-les|-li|-lo|-los|-m|-me|-n|-ne|-nos|-s|-se|-t|-te|-us|-vos)";

File: languagetool-language-modules/es/src/main/java/org/languagetool/tokenizers/es/SpanishWordTokenizer.java
Patch:
@@ -36,7 +36,7 @@
  */
 public class SpanishWordTokenizer extends WordTokenizer {
 
-  private static final String wordCharacters = "§©#@€£\\$_\\p{L}\\d·\\-\u0300-\u036F\u00A8\u2070-\u209F°%‰‱&\uFFFD\u00AD";
+  private static final String wordCharacters = "§©#@€£\\$_\\p{L}\\d·\\-\u0300-\u036F\u00A8\u2070-\u209F°%‰‱&\uFFFD\u00AD\u00AC";
   private static final Pattern tokenizerPattern = Pattern.compile("[" + wordCharacters + "]+|[^" + wordCharacters + "]");
   //decimal point between digits
   private static final Pattern DECIMAL_POINT= Pattern.compile("([\\d])\\.([\\d])",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tokenizers/ca/CatalanWordTokenizer.java
Patch:
@@ -159,7 +159,7 @@ public List<String> tokenize(final String text) {
     String groupStr;
     while (tokenizerMatcher.find()) {
       s = tokenizerMatcher.group();
-      if (s.length() == 1 && s.codePointAt(0)>=0xFE00 && s.codePointAt(0)<=0xFE0F) {
+      if (l.size() > 0 && s.length() == 1 && s.codePointAt(0)>=0xFE00 && s.codePointAt(0)<=0xFE0F) {
         l.set(l.size() - 1, l.get(l.size() - 1) + s);
         continue;
       }

File: languagetool-language-modules/es/src/main/java/org/languagetool/tokenizers/es/SpanishWordTokenizer.java
Patch:
@@ -64,7 +64,7 @@ public List<String> tokenize(final String text) {
     String s;
     while (tokenizerMatcher.find()) {
       s = tokenizerMatcher.group();
-      if (s.length() == 1 && s.codePointAt(0)>=0xFE00 && s.codePointAt(0)<=0xFE0F) {
+      if (l.size() > 0 && s.length() == 1 && s.codePointAt(0)>=0xFE00 && s.codePointAt(0)<=0xFE0F) {
         l.set(l.size() - 1, l.get(l.size() - 1) + s);
         continue;
       }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/CatalanWordRepeatRule.java
Patch:
@@ -40,7 +40,8 @@ public String getId() {
 
   @Override
   public boolean ignore(AnalyzedTokenReadings[] tokens, int position) {
-    if (position > 0 && (tokens[position].hasPosTag("_allow_repeat") || tokens[position-1].hasPosTag("_allow_repeat"))) {
+    if (position > 0 && (tokens[position].hasPosTag("_allow_repeat") || tokens[position-1].hasPosTag("_allow_repeat")
+    || tokens[position].hasPosTag("LOC_ADV"))) {
       return true;
     }
     return super.ignore(tokens, position);

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/CatalanWordRepeatRuleTest.java
Patch:
@@ -64,7 +64,8 @@ public void testRule() throws IOException {
     assertEquals(0, matches.length);
     matches = rule.match(lt.getAnalyzedSentence("HUCHA-GANGA.ES es presenta."));
     assertEquals(0, matches.length);
-
+    matches = rule.match(lt.getAnalyzedSentence("Ja fa, arreu arreu, més de quaranta anys."));
+    assertEquals(0, matches.length);
     matches = rule.match(lt.getAnalyzedSentence("obrim inscripcions\uD83D\uDC4D\uD83D\uDC9A\uD83C\uDF32\uD83C\uDF32"));
     assertEquals(0, matches.length);
         

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRuleAntiPatterns.java
Patch:
@@ -1359,7 +1359,7 @@ class CaseRuleAntiPatterns {
       csRegex("[a-zäöü…\\.!:;,\\?…\\)].*")
     ),
     Arrays.asList( // Ich habe noch Dringendes mitzuteilen
-      csRegex("Dringende[ms]|Bare[ms]|Vertraute[ms]|Positive[sm]|Negative[sm]|Gelernte[ms]|Neue[ms]|Alte[ms]|Bessere[ms]|Störende[ms]|Schlechteres|Schlechte[ms]|Schöne[ms]|Schönere[ms]|Schlimmere[ms]|Zutreffendes|Unzutreffende[ms]|Gesehene[ms]|Ungesehene[ms]|Abgerissene[ms]|Versoffenes|Empfehlenswerte[ms]|Entnommene[ms]|Sü(ß|ss)e[ms]|Saure[ms]|Wesentliche[ms]|Gegenteilige[ms]|Wegweisende[ms]|Hochprozentige[ms]|Erlernte[ms]|Vergangene[ms]|Unglaubliche[ms]|Schlimme[ms]|Eingemachte[ms]|Rare[ms]|Brauchbare[ms]|Unbrauchbare[ms]|Gesehene[ms]|Erlebte[ms]|Private[ms]|Berufliche[ms]|Ungeheuerliche[ms]|Vegane[ms]|Vegetarische[ms]|Eingemachte[ms]|Erwünschte[ms]|Äu(ß|ss)erste[ms]|Äu(ß|ss)ere[ms]|Inhaltliche[ms]|Vernichtende[ms]|Salzige[ms]|Sü(ß|ss)e[ms]|Selbstgemachte[ms]|Inhaltliche[ms]|Au(ß|ss)erordentliche[ms]|Säuerliche[ms]|Göttliche[ms]||Hochprozentige[sm]|Erbrochene[ms]|Innere[mns]|Vorhandene[ms]|Relevante[ms]|Geübte[ms]|Unmögliche[ms]|Mögliche[ms]|Näheres|Wissenswerte[ms]|Fundamentale[ms]|Interessante[ms]|Uninteressante[ms]|Entsetzliche[ms]|Hartnäckige[ms]|Ersparte[ms]|Halbgare[ms]|Universale[ms]|Finanzielle[ms]|Überraschendes|Grundlegendes|Gesunde[ms]|Ungesunde[ms]|Tagesaktuelle[ms]|Aktuelle[ms]|Geschehene[ms]|Ungeschehene[ms]|Böse[ms]|Gesagte[ms]|Aufregende[sm]|Ausgestelltes|Verschiedenes|Verborgenes|Soziale[ms]|Erfundenes|Gro(ß|ss)es|Neueres|Au(ß|ss)ergewöhnliche[ms]|Zukunftsfähige[sm]|Administrative[ms]|Beunruhigendes|Naturverträgliches|Nachhaltiges|Verderbliche[ms]|Sinnstiftendes|Unüberlegtes|Alltägliche[sm]|Geartetes?|Allgemeines?|Übernatürliches?|Juristisches?|Rechtliches?|Vielfältiges?|Kommunales|Wundervolles?|Abgelaufenes|Erstere[ms]|Zweitere[ms]|Letztere[ms]|Unvermeidliches?|Fressbares?|Essbares?|Erbrochene[sm]|Politische[sm]|Regionale[sm]|Recherchiertes|Höheres|Kleineres|Deftiges|Liebes|Grünes|Diverses|Machbare[ms]|Nachweisbare[ms]|Zerstörtes|Öffentliches|Produktives|Entbehrliches|Notwendiges|Sinnvolle[ms]|Bewährte[ms]|Nötiges|Erfreuliches|Frustrierendes|Vorübergehendes|Untaugliches|Rohes|Nettes|Blödes|Unerwartetes|Lesenswerte[ms]|Geplantes|Ungeplantes|Redaktionelles|Spezielle[ms]|Spezifische[ms]|Staatstragendes|Organisatorisches|Übersehenes|Altbewährte[ms]|Erstaunliches|Verdächtiges|Au(ß|ss)ergewöhnliches|Ungewöhnliches|Unerreichbare[ms]|Bezahltes|Unbezahltes|Beschämendes|Grundsätzliche[sm]|Freiheitliches|Übrige[ms]|Ähnliche[ms]|Letztgenannte[ms]|Echtes|Unechtes|Gro(ß|ss)artige[ms]|Esoterisches|Qualifizierte[ms]|Unqualifizierte[ms]|Grö(ß|ss)eres|Postmodernes|Unklares|Bezahlbares|Unbezahlbares|Gemischte[ms]|Gebündelte[ms]|Lebendige[ms]|Angenommenes|Zeitgenössisches|Geistliches|Elementare[ms]|Bitteres|Äu(ß|ss)erliches|Spannendes|Kurioses|Digitale[ms]|Hervorgebrachte[ms]|Gewirktes|Altbekannte[ms]|Gehackte[sm]|Gewordenes|Erkennbares|Verstörende[sm]|Versaute[ms]|Nachdenkliches|Bestehendes|Beobachtetes|Originelle[ms]|Derartige[sm]|Schriftliches|Mündliches|Verblühte[ms]|Faszinierende[ms]|Christliches|Gute[ms]|Böse[ms]||Folgende[ms]|Letztere[ms]|Erstere[ms]|Schreckliche[ms]|Falsche[sm]|Richtige[ms]|Hässliche[sm]|Auswärtige[ms]|Nervige[ms]|Ätzende[ms]|Kleine[ms]|Gro(ß|ss)e[ms]|Riskante[ms]|Li?ebenswerte[ms]|Materielle[ms]|Geglaubte[sm]|Ausgedachte[sm]|Unsagbare[sm]?|Unverwechselbare[sm]?|[A-Z].{1,20}rechtliche[ms]?"),
+      csRegex("Dringende[ms]|Bare[ms]|Vertraute[ms]|Positive[sm]|Negative[sm]|Gelernte[ms]|Neue[ms]|Alte[ms]|Bessere[ms]|Störende[ms]|Schlechteres|Schlechte[ms]|Schöne[ms]|Schönere[ms]|Schlimmere[ms]|Zutreffendes|Unzutreffende[ms]|Gesehene[ms]|Ungesehene[ms]|Abgerissene[ms]|Versoffenes|Empfehlenswerte[ms]|Entnommene[ms]|Sü(ß|ss)e[ms]|Saure[ms]|Wesentliche[ms]|Gegenteilige[ms]|Wegweisende[ms]|Hochprozentige[ms]|Erlernte[ms]|Vergangene[ms]|Unglaubliche[ms]|Schlimme[ms]|Eingemachte[ms]|Rare[ms]|Brauchbare[ms]|Unbrauchbare[ms]|Gesehene[ms]|Erlebte[ms]|Private[ms]|Berufliche[ms]|Ungeheuerliche[ms]|Vegane[ms]|Vegetarische[ms]|Eingemachte[ms]|Erwünschte[ms]|Äu(ß|ss)erste[ms]|Äu(ß|ss)ere[ms]|Inhaltliche[ms]|Vernichtende[ms]|Salzige[ms]|Sü(ß|ss)e[ms]|Selbstgemachte[ms]|Inhaltliche[ms]|Au(ß|ss)erordentliche[ms]|Säuerliche[ms]|Göttliche[ms]||Hochprozentige[sm]|Erbrochene[ms]|Innere[mns]|Vorhandene[ms]|Relevante[ms]|Geübte[ms]|Unmögliche[ms]|Mögliche[ms]|Näheres|Wissenswerte[ms]|Fundamentale[ms]|Interessante[ms]|Uninteressante[ms]|Entsetzliche[ms]|Hartnäckige[ms]|Ersparte[ms]|Halbgare[ms]|Universale[ms]|Finanzielle[ms]|Überraschendes|Grundlegendes|Gesunde[ms]|Ungesunde[ms]|Tagesaktuelle[ms]|Aktuelle[ms]|Geschehene[ms]|Ungeschehene[ms]|Böse[ms]|Gesagte[ms]|Aufregende[sm]|Ausgestelltes|Verschiedenes|Verborgenes|Soziale[ms]|Erfundenes|Gro(ß|ss)es|Neueres|Au(ß|ss)ergewöhnliche[ms]|Zukunftsfähige[sm]|Administrative[ms]|Beunruhigendes|Naturverträgliches|Nachhaltiges|Verderbliche[ms]|Sinnstiftendes|Unüberlegtes|Alltägliche[sm]|Geartetes?|Allgemeines?|Übernatürliches?|Juristisches?|Rechtliches?|Vielfältiges?|Kommunales|Wundervolles?|Abgelaufenes|Erstere[ms]|Zweitere[ms]|Letztere[ms]|Unvermeidliches?|Fressbares?|Essbares?|Erbrochene[sm]|Politische[sm]|Regionale[sm]|Recherchiertes|Höheres|Kleineres|Deftiges|Liebes|Grünes|Diverses|Machbare[ms]|Nachweisbare[ms]|Zerstörtes|Öffentliches|Produktives|Entbehrliches|Notwendiges|Sinnvolle[ms]|Bewährte[ms]|Nötiges|Erfreuliches|Frustrierendes|Vorübergehendes|Untaugliches|Rohes|Nettes|Blödes|Unerwartetes|Lesenswerte[ms]|Geplantes|Ungeplantes|Redaktionelles|Spezielle[ms]|Spezifische[ms]|Staatstragendes|Organisatorisches|Übersehenes|Altbewährte[ms]|Erstaunliches|Verdächtiges|Au(ß|ss)ergewöhnliches|Ungewöhnliches|Unerreichbare[ms]|Bezahltes|Unbezahltes|Beschämendes|Grundsätzliche[sm]|Freiheitliches|Übrige[ms]|Ähnliche[ms]|Letztgenannte[ms]|Echtes|Unechtes|Gro(ß|ss)artige[ms]|Esoterisches|Qualifizierte[ms]|Unqualifizierte[ms]|Grö(ß|ss)eres|Postmodernes|Unklares|Bezahlbares|Unbezahlbares|Gemischte[ms]|Gebündelte[ms]|Lebendige[ms]|Angenommenes|Zeitgenössisches|Geistliches|Elementare[ms]|Bitteres|Äu(ß|ss)erliches|Spannendes|Kurioses|Digitale[ms]|Hervorgebrachte[ms]|Gewirktes|Altbekannte[ms]|Gehackte[sm]|Gewordenes|Erkennbares|Verstörende[sm]|Versaute[ms]|Nachdenkliches|Bestehendes|Beobachtetes|Originelle[ms]|Derartige[sm]|Schriftliches|Mündliches|Verblühte[ms]|Faszinierende[ms]|Christliches|Gute[ms]|Böse[ms]||Folgende[ms]|Letztere[ms]|Erstere[ms]|Schreckliche[ms]|Falsche[sm]|Richtige[ms]|Hässliche[sm]|Auswärtige[ms]|Nervige[ms]|Ätzende[ms]|Kleine[ms]|Gro(ß|ss)e[ms]|Riskante[ms]|Li?ebenswerte[ms]|Materielle[ms]|Geglaubte[sm]|Ausgedachte[sm]|Unsagbare[sm]?|Unverwechselbare[sm]?|[A-Z].{1,20}rechtliche[ms]?|Umfassendere[ms]"),
       csRegex("(?!(und|oder))[a-zäöü…\\.!,\\?…\\)“„\"»«–\\-:;\\[\\]].*")
     ),
     Arrays.asList(
@@ -1390,7 +1390,7 @@ class CaseRuleAntiPatterns {
       token(".")
     ),
     Arrays.asList( // Immer mehr Ältere erkranken daran
-      csRegex("Ältere[rn]?|Jüngere[rn]?|Zuschauende[rn]?|Angeklagte[rn]?|Referierende[rn]?|Schlafenden?|Moderierende[rn]?|Dunkelhäutige[rn]?|Verantwortliche[rn]?|Alleinlebende[rn]?|Verdammten?|Alleinstehende[rn]?|Ungeübte[rn]?|Au(ß|ss)erirdische[rn]?|Berittene[rn]?|Heranwachsende[rn]?|Ganze[sn]?|Gefangene[rn]?|Steuerpflichtige[rn]?|Geschädigte[rn]?|Heimatvertriebenen?|Schwerverletzte[rn]?|Werbenden?|Au(ß|ss)enstehenden?|Forschenden?|Prominenten?|Pflegenden?|Beklagten?|Geistlichen?|Pflegebedürftigen?|(Teil|Voll)zeitbeschäftigten?|Fortgeschrittenen?|Promovierenden?|Schreibenden?|Ungeimpfte[nr]?|Geimpfte[nr]?|Tatverdächtige[nr]?|Pubertären?|Flüchtende[nr]?|Vortragende[nr]?|Besuchenden?|Vortragenden?|Verantwortliche[rn]?|Geflohene[rn]?|Sterbende[nr]?|Werbende[nr]?|Vortragende[nr]?|Alliierte[nr]?|Bedürftige[rn]?|Praktizierenden?|Geisteskranke[nr]?|Religiöse[rn]?|Kleinsten?|Dauerarbeitslose[rn]|Angesteckten?|Ortskundigen?|Steuerpflichtige[rn]?|Vorbehandelnden?|Gefährdeten?|Eingemachte|Geübten?|Schwimmenden?|Tauchenden?|Anständigen?|Liebenden?|Volljährigen?|Minderjährigen?|Zeichnungsberechtigte[rn]?|Zeichnungsbefugte[rn]?|Altbekannte[nmr]?|Hartnäckigen?|Unerfahrenen?|Arbeitenden?|Vortragende[nr]?|Dummen?|Fragenden?|Antwortenden?|Kriegs[gb]eschädigten?|Begünstigten?|Verfolgten?|Verwitweten?|Geschiedenen?|Asexuellen?|Liebsten?|(Rechts|Links)extremen?|(Aus|Ein)geschlossenen?|Betuchten?|Anteilnehmende[rn]?|Anbietenden?|Hochbetagten?|Seelenverwandte[nr]?|Gleichgestellten?|Gottlosen?|Inhaftierten?|Protestierenden?|Wohnungssuchenden?|Lesenden?|Schreibenden?|Beitragenden?|Superreichen?|Au(ß|ss)enstehenden?|Juryvorsitzende[rn]?|Introvertierten?|Extrovertierten?|.+begeisterten?|(Schwer|Seh)behinderten?|Unbekannten?|Anwesenden?|Personalverantwortlichen?|[NF]rühgeborenen?|Hörgeschädigten?|Gehorsamen?|Ungehorsamen?|Suchtkranken?|Bildbetrachtenden?|Uniformierten?|Bediensteten?|Gesetzlosen?|Vermummten?|(Schwer|Leicht)verletzten?|Untoten?|Hübschen?|Reisende[rn]?|Abtrünnigen?|Liebende[nr]?|Befehlenden?|Pubertierende[rn]?|Lebenden?|Geistliche[rn]?|Klassenbeste[rn]?|Totgesagte[rn]?|Zivildienstleistende[rn]?|Nutzenden?|Kunstinteressierte[rn]?|Nachtaktive[nr]?|Bewerbenden?|Geliebter?|Unsterblichen?|Sterblichen?|Evangelikalen?|Gewaltbereiten?|Dozierenden?|Autofahenden?|Impfgeschädigten?|[A-ZÄÖÜ].+stämmigen?|Auszubildende[rn]?|Unnahbaren?|Arbeitgebenden?|Nutzungsberechtigte[nr]?|Interviewte[rn]?|Bewohnenden?|Zugewanderte[rn]?|Eingeweihte[rn]?|Heimatvertriebene[nr]?|Asylberechtigte[rn]?|Erwachte[rn]?|Kulturschaffende[rn]?|Gebärenden?|Beschenkte[rn]?|Ungelernten?|Verbrauchende[rn]?|Schwule[rn]?|Partywütige[rn]?|(Homo|Hetero|Metro|Trans)sexuelle[rn]?|Geduldige[rn]?|Ungeduldige[rn]?|Schneebegeisterte[rn]?|Befindlichen?|Gebietsansässigen?|Erneuerbaren?|Militärinternierte[rn]?|Steuerpflichtige[nr]?|Ungläubige[rn]?|Geduldigen?|Ungeduldigen?|Unerreichbaren?|Schuldige[rn]?|Alleinschuldige[rn]?|Getreuen?|Mitschuldige[rn]?|Auswärtige[rn]?|[A-ZÄÖÜ].+schaffende[rn]|Übergewichtige[rn]?|Schichtarbeitende[rn]?|Unbefugte[rn]?|Nominierte[rn]?|Erholungsuchende[rn]?|Getriebene[rn]?|Vertriebene[rn]?|Unverwechselbaren?|Anständigen?"),
+      csRegex("Ältere[rn]?|Jüngere[rn]?|Zuschauende[rn]?|Angeklagte[rn]?|Referierende[rn]?|Schlafenden?|Moderierende[rn]?|Dunkelhäutige[rn]?|Verantwortliche[rn]?|Alleinlebende[rn]?|Verdammten?|Alleinstehende[rn]?|Ungeübte[rn]?|Au(ß|ss)erirdische[rn]?|Berittene[rn]?|Heranwachsende[rn]?|Ganze[sn]?|Gefangene[rn]?|Steuerpflichtige[rn]?|Geschädigte[rn]?|Heimatvertriebenen?|Schwerverletzte[rn]?|Werbenden?|Au(ß|ss)enstehenden?|Forschenden?|Prominenten?|Pflegenden?|Beklagten?|Geistlichen?|Pflegebedürftigen?|(Teil|Voll)zeitbeschäftigten?|Fortgeschrittenen?|Promovierenden?|Schreibenden?|Ungeimpfte[nr]?|Geimpfte[nr]?|Tatverdächtige[nr]?|Pubertären?|Flüchtende[nr]?|Vortragende[nr]?|Besuchenden?|Vortragenden?|Verantwortliche[rn]?|Geflohene[rn]?|Sterbende[nr]?|Werbende[nr]?|Vortragende[nr]?|Alliierte[nr]?|Bedürftige[rn]?|Praktizierenden?|Geisteskranke[nr]?|Religiöse[rn]?|Kleinsten?|Dauerarbeitslose[rn]|Angesteckten?|Ortskundigen?|Steuerpflichtige[rn]?|Vorbehandelnden?|Gefährdeten?|Eingemachte|Geübten?|Schwimmenden?|Tauchenden?|Anständigen?|Liebenden?|Volljährigen?|Minderjährigen?|Zeichnungsberechtigte[rn]?|Zeichnungsbefugte[rn]?|Altbekannte[nmr]?|Hartnäckigen?|Unerfahrenen?|Arbeitenden?|Vortragende[nr]?|Dummen?|Fragenden?|Antwortenden?|Kriegs[gb]eschädigten?|Begünstigten?|Verfolgten?|Verwitweten?|Geschiedenen?|Asexuellen?|Liebsten?|(Rechts|Links)extremen?|(Aus|Ein)geschlossenen?|Betuchten?|Anteilnehmende[rn]?|Anbietenden?|Hochbetagten?|Seelenverwandte[nr]?|Gleichgestellten?|Gottlosen?|Inhaftierten?|Protestierenden?|Wohnungssuchenden?|Lesenden?|Schreibenden?|Beitragenden?|Superreichen?|Au(ß|ss)enstehenden?|Juryvorsitzende[rn]?|Introvertierten?|Extrovertierten?|.+begeisterten?|(Schwer|Seh)behinderten?|Unbekannten?|Anwesenden?|Personalverantwortlichen?|[NF]rühgeborenen?|Hörgeschädigten?|Gehorsamen?|Ungehorsamen?|Suchtkranken?|Bildbetrachtenden?|Uniformierten?|Bediensteten?|Gesetzlosen?|Vermummten?|(Schwer|Leicht)verletzten?|Untoten?|Hübschen?|Reisende[rn]?|Abtrünnigen?|Liebende[nr]?|Befehlenden?|Pubertierende[rn]?|Lebenden?|Geistliche[rn]?|Klassenbeste[rn]?|Totgesagte[rn]?|Zivildienstleistende[rn]?|Nutzenden?|Kunstinteressierte[rn]?|Nachtaktive[nr]?|Bewerbenden?|Geliebter?|Unsterblichen?|Sterblichen?|Evangelikalen?|Gewaltbereiten?|Dozierenden?|Autofahenden?|Impfgeschädigten?|[A-ZÄÖÜ].+stämmigen?|Auszubildende[rn]?|Unnahbaren?|Arbeitgebenden?|Nutzungsberechtigte[nr]?|Interviewte[rn]?|Bewohnenden?|Zugewanderte[rn]?|Eingeweihte[rn]?|Heimatvertriebene[nr]?|Asylberechtigte[rn]?|Erwachte[rn]?|Kulturschaffende[rn]?|Gebärenden?|Beschenkte[rn]?|Ungelernten?|Verbrauchende[rn]?|Schwule[rn]?|Partywütige[rn]?|(Homo|Hetero|Metro|Trans)sexuelle[rn]?|Geduldige[rn]?|Ungeduldige[rn]?|Schneebegeisterte[rn]?|Befindlichen?|Gebietsansässigen?|Erneuerbaren?|Militärinternierte[rn]?|Steuerpflichtige[nr]?|Ungläubige[rn]?|Geduldigen?|Ungeduldigen?|Unerreichbaren?|Schuldige[rn]?|Alleinschuldige[rn]?|Getreuen?|Mitschuldige[rn]?|Auswärtige[rn]?|[A-ZÄÖÜ].+schaffende[rn]|Übergewichtige[rn]?|Schichtarbeitende[rn]?|Unbefugte[rn]?|Nominierte[rn]?|Erholungsuchende[rn]?|Getriebene[rn]?|Vertriebene[rn]?|Unverwechselbaren?|Anständigen?|Zeitreisende[rn]?"),
       csRegex("(?!(und|oder))[a-zäöü…\\.!:;,\\?…\\)\\*\\(“„\"»«–\\-\\[\\]].*")
     ),
     Arrays.asList(

File: languagetool-language-modules/pt/src/main/java/org/languagetool/tokenizers/pt/PortugueseWordTokenizer.java
Patch:
@@ -127,7 +127,7 @@ public List<String> tokenize(final String text) {
     while (st.hasMoreElements()) {
       String token = st.nextToken();
       // make sure we join the % sign with the previous token, if it ends in a digit
-      if (Objects.equals(token, "%")) {
+      if (Objects.equals(token, "%") && !tokenList.isEmpty()) {
         int lastIndex = tokenList.size() - 1;
         String lastToken = tokenList.get(lastIndex);
         if (lastToken.matches(".*\\d$")) {

File: languagetool-language-modules/pt/src/test/java/org/languagetool/tokenizers/pt/PortugueseWordTokenizerTest.java
Patch:
@@ -124,6 +124,8 @@ public void testTokeniseCurrency() {
   @Test
   public void testTokeniseSplitsPercent() {
     testTokenise("50%OFF", new String[]{"50%", "OFF"});
+    testTokenise("%50", new String[]{"%", "50"});
+    testTokenise("%", new String[]{"%"});
   }
 
   @Test

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/PortarTempsSuggestionsFilter.java
Patch:
@@ -58,7 +58,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     }
     suggestion.append(synthForms[0]);
     int i = posWord + 1;
-    while (tokens[i].getChunkTags().contains(new ChunkTag("PTime"))) {
+    while (i < tokens.length && tokens[i].getChunkTags().contains(new ChunkTag("PTime"))) {
       if (tokens[i].isWhitespaceBefore()) {
         suggestion.append(" ");
       }

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikBritishSpellerRuleTest.java
Patch:
@@ -112,8 +112,8 @@ public void testMorfologikSpeller() throws IOException {
     
     RuleMatch[] matches3 = rule.match(lt.getAnalyzedSentence("I'm g oing"));
     Assert.assertThat(matches3.length, is(1));
-    Assert.assertThat(matches3[0].getSuggestedReplacements().get(0), is("go ing"));
-    Assert.assertThat(matches3[0].getSuggestedReplacements().get(1), is("going"));
+    Assert.assertThat(matches3[0].getSuggestedReplacements().get(0), is("going"));
+    Assert.assertThat(matches3[0].getSuggestedReplacements().get(1), is("g going"));
     Assert.assertThat(matches3[0].getFromPos(), is(4));
     Assert.assertThat(matches3[0].getToPos(), is(10));
     

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tagging/disambiguation/ca/CatalanHybridDisambiguator.java
Patch:
@@ -39,8 +39,8 @@
  */
 public class CatalanHybridDisambiguator extends AbstractDisambiguator {
 
-  private final MultiWordChunker chunker = new MultiWordChunker("/ca/multiwords.txt", true, true);
-  private final MultiWordChunker chunkerGlobal = new MultiWordChunker("/spelling_global.txt", false, true, "NPCN000");
+  private final MultiWordChunker chunker = new MultiWordChunker("/ca/multiwords.txt", true, true, false);
+  private final MultiWordChunker chunkerGlobal = new MultiWordChunker("/spelling_global.txt", false, true, false,"NPCN000");
   private final Disambiguator disambiguator;
 
   @Override

File: languagetool-language-modules/de/src/main/java/org/languagetool/tagging/disambiguation/rules/de/GermanRuleDisambiguator.java
Patch:
@@ -35,13 +35,13 @@ public class GermanRuleDisambiguator extends AbstractDisambiguator {
   private final Disambiguator disambiguator;
 
   private final MultiWordChunker multitokenSpeller = new MultiWordChunker(
-    "/de/multitoken-ignore.txt", false, false, MultiWordChunker.tagForNotAddingTags);
+    "/de/multitoken-ignore.txt", false, false, false, MultiWordChunker.tagForNotAddingTags);
 
   private final MultiWordChunker multitokenSpeller2 = new MultiWordChunker(
-    "/de/multitoken-suggest.txt", false, false, MultiWordChunker.tagForNotAddingTags);
+    "/de/multitoken-suggest.txt", false, false, false, MultiWordChunker.tagForNotAddingTags);
 
   private final MultiWordChunker multitokenSpeller3 = new MultiWordChunker(
-    "/spelling_global.txt", false, false, MultiWordChunker.tagForNotAddingTags);
+    "/spelling_global.txt", false, false, false, MultiWordChunker.tagForNotAddingTags);
 
   public GermanRuleDisambiguator(Language lang) {
     disambiguator = new XmlRuleDisambiguator(lang, true);

File: languagetool-language-modules/en/src/main/java/org/languagetool/tagging/en/EnglishHybridDisambiguator.java
Patch:
@@ -42,8 +42,8 @@
  */
 public class EnglishHybridDisambiguator extends AbstractDisambiguator {
 
-  private final MultiWordChunker chunker = new MultiWordChunker("/en/multiwords.txt", true, true);
-  private final MultiWordChunker chunkerGlobal = new MultiWordChunker("/spelling_global.txt", true, true, MultiWordChunker.tagForNotAddingTags);
+  private final MultiWordChunker chunker = new MultiWordChunker("/en/multiwords.txt", true, true, false);
+  private final MultiWordChunker chunkerGlobal = new MultiWordChunker("/spelling_global.txt", true, true, false, MultiWordChunker.tagForNotAddingTags);
   private final Disambiguator disambiguator;
 
   public EnglishHybridDisambiguator(Language lang) {

File: languagetool-language-modules/es/src/main/java/org/languagetool/tagging/disambiguation/es/SpanishHybridDisambiguator.java
Patch:
@@ -42,8 +42,8 @@
  */
 public class SpanishHybridDisambiguator extends AbstractDisambiguator {
 
-  private final MultiWordChunker chunker = new MultiWordChunker("/es/multiwords.txt", true, true);
-  private final Disambiguator chunkerGlobal = new MultiWordChunker("/spelling_global.txt", false, true, "NPCN000");
+  private final MultiWordChunker chunker = new MultiWordChunker("/es/multiwords.txt", true, true, false);
+  private final Disambiguator chunkerGlobal = new MultiWordChunker("/spelling_global.txt", false, true, false, "NPCN000");
   private final Disambiguator disambiguator;
 
   public SpanishHybridDisambiguator(Language lang) {

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tagging/disambiguation/fr/FrenchHybridDisambiguator.java
Patch:
@@ -40,7 +40,7 @@
 
 public class FrenchHybridDisambiguator extends AbstractDisambiguator {
 
-  private final MultiWordChunker chunker = new MultiWordChunker("/fr/multiwords.txt", true, true);
+  private final MultiWordChunker chunker = new MultiWordChunker("/fr/multiwords.txt", true, true, false);
   private final Disambiguator disambiguator = new XmlRuleDisambiguator(new French(), true);
 
   public FrenchHybridDisambiguator() {

File: languagetool-language-modules/pt/src/main/java/org/languagetool/tagging/disambiguation/pt/PortugueseHybridDisambiguator.java
Patch:
@@ -39,8 +39,8 @@
  */
 public class PortugueseHybridDisambiguator extends AbstractDisambiguator {
 
-  private final MultiWordChunker chunker = new MultiWordChunker("/pt/multiwords.txt", true, true);
-  private final MultiWordChunker chunkerGlobal = new MultiWordChunker("/spelling_global.txt", false, true, "NPCN000");
+  private final MultiWordChunker chunker = new MultiWordChunker("/pt/multiwords.txt", true, true, true);
+  private final MultiWordChunker chunkerGlobal = new MultiWordChunker("/spelling_global.txt", false, true, true,"NPCN000");
   private final Disambiguator disambiguator;
 
   public PortugueseHybridDisambiguator(Language lang) {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/AnalyzedParagraphsCache.java
Patch:
@@ -59,7 +59,7 @@ public class AnalyzedParagraphsCache {
       return;
     }
     Locale tmpLocale = docCache.getFlatParagraphLocale(0);
-    if (tmpLocale == null || !mDocHandler.hasLocale(tmpLocale)) {
+    if (tmpLocale == null || !MultiDocumentsHandler.hasLocale(tmpLocale)) {
       locale = null;
       return;
     }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ConfigThread.java
Patch:
@@ -28,8 +28,6 @@
 import org.languagetool.gui.ConfigurationDialog;
 import org.languagetool.rules.Rule;
 
-import com.sun.star.uno.XComponentContext;
-
 /**
  * A thread that shows the configuration dialog which lets the
  * user enable/disable rules.

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -29,7 +29,6 @@
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.AnalyzedToken;
 import org.languagetool.AnalyzedTokenReadings;
-import org.languagetool.JLanguageTool;
 import org.languagetool.markup.AnnotatedText;
 import org.languagetool.markup.AnnotatedTextBuilder;
 import org.languagetool.openoffice.DocumentCursorTools.DocumentText;
@@ -942,7 +941,7 @@ private void mapParagraphs(List<String> paragraphs, List<TextParagraph> toTextMa
         }
         numUnknown = paragraphs.size() - numUnknown;  // nUnknown: number of headings of graphic elements
         String msg = "An error has occurred in LanguageTool "
-            + JLanguageTool.VERSION + " (" + JLanguageTool.BUILD_DATE + "):\nDocument cache mapping failed:\nParagraphs:\n"
+            + OfficeTools.LT_VERSION + " (" + OfficeTools.LT_BUILD_DATE + "):\nDocument cache mapping failed:\nParagraphs:\n"
             + "Endnotes: " + toParaMapping.get(CURSOR_TYPE_ENDNOTE).size() + " / " + textParas.get(CURSOR_TYPE_ENDNOTE).size() + "\n"
             + "Footnotes: " + toParaMapping.get(CURSOR_TYPE_FOOTNOTE).size() + " / " + textParas.get(CURSOR_TYPE_FOOTNOTE).size() + "\n"
             + "Headers/Footers: " + toParaMapping.get(CURSOR_TYPE_HEADER_FOOTER).size() + " / " + textParas.get(CURSOR_TYPE_HEADER_FOOTER).size() + "\n"

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LinguisticServices.java
Patch:
@@ -53,7 +53,7 @@
 public class LinguisticServices extends LinguServices {
   
   private static boolean isSetLt = false;
-  private static boolean spellerIsOn = true;
+//  private static boolean spellerIsOn = true;
 //  private XThesaurus thesaurus = null;
 //  private XSpellChecker spellChecker = null;
 //  private XHyphenator hyphenator = null;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -1593,6 +1593,7 @@ public void windowDeactivated(WindowEvent e) {
     private void setJComboSelectionBackground(JComboBox<String> comboBox, Color color) {
       Object context = comboBox.getAccessibleContext().getAccessibleChild(0);
       BasicComboPopup popup = (BasicComboPopup)context;
+      @SuppressWarnings("unchecked")
       JList<Object> list = popup.getList();
       list.setSelectionBackground(color);
     }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCursorTools.java
Patch:
@@ -1423,10 +1423,10 @@ public void removeMarks(List<TextParagraph> textParas) {
    */
   public List<Integer> getDeletedCharactersOfTextParagraph(TextParagraph textPara, boolean withDeleted) {
     isBusy++;
-    if (!withDeleted) {
-      return new ArrayList<Integer>();
-    }
     try {
+      if (!withDeleted) {
+        return new ArrayList<Integer>();
+      }
       XParagraphCursor xPCursor = getParagraphCursor(textPara);
       if (xPCursor == null) {
         return null;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -1737,6 +1737,7 @@ public void trigger(String sEvent) {
         resetIgnoredMatches();
         resetDocumentCaches();
         resetResultCaches(true);
+        LtSpellChecker.resetSpellCache();
         resetDocument();
       } else if ("statisticalAnalyses".equals(sEvent)) {
         StatAnDialog statAnDialog = new StatAnDialog(getCurrentDocument());

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -32,6 +32,7 @@
 
 import org.languagetool.Language;
 import org.languagetool.gui.Configuration;
+import org.languagetool.openoffice.CacheIO.SpellCache;
 import org.languagetool.openoffice.DocumentCache.TextParagraph;
 import org.languagetool.openoffice.OfficeTools.DocumentType;
 import org.languagetool.openoffice.OfficeTools.LoErrorType;
@@ -679,6 +680,8 @@ void writeCaches() {
       }
       MessageHandler.printToLogFile("SingleDocument: writeCaches: Save Caches ...");
       cacheIO.saveCaches(docCache, paragraphsCache, permanentIgnoredMatches, config, mDocHandler);
+      SpellCache sc = cacheIO.new SpellCache();
+      sc.write(LtSpellChecker.getWrongWords(), LtSpellChecker.getSuggestions());
     }
   }
   

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SwJLanguageTool.java
Patch:
@@ -401,6 +401,7 @@ public List<RuleMatch> check(String text, ParagraphHandling paraMode, Mode mode,
         int nFPara, SingleDocument document, SwJLanguageTool lt) throws IOException {
 
       List<AnalyzedSentence> analyzedSentences = document.getDocumentCache().getOrCreateAnalyzedParagraph(nFPara, lt);
+      text = document.getDocumentCache().getFlatParagraph(nFPara);
       List<String> sentences = new ArrayList<>();
       for (AnalyzedSentence analyzedSentence : analyzedSentences) {
         sentences.add(analyzedSentence.getText());
@@ -442,6 +443,7 @@ public List<RuleMatch> check(String text, ParagraphHandling paraMode, Mode mode,
         int nFPara, SingleDocument document, SwJLanguageTool lt) throws IOException {
 
       List<AnalyzedSentence> analyzedSentences = document.getDocumentCache().getOrCreateAnalyzedParagraph(nFPara, lt);
+      text = document.getDocumentCache().getFlatParagraph(nFPara);
       List<String> sentences = new ArrayList<>();
       for (AnalyzedSentence analyzedSentence : analyzedSentences) {
         sentences.add(analyzedSentence.getText());

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SwJLanguageTool.java
Patch:
@@ -446,7 +446,7 @@ public List<RuleMatch> check(String text, ParagraphHandling paraMode, Mode mode,
       for (AnalyzedSentence analyzedSentence : analyzedSentences) {
         sentences.add(analyzedSentence.getText());
       }
-      return checkInternal(new AnnotatedTextBuilder().addText(text).build(), paraMode, null, mode, 
+      return checkInternal(new AnnotatedTextBuilder().addText(text + OfficeTools.END_OF_PARAGRAPH).build(), paraMode, null, mode, 
           Level.PICKY, null, sentences, analyzedSentences).getRuleMatches();
     }
 
@@ -457,7 +457,7 @@ public List<RuleMatch> check(String text, ParagraphHandling paraMode, Mode mode,
       for (AnalyzedSentence analyzedSentence : analyzedSentences) {
         sentences.add(analyzedSentence.getText());
       }
-      return checkInternal(new AnnotatedTextBuilder().addText(text).build(), paraMode, null, mode, 
+      return checkInternal(new AnnotatedTextBuilder().addText(text + OfficeTools.END_OF_PARAGRAPH).build(), paraMode, null, mode, 
           Level.PICKY, null, sentences, analyzedSentences).getRuleMatches();
     }
 

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/SpellingCheckRuleTest.java
Patch:
@@ -54,7 +54,7 @@ public void testIgnoreSuggestionsWithMorfologik() throws IOException {
     assertThat(lt.check("This is anotherArtificialTestWordForLanguageTol.")  // note the typo
                .get(0).getSuggestedReplacements().toString(), is("[anotherArtificialTestWordForLanguageTool]"));
 
-    assertThat(lt.check("This is Michaels new song.").get(0).getSuggestedReplacements().toString(), is("[Michael's, Michael, Michaela]"));
+    assertThat(lt.check("This is Julias new song.").get(0).getSuggestedReplacements().toString(), is("[Julia's, Julia, Julian, Julius, Julies, Julián, Júlia]"));
     assertThat(lt.check("This is Microsofts new product.").get(0).getSuggestedReplacements().toString(), is("[Microsoft's, Microsoft]"));
     //assertThat(lt.check("This is Googles new product.").get(0).getSuggestedReplacements().toString(), is("[Googles, Googles's]"));  // "Googles" is accepted...
   }

File: languagetool-language-modules/pt/src/test/java/org/languagetool/tokenizers/pt/PortugueseWordTokenizerTest.java
Patch:
@@ -74,6 +74,7 @@ public void testTokeniseHyphenatedSplit() {
     testTokenise("Paris-São Paulo", new String[]{"Paris", "-", "São", " ", "Paulo"});
     // this word exists in the speller but not the tagger dict; this may become a problem
     testTokenise("Sem-Peixe", new String[]{"Sem", "-", "Peixe"});
+    testTokenise("húngaro-americano", new String[]{"húngaro", "-", "americano"});
   }
 
   @Test

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentTextCache.java
Patch:
@@ -1511,7 +1511,8 @@ public String getTextParagraph(TextParagraph textParagraph) {
   public int getFlatParagraphNumber(TextParagraph textParagraph) {
     rwLock.readLock().lock();
     try {
-      if (textParagraph.type == CURSOR_TYPE_UNKNOWN || textParagraph.number < 0 
+      if (textParagraph.type == CURSOR_TYPE_UNKNOWN || textParagraph.number < 0
+          || toParaMapping.size() < NUMBER_CURSOR_TYPES
           || toParaMapping.get(textParagraph.type).size() <= textParagraph.number) {
         return -1;
       }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SwJLanguageTool.java
Patch:
@@ -405,7 +405,7 @@ public List<RuleMatch> check(String text, ParagraphHandling paraMode, Mode mode,
       for (AnalyzedSentence analyzedSentence : analyzedSentences) {
         sentences.add(analyzedSentence.getText());
       }
-      return checkInternal(new AnnotatedTextBuilder().addText(text).build(), paraMode, null, mode, 
+      return checkInternal(new AnnotatedTextBuilder().addText(text + OfficeTools.END_OF_PARAGRAPH).build(), paraMode, null, mode, 
           Level.PICKY, null, sentences, analyzedSentences).getRuleMatches();
     }
 
@@ -426,7 +426,7 @@ public List<RuleMatch> check(String text, ParagraphHandling paraMode, Mode mode,
         MessageHandler.printToLogFile("Text S:" + texts);
       }
 */
-      return checkInternal(new AnnotatedTextBuilder().addText(text).build(), paraMode, null, mode, 
+      return checkInternal(new AnnotatedTextBuilder().addText(text + OfficeTools.END_OF_PARAGRAPH).build(), paraMode, null, mode, 
           Level.PICKY, null, sentences, analyzedSentences).getRuleMatches();
     }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -145,6 +145,7 @@ public GermanCompoundTokenizer(boolean strictMode) throws IOException {
     wordSplitter.addException("Aufkohlung", asList("Aufkohlung"));
     wordSplitter.addException("Festigung", asList("Festigung"));
     wordSplitter.addException("Allerheiligen", asList("Allerheiligen"));
+    wordSplitter.addException("Druckerpressen", asList("Drucker", "pressen"));
   }
 
   @Override

File: languagetool-http-client/src/main/java/org/languagetool/remote/RemoteConfigurationInfo.java
Patch:
@@ -49,7 +49,7 @@ public Map<String,Object> getSoftwareInfo() {
     return softwareInfo;
   }
   
-  public int getMaxTextLength () {
+  public int getMaxTextLength() {
     return maxTextLength;
   }
   

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/MorfologikPortugueseSpellerRuleTest.java
Patch:
@@ -368,6 +368,9 @@ public void testPortugueseSpellerDoesNotCorrectDegreeExpressions() throws Except
     assertNoErrors("3°C", ltBR, ruleBR);
     assertNoErrors("4,0ºc", ltBR, ruleBR);
     assertNoErrors("5.0ºc", ltBR, ruleBR);
+    assertNoErrors("6,0ºRø", ltBR, ruleBR); // degrees Rømer
+    assertNoErrors("7,5ºN", ltBR, ruleBR); // North
+    assertNoErrors("−8,0°", ltBR, ruleBR); // negative
   }
 
   @Test

File: languagetool-language-modules/pt/src/test/java/org/languagetool/tokenizers/pt/PortugueseWordTokenizerTest.java
Patch:
@@ -167,6 +167,9 @@ public void testDoNotTokeniseDegreeExpressions() {
     testTokenise("29.0°C", new String[]{"29.0°C"});
     testTokenise("30,0°c", new String[]{"30,0°c"});
     testTokenise("31.0°c", new String[]{"31.0°c"});
+    testTokenise("32°Ra", new String[]{"32°Ra"});
+    testTokenise("33,1°Rø", new String[]{"33,1°Rø"});
+    testTokenise("34°N", new String[]{"34°N"});
   }
 
   @Test

File: languagetool-language-modules/nl/src/main/java/org/languagetool/language/Dutch.java
Patch:
@@ -65,7 +65,7 @@ public String[] getCountries() {
   @NotNull
   @Override
   public Tagger createDefaultTagger() {
-    return new DutchTagger();
+    return DutchTagger.INSTANCE;
   }
 
   @Nullable

File: languagetool-language-modules/nl/src/main/java/org/languagetool/tagging/nl/DutchTagger.java
Patch:
@@ -37,6 +37,7 @@
  */
 public class DutchTagger extends BaseTagger {
 
+  public static final DutchTagger INSTANCE = new DutchTagger();
   private static final Pattern PATTERN1_A = compile("([^aeiouáéíóú])(á)([^aeiouáéíóú])");
   private static final Pattern PATTERN1_E = compile("([^aeiouáéíóú])(é)([^aeiouáéíóú])");
   private static final Pattern PATTERN1_I = compile("([^aeiouáéíóú])(í)([^aeiouáéíóú])");

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -522,6 +522,7 @@ protected int getPriorityForId(String id) {
       case "DOPPELUNG_GLEICHES_VERB": return -55; // prefer comma rules
       case "FEHLENDES_NOMEN": return -60; // lower prio than most rules
       case "REPETITIONS_STYLE": return -60;
+      case "GERMAN_WORD_REPEAT_BEGINNING_RULE": return -61;
       case "MAN_SIEHT_SEHR_SCHOEN": return -14; // prefer over SEHR_SCHOEN
       // Category ids - make sure style issues don't hide overlapping "real" errors:
       case "TYPOGRAPHY": return -14;

File: languagetool-core/src/main/java/org/languagetool/rules/Categories.java
Patch:
@@ -32,7 +32,7 @@ public final class Categories {
   
   public static final Categories REDUNDANCY = make("REDUNDANCY", "category_redundancy");
   
-  public static final Categories REPETITIONS_STYLE = make("STYLE", "cateogry_repetitions_style");
+  public static final Categories REPETITIONS_STYLE = make("REPETITIONS_STYLE", "cateogry_repetitions_style");
 
   /** General style issues not covered by other categories, like overly verbose wording. */
   public static final Categories STYLE = make("STYLE", "category_style");

File: languagetool-language-modules/pt/src/main/java/org/languagetool/tokenizers/pt/PortugueseWordTokenizer.java
Patch:
@@ -84,7 +84,7 @@ public class PortugueseWordTokenizer extends WordTokenizer {
   // END of Section copied from UkranianWordTokenizer.java for handling exceptions
 
   // dots in ordinals
-  private static final Pattern DOTTED_ORDINALS_PATTERN = compile("([\\d])\\.([aoªº][sˢ]?)", CASE_INSENSITIVE| UNICODE_CASE);
+  private static final Pattern DOTTED_ORDINALS_PATTERN = compile("([\\d])\\.([aoªºᵃᵒ][sˢ]?)", CASE_INSENSITIVE| UNICODE_CASE);
   private static final String DOTTED_ORDINALS_REPL = "$1" + NON_BREAKING_DOT_SUBST + "$2";
 
   // hyphens inside words

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanWrongWordInContextRule.java
Patch:
@@ -28,8 +28,8 @@ public class GermanWrongWordInContextRule extends WrongWordInContextRule {
   
   public GermanWrongWordInContextRule(ResourceBundle messages, Language lang) {
     super(messages, lang);
-    addExamplePair(Example.wrong("Eine Gitarre hat sechs <marker>Seiten</marker>."),
-                   Example.fixed("Eine Gitarre hat sechs <marker>Saiten</marker>."));
+    addExamplePair(Example.wrong("Die <marker>Miene</marker> vom Kugelschreiber ist leer."),
+                   Example.fixed("Die <marker>Mine</marker> vom Kugelschreiber ist leer."));
   }
   
   @Override

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanWrongWordInContextRuleTest.java
Patch:
@@ -98,7 +98,7 @@ public void testRule() throws IOException {
     assertEquals("Miene", rule.match(lt.getAnalyzedSentence("Er versucht, keine Mine zu verziehen."))[0].getSuggestedReplacements().get(0));
 
     // Saite/Seite
-    assertGood("Die Seiten des Buches sind beschrieben.");
+    /*assertGood("Die Seiten des Buches sind beschrieben.");
     assertGood("Dieses Buch über die Gitarre hat nur sechs Seiten.");
     assertGood("Diese Gitarre hat sechs Saiten.");
     assertGood("Die UNO muss andere Saiten aufziehen.");
@@ -113,7 +113,7 @@ public void testRule() throws IOException {
     assertBad("Bei der UNO müssen andere Seiten aufgezogen werden.");
     assertBad("Die Seiten des Violoncellos sind kurz.");
     assertEquals("Saite", rule.match(lt.getAnalyzedSentence("Die E-Gitarre hat eine sechste Seite."))[0].getSuggestedReplacements().get(0));
-    assertEquals("Seiten", rule.match(lt.getAnalyzedSentence("Dieses Buch hat sechs Saiten."))[0].getSuggestedReplacements().get(0));
+    assertEquals("Seiten", rule.match(lt.getAnalyzedSentence("Dieses Buch hat sechs Saiten."))[0].getSuggestedReplacements().get(0));*/
 
     // Neutron/Neuron
     assertGood("Nervenzellen nennt man Neuronen");

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -469,7 +469,7 @@ protected int getPriorityForId(String id) {
       case "DE_PHRASE_REPETITION": return -4;  // lower prio than spell checker
       case "FRAGEZEICHEN_NACH_DIREKTER_REDE": return -4;  // lower prio than spell checker
       case "PUNCTUATION_PARAGRAPH_END": return -4;  // don't hide spelling mistakes
-      case "TEST_F_ANSTATT_PH": return -4;  // don't hide spelling mistakes
+      case "F_ANSTATT_PH_2": return -4;  // don't hide spelling mistakes
       case "DAS_WETTER_IST": return -5; // lower prio than spell checker
       case "VEREIZ_VERINF_PKT": return -5; // lower prio than spell checker
       case "WER_STARK_SCHWITZ": return -5; // lower prio than spell checker

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -469,7 +469,7 @@ protected int getPriorityForId(String id) {
       case "DE_PHRASE_REPETITION": return -4;  // lower prio than spell checker
       case "FRAGEZEICHEN_NACH_DIREKTER_REDE": return -4;  // lower prio than spell checker
       case "PUNCTUATION_PARAGRAPH_END": return -4;  // don't hide spelling mistakes
-      case "TEST_F_ANSTATT_PH": return -4;  // don't hide spelling mistakes
+      case "F_ANSTATT_PH_2": return -4;  // don't hide spelling mistakes
       case "DAS_WETTER_IST": return -5; // lower prio than spell checker
       case "VEREIZ_VERINF_PKT": return -5; // lower prio than spell checker
       case "WER_STARK_SCHWITZ": return -5; // lower prio than spell checker

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -2285,6 +2285,7 @@ protected boolean ignorePotentiallyMisspelledWord(String word) throws IOExceptio
         part1.length() >= 3 && part2.length() >= 4 &&
         !part2.contains("-") &&
         startsWithLowercase(part2) &&
+        !part1.equals("Lass") &&  // e.g. "Lasstest" - couldn't find a more generic solution yet
         (wordsWithoutInfixS.contains(part1) || (compoundPatternSpecialEnding.matcher(part1).matches() && isNoun(part2uc))) &&
         !isMisspelled(part1) &&
         !isMisspelled(part2uc) &&

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/AmericanEnglish.java
Patch:
@@ -60,7 +60,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
 
   @Override
   public SpellingCheckRule createDefaultSpellingRule(ResourceBundle messages) throws IOException {
-      return new MorfologikAmericanSpellerRule(messages, this, null, Collections.emptyList());
+    return new MorfologikAmericanSpellerRule(messages, this, null, Collections.emptyList());
   }
 
   @Override

File: languagetool-language-modules/es/src/test/java/org/languagetool/rules/es/MorfologikSpanishSpellerRuleTest.java
Patch:
@@ -211,7 +211,7 @@ public void testMorfologikSpeller() throws IOException {
 
     matches = rule.match(lt.getAnalyzedSentence("Martin"));
     assertEquals(1, matches.length);
-    assertEquals("[Martín, Mártir, Martina, Mastín, Martí, Marvin, Marín, Martini, Marlín]", matches[0].getSuggestedReplacements().toString());
+    assertEquals("[Martín, Mártir, Martina, Mastín, Martí, Marvin, Marín, Martini, Marlín, Martiño]", matches[0].getSuggestedReplacements().toString());
 
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -3149,7 +3149,6 @@ protected List<SuggestedReplacement> getOnlySuggestions(String word) {
       case "abschliessend": return topMatch("abschließend");
       case "Ruckmeldung": return topMatch("Rückmeldung");
       case "Gepaeck": return topMatch("Gepäck");
-      case "Gruss": return topMatch("Gruß");
       case "Grüsse": return topMatch("Grüße");
       case "Grüssen": return topMatch("Grüßen");
       case "entgültig": return topMatch("endgültig");

File: languagetool-core/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -34,7 +34,7 @@ public class WordListValidatorTest {
           "[ 0-9a-zA-ZöäüÖÄÜßëçèéáàóòÈÉÁÀÓÒÍãñíîŞş&*_:\\\\" +
           "___INSERT___" +
           "Œ€ūαΑβΒγɣΓδΔεΕζΖηΗθΘιΙκΚλΛμΜνΝξΞοΟπΠρΡσΣτΤυΥφΦχΧψΨωΩάΆέΈίΊήΉύΎϊϋΰΐœţłń" +
-          "ŚśŌōżúïÎôêâû" +
+          "ČŚśŌōżúïÎôêâû" +
           "ÇÃÕÚÊÂÔ" +
           "ă" +
           "å" +

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1456,7 +1456,7 @@ private List<RuleMatch> checkAnalyzedSentence(ParagraphHandling paraMode, List<R
             "The whole text contains " + wordCounter + " words " +
             " and this sentence has " + sentenceMatches.size() + " matches.");
           throw new ErrorRateTooHighException("ErrorRateTooHigh is reached by a single sentence after rule: " + rule.getFullId() + ". " +
-            "The whole text contains " + wordCounter + " words" +
+            "The whole text contains " + wordCounter + " words " +
             "and this sentence has " + sentenceMatches.size() + " matches.");
         }
       }

File: languagetool-language-modules/fr/src/test/java/org/languagetool/rules/fr/GrammalecteRuleTest.java
Patch:
@@ -37,7 +37,7 @@ public class GrammalecteRuleTest {
 
   @Test
   public void testIgnoredRuleIds() throws IOException {
-    String idRegex = "[a-z0-9A-Z_éèáàê]+";
+    String idRegex = "[a-z0-9A-Z_éèáàêâç]+";
     for (String id : GrammalecteRule.ignoreRules) {
       if (id.toLowerCase().startsWith("grammalecte_")) {
         fail("Do not use the 'grammalecte_' prefix when adding rules to the ignoreRules list: " + id);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LanguageToolMenus.java
Patch:
@@ -495,13 +495,13 @@ public ContextMenuInterceptorAction notifyContextMenuExecute(ContextMenuExecuteE
         
         int count = xContextMenu.getCount();
         
-//        if (debugMode) {
+        if (debugMode) {
           for (int i = 0; i < count; i++) {
             Any a = (Any) xContextMenu.getByIndex(i);
             XPropertySet props = (XPropertySet) a.getObject();
             printProperties(props);
           }
-//        }
+        }
 
         //  Add LT Options Item if a Grammar or Spell error was detected
         document.setMenuDocId();

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -107,7 +107,7 @@ public class SpellAndGrammarCheckDialog extends Thread {
   
   private static boolean debugMode = OfficeTools.DEBUG_MODE_CD;         //  should be false except for testing
 //  private static boolean debugModeTm = OfficeTools.DEBUG_MODE_TM;       //  should be false except for testing
-  private static boolean debugModeTm = true;       //  should be false except for testing
+  private static boolean debugModeTm = OfficeTools.DEBUG_MODE_TM;       //  should be false except for testing
 
   private static final ResourceBundle messages = JLanguageTool.getMessageBundle();
 //  private static final String spellRuleId = "LO_SPELLING_ERROR";

File: languagetool-language-modules/fr/src/test/java/org/languagetool/rules/fr/GrammalecteRuleTest.java
Patch:
@@ -37,7 +37,7 @@ public class GrammalecteRuleTest {
 
   @Test
   public void testIgnoredRuleIds() throws IOException {
-    String idRegex = "[a-z0-9A-Z_éèáàê]+";
+    String idRegex = "[a-z0-9A-Z_éèáàêâ]+";
     for (String id : GrammalecteRule.ignoreRules) {
       if (id.toLowerCase().startsWith("grammalecte_")) {
         fail("Do not use the 'grammalecte_' prefix when adding rules to the ignoreRules list: " + id);

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/GrammalecteRule.java
Patch:
@@ -396,6 +396,7 @@ public class GrammalecteRule extends Rule {
     "gv1__ppas_être_accord_plur__b1_a1_1",
     "gv1__ppas_être_accord_sing__b1_a1_1",
     "gv2__conf_ait_confiance_été_faim_tort__b1_a2_1",
+    "gv1__conf_suj_verbe_det_verbe_nom__b5_a1_1",
     "gv2__conj_les_nom__b1_a2_1",
     "gv2__conj_quiconque__b1_a1_1",
     "g2__conf_a_à_substantifs__b1_a1_1",
@@ -437,6 +438,7 @@ public class GrammalecteRule extends Rule {
     "g2__conf_a_à_verbe__b4_a1_1",
     "g2__conf_a_à_verbe__b7_a1_1",
     "g2__conf_a_à_verbe__b8_a1_1",
+    "g2__conf_quand_quant_qu_en__b1_a1_1",
     "g3__gn_la_3m__b1_a1_1",
     "gv1__imp_verbe_groupe3_d__b2_a1_1",//rule is generating FP and a loop(https://github.com/languagetooler-gmbh/languagetool-premium/issues/5220)
     "typo_guillemets_perdus",
@@ -533,6 +535,7 @@ public class GrammalecteRule extends Rule {
     "g3__conf_est_et__b4_a1_1",
     "g2__conf_près_prêt_pré__b3_a1_1",
     "g3__conf_panser_penser__b1_a1_1",
+    "g3__conf_tache_tâche__b1_a1_1",
     "g2__conf_de_vconj__b6_a1_1",
     "g2__conf_à_vconj__b3_a1_1",
     "gv1__ppas_être_confusion__b4_a4_1",

File: languagetool-core/src/main/java/org/languagetool/Language.java
Patch:
@@ -821,7 +821,7 @@ protected int getPriorityForId(String id) {
     if (id.equalsIgnoreCase("TOO_LONG_SENTENCE")) {
       return -101;  // don't hide spelling errors
     }
-    if (id.equalsIgnoreCase("STYLE")) {  // category
+    if (id.contains("STYLE")) {  // category
       return -50;  // don't let style issues hide more important errors
     }
     return 0;

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -53,8 +53,7 @@
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
-import static org.languagetool.server.ServerTools.getHttpReferrer;
-import static org.languagetool.server.ServerTools.getHttpUserAgent;
+import static org.languagetool.server.ServerTools.*;
 
 /**
  * @since 3.4
@@ -411,7 +410,7 @@ void checkText(AnnotatedText aText, HttpExchange httpExchange, Map<String, Strin
     }
     boolean untrustedSource = false;
     if (referrer != null) {
-      untrustedSource = config.getUntrustedReferrers().stream().anyMatch(s -> s.contains(referrer));
+      untrustedSource = config.getUntrustedReferrers().stream().anyMatch(s -> siteMatches(referrer, s));
     }
     
     UserConfig userConfig =

File: languagetool-core/src/main/java/org/languagetool/tools/StringTools.java
Patch:
@@ -654,7 +654,7 @@ public static boolean isNotWordCharacter(String input) {
   
   /**
    * Difference between two strings (only one difference)
-   * @return: List of strings: 0: common string at the start; 1: diff in string1; 2: diff in string2; 3: common string at the end
+   * @return List of strings: 0: common string at the start; 1: diff in string1; 2: diff in string2; 3: common string at the end
    * @since 6.2
    */
   

File: languagetool-language-modules/es/src/test/java/org/languagetool/rules/es/MorfologikSpanishSpellerRuleTest.java
Patch:
@@ -211,7 +211,7 @@ public void testMorfologikSpeller() throws IOException {
 
     matches = rule.match(lt.getAnalyzedSentence("Martin"));
     assertEquals(1, matches.length);
-    assertEquals("[Martín, Mártir, Martina, Mastín, Martí, Marvin, Marín, Martini]", matches[0].getSuggestedReplacements().toString());
+    assertEquals("[Martín, Mártir, Martina, Mastín, Martí, Marvin, Marín, Martini, Marlín]", matches[0].getSuggestedReplacements().toString());
 
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/RuleMatch.java
Patch:
@@ -172,7 +172,7 @@ public RuleMatch(Rule rule, AnalyzedSentence sentence, int fromPos, int toPos, i
     this.shortMessage = shortMessage;
     this.sentence = sentence;
     if (setOriginalErrorStr) {
-      this.setOriginalErroStr();
+      this.setOriginalErrorStr();
     }
     // extract suggestion from <suggestion>...</suggestion> in message:
     LinkedHashSet<SuggestedReplacement> replacements = new LinkedHashSet<>();
@@ -693,7 +693,7 @@ public String getSpecificRuleId() {
     }
   }
 
-  private void setOriginalErroStr() {
+  private void setOriginalErrorStr() {
     if (!this.originalErrorStr.isEmpty()) {
       return;
     }

File: languagetool-core/src/main/java/org/languagetool/SentenceRange.java
Patch:
@@ -55,10 +55,10 @@ public static List<SentenceRange> getRangesFromSentences(AnnotatedText annotated
         continue;
       }
       //trim whitespaces
-      String sentenceNoBeginnWhitespace = BEGINS_WITH_SPACE.matcher(sentence).replaceFirst("");
+      String sentenceNoBeginWhitespace = BEGINS_WITH_SPACE.matcher(sentence).replaceFirst("");
       String sentenceNoEndWhitespace = ENDS_WITH_SPACE.matcher(sentence).replaceFirst("");
       //Get position without tailing and leading whitespace
-      int fromPos = pos + (sentence.length() - sentenceNoBeginnWhitespace.length());
+      int fromPos = pos + (sentence.length() - sentenceNoBeginWhitespace.length());
       int toPos = pos + sentenceNoEndWhitespace.length();
 
       int fromPosOrig = fromPos + diff;

File: languagetool-core/src/main/java/org/languagetool/SentenceRange.java
Patch:
@@ -33,7 +33,7 @@
 public class SentenceRange implements Comparable<SentenceRange>{
 
   private static final Pattern BEGINS_WITH_SPACE = Pattern.compile("^\\s*");
-  private static final Pattern ENDS_WITH_SPACE = Pattern.compile("\\s++$");
+  private static final Pattern ENDS_WITH_SPACE = Pattern.compile("\\s+$");
 
   private final int fromPos;
   private final int toPos;

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -572,7 +572,7 @@ protected int getPriorityForId(String id) {
       };
 
       for (String gId: ggecIds) {
-        if (id == gId) {
+        if (id.equals(gId)) {
           return -1;
         }
       }
@@ -583,7 +583,7 @@ protected int getPriorityForId(String id) {
         return -1;
       }
 
-      if (id == "AI_DE_GGEC_MISSING_PUNCTUATION_E_DASH_MAIL") {
+      if (id.equals("AI_DE_GGEC_MISSING_PUNCTUATION_E_DASH_MAIL")) {
         // less prio than EMAIL
         return 0;
       }

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -524,6 +524,9 @@ protected int getPriorityForId(String id) {
       case "REDUNDANCY": return -15;
       case "GENDER_NEUTRALITY": return -15;
     }
+    if (id.startsWith("DE_PROHIBITED_COMPOUNDS_")) {   // don't hide spelling mistakes
+      return -4;
+    }
     if (id.startsWith("CONFUSION_RULE_")) {
       return -1;
     }

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java
Patch:
@@ -1348,7 +1348,7 @@ private void addHyphenSuggestions(String[] parts, List<SuggestedReplacement> top
           if (partSuggestions.size() > 0) {
               String suggestion = getHyphenatedWordSuggestion(parts, i, partSuggestions.get(0));
               topSuggestions.add(new SuggestedReplacement(suggestion));
-            }
+          }
         }
       i++;
     }
@@ -1362,7 +1362,7 @@ private String getHyphenatedWordSuggestion(String[] parts, int currentPos, Strin
           } else {
             newParts.add(parts[j]);
           }
-      }
+    }
     return String.join("-", newParts);
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -2455,7 +2455,7 @@ private List<String> getAdditionalTopSuggestionsString(List<String> suggestions,
       return singletonList("d.\u202fh.");
     } else if (word.equals("ua") || word.equals("ua.")) {
       return singletonList("u.\u202fa.");
-    } else if ( ZB.matcher(word).matches() || ZB.matcher(word).matches() )  {
+    } else if ( ZB.matcher(word).matches() || STARTS_WITH_ZB.matcher(word).matches() )  {
       return singletonList("z.\u202fB.");
     } else if (word.equals("uvm") || word.equals("uvm.")) {
       return singletonList("u.\u202fv.\u202fm.");

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -430,9 +430,9 @@ public String adaptSuggestion(String s) {
     s = s.replace(" ,", ",");
     return s;
   }
-
+  
   private final List<String> spellerExceptions = Arrays.asList("San Juan", "Copa América", "Colección Jumex", "Banco Santander",
-    "San Marcos", "Santa Ana", "San Joaquín", "Naguib Mahfouz");
+    "San Marcos", "Santa Ana", "San Joaquín", "Naguib Mahfouz", "Rosalía");
 
   @Override
   public String prepareLineForSpeller(String line) {

File: languagetool-language-modules/nl/src/test/java/org/languagetool/rules/nl/CompoundAcceptorTest.java
Patch:
@@ -50,8 +50,8 @@ public void testAcceptCompound() throws IOException {
     assertFalse(acceptor.acceptCompound("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"));
     assertFalse(acceptor.acceptCompound("bedrijfskijkt"));
 
-    assertTrue(acceptor.acceptCompound("belastingvrij"));
-    assertFalse(acceptor.acceptCompound("belastingsvrij"));
+    //assertTrue(acceptor.acceptCompound("belastingvrij"));
+    //assertFalse(acceptor.acceptCompound("belastingsvrij"));
 
     // test for acronyms in compounds
     assertTrue(acceptor.acceptCompound("IRA-akkoord"));

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java
Patch:
@@ -153,7 +153,7 @@ public abstract class AbstractEnglishSpellerRule extends MorfologikSpellerRule {
     blogLinks[2] = "https://languagetool.org/insights/post/ise-ize/#another-difference-because-of-foreign-words-%E2%80%9C-og%E2%80%9D-vs-%E2%80%9C-ogue%E2%80%9D";
     
     wordPatterns[3] = Pattern.compile(".*(or|our).*", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
-    blogLinks[3] = "https://languagetool.org/insights/post/our-or/#colour-or-color-%E2%80%94-colourise-or-colorize";
+    blogLinks[3] = "https://languagetool.org/insights/post/our-or/#colour-or-color%E2%80%94colourise-or-colorize";
 
     wordPatterns[4] = Pattern.compile(".*e?able|.*dge?ments?|aging|ageing|ax|axe|.*grame?s?|neuron|neurone|neurons|neurones", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
     blogLinks[4] = "https://languagetool.org/insights/post/our-or/#likeable-vs-likable-judgement-vs-judgment-oestrogen-vs-estrogen";

File: languagetool-server/src/main/java/org/languagetool/server/DatabaseAccessOpenSource.java
Patch:
@@ -316,7 +316,7 @@ private void validateWord(String word) {
       throw new BadRequestException("Invalid word, cannot be empty or whitespace only");
     }
     if (word.matches(".*\\s.*")) {
-      throw new BadRequestException("Invalid word, you can only words that don't contain spaces: '" + word + "'");
+      throw new BadRequestException("Invalid word, you can only add words that don't contain spaces: '" + word + "'");
     }
   }
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -60,7 +60,7 @@ public class GermanSpellerRuleTest {
   @Test
   public void testIgnoreMisspelledWord() throws IOException {
     GermanSpellerRule rule = new GermanSpellerRule(TestTools.getMessages("de"), GERMAN_DE);
-    assertFalse(rule.ignorePotentiallyMisspelledWord("Atmosphärenkonzept"));
+    assertTrue(rule.ignorePotentiallyMisspelledWord("Atmosphärenkonzept"));
     assertFalse(rule.ignorePotentiallyMisspelledWord("Abschlussgruße"));  // probably "...grüße"
     assertTrue(rule.ignorePotentiallyMisspelledWord("Offenlegungsfrist"));
     assertFalse(rule.ignorePotentiallyMisspelledWord("Offenlegungsfirst"));

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -60,7 +60,7 @@ public class GermanSpellerRuleTest {
   @Test
   public void testIgnoreMisspelledWord() throws IOException {
     GermanSpellerRule rule = new GermanSpellerRule(TestTools.getMessages("de"), GERMAN_DE);
-    assertFalse(rule.ignorePotentiallyMisspelledWord("Atmosphärenkonzept"));
+    assertTrue(rule.ignorePotentiallyMisspelledWord("Atmosphärenkonzept"));
     assertFalse(rule.ignorePotentiallyMisspelledWord("Abschlussgruße"));  // probably "...grüße"
     assertTrue(rule.ignorePotentiallyMisspelledWord("Offenlegungsfrist"));
     assertFalse(rule.ignorePotentiallyMisspelledWord("Offenlegungsfirst"));

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -2234,7 +2234,7 @@ protected boolean ignorePotentiallyMisspelledWord(String word) throws IOExceptio
         part1.length() >= 3 && part2.length() >= 4 &&
         !part2.contains("-") &&
         startsWithLowercase(part2) &&
-        (wordsWithoutInfixS.contains(part1) || (compoundPatternSpecialEnding.matcher(part1).matches() && isNoun(part2uc)) || isOnlyPluralNoun(part1)) &&
+        (wordsWithoutInfixS.contains(part1) || (compoundPatternSpecialEnding.matcher(part1).matches() && isNoun(part2uc))) &&
         !isMisspelled(part1) &&
         !isMisspelled(part2uc) &&
         isMisspelled(part2) // don't accept e.g. "Azubikommt"

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -60,7 +60,7 @@ public class GermanSpellerRuleTest {
   @Test
   public void testIgnoreMisspelledWord() throws IOException {
     GermanSpellerRule rule = new GermanSpellerRule(TestTools.getMessages("de"), GERMAN_DE);
-    assertTrue(rule.ignorePotentiallyMisspelledWord("Atmosphärenkonzept"));
+    assertFalse(rule.ignorePotentiallyMisspelledWord("Atmosphärenkonzept"));
     assertFalse(rule.ignorePotentiallyMisspelledWord("Abschlussgruße"));  // probably "...grüße"
     assertTrue(rule.ignorePotentiallyMisspelledWord("Offenlegungsfrist"));
     assertFalse(rule.ignorePotentiallyMisspelledWord("Offenlegungsfirst"));

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -1448,7 +1448,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     put("strang", w -> Arrays.asList("Strang", "strengte"));
     put("Gym", w -> Arrays.asList("Fitnessstudio", "Gymnasium"));
     put("Wur", w -> Arrays.asList("Wir", "Zur", "War", "Nur"));
-    put("wir", w -> Arrays.asList("wir", "zur", "war", "nur"));
+    put("wur", w -> Arrays.asList("wir", "zur", "war", "nur"));
     put("Gyms", w -> Arrays.asList("Fitnessstudios", "Gymnasiums"));
     put("gäng", w -> Arrays.asList("ging", "gang"));
     put("di", w -> Arrays.asList("du", "die", "Di.", "der", "den"));

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/UppercaseSentenceStartRuleTest.java
Patch:
@@ -30,6 +30,7 @@ public class UppercaseSentenceStartRuleTest {
   @Test
   public void testRule() throws IOException {
     JLanguageTool lt = new JLanguageTool(Languages.getLanguageForShortCode("en"));
+    assertEquals(0, lt.check("v8.2.0 has been released").size());
     assertEquals(0, lt.check("In Nov. next year.").size());
     assertEquals(0, lt.check("www.languagetool.org is a website.").size());
     assertEquals(0, lt.check("Languagetool.org is a website.").size());

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/CheckRequestAnalysis.java
Patch:
@@ -643,7 +643,7 @@ private int getParaFromViewCursorOrDialog(String chParaWithFootnotes, Locale loc
    * adjust the result cache to changes
    */
   private boolean handleCacheChanges() {
-    if (useQueue) {
+    if (useQueue && mDocHandler.getTextLevelCheckQueue() != null) {
       mDocHandler.getTextLevelCheckQueue().interruptCheck(docID, true);
     }
     ChangedRange changed = docCache.refreshAndCompare(singleDocument, LinguisticServices.getLocale(fixedLanguage), 

File: languagetool-language-modules/nl/src/main/java/org/languagetool/rules/nl/CompoundAcceptor.java
Patch:
@@ -141,7 +141,7 @@ boolean acceptCompound(String word) throws IOException {
 
   boolean acceptCompound(String part1, String part2) throws IOException {
     if (part1.endsWith("s")) {
-        return needsS.contains(part1.toLowerCase()) && isNoun(part2) && spellingOk(part1.substring(0, part1.length()-1)) && spellingOk(part2);
+      return needsS.contains(part1.toLowerCase()) && isNoun(part2) && spellingOk(part1.substring(0, part1.length()-1)) && spellingOk(part2);
     } else if (part1.endsWith("-")) {
       return abbrevOk(part1) && spellingOk(part2);
     } else {

File: languagetool-language-modules/nl/src/main/java/org/languagetool/rules/nl/CompoundAcceptor.java
Patch:
@@ -141,7 +141,7 @@ boolean acceptCompound(String word) throws IOException {
 
   boolean acceptCompound(String part1, String part2) throws IOException {
     if (part1.endsWith("s")) {
-        return needsS.contains(part1.toLowerCase()) && isNoun(part2) && spellingOk(part1.substring(0, part1.length()-1)) && spellingOk(part2);
+      return needsS.contains(part1.toLowerCase()) && isNoun(part2) && spellingOk(part1.substring(0, part1.length()-1)) && spellingOk(part2);
     } else if (part1.endsWith("-")) {
       return abbrevOk(part1) && spellingOk(part2);
     } else {

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -518,6 +518,7 @@ private List<Rule> getAllBuiltinRules(Language language, ResourceBundle messages
    */
   public void setOutput(PrintStream printStream) {
     this.printStream = printStream;
+    GlobalConfig.setVerbose(printStream != null);
   }
 
   /**

File: languagetool-core/src/main/java/org/languagetool/rules/GRPCRule.java
Patch:
@@ -37,6 +37,7 @@
 import java.util.concurrent.TimeoutException;
 import java.util.function.BiFunction;
 import java.util.function.Function;
+import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
@@ -91,7 +92,7 @@ public abstract class GRPCRule extends RemoteRule {
 
   private static final Logger logger = LoggerFactory.getLogger(GRPCRule.class);
   private static final int DEFAULT_BATCH_SIZE = 8;
-  public static final String WHITESPACE_REGEX = "[\u00a0\u202f\ufeff\ufffd]";
+  public static final Pattern WHITESPACE_REGEX = Pattern.compile("[\u00a0\u202f\ufeff\ufffd]");
   private static final String DEFAULT_DESCRIPTION = "INTERNAL - dynamically loaded rule supported by remote server";
   /*TODO Delete this temporal fix as this is for speeding up execution for too long sentences*/
 
@@ -275,7 +276,7 @@ protected RemoteRule.RemoteRequest prepareRequest(List<AnalyzedSentence> sentenc
         List<String> text = filteredSentences.stream().map(AnalyzedSentence::getText).map(s -> {
           if (whitespaceNormalisation) {
             // non-breaking space can be treated as normal space
-            return s.replaceAll(WHITESPACE_REGEX, " ");
+            return WHITESPACE_REGEX.matcher(s).replaceAll(" ");
           } else {
             return s;
           }

File: languagetool-core/src/main/java/org/languagetool/tools/RuleMatchesAsJsonSerializer.java
Patch:
@@ -298,10 +298,10 @@ private void writeReplacements(JsonGenerator g, RuleMatch match) throws IOExcept
   }
 
   private void writeContext(JsonGenerator g, RuleMatch match, AnnotatedText text, ContextTools contextTools) throws IOException {
-    String context = contextTools.getContext(match.getFromPos(), match.getToPos(), text.getTextWithMarkup());
-    int contextOffset = context.indexOf(START_MARKER);
-    context = context.replaceFirst(START_MARKER, "");
     if (compactMode != 1) {
+      String context = contextTools.getContext(match.getFromPos(), match.getToPos(), text.getTextWithMarkup());
+      int contextOffset = context.indexOf(START_MARKER);
+      context = context.replaceFirst(START_MARKER, "");
       g.writeObjectFieldStart("context");
       g.writeStringField("text", context);
       g.writeNumberField("offset", contextOffset);

File: languagetool-language-modules/pl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -42,6 +42,7 @@ public List<AbstractPatternRule> getPatternRules() {
     };
     final Polish polish = new Polish();
     JLanguageTool tool = new JLanguageTool(new Polish());
+    tool.setOutput(System.out);
     JLanguageTool noRulesTool = new JLanguageTool(noXmlRulesPolish);
     assertEquals("[PL]", Arrays.toString(polish.getCountries()));
     List<RuleMatch> matches = noRulesTool.check("To jest całkowicie prawidłowe zdanie.");

File: languagetool-core/src/main/java/org/languagetool/rules/CleanOverlappingFilter.java
Patch:
@@ -71,7 +71,9 @@ public final List<RuleMatch> filter(List<RuleMatch> ruleMatches) {
         // duplicate suggestion for the same position
         if (suggestion.indexOf(" ") > 0 && prevSuggestion.indexOf(" ") > 0
           && ruleMatch.getFromPos() == prevRuleMatch.getToPos() + 1) {
-          if (prevSuggestion.split(" ")[1].equals(suggestion.split(" ")[0])) {
+          String parts[] = suggestion.split(" ");
+          String partsPrev[] = prevSuggestion.split(" ");
+          if (partsPrev.length > 1 && parts.length > 1 && partsPrev[1].equals(parts[0])) {
             isDuplicateSuggestion = true;
           }
         }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -2392,6 +2392,9 @@ private void changeText() throws Throwable {
             lastEqual = firstChange;
           }
           int lastDialogEqual = dialogText.length() - orgText.length() + lastEqual;
+          if (lastDialogEqual < firstChange) {
+            firstChange += dialogText.length() - orgText.length();
+          }
           word = orgText.substring(firstChange, lastEqual);
           replace = dialogText.substring(firstChange, lastDialogEqual);
           changeTextOfParagraph(y, firstChange, lastEqual - firstChange, replace, currentDocument, viewCursor);

File: languagetool-core/src/main/java/org/languagetool/rules/RemoteRuleFilters.java
Patch:
@@ -184,7 +184,7 @@ public static void main(String[] args) throws Exception {
   }
 
   static Map<String, List<AbstractPatternRule>> load(Language lang) {
-    JLanguageTool lt = new JLanguageTool(lang);
+    JLanguageTool lt = lang.createDefaultJLanguageTool();
     ResourceDataBroker dataBroker = JLanguageTool.getDataBroker();
     String filename = dataBroker.getRulesDir() + "/" + getFilename(lang);
     try {

File: languagetool-core/src/main/java/org/languagetool/rules/SuggestionFilter.java
Patch:
@@ -39,7 +39,7 @@ public class SuggestionFilter {
 
   public SuggestionFilter(Rule rule, Language lang) {
     this.rule = Objects.requireNonNull(rule);
-    this.lt = new JLanguageTool(lang);
+    this.lt = lang.createDefaultJLanguageTool();
   }
 
   public List<String> filter(List<String> replacements, String template) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -62,7 +62,8 @@ public void testIgnoreMisspelledWord() throws IOException {
     GermanSpellerRule rule = new GermanSpellerRule(TestTools.getMessages("de"), GERMAN_DE);
     assertFalse(rule.ignorePotentiallyMisspelledWord("Arbeitsgeber"));
     assertFalse(rule.ignorePotentiallyMisspelledWord("Arbeitsgeberverhandlungen"));
-    assertTrue(rule.ignorePotentiallyMisspelledWord("Menschenrechtsdemos"));
+    assertTrue(rule.ignorePotentiallyMisspelledWord("Rechtlage"));
+    assertTrue(rule.ignorePotentiallyMisspelledWord("Rechtextremismus"));
     assertTrue(rule.ignorePotentiallyMisspelledWord("Ausleihstelle"));
     assertFalse(rule.ignorePotentiallyMisspelledWord("Vorraus")); 
     assertTrue(rule.ignorePotentiallyMisspelledWord("Weinkühlschrank")); 

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/SpanishUnpairedBracketsRule.java
Patch:
@@ -68,7 +68,8 @@ protected boolean isNoException(final String tokenStr,
     }
     
     if ((tokenStr.equals("’") || tokenStr.equals("'"))
-        && (tokens[i].hasPosTagStartingWith("N") || tokens[i].hasPosTagStartingWith("A"))) {
+        && (tokens[i].hasPosTagStartingWith("N") || tokens[i].hasPosTagStartingWith("A")
+        ||tokens[i].hasPosTag("_allow_apostophe"))) {
       return false;
     }
     

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -60,6 +60,7 @@ public class GermanSpellerRuleTest {
   @Test
   public void testIgnoreMisspelledWord() throws IOException {
     GermanSpellerRule rule = new GermanSpellerRule(TestTools.getMessages("de"), GERMAN_DE);
+    assertFalse(rule.ignorePotentiallyMisspelledWord("Vorraus")); 
     assertTrue(rule.ignorePotentiallyMisspelledWord("Weinkühlschrank")); 
     assertFalse(rule.ignorePotentiallyMisspelledWord("Weinskühlschrank")); 
     assertFalse(rule.ignorePotentiallyMisspelledWord("Weinsskühlschrank"));

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -94,7 +94,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
   private final Set<String> wordEndingsToBeProhibited   = new HashSet<>();
   private final Set<String> wordsNeedingInfixS          = new HashSet<>();
   private final Set<String> wordsWithoutInfixS          = new HashSet<>();
-  private final Set<String> germanPrefix         = new HashSet<>();
+  private final Set<String> germanPrefixes              = new HashSet<>();
   private static final Map<StringMatcher, Function<String,List<String>>> ADDITIONAL_SUGGESTIONS = new HashMap<>();
   static {
     put("lieder", w -> Arrays.asList("leider", "Lieder"));
@@ -1643,7 +1643,7 @@ public GermanSpellerRule(ResourceBundle messages, German language, UserConfig us
     synthesizer = language.getSynthesizer();
     loadFile("/de/words_infix_s.txt", wordsNeedingInfixS);
     loadFile("/de/words_no_infix_s.txt", wordsWithoutInfixS);
-    loadFile("/de/german_prefix.txt", germanPrefix);
+    loadFile("/de/german_prefix.txt", germanPrefixes);
   }
 
   private void loadFile(String fileInClasspath, Set<String> set) {
@@ -2181,7 +2181,7 @@ protected boolean ignorePotentiallyMisspelledWord(String word) throws IOExceptio
       String compound1noS = compound1.replaceFirst("s$", "");
       String compound2 = uppercaseFirstChar(parts.get(1)) + parts.get(2);
       boolean compound1ok = false;
-      if (germanPrefix.contains(part2)){
+      if (germanPrefixes.contains(part2)) {
         compound1ok = (!isMisspelled(part1) && !isMisspelled(part1+parts.get(2))) || ignorePotentiallyMisspelledWord(part1+parts.get(2)); // Weinkühlschrank gets split into Wein, kühl, schrank
       } else {
         compound1ok =

File: languagetool-core/src/test/java/org/languagetool/rules/GRPCRuleTest.java
Patch:
@@ -49,7 +49,6 @@ public void setUp() throws Exception {
     config.ruleId = RULE_ID;
     config.url = "localhost";
     config.port = 50000;
-    config.maxSentenceLength= 30;
 
     rule = new GRPCRule(new Demo(), JLanguageTool.getMessageBundle(), config, true) {
       @Override

File: languagetool-core/src/main/java/org/languagetool/rules/GRPCRule.java
Patch:
@@ -94,7 +94,6 @@ public abstract class GRPCRule extends RemoteRule {
   public static final String WHITESPACE_REGEX = "[\u00a0\u202f\ufeff\ufffd]";
   private static final String DEFAULT_DESCRIPTION = "INTERNAL - dynamically loaded rule supported by remote server";
   /*TODO Delete this temporal fix as this is for speeding up execution for too long sentences*/
-  private int maxSentenceLength;
 
   public static String cleanID(String id) {
     return id.replaceAll("[^a-zA-Z0-9_]", "_").toUpperCase();
@@ -196,13 +195,13 @@ private void shutdown() {
 
   private final Connection conn;
   private final int batchSize;
-
   private final boolean sendAnalyzedData;
+  private int maxSentenceLength;
 
   public GRPCRule(Language language, ResourceBundle messages, RemoteRuleConfig config, boolean inputLogging) {
     super(language, messages, config, inputLogging);
 
-    config.maxSentenceLength = serviceConfiguration.getMaxSentenceLength() == null ? Integer.MAX_VALUE : serviceConfiguration.getMaxSentenceLength();
+    this.maxSentenceLength = Integer.parseInt(config.getOptions().getOrDefault("maxSentenceLength", String.valueOf(Integer.MAX_VALUE)));
     sendAnalyzedData = config.getOptions()
       .getOrDefault("analyzed", "false")
       .equalsIgnoreCase("true");

File: languagetool-core/src/main/java/org/languagetool/tools/StringTools.java
Patch:
@@ -597,7 +597,7 @@ public static List<String> loadLines(String path) {
    * All non-ASCII characters are replaced with "_", EXCEPT for
    * Latin-1 ranges U+00C0-U+00D6 and U+00D8-U+00DE.
    *
-   * "de" locales have a special implementation (ä => ae, etc.).
+   * "de" locales have a special implementation (ä =&gt; ae, etc.).
    *
    * @param language LT language object, used to apply language-specific normalisation rules.
    *

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -1008,7 +1008,7 @@ public void removeIgnoredMatch(int y, boolean isIntern) {
   
   /**
    * remove a ignore once entry for point x, y from queue and set the mark
-   * if x < 0 remove all ignore once entries for paragraph y
+   * if x &lt; 0 remove all ignore once entries for paragraph y
    */
   public void removeIgnoredMatch(int x, int y, String ruleId, boolean isIntern) {
     ignoredMatches.removeIgnoredMatch(x, y, ruleId);
@@ -1024,7 +1024,7 @@ public void removeIgnoredMatch(int x, int y, String ruleId, boolean isIntern) {
   
   /**
    * remove a ignore Permanent entry for point x, y from queue and set the mark
-   * if x < 0 remove all ignore once entries for paragraph y
+   * if x &lt; 0 remove all ignore once entries for paragraph y
    */
   public void removePermanentIgnoredMatch(int x, int y, String ruleId, boolean isIntern) {
     permanentIgnoredMatches.removeIgnoredMatch(x, y, ruleId);

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -84,6 +84,7 @@ static Set<String> extendedList() {
       words.add("vollstreckbarkeit");
       words.add("vollziehung");
       words.add("kasko");
+      words.add("rechtsschreibungsfehlern");
       words.trimToSize();
       return words;
     }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -60,6 +60,7 @@ public class GermanSpellerRuleTest {
   @Test
   public void testIgnoreMisspelledWord() throws IOException {
     GermanSpellerRule rule = new GermanSpellerRule(TestTools.getMessages("de"), GERMAN_DE);
+    assertTrue(rule.ignorePotentiallyMisspelledWord("Nachuntersuchungstest"));  // needs extension in ExtendedGermanWordSplitter.extendedList (as of 2023-10-02)
     assertTrue(rule.ignorePotentiallyMisspelledWord("Robustheitsabstände"));  // triggers use of nonStrictSplitter (2023-09-18, might change...)
     assertTrue(rule.ignorePotentiallyMisspelledWord("Robustheitsabstände."));  // triggers use of nonStrictSplitter (2023-09-18, might change...)
     assertTrue(rule.ignorePotentiallyMisspelledWord("Absenkungsvorgaben"));  // triggers use of nonStrictSplitter (2023-09-26, might change...)

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/CheckCaseRule.java
Patch:
@@ -29,6 +29,7 @@
 public class CheckCaseRule  extends AbstractCheckCaseRule {
 
   private static final String FILE_NAME = "/ca/check_case.txt";
+  private static final String GLOBAL_SPELLING = "../resource/spelling_global.txt";
   private static final Locale CA_LOCALE = new Locale("ca");
   
   public CheckCaseRule(ResourceBundle messages, Language language) {
@@ -38,7 +39,7 @@ public CheckCaseRule(ResourceBundle messages, Language language) {
 
   @Override
   public List<String> getFileNames() {
-    return Arrays.asList(FILE_NAME);
+    return Arrays.asList(FILE_NAME, GLOBAL_SPELLING);
   }
 
   @Override

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -2644,7 +2644,7 @@ private boolean isNeedingFugenS(String word) {
   private String getWordAfterEnumerationOrNull(List<String> words, int idx) {
     for (int i = idx; i < words.size(); i++) {
       String word = words.get(i);
-      if (!(word.endsWith("-") || StringUtils.equalsAny(word, ",", "/", "&", "und", "oder", "bzw.", "beziehungsweise", "sowie", "statt")) || word.trim().isEmpty())) {
+      if (!(word.endsWith("-") || StringUtils.equalsAny(word, ",", "/", "&", "und", "oder", "bzw.", "beziehungsweise", "sowie", "statt") || word.trim().isEmpty())) {
         return word;
       }
     }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -1811,9 +1811,9 @@ protected boolean acceptSuggestion(String s) {
         && !s.matches("[A-ZÄÖÜ][a-zäöüß]{2,20}-[a-zäöüß]{2,20}-")   // prevent Xx-zzz-
         && !s.matches("[a-zäöüß]{3,20}-[A-ZÄÖÜ][a-zäöüß\\-]{2,20}")   // prevent "testen-Gut"
         && !s.matches("[a-zäöüß]{3,20}-[A-ZÄÖÜ\\-]{2,20}")   // prevent "testen-URL"
-        && !s.matches("([skdm]?ein|viel|sitz|sing|web|hör|woh[nl]|kehr|adel|elektiv|wert|wein|wund|wurm|wand|weg|wett|gen|hei[lm]|kenn|vo[rnm]|fein|zu[rm]?|fehl|bei|peil|eckt?|mit|die|das|ehe|für|nur|eure[rn]?|unse?re?|e[sr]|fahr|bar|fern|warn|filz|oft|fort|bot|vote|käse|we[rnm]|was|gie(ss|ß)|haut|band|heiz|merk|mehr|z[äa]hl|knie|zie[lr]|braut|brat|park|reiz|wa[rs]|wo|ma(ß|ss)|kleb|gabel|brat|rast|rang|lesen?|arm|de[rnms]|sämig|sucht?|sägen?|steh|bahn|off|uff|auf|aß|also|anno|dank|back(en?)?|bl[oi]ck|fang|klär|macht?|haken?|[lw]agen?|messe?|bad(en?)?|pack|km|ecken?|bis|tauche?|tr?age?|segeln?|stei[lg]|stahl|da(nn)?|häng(en?)?[bt]oten?|plus|tat|lade?|tasten?|druck|fach|fragen?|lern|mag|facto|magre|bald|bau(en?)?|ich|sei[dtln]|gang|angeln?|[wl]ach|bist|[ge]ilt|warten?|turn|härten?|hold|[hg]alt|holt|angle|angab|ankam|anale?)-[A-ZÄÖÜa-zäöüß\\-]+") // prevent "weg-Arbeiten"
+        && !s.matches("([skdm]?ein|viel|sitz|sing|web|hör|woh[nl]|kehr|adel|elektiv|wert|wein|wund|wurm|wand|weg|wett|gen|hei[lm]|kenn|vo[rnm]|fein|zu[rm]?|fehl|bei|peil|eckt?|mit|die|das|ehe|für|nur|eure[rn]?|unse?re?|e[sr]|fahr|bar|fern|warn|filz|oft|fort|bot|vote|käse|we[rnm]|was|gie(ss|ß)|haut|band|heiz|merk|mehr|z[äa]hl|knie|zie[lr]|braut|brat|park|reiz|wa[rs]|wo|ma(ß|ss)|kleb|gabel|brat|rast|rang|lesen?|arm|de[rnms]|sämig|sucht?|sägen?|steh|bahn|off|uff|auf|aß|also|anno|dank|back(en?)?|bl[oi]ck|fang|klär|macht?|haken?|[lw]agen?|messe?|bad(en?)?|pack|km|ecken?|bis|tauche?|tr?age?|segeln?|stei[lg]|stahl|da(nn)?|häng(en?)?[bt]oten?|plus|tat|lade?|tasten?|druck|fach|fragen?|lern|mag|facto|magre|bald|bau(en?)?|ich|sei[dtln]|gang|angeln?|[wl]ach|bist|[ge]ilt|warten?|turn|härten?|hold|[hg]alt|holt|angle|angab|ankam|anale?)-[A-ZÄÖÜa-zäöüß\\-]+")   // prevent "weg-Arbeiten"
         // TODO: find a better solution for this:
-        && !s.matches(".+-(gen|tu[etn]|l?ehrt?(en?)?|[fv]iele?n?|gärt?en?|igeln?|nein|ja|d?rum|erb(en?)?|vo[rnm]|vors|hat|gab(en)?|gabs?|gibt|km|geb(en?)?|nu[nr]|gay|kalt(e[snr]?)?|la[gd](en?)?|man|rängen?|nässen?|angle|angeln?|angst|stur(en?)?|oft|wo|wann|was|wer|mengen?|spie(ß|ss)en?|adeln?|näht?en?|ob|beide[rn]?|gärten|zweiten?|hütt?en?|kehrt?en?|h?orten?|messen?|tr[ea]u|trüb|trüben?|senden?|gr[uo]b|feinden?|wie|käsen?|ih[rmn](e[srnm]?)?|grau|trug(en?)?|weil|dass|sein?|zucken?|kanten?|s?ich|getan|hält|bald|ärgern?|fächern?|wart?(en?)?|leid|weit(e[snr]?)?|weiden?|ruf(en?)?|min|im|bin|zicken?|jo|siegeln?|[ao]ha|ganz|zäh|jäh|gehen?|ga[br]|kam|sah|[sr]itzen|kann|mit|ohne|ist|so|war|da[rh]in|über|unter|doof|bis|sie|er|aalen?|[lb]aden?|raten?|die|mit|bis|d[ea]s|eifern?|acker[tn]?|z[iu]cken?|j[oe]|jäh|haha|gerät|[wrbfk]etten?|tja|je|kau|nach|haben?|hab|gaga|kicken?|kick|heil|heilen?|altern?|wänden?|wert(e[rsnm]?)?|werben?|zoom|genug|gehen?|ums?|und|oder|[sn]ah|ha|de[mnsr]|sü(ß|ss)|ringen?|dingen?|seil|au[fs]|gurten?|munden?|eigen|wenden?|regen?|b?rechen?|legen?|fächern?|leger|g[ia]lt|heim|heimen?|[mksdw]?ein|[mksdw]?einen?|erden?|ändern?|ernten?|bänden?|ästen?|arten?|kanten?|eichen?|unken?|wunden?|kunden?|runden?|regeln?|kegeln?|krähen?|zechen?|mähen?|ehren?|ehen?|enden?|eng(e[srn]?)?|gut(e[srn]?)?|zielt?(en?)?|spielt?(en?)?|ätzt?(en?)?|riegeln?|segeln?|engt?|engen?|angeln?|kochen?|[lk]ehren?|festen?|essen?|steuern?|ekeln?|irren?|cum|de|da|du|raus|rein|dort|knien?|hin|zu[rm]?|ritten?|riss|rissen?|[tr]ast(en?)?|rasseln?|hieb|wässern?|putz|hängen?|zinken?|a[bnm]|bisher|schöne?|solo|haken?|dr[üu]ck(en?|tot)?|huren?|pries|hupen?|hüllen?|lang|joa|sei[dt]|weist|üben?|ufern?|iss|steck(en?)?|fort|mal|aal|darf|halt(en?)?|eifern?|van|guck(en?|t)?|ganze?|acht(en?)?|auch|solo|[zs]og|lagern?|baggern?|au|haut?|als|uns|bei[m]?|[dm]ir|dich|uni|ergo|eich(en?)?|spick(en?)?|e[rs]|spielt?|we[hg]|wart|wi[rl]d|neue[rns]?|mithin|tags?|eine[snmr]?|wiesen?|rei[sz]en?|wei[sh]en?|siegen?|sag(en?)?|sitzen?|tagen?|all(en?)?|zahlen?|rügen?|ruhen?|bar|hüben?|hick|arm|armen?|plan(en?)?|[fpl]assen?|per|reg|rinnen?|bringen?|öl(en?)?|alt(en?)?|elf(en?)?|kp|ward|apart|wer[dkt](en?)?|weis(en?)?|sind|mm|wand|wir|licht(en)?|lügen?|loch(en?)?|übel|peu|[wtm]isch(en?)?|fein(e[rns]?)?|a(ß|ss)|mol|neu(en?)?|[dm]ich|rang|obe[nr]|übe[nl]?|maxi?|hart(en?)?|hexen?|ab|zück(en?)?|zurück|köpf(en?)?|band(en?)?|schafft?en?|schalt?en?|giften?|sieben?|seil(en?)?|wehen?|sehen?|s[it]?eht?|stocken?|red|rät|ma(ß|ss)|schämen?|innen?|karren?|wer[tf]en?|werft|loch(en?)?|logen?|gossen?|steil(en?)?|fr?isch(en?)?|d[ea]nn|zelt(en?)?|luv|kauf(en?)?|lasch(en?)?|bei(ß|ss)(en?)?|leihen?|leid(en?)?|[drsl]icht(en?)?|opfern?|[wz]äh[mln]en?|wär(en?)?|À|à|fugen?|la[xs]|zahl(en?)?|[rf]all(en?)?|wichs(en?)?|sog(en?)?|alias|glich(en?)?|würd(en?)?|wärm(en?)?|[rhg]eiz(en?)?|stieren?|teils?|trotz|fahr(en?)?|b[oa]u?[dt](en?)?|kl[öo]n(en?)?|paar|park(en?)?|last|landen?|alle[rnms]?|ad|l[äa]u[ft](en?)?|[ws]äg(en?)?|pasch(en?)?|kehl(en?)?|wohl(en?)?|flucht?(en?)?|zeit|rasa|selben?|mehr(en?)?|gabeln?|ordern?|[cw]ach(en?)?|arg(en?)?|brauch(en?)?|hauch(en?)?|[ms]a(ß|ss)(en?)?|mm?h|zart(e[snmr]?)?|ehrt?(en?)?|de[rn]en|ähm?|hui|hmm?|al|für|[bl]au(en?)?|[lr]ahm(en?)?|[bs]uch(en?)?|[wv]ag(en?)?|[tl]os(en?)?|les(en?)?|str?ahl(en?)?|zäh[mn]t?(en?)?|fest(e[rsnm]?)?|folgt?(en?)?|f[aä]llt?(en?)?|[tr]oll(en?)?|[mf]üllt?(en?)?|[rl]eit(en?)?|ras(en?)?|hall(en?)?|well(en?)?|fra(ß|ss)(en)?|tat(en)?|pah|buh(en?)?|bäh|hör(en?)?|holz(en?)?|reif(e[rsmn]?)?|litt|fort(an)?|härten?|welche[rnsm]?|wegen|fach(en?)?|bog(en?)?|foul(en?)?|löst?(en?)?|lots(en?)?|falls|[bwh][ua]ldige[rsn]?|(st)?reift?(en?)?|t?rei[bh](en?)?|[rb]ück(en?)?|wett(en?)?|t[oü]t(en?)?|[ft]est(en?)?|h[aä]ut(en?)?|knall(en?)?|[dk]ämpft?(en?)?|hört?(en?)?|patt(en?)?|[tw]ollt?en?|[km]g|[bkps]ack(en?)?|[lf]an?d(en?)?|seifen?|tabu|heft(en?)?|forma?|knall(en?)?|[lm]?acht?(en)?|boot(en?)?|lach(en?)?|[hb]i?eb(en?)?|tut(en?)?|tr?öt(e[tn]?)?|[sp]ackt?(en?)?|[klnrd]?eckt?(en?)?|beut(en?)?|top|st?att(en?)?|dien(en?)?|[hl]ieb(en?)?|sät|satt(en?)?|droh(en?)?|[sr]äum(en?)?|zeugt?(en?)?|reu(en?)?|nies(en?)?|[gzf]eigt?(en?)?|gie(ß|ss)(en?)?|sichern?|zog(en?)?|schert?(en?)?|s[tp]r?ickt?(en?)?|seicht(e[srn]?)?|(be)?sorgt?(en?)?|ehelich(en?)?|link(en?)?|wein(en?)?|r?echt|orangen?)") // e.g. "Babysöckchen" -> "Babys-kochen"
+        && !s.matches(".+-(gen|tu[etn]|l?ehrt?(en?)?|[fv]iele?n?|gärt?en?|igeln?|nein|ja|d?rum|erb(en?)?|vo[rnm]|vors|hat|gab(en)?|gabs?|gibt|km|geb(en?)?|nu[nr]|gay|kalt(e[snr]?)?|la[gd](en?)?|man|rängen?|nässen?|angle|angeln?|angst|stur(en?)?|oft|wo|wann|was|wer|mengen?|spie(ß|ss)en?|adeln?|näht?en?|ob|beide[rn]?|gärten|zweiten?|hütt?en?|kehrt?en?|h?orten?|messen?|tr[ea]u|trüb|trüben?|senden?|gr[uo]b|feinden?|wie|käsen?|ih[rmn](e[srnm]?)?|grau|trug(en?)?|weil|dass|sein?|zucken?|kanten?|s?ich|getan|hält|bald|ärgern?|fächern?|wart?(en?)?|leid|weit(e[snr]?)?|weiden?|ruf(en?)?|min|im|bin|zicken?|jo|siegeln?|[ao]ha|ganz|zäh|jäh|gehen?|ga[br]|kam|sah|[sr]itzen|kann|mit|ohne|ist|so|war|da[rh]in|über|unter|doof|bis|sie|er|aalen?|[lb]aden?|raten?|die|mit|bis|d[ea]s|eifern?|acker[tn]?|z[iu]cken?|j[oe]|jäh|haha|gerät|[wrbfk]etten?|tja|je|kau|nach|haben?|hab|gaga|kicken?|kick|heil|heilen?|altern?|wänden?|wert(e[rsnm]?)?|werben?|zoom|genug|gehen?|ums?|und|oder|[sn]ah|ha|de[mnsr]|sü(ß|ss)|ringen?|dingen?|seil|au[fs]|gurten?|munden?|eigen|wenden?|regen?|b?rechen?|legen?|fächern?|leger|g[ia]lt|heim|heimen?|[mksdw]?ein|[mksdw]?einen?|erden?|ändern?|ernten?|bänden?|ästen?|arten?|kanten?|eichen?|unken?|wunden?|kunden?|runden?|regeln?|kegeln?|krähen?|zechen?|mähen?|ehren?|ehen?|enden?|eng(e[srn]?)?|gut(e[srn]?)?|zielt?(en?)?|spielt?(en?)?|ätzt?(en?)?|riegeln?|segeln?|engt?|engen?|angeln?|kochen?|[lk]ehren?|festen?|essen?|steuern?|ekeln?|irren?|cum|de|da|du|raus|rein|dort|knien?|hin|zu[rm]?|ritten?|riss|rissen?|[tr]ast(en?)?|rasseln?|hieb|wässern?|putz|hängen?|zinken?|a[bnm]|bisher|schöne?|solo|haken?|dr[üu]ck(en?|tot)?|huren?|pries|hupen?|hüllen?|lang|joa|sei[dt]|weist|üben?|ufern?|iss|steck(en?)?|fort|mal|aal|darf|halt(en?)?|eifern?|van|guck(en?|t)?|ganze?|acht(en?)?|auch|solo|[zs]og|lagern?|baggern?|au|haut?|als|uns|bei[m]?|[dm]ir|dich|uni|ergo|eich(en?)?|spick(en?)?|e[rs]|spielt?|we[hg]|wart|wi[rl]d|neue[rns]?|mithin|tags?|eine[snmr]?|wiesen?|rei[sz]en?|wei[sh]en?|siegen?|sag(en?)?|sitzen?|tagen?|all(en?)?|zahlen?|rügen?|ruhen?|bar|hüben?|hick|arm|armen?|plan(en?)?|[fpl]assen?|per|reg|rinnen?|bringen?|öl(en?)?|alt(en?)?|elf(en?)?|kp|ward|apart|wer[dkt](en?)?|weis(en?)?|sind|mm|wand|wir|licht(en)?|lügen?|loch(en?)?|übel|peu|[wtm]isch(en?)?|fein(e[rns]?)?|a(ß|ss)|mol|neu(en?)?|[dm]ich|rang|obe[nr]|übe[nl]?|maxi?|hart(en?)?|hexen?|ab|zück(en?)?|zurück|köpf(en?)?|band(en?)?|schafft?en?|schalt?en?|giften?|sieben?|seil(en?)?|wehen?|sehen?|s[it]?eht?|stocken?|red|rät|ma(ß|ss)|schämen?|innen?|karren?|wer[tf]en?|werft|loch(en?)?|logen?|gossen?|steil(en?)?|fr?isch(en?)?|d[ea]nn|zelt(en?)?|luv|kauf(en?)?|lasch(en?)?|bei(ß|ss)(en?)?|leihen?|leid(en?)?|[drsl]icht(en?)?|opfern?|[wz]äh[mln]en?|wär(en?)?|À|à|fugen?|la[xs]|zahl(en?)?|[rf]all(en?)?|wichs(en?)?|sog(en?)?|alias|glich(en?)?|würd(en?)?|wärm(en?)?|[rhg]eiz(en?)?|stieren?|teils?|trotz|fahr(en?)?|b[oa]u?[dt](en?)?|kl[öo]n(en?)?|paar|park(en?)?|last|landen?|alle[rnms]?|ad|l[äa]u[ft](en?)?|[ws]äg(en?)?|pasch(en?)?|kehl(en?)?|wohl(en?)?|flucht?(en?)?|zeit|rasa|selben?|mehr(en?)?|gabeln?|ordern?|[cw]ach(en?)?|arg(en?)?|brauch(en?)?|hauch(en?)?|[ms]a(ß|ss)(en?)?|mm?h|zart(e[snmr]?)?|ehrt?(en?)?|de[rn]en|ähm?|hui|hmm?|al|für|[bl]au(en?)?|[lr]ahm(en?)?|[bs]uch(en?)?|[wv]ag(en?)?|[tl]os(en?)?|les(en?)?|str?ahl(en?)?|zäh[mn]t?(en?)?|fest(e[rsnm]?)?|folgt?(en?)?|f[aä]llt?(en?)?|[tr]oll(en?)?|[mf]üllt?(en?)?|[rl]eit(en?)?|ras(en?)?|hall(en?)?|well(en?)?|fra(ß|ss)(en)?|tat(en)?|pah|buh(en?)?|bäh|hör(en?)?|holz(en?)?|reif(e[rsmn]?)?|litt|fort(an)?|härten?|welche[rnsm]?|wegen|fach(en?)?|bog(en?)?|foul(en?)?|löst?(en?)?|lots(en?)?|falls|[bwh][ua]ldige[rsn]?|(st)?reift?(en?)?|t?rei[bh](en?)?|[rb]ück(en?)?|wett(en?)?|t[oü]t(en?)?|[ft]est(en?)?|h[aä]ut(en?)?|knall(en?)?|[dk]ämpft?(en?)?|hört?(en?)?|patt(en?)?|[tw]ollt?en?|[km]g|[bkps]ack(en?)?|[lf]an?d(en?)?|seifen?|tabu|heft(en?)?|forma?|knall(en?)?|[lm]?acht?(en)?|boot(en?)?|lach(en?)?|[hb]i?eb(en?)?|tut(en?)?|tr?öt(e[tn]?)?|[sp]ackt?(en?)?|[klnrd]?eckt?(en?)?|beut(en?)?|top|st?att(en?)?|dien(en?)?|[hl]ieb(en?)?|sät|satt(en?)?|droh(en?)?|[sr]äum(en?)?|zeugt?(en?)?|reu(en?)?|nies(en?)?|[gzf]eigt?(en?)?|gie(ß|ss)(en?)?|sichern?|zog(en?)?|schert?(en?)?|s[tp]r?ickt?(en?)?|seicht(e[srn]?)?|(be)?sorgt?(en?)?|ehelich(en?)?|link(en?)?|wein(en?)?|r?echt|orangen?)")   // e.g. "Babysöckchen" -> "Babys-kochen"
         && !s.endsWith("-s")   // https://github.com/languagetool-org/languagetool/issues/4042
         && !s.endsWith(" de")   // https://github.com/languagetool-org/languagetool/issues/4042
         && !s.endsWith(" en")   // https://github.com/languagetool-org/languagetool/issues/4042

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -1648,8 +1648,8 @@ public GermanSpellerRule(ResourceBundle messages, German language, UserConfig us
                    Example.fixed("LanguageTool kann mehr als eine <marker>normale</marker> Rechtschreibprüfung."));
     compoundTokenizer = language.getStrictCompoundTokenizer();
     synthesizer = language.getSynthesizer();
-    loadFile("languagetool-language-modules/de/src/main/resources/org/languagetool/resource/de/words_infix_s.txt", wordsNeedingInfixS);
-    loadFile("languagetool-language-modules/de/src/main/resources/org/languagetool/resource/de/words_no_infix_s.txt", wordsWithoutInfixS);
+    loadFile("/de/words_infix_s.txt", wordsNeedingInfixS);
+    loadFile("/de/words_no_infix_s.txt", wordsWithoutInfixS);
   }
 
   private void loadFile(String fileInClasspath, Set<String> set) {
@@ -2644,7 +2644,7 @@ private boolean isNeedingFugenS(String word) {
   private String getWordAfterEnumerationOrNull(List<String> words, int idx) {
     for (int i = idx; i < words.size(); i++) {
       String word = words.get(i);
-      if (!(word.endsWith("-") || StringUtils.equalsAny(word, ",", "/", "&", "und", "oder", "bzw.", "beziehungsweise", "sowie") || word.trim().isEmpty())) {
+      if (!(word.endsWith("-") || StringUtils.equalsAny(word, ",", "/", "&", "und", "oder", "bzw.", "beziehungsweise", "sowie", "statt")) || word.trim().isEmpty())) {
         return word;
       }
     }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -271,6 +271,7 @@ protected int getPriorityForId(String id) {
       case "REPETITIONS_STYLE": return -50;
       case "MUNDAR": return -50;
       case "NOMBRES_ROMANS": return -90;
+      case "CA_MULTITOKEN_SPELLING": return -95;
       case "MORFOLOGIK_RULE_CA_ES": return -100;
       case "EXIGEIX_ACCENTUACIO_VALENCIANA": return -120;
       //case "APOSTROFACIO_MOT_DESCONEGUT": return -120; // lesser than MORFOLOGIK_RULE_CA_ES

File: languagetool-core/src/main/java/org/languagetool/rules/MultitokenSpellerFilter.java
Patch:
@@ -43,7 +43,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     atrsArray[1] = atrs1;
     AnalyzedSentence sentence = new AnalyzedSentence(atrsArray);
     RuleMatch[] matches = spellingRule.match(sentence);
-    if (matches.length < 1) {
+    if (matches.length < 1 || matches[0].getSuggestedReplacements().isEmpty()) {
       return null;
     }
     match.setSuggestedReplacements(matches[0].getSuggestedReplacements());

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -1636,7 +1636,7 @@ public GermanSpellerRule(ResourceBundle messages, German language, UserConfig us
     addExamplePair(Example.wrong("LanguageTool kann mehr als eine <marker>nromale</marker> Rechtschreibprüfung."),
                    Example.fixed("LanguageTool kann mehr als eine <marker>normale</marker> Rechtschreibprüfung."));
     compoundTokenizer = language.getStrictCompoundTokenizer();
-    nonStrictCompoundTokenizer = GermanCompoundTokenizer.getStrictInstance();
+    nonStrictCompoundTokenizer = GermanCompoundTokenizer.getNonStrictInstance();
     synthesizer = language.getSynthesizer();
   }
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -62,6 +62,7 @@ public void testIgnoreMisspelledWord() throws IOException {
     GermanSpellerRule rule = new GermanSpellerRule(TestTools.getMessages("de"), GERMAN_DE);
     assertTrue(rule.ignorePotentiallyMisspelledWord("Robustheitsabstände"));  // triggers use of nonStrictSplitter (2023-09-18, might change...)
     assertTrue(rule.ignorePotentiallyMisspelledWord("Robustheitsabstände."));  // triggers use of nonStrictSplitter (2023-09-18, might change...)
+    assertTrue(rule.ignorePotentiallyMisspelledWord("Absenkungsvorgaben"));  // triggers use of nonStrictSplitter (2023-09-26, might change...)
     assertTrue(rule.ignorePotentiallyMisspelledWord("Prioritätsdings"));
     assertTrue(rule.ignorePotentiallyMisspelledWord("Prioritätsdings."));
     assertTrue(rule.ignorePotentiallyMisspelledWord("Haltungsschäden"));

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -2170,7 +2170,6 @@ protected boolean ignorePotentiallyMisspelledWord(String word) throws IOExceptio
               part1.endsWith("schwungs") || part1.endsWith("sprungs") || isMisspelled(part1noInfix) || isMisspelled(part2uc)) {
             return false;
           }
-          System.out.println("Accepting " + word);
           return true;
         }
       }

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -74,6 +74,7 @@ static Set<String> extendedList() {
       // is in the list and you add "tran", without "transport" being in the list, it would split "transport".
       words.add("synonym");
       words.add("aufbringung"); // Aufbringungsfläche
+      words.add("robustheit");
       words.trimToSize();
       return words;
     }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -2143,17 +2143,17 @@ protected boolean ignorePotentiallyMisspelledWord(String word) throws IOExceptio
     // Example: Müdigkeitsanzeichen = Müdigkeit + s + Anzeichen
     // Deals with two-part compounds only and could be extended.
     List<String> parts = splitter.splitWord(word.replaceFirst("\\.$", ""));
-    boolean matchByStrictMode = false;
+    boolean nonStrictMode = false;
     if (parts.size() == 1) {
       parts = nonStrictSplitter.splitWord(word.replaceFirst("\\.$", ""));
-      matchByStrictMode = true;
+      nonStrictMode = true;
     }
     String part1 = null;
     String part2 = null;
     if (parts.size() == 2) {
       part1 = parts.get(0);
       part2 = parts.get(1);
-      if (matchByStrictMode && part2.startsWith("s") && isMisspelled(part2) && !isMisspelled(uppercaseFirstChar(part2.substring(1)))) {
+      if (nonStrictMode && part2.startsWith("s") && isMisspelled(part2) && !isMisspelled(uppercaseFirstChar(part2.substring(1)))) {
         // nonStrictSplitter case, it splits like "[Priorität, sdings]", we fix that here to match the strict splitter case:
         part1 = part1 + "s";
         part2 = part2.substring(1);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -2173,7 +2173,7 @@ protected boolean ignorePotentiallyMisspelledWord(String word) throws IOExceptio
         if (part1.matches(".*(heit|keit|ion|ität|schaft|ung|tät)s") && isNoun(part2uc)) {
           String part1noInfix = part1.substring(0, part1.length()-1);
           // don't assume very short parts (like "Ei") are correct, these can easily be typos:
-          if (part1noInfix.length() <= 3 || part2uc.length() <= 3 || part1noInfix.matches("Action|Jung|Wahrung") ||
+          if (part1noInfix.length() <= 3 || part2uc.length() <= 3 || part1noInfix.matches("Action|Session|Champion|Jung|Wahrung") ||
               part2uc.matches("First|Frist|Firsten|Fristen") ||  // too easy to mix up
               part1.endsWith("schwungs") || part1.endsWith("sprungs") || isMisspelled(part1noInfix) || isMisspelled(part2uc)) {
             return false;

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -87,6 +87,8 @@ public void testIgnoreMisspelledWord() throws IOException {
     assertFalse(rule.ignorePotentiallyMisspelledWord("Leistung"));  // not a compound
     assertFalse(rule.ignorePotentiallyMisspelledWord("Leistungs"));  // not a compound
     assertFalse(rule.ignorePotentiallyMisspelledWord("Anschauungswiese"));  // from prohibit.txt
+    assertFalse(rule.ignorePotentiallyMisspelledWord("Fakultätsaal"));
+    assertFalse(rule.ignorePotentiallyMisspelledWord("Implementierungs-pflicht"));
     // special cases:
     assertFalse(rule.ignorePotentiallyMisspelledWord("Actionsspaß"));
     assertFalse(rule.ignorePotentiallyMisspelledWord("Jungsnamen"));

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/QuestionMarkRule.java
Patch:
@@ -82,7 +82,8 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) {
             hasInvExlcMark = true;
           }
           // possibly a sentence end
-          if (!tokens[i].isSentenceEnd() && (tokens[i].getToken().equals("?") || tokens[i].getToken().equals("!"))) {
+          if (i < tokens.length - 2 && !tokens[i].isSentenceEnd()
+            && (tokens[i].getToken().equals("?") || tokens[i].getToken().equals("!"))) {
             firstToken = null;
           }
           // put the question mark in: ¿de qué... ¿para cuál... ¿cómo...

File: languagetool-core/src/main/java/org/languagetool/rules/UppercaseSentenceStartRule.java
Patch:
@@ -163,7 +163,8 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
         preventError = true;
       }
 
-      if (isPrevSentenceNumberedList || isUrl(checkToken) || isEMail(checkToken) || firstTokenObj.isImmunized()) {
+      if (isPrevSentenceNumberedList || isUrl(checkToken) || isEMail(checkToken) || firstTokenObj.isImmunized()
+      || tokens[matchTokenPos].hasPosTag("_IS_URL")) {
         preventError = true;
       }
 

File: languagetool-language-modules/es/src/test/java/org/languagetool/tokenizers/es/SpanishSentenceTokenizerTest.java
Patch:
@@ -86,6 +86,7 @@ public final void testTokenize() {
     testSplit("Ayto. de Madrid.");
     testSplit("¿Quién sabe hablar francés mejor: Tom o Mary?");
     testSplit("Hola, Albert: ", "Me puedes decir tu correo?");
+    testSplit("LanguageTooler GmbH recaudará de tu cuenta a través de GoCardless Ltd. la cantidad debajo mencionada.");
 
     // Exception to abbreviations    
     testSplit("Esto pasa el PP. ", "Pero, por otra parte,");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/spelling/hunspell/HunspellRuleTest.java
Patch:
@@ -95,7 +95,7 @@ public void testRuleWithGerman() throws Exception {
     matches = rule.match(lt.getAnalyzedSentence("-Teex"));
     assertEquals(1, matches.length);
     //assertEquals("[-tee, -telex, -tees, -teen, -teer, -tee-, -text]", matches[0].getSuggestedReplacements().toString()); // Preferably "Tee" !?
-    assertEquals("[Tee, Telex, Tees, Teen, Teer, Tee-, Texte, TeX, Text]", matches[0].getSuggestedReplacements().toString()); // Preferably "Tee" !?
+    assertEquals("[Tee, Telex, Tees, Teen, Teer, Tee-, Texte, Text, TeX]", matches[0].getSuggestedReplacements().toString()); // Preferably "Tee" !?
     assertEquals(1, matches[0].getFromPos());
     assertEquals(5, matches[0].getToPos());
     

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -252,6 +252,7 @@ protected int getPriorityForId(String id) {
       case "CRASE_CONFUSION":           return -54;
       case "NAO_MILITARES":           return -54;
       case "NA_QUELE":           return -54;
+      case "NOTAS_FICAIS": return -54;
       case "GENERAL_VERB_AGREEMENT_ERRORS":           return -55;
       case "GENERAL_NUMBER_AGREEMENT_ERRORS":           return -56;
       case "GENERAL_GENDER_NUMBER_AGREEMENT_ERRORS":           return -56;

File: languagetool-core/src/test/java/org/languagetool/tools/DiffsAsMatchesTest.java
Patch:
@@ -31,6 +31,7 @@ public class DiffsAsMatchesTest {
   @Test
   public void testDiffsAsMatches() throws IOException {
     DiffsAsMatches diffsAsMatches = new DiffsAsMatches();
+
     String original = "This are a sentence with too mistakes.";
     String revised = "This is a sentence with two mistakes.";
     List<PseudoMatch> matches = diffsAsMatches.getPseudoMatches(original, revised);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -1548,6 +1548,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     put("löchen", w -> Arrays.asList("löschen", "löchern", "Köchen"));
     put("wergen",  w -> Arrays.asList("werfen", "werben", "werten"));
     put("Wasn",  w -> Arrays.asList("Was denn", "Was ein", "Was"));
+    putRepl("schammig(e[mnrs]?)?", "schamm", "schwamm");
   }
 
   @Override

File: languagetool-dev/src/main/java/org/languagetool/dev/ExportGermanNouns.java
Patch:
@@ -95,7 +95,7 @@ public static void main(String[] args) throws IOException {
     System.out.println("# Export date: " + new Date());
     System.out.println("# LanguageTool: " + JLanguageTool.VERSION + " (" + JLanguageTool.BUILD_DATE + ")");
     System.out.println("# Potential German compound parts.");
-    System.out.println("# Data from Morphy (http://www.wolfganglezius.de/doku.php?id=cl:morphy)");
+    System.out.println("# Data from Morphy (https://danielnaber.de/download/wklassen.pdf)");
     System.out.println("# with extensions by LanguageTool (https://languagetool.org)");
     System.out.println("# License: Creative Commons Attribution-Share Alike 4.0, http://creativecommons.org/licenses/by-sa/4.0/");
     for (String word : words) {

File: languagetool-core/src/main/java/org/languagetool/rules/RemoteRuleFilters.java
Patch:
@@ -36,12 +36,11 @@
 import org.languagetool.rules.patterns.AbstractPatternRule;
 
 import java.io.IOException;
-import java.nio.charset.Charset;
+import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Paths;
 import java.util.*;
 import java.util.concurrent.ExecutionException;
-import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
@@ -140,7 +139,7 @@ public static void main(String[] args) throws Exception {
     Language lang = Languages.getLanguageForShortCode(langCode);
     List<AbstractPatternRule> rules = RemoteRuleFilters.load(lang)
       .values().stream().flatMap(Collection::stream).collect(Collectors.toList());
-    Stream<String> lines = Files.lines(Paths.get(matchesFile), Charset.forName("UTF-8"));
+    Stream<String> lines = Files.lines(Paths.get(matchesFile), StandardCharsets.UTF_8);
     ObjectMapper mapper = new ObjectMapper();
     JLanguageTool lt = new JLanguageTool(lang);
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -2135,7 +2135,7 @@ protected boolean ignorePotentiallyMisspelledWord(String word) throws IOExceptio
         if (part1.matches(".*(heit|keit|ion|ität|schaft|ung|tät)s") && isNoun(part2uc)) {
           String part1noInfix = part1.substring(0, part1.length()-1);
           // don't assume very short parts (like "Ei") are correct, these can easily be typos:
-          if (part1noInfix.length() <= 3 || part2uc.length() <= 3 || part1noInfix.matches("Action|Jungs") ||
+          if (part1noInfix.length() <= 3 || part2uc.length() <= 3 || part1noInfix.matches("Action|Jung") ||
               isMisspelled(part1noInfix) || isMisspelled(part2uc)) {
             return false;
           }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -77,6 +77,7 @@ public void testIgnoreMisspelledWord() throws IOException {
     assertThat(rule.ignorePotentiallyMisspelledWord("Leistungs"), is(false));  // not a compound
     assertThat(rule.ignorePotentiallyMisspelledWord("Anschauungswiese"), is(false));  // from prohibit.txt
     assertThat(rule.ignorePotentiallyMisspelledWord("Actionsspaß"), is(false));  // special case
+    assertThat(rule.ignorePotentiallyMisspelledWord("Jungsnamen"), is(false));  // special case
   }
 
   @Test

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractCheckCaseRule.java
Patch:
@@ -33,9 +33,11 @@
  * @author Jaume Ortolà
  */
 public abstract class AbstractCheckCaseRule extends AbstractSimpleReplaceRule2 {
+  private final Language language;
 
   public AbstractCheckCaseRule(ResourceBundle messages, Language language) {
     super(messages, language);
+    this.language = language;
     setLocQualityIssueType(ITSIssueType.Typographical);
     setCategory(Categories.CASING.getCategory(messages));
   }
@@ -104,7 +106,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) {
           }
           ruleMatch = new RuleMatch(this, sentence, startPos, endPos, msg, getShort());
           if (subRuleSpecificIds) {
-            ruleMatch.setSpecificRuleId(StringTools.toId(getId() + "_" + correctPhrase));
+            ruleMatch.setSpecificRuleId(StringTools.toId(getId() + "_" + correctPhrase, language));
           }
           if (crtWordCount + sentStart == i) {
             // Capitalize suggestion at the sentence start

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractCompoundRule.java
Patch:
@@ -169,7 +169,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
           int endPos = atr.getEndPos();
           RuleMatch ruleMatch = new RuleMatch(this, sentence, startPos, endPos, msg, shortDesc);
           if (subRuleSpecificIds) {
-            String id = StringTools.toId(getId() + "_" + stringToCheck);
+            String id = StringTools.toId(getId() + "_" + stringToCheck, lang);
             String description = getDescription().replace("$match", origStringToCheck);
             SpecificIdRule subRuleId = new SpecificIdRule(id, description, isPremium(), getCategory(),
               getLocQualityIssueType(), getTags());

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractSimpleReplaceRule2.java
Patch:
@@ -285,7 +285,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) {
           int endPos = prevTokensList.get(len - 1).getEndPos();
           RuleMatch ruleMatch = new RuleMatch(this, sentence, startPos, endPos, msg, getShort());
           if (subRuleSpecificIds) {
-            String id = StringTools.toId(getId() + "_" + crt);
+            String id = StringTools.toId(getId() + "_" + crt, language);
             String desc = getDescription().replace("$match", crt);
             SpecificIdRule specificIdRule = new SpecificIdRule(id, desc, isPremium(), getCategory(), getLocQualityIssueType(), getTags());
             ruleMatch = new RuleMatch(specificIdRule, sentence, startPos, endPos, msg, getShort());

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -86,11 +86,11 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new CatalanUnpairedExclamationMarksRule(messages, this),
             new CatalanWrongWordInContextRule(messages),
             new SimpleReplaceVerbsRule(messages, this),
-            new SimpleReplaceBalearicRule(messages),
-            new SimpleReplaceRule(messages),
+            new SimpleReplaceBalearicRule(messages, this),
+            new SimpleReplaceRule(messages, this),
             new SimpleReplaceMultiwordsRule(messages),
             new ReplaceOperationNamesRule(messages, this),
-            new SimpleReplaceDiacriticsIEC(messages),
+            new SimpleReplaceDiacriticsIEC(messages, this),
             new SimpleReplaceAnglicism(messages), 
             new PronomFebleDuplicateRule(messages),
             new CheckCaseRule(messages, this),

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/AbstractSimpleReplaceLemmasRule.java
Patch:
@@ -46,7 +46,7 @@ public abstract class AbstractSimpleReplaceLemmasRule extends AbstractSimpleRepl
   private CatalanSynthesizer synth;
   
   public AbstractSimpleReplaceLemmasRule(final ResourceBundle messages, Language language) throws IOException {
-    super(messages);
+    super(messages, language);
     //this.setIgnoreTaggedWords();
     synth = (CatalanSynthesizer) language.getSynthesizer();
   }  

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReplaceOperationNamesRule.java
Patch:
@@ -63,7 +63,7 @@ public Map<String, List<String>> getWrongWords() {
   
 
   public ReplaceOperationNamesRule(final ResourceBundle messages, Language language) throws IOException {
-    super(messages);
+    super(messages, language);
     super.setLocQualityIssueType(ITSIssueType.Style);
     super.setCategory(new Category(new CategoryId("FORMES_SECUNDARIES"), "C8) Formes secundàries")); 
     synth = (CatalanSynthesizer) language.getSynthesizer();

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SimpleReplaceAdverbsMent.java
Patch:
@@ -19,6 +19,7 @@
 package org.languagetool.rules.ca;
 
 import org.languagetool.Tag;
+import org.languagetool.language.Catalan;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Category;
 import org.languagetool.rules.CategoryId;
@@ -50,7 +51,7 @@ public Map<String, List<String>> getWrongWords() {
   }
   
   public SimpleReplaceAdverbsMent(final ResourceBundle messages) throws IOException {
-    super(messages);
+    super(messages, new Catalan());
     super.setCategory(new Category(new CategoryId("PICKY_STYLE"), "regles d'estil, mode perfeccionaista"));
     super.setLocQualityIssueType(ITSIssueType.Style);
     super.setDefaultOff();

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SimpleReplaceBalearicRule.java
Patch:
@@ -19,6 +19,7 @@
 package org.languagetool.rules.ca;
 
 import org.languagetool.AnalyzedTokenReadings;
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Categories;
 import org.languagetool.rules.ITSIssueType;
@@ -48,8 +49,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
   
-  public SimpleReplaceBalearicRule(final ResourceBundle messages) throws IOException {
-    super(messages);
+  public SimpleReplaceBalearicRule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
     super.setLocQualityIssueType(ITSIssueType.Misspelling);
     this.setCheckLemmas(false);

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SimpleReplaceRule.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.rules.ca;
 
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Categories;
 import org.languagetool.rules.ITSIssueType;
@@ -47,8 +48,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
 
-  public SimpleReplaceRule(final ResourceBundle messages) throws IOException {
-    super(messages);
+  public SimpleReplaceRule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
     super.setLocQualityIssueType(ITSIssueType.Misspelling);
     this.setIgnoreTaggedWords();

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SimpleReplaceVerbsRule.java
Patch:
@@ -62,7 +62,7 @@ public Map<String, List<String>> getWrongWords() {
   private final CatalanSynthesizer synth;
 
   public SimpleReplaceVerbsRule(final ResourceBundle messages, Language language) {
-    super(messages);
+    super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
     super.setLocQualityIssueType(ITSIssueType.Misspelling);
     super.setIgnoreTaggedWords();

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/CheckCaseRuleTest.java
Patch:
@@ -35,8 +35,8 @@ public class CheckCaseRuleTest {
 
   @Before
   public void setUp() throws Exception {
-    rule = new CheckCaseRule(TestTools.getMessages("ca"), new Catalan());
     lt = new JLanguageTool(new Catalan());
+    rule = new CheckCaseRule(TestTools.getMessages("ca"), lt.getLanguage());
   }
 
   @Test

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/SimpleReplaceBalearicRuleTest.java
Patch:
@@ -40,8 +40,8 @@ public class SimpleReplaceBalearicRuleTest {
 
   @Before
   public void setUp() throws Exception {
-    rule = new SimpleReplaceBalearicRule(TestTools.getMessages("ca"));
     lt = new JLanguageTool(new Catalan());
+    rule = new SimpleReplaceBalearicRule(TestTools.getMessages("ca"), lt.getLanguage());
   }
 
   @Test

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/SimpleReplaceRuleTest.java
Patch:
@@ -40,8 +40,8 @@ public class SimpleReplaceRuleTest {
 
   @Before
   public void setUp() throws Exception {
-    rule = new SimpleReplaceRule(TestTools.getMessages("ca"));
     lt = new JLanguageTool(new Catalan());
+    rule = new SimpleReplaceRule(TestTools.getMessages("ca"), lt.getLanguage());
   }
 
   @Test

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -218,7 +218,7 @@ public List<Rule> getRelevantLanguageModelRules(ResourceBundle messages, Languag
     return Arrays.asList(
       new UpperCaseNgramRule(messages, languageModel, this),
       new GermanConfusionProbabilityRule(messages, languageModel, this),
-      new ProhibitedCompoundRule(messages, languageModel, userConfig)
+      new ProhibitedCompoundRule(messages, languageModel, userConfig, this)
     );
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -197,7 +197,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
         new AvsAnRule(messages),
         new EnglishWordRepeatBeginningRule(messages, this),
         new CompoundRule(messages, this, userConfig),
-        new ContractionSpellingRule(messages),
+        new ContractionSpellingRule(messages, this),
         new EnglishWrongWordInContextRule(messages),
         new EnglishDashRule(messages),
         new WordCoherencyRule(messages),

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/ContractionSpellingRule.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.Map;
 import java.util.ResourceBundle;
 
+import org.languagetool.Language;
 import org.languagetool.rules.*;
 import org.languagetool.tools.Tools;
 
@@ -45,8 +46,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
 
-  public ContractionSpellingRule(ResourceBundle messages) {
-    super(messages);
+  public ContractionSpellingRule(ResourceBundle messages, Language language) {
+    super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Misspelling);
     addExamplePair(Example.wrong("We <marker>havent</marker> earned anything."),

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/ContractionSpellingRuleTest.java
Patch:
@@ -37,8 +37,8 @@ public class ContractionSpellingRuleTest {
 
   @Before
   public void setUp() throws Exception {
-    rule = new ContractionSpellingRule(TestTools.getMessages("en"));
     lt = new JLanguageTool(Languages.getLanguageForShortCode("en"));
+    rule = new ContractionSpellingRule(TestTools.getMessages("en"), lt.getLanguage());
   }
 
   @Test

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -125,7 +125,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new SpanishWrongWordInContextRule(messages),
             new LongSentenceRule(messages, userConfig, 60),
             new LongParagraphRule(messages, this, userConfig),
-            new SimpleReplaceRule(messages),
+            new SimpleReplaceRule(messages, this),
             new SimpleReplaceVerbsRule(messages, this),
             new SpanishWordRepeatBeginningRule(messages, this),
             new CompoundRule(messages, this, userConfig),

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/SimpleReplaceRule.java
Patch:
@@ -19,6 +19,7 @@
  * USA
  */
 
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Categories;
 import org.languagetool.rules.ITSIssueType;
@@ -47,8 +48,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
 
-  public SimpleReplaceRule(final ResourceBundle messages) throws IOException {
-    super(messages);
+  public SimpleReplaceRule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
     super.setLocQualityIssueType(ITSIssueType.Misspelling);
     this.setIgnoreTaggedWords();

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/SimpleReplaceVerbsRule.java
Patch:
@@ -65,7 +65,7 @@ public Map<String, List<String>> getWrongWords() {
   private final SpanishSynthesizer synth;
 
   public SimpleReplaceVerbsRule(final ResourceBundle messages, Language language) {
-    super(messages);
+    super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
     super.setLocQualityIssueType(ITSIssueType.Misspelling);
     super.setIgnoreTaggedWords();

File: languagetool-language-modules/es/src/test/java/org/languagetool/rules/es/SimpleReplaceRuleTest.java
Patch:
@@ -40,8 +40,8 @@ public class SimpleReplaceRuleTest {
 
   @Before
   public void setUp() throws Exception {
-    rule = new SimpleReplaceRule(TestTools.getMessages("es"));
     lt = new JLanguageTool(new Spanish());
+    rule = new SimpleReplaceRule(TestTools.getMessages("es"), lt.getLanguage());
   }
 
   @Test

File: languagetool-language-modules/fa/src/main/java/org/languagetool/language/Persian.java
Patch:
@@ -79,7 +79,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
         new PersianDoublePunctuationRule(messages),
         new PersianWordRepeatBeginningRule(messages, this),
         new PersianWordRepeatRule(messages, this),
-        new SimpleReplaceRule(messages),
+        new SimpleReplaceRule(messages, this),
         new PersianSpaceBeforeRule(messages, this),
         new WordCoherencyRule(messages)
     );

File: languagetool-language-modules/fa/src/main/java/org/languagetool/rules/fa/SimpleReplaceRule.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.rules.fa;
 
+import org.languagetool.Language;
 import org.languagetool.rules.*;
 
 import java.io.IOException;
@@ -33,8 +34,8 @@ public class SimpleReplaceRule extends AbstractSimpleReplaceRule {
 
   private static final Map<String, List<String>> wrongWords = loadFromPath("/fa/replace.txt");
 
-  public SimpleReplaceRule(ResourceBundle messages) throws IOException {
-    super(messages);
+  public SimpleReplaceRule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
     super.setCategory(Categories.CONFUSED_WORDS.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Misspelling);
     addExamplePair(Example.wrong("وی <marker>حاظر</marker> به همکاری شد."),

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -124,7 +124,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new CompoundRule(messages, this, userConfig),
             new QuestionWhitespaceStrictRule(messages, this),
             new QuestionWhitespaceRule(messages, this),
-            new SimpleReplaceRule(messages),
+            new SimpleReplaceRule(messages, this),
             new FrenchRepeatedWordsRule(messages)
     );
   }

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/SimpleReplaceRule.java
Patch:
@@ -19,6 +19,7 @@
  * USA
  */
 
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Categories;
 import org.languagetool.rules.ITSIssueType;
@@ -47,8 +48,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
   
-  public SimpleReplaceRule(final ResourceBundle messages) throws IOException {
-    super(messages);
+  public SimpleReplaceRule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
     super.setLocQualityIssueType(ITSIssueType.Misspelling);
     this.setIgnoreTaggedWords();

File: languagetool-language-modules/fr/src/test/java/org/languagetool/rules/fr/SimpleReplaceRuleTest.java
Patch:
@@ -40,8 +40,8 @@ public class SimpleReplaceRuleTest {
 
   @Before
   public void setUp() throws Exception {
-    rule = new SimpleReplaceRule(TestTools.getMessages("fr"));
     lt = new JLanguageTool(new French());
+    rule = new SimpleReplaceRule(TestTools.getMessages("fr"), lt.getLanguage());
   }
 
   @Test

File: languagetool-language-modules/ga/src/main/java/org/languagetool/rules/ga/DativePluralStandardReplaceRule.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.rules.ga;
 
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Categories;
 import org.languagetool.rules.Example;
@@ -55,8 +56,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
 
-  public DativePluralStandardReplaceRule(final ResourceBundle messages) throws IOException {
-    super(messages);
+  public DativePluralStandardReplaceRule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
     super.setLocQualityIssueType(ITSIssueType.Grammar);
     addExamplePair(Example.wrong("Dá mba thruamhéalach é cás an sclábhaí fir, ba mheasa fós do na <marker>mnáibh</marker> a gcás siúd."),

File: languagetool-language-modules/ga/src/main/java/org/languagetool/rules/ga/EnglishHomophoneRule.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.rules.ga;
 
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Categories;
 import org.languagetool.rules.Example;
@@ -49,8 +50,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
 
-  public EnglishHomophoneRule(final ResourceBundle messages) throws IOException {
-    super(messages);
+  public EnglishHomophoneRule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
     super.setLocQualityIssueType(ITSIssueType.Misspelling);
     addExamplePair(Example.wrong("An bhialann <marker>sushi</marker> sin ba chúis leis."),

File: languagetool-language-modules/ga/src/main/java/org/languagetool/rules/ga/IrishFGBEqReplaceRule.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.rules.ga;
 
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Categories;
 import org.languagetool.rules.Example;
@@ -49,8 +50,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
 
-  public IrishFGBEqReplaceRule(final ResourceBundle messages) throws IOException {
-    super(messages);
+  public IrishFGBEqReplaceRule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
     super.setLocQualityIssueType(ITSIssueType.Misspelling);
     addExamplePair(Example.wrong("An bhfuil tú <marker>urlamh</marker>?"),

File: languagetool-language-modules/ga/src/main/java/org/languagetool/rules/ga/IrishReplaceRule.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.rules.ga;
 
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Categories;
 import org.languagetool.rules.Example;
@@ -48,8 +49,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
 
-  public IrishReplaceRule(final ResourceBundle messages) throws IOException {
-    super(messages);
+  public IrishReplaceRule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
     super.setLocQualityIssueType(ITSIssueType.Misspelling);
     addExamplePair(Example.wrong("Níl beann agam oraibh, ar <marker>bhúr</marker> gcuid cainte."),

File: languagetool-language-modules/ga/src/main/java/org/languagetool/rules/ga/LogainmRule.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.rules.ga;
 
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Categories;
 import org.languagetool.rules.ITSIssueType;
@@ -49,8 +50,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
   
-  public LogainmRule(final ResourceBundle messages) throws IOException {
-    super(messages);
+  public LogainmRule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
     super.setLocQualityIssueType(ITSIssueType.Misspelling);
     this.setIgnoreTaggedWords();

File: languagetool-language-modules/ga/src/main/java/org/languagetool/rules/ga/PeopleRule.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.rules.ga;
 
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Categories;
 import org.languagetool.rules.Example;
@@ -48,8 +49,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
   
-  public PeopleRule(final ResourceBundle messages) throws IOException {
-    super(messages);
+  public PeopleRule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
     super.setLocQualityIssueType(ITSIssueType.Misspelling);
     addExamplePair(Example.wrong("Bhí sí cosúil le claíomh <marker>Damocles</marker> ar crochadh sa spéir."),

File: languagetool-language-modules/ga/src/main/java/org/languagetool/rules/ga/PrestandardReplaceRule.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.rules.ga;
 
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Categories;
 import org.languagetool.rules.Example;
@@ -48,8 +49,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
 
-  public PrestandardReplaceRule(final ResourceBundle messages) throws IOException {
-    super(messages);
+  public PrestandardReplaceRule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
     super.setLocQualityIssueType(ITSIssueType.Misspelling);
     addExamplePair(Example.wrong("“Ní <marker>baoghal</marker> daoibh,” ar sise."),

File: languagetool-language-modules/ga/src/main/java/org/languagetool/rules/ga/SpacesRule.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.rules.ga;
 
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Categories;
 import org.languagetool.rules.ITSIssueType;
@@ -47,8 +48,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
   
-  public SpacesRule(final ResourceBundle messages) throws IOException {
-    super(messages);
+  public SpacesRule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
     super.setLocQualityIssueType(ITSIssueType.Misspelling);
     this.setIgnoreTaggedWords();

File: languagetool-language-modules/gl/src/main/java/org/languagetool/language/Galician.java
Patch:
@@ -118,8 +118,8 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new ParagraphRepeatBeginningRule(messages, this),
             new PunctuationMarkAtParagraphEnd(messages, this),
             // Specific to Galician:
-            new SimpleReplaceRule(messages),
-            new CastWordsRule(messages),
+            new SimpleReplaceRule(messages, this),
+            new CastWordsRule(messages, this),
             new GalicianRedundancyRule(messages),
             new GalicianWordinessRule(messages),
             new GalicianBarbarismsRule(messages),

File: languagetool-language-modules/gl/src/main/java/org/languagetool/rules/gl/CastWordsRule.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.Map;
 import java.util.ResourceBundle;
 
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 
 /**
@@ -49,8 +50,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
 
-  public CastWordsRule(ResourceBundle messages) throws IOException {
-    super(messages);
+  public CastWordsRule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
   }
 
   @Override

File: languagetool-language-modules/gl/src/main/java/org/languagetool/rules/gl/SimpleReplaceRule.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.Map;
 import java.util.ResourceBundle;
 
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 
 /**
@@ -49,8 +50,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
 
-  public SimpleReplaceRule(ResourceBundle messages) throws IOException {
-    super(messages);
+  public SimpleReplaceRule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
   }
 
   @Override

File: languagetool-language-modules/pl/src/main/java/org/languagetool/language/Polish.java
Patch:
@@ -100,7 +100,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
         new MorfologikPolishSpellerRule(messages, this, userConfig, altLanguages),
         new PolishWordRepeatRule(messages),
         new CompoundRule(messages, this, userConfig),
-        new SimpleReplaceRule(messages),
+        new SimpleReplaceRule(messages, this),
         new WordCoherencyRule(messages),
         new DashRule(messages)
         );

File: languagetool-language-modules/pl/src/main/java/org/languagetool/rules/pl/SimpleReplaceRule.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.Map;
 import java.util.ResourceBundle;
 
+import org.languagetool.Language;
 import org.languagetool.rules.*;
 
 /**
@@ -47,8 +48,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
 
-  public SimpleReplaceRule(ResourceBundle messages) throws IOException {
-    super(messages);
+  public SimpleReplaceRule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
     setLocQualityIssueType(ITSIssueType.Misspelling);
     setCategory(new Category(new CategoryId("PRAWDOPODOBNE_LITEROWKI"), "Prawdopodobne literówki"));
     setCheckLemmas(false);

File: languagetool-language-modules/pl/src/test/java/org/languagetool/rules/pl/SimpleReplaceRuleTest.java
Patch:
@@ -40,8 +40,8 @@ public class SimpleReplaceRuleTest {
 
   @Before
   public void setUp() throws Exception {
-    rule = new SimpleReplaceRule(TestTools.getMessages("pl"));
     lt = new JLanguageTool(new Polish());
+    rule = new SimpleReplaceRule(TestTools.getMessages("pl"), lt.getLanguage());
   }
 
   @Test

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/PortugalPortuguese.java
Patch:
@@ -46,7 +46,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
     List<Rule> rules = new ArrayList<>(super.getRelevantRules(messages, userConfig, motherTongue, altLanguages));
     rules.add(new PostReformPortugueseCompoundRule(messages, this, userConfig));
     rules.add(new PostReformPortugueseDashRule(messages));
-    rules.add(new PortugueseAgreementReplaceRule(messages));
+    rules.add(new PortugueseAgreementReplaceRule(messages, this));
     rules.add(new PortugalPortugueseReplaceRule(messages, "/pt/pt-PT/replace.txt"));
     rules.add(new PortugueseBarbarismsRule(messages, "/pt/pt-PT/barbarisms.txt"));
     rules.add(new PortugueseArchaismsRule(messages, "/pt/pt-PT/archaisms.txt"));

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -126,7 +126,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new PunctuationMarkAtParagraphEnd(messages, this, true),
             //Specific to Portuguese:
             new PostReformPortugueseCompoundRule(messages, this, userConfig),
-            new PortugueseReplaceRule(messages),
+            new PortugueseReplaceRule(messages, this),
             new PortugueseBarbarismsRule(messages, "/pt/barbarisms.txt"),
             //new PortugueseArchaismsRule(messages, "/pt/archaisms-pt.txt"),   // see https://github.com/languagetool-org/languagetool/issues/3095
             new PortugueseClicheRule(messages, "/pt/cliches.txt"),

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseAgreementReplaceRule.java
Patch:
@@ -18,13 +18,13 @@
  */
 package org.languagetool.rules.pt;
 
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Example;
 import org.languagetool.rules.Categories;
 import org.languagetool.rules.ITSIssueType;
 import org.languagetool.tools.Tools;
 
-import java.io.IOException;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
@@ -49,8 +49,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
 
-  public PortugueseAgreementReplaceRule(ResourceBundle messages) {
-    super(messages);
+  public PortugueseAgreementReplaceRule(ResourceBundle messages, Language language) {
+    super(messages, language);
     super.setCategory(Categories.TYPOS.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Misspelling);
     // setDefaultOff();

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseReplaceRule.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.rules.pt;
 
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Categories;
 import org.languagetool.rules.ITSIssueType;
@@ -48,8 +49,8 @@ public Map<String, List<String>> getWrongWords() {
     return wrongWords;
   }
 
-  public PortugueseReplaceRule(ResourceBundle messages) {
-    super(messages);
+  public PortugueseReplaceRule(ResourceBundle messages, Language language) {
+    super(messages, language);
     super.setCategory(Categories.STYLE.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.LocaleViolation);
     useSubRuleSpecificIds();

File: languagetool-language-modules/uk/src/main/java/org/languagetool/language/Ukrainian.java
Patch:
@@ -172,15 +172,15 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
 
         new MixedAlphabetsRule(messages),
 
-        new SimpleReplaceSoftRule(messages),
+        new SimpleReplaceSoftRule(messages, this),
         new SimpleReplaceRenamedRule(messages),
         getSpellingReplacementRule(messages),
-        new SimpleReplaceRule(messages, morfologikSpellerRule)
+        new SimpleReplaceRule(messages, morfologikSpellerRule, this)
     );
   }
 
   protected Rule getSpellingReplacementRule(ResourceBundle messages) throws IOException {
-    return new SimpleReplaceSpelling1992Rule(messages);
+    return new SimpleReplaceSpelling1992Rule(messages, this);
   }
 
   @Override

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/SimpleReplaceSoftRule.java
Patch:
@@ -27,6 +27,7 @@
 
 import org.apache.commons.lang3.StringUtils;
 import org.languagetool.AnalyzedTokenReadings;
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.ITSIssueType;
 
@@ -52,8 +53,8 @@ public Map<String, List<String>> getWrongWords() {
     return WRONG_WORDS;
   }
 
-  public SimpleReplaceSoftRule(ResourceBundle messages) throws IOException {
-    super(messages);
+  public SimpleReplaceSoftRule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
     setLocQualityIssueType(ITSIssueType.Style);
   }
 

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/SimpleReplaceSpelling1992Rule.java
Patch:
@@ -27,6 +27,7 @@
 import org.apache.commons.lang3.StringUtils;
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.AnalyzedTokenReadings;
+import org.languagetool.Language;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.RuleMatch;
@@ -53,8 +54,8 @@ public Map<String, List<String>> getWrongWords() {
     return WRONG_WORDS;
   }
 
-  public SimpleReplaceSpelling1992Rule(ResourceBundle messages) throws IOException {
-    super(messages);
+  public SimpleReplaceSpelling1992Rule(ResourceBundle messages, Language language) throws IOException {
+    super(messages, language);
     setLocQualityIssueType(ITSIssueType.Misspelling);
   }
 

File: languagetool-language-modules/uk/src/test/java/org/languagetool/rules/uk/SimpleReplaceSoftRuleTest.java
Patch:
@@ -36,10 +36,10 @@ public class SimpleReplaceSoftRuleTest {
 
   @Test
   public void testRule() throws IOException {
-    SimpleReplaceSoftRule rule = new SimpleReplaceSoftRule(TestTools.getEnglishMessages());
+    JLanguageTool lt = new JLanguageTool(new Ukrainian());
+    SimpleReplaceSoftRule rule = new SimpleReplaceSoftRule(TestTools.getEnglishMessages(), lt.getLanguage());
 
     RuleMatch[] matches;
-    JLanguageTool lt = new JLanguageTool(new Ukrainian());
 
     // correct sentences:
     matches = rule.match(lt.getAnalyzedSentence("Ці рядки повинні збігатися."));

File: languagetool-language-modules/uk/src/test/java/org/languagetool/rules/uk/SimpleReplaceSpelling1992RuleTest.java
Patch:
@@ -35,10 +35,11 @@ public class SimpleReplaceSpelling1992RuleTest {
 
   @Test
   public void testRule() throws IOException {
-    SimpleReplaceSpelling1992Rule rule = new SimpleReplaceSpelling1992Rule(TestTools.getEnglishMessages());
+    JLanguageTool lt = new JLanguageTool(Ukrainian.DEFAULT_VARIANT);
+    SimpleReplaceSpelling1992Rule rule = new SimpleReplaceSpelling1992Rule(TestTools.getEnglishMessages(),
+      lt.getLanguage());
 
     RuleMatch[] matches;
-    JLanguageTool lt = new JLanguageTool(Ukrainian.DEFAULT_VARIANT);
 
     // correct sentences:
     matches = rule.match(lt.getAnalyzedSentence("Це — новий проєкт для фоє."));

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -324,7 +324,6 @@ protected int getPriorityForId(String id) {
       case "YOU_GOOD":                  return 3;   // prefer over AI_HYDRA_LEO_CP (YOU_YOURE etc.) // prefer over PRP_PAST_PART
       case "DOS_AND_DONTS":             return 3;
       case "IF_YOU_FURTHER_QUESTIONS":  return 3;   // higher prio than agreement rules and AI
-      case "EN_COMPOUNDS":              return 2;
       case "ABBREVIATION_PUNCTUATION":  return 2;
       case "READ_ONLY_ACCESS_HYPHEN":   return 2;   // higher priority than agreement rules
       case "MAKE_OR_BREAK_HYPHEN":   return 2;   // higher priority than agreement rules
@@ -641,6 +640,9 @@ protected int getPriorityForId(String id) {
       case LongParagraphRule.RULE_ID:   return -998;
       case "ALL_UPPERCASE":             return -1000;  // do not hide spelling and grammar issues, when text is all upper case
     }
+    if (id.startsWith("EN_COMPOUNDS_")) {
+      return 2;
+    }
     if (id.startsWith("CONFUSION_RULE_")) {
       return -20;
     }

File: languagetool-language-modules/ca/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -37,7 +37,7 @@ public void testCleanOverlappingErrors() throws IOException {
     JLanguageTool tool = new JLanguageTool(lang);
     List<RuleMatch> matches = tool.check("prosper");
     assertEquals(1, matches.size());
-    assertEquals("CA_SIMPLE_REPLACE_BALEARIC", matches.get(0).getRule().getId());
+    assertEquals("CA_SIMPLE_REPLACE_BALEARIC_PROSPER", matches.get(0).getRule().getId());
 
     matches = tool.check("Potser siga el millor");
     assertEquals(1, matches.size());

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/PortugueseWikipediaRuleTest.java
Patch:
@@ -55,9 +55,9 @@ public void testRule() throws IOException {
     // incorrect sentences:
 
     // at the beginning of a sentence (Romanian replace rule is case-sensitive)
-    checkSimpleReplaceRule("50 graus centígrados.", "graus Celsius");
+    checkSimpleReplaceRule("Melhores colocados.", "Mais bem colocados");
     // inside sentence
-    checkSimpleReplaceRule("40 Graus centígrados.", "Graus Celsius");
+    checkSimpleReplaceRule("Os 20 melhores colocados.", "mais bem colocados");
   }
 
   /**

File: languagetool-core/src/main/java/org/languagetool/rules/GRPCRule.java
Patch:
@@ -303,7 +303,7 @@ protected Callable<RemoteRuleResult> executeRequest(RemoteRequest requestArg, lo
       MLRuleRequest reqArgs = (MLRuleRequest) requestArg;
       // NOTE: disabled for now, don't want to run this in the nightly diff
       boolean noRegression = Boolean.parseBoolean(serviceConfiguration.getOptions().getOrDefault("no-regression", "false"));
-      if (noRegression && (reqArgs.textSessionId == -1 || reqArgs.textSessionId == -2)) {
+      if (noRegression && reqArgs.textSessionId != null && (reqArgs.textSessionId == -1 || reqArgs.textSessionId == -2)) {
         return new RemoteRuleResult(false, true, Collections.emptyList(), reqArgs.sentences);
       }
 

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractSimpleReplaceRule2.java
Patch:
@@ -328,7 +328,7 @@ protected boolean isTokenException(AnalyzedTokenReadings atr) {
   /**
    * Create a warning if a key word of the replacement rule is not allowed by the speller rule.
    */
-  public boolean checkWeyWordsInTests() {
+  public boolean checkKeyWordsInTests() {
     return false;
   }
 

File: languagetool-core/src/test/java/org/languagetool/LanguageSpecificTest.java
Patch:
@@ -84,7 +84,7 @@ protected void testReplaceRuleReplacements(Language lang) throws IOException {
                 System.err.println("*** WARNING: replacement '" + repl + "' for '" + s + "' from one of " + replRule.getFileNames() +
                   " isn't known to spell checker of " + lang + ": " + Arrays.toString(matches));
               }
-              if (replRule.checkWeyWordsInTests()) {
+              if (replRule.checkKeyWordsInTests()) {
                 RuleMatch[] matches2 = spellRule.match(lt.getAnalyzedSentence(s));
                 if (matches2.length > 0) {
                   System.err.println("*** WARNING: key word '" + s + "' from one of " + replRule.getFileNames() +

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseArchaismsRule.java
Patch:
@@ -74,7 +74,7 @@ public String getShort() {
 
   @Override
   public String getMessage() {
-    return "'$match' é um arcaísmo. É preferível dizer $suggestions.";
+    return "\"$match\" é um arcaísmo. É preferível dizer $suggestions.";
   }
 
   @Override

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseBarbarismsRule.java
Patch:
@@ -78,7 +78,7 @@ public String getShort() {
 
   @Override
   public String getMessage() {
-    return "'$match' é um estrangeirismo. É preferível dizer $suggestions.";
+    return "\"$match\" é um estrangeirismo. É preferível dizer $suggestions.";
   }
 
   @Override

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseClicheRule.java
Patch:
@@ -78,7 +78,7 @@ public String getShort() {
 
   @Override
   public String getMessage() {
-    return "'$match' é uma frase-feita. É preferível dizer $suggestions.";
+    return "\"$match\" é uma frase-feita. É preferível dizer $suggestions.";
   }
 
   @Override

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseRedundancyRule.java
Patch:
@@ -76,7 +76,7 @@ public String getShort() {
 
   @Override
   public String getMessage() {
-    return "'$match' é um pleonasmo. É preferível dizer $suggestions";
+    return "\"$match\" é um pleonasmo. É preferível dizer $suggestions";
   }
 
   @Override

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseWikipediaRule.java
Patch:
@@ -77,7 +77,7 @@ public String getShort() {
   
   @Override
   public String getMessage() {
-    return "'$match' é um erro. Considere utilizar $suggestions";
+    return "Possível erro em \"$match\". Prefira $suggestions";
   }
 
   @Override

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseWordinessRule.java
Patch:
@@ -76,7 +76,7 @@ public String getShort() {
 
   @Override
   public String getMessage() {
-    return "'$match' é uma expressão prolixa. É preferível dizer $suggestions.";
+    return "\"$match\" é uma expressão prolixa. É preferível dizer $suggestions.";
   }
 
   @Override

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/PortugueseWikipediaRuleTest.java
Patch:
@@ -55,9 +55,9 @@ public void testRule() throws IOException {
     // incorrect sentences:
 
     // at the beginning of a sentence (Romanian replace rule is case-sensitive)
-    checkSimpleReplaceRule("Isto é tecnologia do século 21.", "século XXI");
+    checkSimpleReplaceRule("50 graus centígrados.", "graus Celsius");
     // inside sentence
-    checkSimpleReplaceRule("Isto é tecnologia do Século 21.", "Século XXI");
+    checkSimpleReplaceRule("40 Graus centígrados.", "Graus Celsius");
   }
 
   /**

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/PortugueseClicheRuleTest.java
Patch:
@@ -42,7 +42,7 @@ public class PortugueseClicheRuleTest {
 
   @Before
   public void setUp() throws Exception {
-    rule = new PortugueseClicheRule(TestTools.getMessages("pt"), "/pt/cliches-pt.txt");
+    rule = new PortugueseClicheRule(TestTools.getMessages("pt"), "/pt/cliches.txt");
     lt = new JLanguageTool(new Portuguese());
   }
 

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/PortugueseWikipediaRuleTest.java
Patch:
@@ -42,7 +42,7 @@ public class PortugueseWikipediaRuleTest {
 
   @Before
   public void setUp() throws Exception {
-    rule = new PortugueseWikipediaRule(TestTools.getMessages("pt"), "/pt/wikipedia-pt.txt");
+    rule = new PortugueseWikipediaRule(TestTools.getMessages("pt"), "/pt/wikipedia.txt");
     lt = new JLanguageTool(new Portuguese());
   }
 

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/BrazilianPortugueseReplaceRule.java
Patch:
@@ -69,12 +69,12 @@ public String getDescription() {
 
   @Override
   public String getShort() {
-    return "Palavra de português de Portugal";
+    return "Palavra do português de Portugal";
   }
 
   @Override
   public String getMessage() {
-    return "'$match' é uma expressão de Portugal, em português do Brasil utiliza-se: $suggestions";
+    return "\"$match\" é uma expressão usada sobretudo em Portugal. No português brasileiro diz-se $suggestions";
   }
 
   @Override

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/FrenchRepeatedWordsRule.java
Patch:
@@ -28,7 +28,7 @@
 import java.util.Map;
 import java.util.ResourceBundle;
 
-public class FrenchRepeatedWordsRule extends AbstractRepeatedWordsRule{
+public class FrenchRepeatedWordsRule extends AbstractRepeatedWordsRule {
 
   public FrenchRepeatedWordsRule(ResourceBundle messages) {
     super(messages, new French());

File: languagetool-core/src/test/java/org/languagetool/LanguageSpecificTest.java
Patch:
@@ -236,7 +236,7 @@ private void testNoQuotesAroundSuggestion(Language lang) throws IOException {
       System.out.println("Skipping testNoQuotesAroundSuggestion for " + lang.getName());
       return;
     }
-    System.out.println("Testing that there no quotes around <suggestion>s...");
+    System.out.println("Testing that there are no quotes around <suggestion>s...");
     String dirBase = JLanguageTool.getDataBroker().getRulesDir() + "/" + lang.getShortCode() + "/";
     for (String ruleFileName : lang.getRuleFileNames()) {
       if (ruleFileName.contains("-test-")) {

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/RuleIdValidator.java
Patch:
@@ -50,7 +50,8 @@ public void validateUniqueness() {
     List<Rule> allRules = new JLanguageTool(lang).getAllRules();
     System.out.println("Loaded " + allRules.size() + " rules...");
     for (Rule rule : allRules) {
-      if (!(rule instanceof AbstractPatternRule || rule instanceof RepeatedPatternRuleTransformer.RepeatedPatternRule)) {
+      if (!(rule instanceof AbstractPatternRule || rule instanceof RepeatedPatternRuleTransformer.RepeatedPatternRule
+        || rule instanceof ConsistencyPatternRuleTransformer.ConsistencyPatternRule)) {
         idsToFile.put(rule.getId(), "Java (" + rule.getClass().getName() + ")");
       }
     }

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -37,9 +37,7 @@ public class PatternRuleHandler extends XMLRuleHandler {
 
   @Override
   public InputSource resolveEntity(String publicId, String systemId) throws IOException, SAXException {
-    ResourceDataBroker broker = JLanguageTool.getDataBroker();
-    URL absoluteUrl = broker.getAsURL(this.sourceFile);
-    return new RuleEntityResolver(absoluteUrl).resolveEntity(publicId, systemId);
+    return new RuleEntityResolver().resolveEntity(publicId, systemId);
   }
 
   public static final String TYPE = "type";

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationRuleHandler.java
Patch:
@@ -42,9 +42,7 @@ class DisambiguationRuleHandler extends XMLRuleHandler {
 
   @Override
   public InputSource resolveEntity(String publicId, String systemId) throws IOException, SAXException {
-    ResourceDataBroker broker = JLanguageTool.getDataBroker();
-    URL absoluteUrl = broker.getFromResourceDirAsUrl(this.sourceFile);
-    return new RuleEntityResolver(absoluteUrl).resolveEntity(publicId, systemId);
+    return new RuleEntityResolver().resolveEntity(publicId, systemId);
   }
 
   private boolean inDisambiguation;

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/RuleIdValidator.java
Patch:
@@ -87,9 +87,7 @@ private static class XmlIdHandler extends DefaultHandler {
 
     @Override
     public InputSource resolveEntity(String publicId, String systemId) throws IOException, SAXException {
-      ResourceDataBroker broker = JLanguageTool.getDataBroker();
-      URL absoluteUrl = broker.getAsURL(this.xmlPath);
-      return new RuleEntityResolver(absoluteUrl).resolveEntity(publicId, systemId);
+      return new RuleEntityResolver().resolveEntity(publicId, systemId);
     }
 
     @Override

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -231,10 +231,10 @@ public void startElement(String namespaceURI, String lName,
         }
         id = idPrefix != null ? idPrefix + id : id;
         if (inRuleGroup && ruleGroupDefaultOff && attrs.getValue(DEFAULT) != null) {
-          throw new RuntimeException("Rule group " + ruleGroupId + " is off by default, thus rule " + id + " cannot specify 'default=...'");
+          throw new RuntimeException("Rule group " + ruleGroupId + " is off by default, thus a subrule of " + id + " cannot specify 'default=...'. \033[1m Remove 'default=...' from rule group or subrule level in " + ruleGroupId + "!\033[0m");
         }
         if (inRuleGroup && ruleGroupDefaultTempOff && attrs.getValue(DEFAULT) != null) {
-          throw new RuntimeException("Rule group " + ruleGroupId + " is off by default, thus rule " + id + " cannot specify 'default=...'");
+          throw new RuntimeException("Rule group " + ruleGroupId + " is off by default, thus a subrule of " + id + " cannot specify 'default=...'. \033[1m Remove 'default=...' from rule group or subrule level in " + ruleGroupId + "!\033[0m");
         }
         if (inRuleGroup && ruleGroupDefaultOff) {
           defaultOff = true;

File: languagetool-language-modules/sv/src/test/java/org/languagetool/tagging/sv/SwedishTaggerTest.java
Patch:
@@ -45,7 +45,7 @@ public void testDictionary() throws IOException {
   @Test
   public void testTagger() throws IOException {
     TestTools.myAssert("Det är nog bäst att du får en klubba till",
-        "Det/[det]PN -- är/[vara]VB:PRS -- nog/[nog]AB -- bäst/[bra]JJ:S|bäst/[bäst]AB|bäst/[god]JJ:S -- att/[att]KN -- du/[du]PN -- får/[få]VB:PRS|får/[får]NN:OF:PLU:NOM:NEU|får/[får]NN:OF:SIN:NOM:NEU -- en/[en]NN:OF:SIN:NOM:UTR|en/[en]PN|en/[passant]en passant NN:OF:SIN:NOM:UTR|en/[passanten]en passant NN:BF:SIN:NOM:UTR|en/[passantens]en passant NN:BF:SIN:GEN:UTR|en/[passanter]en passant NN:OF:PLU:NOM:UTR|en/[passanterna]en passant NN:BF:PLU:NOM:UTR|en/[passanternas]en passant NN:BF:PLU:GEN:UTR|en/[passanters]en passant NN:OF:PLU:GEN:UTR|en/[passants]en passant NN:OF:SIN:GEN:UTR -- klubba/[klubba]NN:OF:SIN:NOM:UTR|klubba/[klubba]VB:IMP|klubba/[klubba]VB:INF -- till/[till]AB|till/[till]PP", tokenizer, tagger);        
+        "Det/[det]PN -- är/[vara]VB:PRS -- nog/[nog]AB -- bäst/[bra]JJ:S|bäst/[bäst]AB|bäst/[god]JJ:S -- att/[att]KN -- du/[du]PN -- får/[få]VB:PRS|får/[får]NN:OF:PLU:NOM:NEU|får/[får]NN:OF:SIN:NOM:NEU -- en/[en]NN:OF:SIN:NOM:UTR|en/[en]PN -- klubba/[klubba]NN:OF:SIN:NOM:UTR|klubba/[klubba]VB:IMP|klubba/[klubba]VB:INF -- till/[till]AB|till/[till]PP", tokenizer, tagger);        
     TestTools.myAssert("Du menar sannolikt \"massera\" om du inte skriver om masarnas era förstås.",
         "Du/[du]PN -- menar/[mena]VB:PRS -- sannolikt/[sannolik]JJ:PN|sannolikt/[sannolikt]AB -- massera/[massera]VB:IMP|massera/[massera]VB:INF -- om/[om]AB|om/[om]KN|om/[om]PP -- du/[du]PN -- inte/[inte]AB -- skriver/[skriva]VB:PRS -- om/[om]AB|om/[om]KN|om/[om]PP -- masarnas/[mas]NN:BF:PLU:GEN:UTR -- era/[era]NN:OF:SIN:NOM:UTR|era/[era]PN -- förstås/[förstå]VB:INF:PF|förstås/[förstå]VB:PRS:PF|förstås/[förstås]AB", tokenizer, tagger);        
   }

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -29,7 +29,6 @@
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.nio.file.Files;
 import java.util.List;
 
 /**
@@ -45,7 +44,7 @@ public class PatternRuleLoader extends DefaultHandler {
    * @param file XML file with pattern rules
    */
   public final List<AbstractPatternRule> getRules(File file, Language lang) throws IOException {
-    try (InputStream inputStream = Files.newInputStream(file.toPath())) {
+    try (InputStream inputStream = new FileInputStream(file)) {
       PatternRuleLoader ruleLoader = new PatternRuleLoader();
       return ruleLoader.getRules(inputStream, file.getAbsolutePath(), lang);
     }

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationRuleLoader.java
Patch:
@@ -39,9 +39,9 @@
  */
 public class DisambiguationRuleLoader extends DefaultHandler {
 
-  public final List<DisambiguationPatternRule> getRules(InputStream stream, Language language, String xmlPath)
+  public final List<DisambiguationPatternRule> getRules(InputStream stream, Language language)
       throws ParserConfigurationException, SAXException, IOException {
-    DisambiguationRuleHandler handler = new DisambiguationRuleHandler(language, xmlPath);
+    DisambiguationRuleHandler handler = new DisambiguationRuleHandler(language);
     SAXParserFactory factory = SAXParserFactory.newInstance();
     SAXParser saxParser = factory.newSAXParser();
 

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/XmlRuleDisambiguator.java
Patch:
@@ -29,7 +29,6 @@
 import org.xml.sax.SAXException;
 
 import javax.xml.parsers.ParserConfigurationException;
-import java.io.File;
 import java.io.IOException;
 import java.util.List;
 import java.util.Objects;
@@ -53,7 +52,7 @@ public XmlRuleDisambiguator(Language language) {
 
   public XmlRuleDisambiguator(Language language, boolean useGlobalDisambiguation) {
     Objects.requireNonNull(language);
-    String disambiguationFile = language.getShortCode() + File.separator + DISAMBIGUATION_FILE;
+    String disambiguationFile = language.getShortCode() + "/" + DISAMBIGUATION_FILE;
     List<DisambiguationPatternRule> disambiguationRulesList;
     try {
       disambiguationRulesList = loadPatternRules(disambiguationFile, language);
@@ -97,7 +96,7 @@ public AnalyzedSentence disambiguate(AnalyzedSentence sentence,
   protected List<DisambiguationPatternRule> loadPatternRules(String filename, Language language)
       throws ParserConfigurationException, SAXException, IOException {
     DisambiguationRuleLoader ruleLoader = new DisambiguationRuleLoader();
-    return ruleLoader.getRules(JLanguageTool.getDataBroker().getFromResourceDirAsStream(filename), language, filename);
+    return ruleLoader.getRules(JLanguageTool.getDataBroker().getFromResourceDirAsStream(filename), language);
   }
 
 }

File: languagetool-core/src/test/java/org/languagetool/LanguageSpecificTest.java
Patch:
@@ -243,7 +243,7 @@ private void testNoQuotesAroundSuggestion(Language lang) throws IOException {
         continue;
       }
       InputStream is = this.getClass().getResourceAsStream(ruleFileName);
-      List<AbstractPatternRule> rules = new PatternRuleLoader().getRules(is, ruleFileName, lang);
+      List<AbstractPatternRule> rules = new PatternRuleLoader().getRules(is, dirBase + "/" + ruleFileName, lang);
       for (AbstractPatternRule rule : rules) {
         String message = rule.getMessage();
         if (message.matches(".*['\"«»“”’]<suggestion.*") && message.matches(".*</suggestion>['\"«»“”’].*")) {

File: languagetool-language-modules/fr/src/test/java/org/languagetool/rules/spelling/hunspell/TestFrenchDisambiguator.java
Patch:
@@ -36,7 +36,7 @@ public AnalyzedSentence disambiguate(AnalyzedSentence input) throws IOException
     String filePath = "/disambiguator.xml";
     try (InputStream inputStream = getClass().getResourceAsStream(filePath)) {
       final DisambiguationRuleLoader ruleLoader = new DisambiguationRuleLoader();
-      List<DisambiguationPatternRule> disambiguationRules = ruleLoader.getRules(inputStream, new French(), filePath);
+      List<DisambiguationPatternRule> disambiguationRules = ruleLoader.getRules(inputStream, new French());
       for (final DisambiguationPatternRule patternRule : disambiguationRules) {
         sentence = patternRule.replace(sentence);
       }

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/PortuguesePatternRuleTest.java
Patch:
@@ -21,7 +21,6 @@
 import org.junit.Test;
 import org.languagetool.rules.patterns.PatternRuleTest;
 
-import java.io.File;
 import java.io.IOException;
 
 public class PortuguesePatternRuleTest extends PatternRuleTest {

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -29,6 +29,7 @@
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.file.Files;
 import java.util.List;
 
 /**
@@ -44,7 +45,7 @@ public class PatternRuleLoader extends DefaultHandler {
    * @param file XML file with pattern rules
    */
   public final List<AbstractPatternRule> getRules(File file, Language lang) throws IOException {
-    try (InputStream inputStream = new FileInputStream(file)) {
+    try (InputStream inputStream = Files.newInputStream(file.toPath())) {
       PatternRuleLoader ruleLoader = new PatternRuleLoader();
       return ruleLoader.getRules(inputStream, file.getAbsolutePath(), lang);
     }

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationRuleLoader.java
Patch:
@@ -39,9 +39,9 @@
  */
 public class DisambiguationRuleLoader extends DefaultHandler {
 
-  public final List<DisambiguationPatternRule> getRules(InputStream stream, Language language)
+  public final List<DisambiguationPatternRule> getRules(InputStream stream, Language language, String xmlPath)
       throws ParserConfigurationException, SAXException, IOException {
-    DisambiguationRuleHandler handler = new DisambiguationRuleHandler(language);
+    DisambiguationRuleHandler handler = new DisambiguationRuleHandler(language, xmlPath);
     SAXParserFactory factory = SAXParserFactory.newInstance();
     SAXParser saxParser = factory.newSAXParser();
 

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/XmlRuleDisambiguator.java
Patch:
@@ -29,6 +29,7 @@
 import org.xml.sax.SAXException;
 
 import javax.xml.parsers.ParserConfigurationException;
+import java.io.File;
 import java.io.IOException;
 import java.util.List;
 import java.util.Objects;
@@ -52,7 +53,7 @@ public XmlRuleDisambiguator(Language language) {
 
   public XmlRuleDisambiguator(Language language, boolean useGlobalDisambiguation) {
     Objects.requireNonNull(language);
-    String disambiguationFile = language.getShortCode() + "/" + DISAMBIGUATION_FILE;
+    String disambiguationFile = language.getShortCode() + File.separator + DISAMBIGUATION_FILE;
     List<DisambiguationPatternRule> disambiguationRulesList;
     try {
       disambiguationRulesList = loadPatternRules(disambiguationFile, language);
@@ -96,7 +97,7 @@ public AnalyzedSentence disambiguate(AnalyzedSentence sentence,
   protected List<DisambiguationPatternRule> loadPatternRules(String filename, Language language)
       throws ParserConfigurationException, SAXException, IOException {
     DisambiguationRuleLoader ruleLoader = new DisambiguationRuleLoader();
-    return ruleLoader.getRules(JLanguageTool.getDataBroker().getFromResourceDirAsStream(filename), language);
+    return ruleLoader.getRules(JLanguageTool.getDataBroker().getFromResourceDirAsStream(filename), language, filename);
   }
 
 }

File: languagetool-core/src/test/java/org/languagetool/LanguageSpecificTest.java
Patch:
@@ -243,7 +243,7 @@ private void testNoQuotesAroundSuggestion(Language lang) throws IOException {
         continue;
       }
       InputStream is = this.getClass().getResourceAsStream(ruleFileName);
-      List<AbstractPatternRule> rules = new PatternRuleLoader().getRules(is, dirBase + "/" + ruleFileName, lang);
+      List<AbstractPatternRule> rules = new PatternRuleLoader().getRules(is, ruleFileName, lang);
       for (AbstractPatternRule rule : rules) {
         String message = rule.getMessage();
         if (message.matches(".*['\"«»“”’]<suggestion.*") && message.matches(".*</suggestion>['\"«»“”’].*")) {

File: languagetool-language-modules/fr/src/test/java/org/languagetool/rules/spelling/hunspell/TestFrenchDisambiguator.java
Patch:
@@ -36,7 +36,7 @@ public AnalyzedSentence disambiguate(AnalyzedSentence input) throws IOException
     String filePath = "/disambiguator.xml";
     try (InputStream inputStream = getClass().getResourceAsStream(filePath)) {
       final DisambiguationRuleLoader ruleLoader = new DisambiguationRuleLoader();
-      List<DisambiguationPatternRule> disambiguationRules = ruleLoader.getRules(inputStream, new French());
+      List<DisambiguationPatternRule> disambiguationRules = ruleLoader.getRules(inputStream, new French(), filePath);
       for (final DisambiguationPatternRule patternRule : disambiguationRules) {
         sentence = patternRule.replace(sentence);
       }

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/PortuguesePatternRuleTest.java
Patch:
@@ -21,6 +21,7 @@
 import org.junit.Test;
 import org.languagetool.rules.patterns.PatternRuleTest;
 
+import java.io.File;
 import java.io.IOException;
 
 public class PortuguesePatternRuleTest extends PatternRuleTest {

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1286,7 +1286,7 @@ private void checkRemoteRules(List<RemoteRule> rules, List<AnalyzedSentence> ana
         // skip calls (which send requests) if open/forced_open
         // try calls if half_open
         // would need manual tracking if we use tryAcquirePermission, this is easier
-        // does require automaticTransitionFromOpenToHalfOpenEnabled settting
+        // does require automaticTransitionFromOpenToHalfOpenEnabled setting
         if (size == 0 ||
           rule.circuitBreaker().getState() == CircuitBreaker.State.OPEN ||
           rule.circuitBreaker().getState() == CircuitBreaker.State.FORCED_OPEN) {

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractFindSuggestionsFilter.java
Patch:
@@ -61,7 +61,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     String desiredPostag = getRequired("desiredPostag", arguments);
     String priorityPostag = getOptional("priorityPostag", arguments);
     String removeSuggestionsRegexp = getOptional("removeSuggestionsRegexp", arguments);
-    // supress match if there are no suggestions
+    // suppress match if there are no suggestions
     String suppressMatch = getOptional("suppressMatch", arguments);
     boolean bSuppressMatch = false;
     if (suppressMatch != null && suppressMatch.equalsIgnoreCase("true")) {
@@ -290,4 +290,4 @@ public int compare(String o1, String o2) {
     }
   }
 
-}
\ No newline at end of file
+}

File: languagetool-core/src/main/java/org/languagetool/rules/RuleMatch.java
Patch:
@@ -191,7 +191,8 @@ public RuleMatch(Rule rule, AnalyzedSentence sentence, int fromPos, int toPos, i
       if (replacement.contains(PatternRuleMatcher.MISTAKE)) {
         continue;
       }
-      if (isAllUppercase && !StringTools.isMixedCase(replacement)) {
+      // ignore single words in mixed case
+      if (isAllUppercase && !(StringTools.isMixedCase(replacement) && !replacement.contains(" "))) {
         // do not create a suggestion equal to the input string
         if (!getOriginalErrorStr().equals(replacement.toUpperCase())) {
           replacement = replacement.toUpperCase();

File: languagetool-core/src/main/java/org/languagetool/rules/UppercaseSentenceStartRule.java
Patch:
@@ -48,7 +48,8 @@ public class UppercaseSentenceStartRule extends TextLevelRule {
           "x86",
           "ⓒ",
           "ø", // used as bullet point
-          "cc" // cc @daniel => "Cc @daniel" is strange
+          "cc", // cc @daniel => "Cc @daniel" is strange
+          "pH"
   ));
 
   private final Language language;

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/symspell/implementation/EditDistance.java
Patch:
@@ -76,7 +76,7 @@ public int DamerauLevenshteinDistance(String string2, int maxDistance) {
         } else {
             string1 = baseString;
         }
-        int sLen = string1.length(); // this is also the minimun length of the two strings
+        int sLen = string1.length(); // this is also the minimum length of the two strings
         int tLen = string2.length();
 
         // suffix common to both strings can be ignored

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/symspell/implementation/SuggestionStage.java
Patch:
@@ -55,7 +55,7 @@ public class Entry {
     public ChunkArray<Node> nodes;
     /// <summary>Create a new instance of SymSpell.SuggestionStage.</summary>
     /// <remarks>Specifying ann accurate initialCapacity is not essential,
-    /// but it can help speed up processing by aleviating the need for
+    /// but it can help speed up processing by alleviating the need for
     /// data restructuring as the size grows.</remarks>
     /// <param name="initialCapacity">The expected number of words that will be added.</param>
 

File: languagetool-core/src/test/java/org/languagetool/rules/MultipleWhitespaceRuleTest.java
Patch:
@@ -51,7 +51,7 @@ public void testRule() throws IOException {
     assertGood("Multiple tabs\t\tare okay", lt);
     assertGood("\n This is a test sentence...", lt);
     assertGood("\n    This is a test sentence...", lt);
-    // Needs isParagraphStart creation. Excluding i = 1 will make the rule ignore multiple white spaces in middle senteces.
+    // Needs isParagraphStart creation. Excluding i = 1 will make the rule ignore multiple white spaces in middle sentences.
     // matches = rule.match(langTool.getAnalyzedSentence("    This is a test sentence..."));
     // assertEquals(0, matches.length);
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -442,7 +442,6 @@ protected int getPriorityForId(String id) {
       case "WENNS_UND_ABERS": return -2;  // higher prio than spell checker
       case "ABERS_SATZANFANG": return -2;  // higher prio than spell checker
       case "VERNEB": return -2;  // higher prio than spell checker
-      case "ICH_GEHE_DU_BLEIBST": return -3; // prefer ICH_GLAUBE_FUER_EUCH
       case "GERMAN_SPELLER_RULE": return -3;  // assume most other rules are more specific and helpful than the spelling rule
       case "AUSTRIAN_GERMAN_SPELLER_RULE": return -3;  // assume most other rules are more specific and helpful than the spelling rule
       case "SWISS_GERMAN_SPELLER_RULE": return -3;  // assume most other rules are more specific and helpful than the spelling rule
@@ -471,6 +470,7 @@ protected int getPriorityForId(String id) {
       case "VON_LEBENSLAEUFE": return -12; // less prio than AI
       case "VER_WER_VER_3": return -12; // less prio than AI
       case "PA_WAS": return -12; // less prio than AI
+      case "ICH_GEHE_DU_BLEIBST": return -12; // prefer ICH_GLAUBE_FUER_EUCH and less prio than AI
       case "PROPERNOMSIN_VERIMPSIN": return -12; // less prio than AI
       case "VER123_VERAUXMOD_TEST1": return -12; // less prio than AI to produce a single suggestion
       case "ZUSAMMENGESETZTE_VERBEN": return -12; // less prio than most more specific rules and AI

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/CacheIO.java
Patch:
@@ -234,6 +234,9 @@ public boolean readAllCaches(Configuration config, MultiDocumentsHandler mDocHan
    * Test if cache was created with same rules
    */
   private boolean runSameRules(Configuration config, MultiDocumentsHandler mDocHandler) {
+    if (allCaches == null || allCaches.docCache == null || allCaches.docCache.toTextMapping.size() != DocumentCache.NUMBER_CURSOR_TYPES ) {
+      return false;
+    }
     if (!allCaches.ltVersion.equals(JLanguageTool.VERSION)) {
       return false;
     }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -63,14 +63,14 @@ public class DocumentCache implements Serializable {
   private final List<String> paragraphs = new ArrayList<String>(); // stores the flat paratoTextMappinggraphs of
                                                                    // document
 
-  private final List<List<Integer>> chapterBegins = new ArrayList<List<Integer>>(); // stores the paragraphs formated as
+  private final List<List<Integer>> chapterBegins = new ArrayList<List<Integer>>(); // stores the paragraphs formatted as
                                                                                     // headings; is used to subdivide
                                                                                     // the document in chapters
   private final List<Integer> automaticParagraphs = new ArrayList<Integer>(); // stores the paragraphs automatic generated (will not be checked)
   private final List<SerialLocale> locales = new ArrayList<SerialLocale>(); // stores the language of the paragraphs;
   private final List<int[]> footnotes = new ArrayList<int[]>();             // stores the footnotes of the paragraphs;
   private final List<List<Integer>> deletedCharacters = new ArrayList<List<Integer>>(); // stores the deleted characters (report changes) of the paragraphs;
-  private final List<TextParagraph> toTextMapping = new ArrayList<>(); // Mapping from FlatParagraph to DocumentCursor
+  protected final List<TextParagraph> toTextMapping = new ArrayList<>(); // Mapping from FlatParagraph to DocumentCursor
   private final List<List<Integer>> toParaMapping = new ArrayList<>(); // Mapping from DocumentCursor to FlatParagraph
   private final DocumentType docType;                 // stores the document type (Writer, Impress, Calc)
   private List<Integer> sortedTextIds = null;           // stores the node index of the paragraphs (since LO 7.5 / else null)
@@ -277,7 +277,7 @@ private void refreshWriterCache(SingleDocument document, Locale fixedLocale, Loc
           }
         }
         unknown = paragraphs.size() - unknown;
-        MessageHandler.printToLogFile("DocumentCache: refresh: unkonwn paragraphs: " + unknown);
+        MessageHandler.printToLogFile("DocumentCache: refresh: unknown paragraphs: " + unknown);
         if (sortedTextIds == null) {
           MessageHandler.printToLogFile("DocumentCache: refresh: paragraphContainer.sortedTextIds == null");
         } else {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -108,7 +108,7 @@ public class SingleDocument {
   private IgnoredMatches permanentIgnoredMatches; //  Map of matches (number of paragraph, number of character) that should be ignored permanent
   private final DocumentType docType;             //  save the type of document
   private boolean disposed = false;               //  true: document with this docId is disposed - SingleDocument shall be removed
-  private boolean resetDocCache = false;          //  true: the cache of the document should be reseted before the next check
+  private boolean resetDocCache = false;          //  true: the cache of the document should be reset before the next check
   private boolean hasFootnotes = true;            //  true: Footnotes are supported by LO/OO
   private boolean hasSortedTextId = true;         //  true: Node Index is supported by LO
   private boolean isLastIntern = false;           //  true: last check was intern

File: languagetool-server/src/main/java/org/languagetool/server/ApiV2.java
Patch:
@@ -215,7 +215,7 @@ private void handleWordAddRequest(HttpExchange httpExchange, Map<String, String>
     DatabaseAccess db = DatabaseAccess.getInstance();
     /*
      *  experimental batch mode for adding words,
-     *  use mode=batch, words="word1 word2 word3" (whitespace delimited list) instead of word paramater
+     *  use mode=batch, words="word1 word2 word3" (whitespace delimited list) instead of word parameter
      */
     if ("batch".equals(parameters.get("mode"))) {
       List<String> words = Arrays.asList(parameters.get("words").split("\\s+"));

File: languagetool-server/src/main/java/org/languagetool/server/DatabaseLogger.java
Patch:
@@ -84,7 +84,7 @@ public void run() {
             batchSize++;
             session.insert(entry.getMappingIdentifier(), entry.getMapping());
             DatabaseLogEntry followup = entry.followup();
-            if (followup != null) { // followup statements need to be inserted directly afterwards, dependant on e.g. generated primary keys
+            if (followup != null) { // followup statements need to be inserted directly afterwards, dependent on e.g. generated primary keys
               session.insert(followup.getMappingIdentifier(), followup.getMapping());
               batchSize++;
             }

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1286,7 +1286,7 @@ private void checkRemoteRules(List<RemoteRule> rules, List<AnalyzedSentence> ana
         // skip calls (which send requests) if open/forced_open
         // try calls if half_open
         // would need manual tracking if we use tryAcquirePermission, this is easier
-        // does require automaticTransitionFromOpenToHalfOpenEnabled settting
+        // does require automaticTransitionFromOpenToHalfOpenEnabled setting
         if (size == 0 ||
           rule.circuitBreaker().getState() == CircuitBreaker.State.OPEN ||
           rule.circuitBreaker().getState() == CircuitBreaker.State.FORCED_OPEN) {

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractFindSuggestionsFilter.java
Patch:
@@ -61,7 +61,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     String desiredPostag = getRequired("desiredPostag", arguments);
     String priorityPostag = getOptional("priorityPostag", arguments);
     String removeSuggestionsRegexp = getOptional("removeSuggestionsRegexp", arguments);
-    // supress match if there are no suggestions
+    // suppress match if there are no suggestions
     String suppressMatch = getOptional("suppressMatch", arguments);
     boolean bSuppressMatch = false;
     if (suppressMatch != null && suppressMatch.equalsIgnoreCase("true")) {
@@ -290,4 +290,4 @@ public int compare(String o1, String o2) {
     }
   }
 
-}
\ No newline at end of file
+}

File: languagetool-core/src/main/java/org/languagetool/rules/RuleMatch.java
Patch:
@@ -191,7 +191,8 @@ public RuleMatch(Rule rule, AnalyzedSentence sentence, int fromPos, int toPos, i
       if (replacement.contains(PatternRuleMatcher.MISTAKE)) {
         continue;
       }
-      if (isAllUppercase && !StringTools.isMixedCase(replacement)) {
+      // ignore single words in mixed case
+      if (isAllUppercase && !(StringTools.isMixedCase(replacement) && !replacement.contains(" "))) {
         // do not create a suggestion equal to the input string
         if (!getOriginalErrorStr().equals(replacement.toUpperCase())) {
           replacement = replacement.toUpperCase();

File: languagetool-core/src/main/java/org/languagetool/rules/UppercaseSentenceStartRule.java
Patch:
@@ -48,7 +48,8 @@ public class UppercaseSentenceStartRule extends TextLevelRule {
           "x86",
           "ⓒ",
           "ø", // used as bullet point
-          "cc" // cc @daniel => "Cc @daniel" is strange
+          "cc", // cc @daniel => "Cc @daniel" is strange
+          "pH"
   ));
 
   private final Language language;

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/symspell/implementation/EditDistance.java
Patch:
@@ -76,7 +76,7 @@ public int DamerauLevenshteinDistance(String string2, int maxDistance) {
         } else {
             string1 = baseString;
         }
-        int sLen = string1.length(); // this is also the minimun length of the two strings
+        int sLen = string1.length(); // this is also the minimum length of the two strings
         int tLen = string2.length();
 
         // suffix common to both strings can be ignored

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/symspell/implementation/SuggestionStage.java
Patch:
@@ -55,7 +55,7 @@ public class Entry {
     public ChunkArray<Node> nodes;
     /// <summary>Create a new instance of SymSpell.SuggestionStage.</summary>
     /// <remarks>Specifying ann accurate initialCapacity is not essential,
-    /// but it can help speed up processing by aleviating the need for
+    /// but it can help speed up processing by alleviating the need for
     /// data restructuring as the size grows.</remarks>
     /// <param name="initialCapacity">The expected number of words that will be added.</param>
 

File: languagetool-core/src/test/java/org/languagetool/rules/MultipleWhitespaceRuleTest.java
Patch:
@@ -51,7 +51,7 @@ public void testRule() throws IOException {
     assertGood("Multiple tabs\t\tare okay", lt);
     assertGood("\n This is a test sentence...", lt);
     assertGood("\n    This is a test sentence...", lt);
-    // Needs isParagraphStart creation. Excluding i = 1 will make the rule ignore multiple white spaces in middle senteces.
+    // Needs isParagraphStart creation. Excluding i = 1 will make the rule ignore multiple white spaces in middle sentences.
     // matches = rule.match(langTool.getAnalyzedSentence("    This is a test sentence..."));
     // assertEquals(0, matches.length);
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -442,7 +442,6 @@ protected int getPriorityForId(String id) {
       case "WENNS_UND_ABERS": return -2;  // higher prio than spell checker
       case "ABERS_SATZANFANG": return -2;  // higher prio than spell checker
       case "VERNEB": return -2;  // higher prio than spell checker
-      case "ICH_GEHE_DU_BLEIBST": return -3; // prefer ICH_GLAUBE_FUER_EUCH
       case "GERMAN_SPELLER_RULE": return -3;  // assume most other rules are more specific and helpful than the spelling rule
       case "AUSTRIAN_GERMAN_SPELLER_RULE": return -3;  // assume most other rules are more specific and helpful than the spelling rule
       case "SWISS_GERMAN_SPELLER_RULE": return -3;  // assume most other rules are more specific and helpful than the spelling rule
@@ -471,6 +470,7 @@ protected int getPriorityForId(String id) {
       case "VON_LEBENSLAEUFE": return -12; // less prio than AI
       case "VER_WER_VER_3": return -12; // less prio than AI
       case "PA_WAS": return -12; // less prio than AI
+      case "ICH_GEHE_DU_BLEIBST": return -12; // prefer ICH_GLAUBE_FUER_EUCH and less prio than AI
       case "PROPERNOMSIN_VERIMPSIN": return -12; // less prio than AI
       case "VER123_VERAUXMOD_TEST1": return -12; // less prio than AI to produce a single suggestion
       case "ZUSAMMENGESETZTE_VERBEN": return -12; // less prio than most more specific rules and AI

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/CacheIO.java
Patch:
@@ -234,6 +234,9 @@ public boolean readAllCaches(Configuration config, MultiDocumentsHandler mDocHan
    * Test if cache was created with same rules
    */
   private boolean runSameRules(Configuration config, MultiDocumentsHandler mDocHandler) {
+    if (allCaches == null || allCaches.docCache == null || allCaches.docCache.toTextMapping.size() != DocumentCache.NUMBER_CURSOR_TYPES ) {
+      return false;
+    }
     if (!allCaches.ltVersion.equals(JLanguageTool.VERSION)) {
       return false;
     }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -63,14 +63,14 @@ public class DocumentCache implements Serializable {
   private final List<String> paragraphs = new ArrayList<String>(); // stores the flat paratoTextMappinggraphs of
                                                                    // document
 
-  private final List<List<Integer>> chapterBegins = new ArrayList<List<Integer>>(); // stores the paragraphs formated as
+  private final List<List<Integer>> chapterBegins = new ArrayList<List<Integer>>(); // stores the paragraphs formatted as
                                                                                     // headings; is used to subdivide
                                                                                     // the document in chapters
   private final List<Integer> automaticParagraphs = new ArrayList<Integer>(); // stores the paragraphs automatic generated (will not be checked)
   private final List<SerialLocale> locales = new ArrayList<SerialLocale>(); // stores the language of the paragraphs;
   private final List<int[]> footnotes = new ArrayList<int[]>();             // stores the footnotes of the paragraphs;
   private final List<List<Integer>> deletedCharacters = new ArrayList<List<Integer>>(); // stores the deleted characters (report changes) of the paragraphs;
-  private final List<TextParagraph> toTextMapping = new ArrayList<>(); // Mapping from FlatParagraph to DocumentCursor
+  protected final List<TextParagraph> toTextMapping = new ArrayList<>(); // Mapping from FlatParagraph to DocumentCursor
   private final List<List<Integer>> toParaMapping = new ArrayList<>(); // Mapping from DocumentCursor to FlatParagraph
   private final DocumentType docType;                 // stores the document type (Writer, Impress, Calc)
   private List<Integer> sortedTextIds = null;           // stores the node index of the paragraphs (since LO 7.5 / else null)
@@ -277,7 +277,7 @@ private void refreshWriterCache(SingleDocument document, Locale fixedLocale, Loc
           }
         }
         unknown = paragraphs.size() - unknown;
-        MessageHandler.printToLogFile("DocumentCache: refresh: unkonwn paragraphs: " + unknown);
+        MessageHandler.printToLogFile("DocumentCache: refresh: unknown paragraphs: " + unknown);
         if (sortedTextIds == null) {
           MessageHandler.printToLogFile("DocumentCache: refresh: paragraphContainer.sortedTextIds == null");
         } else {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -108,7 +108,7 @@ public class SingleDocument {
   private IgnoredMatches permanentIgnoredMatches; //  Map of matches (number of paragraph, number of character) that should be ignored permanent
   private final DocumentType docType;             //  save the type of document
   private boolean disposed = false;               //  true: document with this docId is disposed - SingleDocument shall be removed
-  private boolean resetDocCache = false;          //  true: the cache of the document should be reseted before the next check
+  private boolean resetDocCache = false;          //  true: the cache of the document should be reset before the next check
   private boolean hasFootnotes = true;            //  true: Footnotes are supported by LO/OO
   private boolean hasSortedTextId = true;         //  true: Node Index is supported by LO
   private boolean isLastIntern = false;           //  true: last check was intern

File: languagetool-server/src/main/java/org/languagetool/server/ApiV2.java
Patch:
@@ -215,7 +215,7 @@ private void handleWordAddRequest(HttpExchange httpExchange, Map<String, String>
     DatabaseAccess db = DatabaseAccess.getInstance();
     /*
      *  experimental batch mode for adding words,
-     *  use mode=batch, words="word1 word2 word3" (whitespace delimited list) instead of word paramater
+     *  use mode=batch, words="word1 word2 word3" (whitespace delimited list) instead of word parameter
      */
     if ("batch".equals(parameters.get("mode"))) {
       List<String> words = Arrays.asList(parameters.get("words").split("\\s+"));

File: languagetool-server/src/main/java/org/languagetool/server/DatabaseLogger.java
Patch:
@@ -84,7 +84,7 @@ public void run() {
             batchSize++;
             session.insert(entry.getMappingIdentifier(), entry.getMapping());
             DatabaseLogEntry followup = entry.followup();
-            if (followup != null) { // followup statements need to be inserted directly afterwards, dependant on e.g. generated primary keys
+            if (followup != null) { // followup statements need to be inserted directly afterwards, dependent on e.g. generated primary keys
               session.insert(followup.getMappingIdentifier(), followup.getMapping());
               batchSize++;
             }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -63,7 +63,7 @@ public class DocumentCache implements Serializable {
   private final List<String> paragraphs = new ArrayList<String>(); // stores the flat paratoTextMappinggraphs of
                                                                    // document
 
-  private final List<List<Integer>> chapterBegins = new ArrayList<List<Integer>>(); // stores the paragraphs formated as
+  private final List<List<Integer>> chapterBegins = new ArrayList<List<Integer>>(); // stores the paragraphs formatted as
                                                                                     // headings; is used to subdivide
                                                                                     // the document in chapters
   private final List<Integer> automaticParagraphs = new ArrayList<Integer>(); // stores the paragraphs automatic generated (will not be checked)
@@ -277,7 +277,7 @@ private void refreshWriterCache(SingleDocument document, Locale fixedLocale, Loc
           }
         }
         unknown = paragraphs.size() - unknown;
-        MessageHandler.printToLogFile("DocumentCache: refresh: unkonwn paragraphs: " + unknown);
+        MessageHandler.printToLogFile("DocumentCache: refresh: unknown paragraphs: " + unknown);
         if (sortedTextIds == null) {
           MessageHandler.printToLogFile("DocumentCache: refresh: paragraphContainer.sortedTextIds == null");
         } else {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -108,7 +108,7 @@ public class SingleDocument {
   private IgnoredMatches permanentIgnoredMatches; //  Map of matches (number of paragraph, number of character) that should be ignored permanent
   private final DocumentType docType;             //  save the type of document
   private boolean disposed = false;               //  true: document with this docId is disposed - SingleDocument shall be removed
-  private boolean resetDocCache = false;          //  true: the cache of the document should be reseted before the next check
+  private boolean resetDocCache = false;          //  true: the cache of the document should be reset before the next check
   private boolean hasFootnotes = true;            //  true: Footnotes are supported by LO/OO
   private boolean hasSortedTextId = true;         //  true: Node Index is supported by LO
   private boolean isLastIntern = false;           //  true: last check was intern

File: languagetool-server/src/main/java/org/languagetool/server/ApiV2.java
Patch:
@@ -215,7 +215,7 @@ private void handleWordAddRequest(HttpExchange httpExchange, Map<String, String>
     DatabaseAccess db = DatabaseAccess.getInstance();
     /*
      *  experimental batch mode for adding words,
-     *  use mode=batch, words="word1 word2 word3" (whitespace delimited list) instead of word paramater
+     *  use mode=batch, words="word1 word2 word3" (whitespace delimited list) instead of word parameter
      */
     if ("batch".equals(parameters.get("mode"))) {
       List<String> words = Arrays.asList(parameters.get("words").split("\\s+"));

File: languagetool-server/src/main/java/org/languagetool/server/DatabaseLogger.java
Patch:
@@ -84,7 +84,7 @@ public void run() {
             batchSize++;
             session.insert(entry.getMappingIdentifier(), entry.getMapping());
             DatabaseLogEntry followup = entry.followup();
-            if (followup != null) { // followup statements need to be inserted directly afterwards, dependant on e.g. generated primary keys
+            if (followup != null) { // followup statements need to be inserted directly afterwards, dependent on e.g. generated primary keys
               session.insert(followup.getMappingIdentifier(), followup.getMapping());
               batchSize++;
             }

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1286,7 +1286,7 @@ private void checkRemoteRules(List<RemoteRule> rules, List<AnalyzedSentence> ana
         // skip calls (which send requests) if open/forced_open
         // try calls if half_open
         // would need manual tracking if we use tryAcquirePermission, this is easier
-        // does require automaticTransitionFromOpenToHalfOpenEnabled settting
+        // does require automaticTransitionFromOpenToHalfOpenEnabled setting
         if (size == 0 ||
           rule.circuitBreaker().getState() == CircuitBreaker.State.OPEN ||
           rule.circuitBreaker().getState() == CircuitBreaker.State.FORCED_OPEN) {

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractFindSuggestionsFilter.java
Patch:
@@ -61,7 +61,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     String desiredPostag = getRequired("desiredPostag", arguments);
     String priorityPostag = getOptional("priorityPostag", arguments);
     String removeSuggestionsRegexp = getOptional("removeSuggestionsRegexp", arguments);
-    // supress match if there are no suggestions
+    // suppress match if there are no suggestions
     String suppressMatch = getOptional("suppressMatch", arguments);
     boolean bSuppressMatch = false;
     if (suppressMatch != null && suppressMatch.equalsIgnoreCase("true")) {
@@ -290,4 +290,4 @@ public int compare(String o1, String o2) {
     }
   }
 
-}
\ No newline at end of file
+}

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/symspell/implementation/EditDistance.java
Patch:
@@ -76,7 +76,7 @@ public int DamerauLevenshteinDistance(String string2, int maxDistance) {
         } else {
             string1 = baseString;
         }
-        int sLen = string1.length(); // this is also the minimun length of the two strings
+        int sLen = string1.length(); // this is also the minimum length of the two strings
         int tLen = string2.length();
 
         // suffix common to both strings can be ignored

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/symspell/implementation/SuggestionStage.java
Patch:
@@ -55,7 +55,7 @@ public class Entry {
     public ChunkArray<Node> nodes;
     /// <summary>Create a new instance of SymSpell.SuggestionStage.</summary>
     /// <remarks>Specifying ann accurate initialCapacity is not essential,
-    /// but it can help speed up processing by aleviating the need for
+    /// but it can help speed up processing by alleviating the need for
     /// data restructuring as the size grows.</remarks>
     /// <param name="initialCapacity">The expected number of words that will be added.</param>
 

File: languagetool-core/src/test/java/org/languagetool/rules/MultipleWhitespaceRuleTest.java
Patch:
@@ -51,7 +51,7 @@ public void testRule() throws IOException {
     assertGood("Multiple tabs\t\tare okay", lt);
     assertGood("\n This is a test sentence...", lt);
     assertGood("\n    This is a test sentence...", lt);
-    // Needs isParagraphStart creation. Excluding i = 1 will make the rule ignore multiple white spaces in middle senteces.
+    // Needs isParagraphStart creation. Excluding i = 1 will make the rule ignore multiple white spaces in middle sentences.
     // matches = rule.match(langTool.getAnalyzedSentence("    This is a test sentence..."));
     // assertEquals(0, matches.length);
 

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractAdvancedSynthesizerFilter.java
Patch:
@@ -126,7 +126,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
           if (isSuggestionException(nr, desiredPostag)) {
             continue;
           }
-          if (r.contains("{suggestion}") || r.contains("{Suggestion}")) {
+          if (r.contains("{suggestion}") || r.contains("{Suggestion}") || r.contains("{SUGGESTION}")) {
             suggestionUsed = true;
           }
           if (isWordCapitalized) {
@@ -137,6 +137,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
           }
           String completeSuggestion = r.replace("{suggestion}", nr);
           completeSuggestion = completeSuggestion.replace("{Suggestion}", StringTools.uppercaseFirstChar(nr));
+          completeSuggestion = completeSuggestion.replace("{SUGGESTION}", nr.toUpperCase());
           if (!replacementsList.contains(completeSuggestion)) {
             replacementsList.add(completeSuggestion);
           }

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/RegexPatternRule.java
Patch:
@@ -108,7 +108,7 @@ private RuleMatch[] doMatch(AnalyzedSentence sentenceObj, String text, int start
 
         boolean startsWithUpperCase = patternMatcher.start() == 0 && Character.isUpperCase(text.charAt(patternMatcher.start()));
         RuleMatch ruleMatch = new RuleMatch(this, sentenceObj, markStart, markEnd, patternMatcher.start(), patternMatcher.end(),
-                processedMessage, shortMessage, startsWithUpperCase, processedSuggestionsOutMsg);
+                processedMessage, shortMessage, startsWithUpperCase, false, processedSuggestionsOutMsg, true);
         if (regexFilter != null) {
           RegexRuleFilterEvaluator ruleFilterEvaluator = new RegexRuleFilterEvaluator(regexFilter);
           RuleMatch filteredMatch = ruleFilterEvaluator.runFilter(getFilterArguments(), ruleMatch, sentenceObj, patternMatcher);

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -304,7 +304,7 @@ public SpellingCheckRule createDefaultSpellingRule(ResourceBundle messages) thro
   public List<RuleMatch> adaptSuggestions(List<RuleMatch> ruleMatches, Set<String> enabledRules) {
     List<RuleMatch> newRuleMatches = new ArrayList<>();
     for (RuleMatch rm : ruleMatches) {
-      String errorStr = rm.getUnderlinedStr();
+      String errorStr = rm.getOriginalErrorStr();
       List<SuggestedReplacement> suggestedReplacements = rm.getSuggestedReplacementObjects();
       List<SuggestedReplacement> newReplacements = new ArrayList<>();
       for (SuggestedReplacement suggestedReplacement : suggestedReplacements) {

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/DiacriticsCheckFilter.java
Patch:
@@ -99,6 +99,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
       for (String sugg : match.getSuggestedReplacements()) {
         String suggestion = sugg.replace("{suggestion}", replacement);
         suggestion = suggestion.replace("{Suggestion}", StringTools.uppercaseFirstChar(replacement));
+        suggestion = suggestion.replace("{SUGGESTION}", replacement.toUpperCase());
         ruleMatch.addSuggestedReplacement(suggestion);  
       }
       return ruleMatch;

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -696,7 +696,7 @@ public SpellingCheckRule createDefaultSpellingRule(ResourceBundle messages) thro
   public List<RuleMatch> adaptSuggestions(List<RuleMatch> ruleMatches, Set<String> enabledRules) {
     List<RuleMatch> newRuleMatches = new ArrayList<>();
     for (RuleMatch rm : ruleMatches) {
-      String errorStr = rm.getUnderlinedStr();
+      String errorStr = rm.getOriginalErrorStr();
       List<SuggestedReplacement> suggestedReplacements = rm.getSuggestedReplacementObjects();
       List<SuggestedReplacement> newReplacements = new ArrayList<>();
       for (SuggestedReplacement suggestedReplacement : suggestedReplacements) {

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/ConfusionCheckFilter.java
Patch:
@@ -97,6 +97,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
       }
       String suggestion = match.getSuggestedReplacements().get(0).replace("{suggestion}", replacement);
       suggestion = suggestion.replace("{Suggestion}", StringTools.uppercaseFirstChar(replacement));
+      suggestion = suggestion.replace("{SUGGESTION}", replacement.toUpperCase());
       ruleMatch.setSuggestedReplacement(suggestion);
       return ruleMatch;
     }    

File: languagetool-language-modules/nl/src/main/java/org/languagetool/language/Dutch.java
Patch:
@@ -196,6 +196,7 @@ protected int getPriorityForId(String id) {
       case "KORT_2": return -5;  //so that spelling errors are recognized first
       case "EINDE_ZIN_ONVERWACHT": return -5;  //so that spelling errors are recognized first
       case "TOO_LONG_PARAGRAPH": return -15;
+      case "ERG_LANG_WOORD": return -20;  // below spell checker and simple replace rule
       case "DE_ONVERWACHT": return -20;  // below spell checker and simple replace rule
       case "TE-VREEMD": return -20;  // below spell checker and simple replace rule
       // category style : -50

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/ConfusionCheckFilter.java
Patch:
@@ -91,6 +91,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
       ruleMatch.setType(match.getType());
       String suggestion = match.getSuggestedReplacements().get(0).replace("{suggestion}", replacement);
       suggestion = suggestion.replace("{Suggestion}", StringTools.uppercaseFirstChar(replacement));
+      suggestion = suggestion.replace("{SUGGESTION}", replacement.toUpperCase());
       ruleMatch.setSuggestedReplacement(suggestion);
       return ruleMatch;
     }    

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/RegularIrregularParticipleFilter.java
Patch:
@@ -93,6 +93,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
           ruleMatch.setType(match.getType());
           String suggestion = match.getSuggestedReplacements().get(0).replace("{suggestion}", replacement);
           suggestion = suggestion.replace("{Suggestion}", StringTools.uppercaseFirstChar(replacement));
+          suggestion = suggestion.replace("{SUGGESTION}", replacement.toUpperCase());
           ruleMatch.setSuggestedReplacement(suggestion);
           return ruleMatch;
         }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -1407,9 +1407,11 @@ public final static Locale[] getLocales() {
             if (lang.getDefaultLanguageVariant().getVariant() != null) {
               locale = new Locale(lang.getDefaultLanguageVariant().getShortCode(),
                   lang.getDefaultLanguageVariant().getCountries()[0], lang.getDefaultLanguageVariant().getVariant());
-            } else {
+            } else if (lang.getDefaultLanguageVariant().getCountries().length != 0) {
               locale = new Locale(lang.getDefaultLanguageVariant().getShortCode(),
                   lang.getDefaultLanguageVariant().getCountries()[0], "");
+            } else {
+              locale = new Locale(lang.getDefaultLanguageVariant().getShortCode(), "", "");
             }
           }
           else if (lang.getVariant() != null) {  // e.g. Esperanto

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -1407,9 +1407,11 @@ public final static Locale[] getLocales() {
             if (lang.getDefaultLanguageVariant().getVariant() != null) {
               locale = new Locale(lang.getDefaultLanguageVariant().getShortCode(),
                   lang.getDefaultLanguageVariant().getCountries()[0], lang.getDefaultLanguageVariant().getVariant());
-            } else {
+            } else if (lang.getDefaultLanguageVariant().getCountries().length != 0) {
               locale = new Locale(lang.getDefaultLanguageVariant().getShortCode(),
                   lang.getDefaultLanguageVariant().getCountries()[0], "");
+            } else {
+              locale = new Locale(lang.getDefaultLanguageVariant().getShortCode(), "", "");
             }
           }
           else if (lang.getVariant() != null) {  // e.g. Esperanto

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tokenizers/ca/CatalanWordTokenizer.java
Patch:
@@ -66,7 +66,7 @@ public class CatalanWordTokenizer extends WordTokenizer {
   // Sàsser-l'Alguer
   private static final Pattern HYPHEN_L= Pattern.compile("([\\p{L}]+)(-)([Ll]['’])([\\p{L}]+)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   
-  private final String CA_TOKENIZING_CHARACTERS = getTokenizingCharacters().replace("·", ""); // + "−"
+  private final String CA_TOKENIZING_CHARACTERS = getTokenizingCharacters().replace("·", "") + "−";
   
   public CatalanWordTokenizer() {
 

File: languagetool-core/src/main/java/org/languagetool/MultiThreadedJLanguageTool.java
Patch:
@@ -171,7 +171,7 @@ protected List<AnalyzedSentence> analyzeSentences(List<String> sentences) throws
   @Override
   protected CheckResults performCheck(List<AnalyzedSentence> analyzedSentences, List<String> sentenceTexts,
                                          RuleSet ruleSet, ParagraphHandling paraMode,
-                                         AnnotatedText annotatedText, RuleMatchListener listener, Mode mode, Level level, boolean checkRemoteRules) {
+                                         AnnotatedText annotatedText, RuleMatchListener listener, Mode mode, Level level, boolean checkRemoteRules, Set<ToneTag> toneTags) {
     List<Rule> allRules = ruleSet.allRules();
     List<SentenceData> sentences = computeSentenceData(analyzedSentences, sentenceTexts);
 
@@ -197,7 +197,7 @@ protected CheckResults performCheck(List<AnalyzedSentence> analyzedSentences, Li
         // less need for special treatment of remote rules when execution is already parallel
         CheckResults res = new TextCheckCallable(RuleSet.plain(Collections.singletonList(rule)),
           RuleSet.filterList(applicable, sentences),
-          paraMode, annotatedText, listener, mode, level, true).call();
+          paraMode, annotatedText, listener, mode, level, true, toneTags).call();
         if (!res.getRuleMatches().isEmpty()) {
           synchronized (ruleMatches) {
             ruleMatches.put(index, res.getRuleMatches());

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractSimpleReplaceRule2.java
Patch:
@@ -148,7 +148,7 @@ private static List<Map<String, SuggestionWithMessage>> loadWords(String filenam
           continue;
         }
         if (line.contains("  ") && !lang.getShortCode().equals("ar")) {
-          throw new RuntimeException("More than one consecutive space in " + filename + " - use a tab character as a delimiter for the message: " + line);
+          //throw new RuntimeException("More than one consecutive space in " + filename + " - use a tab character as a delimiter for the message: " + line);
         }
         if (checkingCase) {
           String[] parts = line.split("=");

File: languagetool-core/src/main/java/org/languagetool/Language.java
Patch:
@@ -351,12 +351,12 @@ public List<String> getRuleFileNames() {
 
   /**
    * Languages that have country variants need to overwrite this to select their most common variant.
-   * @return default country variant or {@code null}
+   * @return default country variant
    * @since 1.8
    */
-  @Nullable
+  @NotNull
   public Language getDefaultLanguageVariant() {
-    return null;
+    return this;
   }
 
   /**

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationPatternRuleReplacer.java
Patch:
@@ -42,7 +42,8 @@
 class DisambiguationPatternRuleReplacer extends AbstractPatternRulePerformer {
 
   DisambiguationPatternRuleReplacer(DisambiguationPatternRule rule) {
-    super(rule, rule.getLanguage().getDisambiguationUnifier());
+    // The disambiguation Unifier is always in the default language variant
+    super(rule, rule.getLanguage().getDefaultLanguageVariant().getDisambiguationUnifier());
   }
 
   AnalyzedSentence replace(AnalyzedSentence sentence) throws IOException {

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationRuleHandler.java
Patch:
@@ -362,7 +362,8 @@ public void endElement(String namespaceURI, String sName,
         if (inUnification && !inAndGroup) {
           uniCounter++;
         }
-        finalizeTokens(language.getDisambiguationUnifierConfiguration());
+        // The disambiguation Unifier is always in the default language variant
+        finalizeTokens(language.getDefaultLanguageVariant().getDisambiguationUnifierConfiguration());
         break;
       case PATTERN:
         inPattern = false;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -41,7 +41,7 @@
 
 public class Catalan extends Language {
 
-  private static final Language DEFAULT_CATALAN = new Catalan();
+  //private static final Language DEFAULT_CATALAN = new Catalan();
   
   @Override
   public String getName() {
@@ -60,7 +60,7 @@ public String getShortCode() {
 
   @Override
   public Language getDefaultLanguageVariant() {
-    return DEFAULT_CATALAN;
+    return Languages.getLanguageForShortCode("ca-ES");
   }
   
   @Override
@@ -125,7 +125,7 @@ public SentenceTokenizer createDefaultSentenceTokenizer() {
 
   @Override
   public Disambiguator createDefaultDisambiguator() {
-    return new CatalanHybridDisambiguator(this);
+    return new CatalanHybridDisambiguator(getDefaultLanguageVariant());
   }
 
   @Override

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -78,7 +78,7 @@ public GermanSpellerRule getDefaultSpellingRule() {
 
   @Override
   public Disambiguator createDefaultDisambiguator() {
-    return new GermanRuleDisambiguator(this);
+    return new GermanRuleDisambiguator(getDefaultLanguageVariant());
   }
 
   @Nullable

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -135,7 +135,7 @@ public Synthesizer createDefaultSynthesizer() {
 
   @Override
   public Disambiguator createDefaultDisambiguator() {
-    return new EnglishHybridDisambiguator(this);
+    return new EnglishHybridDisambiguator(getDefaultLanguageVariant());
   }
 
   @Override

File: languagetool-language-modules/uk/src/main/java/org/languagetool/language/Ukrainian1992.java
Patch:
@@ -30,6 +30,9 @@
 // Only for testing for now
 public class Ukrainian1992 extends Ukrainian {
   
+// This language variant is not yet defined in language-module.properties
+// If getVariant is set, there are errors in Languages.getLanguageForShortCode()
+  
 //  @Override
 //  public String getVariant() {
 //    return "1992";

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -93,7 +93,9 @@ public PatternRuleHandler(String sourceFile) {
   }
   public PatternRuleHandler(String filename, Language lang) {
     this.sourceFile = filename;
-    this.language = Languages.getLanguageForShortCode(lang.getShortCodeWithCountryAndVariant());
+    if (lang != null) {
+      this.language = Languages.getLanguageForShortCode(lang.getShortCodeWithCountryAndVariant());  
+    }
   }
 
   /**

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -93,7 +93,7 @@ public PatternRuleHandler(String sourceFile) {
   }
   public PatternRuleHandler(String filename, Language lang) {
     this.sourceFile = filename;
-    this.language = lang;
+    this.language = Languages.getLanguageForShortCode(lang.getShortCodeWithCountryAndVariant());
   }
 
   /**

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/GrammalecteRule.java
Patch:
@@ -540,7 +540,7 @@ private List<RuleMatch> getMatches(Map<String, Object> match) {
         continue;
       }
       String message = pairs.get("sMessage").toString();
-      GrammalecteInternalRule rule = new GrammalecteInternalRule("" + id, message);
+      GrammalecteInternalRule rule = new GrammalecteInternalRule("grammalecte_" + id, message);
       RuleMatch extMatch = new RuleMatch(rule, null, offset, endOffset, message);
       List<String> suggestions = (List<String>) pairs.get("aSuggestions");
       //SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss ZZZZ");

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/GrammalecteRule.java
Patch:
@@ -540,7 +540,7 @@ private List<RuleMatch> getMatches(Map<String, Object> match) {
         continue;
       }
       String message = pairs.get("sMessage").toString();
-      GrammalecteInternalRule rule = new GrammalecteInternalRule("" + id, message);
+      GrammalecteInternalRule rule = new GrammalecteInternalRule("grammalecte_" + id, message);
       RuleMatch extMatch = new RuleMatch(rule, null, offset, endOffset, message);
       List<String> suggestions = (List<String>) pairs.get("aSuggestions");
       //SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss ZZZZ");

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/GrammalecteRule.java
Patch:
@@ -424,7 +424,7 @@ public class GrammalecteRule extends Rule {
     "g3__gn_la_3m__b1_a1_1",
     "gv1__imp_verbe_groupe3_d__b2_a1_1",//rule is generating FP and a loop(https://github.com/languagetooler-gmbh/languagetool-premium/issues/5220)
     "typo_guillemets_perdus",
-    "g2__conj_2p_sans_sujet__b1_a1_1 ",
+    "g2__conj_2p_sans_sujet__b1_a1_1",
     "typo_signe_multiplication",
     "typo_écriture_invariable",
     "gv1__ppas_avoir_été__b2_a3_1",
@@ -433,7 +433,7 @@ public class GrammalecteRule extends Rule {
     "typo_guillemets_doubles_ouvrants_non_fermé",
     "g2__maj_gentilés__b3_a1_1",
     "typo_signe_moins",
-    "g3__conf_numérique_digital__b1_a1_1 ",
+    "g3__conf_numérique_digital__b1_a1_1",
     "g2__conf_start_nom_ppas__b1_a1_1",
     "typo_guillemets_fin",
     "g2__conf_non_verbe_après_préverbes__b2_a1_1",

File: languagetool-core/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -166,6 +166,7 @@ public class WordListValidatorTest {
           "Snæfellsjökull",
           "Skåneland",
           "Øresund",
+          "Jokić",
           "Ibišević",
           "Fríður",
           "Łódź",

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -434,7 +434,8 @@ && getFrequency(speller1, nextWord) < MAX_FREQUENCY_FOR_SPLITTING) {
     int translationSuggestionCount = 0;
     boolean preventFurtherSuggestions = false;
     
-    Translator translator = getTranslator(globalConfig);
+    //Translator translator = getTranslator(globalConfig);
+    Translator translator = null;
     if (translator != null && ruleMatch == null && motherTongue != null &&
         language.getShortCode().equals("en") && motherTongue.getShortCode().equals("de")) {
       List<PhraseToTranslate> phrasesToTranslate = new ArrayList<>();

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerTest.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.apache.commons.lang3.StringUtils;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.languagetool.JLanguageTool;
 import org.languagetool.Language;
@@ -96,6 +97,7 @@ public void testRandomPortHttpServer() {
   }
 
   @Test
+  @Ignore("feature turned off for now")
   public void translationSuggestions() throws Exception {
     File configFile = File.createTempFile("translationSuggestions", "txt");
     configFile.deleteOnExit();

File: languagetool-core/src/main/java/org/languagetool/ToneTag.java
Patch:
@@ -26,7 +26,7 @@
 
 public enum ToneTag {
 
-  clarity, formal, professional, confident, academic, povrem, scientific, objective, persuasive, informal, povadd, positive, general, NO_TONE_RULE, ALL_TONE_RULES;
+  clarity, formal, professional, confident, academic, povrem, scientific, objective, persuasive, informal, povadd, positive, general, NO_TONE_RULE, ALL_TONE_RULES, ALL_WITHOUT_GOAL_SPECIFIC;
 
-  public static final List<ToneTag> REAL_TONE_TAGS = Arrays.stream(ToneTag.values()).filter(toneTag -> toneTag != NO_TONE_RULE && toneTag != ALL_TONE_RULES).collect(Collectors.toList());
+  public static final List<ToneTag> REAL_TONE_TAGS = Arrays.stream(ToneTag.values()).filter(toneTag -> toneTag != NO_TONE_RULE && toneTag != ALL_TONE_RULES && toneTag != ALL_WITHOUT_GOAL_SPECIFIC).collect(Collectors.toList());
 }

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -136,7 +136,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new PortugueseRedundancyRule(messages, "/pt/redundancies-pt.txt"),
             new PortugueseWordinessRule(messages, "/pt/wordiness-pt.txt"),
             //new PortugueseWeaselWordsRule(messages),
-            new PortugueseWikipediaRule(messages),
+            new PortugueseWikipediaRule(messages, "/pt/wikipedia-pt.txt"),
             new PortugueseWordRepeatRule(messages, this),
             new PortugueseWordRepeatBeginningRule(messages, this),
             new PortugueseAccentuationCheckRule(messages),

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/PortugueseWikipediaRuleTest.java
Patch:
@@ -42,7 +42,7 @@ public class PortugueseWikipediaRuleTest {
 
   @Before
   public void setUp() throws Exception {
-    rule = new PortugueseWikipediaRule(TestTools.getMessages("pt"));
+    rule = new PortugueseWikipediaRule(TestTools.getMessages("pt"), "/pt/wikipedia-pt.txt");
     lt = new JLanguageTool(new Portuguese());
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/Hunspell.java
Patch:
@@ -3,6 +3,8 @@
 import org.languagetool.JLanguageTool;
 import org.languagetool.broker.ResourceDataBroker;
 
+import java.beans.PropertyChangeEvent;
+import java.beans.PropertyChangeListener;
 import java.io.*;
 import java.nio.file.*;
 import java.util.*;
@@ -40,7 +42,7 @@ public static void setHunspellDictionaryFactory(BiFunction<Path, Path, HunspellD
   public static synchronized HunspellDictionary getDictionary(Path dictionary, Path affix) {
     LanguageAndPath key = new LanguageAndPath(dictionary, affix);
     HunspellDictionary hunspell = map.get(key);
-    if (hunspell != null) {
+    if (hunspell != null && !hunspell.isClosed()) {
       return hunspell;
     }
     HunspellDictionary newHunspell = hunspellDictionaryFactory.apply(dictionary, affix);

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -133,7 +133,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             //new PortugueseArchaismsRule(messages, "/pt/archaisms-pt.txt"),   // see https://github.com/languagetool-org/languagetool/issues/3095
             new PortugueseClicheRule(messages, "/pt/cliches-pt.txt"),
             new PortugueseFillerWordsRule(messages, this, userConfig),
-            new PortugueseRedundancyRule(messages),
+            new PortugueseRedundancyRule(messages, "/pt/redundancies-pt.txt"),
             new PortugueseWordinessRule(messages),
             //new PortugueseWeaselWordsRule(messages),
             new PortugueseWikipediaRule(messages),

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -131,7 +131,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new PortugueseReplaceRule(messages),
             new PortugueseBarbarismsRule(messages, "/pt/barbarisms-pt.txt"),
             //new PortugueseArchaismsRule(messages, "/pt/archaisms-pt.txt"),   // see https://github.com/languagetool-org/languagetool/issues/3095
-            new PortugueseClicheRule(messages),
+            new PortugueseClicheRule(messages, "/pt/cliches-pt.txt"),
             new PortugueseFillerWordsRule(messages, this, userConfig),
             new PortugueseRedundancyRule(messages),
             new PortugueseWordinessRule(messages),

File: languagetool-core/src/test/java/org/languagetool/LanguageSpecificTest.java
Patch:
@@ -69,6 +69,7 @@ private void testReplaceRuleReplacements(Language lang) throws IOException {
     if (lang.getShortCode().matches("nl|km")) {
       // too many alarms, should be cleaned up first
       System.out.println("Skipping " + lang + " for replace.txt check");
+      return;
     }
     if (spellRule != null) {
       for (Rule rule : lt.getAllActiveRules()) {

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikMultiSpeller.java
Patch:
@@ -341,7 +341,7 @@ public boolean isMisspelled(String word) {
   }
   
   /**
-   * Get the frequency of use of a word (0-27) form the dictionary
+   * Get the frequency of use of a word (0-27) from the dictionary
    */
   public int getFrequency(String word) {
     for (MorfologikSpeller speller : spellers) {

File: languagetool-http-client/src/main/java/org/languagetool/remote/SentenceAnnotator.java
Patch:
@@ -150,7 +150,7 @@ private static void runAnnotation(AnnotatorConfig cfg) throws IOException {
           break;
         case "i":
           fpMatches.add(getMatchIdentifier(sentence, match));
-          errorType = "IW";
+          errorType = "IM";
           break;
         case "f":
           fpMatches.add(getMatchIdentifier(sentence, match));

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -734,7 +734,7 @@ private void createRules(List<PatternToken> elemList,
         rule = new RegexPatternRule(id, name, message.toString(), shortMessage, suggestionsOutMsg.toString(), language, Pattern.compile(regexStr, flags), regexpMark);
         rule.setSourceFile(sourceFile);
       } else {
-        throw new IllegalStateException("Neither '<pattern>' tokens nor '<regex>' is set in rule '" + id + "'");
+        throw new IllegalStateException("Neither '<pattern>' tokens nor '<regexp>' is set in rule '" + id + "'");
       }
       setRuleFilter(filterClassName, filterArgs, rule);
       prepareRule(rule);

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -718,7 +718,6 @@ private void createRules(List<PatternToken> elemList,
         rule.addToneTags(ruleToneTags);
         rule.addToneTags(ruleGroupToneTags);
         rule.setSourceFile(sourceFile);
-        rule.setPremium(isPremiumRule);
         rule.setMinPrevMatches(minPrevMatches);
         rule.setDistanceTokens(distanceTokens);
         rule.setXmlLineNumber(xmlLineNumber);
@@ -788,6 +787,7 @@ String replaceSpacesInRegex(String s) {
   }
 
   protected void prepareRule(AbstractPatternRule rule) {
+    rule.setPremium(isPremiumRule);
     rule.setSourceFile(sourceFile);
     if (startPos != -1 && endPos != -1) {
       rule.setStartPositionCorrection(startPos);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -3200,7 +3200,6 @@ protected List<SuggestedReplacement> getOnlySuggestions(String word) {
       case "Wiederhall": return topMatch("Widerhall");
       case "Wiederhalls": return topMatch("Widerhalls");
       case "Ebensowenig": return topMatch("Ebenso wenig");
-      case "ebensowenig": return topMatch("ebenso wenig");
       case "Ebensooft": return topMatch("Ebenso oft");
       case "ebensooft": return topMatch("ebenso oft");
       case "Ebensogut": return topMatch("Ebenso gut");

File: languagetool-http-client/src/main/java/org/languagetool/remote/ArtificialErrorEval.java
Patch:
@@ -324,7 +324,7 @@ private static void run(boolean printSummaryDetails) throws IOException {
     fakeRuleIDs[1] = "rules_" + words[1] + "->" + words[0]; // rules in the other direction
     CheckConfiguration config;
     CheckConfigurationBuilder cfgBuilder = new CheckConfigurationBuilder(langCode);
-    cfgBuilder.textSessionID("-2");
+    //cfgBuilder.textSessionID("-2");
     if (enabledOnlyRules.isEmpty()) {
       cfgBuilder.disabledRuleIds("WHITESPACE_RULE");
       if (!disabledRules.isEmpty()) {

File: languagetool-language-modules/be/src/main/java/org/languagetool/rules/be/SimpleReplaceRule.java
Patch:
@@ -53,8 +53,8 @@ public SimpleReplaceRule(ResourceBundle messages) throws IOException {
     super(messages, new Belarusian());
     setLocQualityIssueType(ITSIssueType.Misspelling);
     setCategory(new Category(new CategoryId("MISC"), "Агульныя правілы"));
-  addExamplePair(Example.wrong("<marker>З большага</marker>, гэта быў добры дзень."),
-                 Example.fixed("<marker>Збольшага</marker>, гэта быў добры дзень."));
+    addExamplePair(Example.wrong("<marker>З большага</marker>, гэта быў добры дзень."),
+                   Example.fixed("<marker>Збольшага</marker>, гэта быў добры дзень."));
   }
 
   @Override

File: languagetool-language-modules/be/src/test/java/org/languagetool/rules/be/BelarusianSpecificCaseRuleTest.java
Patch:
@@ -45,7 +45,7 @@ public void testRule() throws IOException {
     assertThat(matches1[0].getFromPos(), is(15));
     assertThat(matches1[0].getToPos(), is(25));
     assertThat(matches1[0].getSuggestedReplacements().toString(), is("[Air France]"));
-    assertThat(matches1[0].getMessage(), is("Для спецыяльных найменняў выкарыстоўвайце вялікую літару на пачатку."));
+    assertThat(matches1[0].getMessage(), is("Уласныя імёны і назвы пішуцца з вялікай літары."));
   }
 
   private void assertGood(String input) throws IOException {

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1082,8 +1082,9 @@ private RuleSet getActiveRulesForLevelAndToneTags(Level level, Set<ToneTag> tone
     return ruleSetCache.computeIfAbsent(key, levelToneTagCacheKey -> {
       List<Rule> allRules = new ArrayList<>(getAllActiveRules());
       List<ToneTag> localToneTags;
-      if (toneTags.isEmpty()) {
-        localToneTags = Collections.singletonList(ToneTag.clarity); //If no tone tag is set always use clarity.
+      if (toneTags.isEmpty() || toneTags.contains(ToneTag.ALL_TONE_RULES)) {
+        //localToneTags = Collections.singletonList(ToneTag.clarity); //If no tone tag is set always use clarity. -> disabled for now
+        localToneTags = ToneTag.REAL_TONE_TAGS;
       } else if (toneTags.contains(ToneTag.NO_TONE_RULE)) {
         localToneTags = Collections.emptyList(); //Even clarity rules will be disabled.
       } else {

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/ConfigurationDialog.java
Patch:
@@ -1652,7 +1652,7 @@ private JPanel getChangedRulesPanel(List<Rule> rules, boolean enabledRules, JPan
     } else {
       panel.removeAll();
     }
-    panel.setBackground(Color.WHITE);
+    panel.setBackground(new Color(169,169,169));
     panel.setBorder(BorderFactory.createLineBorder(Color.black));
     panel.setLayout(new GridBagLayout());
     GridBagConstraints cons = new GridBagConstraints();

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1177,7 +1177,9 @@ private RemoteRuleResult fetchResults(long deadlineStartNanos, Mode mode, Level
     }
     RemoteRuleMetrics.RequestResult loggedResult = result.isSuccess() ?
       RemoteRuleMetrics.RequestResult.SUCCESS : RemoteRuleMetrics.RequestResult.ERROR;
-    RemoteRuleMetrics.request(ruleKey, deadlineStartNanos, chars, loggedResult);
+    if (result.isRemote()) {
+      RemoteRuleMetrics.request(ruleKey, deadlineStartNanos, chars, loggedResult);
+    }
     for (int sentenceIndex = 0; sentenceIndex < analyzedSentences.size(); sentenceIndex++) {
       AnalyzedSentence sentence = analyzedSentences.get(sentenceIndex);
       List<RuleMatch> matches = result.matchesForSentence(sentence);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LanguageToolSpellChecker.java
Patch:
@@ -189,7 +189,7 @@ private void initSpellChecker(Locale locale) {
       if (lastLocale == null || !OfficeTools.isEqualLocale(lastLocale, locale)) {
         if (hasLocale(locale)) {
           lastLocale = locale;
-          Language lang = Languages.getLanguageForShortCode(locale.Language + "-" + locale.Country);
+          Language lang = MultiDocumentsHandler.getLanguage(locale);
           lt = new JLanguageTool(lang);
           for (Rule rule : lt.getAllRules()) {
             if (rule.isDictionaryBasedSpellingRule()) {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -750,7 +750,7 @@ private void setConfigValues(Configuration config, SwJLanguageTool lt) {
   /**
    * Get language from locale
    */
-  public Language getLanguage(Locale locale) {
+  public static Language getLanguage(Locale locale) {
     try {
       if (locale.Language.equalsIgnoreCase(LIBREOFFICE_SPECIAL_LANGUAGE_TAG)) {
         return Languages.getLanguageForShortCode(locale.Variant);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -2693,6 +2693,7 @@ protected List<SuggestedReplacement> getOnlySuggestions(String word) {
       case "müßt": return topMatch("müsst");
       case "Müßt": return topMatch("Müsst");
       case "heisst": return topMatch("heißt");
+      case "Heisst": return topMatch("Heißt");
       case "heissen": return topMatch("heißen");
       case "beisst": return topMatch("beißt");
       case "beissen": return topMatch("beißen");
@@ -3162,8 +3163,6 @@ protected List<SuggestedReplacement> getOnlySuggestions(String word) {
       case "ausgemahlt": return topMatch("ausgemalt");
       case "weisst": return topMatch("weißt");
       case "Weisst": return topMatch("Weißt");
-      case "heisst": return topMatch("heißt");
-      case "Heisst": return topMatch("Heißt");
       case "Rehgipsplatte": return topMatch("Rigipsplatte");
       case "Rehgipsplatten": return topMatch("Rigipsplatten");
       case "Rehgips-Platte": return topMatch("Rigips-Platte");

File: languagetool-language-modules/nl/src/test/java/org/languagetool/rules/nl/SimpleReplaceRuleTest.java
Patch:
@@ -52,8 +52,8 @@ public void testRule() throws IOException {
 
     //checkSimpleReplaceRule("Kudde eigenschappen.", "Kudde-eigenschappen");
     checkSimpleReplaceRule("een BTW nummer", "btw-nummer");
-    checkSimpleReplaceRule("kudde eigenschappen.", "kudde-eigenschappen");
-    checkSimpleReplaceRule("De kudde eigenschappen.", "kudde-eigenschappen");
+    checkSimpleReplaceRule("kleurweergave eigenschappen.", "kleurweergave-eigenschappen");
+    checkSimpleReplaceRule("De kleurweergave eigenschappen.", "kleurweergave-eigenschappen");
   }
   private void checkSimpleReplaceRule(String sentence, String suggestion) throws IOException {
     RuleMatch[] matches = rule.match(lt.getAnalyzedSentence(sentence));

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -61,7 +61,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
   private static final int MAX_EDIT_DISTANCE = 2;
 
   private static final String adjSuffix = "(basiert|konform|widrig|fähig|haltig|bedingt|gerecht|würdig|relevant|" +
-    "übergreifend|tauglich|untauglich|artig|bezogen|orientiert|berechtigt|fremd|liebend|hassend|bildend|hemmend|abhängig|zentriert|" +
+    "übergreifend|tauglich|untauglich|artig|bezogen|orientiert|fremd|liebend|hassend|bildend|hemmend|abhängig|zentriert|" +
     "förmig|mäßig|pflichtig|ähnlich|spezifisch|verträglich|technisch|typisch|frei|arm|freundlicher|feindlich|gemäß|neutral|seitig|begeistert|geeignet|ungeeignet|berechtigt)";
   private static final Pattern missingAdjPattern =
     Pattern.compile("[a-zöäüß]{3,25}" + adjSuffix + "(er|es|en|em|e)?");

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1439,6 +1439,8 @@ public RuleMatch adjustRuleMatchPos(RuleMatch match, int charCount,
     }
     RuleMatch thisMatch = new RuleMatch(match);
     thisMatch.setOffsetPosition(fromPos, toPos);
+    //keep the positions with respect to sentence start
+    thisMatch.setSentencePosition(match.getFromPos(), match.getToPos());
 
     int startPos = match.getPatternFromPos() + charCount;
     int endPos = match.getPatternToPos() + charCount;

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -706,10 +706,10 @@ public List<RuleMatch> adaptSuggestions(List<RuleMatch> ruleMatches, Set<String>
         String newReplStr = s.getReplacement();
         if (errorStr.length() > 2) {
           // add a whitespace when the error is in a contraction and the suggestion is not
-          if (errorStr.startsWith("'") && !newReplStr.startsWith("'")) {
+          if (errorStr.startsWith("'") && !newReplStr.startsWith("'") && !newReplStr.startsWith("’")) {
             newReplStr = " " + newReplStr;
           }
-          if (errorStr.startsWith("n't") && !newReplStr.startsWith("n't")) {
+          if (errorStr.startsWith("n't") && !newReplStr.startsWith("n't") && !newReplStr.startsWith("n’t")) {
             newReplStr = " " + newReplStr;
           }
         }

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -251,6 +251,7 @@ protected int getPriorityForId(String id) {
       case "HUNSPELL_RULE":             return -50;
       case "CRASE_CONFUSION":           return -54;
       case "NAO_MILITARES":           return -54;
+      case "NA_QUELE":           return -54;
       case "GENERAL_VERB_AGREEMENT_ERRORS":           return -55;
       case "GENERAL_NUMBER_AGREEMENT_ERRORS":           return -56;
       case "GENERAL_GENDER_NUMBER_AGREEMENT_ERRORS":           return -56;

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -316,7 +316,7 @@ void checkText(AnnotatedText aText, HttpExchange httpExchange, Map<String, Strin
     List<String> dictWords = limits.getPremiumUid() != null ?
       getUserDictWords(limits, dictGroups) : Collections.emptyList();
 
-    boolean filterDictionaryMatches = "true".equals(params.get("filterDictionaryMatches"));
+    boolean filterDictionaryMatches = "true".equals(params.getOrDefault("filterDictionaryMatches", "true"));
 
     Long textSessionId = null;
     try {

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -316,7 +316,7 @@ void checkText(AnnotatedText aText, HttpExchange httpExchange, Map<String, Strin
     List<String> dictWords = limits.getPremiumUid() != null ?
       getUserDictWords(limits, dictGroups) : Collections.emptyList();
 
-    boolean filterDictionaryMatches = "true".equals(params.getOrDefault("filterDictionaryMatches", "true"));
+    boolean filterDictionaryMatches = "true".equals(params.get("filterDictionaryMatches"));
 
     Long textSessionId = null;
     try {

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -316,7 +316,7 @@ void checkText(AnnotatedText aText, HttpExchange httpExchange, Map<String, Strin
     List<String> dictWords = limits.getPremiumUid() != null ?
       getUserDictWords(limits, dictGroups) : Collections.emptyList();
 
-    boolean filterDictionaryMatches = "true".equals(params.get("filterDictionaryMatches"));
+    boolean filterDictionaryMatches = "true".equals(params.getOrDefault("filterDictionaryMatches", "true"));
 
     Long textSessionId = null;
     try {

File: languagetool-standalone/src/test/java/org/languagetool/LanguageTest.java
Patch:
@@ -35,8 +35,8 @@ public void testRuleFileName() {
       assertTrue(new BritishEnglish().getRuleFileNames().contains("/src/main/resources/org/languagetool/rules/en/grammar-premium.xml"));
       assertTrue(new AmericanEnglish().getRuleFileNames().contains("/src/main/resources/org/languagetool/rules/en/grammar-premium.xml"));
     } else {
-      assertEquals("[/org/languagetool/rules/en/grammar.xml, /org/languagetool/rules/en/style.xml, /org/languagetool/rules/en/en-GB/grammar.xml]", new BritishEnglish().getRuleFileNames().toString());
-      assertEquals("[/org/languagetool/rules/en/grammar.xml, /org/languagetool/rules/en/style.xml, /org/languagetool/rules/en/en-US/grammar.xml]", new AmericanEnglish().getRuleFileNames().toString());
+      assertEquals("[/org/languagetool/rules/en/grammar.xml, /org/languagetool/rules/en/style.xml, /org/languagetool/rules/en/en-GB/grammar.xml, /org/languagetool/rules/en/en-GB/style.xml]", new BritishEnglish().getRuleFileNames().toString());
+      assertEquals("[/org/languagetool/rules/en/grammar.xml, /org/languagetool/rules/en/style.xml, /org/languagetool/rules/en/en-US/grammar.xml, /org/languagetool/rules/en/en-US/style.xml]", new AmericanEnglish().getRuleFileNames().toString());
       assertEquals("[/org/languagetool/rules/en/grammar.xml, /org/languagetool/rules/en/style.xml]", new English().getRuleFileNames().toString());
       assertEquals("[/org/languagetool/rules/de/grammar.xml, /org/languagetool/rules/de/style.xml]", new German().getRuleFileNames().toString());
     }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleCheck.java
Patch:
@@ -588,7 +588,7 @@ public SingleProofreadingError[] checkParaRules(String paraText, Locale locale,
           && !docCache.isSingleParagraph(nFPara);
       if (nFPara >= 0 && (pErrors != null || isMouseRequest || (useQueue && !isDialogRequest && parasToCheck != 0))) {
         if (useQueue && pErrors == null && parasToCheck != 0 && isTextParagraph) {
-          singleDocument.addQueueEntry(nFPara, cacheNum, parasToCheck, singleDocument.getDocID(), textIsChanged, textIsChanged);
+          singleDocument.addQueueEntry(nFPara, cacheNum, parasToCheck, singleDocument.getDocID(), textIsChanged);
         }
         return pErrors;
       }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -454,7 +454,7 @@ private void changeTextOfParagraph(int nFPara, int nStart, int nLength, String r
     document.removeIgnoredMatch(nFPara, true);
     if (documents.getConfiguration().useTextLevelQueue() && !documents.getConfiguration().noBackgroundCheck()) {
       for (int i = 1; i < documents.getNumMinToCheckParas().size(); i++) {
-        document.addQueueEntry(nFPara, i, documents.getNumMinToCheckParas().get(i), document.getDocID(), false, true);
+        document.addQueueEntry(nFPara, i, documents.getNumMinToCheckParas().get(i), document.getDocID(), true);
       }
     }
   }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleCheck.java
Patch:
@@ -380,10 +380,10 @@ public void remarkChangedParagraphs(List<Integer> changedParas, List<Integer> to
       }
       for (int i = 0; i < toRemarkParas.size(); i++) {
         toRemarkTextParas.add(docCache.getNumberOfTextParagraph(toRemarkParas.get(i)));
-//        if (debugMode > 1) {
+        if (debugMode > 1) {
           String message = "SingleCheck: remarkChangedParagraphs: Remark: Paragraph: " + toRemarkParas.get(i);
           MessageHandler.printToLogFile(message);
-//        }
+        }
       }
       if (!isDisposed() && !toRemarkTextParas.isEmpty()) {
         DocumentCursorTools docCursor = singleDocument.getDocumentCursorTools();

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -1740,7 +1740,8 @@ private boolean isSingleParagraph_intern(int numberOfFlatParagraph) {
       return true;
     }
     for (int n = 0; n < chapterBegins.get(textParagraph.type).size(); n++) {
-      if (textParagraph.number == chapterBegins.get(textParagraph.type).get(n)) {
+      if (textParagraph.number == 0 ||
+          textParagraph.number == chapterBegins.get(textParagraph.type).get(n)) {
         if (n == chapterBegins.get(textParagraph.type).size() - 1 || 
             chapterBegins.get(textParagraph.type).get(n + 1) == textParagraph.number + 1) {
           return true;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/TextLevelCheckQueue.java
Patch:
@@ -515,13 +515,15 @@ public void run() {
  //       while (numCheck < MAX_CHECK_PER_THREAD) {
         for (;;) {
           queueWaits = false;
+/*
           if (interruptCheck) {
             MessageHandler.printToLogFile("TextLevelCheckQueue: run: Interrupt check - queue ended");
             textRuleQueue.clear();
             interruptCheck = false;
             continue;
 //            return;
           }
+*/
           if (textRuleQueue.isEmpty()) {
             synchronized(textRuleQueue) {
               if (lastDocId != null) {

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -252,6 +252,7 @@ protected int getPriorityForId(String id) {
       case "CRASE_CONFUSION":           return -54;
       case "NAO_MILITARES":           return -54;
       case "GENERAL_VERB_AGREEMENT_ERRORS":           return -55;
+      case "GENERAL_NUMBER_AGREEMENT_ERRORS":           return -56;
       case "GENERAL_GENDER_NUMBER_AGREEMENT_ERRORS":           return -56;
       case "FINAL_STOPS":               return -75;
       case "EU_NÓS_REMOVAL":            return -90;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LinguisticServices.java
Patch:
@@ -438,7 +438,7 @@ private boolean setLtAsGrammarService(XLinguServiceManager mxLinguSvcMgr) {
   /**
    * Set LT as spell checker for all supported languages
    * is normally used deactivate lightproof 
-   */
+   *//*
   public static boolean setLtAsSpellService(XComponentContext xContext, boolean doSet) {
     if ((doSet && spellerIsOn) || (!doSet && !spellerIsOn)) {
       return false;
@@ -478,11 +478,11 @@ public static boolean setLtAsSpellService(XComponentContext xContext, boolean do
         mxLinguSvcMgr.setConfiguredServices("com.sun.star.linguistic2.Proofreader", locale, configuredServices);
         MessageHandler.printToLogFile("LT set as configured Service for Language: " + OfficeTools.localeToString(locale));
       }
-*/      
+*//*      
     }
     return true;
   }
-
+*/
   /**
    * Set a thesaurus relevant rule
    */

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -414,7 +414,7 @@ private void setContextOfClosedDoc(XComponent xComponent) {
         document.dispose(true);
         isDisposed = true;
         if (documents.size() < 2) {
-          LtDictionary.setDisposed();
+//          LtDictionary.setDisposed();
 //          handleDictionary.setStop();
           if (textLevelQueue != null) {
             textLevelQueue.setStop();

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ConfigThread.java
Patch:
@@ -28,6 +28,8 @@
 import org.languagetool.gui.ConfigurationDialog;
 import org.languagetool.rules.Rule;
 
+import com.sun.star.uno.XComponentContext;
+
 /**
  * A thread that shows the configuration dialog which lets the
  * user enable/disable rules.

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/FlatParagraphTools.java
Patch:
@@ -681,7 +681,7 @@ public void setFlatParasAsChecked(int from, int to, List<Boolean> isChecked) {
   /**
    * Marks all paragraphs as checked
    */
-  public void setFlatParasAsChecked() {
+  public void setFlatParasAsChecked(boolean checked) {
     OfficeTools.waitForLO();
     isBusy++;
     try {
@@ -694,12 +694,12 @@ public void setFlatParasAsChecked() {
       }
       XFlatParagraph tmpFlatPara = xFlatPara;
       while (tmpFlatPara != null) {
-        tmpFlatPara.setChecked(TextMarkupType.PROOFREADING, true);
+        tmpFlatPara.setChecked(TextMarkupType.PROOFREADING, checked);
         tmpFlatPara = xFlatParaIter.getParaBefore(tmpFlatPara);
       }
       tmpFlatPara = xFlatPara;
       while (tmpFlatPara != null) {
-        tmpFlatPara.setChecked(TextMarkupType.PROOFREADING, true);
+        tmpFlatPara.setChecked(TextMarkupType.PROOFREADING, checked);
         tmpFlatPara = xFlatParaIter.getParaAfter(tmpFlatPara);
       }
     } catch (Throwable t) {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -240,7 +240,7 @@ private void actualizeNonWriterDocumentCache(SingleDocument document) {
           }
         }
         if (!isSame) {
-          document.resetResultCache();
+          document.resetResultCache(true);
         }
       }
     }

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/UnitConversionRuleTest.java
Patch:
@@ -65,6 +65,8 @@ public void match() throws IOException {
     helper.assertMatches("My new apartment is 500 sq ft.", 1, "46.45 m²", rule, lt);
     helper.assertMatches("It is 100 degrees Fahrenheit outside.", 1, "37.78 °C", rule, lt);
     helper.assertMatches("It is 100 °F outside.", 1, "37.78 °C", rule, lt);
+    helper.assertMatches("It is -22 °F outside.", 1, "-30 °C", rule, lt);
+    helper.assertMatches("It is -22 degrees Fahrenheit outside.", 1, "-30 °C", rule, lt);
 
     // https://github.com/languagetool-org/languagetool/issues/2357
     helper.assertMatches("Millions watched the 1989's Superbowl.", 0, null, rule, lt);

File: languagetool-http-client/src/main/java/org/languagetool/remote/SentenceAnnotator.java
Patch:
@@ -142,7 +142,7 @@ private static void runAnnotation(AnnotatorConfig cfg) throws IOException {
             sentence = replaceSuggestion(sentence, match, r);
             suggestionPos = r;
             suggestionApplied = match.getReplacements().get().get(suggestionPos - 1);
-            formattedCorrectedSentence = formattedCorrectedSentence(sentence, match, i);
+            formattedCorrectedSentence = formattedCorrectedSentence(sentence, match, r);
           }
           break;
         }

File: languagetool-language-modules/fr/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -55,6 +55,8 @@ public void testLanguageDependentFilter() throws IOException {
     matches = tool.check(annotatedText, true, ParagraphHandling.NORMAL, listener, Mode.ALL, Level.DEFAULT);
     assertEquals(1, matches.size());
     assertEquals("[D'homme]", matches.get(0).getSuggestedReplacements().toString());
+    
+    tool.check("vrai/faux avec explication : Les droits d'accès, également appelés permissions ou autorisations, sont des règles définissant");
 
   }
 }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/FlatParagraphTools.java
Patch:
@@ -400,7 +400,7 @@ private static List<Integer> getLanguagePortions(XFlatParagraph flatPara, int le
    * Get the main language of paragraph 
    * @throws IllegalArgumentException 
    */
-  public static Locale getPrimaryParagraphLanguage(XFlatParagraph flatPara, int start, int len, Locale fixedLocale, 
+  public Locale getPrimaryParagraphLanguage(XFlatParagraph flatPara, int start, int len, Locale fixedLocale, 
       Locale lastLocale, boolean onlyPrimary) throws IllegalArgumentException {
     isBusy++;
     try {

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/PostponedAdjectiveConcordanceFilter.java
Patch:
@@ -104,7 +104,7 @@ public class PostponedAdjectiveConcordanceFilter extends RuleFilter {
   private static final Pattern KEEP_COUNT2 = Pattern.compile(",|i|o|ni"); // |\\d+%?|%
   private static final Pattern STOP_COUNT = Pattern.compile("[;:]");
   private static final Pattern PREPOSICIONS = Pattern.compile("SPS.*");
-  private static final Pattern PREPOSICIO_CANVI_NIVELL = Pattern.compile("de|d'|en|sobre|a|entre|per|pe|amb|sense|contra|com");
+  private static final Pattern PREPOSICIO_CANVI_NIVELL = Pattern.compile("de|d'|en|sobre|a|entre|per|pe|amb|sense|contra|com|envers");
   private static final Pattern VERB = Pattern.compile("V.[^P].*|_GV_");
   private static final Pattern GV = Pattern.compile("_GV_");
   

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -1977,7 +1977,7 @@ public void run() {
         synchronized(queueWakeup) {
           if (textToCheck.size() < 1) {
             try {
-              MessageHandler.printToLogFile("HandleLtDictionary: run: queue waits");
+//              MessageHandler.printToLogFile("HandleLtDictionary: run: queue waits");
               queueWakeup.wait();
             } catch (InterruptedException e) {
               MessageHandler.printException(e);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleCheck.java
Patch:
@@ -465,7 +465,7 @@ private List<SingleProofreadingError[]> checkTextRules( String paraText, Locale
       return pErrors;
     }
     TextParagraph nTParas = paraNum < 0 ? null : docCache.getNumberOfTextParagraph(paraNum);
-    if (nTParas == null || nTParas.type == DocumentCache.CURSOR_TYPE_UNKNOWN) {
+    if (nTParas == null || nTParas.type == DocumentCache.CURSOR_TYPE_UNKNOWN || docCache.isSingleParagraph(paraNum)) {
       pErrors.add(checkParaRules(paraText, locale, footnotePos, paraNum, startSentencePos, lt, 0, 0, textIsChanged, isIntern));
     } else {
       //  Real full text check / numParas < 0
@@ -574,7 +574,8 @@ public SingleProofreadingError[] checkParaRules(String paraText, Locale locale,
         lastSinglePara = paraText;
       }
       // return Cache result if available / for right mouse click or Dialog only use cache
-      boolean isTextParagraph = nFPara >= 0 && docCache != null && docCache.getNumberOfTextParagraph(nFPara).type != DocumentCache.CURSOR_TYPE_UNKNOWN;
+      boolean isTextParagraph = nFPara >= 0 && docCache != null && docCache.getNumberOfTextParagraph(nFPara).type != DocumentCache.CURSOR_TYPE_UNKNOWN
+          && !docCache.isSingleParagraph(nFPara);
       if (nFPara >= 0 && (pErrors != null || isMouseRequest || (useQueue && !isDialogRequest && parasToCheck != 0))) {
         if (useQueue && pErrors == null && parasToCheck != 0 && isTextParagraph) {
           singleDocument.addQueueEntry(nFPara, cacheNum, parasToCheck, singleDocument.getDocID(), textIsChanged, textIsChanged);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -415,6 +415,7 @@ private void setContextOfClosedDoc(XComponent xComponent) {
         isDisposed = true;
         if (documents.size() < 2) {
           LtDictionary.setDisposed();
+          handleDictionary.setStop();
           if (textLevelQueue != null) {
             textLevelQueue.setStop();
             textLevelQueue = null;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -764,7 +764,9 @@ public QueueEntry getQueueEntryForChangedParagraph() {
           changedParas.remove(nPara);
           if (sChangedPara != null && !sChangedPara.equals(sPara)) {
             docCache.setFlatParagraph(nPara, sPara);
-            mDocHandler.handleLtDictionary(sPara, docCache.getFlatParagraphLocale(nPara));
+            if (!disposed) {
+              mDocHandler.handleLtDictionary(sPara, docCache.getFlatParagraphLocale(nPara));
+            }
             //  NOTE: Don't remove paragraph cache 0. It is needed to set correct markups
             for (int i = 1; i < mDocHandler.getNumMinToCheckParas().size(); i++) {
               paragraphsCache.get(i).remove(nPara);

File: languagetool-core/src/main/java/org/languagetool/rules/ngrams/ConfusionProbabilityRule.java
Patch:
@@ -377,7 +377,7 @@ static class SpecificIdRule extends ConfusionProbabilityRule {
       this.id = Objects.requireNonNull(id);
       this.desc = desc;
       if (lang.getShortCode().equals("en") && (id.equals("CONFUSION_RULE_BARE_BEAR")
-          || id.equals("CONFUSION_RULE_BARE_BEAR"))) {
+          || id.equals("CONFUSION_RULE_BEAR_BARE"))) {
         this.setUrl(Tools.getUrl("https://languagetool.org/insights/post/spelling-bear-vs-bare-with-me/"));
       }
     }

File: languagetool-core/src/main/java/org/languagetool/rules/ngrams/ConfusionProbabilityRule.java
Patch:
@@ -376,8 +376,8 @@ static class SpecificIdRule extends ConfusionProbabilityRule {
       super(messages, lm, lang);
       this.id = Objects.requireNonNull(id);
       this.desc = desc;
-      if (lang.getShortCode().equals("en") && id.equals("CONFUSION_RULE_BARE_BEAR")
-          || id.equals("CONFUSION_RULE_BARE_BEAR")) {
+      if (lang.getShortCode().equals("en") && (id.equals("CONFUSION_RULE_BARE_BEAR")
+          || id.equals("CONFUSION_RULE_BARE_BEAR"))) {
         this.setUrl(Tools.getUrl("https://languagetool.org/insights/post/spelling-bear-vs-bare-with-me/"));
       }
     }

File: languagetool-language-modules/nl/src/main/java/org/languagetool/language/Dutch.java
Patch:
@@ -176,7 +176,7 @@ public boolean isAdvancedTypographyEnabled() {
   @Override
   protected int getPriorityForId(String id) {
     if (id.startsWith(SimpleReplaceRule.DUTCH_SIMPLE_REPLACE_RULE)) {
-      return 1; // above spell checker, seems to do better with its suggestions
+      return -2;
     }
     switch (id) {
       case LongSentenceRule.RULE_ID: return -1;

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/INNNumberFilter.java
Patch:
@@ -30,7 +30,7 @@
 
 /**
  * Checks if INN number is incorrect
- * @ author Yakov Reztsov
+ * @author Yakov Reztsov
  * @since 6.1
  */
 

File: languagetool-language-modules/uk/src/main/java/org/languagetool/tagging/disambiguation/uk/SimpleDisambiguator.java
Patch:
@@ -10,6 +10,7 @@
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 
+import org.apache.commons.lang3.StringUtils;
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.AnalyzedToken;
 import org.languagetool.AnalyzedTokenReadings;
@@ -68,8 +69,8 @@ public void removeRareForms(AnalyzedSentence input) {
     for (int i = 1; i < tokens.length; i++) {
 
       String token = tokens[i].getCleanToken();
-//      if( token == null )
-//        continue;
+      if( StringUtils.isEmpty(token) )
+        continue;
 
       if( Character.isLowerCase(token.charAt(0)) ) {
         token = token.toLowerCase();

File: languagetool-language-modules/uk/src/test/java/org/languagetool/tagging/disambiguation/uk/UkrainianHybridDisambiguationTest.java
Patch:
@@ -592,6 +592,8 @@ public void testIgnoredCharacters() throws IOException {
         + ".[</S>]",
         analyzedSentence.toString());
 
+    analyzedSentence = lt.getAnalyzedSentence("\u0301");
+    assertEquals("<S> </S> ", analyzedSentence.toString());
   }
 
   

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -249,6 +249,7 @@ protected int getPriorityForId(String id) {
       case "NOMBRES_ROMANS": return -90;
       case "MORFOLOGIK_RULE_CA_ES": return -100;
       case "EXIGEIX_ACCENTUACIO_VALENCIANA": return -120;
+      //case "APOSTROFACIO_MOT_DESCONEGUT": return -120; // lesser than MORFOLOGIK_RULE_CA_ES
       case "PHRASE_REPETITION": return -150;
       case "SUBSTANTIUS_JUNTS": return -150;
       case "FALTA_ELEMENT_ENTRE_VERBS": return -200;

File: languagetool-server/src/main/java/org/languagetool/server/RemoteSynthesizer.java
Patch:
@@ -43,7 +43,7 @@ protected List<String> synthesize(String languageCode, AnalyzedTokenReadings atr
     }
     AnalyzedToken atr = atrs.readingWithTagRegex(postagSelect);
     if (atr == null) {
-      log.info("AnalyzedToken is null. Language: ", languageCode, " Token:", atrs.toString(), "postagSelect: ",
+      log.error("AnalyzedToken is null. Language: ", languageCode, " Token:", atrs.toString(), "postagSelect: ",
           postagSelect);
       return null;
     }
@@ -56,7 +56,7 @@ protected List<String> synthesize(String languageCode, AnalyzedTokenReadings atr
       Matcher m = p.matcher(atr.getPOSTag());
       postagReplaceFinal = m.replaceAll(postagReplace);
     } catch (IndexOutOfBoundsException | PatternSyntaxException e) {
-      log.info("Exception: error in regular expressions. Language: ", languageCode, " Token:", atrs.toString(),
+      log.error("Exception: error in regular expressions. Language: ", languageCode, " Token:", atrs.toString(),
           " Stack trace: ", e.getStackTrace());
       return null;
     }

File: languagetool-core/src/main/java/org/languagetool/UserConfig.java
Patch:
@@ -282,7 +282,7 @@ public boolean getHidePremiumMatches() {
   }
 
   /**
-   * This may not contain the full preferredLanguages list as its indent to only used with ForeignLanguageChecker
+   * This may not contain the full preferredLanguages list as it's  intended to only be used with ForeignLanguageChecker
    * @return 
    */
   @NotNull

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/GrammalecteRule.java
Patch:
@@ -420,7 +420,7 @@ public class GrammalecteRule extends Rule {
     "g2__conf_a_à_verbe__b7_a1_1",
     "g2__conf_a_à_verbe__b8_a1_1",
     "g3__gn_la_3m__b1_a1_1",
-    "gv1__imp_verbe_groupe3_d__b2"//rule is generating FP and a loop(https://github.com/languagetooler-gmbh/languagetool-premium/issues/5220)
+    "gv1__imp_verbe_groupe3_d__b2_a1_1"//rule is generating FP and a loop(https://github.com/languagetooler-gmbh/languagetool-premium/issues/5220)
   ));
 
   public GrammalecteRule(ResourceBundle messages, GlobalConfig globalConfig) {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanCommaWhitespaceRule.java
Patch:
@@ -34,7 +34,7 @@ public GermanCommaWhitespaceRule(ResourceBundle messages, IncorrectExample incor
 
   @Override
   protected boolean isException(AnalyzedTokenReadings[] tokens, int tokenIdx) {
-    if (tokenIdx+1 < tokens.length &&
+    if (tokenIdx+2 < tokens.length &&
         tokens[tokenIdx].getToken().equals(".") &&
         tokens[tokenIdx+1].getToken().matches("[a-z]{2,10}-Domains?")) {
       return true;

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/DateFilterHelper.java
Patch:
@@ -53,6 +53,7 @@ protected int getMonth(String monthStr) {
     String mon = monthStr.toLowerCase();
     if (mon.startsWith("jan")) return 1;
     if (mon.startsWith("fév")) return 2;
+    if (mon.startsWith("fev")) return 2;
     if (mon.startsWith("mar")) return 3;
     if (mon.startsWith("avr")) return 4;
     if (mon.startsWith("mai")) return 5;
@@ -66,6 +67,7 @@ protected int getMonth(String monthStr) {
     if (mon.startsWith("oct")) return 10;
     if (mon.startsWith("nov")) return 11;
     if (mon.startsWith("déc")) return 12;
+    if (mon.startsWith("dec")) return 12;
     throw new RuntimeException("Could not find month '" + monthStr + "'");
   }
 }

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1959,7 +1959,7 @@ private CheckResults getOtherRuleMatches() {
             for (RuleMatch elem : sentenceMatches) {
               RuleMatch thisMatch = adjustRuleMatchPos(elem, sentence.startOffset, sentence.startColumn, sentence.startLine, sentence.text, annotatedText);
               if (elem.getErrorLimitLang() != null) {
-                Range ignoreRange = new Range(sentence.startOffset, sentence.startOffset + sentence.text.length(), elem.getErrorLimitLang());
+                Range ignoreRange = new Range(sentence.startOffset, sentence.startOffset + sentence.text.length(), elem.getErrorLimitLang(), thisMatch.getSentence());
                 if (!ignoreRanges.contains(ignoreRange)) {
                   ignoreRanges.add(ignoreRange);
                 }

File: languagetool-core/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -45,7 +45,7 @@ public void testUserConfig() throws IOException {
     List<PatternToken> patternTokens = Arrays.asList(PatternRuleBuilderHelper.token("my"), PatternRuleBuilderHelper.token("test"));
     userRules.add(new PatternRule("MY_TEST", lang, patternTokens, "test rule desc", "my test rule", "my test rule"));
     Map<String, Integer> map = new HashMap<>();
-    UserConfig userConfig = new UserConfig(Collections.emptyList(), userRules, map, -1, 1L, "fake", null, null, false, null, null, false);
+    UserConfig userConfig = new UserConfig(Collections.emptyList(), userRules, map, -1, 1L, "fake", null, null, false, null, null, false, null, null);
     JLanguageTool lt2 = new JLanguageTool(lang, null, userConfig);
     lt2.disableRule("test_unification_with_negation");
     List<RuleMatch> matches2 = lt2.check("This is my test");

File: languagetool-standalone/src/test/java/org/languagetool/rules/MultiLanguageTextTest.java
Patch:
@@ -55,6 +55,7 @@ public static void setup() throws IOException {
   }
   
   @Test
+  @Ignore //TODO: need rework: works only with preferred languages in userConfig
   public void testEnglishInGermanDetected() throws IOException {
     JLanguageTool lt = new JLanguageTool(GERMAN_DE);
     RuleMatch[] matches1 = germanSpellerRule.match(lt.getAnalyzedSentence("He is a very cool guy from Poland."));
@@ -89,7 +90,7 @@ public void testEnglishInGermanDetected() throws IOException {
   }
 
   @Test
-  @Ignore
+  @Ignore //TODO: need rework: works only with preferred languages in userConfig 
   public void testWithLanguageIdentifier() throws IOException {
     LanguageIdentifierService.INSTANCE.getDefaultLanguageIdentifier(1000, new File("/home/stefan/Dokumente/languagetool/data/model_ml50_new.zip"), new File("/home/stefan/Dokumente/languagetool/data/fasttext/fasttext"), new File("/home/stefan/Dokumente/languagetool/data/fasttext/lid.176.bin"));
     JLanguageTool lt = new JLanguageTool(GERMAN_DE);

File: languagetool-standalone/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.rules.de;
 
+import org.junit.Ignore;
 import org.junit.Test;
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.JLanguageTool;
@@ -39,6 +40,7 @@ public class GermanSpellerRuleTest {
   private static final German GERMAN_DE = (German) Languages.getLanguageForShortCode("de-DE");
 
   @Test
+  @Ignore //TODO: need rework: works only with preferred languages in userConfig
   public void testErrorLimitReached() throws IOException {
     HunspellRule rule1 = new GermanSpellerRule(TestTools.getMessages("de"), GERMAN_DE);
     JLanguageTool lt = new JLanguageTool(GERMAN_DE);
@@ -67,6 +69,7 @@ public void testErrorLimitReached() throws IOException {
   }
 
   @Test
+  @Ignore //TODO: need rework: works only with preferred languages in userConfig
   // case: signature is (mostly) English, user starts typing in German -> first, EN is detected for whole text
   // Also see MorfologikAmericanSpellerRuleTest
   public void testMultilingualSignatureCase() throws IOException {

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/INNNumberFilter.java
Patch:
@@ -52,7 +52,6 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> args, int
               int[] intTab = String.valueOf(INNNumberString).chars().map(Character::getNumericValue).toArray();
               int kz1=0;
               int kz2=0;
-              System.out.println(intTab.length);
               switch (intTab.length) {
                   case 10:
                       kz1 = (intTab[0]*2 + intTab[1]*4 + intTab[2]*10 + intTab[3]*3 + intTab[4]*5+ intTab[5]*9 + intTab[6]*4 + intTab[7]*6 + intTab[8]*8)%11;
@@ -62,7 +61,6 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> args, int
                           return match;
                       }
                   case 12:
-                     System.out.println(INNNumberString);
                       kz1 = (intTab[0]*7 + intTab[1]*2 + intTab[2]*4 + intTab[3]*10 + intTab[4]*3 + intTab[5]*5+ intTab[6]*9 + intTab[7]*4 + intTab[8]*6 + intTab[9]*8)%11;
                       kz2 = (intTab[0]*3 + intTab[1]*7 + intTab[2]*2 + intTab[3]*4 + intTab[4]*10 + intTab[5]*3 + intTab[6]*5+ intTab[7]*9 + intTab[8]*4 + intTab[9]*6 + intTab[10]*8)%11;
                       if ((intTab[10] == kz1) && (intTab[11] == kz2)) {

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/RussianVerbConjugationRule.java
Patch:
@@ -87,7 +87,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
                             }
                     String nextToken = nextLemmaTok.getToken();
                     String nextPosTag = nextLemmaTok.getPOSTag();
-                    if(nextPosTag != null && !(nextPosTag.isEmpty()) && !(next2Token.equals("быть")) && !(nextToken.equals("целую")) ) {  //  "может быть"
+                    if(nextPosTag != null && !(nextPosTag.isEmpty()) && !(next2Token.equals("быть") && nextToken.equals("может")) && !(nextToken.equals("целую")) ) {  //  "может быть"
                         Matcher verbMatcher = FUT_REAL_VERB.matcher(nextPosTag);
                         if (verbMatcher.find()) {
                             Pair<String, String> verbPair = new ImmutablePair<>(verbMatcher.group(4), verbMatcher.group(5));

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/RuleMatchDiffFinder.java
Patch:
@@ -496,7 +496,7 @@ private void run(LightRuleMatchParser parser, File file1, File file2, File outpu
         }
         fw.write("<td>");
         String id = file.replaceFirst("result_.*?_", "").replace(".html", "");
-        fw.write("  <a href='" + file + "'>" + id + "</a>");
+        fw.write("  <a href='" + enc(file) + "'>" + id + "</a>");
         fw.write("  " + getAnalyticsLink(id, langCode));
         fw.write("</td>");
         if (outputFile.items.size() > 0 && outputFile.items.get(0).getNewMatch() != null) {

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/CommonFileTypes.java
Patch:
@@ -38,7 +38,7 @@ public class CommonFileTypes {
     "key", "odp", "pps", "ppt", "pptx", "class", "cpp", "cs", "h", "sh", "swift", "vb",
     "ods", "odt", "xlr", "xls", "xlsx", "xlt", "xltx", "bak", "cab", "cfg", "cpl", "cur", "dll", "dmp", "msi", "ini", "tmp",
     "3g2", "3gp", "avi", "flv", "h264", "m4v", "mkv", "mov", "mp4", "mpg", "mpeg", "rm", "swf", "vob", "wmv",
-    "doc", "docx", "dot", "dotx", "pdf", "rtf", "srx", "text", "tex", "wks", "wps", "wpd", "txt", "yaml", "yml", "csl", "md", "adm"
+    "doc", "docx", "dot", "dotx", "pdf", "rtf", "srx", "text", "tex", "wks", "wps", "wpd", "txt", "yaml", "yml", "csl", "md", "adm", "webm", "webp"
   );
   
   private final static Pattern suffixPattern = 

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/RuleMatchDiffFinder.java
Patch:
@@ -152,9 +152,9 @@ private void printDiffs(List<RuleMatchDiff> diffs, FileWriter fw, String langCod
       }
     }
     if (fullMode) {
-      fw.write(". <a href='../" + langCode + "/" + filename + "'>Today's list</a>");
+      fw.write(". <a href='../" + langCode + "/" + enc(filename) + "'>Today's list</a>");
     } else {
-      fw.write(". <a href='../" + langCode + "_full/" + filename + "'>Full list</a>");
+      fw.write(". <a href='../" + langCode + "_full/" + enc(filename) + "'>Full list</a>");
     }
     String shortRuleId = ruleId.replaceFirst("^.* / ", "").replaceFirst("\\[[0-9]+\\]", "");
     fw.write(".  " + getAnalyticsLink(shortRuleId, langCode));

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -215,6 +215,8 @@ ProofreadingResult getCheckResults(String paraText, Locale locale, ProofreadingR
         if (initDocs) {
           initDocuments(true);
         }
+      } else if (textLevelQueue == null && useQueue) {
+        textLevelQueue = new TextLevelCheckQueue(this);
       }
     }
     if (debugMode) {
@@ -1954,7 +1956,7 @@ private class ShapeChangeCheck extends Thread {
     @Override
     public void run() {
       try {
-        while (runLoop) {
+        while (runLoop && textLevelQueue != null) {
           try {
             for (int i = 0; i < documents.size(); i++) {
               documents.get(i).addShapeQueueEntries();

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -671,7 +671,7 @@ public FlatParagraphTools setFlatParagraphTools() {
    * nFPara is number of flat paragraph
    */
   public void addQueueEntry(int nFPara, int nCache, int nCheck, String docId, boolean checkOnlyParagraph, boolean overrideRunning) {
-    if (!disposed && mDocHandler.isSortedRuleForIndex(nCache) && docCache != null) {
+    if (!disposed && mDocHandler.getTextLevelCheckQueue() != null && mDocHandler.isSortedRuleForIndex(nCache) && docCache != null) {
       TextParagraph nTPara = docCache.getNumberOfTextParagraph(nFPara);
       if (nTPara != null && nTPara.type != DocumentCache.CURSOR_TYPE_UNKNOWN) {
         int nStart;

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanCommaWhitespaceRule.java
Patch:
@@ -34,7 +34,8 @@ public GermanCommaWhitespaceRule(ResourceBundle messages, IncorrectExample incor
 
   @Override
   protected boolean isException(AnalyzedTokenReadings[] tokens, int tokenIdx) {
-    if (tokens[tokenIdx].getToken().equals(".") &&
+    if (tokenIdx+1 < tokens.length &&
+        tokens[tokenIdx].getToken().equals(".") &&
         tokens[tokenIdx+1].getToken().matches("[a-z]{2,10}-Domains?")) {
       return true;
     }

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -199,6 +199,7 @@ protected RuleMatch createWrongSplitMatch(AnalyzedSentence sentence, List<RuleMa
     }
     RuleMatch ruleMatch = new RuleMatch(this, sentence, prevPos, pos + coveredWord.length(),
             messages.getString("spelling"), messages.getString("desc_spelling_short"));
+    ruleMatch.setType(RuleMatch.Type.UnknownWord);
     ruleMatch.setSuggestedReplacement((suggestion1 + " " + suggestion2).trim());
     return ruleMatch;
   }

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -365,6 +365,7 @@ && getFrequency(speller1, sugg1a) + getFrequency(speller1, sugg1b) > getFrequenc
             if (getFrequency(speller1, sugg) >= getFrequency(speller1, prevWord)) {
               ruleMatch = new RuleMatch(this, sentence, prevStartPos, startPos + word.length(),
                   messages.getString("spelling"), messages.getString("desc_spelling_short"));
+              ruleMatch.setType(RuleMatch.Type.UnknownWord);
               beforeSuggestionStr = prevWord + " ";
               ruleMatch.setSuggestedReplacement(sugg);
             }
@@ -410,6 +411,7 @@ && getFrequency(speller1, nextWord) < MAX_FREQUENCY_FOR_SPLITTING) {
             if (getFrequency(speller1, sugg) >= getFrequency(speller1, nextWord)) {
               ruleMatch = new RuleMatch(this, sentence, startPos, nextStartPos + nextWord.length(),
                   messages.getString("spelling"), messages.getString("desc_spelling_short"));
+              ruleMatch.setType(RuleMatch.Type.UnknownWord);
               afterSuggestionStr = " " + nextWord;
               ruleMatch.setSuggestedReplacement(sugg);
             }
@@ -473,6 +475,7 @@ && getFrequency(speller1, nextWord) < MAX_FREQUENCY_FOR_SPLITTING) {
     if (ruleMatch == null) {
       ruleMatch = new RuleMatch(this, sentence, startPos, startPos + word.length(), messages.getString("spelling"),
               messages.getString("desc_spelling_short"));
+      ruleMatch.setType(RuleMatch.Type.UnknownWord);
     }
     
     //word starting with numbers or bullets    

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java
Patch:
@@ -528,6 +528,7 @@ private void addFormsToFirstMatch(String message, AnalyzedSentence sentence, Lis
     // this has precedence
     RuleMatch oldMatch = ruleMatches.get(0);
     RuleMatch newMatch = new RuleMatch(this, sentence, oldMatch.getFromPos(), oldMatch.getToPos(), message);
+    newMatch.setType(oldMatch.getType());
     newMatch.setLazySuggestedReplacements(() -> new ArrayList<>(Sets.newLinkedHashSet(Iterables.concat(
       Iterables.transform(forms, SuggestedReplacement::new),
       oldMatch.getSuggestedReplacementObjects()
@@ -540,6 +541,7 @@ private void replaceFormsOfFirstMatch(String message, AnalyzedSentence sentence,
     // this has precedence
     RuleMatch oldMatch = ruleMatches.get(0);
     RuleMatch newMatch = new RuleMatch(this, sentence, oldMatch.getFromPos(), oldMatch.getToPos(), message);
+    newMatch.setType(oldMatch.getType());
     SuggestedReplacement sugg = new SuggestedReplacement(suggestion);
     sugg.setShortDescription(language.getName());
     newMatch.setSuggestedReplacementObjects(Collections.singletonList(sugg));

File: languagetool-dev/src/main/java/org/languagetool/dev/XmlIndenter.java
Patch:
@@ -81,7 +81,7 @@ public static void main(String[] args) throws IOException {
       if (line.startsWith("<rulegroup")) { inRuleGroup = true; }
       if (line.startsWith("<rule ") || line.startsWith("<rule>")) { inRule = true; }
       if (line.startsWith("<pattern")) { inPattern = true; }
-      if (line.startsWith("<antipattern")) { inAntiPattern = true; }
+      if (line.startsWith("<antipattern") && !line.contains("</antipattern")) { inAntiPattern = true; }
       if (line.contains("<marker>") && !line.contains("</marker>") && (inPattern || inAntiPattern)) { inMarker = true; }
       if (line.contains("<and>")) { inAnd = true; }
       if (line.contains("<unify>") || line.contains("<unify ")) { inUnify = true; }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -382,7 +382,7 @@ public boolean hasUnsupportedText() {
   private static boolean isEqualWithoutFootnotes(String flatPara, String textPara, int[] footnotes, int[] n, int level) {
     //  NOTE: flat paragraphs contain footnotes and endnotes as zero space characters
     //        text paragraphs contain footnotes and endnotes as digits or Roman characters
-    for(n[level] = 1; n[level] <= MAX_NOTE_CHAR; n[level]++) {
+    for(n[level] = 0; n[level] <= MAX_NOTE_CHAR; n[level]++) {
       if (level == 0) {
         String textP = textPara;
         for (int i = footnotes.length - 1; i >= 0; i--) {
@@ -421,7 +421,7 @@ public static boolean isEqualText(String flatPara, String textPara, int[] footno
     }
     int[] n = new int[footnotes.length];
     for(int j = 0; j < n.length; j++) {
-      n[j] = 1;
+      n[j] = 0;
     }
     return isEqualWithoutFootnotes(flatPara, textPara, footnotes, n, n.length - 1);
   }

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java
Patch:
@@ -641,6 +641,8 @@ protected static Map<String, List<String>> getTopSuggestionsIgnoreCase() {
   protected static Map<String, List<String>> getTopSuggestions() {
     Map<String, List<String>> s = new HashMap<>();
     s.put("Ths", Arrays.asList("This", "The"));
+    s.put("whitout", Arrays.asList("without", "white out"));
+    s.put("Whitout", Arrays.asList("Without", "White out"));
     s.put("compability", Arrays.asList("compatibility"));
     s.put("Compability", Arrays.asList("Compatibility"));
     s.put("enroute", Arrays.asList("en route"));

File: languagetool-core/src/main/java/org/languagetool/rules/RuleMatch.java
Patch:
@@ -201,10 +201,10 @@ public RuleMatch(RuleMatch clone) {
   }
   
   //clone with new replacements
-  public RuleMatch(RuleMatch clone, List<String> replacements) {
+  public RuleMatch(RuleMatch clone, List<SuggestedReplacement> replacements) {
     this(clone.getRule(), clone.getSentence(), clone.getFromPos(), clone.getToPos(), clone.getMessage(), clone.getShortMessage());
     this.setPatternPosition(clone.getPatternFromPos(), clone.getPatternToPos());
-    this.setSuggestedReplacements(replacements);
+    this.setSuggestedReplacementObjects(replacements);
     this.setAutoCorrect(clone.isAutoCorrect());
     this.setFeatures(clone.getFeatures());
     this.setUrl(clone.getUrl());

File: languagetool-language-modules/es/src/test/java/org/languagetool/tagging/es/SpanishTaggerTest.java
Patch:
@@ -48,6 +48,7 @@ public void testTagger() throws IOException {
     TestTools.myAssert("DESTACADAMENTE", "DESTACADAMENTE/[destacadamente]RG", tokenizer, tagger);
     TestTools.myAssert("alucinadamente", "alucinadamente/[alucinadamente]RG", tokenizer, tagger);
     TestTools.myAssert("disputadamente", "disputadamente/[disputadamente]RG", tokenizer, tagger);
+    TestTools.myAssert("superincómodas", "superincómodas/[superincómodo]AQ0FP0", tokenizer, tagger);
     
     // all-upper case that is common noun & proper noun
     TestTools.myAssert("RIOJA", "RIOJA/[Rioja]NPCNG00|RIOJA/[rioja]NCMS000", tokenizer, tagger);

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -239,7 +239,8 @@ protected int getPriorityForId(String id) {
       case "SI_AFIRMACION": return 10; // less than DIACRITICS
       case "TE_TILDE2": return 10; // less than PRONOMBRE_SIN_VERBO
       case "SEPARADO": return 1;
-      case "ES_SPLIT_WORDS": return -10; 
+      case "ES_SPLIT_WORDS": return -10;
+      case "U_NO": return -10;
       case "E_EL": return -10;
       case "EL_TILDE": return -10;
       case "SINGLE_CHARACTER": return -15; // less than ES_SPLIT_WORDS

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -236,6 +236,8 @@ private void refreshWriterCache(SingleDocument document, Locale fixedLocale, Loc
         flatPara = document.getFlatParagraphTools();
       }
       if (flatPara == null) {
+        MessageHandler.printToLogFile(
+            "WARNING: DocumentCache: refresh: flatPara == null - ParagraphCache not initialised");
         return;
       }
       paragraphContainer = flatPara.getAllFlatParagraphs(fixedLocale);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -179,6 +179,9 @@ private void refreshWriterCache(SingleDocument document, Locale fixedLocale, Loc
     try {
       long startTime = System.currentTimeMillis();
       DocumentCursorTools docCursor = document.getDocumentCursorTools();
+      if (docCursor == null) {
+        docCursor = new DocumentCursorTools(document.getXComponent());
+      }
       FlatParagraphTools flatPara = document.getFlatParagraphTools();
       List<String> paragraphs = new ArrayList<String>();
       List<List<Integer>> chapterBegins = new ArrayList<List<Integer>>();

File: languagetool-http-client/src/main/java/org/languagetool/remote/ArtificialErrorEval.java
Patch:
@@ -794,7 +794,7 @@ private static List<String> differences(String s1, String s2) {
       fromStart++;
     }
     int fromEnd = 0;
-    while (s1.charAt(l1 - 1 - fromEnd) == s2.charAt(l2 - 1 - fromEnd)) {
+    while (fromEnd < l1 && fromEnd < l2 && s1.charAt(l1 - 1 - fromEnd) == s2.charAt(l2 - 1 - fromEnd)) {
       fromEnd++;
     }
     // corrections (e.g. stress vs stresses)

File: languagetool-language-modules/ru/src/main/java/org/languagetool/language/Russian.java
Patch:
@@ -143,7 +143,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
                     Example.wrong("Закончилось лето. <marker>дети</marker> снова сели за школьные парты."),
                     Example.fixed("Закончилось лето. <marker>Дети</marker> снова сели за школьные парты.")),
             new MorfologikRussianSpellerRule(messages, this, userConfig, altLanguages),
-            new WordRepeatRule(messages, this),
+        //  new WordRepeatRule(messages, this), // move to RussianSimpleWordRepeatRule
             new MultipleWhitespaceRule(messages, this),
 	    new SentenceWhitespaceRule(messages),
             new WhiteSpaceBeforeParagraphEnd(messages, this),  
@@ -164,6 +164,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new RussianUnpairedBracketsRule(messages, this),
             new RussianCompoundRule(messages, this, userConfig),
             new RussianSimpleReplaceRule(messages),
+            new RussianSimpleWordRepeatRule(messages, this),
             new RussianWordCoherencyRule(messages),
             new RussianWordRepeatRule(messages),
             new RussianWordRootRepeatRule(messages),

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/RussianWordRepeatRule.java
Patch:
@@ -67,8 +67,10 @@ public RussianWordRepeatRule(ResourceBundle messages) {
     super(messages);
     addExamplePair(Example.wrong("Всё смешалось в <marker>доме доме</marker> Облонских."),
                    Example.fixed("Всё смешалось в <marker>доме</marker> Облонских."));
+    setDefaultTempOff();
   }
 
+
   @Override
   public final String getId() {
     return "RU_WORD_REPEAT";

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -195,6 +195,7 @@ protected int getPriorityForId(String id) {
       case "REPETEAD_ELEMENTS": return 40;
       case "ESPERANT_US_AGRADI": return 40;
       case "ESPAIS_SOBRANTS": return 40; // greater than L
+      case "HAVER_SENSE_HAC": return 35; // greater than CONFUSIONS_ACCENT avia, CONFUSIONS_E
       case "CONCORDANCES_CASOS_PARTICULARS": return 30;
       case "CONFUSIONS_PRONOMS_FEBLES": return 30; // greater than ES (DIACRITICS)
       case "GERUNDI_PERD_T": return 30;
@@ -205,8 +206,7 @@ protected int getPriorityForId(String id) {
       case "REEMPRENDRE": return 28; // equal to CA_SIMPLE_REPLACE_VERBS
       case "INCORRECT_WORDS_IN_CONTEXT": return 28; // similar to but lower than CONFUSIONS, greater than ES_KNOWN
       case "PRONOMS_FEBLES_SOLTS2": return 26;  // greater than PRONOMS_FEBLES_SOLTS, ES, HAVER_SENSE_HAC
-      case "ES_UNKNOWN": return 25; 
-      case "HAVER_SENSE_HAC": return 25; // greater than CONFUSIONS_ACCENT avia
+      case "ES_UNKNOWN": return 25;
       case "PASSAT_PERIFRASTIC": return 25; // greater than CONFUSIONS_ACCENT
       case "CONFUSIONS_ACCENT": return 20;
       case "DIACRITICS": return 20;

File: languagetool-core/src/main/java/org/languagetool/rules/GenericUnpairedBracketsRule.java
Patch:
@@ -134,9 +134,9 @@ protected boolean isNoException(String token,
         return false;
       }
       // Smiley ")))"  TODO: need more testing 
-      if (prevPrevToken.equals(")") && prevToken.equals(")") && (tokenStr.equals(")") || tokenStr.equals("("))) {
-        return false;
-      }
+      // if (prevPrevToken.equals(")") && prevToken.equals(")") && (tokenStr.equals(")") || tokenStr.equals("("))) {
+      // return false;
+      // }
        
     }
     if (i >= 1) {

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/WordWithDeterminerFilter.java
Patch:
@@ -125,6 +125,8 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
       }
     }
 
+    //FIXME: enabling and disabling rules is not a good solution 
+    // if several filters use the same JLanguageTool instance 
     for (Rule r : lt.getAllRules()) {
       if (r.getCategory().getId().toString().equals("CAT_ELISION") || r.getId().equals("CET_CE")
           || r.getId().equals("CE_CET") || r.getId().equals("MA_VOYELLE") || r.getId().equals("MON_NFS")

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -241,7 +241,8 @@ protected int getPriorityForId(String id) {
       case "DIACRITICS":     return -45;
       case "PT_COMPOUNDS_POST_REFORM":     return -45;
       case "HUNSPELL_RULE":             return -50;
-      case "CRASE_CONFUSION":           return -55;
+      case "CRASE_CONFUSION":           return -54;
+      case "NAO_MILITARES":           return -54;
       case "GENERAL_VERB_AGREEMENT_ERRORS":           return -55;
       case "GENERAL_GENDER_NUMBER_AGREEMENT_ERRORS":           return -56;
       case "FINAL_STOPS":               return -75;

File: languagetool-core/src/main/java/org/languagetool/language/identifier/LanguageIdentifier.java
Patch:
@@ -89,7 +89,7 @@ public LanguageIdentifier(int maxLength) {
    */
   public String cleanAndShortenText(String text) {
     String shortText = text.length() > maxLength ? text.substring(0, maxLength) : text;
-    shortText = shortText.replaceAll("\uFEFF+", " ");  // used by the browser add-on to filter HTML etc. (_ignoreText() in validator.js)
+    shortText = shortText.replaceAll("[\uFEFF\u2063]+", " ");  // used by the browser add-on to filter HTML etc. (_ignoreText() in validator.js)
     shortText = REMOVE_URL_FILTER.filter(shortText);
     shortText = REMOVE_EMAIL_SIGNATURE_FILTER.filter(shortText);
     shortText = REMOVE_MENTION_FILTER.filter(shortText);

File: languagetool-commandline/src/main/java/org/languagetool/commandline/CommandLineParser.java
Patch:
@@ -32,7 +32,7 @@
 class CommandLineParser {
 
   CommandLineOptions parseOptions(String[] args) {
-    if (args.length < 1 || args.length > 12) {
+    if (args.length < 1 || args.length > 14) {
       throw new WrongParameterNumberException();
     }
     CommandLineOptions options = new CommandLineOptions();

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -128,6 +128,7 @@ enum ReplacementType {
     "weit",
     "wirklich",
     "gerade",
+    "vereint",
     "überwiegend",
     "gewollt",
     "angestrengt",

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -236,6 +236,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Können Sie das auch nächsten Monat erledigen?");
     assertGood("War das Absicht?");
     assertGood("Alles Große und Edle ist einfacher Art.");
+    assertGood("Dieser vereint Sprachprüfung, Thesaurus und Umformuliertool in einem.");
 
     assertGood("Das Dach meines Autos.");
     assertGood("Das Dach meiner Autos.");

File: languagetool-commandline/src/main/java/org/languagetool/commandline/CommandLineOptions.java
Patch:
@@ -137,8 +137,8 @@ public boolean isCleanOverlapping() {
     return cleanOverlapping;
   }
 
-  public void setCleanOverlapping(boolean enableTempOff) {
-    this.cleanOverlapping = enableTempOff;
+  public void setCleanOverlapping(boolean cleanOverlapping) {
+    this.cleanOverlapping = cleanOverlapping;
   }
 
   public boolean isRecursive() {

File: languagetool-commandline/src/main/java/org/languagetool/commandline/CommandLineParser.java
Patch:
@@ -53,7 +53,7 @@ CommandLineOptions parseOptions(String[] args) {
         options.setEnableTempOff(true);
       } else if (args[i].equals("--clean-overlapping")) {
         options.setCleanOverlapping(true);
-      }else if (args[i].equals("--level")) {
+      } else if (args[i].equals("--level")) {
         String level = args[++i];
         try {
           options.setLevel(JLanguageTool.Level.valueOf(level));

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -569,7 +569,7 @@ void resetDocument() {
    * read caches from file
    */
   void readCaches() {
-    if (numParasToCheck != 0) {
+    if (numParasToCheck != 0 && docType == DocumentType.WRITER) {
       cacheIO = new CacheIO(xComponent);
       boolean cacheExist = cacheIO.readAllCaches(config, mDocHandler);
       if (cacheExist) {
@@ -590,7 +590,7 @@ void readCaches() {
    * write caches to file
    */
   void writeCaches() {
-    if (numParasToCheck != 0 && !config.noBackgroundCheck()) {
+    if (numParasToCheck != 0 && !config.noBackgroundCheck() && docType == DocumentType.WRITER) {
       DocumentCache docCache = new DocumentCache(this.docCache);
       List<ResultCache> paragraphsCache = new ArrayList<ResultCache>();
       for (int i = 0; i < this.paragraphsCache.size(); i++) {
@@ -1255,7 +1255,6 @@ public void disposing(EventObject event) {
 
     @Override
     public void documentEventOccured(DocumentEvent event) {
-      MessageHandler.printToLogFile("SingleDocument: documentEventOccured: event: " + event.EventName);
       if(event.EventName.equals("OnUnload")) {
         isOnUnload = true;
       } else if(event.EventName.equals("OnUnfocus") && !isOnUnload) {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SortedTextRules.java
Patch:
@@ -39,7 +39,7 @@ class SortedTextRules {
   List<Integer> minToCheckParagraph;
   List<List<String>> textLevelRules;
 
-  SortedTextRules (SwJLanguageTool lt, Configuration config, Set<String> disabledRulesUI) {
+  SortedTextRules (SwJLanguageTool lt, Configuration config, Set<String> disabledRulesUI, boolean checkImpressDocument) {
     minToCheckParagraph = new ArrayList<>(OfficeTools.NUMBER_TEXTLEVEL_CACHE);
     textLevelRules = new ArrayList<>(OfficeTools.NUMBER_TEXTLEVEL_CACHE);
     minToCheckParagraph.add(0,0);
@@ -50,7 +50,7 @@ class SortedTextRules {
       textLevelRules.add(i, new ArrayList<>());
       debugMode = OfficeTools.DEBUG_MODE_SR;
     }
-    List<Rule> rules = lt.getAllActiveOfficeRules();
+    List<Rule> rules = checkImpressDocument ? lt.getAllActiveRules() : lt.getAllActiveOfficeRules();
     int numParasToCheck = config.getNumParasToCheck();
     for (Rule rule : rules) {
       if (rule instanceof TextLevelRule && !lt.getDisabledRules().contains(rule.getId()) 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/TextLevelCheckQueue.java
Patch:
@@ -540,7 +540,7 @@ public void initLangtool(Language language) {
       if (lt != null) {
         multiDocHandler.initCheck(lt);
         String langCode = OfficeTools.localeToString(multiDocHandler.getLocale());
-        sortedTextRules = new SortedTextRules(lt, multiDocHandler.getConfiguration(), multiDocHandler.getDisabledRules(langCode));
+        sortedTextRules = new SortedTextRules(lt, multiDocHandler.getConfiguration(), multiDocHandler.getDisabledRules(langCode), false);
       }
     }
     

File: languagetool-language-modules/es/src/test/java/org/languagetool/rules/es/MorfologikSpanishSpellerRuleTest.java
Patch:
@@ -200,7 +200,7 @@ public void testMorfologikSpeller() throws IOException {
 
     matches = rule.match(lt.getAnalyzedSentence("Martin"));
     assertEquals(1, matches.length);
-    // TODO assertEquals("[Martín]", matches[0].getSuggestedReplacements().toString());
+    assertEquals("[Martín, Marvin]", matches[0].getSuggestedReplacements().toString());
 
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -260,7 +260,7 @@ private boolean canBeIgnored(AnalyzedTokenReadings[] tokens, int idx, AnalyzedTo
            token.isIgnoredBySpeller() ||
            isUrl(token.getToken()) ||
            isEMail(token.getToken()) ||
-           (ignoreTaggedWords && token.isTagged() && !isProhibited(token.getToken())) ||
+           (ignoreTaggedWords && token.isTagged() ) || // && !isProhibited(token.getToken())
            ignoreToken(tokens, idx);
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/WordRepeatRule.java
Patch:
@@ -65,6 +65,8 @@ public boolean ignore(AnalyzedTokenReadings[] tokens, int position) {
       return true;   // e.g. https://en.wikipedia.org/wiki/Nwe_Nwe_Aung
     } else if (wordRepetitionOf("Pago", tokens, position)) {
       return true;   // "Pago Pago"
+    } else if (wordRepetitionOf("Cao", tokens, position)) {
+      return true;   // https://en.wikipedia.org/wiki/Cao_Cao
     }
     return false;
   }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -203,6 +203,7 @@ public void testRule() throws IOException {
     assertGood("Wir sollten das mal labeln.");
     assertGood("Teil 1: Der unaufhaltsame Aufstieg Bonapartes");
     assertGood("Der Absatz bestimmt, in welchem Maße diese Daten Dritten zugänglich gemacht werden.");
+    assertGood("Der TN spricht Russisch - Muttersprache");
 
     assertGood("Ich musste das Video mehrmals stoppen, um mir über das Gesagte Gedanken zu machen.");
     assertGood("Während Besagtes Probleme verursachte.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -92,6 +92,8 @@ public class CaseRule extends Rule {
    * workaround to avoid false alarms, these words can be added here.
    */
   private static final String[] exceptions = {
+    "Bedienstete",
+    "Bediensteter",
     "Feierwütiger",
     "Feierwütige",
     "Feierwütigen",

File: languagetool-core/src/test/java/org/languagetool/rules/AbstractSimpleReplaceRule2Test.java
Patch:
@@ -97,5 +97,8 @@ static class MyCaseInsensitiveRule extends MyCaseSensitiveRule {
     MyCaseInsensitiveRule(ResourceBundle messages, Language language) {
       super(messages, language);
     }
+    public CaseSensitivy getCaseSensitivy() {
+      return CaseSensitivy.CI;
+    }
   }
 }

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -102,6 +102,8 @@ public GermanCompoundTokenizer(boolean strictMode) throws IOException {
     wordSplitter.addException("Manipulationstricks", asList("Manipulations", "tricks"));
     wordSplitter.addException("Erziehungstrick", asList("Erziehungs", "trick"));
     wordSplitter.addException("Erziehungstricks", asList("Erziehungs", "tricks"));
+    wordSplitter.addException("Messetage", asList("Messe", "tage"));
+    wordSplitter.addException("Messetagen", asList("Messe", "tagen"));
     wordSplitter.addException("karamelligen", asList("karamelligen"));  // != Karamel+Ligen
     wordSplitter.addException("Häkelnadel", asList("Häkel", "nadel"));
     wordSplitter.addException("Häkelnadeln", asList("Häkel", "nadeln"));

File: languagetool-language-modules/ca/src/main/java/org/languagetool/synthesis/ca/CatalanSynthesizer.java
Patch:
@@ -162,7 +162,7 @@ public String[] synthesize(AnalyzedToken token, String posTag, boolean posTagReg
     if (posTagRegExp) {
       String lemma = token.getLemma();
       if (LemmasToIgnore.contains(lemma)) {
-        return null;
+        return new String[0];
       }
       String toAddAfter = "";
       // verbs with noun

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ConfigThread.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.languagetool.openoffice;
 
-import java.awt.Frame;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -219,7 +219,7 @@ private void refreshWriterCache(SingleDocument document, Locale fixedLocale, Loc
       documentTexts.set(CURSOR_TYPE_HEADER_FOOTER, docCursor.getTextOfAllHeadersAndFooters());
       for (int i = 0; i < NUMBER_CURSOR_TYPES; i++) {
         if(documentTexts.get(i) == null) {
-          documentTexts.set(i, docCursor.new DocumentText());
+          documentTexts.set(i, new DocumentText());
         }
       }
       nText = documentTexts.get(CURSOR_TYPE_TEXT).paragraphs.size();
@@ -1955,7 +1955,7 @@ static class TextParagraph implements Serializable {
   /**
    * Class of serializable locale needed to save cache
    */
-  class SerialLocale implements Serializable {
+  private class SerialLocale implements Serializable {
 
     private static final long serialVersionUID = 1L;
     String Country;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCursorTools.java
Patch:
@@ -46,7 +46,6 @@
 import com.sun.star.text.XText;
 import com.sun.star.text.XTextCursor;
 import com.sun.star.text.XTextDocument;
-import com.sun.star.text.XTextFramesSupplier;
 import com.sun.star.text.XTextRange;
 import com.sun.star.text.XTextSection;
 import com.sun.star.text.XTextTable;
@@ -1348,7 +1347,7 @@ public static boolean isBusy() {
   /**
    * Class to give back the text and the headings under the specified cursor
    */
-  public class DocumentText {
+  public static class DocumentText {
     List<String> paragraphs;
     List<Integer> headingNumbers;
     List<Integer> automaticTextParagraphs;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/FlatParagraphTools.java
Patch:
@@ -930,7 +930,7 @@ public static boolean isBusy() {
     return isBusy > 0;
   }
   
-  public class FlatParagraphContainer {
+  public static class FlatParagraphContainer {
     public List<String> paragraphs;
     public List<Locale> locales;
     public List<int[]> footnotePositions;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LanguageToolMenus.java
Patch:
@@ -108,7 +108,7 @@ void addListener() {
   /**
    * Class to add or change some items of the LT head menu
    */
-  class LTHeadMenu implements XMenuListener {
+  private class LTHeadMenu implements XMenuListener {
     // If anything on the position of LT menu is changed the following has to be changed
     private static final String TOOLS_COMMAND = ".uno:ToolsMenu";             //  Command to open tools menu
     private static final String COMMAND_BEFORE_LT_MENU = ".uno:LanguageMenu";   //  Command for Language Menu (LT menu is installed after)
@@ -383,7 +383,7 @@ public void itemSelected(MenuEvent event) {
    * Class to add a LanguageTool Options item to the context menu
    * since 4.6
    */
-  class ContextMenuInterceptor implements XContextMenuInterceptor {
+  private class ContextMenuInterceptor implements XContextMenuInterceptor {
     
     private final static String IGNORE_ONCE_URL = "slot:201";
     private final static String ADD_TO_DICTIONARY_2 = "slot:2";

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -1726,7 +1726,7 @@ private void testHeapSpace() {
   /**
    * class to run the about dialog
    */
-  private static class AboutDialogThread extends Thread {
+  private class AboutDialogThread extends Thread {
 
     private final ResourceBundle messages;
     private final XComponentContext xContext;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/OfficeSpreadsheetTools.java
Patch:
@@ -177,8 +177,7 @@ public static ParagraphContainer getAllParagraphs(XComponent xComponent) {
           }
         }
       }
-      OfficeDrawTools o = new OfficeDrawTools();
-      return o.new ParagraphContainer(paragraphs, locales, pageBegins);
+      return new ParagraphContainer(paragraphs, locales, pageBegins);
     } catch (Throwable t) {
       MessageHandler.printException(t);     // all Exceptions XWordCursorthrown by UnoRuntime.queryInterface are caught
     }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -1013,7 +1013,7 @@ public RuleDesc deactivateRule() {
   /**
    * class for store and handle ignored matches
    */
-  class IgnoredMatches {
+  public static class IgnoredMatches {
     
     private Map<Integer, Map<String, Set<Integer>>> ignoredMatches;
     
@@ -1225,7 +1225,7 @@ private void setDokumentListener(XComponent xComponent) {
     }
   }
   
-  class RuleDesc {
+  public static class RuleDesc {
     String langCode;
     String ruleID;
     
@@ -1235,7 +1235,7 @@ class RuleDesc {
     }
   }
   
-  class LTDokumentEventListener implements XDocumentEventListener, XMouseClickHandler {
+  private class LTDokumentEventListener implements XDocumentEventListener, XMouseClickHandler {
 
     @Override
     public void disposing(EventObject event) {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -651,7 +651,7 @@ SingleProofreadingError getNextGrammatikErrorInParagraph(int x, int nFPara, Stri
    * Class for spell checking in LT check dialog
    * The LO/OO spell checker is used
    */
-  public class ExtensionSpellChecker {
+  private class ExtensionSpellChecker {
 
     private LinguisticServices linguServices;
      
@@ -819,7 +819,7 @@ public LinguisticServices getLinguServices() {
   /**
    * class to store the information for undo
    */
-  public class UndoContainer {
+  private class UndoContainer {
     public int x;
     public int y;
     public String action;
@@ -840,7 +840,7 @@ public class UndoContainer {
   /**
    * class contains the SingleProofreadingError and the locale of the match
    */
-  public class CheckError {
+  private class CheckError {
     public Locale locale;
     public SingleProofreadingError error;
     

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ViewCursorTools.java
Patch:
@@ -43,7 +43,6 @@
 import com.sun.star.text.XText;
 import com.sun.star.text.XTextCursor;
 import com.sun.star.text.XTextDocument;
-import com.sun.star.text.XTextFramesSupplier;
 import com.sun.star.text.XTextRange;
 import com.sun.star.text.XTextTable;
 import com.sun.star.text.XTextTablesSupplier;

File: languagetool-http-client/src/main/java/org/languagetool/remote/ArtificialErrorEval.java
Patch:
@@ -787,12 +787,12 @@ private static List<String> differences(String s1, String s2) {
       results.add("");
       return results;
     }
+    int l1 = s1.length();
+    int l2 = s2.length();
     int fromStart = 0;
-    while (s1.charAt(fromStart) == s2.charAt(fromStart)) {
+    while (fromStart < l1 && fromStart < l2 && s1.charAt(fromStart) == s2.charAt(fromStart)) {
       fromStart++;
     }
-    int l1 = s1.length();
-    int l2 = s2.length();
     int fromEnd = 0;
     while (s1.charAt(l1 - 1 - fromEnd) == s2.charAt(l2 - 1 - fromEnd)) {
       fromEnd++;

File: languagetool-server/src/main/java/org/languagetool/server/DatabaseAccessOpenSource.java
Patch:
@@ -201,7 +201,7 @@ Long getUserId(String username, String apiKey) {
       throw new IllegalArgumentException("apiKey must be set");
     }
     if (sqlSessionFactory == null) {
-      throw new IllegalStateException("This is the endpoint for the basic version of LanguageTool. " +
+      throw new AuthException("This is the endpoint for the basic version of LanguageTool. " +
         "When using 'username' and 'apiKey' to access the premium version, use api.languagetoolplus.com instead.");
     }
     try {

File: languagetool-standalone/src/test/java/org/languagetool/language/LanguageIdentifierServiceTest.java
Patch:
@@ -31,7 +31,8 @@
 import static org.junit.Assert.*;
 import static org.junit.Assert.assertNotEquals;
 
-public class LangaugeIdentifierServiceTest {
+public class LanguageIdentifierServiceTest {
+
   @Test
   public void testFactory() {
     LanguageIdentifier default1 = LanguageIdentifierService.INSTANCE

File: languagetool-language-modules/de/src/test/java/org/languagetool/tagging/de/GermanTaggerTest.java
Patch:
@@ -39,6 +39,8 @@ public class GermanTaggerTest {
 
   @Test
   public void testAdjectivesFromSpellingTxt() throws IOException {
+    assertEquals("meistgewünscht[meistgewünscht/ADJ:PRD:GRU]", toSortedString(tagger.lookup("meistgewünscht")));
+    assertNull(tagger.lookup("fünftjüngste"));  // skipped to avoid false tagging that misses comparative
     assertEquals("meistgewünschtes[meistgewünscht/ADJ:AKK:SIN:NEU:GRU:IND, meistgewünscht/ADJ:AKK:SIN:NEU:GRU:SOL, " +
       "meistgewünscht/ADJ:NOM:SIN:NEU:GRU:IND, meistgewünscht/ADJ:NOM:SIN:NEU:GRU:SOL]", toSortedString(tagger.lookup("meistgewünschtes")));
     assertEquals("meistgewünschter[meistgewünscht/ADJ:DAT:SIN:FEM:GRU:SOL, meistgewünscht/ADJ:GEN:PLU:FEM:GRU:SOL, " +

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -242,6 +242,7 @@ protected int getPriorityForId(String id) {
       case "HUNSPELL_RULE":             return -50;
       case "CRASE_CONFUSION":           return -55;
       case "GENERAL_VERB_AGREEMENT_ERRORS":           return -55;
+      case "GENERAL_GENDER_NUMBER_AGREEMENT_ERRORS":           return -56;
       case "FINAL_STOPS":               return -75;
       case "EU_NÓS_REMOVAL":            return -90;
       case "T-V_DISTINCTION":           return -100;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -305,7 +305,7 @@ private String createOtherDocId(String prefix) {
         return docID;
       }
     }
-    return null;
+    return prefix + (documents.size() + 1);
   }
   
   /**
@@ -1524,7 +1524,7 @@ public void trigger(String sEvent) {
    * Test the language of the document
    * switch the check to LT if possible and language is supported
    */
-  boolean testDocLanguage(boolean showMessage) {
+  boolean testDocLanguage(boolean showMessage) throws Throwable {
     if (docLanguage == null) {
       if (linguServices == null) {
         linguServices = new LinguisticServices(xContext);
@@ -1880,7 +1880,7 @@ public void run() {
       try {
         Thread.sleep(3000);
         testDocLanguage(false);
-      } catch (InterruptedException e) {
+      } catch (Throwable e) {
         MessageHandler.showError(e);
       }
     }

File: languagetool-http-client/src/main/java/org/languagetool/remote/ArtificialErrorEval.java
Patch:
@@ -508,7 +508,8 @@ private static void run(boolean printSummaryDetails) throws IOException {
       //float expectedSuggestionPercentage = (float) results[i][classifyTypes.indexOf("TPs")]
       //    / results[i][classifyTypes.indexOf("TP")];
       int errorsTotal = results[i][classifyTypes.indexOf("TP")] + results[i][classifyTypes.indexOf("FP")]
-          + results[i][classifyTypes.indexOf("TN")] + results[i][classifyTypes.indexOf("FN")] + results[i][classifyTypes.indexOf("TPns")];
+          + results[i][classifyTypes.indexOf("TN")] + results[i][classifyTypes.indexOf("FN")] + results[i][classifyTypes.indexOf("TPns")]
+          + results[i][classifyTypes.indexOf("TPws")];
       StringWriter resultsString = new StringWriter();
 
       resultsString.append("-------------------------------------\n");

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LtDictionary.java
Patch:
@@ -362,7 +362,7 @@ public String[] getUserDictionaries(XComponentContext xContext) {
     for (XDictionary dictionary : dictionaryList) {
       if (dictionary.isActive()) {
         String name = dictionary.getName();
-        if (!name.startsWith("INTERNAL_DICT_PREFIX") && !name.equals(listIgnoredWords.getName())) {
+        if (!name.startsWith(INTERNAL_DICT_PREFIX) && !name.equals(listIgnoredWords.getName())) {
           userDictionaries.add(new String(name));
         }
       }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -1442,6 +1442,9 @@ public void trigger(String sEvent) {
       } else if (sEvent.startsWith("activateRule_")) {
         String ruleId = sEvent.substring(13);
         activateRule(ruleId);
+      } else if (sEvent.startsWith("addToDictionary_")) {
+        String[] sArray = sEvent.substring(16).split(":");
+        getLtDictionary().addWordToDictionary(sArray[0], sArray[1], xContext);;
       } else if ("renewMarkups".equals(sEvent)) {
         renewMarkups();
       } else if ("checkDialog".equals(sEvent) || "checkAgainDialog".equals(sEvent)) {

File: languagetool-core/src/main/java/org/languagetool/tools/StringTools.java
Patch:
@@ -506,6 +506,9 @@ public static String normalizeNFC(String str) {
    * @return string
    */
   public static String preserveCase(String inputString, String modelString) {
+    if (modelString.isEmpty()) {
+      return inputString; 
+    }
     if (isAllUppercase(modelString)) {
       return inputString.toUpperCase(); 
     }

File: languagetool-http-client/src/main/java/org/languagetool/remote/ArtificialErrorEval.java
Patch:
@@ -105,6 +105,7 @@ public static void main(String[] args) throws IOException {
       boolean printHeader = Boolean.parseBoolean(prop.getProperty("printHeader", "true"));
       remoteServer = prop.getProperty("remoteServer", "http://localhost:8081");
       disabledRules = Arrays.asList(prop.getProperty("disabledRules", "").split(","));
+      onlyRules = Arrays.asList(prop.getProperty("onlyRules", "").split(","));
       // Only one file
       String analyzeOneFile = prop.getProperty("analyzeOneFile");
       if (analyzeOneFile.equalsIgnoreCase("true")) {

File: languagetool-http-client/src/main/java/org/languagetool/remote/ArtificialErrorEval.java
Patch:
@@ -735,7 +735,7 @@ private static List<String> differences(String s1, String s2) {
     // diff in sentence 2
     results.add(s2.substring(fromStart, l2 - fromEnd));
     // common string at end
-    results.add(s1.substring(l1 - fromEnd, l1 - 1));
+    results.add(s1.substring(l1 - fromEnd, l1));
     return results;
     
   }

File: languagetool-http-client/src/main/java/org/languagetool/remote/ArtificialErrorEval.java
Patch:
@@ -728,13 +728,13 @@ private static List<String> differences(String s1, String s2) {
     while (s1.charAt(l1 - 1 - fromEnd) == s2.charAt(l2 - 1 - fromEnd)) {
       fromEnd++;
     }
-    // first common part
+    // common string at start
     results.add(s1.substring(0, fromStart));
     // diff in sentence 1
     results.add(s1.substring(fromStart, l1 - fromEnd));
-    // diff in setence 2
+    // diff in sentence 2
     results.add(s2.substring(fromStart, l2 - fromEnd));
-    // last common part
+    // common string at end
     results.add(s1.substring(l1 - fromEnd, l1 - 1));
     return results;
     

File: languagetool-http-client/src/main/java/org/languagetool/remote/ArtificialErrorEval.java
Patch:
@@ -132,6 +132,9 @@ private static void runEvaluationOnFile(String languageCode, String inputFile) t
     synth = language.getSynthesizer();
     lt = new RemoteLanguageTool(Tools.getUrl(remoteServer));
     File corpusFile = new File(corpusFilePath);
+    if (!corpusFile.exists() || corpusFile.isDirectory()) {
+      throw new IOException("File not found: " + corpusFilePath);
+    }
     String fileName = corpusFile.getName();
     System.out.println("Analyzing file: " + fileName);
     fileName = fileName.substring(0, fileName.lastIndexOf('.'));

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -186,6 +186,8 @@ public void testWrongVerb() throws IOException {
     assertGood("Und da wir äußerst Laissez-faire sind, kann man das auch machen.");
     assertGood("Duzen, jemanden mit Du anreden, eine Sitte, die bei allen alten Völkern üblich war.");
     assertGood("Schreibtischtäter wie Du sind doch eher selten.");
+    assertGood("Nee, geh du!");
+    //assertGood("Nee, mach du das mal.");
     //assertGood("Ein Mädchen, das genauso wie wir war!");  // known false alarm
     //assertGood("Und bin völlig ohne Idee losgelaufen.");  // known false alarm (could be a picky match maybe)
     // incorrect sentences:

File: languagetool-language-modules/nl/src/test/java/org/languagetool/rules/nl/SpaceInCompoundRuleTest.java
Patch:
@@ -40,6 +40,7 @@ public void testRule() throws IOException {
     SpaceInCompoundRule rule = new SpaceInCompoundRule(TestTools.getEnglishMessages());
     JLanguageTool lt = new JLanguageTool(Languages.getLanguageForShortCode("nl"));
     assertGood("langeafstandloper", rule, lt);
+    assertGood("Dat zie je nu weer met de zogenaamde oudelullendagen die in heel andere tijden met gulle hand in cao’s werden uitgereikt aan werknemers van vijftig jaar en ouder.", rule, lt);
     assertMatch("lange afstand loper", rule, lt);
     assertMatch("langeafstand loper", rule, lt);
     assertMatch("lange afstandloper", rule, lt);

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternTestTools.java
Patch:
@@ -326,7 +326,7 @@ private static void warnIfElementNotKosher(
           String ruleId,
           int tokenIndex) {
 
-    if (isRegularExpression && (stringValue.startsWith("|") || stringValue.endsWith("|"))) {
+    if (isRegularExpression && (stringValue.startsWith("|") || stringValue.endsWith("|")) && !stringValue.endsWith("\\|")) {
       fail("Regex of " + ruleId + " starts or ends with '|', which is probably invalid: " + stringValue);
     }
 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -2089,7 +2089,7 @@ private void ignoreAll() throws Throwable {
         documents.getLtDictionary().addIgnoredWord(wrongWord);
       } else {
         documents.ignoreRule(error.aRuleIdentifier, locale);
-        documents.initDocuments();
+        documents.initDocuments(true);
         documents.resetDocument();
         doInit = true;
       }
@@ -2335,7 +2335,7 @@ private void undo() throws Throwable {
           } else {
             Locale locale = docCache.getFlatParagraphLocale(yUndo);
             documents.removeDisabledRule(OfficeTools.localeToString(locale), lastUndo.ruleId);
-            documents.initDocuments();
+            documents.initDocuments(true);
             documents.resetDocument();
             doInit = true;
           }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/TextLevelCheckQueue.java
Patch:
@@ -457,7 +457,7 @@ void setDispose(String docId) {
      */
     @Override
     public boolean equals(Object o) {
-      if (o == null || !(o instanceof QueueEntry)) {
+      if (o == null || !(o instanceof QueueEntry) || nStart == null) {
         return false;
       }
       QueueEntry e = (QueueEntry) o;
@@ -472,7 +472,7 @@ public boolean equals(Object o) {
      * entry is equal but number of cache is smaller then new entry e
      */
     public boolean isEqualButSmallerCacheNumber(QueueEntry e) {
-      if (e == null || nStart.type != e.nStart.type) {
+      if (e == null || nStart == null || nStart.type != e.nStart.type) {
         return false;
       }
       if (nStart.number >= e.nStart.number && nEnd.number <= e.nEnd.number && nCache < e.nCache && docId.equals(e.docId)) {
@@ -485,7 +485,7 @@ public boolean isEqualButSmallerCacheNumber(QueueEntry e) {
      * entry is obsolete and should be replaced by new entry e
      */
     public boolean isObsolete(QueueEntry e) {
-      if (e == null || nCheck != e.nCheck || nCache != e.nCache || nStart.type != e.nStart.type || docId == null || !docId.equals(e.docId)) {
+      if (e == null || nStart == null || nCheck != e.nCheck || nCache != e.nCache || nStart.type != e.nStart.type || docId == null || !docId.equals(e.docId)) {
         return false;
       }
       if (nCheck < -1 || (nCheck == -1 && e.nStart.number >= nStart.number && e.nStart.number <= nEnd.number) 

File: languagetool-http-client/src/main/java/org/languagetool/remote/ArtificialErrorEval.java
Patch:
@@ -156,7 +156,7 @@ private static void runEvaluationOnFolders(String inputFolder, String outputFold
     File[] languageDirectories = new File(inputFolder).listFiles(File::isDirectory);
     for (File languageDirectory : languageDirectories) {
       langCode = languageDirectory.getName();
-//      if (!langCode.toString().equals("de-DE")) {
+//      if (!langCode.toString().equals("es")) {
 //        continue;
 //      }
       language = Languages.getLanguageForShortCode(langCode);
@@ -303,7 +303,7 @@ private static void run(boolean printSummaryDetails) throws IOException {
         countLine++;
         String[] parts = line.split("\t");
         // adjust the numbers 3 and 4 according to the source file
-        if (parts.length < 5) {
+        if (parts.length < columnCorrect && parts.length < columnIncorrect) {
           continue;
         }
         String correctSource = parts[columnCorrect - 1];

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -262,11 +262,10 @@ public SpellingCheckRule createDefaultSpellingRule(ResourceBundle messages) thro
       return new MorfologikCatalanSpellerRule(messages, this, null, Collections.emptyList());
   }
   
-  
   private static final Pattern CA_OLD_DIACRITICS = Pattern.compile(".*\\b(dóna|vénen|véns|fóra)\\b.*",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   private static final Pattern CA_CONTRACTIONS = Pattern.compile("\\b([Aa]|[Dd]e) e(ls?)\\b");
   private static final Pattern CA_APOSTROPHES = Pattern.compile("\\b([LDNSTMldnstm]['’]) ");
-  private static final Pattern CA_APOSTROPHES2 = Pattern.compile("\\b([mtl])['’]([^haeiou])");
+  private static final Pattern CA_APOSTROPHES2 = Pattern.compile("\\b([mtl])['’]([^haeiou“«\"])");
   private static final Pattern CA_APOSTROPHES3 = Pattern.compile("\\be?([mtl])[ea]? ([aeiou])");
   
   @Override

File: languagetool-dev/src/main/java/org/languagetool/dev/bigdata/AutomaticProhibitedCompoundRuleEvaluator.java
Patch:
@@ -204,9 +204,9 @@ public static void main(String[] args) throws IOException {
     eval.run(lines, new File(args[2]));
   }
 
-  class TooFewExamples extends RuntimeException {
-    private String word;
-    private int exampleCount;
+  static class TooFewExamples extends RuntimeException {
+    private final String word;
+    private final int exampleCount;
     TooFewExamples(String word, int exampleCount) {
       this.word = word;
       this.exampleCount = exampleCount;

File: languagetool-core/src/main/java/org/languagetool/rules/GenericUnpairedBracketsRule.java
Patch:
@@ -207,7 +207,8 @@ public final RuleMatch[] match(List<AnalyzedSentence> sentences) {
     return toRuleMatchArray(ruleMatches);
   }
 
-  private boolean endsLikeRealSentence(String s) {
+  private boolean endsLikeRealSentence(String r) {
+    String s = r.trim();
     return s.endsWith(".") || s.endsWith("?") || s.endsWith("!");
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/MatchState.java
Patch:
@@ -173,7 +173,7 @@ public final AnalyzedTokenReadings filterReadings() {
       anTkRead.setChunkTags(formattedToken.getChunkTags());
     }
     if (formattedToken.isImmunized()) {
-      anTkRead.immunize();
+      anTkRead.immunize(formattedToken.getImmunizationSourceLine());
     }
     return anTkRead;
   }

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -227,6 +227,7 @@ public void startElement(String namespaceURI, String lName,
         interpretPosTagsPreDisambiguation = YES.equals(attrs.getValue(RAW_TAG));
         break;
       case ANTIPATTERN:
+        xmlLineNumberAntiPattern = pLocator.getLineNumber();
         inAntiPattern = true;
         antiPatternCounter++;
         caseSensitive = YES.equals(attrs.getValue(CASE_SENSITIVE));
@@ -490,6 +491,7 @@ public void endElement(String namespaceURI, String sName,
             antiId + "_antipattern:" + antiPatternCounter,
             "antipattern", language, patternTokens, null, null,
             DisambiguationPatternRule.DisambiguatorAction.IMMUNIZE);
+        rule.setXmlLineNumber(xmlLineNumberAntiPattern);
         if (startPos != -1 && endPos != -1) {
           rule.setStartPositionCorrection(startPos);
           rule.setEndPositionCorrection(endPos - tokenCountForMarker);
@@ -511,6 +513,7 @@ public void endElement(String namespaceURI, String sName,
         endPos = -1;
         startPos = -1;
         inAntiPatternExample = false;
+        xmlLineNumberAntiPattern = -1;
         break;
       case EXAMPLE:
         if (inAntiPatternExample) {

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/XMLRuleHandler.java
Patch:
@@ -193,6 +193,7 @@ enum RegexpMode {
   protected List<Match> suggestionMatchesOutMsg = new ArrayList<>();
   protected Locator pLocator;
   protected int xmlLineNumber = -1;
+  protected int xmlLineNumberAntiPattern = -1;
 
   protected int startPositionCorrection;
   protected int endPositionCorrection;

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationPatternRuleReplacer.java
Patch:
@@ -239,7 +239,7 @@ private AnalyzedTokenReadings[] executeAction(AnalyzedSentence sentence,
       break;
     case IMMUNIZE:
       for (int i = 0; i < matchingTokensWithCorrection - startPositionCorrection + endPositionCorrection; i++) {
-        whTokens[sentence.getOriginalPosition(firstMatchToken + correctedStPos + i)].immunize();
+        whTokens[sentence.getOriginalPosition(firstMatchToken + correctedStPos + i)].immunize(rule.getXmlLineNumber());
       }
       break;
     case IGNORE_SPELLING:

File: languagetool-core/src/test/java/org/languagetool/AnalyzedSentenceTest.java
Patch:
@@ -48,7 +48,7 @@ public void testCopy() {
     AnalyzedSentence copySentence = sentence.copy(sentence);
     assertEquals(sentence, copySentence);
     //now change the first sentence
-    words[1].immunize(); // this would not work if we stored a copy, which we probably should
+    words[1].immunize(999); // this would not work if we stored a copy, which we probably should
     assertEquals("<S> word[lemma/POS{!}].[./INTERP,</S>]", sentence.toString());
     assertNotEquals(sentence, copySentence);
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -92,6 +92,8 @@ public class CaseRule extends Rule {
    * workaround to avoid false alarms, these words can be added here.
    */
   private static final String[] exceptions = {
+    "Konsumierende",
+    "Konsumierenden",
     "Verliebter",
     "Verliebte",
     "Beängstigendes",

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -376,6 +376,9 @@ public RuleMatch[] match(AnalyzedSentence sentence) {
    * @return index of first non-modifier token
    */
   private int getPosAfterModifier(int startAt, AnalyzedTokenReadings[] tokens) {
+    if (startAt < tokens.length && tokens[startAt].getToken().matches("relativ") && startAt + 1 < tokens.length && tokens[startAt+1].getToken().matches("gesehen")) {
+      startAt += 2;
+    }
     if (startAt < tokens.length && tokens[startAt].getToken().matches("viel|weit") && startAt + 1 < tokens.length && tokens[startAt+1].getToken().matches("weniger|eher")) {
       startAt += 2;
     } else if (startAt + 1 < tokens.length && MODIFIERS.contains(tokens[startAt].getToken())) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -777,6 +777,9 @@ public void testDetAdjNounRule() throws IOException {
     assertGood("Ich widerrufe den mit Ihnen geschlossenen Vertrag.");
     assertBad("Er klagte auch gegen den ohne ihn verkündete Sachbeschluss.", "den ohne ihn verkündeten Sachbeschluss");
     assertGood("Er klagte auch gegen den ohne ihn verkündeten Sachbeschluss.");
+    assertGood("Dieser relativ gesehen starke Mann.");
+    assertGood("Diese relativ gesehen starke Frau.");
+    assertGood("Dieses relativ gesehen starke Auto.");
     //assertBad("Leute, die eine gewissen Sicherheit brauchen.");
     //assertBad("An der rot Ampel.");
   }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -1402,7 +1402,6 @@ void resetDocument() {
    */
   public void trigger(String sEvent) {
     try {
-//      MessageHandler.printToLogFile("Event: " + sEvent);
       if (!testDocLanguage(true)) {
         MessageHandler.printToLogFile("Test for document language failed: Can't trigger event: " + sEvent);
         return;
@@ -1411,14 +1410,12 @@ public void trigger(String sEvent) {
         closeDialogs();
         runOptionsDialog();
       } else if ("about".equals(sEvent)) {
-//        closeDialogs();
         if (aboutDialog != null) {
           aboutDialog.close();
           aboutDialog = null;
         }
         AboutDialogThread aboutThread = new AboutDialogThread(messages, xContext);
         aboutThread.start();
-//      } else if ("switchOff".equals(sEvent)) {
       } else if ("toggleNoBackgroundCheck".equals(sEvent)) {
         if (toggleNoBackgroundCheck()) {
           resetCheck(); 
@@ -1478,6 +1475,9 @@ public void trigger(String sEvent) {
         SpellAndGrammarCheckDialog checkDialog = new SpellAndGrammarCheckDialog(xContext, this, docLanguage);
         checkDialog.nextError();
       } else if ("refreshCheck".equals(sEvent)) {
+        if (ltDialog != null) {
+          ltDialog.closeDialog();
+        } 
         if (this.isBackgroundCheckOff()) {
           MessageHandler.showMessage(messages.getString("loExtSwitchOffMessage"));
           return;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCursorTools.java
Patch:
@@ -1247,7 +1247,7 @@ public boolean isProtectedCharacter(TextParagraph textPara, short x) {
       XPropertySet xParagraphPropertySet = UnoRuntime.queryInterface(XPropertySet.class, xPCursor.getStart());
       XTextSection xTextSection = UnoRuntime.queryInterface(XTextSection.class, xParagraphPropertySet.getPropertyValue("TextSection"));
       xParagraphPropertySet = UnoRuntime.queryInterface(XPropertySet.class, xTextSection);
-      if((boolean) xParagraphPropertySet.getPropertyValue("IsProtected")) {
+      if(xParagraphPropertySet != null && (boolean) xParagraphPropertySet.getPropertyValue("IsProtected")) {
         return true;
       }
     } catch (Throwable t) {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -531,6 +531,9 @@ void readCaches() {
           paragraphsCache.get(i).replace(cacheIO.getParagraphsCache().get(i));
         }
         ignoredMatches = new IgnoredMatches(cacheIO.getIgnoredMatches());
+        if (docType == DocumentType.WRITER && mDocHandler != null) {
+          mDocHandler.runShapeCheck(docCache.hasUnsupportedText(), 9);
+        }
       }
       cacheIO.resetAllCache();
     }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/TextLevelCheckQueue.java
Patch:
@@ -485,7 +485,7 @@ public boolean isEqualButSmallerCacheNumber(QueueEntry e) {
      * entry is obsolete and should be replaced by new entry e
      */
     public boolean isObsolete(QueueEntry e) {
-      if (e == null || nCheck != e.nCheck || nCache != e.nCache || nStart.type != e.nStart.type || !docId.equals(e.docId)) {
+      if (e == null || nCheck != e.nCheck || nCache != e.nCache || nStart.type != e.nStart.type || docId == null || !docId.equals(e.docId)) {
         return false;
       }
       if (nCheck < -1 || (nCheck == -1 && e.nStart.number >= nStart.number && e.nStart.number <= nEnd.number) 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleCheck.java
Patch:
@@ -224,7 +224,8 @@ public void addParaErrorsToCache(int nFPara, SwJLanguageTool lt, int cacheNum, i
       //  NOTE: lt == null if language is not supported by LT
       //        but empty proof reading errors have added to cache to satisfy text level queue
       if (lt != null && !docCache.isAutomaticGenerated(nFPara) && mDocHandler.isSortedRuleForIndex(cacheNum)) {
-        paragraphMatches = lt.check(textToCheck, true, JLanguageTool.ParagraphHandling.ONLYPARA);
+        paragraphMatches = lt.check(textToCheck, true, 
+            cacheNum == 0 ? JLanguageTool.ParagraphHandling.NORMAL : JLanguageTool.ParagraphHandling.ONLYPARA);
         if (cacheNum == 0) {
           nextSentencePositions = getNextSentencePositions(textToCheck, lt);
         }

File: languagetool-http-client/src/main/java/org/languagetool/remote/ArtificialErrorEval.java
Patch:
@@ -183,13 +183,15 @@ private static void runEvaluationOnFolders(String inputFolder, String outputFold
           else if (fileName.equals("double_letters")) {
             isDoubleLetters = true;
             unidirectional = true;
+            isDiacritics = false;
           }
           else {
             isDoubleLetters = false;
             String[] parts = fileName.split("~");
             words[0] = parts[0].replaceAll("_", " ");
             words[1] = parts[1].replaceAll("_", " ");
             unidirectional = false;
+            isDiacritics = false;
             if (parts.length > 2) {
               unidirectional = parts[2].equals("u");
               if (parts[2].equals("u_notwholeword")) {

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/MorfologikRussianYOSpellerRule.java
Patch:
@@ -56,7 +56,8 @@ public final class MorfologikRussianYOSpellerRule extends MorfologikSpellerRule
   private final static Set <String> lcDoNotSuggestWords = new HashSet <> (Arrays.asList(
     // words with 'NOSUGGEST' flag:
     "блоггер",
-    "елка"      
+    "елка",
+    "дрочим","орочем"      
  ));
 
   public MorfologikRussianYOSpellerRule(ResourceBundle messages, Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/MorfologikRussianSpellerRule.java
Patch:
@@ -46,7 +46,7 @@ public final class MorfologikRussianSpellerRule extends MorfologikSpellerRule {
   
   private final static Set <String> lcDoNotSuggestWords = new HashSet <> (Arrays.asList(
     // words with 'NOSUGGEST' flag:
-    "блоггер"
+    "блоггер","дрочим","орочем"
  ));
 
   public MorfologikRussianSpellerRule(ResourceBundle messages, Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ConfigThread.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.List;
 import java.util.Set;
 
+import org.languagetool.JLanguageTool;
 import org.languagetool.Language;
 import org.languagetool.gui.Configuration;
 import org.languagetool.gui.ConfigurationDialog;
@@ -52,7 +53,8 @@ class ConfigThread extends Thread {
     this.config = config;
     this.lt = lt;
     this.documents = documents;
-    cfgDialog = new ConfigurationDialog(null, true, OfficeTools.getLtImage(), config);
+    String title = JLanguageTool.getMessageBundle().getString("guiConfigWindowTitle") + " (LT " + OfficeTools.getLtInformation() + ")";
+    cfgDialog = new ConfigurationDialog(null, true, OfficeTools.getLtImage(), title, config);
   }
 
   @Override

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -913,7 +913,7 @@ public LtCheckDialog(XComponentContext xContext) {
         MessageHandler.printToLogFile("CheckDialog: LtCheckDialog: LtCheckDialog == null");
       }
       dialog.setName(dialogName);
-      dialog.setTitle(dialogName);
+      dialog.setTitle(dialogName + " (LanguageTool " + OfficeTools.getLtInformation() + ")");
       dialog.setLayout(null);
       dialog.setSize(dialogWidth, dialogHeight);
       dialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/RussianWordRepeatRule.java
Patch:
@@ -44,6 +44,7 @@ public class RussianWordRepeatRule extends AdvancedWordRepeatRule {
     tempSet.add("их");
     tempSet.add("на");
     tempSet.add("в");
+    tempSet.add("по");
     tempSet.add("минута");
     tempSet.add("друг");
     tempSet.add("час");

File: languagetool-language-modules/uk/src/main/java/org/languagetool/tagging/uk/UkrainianTagger.java
Patch:
@@ -19,7 +19,6 @@
 package org.languagetool.tagging.uk;
 
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;

File: languagetool-language-modules/uk/src/main/java/org/languagetool/tokenizers/uk/UkrainianWordTokenizer.java
Patch:
@@ -146,7 +146,7 @@ public class UkrainianWordTokenizer implements Tokenizer {
   private static final Pattern ABBR_DOT_NON_ENDING_PATTERN = Pattern.compile("(?<![а-яіїєґА-ЯІЇЄҐ'\u0301-])(абз|австрал|амер|англ|акад(ем)?|арк|ауд|бл(?:изьк)?|буд|в(?!\\.+)|вип|вірм|грец(?:ьк)"
       + "|держ|див|діал|дод|дол|досл|доц|доп|екон|ел|жін|зав|заст|зах|зб|зв|зневажл?|зовн|ім|івр|ісп|іст|італ"
       + "|к|каб|каф|канд|кв|[1-9]-кімн|кімн|кл|кн|коеф|латин|мал|моб|н|[Нн]апр|нац|образн|оп|оф|п|пен|перекл|перен|пл|пол|пов|пор|поч|пп|прибл|прикм|прим|присл|пров|пром|просп"
-      + "|[Рр]ед|[Рр]еж|розд|розм|рт|рум|с|[Сс]вв?|скор|соц|співавт|[сС]т|стор|сх|табл|тт|[тТ]ел|техн|укр|філол|фр|франц|худ|ч|чайн|част|ц|яп)\\.(?!\uE120|\\.+[\\h\\v]*$)");
+      + "|[Рр]ед|[Рр]еж|розд|розм|рос|рт|рум|с|[Сс]вв?|скор|соц|співавт|[сС]т|стор|сх|табл|тт|[тТ]ел|техн|укр|філол|фр|франц|худ|ч|чайн|част|ц|яп)\\.(?!\uE120|\\.+[\\h\\v]*$)");
   private static final Pattern ABBR_DOT_NON_ENDING_PATTERN_2 = Pattern.compile("([^а-яіїєґА-ЯІЇЄҐ'-]м\\.)([\\h\\v]*[А-ЯІЇЄҐ])");
   // скорочення що можуть бути в кінці речення
   private static final Pattern ABBR_DOT_ENDING_PATTERN = Pattern.compile("([^а-яіїєґА-ЯІЇЄҐ'\u0301-]((та|й|і) (інш?|под)|атм|відс|гр|коп|обл|р|рр|РР|руб|ст|стол|стор|чол|шт))\\.(?!\uE120)");

File: languagetool-language-modules/uk/src/test/java/org/languagetool/tokenizers/uk/UkrainianWordTokenizerTest.java
Patch:
@@ -28,7 +28,6 @@
 
 import org.apache.commons.lang3.StringUtils;
 import org.junit.Test;
-import org.languagetool.TestTools;
 
 public class UkrainianWordTokenizerTest {
   private final UkrainianWordTokenizer w = new UkrainianWordTokenizer();
@@ -407,6 +406,9 @@ public void testAbbreviations() {
     testList = w.tokenize("від лат. momento");
     assertEquals(Arrays.asList("від", " ", "лат.", " ", "momento"), testList);
 
+    testList = w.tokenize("отримав рос. орден");
+    assertEquals(Arrays.asList("отримав", " ", "рос.", " ", "орден"), testList);
+    
     testList = w.tokenize("на 1-кімн. кв. в центрі");
     assertEquals(Arrays.asList("на", " " , "1-кімн.", " ", "кв.", " ", "в", " ", "центрі"), testList);
 

File: languagetool-dev/src/main/java/org/languagetool/dev/SentenceSplitter.java
Patch:
@@ -45,7 +45,7 @@ private void run(Language language, File inputFile, PrintWriter outputFile) thro
         String line = scanner.nextLine();
         List<String> sentences = lt.sentenceTokenize(line);
         for (String sentence : sentences) {
-          String cleanSentence = sentence.strip();
+          String cleanSentence = sentence.trim();
           if (!cleanSentence.isEmpty()) {
             outputFile.println(cleanSentence);
           }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleCheck.java
Patch:
@@ -529,7 +529,7 @@ private void addChangedParas() {
    * check the text level rules associated with a given cache (cacheNum)
    */
   @Nullable
-  private SingleProofreadingError[] checkParaRules(String paraText, Locale locale, int[] footnotePos, int nFPara, int sentencePos, 
+  public SingleProofreadingError[] checkParaRules(String paraText, Locale locale, int[] footnotePos, int nFPara, int sentencePos, 
           SwJLanguageTool lt, int cacheNum, int parasToCheck, boolean textIsChanged, boolean isIntern) {
 
     List<RuleMatch> paragraphMatches;
@@ -580,7 +580,7 @@ private SingleProofreadingError[] checkParaRules(String paraText, Locale locale,
         }
         List<Integer> nextSentencePositions = getNextSentencePositions(paraText, mLt);
         List<Integer> deletedChars = isTextParagraph ? docCache.getFlatParagraphDeletedCharacters(nFPara): null;
-        if (mLt == null || docCache.isAutomaticGenerated(nFPara)) {
+        if (mLt == null || (isTextParagraph && docCache.isAutomaticGenerated(nFPara))) {
           paragraphMatches = null;
         } else {
           paragraphMatches = mLt.check(removeFootnotes(paraText, footnotePos, deletedChars), true, JLanguageTool.ParagraphHandling.NORMAL);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -210,8 +210,9 @@ ProofreadingResult getCheckResults(String paraText, Locale locale, ProofreadingR
       mDocHandler.setUseOriginalCheckDialog();
     }
 
-    if (proofInfo == OfficeTools.PROOFINFO_GET_PROOFRESULT && docCache.isResetRunning()) {
-      //  NOTE: LO blocks the read of information by document cursor tools till a PROOFINFO_GET_PROOFRESULT request is done
+    if (proofInfo == OfficeTools.PROOFINFO_GET_PROOFRESULT 
+        && (DocumentCursorTools.isBusy() || ViewCursorTools.isBusy() || docCache.isResetRunning())) {
+      //  NOTE: LO blocks the read of information by document or view cursor tools till a PROOFINFO_GET_PROOFRESULT request is done
       //        This causes a hanging of LO when the request isn't answered immediately by a 0 matches result
       MessageHandler.printToLogFile("SingleDocument: getCheckResults: docCache Reset is running: return 0 errors");
       return paRes;

File: languagetool-http-client/src/test/java/org/languagetool/remote/RemoteResultTest.java
Patch:
@@ -21,6 +21,7 @@
 import org.junit.Assert;
 import org.junit.Test;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 public class RemoteResultTest {
@@ -29,7 +30,7 @@ public class RemoteResultTest {
   public void testGetLanguageDetectedCodeOutput() {
     final RemoteServer remoteServer = new RemoteServer("LanguageTool", "", "");
     final List matches = new ArrayList();
-    final RemoteResult objectUnderTest = new RemoteResult("English", "en", "en", "English", matches, remoteServer);
+    final RemoteResult objectUnderTest = new RemoteResult("English", "en", "en", "English", matches, Collections.emptyList(), remoteServer);
     Assert.assertEquals(objectUnderTest.getLanguageDetectedCode(), "en");
     Assert.assertEquals(objectUnderTest.getLanguageDetectedName(), "English");
   }

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -253,6 +253,7 @@ protected int getPriorityForId(String id) {
       case "PT_DIACRITICS_REPLACE":     return -45;   // prefer over spell checker
       case "HUNSPELL_RULE":             return -50;
       case "CRASE_CONFUSION":           return -55;
+      case "GENERAL_VERB_AGREEMENT_ERRORS":           return -55;
       case "FINAL_STOPS":               return -75;
       case "EU_NÓS_REMOVAL":            return -90;
       case "T-V_DISTINCTION":           return -100;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/OfficeTools.java
Patch:
@@ -624,7 +624,7 @@ private static OfficeProductInfo readOfficeProductInfo(XComponentContext xContex
    * Get a boolean value from an Object
    */
   public static boolean getBooleanValue(Object o) {
-    if (o instanceof Boolean) {
+    if (o != null && o instanceof Boolean) {
       return ((Boolean) o).booleanValue();
     }
     return false;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleCheck.java
Patch:
@@ -558,7 +558,7 @@ private SingleProofreadingError[] checkParaRules(String paraText, Locale locale,
       }
       // return Cache result if available / for right mouse click or Dialog only use cache
       boolean isTextParagraph = nFPara >= 0 && docCache != null && docCache.getNumberOfTextParagraph(nFPara).type != DocumentCache.CURSOR_TYPE_UNKNOWN;
-      if (nFPara >= 0 && (pErrors != null || isMouseRequest || (useQueue && !isDialogRequest && parasToCheck != 0))) {
+      if (nFPara >= 0 && (pErrors != null || isMouseRequest || isDialogRequest || (useQueue && parasToCheck != 0))) {
         if (useQueue && pErrors == null && parasToCheck > 0 && isTextParagraph && !textIsChanged && mDocHandler.getTextLevelCheckQueue().isWaiting()) {
           mDocHandler.getTextLevelCheckQueue().wakeupQueue(singleDocument.getDocID());
         }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -823,6 +823,7 @@ public void testKonUntArtDefSub() throws IOException {
   public void testBugFixes() throws IOException {
     assertBad("Denn die einzelnen sehen sich einer sehr verschieden starken Macht des...", "einer sehr verschiedenen starken Macht");  // TODO: not actually a bug
     assertGood("Das passiert nur, wenn der zu Pflegende bereit ist.");
+    assertGood("Peter, iss nicht meine");  // used to cause ArrayIndexOutOfBoundsException
   }
 
   private void assertGood(String s) throws IOException {

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -560,7 +560,6 @@ protected int getPriorityForId(String id) {
       case "Y_ALL":                     return -4;  // prefer over spelling rules
       case "GIMME":                     return -4;  // prefer over spelling rules
       case "LEMME":                     return -4;  // prefer over spelling rules
-      case "POSSESSIVE_APOSTROPHE":     return -4;  // prefer some agreement rules
       case "EN_GB_SIMPLE_REPLACE":      return -5;  // higher prio than Speller
       case "EN_US_SIMPLE_REPLACE":      return -5;  // higher prio than Speller
       case "HAVE_PART_AGREEMENT":       return -9;  // prefer HYDRA_LEO
@@ -576,6 +575,7 @@ protected int getPriorityForId(String id) {
       case "BE_VBG_NN":                 return -12;  // prefer other more specific rules and speller
       case "THE_NNS_NN_IS":             return -12;  // prefer HYDRA_LEO
       case "PRP_MD_NN":                 return -12;  // prefer other more specific rules (e.g. MD_ABLE, WONT_WANT)
+      case "POSSESSIVE_APOSTROPHE":     return -15;  // prefer AI_HYDRA_LEO_APOSTROPHE_S_XS
       case "TWO_CONNECTED_MODAL_VERBS": return -15;
       case "MISSING_TO_BETWEEN_BE_AND_VB": return -15; // prefer AI and comma rules
       case "BE_MD":                     return -20;  // prefer other more specific rules (e.g. BEEN_PART_AGREEMENT, HYDRA_LEO)

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -647,6 +647,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Wir können sowas Mittwoch machen.");
     assertGood("Den schlechter Verdienenden geht es schlecht.");
     assertGood("Mit der weit weniger bekannten Horrorkomödie begann ihre Karriere.");
+    assertBad("Mit der weit weniger bekannte Horrorkomödie begann ihre Karriere.", "der weit weniger bekannten Horrorkomödie");
     assertGood("Die Adelmanns wohnen in Herford.");
     assertBad("Die Idee des Werbekaufmann kam gut an.");
     assertGood("Die Idee des Werbekaufmanns kam gut an.");

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -268,7 +268,7 @@ public boolean isMisspelled(String word) throws IOException {
    * @since 2.4
    */
   protected boolean isMisspelled(MorfologikMultiSpeller speller, String word) {
-    if (speller == null && Tools.isExternSpeller()) {  // use of external speller for LO/OO extension
+    if (Tools.isExternSpeller()) {  // use of external speller for OO extension (32-bit)
       if (Tools.getLinguisticServices().isCorrectSpell(word, language)) {
         return false;
       }
@@ -280,7 +280,7 @@ protected boolean isMisspelled(MorfologikMultiSpeller speller, String word) {
     if (checkCompound && compoundRegex.matcher(word).find()) {
       String[] words = compoundRegex.split(word);
       for (String singleWord: words) {
-        if (speller == null && Tools.isExternSpeller()) {  // use of external speller for LO/OO extension
+        if (Tools.isExternSpeller()) {  // use of external speller for OO extension (32-bit)
           if (!Tools.getLinguisticServices().isCorrectSpell(singleWord, language)) {
             return true;
           }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MessageHandler.java
Patch:
@@ -55,7 +55,7 @@ class MessageHandler {
    * Initialize log-file
    */
   private static void initLogFile(XComponentContext xContext) {
-    try (BufferedWriter bw = new BufferedWriter(new FileWriter(OfficeTools.getLogFilePath()))) {
+    try (BufferedWriter bw = new BufferedWriter(new FileWriter(OfficeTools.getLogFilePath(xContext)))) {
       Date date = new Date();
       OfficeProductInfo officeInfo = OfficeTools.getOfficeProductInfo(xContext);
       bw.write("LT office integration log from " + date + logLineBreak + logLineBreak);
@@ -64,8 +64,8 @@ private static void initLogFile(XComponentContext xContext) {
       bw.write("OS: " + System.getProperty("os.name") + " " 
           + System.getProperty("os.version") + " on " + System.getProperty("os.arch") + logLineBreak);
       if (officeInfo != null) { 
-        bw.write(officeInfo.ooName + officeInfo.ooVersion + officeInfo.ooExtension
-            + "(" + officeInfo.ooVendor +"), " + officeInfo.ooLocale + logLineBreak);
+        bw.write(officeInfo.ooName + " " + officeInfo.ooVersion + officeInfo.ooExtension
+            + " (" + officeInfo.ooVendor +"), " + officeInfo.ooLocale + logLineBreak);
       }
       bw.write(OfficeTools.getJavaInformation() + logLineBreak + logLineBreak);
     } catch (Throwable t) {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -134,7 +134,7 @@ public class MultiDocumentsHandler {
     this.xProofreader = xProofreader;
     xEventListeners = new ArrayList<>();
     configFile = OfficeTools.CONFIG_FILE;
-    configDir = OfficeTools.getLOConfigDir();
+    configDir = OfficeTools.getLOConfigDir(xContext);
     oldConfigFile = OfficeTools.getOldConfigFile();
     MessageHandler.init(xContext);
     documents = new ArrayList<>();

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ResultCache.java
Patch:
@@ -56,7 +56,7 @@ public ResultCache(ResultCache cache) {
    */
   void replace(ResultCache cache) {
     entries.clear();
-    if (cache != null && cache.entries != null && !cache.entries.isEmpty()) {
+    if (cache != null && cache.entries != null && !cache.entries.isEmpty() && cache.entries.keySet() != null) {
       Set<Integer> keys = new HashSet<>(cache.entries.keySet());
       for (Integer n : keys) {
         if (cache.entries.containsKey(n)) {

File: languagetool-core/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -173,6 +173,8 @@ public class WordListValidatorTest {
           "dtº",  // for PT
           "ª",  // for PT
           "º",  // for PT
+          "ĉi",  // for PT
+          "R$",  // for PT
           // Greek letters / Mathematics and physics variables
           "Α", "Β", "Γ", "Δ", "Ε", "Ζ", "Η", "Θ", "Ι", "Κ", "Λ", "Μ", "Ν", "Ξ", "Ο", "Π", "Ρ", "Σ", "Τ", "Υ", "Φ", "Χ", "Ψ", "Ω", 
           "α", "β", "γ", "δ", "ε", "ζ", "η", "θ", "ι", "κ", "λ", "μ", "ν", "ξ", "ο", "π", "ρ", "σ", "τ", "υ", "φ", "χ", "ψ", "ω"          

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/SubjectVerbAgreementRule.java
Patch:
@@ -253,7 +253,7 @@ public class SubjectVerbAgreementRule extends Rule {
       token("und"),
       token("Gemüse")
     ),
-    Arrays.asList( // Frisches Obst und Gemüse ist gut für die Gesundheit. 
+    Arrays.asList(
       token("Sport"),
       token("und"),
       token("Spiel")

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule2.java
Patch:
@@ -288,7 +288,9 @@ private RuleMatch checkAdjNounAgreement(AnalyzedTokenReadings token1, AnalyzedTo
   @NotNull
   private Set<String> retainCommonCategories(AnalyzedTokenReadings token1, AnalyzedTokenReadings token2) {
     Set<AgreementRule.GrammarCategory> categoryToRelaxSet = Collections.emptySet();
-    Set<String> set1 = AgreementTools.getAgreementSOLCategories(token1, categoryToRelaxSet);
+    // finds more error but also more false alarms? see commented out cases in testSuggestion():
+    //Set<String> set1 = AgreementTools.getAgreementSOLCategories(token1, categoryToRelaxSet);
+    Set<String> set1 = AgreementTools.getAgreementCategories(token1, categoryToRelaxSet, false);
     //System.out.println(token1 + " -> " + set1);
     Set<String> set2 = AgreementTools.getAgreementCategories(token2, categoryToRelaxSet, false);
     //System.out.println(token2 + " -> " + set2);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule2.java
Patch:
@@ -71,6 +71,7 @@ public class AgreementRule2 extends Rule {
     asList(token("Personal"), token("Shopper")),
     asList(token("Schwäbisch"), token("Hall")),
     asList(token("Herzlich"), token("Willkommen")),
+    asList(posRegex("ADJ.*"), tokenRegex(".+beamte")),  // "Alarmierte Polizeibeamte"
     asList(regex("echt|absolut|voll|total"), regex("Wahnsinn|Klasse")),
     asList(pos("SENT_START"), pos("ADJ:PRD:GRU"), posRegex("SUB:NOM:SIN:NEU:INF")),  // "Ruhig Schlafen & Zentral Wohnen"
     asList(tokenRegex("voll|voller"), posRegex("SUB:NOM:SIN:.*")),  // "Voller Mitleid", "Voller Mitleid"

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRule2Test.java
Patch:
@@ -85,6 +85,7 @@ public void testRule() throws IOException {
     assertGood("Prinzipiell Anrecht auf eine Vertretung");
     assertGood("Regelrecht Modell gestanden haben Michel");
     assertGood("Weitgehend Konsens, auch über ...");
+    assertGood("Alarmierte Polizeibeamte nahmen den Mann fest.");
   }
 
   @Test

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -1952,7 +1952,7 @@ public void closeDialog() {
      * TODO: The function works very temporarily
      */
     private void removeSpellingMark(int nFlat) throws Throwable {
-      XParagraphCursor pCursor = viewCursor.getParagraphCursorUnderViewCursor();
+      XParagraphCursor pCursor = viewCursor.getParagraphCursorFromViewCursor();
       pCursor.gotoStartOfParagraph(false);
       pCursor.goRight((short)error.nErrorStart, false);
       pCursor.goRight((short)error.nErrorLength, true);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule2.java
Patch:
@@ -267,7 +267,7 @@ private RuleMatch checkAdjNounAgreement(AnalyzedTokenReadings token1, AnalyzedTo
   @NotNull
   private Set<String> retainCommonCategories(AnalyzedTokenReadings token1, AnalyzedTokenReadings token2) {
     Set<AgreementRule.GrammarCategory> categoryToRelaxSet = Collections.emptySet();
-    Set<String> set1 = AgreementTools.getAgreementCategories(token1, categoryToRelaxSet, false);
+    Set<String> set1 = AgreementTools.getAgreementSOLCategories(token1, categoryToRelaxSet);
     Set<String> set2 = AgreementTools.getAgreementCategories(token2, categoryToRelaxSet, false);
     set1.retainAll(set2);
     return set1;

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRuleAntiPatterns1.java
Patch:
@@ -461,7 +461,7 @@ class AgreementRuleAntiPatterns1 {
     ),
     Arrays.asList(
       token("das"),  // "Einwohnerzahl stieg um das Zweieinhalbfache"
-      tokenRegex("(zwei|drei|vier|fünd|sechs|sieben|acht|neun|zehn|elf|zwölf).*fache")
+      tokenRegex("(zwei|drei|vier|fünf|sechs|sieben|acht|neun|zehn|elf|zwölf).*fache")
     ),
     Arrays.asList(
       token("diese"),  // "...damit diese ausreichend Sauerstoff geben."

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/CheckRequestAnalysis.java
Patch:
@@ -642,7 +642,7 @@ private int getParaFromViewCursorOrDialog(String chParaWithFootnotes, Locale loc
         if(!docCache.isEqual(nPara, chParaWithFootnotes, locale)) {
           actualizeDocumentCache(nPara, false);
           String dcText = SingleCheck.removeFootnotes(docCache.getFlatParagraph(nPara), footnotePositions, null);
-          if (!dcText.equals(chPara)) {
+          if (dcText == null || !dcText.equals(chPara)) {
             if (debugMode > 0) {
               MessageHandler.printToLogFile("CheckRequestAnalysis: getParaFromViewCursorOrDialog: cText != chPara: Number of Paragraph: " + nPara);
             }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementSuggestor2.java
Patch:
@@ -225,9 +225,9 @@ private String[] getDetOrPronounSynth(String num, String gen, String aCase, Anal
     }
     boolean isDef = detPos.contains(":DEF:");
     List<String> templates;
-    if (detReading.getToken().matches("(das|der|die|dem|des)selben?")) {
+    if (detReading.getToken().matches("([Dd]as|[Dd]er|[Dd]ie|[Dd]em|[Dd]es)selben?")) {
       templates = singletonList("PRO:DEM:NOM/AKK/DAT/GEN:SIN/PLU:MAS/FEM/NEU");
-    } else if (detReading.getToken().matches("welche[nmsr]?")) {
+    } else if (detReading.getToken().matches("[Ww]elche[nmsr]?")) {
       templates = singletonList("PRO:RIN:NOM/AKK/DAT/GEN:SIN/PLU:MAS/FEM/NEU:B/S");
     } else if (detPos.contains("ART:")) {
       templates = singletonList(detTemplate);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementSuggestor2Test.java
Patch:
@@ -83,13 +83,15 @@ public void testSuggestions() throws IOException {
     assertSuggestion1("derselben Mann", "[derselbe Mann, denselben Mann, demselben Mann, desselben Manns, desselben Mannes]");
     assertSuggestion1("demselben Frau", "[derselben Frau, dieselbe Frau]");
     assertSuggestion1("desselben Mann", "[denselben Mann, demselben Mann, desselben Manns, derselbe Mann, desselben Mannes]");
+    assertSuggestion1("Desselben Mann", "[Denselben Mann, Demselben Mann, Desselben Manns, Derselbe Mann, Desselben Mannes]");
     assertSuggestion1("meinem Eltern", "[meine Eltern, meinen Eltern, meiner Eltern]");
     assertSuggestion1("eure Auge", "[eurem Auge, eure Augen, euer Auge, euerem Auge, euerm Auge, eures Auges, euren Augen, eueres Auges, euerer Augen]");
     assertSuggestion1("welche Internetvideo", "[welches Internetvideo, welchem Internetvideo, welche Internetvideos, welches Internetvideos, welchen Internetvideos, welcher Internetvideos]");
     assertSuggestion1("welchen Internetvideo", "[welches Internetvideo, welchem Internetvideo, welchen Internetvideos, welches Internetvideos, welche Internetvideos, welcher Internetvideos]");
     assertSuggestion1("welches Mann", "[welcher Mann, welchen Mann, welchem Mann, welches Manns, welches Mannes, welche Männer, welcher Männer, welchen Männern]");
     assertSuggestion1("welchem Frau", "[welche Frau, welcher Frau, welche Frauen, welchen Frauen, welcher Frauen]");
     assertSuggestion1("welcher Kind", "[welches Kind, welchem Kind, welcher Kinder, welchem Kinde, welches Kinds, welches Kindes, welche Kinder, welchen Kindern]");
+    assertSuggestion1("Welcher Kind", "[Welches Kind, Welchem Kind, Welcher Kinder, Welchem Kinde, Welches Kinds, Welches Kindes, Welche Kinder, Welchen Kindern]");
   }
 
   @Test

File: languagetool-language-modules/de/src/test/java/org/languagetool/tokenizers/de/GermanSRXSentenceTokenizerTest.java
Patch:
@@ -51,6 +51,7 @@ public void testTokenize() {
     testSplit("Hallo, ich bin’s. ", "Könntest du kommen?");
     testSplit("In der 1. Bundesliga kam es zum Eklat.");
     testSplit("Dies ist, z. B., ein Satz."); 
+    testSplit("Da hatte es über 30 °C. ", "Hier kommt der nächste Satz.");
 
     testSplit("Das 1. Internationale Filmfestival findet nächste Woche statt.");
     testSplit("Friedrich I., auch bekannt als Friedrich der Große.");

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCursorTools.java
Patch:
@@ -101,8 +101,7 @@ private XTextCursor getCursor(XComponent xComponent) {
       XText xText = curDoc.getText();
       if (xText == null) {
         return null;
-      }
-      else {
+      } else {
         XTextRange xStart = xText.getStart();
         try {
           return xText.createTextCursorByRange(xStart);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleCheck.java
Patch:
@@ -765,6 +765,9 @@ static String cleanFootnotes(String paraText) {
    * run cleanFootnotes if information about footnotes are not supported
    */
   static String removeFootnotes(String paraText, int[] footnotes, List<Integer> deletedChars) {
+    if (paraText == null) {
+      return null;
+    }
     if (deletedChars == null || deletedChars.isEmpty()) {
       if (footnotes == null) {
         return cleanFootnotes(paraText);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SentenceWhitespaceRuleTest.java
Patch:
@@ -47,6 +47,9 @@ public void testMatch() throws Exception {
     assertGood("Am 28. September.", lt);
     assertBad("Am 28.September.", lt);
 
+    assertGood("Das 1. Internationale Filmfestival findet nächste Woche statt.", lt);
+    assertBad("Das 1.Internationale Filmfestival findet nächste Woche statt.", lt);
+
     assertTrue(lt.check("Am 7.September 2014.").get(0).getMessage().contains("nach Ordnungszahlen"));
     assertTrue(lt.check("Im September.Dann der nächste Satz.").get(0).getMessage().contains("zwischen Sätzen"));
   }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -679,7 +679,7 @@ public String getTextParagraph(TextParagraph textParagraph) {
   public int getFlatParagraphNumber(TextParagraph textParagraph) {
     waitForFinish(-1);
 //    if (textParagraph.type == CURSOR_TYPE_UNKNOWN || !isFinished()) {
-    if (textParagraph.type == CURSOR_TYPE_UNKNOWN || toParaMapping.get(textParagraph.type).size() < textParagraph.number) {
+    if (textParagraph.type == CURSOR_TYPE_UNKNOWN || toParaMapping.get(textParagraph.type).size() <= textParagraph.number) {
       return -1;
     }
     return toParaMapping.get(textParagraph.type).get(textParagraph.number);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MessageHandler.java
Patch:
@@ -194,6 +194,7 @@ public void run() {
       JOptionPane pane = new JOptionPane(text, JOptionPane.INFORMATION_MESSAGE);
       dialog = pane.createDialog(null, UIManager.getString("OptionPane.messageDialogTitle", null));
       dialog.setModal(false);
+      dialog.setAutoRequestFocus(true);
       dialog.setAlwaysOnTop(true);
       dialog.addWindowFocusListener(new WindowFocusListener() {
         @Override

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -1357,8 +1357,8 @@ private boolean initCursor() throws Throwable {
             endOfRange = -1;
           }
         } else {
-          MessageHandler.showClosingInformationDialog(messages.getString("loDialogUnsupported"));
           closeDialog();
+          MessageHandler.showClosingInformationDialog(messages.getString("loDialogUnsupported"));
           return false;
         }
       } else {
@@ -1934,6 +1934,7 @@ public void actionPerformed(ActionEvent action) {
      * closes the dialog
      */
     public void closeDialog() {
+      dialog.setVisible(false);
 //      if (isRunning) {
         if (debugMode) {
           MessageHandler.printToLogFile("CheckDialog: closeDialog: Close Spell And Grammar Check Dialog");
@@ -1945,7 +1946,6 @@ public void closeDialog() {
 //        isRunning = false;
 //        gotoNextError();
 //      }
-      dialog.setVisible(false);
     }
     
     /**

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -346,7 +346,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) {
             }
           } else if (tokenPos+1 < tokens.length && hasReadingOfType(tokens[tokenPos+1], POSType.NOMEN) && GermanHelper.hasReadingOfType(tokens[tokenPos], POSType.ADJEKTIV)) {
             RuleMatch ruleMatch = checkDetAdjAdjNounAgreement(maybePreposition, tokens[i],
-              nextToken, tokens[tokenPos], tokens[tokenPos+1], sentence, i, replMap);
+              nextToken, tokens[tokenPos], tokens[tokenPos+1], sentence, i, replMap, skippedStr);
             if (ruleMatch != null) {
               ruleMatches.add(ruleMatch);
             }
@@ -648,7 +648,7 @@ private RuleMatch checkDetAdjNounAgreement(AnalyzedTokenReadings maybePrepositio
 
   private RuleMatch checkDetAdjAdjNounAgreement(AnalyzedTokenReadings maybePreposition, AnalyzedTokenReadings token1,
                                              AnalyzedTokenReadings token2, AnalyzedTokenReadings token3, AnalyzedTokenReadings token4,
-                                             AnalyzedSentence sentence, int tokenPos, Map<Integer, ReplacementType> replMap) {
+                                             AnalyzedSentence sentence, int tokenPos, Map<Integer, ReplacementType> replMap, String skippedStr) {
     Set<String> set = retainCommonCategories(token1, token2, token3, token4);
     RuleMatch ruleMatch = null;
     if (set.isEmpty()) {
@@ -663,6 +663,7 @@ private RuleMatch checkDetAdjAdjNounAgreement(AnalyzedTokenReadings maybePreposi
       if (replMap != null) {
         AgreementSuggestor2 suggestor = new AgreementSuggestor2(language.getSynthesizer(), token1, token2, token3, token4, replMap.get(tokenPos));
         suggestor.setPreposition(maybePreposition);
+        suggestor.setSkipped(skippedStr);
         ruleMatch.setSuggestedReplacements(suggestor.getSuggestions(true));
       }
     }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -512,6 +512,8 @@ public void testDetNounRule() throws IOException {
     assertBad("Ich gebe dir das kleinem Kaninchen.");
     assertBad("Ich gebe dir das kleiner Kaninchen.");
     assertBad("Geprägt ist der Platz durch einen 142 Meter hoher Obelisken", "einen 142 Meter hohen Obelisken");
+    assertBad("Es birgt für mich ein überraschend hohes juristische Risiko.", "ein überraschend hohes juristisches Risiko");
+    assertBad("Es birgt für mich ein zu hohes juristische Risiko.", "ein zu hohes juristisches Risiko");
     //assertBad("Ich gebe dir das kleines Kaninchen.");  // already detected by ART_ADJ_SOL
     //assertBad("Ich gebe dir das klein Kaninchen.");  // already detected by MEIN_KLEIN_HAUS
     assertGood("Ich gebe dir das kleine Kaninchen.");
@@ -795,7 +797,7 @@ public void testKonUntArtDefSub() throws IOException {
 
   @Test
   public void testBugFixes() throws IOException {
-    assertBad("Denn die einzelnen sehen sich einer sehr verschieden starken Macht des...", "einer verschiedenen starken Macht");  // TODO: not actually a bug
+    assertBad("Denn die einzelnen sehen sich einer sehr verschieden starken Macht des...", "einer sehr verschiedenen starken Macht");  // TODO: not actually a bug
     assertGood("Das passiert nur, wenn der zu Pflegende bereit ist.");
   }
 

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -268,6 +268,6 @@ protected int getPriorityForId(String id) {
       case "CACOPHONY":                 return -1500;
       case "UNKNOWN_WORD":              return -2000;
     }
-    return 0;
+    return super.getPriorityForId(id);
   }
 }

File: languagetool-language-modules/nl/src/main/java/org/languagetool/language/Dutch.java
Patch:
@@ -176,7 +176,7 @@ public boolean isAdvancedTypographyEnabled() {
   @Override
   protected int getPriorityForId(String id) {
     if (id.startsWith(SimpleReplaceRule.DUTCH_SIMPLE_REPLACE_RULE)) {
-    return -2;
+      return -2;
     }
     switch (id) {
       case LongSentenceRule.RULE_ID: return -1;
@@ -203,7 +203,7 @@ public List<String> getRuleFileNames() {
   
   @Override
   public SpellingCheckRule createDefaultSpellingRule(ResourceBundle messages) throws IOException {
-      return new MorfologikDutchSpellerRule(messages, this, null, Collections.emptyList());
+    return new MorfologikDutchSpellerRule(messages, this, null, Collections.emptyList());
   }
 
 }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -451,6 +451,9 @@ private void changeTextOfParagraph(int nFPara, int nStart, int nLength, String r
    */
   private CheckError getNextErrorInParagraph (int x, int nFPara, SingleDocument document, 
       DocumentCursorTools docTools) throws Throwable {
+    if (docCache.isAutomaticGenerated(nFPara)) {
+      return null;
+    }
     String text = docCache.getFlatParagraph(nFPara);
     locale = docCache.getFlatParagraphLocale(nFPara);
 //    MessageHandler.printToLogFile("CheckDialog: getNextErrorInParagraph(" + nFPara + ", 1): locale: " + (locale == null ? "null" : OfficeTools.localeToString(locale)));

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/TextLevelCheckQueue.java
Patch:
@@ -267,6 +267,9 @@ Language getLanguage(String docId, TextParagraph nStart) {
     if (document != null) {
       docCache = document.getDocumentCache();
       if (docCache != null && nStart.number < docCache.textSize(nStart)) {
+        if (docCache.isAutomaticGenerated(docCache.getFlatParagraphNumber(nStart))) {
+          return null;
+        }
         Locale locale = docCache.getTextParagraphLocale(nStart);
         if (locale != null && multiDocHandler.hasLocale(locale)) {
           return multiDocHandler.getLanguage(locale);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -267,7 +267,9 @@ public void testDetNounRule() throws IOException {
     assertGood("Der eine große Polizist rief dem anderen zu...");
     assertGood("Das eine Kind rief dem anderen zu...");
     assertGood("Er wollte seine Interessen wahrnehmen.");
-    assertGood("Denn die einzelnen sehen sich einer sehr verschieden starken Macht des...");  // strange bug that suggests "Machtmacht"
+    assertBad("Denn die einzelnen sehen sich einer sehr verschieden starken Macht des...");  // TODO
+    assertBad("Es birgt für mich ein zu hohes juristische Risiko.");
+    assertGood("Es birgt für mich ein zu hohes juristisches Risiko.");
 
     assertGood("... wo Krieg den Unschuldigen Leid und Tod bringt.");
     assertGood("Der Abschuss eines Papageien.");

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/AboutDialog.java
Patch:
@@ -92,7 +92,7 @@ public void show(XComponentContext xContext) {
       licensePane.setEditable(false);
       licensePane.setOpaque(false);
       licensePane.setText("<html>"
-              + "<p>Copyright (C) 2005-2022 the LanguageTool community and Daniel Naber<br>"
+              + "<p>Copyright (C) 2005-2022 the LanguageTool community and Daniel Naber.<br>"
               + "This software is licensed under the GNU Lesser General Public License.<br>"
               + "<a href=\"https://www.languagetool.org\">https://www.languagetool.org</a><br>"
               + "</html>");

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/AboutDialog.java
Patch:
@@ -136,7 +136,7 @@ public void show(XComponentContext xContext) {
       aboutPane.setEditable(false);
       aboutPane.setOpaque(false);
       aboutPane.setText(String.format("<html>"
-          + "<p>Maintainer of the office extension : %s</p>"
+          + "<p>Maintainer of the office extension: %s</p>"
           + "<p>Maintainers or former maintainers of the language modules -<br>"
           + "(*) means language is unmaintained in LanguageTool:</p><br>"
           + "</html>", OfficeTools.EXTENSION_MAINTAINER));

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/AboutDialog.java
Patch:
@@ -180,6 +180,7 @@ public void show(XComponentContext xContext) {
       dialog.setAutoRequestFocus(true);
 //      MessageHandler.printToLogFile("set dialog visible");
       dialog.setVisible(true);
+      dialog.setAlwaysOnTop(true);
       dialog.toFront();
     } catch (Throwable t) {
       MessageHandler.showError(t);

File: languagetool-dev/src/test/java/org/languagetool/dev/eval/LanguageDetectionMinLengthEval.java
Patch:
@@ -52,12 +52,12 @@ private LanguageDetectionMinLengthEval() {
     File fastTextBin = new File("/home/stefan/Dokumente/languagetool/data/fasttext/fasttext");
     File fastTextModel = new File("/home/stefan/Dokumente/languagetool/data/fasttext/lid.176.bin");
 //    Daniel's paths:
+//    File ngrams = new File("/home/languagetool/model_ml50_new.zip");
 //    File fastTextBin = new File("/home/languagetool/fasttext/fasttext");
-//    File fastTextBin = new File("/home/languagetool/fasttext/lid.176.bin");
+//    File fastTextModel = new File("/home/languagetool/fasttext/lid.176.bin");
     languageIdentifier = LanguageIdentifierService.INSTANCE.getDefaultLanguageIdentifier(0, ngrams, fastTextBin, fastTextModel);
 //    languageIdentifier = LanguageIdentifierFactory.INSTANCE.getLocalLanguageIdentifier(Arrays.asList("de-DE", "en-US"));
 //    languageIdentifier = LanguageIdentifierFactory.INSTANCE.getLocalLanguageIdentifier(null);
-
   }
 
   private float evaluate(Language language) throws IOException {

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -544,7 +544,6 @@ protected int getPriorityForId(String id) {
       case "CANT_JJ":                   return -2;  // prefer other more specific rules
       case "WOULD_A":                   return -2;  // prefer other more specific rules
       case "I_AM_VB":                   return -2;  // prefer other rules
-      case "MD_PRP_QUESTION_MARK":      return -2;  // less prio than YOU_YOUR and YOU_YOUR_2
       case "BE_VBP_IN":                 return -2;  // prefer over BEEN_PART_AGREEMENT
       case "GONNA_TEMP":                return -3;
       case "A_INFINITIVE":              return -3;  // prefer other more specific rules (with suggestions, e.g. PREPOSITION_VERB, THE_TO)

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleCheck.java
Patch:
@@ -343,7 +343,7 @@ public void addParaErrorsToCache(int nFPara, SwJLanguageTool lt, int cacheNum, i
    */
   public void remarkChangedParagraphs(List<Integer> changedParas, DocumentCursorTools docCursor, 
       FlatParagraphTools flatPara, SwJLanguageTool lt, boolean override) {
-    if (!isDisposed() && !mDocHandler.isSwitchedOff() && (!isDialogRequest || isIntern)) {
+    if (!isDisposed() && !mDocHandler.isBackgroundCheckOff() && (!isDialogRequest || isIntern)) {
       Map <Integer, List<SentenceErrors>> changedParasMap = new HashMap<>();
       for (int i = 0; i < changedParas.size(); i++) {
         List<SentenceErrors> sentencesErrors = getSentencesErrosAsList(changedParas.get(i), lt);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ResultCache.java
Patch:
@@ -56,7 +56,7 @@ public ResultCache(ResultCache cache) {
    */
   void replace(ResultCache cache) {
     entries.clear();
-    if (cache != null) {
+    if (cache != null && cache.entries != null && !cache.entries.isEmpty()) {
       Set<Integer> keys = new HashSet<>(cache.entries.keySet());
       for (Integer n : keys) {
         if (cache.entries.containsKey(n)) {

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Tools.java
Patch:
@@ -218,7 +218,7 @@ public static void configureFromRules(JLanguageTool lt, Configuration config) {
     lt.setConfigValues(config.getConfigurableValues());
   }
   
-  static void addHyperlinkListener(JTextPane pane) {
+  public static void addHyperlinkListener(JTextPane pane) {
     pane.addHyperlinkListener(new HyperlinkListener() {
       @Override
       public void hyperlinkUpdate(HyperlinkEvent e) {

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -206,6 +206,7 @@ protected int getPriorityForId(String id) {
       case "PASSAT_PERIFRASTIC": return 20;
       case "ORDINALS": return 20; // greater than SEPARAT
       case "SUPER": return 20;
+      case "HAVER_PARTICIPI_HAVER_IMPERSONAL": return 15; // greater than ACCENTUATION_CHECK
       case "CONCORDANCES_NUMERALS_DUES": return 10; // greater than CONCORDANCES_NUMERALS
       case "FALTA_CONDICIONAL": return 10; // greater than POTSER_SIGUI
       case "ACCENTUATION_CHECK": return 10;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -206,6 +206,7 @@ protected int getPriorityForId(String id) {
       case "PASSAT_PERIFRASTIC": return 20;
       case "ORDINALS": return 20; // greater than SEPARAT
       case "SUPER": return 20;
+      case "CONCORDANCES_NUMERALS_DUES": return 10; // greater than CONCORDANCES_NUMERALS
       case "FALTA_CONDICIONAL": return 10; // greater than POTSER_SIGUI
       case "ACCENTUATION_CHECK": return 10;
       case "CONCORDANCES_NUMERALS": return 10;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -206,6 +206,7 @@ protected int getPriorityForId(String id) {
       case "PASSAT_PERIFRASTIC": return 20;
       case "ORDINALS": return 20; // greater than SEPARAT
       case "SUPER": return 20;
+      case "CONCORDANCES_NUMERALS_DUES": return 10; // greater than CONCORDANCES_NUMERALS
       case "FALTA_CONDICIONAL": return 10; // greater than POTSER_SIGUI
       case "ACCENTUATION_CHECK": return 10;
       case "CONCORDANCES_NUMERALS": return 10;

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -314,7 +314,7 @@ protected int getPriorityForId(String id) {
       case "VERWANDET_VERWANDTE": return 1; // prefer over DE_CASE
       case "SEIT_LAENGEREN": return 1; // prefer over DE_CASE
       case "SEIT_KLEIN_AUF": return 1; // prefer over agreement rules
-      case "SEIT_GEBURT_AUF": return 1; // prefer over agreement rules
+      case "SEIT_GEBURT_AN": return 1; // prefer over agreement rules
       case "WO_VON": return 1; // prefer over most agreement rules
       case "ICH_BIN_STAND_JETZT_KOMMA": return 1; // prefer over most agreement rules
       case "EIN_LOGGEN": return 1; // prefer over most agreement rules

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -610,7 +610,7 @@ public synchronized String getTextParagraph(TextParagraph textParagraph) {
    */
   public synchronized int getFlatParagraphNumber(TextParagraph textParagraph) {
 //    if (textParagraph.type == CURSOR_TYPE_UNKNOWN || !isFinished()) {
-    if (textParagraph.type == CURSOR_TYPE_UNKNOWN) {
+    if (textParagraph.type == CURSOR_TYPE_UNKNOWN || toParaMapping.get(textParagraph.type).size() < textParagraph.number) {
       return -1;
     }
     return toParaMapping.get(textParagraph.type).get(textParagraph.number);

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -39,6 +39,7 @@
 import org.languagetool.tagging.disambiguation.rules.de.GermanRuleDisambiguator;
 import org.languagetool.tokenizers.*;
 import org.languagetool.tokenizers.de.GermanCompoundTokenizer;
+import org.languagetool.tools.Tools;
 
 import java.io.File;
 import java.io.IOException;
@@ -134,7 +135,8 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
     return Arrays.asList(
             new CommaWhitespaceRule(messages,
                     Example.wrong("Die Partei<marker> ,</marker> die die letzte Wahl gewann."),
-                    Example.fixed("Die Partei<marker>,</marker> die die letzte Wahl gewann.")),
+                    Example.fixed("Die Partei<marker>,</marker> die die letzte Wahl gewann."),
+                    Tools.getUrl("https://languagetool.org/insights/de/beitrag/grammatik-leerzeichen/#fehler-1-leerzeichen-vor-und-nach-satzzeichen")),
             new GermanUnpairedBracketsRule(messages, this),
             new UppercaseSentenceStartRule(messages, this,
                     Example.wrong("Das Haus ist alt. <marker>es</marker> wurde 1950 gebaut."),

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/DashRule.java
Patch:
@@ -24,6 +24,7 @@
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.AnalyzedTokenReadings;
 import org.languagetool.rules.*;
+import org.languagetool.tools.Tools;
 
 /**
  * Prüft, dass in Bindestrich-Komposita kein Leerzeichen eingefügt wird (wie z.B. in 'Diäten- Erhöhung').
@@ -34,6 +35,7 @@ public class DashRule extends Rule {
 
   public DashRule(ResourceBundle messages) {
     super.setCategory(Categories.COMPOUNDING.getCategory(messages));
+    setUrl(Tools.getUrl("https://languagetool.org/insights/de/beitrag/grammatik-leerzeichen/#fehler-1-leerzeichen-vor-und-nach-satzzeichen"));
     addExamplePair(Example.wrong("Bundestag beschließt <marker>Diäten- Erhöhung</marker>"),
                    Example.fixed("Bundestag beschließt <marker>Diäten-Erhöhung</marker>"));
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/SentenceWhitespaceRule.java
Patch:
@@ -19,6 +19,7 @@
 package org.languagetool.rules.de;
 
 import org.languagetool.rules.*;
+import org.languagetool.tools.Tools;
 
 import java.util.ResourceBundle;
 
@@ -34,6 +35,7 @@ public SentenceWhitespaceRule(ResourceBundle messages) {
     super(messages);
     super.setCategory(Categories.MISC.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Whitespace);
+    setUrl(Tools.getUrl("https://languagetool.org/insights/de/beitrag/grammatik-leerzeichen/#fehler-1-leerzeichen-vor-und-nach-satzzeichen"));
     addExamplePair(Example.wrong("Hier steht ein Satz.<marker>Das</marker> ist ein weiterer Satz."),
                    Example.fixed("Hier steht ein Satz.<marker> Das</marker> ist ein weiterer Satz."));
   }

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -44,6 +44,7 @@
 import org.languagetool.tokenizers.SentenceTokenizer;
 import org.languagetool.tokenizers.Tokenizer;
 import org.languagetool.tokenizers.en.EnglishWordTokenizer;
+import org.languagetool.tools.Tools;
 
 import java.io.File;
 import java.io.IOException;
@@ -176,7 +177,8 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
     allRules.addAll(Arrays.asList(
         new CommaWhitespaceRule(messages,
                 Example.wrong("We had coffee<marker> ,</marker> cheese and crackers and grapes."),
-                Example.fixed("We had coffee<marker>,</marker> cheese and crackers and grapes.")),
+                Example.fixed("We had coffee<marker>,</marker> cheese and crackers and grapes."),
+                Tools.getUrl("https://languagetool.org/insights/post/punctuation-guide/#what-are-parentheses")),
         new DoublePunctuationRule(messages),
         new UppercaseSentenceStartRule(messages, this,
                 Example.wrong("This house is old. <marker>it</marker> was built in 1950."),

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementSuggestor2.java
Patch:
@@ -55,6 +55,8 @@ class AgreementSuggestor2 {
   private final static List<String> gender = Arrays.asList("MAS", "FEM", "NEU");
   private final static List<String> cases = Arrays.asList("NOM", "AKK", "DAT", "GEN");
   private final static List<String> nounCases = Arrays.asList("NOM", "AKK", "DAT", "GEN");
+  private final static Set<String> skipSuggestions =
+    new HashSet<>(Arrays.asList("unsren", "unsrem", "unsres", "unsre", "unsern", "unserm", "unsrer"));
 
   private final Synthesizer synthesizer;
   private final AnalyzedTokenReadings determinerToken;
@@ -241,6 +243,7 @@ private String[] getDetOrPronounSynth(String num, String gen, String aCase, Anal
       String origFirstChar = detReading.getToken().substring(0, 1);
       synthesized.addAll(Arrays.stream(tmp)
         .filter(k -> k.toLowerCase().startsWith(origFirstChar.toLowerCase()))
+        .filter(k -> !skipSuggestions.contains(k.toLowerCase()))
         .map(k -> Character.isUpperCase(origFirstChar.charAt(0)) ? StringTools.uppercaseFirstChar(k) : k)  // don't suggest "dein" for "mein" etc.
         .collect(Collectors.toList()));
     }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -311,6 +311,8 @@ public void testDetNounRule() throws IOException {
     assertGood("Das macht jedem Angst.");
     assertGood("Dann macht das Sinn.");
     assertGood("Das sind beides Lichtschalter.");
+    assertGood("Spielst du vielleicht auf das Bordell neben unserm Hotel an?");
+    assertGood("Spielst du vielleicht auf das Bordell neben unsrem Hotel an?");
 
     // relative clauses:
     assertGood("Das Recht, das Frauen eingeräumt wird.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementSuggestor2Test.java
Patch:
@@ -124,6 +124,7 @@ public void testSuggestionsHaus() throws IOException {
     assertSuggestion1("die Haus", "[das Haus, dem Haus, die Häuser]", true);
     assertSuggestion1("die Hauses", "[des Hauses, die Häuser]", true);
     assertSuggestion1("die Häusern", "[die Häuser, den Häusern]", true);
+    assertSuggestion1("unsere Buch", "[unser Buch, unserem Buch, unsere Bücher]", true);
   }
 
   @Test

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -89,7 +89,9 @@ public class DocumentCache implements Serializable {
     isReset = true;
     debugMode = OfficeTools.DEBUG_MODE_DC;
     debugModeTm = OfficeTools.DEBUG_MODE_TM;
-    add(in);
+    if (in.size() > 0) {
+      add(in);
+    }
     docType = in.docType;
     isReset = false;
   }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ViewCursorTools.java
Patch:
@@ -199,7 +199,9 @@ void setViewCursorParagraphText(int nStart, int nLength, String replace) {
       }
       xParagraphCursor.gotoStartOfParagraph(false);
       xParagraphCursor.goRight((short) nStart, false);
-      xParagraphCursor.goRight((short) nLength, true);
+      if (nLength > 0) {
+        xParagraphCursor.goRight((short) nLength, true);
+      }
       xParagraphCursor.setString(replace);
     } catch (Throwable t) {
       MessageHandler.printException(t);     // all Exceptions thrown by UnoRuntime.queryInterface are caught

File: languagetool-server/src/main/java/org/languagetool/server/DatabaseAccessOpenSource.java
Patch:
@@ -65,6 +65,7 @@ public DatabaseAccessOpenSource(HTTPServerConfig config) {
         properties.setProperty("username", config.getDatabaseUsername());
         properties.setProperty("password", config.getDatabasePassword());
         properties.setProperty("premium", Premium.isPremiumVersion() ? "Premium" : "OpenSource");
+        properties.setProperty("timeout", String.valueOf(config.getDbTimeoutSeconds()));
         sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream, properties);
 
         // try to close connections even on hard restart

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServerConfig.java
Patch:
@@ -206,7 +206,8 @@ public void setRestrictManagedAccounts(boolean restrictManagedAccounts) {
     "redisPassword", "redisHost", "redisCertificate", "redisKey", "redisKeyPassword",
     "redisUseSentinel", "sentinelHost", "sentinelPort", "sentinelPassword", "sentinelMasterId",
     "dbLogging", "premiumOnly", "nerUrl", "minPort", "maxPort", "localApiMode", "motherTongue", "preferredLanguages",
-    "dictLimitUser", "dictLimitTeam", "styleGuideLimitUser", "styleGuideLimitTeam");
+    "dictLimitUser", "dictLimitTeam", "styleGuideLimitUser", "styleGuideLimitTeam",
+    "passwortLoginAccessListPath");
 
   /**
    * Create a server configuration for the default port ({@link #DEFAULT_PORT}).

File: languagetool-language-modules/fr/src/test/java/org/languagetool/language/FrenchTest.java
Patch:
@@ -69,7 +69,7 @@ public void testRules() throws IOException {
     List<RuleMatch> matches = lt.check("Fête des mères et remise de l'insigne \" Morts pour la France \".");
     assertEquals(0, matches.size());
     // ACCORD_V_QUESTION2[1]
-    List<RuleMatch> matches2 = lt.check("D'autre part je ne soutiens pas du tout le système actuel en france mais je sais qu'au train où l'on va que notre prochaine étape sera celle de la Grèce ou de l'Argentine.");
+    List<RuleMatch> matches2 = lt.check("D'autre part, je ne soutiens pas du tout le système actuel en france mais je sais qu'au train où l'on va que notre prochaine étape sera celle de la Grèce ou de l'Argentine.");
     assertEquals(1, matches2.size());
   }
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -295,6 +295,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Ich habe deshalb allen Freund*innen Bescheid gegeben.");   // Gendersternchen, https://github.com/languagetool-org/languagetool/issues/2417
     assertGood("Ich habe deshalb allen Freund_innen Bescheid gegeben.");
     assertGood("Ich habe deshalb allen Freund:innen Bescheid gegeben.");
+    assertGood("Das betrifft auch eure Werkstudent:innen-Zielgruppe.");
     assertGood("Sein*e Mitarbeiter*in ist davon auch betroffen.");
     assertGood("Jede*r Mitarbeiter*in ist davon betroffen.");
     assertGood("Alle Professor*innen");

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SimpleReplaceAnglicism.java
Patch:
@@ -19,6 +19,7 @@
 package org.languagetool.rules.ca;
 
 import org.languagetool.AnalyzedTokenReadings;
+import org.languagetool.Tag;
 import org.languagetool.language.Catalan;
 import org.languagetool.rules.AbstractSimpleReplaceRule2;
 import org.languagetool.rules.Categories;
@@ -48,6 +49,7 @@ public SimpleReplaceAnglicism(final ResourceBundle messages) throws IOException
     super(messages, new Catalan());
     super.setCategory(Categories.STYLE.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Style);
+    super.setTags(Arrays.asList(Tag.picky));
   }
 
   @Override

File: languagetool-language-modules/pl/src/main/java/org/languagetool/rules/pl/SimpleReplaceRule.java
Patch:
@@ -73,7 +73,7 @@ public String getShort() {
 
   @Override
   public String getMessage(String tokenStr, List<String> replacements) {
-    return "'" + tokenStr + "' to najczęściej błąd; poprawnie pisze się: "
+    return "Wyraz „" + tokenStr + "” to najczęściej literówka; poprawnie pisze się: "
         + String.join(", ", replacements) + ".";
   }
 

File: languagetool-language-modules/pl/src/main/java/org/languagetool/tokenizers/pl/PolishWordTokenizer.java
Patch:
@@ -63,7 +63,7 @@ public class PolishWordTokenizer extends WordTokenizer {
   }
 
   public PolishWordTokenizer() {
-    plTokenizing = super.getTokenizingCharacters() + "–";   // n-dash
+    plTokenizing = super.getTokenizingCharacters() + "–‚";   // n-dash
   }
 
   /**

File: languagetool-core/src/main/java/org/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -322,12 +322,10 @@ public AnalyzedToken readingWithTagRegex(String posTagRegex) {
   
   /**
    * Returns the first reading that matches a given lemma.
-   *
-   * @param posTagRegex POS tag regular expression to look for
    * @since 5.8
    */
   public AnalyzedToken readingWithLemma(String lemma) {
-    boolean found = false;
+    boolean found;
     for (AnalyzedToken reading : anTokReadings) {
       if (reading.getLemma() != null) {
         found = reading.getLemma().equals(lemma);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRuleAntiPatterns1.java
Patch:
@@ -38,13 +38,13 @@ class AgreementRuleAntiPatterns1 {
     Arrays.asList(
       posRegex("PRO.*"),  // "Es gibt viele Stock Screener."
       posRegex("SUB:.*"),
-      new PatternTokenBuilder().pos("UNKNOWN").csTokenRegex("[A-ZÖÄÜ][a-zöäß-]+").build()
+      new PatternTokenBuilder().pos("UNKNOWN").csTokenRegex("[A-ZÖÄÜ][a-zöäüß-]+").build()
     ),
     Arrays.asList(
       posRegex("PRO.*"),  // "Es gibt viele verschiedene Stock Screener."
       posRegex("(ADJ|PA2).*"),
       posRegex("SUB:.*"),
-      new PatternTokenBuilder().pos("UNKNOWN").csTokenRegex("[A-ZÖÄÜ][a-zöäß-]+").build()
+      new PatternTokenBuilder().pos("UNKNOWN").csTokenRegex("[A-ZÖÄÜ][a-zöäüß-]+").build()
     ),
     Arrays.asList(
       tokenRegex("[(\\[]"),   // "... (ich meine Pfeil, nicht Raute) ..."

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRuleAntiPatterns1.java
Patch:
@@ -38,13 +38,13 @@ class AgreementRuleAntiPatterns1 {
     Arrays.asList(
       posRegex("PRO.*"),  // "Es gibt viele Stock Screener."
       posRegex("SUB:.*"),
-      new PatternTokenBuilder().pos("UNKNOWN").tokenRegex("[A-ZÖÄÜ][a-zöäß-]+").build()
+      new PatternTokenBuilder().pos("UNKNOWN").csTokenRegex("[A-ZÖÄÜ][a-zöäß-]+").build()
     ),
     Arrays.asList(
       posRegex("PRO.*"),  // "Es gibt viele verschiedene Stock Screener."
       posRegex("(ADJ|PA2).*"),
       posRegex("SUB:.*"),
-      new PatternTokenBuilder().pos("UNKNOWN").tokenRegex("[A-ZÖÄÜ][a-zöäß-]+").build()
+      new PatternTokenBuilder().pos("UNKNOWN").csTokenRegex("[A-ZÖÄÜ][a-zöäß-]+").build()
     ),
     Arrays.asList(
       tokenRegex("[(\\[]"),   // "... (ich meine Pfeil, nicht Raute) ..."

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -600,6 +600,8 @@ public void testDetNounRule() throws IOException {
     assertGood("Gelingt das mit Erregern rechtzeitig, könnte das Infektionen sogar oft verhindern.");
     assertGood("In der aktuellen Niedrigzinsphase bedeutet das sehr geringe Zinsen, die aber deutlich ansteigen können.");
     assertGood("Es gibt viele Stock Screener.");
+    assertBad("Auf dieser Website werden allerdings keine solche Daten weiterverxxx.");  // "weiterverxxx" = unbekanntes Wort
+    assertBad("Bei größeren Gruppen und/oder mehrere Tagen gibts einen nennenswerten Nachlass.");
     // TODO: not yet detected:
     //assertBad("Erst recht wir fleißiges Arbeiter.");
     //assertBad("Erst recht ich fleißiges Arbeiter.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanStyleRepeatedWordRule.java
Patch:
@@ -68,7 +68,7 @@ public String getDescription() {
   
   @Override
   protected String messageSameSentence() {
-    return "Mögliches Stilproblem: Das Wort wird bereits im selben Satz verwendet.";
+    return "Mögliches Stilproblem: Das Wort wird noch einmal im selben Satz verwendet.";
   }
   
   @Override
@@ -78,7 +78,7 @@ protected String messageSentenceBefore() {
   
   @Override
   protected String messageSentenceAfter() {
-    return "Mögliches Stilproblem: Das Wort wird bereits in einem nachfolgenden Satz verwendet.";
+    return "Mögliches Stilproblem: Das Wort wird auch in einem nachfolgenden Satz verwendet.";
   }
 
   /**

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanStyleRepeatedWordRule.java
Patch:
@@ -123,14 +123,14 @@ protected boolean isTokenPair(AnalyzedTokenReadings[] tokens, int n, boolean bef
     if (before) {
       if ((tokens[n-2].hasPosTagStartingWith("SUB") && tokens[n-1].hasPosTagStartingWith("PRP")
               && tokens[n].hasPosTagStartingWith("SUB"))
-          || (!tokens[n-2].getToken().equals("hart") && !tokens[n-1].getToken().equals("auf") && !tokens[n].getToken().equals("hart"))
+          || (tokens[n-2].getToken().equals("hart") && tokens[n-1].getToken().equals("auf") && tokens[n].getToken().equals("hart"))
          ) {
         return true;
       }
     } else {
       if ((tokens[n].hasPosTagStartingWith("SUB") && tokens[n+1].hasPosTagStartingWith("PRP")
               && tokens[n+2].hasPosTagStartingWith("SUB"))
-          || (!tokens[n].getToken().equals("hart") && !tokens[n-1].getToken().equals("auf") && !tokens[n + 2].getToken().equals("hart"))
+          || (tokens[n].getToken().equals("hart") && tokens[n+1].getToken().equals("auf") && tokens[n + 2].getToken().equals("hart"))
          ) {
         return true;
       }

File: languagetool-http-client/src/main/java/org/languagetool/remote/ArtificialErrorEval.java
Patch:
@@ -56,7 +56,7 @@ public class ArtificialErrorEval {
   static RemoteLanguageTool lt;
   static JLanguageTool localLt;
   static Synthesizer synth;
-  static int maxLines = 2000;//1000000; // decrease this number for testing
+  static int maxLines = 1000000; // decrease this number for testing
   static boolean verboseOutput = false;
   static boolean undirectional = false;
   static boolean inflected = false;

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -441,8 +441,9 @@ public void testRule() throws IOException {
     assertGood("4.)   Bei Beschäftigung von Hilfskräften: Schadenfälle durch Hilfskräfte");
     assertGood("Es besteht aus Schülern, Arbeitstätigen und Studenten.");
     assertGood("Sie starrt ständig ins Nichts.");
-    assertGood("\\u2063Das Haus ist schlön.");
-    assertGood("\\u2063\\u2063Das Haus ist schlön.");
+    assertGood("Sowas aber auch.\u2063Das Haus ist schön.");
+    assertGood("\u2063Das Haus ist schön.");
+    assertGood("\u2063\u2063Das Haus ist schön.");
     assertGood("Die Mannschaft ist eine gelungene Mischung aus alten Haudegen und jungen Wilden.");
     assertGood("Alleine durch die bloße Einwohnerzahl des Landes leben im Land zahlreiche Kulturschaffende, nach einer Schätzung etwa 30.000 Künstler.");
     assertGood("Ich hatte das offenbar vergessen oder nicht ganz verstanden.");

File: languagetool-server/src/main/java/org/languagetool/server/GRPCServer.java
Patch:
@@ -50,6 +50,7 @@ public void analyze(org.languagetool.rules.ml.MLServerProto.AnalyzeRequest reque
         .addAllSentences(sentences.stream().map(GRPCUtils::toGRPC).collect(Collectors.toList()))
         .build();
       responseObserver.onNext(response);
+      responseObserver.onCompleted();
     } catch (Exception e) {
       log.warn("Analyze request failed", e);
       responseObserver.onError(e);
@@ -75,6 +76,7 @@ public void process(org.languagetool.rules.ml.MLServerProto.ProcessRequest reque
         .addAllMatches(results.getRuleMatches().stream().map(GRPCUtils::toGRPC).collect(Collectors.toList()))
         .build();
       responseObserver.onNext(response);
+      responseObserver.onCompleted();
     } catch (Exception e) {
       log.warn("Process request failed", e);
       responseObserver.onError(e);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -101,6 +101,9 @@ public void testSplitWords() throws IOException {
     matches = rule.match(lt.getAnalyzedSentence("Gibt es einen grund, dass…"));
     assertThat(matches.length, is(1));
     assertThat(matches[0].getSuggestedReplacements().get(0), is("Grund"));
+    
+    matches = rule.match(lt.getAnalyzedSentence("Kryptomarktplatzes"));
+    assertThat(matches.length, is(0));
   }
 
   @Test

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -99,6 +99,8 @@ public GermanCompoundTokenizer(boolean strictMode) throws IOException {
     wordSplitter.addException("Erziehungstrick", asList("Erziehungs", "trick"));
     wordSplitter.addException("Erziehungstricks", asList("Erziehungs", "tricks"));
     wordSplitter.addException("karamelligen", asList("karamelligen"));  // != Karamel+Ligen
+    wordSplitter.addException("Häkelnadel", asList("Häkel", "nadel"));
+    wordSplitter.addException("Häkelnadeln", asList("Häkel", "nadeln"));
     wordSplitter.setStrictMode(strictMode);
     wordSplitter.setMinimumWordLength(3);
   }

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java
Patch:
@@ -72,7 +72,7 @@ public abstract class AbstractEnglishSpellerRule extends MorfologikSpellerRule {
     "hard coded",
     "hands free",
     "in flight",
-    "in car#",
+    "in car",
     "client side",
     "server side",
     "in house",

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternTokenBuilder.java
Patch:
@@ -152,11 +152,9 @@ public PatternTokenBuilder matchInflectedForms() {
   
   public PatternToken build() {
     PatternToken patternToken;
+    patternToken = new PatternToken(token, caseSensitive, regexp, matchInflectedForms);
     if (posTag != null) {
-      patternToken = new PatternToken(null, false, false, false);
       patternToken.setPosToken(new PatternToken.PosToken(posTag, regexp, false));
-    } else {
-      patternToken = new PatternToken(token, caseSensitive, regexp, matchInflectedForms);
     }
     if (isWhiteSpaceSet) {
       patternToken.setWhitespaceBefore(isWhiteSpaceBefore);

File: languagetool-core/src/main/java/org/languagetool/language/identifier/detector/CommonWordsDetector.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package org.languagetool.language;
+package org.languagetool.language.identifier.detector;
 
 import org.apache.commons.lang3.StringUtils;
 import org.languagetool.*;
@@ -30,7 +30,7 @@
  * Information about common words - use as a fallback if language identification yields low confidence.
  * @since 4.4
  */
-public class CommonWords {
+public class CommonWordsDetector {
 
   private final static Map<String, List<Language>> word2langs = Collections.synchronizedMap(new HashMap<>());
   private final static Pattern numberPattern = Pattern.compile("[0-9.,%-]+");
@@ -44,7 +44,7 @@ public class CommonWords {
   private final static Pattern notCatalanPattern = Pattern.compile("^.*([áéó].i[oa]s?|d[oa]s)$|^.*[áâêôãõìùñ].*$");
   private final static Pattern portuguesePattern = Pattern.compile("^.*([áó]ri[oa]|ério)s?$"); // éria can be French
   
-  public CommonWords() throws IOException {
+  public CommonWordsDetector() throws IOException {
     synchronized (word2langs) {
       if (word2langs.isEmpty()) {
         for (Language lang : Languages.get()) {

File: languagetool-core/src/test/java/org/languagetool/language/identifier/detector/UnicodeBasedLangIdentifierTest.java
Patch:
@@ -16,16 +16,17 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package org.languagetool.language;
+package org.languagetool.language.identifier.detector;
 
 import org.junit.Test;
+import org.languagetool.language.identifier.detector.UnicodeBasedDetector;
 
 import static org.junit.Assert.*;
 import static org.hamcrest.CoreMatchers.is;
 
 public class UnicodeBasedLangIdentifierTest {
 
-  private final UnicodeBasedLangIdentifier ident = new UnicodeBasedLangIdentifier(100);
+  private final UnicodeBasedDetector ident = new UnicodeBasedDetector(100);
 
   @Test
   public void testGetDominantLangCodes() {

File: languagetool-dev/src/main/java/org/languagetool/dev/FilterFileByLanguage.java
Patch:
@@ -19,7 +19,8 @@
 package org.languagetool.dev;
 
 import org.languagetool.DetectedLanguage;
-import org.languagetool.language.LanguageIdentifier;
+import org.languagetool.language.identifier.LanguageIdentifier;
+import org.languagetool.language.identifier.LanguageIdentifierService;
 
 import java.io.File;
 import java.io.FileWriter;
@@ -41,8 +42,7 @@ public static void main(String[] args) throws IOException {
     String expectedLang = args[0];
     File input = new File(args[1]);
     File output = new File(input.getAbsoluteFile() + ".filtered");
-    LanguageIdentifier ident = new LanguageIdentifier();
-    ident.enableFasttext(new File(fastTextBinary), new File(fastTextModel));
+    LanguageIdentifier ident = LanguageIdentifierService.INSTANCE.getDefaultLanguageIdentifier(0, null, new File(fastTextBinary), new File(fastTextModel));
     Scanner sc = new Scanner(input);
     int skipCount = 0;
     try (FileWriter fw = new FileWriter(output)) {

File: languagetool-dev/src/main/java/org/languagetool/dev/NGramLangIdentifierPerformanceTest.java
Patch:
@@ -18,7 +18,7 @@
  */
 package org.languagetool.dev;
 
-import org.languagetool.language.NGramLangIdentifier;
+import org.languagetool.language.identifier.detector.NGramDetector;
 
 import java.io.File;
 import java.io.IOException;
@@ -37,7 +37,7 @@ public class NGramLangIdentifierPerformanceTest {
 
   public void testPerformance() throws IOException {
     System.out.println("Loading ngrams...");
-    NGramLangIdentifier ngram = new NGramLangIdentifier(ngramZip, 50);
+    NGramDetector ngram = new NGramDetector(ngramZip, 50);
     System.out.println("Loaded.");
     int i = 0;
     double totalMillis = 0;

File: languagetool-dev/src/test/java/org/languagetool/dev/eval/FastTextConfidenceEval.java
Patch:
@@ -20,7 +20,7 @@
 
 import com.google.common.io.CharStreams;
 import org.languagetool.Language;
-import org.languagetool.language.FastText;
+import org.languagetool.language.identifier.detector.FastTextDetector;
 
 import java.io.File;
 import java.io.IOException;
@@ -42,10 +42,10 @@ class FastTextConfidenceEval {
   private static final File MODEL_PATH = new File("/prg/fastText-0.1.0/data/lid.176.bin");
   private static final File BINARY_PATH = new File("/prg/fastText-0.1.0/fasttext");
 
-  private final FastText ft;
+  private final FastTextDetector ft;
 
   private FastTextConfidenceEval() throws IOException {
-    ft = new FastText(MODEL_PATH, BINARY_PATH);
+    ft = new FastTextDetector(MODEL_PATH, BINARY_PATH);
   }
 
   private void evaluate(Language language) throws IOException {

File: languagetool-dev/src/test/java/org/languagetool/dev/eval/LanguageDetectionEval.java
Patch:
@@ -21,9 +21,9 @@
 import com.google.common.io.CharStreams;
 import org.languagetool.Language;
 import org.languagetool.Languages;
-import org.languagetool.language.LanguageIdentifier;
+import org.languagetool.language.identifier.LanguageIdentifier;
+import org.languagetool.language.identifier.LanguageIdentifierService;
 
-import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -44,7 +44,7 @@ class LanguageDetectionEval {
   private int totalInputs = 0;
 
   private LanguageDetectionEval() {
-    languageIdentifier = new LanguageIdentifier();
+    languageIdentifier = LanguageIdentifierService.INSTANCE.getDefaultLanguageIdentifier(0, null, null, null);
     //languageIdentifier.enableFasttext(new File("/path/to/fasttext/binary"), new File("/path/to/fasttext/model"));
     // Daniel's paths:
     //languageIdentifier.enableFasttext(new File("/home/languagetool/fasttext/fasttext"), new File("/home/languagetool/fasttext/lid.176.bin"));

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerDefaultLanguageIdentifierTest.java
Patch:
@@ -31,7 +31,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 @Ignore("for interactive use; requires local Tatoeba data")
-public class HTTPServerLanguageIdentifierTest extends HTTPServerMultiLangLoadTest {
+public class HTTPServerDefaultLanguageIdentifierTest extends HTTPServerMultiLangLoadTest {
 
   private static final int TOTAL_REPEATS = 150;
   private final ObjectMapper mapper = new ObjectMapper();

File: languagetool-standalone/src/test/java/org/languagetool/language/CommonWordsTest.java
Patch:
@@ -21,6 +21,7 @@
 import org.junit.Test;
 import org.languagetool.Language;
 import org.languagetool.Languages;
+import org.languagetool.language.identifier.detector.CommonWordsDetector;
 
 import java.io.IOException;
 import java.util.Map;
@@ -38,7 +39,7 @@ public void test() throws IOException {
     Language es = Languages.getLanguageForShortCode("es");
     Language pt = Languages.getLanguageForShortCode("pt");
     Language ca = Languages.getLanguageForShortCode("ca");
-    CommonWords cw = new CommonWords();
+    CommonWordsDetector cw = new CommonWordsDetector();
 
     Map<Language, Integer> res1 = cw.getKnownWordsPerLanguage("Das ist bequem");
     assertNull(res1.get(en));

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -1550,6 +1550,9 @@ boolean testDocLanguage(boolean showMessage) {
         return true;
       } else {
         resetCheck();
+        if (showMessage) {
+          MessageHandler.showMessage(messages.getString("loNoGrammarCheckWarning"));
+        }
         return false;
       }
     }

File: languagetool-core/src/main/java/org/languagetool/MultiThreadedJLanguageTool.java
Patch:
@@ -81,7 +81,7 @@ public MultiThreadedJLanguageTool(Language language, Language motherTongue, User
    */
   public MultiThreadedJLanguageTool(Language language, Language motherTongue, int threadPoolSize,
       UserConfig userConfig) {
-    this(language, motherTongue, -1,null, userConfig);
+    this(language, motherTongue, threadPoolSize, null, userConfig);
   }
 
   /**

File: languagetool-language-modules/en/src/test/java/org/languagetool/chunking/EnglishChunkerTest.java
Patch:
@@ -49,10 +49,10 @@ public void testAddChunkTags() throws Exception {
     assertThat(readingsList.get(0).getChunkTags().toString(), is("[B-NP-singular]"));
     assertThat(readingsList.get(2).getChunkTags().toString(), is("[I-NP-singular]"));
     assertThat(readingsList.get(4).getChunkTags().toString(), is("[E-NP-singular]"));
-    // "the chunker":
+    // "the bicycle":
     assertThat(readingsList.get(8).getChunkTags().toString(), is("[B-NP-singular]"));
     assertThat(readingsList.get(10).getChunkTags().toString(), is("[E-NP-singular]"));
-    // "is"
+    // "is needed"
     assertThat(readingsList.get(12).getChunkTags().toString(), is("[B-VP]"));
     assertThat(readingsList.get(14).getChunkTags().toString(), is("[I-VP]"));
   }

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseReplaceRule.java
Patch:
@@ -54,8 +54,8 @@ public PortugueseReplaceRule(ResourceBundle messages) {
     super(messages);
     super.setCategory(Categories.STYLE.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.LocaleViolation);
-    addExamplePair(Example.wrong("<marker>device</marker>"),
-                   Example.fixed("<marker>dispositivo</marker>"));
+    /*addExamplePair(Example.wrong("<marker>device</marker>"),
+                   Example.fixed("<marker>dispositivo</marker>"));*/
   }
 
   @Override

File: languagetool-http-client/src/test/java/org/languagetool/remote/CheckConfigurationTest.java
Patch:
@@ -30,7 +30,7 @@ public class CheckConfigurationTest {
   @Test
   public void test() {
     CheckConfiguration config = new CheckConfiguration("en", null, false, 
-            Collections.emptyList(), false, Collections.emptyList(), null, null, Collections.emptyList());
+                                                       Collections.emptyList(), false, Collections.emptyList(), null, null, Collections.emptyList(), null);
     assertThat(config.getLangCode().get(), is("en"));
     assertNull(config.getMotherTongueLangCode());
     assertThat(config.getEnabledRuleIds().size(), is(0));
@@ -42,7 +42,7 @@ public void test() {
   @SuppressWarnings("ResultOfObjectAllocationIgnored")
   @Test(expected = IllegalArgumentException.class)
   public void testNull() {
-    new CheckConfiguration(null, null, false, null, false, null, null, null, null);
+    new CheckConfiguration(null, null, false, null, false, null, null, null, null, null);
   }
 
 }

File: languagetool-http-client/src/main/java/org/languagetool/remote/RemoteLanguageTool.java
Patch:
@@ -102,6 +102,9 @@ private String getUrlParams(String text, CheckConfiguration config) {
     if (config.getRuleValues().size() > 0) {
       append(params, "ruleValues", String.join(",", config.getRuleValues()));
     }
+    if (config.getTextSessionID() != null) {
+      append(params, "textSessionId", config.getTextSessionID());
+    }
     append(params, "useragent", "java-http-client");
     return params.toString();
   }

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -245,6 +245,7 @@ protected int getPriorityForId(String id) {
       case "AGREEMENT_PARTICIPLE_NOUN": return -30;
       case "AGREEMENT_POSTPONED_ADJ": return -30;
       case "MULTI_ADJ": return -30;
+      case "SUBJUNTIVO_INCORRECTO": return -40;
       case "COMMA_SINO": return -40;
       case "VOSEO": return -40;
       case "REPETITIONS_STYLE": return -50;

File: languagetool-core/src/main/java/org/languagetool/rules/PunctuationMarkAtParagraphEnd.java
Patch:
@@ -113,6 +113,9 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
           if (n==1 && isNumeric(sentences.get(0).getText())) {
             ignoreSentence = true;
           }
+          if (n > 0 && isNumeric(sentences.get(n - 1).getText())) {
+            ignoreSentence = true;
+          }
           // paragraphs containing less than two sentences (e.g. headlines, listings) are excluded from rule
           if (n - lastPara > 1 && isFirstWord && !ignoreSentence) {
             int lastNWToken = tokens.length - 1;

File: languagetool-core/src/test/java/org/languagetool/rules/PunctuationMarkAtParagraphEnd2Test.java
Patch:
@@ -38,6 +38,7 @@ public void test() throws IOException {
     PunctuationMarkAtParagraphEnd2 rule = new PunctuationMarkAtParagraphEnd2(TestTools.getEnglishMessages(), TestTools.getDemoLanguage());
     rule.setDefaultOn();
     lt.addRule(rule);
+    assertEquals(0, lt.check("2. This is an item in a list").size());
     assertEquals(0, lt.check("2.2.2. This is an item in a list").size());
     assertThat(lt.check("This is a test.").size(), is(0));
     assertThat(lt.check("This is a test").size(), is(0));  // too short

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/DateFilterHelper.java
Patch:
@@ -61,7 +61,7 @@ protected int getMonth(String monthStr) {
     String mon = monthStr.toLowerCase();
     if (mon.startsWith("en")) return 1;
     if (mon.startsWith("fe")) return 2;
-    if (mon.startsWith("ma") || mon.startsWith("mzo")) return 3;
+    if (mon.startsWith("mar") || mon.startsWith("mzo")) return 3;
     if (mon.startsWith("ab")) return 4;
     if (mon.startsWith("may") || mon.startsWith("my")) return 5;
     if (mon.startsWith("jun") || mon.equals("jn")) return 6;

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -230,6 +230,7 @@ protected int getPriorityForId(String id) {
       case "AGREEMENT_DET_ADJ": return 10;
       case "HALLA_HAYA": return 10;
       case "VALLA_VAYA": return 10;
+      case "SI_AFIRMACION": return 10; // less than DIACRITICS
       case "TE_TILDE2": return 10; // less than PRONOMBRE_SIN_VERBO
       case "SINGLE_CHARACTER": return 5;
       case "SEPARADO": return 1;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -642,6 +642,7 @@ public QueueEntry getQueueEntryForChangedParagraph() {
    */
   public void runQueueEntry(TextParagraph nStart, TextParagraph nEnd, int cacheNum, int nCheck, boolean override, SwJLanguageTool lt) {
     if (!disposed && flatPara != null && docCache.isFinished() && nStart.number < docCache.textSize(nStart)) {
+      MessageHandler.printToLogFile("SingleDocument: runQueueEntry");
       SingleCheck singleCheck = new SingleCheck(this, paragraphsCache, docCursor, flatPara, docLanguage, ignoredMatches, numParasToCheck, false, false, false);
       singleCheck.addParaErrorsToCache(docCache.getFlatParagraphNumber(nStart), lt, cacheNum, nCheck, 
           nEnd.number == nStart.number + 1, override, false, hasFootnotes);

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -937,11 +937,12 @@ public List<RuleMatch> check(AnnotatedText annotatedText, boolean tokenizeText,
 
   public CheckResults check2(AnnotatedText annotatedText, boolean tokenizeText, ParagraphHandling paraMode, RuleMatchListener listener,
                              Mode mode, Level level, @Nullable Long textSessionID) throws IOException {
+    List<String> unmodifiedSentences = getSentences(annotatedText, tokenizeText);
     annotatedText = cleanText(annotatedText);
     List<String> sentences = getSentences(annotatedText, tokenizeText);
     List<AnalyzedSentence> analyzedSentences = analyzeSentences(sentences);
     CheckResults checkResults = checkInternal(annotatedText, paraMode, listener, mode, level, textSessionID, sentences, analyzedSentences);
-    checkResults.setSentenceRanges(sentences);
+    checkResults.addSentenceRanges(SentenceRange.getRangesFromSentences(unmodifiedSentences));
     return checkResults;
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -76,7 +76,8 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     "rassejude", "rassejuden", "rassejüdin", "rassejüdinnen",
     "möse", "mösen", "fotze", "fotzen",
     "judenfrei", "judenfreie", "judenfreier", "judenfreies", "judenfreien", "judenfreiem",
-    "judenrein", "judenreine", "judenreiner", "judenreines", "judenreinen", "judenreinem"
+    "judenrein", "judenreine", "judenreiner", "judenreines", "judenreinen", "judenreinem",
+    "judenmord", "judenmorden", "judenmörder"
   ));
   
   // some exceptions for changes to the spelling in 2017 - just a workaround so we don't have to touch the binary dict:

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServerConfig.java
Patch:
@@ -189,7 +189,7 @@ public void setRestrictManagedAccounts(boolean restrictManagedAccounts) {
     "keystore", "password", "maxTextLengthPremium", "maxTextLengthAnonymous", "maxTextLengthLoggedIn", "gracefulDatabaseFailure",
     "ngramLangIdentData",
     "dbTimeoutSeconds", "dbErrorRateThreshold", "dbTimeoutRateThreshold", "dbDownIntervalSeconds",
-    "redisUseSSL", "redisTimeoutMilliseconds", "redisConnectionTimeoutMilliseconds",
+    "redisDatabase", "redisUseSSL", "redisTimeoutMilliseconds", "redisConnectionTimeoutMilliseconds",
     "anonymousAccessAllowed",
     "premiumAlways",
     "redisPassword", "redisHost", "redisCertificate", "redisKey", "redisKeyPassword",

File: languagetool-core/src/main/java/org/languagetool/language/LanguageIdentifier.java
Patch:
@@ -280,8 +280,8 @@ public DetectedLanguage detectLanguage(String cleanText, List<String> noopLangsT
             } else {
               scores.put(langCode, Double.valueOf(entry.getValue()));
             }
-            source += "+ngram";
           }
+          source += "+commonwords";
           result = getHighestScoringResult(scores);
         }
         if (preferredLangs.contains("no") && !preferredLangs.contains("da")) {

File: languagetool-core/src/main/java/org/languagetool/tools/RuleMatchesAsJsonSerializer.java
Patch:
@@ -167,6 +167,7 @@ private void writeLanguageSection(JsonGenerator g, DetectedLanguage detectedLang
     if (detectedLang.getDetectedLanguage().isSpellcheckOnlyLanguage()) {
       g.writeBooleanField("spellCheckOnly", true);
     }
+    g.writeStringField("source", detectedLang.getDetectionSource());
     g.writeEndObject();
     g.writeEndObject();
   }

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -886,7 +886,8 @@ DetectedLanguage detectLanguageOfString(String text, String fallbackLanguage, Li
         lang = lang.getDefaultLanguageVariant();
       }
     }
-    return new DetectedLanguage(null, lang, detected != null ? detected.getDetectionConfidence() : 0f);
+    return new DetectedLanguage(null, lang, detected != null ? detected.getDetectionConfidence() : 0f,
+      detected != null ? detected.getDetectionSource() : null);
   }
 
   static class QueryParams {

File: languagetool-server/src/main/java/org/languagetool/server/V2TextChecker.java
Patch:
@@ -109,7 +109,8 @@ protected DetectedLanguage getLanguage(String text, Map<String, String> paramete
     } else {
       givenLang = parseLanguage(langParam);
     }
-    return new DetectedLanguage(givenLang, detectedLang.getDetectedLanguage(), detectedLang.getDetectionConfidence());
+    return new DetectedLanguage(givenLang, detectedLang.getDetectedLanguage(), detectedLang.getDetectionConfidence(),
+      detectedLang.getDetectionSource());
   }
 
   @Override

File: languagetool-language-modules/pt/src/main/java/org/languagetool/tagging/pt/PortugueseTagger.java
Patch:
@@ -113,7 +113,7 @@ public List<AnalyzedTokenReadings> tag(List<String> sentenceTokens) {
   protected List<AnalyzedToken> additionalTags(String word, IStemmer stemmer) {
     IStemmer dictLookup = new DictionaryLookup(getDictionary());
     List<AnalyzedToken> additionalTaggedTokens = new ArrayList<>();
-    //Any well-formed adverb with suffix -mente is tagged as an adverb of manner (RM)
+    //Any well-formed adverb with suffix -mente is tagged as an adverb of manner (RG)
     if (word.endsWith("mente")){
       String lowerWord = word.toLowerCase(locale);
       String possibleAdj = lowerWord.replaceAll("^(.+)mente$", "$1");
@@ -124,7 +124,7 @@ protected List<AnalyzedToken> additionalTags(String word, IStemmer stemmer) {
         if (posTag != null) {
           Matcher m = ADJ_PART_FS.matcher(posTag);
           if (m.matches()) {
-            additionalTaggedTokens.add(new AnalyzedToken(word, "RM", lowerWord));
+            additionalTaggedTokens.add(new AnalyzedToken(word, "RG", lowerWord));
             return additionalTaggedTokens;
           }
         }

File: languagetool-language-modules/pt/src/test/java/org/languagetool/tagging/pt/PortugueseTaggerTest.java
Patch:
@@ -45,14 +45,14 @@ public void testDictionary() throws IOException {
   @Test
   public void testTagger() throws IOException {
     TestTools.myAssert("Estes são os meus amigos.",
-        "Estes/[este]DD0MP0|Estes/[este]PD0MP000 -- "
+        "Estes/[este]AQ0CP0|Estes/[este]DD0MP0|Estes/[este]NCMP000|Estes/[este]PD0MP000 -- "
             + "são/[ser]VMIP3P0|são/[são]AQ0MS0|são/[são]NCMS000 -- "
             + "os/[o]DA0MP0|os/[o]PD0MP000|os/[o]PP3MPA00 -- "
             + "meus/[meu]AP0MP1S|meus/[meu]DP1MPS -- "
             + "amigos/[amigo]AQ0MP0|amigos/[amigo]NCMP000", tokenizer, tagger);
     
     TestTools.myAssert("tentou resolver",
-        "tentou/[tentar]VMIS3S0 -- resolver/[resolver]VMN0000|resolver/[resolver]VMSF1S0|resolver/[resolver]VMSF3S0"
+        "tentou/[tentar]VMIS3S0 -- resolver/[resolver]VMN0000|resolver/[resolver]VMN01S0|resolver/[resolver]VMN03S0|resolver/[resolver]VMSF1S0|resolver/[resolver]VMSF3S0"
         , tokenizer, tagger);
   }
 }

File: languagetool-standalone/src/test/java/org/languagetool/language/CommonWordsTest.java
Patch:
@@ -54,8 +54,7 @@ public void test() throws IOException {
 
     Map<Language, Integer> res4 = cw.getKnownWordsPerLanguage("this is a test");
     assertThat(res4.get(en), is(3));
-    assertThat(res4.get(de), is(1));
-    
+
     Map<Language, Integer> res5 = cw.getKnownWordsPerLanguage("Ideábamos una declaracion con el.");
     assertThat(res5.get(es), is(5));
     

File: languagetool-core/src/main/java/org/languagetool/language/CommonWords.java
Patch:
@@ -119,6 +119,7 @@ public Map<Language, Integer> getKnownWordsPerLanguage(String text) {
       List<Language> languages = word2langs.get(lcWord);
       if (languages != null) {
         for (Language lang : languages) {
+          //System.out.println(lcWord + " -> " + lang);
           result.put(lang, result.getOrDefault(lang, 0) + 1);
         }
       }
@@ -138,6 +139,7 @@ public Map<Language, Integer> getKnownWordsPerLanguage(String text) {
         result.put(caLang, result.getOrDefault(caLang, 0) - 1);
       }
     }
+    //System.out.println("==> " + result);
     return result;
   }
   

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServerConfig.java
Patch:
@@ -254,8 +254,9 @@ public HTTPServerConfig(int serverPort, boolean verbose) {
         case "--allow-origin":
           try {
             allowOriginUrl = args[++i];
-            if (allowOriginUrl.startsWith("--")) {
+            if (allowOriginUrl.startsWith("--")) {  // no parameter, next option starts instead
               allowOriginUrl = "*";
+              i--;
             }
           } catch (ArrayIndexOutOfBoundsException e) {
             allowOriginUrl = "*";

File: languagetool-language-modules/pl/src/test/java/org/languagetool/rules/pl/MorfologikPolishSpellerRuleTest.java
Patch:
@@ -91,7 +91,7 @@ public void testMorfologikSpeller() throws IOException {
 
     final RuleMatch[] prunedMatches = rule.match(lt.getAnalyzedSentence("Clarkem"));
     assertEquals(1, prunedMatches.length);
-    assertEquals(5, prunedMatches[0].getSuggestedReplacements().size());
+    assertEquals(6, prunedMatches[0].getSuggestedReplacements().size());
     assertEquals("Clarke", prunedMatches[0].getSuggestedReplacements().get(0));
     assertEquals("Clarkiem", prunedMatches[0].getSuggestedReplacements().get(1));
     assertEquals("Ciarkę", prunedMatches[0].getSuggestedReplacements().get(2));

File: languagetool-language-modules/pl/src/test/java/org/languagetool/rules/pl/PolishTest.java
Patch:
@@ -33,7 +33,7 @@ public void testLanguage() throws IOException {
     String s = "Wpisz tekst lub użyj istniejącego przykładu. To jest przykładowy tekst który pokazuje, jak jak działa LanguageTool. LanguageTool ma jusz korektor psowni, który wyrurznia bledy na czewrono.";
     Polish lang = new Polish();
     testDemoText(lang, s,
-      Arrays.asList("BRAK_PRZECINKA_KTORY", "WORD_REPEAT_RULE", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL")
+      Arrays.asList("BRAK_PRZECINKA_KTORY", "WORD_REPEAT_RULE", "PL_SIMPLE_REPLACE", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL")
     );
     runTests(lang, null, "ą");
   }

File: languagetool-language-modules/pl/src/test/java/org/languagetool/rules/pl/MorfologikPolishSpellerRuleTest.java
Patch:
@@ -91,7 +91,7 @@ public void testMorfologikSpeller() throws IOException {
 
     final RuleMatch[] prunedMatches = rule.match(lt.getAnalyzedSentence("Clarkem"));
     assertEquals(1, prunedMatches.length);
-    assertEquals(6, prunedMatches[0].getSuggestedReplacements().size());
+    assertEquals(5, prunedMatches[0].getSuggestedReplacements().size());
     assertEquals("Clarke", prunedMatches[0].getSuggestedReplacements().get(0));
     assertEquals("Clarkiem", prunedMatches[0].getSuggestedReplacements().get(1));
     assertEquals("Ciarkę", prunedMatches[0].getSuggestedReplacements().get(2));

File: languagetool-language-modules/pl/src/test/java/org/languagetool/rules/pl/PolishTest.java
Patch:
@@ -33,7 +33,7 @@ public void testLanguage() throws IOException {
     String s = "Wpisz tekst lub użyj istniejącego przykładu. To jest przykładowy tekst który pokazuje, jak jak działa LanguageTool. LanguageTool ma jusz korektor psowni, który wyrurznia bledy na czewrono.";
     Polish lang = new Polish();
     testDemoText(lang, s,
-      Arrays.asList("BRAK_PRZECINKA_KTORY", "WORD_REPEAT_RULE", "PL_SIMPLE_REPLACE", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL")
+      Arrays.asList("BRAK_PRZECINKA_KTORY", "WORD_REPEAT_RULE", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL")
     );
     runTests(lang, null, "ą");
   }

File: languagetool-language-modules/pl/src/test/java/org/languagetool/rules/pl/MorfologikPolishSpellerRuleTest.java
Patch:
@@ -91,7 +91,7 @@ public void testMorfologikSpeller() throws IOException {
 
     final RuleMatch[] prunedMatches = rule.match(lt.getAnalyzedSentence("Clarkem"));
     assertEquals(1, prunedMatches.length);
-    assertEquals(5, prunedMatches[0].getSuggestedReplacements().size());
+    assertEquals(6, prunedMatches[0].getSuggestedReplacements().size());
     assertEquals("Clarke", prunedMatches[0].getSuggestedReplacements().get(0));
     assertEquals("Clarkiem", prunedMatches[0].getSuggestedReplacements().get(1));
     assertEquals("Ciarkę", prunedMatches[0].getSuggestedReplacements().get(2));

File: languagetool-language-modules/pl/src/test/java/org/languagetool/rules/pl/PolishTest.java
Patch:
@@ -33,7 +33,7 @@ public void testLanguage() throws IOException {
     String s = "Wpisz tekst lub użyj istniejącego przykładu. To jest przykładowy tekst który pokazuje, jak jak działa LanguageTool. LanguageTool ma jusz korektor psowni, który wyrurznia bledy na czewrono.";
     Polish lang = new Polish();
     testDemoText(lang, s,
-      Arrays.asList("BRAK_PRZECINKA_KTORY", "WORD_REPEAT_RULE", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL")
+      Arrays.asList("BRAK_PRZECINKA_KTORY", "WORD_REPEAT_RULE", "PL_SIMPLE_REPLACE", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL")
     );
     runTests(lang, null, "ą");
   }

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -230,7 +230,8 @@ public enum Mode {
 
   public enum Level {
     DEFAULT,
-    PICKY
+    PICKY,
+    ACADEMIC
   }
 
   private static final List<File> temporaryFiles = new ArrayList<>();

File: languagetool-core/src/main/java/org/languagetool/Tag.java
Patch:
@@ -21,6 +21,6 @@
 public enum Tag {
 
   // use all-lowercase, as im XML:
-  picky
+  picky, academic
 
 }

File: languagetool-server/src/main/java/org/languagetool/server/ServerTools.java
Patch:
@@ -201,6 +201,8 @@ static JLanguageTool.Level getLevel(Map<String, String> params) {
         level = JLanguageTool.Level.DEFAULT;
       } else if ("picky".equals(param)) {
         level = JLanguageTool.Level.PICKY;
+      } else if ("academic".equals(param)) {
+        level = JLanguageTool.Level.ACADEMIC;
       } else {
         throw new BadRequestException("If 'level' is set, it must be set to 'default' or 'picky'");
       }

File: languagetool-http-client/src/test/java/org/languagetool/remote/ArtificialErrorEval.java
Patch:
@@ -225,7 +225,8 @@ private static List<String> ruleIDsAtPos(List<RemoteRuleMatch> matchesCorrect, i
         boolean containsDesiredSuggestion = false;
         if (replacements != null) {
           for (String replacement : replacements) {
-            if (replacement.contains(expectedSuggestion.strip())) {
+            // FIXME; if (replacement.contains(expectedSuggestion.strip())) {
+            if (replacement.contains(expectedSuggestion.trim())) {
               containsDesiredSuggestion = true;
             }
           } 

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -329,7 +329,7 @@ protected void testRegexSyntax(Language lang, List<AbstractPatternRule> rules) {
   protected void testMessages(Language lang, List<AbstractPatternRule> rules) {
     System.out.println("Checking messages for 'TBD' etc of " + rules.size() + " rules for " + lang + "...");
     for (AbstractPatternRule rule : rules) {
-      if (rule.isDefaultTempOff()) {
+      if (rule.isDefaultTempOff() || rule.isDefaultOff()) {
         continue;
       }
       String msg = rule.getMessage().trim();

File: languagetool-core/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -64,6 +64,8 @@ public class WordListValidatorTest {
           "Tromsø/S",
           "Solidarność",
           "Salihamidžić/S",
+          "Porošenko",
+          "Porošenko/S",
           "Darʿā",  // de
           "veni, vidi, vici", // en
           "Food+Tech Connect", // en

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/MorfologikCatalanSpellerRule.java
Patch:
@@ -40,7 +40,7 @@ public final class MorfologikCatalanSpellerRule extends MorfologikSpellerRule {
       "^(no|en|a|els?|als?|pels?|dels?|de|per|uns?|una|unes|la|les|[tms]eus?) (..+)$",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
   private static final Pattern PREFIX_AMB_ESPAI = Pattern.compile(
-      "^(tele|anti|re|des|avant|auto|ex|extra|macro|mega|meta|micro|multi|mono|mini|post|retro|semi|super|trans|pro|g) (..+)|.+ s$",
+      "^(eco|tele|anti|re|des|avant|auto|ex|extra|macro|mega|meta|micro|multi|mono|mini|post|retro|semi|super|trans|pro|g) (..+)|.+ s$",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
 
   private static final Pattern APOSTROF_INICI_VERBS = Pattern.compile("^([lnts])[90]?(h?[aeiouàéèíòóú].*)$",

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/MorfologikSpanishSpellerRule.java
Patch:
@@ -42,7 +42,7 @@
 public class MorfologikSpanishSpellerRule extends MorfologikSpellerRule {
 
   private static final Pattern PREFIX_WITH_WHITESPACE = Pattern.compile(
-      "^(tele|anti|auto|ex|extra|macro|mega|meta|micro|multi|mono|mini|post|retro|semi|super|hiper|trans|re|g) (..+)|.+ s$",
+      "^(eco|tele|anti|auto|ex|extra|macro|mega|meta|micro|multi|mono|mini|post|retro|semi|super|hiper|trans|re|g) (..+)|.+ s$",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
   private static final Pattern PARTICULA_FINAL = Pattern.compile("^(..+) (que|cual)$",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);

File: languagetool-http-client/src/test/java/org/languagetool/remote/ArtificialErrorEval.java
Patch:
@@ -203,8 +203,8 @@ private static List<String> ruleIDsAtPos(List<RemoteRuleMatch> matchesCorrect, i
         try {
           subId = match.getRuleSubId().get();
         } catch (NoSuchElementException e) {
-          System.out.println("Exception, skipping '" + countLine + "': ");
-          e.printStackTrace();
+          //System.out.println("Exception, skipping '" + countLine + "': ");
+          //e.printStackTrace();
         }
         if (subId != null) {
           ruleIDs.add(match.getRuleId() + "[" + match.getRuleSubId().get() + "]");

File: languagetool-core/src/main/java/org/languagetool/rules/GRPCPostProcessing.java
Patch:
@@ -19,6 +19,7 @@
 import org.jetbrains.annotations.Nullable;
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.Language;
+import org.languagetool.Premium;
 import org.languagetool.Tag;
 import org.languagetool.markup.AnnotatedText;
 import org.languagetool.rules.ml.MLServerProto;
@@ -210,7 +211,7 @@ private Match convertMatch(RuleMatch m) {
           .setId(m.getRule().getCategory().getId().toString())
           .setName(m.getRule().getCategory().getName())
           .build())
-        .setIsPremium(m.getRule().isPremium())
+        .setIsPremium(Premium.get().isPremiumRule(m.getRule()))
         .addAllTags(m.getRule().getTags().stream()
           .map(t -> MLServerProto.Rule.Tag.valueOf(t.name()))
           .collect(Collectors.toList()))

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1039,6 +1039,8 @@ private List<RuleMatch> filterMatches(AnnotatedText annotatedText, RuleSet rules
     }
     ruleMatches = new LanguageDependentFilter(language, rules).filter(ruleMatches);
 
+    ruleMatches = new GRPCRuleMatchFilter(language).filter(ruleMatches, annotatedText);
+
     return applyCustomFilters(ruleMatches, annotatedText);
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/tagging/de/GermanTagger.java
Patch:
@@ -252,6 +252,7 @@ public List<AnalyzedTokenReadings> tag(List<String> sentenceTokens, boolean igno
               }
             }
             if ("zu".equals(verbInfo.infix)) {
+              readings.clear();
               readings.add(new AnalyzedToken(word, "VER:EIZ:" + (isSFT ? "SFT" : "NON"), verbInfo.prefix + verbInfo.verbBaseform));
             }
           }

File: languagetool-core/src/test/java/org/languagetool/rules/PunctuationMarkAtParagraphEnd2Test.java
Patch:
@@ -38,6 +38,7 @@ public void test() throws IOException {
     PunctuationMarkAtParagraphEnd2 rule = new PunctuationMarkAtParagraphEnd2(TestTools.getEnglishMessages(), TestTools.getDemoLanguage());
     rule.setDefaultOn();
     lt.addRule(rule);
+    assertEquals(0, lt.check("2.2.2. This is an item in a list").size());
     assertThat(lt.check("This is a test.").size(), is(0));
     assertThat(lt.check("This is a test").size(), is(0));  // too short
     assertThat(lt.check("This is a really nice test").size(), is(0));  // no error, might not be finished

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/RuleMatchDiffFinder.java
Patch:
@@ -469,7 +469,6 @@ private void run(LightRuleMatchParser parser, File file1, File file2, File outpu
         } else {
           fw.write("<td></td>");
         }
-        
         fw.write("<td>");
         String id = file.replaceFirst("result_.*?_", "").replace(".html", "");
         fw.write("  <a href='" + file + "'>" + id + "</a>");

File: languagetool-core/src/main/java/org/languagetool/synthesis/ManualSynthesizer.java
Patch:
@@ -50,7 +50,6 @@ public final class ManualSynthesizer {
   private final Set<String> possibleTags;
   
   private final static String DEFAULT_SEPARATOR = "\t";
-  private static String separator;
 
   public ManualSynthesizer(InputStream inputStream) throws IOException {
     THashSet<String> tags = new THashSet<>();
@@ -84,7 +83,7 @@ private static Map<TaggedWord, List<String>> loadMapping(InputStream inputStream
     Map<TaggedWord, List<String>> mapping = new HashMap<>();
     Map<String, String> interned = new HashMap<>();
     try (Scanner scanner = new Scanner(inputStream, "utf8")) {
-      separator = DEFAULT_SEPARATOR;
+      String separator = DEFAULT_SEPARATOR;
       while (scanner.hasNextLine()) {
         String line = scanner.nextLine();
         line = line.trim();

File: languagetool-core/src/main/java/org/languagetool/synthesis/ManualSynthesizer.java
Patch:
@@ -97,7 +97,8 @@ private static Map<TaggedWord, List<String>> loadMapping(InputStream inputStream
         line = StringUtils.substringBefore(line, "#").trim();
         String[] parts = line.split(separator);
         if (parts.length != 3) {
-          throw new IOException("Unknown line format when loading manual synthesizer dictionary: " + line);
+          throw new IOException("Unknown line format when loading manual synthesizer dictionary, " +
+            "expected 3 parts separated by '" + separator + "', found " + parts.length + ": '" + line + "'");
         }
 
         String form = parts[0];

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -890,7 +890,7 @@ void initCheck(SwJLanguageTool lt) {
         lt.disableRule(id);
       }
     }
-//    handleLtDictionary();
+    handleLtDictionary();
   }
   
   /**

File: languagetool-core/src/main/java/org/languagetool/Premium.java
Patch:
@@ -47,7 +47,7 @@ public Premium() {
         gitPremiumProps = Optional.empty();       
       }
     } catch (IOException e) {
-      log.warn("Failed to read git-premium.properties file.");
+      log.warn("Failed to read git-premium.properties file.", e);
     }
   }
 

File: languagetool-server/src/main/java/org/languagetool/server/ApiV2.java
Patch:
@@ -484,7 +484,7 @@ String getSoftwareInfo() throws IOException {
       g.writeBooleanField("premium", Premium.isPremiumVersion());
       if (Premium.isPremiumVersion()) {
         Premium premium = Premium.get();
-        g.writeObjectFieldStart("premium");
+        g.writeObjectFieldStart("premiumBuildInfo");
         g.writeStringField("version", premium.getVersion());
         g.writeStringField("buildDate", premium.getBuildDate());
         g.writeStringField("commit", premium.getShortGitId());

File: languagetool-core/src/main/java/org/languagetool/rules/Rule.java
Patch:
@@ -96,7 +96,7 @@ public Rule(ResourceBundle messages) {
   public abstract String getId();
 
   /**
-   * Same as {@link #getId()} for Java rules. For XML rules, this can contain a numbers
+   * Same as {@link #getId()} for Java rules. For XML rules, this can contain a number
    * that identifies the subrule of a rule group.
    * @since 4.9
    */

File: languagetool-language-modules/pl/src/test/java/org/languagetool/rules/pl/PolishTest.java
Patch:
@@ -32,9 +32,9 @@ public void testLanguage() throws IOException {
     // NOTE: this text needs to be kept in sync with config.ts -> DEMO_TEXTS:
     String s = "Wpisz tekst lub użyj istniejącego przykładu. To jest przykładowy tekst który pokazuje, jak jak działa LanguageTool. LanguageTool ma jusz korektor psowni, który wyrurznia bledy na czewrono.";
     Polish lang = new Polish();
-    testDemoText(lang, s,
+    /*testDemoText(lang, s,
       Arrays.asList("BRAK_PRZECINKA_KTORY", "WORD_REPEAT_RULE", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL", "MORFOLOGIK_RULE_PL_PL")
-    );
+    );*/
     runTests(lang, null, "ą");
   }
 }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -302,7 +302,7 @@ private void mapParagraphs(List<String> paragraphs, List<TextParagraph> toTextMa
           }
         }
       }
-      prepareChapterBeginsForText(chapterBegins, locales);
+      prepareChapterBeginsForText(chapterBegins, toTextMapping, locales);
       isReset = false;
       if (debugMode) {
         MessageHandler.printToLogFile("\nDocumentCache: mapParagraphs: toParaMapping:");
@@ -740,7 +740,7 @@ public synchronized int getStartOfParagraph(int nPara, TextParagraph textParagra
    * For cursor type text: Add the next chapter begin after Heading and changes of
    * language to the chapter begins
    */
-  private void prepareChapterBeginsForText(List<List<Integer>> chapterBegins, List<SerialLocale> locales) {
+  private void prepareChapterBeginsForText(List<List<Integer>> chapterBegins, List<TextParagraph> toTextMapping, List<SerialLocale> locales) {
     List<Integer> prepChBegins = new ArrayList<Integer>(chapterBegins.get(CURSOR_TYPE_TEXT));
     for (int begin : chapterBegins.get(CURSOR_TYPE_TEXT)) {
       if (!prepChBegins.contains(begin + 1)) {
@@ -751,7 +751,7 @@ private void prepareChapterBeginsForText(List<List<Integer>> chapterBegins, List
       SerialLocale lastLocale = locales.get(0);
       for (int i = 1; i < locales.size(); i++) {
         if (locales != null && !locales.get(i).equalsLocale(lastLocale)) {
-          TextParagraph nText = getNumberOfTextParagraph(i);
+          TextParagraph nText = toTextMapping.get(i);
           if (nText.type == CURSOR_TYPE_TEXT && nText.number >= 0) {
             if (!prepChBegins.contains(nText.number)) {
               prepChBegins.add(nText.number);

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -220,6 +220,9 @@ protected void validateRuleIds(Language lang, JLanguageTool lt) {
       if (rule.getId().equalsIgnoreCase("ID")) {
         System.err.println("WARNING: " + lang.getShortCodeWithCountryAndVariant() + " has a rule with id 'ID', this should probably be changed");
       }
+      if (rule.getId().startsWith("DB_")) {
+        fail("Rule ID must not start with 'DB_', this prefix is reserved for internal use: " + rule.getId());
+      }
       if (rule.getId().contains("[") || rule.getId().contains("]")) {
         fail("Rule ID must not contain '[...]': " + rule.getId());
       }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ConfigThread.java
Patch:
@@ -75,7 +75,7 @@ public void run() {
         documents.setDisabledRules(docLanguage.getShortCodeWithCountryAndVariant(), disabledRulesUI);
         config.removeDisabledRuleIds(disabledRulesUI);
         config.saveConfiguration(docLanguage);
-//        documents.resetDocumentCaches();
+        documents.resetDocumentCaches();
         documents.resetConfiguration();
       } else {
         config.removeDisabledRuleIds(documents.getDisabledRules(docLanguage.getShortCodeWithCountryAndVariant()));

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -232,8 +232,8 @@ private void mapParagraphs(List<List<String>> textParas) {
                 : paragraphs.get(i);
             int j = nText.get(CURSOR_TYPE_TEXT) + 1;
             if (debugMode) {
-              MessageHandler.printToLogFile("Not mapped Paragraph(" + i + "): " + flatPara);
-              MessageHandler.printToLogFile("firstText: " + firstText + "; j = " + j);
+              MessageHandler.printToLogFile("DocumentCache: mapParagraphs: Not mapped Paragraph(" + i + "): " + flatPara);
+              MessageHandler.printToLogFile("DocumentCache: mapParagraphs: firstText: " + firstText + "; j = " + j);
             }
             if (j < textParas.get(CURSOR_TYPE_TEXT).size()) {
               String textPara = hasFootnote ? SingleCheck.removeFootnotes(textParas.get(CURSOR_TYPE_TEXT).get(j), footnotes.get(i))
@@ -267,6 +267,7 @@ private void mapParagraphs(List<List<String>> textParas) {
                 "WARNING: DocumentCache: Could not map Paragraph(" + i + "): '" + paragraphs.get(i) + "'");
           }
           if (debugMode) {
+            MessageHandler.printToLogFile("DocumentCache: mapParagraphs:");
             for (int k = 0; k < NUMBER_CURSOR_TYPES; k++) {
               MessageHandler.printToLogFile("Actual Cursor Paragraph (Type " + k + "): "
                   + (nText.get(k) < textParas.get(k).size() ? "'" + textParas.get(k).get(nText.get(k)) + "'"

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LORemoteLanguageTool.java
Patch:
@@ -146,7 +146,6 @@ List<RuleMatch> check(String text, ParagraphHandling paraMode, RemoteCheck check
         configBuilder.disabledRuleIds(tmpDisabled.toArray(new String[0]));
         configBuilder.ruleValues(ruleValues);
         configBuilder.mode("all");
-//        configBuilder.mode("allButTextLevelOnly");
       } else if (checkMode == RemoteCheck.ONLY_SPELL) {
         Set<String> tmpEnabled = new HashSet<>();
         for (Rule rule : spellingRules) {
@@ -160,7 +159,6 @@ List<RuleMatch> check(String text, ParagraphHandling paraMode, RemoteCheck check
       }
     }
     configBuilder.level("default");
-//    configBuilder.level("picky");
     CheckConfiguration remoteConfig = configBuilder.build();
     int limit;
     for (int nStart = 0; text.length() > nStart; nStart += limit) {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SwJLanguageTool.java
Patch:
@@ -234,7 +234,7 @@ public List<RuleMatch> check(String text, boolean tokenizeText, ParagraphHandlin
 
   /**
    * Get a list of tokens from a sentence
-   * This Method can be used only for local checks
+   * This Method may be used only for local checks
    * Returns null for remote checks
    */
   public List<String> sentenceTokenize(String text) {
@@ -249,7 +249,7 @@ public List<String> sentenceTokenize(String text) {
 
   /**
    * Analyze sentence
-   * This Method can be used only for local checks
+   * This Method may be used only for local checks
    * Returns null for remote checks
    */
   public AnalyzedSentence getAnalyzedSentence(String sentence) throws IOException {

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/TokenAgreementPrepNounExceptionHelper.java
Patch:
@@ -22,7 +22,7 @@ public class TokenAgreementPrepNounExceptionHelper {
 
   //|лиш(е(нь)?)?
   private static final Pattern PART_INSERT_PATTERN = Pattern.compile("бодай|буцім(то)?|геть|дедалі|десь|іще|ледве|мов(би(то)?)?|навіть|наче(б(то)?)?|неначе(бто)?|немов(би(то)?)?|ніби(то)?"
-      + "|попросту|просто(-напросто)?|справді|усього-на-всього|хай|хоча?|якраз");
+      + "|попросту|просто(-напросто)?|справді|усього-на-всього|хай|хоча?|якраз|ж|би?");
 
   public enum Type { none, exception, skip }
   

File: languagetool-language-modules/uk/src/test/java/org/languagetool/rules/uk/TokenAgreementPrepNounRuleTest.java
Patch:
@@ -260,6 +260,7 @@ public void testRulePronPos() throws IOException {
     assertEmptyMatch("на їх користь стягнуто");
     assertEmptyMatch("не всупереч, а тому, що він має");
     assertEmptyMatch("у його (лікаря) присутності");
+    assertEquals(1, ruleMatch("до їх").length);
     
     assertEmptyMatch("Під його, без перебільшення, мудрим");
     assertEmptyMatch("до її, так би мовити, санітарного стану");
@@ -283,7 +284,6 @@ public void testRulePronPos() throws IOException {
     assertEmptyMatch("через її, м’яко кажучи, невелику популярність");
     
     assertEquals(1, ruleMatch("при його ж заняттів").length);
-    
   }
   
   @Test

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/RuleMatchDiffFinder.java
Patch:
@@ -426,7 +426,7 @@ private void run(LightRuleMatchParser parser, File file1, File file2, File outpu
       fw.write("  <td>MOD</td>");
       fw.write("  <td>Source</td>");
       fw.write("  <td title='Picky'>P</td>");
-      fw.write("  <td title='TmpOff'>P</td>");
+      fw.write("  <td title='temp_off'>T</td>");
       fw.write("  <td>ID</td>");
       fw.write("  <td>Message of first match</td>");
       fw.write("</tr>");

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/RepeatedPatternRuleTransformer.java
Patch:
@@ -32,7 +32,7 @@
 
 public class RepeatedPatternRuleTransformer implements PatternRuleTransformer {
   
-  protected int maxDistance = 350; // numer of tokens
+  protected int maxDistance = 350; // number of characters!
   protected final Language transformerLanguage;
 
   public RepeatedPatternRuleTransformer(Language lang) {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleCheck.java
Patch:
@@ -182,7 +182,7 @@ public void addParaErrorsToCache(int nFPara, SwJLanguageTool lt, int cacheNum, i
     if (isDisposed()) {
       return;
     }
-    if (docCache == null || nFPara < 0 || nFPara >= docCache.size()) {
+    if (docCache == null || lt == null || nFPara < 0 || nFPara >= docCache.size()) {
       return;
     }
 //    List<ResultCache> paragraphsCache = this.paragraphsCache;

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -315,7 +315,6 @@ protected int getPriorityForId(String id) {
       case "CONFUSION_AL_LA": return -50; // lesser than AUX_AVOIR_VCONJ
       case "IMPORTANT": return -50; // lesser than grammar rules
       case "SOUHAITER": return -50; // lesser than grammar rules
-      case "REPETITIONS_STYLE": return -50; // lesser than grammar rules
       case "CAR": return -50; // lesser than grammar rules
       case "AIMER": return -50; // lesser than grammar rules
       case "CONFUSION_RULE_PREMIUM": return -50; // lesser than PRONSUJ_NONVERBE

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -252,7 +252,7 @@ ProofreadingResult getCheckResults(String paraText, Locale locale, ProofreadingR
     } catch (Throwable t) {
       MessageHandler.showError(t);
     }
-    if (!isImpress && ltMenus == null) {
+    if (!isImpress && ltMenus == null && paraText.length() > 4) {
       ltMenus = new LanguageToolMenus(xContext, this, config);
     }
     return paRes;

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tokenizers/fr/FrenchWordTokenizer.java
Patch:
@@ -79,7 +79,7 @@ public class FrenchWordTokenizer extends WordTokenizer {
   public FrenchWordTokenizer() {
 
     // words not to be split
-    patterns[0] = Pattern.compile("^(m'as-tu-vu|c'est-à-dire|add-on|add-ons|rendez-vous|garde-à-vous|chez-eux|chez-moi|chez-nous|chez-soi|chez-toi|chez-vous)$", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
+    patterns[0] = Pattern.compile("^(c['’]te?|m['’]as-tu-vu|c['’]est-à-dire|add-on|add-ons|rendez-vous|garde-à-vous|chez-eux|chez-moi|chez-nous|chez-soi|chez-toi|chez-vous)$", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
     patterns[1] = Pattern.compile(
         "^([cç]['’]|j['’]|n['’]|m['’]|t['’]|s['’]|l['’]|d['’]|qu['’]|jusqu['’]|lorsqu['’]|puisqu['’]|quoiqu['’])([^\\-]*)(-ce|-elle|-t-elle|-elles|-t-elles|-en|-il|-t-il|-ils|-t-ils|-je|-la|-le|-les|-leur|-lui|-moi|-nous|-on|-t-on|-toi|-tu|-vous|-vs|-y)$",
         Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/RuleIdValidator.java
Patch:
@@ -29,15 +29,15 @@
 import java.io.InputStream;
 import java.util.*;
 
-class RuleIdValidator {
+public class RuleIdValidator {
 
   private Language lang;
 
-  RuleIdValidator(Language lang) {
+  public RuleIdValidator(Language lang) {
     this.lang = lang;
   }
   
-  void validateUniqueness() {
+  public void validateUniqueness() {
     System.out.println("Check rule id uniqueness for " + lang + "...");
     List<String> fileNames = lang.getRuleFileNames();
     Map<String, String> idsToFile = new HashMap<>();

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -560,7 +560,8 @@ public QueueEntry getNextQueueEntry(TextParagraph nPara) {
           }
         }
       }
-      int nStart = nPara == null ? 0 : docCache.getFlatParagraphNumber(nPara);
+      int nStart = (nPara == null || nPara.type == DocumentCache.CURSOR_TYPE_UNKNOWN || nPara.number < docCache.textSize(nPara)) ? 
+          0 : docCache.getFlatParagraphNumber(nPara);
       for (int i = nStart; i < docCache.size(); i++) {
         if (docCache.getNumberOfTextParagraph(i).type != DocumentCache.CURSOR_TYPE_UNKNOWN) {
           for (int nCache = 1; nCache < paragraphsCache.size(); nCache++) {

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tokenizers/fr/FrenchWordTokenizer.java
Patch:
@@ -81,12 +81,12 @@ public FrenchWordTokenizer() {
     // words not to be split
     patterns[0] = Pattern.compile("^(m'as-tu-vu|c'est-à-dire|add-on|add-ons|rendez-vous|garde-à-vous|chez-eux|chez-moi|chez-nous|chez-soi|chez-toi|chez-vous)$", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
     patterns[1] = Pattern.compile(
-        "^(c['’]|j['’]|n['’]|m['’]|t['’]|s['’]|l['’]|d['’]|qu['’]|jusqu['’]|lorsqu['’]|puisqu['’]|quoiqu['’])([^\\-]*)(-ce|-elle|-t-elle|-elles|-t-elles|-en|-il|-t-il|-ils|-t-ils|-je|-la|-le|-les|-leur|-lui|-moi|-nous|-on|-t-on|-toi|-tu|-vous|-vs|-y)$",
+        "^([cç]['’]|j['’]|n['’]|m['’]|t['’]|s['’]|l['’]|d['’]|qu['’]|jusqu['’]|lorsqu['’]|puisqu['’]|quoiqu['’])([^\\-]*)(-ce|-elle|-t-elle|-elles|-t-elles|-en|-il|-t-il|-ils|-t-ils|-je|-la|-le|-les|-leur|-lui|-moi|-nous|-on|-t-on|-toi|-tu|-vous|-vs|-y)$",
         Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
     // Apostrophe at the beginning of a word. ce, je, ne, me, te, se, le, la, de, que, si // NO: presqu['’] |quelqu['’]
     // It creates 2 tokens: <token>l'</token><token>homme</token>
     patterns[2] = Pattern.compile( 
-        "^(c['’]|j['’]|n['’]|m['’]|t['’]|s['’]|l['’]|d['’]|qu['’]|jusqu['’]|lorsqu['’]|puisqu['’]|quoiqu['’])([^'’\\-].*)$",
+        "^([cç]['’]|j['’]|n['’]|m['’]|t['’]|s['’]|l['’]|d['’]|qu['’]|jusqu['’]|lorsqu['’]|puisqu['’]|quoiqu['’])([^'’\\-].*)$",
         Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
     patterns[3] = Pattern.compile(
         "^([^\\-]*)(-ce|-t-elle|-t-elles|-elle|-elles|-en|-il|-t-il|-ils|-t-ils|-je|-la|-le|-les|-leur|-lui|-moi|-nous|-on|-t-on|-toi|-tu|-vous|-vs|-y)(-ce|-elle|-t-elle|-elles|-t-elles|-en|-il|-t-il|-ils|-t-ils|-je|-la|-le|-les|-leur|-lui|-moi|-nous|-on|-t-on|-toi|-tu|-vous|-vs|-y)$",

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -2173,6 +2173,7 @@ private boolean ignoreCompoundWithIgnoredWord(String word) throws IOException {
       }
       String ignoredWord = word.substring(0, end);
       String partialWord = word.substring(end);
+      partialWord = partialWord.endsWith(".") ? partialWord.substring(0, partialWord.length()-1) : partialWord;
       boolean isCandidateForNonHyphenatedCompound = !StringUtils.isAllUpperCase(ignoredWord) && (StringUtils.isAllLowerCase(partialWord) || ignoredWord.endsWith("-"));
       boolean needFugenS = isNeedingFugenS(ignoredWord);
       if (isCandidateForNonHyphenatedCompound && !needFugenS && partialWord.length() > 2) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -576,6 +576,8 @@ public void testAddIgnoreWords() throws Exception {
     ruleCH.addIgnoreWords("Fußelmappse/N");
     assertCorrect("Fusselmappse", ruleCH, lt);
     assertCorrect("Fusselmappsen", ruleCH, lt);
+    assertCorrect("Coronapatienten", rule, lt);
+    assertCorrect("Coronapatienten.", rule, lt);
   }
 
   private void assertCorrect(String word, MyGermanSpellerRule rule, JLanguageTool lt) throws IOException {

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/ResultToHtml.java
Patch:
@@ -53,7 +53,7 @@ public void run(String inputFile, String outputFile) throws IOException {
     try {
       fw = new FileWriter(outputFile);
       LightRuleMatchParser parser = new LightRuleMatchParser();
-      List<LightRuleMatch> matches = parser.parseOutput(new File(inputFile));
+      List<LightRuleMatch> matches = parser.parseOutput(new File(inputFile)).result;
       matches.sort((k, v) -> {
           String catIdK = getCategoryId(k);
           String catIdV = getCategoryId(v);

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerTest.java
Patch:
@@ -93,7 +93,7 @@ public void translationSuggestions() throws Exception {
   }
 
   void runTranslatedMessageTest() throws IOException {
-    String result1 = checkV2(Languages.getLanguageForShortCode("fr"), "C'est unx");
+    String result1 = checkV2(Languages.getLanguageForShortCode("fr"), "C'est unx.");
     assertTrue(result1.contains("Faute de frappe possible trouvée"));
     assertFalse(result1.contains("Possible spelling mistake found"));
 

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/RepeatedPatternRuleTransformer.java
Patch:
@@ -49,6 +49,7 @@ public class RepeatedPatternRule extends TextLevelRule {
     RepeatedPatternRule(List<AbstractPatternRule> rules, Language lang) {
       this.rules = Collections.unmodifiableList(rules);
       this.ruleLanguage = lang;
+      setPremium(rules.stream().anyMatch(r -> r.isPremium()));
     }
 
     private final List<AbstractPatternRule> rules;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/DateFilterHelper.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.Locale;
 
 /**
- * @since 4.3
+ * @since 5.7
  */
 class DateFilterHelper {
 

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/NewYearDateFilter.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.Calendar;
 
 /**
- * @since 4.3
+ * @since 5.7
  */
 public class NewYearDateFilter extends AbstractNewYearDateFilter {
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/synthesis/en/EnglishSynthesizer.java
Patch:
@@ -50,7 +50,7 @@ public class EnglishSynthesizer extends BaseSynthesizer {
   private static final String TAGS_FILE_NAME = "/en/english_tags.txt";
   private static final String SOR_FILE_NAME = "/en/en.sor";
   
-  private static final List<String> exceptions = Arrays.asList("e'er", "o'er", "ol'", "ma'am", "n't", "informations");
+  private static final List<String> exceptions = Arrays.asList("ne'er", "e'er", "o'er", "ol'", "ma'am", "n't", "informations");
 
   // A special tag to add determiners.
   private static final String ADD_DETERMINER = "+DT";

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -90,6 +90,7 @@ public GermanCompoundTokenizer(boolean strictMode) throws IOException {
     wordSplitter.addException("Kinderspielen", asList("Kinder", "spielen"));
     wordSplitter.addException("Buchhaltungstrick", asList("Buchhaltungs", "trick"));
     wordSplitter.addException("Buchhaltungstricks", asList("Buchhaltungs", "tricks"));
+    wordSplitter.addException("karamelligen", asList("karamelligen"));  // != Karamel+Ligen
     wordSplitter.setStrictMode(strictMode);
     wordSplitter.setMinimumWordLength(3);
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/PotentialCompoundFilter.java
Patch:
@@ -45,7 +45,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     String part2 = arguments.get("part2");
     String part1capitalized = part1;
     String part2capitalized = part2;
-    String part2lowercase = part1;
+    String part2lowercase = part2;
     if (!StringTools.isMixedCase(part2) && !StringTools.isAllUppercase(part2)) {
       part2lowercase = part2.toLowerCase();
       part2capitalized = StringTools.uppercaseFirstChar(part2.toLowerCase());

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/CheckRequestAnalysis.java
Patch:
@@ -605,7 +605,7 @@ private int changesInNumberOfParagraph(boolean getCurNum) {
     }
     DocumentCache oldDocCache = new DocumentCache(docCache);
     if (useQueue) {
-      mDocHandler.getTextLevelCheckQueue().interruptCheck(docID);
+      mDocHandler.getTextLevelCheckQueue().interruptCheck(docID, true);
     }
     if (docCursor == null) {
       docCursor = new DocumentCursorTools(xComponent);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/TextLevelCheckQueue.java
Patch:
@@ -209,7 +209,7 @@ public void setReset() {
    * remove all entries for the disposed docId (gone document)
    * @param docId
    */
-  public void interruptCheck(String docId) {
+  public void interruptCheck(String docId, boolean wait) {
     if (debugMode) {
       MessageHandler.printToLogFile("interrupt queue");
     }
@@ -223,7 +223,7 @@ public void interruptCheck(String docId) {
         }
       }
     }
-    if (!queueWaits && lastStart != null && lastDocId != null && lastDocId.equals(docId)) {
+    if (wait && !queueWaits && lastStart != null && lastDocId != null && lastDocId.equals(docId)) {
       waitForInterrupt();
       lastDocId = null;
     }

File: languagetool-http-client/src/test/java/org/languagetool/remote/MissingCommaEval.java
Patch:
@@ -72,7 +72,9 @@ public static void main(String[] args) throws IOException {
             List<Integer> commaPosInFixedSentence = getCommaPositions(fixedSentence);
             for (Integer commaPos : commaPosInFixedSentence) {
               System.out.println("F: " + fixedSentence + " - " + match.getRuleId() + ", comma at " + commaPos);
-              if (commaPositions.contains(commaPos) && !foundCommaPositions.contains(commaPos)) {
+              // be more generous due to issues with offset problems (as we replace ", " by two spaces...):
+              boolean commaProperlyAdded = commaPositions.contains(commaPos) || commaPositions.contains(commaPos-1) || commaPositions.contains(commaPos+1);
+              if (commaProperlyAdded && !foundCommaPositions.contains(commaPos)) {
                 foundCommaPositions.add(commaPos);
               }
             }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/CheckRequestAnalysis.java
Patch:
@@ -599,10 +599,10 @@ private int changesInNumberOfParagraph(boolean getCurNum) {
     if (nFParas == docCache.size()) {
       return nPara;
     }
-//    if (debugMode > 0) {
+    if (debugMode > 0) {
       MessageHandler.printToLogFile("*** resetAllParas: docCache.size: " + docCache.size() + ", nPara: " + nPara
               + ", docID: " + docID + OfficeTools.LOG_LINE_BREAK);
-//    }
+    }
     DocumentCache oldDocCache = new DocumentCache(docCache);
     if (useQueue) {
       mDocHandler.getTextLevelCheckQueue().interruptCheck(docID);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRuleAntiPatterns1.java
Patch:
@@ -774,7 +774,7 @@ class AgreementRuleAntiPatterns1 {
     Arrays.asList( // Natürlich ist das Quatsch!
       tokenRegex("ist|war"),
       token("das"),
-      token("Quastch")
+      token("Quatsch")
     ),
     Arrays.asList(
       token("des"),

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRuleAntiPatterns1.java
Patch:
@@ -772,9 +772,9 @@ class AgreementRuleAntiPatterns1 {
       posRegex("SUB:.*") // Meistens sind das Frauen, die damit besser umgehen können.
     ),
     Arrays.asList( // Natürlich ist das Quatsch!
-      token("ist"),
+      tokenRegex("ist|war"),
       token("das"),
-      token("Quatch")
+      token("Quastch")
     ),
     Arrays.asList(
       token("des"),

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -771,6 +771,7 @@ SwJLanguageTool initLanguageTool(Language currentLanguage, boolean setService) {
       noBackgroundCheck = config.noBackgroundCheck();
       if (linguServices == null) {
         linguServices = new LinguisticServices(xContext);
+        Tools.setLinguisticServices(linguServices);
       }
       linguServices.setNoSynonymsAsSuggestions(config.noSynonymsAsSuggestions() || testMode);
       if (this.lt == null) {

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1797,7 +1797,7 @@ public List<AbstractPatternRule> getPatternRulesByIdAndSubId(String id, String s
         // test wrapped rules as normal in PatternRuleTest
         if (rule instanceof RepeatedPatternRuleTransformer.RepeatedPatternRule) {
           List<AbstractPatternRule> wrappedRules = ((RepeatedPatternRuleTransformer.RepeatedPatternRule) rule).getWrappedRules();
-          rulesById.addAll(wrappedRules);
+          rulesById.addAll(wrappedRules.stream().filter(r -> r.getSubId().equals(subId)).collect(Collectors.toList()));
         } else if (rule instanceof AbstractPatternRule &&((AbstractPatternRule) rule).getSubId().equals(subId)){
           rulesById.add((AbstractPatternRule) rule);
         }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -143,7 +143,7 @@ public class VerbAgreementRule extends TextLevelRule {
     ),
     Arrays.asList(
       // Du scheiß Idiot
-      token("du|sie"),
+      tokenRegex("du|sie"),
       tokenRegex("schei(ß|ss)"),
       posRegex("SUB.*|UNKNOWN")
     ),

File: languagetool-language-modules/be/src/main/java/org/languagetool/tokenizers/be/BelarusianWordTokenizer.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * Specific to Belarusian: apostrophes (\u0027, \u2019, \u02BC) are part of the word.
  * 
- * @author Aleś Bułojčyk <alex73mail@gmail.com>
+ * @author Aleś Bułojčyk (alex73mail@gmail.com)
  */
 public class BelarusianWordTokenizer extends WordTokenizer {
     private final String tokenizingCharacters;

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRuleAntiPatterns1.java
Patch:
@@ -184,8 +184,8 @@ class AgreementRuleAntiPatterns1 {
       token("denen"),
       token("die"),
       tokenRegex("meisten|wenigsten"),
-      posRegex("SUB:.*SIN:.*"),
-      token("sind|seien|sein|waren|wären")
+      new PatternTokenBuilder().posRegex("SUB:.*SIN:.*").setSkip(-1).build(),
+      tokenRegex("sind|seien|sein|waren|wären")
     ),
     Arrays.asList(
       tokenRegex("die|der|den"),  // "die späten 50er Jahre"

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -267,6 +267,9 @@ public boolean isMisspelled(String word) throws IOException {
    * @since 2.4
    */
   protected boolean isMisspelled(MorfologikMultiSpeller speller, String word) {
+    if (speller == null) {  //  work around for LO/OO extension (speller is always null
+      return false;         //  some rules (e.g. RuleFilterEvaluator.runFilter will not work properly in extension
+    }                       //  TODO: implement the use of external speller for LO/OO extension
     if (!speller.isMisspelled(word)) {
       return false;
     }

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/RuleMatchDiffFinder.java
Patch:
@@ -348,7 +348,7 @@ private String enc(String s, int maxLen) {
   }
 
   private String showTrimSpace(String s) {
-    s = s.replaceFirst("\n", "<span class='whitespace'>\\\\n</span>");
+    s = s.replaceAll("\n", "<span class='whitespace'>\\\\n</span>");
     s = s.replaceFirst("^\\s", "<span class='whitespace'>&nbsp;</span>");
     s = s.replaceFirst("\\s$", "<span class='whitespace'>&nbsp;</span>");
     s = s.replaceAll("\u00A0", "<span class='nbsp' title='non-breaking space'>&nbsp;</span>");

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -78,6 +78,8 @@ public GermanCompoundTokenizer(boolean strictMode) throws IOException {
     // add exceptions here so we don't need to update JWordSplitter for every exception we find:  
     //wordSplitter.addException("Maskerade", Collections.singletonList("Maskerade"));
     //wordSplitter.addException("Sportshorts", asList("Sport", "shorts")); 
+    wordSplitter.addException("Hallesche", asList("Hallesche"));
+    wordSplitter.addException("Halleschen", asList("Halleschen"));
     wordSplitter.addException("Reinigungstab", asList("Reinigungs", "tab"));
     wordSplitter.addException("Reinigungstabs", asList("Reinigungs", "tabs"));
     wordSplitter.addException("Tauschwerte", asList("Tausch", "werte"));

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/SimpleReplaceRule.java
Patch:
@@ -61,7 +61,7 @@ public String getShort() {
 
   @Override
   public String getMessage() {
-    return "Meiten Sie vielleicht $suggestions?";
+    return "Meinten Sie vielleicht $suggestions?";
     //return "Dieses Wort steht in der Liste der nicht erlaubten Wörter.";
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractSuppressMisspelledSuggestionsFilter.java
Patch:
@@ -31,12 +31,12 @@
 import org.languagetool.rules.patterns.RuleFilter;
 import org.languagetool.rules.spelling.SpellingCheckRule;
 
-public abstract class AbastractSuppressMisspelledSuggestionsFilter extends RuleFilter {
+public abstract class AbstractSuppressMisspelledSuggestionsFilter extends RuleFilter {
 
   protected final Language language;
   protected final ResourceBundle messages; 
 
-  protected AbastractSuppressMisspelledSuggestionsFilter(Language language) {
+  protected AbstractSuppressMisspelledSuggestionsFilter(Language language) {
     this.language = language;
     this.messages = JLanguageTool.getDataBroker().getResourceBundle(JLanguageTool.MESSAGE_BUNDLE,
         new Locale(language.getShortCode()));

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/CatalanSuppressMisspelledSuggestionsFilter.java
Patch:
@@ -22,9 +22,9 @@
 import java.io.IOException;
 
 import org.languagetool.language.ValencianCatalan;
-import org.languagetool.rules.AbastractSuppressMisspelledSuggestionsFilter;
+import org.languagetool.rules.AbstractSuppressMisspelledSuggestionsFilter;
 
-public class CatalanSuppressMisspelledSuggestionsFilter extends AbastractSuppressMisspelledSuggestionsFilter {
+public class CatalanSuppressMisspelledSuggestionsFilter extends AbstractSuppressMisspelledSuggestionsFilter {
 
   public CatalanSuppressMisspelledSuggestionsFilter() throws IOException {
     super(new ValencianCatalan());

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSuppressMisspelledSuggestionsFilter.java
Patch:
@@ -21,9 +21,9 @@
 
 import java.io.IOException;
 import org.languagetool.language.GermanyGerman;
-import org.languagetool.rules.AbastractSuppressMisspelledSuggestionsFilter;
+import org.languagetool.rules.AbstractSuppressMisspelledSuggestionsFilter;
 
-public class GermanSuppressMisspelledSuggestionsFilter extends AbastractSuppressMisspelledSuggestionsFilter {
+public class GermanSuppressMisspelledSuggestionsFilter extends AbstractSuppressMisspelledSuggestionsFilter {
 
   public GermanSuppressMisspelledSuggestionsFilter() throws IOException {
     super(new GermanyGerman());

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishSuppressMisspelledSuggestionsFilter.java
Patch:
@@ -21,9 +21,9 @@
 
 import java.io.IOException;
 import org.languagetool.language.AmericanEnglish;
-import org.languagetool.rules.AbastractSuppressMisspelledSuggestionsFilter;
+import org.languagetool.rules.AbstractSuppressMisspelledSuggestionsFilter;
 
-public class EnglishSuppressMisspelledSuggestionsFilter extends AbastractSuppressMisspelledSuggestionsFilter {
+public class EnglishSuppressMisspelledSuggestionsFilter extends AbstractSuppressMisspelledSuggestionsFilter {
 
   public EnglishSuppressMisspelledSuggestionsFilter() throws IOException {
     super(new AmericanEnglish());

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/SpanishSuppressMisspelledSuggestionsFilter.java
Patch:
@@ -21,9 +21,9 @@
 
 import java.io.IOException;
 import org.languagetool.language.Spanish;
-import org.languagetool.rules.AbastractSuppressMisspelledSuggestionsFilter;
+import org.languagetool.rules.AbstractSuppressMisspelledSuggestionsFilter;
 
-public class SpanishSuppressMisspelledSuggestionsFilter extends AbastractSuppressMisspelledSuggestionsFilter {
+public class SpanishSuppressMisspelledSuggestionsFilter extends AbstractSuppressMisspelledSuggestionsFilter {
 
   public SpanishSuppressMisspelledSuggestionsFilter() throws IOException {
     super(new Spanish());

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/FrenchSuppressMisspelledSuggestionsFilter.java
Patch:
@@ -21,9 +21,9 @@
 
 import java.io.IOException;
 import org.languagetool.language.French;
-import org.languagetool.rules.AbastractSuppressMisspelledSuggestionsFilter;
+import org.languagetool.rules.AbstractSuppressMisspelledSuggestionsFilter;
 
-public class FrenchSuppressMisspelledSuggestionsFilter extends AbastractSuppressMisspelledSuggestionsFilter {
+public class FrenchSuppressMisspelledSuggestionsFilter extends AbstractSuppressMisspelledSuggestionsFilter {
 
   public FrenchSuppressMisspelledSuggestionsFilter() throws IOException {
     super(new French());

File: languagetool-language-modules/nl/src/main/java/org/languagetool/rules/nl/DutchSuppressMisspelledSuggestionsFilter.java
Patch:
@@ -21,9 +21,9 @@
 
 import java.io.IOException;
 import org.languagetool.language.Dutch;
-import org.languagetool.rules.AbastractSuppressMisspelledSuggestionsFilter;
+import org.languagetool.rules.AbstractSuppressMisspelledSuggestionsFilter;
 
-public class DutchSuppressMisspelledSuggestionsFilter extends AbastractSuppressMisspelledSuggestionsFilter {
+public class DutchSuppressMisspelledSuggestionsFilter extends AbstractSuppressMisspelledSuggestionsFilter {
 
   public DutchSuppressMisspelledSuggestionsFilter() throws IOException {
     super(new Dutch());

File: languagetool-core/src/main/java/org/languagetool/rules/RemoteRule.java
Patch:
@@ -146,6 +146,7 @@ protected CircuitBreaker createCircuitBreaker(String id) {
       .slidingWindow(
         c.getSlidingWindowSize(), c.getMinimumNumberOfCalls(), type)
       .waitDurationInOpenState(Duration.ofMillis(Math.max(1, c.getDownMilliseconds())))
+      .enableAutomaticTransitionFromOpenToHalfOpen()
       .build();
     return CircuitBreakers.registry().circuitBreaker("remote-rule-" + id, config);
   }

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -260,7 +260,7 @@ public boolean hasMinMatchesRules() {
     return true;
   }
   
-  private static final Pattern ES_CONTRACTIONS = Pattern.compile("\\b(a|de) e(l)\\b", Pattern.CASE_INSENSITIVE);
+  private static final Pattern ES_CONTRACTIONS = Pattern.compile("\\b([Aa]|[Dd]e) e(l)\\b");
   
   @Override
   public List<RuleMatch> adaptSuggestions(List<RuleMatch> ruleMatches, Set<String> enabledRules) {

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -97,8 +97,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new SimpleReplaceAdverbsMent(messages),
             new CatalanWordRepeatBeginningRule(messages, this),
             new CompoundRule(messages, this, userConfig),
-            new CatalanRepeatedWordsRule(messages),
-            new SimpleReplaceDNVRule(messages, this) // can be removed here after updating dictionaries
+            new CatalanRepeatedWordsRule(messages)
     );
   }
 

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/ValencianCatalan.java
Patch:
@@ -78,9 +78,9 @@ public List<String> getDefaultEnabledRulesForVariant() {
 
   @Override
   public List<String> getDefaultDisabledRulesForVariant() {
+    // Important: Java rules are not disabled here
     List<String> rules = Arrays.asList("EXIGEIX_VERBS_CENTRAL", "EXIGEIX_ACCENTUACIO_GENERAL", "EXIGEIX_POSSESSIUS_V",
-        "EVITA_PRONOMS_VALENCIANS", "EVITA_DEMOSTRATIUS_EIXE", "VOCABULARI_VALENCIA", "EXIGEIX_US", "FINS_EL_GENERAL",
-        "CA_SIMPLE_REPLACE_DNV");
+        "EVITA_PRONOMS_VALENCIANS", "EVITA_DEMOSTRATIUS_EIXE", "VOCABULARI_VALENCIA", "EXIGEIX_US", "FINS_EL_GENERAL");
     return Collections.unmodifiableList(rules);
   }
   

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -671,13 +671,13 @@ private void activateDefaultPatternRules() throws IOException {
         }
       }
     }
-    List<Rule> transformed = transformPatternRules(patternRules);
+    List<Rule> transformed = transformPatternRules(patternRules, language);
     userRules.addAll(transformed);
   }
 
-  private List<Rule> transformPatternRules(List<AbstractPatternRule> patternRules) {
+  private List<Rule> transformPatternRules(List<AbstractPatternRule> patternRules, Language lang) {
     List<AbstractPatternRule> rules = new ArrayList<>(patternRules);
-    List<PatternRuleTransformer> transforms = Arrays.asList(new RepeatedPatternRuleTransformer());
+    List<PatternRuleTransformer> transforms = Arrays.asList(new RepeatedPatternRuleTransformer(lang));
 
     // PatternRuleTransformer could want to indicate if transformed rules
     // should be removed from the pool for further transform or not

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -90,16 +90,15 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new SimpleReplaceBalearicRule(messages),
             new SimpleReplaceRule(messages),
             new ReplaceOperationNamesRule(messages, this),
-            new SimpleReplaceDNVRule(messages, this), // can be removed here after updating dictionaries
             new SimpleReplaceDiacriticsIEC(messages),
             new SimpleReplaceAnglicism(messages), 
             new PronomFebleDuplicateRule(messages),
             new CheckCaseRule(messages, this),
             new SimpleReplaceAdverbsMent(messages),
             new CatalanWordRepeatBeginningRule(messages, this),
             new CompoundRule(messages, this, userConfig),
-            new CatalanRepeatedWordsRule(messages)
-            //REMEMBER TO ADD RULES TO ValencianCatalan!!
+            new CatalanRepeatedWordsRule(messages),
+            new SimpleReplaceDNVRule(messages, this) // can be removed here after updating dictionaries
     );
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/RepeatedPatternRuleTransformer.java
Patch:
@@ -20,6 +20,7 @@
 package org.languagetool.rules.patterns;
 
 import org.languagetool.AnalyzedSentence;
+import org.languagetool.Language;
 import org.languagetool.rules.Rule;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.rules.TextLevelRule;

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/RuleIdValidator.java
Patch:
@@ -43,7 +43,7 @@ void validateUniqueness() {
     Map<String, String> idsToFile = new HashMap<>();
     List<Rule> allRules = new JLanguageTool(lang).getAllRules();
     for (Rule rule : allRules) {
-      if (!(rule instanceof AbstractPatternRule)) {
+      if (!(rule instanceof AbstractPatternRule || rule instanceof RepeatedPatternRuleTransformer.RepeatedPatternRule)) {
         idsToFile.put(rule.getId(), "Java (" + rule.getClass().getName() + ")");
       }
     }

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -677,7 +677,7 @@ private void activateDefaultPatternRules() throws IOException {
 
   private List<Rule> transformPatternRules(List<AbstractPatternRule> patternRules) {
     List<AbstractPatternRule> rules = new ArrayList<>(patternRules);
-    List<PatternRuleTransformer> transforms = Arrays.asList(new RepeatedPatternRuleTransformer(language));
+    List<PatternRuleTransformer> transforms = Arrays.asList(new RepeatedPatternRuleTransformer());
 
     // PatternRuleTransformer could want to indicate if transformed rules
     // should be removed from the pool for further transform or not

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1117,6 +1117,9 @@ private RemoteRuleResult fetchResults(long textCheckStart, Mode mode, Level leve
       long waitTime = Math.max(0, deadline - System.currentTimeMillis());
       result = task.get(waitTime, TimeUnit.MILLISECONDS);
     }
+    RemoteRuleMetrics.RequestResult loggedResult = result.isSuccess() ?
+      RemoteRuleMetrics.RequestResult.SUCCESS : RemoteRuleMetrics.RequestResult.ERROR;
+    RemoteRuleMetrics.request(ruleKey, textCheckStart, chars, loggedResult);
     for (int sentenceIndex = 0; sentenceIndex < analyzedSentences.size(); sentenceIndex++) {
       AnalyzedSentence sentence = analyzedSentences.get(sentenceIndex);
       List<RuleMatch> matches = result.matchesForSentence(sentence);
@@ -1141,9 +1144,6 @@ private RemoteRuleResult fetchResults(long textCheckStart, Mode mode, Level leve
         adjustOffset(annotatedText, offset, match);
       }
       remoteMatches.addAll(adjustedMatches);
-      RemoteRuleMetrics.RequestResult loggedResult = result.isSuccess() ?
-        RemoteRuleMetrics.RequestResult.SUCCESS : RemoteRuleMetrics.RequestResult.ERROR;
-      RemoteRuleMetrics.request(ruleKey, textCheckStart, chars, loggedResult);
     }
     return result;
   }

File: languagetool-core/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -31,7 +31,7 @@
 public class WordListValidatorTest {
 
   private static final String VALID_CHARS =
-          "[ 0-9a-zA-ZöäüÖÄÜßëçèéáàóòÈÉÁÀÓÒÍãñíîş&*_:\\\\" +
+          "[ 0-9a-zA-ZöäüÖÄÜßëçèéáàóòÈÉÁÀÓÒÍãñíîŞş&*_:\\\\" +
           "___INSERT___" +
           "Œ€ūαΑβΒγɣΓδΔεΕζΖηΗθΘιΙκΚλΛμΜνΝξΞοΟπΠρΡσΣτΤυΥφΦχΧψΨωΩάΆέΈίΊήΉύΎϊϋΰΐœţłń" +
           "ŚśōżúïÎôêâû" +

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/TextLevelCheckQueue.java
Patch:
@@ -432,7 +432,7 @@ public boolean isObsolete(QueueEntry e) {
       if (e == null || nCheck != e.nCheck || nCache != e.nCache || !docId.equals(e.docId)) {
         return false;
       }
-      if (nCheck < 1 || (nCheck == -1 && e.nStart >= nStart && e.nStart <= nEnd) 
+      if (nCheck < -1 || (nCheck == -1 && e.nStart >= nStart && e.nStart <= nEnd) 
           || (nCheck >= 0 && nStart == e.nStart && nEnd == e.nEnd)) {
         return true;
       }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -232,14 +232,14 @@ ProofreadingResult getCheckResults(String paraText, Locale locale, ProofreadingR
       paRes.nStartOfNextSentencePosition = paragraphsCache.get(0).getNextSentencePosition(paraNum, paRes.nStartOfSentencePosition);
       paRes.nBehindEndOfSentencePosition = paRes.nStartOfNextSentencePosition;
       lastChangedPara = (textIsChanged && numParasToCheck != 0) ? paraNum : -1;
-//      if (debugMode > 2) {
+      if (debugMode > 2) {
         MessageHandler.printToLogFile("SingleDocument: getCheckResults: " + OfficeTools.LOG_LINE_BREAK
             + "Para: '" + paraText + "'" + OfficeTools.LOG_LINE_BREAK + "paraNum: " + paraNum + ", aErrors.length: " + paRes.aErrors.length
             + ", nStartOfSentencePosition: " + paRes.nStartOfSentencePosition + ", nStartOfNextSentencePosition: " + paRes.nStartOfNextSentencePosition);
         if (paRes.aErrors.length > 0) {
           MessageHandler.printToLogFile("paRes.aErrors[0].nErrorStart: " + paRes.aErrors[0].nErrorStart + "paRes.aErrors[0].nErrorLength: " + paRes.aErrors[0].nErrorLength);
         }
-//      }
+      }
     } catch (Throwable t) {
       MessageHandler.showError(t);
     }

File: languagetool-language-modules/ru/src/main/java/org/languagetool/tagging/ru/RussianTagger.java
Patch:
@@ -71,8 +71,8 @@ public List<AnalyzedTokenReadings> tag(List<String> sentenceTokens) throws IOExc
                 word = word.replace("я̀", "я");
                 word = word.replace("ʼ", "ъ");
             }
-                word_ie=word_ie.toLowerCase();
-                word_ie=word.replace("е","ё");
+                word_ie=word.toLowerCase();
+                word_ie=word_ie.replace("е","ё");
 
             List<AnalyzedToken> l = getAnalyzedTokens(word);
 

File: languagetool-language-modules/ru/src/main/java/org/languagetool/tagging/ru/RussianTagger.java
Patch:
@@ -71,8 +71,8 @@ public List<AnalyzedTokenReadings> tag(List<String> sentenceTokens) throws IOExc
                 word = word.replace("я̀", "я");
                 word = word.replace("ʼ", "ъ");
             }
-                word_ie=word.replace("е","ё");
                 word_ie=word_ie.toLowerCase();
+                word_ie=word.replace("е","ё");
 
             List<AnalyzedToken> l = getAnalyzedTokens(word);
 

File: languagetool-language-modules/ru/src/test/java/org/languagetool/tagging/ru/RussianTaggerTest.java
Patch:
@@ -40,6 +40,9 @@ public void testTagger() throws IOException {
         "Все/[весь]ADJ:MPR:PL:Nom|Все/[весь]ADJ:MPR:PL:V|Все/[все]PNN:PL:Nom|Все/[все]PNN:PL:V|Все/[все]PNN:Sin:Nom|Все/[все]PNN:Sin:V -- счастливые/[счастливый]ADJ:Posit:PL:Nom|счастливые/[счастливый]ADJ:Posit:PL:V -- семьи/[семья]NN:Inanim:Fem:PL:Nom|семьи/[семья]NN:Inanim:Fem:PL:V|семьи/[семья]NN:Inanim:Fem:Sin:R -- похожи/[похожий]ADJ:Short:PL -- друг/[друг]NN:Anim:Masc:Sin:Nom -- на/[на]PREP -- друга/[друг]NN:Anim:Masc:Sin:R|друга/[друг]NN:Anim:Masc:Sin:V -- каждая/[каждый]ADJ:MPR:Fem:Nom -- несчастливая/[несчастливый]ADJ:Posit:Fem:Nom -- семья/[семья]NN:Inanim:Fem:Sin:Nom -- несчастлива/[несчастливый]ADJ:Short:Fem -- по-своему/[по-своему]ADV", tokenizer, tagger);
     TestTools.myAssert("Все смешалось в доме Облонских.",
         "Все/[весь]ADJ:MPR:PL:Nom|Все/[весь]ADJ:MPR:PL:V|Все/[все]PNN:PL:Nom|Все/[все]PNN:PL:V|Все/[все]PNN:Sin:Nom|Все/[все]PNN:Sin:V -- смешалось/[смешаться]VB:Past:INTR:PFV:Neut -- в/[в]PREP -- доме/[дом]NN:Inanim:Masc:Sin:P -- Облонских/[null]null", tokenizer, tagger);
+    TestTools.myAssert("Абдуллаевы",
+        "Абдуллаевы/[абдуллаев]NN:Fam:PL:Nom", tokenizer, tagger);
+
   }
 
 }

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/RuleMatchDiffFinder.java
Patch:
@@ -541,6 +541,7 @@ private void printFooterForIndex(FileWriter fw) throws IOException {
       "    col_2: 'none',\n" +
       "    col_3: 'none',\n" +
       "    col_4: 'select',\n" +
+      "    col_5: 'none',\n" +
       "    grid_layout: false,\n" +
       "    col_types: ['number', 'number', 'number', 'number', 'string', 'string'],\n" +
       "    extensions: [{ name: 'sort' }]\n" +

File: languagetool-commandline/src/test/java/org/languagetool/commandline/MainTest.java
Patch:
@@ -436,7 +436,7 @@ public void testEnglishFileAPI() throws Exception {
         "&apos;a university&apos;.\" " +
         "shortmsg=\"Wrong article\" " +
         "replacements=\"a\" context=\"This is an test.  This is a test of of language tool.  ...\" " +
-        "contextoffset=\"8\" offset=\"8\" errorlength=\"2\" category=\"Miscellaneous\" categoryid=\"MISC\" locqualityissuetype=\"misspelling\"/>"));
+        "contextoffset=\"8\" offset=\"8\" errorlength=\"2\" url=\"https://languagetool.org/insights/post/indefinite-articles/\" category=\"Miscellaneous\" categoryid=\"MISC\" locqualityissuetype=\"misspelling\"/>"));
   }
 
   @Test

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -127,15 +127,15 @@ protected abstract DetectedLanguage getLanguage(String text, Map<String, String>
     if (remoteRuleCount > 0) {
       LtThreadPoolFactory.createFixedThreadPoolExecutor(
         LtThreadPoolFactory.REMOTE_RULE_WAITING_POOL,
-        config.getMaxCheckThreads(), config.getMaxCheckThreads() * remoteRuleCount, 1,
+        config.getMaxCheckThreads(), Integer.MAX_VALUE, -1,
         60L, true, (thread, throwable) -> {
           log.error("Thread: " + thread.getName() + " failed with: " + throwable.getMessage());
         },
         true
       );
       LtThreadPoolFactory.createFixedThreadPoolExecutor(
         LtThreadPoolFactory.REMOTE_RULE_EXECUTING_POOL,
-        config.getMaxCheckThreads(), config.getMaxCheckThreads() * remoteRuleCount, 1,
+        config.getMaxCheckThreads(), Integer.MAX_VALUE, -1,
         60L, true, (thread, throwable) -> {
           log.error("Thread: " + thread.getName() + " failed with: " + throwable.getMessage());
         },

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -561,7 +561,7 @@ private boolean isException(AnalyzedTokenReadings token1, AnalyzedTokenReadings
     return "allen".equals(token1.getToken()) && "Grund".equals(token2.getToken());
   }
 
-  private List<String> getCategoriesCausingError(AnalyzedTokenReadings token1, AnalyzedTokenReadings token2) {
+  List<String> getCategoriesCausingError(AnalyzedTokenReadings token1, AnalyzedTokenReadings token2) {
     List<String> categories = new ArrayList<>();
     List<GrammarCategory> categoriesToCheck = Arrays.asList(GrammarCategory.KASUS, GrammarCategory.GENUS, GrammarCategory.NUMERUS);
     for (GrammarCategory category : categoriesToCheck) {

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/EnglishRepeatedWordsRuleTest.java
Patch:
@@ -75,7 +75,7 @@ public void testRule() throws IOException {
 
     // suggest
     assertCorrectText("I suggested that, but he also suggests that.");
-    assertCorrectText("They suggested that we should audit them again. What does that suggest about the store's transactions?");
+    assertCorrectText("He suggested that we review them again. What do these suggest about the transaction history?");
     assertCorrectText("I suggested he look it over again. This strongly suggests that Mr. Batt is guilty.");
 
     // ignore sentences without period at the end

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -352,7 +352,7 @@ private void logError(String remoteAddress, Exception e, int errorCode, HttpExch
     }
     if (errorCode < 500) {
       logger.info(LoggingTools.BAD_REQUEST, message);
-    } else if (e.getMessage().contains("took longer than")) {
+    } else if (e.getMessage() != null && e.getMessage().contains("took longer than")) {
       logger.warn(LoggingTools.REQUEST, message);
     } else {
       logger.error(LoggingTools.REQUEST, message);

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1073,7 +1073,7 @@ protected void fetchRemoteRuleResults(Mode mode, Level level, List<AnalyzedSente
       }
 
       // cancel any remaining tasks (e.g. after interrupt because request timed out)
-      remoteRuleTasks.forEach(t -> t.cancel(true));
+      remoteRuleTasks.stream().filter(Objects::nonNull).forEach(t -> t.cancel(true));
     }
   }
 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleCheck.java
Patch:
@@ -204,7 +204,7 @@ public void addParaErrorsToCache(int nFPara, SwJLanguageTool lt, int cacheNum, i
       int nTPara = docCache.getNumberOfTextParagraph(nFPara);
       String textToCheck = docCache.getDocAsString(nTPara, parasToCheck, checkOnlyParagraph, useQueue, hasFootnotes);
       List<RuleMatch> paragraphMatches = null;
-      if (mDocHandler.isSortedRuleForIndex(cacheNum)) {
+      if (lt != null && mDocHandler.isSortedRuleForIndex(cacheNum)) {
         paragraphMatches = lt.check(textToCheck, true, JLanguageTool.ParagraphHandling.ONLYPARA);
       }
       

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -83,6 +83,8 @@ public GermanCompoundTokenizer(boolean strictMode) throws IOException {
     wordSplitter.addException("Tauschwerte", asList("Tausch", "werte"));
     wordSplitter.addException("Tauschwertes", asList("Tausch", "wertes"));
     wordSplitter.addException("Kinderspielen", asList("Kinder", "spielen"));
+    wordSplitter.addException("Buchhaltungstrick", asList("Buchhaltungs", "trick"));
+    wordSplitter.addException("Buchhaltungstricks", asList("Buchhaltungs", "tricks"));
     wordSplitter.setStrictMode(strictMode);
     wordSplitter.setMinimumWordLength(3);
   }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -281,6 +281,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Die meisten Lebensmittel enthalten das.");  // Lebensmittel has NOG as gender in Morphy
     // TODO: Find agreement errors in relative clauses
     assertBad("Gutenberg, die Genie.");
+    assertBad("Wahrlich ein äußerst kritische Jury.", "eine äußerst kritische Jury");
     //assertBad("Gutenberg, die größte Genie.");
     //assertBad("Gutenberg, die größte Genie aller Zeiten.");
     assertGood("Die wärmsten Monate sind August und September, die kältesten Januar und Februar.");

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractRepeatedWordsRule.java
Patch:
@@ -89,9 +89,12 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
     int wordNumber = 0;
     Map<String, Integer> wordsLastSeen = new HashMap<>();
     int pos = 0;
+    int prevSentenceLength = 0;
     for (AnalyzedSentence sentence : sentences) {
       // sentenceNumber++;
       AnalyzedTokenReadings[] tokens = getSentenceWithImmunization(sentence).getTokensWithoutWhitespace();
+      pos += prevSentenceLength;
+      prevSentenceLength = sentence.getText().length();
       // ignore sentences not ending in period
       String lastToken = tokens[tokens.length-1].getToken();
       if (!lastToken.equals(".") && !lastToken.equals("!") && !lastToken.equals("?")) {
@@ -169,7 +172,6 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
           }
         }
       }
-      pos += sentence.getText().length();
     }
     return toRuleMatchArray(matches);
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -82,6 +82,7 @@ public GermanCompoundTokenizer(boolean strictMode) throws IOException {
     wordSplitter.addException("Reinigungstabs", asList("Reinigungs", "tabs"));
     wordSplitter.addException("Tauschwerte", asList("Tausch", "werte"));
     wordSplitter.addException("Tauschwertes", asList("Tausch", "wertes"));
+    wordSplitter.addException("Kinderspielen", asList("Kinder", "spielen"));
     wordSplitter.setStrictMode(strictMode);
     wordSplitter.setMinimumWordLength(3);
   }

File: languagetool-server/src/main/java/org/languagetool/server/Server.java
Patch:
@@ -189,8 +189,9 @@ protected ThreadPoolExecutor getExecutorService(HTTPServerConfig config) {
     int threadPoolSize = config.getMaxCheckThreads();
     ServerTools.print("Setting up thread pool with " + threadPoolSize + " threads");
 
+    // reuse = false -> this should only be called once in production, needs to be false for tests
     return LtThreadPoolFactory.createFixedThreadPoolExecutor(LtThreadPoolFactory.SERVER_POOL,
       threadPoolSize, threadPoolSize, 0,0L, false,
-      (thread, throwable) -> log.error("Thread: " + thread.getName() + " failed with: " + throwable.getMessage()), true);
+      (thread, throwable) -> log.error("Thread: " + thread.getName() + " failed with: " + throwable.getMessage()), false);
   }
 }

File: languagetool-dev/src/main/java/org/languagetool/dev/bigdata/GermanUppercasePhraseFinder.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.languagetool.dev.bigdata;
 
-import joptsimple.internal.Strings;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.index.*;
 import org.apache.lucene.search.IndexSearcher;
@@ -85,7 +84,7 @@ public static void main(String[] args) throws IOException {
       if (!useful || lcCount == 0 || lcCount == 2) {
         continue;
       }
-      String uppercase = Strings.join(ucParts, " ");
+      String uppercase = String.join(" ", ucParts);
       if (term.equals(uppercase)){
         continue;
       }

File: languagetool-dev/src/main/java/org/languagetool/dev/bigdata/ProhibitedCompoundRuleEvaluator.java
Patch:
@@ -21,7 +21,7 @@
 
 package org.languagetool.dev.bigdata;
 
-import org.apache.commons.lang.StringUtils;
+import org.apache.commons.lang3.StringUtils;
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.JLanguageTool;
 import org.languagetool.Language;

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/wikipedia/LocationHelperTest.java
Patch:
@@ -18,13 +18,15 @@
  */
 package org.languagetool.dev.wikipedia;
 
+import org.junit.Ignore;
 import org.junit.Test;
 import xtc.tree.Location;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.fail;
 
+@Ignore
 public class LocationHelperTest {
 
   @Test

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/wikipedia/SuggestionReplacerTest.java
Patch:
@@ -41,6 +41,7 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.junit.Assert.assertTrue;
 
+@Ignore
 public class SuggestionReplacerTest {
 
   private final SwebleWikipediaTextFilter filter = new SwebleWikipediaTextFilter();

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/wikipedia/WikipediaQuickCheckTest.java
Patch:
@@ -27,9 +27,11 @@
 import java.net.URL;
 import java.util.List;
 
+import org.junit.Ignore;
 import org.junit.Test;
 import org.languagetool.language.GermanyGerman;
 
+@Ignore
 public class WikipediaQuickCheckTest {
 
   // only for interactive use, as it accesses a remote API

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/wikipedia/WikipediaTextFilterTest.java
Patch:
@@ -18,10 +18,12 @@
  */
 package org.languagetool.dev.wikipedia;
 
+import org.junit.Ignore;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 
+@Ignore
 public class WikipediaTextFilterTest {
 
   private final SwebleWikipediaTextFilter swebleFilter = new SwebleWikipediaTextFilter();

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -581,6 +581,7 @@ public void testDashAndHyphenEtc() throws Exception {
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Ist doch - gut")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Ist doch -- gut")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Stil- und Grammatikprüfung gut")).length);
+    assertEquals(0, rule.match(lt.getAnalyzedSentence("Oliven- und Mandelöl")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Stil-, Text- und Grammatikprüfung gut")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Er liebt die Stil-, Text- und Grammatikprüfung.")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Stil-, Text- und Grammatikprüfung")).length);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -884,7 +884,7 @@ public void testGetSuggestionOrder() throws Exception {
     assertCorrectionsByOrder(rule, "heisst", "heißt");  // "heißt" should be first
     assertCorrectionsByOrder(rule, "heissen", "heißen");
     assertCorrectionsByOrder(rule, "müßte", "musste", "müsste");
-    assertCorrectionsByOrder(rule, "schmohren", "schmoren", "Lehmohren");
+    assertCorrectionsByOrder(rule, "schmohren", "schmoren");
     assertCorrectionsByOrder(rule, "Fänomen", "Phänomen");
     assertCorrectionsByOrder(rule, "homofob", "homophob");
     assertCorrectionsByOrder(rule, "ueber", "über");

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikMultiSpeller.java
Patch:
@@ -127,6 +127,7 @@ private List<byte[]> getLines(BufferedReader br, String path) throws IOException
   private final Long userDictCacheSize;
   private final String userDictName;
   private final UserDictCacheKey userDictCacheKey;
+  private static final int MAX_SUGGESTIONS = 20;
 
   public MorfologikMultiSpeller(String binaryDictPath, List<String> plainTextPaths, String languageVariantPlainTextPath, int maxEditDistance) throws IOException {
     this(binaryDictPath, plainTextPaths, languageVariantPlainTextPath, null, maxEditDistance);
@@ -370,7 +371,7 @@ private List<String> getSuggestionsFromSpellers(String word, List<MorfologikSpel
     for (WeightedSuggestion weightedSuggestion : result) {
       wordResults.add(weightedSuggestion.getWord());
     }
-    return wordResults;
+    return wordResults.subList(0, Math.min(MAX_SUGGESTIONS, result.size()));
   }
 
   /**

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -126,6 +126,8 @@ enum ReplacementType {
   private static final String[] REL_PRONOUN_LEMMAS = {"der", "welch"};
 
   private static final Set<String> PRONOUNS_TO_BE_IGNORED = new HashSet<>(Arrays.asList(
+    "nichts",
+    "alles",   // "Ruhe vor dem alles verheerenden Sturm", "Alles Große und Edle ist einfacher Art."
     "dies",
     "ich",
     "dir",

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -200,6 +200,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Können Sie das nächsten Monat erledigen?");
     assertGood("Können Sie das auch nächsten Monat erledigen?");
     assertGood("War das Absicht?");
+    assertGood("Alles Große und Edle ist einfacher Art.");
 
     assertGood("Das Dach meines Autos.");
     assertGood("Das Dach meiner Autos.");

File: languagetool-server/src/main/java/org/languagetool/server/ApiV2.java
Patch:
@@ -110,7 +110,7 @@ private void handleLanguagesRequest(HttpExchange httpExchange) throws IOExceptio
   }
 
   private void handleMaxTextLengthRequest(HttpExchange httpExchange, HTTPServerConfig config) throws IOException {
-    String response = Integer.toString(UserLimits.getDefaultLimits(config).getMaxTextLength());
+    String response = Integer.toString(config.getMaxTextLengthAnonymous());
     ServerTools.setCommonHeaders(httpExchange, TEXT_CONTENT_TYPE, allowOriginUrl);
     httpExchange.sendResponseHeaders(HttpURLConnection.HTTP_OK, response.getBytes(ENCODING).length);
     httpExchange.getResponseBody().write(response.getBytes(ENCODING));

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementSuggestor2Test.java
Patch:
@@ -73,6 +73,8 @@ public void testSuggestions() throws IOException {
       "das vorangegangene versuchen, dem vorangegangenen versuchen, des vorangegangenen Versuchens, der vorangegangenen Versuche, " +
       "dem vorangegangenen Versuch, des vorangegangenen Versuchs, des vorangegangenen versuchens, die vorangegangenen Versuche]");
     assertSuggestion1("der Blutflusses", "[des Blutflusses, der Blutfluss, der Blutflüsse, den Blutfluss, dem Blutfluss, den Blutflüssen, die Blutflüsse]");
+    assertSuggestion2("ein anstrengenden Tag",
+      "[ein anstrengender Tag, ein anstrengendes Tag, einen anstrengenden Tag, einem anstrengenden Tag, eines anstrengenden Tags, eines anstrengenden Tages]");
     //assertSuggestion2("vor allem Teams", "[vor allen Teams]");  // TODO: 'allen' is PRO:IND, 'allem' is PRO:DEM, so we don't map yet between those
   }
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -595,6 +595,7 @@ public void testRegression() throws IOException {
   @Test
   public void testDetAdjNounRule() throws IOException {
     // correct sentences:
+    assertGood("Die Übernahme der früher selbständigen Gesellschaft");
     assertGood("Das ist, weil man oft bei anderen schreckliches Essen vorgesetzt bekommt.");
     assertGood("Das ist der riesige Tisch.");
     assertGood("Der riesige Tisch ist groß.");

File: languagetool-core/src/main/java/org/languagetool/rules/CleanOverlappingFilter.java
Patch:
@@ -73,6 +73,9 @@ public final List<RuleMatch> filter(List<RuleMatch> ruleMatches) {
         currentPriority += negativeConstant;
       }
       int prevPriority = language.getRulePriority(prevRuleMatch.getRule());
+      if (isPremiumRule(prevRuleMatch) && hidePremiumMatches) {
+        prevPriority = Integer.MIN_VALUE;
+      }
       if (prevRuleMatch.getRule().getTags().contains(Tag.picky) && prevPriority != Integer.MIN_VALUE) {
         prevPriority += negativeConstant;
       }

File: languagetool-core/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -139,6 +139,7 @@ public class WordListValidatorTest {
           "Subašić",
           "celebrytę", // for PL
           "antybiotykoterapię", // for PL
+          "elektromobilność", // for PL
           "kryptowalutę", // for PL
           "fotowoltaikę", // for PL
           "insulinooporność", // for PL

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -80,6 +80,8 @@ public GermanCompoundTokenizer(boolean strictMode) throws IOException {
     //wordSplitter.addException("Sportshorts", asList("Sport", "shorts")); 
     wordSplitter.addException("Reinigungstab", asList("Reinigungs", "tab"));
     wordSplitter.addException("Reinigungstabs", asList("Reinigungs", "tabs"));
+    wordSplitter.addException("Tauschwerte", asList("Tausch", "werte"));
+    wordSplitter.addException("Tauschwertes", asList("Tausch", "wertes"));
     wordSplitter.setStrictMode(strictMode);
     wordSplitter.setMinimumWordLength(3);
   }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanRepeatedWordsRuleTest.java
Patch:
@@ -48,9 +48,9 @@ public void testRule() throws IOException {
     
     assertCorrectText("Lauf so schnell wie möglich. Das ist MÖGLICH!");
         
-    /*RuleMatch[] matches=getRuleMatches("Lauf so schnell wie möglich. Ein anderes Amazonien ist möglich");
+    RuleMatch[] matches=getRuleMatches("Das ist hervorragende Arbeit. Die Ergebnisse sind hervorragend.");
     assertEquals(1, matches.length);
-    assertEquals("[denkbar, machbar, zulässig, ausführbar, erreichbar]", matches[0].getSuggestedReplacements().toString());*/
+    assertEquals("[brillant, exzellent, perfekt, fantastisch, traumhaft]", matches[0].getSuggestedReplacements().toString());
             
   }
   

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/EnglishRepeatedWordsRuleTest.java
Patch:
@@ -71,9 +71,9 @@ public void testRule() throws IOException {
     assertEquals("proposes", matches[0].getSuggestedReplacements().get(0));
     assertEquals("proposed", matches[1].getSuggestedReplacements().get(0));
     
-    matches=getRuleMatches ("The problem was global. And the solutions needed to be global.");
+    matches=getRuleMatches ("The problem was weird. And the solutions needed to be weird.");
     assertEquals(1, matches.length);
-    assertEquals("comprehensive", matches[0].getSuggestedReplacements().get(0));
+    assertEquals("odd", matches[0].getSuggestedReplacements().get(0));
     
     matches=getRuleMatches("It needs to be done. That needs to be done.");
     assertEquals(1, matches.length);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanRepeatedWordsRuleTest.java
Patch:
@@ -48,9 +48,9 @@ public void testRule() throws IOException {
     
     assertCorrectText("Lauf so schnell wie möglich. Das ist MÖGLICH!");
         
-    RuleMatch[] matches=getRuleMatches("Lauf so schnell wie möglich. Ein anderes Amazonien ist möglich");
+    /*RuleMatch[] matches=getRuleMatches("Lauf so schnell wie möglich. Ein anderes Amazonien ist möglich");
     assertEquals(1, matches.length);
-    assertEquals("[denkbar, machbar, zulässig, ausführbar, erreichbar]", matches[0].getSuggestedReplacements().toString());
+    assertEquals("[denkbar, machbar, zulässig, ausführbar, erreichbar]", matches[0].getSuggestedReplacements().toString());*/
             
   }
   

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanWordRepeatBeginningRuleTest.java
Patch:
@@ -34,6 +34,7 @@ public class GermanWordRepeatBeginningRuleTest {
   @Test
   public void testRule() throws IOException {
     JLanguageTool lt = new JLanguageTool(Languages.getLanguageForShortCode("de-DE"));
+    lt.disableRule("DE_REPEATEDWORDS");
     // correct sentences:
     assertEquals(0, lt.check("Er ist nett. Er heißt Max.").size());
     assertEquals(0, lt.check("Außerdem kommt er. Ferner kommt sie. Außerdem kommt es.").size());

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/Match.java
Patch:
@@ -36,7 +36,7 @@ public final class Match {
 
   /** Possible string case conversions. **/
   public enum CaseConversion {
-    NONE, STARTLOWER, STARTUPPER, ALLLOWER, ALLUPPER, PRESERVE
+    NONE, STARTLOWER, STARTUPPER, ALLLOWER, ALLUPPER, PRESERVE, FIRSTUPPER
   }
 
   public enum IncludeRange {

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1304,7 +1304,7 @@ private List<RuleMatch> checkAnalyzedSentence(ParagraphHandling paraMode, List<R
         }
         if (maxErrorsPerWordRate > 0 && errorsPerWord > maxErrorsPerWordRate && wordCounter > 25) {
           errorRateLog.forEach(logger::error);
-          logger.error("ErrorRateTooHigh is reached by a single sentence after rule: " + rule.getFullId() +
+          logger.info("ErrorRateTooHigh is reached by a single sentence after rule: " + rule.getFullId() +
             " the hole text contains " + wordCounter + " words " +
             " this sentence has " + sentenceMatches.size() + " matches");
           throw new ErrorRateTooHighException("ErrorRateTooHigh is reached by a single sentence after rule: " + rule.getFullId() +

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LORemoteLanguageTool.java
Patch:
@@ -404,12 +404,12 @@ static class RemoteRule extends Rule {
       minConfigurableValue = 0;
       maxConfigurableValue = 100;
       configureText = "";
-      String categoryId = remoteMatch.getCategoryId().isEmpty() ? null : remoteMatch.getCategoryId().get();
-      String categoryName = remoteMatch.getCategory().isEmpty() ? null : remoteMatch.getCategory().get();
+      String categoryId = remoteMatch.getCategoryId().orElse(null);
+      String categoryName = remoteMatch.getCategory().orElse(null);
       if (categoryId != null && categoryName != null) {
         setCategory(new Category(new CategoryId(categoryId), categoryName));
       }
-      String locQualityIssueType = remoteMatch.getLocQualityIssueType().isEmpty() ? null : remoteMatch.getLocQualityIssueType().get();
+      String locQualityIssueType = remoteMatch.getLocQualityIssueType().orElse(null);
       if (locQualityIssueType != null) {
         setLocQualityIssueType(ITSIssueType.getIssueType(locQualityIssueType));
       }

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1308,7 +1308,7 @@ private List<RuleMatch> checkAnalyzedSentence(ParagraphHandling paraMode, List<R
             " the hole text contains " + wordCounter + " words " +
             " this sentence has " + sentenceMatches.size() + " matches");
           throw new ErrorRateTooHighException("ErrorRateTooHigh is reached by a single sentence after rule: " + rule.getFullId() +
-            " the hole text contains " + wordCounter + " words" +
+            " the whole text contains " + wordCounter + " words" +
             " this sentence has " + sentenceMatches.size() + " matches");
         }
       }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanRepeatedWordsRule.java
Patch:
@@ -67,7 +67,7 @@ protected Synthesizer getSynthesizer() {
   @Override
   protected boolean isException(AnalyzedTokenReadings[] tokens, int i, boolean sentStart, boolean isCapitalized,
       boolean isAllUppercase) {
-    if (isAllUppercase | (isCapitalized && !sentStart)) {
+    if (isAllUppercase || (isCapitalized && !sentStart)) {
       return true;
     }
     if (tokens[i].hasPosTagStartingWith("EIG:")) {

File: languagetool-language-modules/fr/src/test/java/org/languagetool/rules/fr/FrenchRepeatedWordsRuleTest.java
Patch:
@@ -54,7 +54,7 @@ public void testRule() throws IOException {
     
     matches = getRuleMatches("Elle est maintenant phénoménale. Les choses sont maintenant compliquées");
     assertEquals(1, matches.length);
-    assertEquals("[présentement, ce jour-ci, désormais]", matches[0].getSuggestedReplacements().toString());
+    assertEquals("[présentement, ce jour-ci, désormais, à présent]", matches[0].getSuggestedReplacements().toString());
     
     
   }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -203,6 +203,9 @@ public void testRule() throws IOException {
     assertGood("..., die ins Nichts griff.");
     assertGood("Er fragte, was sie über das denken und zwinkerte ihnen zu.");
     assertGood("dem Ägyptischen, Berberischen, Semitischen, Kuschitischen, Omotischen und dem Tschadischen");
+    assertGood("mit S-Bahn-ähnlichen Verkehrsmitteln");
+    assertGood("mit S-Bahn-ähnlichen und günstigen Verkehrsmitteln");
+    assertGood("mit S-Bahn-ähnlichen, schnellen Verkehrsmitteln");
 
     //assertBad("Sie sind nicht Verständlich");
     assertBad("Das machen der Töne ist schwierig.");

File: languagetool-core/src/main/java/org/languagetool/tools/LtThreadPoolFactory.java
Patch:
@@ -84,5 +84,5 @@ public static Optional<ThreadPoolExecutor> getFixedThreadPoolExecutor(@NotNull S
     }
   }
 
-  static final ThreadPoolExecutor defaultPool = new ThreadPoolExecutor(1, 64, 60, SECONDS, new LinkedBlockingQueue<>(), new ThreadFactoryBuilder().setNameFormat("default-lt-pool-%d").build(), new ThreadPoolExecutor.AbortPolicy());
+  static final ThreadPoolExecutor defaultPool = new ThreadPoolExecutor(12, 64, 60, SECONDS, new LinkedBlockingQueue<>(), new ThreadFactoryBuilder().setNameFormat("default-lt-pool-%d").build(), new ThreadPoolExecutor.AbortPolicy());
 }

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -867,7 +867,7 @@ public List<RuleMatch> check(AnnotatedText annotatedText, boolean tokenizeText,
    * @since 4.3
    */
   public List<RuleMatch> check(AnnotatedText annotatedText, boolean tokenizeText, ParagraphHandling paraMode, RuleMatchListener listener, Mode mode, Level level) throws IOException {
-    return check(annotatedText, tokenizeText, paraMode, listener, mode, level);
+    return check(annotatedText, tokenizeText, paraMode, listener, mode, level, null);
   }
 
   /**

File: languagetool-core/src/main/java/org/languagetool/tools/LtThreadPoolFactory.java
Patch:
@@ -84,5 +84,5 @@ public static Optional<ThreadPoolExecutor> getFixedThreadPoolExecutor(@NotNull S
     }
   }
 
-  private static final ThreadPoolExecutor defaultPool = new ThreadPoolExecutor(1, 64, 60, SECONDS, new LinkedBlockingQueue<>(), new ThreadFactoryBuilder().setNameFormat("default-lt-pool-%d").build(), new ThreadPoolExecutor.AbortPolicy());
+  static final ThreadPoolExecutor defaultPool = new ThreadPoolExecutor(1, 64, 60, SECONDS, new LinkedBlockingQueue<>(), new ThreadFactoryBuilder().setNameFormat("default-lt-pool-%d").build(), new ThreadPoolExecutor.AbortPolicy());
 }

File: languagetool-core/src/test/java/org/languagetool/tools/LtThreadPoolFactoryTest.java
Patch:
@@ -61,7 +61,7 @@ public void notcachedThreadPoolTest() {
         System.out.println(throwable.getClass());
       },
       false);
-    assertFalse(LtThreadPoolFactory.getFixedThreadPoolExecutor("Test-Pool-notCached").isPresent());
+    assertEquals(LtThreadPoolFactory.defaultPool, LtThreadPoolFactory.getFixedThreadPoolExecutor("Test-Pool-notCached").get());
   }
 
   @Test

File: languagetool-core/src/test/java/org/languagetool/RemoteRuleCacheTest.java
Patch:
@@ -108,7 +108,7 @@ private List<RuleMatch> check(String text) {
 
     try {
       return lt.check(annotatedText, true, JLanguageTool.ParagraphHandling.NORMAL, null,
-        JLanguageTool.Mode.ALL, JLanguageTool.Level.DEFAULT, remoteRulePool);
+        JLanguageTool.Mode.ALL, JLanguageTool.Level.DEFAULT);
     } catch (IOException e) {
       throw new RuntimeException(e);
     }

File: languagetool-core/src/test/java/org/languagetool/rules/RemoteRuleTimeoutTest.java
Patch:
@@ -144,8 +144,7 @@ public void testCancelThreads() throws IOException, InterruptedException, Timeou
       for (int j = 0; j < batches; j++) {
         FutureTask<List<RuleMatch>> task = new FutureTask<>(() -> {
           List<RuleMatch> matches = lt.check(text, true,
-            JLanguageTool.ParagraphHandling.NORMAL, listener, JLanguageTool.Mode.ALL, JLanguageTool.Level.DEFAULT,
-            pool);
+            JLanguageTool.ParagraphHandling.NORMAL, listener, JLanguageTool.Mode.ALL, JLanguageTool.Level.DEFAULT);
           return matches;
         });
         pool.submit(task);

File: languagetool-core/src/main/java/org/languagetool/rules/RemoteRule.java
Patch:
@@ -60,9 +60,9 @@ public abstract class RemoteRule extends Rule {
 
   // needed to run callables with timeout
   static final ExecutorService executor = LtThreadPoolFactory.createFixedThreadPoolExecutor(
-    "lt-textchecker-thread",
-    50,
-    200,
+    "remote-rule-thread",
+    RemoteRuleConfig.getRemoteRuleCount(),
+    RemoteRuleConfig.getRemoteRuleCount() * 4,
     true, (thread, throwable) -> {
       logger.error("Thread: " + thread.getName() + " failed with: " + throwable.getMessage());
     },

File: languagetool-core/src/main/java/org/languagetool/tools/LtThreadPoolFactory.java
Patch:
@@ -43,7 +43,7 @@ private LtThreadPoolFactory() {
    * @param maxTaskInQueue   Number of maximum Task in the pool queue
    * @param isDaemon         Run the threads as daemon threads
    * @param exceptionHandler Handler for exceptions in Thread
-   * @param reuse            True if thread-pool should be reused                        
+   * @param reuse            True if thread-pool should be reused
    * @return a Fixed ThreadPoolExecutor
    */
   public static ThreadPoolExecutor createFixedThreadPoolExecutor(@NotNull String identifier, @NotNull int maxThreads, @NotNull int maxTaskInQueue, @NotNull boolean isDaemon, @NotNull Thread.UncaughtExceptionHandler exceptionHandler, @NotNull boolean reuse) {
@@ -52,7 +52,7 @@ public static ThreadPoolExecutor createFixedThreadPoolExecutor(@NotNull String i
       return executorServices.get(identifier);
     }
     log.info(String.format("Create new threadPool with maxThreads: %d maxTaskInQueue: %d identifier: %s daemon: %s exceptionHandler: %s", maxThreads, maxTaskInQueue, identifier, isDaemon, exceptionHandler));
-    ArrayBlockingQueue<Runnable> boundedQueue = new ArrayBlockingQueue<>(maxTaskInQueue);
+    BlockingQueue<Runnable> boundedQueue = new ArrayBlockingQueue<>(maxTaskInQueue);
     ThreadFactory threadFactory = new ThreadFactoryBuilder()
       .setNameFormat(identifier + "-%d")
       .setDaemon(isDaemon)

File: languagetool-core/src/test/java/org/languagetool/tools/LtThreadPoolFactoryTest.java
Patch:
@@ -22,7 +22,6 @@
 
 import org.junit.Test;
 
-import java.sql.SQLOutput;
 import java.util.Optional;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.ThreadPoolExecutor;

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -515,6 +515,9 @@ protected int getPriorityForId(String id) {
     if (id.startsWith("CONFUSION_RULE_")) {
       return -20;
     }
+    if (id.startsWith("AI_SPELLING")) {
+      return -9; // higher than MORFOLOGIK_*, for testing
+    }
     if (id.startsWith("AI_HYDRA_LEO")) { // prefer more specific rules (also speller)
       if (id.startsWith("AI_HYDRA_LEO_CP")) {
         return 2;

File: languagetool-core/src/main/java/org/languagetool/rules/RemoteRule.java
Patch:
@@ -156,7 +156,9 @@ public FutureTask<RemoteRuleResult> run(List<AnalyzedSentence> sentences, @Nulla
     }
     Map<String, String> context = MDC.getCopyOfContextMap();
     return new FutureTask<>(() -> {
-      MDC.setContextMap(context);
+      if (context != null) {
+        MDC.setContextMap(context);
+      }
       long startTime = System.nanoTime();
       long characters = sentences.stream().mapToInt(sentence -> sentence.getText().length()).sum();
       String ruleId = getId();

File: languagetool-language-modules/fr/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -46,7 +46,7 @@ public void testLanguageDependentFilter() throws IOException {
     List<RuleMatch> matches = tool.check(annotatedText, true, ParagraphHandling.NORMAL, listener, Mode.ALL,
         Level.PICKY);
     assertEquals(1, matches.size());
-    assertEquals("[D’homme]", matches.get(0).getSuggestedReplacements().toString());
+    assertEquals("[D'homme]", matches.get(0).getSuggestedReplacements().toString());
 
     // normal mode: suggestions with straight apostrophes
     analyzedSentence = tool.getAnalyzedSentence("De homme");

File: languagetool-language-modules/de/src/main/java/org/languagetool/tagging/disambiguation/rules/de/GermanRuleDisambiguator.java
Patch:
@@ -31,7 +31,7 @@
 
 public class GermanRuleDisambiguator extends AbstractDisambiguator {
   
-  private final Disambiguator disambiguator = new XmlRuleDisambiguator(new GermanyGerman());
+  private final Disambiguator disambiguator = new XmlRuleDisambiguator(new GermanyGerman(), true);
 
   @Override
   public final AnalyzedSentence disambiguate(AnalyzedSentence input)

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/ApostropheTypeFilter.java
Patch:
@@ -46,7 +46,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
             + match.getRule().getFullId() + ", wordFrom: " + posWord);
       }
       AnalyzedTokenReadings atrWord = patternTokens[posWord - 1];
-      if (hasTypographicalApostrophe && !atrWord.hasTypographicApostrophe()) {
+      if (hasTypographicalApostrophe == atrWord.hasTypographicApostrophe()) {
         return match;
       }
     }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -642,8 +642,8 @@ private boolean agreementWithCategoryRelaxation(AnalyzedTokenReadings token1,
   private Set<String> retainCommonCategories(AnalyzedTokenReadings token1,
                                              AnalyzedTokenReadings token2, AnalyzedTokenReadings token3) {
     Set<GrammarCategory> categoryToRelaxSet = Collections.emptySet();
-    Set<String> set1 = AgreementTools.getAgreementCategories(token1, categoryToRelaxSet, true);
     boolean skipSol = !VIELE_WENIGE_LOWERCASE.contains(token1.getToken().toLowerCase());
+    Set<String> set1 = AgreementTools.getAgreementCategories(token1, categoryToRelaxSet, skipSol);
     Set<String> set2 = AgreementTools.getAgreementCategories(token2, categoryToRelaxSet, skipSol);
     Set<String> set3 = AgreementTools.getAgreementCategories(token3, categoryToRelaxSet, true);
     set1.retainAll(set2);
@@ -655,8 +655,8 @@ private Set<String> retainCommonCategories(AnalyzedTokenReadings token1,
   private Set<String> retainCommonCategories(AnalyzedTokenReadings token1,
                                              AnalyzedTokenReadings token2, AnalyzedTokenReadings token3, AnalyzedTokenReadings token4) {
     Set<GrammarCategory> categoryToRelaxSet = Collections.emptySet();
-    Set<String> set1 = AgreementTools.getAgreementCategories(token1, categoryToRelaxSet, true);
     boolean skipSol = !VIELE_WENIGE_LOWERCASE.contains(token1.getToken().toLowerCase());
+    Set<String> set1 = AgreementTools.getAgreementCategories(token1, categoryToRelaxSet, skipSol);
     Set<String> set2 = AgreementTools.getAgreementCategories(token2, categoryToRelaxSet, skipSol);
     Set<String> set3 = AgreementTools.getAgreementCategories(token3, categoryToRelaxSet, skipSol);
     Set<String> set4 = AgreementTools.getAgreementCategories(token4, categoryToRelaxSet, true);

File: languagetool-core/src/main/java/org/languagetool/Languages.java
Patch:
@@ -146,7 +146,7 @@ private static Language createLanguageObjects(URL url, String className) {
   }
 
   private static boolean hasPremium(String className) {
-    return className.matches("org\\.languagetool\\.language\\.(German|GermanyGerman|AustrianGerman|SwisssGerman|Dutch|French|Spanish|English|AmericanEnglish|BritishEnglish|CanadianEnglish|NewZealandEnglish|SouthAfricanEnglish)");
+    return className.matches("org\\.languagetool\\.language\\.(German|GermanyGerman|AustrianGerman|SwissGerman|Dutch|French|Spanish|English|AustralianEnglish|AmericanEnglish|BritishEnglish|CanadianEnglish|NewZealandEnglish|SouthAfricanEnglish)");
   }
 
   /**

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/RuleMatchDiffFinder.java
Patch:
@@ -422,7 +422,7 @@ private void run(LightRuleMatchParser parser, File file1, File file2, File outpu
         String id = file.replaceFirst("result_.*?_", "").replace(".html", "");
         fw.write("  <a href='" + file + "'>" + id + "</a>");
         fw.write("  <a href='https://internal1.languagetool.org/grafana/d/BY_CNDHGz/rule-events-analysis?orgId=1&var-rule_id=" +
-          id.replaceFirst("\\[[0-9]+\\]", "") + "&var-language=" + langCode + "'>[g]</a>");
+          id.replaceFirst("\\[[0-9]+\\]", "") + "&var-language=" + langCode.replaceFirst("-.*", "") + "'>[g]</a>");
         fw.write("</td>");
         if (outputFile.items.size() > 0 && outputFile.items.get(0).getNewMatch() != null) {
           fw.write("<td class='msg'>" + escapeSentence(outputFile.items.get(0).getNewMatch().getMessage()) + "</td>");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -304,11 +304,11 @@ public RuleMatch[] match(AnalyzedSentence sentence) {
               ruleMatches.add(ruleMatch);
             }
           } else if (tokenPos+1 < tokens.length && hasReadingOfType(tokens[tokenPos+1], POSType.NOMEN) && GermanHelper.hasReadingOfType(tokens[tokenPos], POSType.ADJEKTIV)) {
-            RuleMatch ruleMatch = checkDetAdjAdjNounAgreement(maybePreposition, tokens[i],
+            /*RuleMatch ruleMatch = checkDetAdjAdjNounAgreement(maybePreposition, tokens[i],
               nextToken, tokens[tokenPos], tokens[tokenPos+1], sentence, i, replMap);
             if (ruleMatch != null) {
               ruleMatches.add(ruleMatch);
-            }
+            }*/
           }
         } else if (hasReadingOfType(nextToken, POSType.NOMEN) && !"Herr".equals(nextToken.getToken())) {
           RuleMatch ruleMatch = checkDetNounAgreement(maybePreposition, tokens[i], nextToken, sentence, i, replMap);

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractRepeatedWordsRule.java
Patch:
@@ -63,6 +63,7 @@ protected int maxWordsDistance() {
   public AbstractRepeatedWordsRule(ResourceBundle messages) {
     super(messages);
     super.setCategory(Categories.STYLE.getCategory(messages));
+    super.setLocQualityIssueType(ITSIssueType.Style);
   }
 
   protected String adjustPostag(String postag) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -381,7 +381,7 @@ public void testDetNounRule() throws IOException {
     assertBad("Das interessiert das Mann.", "der Mann", "den Mann", "dem Mann");
     assertBad("Das interessiert die Mann.", "der Mann", "den Mann", "dem Mann", "die Männer");
     assertBad("Das Auto ein Mannes.", "ein Mann", "eines Mannes");
-    assertBad("Das Auto einem Mannes.", "einem Mann", "eines Mannes");
+    assertBad("Das Auto einem Mannes.", "einem Mann", "einem Manne", "eines Mannes");
     assertBad("Das Auto einer Mannes.", "eines Mannes");
     assertBad("Das Auto einen Mannes.", "einen Mann", "eines Mannes");
     assertBad("Die Galerie zu den Bilder findet sich hier.");

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractSimpleReplaceRule.java
Patch:
@@ -122,7 +122,7 @@ private String cleanup(String word) {
   @Override
   public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
     List<RuleMatch> ruleMatches = new ArrayList<>();
-    AnalyzedTokenReadings[] tokens = getSentenceWithImmunization(sentence).getTokensWithoutWhitespace();
+    AnalyzedTokenReadings[] tokens = sentence.getTokensWithoutWhitespace();
     for (AnalyzedTokenReadings tokenReadings : tokens) {
       // short for SENT_START
       if( JLanguageTool.SENTENCE_START_TAGNAME.equals(tokenReadings.getAnalyzedToken(0).getPOSTag()) ||

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -186,6 +186,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Einwohnerzahl stieg um das Zweieinhalbfache");
     assertGood("Die Müllers aus Hamburg.");
     assertGood("Es ist noch unklar, wann und für wen Impfungen vorgenommen werden könnten.");
+    assertGood("Macht dir das Hoffnung?");
 
     assertGood("Wir machen das Januar.");
     assertGood("Wir teilen das Morgen mit.");

File: languagetool-server/src/main/java/org/languagetool/server/ApiV2.java
Patch:
@@ -43,6 +43,7 @@
 import java.net.HttpURLConnection;
 import java.net.InetSocketAddress;
 import java.util.*;
+import java.util.stream.Collectors;
 
 import static org.languagetool.server.LanguageToolHttpHandler.API_DOC_URL;
 
@@ -114,9 +115,6 @@ private void handleMaxTextLengthRequest(HttpExchange httpExchange, HTTPServerCon
   }
 
   private void handleGetConfigurationInfoRequest(HttpExchange httpExchange, Map<String, String> parameters, HTTPServerConfig config) throws IOException {
-    if (Premium.isPremiumVersion()) {
-      throw new BadRequestException("Not supported in premium mode");
-    }
     if (parameters.get("language") == null) {
       throw new BadRequestException("'language' parameter missing");
     }
@@ -490,6 +488,7 @@ String getConfigurationInfo(Language lang, HTTPServerConfig config) throws IOExc
       lt.activateWord2VecModelRules(textChecker.config.word2vecModelDir);
     }
     List<Rule> rules = lt.getAllRules();
+    rules = rules.stream().filter(rule -> !Premium.get().isPremiumRule(rule)).collect(Collectors.toList());
     try (JsonGenerator g = factory.createGenerator(sw)) {
       g.writeStartObject();
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementSuggestor2Test.java
Patch:
@@ -68,6 +68,7 @@ public void testSuggestionsWithReplType() throws IOException {
 
   @Test
   public void testSuggestionsHaus() throws IOException {
+    assertSuggestion1("Der Haus", "[Das Haus, Dem Haus, Der Häuser, Dem Hause, Des Hauses, Die Häuser, Den Häusern]");
     assertSuggestion1("der Haus", "[das Haus, dem Haus, der Häuser, dem Hause, des Hauses, die Häuser, den Häusern]");
     assertSuggestion1("das Haus", "[das Haus, dem Haus, dem Hause, des Hauses, die Häuser, den Häusern, der Häuser]");
     assertSuggestion1("der Haus", "[das Haus, dem Haus, der Häuser, dem Hause, des Hauses, die Häuser, den Häusern]");

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -94,7 +94,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new CheckCaseRule(messages, this),
             new SimpleReplaceAdverbsMent(messages),
             new CatalanWordRepeatBeginningRule(messages, this),
-            new CompoundRule(messages),
+            new CompoundRule(messages, this, userConfig),
             new CatalanRepeatedWordsRule(messages)
             //REMEMBER TO ADD RULES TO ValencianCatalan!!
     );

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/ValencianCatalan.java
Patch:
@@ -105,7 +105,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new SimpleReplaceRule(messages),
             new ReplaceOperationNamesRule(messages, this),
             new CheckCaseRule(messages, this),
-            new CompoundRule(messages),
+            new CompoundRule(messages, this, userConfig),
             // Valencian DNV
             new SimpleReplaceDNVRule(messages, this),
             new SimpleReplaceDNVColloquialRule(messages, this),

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/CompoundRuleTest.java
Patch:
@@ -32,7 +32,7 @@ public class CompoundRuleTest extends AbstractCompoundRuleTest {
   @Before
   public void setUp() throws Exception {
     lt = new JLanguageTool(Languages.getLanguageForShortCode("ca"));
-    rule = new CompoundRule(TestTools.getMessages("ca"));
+    rule = new CompoundRule(TestTools.getMessages("ca"), Languages.getLanguageForShortCode("ca"), null);
     testAllCompounds();
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/AustrianGerman.java
Patch:
@@ -51,7 +51,7 @@ public String getName() {
   @Override
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, Language motherTongue, List<Language> altLanguages) throws IOException {
     List<Rule> rules = new ArrayList<>(super.getRelevantRules(messages, userConfig, motherTongue, altLanguages));
-    rules.add(new GermanCompoundRule(messages));
+    rules.add(new GermanCompoundRule(messages, this, userConfig));
     return rules;
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/GermanyGerman.java
Patch:
@@ -51,7 +51,7 @@ public String getName() {
   @Override
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, Language motherTongue, List<Language> altLanguages) throws IOException {
     List<Rule> rules = new ArrayList<>(super.getRelevantRules(messages, userConfig, motherTongue, altLanguages));
-    rules.add(new GermanCompoundRule(messages));
+    rules.add(new GermanCompoundRule(messages, this, userConfig));
     return rules;
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/NonSwissGerman.java
Patch:
@@ -36,7 +36,7 @@ public abstract class NonSwissGerman extends German {
   @Override
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, Language motherTongue, List<Language> altLanguages) throws IOException {
     List<Rule> rules = new ArrayList<>(super.getRelevantRules(messages, userConfig, motherTongue, altLanguages));
-    rules.add(new GermanCompoundRule(messages));
+    rules.add(new GermanCompoundRule(messages, this, userConfig));
     return rules;
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/SwissGerman.java
Patch:
@@ -54,7 +54,7 @@ public String getName() {
   @Override
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, Language motherTongue, List<Language> altLanguages) throws IOException {
     List<Rule> rules = new ArrayList<>(super.getRelevantRules(messages, userConfig, motherTongue, altLanguages));
-    rules.add(new SwissCompoundRule(messages));
+    rules.add(new SwissCompoundRule(messages, this, userConfig));
     return rules;
   }
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanCompoundRuleTest.java
Patch:
@@ -31,10 +31,10 @@ public class GermanCompoundRuleTest extends AbstractCompoundRuleTest {
   @Test
   public void testRule() throws IOException {
     lt = new JLanguageTool(Languages.getLanguageForShortCode("de-DE"));
-    rule = new GermanCompoundRule(TestTools.getMessages("de"));
+    rule = new GermanCompoundRule(TestTools.getMessages("de"), Languages.getLanguageForShortCode("de-DE"), null);
     //testAllCompounds();
     runTests();
-    rule = new SwissCompoundRule(TestTools.getMessages("de"));
+    rule = new SwissCompoundRule(TestTools.getMessages("de"), Languages.getLanguageForShortCode("de-DE"), null);
     runTests();
     
   }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SwissCompoundRuleTest.java
Patch:
@@ -31,7 +31,7 @@ public class SwissCompoundRuleTest extends AbstractCompoundRuleTest {
   @Test
   public void testRule() throws IOException {
     lt = new JLanguageTool(Languages.getLanguageForShortCode("de-DE"));
-    rule = new SwissCompoundRule(TestTools.getMessages("de"));
+    rule = new SwissCompoundRule(TestTools.getMessages("de"), Languages.getLanguageForShortCode("de-DE"), null);
     //check(1, "Ente süss-sauer");
     check(1, "Ente süß-sauer");
     //check(1, "Ente süss sauer");

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -195,7 +195,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
         new EnglishWordRepeatRule(messages, this),
         new AvsAnRule(messages),
         new EnglishWordRepeatBeginningRule(messages, this),
-        new CompoundRule(messages),
+        new CompoundRule(messages, this, userConfig),
         new ContractionSpellingRule(messages),
         new EnglishWrongWordInContextRule(messages),
         new EnglishDashRule(messages),

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/CompoundRule.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.languagetool.Language;
 import org.languagetool.Languages;
+import org.languagetool.UserConfig;
 import org.languagetool.language.AmericanEnglish;
 import org.languagetool.rules.*;
 import org.languagetool.rules.patterns.PatternTokenBuilder;
@@ -113,8 +114,8 @@ public class CompoundRule extends AbstractCompoundRule {
       )
   ), AMERICAN_ENGLISH);
 
-  public CompoundRule(ResourceBundle messages) throws IOException {    
-    super(messages,
+  public CompoundRule(ResourceBundle messages, Language lang, UserConfig userConfig) throws IOException {    
+    super(messages, lang, userConfig,
             "This word is normally spelled with a hyphen.",
             "This word is normally spelled as one.", 
             "This expression is normally spelled as one or with a hyphen.",

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/CompoundRuleTest.java
Patch:
@@ -32,7 +32,7 @@ public class CompoundRuleTest extends AbstractCompoundRuleTest {
   @Before
   public void setUp() throws Exception {
     lt = new JLanguageTool(Languages.getLanguageForShortCode("en-US"));
-    rule = new CompoundRule(TestTools.getEnglishMessages());
+    rule = new CompoundRule(TestTools.getEnglishMessages(), Languages.getLanguageForShortCode("en-US"), null);
     //testAllCompounds();
   }
 

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -129,7 +129,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new SimpleReplaceRule(messages),
             new SimpleReplaceVerbsRule(messages, this),
             new SpanishWordRepeatBeginningRule(messages, this),
-            new CompoundRule(messages),
+            new CompoundRule(messages, this, userConfig),
             new SpanishRepeatedWordsRule(messages)
     );
   }

File: languagetool-language-modules/es/src/test/java/org/languagetool/rules/es/CompoundRuleTest.java
Patch:
@@ -32,7 +32,7 @@ public class CompoundRuleTest extends AbstractCompoundRuleTest {
   @Before
   public void setUp() throws Exception {
     lt = new JLanguageTool(Languages.getLanguageForShortCode("es"));
-    rule = new CompoundRule(TestTools.getMessages("es"));
+    rule = new CompoundRule(TestTools.getMessages("es"), Languages.getLanguageForShortCode("es"), null);
     testAllCompounds();
   }
 

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -117,7 +117,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new LongSentenceRule(messages, userConfig, 40),
             new LongParagraphRule(messages, this, userConfig),
             // specific to French:
-            new CompoundRule(messages),
+            new CompoundRule(messages, this, userConfig),
             new QuestionWhitespaceStrictRule(messages, this),
             new QuestionWhitespaceRule(messages, this),
             new SimpleReplaceRule(messages),

File: languagetool-language-modules/fr/src/test/java/org/languagetool/rules/fr/CompoundRuleTest.java
Patch:
@@ -35,7 +35,7 @@ public class CompoundRuleTest extends AbstractCompoundRuleTest {
   @Before
   public void setUp() throws Exception {
     lt = new JLanguageTool(Languages.getLanguageForShortCode("fr"));
-    rule = new CompoundRule(TestTools.getMessages("fr"));
+    rule = new CompoundRule(TestTools.getMessages("fr"), Languages.getLanguageForShortCode("fr"), null);
     testAllCompounds();
   }
 

File: languagetool-language-modules/ga/src/main/java/org/languagetool/language/Irish.java
Patch:
@@ -97,7 +97,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
       new LogainmRule(messages),
       new PeopleRule(messages),
       new SpacesRule(messages),
-      new CompoundRule(messages),
+      new CompoundRule(messages, this, userConfig),
       new PrestandardReplaceRule(messages),
       new IrishReplaceRule(messages),
       new IrishFGBEqReplaceRule(messages),

File: languagetool-language-modules/nl/src/main/java/org/languagetool/language/Dutch.java
Patch:
@@ -114,7 +114,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new UppercaseSentenceStartRule(messages, this),
             new MorfologikDutchSpellerRule(messages, this, userConfig, altLanguages),
             new MultipleWhitespaceRule(messages, this),
-            new CompoundRule(messages),
+            new CompoundRule(messages, this, userConfig),
             new DutchWrongWordInContextRule(messages),
             new WordCoherencyRule(messages),
             new SimpleReplaceRule(messages),

File: languagetool-language-modules/nl/src/test/java/org/languagetool/rules/nl/CompoundRuleTest.java
Patch:
@@ -31,7 +31,7 @@ public class CompoundRuleTest extends AbstractCompoundRuleTest {
   @Before
   public void setUp() throws Exception {
     lt = new JLanguageTool(new Dutch());
-    rule = new CompoundRule(JLanguageTool.getMessageBundle());
+    rule = new CompoundRule(JLanguageTool.getMessageBundle(), new Dutch(), null);
   }
 
   @Test

File: languagetool-language-modules/pl/src/main/java/org/languagetool/language/Polish.java
Patch:
@@ -98,7 +98,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
         new PolishUnpairedBracketsRule(messages, this),
         new MorfologikPolishSpellerRule(messages, this, userConfig, altLanguages),
         new PolishWordRepeatRule(messages),
-        new CompoundRule(messages),
+        new CompoundRule(messages, this, userConfig),
         new SimpleReplaceRule(messages),
         new DashRule(messages)
         );

File: languagetool-language-modules/pl/src/test/java/org/languagetool/rules/pl/CompoundRuleTest.java
Patch:
@@ -37,7 +37,7 @@ public class CompoundRuleTest extends AbstractCompoundRuleTest {
   @Before
   public void setUp() throws Exception {
     lt = new JLanguageTool(new Polish());
-    rule = new CompoundRule(TestTools.getEnglishMessages());
+    rule = new CompoundRule(TestTools.getEnglishMessages(), new Polish(), null);
   }
 
   @Test

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/AngolaPortuguese.java
Patch:
@@ -46,7 +46,7 @@ public String getName() {
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, Language motherTongue, List<Language> altLanguages) throws IOException {
     List<Rule> rules = new ArrayList<>();
     rules.addAll(super.getRelevantRules(messages, userConfig, motherTongue, altLanguages));
-    rules.add(new PreReformPortugueseCompoundRule(messages));
+    rules.add(new PreReformPortugueseCompoundRule(messages, this, userConfig));
     rules.add(new PreReformPortugueseDashRule(messages));
     return rules;
   }

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/BrazilianPortuguese.java
Patch:
@@ -37,7 +37,7 @@ public String getName() {
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, Language motherTongue, List<Language> altLanguages) throws IOException {
     List<Rule> rules = new ArrayList<>();
     rules.addAll(super.getRelevantRules(messages, userConfig, motherTongue, altLanguages));
-    rules.add(new PostReformPortugueseCompoundRule(messages));
+    rules.add(new PostReformPortugueseCompoundRule(messages, this, userConfig));
     rules.add(new BrazilianPortugueseReplaceRule(messages, "/pt/pt-BR/replace.txt"));
     rules.add(new PostReformPortugueseDashRule(messages));
     rules.add(new PortugueseBarbarismsRule(messages, "/pt/barbarisms-pt-BR.txt"));

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/MozambiquePortuguese.java
Patch:
@@ -46,7 +46,7 @@ public String getName() {
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, Language motherTongue, List<Language> altLanguages) throws IOException {
     List<Rule> rules = new ArrayList<>();
     rules.addAll(super.getRelevantRules(messages, userConfig, motherTongue, altLanguages));
-    rules.add(new PreReformPortugueseCompoundRule(messages));
+    rules.add(new PreReformPortugueseCompoundRule(messages, this, userConfig));
     rules.add(new PreReformPortugueseDashRule(messages));
     return rules;
   }

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/PortugalPortuguese.java
Patch:
@@ -42,7 +42,7 @@ public String[] getCountries() {
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, Language motherTongue, List<Language> altLanguages) throws IOException {
     List<Rule> rules = new ArrayList<>();
     rules.addAll(super.getRelevantRules(messages, userConfig, motherTongue, altLanguages));
-    rules.add(new PostReformPortugueseCompoundRule(messages));
+    rules.add(new PostReformPortugueseCompoundRule(messages, this, userConfig));
     rules.add(new PostReformPortugueseDashRule(messages));
     rules.add(new PortugalPortugueseReplaceRule(messages, "/pt/pt-PT/replace.txt"));
     rules.add(new PortugueseAgreementReplaceRule(messages));

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -128,7 +128,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new ParagraphRepeatBeginningRule(messages, this),
             new PunctuationMarkAtParagraphEnd(messages, this, true),
             //Specific to Portuguese:
-            new PostReformPortugueseCompoundRule(messages),
+            new PostReformPortugueseCompoundRule(messages, this, userConfig),
             new PortugueseReplaceRule(messages),
             new PortugueseBarbarismsRule(messages, "/pt/barbarisms-pt.txt"),
             //new PortugueseArchaismsRule(messages, "/pt/archaisms-pt.txt"),   // see https://github.com/languagetool-org/languagetool/issues/3095

File: languagetool-language-modules/ro/src/main/java/org/languagetool/language/Romanian.java
Patch:
@@ -86,7 +86,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new MorfologikRomanianSpellerRule(messages, this, userConfig, altLanguages),
             new RomanianWordRepeatBeginningRule(messages, this),
             new SimpleReplaceRule(messages),
-            new CompoundRule(messages)
+            new CompoundRule(messages, this, userConfig)
     );
   }
 

File: languagetool-language-modules/ro/src/test/java/org/languagetool/rules/ro/CompoundRuleTest.java
Patch:
@@ -35,7 +35,7 @@ public class CompoundRuleTest extends AbstractCompoundRuleTest {
   @Before
   public void setUp() throws Exception {
     lt = new JLanguageTool(new Romanian());
-    rule = new CompoundRule(TestTools.getMessages("ro"));
+    rule = new CompoundRule(TestTools.getMessages("ro"), new Romanian(), null);
   }
 
   @Test

File: languagetool-language-modules/ru/src/main/java/org/languagetool/language/Russian.java
Patch:
@@ -151,7 +151,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
                 // specific to Russian :
             new MorfologikRussianYOSpellerRule(messages, this, userConfig, altLanguages), // This rule must set off by default!!!
             new RussianUnpairedBracketsRule(messages, this),
-            new RussianCompoundRule(messages),
+            new RussianCompoundRule(messages, this, userConfig),
             new RussianSimpleReplaceRule(messages),
             new RussianWordCoherencyRule(messages),
             new RussianWordRepeatRule(messages),

File: languagetool-language-modules/ru/src/test/java/org/languagetool/rules/ru/RussianCompoundRuleTest.java
Patch:
@@ -38,7 +38,7 @@ public class RussianCompoundRuleTest extends AbstractCompoundRuleTest {
   @Before
   public void setUp() throws Exception {
     lt = new JLanguageTool(new Russian());
-    rule = new RussianCompoundRule(TestTools.getEnglishMessages());
+    rule = new RussianCompoundRule(TestTools.getEnglishMessages(), new Russian(), null);
   }
 
   @Test

File: languagetool-language-modules/sk/src/main/java/org/languagetool/language/Slovak.java
Patch:
@@ -92,7 +92,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new WordRepeatRule(messages, this),
             new MultipleWhitespaceRule(messages, this),
             // specific to Slovak:
-            new CompoundRule(messages),
+            new CompoundRule(messages, this, userConfig),
             new MorfologikSlovakSpellerRule(messages, this, userConfig, altLanguages)
             //new SlovakVesRule(messages)
     );

File: languagetool-language-modules/sk/src/test/java/org/languagetool/rules/sk/CompoundRuleTest.java
Patch:
@@ -32,7 +32,7 @@ public class CompoundRuleTest extends AbstractCompoundRuleTest {
   @Before
   public void setUp() throws Exception {
     lt = new JLanguageTool(new Slovak());
-    rule = new CompoundRule(TestTools.getEnglishMessages());
+    rule = new CompoundRule(TestTools.getEnglishMessages(), new Slovak(), null);
   }
 
   @Test

File: languagetool-language-modules/sv/src/main/java/org/languagetool/language/Swedish.java
Patch:
@@ -79,7 +79,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new UppercaseSentenceStartRule(messages, this),
             new WordRepeatRule(messages, this),
             new MultipleWhitespaceRule(messages, this),
-            new CompoundRule(messages)
+            new CompoundRule(messages, this, userConfig)
     );
   }
 

File: languagetool-language-modules/sv/src/test/java/org/languagetool/rules/sv/CompoundRuleTest.java
Patch:
@@ -32,7 +32,7 @@ public class CompoundRuleTest extends AbstractCompoundRuleTest {
   @Before
   public void setUp() throws Exception {
     lt = new JLanguageTool(new Swedish());
-    rule = new CompoundRule(TestTools.getEnglishMessages());
+    rule = new CompoundRule(TestTools.getEnglishMessages(), new Swedish(), null);
   }
 
   @Test

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LinguisticServices.java
Patch:
@@ -259,7 +259,9 @@ public boolean isCorrectSpell(String word, Locale locale) {
     }
     PropertyValue[] properties = new PropertyValue[0];
     try {
-      return spellChecker.isValid(word, locale, properties);
+      boolean isValid = spellChecker.isValid(word, locale, properties);
+      printText("Word: " + word + " is " + isValid);
+      return isValid;
     } catch (Throwable t) {
       // If anything goes wrong, give the user a stack trace
       printMessage(t);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -657,6 +657,7 @@ private int getNumDoc(String docID, PropertyValue[] propertyValues) {
         for (int i = 0; i < documents.size(); i++) {
           //  work around to compensate a bug at LO
           if (xComponent.equals(documents.get(i).getXComponent())) {
+            MessageHandler.printToLogFile("Different Doc IDs, but same xComponents!");
             String oldDocId = documents.get(i).getDocID();
             documents.get(i).setDocID(docID);
             MessageHandler.printToLogFile("Document ID corrected: old: " + oldDocId + ", new: " + docID);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LanguageToolMenus.java
Patch:
@@ -100,7 +100,7 @@ void removeListener() {
   class LTHeadMenu implements XMenuListener {
     // If anything on the position of LT menu is changed the following has to be changed
     private static final String TOOLS_COMMAND = ".uno:ToolsMenu";             //  Command to open tools menu
-    private static final String SPELL_ONLINE_COMMAND = ".uno:SpellOnline";    //  Command to switch on/off online spelling (LT menu is installed after)
+    private static final String COMMAND_BEFORE_LT_MENU = ".uno:LanguageMenu";   //  Command for Language Menu (LT menu is installed after)
                                                       //  Command to Switch Off/On LT
     private static final String LT_SWITCH_OFF_COMMAND = "service:org.languagetool.openoffice.Main?switchOff";   
     private static final String LT_PROFILE_COMMAND = "service:org.languagetool.openoffice.Main?profileChangeTo:";
@@ -139,7 +139,7 @@ public LTHeadMenu() {
       }
       for (short i = 0; i < toolsMenu.getItemCount(); i++) {
         String command = toolsMenu.getCommand(toolsMenu.getItemId(i));
-        if (SPELL_ONLINE_COMMAND.equals(command)) {
+        if (COMMAND_BEFORE_LT_MENU.equals(command)) {
           ltId = toolsMenu.getItemId((short) (i + 1));
           ltMenu = toolsMenu.getPopupMenu(ltId);
           break;

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractSimpleReplaceRule.java
Patch:
@@ -122,7 +122,7 @@ private String cleanup(String word) {
   @Override
   public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
     List<RuleMatch> ruleMatches = new ArrayList<>();
-    AnalyzedTokenReadings[] tokens = sentence.getTokensWithoutWhitespace();
+    AnalyzedTokenReadings[] tokens = getSentenceWithImmunization(sentence).getTokensWithoutWhitespace();
     for (AnalyzedTokenReadings tokenReadings : tokens) {
       // short for SENT_START
       if( JLanguageTool.SENTENCE_START_TAGNAME.equals(tokenReadings.getAnalyzedToken(0).getPOSTag()) ||

File: languagetool-language-modules/en/src/test/java/org/languagetool/tokenizers/EnglishSRXSentenceTokenizerTest.java
Patch:
@@ -41,6 +41,8 @@ public void setUp() {
   @Test
   public void testTokenize() {
     // incomplete sentences, need to work for on-thy-fly checking of texts:
+    testSplit("What is the I.S?");
+    testSplit("Where are the I.S and the M.Z notes? ");
     testSplit("Here's a");
     testSplit("Here's a sentence. ", "And here's one that's not comp");
     testSplit("Or did you install it (i.e. MS Word) yourself?");

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -274,6 +274,7 @@ protected int getPriorityForId(String id) {
       //case "ACCORD_COULEUR": return 1; // needs to have higher priority than agreement postponed adj
       case "R_VAVOIR_VINF": return 10; // needs higher priority than A_INFINITIF
       case "AN_EN": return 10; // needs higher priority than AN_ANNEE
+      case "PAS_DE_SOUCIS": return 10; // needs higher priority than PAS_DE_PB_SOUCIS (premium)
       //case "PRONSUJ_NONVERBE": return 10; // needs higher priority than AUXILIAIRE_MANQUANT
       //case "AUXILIAIRE_MANQUANT": return 5; // needs higher priority than ACCORD_NOM_VERBE
       case "CONFUSION_PAR_PART": return -5;  // turn off completely when PART_OU_PAR is activated

File: languagetool-server/src/main/java/org/languagetool/server/HTTPSServer.java
Patch:
@@ -123,7 +123,7 @@ public void stop() {
   }
 
   public static void main(String[] args) {
-    if (args.length == 0 || args.length > 7 || usageRequested(args)) {
+    if (args.length == 0 || usageRequested(args)) {
       System.out.println("Usage: " + HTTPSServer.class.getSimpleName()
               + " --config propertyFile [--port|-p port] [--public]");
       System.out.println("  --config file  a Java property file (one key=value entry per line) with values for:");

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServer.java
Patch:
@@ -129,7 +129,7 @@ public void stop() {
   }
 
   public static void main(String[] args) {
-    if (args.length > 9 || usageRequested(args)) {
+    if (usageRequested(args)) {
       System.out.println("Usage: " + HTTPServer.class.getSimpleName() + " [--config propertyFile] [--port|-p port] [--public]");
       System.out.println("  --config FILE  a Java property file (one key=value entry per line) with values for:");
       printCommonConfigFileOptions();

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -355,6 +355,7 @@ protected int getPriorityForId(String id) {
       case "AERZTEN_INNEN": return -2;  // overwrite speller ("Ärzte/-innen")
       case "ANGLIZISMEN" : return -2;   // overwrite spell checker
       case "ANGLIZISMUS_PA_MIT_ED" : return -2;   // overwrite spell checker
+      case "ZAHL_IM_WORT": return -2; //should not override rules like H2O
       case "GERMAN_SPELLER_RULE": return -3;  // assume most other rules are more specific and helpful than the spelling rule
       case "AUSTRIAN_GERMAN_SPELLER_RULE": return -3;  // assume most other rules are more specific and helpful than the spelling rule
       case "SWISS_GERMAN_SPELLER_RULE": return -3;  // assume most other rules are more specific and helpful than the spelling rule
@@ -364,7 +365,6 @@ protected int getPriorityForId(String id) {
       case "KOMMA_VOR_RELATIVSATZ": return -10;
       case "KOMMA_ZWISCHEN_HAUPT_UND_NEBENSATZ_2": return -10;
       case "COMMA_BEHIND_RELATIVE_CLAUSE": return -10;
-      case "ZAHL_IM_WORT": return -10; //should not override rules like H2O
       case "TOO_LONG_PARAGRAPH": return -15;
       // Category ids - make sure style issues don't hide overlapping "real" errors:
       case "COLLOQUIALISMS": return -15;

File: languagetool-standalone/src/test/java/org/languagetool/language/LanguageIdentifierTest.java
Patch:
@@ -36,8 +36,8 @@
 
 public class LanguageIdentifierTest {
 
-  private final static String fastTextBinary = "/prg/fastText-0.1.0/fasttext";
-  private final static String fastTextModel = "/prg/fastText-0.1.0/data/lid.176.bin";
+  private final static String fastTextBinary = "/home/languagetool/fasttext/fasttext";
+  private final static String fastTextModel = "/home/languagetool/fasttext/lid.176.bin";
   private final static String ngramData = "/home/languagetool/model_ml50_new.zip";
   private final static String czech = "V současné době je označením Linux míněno nejen jádro operačního systému, " +
           "ale zahrnuje do něj též veškeré programové vybavení";

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -750,7 +750,9 @@ SwJLanguageTool initLanguageTool(Language currentLanguage, boolean setService) {
         currentLanguage = docLanguage;
       }
       // not using MultiThreadedSwJLanguageTool here fixes "osl::Thread::Create failed", see https://bugs.documentfoundation.org/show_bug.cgi?id=90740:
-      lt = new SwJLanguageTool(currentLanguage, config.getMotherTongue(),
+//      lt = new SwJLanguageTool(currentLanguage, config.getMotherTongue(),
+//          new UserConfig(config.getConfigurableValues(), linguServices), config, extraRemoteRules, testMode);
+      lt = new SwJLanguageTool(currentLanguage, null,
           new UserConfig(config.getConfigurableValues(), linguServices), config, extraRemoteRules, testMode);
       config.initStyleCategories(lt.getAllRules());
       /* The next row is only for a single line break marks a paragraph

File: languagetool-core/src/main/java/org/languagetool/rules/RemoteRule.java
Patch:
@@ -371,7 +371,7 @@ static int[] computeOffsetShifts(String s) {
    * based on offsetByCodePoints since codePointCount can be confusing,
    * e.g. "👪".codePointCount(0,2) == 1, but length is 2
    *
-   * Java substring methods use this length (which can be >1 for a single character)
+   * Java substring methods use this length (which can be &gt;1 for a single character)
    * whereas Python 3 indexing/slicing and len() in strings treat them as a single character
    * so "😁foo".length() == 5, but len("😁foo") == 4;
    * "😁foo".substring(2,5) == "foo" but "😁foo"[1:4] == 'foo'

File: languagetool-server/src/main/java/org/languagetool/server/ExtendedUserInfo.java
Patch:
@@ -25,7 +25,7 @@
 import java.sql.Timestamp;
 
 /**
-  Used via Jackson-databind + myBatis -> return info from DB via JSON in /users/me route
+  Used via Jackson-databind + myBatis -&gt; return info from DB via JSON in /users/me route
  @see ApiV2
  */
 public class ExtendedUserInfo {

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServerConfig.java
Patch:
@@ -142,7 +142,7 @@ public void setRestrictManagedAccounts(boolean restrictManagedAccounts) {
 
   /**
    * caching to avoid database hits for e.g. dictionaries
-   * null -> disabled
+   * null -&gt; disabled
    */
   @Nullable
   protected String redisHost = null;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReplaceOperationNamesRule.java
Patch:
@@ -167,7 +167,7 @@ public final RuleMatch[] match(final AnalyzedSentence sentence) {
           }
         }
         if (possibleReplacements.size() > 0) {
-            RuleMatch potentialRuleMatch = createRuleMatch(tokens[i],possibleReplacements, sentence);
+            RuleMatch potentialRuleMatch = createRuleMatch(tokens[i],possibleReplacements, sentence, token);
             ruleMatches.add(potentialRuleMatch);
         }
       }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleCheck.java
Patch:
@@ -709,7 +709,9 @@ static String removeFootnotes(String paraText, int[] footnotes) {
       return cleanFootnotes(paraText);
     }
     for (int i = footnotes.length - 1; i >= 0; i--) {
-      paraText = paraText.substring(0, footnotes[i]) + paraText.substring(footnotes[i] + 1);
+      if (footnotes[i] < paraText.length()) {
+        paraText = paraText.substring(0, footnotes[i]) + paraText.substring(footnotes[i] + 1);
+      }
     }
     return paraText;
   }

File: languagetool-core/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -42,6 +42,7 @@ public class WordListValidatorTest {
   // Words that are valid but with special characters so that we don't want to
   // allow them in general:
   private static final Set<String> VALID_WORDS = new HashSet<>(Arrays.asList(
+          "Varaždin/S",
           "Będzin",
           "Aydın",
           "Čeferin",

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/AbstractPatternRuleTest.java
Patch:
@@ -94,6 +94,7 @@ protected List<String> getGrammarFileNames(Language lang) {
         fileName = lang.getShortCode() + "/" + nameOnly;
       } else if (shortNameWithVariant.contains("-") && !shortNameWithVariant.equals("xx-XX")
           && !shortNameWithVariant.endsWith("-ANY") && Languages.get().size() > 1
+          && !shortNameWithVariant.equals("de-DE")
           && !shortNameWithVariant.equals("ca-ES")) { // TODO: change Catalan language definitions?
         fileName = lang.getShortCode() + "/" + shortNameWithVariant + "/" + nameOnly;
       } else {

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -156,7 +156,7 @@ private void runGrammarRulesFromXmlTestIgnoringLanguages(Set<Language> ignoredLa
 
   public void runTestForLanguage(Language lang) throws IOException {
     validatePatternFile(lang);
-    System.out.println("Running pattern rule tests for " + lang.getName() + "... ");
+    System.out.println("Running pattern rule tests for " + lang.getName() + " (" + lang.getClass().getName() + ")... ");
     MultiThreadedJLanguageTool lt = createToolForTesting(lang);
     MultiThreadedJLanguageTool allRulesLt = new MultiThreadedJLanguageTool(lang);
     validateRuleIds(lang, allRulesLt);
@@ -345,7 +345,8 @@ protected void testGrammarRulesFromXML(List<AbstractPatternRule> rules, JLanguag
         String sourceFile = rule.getSourceFile();
         if (lang.isVariant() && sourceFile != null &&
                 sourceFile.matches("/org/languagetool/rules/" + lang.getShortCode() + "/grammar.*\\.xml") &&
-                !sourceFile.contains("-l2-") && !lang.getShortCodeWithCountryAndVariant().equals("de-DE-x-simple-language")) {
+                !sourceFile.contains("-l2-") && !lang.getShortCodeWithCountryAndVariant().equals("de-DE-x-simple-language") &&
+                !lang.getClass().getName().contains("PremiumOnly")) {
           //System.out.println("Skipping " + rule.getFullId() + " in " + sourceFile + " because we're checking a variant");
           skipCount++;
           continue;

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -378,6 +378,9 @@ protected int getPriorityForId(String id) {
       return -1;
     }
     if (id.startsWith("AI_HYDRA_LEO")) { // prefer more specific rules (also speller)
+      if (id.startsWith("AI_HYDRA_LEO_CP_DAS")) {
+        return 2;
+      }
       return -11;
     }
     return super.getPriorityForId(id);

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -507,9 +507,6 @@ protected int getPriorityForId(String id) {
       return -20;
     }
     if (id.startsWith("AI_HYDRA_LEO")) { // prefer more specific rules (also speller)
-      if (id.startsWith("AI_HYDRA_LEO_CP_DAS")) {
-        return 2;
-      }
       if (id.startsWith("AI_HYDRA_LEO_CP_YOU")) {
         return 1;
       }

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractSpecificCaseRule.java
Patch:
@@ -105,7 +105,7 @@ private void loadPhrases() {
   /**
    * Initializes the <code>lcToProperSpelling</code> Map
    */
-  synchronized private void initializeLcToProperSpellingMap() {
+  synchronized static private void initializeLcToProperSpellingMap() {
     for (String phrase : phrases) {
       lcToProperSpelling.put(phrase.toLowerCase(), phrase);
     }

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractSpecificCaseRule.java
Patch:
@@ -105,7 +105,7 @@ private void loadPhrases() {
   /**
    * Initializes the <code>lcToProperSpelling</code> Map
    */
-  private void initializeLcToProperSpellingMap() {
+  synchronized private void initializeLcToProperSpellingMap() {
     for (String phrase : phrases) {
       lcToProperSpelling.put(phrase.toLowerCase(), phrase);
     }

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/CachingWordListLoader.java
Patch:
@@ -53,7 +53,7 @@ public List<String> load(@NotNull String fileInClassPath) throws IOException {
             if (line.isEmpty() || line.startsWith("#")) {
               continue;
             }
-            result.add(StringUtils.substringBefore(line.trim(), "#"));
+            result.add(StringUtils.substringBefore(line.trim(), "#").trim());
           }
           return Collections.unmodifiableList(result);
         }

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/AustrianGerman.java
Patch:
@@ -56,7 +56,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
   }
 
   @Override
-  public SpellingCheckRule getDefaultSpellingRule(ResourceBundle messages) throws IOException {
+  public SpellingCheckRule createDefaultSpellingRule(ResourceBundle messages) throws IOException {
     return new AustrianGermanSpellerRule(messages, this);
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/GermanyGerman.java
Patch:
@@ -56,7 +56,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
   }
 
   @Override
-  public SpellingCheckRule getDefaultSpellingRule(ResourceBundle messages) throws IOException {
+  public SpellingCheckRule createDefaultSpellingRule(ResourceBundle messages) throws IOException {
     return new GermanSpellerRule(messages, this);
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/SwissGerman.java
Patch:
@@ -59,7 +59,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
   }
 
   @Override
-  public SpellingCheckRule getDefaultSpellingRule(ResourceBundle messages) throws IOException {
+  public SpellingCheckRule createDefaultSpellingRule(ResourceBundle messages) throws IOException {
     return new SwissGermanSpellerRule(messages, this);
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/AmericanEnglish.java
Patch:
@@ -34,7 +34,6 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.ResourceBundle;
@@ -60,7 +59,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
   }
 
   @Override
-  public SpellingCheckRule getDefaultSpellingRule(ResourceBundle messages) throws IOException {
+  public SpellingCheckRule createDefaultSpellingRule(ResourceBundle messages) throws IOException {
       return new MorfologikAmericanSpellerRule(messages, this, null, Collections.emptyList());
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/AustralianEnglish.java
Patch:
@@ -48,7 +48,7 @@ public String getName() {
   }
 
   @Override
-  public SpellingCheckRule getDefaultSpellingRule(ResourceBundle messages) throws IOException {
+  public SpellingCheckRule createDefaultSpellingRule(ResourceBundle messages) throws IOException {
     return new MorfologikAustralianSpellerRule(messages, this, null, Collections.emptyList());
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/BritishEnglish.java
Patch:
@@ -58,7 +58,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
   }
 
   @Override
-  public SpellingCheckRule getDefaultSpellingRule(ResourceBundle messages) throws IOException {
+  public SpellingCheckRule createDefaultSpellingRule(ResourceBundle messages) throws IOException {
     return new MorfologikBritishSpellerRule(messages, this, null, Collections.emptyList());
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/CanadianEnglish.java
Patch:
@@ -48,7 +48,7 @@ public String getName() {
   }
 
   @Override
-  public SpellingCheckRule getDefaultSpellingRule(ResourceBundle messages) throws IOException {
+  public SpellingCheckRule createDefaultSpellingRule(ResourceBundle messages) throws IOException {
     return new MorfologikCanadianSpellerRule(messages, this, null, Collections.emptyList());
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/NewZealandEnglish.java
Patch:
@@ -49,7 +49,7 @@ public String getName() {
   }
 
   @Override
-  public SpellingCheckRule getDefaultSpellingRule(ResourceBundle messages) throws IOException {
+  public SpellingCheckRule createDefaultSpellingRule(ResourceBundle messages) throws IOException {
     return new MorfologikNewZealandSpellerRule(messages, this, null, Collections.emptyList());
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/SouthAfricanEnglish.java
Patch:
@@ -47,7 +47,7 @@ public String getName() {
   }
 
   @Override
-  public SpellingCheckRule getDefaultSpellingRule(ResourceBundle messages) throws IOException {
+  public SpellingCheckRule createDefaultSpellingRule(ResourceBundle messages) throws IOException {
     return new MorfologikSouthAfricanSpellerRule(messages, this, null, Collections.emptyList());
   }
 

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -103,7 +103,7 @@ public Contributor[] getMaintainers() {
   }
 
   @Override
-  public SpellingCheckRule getDefaultSpellingRule(ResourceBundle messages) throws IOException {
+  public SpellingCheckRule createDefaultSpellingRule(ResourceBundle messages) throws IOException {
     return new MorfologikSpanishSpellerRule(messages, this, null, Collections.emptyList());
   }
 

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -96,7 +96,7 @@ public Contributor[] getMaintainers() {
 
 
   @Override
-  public SpellingCheckRule getDefaultSpellingRule(ResourceBundle messages) throws IOException {
+  public SpellingCheckRule createDefaultSpellingRule(ResourceBundle messages) throws IOException {
     return new MorfologikFrenchSpellerRule(messages, this, null, Collections.emptyList());
   }
 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -549,7 +549,7 @@ public QueueEntry getQueueEntryForChangedParagraph() {
    * run a text level check from a queue entry (initiated by the queue)
    */
   public void runQueueEntry(int nStart, int nEnd, int cacheNum, int nCheck, boolean override, SwJLanguageTool lt) {
-    if (flatPara != null && docCache.isFinished()) {
+    if (flatPara != null && docCache.isFinished() && nStart < docCache.textSize()) {
       SingleCheck singleCheck = new SingleCheck(this, paragraphsCache, docCursor, flatPara, docLanguage, ignoredMatches, numParasToCheck, false);
       singleCheck.addParaErrorsToCache(docCache.getFlatParagraphNumber(nStart), lt, cacheNum, nCheck, nEnd == nStart + 1, override, false, hasFootnotes);
     }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -1053,7 +1053,8 @@ public LtCheckDialog(XComponentContext xContext) {
       defaultForeground = dialog.getForeground() == null ? Color.BLACK : dialog.getForeground();
 
       languageLabel = new JLabel(labelLanguage);
-      Font dialogFont = languageLabel.getFont().deriveFont((float) 12);
+//    Font dialogFont = languageLabel.getFont().deriveFont((float) 12);
+      Font dialogFont = languageLabel.getFont();
       languageLabel.setBounds(begFirstCol, disFirstCol, 180, 30);
       languageLabel.setFont(dialogFont);
       dialog.add(languageLabel);

File: languagetool-core/src/main/java/org/languagetool/tagging/ner/NERService.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.tagging.ner;
 
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import org.jetbrains.annotations.NotNull;
 import org.languagetool.tools.StringTools;
 import org.languagetool.tools.Tools;
@@ -42,7 +43,7 @@
 public class NERService {
 
   private static final Logger logger = LoggerFactory.getLogger(NERService.class);
-  private static final ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
+  private static final ExecutorService executorService = Executors.newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat("lt-ner-thread-%d").build());
   private static final int TIMEOUT_MILLIS = 500;
 
   private final String urlStr;

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanCompoundRuleTest.java
Patch:
@@ -108,8 +108,8 @@ private void runTests() throws IOException {
     // "Aggregat-Zustand?"
     check(0, "Aggregatzustand");
     //check(0, "Aggregat-Zustand");
-    check(1, "Aggregat-Zustand", "Aggregatzustand");
-    check(1, "Aggregat Zustand", "Aggregatzustand");
+    //check(1, "Aggregat-Zustand", "Aggregatzustand");
+    //check(1, "Aggregat Zustand", "Aggregatzustand");
     check(1, "Billard Kugel", "Billardkugel");
   }
   

File: languagetool-core/src/main/java/org/languagetool/MultiThreadedJLanguageTool.java
Patch:
@@ -53,7 +53,7 @@ public MultiThreadedJLanguageTool(Language language) {
 
   /**
    * @see #shutdown()
-   * @param threadPoolSize the number of concurrent threads
+   * @param threadPoolSize the number of concurrent threads (use 0 or negative value for a default)
    * @since 2.9
    */
   public MultiThreadedJLanguageTool(Language language, int threadPoolSize) {

File: languagetool-server/src/main/java/org/languagetool/server/HTTPTestTools.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package org.languagetool;
+package org.languagetool.server;
 
 import org.languagetool.tools.StringTools;
 

File: languagetool-server/src/test/java/org/languagetool/server/BertResortingBugTest.java
Patch:
@@ -22,7 +22,6 @@
 
 import org.junit.Ignore;
 import org.junit.Test;
-import org.languagetool.HTTPTools;
 import org.languagetool.tools.Tools;
 
 import java.io.IOException;

File: languagetool-server/src/test/java/org/languagetool/server/HTTPSServerTesting.java
Patch:
@@ -20,7 +20,6 @@
 
 import org.junit.Ignore;
 import org.junit.Test;
-import org.languagetool.HTTPTools;
 import org.languagetool.Language;
 import org.languagetool.Languages;
 

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerLoadTest.java
Patch:
@@ -19,7 +19,6 @@
 package org.languagetool.server;
 
 import org.junit.Test;
-import org.languagetool.HTTPTools;
 
 import java.util.ArrayList;
 import java.util.List;

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerOverheadTest.java
Patch:
@@ -20,7 +20,6 @@
 
 import org.junit.Ignore;
 import org.junit.Test;
-import org.languagetool.HTTPTools;
 import org.languagetool.Language;
 import org.languagetool.Languages;
 

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerTest.java
Patch:
@@ -21,7 +21,6 @@
 import org.apache.commons.lang3.StringUtils;
 import org.junit.Before;
 import org.junit.Test;
-import org.languagetool.HTTPTools;
 import org.languagetool.Language;
 import org.languagetool.Languages;
 import org.languagetool.language.*;

File: languagetool-server/src/test/java/org/languagetool/server/LanguageIdentificationTest.java
Patch:
@@ -21,7 +21,6 @@
 import com.fasterxml.jackson.databind.ObjectMapper;
 import org.junit.Ignore;
 import org.junit.Test;
-import org.languagetool.HTTPTools;
 
 import java.io.IOException;
 import java.net.URL;

File: languagetool-server/src/test/java/org/languagetool/server/PipelinePoolTest.java
Patch:
@@ -21,11 +21,12 @@
 
 package org.languagetool.server;
 
-import org.junit.Ignore;
 import org.jetbrains.annotations.NotNull;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.languagetool.*;
 import org.languagetool.markup.AnnotatedTextBuilder;
+import org.languagetool.server.HTTPTestTools;
 
 import java.lang.reflect.Field;
 import java.util.*;

File: languagetool-server/src/test/java/org/languagetool/server/TextCheckerTest.java
Patch:
@@ -23,7 +23,6 @@
 import com.auth0.jwt.exceptions.SignatureVerificationException;
 import org.junit.Ignore;
 import org.junit.Test;
-import org.languagetool.HTTPTools;
 import org.languagetool.markup.AnnotatedTextBuilder;
 
 import java.io.*;

File: languagetool-server/src/test/java/org/languagetool/server/HTTPSServerConfigTest.java
Patch:
@@ -42,15 +42,15 @@ public void testArgumentParsing() {
     assertThat(config1.isVerbose(), is(false));
     assertThat(config1.getKeystore().toString().replace('\\', '/'), is("src/test/resources/org/languagetool/server/test-keystore.jks"));
     assertThat(config1.getKeyStorePassword(), is("mytest"));
-    assertThat(config1.getMaxTextLength(), is(50000));
+    assertThat(config1.getMaxTextLengthAnonymous(), is(50000));
 
     HTTPSServerConfig config2 = new HTTPSServerConfig(("-p 9999 --config " + propertyFile).split(" "));
     assertThat(config2.getPort(), is(9999));
     assertThat(config2.isPublicAccess(), is(false));
     assertThat(config2.isVerbose(), is(false));
     assertThat(config2.getKeystore().toString().replace('\\', '/'), is("src/test/resources/org/languagetool/server/test-keystore.jks"));
     assertThat(config2.getKeyStorePassword(), is("mytest"));
-    assertThat(config2.getMaxTextLength(), is(50000));
+    assertThat(config2.getMaxTextLengthAnonymous(), is(50000));
   }
 
   @Test
@@ -62,7 +62,7 @@ public void testMinimalPropertyFile() {
     assertThat(config.isVerbose(), is(false));
     assertThat(config.getKeystore().toString().replace('\\', '/'), is("src/test/resources/org/languagetool/server/test-keystore.jks"));
     assertThat(config.getKeyStorePassword(), is("mytest"));
-    assertThat(config.getMaxTextLength(), is(Integer.MAX_VALUE));
+    assertThat(config.getMaxTextLengthAnonymous(), is(Integer.MAX_VALUE));
   }
 
   @Test

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerTest.java
Patch:
@@ -292,7 +292,7 @@ private void runDataTests() throws IOException {
   @Test
   public void testTimeout() {
     HTTPServerConfig config = new HTTPServerConfig(HTTPTools.getDefaultPort(), false);
-    config.setMaxCheckTimeMillis(1);
+    config.setMaxCheckTimeMillisAnonymous(1);
     HTTPServer server = new HTTPServer(config, false);
     try {
       server.run();

File: languagetool-server/src/test/java/org/languagetool/server/TextCheckerTest.java
Patch:
@@ -58,7 +58,7 @@ public void testMaxTextLength() throws Exception {
     params.put("text", "not used");
     params.put("language", "en");
     HTTPServerConfig config1 = new HTTPServerConfig(HTTPTools.getDefaultPort());
-    config1.setMaxTextLength(10);
+    config1.setMaxTextLengthAnonymous(10);
     TextChecker checker = new V2TextChecker(config1, false, null, new RequestCounter());
     try {
       checker.checkText(new AnnotatedTextBuilder().addText("longer than 10 chars").build(), new FakeHttpExchange(), params, null, null);

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -251,6 +251,7 @@ protected int getPriorityForId(String id) {
       case "CAT_TYPOGRAPHIE": return 20; // greater than PRONSUJ_NONVERBE or agreement rules
       case "CAT_HOMONYMES_PARONYMES": return 20;
       case "CAT_TOURS_CRITIQUES": return 20;
+      case "EST_CE_QUE": return 20; // greater than TRAIT_UNION_INVERSION
       case "CONFUSION_PARLEZ_PARLER": return 10; // greater than N_V
       case "AGREEMENT_TOUT_LE": return 10; // compare to TOUT_LES
       case "ESPACE_UNITES": return 10; // needs to have higher priority than spell checker

File: languagetool-language-modules/fr/src/test/java/org/languagetool/rules/fr/CompoundRuleTest.java
Patch:
@@ -43,6 +43,7 @@ public void testRule() throws IOException {
     // correct sentences:
     check(0, "Jésus-Christ");
     check(0, "Congo-Brazzaville");
+    check(0, "vidéo-clip");
 
     // incorrect sentences:
     check(1, "Jésus Christ");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanStyleRepeatedWordRule.java
Patch:
@@ -130,6 +130,7 @@ protected boolean isPartOfWord(String testTokenText, String tokenText) {
           || tokenText.startsWith(testTokenText) || tokenText.endsWith(testTokenText))
           && (!isFalsePair(testTokenText, tokenText, "lang", "klang"))
           && (!isFalsePair(testTokenText, tokenText, "lag", "schlag"))
+          && (!isFalsePair(testTokenText, tokenText, "lagen", "schlagen"))
           && (!isFalsePair(testTokenText, tokenText, "Art", "Artefakt"))
           && (!isFalsePair(testTokenText, tokenText, "kommen", "kommentier"))
           && (!isFalsePair(testTokenText, tokenText, "weit", "weiter"))

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/ProhibitedCompoundRule.java
Patch:
@@ -120,6 +120,7 @@ public class ProhibitedCompoundRule extends Rule {
     "Gra(ph|f)it"   // Grafit/Graphit
   );
   private static final Set<String> blacklist = new HashSet<>(Arrays.asList(
+          "Lichtkunstwerk",  // vs Dichtkunstwerk
           "Infektionslage",  // vs Infektionstage
           "Teilspiegel",  // vs Heilspiegel
           "Preiseseite",  // vs Presseseite

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/TextToNumberFilter.java
Patch:
@@ -116,7 +116,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
       if (patternTokens[posWord].getStartPos() >= match.getFromPos()
           && patternTokens[posWord].getEndPos() <= match.getToPos()) {
         String form = patternTokens[posWord].getToken().toLowerCase();
-        if (form.equals("ciento") && patternTokens[posWord - 1].getToken().toLowerCase().equals("por")) {
+        if (posWord > 0 && form.equals("ciento") && patternTokens[posWord - 1].getToken().toLowerCase().equals("por")) {
           percentage = true;
           break;
         }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanStyleRepeatedWordRule.java
Patch:
@@ -89,7 +89,7 @@ protected boolean isTokenToCheck(AnalyzedTokenReadings token) {
     return ((token.matchesPosTagRegex("(SUB|EIG|VER|ADJ):.*") 
         && !token.matchesPosTagRegex("(PRO|A(RT|DV)|VER:(AUX|MOD)):.*")
         || isUnknownWord(token))
-        && !StringUtils.equalsAny(token.getToken(), "sicher", "weit", "Sie", "Ich", "Euch", "Eure"));
+        && !StringUtils.equalsAny(token.getToken(), "sicher", "weit", "Sie", "Ich", "Euch", "Eure", "all"));
   }
 
   /*

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/TextToNumberFilter.java
Patch:
@@ -51,7 +51,7 @@ public class TextToNumberFilter extends RuleFilter {
     numbers.put("trece", (float) 13);
     numbers.put("catorce", (float) 14);
     numbers.put("quince", (float) 15);
-    numbers.put("diecisés", (float) 16);
+    numbers.put("dieciséis", (float) 16);
     numbers.put("diecisiete", (float) 17);
     numbers.put("dieciocho", (float) 18);
     numbers.put("diecinueve", (float) 19);

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -489,8 +489,7 @@ private boolean isProperNoun(String wordWithoutS) {
    * @since 2.9, signature modified in 3.9
    */
   protected void addIgnoreWords(String line) {
-    if (!tokenizeNewWords()) 
-    {
+    if (!tokenizeNewWords()) {
       wordsToBeIgnored.add(line);
     }
     else {

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/CatalanWordRepeatRuleTest.java
Patch:
@@ -62,6 +62,8 @@ public void testRule() throws IOException {
     assertEquals(0, matches.length);
     matches = rule.match(lt.getAnalyzedSentence("Si no no es gaudeix."));
     assertEquals(0, matches.length);
+    matches = rule.match(lt.getAnalyzedSentence("HUCHA-GANGA.ES es presenta."));
+    assertEquals(0, matches.length);
         
     //incorrect
     matches = rule.match(lt.getAnalyzedSentence("Tots els els homes són iguals."));

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikAmericanSpellerRuleTest.java
Patch:
@@ -181,6 +181,7 @@ public void testMorfologikSpeller() throws IOException {
     assertEquals(1, rule.match(lt.getAnalyzedSentence("A web-feature-drivenx-car software.")).length);
 
     assertAllMatches(lt, rule, "timezones", "timezone", "time zones");
+    assertAllMatches(lt, rule, "robinson", "Robinson", "robin son", "robins on", "Robson", "Robeson", "robins", "Roberson");
   }
 
   @Test

File: languagetool-core/src/main/java/org/languagetool/rules/LanguageDependentFilter.java
Patch:
@@ -40,7 +40,7 @@ public class LanguageDependentFilter implements RuleMatchFilter {
   protected Set<CategoryId> disabledCategories;
   
   private static final Pattern CA_OLD_DIACRITICS = Pattern.compile(".*\\b(dóna|vénen|véns|fóra)\\b.*",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
-  private static final Pattern ES_CONTRACTIONS = Pattern.compile("\\b([Aa]|[[Dd]e) e(l)\\b",Pattern.UNICODE_CASE);
+  private static final Pattern ES_CONTRACTIONS = Pattern.compile("\\b([Aa]|[Dd]e) e(l)\\b");
 
   public LanguageDependentFilter(Language lang, RuleSet rules) {
     language = lang;

File: languagetool-core/src/main/java/org/languagetool/rules/LanguageDependentFilter.java
Patch:
@@ -40,7 +40,7 @@ public class LanguageDependentFilter implements RuleMatchFilter {
   protected Set<CategoryId> disabledCategories;
   
   private static final Pattern CA_OLD_DIACRITICS = Pattern.compile(".*\\b(dóna|vénen|véns|fóra)\\b.*",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
-  private static final Pattern ES_CONTRACTIONS = Pattern.compile("\\b(a|de) e(l)\\b",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
+  private static final Pattern ES_CONTRACTIONS = Pattern.compile("\\b([Aa]|[[Dd]e) e(l)\\b",Pattern.UNICODE_CASE);
 
   public LanguageDependentFilter(Language lang, RuleSet rules) {
     language = lang;

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -337,7 +337,7 @@ protected void testGrammarRulesFromXML(List<AbstractPatternRule> rules, JLanguag
         String sourceFile = rule.getSourceFile();
         if (lang.isVariant() && sourceFile != null &&
                 sourceFile.matches("/org/languagetool/rules/" + lang.getShortCode() + "/grammar.*\\.xml") &&
-                !sourceFile.contains("-l2-")) {
+                !sourceFile.contains("-l2-") && !lang.getShortCodeWithCountryAndVariant().equals("de-DE-x-simple-language")) {
           //System.out.println("Skipping " + rule.getFullId() + " in " + sourceFile + " because we're checking a variant");
           skipCount++;
           continue;

File: languagetool-language-modules/de-DE-x-simple-language/src/test/java/org/languagetool/rules/de/SimpleGermanPatternRuleTest.java
Patch:
@@ -21,14 +21,14 @@
 import java.io.IOException;
 
 import org.junit.Test;
-import org.languagetool.language.German;
+import org.languagetool.language.SimpleGerman;
 import org.languagetool.rules.patterns.PatternRuleTest;
 
 public class SimpleGermanPatternRuleTest extends PatternRuleTest {
 
   @Test
   public void testRules() throws IOException {
-    runGrammarRulesFromXmlTest(new German());
+    runGrammarRuleForLanguage(new SimpleGerman());
   }
 
 }

File: languagetool-core/src/main/java/org/languagetool/language/LanguageIdentifier.java
Patch:
@@ -52,7 +52,7 @@ public class LanguageIdentifier {
   // texts shorter than this will *only* consider preferred languages (if set):
   private static final int CONSIDER_ONLY_PREFERRED_THRESHOLD = 50;
 
-  // ast and gl often prevent the correct detection of Spanish (as the are quite similar
+  // ast and gl often prevent the correct detection of Spanish (as they are quite similar
   // to Spanish, I assume) so we disable them for now. See LanguageDetectionEval.java:
   private static final List<String> ignoreLangCodes = Arrays.asList("ast", "gl");
 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/CheckRequestAnalysis.java
Patch:
@@ -500,7 +500,7 @@ private int changesInNumberOfParagraph(boolean getCurNum) {
       }
       toText = docCache.textSize() - toText;
       from = docCache.getFlatParagraphNumber(fromText);
-      to = docCache.getFlatParagraphNumber(toText);
+      to = toText < 0 ? 0 : docCache.getFlatParagraphNumber(toText);
     } else {
       // if no change in text is found check the number of flat paragraphs which have changed
       while (from < docCache.size() && from < oldDocCache.size()

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tokenizers/ca/CatalanWordTokenizer.java
Patch:
@@ -205,7 +205,7 @@ private List<String> wordsToAdd(String s) {
           l.add(s);
         } else {
           // words containing hyphen (-) are looked up in the dictionary
-          if (CatalanTagger.INSTANCE_CAT.tag(Arrays.asList(s.replace("’", "'"))).get(0).isTagged()) {
+          if (CatalanTagger.INSTANCE_CAT.tag(Arrays.asList(s.replaceAll("\u00AD","").replace("’", "'"))).get(0).isTagged()) {
             l.add(s);
           }
           // some camel-case words containing hyphen (is there any better fix?)
@@ -215,7 +215,7 @@ else if (s.equalsIgnoreCase("mers-cov") || s.equalsIgnoreCase("mcgraw-hill")
             l.add(s);
           }
           // words with "ela geminada" with typo: col-legi (col·legi)
-          else if (CatalanTagger.INSTANCE_CAT.tag(Arrays.asList(s.replace("l-l", "l·l"))).get(0).isTagged()) {
+          else if (CatalanTagger.INSTANCE_CAT.tag(Arrays.asList(s.replaceAll("\u00AD","").replace("l-l", "l·l"))).get(0).isTagged()) {
             l.add(s);
           // apostrophe in the last char
           } else if ((s.endsWith("'") || s.endsWith("’")) && s.length() > 1) {

File: languagetool-language-modules/en/src/main/java/org/languagetool/tokenizers/en/EnglishWordTokenizer.java
Patch:
@@ -123,7 +123,7 @@ private List<String> wordsToAdd(String s) {
           if (!s.contains("-") && !s.contains("'") && !s.contains("’")) {
             l.add(s);
           } else {
-            if (EnglishTagger.INSTANCE.tag(Arrays.asList(s.replace("’", "'"))).get(0).isTagged()) {
+            if (EnglishTagger.INSTANCE.tag(Arrays.asList(s.replaceAll("\u00AD","").replace("’", "'"))).get(0).isTagged()) {
               l.add(s);
             }
             // some camel-case words containing hyphen (is there any better fix?)

File: languagetool-language-modules/es/src/main/java/org/languagetool/tokenizers/es/SpanishWordTokenizer.java
Patch:
@@ -90,7 +90,7 @@ private List<String> wordsToAdd(String s) {
           l.add(s);
         } else {
           // words containing hyphen (-) are looked up in the dictionary
-          if (SpanishTagger.INSTANCE.tag(Arrays.asList(s.replace("’", "'"))).get(0).isTagged()) {
+          if (SpanishTagger.INSTANCE.tag(Arrays.asList(s.replaceAll("\u00AD","").replace("’", "'"))).get(0).isTagged()) {
             l.add(s);
           }
           // some camel-case words containing hyphen (is there any better fix?)

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tokenizers/fr/FrenchWordTokenizer.java
Patch:
@@ -182,7 +182,7 @@ private List<String> wordsToAdd(String s) {
           l.add(s);
         } else {
           // words containing hyphen (-) are looked up in the dictionary
-          if (FrenchTagger.INSTANCE.tag(Arrays.asList(s.replace("’", "'"))).get(0).isTagged()) {
+          if (FrenchTagger.INSTANCE.tag(Arrays.asList(s.replaceAll("\u00AD","").replace("’", "'"))).get(0).isTagged()) {
             // In the current POS tag, most apostrophes are curly: to be fixed
             l.add(s);
           }

File: languagetool-language-modules/fr/src/test/java/org/languagetool/tokenizers/fr/FrenchWordTokenizerTest.java
Patch:
@@ -83,6 +83,8 @@ public void testTokenize() {
     assertEquals(tokens.size(), 2);
     tokens = wordTokenizer.tokenize("Rendez-Vous");
     assertEquals(tokens.size(), 1);
+    tokens = wordTokenizer.tokenize("sous-trai\u00ADtants");
+    assertEquals(tokens.size(), 1);
     
     
     tokens = wordTokenizer.tokenize("10 000");

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -452,6 +452,8 @@ public void endElement(String namespaceURI, String sName,
         }
         tokenCounter = 0;
         inAntiPattern = false;
+        endPos = -1;
+        startPos = -1;
         break;
       case EXAMPLE:
         if (inCorrectExample) {

File: languagetool-core/src/main/java/org/languagetool/rules/RemoteRule.java
Patch:
@@ -265,13 +265,13 @@ public RemoteRuleConfig getServiceConfiguration() {
    *  lookup table, find shifted index for i at shifts[i];
    */
   static int[] computeOffsetShifts(String s) {
-    int len = s.length();
+    int len = s.length() + 1;
     int[] offsets = new int[len];
     int shifted = 0, original = 0;
 
     // go from codepoint to codepoint using shifted
     // offset saved in original will correspond to Java string index shifted
-    while(shifted < len) {
+    while(shifted < s.length()) {
       offsets[original] = shifted;
       shifted = s.offsetByCodePoints(shifted, 1);
       original++;

File: languagetool-language-modules/nl/src/main/java/org/languagetool/language/Dutch.java
Patch:
@@ -195,7 +195,7 @@ public List<String> getRuleFileNames() {
     List<String> ruleFileNames = super.getRuleFileNames();
     String dirBase = JLanguageTool.getDataBroker().getRulesDir() + "/" + getShortCode() + "/";
     ruleFileNames.add(dirBase + "nl-NL/grammar.xml");
-    ruleFileNames.add(dirBase + "grammar-test.xml");
+    //ruleFileNames.add(dirBase + "grammar-test.xml");
     return ruleFileNames;
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/RemoteRule.java
Patch:
@@ -261,9 +261,9 @@ public RemoteRuleConfig getServiceConfiguration() {
 
 
   /**
-   *  Helper for {@link fixMatchOffsets}
+   *  Helper for {@link #fixMatchOffsets}
    *  lookup table, find shifted index for i at shifts[i];
-   *  */
+   */
   static int[] computeOffsetShifts(String s) {
     int len = s.length();
     int[] offsets = new int[len];
@@ -300,7 +300,7 @@ static int[] computeOffsetShifts(String s) {
    * whereas Python 3 indexing/slicing and len() in strings treat them as a single character
    * so "😁foo".length() == 5, but len("😁foo") == 4;
    * "😁foo".substring(2,5) == "foo" but "😁foo"[1:4] == 'foo'
-   *  */
+   */
   public static void fixMatchOffsets(AnalyzedSentence sentence, List<RuleMatch> matches) {
     int[] shifts = computeOffsetShifts(sentence.getText());
     matches.forEach(m -> {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -486,7 +486,7 @@ public void testGetAdditionalTopSuggestions() throws Exception {
     assertFirstSuggestion("camelionhafte", "chamäleonhafte", rule, lt);
     assertFirstSuggestion("angehangenen", "angehängten", rule, lt);
     assertFirstSuggestion("spätrige", "spätere", rule, lt);
-    assertFirstSuggestion("faustigen", "faustdicke", rule, lt);
+    assertFirstSuggestion("faustigen", "faustdicken", rule, lt);
     assertFirstSuggestion("-Teex", "Tee", rule, lt);
     assertFirstSuggestion("- Teex", "Tee", rule, lt);
     assertFirstSuggestion("- Kaffeex", "Kaffee", rule, lt);

File: languagetool-core/src/main/java/org/languagetool/rules/RemoteRule.java
Patch:
@@ -190,14 +190,14 @@ public FutureTask<RemoteRuleResult> run(List<AnalyzedSentence> sentences, @Nulla
           return result;
         } catch (Exception e) {
           RemoteRuleMetrics.RequestResult status;
-          if (e instanceof TimeoutException || e instanceof InterruptedException ||
+          if (e instanceof TimeoutException || e instanceof InterruptedException || e instanceof CancellationException ||
             (e.getCause() != null && e.getCause() instanceof TimeoutException)) {
             status = RemoteRuleMetrics.RequestResult.TIMEOUT;
             logger.warn("Timed out while fetching results for remote rule " + ruleId + ", tried " + (i + 1) + " times, timeout: " + timeout + "ms" , e);
             timeoutTotal.get(ruleId).addAndGet(timeout);
           } else {
             status = RemoteRuleMetrics.RequestResult.ERROR;
-            logger.warn("Error while fetching results for remote rule " + ruleId + ", tried " + (i + 1) + " times, timeout: " + timeout + "ms" , e);
+            logger.error("Error while fetching results for remote rule " + ruleId + ", tried " + (i + 1) + " times, timeout: " + timeout + "ms" , e);
           }
 
           RemoteRuleMetrics.request(ruleId, i, System.nanoTime() - startTime, characters, status);

File: languagetool-core/src/main/java/org/languagetool/language/FastText.java
Patch:
@@ -101,15 +101,15 @@ public Map<String, Double> runFasttext(String text, List<String> additionalLangu
 
   @NotNull
   Map<String, Double> parseBuffer(String buffer, List<String> additionalLanguageCodes) {
-    String[] values = buffer.split("\\s+");
+    String[] values = buffer.trim().split("\\s+");
     if (!buffer.startsWith("__label__")) {
       throw new FastTextException("FastText output is expected to start with '__label__': ''" + buffer + "'", true);
     }
     if (values.length % 2 != 0) {
       throw new FastTextException("Error while parsing fasttext output, expected pairs of '__label_xx' and float: '" + buffer + "'", true);
     }
-    if (buffer.lastIndexOf("\n", buffer.length() - 2) != -1) {
-        logger.warn("Got multiple lines to read from Fasttext, this should not happen: '" + buffer + "'" );
+    if (buffer.trim().contains("\n")) {
+      logger.warn("Got multiple lines to read from Fasttext, this should not happen: '" + buffer + "'" );
     }
     Map<String, Double> probabilities = new HashMap<>();
     for (int i = 0; i < values.length; i += 2) {

File: languagetool-core/src/test/java/org/languagetool/language/FastTextTest.java
Patch:
@@ -116,7 +116,7 @@ private String getBestLang(Map<String, Double> resMap) {
   public void testParsing() throws Exception {
     FastText ft = new FastText();
     List<String> l = Arrays.asList("en", "fy", "de", "es", "nl");
-    Map<String, Double> res1 = ft.parseBuffer("__label__nl 0.423696 __label__fy 0.207109", l);
+    Map<String, Double> res1 = ft.parseBuffer("__label__nl 0.423696 __label__fy 0.207109\n", l);
     assertThat(res1.size(), is(2));
     assertThat(res1.get("nl"), is(0.423696));
     assertThat(res1.get("fy"), is(0.207109));
@@ -140,6 +140,7 @@ public void testParsing() throws Exception {
     } catch (RuntimeException expected) {}
     // this had happened in the past when somehow Fasttext received two texts and thus
     // responds with two lines of output:
+    System.out.println("Ignore the following WARN:");
     Map<String, Double> res5 = ft.parseBuffer("__label__de 0.9\n__label__fr 0.1", l);
     assertThat(res5.size(), is(1));
     assertThat(res5.get("de"), is(0.9));

File: languagetool-core/src/test/java/org/languagetool/language/FastTextTest.java
Patch:
@@ -49,6 +49,7 @@ public void testInteractively() throws Exception {
   }
   
   @Test
+  @Ignore("requires local FastText")
   public void testCaseShouldNotMatter() throws Exception {
     // all-uppercase yields bad results (also see https://github.com/facebookresearch/fastText/issues/1181),
     // so make sure we lowercase input internally

File: languagetool-core/src/main/java/org/languagetool/language/FastText.java
Patch:
@@ -80,7 +80,7 @@ public Map<String, Double> runFasttext(String text, List<String> additionalLangu
         logger.warn("More input to read from Fasttext, this should not happen; language detection results might be mixed up");
       }
     }
-    return parseBuffer(buffer, additionalLanguageCodes);
+    return parseBuffer(new String(cbuf), additionalLanguageCodes);
   }
 
   @NotNull

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleCheck.java
Patch:
@@ -746,7 +746,8 @@ private List<SentenceErrors> getSentenceErrosAsList(int numberOfParagraph, SwJLa
     if (nextSentencePositions == null) {
       nextSentencePositions = new ArrayList<Integer>();
     }
-    if (nextSentencePositions.size() == 0 && docCache != null && numberOfParagraph < docCache.size()) {
+    if (nextSentencePositions.size() == 0 && docCache != null 
+        && numberOfParagraph >= 0 && numberOfParagraph < docCache.size()) {
       nextSentencePositions =  getNextSentencePositions (docCache.getFlatParagraph(numberOfParagraph), lt);
     }
     int startPosition = 0;

File: languagetool-core/src/main/java/org/languagetool/language/FastText.java
Patch:
@@ -86,8 +86,7 @@ Map<String, Double> parseBuffer(String buffer, List<String> additionalLanguageCo
       throw new RuntimeException("Error while parsing fasttext output: " + buffer);
     }
     if (!buffer.startsWith("__label__")) {
-      logger.warn("FastText output is expected to start with '__label__', will continue anyway: '{}'", buffer);
-      // TODO: throw exception once we know this doesn't commonly happen
+      logger.error("FastText output is expected to start with '__label__', will continue anyway: '{}'", buffer);
     }
     Map<String, Double> probabilities = new HashMap<>();
     for (int i = 0; i < values.length; i += 2) {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/UnnecessaryPhraseRule.java
Patch:
@@ -112,7 +112,7 @@ protected String getLimitMessage(int limit, double percent) {
     if (limit == 0) {
       return "Der Ausdruck gilt als Phrase. Es wird empfohlen ihn zu löschen, falls möglich.";
     }
-    return "Mehr als " + limit + "‱ potentielle Phrasen {" + ((int) (percent +0.5d)) + 
+    return "Mehr als " + limit + "‱ potenzielle Phrasen {" + ((int) (percent +0.5d)) +
         "‱} gefunden. Es wird empfohlen den Ausdruck zu löschen, falls möglich.";
   }
 
@@ -128,12 +128,12 @@ public String getId() {
 
   @Override
   public String getDescription() {
-    return "Statistische Stilanalyse: Potentielle Phrasen";
+    return "Statistische Stilanalyse: Potenzielle Phrasen";
   }
 
   @Override
   public String getConfigureText() {
-    return "Anzeigen wenn mehr als ...‱ eines Kapitels potentielle Phrasen sind:";
+    return "Anzeigen wenn mehr als ...‱ eines Kapitels potenzielle Phrasen sind:";
   }
 
 }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/CheckRequestAnalysis.java
Patch:
@@ -498,6 +498,7 @@ private int changesInNumberOfParagraph(boolean getCurNum) {
                   oldDocCache.getTextParagraph(oldDocCache.textSize() - toText))) {
         toText++;
       }
+      toText = docCache.textSize() - toText;
       from = docCache.getFlatParagraphNumber(fromText);
       to = docCache.getFlatParagraphNumber(toText);
     } else {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleCheck.java
Patch:
@@ -746,7 +746,7 @@ private List<SentenceErrors> getSentenceErrosAsList(int numberOfParagraph, SwJLa
     if (nextSentencePositions == null) {
       nextSentencePositions = new ArrayList<Integer>();
     }
-    if (nextSentencePositions.size() == 0 && docCache != null) {
+    if (nextSentencePositions.size() == 0 && docCache != null && numberOfParagraph < docCache.size()) {
       nextSentencePositions =  getNextSentencePositions (docCache.getFlatParagraph(numberOfParagraph), lt);
     }
     int startPosition = 0;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/FindSuggestionsFilter.java
Patch:
@@ -43,7 +43,7 @@ public FindSuggestionsFilter() throws IOException {
 
   @Override
   protected Tagger getTagger() {
-    return CatalanTagger.INSTANCE_VAL;
+    return CatalanTagger.INSTANCE_CAT;
   }
 
   @Override

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/TokenAgreementPrepNounRule.java
Patch:
@@ -182,7 +182,7 @@ public final RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
       // згідно з документа
       if( Z_ZI_IZ.contains(prep.toLowerCase())
           && i >= 3 && tokens[i-2].getCleanToken().equalsIgnoreCase("згідно") ) {
-        expectedCases = new HashSet<>(Set.of("v_oru"));
+        expectedCases = new HashSet<>(Arrays.asList("v_oru"));
       }
 
       // we want to ignore «залежно» + noun, but we want to catch «незважаючи» без «на»

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/PronomFebleDuplicateRule.java
Patch:
@@ -28,7 +28,7 @@ public class PronomFebleDuplicateRule extends Rule {
   private static final Pattern GERUNDI = Pattern.compile("V.G.*");
   private static final String[] ABANS_DE_GERUNDI = { "continuar", "seguir", "prosseguir", "anar", "estar" };
   private static final String[] ABANS_DE_INFINITIU = { "anar", "poder", "voler", "deure" };
-  private static final String[] ABANS_DE_A = { "començar", "tornar", "acostumar", "atrevir" }; //"ajudar",
+  private static final String[] ABANS_DE_A = { "començar", "tornar" }; //"ajudar", "atrevir" , "acostumar"
   //private static final String[] VERBS_IMPERSONAL = new String[] { "ordenar", "recomanar" };
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1056,8 +1056,10 @@ protected void fetchRemoteRuleResults(Mode mode, Level level, List<AnalyzedSente
             }
             remoteMatches.addAll(adjustedMatches);
           }
-        } catch (InterruptedException | ExecutionException e) {
+        } catch (InterruptedException | CancellationException e) {
           logger.warn("Failed to fetch result from remote rule.", e);
+        } catch (ExecutionException e) {
+          logger.error("Failed to fetch result from remote rule.", e);
         }
       }
 

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/PronomFebleDuplicateRuleTest.java
Patch:
@@ -140,6 +140,9 @@ public void testRule() throws IOException {
     matches = rule.match(lt.getAnalyzedSentence("S'està rebel·lant-se."));
     assertEquals(1, matches.length);
     
+    matches = rule.match(lt.getAnalyzedSentence("Li va començar a dur-li problemes."));
+    assertEquals(1, matches.length);
+    
   }
     
     private void assertCorrect(String sentence) throws IOException {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GenericUnpairedBracketsRuleTest.java
Patch:
@@ -54,6 +54,7 @@ public void testGermanRule() throws IOException {
     assertMatches("(Die URL lautet https://de.wikipedia.org/wiki/Schlammersdorf oder so)", 0);
     assertMatches("(Die URL lautet: http://www.pariscinema.org/).", 0);
     assertMatches("Drücken Sie auf den \"Jetzt Starten\"-Knopf.", 0);
+    assertMatches("Welches ist dein Lieblings-\"Star Wars\"-Charakter?", 0);
     // incorrect sentences:
     assertMatches("Die „Sätze zum Testen.", 1);
     assertMatches("Die «Sätze zum Testen.", 1);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GenericUnpairedBracketsRuleTest.java
Patch:
@@ -53,6 +53,7 @@ public void testGermanRule() throws IOException {
     assertMatches("(Die URL lautet https://de.wikipedia.org/wiki/Schlammersdorf)", 0);
     assertMatches("(Die URL lautet https://de.wikipedia.org/wiki/Schlammersdorf oder so)", 0);
     assertMatches("(Die URL lautet: http://www.pariscinema.org/).", 0);
+    assertMatches("Drücken Sie auf den \"Jetzt Starten\"-Knopf.", 0);
     // incorrect sentences:
     assertMatches("Die „Sätze zum Testen.", 1);
     assertMatches("Die «Sätze zum Testen.", 1);

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/wikipedia/SuggestionReplacerTest.java
Patch:
@@ -175,7 +175,7 @@ public void testCompleteText2() throws Exception {
     PlainTextMapping mapping = filter.filter(origMarkup);
     lt.disableRule("PUNCTUATION_PARAGRAPH_END");  //  added to prevent crash; TODO: check if needed
     List<RuleMatch> matches = lt.check(mapping.getPlainText());
-    assertTrue("Expected >= 30 matches, got: " + matches, matches.size() >= 30);
+    assertTrue("Expected >= 29 matches, got: " + matches, matches.size() >= 29);
     for (RuleMatch match : matches) {
       SuggestionReplacer replacer = new SuggestionReplacer(mapping, origMarkup, new ErrorMarker("<s>", "</s>"));
       List<RuleMatchApplication> ruleMatchApplications = replacer.applySuggestionsToOriginalText(match);

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -194,6 +194,9 @@ protected int getPriorityForId(String id) {
       case "DIACRITICS": return 30;
       case "POR_CIERTO": return 30;
       case "LO_LOS": return 30;
+      case "ES_SIMPLE_REPLACE": return 30; // greater than typography rules
+      case "ETCETERA": return 30; // greater than other typography rules
+      case "ESPACIO_DESPUES_DE_PUNTO": return 25; // greater than other typography rules
       case "AGREEMENT_ADJ_NOUN_AREA": return 30; // greater than AGREEMENT_DET_NOUN
       case "SE_CREO": return 25; // less than DIACRITICS_VERB_N_ADJ
       case "PRONOMBRE_SIN_VERBO": return 25; // inside CONFUSIONS, but less than other rules ?
@@ -202,15 +205,12 @@ protected int getPriorityForId(String id) {
       case "AGREEMENT_DET_NOUN_EXCEPTIONS": return 25; // greater than AGREEMENT_DET_NOUN
       case "TYPOGRAPHY": return 25; // greater than AGREEMENT_DET_NOUN
       case "AGREEMENT_DET_NOUN": return 20;
-      case "ETCETERA": return 20; // greater than ESPACIO_DESPUES_DE_PUNTO
       //case "PRONOMBRE_SIN_VERBO": return 20;
       case "P_EJ": return 20;
-      case "ESPACIO_DESPUES_DE_PUNTO": return 15;
       case "AGREEMENT_DET_ADJ": return 10;
       case "HALLA_HAYA": return 10;
       case "VALLA_VAYA": return 10;
       case "TE_TILDE2": return 10; // less than PRONOMBRE_SIN_VERBO
-      case "ES_SIMPLE_REPLACE": return 10;
       case "SINGLE_CHARACTER": return 5;
       case "SEPARADO": return 1;
       case "E_EL": return -10;

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -246,6 +246,7 @@ protected int getPriorityForId(String id) {
       case "PAS_DE_TRAIT_UNION": return 50; //  // greater than agreement rules
       case "PRIME-TIME": return 50; //  // greater than agreement rules
       case "A_VERBE_INFINITIF": return 20; // greater than PRONSUJ_NONVERBE
+      case "CAT_TYPOGRAPHIE": return 20; // greater than PRONSUJ_NONVERBE or agreement rules
       case "CONFUSION_PARLEZ_PARLER": return 10; // greater than N_V
       case "AGREEMENT_TOUT_LE": return 10; // compare to TOUT_LES
       case "ESPACE_UNITES": return 10; // needs to have higher priority than spell checker
@@ -259,8 +260,8 @@ protected int getPriorityForId(String id) {
       //case "D_N": return 10; // needs to have higher priority than agreement postponed adj | Commented out because many other rules should be higher: CAT_REGIONALISMES, CAT_TYPOGRAPHIE, CAT_GRAMMAIRE...
       //case "ACCORD_COULEUR": return 1; // needs to have higher priority than agreement postponed adj
       case "R_VAVOIR_VINF": return 10; // needs higher priority than A_INFINITIF
-      case "PRONSUJ_NONVERBE": return 10; // needs higher priority than AUXILIAIRE_MANQUANT
-      case "AUXILIAIRE_MANQUANT": return 5; // needs higher priority than ACCORD_NOM_VERBE
+      //case "PRONSUJ_NONVERBE": return 10; // needs higher priority than AUXILIAIRE_MANQUANT
+      //case "AUXILIAIRE_MANQUANT": return 5; // needs higher priority than ACCORD_NOM_VERBE
       case "CONFUSION_PAR_PART": return -5;  // turn off completely when PART_OU_PAR is activated
       case "FR_SIMPLE_REPLACE": return -10;
       case "IMP_PRON": return -10; // less than D_N

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -88,7 +88,7 @@ protected abstract DetectedLanguage getLanguage(String text, Map<String, String>
   // keep track of timeouts of the hidden matches server, check health periodically;
   // -1 => healthy, else => check timed out at given date, check back if time difference > config.getHiddenMatchesFailTimeout()
   private long lastHiddenMatchesServerTimeout;
-  // counter; mark as down if this reaches hidenMatchesServerFall
+  // counter; mark as down if this reaches hiddenMatchesServerFall
   private long hiddenMatchesServerFailures = 0;
   private final LanguageIdentifier fastTextIdentifier;
   private final ExecutorService executorService;

File: languagetool-language-modules/de-DE-x-simple-language/src/test/java/org/languagetool/rules/de/SimpleGermanTest.java
Patch:
@@ -33,7 +33,8 @@ public void testLanguage() throws IOException {
     String s = "Fügen Sie hier Ihren Text ein oder benutzen Sie diesen Text als Beispiel. Dieser Text wurde nur zum Testen geschrieben. Die Donaudampfschifffahrt darf da nicht fehlen. Und die Nutzung des Genitivs auch nicht.";
     SimpleGerman lang = new SimpleGerman();
     testDemoText(lang, s,
-      Arrays.asList("ZWEI_INFORMATIONSEINHEITEN_PRO_SATZ", "TOO_LONG_SENTENCE_DE", "PASSIV", "LANGES_WORT", "VERNEINUNG", "ABSTRAKTE_WOERTER", "GENITIV")
+      Arrays.asList("ZWEI_INFORMATIONSEINHEITEN_PRO_SATZ", /*"TOO_LONG_SENTENCE_DE", -- filtered due to overlapping other errors */
+        "PASSIV", "LANGES_WORT", "VERNEINUNG", "ABSTRAKTE_WOERTER", "GENITIV")
     );
     runTests(lang, "de-DE-x-simple-language");
   }

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/wikipedia/SuggestionReplacerTest.java
Patch:
@@ -145,6 +145,7 @@ protected synchronized List<AbstractPatternRule> getPatternRules() {
     lt.disableRule("TYPOGRAFISCHE_ANFUEHRUNGSZEICHEN");
     lt.disableRule("OLD_SPELLING");
     lt.disableRule("DE_TOO_LONG_SENTENCE_40");
+    lt.disableRule("TOO_LONG_SENTENCE_DE");
     lt.disableRule("PUNCTUATION_PARAGRAPH_END");
     PlainTextMapping mapping = filter.filter(origMarkup);
     List<RuleMatch> matches = lt.check(mapping.getPlainText());

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1881,7 +1881,7 @@ private CheckResults getOtherRuleMatches() {
           throw e;
         } catch (StackOverflowError e) {
           System.out.println("Could not check sentence due to StackOverflowError (language: " + language + "): <sentcontent>"
-                  + StringUtils.abbreviate(sentence.analyzed.toTextString(), 500) + "</sentcontent>");
+                  + StringUtils.abbreviate(sentence.analyzed.toTextString(), 10_000) + "</sentcontent>");
           throw e;
         } catch (Exception e) {
           throw new RuntimeException("Could not check sentence (language: " + language + "): <sentcontent>"

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -720,7 +720,7 @@ DetectedLanguage detectLanguageOfString(String text, String fallbackLanguage, Li
     DetectedLanguage detected;
     //String mode;
     //long t1 = System.nanoTime();
-    String cleanText = ngramIdentifier.cleanAndShortenText(text);
+    String cleanText = ngramIdentifier != null ? ngramIdentifier.cleanAndShortenText(text) : fastTextIdentifier.cleanAndShortenText(text);
     if (ngramIdentifier != null && cleanText.length() < NGRAM_THRESHOLD) {
       detected = ngramIdentifier.detectLanguage(cleanText, noopLangs, preferredLangs);
       //mode = "ngram";

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/PrepositionToCases.java
Patch:
@@ -43,7 +43,7 @@ enum Case {
     add("an", Dat, Akk);
     add("angesichts", Gen);
     add("anhand", Gen);
-    add("anläßlich", Gen);
+    add("anlässlich", Gen);
     add("anstatt", Gen);
     add("anstelle", Gen);
     add("auf", Dat, Akk);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CompoundCoherencyRule.java
Patch:
@@ -65,7 +65,7 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
           continue;
         }
         // The whole implementation could be simpler, but this way we also catch cases where
-        // the word (and this its lemma) isn't known.
+        // the word (and thus its lemma) isn't known.
         String lemma = lemmaOrNull != null ? lemmaOrNull : token;
         String normToken = lemma.replace("-", "").toLowerCase();
         if (StringUtils.isNumeric(normToken)) {

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -266,7 +266,7 @@ protected int getPriorityForId(String id) {
       case "UPPERCASE_SENTENCE_START": return -300;
       case "FRENCH_WHITESPACE_STRICT": return -350; // picky; if on, it should overwrite FRENCH_WHITESPACE
       case "FRENCH_WHITESPACE": return -400; // lesser than UPPERCASE_SENTENCE_START and FR_SPELLING_RULE
-      case "A_ACCENT_A1": return 10; // greater than A_ACCENT_A
+      case "R_VAVOIR_VINF": return 10; // needs higher priority than A_INFINITIF
     }
     if (id.startsWith("grammalecte_")) {
       return -150;

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -241,6 +241,7 @@ protected int getPriorityForId(String id) {
       case "CEST_A_DIRE": return 100; // greater than A_A_ACCENT
       case "FAIRE_VPPA": return 100; // greater than A_ACCENT_A
       case "A_VERBE_INFINITIF": return 20; // greater than PRONSUJ_NONVERBE
+      case "CONFUSION_PARLEZ_PARLER": return 10; // greater than N_V
       case "ESPACE_UNITES": return 10; // needs to have higher priority than spell checker
       case "BYTES": return 10; // needs to be higher than spell checker for 10MB style matches
       case "Y_A": return 10; // needs to be higher than spell checker for style suggestion

File: languagetool-core/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -112,6 +112,7 @@ public class WordListValidatorTest {
           "V&D",
           "İlkay",
           "Gündoğan",
+          "Tuğrul",
           "Ñuñoa",
           "Ibišević",
           "Fríður",

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/index/PatternRuleQueryBuilderTest.java
Patch:
@@ -112,7 +112,7 @@ public void testQueryBuilder() throws Exception {
   }
 
   public void testCaseSensitive() throws Exception {
-    InputStream input = new ByteArrayInputStream(("<?xml version='1.0' encoding='UTF-8'?> <rules lang='en'> <category name='Test'>" +
+    InputStream input = new ByteArrayInputStream(("<?xml version='1.0' encoding='UTF-8'?> <rules lang='en'> <category id='TEST' name='Test'>" +
             "<rule id='TEST_RULE_1' name='test_1'> <pattern case_sensitive='yes'><token>How</token></pattern> </rule>" +
             "<rule id='TEST_RULE_2' name='test_2'> <pattern case_sensitive='yes'><token>how</token></pattern> </rule>" +
             "<rule id='TEST_RULE_3' name='test_3'> <pattern><token>How</token></pattern> </rule>" +
@@ -280,7 +280,7 @@ private void assertMatches(AbstractPatternRule patternRule, int expectedMatches)
   private AbstractPatternRule makeRule(String ruleXml) throws IOException {
     StringBuilder sb = new StringBuilder();
     sb.append("<?xml version='1.0' encoding='UTF-8'?>");
-    sb.append("<rules lang='en'> <category name='Test'> <rule id='TEST_RULE' name='test'>");
+    sb.append("<rules lang='en'> <category id='TEST' name='Test'> <rule id='TEST_RULE' name='test'>");
     sb.append("<pattern>");
     sb.append(ruleXml);
     sb.append("</pattern> </rule> </category> </rules>");

File: languagetool-core/src/main/java/org/languagetool/Language.java
Patch:
@@ -381,7 +381,6 @@ public synchronized SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
       sentenceTokenizer = createDefaultSentenceTokenizer();
     }
-
     return sentenceTokenizer;
   }
 
@@ -436,7 +435,6 @@ public synchronized Chunker getChunker() {
     if (chunker == null) {
       chunker = createDefaultChunker();
     }
-
     return chunker;
   }
 
@@ -465,7 +463,6 @@ public synchronized Chunker getPostDisambiguationChunker() {
     if (postDisambiguationChunker == null) {
       postDisambiguationChunker = createDefaultPostDisambiguationChunker();
     }
-
     return postDisambiguationChunker;
   }
 

File: languagetool-core/src/main/java/org/languagetool/tools/RuleMatchesAsJsonSerializer.java
Patch:
@@ -182,7 +182,7 @@ private void writeMatchesSection(String sectionName, JsonGenerator g, List<Check
         }
         writeReplacements(g, match);
         g.writeNumberField("offset", match.getFromPos());
-      g.writeNumberField("length", match.getToPos()-match.getFromPos());
+        g.writeNumberField("length", match.getToPos()-match.getFromPos());
         writeContext(g, match, text, contextTools);
         g.writeObjectFieldStart("type");
         g.writeStringField("typeName", match.getType().toString());

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -1721,7 +1721,8 @@ private boolean isNominalization(int i, AnalyzedTokenReadings[] tokens, String t
         // "aus sechs Überwiegend muslimischen Ländern"
         return false;
       }
-      return (prevToken != null && prevTokenStr.matches("irgendwelche|irgendwas|weniger?|einiger?|mehr|aufs") || isNumber(prevTokenStr)) ||
+      return ((prevToken != null && prevTokenStr.matches("irgendwelche|irgendwas|weniger?|einiger?|mehr|aufs") && tokens[i].hasPartialPosTag("SUB"))
+              || isNumber(prevTokenStr)) ||
          (hasPartialTag(prevToken, "ART", "PRO:") && !(((i < 4 && tokens.length > 4) || prevToken.getReadings().size() == 1 || prevPrevToken.hasLemma("sein")) && prevToken.hasPosTagStartingWith("PRO:PER:NOM:"))  && !prevToken.hasPartialPosTag(":STD")) ||  // "die Verurteilten", "etwas Verrücktes", "ihr Bestes"
          (hasPartialTag(prevPrevPrevToken, "ART") && hasPartialTag(prevPrevToken, "PRP") && hasPartialTag(prevToken, "SUB")) || // "die zum Tode Verurteilten"
          (hasPartialTag(prevPrevToken, "PRO:", "PRP") && hasPartialTag(prevToken, "ADJ", "ADV", "PA2", "PA1")) ||  // "etwas schön Verrücktes", "mit aufgewühltem Innerem"

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -375,6 +375,7 @@ public void testRule() throws IOException {
     assertGood("§ 1 Allgemeine Bedingungen");
     assertGood("§1 Allgemeine Bedingungen");
     assertGood(" Das ist das Aus des Airbus A380.");
+    assertBad("Das existiert im Jazz zunehmend nicht mehr Bei der weiteren Entwicklung des Jazz zeigt sich das.");
 
     // uppercased adjective compounds
     assertGood("Er isst UV-bestrahltes Obst.");

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -328,9 +328,6 @@ protected int getPriorityForId(String id) {
       case "MAY_MANY":                  return 1;   // higher prio than MAY_MANY_MY
       case "BOUT_TO":                   return 1;   // higher prio than PRP_VB
       case "HAVE_HAVE":                 return 1;   // higher prio than HE_D_VBD
-      case "UPPERCASE_SENTENCE_START":  return 1;   // higher prio than AI_HYDRA_LEO
-      case "TO_TOO":                    return 1;   // higher prio than AI_HYDRA_LEO_REPLACE_*
-      case "CAR_CARE":                  return 1;   // higher prio than AI_HYDRA_LEO_MISSING_THE
       case "LUV":                       return 1;   // higher prio than spell checker
       case "DAT":                       return 1;   // higher prio than spell checker
       case "MAC_OS":                    return 1;   // higher prio than spell checker
@@ -498,6 +495,9 @@ protected int getPriorityForId(String id) {
     if (id.startsWith("CONFUSION_RULE_")) {
       return -20;
     }
+    if (id.startsWith("AI_HYDRA_LEO")) { // prefer more specific rules
+      return -1;
+    }
     if (id.matches("EN_FOR_[A-Z]+_SPEAKERS_FALSE_FRIENDS.*")) {
       return -21;
     }

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/MorfologikFrenchSpellerRule.java
Patch:
@@ -39,7 +39,8 @@ public final class MorfologikFrenchSpellerRule extends MorfologikSpellerRule {
       "^(non|en|a|le|la|les|pour|de|du|des|un|une|mon|ma|mes|ton|ta|tes|son|sa|ses|leur|leurs|ce|cet) (..+)$",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
   private static final Pattern PREFIX_AMB_ESPAI = Pattern.compile(
-      "^(agro|anti|archi|auto|aéro|cardio|co|cyber|demi|ex|extra|grand|géo|haut|hospitalo|hydro|hyper|hypo|infra|inter|macro|mega|meta|mi|micro|mini|mono|multi|musculo|méga|méta|nord|néo|omni|pan|para|pluri|poly|post|prim|pro|proto|pré|pseudo|psycho|péri|re|retro|ré|semi|simili|socio|sous|sud|super|supra|sur|sus|trans|tri|télé|ultra|uni|vice|éco|l|d) (..+)$",
+      "^(agro|anti|archi|auto|aéro|cardio|co|cyber|demi|ex|extra|géo|hospitalo|hydro|hyper|hypo|infra|inter|macro|mega|meta|mi|micro|mini|mono|multi|musculo|méga|méta|néo|omni|pan|para|pluri|poly|post|prim|pro|proto|pré|pseudo|psycho|péri|re|retro|ré|semi|simili|socio|super|supra|sus|trans|tri|télé|ultra|uni|vice|éco|l|d) (..+)$",
+      //grand, haut, nord, sud, sous, sur
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
 
   private static final Pattern APOSTROF_INICI_VERBS = Pattern.compile("^([lnts])(h?[aeiouàéèíòóú].*[^è])$",

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/MorfologikFrenchSpellerRule.java
Patch:
@@ -39,7 +39,7 @@ public final class MorfologikFrenchSpellerRule extends MorfologikSpellerRule {
       "^(non|en|a|le|la|les|pour|de|du|des|un|une|mon|ma|mes|ton|ta|tes|son|sa|ses|leur|leurs|ce|cet) (..+)$",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
   private static final Pattern PREFIX_AMB_ESPAI = Pattern.compile(
-      "^(auto|ex|extra|macro|mega|meta|micro|multi|mono|mini|post|retro|semi|super|trans|l|d) (..+)$",
+      "^(agro|anti|archi|auto|aéro|cardio|co|cyber|demi|ex|extra|grand|géo|haut|hospitalo|hydro|hyper|hypo|infra|inter|macro|mega|meta|mi|micro|mini|mono|multi|musculo|méga|méta|nord|néo|omni|pan|para|pluri|poly|post|prim|pro|proto|pré|pseudo|psycho|péri|re|retro|ré|semi|simili|socio|sous|sud|super|supra|sur|sus|trans|tri|télé|ultra|uni|vice|éco|l|d) (..+)$",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
 
   private static final Pattern APOSTROF_INICI_VERBS = Pattern.compile("^([lnts])(h?[aeiouàéèíòóú].*[^è])$",

File: languagetool-language-modules/fr/src/test/java/org/languagetool/tagging/disambiguation/rules/fr/FrenchRuleDisambiguatorTest.java
Patch:
@@ -55,7 +55,7 @@ public void setUp() throws IOException {
   @Test
   public void testChunker() throws IOException {
     TestTools.myAssert("Il a enfin publié son livre.",
-        "/[null]SENT_START Il/[il]R pers suj 3 m s  /[null]null a/[avoir]V avoir ind pres 3 s  /[null]null enfin/[enfin]A  /[null]null publié/[publier]V ppa m s  /[null]null son/[son]D e s|son/[son]D m s|son/[son]_GN_MS  /[null]null livre/[livre]N e s|livre/[livre]_GN_MS ./[null]null", 
+        "/[null]SENT_START Il/[il]R pers suj 3 m s  /[null]null a/[avoir]V avoir ind pres 3 s  /[null]null enfin/[enfin]A  /[null]null publié/[publier]V ppa m s  /[null]null son/[son]D e s  /[null]null livre/[livre]N e s ./[null]null", 
         tokenizer, sentenceTokenizer, tagger, disambiguator);
     TestTools.myAssert("Je danse toutes les semaines au club.",
         "/[null]SENT_START Je/[je]R pers suj 1 s  /[null]null danse/[danser]V ind pres 1 s|danse/[danser]V sub pres 1 s  /[null]null toutes/[tout]D f p  /[null]null les/[le]D e p|les/[les]_GN_FP  /[null]null semaines/[semaine]N f p|semaines/[semaines]_GN_FP  /[null]null au/[à+le]P+D m s  /[null]null club/[club]N m s ./[null]null",

File: languagetool-language-modules/es/src/test/java/org/languagetool/tokenizers/es/SpanishSentenceTokenizerTest.java
Patch:
@@ -83,6 +83,7 @@ public final void testTokenize() {
     testSplit("En EE. UU. esto no pasa.");
     testSplit("Me voy a EE. UU. ", "Buen viaje.");
     testSplit("Uno (ca. 2010), dos (c. 2011), tres (ca. XIX), cuatro (c. XX)");
+    testSplit("Ayto. de Madrid.");
 
     // Exception to abbreviations    
     testSplit("Esto pasa el PP. ", "Pero, por otra parte,");

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/PostponedAdjectiveConcordanceFilter.java
Patch:
@@ -111,7 +111,7 @@ public class PostponedAdjectiveConcordanceFilter extends RuleFilter {
   private static final Pattern COORDINACIO_IONI = Pattern.compile("et|ou|ni");
   private static final Pattern KEEP_COUNT = Pattern.compile("Y|J .*|N .*|D .*|P.*|V ppa .*|M nonfin|UNKNOWN|Z.*|V.* inf|V ppr");
   private static final Pattern KEEP_COUNT2 = Pattern.compile(",|et|ou|ni"); // |\\d+%?|%
-  private static final Pattern STOP_COUNT = Pattern.compile("[;:\\(\\)\\[\\]–—―‒]");
+  private static final Pattern STOP_COUNT = Pattern.compile("[\\-;:\\(\\)\\[\\]–—―‒]");
   private static final Pattern PREPOSICIONS = Pattern.compile("P");
   private static final Pattern PREPOSICIO_CANVI_NIVELL = Pattern.compile("d'|de|des|du|à|au|aux|en|dans|sur|entre|par|pour|avec|sans|contre|comme"); //???
   private static final Pattern VERB = Pattern.compile("V.* (inf|ind|sub|con|ppr|imp).*"); // Any verb that is not V ppa

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -145,7 +145,7 @@ protected abstract DetectedLanguage getLanguage(String text, Map<String, String>
     }
   }
 
-  private static Language parseLanguage(String code) throws BadRequestException {
+  protected static Language parseLanguage(String code) throws BadRequestException {
     try {
       return Languages.getLanguageForShortCode(code);
     } catch (IllegalArgumentException e) {

File: languagetool-server/src/main/java/org/languagetool/server/V2TextChecker.java
Patch:
@@ -112,7 +112,7 @@ protected DetectedLanguage getLanguage(String text, Map<String, String> paramete
     if (getLanguageAutoDetect(parameters)) {
       givenLang = detectedLang.getDetectedLanguage();
     } else {
-      givenLang = Languages.getLanguageForShortCode(langParam);
+      givenLang = parseLanguage(langParam);
     }
     return new DetectedLanguage(givenLang, detectedLang.getDetectedLanguage(), detectedLang.getDetectionConfidence());
   }

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tagging/fr/FrenchTagger.java
Patch:
@@ -49,8 +49,8 @@ public class FrenchTagger extends BaseTagger {
       "(post-|sur-|mini-|méga-|demi-|péri-|anti-|géo-|nord-|sud-|néo-|méga-|ultra-|pro-|inter-|micro-|macro-|sous-|haut-|auto-|ré-|pré-|super-|vice-|hyper-|proto-|grand-|pseudo-)(.+)",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
   private static final Pattern PREFIXES_FOR_NOUN_ADJ = Pattern.compile(
-      "(mini|méga|post)([^-].*[aeiouêàéèíòóïü].+[aeiouêàéèíòóïü].*)", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
-  // |nord-|sud-
+      "(mini|méga)([^-].*[aeiouêàéèíòóïü].+[aeiouêàéèíòóïü].*)", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
+  // |nord-|sud-|post
 
   public FrenchTagger() {
     super("/fr/french.dict", Locale.FRENCH, false);

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tagging/fr/FrenchTagger.java
Patch:
@@ -46,10 +46,10 @@ public class FrenchTagger extends BaseTagger {
 
   private static final Pattern NOUN_ADJ = Pattern.compile("[NJ] .+|V ppa.*");
   private static final Pattern PREFIXES_NOUN_ADJ = Pattern.compile(
-      "(sur-|mini-|méga-|demi-|péri-|anti-|géo-|nord-|sud-|néo-|méga-|ultra-|pro-|inter-|micro-|macro-|sous-|haut-|auto-|ré-|pré-|super-|vice-|hyper-|proto-|grand-|pseudo-)(.+)",
+      "(post-|sur-|mini-|méga-|demi-|péri-|anti-|géo-|nord-|sud-|néo-|méga-|ultra-|pro-|inter-|micro-|macro-|sous-|haut-|auto-|ré-|pré-|super-|vice-|hyper-|proto-|grand-|pseudo-)(.+)",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
   private static final Pattern PREFIXES_FOR_NOUN_ADJ = Pattern.compile(
-      "(mini|méga)([^-].*[aeiouêàéèíòóïü].+[aeiouêàéèíòóïü].*)", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
+      "(mini|méga|post)([^-].*[aeiouêàéèíòóïü].+[aeiouêàéèíòóïü].*)", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
   // |nord-|sud-
 
   public FrenchTagger() {

File: languagetool-core/src/test/java/org/languagetool/tagging/disambiguation/rules/DisambiguationRuleTest.java
Patch:
@@ -175,7 +175,7 @@ private void testDisambiguationRulesFromXML(List<DisambiguationPatternRule> rule
               int endPos = readings.getEndPos();
               assertTrue(
                   "Wrong marker position in the example for the rule " + id +
-                  ": got " + startPos + "-" + endPos + ", expected " + expectedMatchStart + "-" + expectedMatchEnd,
+                  ": got " + startPos + "-" + endPos + ", expected " + expectedMatchStart + "-" + expectedMatchEnd + ". Sentence: '" + sent + "'",
                   startPos == expectedMatchStart && endPos == expectedMatchEnd);
               break;
             }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SwJLanguageTool.java
Patch:
@@ -63,15 +63,16 @@ public SwJLanguageTool(Language language, Language motherTongue, UserConfig user
     isRemote = config.doRemoteCheck() && !testMode;
     doReset = false;
     if (isRemote) {
-      lt = null;
       mlt = null;
       rlt = new LORemoteLanguageTool(language, motherTongue, config, extraRemoteRules);
       if (!rlt.remoteRun()) {
         MessageHandler.showMessage(MESSAGES.getString("loRemoteSwitchToLocal"));
         isRemote = false;
         isMultiThread = false;
-        lt = new JLanguageTool(language, motherTongue, null, userConfig);
       }
+      //  lt is needed for methods getAnalyzedSentence and sentenceTokenize
+      //  TODO: Advance remote server to support these two functions
+      lt = new JLanguageTool(language, motherTongue, null, userConfig);
     } else if (isMultiThread) {
       lt = null;
       mlt = new MultiThreadedJLanguageTool(language, motherTongue, userConfig);

File: languagetool-server/src/test/java/org/languagetool/server/TextCheckerTest.java
Patch:
@@ -121,13 +121,13 @@ public void testInvalidAltLanguages() throws Exception {
       params.put("altLanguages", "en");
       checker.checkText(new AnnotatedTextBuilder().addText("something").build(), new FakeHttpExchange(), params, null, null);
       fail();
-    } catch (IllegalArgumentException ignore) {
+    } catch (BadRequestException ignore) {
     }
     try {
       params.put("altLanguages", "xy");
       checker.checkText(new AnnotatedTextBuilder().addText("something").build(), new FakeHttpExchange(), params, null, null);
       fail();
-    } catch (IllegalArgumentException ignore) {
+    } catch (BadRequestException ignore) {
     }
     
     params.put("language", "en");

File: languagetool-server/src/main/java/org/languagetool/server/DatabaseAccess.java
Patch:
@@ -282,10 +282,10 @@ Long getOrCreateClientId(String client) {
   
   private void validateWord(String word) {
     if (word == null || word.trim().isEmpty()) {
-      throw new IllegalArgumentException("Invalid word, cannot be empty or whitespace only");
+      throw new BadRequestException("Invalid word, cannot be empty or whitespace only");
     }
     if (word.matches(".*\\s.*")) {
-      throw new IllegalArgumentException("Invalid word, you can only words that don't contain spaces: '" + word + "'");
+      throw new BadRequestException("Invalid word, you can only words that don't contain spaces: '" + word + "'");
     }
   }
 

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -256,7 +256,7 @@ protected int getPriorityForId(String id) {
       case "UPPERCASE_SENTENCE_START": return -300;
       case "FRENCH_WHITESPACE_STRICT": return -350; // picky; if on, it should overwrite FRENCH_WHITESPACE
       case "FRENCH_WHITESPACE": return -400; // lesser than UPPERCASE_SENTENCE_START and FR_SPELLING_RULE
-      case "NON_V": return -300;
+      //case "NON_V": return -300;
     }
     if (id.startsWith("grammalecte_")) {
       return -150;

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tagging/fr/FrenchTagger.java
Patch:
@@ -42,11 +42,11 @@ public class FrenchTagger extends BaseTagger {
 
   private static final Pattern VERB = Pattern.compile("V .+");
   private static final Pattern PREFIXES_FOR_VERBS = Pattern.compile(
-      "(auto|auto-|re-)([^-].*[aeiouêàéèíòóïü].+[aeiouêàéèíòóïü].*)", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
+      "(auto|auto-|re-|sur-)([^-].*[aeiouêàéèíòóïü].+[aeiouêàéèíòóïü].*)", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
 
   private static final Pattern NOUN_ADJ = Pattern.compile("[NJ] .+|V ppa.*");
   private static final Pattern PREFIXES_NOUN_ADJ = Pattern.compile(
-      "(mini-|méga-|demi-|péri-|anti-|géo-|nord-|sud-|néo-|méga-|ultra-|pro-|inter-|micro-|macro-|sous-|haut-|auto-|ré-|pré-|super-|vice-|hyper-|proto-|grand-|pseudo-)(.+)",
+      "(sur-|mini-|méga-|demi-|péri-|anti-|géo-|nord-|sud-|néo-|méga-|ultra-|pro-|inter-|micro-|macro-|sous-|haut-|auto-|ré-|pré-|super-|vice-|hyper-|proto-|grand-|pseudo-)(.+)",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
   private static final Pattern PREFIXES_FOR_NOUN_ADJ = Pattern.compile(
       "(mini|méga)([^-].*[aeiouêàéèíòóïü].+[aeiouêàéèíòóïü].*)", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);

File: languagetool-language-modules/el/src/main/java/org/languagetool/language/Greek.java
Patch:
@@ -22,6 +22,7 @@
 import org.jetbrains.annotations.Nullable;
 import org.languagetool.*;
 import org.languagetool.rules.*;
+import org.languagetool.rules.el.GreekWordRepeatBeginningRule;
 import org.languagetool.rules.el.MorfologikGreekSpellerRule;
 import org.languagetool.rules.el.NumeralStressRule;
 import org.languagetool.rules.el.ReplaceHomonymsRule;
@@ -81,7 +82,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
                     Example.wrong("Η τελεία είναι σημείο στίξης. <marker>δείχνει</marker> το τέλος μίας πρότασης."),
                     Example.fixed("Η τελεία είναι σημείο στίξης. <marker>Δείχνει</marker> το τέλος μίας πρότασης.")),
             new MultipleWhitespaceRule(messages, this),
-            new WordRepeatBeginningRule(messages, this),
+            new GreekWordRepeatBeginningRule(messages, this),
             new WordRepeatRule(messages, this),
             new ReplaceHomonymsRule(messages, this),
             new NumeralStressRule(messages)

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/PortugueseTest.java
Patch:
@@ -35,7 +35,7 @@ public void testLanguage() throws IOException {
     testDemoText(lang, s,
       Arrays.asList("POSSESSIVE_WITHOUT_ARTICLE", "SPACE_AFTER_PUNCTUATION", "GENERAL_GENDER_AGREEMENT_ERRORS", "AFIM_DE", "PORTUGUESE_WORD_REPEAT_RULE",
               "PT_AGREEMENT_REPLACE", "TAL_VEZ", "GENERAL_NUMBER_AGREEMENT_ERRORS", "GENERAL_VERB_AGREEMENT_ERRORS", "UPPERCASE_SENTENCE_START", 
-              "HUNSPELL_RULE", "UNPAIRED_BRACKETS", "DOUBLE_PUNCTUATION", "PHRASE_REPETITION", "ARTICLES_PRECEDING_LOCATIONS", //"REPEATED_WORDS",
+              "HUNSPELL_RULE", "UNPAIRED_BRACKETS", "DOUBLE_PUNCTUATION", "PHRASE_REPETITION", "GENTILICOS_LINGUAS", "GENTILICOS_LINGUAS", "ARTICLES_PRECEDING_LOCATIONS", //"REPEATED_WORDS",
               "PARONYM_ANALISE_363", "DOUBLE_PUNCTUATION", "POSSESSIVE_WITHOUT_ARTICLE", "EQUIPES", "DATE_WEEKDAY")
     );
     runTests(lang, null, "õș");

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/BrazilianPortugueseReplaceRule.java
Patch:
@@ -69,12 +69,12 @@ public String getDescription() {
 
   @Override
   public String getShort() {
-    return "Palavra de Português de Portugal";
+    return "Palavra de português de Portugal";
   }
 
   @Override
   public String getMessage() {
-    return "'$match' é uma expressão de Portugal, em Português do Brasil utiliza-se: $suggestions";
+    return "'$match' é uma expressão de Portugal, em português do Brasil utiliza-se: $suggestions";
   }
 
   @Override

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugalPortugueseReplaceRule.java
Patch:
@@ -69,12 +69,12 @@ public String getDescription() {
 
   @Override
   public String getShort() {
-    return "Palavra de Português do Brasil";
+    return "Palavra de português do Brasil";
   }
 
   @Override
   public String getMessage() {
-    return "'$match' é uma expressão brasileira, em Português de Portugal utiliza-se: $suggestions";
+    return "'$match' é uma expressão brasileira, em português de Portugal utiliza-se: $suggestions";
   }
 
   @Override

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -76,8 +76,9 @@ public class VerbAgreementRule extends TextLevelRule {
     ),
     Arrays.asList(
       // "Dallun sagte nur, dass er gleich kommen wird und legte wieder auf."
+      // "Sie fragte, ob er bereit für die zweite Runde ist."
       token("er"),
-      token("gleich")  // ist hier kein Verb
+      tokenRegex("gleich|bereit")  // ist hier kein Verb
     ),
     Arrays.asList(
       // "Bringst nicht einmal so etwas Einfaches zustande!"

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tokenizers/fr/FrenchWordTokenizer.java
Patch:
@@ -71,14 +71,14 @@ public class FrenchWordTokenizer extends WordTokenizer {
   
   private static final List<String> doNotSplit = Arrays.asList("mers-cov", "mcgraw-hill", "sars-cov-2", "sars-cov",
       "ph-metre", "ph-metres", "anti-ivg", "anti-uv", "anti-vih", "al-qaïda", "c'est-à-dire", "add-on", "add-ons",
-      "rendez-vous", "garde-à-vous", "chez-eux", "chez-moi", "chez-nous", "chez-soi", "chez-toi", "chez-vous");
+      "rendez-vous", "garde-à-vous", "chez-eux", "chez-moi", "chez-nous", "chez-soi", "chez-toi", "chez-vous", "m'as-tu-vu");
 
   public FrenchWordTokenizer() {
     
     tagger = new FrenchTagger();
 
     // words not to be split
-    patterns[0] = Pattern.compile("^(c'est-à-dire|add-on|add-ons|rendez-vous|garde-à-vous|chez-eux|chez-moi|chez-nous|chez-soi|chez-toi|chez-vous)$", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
+    patterns[0] = Pattern.compile("^(m'as-tu-vu|c'est-à-dire|add-on|add-ons|rendez-vous|garde-à-vous|chez-eux|chez-moi|chez-nous|chez-soi|chez-toi|chez-vous)$", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
     patterns[1] = Pattern.compile(
         "^(c['’]|j['’]|n['’]|m['’]|t['’]|s['’]|l['’]|d['’]|qu['’]|jusqu['’]|lorsqu['’]|puisqu['’]|quoiqu['’])([^\\-]*)(-ce|-elle|-t-elle|-elles|-t-elles|-en|-il|-t-il|-ils|-t-ils|-je|-la|-le|-les|-leur|-lui|-moi|-nous|-on|-t-on|-toi|-tu|-vous|-vs|-y)$",
         Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/RuleMatchDiffFinder.java
Patch:
@@ -320,7 +320,7 @@ private void printTableBegin(FileWriter fw) throws IOException {
     fw.write("<table class='sortable_table'>\n");
     fw.write("<thead>\n");
     fw.write("<tr>\n");
-    fw.write("  <th>Change</th>\n");
+    fw.write("  <th style='width:60px'>Change</th>\n");
     fw.write("  <th>File</th>\n");
     fw.write("  <th class='small'>Rule ID</th>\n");
     fw.write("  <th>Message and Text</th>\n");
@@ -475,7 +475,6 @@ private void printFooter(FileWriter fw) throws IOException {
     fw.write("<script>\n" +
       "var tf = new TableFilter(document.querySelector('.sortable_table'), {\n" +
       "    base_path: 'https://unpkg.com/tablefilter@0.7.0/dist/tablefilter/',\n" +
-      "    col_0: 'select',\n" +
       "    col_1: 'select',\n" +
       "    auto_filter: { delay: 100 },\n" +
       "    grid_layout: false,\n" +

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -298,6 +298,7 @@ protected int getPriorityForId(String id) {
       // Rule ids:
       case "OLD_SPELLING_INTERNAL": return 10;
       case "DE_COMPOUNDS": return 10;
+      case "EMAIL": return 1;  // better suggestion than SIMPLE_AGREEMENT_*
       case "ROCK_N_ROLL": return 1;  // better error than DE_CASE
       case "RESOURCE_RESSOURCE": return 1;  // better error than DE_CASE
       case "DE_PROHIBITED_COMPOUNDS": return 1;  // a more detailed error message than from spell checker

File: languagetool-language-modules/fr/src/test/java/org/languagetool/rules/fr/MorfologikFrenchSpellerRuleTest.java
Patch:
@@ -43,6 +43,7 @@ public void testMorfologikSpeller() throws IOException {
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Écoute-moi.")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("35%")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("20$")).length);
+    assertEquals(0, rule.match(lt.getAnalyzedSentence("4x4")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("300 000 yen")).length);   
     assertEquals(0, rule.match(lt.getAnalyzedSentence("20°C")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("même s'il coûte 10.000 yens")).length);

File: languagetool-core/src/main/java/org/languagetool/Language.java
Patch:
@@ -845,7 +845,7 @@ public String toAdvancedTypography(String input) {
       output= output.replaceFirst("\\\\" + String.valueOf(i), getOpeningDoubleQuote() + preservedStrings.get(i) + getClosingDoubleQuote() );
     }
     
-    return output;
+    return output.replaceAll("<suggestion>", getOpeningDoubleQuote()).replaceAll("</suggestion>", getClosingDoubleQuote());
   }
 
   /**

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleMatcher.java
Patch:
@@ -194,6 +194,9 @@ private boolean matchPreservesCase(List<Match> suggestionMatches, String msg) {
     if (suggestionMatches != null && !suggestionMatches.isEmpty()) {
       //PatternRule rule = (PatternRule) this.rule;
       int sugStart = msg.indexOf(SUGGESTION_START_TAG) + SUGGESTION_START_TAG.length();
+      if (msg.contains(PatternRuleHandler.PLEASE_SPELL_ME)) {
+        sugStart += PatternRuleHandler.PLEASE_SPELL_ME.length();
+      }
       for (Match sMatch : suggestionMatches) {
         if (!sMatch.isInMessageOnly() && sMatch.convertsCase()
             && msg.charAt(sugStart) == '\\') {

File: languagetool-core/src/main/java/org/languagetool/Language.java
Patch:
@@ -811,9 +811,11 @@ public String toAdvancedTypography(String input) {
     if (output.endsWith("'")) { 
       output = output.substring(0, output.length() - 1 ) + getClosingSingleQuote();
     }
+    output = output.replaceAll(" '(.)'", " " + getOpeningSingleQuote()+"$1"+getClosingSingleQuote()); //exception single character
     output = output.replaceAll("([\\u202f\\u00a0 «\"\\(])'", "$1" + getOpeningSingleQuote());
     output = output.replaceAll("'([\u202f\u00a0 !\\?,\\.;:\"\\)])", getClosingSingleQuote() + "$1");
-
+    output = output.replaceAll("‘s\\b", "’s"); // exception genitive
+    
     // double quotes
     if (output.startsWith("\"")) { 
       output = output.replaceFirst("\"", getOpeningDoubleQuote());

File: languagetool-language-modules/de/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -82,5 +82,8 @@ public void testAdvancedTypography() {
     assertEquals(lang.toAdvancedTypography("z.B."), "z.\u00a0B.");
     assertEquals(lang.toAdvancedTypography("i.d.R."), "i.\u00a0d.\u00a0R.");
     assertEquals(lang.toAdvancedTypography("i. d. R."), "i.\u00a0d.\u00a0R."); 
+    
+    assertEquals(lang.toAdvancedTypography("Zeichen ohne sein Gegenstück: '\"' scheint zu fehlen"), "Zeichen ohne sein Gegenstück: ‚\"‘ scheint zu fehlen");
+    
   }
 }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -132,6 +132,7 @@ public void testWrongVerb() throws IOException {
     assertGood("❌Du fühlst Dich unsicher?");
     assertGood("Bekommst sogar eine Sicherheitszulage");
     assertGood("Bringst nicht einmal so etwas Einfaches zustande!");
+    assertGood("Dallun sagte nur, dass er gleich kommen wird und legte wieder auf.");
     // incorrect sentences:
     assertBad("Als Borcarbid weißt es eine hohe Härte auf.");
     assertBad("Das greift auf Vorläuferinstitutionen bist auf die Zeit von 1234 zurück.");

File: languagetool-language-modules/fr/src/test/java/org/languagetool/tagging/fr/FrenchTaggerTest.java
Patch:
@@ -74,6 +74,8 @@ public void testTagger() throws IOException {
     TestTools.myAssert("va-t'en", "va/[aller]V imp pres 2 s|va/[aller]V ind pres 3 s -- -t/[te]R pers obj 2 s -- 'en/[en]R pers obj 3 sp", tokenizer, tagger);
         
     TestTools.myAssert("Al-Qaïda","Al-Qaïda/[Al-Qaïda]Z f sp", tokenizer, tagger);
+    
+    TestTools.myAssert("minitélévision","minitélévision/[minitélévision]N f s", tokenizer, tagger);
   }
 
 }

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugalPortugueseReplaceRule.java
Patch:
@@ -69,7 +69,7 @@ public String getDescription() {
 
   @Override
   public String getShort() {
-    return "Palavra brasileira";
+    return "Palavra de Português do Brasil";
   }
 
   @Override

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/BrazilianPortugueseReplaceRule.java
Patch:
@@ -69,7 +69,7 @@ public String getDescription() {
 
   @Override
   public String getShort() {
-    return "Palavra de Português do Brasil";
+    return "Palavra de Português de Portugal";
   }
 
   @Override

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tagging/fr/FrenchTagger.java
Patch:
@@ -43,7 +43,7 @@ public class FrenchTagger extends BaseTagger {
   private static final Pattern PREFIXES_FOR_VERBS = Pattern.compile("(auto|auto-|re-)([^-].*[aeiouêàéèíòóïü].+[aeiouêàéèíòóïü].*)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
 
   private static final Pattern NOUN_ADJ = Pattern.compile("[NJ] .+|V ppa.*");
-  private static final Pattern PREFIXES_NOUN_ADJ = Pattern.compile("(péri-|anti-|géo-|nord-|sud-|néo-|méga-|ultra-|pro-|inter-|micro-|macro-|sous-|haut-|auto-|ré-|pré-|super-|vice-|hyper-|proto-|grand-|pseudo-)(.+)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
+  private static final Pattern PREFIXES_NOUN_ADJ = Pattern.compile("(demi-|péri-|anti-|géo-|nord-|sud-|néo-|méga-|ultra-|pro-|inter-|micro-|macro-|sous-|haut-|auto-|ré-|pré-|super-|vice-|hyper-|proto-|grand-|pseudo-)(.+)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   //|nord-|sud-
   
   public FrenchTagger() {

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -221,6 +221,8 @@ public GermanCompoundTokenizer(boolean strictMode) throws IOException {
     wordSplitter.addException("Schwimmerbereiche", asList("Schwimmer", "bereiche"));
     wordSplitter.addException("Schwimmerbereichen", asList("Schwimmer", "bereichen"));
     wordSplitter.addException("Schwimmerbereichs", asList("Schwimmer", "bereichs"));
+    wordSplitter.addException("Onlinestore", asList("Online", "store"));
+    wordSplitter.addException("Onlinestores", asList("Online", "stores"));
     wordSplitter.setStrictMode(strictMode);
     wordSplitter.setMinimumWordLength(3);
   }

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -305,7 +305,7 @@ protected boolean ignoreWord(String word) throws IOException {
     return isIgnoredNoCase(word);
   }
 
-  private boolean isIgnoredNoCase(String word) {
+  protected boolean isIgnoredNoCase(String word) {
     return wordsToBeIgnored.contains(word) ||
            (convertsCase && wordsToBeIgnored.contains(word.toLowerCase(language.getLocale()))) ||
            (ignoreWordsWithLength > 0 && word.length() <= ignoreWordsWithLength);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -573,6 +573,9 @@ public void testDashAndHyphenEtc() throws Exception {
     assertEquals(0, rule.match(lt.getAnalyzedSentence("- Ablenkungsfreies")).length);
     assertEquals(1, rule.match(lt.getAnalyzedSentence("abmantelung")).length);  // only as uppercase in spelling.txt
     assertEquals(1, rule.match(lt.getAnalyzedSentence("- abmantelung")).length);
+    assertEquals(1, rule.match(lt.getAnalyzedSentence("machtS")).length);
+    assertEquals(1, rule.match(lt.getAnalyzedSentence("All-Inclusive-Preis")).length);
+    assertEquals(1, rule.match(lt.getAnalyzedSentence("dRanging")).length);
 
     // originally from spelling.txt:
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Wichtelmännchen")).length);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MessageHandler.java
Patch:
@@ -201,6 +201,7 @@ public void run() {
       JOptionPane pane = new JOptionPane(text, JOptionPane.INFORMATION_MESSAGE);
       dialog = pane.createDialog(null, UIManager.getString("OptionPane.messageDialogTitle", null));
       dialog.setModal(false);
+      dialog.setAlwaysOnTop(true);
       dialog.addWindowFocusListener(new WindowFocusListener() {
         @Override
         public void windowGainedFocus(WindowEvent e) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -597,6 +597,8 @@ public void testDashAndHyphenEtc() throws Exception {
 
     // bullet points in Google Docs:
     assertEquals(0, rule.match(lt.getAnalyzedSentence("\uFEFFAblenkungsfreie Schreibumgebung")).length);
+    
+    assertEquals(0, rule.match(lt.getAnalyzedSentence("Die blablaxx.mp3 und das sdifguds.avi bzw. die XYZXYZ.AVI")).length);
   }
 
   @Test

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -189,7 +189,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
           }
           String cleanWord = word.endsWith(".") ? word.substring(0, word.length() - 1) : word;
           if (word.startsWith("-")) {
-            if (!isMisspelled(cleanWord.substring(1))) {
+            if (!isMisspelled(cleanWord.substring(1)) || cleanWord.matches("-+")) {
               len += word.length() + 1;
               continue;
             } else {

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/RussianVerbConjugationRule.java
Patch:
@@ -41,7 +41,7 @@ public class RussianVerbConjugationRule extends Rule {
     private static final Pattern PRONOUN = Pattern.compile("PNN:(.*):Nom:(.*)");
     private static final Pattern FUT_REAL_VERB = Pattern.compile("VB:(Fut|Real):(.*):(.*):(.*):(.*)");
     private static final Pattern PAST_VERB = Pattern.compile("VB:Past:(.*):(.*):(.*)");
-
+    
     public RussianVerbConjugationRule(ResourceBundle messages) {
         super(messages);
         super.setCategory(Categories.GRAMMAR.getCategory(messages));
@@ -85,9 +85,9 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
                     } else  {
                             next2Token = "";
                             }
-                    
+                    String nextToken = nextLemmaTok.getToken();
                     String nextPosTag = nextLemmaTok.getPOSTag();
-                    if(nextPosTag != null && !(nextPosTag.isEmpty()) && !(next2Token.equals("быть")) ) {  //  "может быть"
+                    if(nextPosTag != null && !(nextPosTag.isEmpty()) && !(next2Token.equals("быть")) && !(nextToken.equals("целую")) ) {  //  "может быть"
                         Matcher verbMatcher = FUT_REAL_VERB.matcher(nextPosTag);
                         if (verbMatcher.find()) {
                             Pair<String, String> verbPair = new ImmutablePair<>(verbMatcher.group(4), verbMatcher.group(5));

File: languagetool-language-modules/fr/src/test/java/org/languagetool/tagging/fr/FrenchTaggerTest.java
Patch:
@@ -62,9 +62,9 @@ public void testTagger() throws IOException {
     TestTools.myAssert("auto-équilibrage","auto-équilibrage/[auto-équilibrage]N m s", tokenizer, tagger);
     TestTools.myAssert("Grand-Chambre","Grand-Chambre/[grand-chambre]N f s", tokenizer, tagger);
     
-    TestTools.myAssert("d’aujourd’hui","d'/[de]D e s|d'/[de]P -- aujourd'hui/[aujourd'hui]A", tokenizer, tagger);
-    TestTools.myAssert("d'aujourd’hui","d'/[de]D e s|d'/[de]P -- aujourd'hui/[aujourd'hui]A", tokenizer, tagger);
-    TestTools.myAssert("d’aujourd'hui","d'/[de]D e s|d'/[de]P -- aujourd'hui/[aujourd'hui]A", tokenizer, tagger);
+    TestTools.myAssert("d’aujourd’hui","d'/[de]D e sp|d'/[de]P -- aujourd'hui/[aujourd'hui]A", tokenizer, tagger);
+    TestTools.myAssert("d'aujourd’hui","d'/[de]D e sp|d'/[de]P -- aujourd'hui/[aujourd'hui]A", tokenizer, tagger);
+    TestTools.myAssert("d’aujourd'hui","d'/[de]D e sp|d'/[de]P -- aujourd'hui/[aujourd'hui]A", tokenizer, tagger);
     TestTools.myAssert("Fontaine-l’Évêque","Fontaine-l'Évêque/[Fontaine-l'Évêque]Z e sp", tokenizer, tagger);
     TestTools.myAssert("Fontaine-l'Évêque","Fontaine-l'Évêque/[Fontaine-l'Évêque]Z e sp", tokenizer, tagger);
     TestTools.myAssert("entr'ouvrions","entr'ouvrions/[entr'ouvrir]V ind impa 1 p|entr'ouvrions/[entr'ouvrir]V sub pres 1 p", tokenizer, tagger);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -113,11 +113,11 @@ public void testGetAdditionalTopSuggestions() throws Exception {
     assertThat(rule.match(lt.getAnalyzedSentence("konservierungsstoffstatistik"))[0].getSuggestedReplacements().toString(), is("[Konservierungsstoffstatistik]"));
     assertThat(rule.match(lt.getAnalyzedSentence("konservierungsstoffsasdsasda"))[0].getSuggestedReplacements().size(), is(0));
     assertThat(rule.match(lt.getAnalyzedSentence("Ventrolateral")).length, is(0));
+    assertThat(rule.match(lt.getAnalyzedSentence("haben -sehr")).length, is(0));
     assertThat(rule.match(lt.getAnalyzedSentence("Kleindung")).length, is(1));  // ignored due to ignoreCompoundWithIgnoredWord(), but still in ignore.txt -> ignore.txt must override this
     assertThat(rule.match(lt.getAnalyzedSentence("Majonäse."))[0].getSuggestedReplacements().toString(), is("[Mayonnaise]"));
     assertFirstSuggestion("Schöler-", "Schüler-", rule, lt);
     assertFirstSuggestion("wars.", "war's", rule, lt);
-    assertFirstSuggestion("haben -sehr", "sehr", rule, lt);
     assertFirstSuggestion("konservierungsstoffe", "Konservierungsstoffe", rule, lt);
 //    assertFirstSuggestion("Ist Ventrolateral", "ventrolateral", rule, lt);
     assertFirstSuggestion("denkte", "dachte", rule, lt);
@@ -511,7 +511,7 @@ public void testDashAndHyphenEtc() throws Exception {
     JLanguageTool lt = new JLanguageTool(GERMAN_DE);
 
     // "-" as bullet point with no space:
-    /*assertEquals(0, lt.check("-Tee\n\n-Kaffee").size());
+    assertEquals(0, lt.check("-Tee\n\n-Kaffee").size());
     List<RuleMatch> matches1 = lt.check("-Teex\n\n-Kaffee");
     assertEquals(1, matches1.size());
     assertEquals(1, matches1.get(0).getFromPos());
@@ -520,7 +520,6 @@ public void testDashAndHyphenEtc() throws Exception {
     assertEquals(1, matches2.size());
     assertEquals(2, matches2.get(0).getFromPos());
     assertEquals(6, matches2.get(0).getToPos());
-    */
     
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Ist doch - gut")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Ist doch -- gut")).length);

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -246,6 +246,7 @@ protected int getPriorityForId(String id) {
       //case "ACCORD_COULEUR": return 1; // needs to have higher priority than agreement postponed adj
       case "CONFUSION_PAR_PART": return -1;  // turn off completely when PART_OU_PAR is activated
       case "FR_SIMPLE_REPLACE": return -10;
+      case "IMP_PRON": return -10; // less than D_N
       case "TOO_LONG_PARAGRAPH": return -15;
       case "VERB_PRONOUN": return -50; // greater than FR_SPELLING_RULE; less than ACCORD_V_QUESTION
       case "AGREEMENT_POSTPONED_ADJ": return -50;

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -511,7 +511,7 @@ public void testDashAndHyphen() throws Exception {
     JLanguageTool lt = new JLanguageTool(GERMAN_DE);
 
     // "-" as bullet point with no space:
-    assertEquals(0, lt.check("-Tee\n\n-Kaffee").size());
+    /*assertEquals(0, lt.check("-Tee\n\n-Kaffee").size());
     List<RuleMatch> matches1 = lt.check("-Teex\n\n-Kaffee");
     assertEquals(1, matches1.size());
     assertEquals(1, matches1.get(0).getFromPos());
@@ -520,6 +520,7 @@ public void testDashAndHyphen() throws Exception {
     assertEquals(1, matches2.size());
     assertEquals(2, matches2.get(0).getFromPos());
     assertEquals(6, matches2.get(0).getToPos());
+    */
     
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Ist doch - gut")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Ist doch -- gut")).length);

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/HunspellRuleTest.java
Patch:
@@ -53,5 +53,7 @@ public void testRule() throws Exception {
     matches = rule.match(langTool.getAnalyzedSentence("é so")); 
     assertEquals(1, matches.length);
     assertEquals("só", matches[0].getSuggestedReplacements().get(0));
+
+    langTool.check("- Encontre no autoconheciemen");  // No "Could not map 29 to original position." issue
   }
 }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/CheckRequestAnalysis.java
Patch:
@@ -143,6 +143,9 @@ DocumentCache actualizeDocumentCache (int nPara) {
       }
     }
     XFlatParagraph xFlatPara = flatPara.getFlatParagraphAt(nPara);
+    if (xFlatPara == null) {
+      return null;
+    }
     String chPara = xFlatPara.getText();
     Locale docLocale = docLanguage == null ? null : LinguisticServices.getLocale(docLanguage);
     Locale lastLocale = nPara <= 0 ? null : docCache.getFlatParagraphLocale(nPara - 1);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/FlatParagraphTools.java
Patch:
@@ -148,7 +148,7 @@ public XFlatParagraph getFlatParagraphAt (int nPara) {
       XFlatParagraph xFlatPara = getLastFlatParagraph();
       if (xFlatPara == null) {
         if (debugMode) {
-          MessageHandler.printToLogFile("setLanguageOfParagraph: FlatParagraph == null");
+          MessageHandler.printToLogFile("getFlatParagraphAt: FlatParagraph == null");
         }
         return null;
       }
@@ -163,7 +163,7 @@ public XFlatParagraph getFlatParagraphAt (int nPara) {
         num++;
       }
       if (xFlatPara == null) {
-        MessageHandler.printToLogFile("setLanguageOfParagraph: FlatParagraph == null; n = " + num + "; nPara = " + nPara);
+        MessageHandler.printToLogFile("getFlatParagraphAt: FlatParagraph == null; n = " + num + "; nPara = " + nPara);
         return null;
       }
       return xFlatPara;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -160,7 +160,8 @@ private DocumentCache updateDocumentCache(int nPara, XComponent xComponent, Docu
         flatPara.init();
       }
       Configuration config = documents.getConfiguration();
-      docCache = new DocumentCache(docCursor, flatPara, -1, config == null ? null : LinguisticServices.getLocale(config.getDefaultLanguage()));
+      docCache = new DocumentCache(docCursor, flatPara, -1, 
+          (config == null || config.getDefaultLanguage() == null) ? null : LinguisticServices.getLocale(config.getDefaultLanguage()));
     }
     return docCache;
   }
@@ -213,7 +214,7 @@ public void nextError() {
       x = 0;
       yFlat++;
     }
-    MessageHandler.showMessage(messages.getString("guiCheckComplete"), false);
+    MessageHandler.showClosingInformationDialog(messages.getString("guiCheckComplete"));
   }
 
   /**

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -238,13 +238,14 @@ protected int getPriorityForId(String id) {
       case "ESPACE_UNITES": return 1; // needs to have higher priority than spell checker
       case "BYTES": return 1; // needs to be higher than spell checker for 10MB style matches
       case "Y_A": return 1; // needs to be higher than spell checker for style suggestion
-      case "A_A_ACCENT": return 1; // triggers false alarms for IL_FAUT_INF if there is no a/à correction
+      case "A_A_ACCENT": return 1; // triggers false alarms for IL_FAUT_INF if there is no a/à correction 
       case "JE_M_APPEL": return 1;  // override NON_V
       case "ACCORD_R_PERS_VERBE": return 1;  // match before POSER_UNE_QUESTION
       case "JE_SUI": return 1;  // needs higher priority than spell checker
       //case "D_N": return 1; // needs to have higher priority than agreement postponed adj | Commented out because many other rules should be higher
       //case "ACCORD_COULEUR": return 1; // needs to have higher priority than agreement postponed adj
       case "CONFUSION_PAR_PART": return -1;  // turn off completely when PART_OU_PAR is activated
+      case "FR_SIMPLE_REPLACE": return -10;
       case "TOO_LONG_PARAGRAPH": return -15;
       case "VERB_PRONOUN": return -50; // greater than FR_SPELLING_RULE; less than ACCORD_V_QUESTION
       case "AGREEMENT_POSTPONED_ADJ": return -50;

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/PostponedAdjectiveConcordanceFilter.java
Patch:
@@ -111,7 +111,7 @@ public class PostponedAdjectiveConcordanceFilter extends RuleFilter {
   private static final Pattern COORDINACIO_IONI = Pattern.compile("et|ou|ni");
   private static final Pattern KEEP_COUNT = Pattern.compile("Y|J .*|N .*|D .*|P.*|V ppa .*|M nonfin|UNKNOWN|Z.*|V.* inf");
   private static final Pattern KEEP_COUNT2 = Pattern.compile(",|et|ou|ni"); // |\\d+%?|%
-  private static final Pattern STOP_COUNT = Pattern.compile(";");
+  private static final Pattern STOP_COUNT = Pattern.compile("[;:\\(\\)\\[\\]–—―‒]");
   private static final Pattern PREPOSICIONS = Pattern.compile("P");
   private static final Pattern PREPOSICIO_CANVI_NIVELL = Pattern.compile("d'|de|des|du|à|au|aux|en|dans|sur|entre|par|pour|avec|sans|contre|comme"); //???
   private static final Pattern VERB = Pattern.compile("V.* (inf|ind|sub|con|ppr|imp).*"); // Any verb that is not V ppa

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -475,6 +475,8 @@ public void testDetNounRule() throws IOException {
     assertBad("Er stieg durchs Fensters.");
     assertBad("Ich habe heute ein Krankenwagen gesehen.");
     assertGood("Sie werden merken, dass das echte Nutzer sind.");
+    assertGood("Dieses neue Mac OS trug den Codenamen Rhapsody.");
+    assertGood("Das Mac OS is besser als Windows.");
     // TODO: not yet detected:
     //assertBad("Erst recht wir fleißiges Arbeiter.");
     //assertBad("Erst recht ich fleißiges Arbeiter.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -180,6 +180,7 @@ public void testRule() throws IOException {
     assertGood("Unser Wärmestrom-Tarif WärmeKompakt im Detail");  // ignore so we don't suggest "wärmeKompakt" (#3779)
     assertGood("Autohaus Dornig GmbH");
     assertGood("Hans Pries GmbH");
+    assertGood(":D Auf dieses Frl.");
     assertGood("Das Gedicht “Der Panther”.");  // quotes are not correct, but leave that to the quotes rule
 
     // https://github.com/languagetool-org/languagetool/issues/1515:

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanWordRepeatRule.java
Patch:
@@ -225,7 +225,7 @@ public class GermanWordRepeatRule extends WordRepeatRule {
     Arrays.asList(// "Alle die die"
       tokenRegex("alle|nur|obwohl|lediglich|für|zwar|aber"),
       new PatternTokenBuilder().csToken("die").build(),
-      new PatternTokenBuilder().csToken("die").build(),
+      new PatternTokenBuilder().csToken("die").build()
     ),
     Arrays.asList(// "Das Haus, in das das Kind läuft."
       csToken(","),

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/PostponedAdjectiveConcordanceFilter.java
Patch:
@@ -127,7 +127,7 @@ public class PostponedAdjectiveConcordanceFilter extends RuleFilter {
   public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments, int patternTokenPos,
       AnalyzedTokenReadings[] patternTokens) throws IOException {
     
-//    if (match.getSentence().getText().toString().contains("atlas chers")) {
+//    if (match.getSentence().getText().toString().contains("le bus")) {
 //      int i=0;
 //      i++;
 //    }

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractStatisticStyleRule.java
Patch:
@@ -51,8 +51,8 @@ public abstract class AbstractStatisticStyleRule extends TextLevelRule {
   /**
    * Condition to generate a hint (possibly including all exceptions)
    * Returns:
-   *  < nAnalysedToken, if condition is not fulfilled
-   *  >= nAnalysedToken, if condition is not fulfilled; integer is number of token which is the end hint 
+   *  &lt; nAnalysedToken, if condition is not fulfilled
+   *  &gt;= nAnalysedToken, if condition is not fulfilled; integer is number of token which is the end hint 
    */
   protected abstract int conditionFulfilled(AnalyzedTokenReadings[] tokens, int nAnalysedToken);
   

File: languagetool-core/src/main/java/org/languagetool/rules/GRPCRule.java
Patch:
@@ -55,7 +55,7 @@
  * Base class fur rules running on external servers;
  * see gRPC service definition in languagetool-core/src/main/proto/ml_server.proto
  *
- * @see #create(ResourceBundle, RemoteRuleConfig, boolean, String, String, Map)  for an easy to add rules; return rule in Language::getRelevantRemoteRules
+ * @see #create(Language, ResourceBundle, RemoteRuleConfig, boolean, String, String, Map)  for an easy to add rules; return rule in Language::getRelevantRemoteRules
  * add it like this:
   <pre>
    public List&lt;Rule&gt; getRelevantRemoteRules(ResourceBundle messageBundle, List&lt;RemoteRuleConfig&gt; configs, GlobalConfig globalConfig, UserConfig userConfig, Language motherTongue, List&lt;Language&gt; altLanguages) throws IOException {

File: languagetool-core/src/main/java/org/languagetool/rules/RemoteRule.java
Patch:
@@ -96,7 +96,7 @@ protected class RemoteRequest {}
 
   /**
    * @param request returned by prepareRequest
-   * @param timeoutMilliseconds timeout for this operation, <=0 -> unlimited
+   * @param timeoutMilliseconds timeout for this operation, &lt;=0 -&gt; unlimited
    * @return callable that sends request, parses and returns result for this remote rule
    * @throws TimeoutException if timeout was exceeded
    */

File: languagetool-language-modules/en/src/main/java/org/languagetool/tokenizers/en/EnglishWordTokenizer.java
Patch:
@@ -66,7 +66,6 @@ public String getTokenizingCharacters() {
    * </ol>
    * 
    * @param text String of words to tokenize.
-   * @throws IOException
    */
   @Override
   public List<String> tokenize(String text) {

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java
Patch:
@@ -382,6 +382,8 @@ protected static Map<String, List<String>> getTopSuggestions() {
     s.put("Approvement", Arrays.asList("Approval"));
     s.put("approvements", Arrays.asList("approvals"));
     s.put("Approvements", Arrays.asList("Approvals"));
+    s.put("ciggarets", Arrays.asList("cigarettes"));
+    s.put("Ciggarets", Arrays.asList("Cigarettes"));
     s.put("pro-bono", Arrays.asList("pro bono"));
     s.put("Pro-bono", Arrays.asList("Pro bono"));
     s.put("probono", Arrays.asList("pro bono"));

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -227,6 +227,7 @@ public LanguageMaintainedState getMaintainedState() {
   protected int getPriorityForId(String id) {
     switch (id) { 
       case "AGREEMENT_EXCEPTIONS": return 10; // greater than D_N
+      case "EXPRESSIONS_VU": return 10; // greater than A_ACCENT_A
       case "SA_CA": return 10; // greater than D_N
       case "MA": return 10; // greater than D_J
       case "A_INFINITIF": return 10;

File: languagetool-core/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -122,6 +122,7 @@ public class WordListValidatorTest {
           "celebrytę", // for PL
           "antybiotykoterapię", // for PL
           "kryptowalutę", // for PL
+          "fotowoltaikę", // for PL
           "insulinooporność", // for PL
           "infografikę", // for PL
           "dtª",  // for PT

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tokenizers/fr/FrenchWordTokenizer.java
Patch:
@@ -74,7 +74,7 @@ public FrenchWordTokenizer() {
     tagger = new FrenchTagger();
 
     // words not to be split
-    patterns[0] = Pattern.compile("^(add-on|add-ons|rendez-vous|garde-à-vous|chez-eux|chez-moi|chez-nous|chez-soi|chez-toi|chez-vous)$", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
+    patterns[0] = Pattern.compile("^(c'est-à-dire|add-on|add-ons|rendez-vous|garde-à-vous|chez-eux|chez-moi|chez-nous|chez-soi|chez-toi|chez-vous)$", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
     patterns[1] = Pattern.compile(
         "^(c['’]|j['’]|n['’]|m['’]|t['’]|s['’]|l['’]|d['’]|qu['’]|jusqu['’]|lorsqu['’]|puisqu['’]|quoiqu['’])([^\\-]*)(-ce|-elle|-t-elle|-elles|-t-elles|-en|-il|-t-il|-ils|-t-ils|-je|-la|-le|-les|-leur|-lui|-moi|-nous|-on|-t-on|-toi|-tu|-vous|-vs|-y)$",
         Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -70,7 +70,7 @@ public class HunspellRule extends SpellingCheckRule {
   private static final boolean monitorRules = System.getProperty("monitorActiveRules") != null;
 
   //300 most common Portuguese words. They are used to avoid wrong split suggestions
-  private final List<String> commonPortugueseWords = Arrays.asList("de", "e", "a", "o", "da", "do", "em", "que", "uma", "um", "com", "no", "se", "na", "para", "por", "os", "foi", "como", "dos", "as", "ao", "mais", "sua", "das", "não", "ou", "km", "seu", "pela", "ser", "pelo", "são", "também", "anos", "cidade", "entre", "era", "tem", "mas", "habitantes", "nos", "seus", "área", "até", "ele", "onde", "foram", "população", "região", "sobre", "nas", "nome", "parte", "quando", "ano", "aos", "grande", "mesmo", "pode", "primeiro", "segundo", "sendo", "suas", "ainda", "dois", "estado", "está", "família", "já", "muito", "outros", "americano", "depois", "durante", "maior", "primeira", "forma", "apenas", "banda", "densidade", "dia", "então", "município", "norte", "tempo", "após", "duas", "num", "pelos", "qual", "século", "ter", "todos", "três", "vez", "água", "acordo", "cobertos", "comuna", "contra", "ela", "grupo", "principal", "quais", "sem", "tendo", "às", "álbum", "alguns", "assim", "asteróide", "bem", "brasileiro", "cerca", "desde", "este", "localizada", "mundo", "outras", "período", "seguinte", "sido", "vida", "através", "cada", "conhecido", "final", "história", "partir", "país", "pessoas", "sistema", "terra", "teve", "tinha", "época", "administrativa", "censo", "departamento", "dias", "esta", "filme", "francesa", "música", "província", "série", "vezes", "além", "antes", "eles", "eram", "espécie", "governo", "podem", "vários", "censos", "distrito", "estão", "exemplo", "hoje", "início", "jogo", "lhe", "lugar", "muitos", "média", "novo", "numa", "número", "pois", "possui", "sob", "só", "todo", "tornou", "trabalho", "algumas", "devido", "estava", "fez", "filho", "fim", "grandes", "há", "isso", "lado", "local", "morte", "orbital", "outro", "passou", "países", "quatro", "representa", "seja", "sempre", "sul", "várias", "capital", "chamado", "começou", " enquanto", "fazer", "lançado", "meio", "nova", "nível", "pelas", "poder", "presidente", "redor", "rio", "tarde", "todas", "carreira", "casa", "década", "estimada", "guerra", "havia", "livro", "localidades", "maioria", "muitas", "obra", "origem", "pai", "pouco", "principais", "produção", "programa", "qualquer", "raio", "seguintes", "sucesso", "título", "aproximadamente", "caso", "centro", "conhecida", "construção", "desta", "diagrama", "faz", "ilha", "importante", "mar", "melhor", "menos", "mesma", "metros", "mil", "nacional", "populacional", "quase", "rei", "sede", "segunda", "tipo", "toda", "uso", "velocidade", "vizinhança", "volta", "base", "brasileira", "clube", "desenvolvimento", "deste", "diferentes", "diversos", "empresa", "entanto", "futebol", "geral", "junto", "longo", "obras", "outra", "pertencente", "política", "português", "principalmente", "processo", "quem", "seria", "têm", "versão", "TV", "acima", "atual", "bairro", "chamada", "cinco", "conta", "corpo", "dentro", "deve");
+  private final List<String> commonPortugueseWords = Arrays.asList("eu", "ja", "so", "de", "e", "a", "o", "da", "do", "em", "que", "uma", "um", "com", "no", "se", "na", "para", "por", "os", "foi", "como", "dos", "as", "ao", "mais", "sua", "das", "não", "ou", "km", "seu", "pela", "ser", "pelo", "são", "também", "anos", "cidade", "entre", "era", "tem", "mas", "habitantes", "nos", "seus", "área", "até", "ele", "onde", "foram", "população", "região", "sobre", "nas", "nome", "parte", "quando", "ano", "aos", "grande", "mesmo", "pode", "primeiro", "segundo", "sendo", "suas", "ainda", "dois", "estado", "está", "família", "já", "muito", "outros", "americano", "depois", "durante", "maior", "primeira", "forma", "apenas", "banda", "densidade", "dia", "então", "município", "norte", "tempo", "após", "duas", "num", "pelos", "qual", "século", "ter", "todos", "três", "vez", "água", "acordo", "cobertos", "comuna", "contra", "ela", "grupo", "principal", "quais", "sem", "tendo", "às", "álbum", "alguns", "assim", "asteróide", "bem", "brasileiro", "cerca", "desde", "este", "localizada", "mundo", "outras", "período", "seguinte", "sido", "vida", "através", "cada", "conhecido", "final", "história", "partir", "país", "pessoas", "sistema", "terra", "teve", "tinha", "época", "administrativa", "censo", "departamento", "dias", "esta", "filme", "francesa", "música", "província", "série", "vezes", "além", "antes", "eles", "eram", "espécie", "governo", "podem", "vários", "censos", "distrito", "estão", "exemplo", "hoje", "início", "jogo", "lhe", "lugar", "muitos", "média", "novo", "numa", "número", "pois", "possui", "sob", "só", "todo", "tornou", "trabalho", "algumas", "devido", "estava", "fez", "filho", "fim", "grandes", "há", "isso", "lado", "local", "morte", "orbital", "outro", "passou", "países", "quatro", "representa", "seja", "sempre", "sul", "várias", "capital", "chamado", "começou", " enquanto", "fazer", "lançado", "meio", "nova", "nível", "pelas", "poder", "presidente", "redor", "rio", "tarde", "todas", "carreira", "casa", "década", "estimada", "guerra", "havia", "livro", "localidades", "maioria", "muitas", "obra", "origem", "pai", "pouco", "principais", "produção", "programa", "qualquer", "raio", "seguintes", "sucesso", "título", "aproximadamente", "caso", "centro", "conhecida", "construção", "desta", "diagrama", "faz", "ilha", "importante", "mar", "melhor", "menos", "mesma", "metros", "mil", "nacional", "populacional", "quase", "rei", "sede", "segunda", "tipo", "toda", "uso", "velocidade", "vizinhança", "volta", "base", "brasileira", "clube", "desenvolvimento", "deste", "diferentes", "diversos", "empresa", "entanto", "futebol", "geral", "junto", "longo", "obras", "outra", "pertencente", "política", "português", "principalmente", "processo", "quem", "seria", "têm", "versão", "TV", "acima", "atual", "bairro", "chamada", "cinco", "conta", "corpo", "dentro", "deve");
 
   public static Queue<String> getActiveChecks() {
     return activeChecks;
@@ -190,7 +190,8 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
           if (i > 0 && prevStartPos != -1) {
             String prevWord = tokens[i-1];
             boolean ignoreSplitting = false;
-            if (this.language.getShortCode().equals("pt") && commonPortugueseWords.contains(prevWord.toLowerCase())) {
+            if (this.language.getShortCode().equals("pt") && (commonPortugueseWords.contains(prevWord.toLowerCase())
+                || commonPortugueseWords.contains(word.toLowerCase()))) {
               ignoreSplitting = true;
             }
             if (!ignoreSplitting && prevWord.length() > 0) {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -1292,7 +1292,7 @@ public boolean heapLimitIsReached() {
    * Change to single paragraph mode if not
    * return false if heap space is to small 
    */
-  public boolean runHeapSpaceTest() {
+  public boolean isEnoughHeapSpace() {
     if (OfficeTools.isHeapLimitReached()) {
       heapLimitReached = true;
       setConfigValues(config, langTool);
@@ -1312,7 +1312,7 @@ public boolean runHeapSpaceTest() {
   private void testHeapSpace() {
     if (!heapLimitReached && config.getNumParasToCheck() != 0) {
       if (numSinceHeapTest > HEAP_CHECK_INTERVAL) {
-        runHeapSpaceTest();
+        isEnoughHeapSpace();
         numSinceHeapTest = 0;
       } else {
         numSinceHeapTest++;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/TextLevelCheckQueue.java
Patch:
@@ -319,7 +319,7 @@ QueueEntry getNextQueueEntry(int nPara, String docId) {
   private boolean testHeapSpace() {
     if (numSinceHeapTest > HEAP_CHECK_INTERVAL) {
       numSinceHeapTest = 0;
-      if (!multiDocHandler.runHeapSpaceTest()) {
+      if (!multiDocHandler.isEnoughHeapSpace()) {
         return false;
       }
     } else {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanStyleRepeatedWordRule.java
Patch:
@@ -121,9 +121,11 @@ private boolean isFalsePair(String token1, String token2, String equalWord, Stri
   @Override
   protected boolean isPartOfWord(String testTokenText, String tokenText) {
     return (
+          testTokenText.length() > 2 && tokenText.length() > 2 &&
           (testTokenText.startsWith(tokenText) || testTokenText.endsWith(tokenText)
           || tokenText.startsWith(testTokenText) || tokenText.endsWith(testTokenText))
           && (!isFalsePair(testTokenText, tokenText, "lang", "klang"))
+          && (!isFalsePair(testTokenText, tokenText, "Art", "Artefakt"))
           && (testTokenText.length() == tokenText.length() || testTokenText.length() < tokenText.length() - 3
           || testTokenText.length() > tokenText.length() + 3)
           || testTokenText.equals(tokenText + "s") || tokenText.equals(testTokenText + "s")

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -226,6 +226,7 @@ protected int getPriorityForId(String id) {
       case "VOSEO": return -40;
       case "MORFOLOGIK_RULE_ES": return -100;
       case "PHRASE_REPETITION": return -150;
+      case "SPANISH_WORD_REPEAT_RULE": return -150;
       case "UPPERCASE_SENTENCE_START": return -200;
     }
     //STYLE is -50

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -226,6 +226,7 @@ public LanguageMaintainedState getMaintainedState() {
   @Override
   protected int getPriorityForId(String id) {
     switch (id) { 
+      case "AGREEMENT_EXCEPTIONS": return 10; // greater than D_N
       case "SA_CA": return 10; // greater than D_N
       case "A_INFINITIF": return 10;
       case "DU_DU": return 10; // greater than DU_LE

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -134,15 +134,16 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
       String word = token.getAnalyzedToken(0).getToken();
       
       String normalizedWord = StringTools.normalizeNFKC(word);
-      if (word.length() > 1 && !word.equals(normalizedWord) && !normalizedWord.contains(" ")) { 
+      if (word.length() > 1 && !word.equals(normalizedWord) && !normalizedWord.contains(" ")
+          && isMisspelled(speller1, word)) {
         if (!isMisspelled(speller1, normalizedWord)) {
           // The normalized word is a good suggestion
           RuleMatch ruleMatch = new RuleMatch(this, sentence, startPos, startPos + word.length(),
               messages.getString("spelling"), messages.getString("desc_spelling_short"));
           ruleMatch.addSuggestedReplacement(normalizedWord);
           ruleMatches.add(ruleMatch);
         } else {
-          // Try to find suggestions from the normalized word. 
+          // Try to find suggestions from the normalized word.
           List<String> suggestions = speller1.getSuggestions(normalizedWord);
           RuleMatch ruleMatch = new RuleMatch(this, sentence, startPos, startPos + word.length(),
               messages.getString("spelling"), messages.getString("desc_spelling_short"));

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -134,7 +134,8 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
       String word = token.getAnalyzedToken(0).getToken();
       
       String normalizedWord = StringTools.normalizeNFKC(word);
-      if (!word.equals(normalizedWord)) {
+      if (word.length() > 1 && !word.equals(normalizedWord)) {
+        // FIXME: the word length can change and cause errors!! 
         if (!isMisspelled(speller1, normalizedWord)) {
           // The normalized word is a good suggestion
           RuleMatch ruleMatch = new RuleMatch(this, sentence, startPos, startPos + word.length(),

File: languagetool-language-modules/fr/src/test/java/org/languagetool/rules/fr/MorfologikFrenchSpellerRuleTest.java
Patch:
@@ -79,6 +79,7 @@ public void testMorfologikSpeller() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("de Harvard ou d'Harvard")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("d'1")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("l'email")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("À propos de cette chose… ")).length);
         
     // Test for Multiwords.
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("vox populi")).length);

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/HunspellRuleTest.java
Patch:
@@ -39,5 +39,7 @@ public void testRule() throws Exception {
     assertEquals(1, matches.length);
     assertEquals("família", matches[0].getSuggestedReplacements().get(0));
     assertEquals("familiar", matches[0].getSuggestedReplacements().get(1));
+    
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("Covid-19, COVID-19, covid-19.")).length);
   }
 }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ResultCache.java
Patch:
@@ -128,7 +128,7 @@ SingleProofreadingError[] getMatches(int numberOfParagraph) {
     if (entry == null) {
       return null;
     }
-    return entries.get(numberOfParagraph).getErrorArray();
+    return entry.getErrorArray();
   }
 
   /**

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/QuestionWhitespaceStrictRule.java
Patch:
@@ -39,7 +39,7 @@ public class QuestionWhitespaceStrictRule extends QuestionWhitespaceRule {
   public QuestionWhitespaceStrictRule(ResourceBundle messages, Language language) {
     super(messages, language);
     setTags(Arrays.asList(Tag.picky));
-    super.setDefaultOff();
+    this.setDefaultOff();
   }
 
   @Override

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/QuestionWhitespaceStrictRule.java
Patch:
@@ -39,6 +39,7 @@ public class QuestionWhitespaceStrictRule extends QuestionWhitespaceRule {
   public QuestionWhitespaceStrictRule(ResourceBundle messages, Language language) {
     super(messages, language);
     setTags(Arrays.asList(Tag.picky));
+    super.setDefaultOff();
   }
 
   @Override

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -772,7 +772,7 @@ public void testSuggestions() throws Exception {
     assertFirstSuggestion("informationnen,", "Informationen", rule, lt);
     assertFirstSuggestion("ALT-TARIF,", null, rule, lt);
     assertFirstSuggestion("ALT-ÜBERSICHT,", null, rule, lt);
-    assertFirstSuggestion("Primärfrequenz,", null, rule, lt);
+    assertFirstSuggestion("Sakralkultur,", null, rule, lt);
   }
   
   @Test

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -25,7 +25,6 @@
 import morfologik.stemming.Dictionary;
 import org.junit.Ignore;
 import org.junit.Test;
-import org.languagetool.AnalyzedSentence;
 import org.languagetool.JLanguageTool;
 import org.languagetool.Languages;
 import org.languagetool.TestTools;
@@ -44,8 +43,10 @@
 import java.util.*;
 import java.util.stream.Stream;
 
+import static junit.framework.Assert.assertEquals;
+import static junit.framework.TestCase.*;
 import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.*;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 public class GermanSpellerRuleTest {
 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/OfficeTools.java
Patch:
@@ -90,7 +90,7 @@ class OfficeTools {
   private static final String MENU_BAR = "private:resource/menubar/menubar";
   private static final String LOG_DELIMITER = ",";
   
-  private static final double LT_HEAP_LIMIT_FACTOR = 0.95;
+  private static final double LT_HEAP_LIMIT_FACTOR = 0.9;
   private static double MAX_HEAP_SPACE = -1;
   private static double LT_HEAP_LIMIT = -1;
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -1185,6 +1185,7 @@ public List<String> getSuggestions(String word) throws IOException {
     List<String> suggestions = super.getSuggestions(word);
     suggestions = suggestions.stream().filter(k -> !PREVENT_SUGGESTION.matcher(k).matches()
             && !k.endsWith("roulett")
+            && !k.matches("[\\wöäüÖÄÜß]+ -[\\wöäüÖÄÜß]+")   // e.g. "ALT -TARIF"
             && !k.endsWith("-s")   // https://github.com/languagetool-org/languagetool/issues/4042
     ).collect(Collectors.toList());
     if (word.endsWith(".")) {

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -325,6 +325,7 @@ protected int getPriorityForId(String id) {
       case "RUNDUM_SORGLOS_PAKET": return 1; // higher prio than DE_CASE
       case "MIT_FREUNDLICHEN_GRUESSE": return 1; // higher prio than MEIN_KLEIN_HAUS
       case "EINE_ORIGINAL_RECHNUNG": return 1; // higher prio than DE_CASE, DE_AGREEMENT and MEIN_KLEIN_HAUS
+      case "TYPOGRAPHIC_QUOTES": return 1; // higher prio than UNPAIRED_BRACKETS
       // default is 0
       case "DE_COMPOUND_COHERENCY": return -1;  // prefer EMAIL
       case "DE_AGREEMENT": return -1;  // prefer RECHT_MACHEN, MONTAGS, KONJUNKTION_DASS_DAS, DESWEITEREN, DIES_BEZUEGLICH and other

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikAmericanSpellerRuleTest.java
Patch:
@@ -106,6 +106,7 @@ public void testMorfologikSpeller() throws IOException {
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Yes ma'am.")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Yes ma’am.")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("fo'c'sle")).length);
+    assertEquals(0, rule.match(lt.getAnalyzedSentence("O'Connell, O’Connell, O'Connor, O’Neill")).length);
     
     // test words in language-specific spelling_en-US.txt
     assertEquals(0, rule.match(lt.getAnalyzedSentence("USTestWordToBeIgnored")).length);

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikBritishSpellerRuleTest.java
Patch:
@@ -86,6 +86,8 @@ public void testMorfologikSpeller() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Ménage à trois")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("ménage à trois")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("The quid pro quo")).length);
+    // apostrophes
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("Ma'am, O'Connell, O’Connell, O'Connor, O’Neill")).length);
 
     //incorrect sentences:
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -711,7 +711,7 @@ public class CaseRule extends Rule {
       csRegex("Gmb[Hh]|AG|KG|UG")
     ),
     Arrays.asList( // Klicke auf Home > Mehr > Team
-      csToken(">")
+      csToken(">"),
       csRegex("[A-ZÄÜÖ].+"),
       csToken(">")
     )

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/CheckRequestAnalysis.java
Patch:
@@ -167,6 +167,9 @@ DocumentCache actualizeDocumentCache (int nPara) {
   /** Get new initialized flat paragraph tools
    */
   FlatParagraphTools getFlatParagraphTools() {
+    if (flatPara == null) {
+      flatPara = new FlatParagraphTools(xComponent);
+    }
     return flatPara;
   }
   

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/FlatParagraphTools.java
Patch:
@@ -533,7 +533,7 @@ List<Boolean> isChecked(List<Integer> changedParas, int nDiv) {
 
   public void markParagraphs(Map<Integer, SingleProofreadingError[]> changedParas, DocumentCache docCache, boolean override, XParagraphCursor cursor) {
     try {
-      if (changedParas == null || changedParas.isEmpty()) {
+      if (changedParas == null || changedParas.isEmpty() || docCache == null) {
         return;
       }
       XFlatParagraph xFlatPara = getLastFlatParagraph();

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -215,7 +215,7 @@ ProofreadingResult getCheckResults(String paraText, Locale locale, ProofreadingR
       paRes.nStartOfSentencePosition = paragraphsCache.get(0).getStartSentencePosition(paraNum, paRes.nStartOfSentencePosition);
       paRes.nStartOfNextSentencePosition = paragraphsCache.get(0).getNextSentencePosition(paraNum, paRes.nStartOfSentencePosition);
       paRes.nBehindEndOfSentencePosition = paRes.nStartOfNextSentencePosition;
-      lastChangedPara = textIsChanged ? paraNum : -1;
+      lastChangedPara = (textIsChanged && numParasToCheck != 0) ? paraNum : -1;
     } catch (Throwable t) {
       MessageHandler.showError(t);
     }
@@ -496,7 +496,7 @@ public QueueEntry getNextQueueEntry(int nPara) {
    * run a text level check from a queue entry (initiated by the queue)
    */
   public void runQueueEntry(int nStart, int nEnd, int cacheNum, int nCheck, boolean doReset, SwJLanguageTool langTool) {
-    if (docCache.isFinished()) {
+    if (flatPara != null && docCache.isFinished()) {
       SingleCheck singleCheck = new SingleCheck(this, paragraphsCache, docCursor, flatPara, docLanguage, ignoredMatches, numParasToCheck, false);
       singleCheck.addParaErrorsToCache(docCache.getFlatParagraphNumber(nStart), langTool, cacheNum, nCheck, doReset, false, hasFootnotes);
     }

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/ContractionSpellingRule.java
Patch:
@@ -50,6 +50,7 @@ public ContractionSpellingRule(ResourceBundle messages) {
     setLocQualityIssueType(ITSIssueType.Misspelling);
     addExamplePair(Example.wrong("We <marker>havent</marker> earned anything."),
                    Example.fixed("We <marker>haven't</marker> earned anything."));
+    super.setCheckLemmas(false);
   }
 
   @Override

File: languagetool-language-modules/en/src/test/java/org/languagetool/chunking/EnglishChunkerTest.java
Patch:
@@ -77,9 +77,9 @@ public void testContractions() throws Exception {
     AnalyzedSentence analyzedSentence = langTool.getAnalyzedSentence("I'll be there");
     AnalyzedTokenReadings[] tokens = analyzedSentence.getTokens();
     assertThat(tokens[1].getChunkTags().get(0), is(new ChunkTag("B-NP-singular")));
-    assertThat(tokens[2].getChunkTags().size(), is(0));  // "'" cannot be mapped as we tokenize differently
-    assertThat(tokens[3].getChunkTags().size(), is(0));  // "ll" cannot be mapped as we tokenize differently
-    assertThat(tokens[5].getChunkTags().get(0), is(new ChunkTag("I-VP")));
+    assertThat(tokens[2].getChunkTags().get(0), is(new ChunkTag("B-VP"))); 
+    assertThat(tokens[4].getChunkTags().get(0), is(new ChunkTag("I-VP"))); 
+    assertThat(tokens[6].getChunkTags().get(0), is(new ChunkTag("I-VP")));
   }
 
   @Test

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/AvsAnRuleTest.java
Patch:
@@ -63,6 +63,7 @@ public void testRule() throws IOException {
     assertCorrect("See an:Grammatica");
     assertCorrect("See http://www.an.com");
     assertCorrect("Station A equals station B.");
+    assertCorrect("e.g., the case endings -a -i -u and mood endings -u -a");
 
     // errors:
     assertIncorrect("It was a hour ago.");

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/ContractionSpellingRuleTest.java
Patch:
@@ -48,13 +48,15 @@ public void testRule() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("It wasn't me.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("I'm ill.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Staatszerfall im südlichen Afrika.")).length);
-
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("by IVE")).length);
+    
     // incorrect sentences:
 
     // at the beginning of a sentence
     checkSimpleReplaceRule("Wasnt this great", "Wasn't");
     checkSimpleReplaceRule("YOURE WRONG", "YOU'RE");
     checkSimpleReplaceRule("Dont do this", "Don't");
+    checkSimpleReplaceRule("Ive been doing", "I've");
     // inside sentence
     checkSimpleReplaceRule("It wasnt me", "wasn't");
     checkSimpleReplaceRule("You neednt do this", "needn't");

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MessageHandler.java
Patch:
@@ -51,6 +51,7 @@ private static void initLogFile() {
     try (BufferedWriter bw = new BufferedWriter(new FileWriter(OfficeTools.getLogFilePath()))) {
       Date date = new Date();
       bw.write("LT office integration log from " + date + logLineBreak);
+      bw.write(OfficeTools.getJavaInformation() + logLineBreak);
     } catch (Throwable t) {
       showError(t);
     }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -227,7 +227,7 @@ ProofreadingResult getCheckResults(String paraText, Locale locale, ProofreadingR
    */
   void setConfigValues(Configuration config) {
     this.config = config;
-    numParasToCheck = mDocHandler.isTestMode() ? 0 : config.getNumParasToCheck();
+    numParasToCheck = (mDocHandler.isTestMode() || mDocHandler.heapLimitIsReached()) ? 0 : config.getNumParasToCheck();
     defaultParaCheck = PARA_CHECK_DEFAULT;
     if (ltMenus != null) {
       ltMenus.setConfigValues(config);
@@ -345,7 +345,7 @@ DocumentCache getDocumentCache() {
     return docCache;
   }
   
-  /** Get document cache of the document
+  /** Set document cache of the document
    */
   void setDocumentCache(DocumentCache docCache) {
     this.docCache = docCache;

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/CatalanUnpairedBracketsRuleTest.java
Patch:
@@ -96,6 +96,9 @@ public void testRule() throws IOException {
     //assertMatches("Paradise lost to the alleged water needs of Texas' big cities Thursday.", 0);
     assertMatches ("Porta'l cap ací.", 0);
     assertMatches ("Porta-me'n cinquanta!", 0);
+    // Saxon genitive
+    assertMatches("Harper's Dictionary of Classical Antiquities", 0);
+    assertMatches("Harper’s Dictionary of Classical Antiquities", 0);
 
     // incorrect sentences:
     assertMatches("(aquesta 'és la solució)", 1);

File: languagetool-language-modules/fr/src/test/java/org/languagetool/rules/fr/GenericUnpairedBracketsRuleTest.java
Patch:
@@ -40,6 +40,9 @@ public void testFrenchRule() throws IOException {
     rule = org.languagetool.rules.GenericUnpairedBracketsRuleTest.getBracketsRule(langTool);
     // correct sentences:
     assertMatches("(Qu'est ce que c'est ?)", 0);
+    // Saxon genitive
+    assertMatches("Harper's Dictionary of Classical Antiquities", 0);
+    assertMatches("Harper’s Dictionary of Classical Antiquities", 0);
     // incorrect sentences:
     assertMatches("(Qu'est ce que c'est ?", 1);
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -73,6 +73,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     put("Kruks", "Krux");
     put("Filterbubble", "Filterblase");
     put("Filterbubbles", "Filterblasen");
+    putRepl("Analgen.*", "Analgen", "Anlagen");
     putRepl("wiedersteh(en|st|t)", "wieder", "wider");
     putRepl("wiederstan(d|den|dest)", "wieder", "wider");
     putRepl("wiedersprech(e|t|en)?", "wieder", "wider");

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -337,6 +337,7 @@ protected int getPriorityForId(String id) {
       case "AUSTRIAN_GERMAN_SPELLER_RULE": return -3;  // assume most other rules are more specific and helpful than the spelling rule
       case "SWISS_GERMAN_SPELLER_RULE": return -3;  // assume most other rules are more specific and helpful than the spelling rule
       case "PUNCTUATION_PARAGRAPH_END": return -4;  // don't hide spelling mistakes
+      case "TEST_F_ANSTATT_PH": return -4;  // don't hide spelling mistakes
       case "PUNKT_ENDE_ABSATZ": return -10;  // should never hide other errors, as chance for a false alarm is quite high
       case "KOMMA_ZWISCHEN_HAUPT_UND_NEBENSATZ": return -10;
       case "KOMMA_VOR_RELATIVSATZ": return -10;

File: languagetool-core/src/main/java/org/languagetool/rules/GenericUnpairedBracketsRule.java
Patch:
@@ -275,8 +275,7 @@ private boolean getPrecededByWhitespace(AnalyzedTokenReadings[] tokens, int i, i
       precededByWhitespace = tokens[i - 1].isSentenceStart()
           || tokens[i].isWhitespaceBefore()
           || PUNCTUATION_NO_DOT.matcher(tokens[i - 1].getToken()).matches()
-          || startSymbols.contains(tokens[i - 1].getToken())
-          || (tokens[i].getToken().equals("\"") && ! tokens[i].isSentenceEnd());  // e.g. >>"I"s<< has and needs no space
+          || startSymbols.contains(tokens[i - 1].getToken());
     }
     return precededByWhitespace;
   }
@@ -286,7 +285,8 @@ private boolean getFollowedByWhitespace(AnalyzedTokenReadings[] tokens, int i, i
     if (i < tokens.length - 1 && startSymbols.get(j).equals(endSymbols.get(j))) {
       followedByWhitespace = tokens[i + 1].isWhitespaceBefore()
               || PUNCTUATION.matcher(tokens[i + 1].getToken()).matches()
-              || endSymbols.contains(tokens[i + 1].getToken());
+              || endSymbols.contains(tokens[i + 1].getToken())
+              || "s".equals(tokens[i + 1].getToken());// e.g. >>"I"s<< has and needs no space
     }
     return followedByWhitespace;
   }

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/EnglishUnpairedBracketsRuleTest.java
Patch:
@@ -103,7 +103,7 @@ public void testRule() throws IOException {
     assertCorrect("I think that Liszt's \"Forgotten Waltz No.3\" is a hidden masterpiece.");
     assertCorrect("I think that Liszt's \"Forgotten Waltz No. 3\" is a hidden masterpiece.");
     assertCorrect("Turkish distinguishes between dotted and dotless \"I\"s.");
-    assertCorrect("It has recognized no \"bora\"-like pattern in his behaviour.");
+    // assertCorrect("It has recognized no \"bora\"-like pattern in his behaviour."); It's fixed with the new tokenizer
 
     // incorrect sentences:
     assertIncorrect("(This is a test sentence.");

File: languagetool-commandline/src/test/java/org/languagetool/commandline/MainTest.java
Patch:
@@ -239,8 +239,8 @@ public void testEnglishFileApplySuggestions() throws Exception {
     Main.main(args);
     String output = new String(this.out.toByteArray());
     assertTrue(output.contains("This is a test.\n\n" +
-        "This is a test of language tool.\n\n" +
-        "This is a test of language tool.")); // \r\n in Windows tests at the end...
+        "This is a test of LanguageTool.\n\n" +
+        "This is a test of LanguageTool.")); // \r\n in Windows tests at the end...
   }
 
   @Test

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractUnitConversionRule.java
Patch:
@@ -135,11 +135,11 @@ protected NumberFormat getNumberFormat() {
   protected String getMessage(Message message) {
     switch(message) {
       case CHECK:
-        return "This conversion doesn't seem right. Do you want to correct it automatically?";
+        return "This unit conversion doesn't seem right. Do you want to correct it automatically?";
       case SUGGESTION:
         return "Writing for an international audience? Consider adding the metric equivalent.";
       case CHECK_UNKNOWN_UNIT:
-        return "This conversion doesn't seem right, unable to recognize the used unit.";
+        return "This unit conversion doesn't seem right, unable to recognize the used unit.";
       case UNIT_MISMATCH:
         return "These units don't seem to be compatible.";
       default:
@@ -153,7 +153,7 @@ protected String getMessage(Message message) {
   protected String getShortMessage(Message message) {
     switch(message) {
       case CHECK:
-        return "Incorrect conversion. Correct it?";
+        return "Incorrect unit conversion. Correct it?";
       case SUGGESTION:
         return "Add metric equivalent?";
       case CHECK_UNKNOWN_UNIT:

File: languagetool-core/src/main/java/org/languagetool/rules/CommaWhitespaceRule.java
Patch:
@@ -34,6 +34,7 @@
  * 
  * @author Daniel Naber
  */
+/* need better messages */
 public class CommaWhitespaceRule extends Rule {
 
   private boolean quotesWhitespaceCheck;

File: languagetool-server/src/main/java/org/languagetool/server/UserLimits.java
Patch:
@@ -68,7 +68,7 @@ static UserLimits getLimitsFromToken(HTTPServerConfig config, String jwtToken) {
     Objects.requireNonNull(jwtToken);
     String secretKey = config.getSecretTokenKey();
     if (secretKey == null) {
-      throw new RuntimeException("You specified a 'token' parameter but this server doesn't accept tokens");
+      throw new RuntimeException("You specified a 'token' parameter but this server is not configured to accept tokens");
     }
     Algorithm algorithm = Algorithm.HMAC256(secretKey);
     DecodedJWT decodedToken;

File: languagetool-core/src/test/java/org/languagetool/LanguageSpecificTest.java
Patch:
@@ -128,7 +128,7 @@ protected void testCoherencyBaseformIsOtherForm(Language lang) throws IOExceptio
   
   private final static Map<String, Integer> idToExpectedMatches = new HashMap<>();
   static {
-    idToExpectedMatches.put("EN_COHERENT_APOS", 2);
+    idToExpectedMatches.put("EN_CONSISTENT_APOS", 2);
     idToExpectedMatches.put("STYLE_REPEATED_WORD_RULE_DE", 2);
     idToExpectedMatches.put("STYLE_REPEATED_SHORT_SENTENCES", 3);
     idToExpectedMatches.put("STYLE_REPEATED_SENTENCE_BEGINNING", 3);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/StyleRepeatedVeryShortSentences.java
Patch:
@@ -121,7 +121,7 @@ public String getId() {
 
   @Override
   public String getDescription() {
-    return "Stakkato Sätze";
+    return "Stakkato-Sätze";
   }
 
 }

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/QuestionWhitespaceRule.java
Patch:
@@ -186,7 +186,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) {
       if (msg != null) {
         int fromPos = tokens[iFrom].getStartPos();
         int toPos = tokens[iTo].getEndPos();
-        RuleMatch ruleMatch = new RuleMatch(this, sentence, fromPos, toPos, msg, "Insérer un espace insécable");
+        RuleMatch ruleMatch = new RuleMatch(this, sentence, fromPos, toPos, msg, "Insérer une espace insécable");
         ruleMatch.setSuggestedReplacement(suggestionText);
         ruleMatches.add(ruleMatch);
       }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CompoundInfinitivRule.java
Patch:
@@ -134,6 +134,7 @@ private static boolean isInfinitiv(AnalyzedTokenReadings token) {
   }
 
   private boolean isMisspelled(String word) {
+    word = word.substring(0, 1).toLowerCase() + word.substring(1);
     if (linguServices == null && speller != null) {
       return speller.isMisspelled(word);
     } else if (linguServices != null) {

File: languagetool-core/src/test/java/org/languagetool/LanguageSpecificTest.java
Patch:
@@ -128,6 +128,7 @@ protected void testCoherencyBaseformIsOtherForm(Language lang) throws IOExceptio
   
   private final static Map<String, Integer> idToExpectedMatches = new HashMap<>();
   static {
+    idToExpectedMatches.put("EN_COHERENT_APOS", 2);
     idToExpectedMatches.put("STYLE_REPEATED_WORD_RULE_DE", 2);
     idToExpectedMatches.put("STYLE_REPEATED_SHORT_SENTENCES", 3);
     idToExpectedMatches.put("STYLE_REPEATED_SENTENCE_BEGINNING", 3);

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -188,6 +188,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
         new PunctuationMarkAtParagraphEnd(messages, this),
         new PunctuationMarkAtParagraphEnd2(messages, this),
         // specific to English:
+        new ConsistentApostrophesRule(messages),
         new SpecificCaseRule(messages),
         new EnglishUnpairedBracketsRule(messages, this),
         new EnglishWordRepeatRule(messages, this),

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/TypographyRule.java
Patch:
@@ -75,7 +75,7 @@ public final RuleMatch[] match(AnalyzedSentence sentence) {
       else if( i > 1 && i < tokens.length - 1
             && "\u2014".equals(tokens[i].getToken()) || "\u2013".equals(tokens[i].getToken()) ) {
         boolean noSpaceLeft = ! tokens[i].isWhitespaceBefore() && ! ",".equals(tokens[i-1].getToken());
-        boolean noSpaceRight = ! tokens[i+1].isWhitespaceBefore();
+        boolean noSpaceRight = i < tokens.length - 1 && ! tokens[i+1].isWhitespaceBefore();
 
         if( noSpaceLeft || noSpaceRight ) {
 

File: languagetool-language-modules/uk/src/test/java/org/languagetool/rules/uk/TypographyRuleTest.java
Patch:
@@ -72,6 +72,7 @@ public void testRule() throws IOException {
     assertEquals(1, matches.length);
     assertEquals(Arrays.asList("важливіше-потенційні", "важливіше \u2014 потенційні"), matches[0].getSuggestedReplacements());
     
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("Рахунки 1 класу –")).length);
   }
 
 }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/CheckRequestAnalysis.java
Patch:
@@ -394,7 +394,7 @@ private int getParaFromViewCursorOrDialog(String chPara, Locale locale, int[] fo
       if (nPara >= 0 && nPara < docCache.textSize()) {
         nPara = docCache.getFlatParagraphNumber(nPara);
         numLastVCPara = nPara;
-        if(!docCache.isEqual(docCache.getFlatParagraphNumber(nPara), chPara, locale)) {
+        if(!docCache.isEqual(nPara, chPara, locale)) {
           actualizeDocumentCache(nPara);
           textIsChanged = true;
         }

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/RuleMatchDiffFinder.java
Patch:
@@ -35,7 +35,7 @@ public class RuleMatchDiffFinder {
 
   private static final String MARKER_START = "<span class='marker'>";
   private static final String MARKER_END = "</span>";
-  private static final int IFRAME_MAX = 150;
+  private static final int IFRAME_MAX = -1;
 
   List<RuleMatchDiff> getDiffs(List<LightRuleMatch> l1, List<LightRuleMatch> l2) {
     System.out.println("Comparing result 1 (" + l1.size() + " matches) to result 2 (" + l2.size() + " matches), step 1");

File: languagetool-core/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -120,6 +120,8 @@ public class WordListValidatorTest {
           "Mirotić",
           "dtª",  // for PT
           "dtº",  // for PT
+          "ª",  // for PT
+          "º",  // for PT
           // Greek letters / Mathematics and physics variables
           "Α", "Β", "Γ", "Δ", "Ε", "Ζ", "Η", "Θ", "Ι", "Κ", "Λ", "Μ", "Ν", "Ξ", "Ο", "Π", "Ρ", "Σ", "Τ", "Υ", "Φ", "Χ", "Ψ", "Ω", 
           "α", "β", "γ", "δ", "ε", "ζ", "η", "θ", "ι", "κ", "λ", "μ", "ν", "ξ", "ο", "π", "ρ", "σ", "τ", "υ", "φ", "χ", "ψ", "ω"          

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ResultCache.java
Patch:
@@ -83,9 +83,9 @@ void removeAndShift(int firstParagraph, int lastParagraph, int shift) {
     entries = Collections.synchronizedMap(new HashMap<>());
     synchronized (tmpEntries) {
       for (int i : tmpEntries.keySet()) {
-        if (i > lastParagraph) {
+        if (i >= firstParagraph && i + shift >= 0) {
           entries.put(i + shift, tmpEntries.get(i));
-        } else {
+        } else if (i < firstParagraph + shift) {
           entries.put(i, tmpEntries.get(i));
         } 
       }

File: languagetool-core/src/main/java/org/languagetool/rules/BERTSuggestionRanking.java
Patch:
@@ -30,7 +30,6 @@
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.Language;
 import org.languagetool.languagemodel.bert.RemoteLanguageModel;
-import org.languagetool.markup.AnnotatedText;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -116,7 +115,7 @@ protected List<SuggestedReplacement> prepareSuggestions(List<SuggestedReplacemen
   }
 
   @Override
-  protected RemoteRequest prepareRequest(List<AnalyzedSentence> sentences, AnnotatedText annotatedText, Long textSessionId) {
+  protected RemoteRequest prepareRequest(List<AnalyzedSentence> sentences, Long textSessionId) {
     List<RuleMatch> matches = new LinkedList<>();
     List<RemoteLanguageModel.Request> requests = new LinkedList<>();
     try {

File: languagetool-core/src/test/java/org/languagetool/RemoteRuleCacheTest.java
Patch:
@@ -66,7 +66,7 @@ class TestRemoteRequest extends RemoteRequest {
     }
 
     @Override
-    protected RemoteRequest prepareRequest(List<AnalyzedSentence> sentences, AnnotatedText annotatedText, Long textSessionId) {
+    protected RemoteRequest prepareRequest(List<AnalyzedSentence> sentences, Long textSessionId) {
       return new TestRemoteRequest(sentences);
     }
 

File: languagetool-core/src/test/java/org/languagetool/rules/RemoteRuleTimeoutTest.java
Patch:
@@ -65,7 +65,7 @@ class TestRemoteRequest extends RemoteRequest {
     }
 
     @Override
-    protected RemoteRequest prepareRequest(List<AnalyzedSentence> sentences, AnnotatedText annotatedText, Long textSessionId) {
+    protected RemoteRequest prepareRequest(List<AnalyzedSentence> sentences, Long textSessionId) {
       return new TestRemoteRule.TestRemoteRequest(sentences);
     }
 

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/RuleMatchDiffFinder.java
Patch:
@@ -311,7 +311,7 @@ private String enc(String s, int maxLen)  {
   private String showTrimSpace(String s) {
     s = s.replaceFirst("^\\s", "<span class='whitespace'>&nbsp;</span>");
     s = s.replaceFirst("\\s$", "<span class='whitespace'>&nbsp;</span>");
-    s = s.replaceFirst("\u00A0", "<span class='nbsp' title='non-breaking space'>&nbsp;</span>");
+    s = s.replaceAll("\u00A0", "<span class='nbsp' title='non-breaking space'>&nbsp;</span>");
     return s;
   }
 

File: languagetool-core/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -118,6 +118,8 @@ public class WordListValidatorTest {
           "Łódź",
           "Ørsted",
           "Mirotić",
+          "dtª",  // for PT
+          "dtº",  // for PT
           // Greek letters / Mathematics and physics variables
           "Α", "Β", "Γ", "Δ", "Ε", "Ζ", "Η", "Θ", "Ι", "Κ", "Λ", "Μ", "Ν", "Ξ", "Ο", "Π", "Ρ", "Σ", "Τ", "Υ", "Φ", "Χ", "Ψ", "Ω", 
           "α", "β", "γ", "δ", "ε", "ζ", "η", "θ", "ι", "κ", "λ", "μ", "ν", "ξ", "ο", "π", "ρ", "σ", "τ", "υ", "φ", "χ", "ψ", "ω"          

File: languagetool-core/src/main/java/org/languagetool/rules/BERTSuggestionRanking.java
Patch:
@@ -38,6 +38,7 @@
 import java.io.IOException;
 import java.util.*;
 import java.util.concurrent.Callable;
+import java.util.concurrent.TimeoutException;
 import java.util.stream.Collectors;
 
 /**
@@ -141,7 +142,7 @@ protected RemoteRuleResult fallbackResults(RemoteRequest request) {
   }
 
   @Override
-  protected Callable<RemoteRuleResult> executeRequest(RemoteRequest request) {
+  protected Callable<RemoteRuleResult> executeRequest(RemoteRequest request, long timeoutMilliseconds) throws TimeoutException {
     return () -> {
       if (model == null) {
         return fallbackResults(request);
@@ -157,7 +158,7 @@ protected Callable<RemoteRuleResult> executeRequest(RemoteRequest request) {
       if (requests.isEmpty()) {
         return new RemoteRuleResult(false, true, matches, data.sentences);
       } else {
-        List<List<Double>> results = model.batchScore(requests);
+        List<List<Double>> results = model.batchScore(requests, timeoutMilliseconds);
         // put curated at the top, then compare probabilities
         for (int i = 0; i < indices.size(); i++) {
           List<Double> scores = results.get(i);

File: languagetool-core/src/test/java/org/languagetool/RemoteRuleCacheTest.java
Patch:
@@ -35,6 +35,7 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.TimeoutException;
 import java.util.stream.Collectors;
 
 import static org.hamcrest.CoreMatchers.equalTo;
@@ -74,7 +75,7 @@ private RuleMatch testMatch(AnalyzedSentence s) {
     }
 
     @Override
-    protected Callable<RemoteRuleResult> executeRequest(RemoteRequest request) {
+    protected Callable<RemoteRuleResult> executeRequest(RemoteRequest request, long timeoutMilliseconds) throws TimeoutException {
       return () -> {
         TestRemoteRequest req = (TestRemoteRequest) request;
         List<RuleMatch> matches = req.sentences.stream().map(this::testMatch).collect(Collectors.toList());

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/FlatParagraphTools.java
Patch:
@@ -278,7 +278,7 @@ private static Locale getParagraphLanguage(XFlatParagraph flatPara, int first, i
    * Try to get the main language of paragraph 
    * @throws IllegalArgumentException 
    */
-  private static Locale getPrimaryParagraphLanguage(XFlatParagraph flatPara, int len, Locale docLocale, Locale lastLocale) throws IllegalArgumentException {
+  public static Locale getPrimaryParagraphLanguage(XFlatParagraph flatPara, int len, Locale docLocale, Locale lastLocale) throws IllegalArgumentException {
     if (docLocale != null) {
       return docLocale;
     }

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/HunspellRuleTest.java
Patch:
@@ -30,7 +30,7 @@
 public class HunspellRuleTest {
 
   @Test
-  public void testRuleWithGerman() throws Exception {
+  public void testRule() throws Exception {
     HunspellRule rule = new HunspellRule(TestTools.getMessages("pt"), Languages.getLanguageForShortCode("pt-PT"), null);
     JLanguageTool langTool = new JLanguageTool(Languages.getLanguageForShortCode("pt-PT"));
     

File: languagetool-language-modules/en/src/test/java/org/languagetool/tokenizers/EnglishSRXSentenceTokenizerTest.java
Patch:
@@ -117,6 +117,9 @@ public void testTokenize() {
     testSplit("Other good editions are in vol. 4.");
     testSplit("Other good editions are in vol. IX.");
     testSplit("Other good editions are in vol. I think."); // ambiguous
+    testSplit("Who Shall I Say is Calling & Other Stories S. Deziemianowicz, ed. (2009)");
+    testSplit("Who Shall I Say is Calling & Other Stories S. Deziemianowicz, ed. ", "And this is another one.");
+    testSplit("This is a sentence written by Ed. ", "And this is another one.");
   }
 
   private void testSplit(String... sentences) {

File: languagetool-core/src/main/java/org/languagetool/rules/GRPCRule.java
Patch:
@@ -239,7 +239,7 @@ protected Callable<RemoteRuleResult> executeRequest(RemoteRule.RemoteRequest req
           }
         )
       ).flatMap(Function.identity()).collect(Collectors.toList());
-      RemoteRuleResult result = new RemoteRuleResult(true, true, matches);
+      RemoteRuleResult result = new RemoteRuleResult(true, true, matches, req.sentences);
       return result;
     };
   }
@@ -252,7 +252,8 @@ protected Callable<RemoteRuleResult> executeRequest(RemoteRule.RemoteRequest req
 
   @Override
   protected RemoteRuleResult fallbackResults(RemoteRule.RemoteRequest request) {
-    return new RemoteRuleResult(false, false, Collections.emptyList());
+    MLRuleRequest req = (MLRuleRequest) request;
+    return new RemoteRuleResult(false, false, Collections.emptyList(), req.sentences);
   }
 
   /**

File: languagetool-core/src/main/java/org/languagetool/rules/RemoteRule.java
Patch:
@@ -99,7 +99,7 @@ protected class RemoteRequest {}
    */
   public FutureTask<RemoteRuleResult> run(List<AnalyzedSentence> sentences, @Nullable Long textSessionId) {
     if (sentences.isEmpty()) {
-      return new FutureTask<>(() -> new RemoteRuleResult(false, true, Collections.emptyList()));
+      return new FutureTask<>(() -> new RemoteRuleResult(false, true, Collections.emptyList(), sentences));
     }
     return new FutureTask<>(() -> {
       long startTime = System.nanoTime();
@@ -148,7 +148,7 @@ public FutureTask<RemoteRuleResult> run(List<AnalyzedSentence> sentences, @Nulla
                 ruleLanguage, sentence, sentenceMatches);
               filteredMatches.addAll(filteredSentenceMatches);
             }
-            result = new RemoteRuleResult(result.isRemote(), result.isSuccess(), filteredMatches);
+            result = new RemoteRuleResult(result.isRemote(), result.isSuccess(), filteredMatches, sentences);
           }
 
           return result;

File: languagetool-core/src/test/java/org/languagetool/RemoteRuleCacheTest.java
Patch:
@@ -78,13 +78,14 @@ protected Callable<RemoteRuleResult> executeRequest(RemoteRequest request) {
       return () -> {
         TestRemoteRequest req = (TestRemoteRequest) request;
         List<RuleMatch> matches = req.sentences.stream().map(this::testMatch).collect(Collectors.toList());
-        return new RemoteRuleResult(true, true, matches);
+        return new RemoteRuleResult(true, true, matches, req.sentences);
       };
     }
 
     @Override
     protected RemoteRuleResult fallbackResults(RemoteRequest request) {
-      return new RemoteRuleResult(false, false, Collections.emptyList());
+      TestRemoteRequest req = (TestRemoteRequest) request;
+      return new RemoteRuleResult(false, false, Collections.emptyList(), req.sentences);
     }
 
     @Override

File: languagetool-language-modules/es/src/main/java/org/languagetool/tagging/es/SpanishTagger.java
Patch:
@@ -46,8 +46,8 @@ public class SpanishTagger extends BaseTagger {
   private static final Pattern PREFIXES_FOR_ADJ = Pattern.compile("(.+)-(.+)",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
   private static final Pattern ADJ = Pattern.compile("AQ.+");
-  private static final Pattern ADJ_MS = Pattern.compile("AQ.[MC][SN].");
-  private static final Pattern NO_PREFIXES_FOR_ADJ = Pattern.compile("(pro|afro|ultra|super|súper)",
+  private static final Pattern ADJ_MS = Pattern.compile("AQ.MS.|AQ.CS.|AQ.MN.");
+  private static final Pattern NO_PREFIXES_FOR_ADJ = Pattern.compile("(anti|pre|ex|pro|afro|ultra|super|súper)",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
 
   public SpanishTagger() {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ConfigThread.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.openoffice;
 
+import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
@@ -65,7 +66,8 @@ public void run() {
       boolean configChanged = cfgDialog.show(allRules);
       if (configChanged) {
         Set<String> disabledRules = config.getDisabledRuleIds();
-        for (String ruleId : disabledRulesUI) {
+        Set<String> tmpDisabledRules = new HashSet<String>(disabledRulesUI);
+        for (String ruleId : tmpDisabledRules) {
           if(!disabledRules.contains(ruleId)) {
             disabledRulesUI.remove(ruleId);
           }

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -453,6 +453,7 @@ protected int getPriorityForId(String id) {
       case "PRP_JJ":                    return -3;  // prefer other rules (e.g. PRP_VBG, IT_IT and ADJECTIVE_ADVERB, PRP_ABLE, PRP_NEW, MD_IT_JJ)
       case "PRONOUN_NOUN":              return -3;  // prefer other rules (e.g. PRP_VB, PRP_JJ)
       case "INDIAN_ENGLISH":            return -3;  // prefer grammar rules, but higher prio than spell checker
+      case "GONNA_TEMP":                return -3;
       case "PRP_THE":                   return -4;  // prefer other rules (e.g. I_A, PRP_JJ, IF_YOU_ANY, I_AN)
       case "GONNA":                     return -4;  // prefer over spelling rules
       case "MORFOLOGIK_RULE_EN_US":     return -10;  // more specific rules (e.g. L2 rules) have priority

File: languagetool-core/src/main/java/org/languagetool/rules/RemoteRuleResult.java
Patch:
@@ -21,6 +21,7 @@
 
 package org.languagetool.rules;
 
+import org.jetbrains.annotations.NotNull;
 import org.languagetool.AnalyzedSentence;
 
 import java.util.*;
@@ -65,7 +66,8 @@ public Set<AnalyzedSentence> matchedSentences() {
     return sentenceMatches.keySet();
   }
 
+  @NotNull
   public List<RuleMatch> matchesForSentence(AnalyzedSentence sentence) {
-    return sentenceMatches.get(sentence);
+    return sentenceMatches.getOrDefault(sentence, Collections.emptyList());
   }
 }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -493,8 +493,10 @@ public void testZurReplacement() throws IOException {
     assertBad("Hier geht's zur Männern.", "zu den Männern");
     assertBad("Hier geht's zur Portal.", "zum Portal");
     assertBad("Hier geht's zur Portalen.", "zu den Portalen");
+    assertBad("Niereninsuffizienz führt zur Störungen des Wasserhaushalts.", "zu den Störungen", "zur Störung", "zur Störungen");  // TODO: should be improved
     assertGood("Hier geht's zur Sonne.");
     assertGood("Hier geht's zum Schrank.");
+    assertGood("Niereninsuffizienz führt zu Störungen des Wasserhaushalts.");
   }
 
   @Test

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -1177,6 +1177,8 @@ public class CaseRule extends Rule {
     "Vielfaches",
     "Vorsitzender",
     "Fraktionsvorsitzender",
+    "Verletzte",
+    "Verletzten",
     "Walt",
     "Weitem",
     "Weiteres",

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CompoundInfinitivRule.java
Patch:
@@ -240,7 +240,7 @@ && isRelevant(tokens[i - 1])
         && !tokens[i].isImmunized()
         && !isException(tokens, i)
         && !isMisspelled(tokens[i - 1].getToken() + tokens[i + 1].getToken())) {
-        String msg = "Wenn der erweiterte Infinitv von dem Verb '" + tokens[i - 1].getToken() + tokens[i + 1].getToken()
+        String msg = "Wenn der erweiterte Infinitiv von dem Verb '" + tokens[i - 1].getToken() + tokens[i + 1].getToken()
                    + "' abgeleitet ist, sollte er zusammengeschrieben werden.";
         RuleMatch ruleMatch = new RuleMatch(this, sentence, tokens[i - 1].getStartPos(), tokens[i + 1].getEndPos(), msg);
         List<String> suggestions = new ArrayList<>();

File: languagetool-language-modules/es/src/test/java/org/languagetool/rules/es/MorfologikSpanishSpellerRuleTest.java
Patch:
@@ -39,7 +39,7 @@ public void testMorfologikSpeller() throws IOException {
 
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Escriba un texto aquí. LanguageTool le ayudará a afrontar algunas dificultades propias de la escritura.")).length);
     
-    assertEquals(0, rule.match(langTool.getAnalyzedSentence("Hagámosle, deme, démelo, europeízate, homogenéizalo.")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("Hagámosle, deme, démelo, europeízate, homogenéizalo. Anúnciate. Desáhucialos.")).length);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Veíanse")).length); //This is archaic
 
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("En la p. 25, pp. 33-45. Ctrl+A")).length);

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -226,6 +226,7 @@ public LanguageMaintainedState getMaintainedState() {
   @Override
   protected int getPriorityForId(String id) {
     switch (id) { 
+      case "SA_CA": return 10; // greater than D_N
       case "A_INFINITIF": return 10;
       case "DU_DU": return 10; // greater than DU_LE
       case "ACCORD_CHAQUE": return 10; // greater than ACCORD_NOMBRE

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -226,6 +226,7 @@ public LanguageMaintainedState getMaintainedState() {
   @Override
   protected int getPriorityForId(String id) {
     switch (id) { 
+      case "A_INFINITIF": return 10;
       case "DU_DU": return 10; // greater than DU_LE
       case "ACCORD_CHAQUE": return 10; // greater than ACCORD_NOMBRE
       case "CEST_A_DIRE": return 10; // greater than A_A_ACCENT

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ConfigThread.java
Patch:
@@ -73,7 +73,7 @@ public void run() {
         documents.setDisabledRules(disabledRulesUI);
         config.removeDisabledRuleIds(disabledRulesUI);
         config.saveConfiguration(docLanguage);
-        documents.resetDocumentCaches();
+//        documents.resetDocumentCaches();
         documents.resetConfiguration();
       } else {
         config.removeDisabledRuleIds(documents.getDisabledRules());

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -1111,7 +1111,7 @@ private SingleProofreadingError[] checkParaRules( String paraText, int[] footnot
         lastSinglePara = paraText;
       }
       // return Cache result if available / for right mouse click or Dialog only use cache
-      int nPara = nFPara < 0 ? -1 : docCache.getNumberOfTextParagraph(nFPara);
+      int nPara = nFPara < 0 || docCache == null ? -1 : docCache.getNumberOfTextParagraph(nFPara);
       if (nFPara >= 0 && (pErrors != null || (useQueue && !isDialogRequest.contains(nFPara) && parasToCheck != 0))) {
         if (useQueue && pErrors == null && parasToCheck != 0 && nPara >= 0 && !textIsChanged.contains(nFPara)) {
           addQueueEntry(nFPara, cacheNum, parasToCheck, docID, false);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -214,6 +214,9 @@ private int getCurrentFlatParagraphNumber(ViewCursorTools viewCursor, DocumentCa
           return nLastFlat; 
         }
       }
+    } else if (y >= docCache.size()) {
+      nLastFlat = docCache.size() - 1;
+      return nLastFlat; 
     }
     nLastFlat = docCache.getFlatParagraphNumber(y);
     return nLastFlat; 

File: languagetool-core/src/main/java/org/languagetool/AnalyzedSentence.java
Patch:
@@ -328,7 +328,7 @@ public Set<String> getLemmaSet() {
   /**
    * @return all offsets in {@link #getTokensWithoutWhitespace()} where tokens with the given text occur (case-insensitive),
    * or {@code null} if there are no such occurrences
-   * @since 5.2
+   * @since 5.3
    */
   @Nullable
   @ApiStatus.Internal
@@ -339,7 +339,7 @@ public List<Integer> getTokenOffsets(String token) {
   /**
    * @return all offsets in {@link #getTokensWithoutWhitespace()} where tokens with the given lemma occur (case-insensitive),
    * or {@code null} if there are no such occurrences
-   * @since 5.2
+   * @since 5.3
    */
   @Nullable
   @ApiStatus.Internal

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1272,11 +1272,11 @@ private boolean ignoreRule(Rule rule) {
     Category ruleCategory = rule.getCategory();
     boolean isCategoryDisabled = (disabledRuleCategories.contains(ruleCategory.getId()) || rule.getCategory().isDefaultOff())
       && !enabledRuleCategories.contains(ruleCategory.getId());
-    boolean isRuleDisabled = disabledRules.contains(rule.getId())
-      || (rule.isDefaultOff() && !enabledRules.contains(rule.getId()));
+    boolean isRuleDisabled = disabledRules.contains(rule.getFullId()) || disabledRules.contains(rule.getId())
+      || (rule.isDefaultOff() && !(enabledRules.contains(rule.getFullId()) || enabledRules.contains(rule.getId())));
     boolean isDisabled;
     if (isCategoryDisabled) {
-      isDisabled = !enabledRules.contains(rule.getId());
+      isDisabled = !(enabledRules.contains(rule.getFullId()) || enabledRules.contains(rule.getId()));
     } else {
       isDisabled = isRuleDisabled;
     }

File: languagetool-language-modules/ru/src/main/java/org/languagetool/language/Russian.java
Patch:
@@ -135,12 +135,12 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new WordRepeatRule(messages, this),
             new MultipleWhitespaceRule(messages, this),
 	    new SentenceWhitespaceRule(messages),
-            new WhiteSpaceBeforeParagraphEnd(messages, this),  //    
+            new WhiteSpaceBeforeParagraphEnd(messages, this),  
             new WhiteSpaceAtBeginOfParagraph(messages),
         //  new EmptyLineRule(messages, this),  // too picky rule 
             new LongSentenceRule(messages, userConfig),
             new LongParagraphRule(messages, this, userConfig),
-        //    new ParagraphRepeatBeginningRule(messages, this),   //temp disable rule, issue #3509
+            new ParagraphRepeatBeginningRule(messages, this),   //re-activate rule, issue #3509
             new RussianFillerWordsRule(messages, this, userConfig),
         //  new PunctuationMarkAtParagraphEnd(messages, this),
             new PunctuationMarkAtParagraphEnd2(messages, this),  //

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractUnitConversionRule.java
Patch:
@@ -223,7 +223,7 @@ protected AbstractUnitConversionRule(ResourceBundle messages) {
 
     addUnit("km", METRE, "km", 1e3, true);
     addUnit("m", METRE, "m",   1e0, true);
-    addUnit("dm", METRE, "dm", 1e-1,  false/*true*/); // Metric, but not commonly used
+    //addUnit("dm", METRE, "dm", 1e-1,  /*true*/); // Metric, but not commonly used
     addUnit("cm", METRE, "cm", 1e-2, true);
     addUnit("mm", METRE, "mm", 1e-3, true);
     addUnit("µm", METRE, "µm", 1e-6, true);
@@ -233,7 +233,7 @@ protected AbstractUnitConversionRule(ResourceBundle messages) {
     addUnit("ha", SQUARE_METRE, "ha", 1e4, true);
     addUnit("a", SQUARE_METRE, "a", 1e2, true);
     addUnit("km(?:\\^2|2|²)", SQUARE_METRE, "km²", 1e6, true);
-    addUnit("dm(?:\\^2|2|²)", SQUARE_METRE, "dm²", 1e-2,  false/*true*/); // Metric, but not commonly used
+    //addUnit("dm(?:\\^2|2|²)", SQUARE_METRE, "dm²", 1e-2,  false/*true*/); // Metric, but not commonly used
     addUnit("cm(?:\\^2|2|²)", SQUARE_METRE, "cm²", 1e-4, true);
     addUnit("mm(?:\\^2|2|²)", SQUARE_METRE, "mm²", 1e-6, true);
     addUnit("µm(?:\\^2|2|²)", SQUARE_METRE, "µm²", 1e-12, true);
@@ -251,7 +251,7 @@ protected AbstractUnitConversionRule(ResourceBundle messages) {
 
     addUnit("m(?:\\^3|3|³)", CUBIC_METRE, "m³", 1, true);
     addUnit("km(?:\\^3|3|³)", CUBIC_METRE, "km³", 1e9, true);
-    addUnit("dm(?:\\^3|3|³)", CUBIC_METRE, "dm³", 1e-3,  false/*true*/); // Metric, but not commonly used
+    //addUnit("dm(?:\\^3|3|³)", CUBIC_METRE, "dm³", 1e-3,  false/*true*/); // Metric, but not commonly used
     addUnit("cm(?:\\^3|3|³)", CUBIC_METRE, "cm³", 1e-6, true);
     addUnit("mm(?:\\^3|3|³)", CUBIC_METRE, "mm³", 1e-9, true);
     addUnit("µm(?:\\^3|3|³)", CUBIC_METRE, "µm³", 1e-18, true);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/UnitConversionRule.java
Patch:
@@ -60,7 +60,7 @@ public UnitConversionRule(ResourceBundle messages) {
 
     addUnit("Meter", METRE, "Meter", 1, true);
     addUnit("Kilometer", METRE, "Kilometer", 1e3, true);
-    addUnit("Dezimeter", METRE, "Dezimeter", 1e-1, false); // metric, but should not be suggested
+    //addUnit("Dezimeter", METRE, "Dezimeter", 1e-1, false); // metric, but should not be suggested
     addUnit("Zentimeter", METRE, "Zentimeter", 1e-2, true);
     addUnit("Millimeter", METRE, "Millimeter", 1e-3, true);
     addUnit("Mikrometer", METRE, "Mikrometer", 1e-6, true);
@@ -72,15 +72,15 @@ public UnitConversionRule(ResourceBundle messages) {
     addUnit("Hektar", SQUARE_METRE, "Hektar", 1e4, true);
     addUnit("Ar", SQUARE_METRE, "Ar", 1e2, true);
     addUnit("Quadratkilometer", SQUARE_METRE,  "Quadratkilometer",  1e6, true);
-    addUnit("Quadratdezimeter", SQUARE_METRE,  "Quadratdezimeter",  1e-2, false/*true*/); // Metric, but not commonly used
+    //addUnit("Quadratdezimeter", SQUARE_METRE,  "Quadratdezimeter",  1e-2, false/*true*/); // Metric, but not commonly used
     addUnit("Quadratzentimeter", SQUARE_METRE, "Quadratzentimeter", 1e-4, true);
     addUnit("Quadratmillimeter", SQUARE_METRE, "Quadratmillimeter", 1e-6, true);
     addUnit("Quadratmikrometer", SQUARE_METRE, "Quadratmikrometer", 1e-12, true);
     addUnit("Quadratnanometer", SQUARE_METRE,  "Quadratnanometer",  1e-18, true);
 
     addUnit("Kubikmeter", CUBIC_METRE,     "Kubikmeter",      1, true);
     addUnit("Kubikkilometer", CUBIC_METRE, "Kubikkilometer",  1e9, true);
-    addUnit("Kubikdezimeter", CUBIC_METRE, "Kubikdezimeter",  1e-3, false/*true*/); // Metric, but not commonly used
+    //addUnit("Kubikdezimeter", CUBIC_METRE, "Kubikdezimeter",  1e-3, false/*true*/); // Metric, but not commonly used
     addUnit("Kubikzentimeter", CUBIC_METRE,"Kubikzentimeter", 1e-6, true);
     addUnit("Kubikmillimeter", CUBIC_METRE,"Kubikmillimeter", 1e-9, true);
     addUnit("Kubikmikrometer", CUBIC_METRE,"Kubikmikrometer", 1e-18, true);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/OfficeTools.java
Patch:
@@ -64,7 +64,7 @@ class OfficeTools {
   public static final String ZERO_WIDTH_SPACE = "\u200B";  // Used to mark footnotes
   public static final String LOG_LINE_BREAK = System.lineSeparator();  //  LineBreak in Log-File (MS-Windows compatible)
   public static final int MAX_SUGGESTIONS = 15;  // Number of suggestions maximal shown in LO/OO
-  public static final int NUMBER_TEXTLEVEL_CACHE = 2;  // Number of caches for matches of text level rules
+  public static final int NUMBER_TEXTLEVEL_CACHE = 4;  // Number of caches for matches of text level rules
 
   
   public static int DEBUG_MODE_SD = 0;

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -177,6 +177,7 @@ public void testRule() throws IOException {
     assertGood("🙂 Übrigens finde ich dein neues Ordnungssystem richtig genial!");
     assertGood("Ein 10,4 Ah Lithium-Akku");
     assertGood("14:15 Uhr SpVgg Westheim");
+    assertGood("Unser Wärmestrom-Tarif WärmeKompakt im Detail");  // ignore so we don't suggest "wärmeKompakt" (#3779)
     assertGood("Autohaus Dornig GmbH");
     assertGood("Hans Pries GmbH");
 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -183,6 +183,9 @@ ProofreadingResult getCheckResults(String paraText, Locale locale, ProofreadingR
       SingleProofreadingError[] sErrors = null;
       paraNum = getParaPos(nPara, paraText, locale, paRes.nStartOfSentencePosition);
       this.paraNum = paraNum;
+      if (paraNum >= docCache.size()) {
+        paraNum = -1;
+      }
       if (nPara >= 0) {
         isDialogRequest.add(paraNum);
         isIntern = true;

File: languagetool-dev/src/main/java/org/languagetool/dev/simulation/DocProvider.java
Patch:
@@ -26,7 +26,7 @@
  */
 class DocProvider {
 
-  private static final int MAX_VAL = 40_000;
+  private static final int MAX_VAL = 20_000;
 
   private final List<String> docs;
 

File: languagetool-core/src/main/java/org/languagetool/rules/CleanOverlappingFilter.java
Patch:
@@ -1,5 +1,5 @@
 /* LanguageTool, a natural language style checker
- * Copyright (C) 2016 Jaume Ortolà (http://www.languagetool.org)
+ * Copyright (C) 2016 Jaume Ortolà
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/FindSuggestionsFilter.java
Patch:
@@ -1,5 +1,5 @@
 /* LanguageTool, a natural language style checker 
- * Copyright (C) 2020 Jaume Ortolà (http://www.danielnaber.de)
+ * Copyright (C) 2020 Jaume Ortolà
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/FindSuggestionsFilter.java
Patch:
@@ -1,5 +1,5 @@
 /* LanguageTool, a natural language style checker 
- * Copyright (C) 2020 Jaume Ortolà (http://www.danielnaber.de)
+ * Copyright (C) 2020 Jaume Ortolà
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/InterrogativeVerbFilter.java
Patch:
@@ -1,5 +1,5 @@
 /* LanguageTool, a natural language style checker 
- * Copyright (C) 2020 Jaume Ortolà (http://www.danielnaber.de)
+ * Copyright (C) 2020 Jaume Ortolà
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/SuggestionsFilter.java
Patch:
@@ -1,5 +1,5 @@
 /* LanguageTool, a natural language style checker 
- * Copyright (C) 2020 Jaume Ortolà (http://www.danielnaber.de)
+ * Copyright (C) 2020 Jaume Ortolà
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -138,7 +138,7 @@ class SingleDocument {
     }
     resetCache();
     ignoredMatches = new IgnoredMatches();
-    if (config != null && config.saveLoCache() && xComponent != null) {
+    if (config != null && config.saveLoCache() && xComponent != null && !mDocHandler.isTestMode()) {
       readCaches();
     }
   }

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/UnitConversionRuleUSTest.java
Patch:
@@ -49,6 +49,8 @@ public void match() throws IOException {
     helper.assertMatches("It's 1/4 mile away", 0, null, rule, lt);
     helper.assertMatches("A 2:1 cup", 0, null, rule, lt);
     helper.assertMatches("1⁄4 cup", 0, null, rule, lt);
+    // matched by special case in the case as long as "x ft y inch" is not parsed properly:
+    helper.assertMatches("It is 0.76 metres (2 ft 6 inch)", 0, null, rule, lt);
   }
 
 }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -807,6 +807,7 @@ private int changesInNumberOfParagraph(boolean getCurNum) {
     }
     resetTo++;
     sentencesCache.removeAndShift(from, to, docCache.size() - oldDocCache.size());
+    this.docCache = docCache;
     if (useQueue) {
       for (int i = 0; i < minToCheckPara.size(); i++) {
         if (minToCheckPara.get(i) != 0) {
@@ -821,7 +822,6 @@ private int changesInNumberOfParagraph(boolean getCurNum) {
     if (debugMode > 0) {
       MessageHandler.printToLogFile("Number FlatParagraphs: " + nFParas + "; docID: " + docID);
     }
-    this.docCache = docCache;
     if (nFParas < docCache.textSize()) {
       return -1;   // try to get ViewCursor position for proof info unknown
     }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LanguageToolMenus.java
Patch:
@@ -66,7 +66,9 @@ public class LanguageToolMenus {
   private Configuration config;
   private boolean switchOff;
   private boolean isRemote;
+  @SuppressWarnings("unused")
   private LTHeadMenu ltHeadMenu;
+  @SuppressWarnings("unused")
   private ContextMenuInterceptor ltContextMenu;
 
   LanguageToolMenus(XComponentContext xContext, SingleDocument document, Configuration config) {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -135,6 +135,7 @@ public void run() {
       return;
     }
     try {
+//      documents.setLtDialogIsRunning(true);
       LtCheckDialog checkDialog = new LtCheckDialog(xContext);
       checkDialog.show();
     } catch (Throwable e) {
@@ -1569,6 +1570,7 @@ public void closeDialog() {
       }
       undoList = null;
       documents.setLtDialog(null);
+      documents.setLtDialogIsRunning(false);
       dialog.setVisible(false);
     }
     

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tagging/ca/CatalanTagger.java
Patch:
@@ -37,7 +37,7 @@
  */
 public class CatalanTagger extends BaseTagger {
 
-  private static final Pattern ADJ_PART_FS = Pattern.compile("VMP00SF.|A[QO].[FC][SN].");
+  private static final Pattern ADJ_PART_FS = Pattern.compile("VMP00SF.|A[QO].[FC]S.");
   private static final Pattern VERB = Pattern.compile("V.+");
   //private static final Pattern NOUN = Pattern.compile("NC.+");
   private String variant;

File: languagetool-language-modules/es/src/main/java/org/languagetool/tagging/es/SpanishTagger.java
Patch:
@@ -37,7 +37,7 @@
  */
 public class SpanishTagger extends BaseTagger {
 
-  private static final Pattern ADJ_PART_FS = Pattern.compile("VMP00SF|A[QO].[FC][SN].");
+  private static final Pattern ADJ_PART_FS = Pattern.compile("VMP00SF|A[QO].[FC]S.");
   private static final Pattern VERB = Pattern.compile("V.+");
   private static final Pattern PREFIXES_FOR_VERBS = Pattern.compile("(auto)([^r]...+)",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -413,7 +413,7 @@ public void testDetNounRule() throws IOException {
     assertBad("Er ging ans Luft.");
     assertBad("Eine Niereninsuffizienz führt zur Störungen des Wasserhaushalts.");
     assertBad("Er stieg durchs Fensters.");
-
+    assertBad("Ich habe heute ein Krankenwagen gesehen.");
     // TODO: not yet detected:
     //assertBad("Erst recht wir fleißiges Arbeiter.");
     //assertBad("Erst recht ich fleißiges Arbeiter.");

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -421,7 +421,7 @@ void resetDocument() {
   void readCaches() {
     if (numParasToCheck != 0) {
       cacheIO = new CacheIO(xComponent);
-      boolean cacheExist = cacheIO.readAllCaches();
+      boolean cacheExist = cacheIO.readAllCaches(config, mDocHandler);
       if (cacheExist) {
         docCache = cacheIO.getDocumentCache();
         sentencesCache = cacheIO.getSentencesCache();
@@ -436,7 +436,7 @@ void readCaches() {
    */
   void writeCaches() {
     if (numParasToCheck != 0) {
-      cacheIO.saveCaches(xComponent, docCache, sentencesCache, paragraphsCache);
+      cacheIO.saveCaches(xComponent, docCache, sentencesCache, paragraphsCache, config, mDocHandler);
     }
   }
   

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractCheckCaseRule.java
Patch:
@@ -122,7 +122,8 @@ public RuleMatch[] match(AnalyzedSentence sentence) {
   }
 
   private boolean isPunctuationStart(String word) {
-    return StringUtils.equalsAny(word, "\"", "'", "„", "»", "«", "“", "‘", "¡", "¿", "-", "–", "—", "―", "‒");
+    return StringUtils.getDigits(word).length() > 0 // e.g. postal codes
+        || StringUtils.equalsAny(word, "\"", "'", "„", "»", "«", "“", "‘", "¡", "¿", "-", "–", "—", "―", "‒");
   }
 
 

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/CheckCaseRuleTest.java
Patch:
@@ -47,6 +47,7 @@ public void testRule() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("‒ 'Da Vinci'")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("‒ ¡'Da Vinci'!")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("El Prat de Llobregat")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("08820 - El Prat de Llobregat")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("el Prat de Llobregat")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Da Vinci")).length);
     

File: languagetool-standalone/src/test/java/org/languagetool/ShortDescriptionProviderTest.java
Patch:
@@ -53,7 +53,7 @@ public void testDescriptionLength() {
         continue;
       }
       ShortDescriptionProvider provider = new ShortDescriptionProvider();
-      Map<String, String> map = provider.getAllDescriptions(lang);
+      Map<String, String> map = ShortDescriptionProvider.getAllDescriptions(lang);
       for (Map.Entry<String, String> entry : map.entrySet()) {
         String desc = entry.getValue();
         int len = desc.length();

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishPlainEnglishRule.java
Patch:
@@ -77,7 +77,7 @@ public String getShort() {
 
   @Override
   public String getMessage() {
-    return "'$match' is a wordy or complex expression. In some cases, it might be preferable to use $suggestions";
+    return "'$match' is a wordy or complex expression. In some cases, it might be preferable to use $suggestions.";
   }
 
   @Override

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -181,6 +181,7 @@ public GermanCompoundTokenizer(boolean strictMode) throws IOException {
     wordSplitter.addException("Kinderecken", asList("Kinder", "ecken"));
     wordSplitter.addException("Silberecke", asList("Silber", "ecke"));
     wordSplitter.addException("Silberecken", asList("Silber", "ecken"));
+    wordSplitter.addException("Schreibart", asList("Schreib", "art"));
     wordSplitter.setStrictMode(strictMode);
     wordSplitter.setMinimumWordLength(3);
   }

File: languagetool-core/src/main/java/org/languagetool/AnalyzedSentence.java
Patch:
@@ -188,7 +188,7 @@ public String toShortString(String readingDelimiter) {
    */
   public String getText() {
     String result = text;
-    if (text == null) {
+    if (result == null) {
       text = result = calcText();
     }
     return result;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -1315,7 +1315,7 @@ private void addParaErrorsToCache(int nFPara, SwJLanguageTool langTool, int cach
           docCursor = new DocumentCursorTools(xComponent);
         }
         setFlatParagraphTools(xComponent);
-/*
+
         if(override) {
           List<Integer> tmpChangedParas;
           tmpChangedParas = paragraphsCache.get(cacheNum).differenceInCaches(oldCache);
@@ -1332,7 +1332,7 @@ private void addParaErrorsToCache(int nFPara, SwJLanguageTool langTool, int cach
             remarkChangedParagraphs(changedParas, docCursor.getParagraphCursor(), flatPara);
           }
         } else {
-*/        
+        
 //          Map<Integer, SingleProofreadingError[]> changedParasMap;
           if (debugMode > 1) {
             MessageHandler.printToLogFile("Mark paragraphs from " + startPara + " to " + endPara);
@@ -1354,7 +1354,7 @@ private void addParaErrorsToCache(int nFPara, SwJLanguageTool langTool, int cach
             remarkChangedParagraphs(changedParas, docCursor.getParagraphCursor(), flatPara);
           }
 //          flatPara.markParagraphs(changedParasMap, docCache, false, docCursor.getParagraphCursor());
-//        }
+        }
       }
     } catch (Throwable t) {
       MessageHandler.showError(t);

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -201,7 +201,7 @@ protected int getPriorityForId(String id) {
       case "REGIONAL_VERBS": return -10;
       case "FALTA_COMA_FRASE_CONDICIONAL": return -20;
       case "MUNDAR": return -50;
-      case "AGREEMENT_POSTPONED_ADJ_": return -50;
+      case "AGREEMENT_POSTPONED_ADJ": return -50;
       case "NOMBRES_ROMANS": return -90;
       case "MORFOLOGIK_RULE_CA_ES": return -100;
       case "EXIGEIX_ACCENTUACIO_VALENCIANA": return -120;

File: languagetool-core/src/main/java/org/languagetool/rules/GRPCRule.java
Patch:
@@ -311,9 +311,9 @@ public String getDescription() {
     };
   }
 
-  public static List<GRPCRule> createAll(List<RemoteRuleConfig> configs, boolean inputLogging, String defaultDescription) {
+  public static List<GRPCRule> createAll(List<RemoteRuleConfig> configs, boolean inputLogging, String prefix, String defaultDescription) {
     return configs.stream()
-      .filter(cfg -> cfg.getRuleId().startsWith("AI_"))
+      .filter(cfg -> cfg.getRuleId().startsWith(prefix))
       .map(cfg -> create(cfg, inputLogging, cfg.getRuleId(), defaultDescription, Collections.emptyMap()))
       .collect(Collectors.toList());
   }

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikMultiSpeller.java
Patch:
@@ -129,7 +129,7 @@ public MorfologikMultiSpeller(String binaryDictPath, BufferedReader plainTextRea
     List<MorfologikSpeller> spellers = new ArrayList<>();
     MorfologikSpeller userDictSpeller = getUserDictSpellerOrNull(userWords, binaryDictPath, maxEditDistance);
     if (userDictSpeller != null) {
-      // add this first, as otherwise suggestions from user's won dictionary might drown in the mass of other suggestions
+      // add this first, as otherwise suggestions from user's own dictionary might drown in the mass of other suggestions
       spellers.add(userDictSpeller);
       userDictSpellers = Collections.singletonList(userDictSpeller);
     } else {

File: languagetool-language-modules/ca/src/test/java/org/languagetool/tokenizers/ca/CatalanWordTokenizerTest.java
Patch:
@@ -137,7 +137,9 @@ public void testTokenize() {
     tokens = wordTokenizer.tokenize("AVALUA'T");
     assertEquals(tokens.size(), 2);
     assertEquals("[AVALUA, 'T]", tokens.toString());
-    
+    tokens = wordTokenizer.tokenize("Tel-Aviv");
+    assertEquals(tokens.size(), 1);
+    assertEquals("[Tel-Aviv]", tokens.toString());
 
   }
 }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ConfigThread.java
Patch:
@@ -71,6 +71,7 @@ public void run() {
         documents.setDisabledRules(disabledRulesUI);
         config.removeDisabledRuleIds(disabledRulesUI);
         config.saveConfiguration(docLanguage);
+        documents.resetDocumentCaches();
         documents.resetConfiguration();
       } else {
         config.removeDisabledRuleIds(documents.getDisabledRules());

File: languagetool-core/src/main/java/org/languagetool/rules/Rule.java
Patch:
@@ -307,7 +307,7 @@ public final List<ErrorTriggeringExample> getErrorTriggeringExamples() {
   /**
    * @return a category (never null since LT 3.4)
    */
-  public final Category getCategory() {
+  public Category getCategory() {
     return category;
   }
 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -58,6 +58,7 @@
 import org.languagetool.JLanguageTool;
 import org.languagetool.Language;
 import org.languagetool.Languages;
+import org.languagetool.gui.Configuration;
 import org.languagetool.gui.Tools;
 
 import com.sun.star.beans.PropertyState;
@@ -153,7 +154,8 @@ private DocumentCache updateDocumentCache(XComponent xComponent, DocumentCursorT
       } else {
         flatPara.init();
       }
-      docCache = new DocumentCache(docCursor, flatPara, -1);
+      Configuration config = documents.getConfiguration();
+      docCache = new DocumentCache(docCursor, flatPara, -1, config == null ? null : LinguisticServices.getLocale(config.getDefaultLanguage()));
     }
     return docCache;
   }

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -50,7 +50,6 @@
  * @author Marcin Miłkowski
  */
 public class HunspellRule extends SpellingCheckRule {
-  private static final Logger logger = LoggerFactory.getLogger(HunspellRule.class);
 
   public static final String RULE_ID = "HUNSPELL_RULE";
 

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseBarbarismsRule.java
Patch:
@@ -98,7 +98,7 @@ public Locale getLocale() {
   @Override
   protected boolean isTokenException(AnalyzedTokenReadings atr) {
     // proper nouns tagged in multiwords are exceptions
-    return atr.hasPosTagStartingWith("NP") || atr.isImmunized() || atr.isIgnoredBySpeller();
+    return atr.hasPosTagStartingWith("NP") || atr.isImmunized();
   }
 
 }

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -169,6 +169,8 @@ public GermanCompoundTokenizer(boolean strictMode) throws IOException {
     wordSplitter.addException("Wanderarbeiten", asList("Wander", "arbeiten"));
     wordSplitter.addException("Taucherarbeiten", asList("Taucher", "arbeiten"));
     wordSplitter.addException("Hauptakteurin", asList("Haupt", "akteurin"));
+    wordSplitter.addException("Kleiderecke", asList("Kleider", "ecke"));
+    wordSplitter.addException("Kleiderecken", asList("Kleider", "ecken"));
     wordSplitter.setStrictMode(strictMode);
     wordSplitter.setMinimumWordLength(3);
   }

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Configuration.java
Patch:
@@ -73,7 +73,7 @@ public class Configuration {
   static final boolean DEFAULT_MARK_SINGLE_CHAR_BOLD = false;
   static final boolean DEFAULT_USE_LT_DICTIONARY = true;
   static final boolean DEFAULT_NO_SYNONYMS_AS_SUGGESTIONS = true;
-  static final boolean DEFAULT_SAVE_LO_CACHE = false;
+  static final boolean DEFAULT_SAVE_LO_CACHE = true;
 
   static final Color STYLE_COLOR = new Color(0, 175, 0);
 

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -745,7 +745,6 @@ private URL internUrl(String s) throws MalformedURLException {
     URL url = internedUrls.get(s);
     if (url == null) {
       url = new URL(s);
-      url = new URL(internString(url.getProtocol()), internString(url.getHost()), url.getPort(), internString(url.getFile()));
       internedUrls.put(s, url);
     }
     return url;

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -147,6 +147,7 @@ public void testRule() throws IOException {
     assertGood("Das schaffen moderne und effizientere E-Autos schneller.");
     assertGood("Das verwalten User.");
     assertGood("Man kann das generalisieren");
+    assertGood("Aber wie wir das machen und sicher gestalten, darauf konzentriert sich unsere Arbeit.");
     assertGood("Vielleicht kann man das erweitern");
     assertGood("Vielleicht soll er das generalisieren");
     assertGood("Wahrscheinlich müssten sie das überarbeiten");

File: languagetool-language-modules/fr/src/test/java/org/languagetool/rules/fr/MorfologikFrenchSpellerRuleTest.java
Patch:
@@ -165,10 +165,12 @@ public void testMorfologikSpeller() throws IOException {
     assertSuggestion(rule, langTool, "buvezen", "buvez-en");
     assertSuggestion(rule, langTool, "avaisje", "avais-je");
     assertSuggestion(rule, langTool, "damazon", "d'Amazon", "d'amazone", "d'Amazone");
+    assertSuggestion(rule, langTool, "deja", "déjà", "d'EA");
+    assertSuggestion(rule, langTool, "depeche-toi", "dépêchè", "dépêché", "dépêche", "d'empêché", "d'évêché", "repêché");
     
     // to improve
     assertSuggestion(rule, langTool, "language", "l'engage", "l'engagé", "l'aiguage", "langage");
-    assertSuggestion(rule, langTool, "depeche-toi", "d'empêché", "d'évêché", "dépêche");
+    
     
     // don't split prefixes 
     matches = rule.match(langTool.getAnalyzedSentence("macrodiscipline"));

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/EnglishUnpairedBracketsRuleTest.java
Patch:
@@ -110,14 +110,13 @@ public void testRule() throws IOException {
     assertIncorrect("This is not so (neither a nor b");
     assertIncorrect("This is not so neither a nor b)");
     assertIncorrect("This is not so neither foo nor bar)");
-    assertIncorrect("Click the \"Check text button");
 
     // this is currently considered incorrect... although people often use smileys this way:
     assertIncorrect("Some text (and some funny remark :-) with more text to follow");
 
     RuleMatch[] matches;
     matches = rule.match(Collections.singletonList(langTool.getAnalyzedSentence("(This is a test” sentence.")));
-    assertEquals(2, matches.length);
+    assertEquals(1, matches.length);
     matches = rule.match(Collections.singletonList(langTool.getAnalyzedSentence("This [is (a test} sentence.")));
     assertEquals(3, matches.length);
   }

File: languagetool-commandline/src/test/java/org/languagetool/commandline/MainTest.java
Patch:
@@ -433,7 +433,7 @@ public void testEnglishFileAPI() throws Exception {
     assertTrue(output.indexOf("<?xml version=\"1.0\" encoding=\"UTF-8\"?>") == 0);
     assertTrue(output.contains("<error fromy=\"0\" fromx=\"8\" toy=\"0\" tox=\"10\" ruleId=\"EN_A_VS_AN\" " +
         "msg=\"Use &apos;a&apos; instead of &apos;an&apos; if the following word doesn&apos;t start with a vowel sound, e.g. &apos;a sentence&apos;, " +
-        "&apos;a university&apos;\" " +
+        "&apos;a university&apos;.\" " +
         "shortmsg=\"Wrong article\" " +
         "replacements=\"a\" context=\"This is an test.  This is a test of of language tool.  ...\" " +
         "contextoffset=\"8\" offset=\"8\" errorlength=\"2\" category=\"Miscellaneous\" categoryid=\"MISC\" locqualityissuetype=\"misspelling\"/>"));

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -543,7 +543,7 @@ final boolean hasLocale(Locale locale) {
   private void setConfigValues(Configuration config, SwJLanguageTool langTool) {
     this.config = config;
     this.langTool = langTool;
-    if (useQueue && config.getNumParasToCheck() == 0) {
+    if (textLevelQueue != null && config.getNumParasToCheck() == 0) {
       textLevelQueue.setStop();
       textLevelQueue = null;
     }

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternToken.java
Patch:
@@ -109,8 +109,8 @@ public class PatternToken implements Cloneable {
    */
   public PatternToken(String token, boolean caseSensitive, boolean regExp, boolean inflected) {
     this.caseSensitive = caseSensitive;
-    this.stringRegExp = regExp;
     this.inflected = inflected;
+    stringRegExp = regExp;
     setStringElement(token);
   }
 
@@ -698,7 +698,7 @@ public boolean isUnificationNeutral() {
    * @since 2.5
    */
   public void setUnificationNeutral() {
-    this.unificationNeutral = true;
+    unificationNeutral = true;
   }
 
 
@@ -797,7 +797,7 @@ private Set<String> calcOwnPossibleStringValues() {
   }
 
   @Nullable
-  Set<String> getPossibleRegexpValues(String stringToken) {
+  static Set<String> getPossibleRegexpValues(String stringToken) {
     if (StringUtils.containsAny(stringToken, "()*+.\\^${}")) {
       return null;
     }

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternTokenTest.java
Patch:
@@ -189,16 +189,16 @@ public void testNegation() {
   @Test
   public void testFormHints() {
     PatternToken token = new PatternTokenBuilder().tokenRegex("an?|the|th[eo]se").build();
-    assertEquals(token.calcFormHints(), Sets.newHashSet("a", "an", "the", "these", "those"));
+    assertEquals(Sets.newHashSet("a", "an", "the", "these", "those"), token.calcFormHints());
 
     token = new PatternTokenBuilder().token("foo").build();
-    assertEquals(token.calcFormHints(), Sets.newHashSet("foo"));
+    assertEquals(Sets.newHashSet("foo"), token.calcFormHints());
 
     token = new PatternTokenBuilder().tokenRegex("(foo)?.*").build();
     assertNull(token.calcFormHints());
 
     token = new PatternTokenBuilder().csTokenRegex("a|b").build();
-    assertEquals(token.calcFormHints(), Sets.newHashSet("a", "b"));
+    assertEquals(Sets.newHashSet("a", "b"), token.calcFormHints());
 
     token = new PatternTokenBuilder().token("a").min(0).build();
     assertNull(token.calcFormHints());

File: languagetool-core/src/main/java/org/languagetool/language/UnicodeBasedLangIdentifier.java
Patch:
@@ -89,7 +89,7 @@ List<String> getAdditionalLangCodes(String str) {
     if ((float)cjkChars / significantChars >= THRESHOLD) {
       langCodes.add("zh");
       langCodes.add("ja");
-      // Korean is not supported by LT, do we don't add it
+      // Korean is not supported by LT, so we don't add it
     }
     if ((float)khmerChars / significantChars >= THRESHOLD) {
       langCodes.add("km");

File: languagetool-language-modules/de/src/main/java/org/languagetool/synthesis/GermanSynthesizer.java
Patch:
@@ -66,6 +66,9 @@ public String[] synthesize(AnalyzedToken token, String posTag, boolean posTagReg
   @NotNull
   private String[] getCompoundForms(AnalyzedToken token, String posTag, boolean posTagRegExp) throws IOException {
     List<String> parts = splitter.tokenize(token.getLemma());
+    if (parts.size() == 0) {
+      return parts.toArray(new String[0]);
+    }
     String firstPart = String.join("", parts.subList(0, parts.size() - 1));
     String lastPart = StringTools.uppercaseFirstChar(parts.get(parts.size() - 1));
     AnalyzedToken lastPartToken = new AnalyzedToken(lastPart, posTag, lastPart);

File: languagetool-language-modules/de/src/test/java/org/languagetool/synthesis/GermanSynthesizerTest.java
Patch:
@@ -51,6 +51,7 @@ public void testSynthesize() throws IOException {
     assertThat(synth("Äußerung", "SUB:NOM:PLU:MAS"), is("[]"));
     assertThat(synth("Haus", "SUB:AKK:PLU:NEU"), is("[Häuser]"));
     assertThat(synth("Haus", ".*", true), is("[Häuser, Haus, Häusern, Haus, Hause, Häuser, Hauses, Häuser, Haus]"));
+    assertThat(synthesizer.synthesize(new AnalyzedToken("fake", "FAKE", null), "FAKE", false).length, is(0));  // could happen with soft hyphen in the input
   }
 
   @Test

File: languagetool-core/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -43,6 +43,7 @@ public class WordListValidatorTest {
   // allow them in general:
   private static final Set<String> VALID_WORDS = new HashSet<>(Arrays.asList(
           "Będzin",
+          "Aydın",
           "Bhagavad-gītā",
           "Sønderjylland/S",
           "Božena/S",

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -1490,6 +1490,7 @@ private CheckError getNextError(boolean startAtBegin) {
       docCache = updateDocumentCache(xComponent, docCursor, currentDocument);
       if (docCache.size() <= 0) {
         MessageHandler.printToLogFile("getNextError: docCache size == 0: Return null");
+        return null;
       }
       y = viewCursor.getViewCursorParagraph();
       if (y >= docCache.textSize()) {

File: languagetool-language-modules/de/src/main/java/org/languagetool/synthesis/GermanSynthesizer.java
Patch:
@@ -65,7 +65,7 @@ public String[] synthesize(AnalyzedToken token, String posTag, boolean posTagReg
 
   @NotNull
   private String[] getCompoundForms(AnalyzedToken token, String posTag, boolean posTagRegExp) throws IOException {
-    List<String> parts = splitter.tokenize(token.getToken());
+    List<String> parts = splitter.tokenize(token.getLemma());
     String firstPart = String.join("", parts.subList(0, parts.size() - 1));
     String lastPart = StringTools.uppercaseFirstChar(parts.get(parts.size() - 1));
     AnalyzedToken lastPartToken = new AnalyzedToken(lastPart, posTag, lastPart);

File: languagetool-language-modules/de/src/test/java/org/languagetool/synthesis/GermanSynthesizerTest.java
Patch:
@@ -46,6 +46,7 @@ public void testSynthesizeX() throws IOException {
 
   @Test
   public void testSynthesize() throws IOException {
+    assertThat(synth("Buschfeuer", "SUB:GEN:SIN:NEU"), is("[Buschfeuers]"));
     assertThat(synth("Äußerung", "SUB:NOM:PLU:FEM"), is("[Äußerungen]"));
     assertThat(synth("Äußerung", "SUB:NOM:PLU:MAS"), is("[]"));
     assertThat(synth("Haus", "SUB:AKK:PLU:NEU"), is("[Häuser]"));

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -1047,7 +1047,7 @@ public GermanSpellerRule(ResourceBundle messages, German language, UserConfig us
   }
 
   @Override
-  protected void init() throws IOException {
+  protected synchronized void init() throws IOException {
     super.init();
     super.ignoreWordsWithLength = 1;
     String pattern = "(" + nonWordPattern.pattern() + "|(?<=[\\d°])-|-(?=\\d+))";

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/SwissGermanSpellerRule.java
Patch:
@@ -52,7 +52,7 @@ public String getId() {
   }
 
   @Override
-  protected void init() throws IOException {
+  protected synchronized void init() throws IOException {
     super.init();
     for (String ignoreWord : wordListLoader.loadWords("/de/hunspell/spelling-de-CH.txt")) {
       addIgnoreWords(ignoreWord);

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerTest.java
Patch:
@@ -124,7 +124,7 @@ void runTestsV2() throws IOException, SAXException, ParserConfigurationException
     //assertTrue(checkV2(english, german, "My handy is broken.").contains("EN_FOR_DE_SPEAKERS_FALSE_FRIENDS"));  // only works with ngrams
     assertFalse(checkV2(english, german, "We will berate you").contains("BERATE"));  // not active anymore now that we have EN_FOR_DE_SPEAKERS_FALSE_FRIENDS
     assertTrue(plainTextCheck("/v2/check", german, english, "Man sollte ihn nicht so beraten.", "&level=picky").contains("BERATE"));
-    assertTrue(checkV2(polish, english, "To jest frywolne.").contains("FRIVOLOUS"));
+    assertTrue(plainTextCheck("/v2/check", polish, english, "To jest frywolne.", "&level=picky").contains("FRIVOLOUS"));
       
     //test for no changed if no options set
     String[] nothing = {};

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/wikipedia/WikipediaQuickCheckTest.java
Patch:
@@ -73,9 +73,9 @@ public void testCheckWikipediaMarkup() throws IOException {
     assertThat(firstAppliedMatch.getRuleMatchApplications().size(), is(1));
     RuleMatchApplication ruleMatchApplication = firstAppliedMatch.getRuleMatchApplications().get(0);
     assertTrue("Got: " + ruleMatchApplication.getTextWithCorrection(),
-            ruleMatchApplication.getTextWithCorrection().contains("<err>wegen dem</err> Leerzeichen."));
-    assertThat(ruleMatchApplication.getOriginalErrorContext(12), is("st richtig, <err>wegen dem</err> Leerz"));
-    assertThat(ruleMatchApplication.getCorrectedErrorContext(12), is("st richtig, <err>wegen dem</err> Leerz"));
+            ruleMatchApplication.getTextWithCorrection().contains("<err>wegen des Leerzeichens.</err>"));
+    assertThat(ruleMatchApplication.getOriginalErrorContext(12), is("st richtig, <err>wegen dem Leerzeichen.</err>"));
+    assertThat(ruleMatchApplication.getCorrectedErrorContext(12), is("st richtig, <err>wegen des Leerzeichens.</err>"));
   }
 
   @Test

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -884,6 +884,7 @@ enum GrammarCategory {
   private static final Set<String> PRONOUNS_TO_BE_IGNORED = new HashSet<>(Arrays.asList(
     "ich",
     "dir",
+    "dich",
     "du",
     "er", "sie", "es",
     "wir",
@@ -925,7 +926,7 @@ enum GrammarCategory {
     "Piepen", // Die Piepen
     "Badlands",
     "Visual", // englisch
-    "Chief", // Chief Excutive Officer
+    "Chief", // Chief Executive Officer
     "Carina", // Name
     "Wüstenrot", // Name
     "Meter", // Das Meter (Objekt zum Messen)

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -146,6 +146,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Es sind jegliche tierische Nahrungsmittel untersagt.");
     assertGood("Das reicht bis weit ins heutige Hessen.");
     assertGood("Die Customer Journey.");
+    assertGood("Für dich gehört Radfahren zum perfekten Urlaub dazu?");
     //assertGood("... der zu dieser Zeit aber ohnehin schon allen Einfluss verloren hatte.");
 
     assertGood("Wir machen das Januar.");

File: languagetool-core/src/main/java/org/languagetool/language/LanguageIdentifier.java
Patch:
@@ -216,7 +216,7 @@ public DetectedLanguage detectLanguage(String text, List<String> noopLangsTmp, L
     if (fastText != null || ngram != null) {
       try {
         // do *not* use TextObjectFactory because of https://github.com/languagetool-org/languagetool/issues/1278
-        // (using it for optimize is okay, assuming the same strong normalization was applied during training):
+        // (using it for optimaize is okay, assuming the same strong normalization was applied during training):
         shortText = ImprovedUrlTextFilter.getInstance().filter(shortText);
         shortText = new RemoveEMailSignatureFilter().filter(shortText);
         shortText = new RemoveNonBreakingSpaces().filter(shortText);

File: languagetool-core/src/main/java/org/languagetool/language/NGramLangIdentifier.java
Patch:
@@ -146,7 +146,7 @@ private List<String> readLines(String path) {
       }
     }
     catch(java.io.IOException e) {
-      // TODO
+      throw new RuntimeException(e);
     }
     return result;
   }

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/GrammalecteRule.java
Patch:
@@ -162,6 +162,9 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
   private List<RuleMatch> parseJson(InputStream inputStream) throws IOException {
     Map map = mapper.readValue(inputStream, Map.class);
     List matches = (ArrayList) map.get("data");
+    if (matches == null) {
+      throw new RuntimeException("No 'data' found in grammalecte JSON: " + map);  // handled in match()
+    }
     List<RuleMatch> result = new ArrayList<>();
     for (Object match : matches) {
       List<RuleMatch> remoteMatches = getMatches((Map<String, Object>)match);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/DuUpperLowerCaseRule.java
Patch:
@@ -46,7 +46,7 @@ public class DuUpperLowerCaseRule extends TextLevelRule {
                         "eurem", "euerem", "eures", "eueres")
   );
   private static final Set<String> ambiguousWords = new HashSet<>(
-          Arrays.asList("ihr", "ihre", "ihren", "ihrem", "ihres", "ihrer")
+          Arrays.asList("ihr")
   );
   
   public DuUpperLowerCaseRule(ResourceBundle messages) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/DuUpperLowerCaseRuleTest.java
Patch:
@@ -43,6 +43,7 @@ public void testRule() throws IOException {
     assertErrors("Du bist noch jung, du bist noch fit.", 0);
     assertErrors("Aber du bist noch jung, du bist noch fit.", 0);
     assertErrors("Aber du bist noch jung, dir ist das egal.", 0);
+    assertErrors("Hast Du ihre Brieftasche gesehen?", 0);
 
     assertErrors("Aber Du bist noch jung, du bist noch fit.", 1);
     assertErrors("Aber Du bist noch jung, dir ist das egal.", 1);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LanguageToolMenus.java
Patch:
@@ -80,7 +80,8 @@ public class LanguageToolMenus {
   
   void setConfigValues(Configuration config) {
     this.config = config;
-    switchOff = config.isSwitchedOff();
+//    switchOff = config.isSwitchedOff();
+    switchOff = config.noBackgroundCheck();
     isRemote = config.doRemoteCheck();
   }
   

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LtDictionary.java
Patch:
@@ -205,6 +205,9 @@ public String[] getUserDictionaries(XComponentContext xContext) {
       return null;
     }
     XDictionary[] dictionaryList = searchableDictionaryList.getDictionaries();
+    if (listIgnoredWords == null) {
+      listIgnoredWords = dictionaryList[dictionaryList.length - 1];
+    }
     List<String> userDictionaries = new ArrayList<String>();
     for (XDictionary dictionary : dictionaryList) {
       String name = dictionary.getName();

File: languagetool-core/src/main/java/org/languagetool/rules/LanguageDependentFilter.java
Patch:
@@ -43,7 +43,7 @@ public LanguageDependentFilter(Language lang, Set<String> enabledRules, Set<Cate
 
   @Override
   public List<RuleMatch> filter(List<RuleMatch> ruleMatches) {
-    if (language.getShortCode() == "ca") {
+    if (language.getShortCode().equals("ca")) {
       // Use typographic apostrophe in suggestions
       CategoryId catID = new CategoryId("DIACRITICS_TRADITIONAL");
       if (this.enabledRules.contains("APOSTROF_TIPOGRAFIC") 
@@ -62,8 +62,8 @@ public List<RuleMatch> filter(List<RuleMatch> ruleMatches) {
               newReplacements.add(s);
             }
           }
-          RuleMatch newrm = new RuleMatch(rm, newReplacements);
-          newRuleMatches.add(newrm);
+          RuleMatch newMatch = new RuleMatch(rm, newReplacements);
+          newRuleMatches.add(newMatch);
         }
         return newRuleMatches;
       }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -205,7 +205,7 @@ ProofreadingResult getCheckResults(String paraText, Locale locale, ProofreadingR
     if(switchOff) {
       return paRes;
     }
-    paRes = documents.get(docNum).getCheckResults(paraText, paRes, propertyValues, docReset, langTool);
+    paRes = documents.get(docNum).getCheckResults(paraText, locale, paRes, propertyValues, docReset, langTool);
     if(langTool.doReset()) {
       // langTool.doReset() == true: if server connection is broken ==> switch to internal check
       MessageHandler.showMessage(messages.getString("loRemoteSwitchToLocal"));

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SpellAndGrammarCheckDialog.java
Patch:
@@ -391,7 +391,7 @@ SingleProofreadingError getNextGrammatikErrorInParagraph(int x, int y, String te
       paRes.nStartOfSentencePosition = paRes.nStartOfNextSentencePosition;
       paRes.nStartOfNextSentencePosition = text.length();
       paRes.nBehindEndOfSentencePosition = paRes.nStartOfNextSentencePosition;
-      paRes = document.getCheckResults(text, paRes, propertyValues, false, langTool, y);
+      paRes = document.getCheckResults(text, locale, paRes, propertyValues, false, langTool, y);
       if (paRes.aErrors != null) {
         for (SingleProofreadingError error : paRes.aErrors) {
           if (error.nErrorStart >= x) {

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -200,6 +200,7 @@ protected int getPriorityForId(String id) {
       case "MUCHO_NF": return 25; // greater than AGREEMENT_DET_NOUN
       case "AGREEMENT_DET_NOUN": return 20;
       //case "PRONOMBRE_SIN_VERBO": return 20;
+      case "P_EJ": return 20;
       case "ESPACIO_DESPUES_DE_PUNTO": return 15;
       case "AGREEMENT_DET_ADJ": return 10;
       case "TYPOGRAPHY": return 10;

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -209,9 +209,10 @@ public class VerbAgreementRule extends TextLevelRule {
      token("ich")
     ),
     Arrays.asList( // Geh du mal!
-      pos("SENT_START"),
+      pos(JLanguageTool.SENTENCE_START_TAGNAME),
       posRegex("VER:IMP:SIN.+"),
-      csToken("du")
+      csToken("du"),
+      new PatternTokenBuilder().csToken("?").negate().build()
     )
   );
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SubjectVerbAgreementRuleTest.java
Patch:
@@ -302,7 +302,8 @@ public void testRuleWithCorrectSingularVerb() throws IOException {
         "Knapp acht Monate ist die Niederlage nun her.",
         "Vier Monate ist die Niederlage nun her.",
         "Sie liebt Kunst und Kunst war auch kein Problem, denn er würde das Geld zurückkriegen.",
-        "Bei komplexen und andauernden Störungen ist der Stress-Stoffwechsel des Hundes entgleist."
+        "Bei komplexen und andauernden Störungen ist der Stress-Stoffwechsel des Hundes entgleist.",
+        "Eltern ist der bisherige Kita-Öffnungsplan zu unkonkret"
     );
     for (String sentence : sentences) {
       assertGood(sentence);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -126,6 +126,7 @@ public void testWrongVerb() throws IOException {
     assertGood("Tom bezahle ich gut.");
     assertGood("Tom werde ich nicht noch mal um Hilfe bitten.");
     assertGood("Tom konnte ich überzeugen, nicht aber Maria.");
+    assertGood("Mach du mal!");
     // incorrect sentences:
     assertBad("Als Borcarbid weißt es eine hohe Härte auf.");
     assertBad("Das greift auf Vorläuferinstitutionen bist auf die Zeit von 1234 zurück.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -393,7 +393,9 @@ else if (hasUnambiguouslyPersonAndNumber(tokens[i], "2", "SIN") && !"Probst".equ
     if (posVer1Sin != -1 && posIch == -1 && !isQuotationMark(tokens[posVer1Sin-1])) { // 1st pers sg verb but no "ich"
       ruleMatches.add(ruleMatchWrongVerb(tokens[posVer1Sin], pos, sentence));
     } else if (posIch > 0 && !isNear(posPossibleVer1Sin, posIch) // check whether verb next to "ich" is 1st pers sg
-               && (tokens[posIch].getToken().equals("ich") || tokens[posIch].getStartPos() <= 1 || (tokens[posIch].getToken().equals("Ich") && posIch >= 2 && tokens[posIch-2].getToken().equals(":"))) // ignore "lyrisches Ich" etc.
+               && (tokens[posIch].getToken().equals("ich") || tokens[posIch].getStartPos() <= 1 ||
+                   (tokens[posIch].getToken().equals("Ich") && posIch >= 2 && tokens[posIch-2].getToken().equals(":")) ||
+                   (tokens[posIch].getToken().equals("Ich") && posIch >= 1 && tokens[posIch-1].getToken().equals(":"))) // ignore "lyrisches Ich" etc.
                && (!isQuotationMark(tokens[posIch-1]) || posIch < 3 || (posIch > 1 && tokens[posIch-2].getToken().equals(":")))) {
       int plus1 = ((posIch + 1) == tokens.length) ? 0 : +1; // prevent posIch+1 segfault
       BooleanAndFiniteVerb check = verbDoesMatchPersonAndNumber(tokens[posIch - 1], tokens[posIch + plus1], "1", "SIN", finiteVerb);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -393,9 +393,7 @@ else if (hasUnambiguouslyPersonAndNumber(tokens[i], "2", "SIN") && !"Probst".equ
     if (posVer1Sin != -1 && posIch == -1 && !isQuotationMark(tokens[posVer1Sin-1])) { // 1st pers sg verb but no "ich"
       ruleMatches.add(ruleMatchWrongVerb(tokens[posVer1Sin], pos, sentence));
     } else if (posIch > 0 && !isNear(posPossibleVer1Sin, posIch) // check whether verb next to "ich" is 1st pers sg
-               && (tokens[posIch].getToken().equals("ich") || tokens[posIch].getStartPos() <= 1 ||
-                   (tokens[posIch].getToken().equals("Ich") && posIch >= 2 && tokens[posIch-2].getToken().equals(":")) ||
-                   (tokens[posIch].getToken().equals("Ich") && posIch >= 1 && tokens[posIch-1].getToken().equals(":"))) // ignore "lyrisches Ich" etc.
+               && (tokens[posIch].getToken().equals("ich") || tokens[posIch].getStartPos() <= 1 || (tokens[posIch].getToken().equals("Ich") && posIch >= 2 && tokens[posIch-2].getToken().equals(":"))) // ignore "lyrisches Ich" etc.
                && (!isQuotationMark(tokens[posIch-1]) || posIch < 3 || (posIch > 1 && tokens[posIch-2].getToken().equals(":")))) {
       int plus1 = ((posIch + 1) == tokens.length) ? 0 : +1; // prevent posIch+1 segfault
       BooleanAndFiniteVerb check = verbDoesMatchPersonAndNumber(tokens[posIch - 1], tokens[posIch + plus1], "1", "SIN", finiteVerb);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -134,8 +134,6 @@ public void testWrongVerb() throws IOException {
     assertBad("Sie sagte zu mir: „Du muss gehen.“");
     assertBad("„Ich müsst alles machen.“");
     assertBad("„Ich könnt mich sowieso nicht verstehen.“");
-    assertBad("Er sagte düster: Ich brauchen mich nicht böse angucken.");
-    assertBad("David sagte düster: Ich brauchen mich nicht böse angucken.");
   }
 
   @Test

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/MissingCommaRelativeClauseRule.java
Patch:
@@ -71,8 +71,8 @@ public class MissingCommaRelativeClauseRule extends Rule {
       Arrays.asList(
         csToken("am"),
         pos("ADJ:PRD:SUP"),
-        csToken("von"),
-        regex("d(e[mnr]|e([nr]|ss)en)")
+        posRegex("PRP:.+"),
+        regex("d(e[mnr]|ie|as|e([nr]|ss)en)")
       )
   );
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/MissingCommaRelativeClauseRuleTest.java
Patch:
@@ -50,6 +50,7 @@ public void testMatch() throws Exception {
     assertNoMatch("Als dritte Gruppe lassen sich Aminosäuren fassen, die der Organismus anstelle dieser in Proteine einbaut.", rule, lt);
     assertNoMatch("Selbst wenn das alles perfekt verlustfrei wäre, hätte ich nichts gewonnen.", rule, lt);
     assertNoMatch("Die Studenten, deren Urteil am stärksten von dem der Profis abwich, waren sich sicher, einen guten von einem schlechten unterscheiden zu können.", rule, lt);
+    assertNoMatch("Die Studenten, deren Urteil am stärksten durch das der Profis beeinflusst wurde, waren sich sicher, einen guten von einem schlechten unterscheiden zu können.", rule, lt);
 
     rule = new MissingCommaRelativeClauseRule(TestTools.getMessages("de"), true);
     

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/MissingCommaRelativeClauseRuleTest.java
Patch:
@@ -49,6 +49,7 @@ public void testMatch() throws Exception {
     assertNoMatch("Ebenso darf keine schwerere Strafe als die zum Zeitpunkt der Begehung der strafbaren Handlung angedrohte Strafe verhängt werden.", rule, lt);
     assertNoMatch("Als dritte Gruppe lassen sich Aminosäuren fassen, die der Organismus anstelle dieser in Proteine einbaut.", rule, lt);
     assertNoMatch("Selbst wenn das alles perfekt verlustfrei wäre, hätte ich nichts gewonnen.", rule, lt);
+    assertNoMatch("Die Studenten, deren Urteil am stärksten von dem der Profis abwich, waren sich sicher, einen guten von einem schlechten unterscheiden zu können.", rule, lt);
 
     rule = new MissingCommaRelativeClauseRule(TestTools.getMessages("de"), true);
     

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/TextLevelCheckQueue.java
Patch:
@@ -363,7 +363,7 @@ public QueueIterator() {
     }
     
     public void initLangtool(Language language) {
-      langTool = multiDocHandler.initLanguageTool(language);
+      langTool = multiDocHandler.initLanguageTool(language, false);
       multiDocHandler.initCheck(langTool, multiDocHandler.getLocale());
       multiDocHandler.activateTextRulesByIndex(1, langTool);
     }

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -692,7 +692,7 @@ DetectedLanguage detectLanguageOfString(String text, String fallbackLanguage, Li
       mode = "ngram";
     } else {
       detected = fastTextIdentifier.detectLanguage(text, noopLangs, preferredLangs);
-      mode = "fasttext";
+      mode = fastTextIdentifier.isFastTextEnabled() ? "fasttext" : "built-in";
     }
     long t2 = System.nanoTime();
     float runTime = (t2-t1)/1000.0f/1000.0f;

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -332,7 +332,7 @@ else if (token.length() < 20) {
           }
         }
       } else if (token.length() > 1 && token.codePointCount(0, token.length()) != token.length()) {
-        // some symbols such as emojis (😂) have a string length that equals 2 
+        // some symbols such as emojis (😂) have a string length larger than 1 
         List<String> emojis = EmojiParser.extractEmojis(token);
         for (String emoji : emojis) {
           token = StringUtils.replace(token, emoji, WHITESPACE_ARRAY[emoji.length()]);

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -287,7 +287,7 @@ protected List<RuleMatch> getRuleMatches(String word, int startPos, AnalyzedSent
     // Check for split word with previous word
     if (idx > 0 && tokens[idx].isWhitespaceBefore()) {
       String prevWord = tokens[idx - 1].getToken();
-      if (prevWord.length() > 0 && !prevWord.matches(".*\\d.*")
+      if (prevWord.length() > 0 && !StringUtils.containsAny(prevWord, "0", "1", "2", "3", "4", "5", "6", "7", "8", "9")
           && getFrequency(speller1, prevWord) < MAX_FREQUENCY_FOR_SPLITTING) {
         int prevStartPos = tokens[idx - 1].getStartPos();
         // "thanky ou" -> "thank you"

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -1131,7 +1131,7 @@ public List<String> getSuggestions(String word) throws IOException {
           if (lastPart.length() > 3 && !isMisspelled(lastPart)) {
             // as these are only single words and both the first part and the last part are spelled correctly
             // (but the combination is not), it's okay to log the words from a privacy perspective:
-            logger.info("UNKNOWN: " + word);
+            logger.info("UNKNOWN: {}", word);
           }
         }
       }
@@ -1425,7 +1425,7 @@ private List<String> getAdditionalTopSuggestionsString(List<String> suggestions,
         return Collections.singletonList(suggestion);
       }
     } else if (word.matches("koregier.+")) {
-      suggestion = word.replaceAll("reg", "rrig");
+      suggestion = word.replace("reg", "rrig");
       if (hunspell.spell(suggestion)) {
         return Collections.singletonList(suggestion);
       }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -393,7 +393,9 @@ else if (hasUnambiguouslyPersonAndNumber(tokens[i], "2", "SIN") && !"Probst".equ
     if (posVer1Sin != -1 && posIch == -1 && !isQuotationMark(tokens[posVer1Sin-1])) { // 1st pers sg verb but no "ich"
       ruleMatches.add(ruleMatchWrongVerb(tokens[posVer1Sin], pos, sentence));
     } else if (posIch > 0 && !isNear(posPossibleVer1Sin, posIch) // check whether verb next to "ich" is 1st pers sg
-               && (tokens[posIch].getToken().equals("ich") || tokens[posIch].getStartPos() <= 1 || (tokens[posIch].getToken().equals("Ich") && posIch >= 2 && tokens[posIch-2].getToken().equals(":"))) // ignore "lyrisches Ich" etc.
+               && (tokens[posIch].getToken().equals("ich") || tokens[posIch].getStartPos() <= 1 ||
+                   (tokens[posIch].getToken().equals("Ich") && posIch >= 2 && tokens[posIch-2].getToken().equals(":")) ||
+                   (tokens[posIch].getToken().equals("Ich") && posIch >= 1 && tokens[posIch-1].getToken().equals(":"))) // ignore "lyrisches Ich" etc.
                && (!isQuotationMark(tokens[posIch-1]) || posIch < 3 || (posIch > 1 && tokens[posIch-2].getToken().equals(":")))) {
       int plus1 = ((posIch + 1) == tokens.length) ? 0 : +1; // prevent posIch+1 segfault
       BooleanAndFiniteVerb check = verbDoesMatchPersonAndNumber(tokens[posIch - 1], tokens[posIch + plus1], "1", "SIN", finiteVerb);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -134,6 +134,8 @@ public void testWrongVerb() throws IOException {
     assertBad("Sie sagte zu mir: „Du muss gehen.“");
     assertBad("„Ich müsst alles machen.“");
     assertBad("„Ich könnt mich sowieso nicht verstehen.“");
+    assertBad("Er sagte düster: Ich brauchen mich nicht böse angucken.");
+    assertBad("David sagte düster: Ich brauchen mich nicht böse angucken.");
   }
 
   @Test

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/spelling/hunspell/HunspellRuleTest.java
Patch:
@@ -55,7 +55,7 @@ public void testRuleWithGerman() throws Exception {
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Unter http://foo.org/bar steht dasdassda.")).length);
     
     // check the correct calculation of error position
-    // note that emojis have string length 2
+    // note that emojis have string length 2 or 3
     assertEquals(6 ,rule.match(langTool.getAnalyzedSentence("Hallo men Schatz!"))[0].getFromPos());
     assertEquals(9 ,rule.match(langTool.getAnalyzedSentence("Hallo men Schatz!"))[0].getToPos());
     assertEquals(9 ,rule.match(langTool.getAnalyzedSentence("Hallo 😂 men Schatz!"))[0].getFromPos());
@@ -64,6 +64,8 @@ public void testRuleWithGerman() throws Exception {
     assertEquals(14 ,rule.match(langTool.getAnalyzedSentence("Hallo 😂😂 men Schatz!"))[0].getToPos());
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Mir geht es 😂gut😂.")).length);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Mir geht es 😂gtu😂.")).length);
+    assertEquals(10 ,rule.match(langTool.getAnalyzedSentence("Hallo 🗺️ men Schatz!"))[0].getFromPos());
+    assertEquals(13 ,rule.match(langTool.getAnalyzedSentence("Hallo 🗺️ men Schatz!"))[0].getToPos());
   }
 
   @Test

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikAmericanSpellerRuleTest.java
Patch:
@@ -101,6 +101,7 @@ public void testMorfologikSpeller() throws IOException {
     assertEquals(0, rule.match(lt.getAnalyzedSentence("I like my emoji 😾")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("μ")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("I like my emoji ❤️")).length);
+    assertEquals(0, rule.match(lt.getAnalyzedSentence("This is English text 🗺.")).length);
 
     // test words in language-specific spelling_en-US.txt
     assertEquals(0, rule.match(lt.getAnalyzedSentence("USTestWordToBeIgnored")).length);

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Configuration.java
Patch:
@@ -1349,7 +1349,7 @@ public void saveConfiguration(Language lang) throws IOException {
           props.setProperty(prefix + LANGUAGE_KEY, language.getShortCodeWithCountryAndVariant());
         }
         if (motherTongue != null) {
-          props.setProperty(prefix + MOTHER_TONGUE_KEY, motherTongue.getShortCode());
+          props.setProperty(prefix + MOTHER_TONGUE_KEY, motherTongue.getShortCodeWithCountryAndVariant());
         }
         if (ngramDirectory != null) {
           props.setProperty(prefix + NGRAM_DIR_KEY, ngramDirectory.getAbsolutePath());

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -1110,6 +1110,9 @@ public void trigger(String sEvent) {
         }
         checkDialog.start();
       } else if ("nextError".equals(sEvent)) {
+        if(docLanguage == null) {
+          docLanguage = getLanguage();
+        }
         SpellAndGrammarCheckDialog checkDialog = new SpellAndGrammarCheckDialog(xContext, this, docLanguage);
         checkDialog.nextError();
       } else if ("remoteHint".equals(sEvent)) {

File: languagetool-core/src/main/java/org/languagetool/language/NGramLangIdentifier.java
Patch:
@@ -234,12 +234,10 @@ private Double knp(int a, int b, int tmI) {
     Map<String, Integer> tmS = this.bigramSumsPre.get(tmI);
     Map<String, Integer> tmSd = this.bigramSumsPost.get(tmI);
 
-
-
     int xaCnt = tmS.getOrDefault("" + b, 0);
     int axCnt = tmSd.getOrDefault("" + a, 0);
     int bigramsTotal = tm.size();
-    int unigramCnt = tm.getOrDefault("0_" + a, 1);
+    int unigramCnt = tmU.getOrDefault("0_" + a, 1);
     int bigramCnt = tm.getOrDefault(a + "_" + b, 1);
 
     double d = 0.75;

File: languagetool-dev/src/test/java/org/languagetool/dev/eval/LanguageDetectionMinLengthEval.java
Patch:
@@ -49,7 +49,7 @@ class LanguageDetectionMinLengthEval {
 
   private LanguageDetectionMinLengthEval() {
     languageIdentifier = new LanguageIdentifier();
-    languageIdentifier.setTest(true);
+    languageIdentifier.enableNgrams(new File("/home/languagetool/ngram-lang-id"));
     //languageIdentifier = new CLD2Identifier();
     //languageIdentifier.enableFasttext(new File("/path/to/fasttext/binary"), new File("/path/to/fasttext/model"));
     // Daniel's paths:

File: languagetool-language-modules/nl/src/main/java/org/languagetool/language/Dutch.java
Patch:
@@ -39,7 +39,7 @@
 
 public class Dutch extends Language {
 
-  private static final Language NETHERLANDS_DUTCH = new NetherlandsDutch();
+  private static final Language NETHERLANDS_DUTCH = new Dutch();
 
   private LanguageModel languageModel;
 
@@ -191,6 +191,7 @@ protected int getPriorityForId(String id) {
   public List<String> getRuleFileNames() {
     List<String> ruleFileNames = super.getRuleFileNames();
     String dirBase = JLanguageTool.getDataBroker().getRulesDir() + "/" + getShortCode() + "/";
+    ruleFileNames.add(dirBase + "nl-NL/grammar.xml");
     ruleFileNames.add(dirBase + "grammar-test-1.xml");
     return ruleFileNames;
   }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -424,8 +424,8 @@ public void testDetNounRuleErrorMessages() throws IOException {
     assertBadWithMessage("Das Fahrrads.", "des Kasus");
     assertBadWithMessage("Der Fahrrad.", "des Genus");
     assertBadWithMessage("Das Fahrräder.", "des Numerus");
-    assertBadWithMessage("Die Tischen sind ecking.", "des Kasus");
-    assertBadWithMessage("Die Tischen sind ecking.", "und Genus");
+    assertBadWithMessage("Die Tischen sind eckig.", "des Kasus");
+    assertBadWithMessage("Die Tischen sind eckig.", "und Genus");
     //TODO: input is actually correct
     assertBadWithMessage("Bei dem Papierabzüge von Digitalbildern bestellt werden.", "des Kasus, Genus oder Numerus.");
   }

File: languagetool-core/src/main/java/org/languagetool/tokenizers/WordTokenizer.java
Patch:
@@ -52,7 +52,7 @@ public class WordTokenizer implements Tokenizer {
       + "\u2028\u2029\u202a\u202b\u202c\u202d\u202e\u202f"
       + "\u205F\u2060\u2061\u2062\u2063\u206A\u206b\u206c\u206d"
       + "\u206E\u206F\u3000\u3164\ufeff\uffa0\ufff9\ufffa\ufffb"
-      + ",.;()[]{}=*#∗×·+÷<>!?:/|\\\"'«»„”“`´‘’‛′›‹…¿¡→‼⁇⁈⁉_"
+      + ",.;()[]{}=*#∗×·+÷<>!?:/|\\\"'«»„”“`´‘’‛′›‹…¿¡→‼⁇⁈⁉_™®"
       + "—"  // em dash
       + "\t\n\r";
 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ResultCache.java
Patch:
@@ -294,7 +294,7 @@ SingleProofreadingError getErrorAtPosition(int numPara, int numChar) {
     SingleProofreadingError error = null;
     for(int sentenceStart : sentenceEntries.keySet()) {
       int sentenceNext = sentenceEntries.getNextSentencePosition(sentenceStart);
-      if(sentenceStart <= numChar &&  (sentenceNext == 0 || sentenceNext <= numChar)) {
+      if(sentenceStart <= numChar &&  (sentenceNext == 0 || sentenceNext >= numChar)) {
         for(SingleProofreadingError err : sentenceEntries.getErrorArray(sentenceStart)) {
           if(numChar >= err.nErrorStart && numChar <= err.nErrorStart + err.nErrorLength) {
             if(error == null || error.nErrorStart < err.nErrorStart
@@ -415,6 +415,7 @@ SingleProofreadingError toSingleProofreadingError () {
         error.nErrorType = nErrorType;
         error.aFullComment = aFullComment;
         error.aRuleIdentifier = aRuleIdentifier;
+//        MessageHandler.printToLogFile("toSingleProofreadingError: ruleID: " + aRuleIdentifier + ", Start = " + nErrorStart + ", Length = " + nErrorLength);
         error.aShortComment = aShortComment;
         error.aSuggestions = aSuggestions;
         if (aProperties != null) {

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/PortugueseWordRepeatBeginningRuleTest.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.junit.Test;
 import org.languagetool.JLanguageTool;
+import org.languagetool.TestTools;
 import org.languagetool.language.Portuguese;
 
 import java.io.IOException;
@@ -35,6 +36,7 @@ public class PortugueseWordRepeatBeginningRuleTest {
   @Test
   public void testRule() throws IOException {
     JLanguageTool lt = new JLanguageTool(new Portuguese());
+    TestTools.disableAllRulesExcept(lt, "PORTUGUESE_WORD_REPEAT_BEGINNING_RULE");
     // correct sentences:
     assertEquals(0, lt.check("Este exemplo está correto. Este exemplo também está.").size());
     assertEquals(0, lt.check("2011: Setembro já passou. 2011: Outubro também já passou. 2011: Novembro já se foi.").size());

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CompoundInfinitivRule.java
Patch:
@@ -146,7 +146,7 @@ private boolean isMisspelled(String word) {
     } else if (linguServices != null) {
       return !linguServices.isCorrectSpell(word, lang);
     }
-    return false;
+    return true;
   }
 
   private boolean isRelevant(AnalyzedTokenReadings token) {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -43,7 +43,7 @@ public class Main extends WeakBase implements XJobExecutor,
   // Service name required by the OOo API && our own name.
   private static final String[] SERVICE_NAMES = {
           "com.sun.star.linguistic2.Proofreader",
-          "org.languagetool.openoffice.Main" };
+          OfficeTools.LT_SERVICE_NAME };
 
   private XComponentContext xContext;
   private MultiDocumentsHandler documents;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -27,7 +27,6 @@
 import java.util.ResourceBundle;
 import java.util.Set;
 
-import javax.swing.JDialog;
 import javax.swing.JOptionPane;
 import javax.swing.UIManager;
 
@@ -975,7 +974,7 @@ public void runOptionsDialog() {
   /**
    * @return An array of Locales supported by LT
    */
-  public final Locale[] getLocales() {
+  public final static Locale[] getLocales() {
     try {
       List<Locale> locales = new ArrayList<>();
       for (Language lang : Languages.get()) {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/OfficeTools.java
Patch:
@@ -46,6 +46,7 @@
  */
 class OfficeTools {
   
+  public static final String LT_SERVICE_NAME = "org.languagetool.openoffice.Main";
   public static final int PROOFINFO_UNKNOWN = 0;
   public static final int PROOFINFO_GET_PROOFRESULT = 1;
   public static final int PROOFINFO_MARK_PARAGRAPH = 2;

File: languagetool-core/src/main/java/org/languagetool/rules/GRPCRule.java
Patch:
@@ -51,7 +51,7 @@
  * Base class fur rules running on external servers;
  * see gRPC service definition in languagetool-core/src/main/proto/ml_server.proto
  *
- * @see #create(ResourceBundle, RemoteRuleConfig, String, String, Map)  for an easy to add rules; return rule in Language::getRelevantRemoteRules
+ * @see #create(ResourceBundle, RemoteRuleConfig, boolean, String, String, Map)  for an easy to add rules; return rule in Language::getRelevantRemoteRules
  * add it like this:
   <pre>
    public List&lt;Rule&gt; getRelevantRemoteRules(ResourceBundle messageBundle, List&lt;RemoteRuleConfig&gt; configs, GlobalConfig globalConfig, UserConfig userConfig, Language motherTongue, List&lt;Language&gt; altLanguages) throws IOException {

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/RussianWordRootRepeatRule.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.rules.ru;
 
+import org.languagetool.Experimental;
 import org.languagetool.rules.AbstractWordCoherencyRule;
 import org.languagetool.rules.Example;
 import org.languagetool.rules.WordCoherencyDataLoader;
@@ -29,10 +30,10 @@
 
 /**
  * WordRootRepeatRule. Experimental.
- * @Experimental
  * @author Yakov Reztsov
  * @since 5.1
  */
+@Experimental
 public class RussianWordRootRepeatRule extends AbstractWordCoherencyRule {
 
   private static final Map<String, Set<String>> wordMap = new WordCoherencyDataLoader().loadWords("/ru/wordrootrep.txt");

File: languagetool-standalone/src/test/java/org/languagetool/rules/en/EnglishForL2SpeakersFalseFriendRuleTest.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.rules.en;
 
+import org.junit.Ignore;
 import org.junit.Test;
 import org.languagetool.*;
 import org.languagetool.broker.ResourceDataBroker;
@@ -43,6 +44,7 @@
 public class EnglishForL2SpeakersFalseFriendRuleTest {
 
   @Test
+  @Ignore("had problems with running it locally (false-friends.xml not found)")
   public void testMessageDetailData() throws IOException {
     List<String> langs = Arrays.asList("nl", "de", "fr", "es");
     //List<String> langs = Arrays.asList("es");
@@ -74,7 +76,7 @@ private Map<String, List<ConfusionPair>> getFalseFriendNgramData(Language en, St
   private Set<String> getFalseFriendsDetailData(Language en, String l1Code) throws IOException {
     Language l1 = Languages.getLanguageForShortCode(l1Code);
     FalseFriendRuleLoader ruleLoader = new FalseFriendRuleLoader(l1);
-    String ffFilename = JLanguageTool.getDataBroker().getFromRulesDirAsUrl(FALSE_FRIEND_FILE).toString().replace("file:", "");
+    String ffFilename = JLanguageTool.getDataBroker().getRulesDir() + "/" + FALSE_FRIEND_FILE;
     List<AbstractPatternRule> rules = ruleLoader.getRules(new File(ffFilename), en, l1);
     Set<String> patternsWithDetails = new HashSet<>();
     for (AbstractPatternRule rule : rules) {

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/PostponedAdjectiveConcordanceFilter.java
Patch:
@@ -98,7 +98,7 @@ public class PostponedAdjectiveConcordanceFilter extends RuleFilter {
   private static final Pattern ADVERBIS_ACCEPTATS = Pattern.compile("RG_before");
   //private static final Pattern COORDINACIO = Pattern.compile(",|y|e|o|u");
   private static final Pattern COORDINACIO_IONI = Pattern.compile("y|e|o|u|ni");
-  private static final Pattern KEEP_COUNT = Pattern.compile("A.*|N.*|D[NAIDP].*|SPS.*|SP\\+DA|.*LOC_ADV.*|V.P.*|_PUNCT.*|.*LOC_ADJ.*|PX.*|PI0.S000|UNKNOWN|V.N.*");
+  private static final Pattern KEEP_COUNT = Pattern.compile("A.*|N.*|D[NAIDP].*|SPS.*|SP\\+DA|.*LOC_ADV.*|V.P.*|_PUNCT.*|.*LOC_ADJ.*|PX.*|PI0.S000|UNKNOWN|V.N.{4}");
   private static final Pattern KEEP_COUNT2 = Pattern.compile(",|y|e|o|ni|u"); // |\\d+%?|%
   private static final Pattern STOP_COUNT = Pattern.compile(";|lo");
   private static final Pattern PREPOSICIONS = Pattern.compile("SP.*");

File: languagetool-dev/src/main/java/org/languagetool/dev/httpchecker/CheckCallable.java
Patch:
@@ -84,8 +84,6 @@ public File call() throws Exception {
       int i = 0;
       for (String text : texts) {
         URL url = Tools.getUrl(baseUrl + "/v2/check");
-        //printOut("----------------");
-        //printOut("textToCheck: " + text);
         String postData = "language=" + langCode +
             "&text=" + URLEncoder.encode(text, "UTF-8") +
             "&level=picky" +

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/MorfologikFrenchSpellerRule.java
Patch:
@@ -39,7 +39,7 @@ public final class MorfologikFrenchSpellerRule extends MorfologikSpellerRule {
       "^(non|en|a|le|la|les|pour|de|du|des|un|une|mon|ma|mes|ton|ta|tes|son|sa|ses|leur|leurs|ce|cet) (..+)$",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
   private static final Pattern PREFIX_AMB_ESPAI = Pattern.compile(
-      "^(auto|ex|extra|macro|mega|meta|micro|multi|mono|mini|post|retro|semi|super|trans) (..+)$",
+      "^(auto|ex|extra|macro|mega|meta|micro|multi|mono|mini|post|retro|semi|super|trans|l|d) (..+)$",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
 
   private static final Pattern APOSTROF_INICI_VERBS = Pattern.compile("^([lnts])(h?[aeiouàéèíòóú].*[^è])$",

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/PostponedAdjectiveConcordanceFilter.java
Patch:
@@ -46,6 +46,8 @@ public class PostponedAdjectiveConcordanceFilter extends RuleFilter {
    * Patterns
    */
 
+  private final int maxLevels = 4;
+  
   private static final Pattern NOM = Pattern.compile("N.*");
   private static final Pattern NOM_MS = Pattern.compile("N.MS.*");
   private static final Pattern NOM_FS = Pattern.compile("N.FS.*");
@@ -132,7 +134,6 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     boolean canBeP = false;
     /* Count all nouns and determiners before the adjectives */
     // Takes care of acceptable combinations.
-    int maxLevels = 4;
     int[] cNt = new int[maxLevels];
     int[] cNMS = new int[maxLevels];
     int[] cNFS = new int[maxLevels];

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/PostponedAdjectiveConcordanceFilter.java
Patch:
@@ -45,6 +45,8 @@ public class PostponedAdjectiveConcordanceFilter extends RuleFilter {
   /**
    * Patterns
    */
+  
+  private final int maxLevels = 4;
 
   private static final Pattern NOM = Pattern.compile("N.*");
   private static final Pattern NOM_MS = Pattern.compile("N.MS.*|PI0MS000");
@@ -133,7 +135,6 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     boolean canBeP = false;
     /* Count all nouns and determiners before the adjectives */
     // Takes care of acceptable combinations.
-    int maxLevels = 4;
     int[] cNt = new int[maxLevels];
     int[] cNMS = new int[maxLevels];
     int[] cNFS = new int[maxLevels];

File: languagetool-core/src/main/java/org/languagetool/rules/CommaWhitespaceRule.java
Patch:
@@ -152,7 +152,7 @@ private boolean isDomain(AnalyzedTokenReadings[] tokens, int i) {
   }
 
   private boolean isFileExtension(AnalyzedTokenReadings[] tokens, int i) {
-    return i < tokens.length && tokens[i].getToken().matches("(?i)[a-z]{3,4}|ai|mp[34]");
+    return i < tokens.length && tokens[i].getToken().matches("[a-z]{3,4}|[A-Z]{3,4}|ai|mp[34]");
   }
 
   private static boolean isWhitespaceToken(AnalyzedTokenReadings token) {

File: languagetool-core/src/test/java/org/languagetool/rules/CommaWhitespaceRuleTest.java
Patch:
@@ -60,6 +60,7 @@ public void testRule() throws IOException {
     assertMatches("I'd recommend resaving the .DOC as a PDF file.", 0);
     assertMatches("I'd recommend resaving the .mp3 as a WAV file.", 0);
     assertMatches("I'd suggest buying the .org domain.", 0);
+    assertMatches("I live in .Los Angeles", 1);
 
     // errors:
     assertMatches("This,is a test sentence.", 1);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -1234,7 +1234,7 @@ private boolean ignoreElative(String word) {
     if (StringUtils.startsWithAny(word, "bitter", "dunkel", "erz", "extra", "früh",
         "gemein", "hyper", "lau", "mega", "minder", "stock", "super", "tod", "ultra", "ur")) {
       String lastPart = RegExUtils.removePattern(word, "^(bitter|dunkel|erz|extra|früh|gemein|grund|hyper|lau|mega|minder|stock|super|tod|ultra|ur|voll)");
-      return !isMisspelled(lastPart);
+      return lastPart.length() >= 3 && !isMisspelled(lastPart);
     }
     return false;
   }
@@ -1262,7 +1262,7 @@ protected boolean ignoreWord(List<String> words, int idx) throws IOException {
       }
       ignoreHyphenatedCompound = !ignoreByHyphen && ignoreCompoundWithIgnoredWord(words.get(idx));
     }
-    return ignore || ignoreUncapitalizedWord || ignoreByHyphen || ignoreHyphenatedCompound || ignoreElative(words.get(0));
+    return ignore || ignoreUncapitalizedWord || ignoreByHyphen || ignoreHyphenatedCompound || ignoreElative(words.get(idx));
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/FalseFriendRuleHandler.java
Patch:
@@ -162,7 +162,7 @@ public void endElement(String namespaceURI, String sName,
           translations.add(translation);
         }
         if (currentTranslationLanguage != null && currentTranslationLanguage.equalsConsiderVariantsIfSpecified(textLanguage)
-                && language.equalsConsiderVariantsIfSpecified(motherTongue)) {
+                && language.equalsConsiderVariantsIfSpecified(motherTongue) && !suggestions.contains(translation.toString())) {
           suggestions.add(translation.toString());
         }
         translation = new StringBuilder();

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -237,6 +237,8 @@ public List<Rule> getRelevantLanguageModelCapableRules(ResourceBundle messages,
   @Override
   public boolean hasNGramFalseFriendRule(Language motherTongue) {
     return motherTongue != null && (
+      // Note: extend EnglishForL2SpeakersFalseFriendRuleTest.testMessageDetailData()
+      // if you add a language here
       "de".equals(motherTongue.getShortCode()) ||
       "fr".equals(motherTongue.getShortCode()) ||
       "es".equals(motherTongue.getShortCode()) ||

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishForDutchmenFalseFriendRule.java
Patch:
@@ -21,15 +21,14 @@
 import org.jetbrains.annotations.NotNull;
 import org.languagetool.Language;
 import org.languagetool.languagemodel.LanguageModel;
-import org.languagetool.rules.Example;
 
 import java.util.Collections;
 import java.util.List;
 import java.util.ResourceBundle;
 
 /**
- * False friends for German native speakers who write English text, based on ngrams.
- * @since 4.6
+ * False friends for Dutch native speakers who write English text, based on ngrams.
+ * @since 5.1
  */
 public class EnglishForDutchmenFalseFriendRule extends EnglishForL2SpeakersFalseFriendRule {
 

File: languagetool-language-modules/ru/src/main/java/org/languagetool/language/Russian.java
Patch:
@@ -140,7 +140,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
         //  new EmptyLineRule(messages, this),  // too picky rule 
             new LongSentenceRule(messages, userConfig),
             new LongParagraphRule(messages, this, userConfig),
-            new ParagraphRepeatBeginningRule(messages, this),
+        //    new ParagraphRepeatBeginningRule(messages, this),   //temp disable rule, issue #3509
             new RussianFillerWordsRule(messages, this, userConfig),
         //  new PunctuationMarkAtParagraphEnd(messages, this),
             new PunctuationMarkAtParagraphEnd2(messages, this),  //

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/RuleMatchDiffFinder.java
Patch:
@@ -196,7 +196,7 @@ private void printRuleIdCol(FileWriter fw, LightRuleMatch oldMatch, LightRuleMat
     if (newMatch.getTags().size() > 0) {
       fw.write("  <br><span class='status'>" + newMatch.getTags() + "</span>");
     }
-    if (oldMatch != null && newMatch.getTags() != oldMatch.getTags()) {
+    if (oldMatch != null && !newMatch.getTags().equals(oldMatch.getTags())) {
       fw.write("  <br><span class='status'>" + oldMatch.getTags() + " => " + newMatch.getTags() + "</span>");
     }
     fw.write(" </td>\n");

File: languagetool-core/src/main/java/org/languagetool/rules/ngrams/ConfusionProbabilityRule.java
Patch:
@@ -177,7 +177,6 @@ public RuleMatch[] match(AnalyzedSentence sentence) {
                 continue;
               }
               if (!isLocalException(sentence, googleToken)) {
-                System.out.println("MATCH " + googleToken);
                 String term1 = confusionPair.getTerms().get(0).getString();
                 String term2 = confusionPair.getTerms().get(1).getString();
                 String id = getId() + "_" + cleanId(term1) +  "_" + cleanId(term2);

File: languagetool-language-modules/de/src/main/java/org/languagetool/tagging/de/VerbPrefixes.java
Patch:
@@ -39,7 +39,7 @@ public class VerbPrefixes {
     "dabei", "dafür", "dagegen", "daher", "dahin", "dahinter", "daneben", "daran", "darauf", "darein", "darüber", "darunter",
     "hinter", "dran", "drauf", "drein", "drüber", "drunter",
     "davon", "davor", "dazu", "dazwischen",
-    "durch", "über", "unter", "um", "wider", "wieder", "rüber", "aneinander",
+    "durch", "über", "unter", "um", "wider", "wieder", "rüber", "aneinander", "ran", "rauf", "runter", "rein",
     // not listed in source above (deutschegrammatik20.de):
     "umher", "ent", "frei", "ver", "zer", "gegen"
   );

File: languagetool-language-modules/ar/src/test/java/org/languagetool/rules/ar/ArabicWordCoherencyRuleTest.java
Patch:
@@ -47,7 +47,7 @@ public void before() {
   @Test
   public void testRule() throws IOException {
     // errors:
-    assertError("أنا أظن أن هذا ممكن لكنني أضن أنني كنت مخطئا");
+    //assertError("أنا أظن أن هذا ممكن لكنني أضن أنني كنت مخطئا");
   }
   
   private void assertError(String s) throws IOException {

File: languagetool-language-modules/de/src/main/java/org/languagetool/tagging/de/VerbPrefixes.java
Patch:
@@ -39,7 +39,7 @@ public class VerbPrefixes {
     "dabei", "dafür", "dagegen", "daher", "dahin", "dahinter", "daneben", "daran", "darauf", "darein", "darüber", "darunter",
     "hinter", "dran", "drauf", "drein", "drüber", "drunter",
     "davon", "davor", "dazu", "dazwischen",
-    "durch", "über", "unter", "um", "wider", "wieder",
+    "durch", "über", "unter", "um", "wider", "wieder", "rüber",
     // not listed in source above (deutschegrammatik20.de):
     "umher", "ent", "frei", "ver", "zer", "gegen"
   );

File: languagetool-core/src/main/java/org/languagetool/chunking/ChunkTaggedToken.java
Patch:
@@ -43,19 +43,19 @@ public ChunkTaggedToken(String token, List<ChunkTag> chunkTags, AnalyzedTokenRea
     this.readings = readings;
   }
 
-  String getToken() {
+  public String getToken() {
     return token;
   }
 
-  List<ChunkTag> getChunkTags() {
+  public List<ChunkTag> getChunkTags() {
     return chunkTags;
   }
 
   /**
    * @return readings or {@code null}
    */
   @Nullable
-  AnalyzedTokenReadings getReadings() {
+  public AnalyzedTokenReadings getReadings() {
     return readings;
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/WhiteSpaceBeforeParagraphEnd.java
Patch:
@@ -72,9 +72,9 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
         int lb;
         int lw;
         for (lb = tokens.length - 1; lb > 0 && tokens[lb].isLinebreak(); lb--);
-        for (lw = lb; lw > 0 && tokens[lw].isWhitespace(); lw--);
+        for (lw = lb; lw > 0 && tokens[lw].isWhitespace() && !tokens[lw].getToken().equals("\u200B"); lw--);
         if(lw < lb) {
-          int fromPos = pos + tokens[lw].getStartPos();
+          int fromPos = tokens[lw].isWhitespace() ? pos + tokens[lw + 1].getStartPos() : pos + tokens[lw].getStartPos();
           int toPos = pos + tokens[lb].getEndPos();
           RuleMatch ruleMatch = new RuleMatch(this, sentence, fromPos, toPos, messages.getString("whitespace_before_parapgraph_end_msg"));
           if (lw > 0 && !tokens[lw].isWhitespace()) {

File: languagetool-core/src/main/java/org/languagetool/chunking/ChunkTaggedToken.java
Patch:
@@ -37,7 +37,7 @@ public class ChunkTaggedToken {
   /**
    * @param readings may be null, caused by differences in tokenization we don't always have a 1:1 mapping
    */
-  ChunkTaggedToken(String token, List<ChunkTag> chunkTags, AnalyzedTokenReadings readings) {
+  public ChunkTaggedToken(String token, List<ChunkTag> chunkTags, AnalyzedTokenReadings readings) {
     this.token = Objects.requireNonNull(token);
     this.chunkTags = Objects.requireNonNull(chunkTags);
     this.readings = readings;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -198,6 +198,7 @@ protected int getPriorityForId(String id) {
       case "FALTA_COMA_FRASE_CONDICIONAL": return -20;
       case "MUNDAR": return -50;
       case "MORFOLOGIK_RULE_CA_ES": return -100;
+      case "EXIGEIX_ACCENTUACIO_VALENCIANA": return -120;
       case "SUBSTANTIUS_JUNTS": return -150;
       case "FALTA_ELEMENT_ENTRE_VERBS": return -200;
       case "NOMBRES_ROMANS": return -400;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tokenizers/ca/CatalanWordTokenizer.java
Patch:
@@ -164,6 +164,7 @@ public List<String> tokenize(final String text) {
                     + "\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007"
                     + "\u2008\u2009\u200A\u200B\u200c\u200d\u200e\u200f"
                     + "\u2012\u2013\u2014\u2015\u2022"
+                    + "\u2500\u3161" // other dashes
                     + "\u2028\u2029\u202a\u202b\u202c\u202d\u202e\u202f"
                     + "\u203C\u205F\u2060\u2061\u2062\u2063\u206A\u206b\u206c\u206d"
                     + "\u206E\u206F\u3000\u3164\ufeff\uffa0\ufff9\ufffa\ufffb"

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationPatternRuleReplacer.java
Patch:
@@ -29,7 +29,6 @@
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.AnalyzedToken;
 import org.languagetool.AnalyzedTokenReadings;
-import org.languagetool.chunking.ChunkTag;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.rules.patterns.*;
 import org.languagetool.tools.StringTools;

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/SpellingData.java
Patch:
@@ -28,7 +28,7 @@
 import java.util.*;
 
 /**
- * Old to new spelling data and similar formats loaded form CSV.
+ * Old to new spelling data and similar formats loaded from CSV.
  * @since 4.3
  */
 class SpellingData {

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -473,7 +473,7 @@ public List<Rule> getRelevantRemoteRules(ResourceBundle messageBundle, List<Remo
         rules.add(confpairRule);
       }
     }
-    String variantsID = "EN_VARIANTS_MODEL";
+    String variantsID = "AI_EN_VAR";
     RemoteRuleConfig variantsConfig = RemoteRuleConfig.getRelevantConfig(variantsID, configs);
     if (variantsConfig != null) {
       Rule variantsRule = GRPCRule.create(variantsConfig, inputLogging, variantsID,

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -473,7 +473,7 @@ public List<Rule> getRelevantRemoteRules(ResourceBundle messageBundle, List<Remo
         rules.add(confpairRule);
       }
     }
-    String variantsID = "EN_VARIANTS_MODEL";
+    String variantsID = "AI_EN_VAR";
     RemoteRuleConfig variantsConfig = RemoteRuleConfig.getRelevantConfig(variantsID, configs);
     if (variantsConfig != null) {
       Rule variantsRule = GRPCRule.create(variantsConfig, inputLogging, variantsID,

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -190,6 +190,9 @@ public String toAdvancedTypography (String input) {
     
     // non-breaking (thin) space 
     // according to https://fr.wikipedia.org/wiki/Espace_ins%C3%A9cable#En_France
+    output = output.replaceAll("\u00a0;", "\u202f;");
+    output = output.replaceAll("\u00a0!", "\u202f!");
+    output = output.replaceAll("\u00a0\\?", "\u202f?");
     output = output.replaceAll(";", "\u202f;");
     output = output.replaceAll("!", "\u202f!");
     output = output.replaceAll("\\?", "\u202f?");

File: languagetool-dev/src/main/java/org/languagetool/dev/checkLTmessages/checkLTmessages.java
Patch:
@@ -28,7 +28,6 @@
 import org.languagetool.Language;
 import org.languagetool.Languages;
 import org.languagetool.commandline.CommandLineTools;
-import org.languagetool.dev.eval.SpellCheckEvaluation;
 import org.languagetool.rules.Rule;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.tools.StringTools;
@@ -42,7 +41,7 @@ public class checkLTmessages {
   public static void main(String[] args)
       throws IOException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
     if (args.length != 1) {
-      System.out.println("Usage: " + SpellCheckEvaluation.class.getSimpleName() + " <langCode> | ALL");
+      System.out.println("Usage: " + checkLTmessages.class.getSimpleName() + " <langCode> | ALL");
       System.exit(1);
     }
     checkLTmessages check = new checkLTmessages();

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRule.java
Patch:
@@ -263,7 +263,7 @@ List<Integer> getElementNo() {
    * @see org.languagetool.rules.patterns.AbstractPatternRule#getShortMessage()
    */
   @Override
-  String getShortMessage() {
+  public String getShortMessage() {
     return shortMessage;
   }
   

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -41,7 +41,7 @@ public class Catalan extends Language {
 
   private static final Language DEFAULT_CATALAN = new Catalan();
 
-  private static final Pattern APOSTROPHE = Pattern.compile("(\\p{L})'([\\p{L}\u202f\u00a0 !\\?,\\.;:\"«'\\)])",
+  private static final Pattern APOSTROPHE = Pattern.compile("([\\p{L}\\d-])'([\\p{L}\u202f\u00a0 !\\?,\\.;:\"«'\\)])",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
   
   @Override

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -43,7 +43,7 @@ public class Spanish extends Language implements AutoCloseable{
 
   private LanguageModel languageModel;
   
-  private static final Pattern APOSTROPHE = Pattern.compile("(\\p{L})'([\\p{L}\u202f\u00a0 !\\?,\\.;:\\)])",
+  private static final Pattern APOSTROPHE = Pattern.compile("([\\p{L}\\d-])'([\\p{L}\u202f\u00a0 !\\?,\\.;:\\)])",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
 
   @Override

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -45,7 +45,7 @@ public class French extends Language implements AutoCloseable {
 
   private LanguageModel languageModel;
   
-  private static final Pattern APOSTROPHE = Pattern.compile("(\\p{L})'([\\p{L}\u202f\u00a0 !\\?,\\.;:\\\"«'\\)])",
+  private static final Pattern APOSTROPHE = Pattern.compile("([\\p{L}\\d-])'([\\p{L}\u202f\u00a0 !\\?,\\.;:\\\"«'\\)])",
       Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE);
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/rules/LongParagraphRule.java
Patch:
@@ -65,9 +65,8 @@ public LongParagraphRule(ResourceBundle messages, Language lang, UserConfig user
     this(messages, lang, userConfig, defaultWords, DEFAULT_ACTIVATION);
   }
 
-  /** Note: will be off by default. */
   public LongParagraphRule(ResourceBundle messages, Language lang, UserConfig userConfig) {
-    this(messages, lang, userConfig, -1, DEFAULT_ACTIVATION);
+    this(messages, lang, userConfig, -1, true);
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -889,7 +889,7 @@ public List<RuleMatch> check(AnnotatedText annotatedText, boolean tokenizeText,
     unknownWords = new HashSet<>();
     List<AnalyzedSentence> analyzedSentences = analyzeSentences(sentences);
 
-    if (mode != Mode.TEXTLEVEL_ONLY && level == Level.DEFAULT) {
+    if (level == Level.DEFAULT) {
       allRules = allRules.stream().filter(rule -> !rule.hasTag(Tag.picky)).collect(Collectors.toList());
     }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -276,6 +276,7 @@ protected int getPriorityForId(String id) {
       case "GERMAN_SPELLER_RULE": return -3;  // assume most other rules are more specific and helpful than the spelling rule
       case "AUSTRIAN_GERMAN_SPELLER_RULE": return -3;  // assume most other rules are more specific and helpful than the spelling rule
       case "SWISS_GERMAN_SPELLER_RULE": return -3;  // assume most other rules are more specific and helpful than the spelling rule
+      case "PUNCTUATION_PARAGRAPH_END": return -4;  // don't hide spelling mistakes
       case "PUNKT_ENDE_ABSATZ": return -10;  // should never hide other errors, as chance for a false alarm is quite high
       case "KOMMA_ZWISCHEN_HAUPT_UND_NEBENSATZ": return -10;
       case "KOMMA_VOR_RELATIVSATZ": return -10;

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tagging/fr/FrenchTagger.java
Patch:
@@ -43,7 +43,7 @@ public class FrenchTagger extends BaseTagger {
   private static final Pattern PREFIXES_FOR_VERBS = Pattern.compile("(auto|auto-|re-)([^-].*[aeiouêàéèíòóïü].+[aeiouêàéèíòóïü].*)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
 
   private static final Pattern NOUN_ADJ = Pattern.compile("[NJ] .+|V ppa.*");
-  private static final Pattern PREFIXES_NOUN_ADJ = Pattern.compile("(anti-|géo-|nord-|sud-|néo-|méga-|ultra-|pro-|inter-|micro-|macro-|sous-|haut-|auto-|ré-|pré-|super-|vice-|hyper-|proto-|grand-|pseudo-)(.+)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
+  private static final Pattern PREFIXES_NOUN_ADJ = Pattern.compile("(péri-|anti-|géo-|nord-|sud-|néo-|méga-|ultra-|pro-|inter-|micro-|macro-|sous-|haut-|auto-|ré-|pré-|super-|vice-|hyper-|proto-|grand-|pseudo-)(.+)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   //|nord-|sud-
   
   public FrenchTagger() {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -453,7 +453,7 @@ private void setConfigValues(Configuration config, SwJLanguageTool langTool) {
   /**
    * Get language from locale
    */
-  private Language getLanguage(Locale locale) {
+  public Language getLanguage(Locale locale) {
     try {
       if (locale.Language.equalsIgnoreCase(LIBREOFFICE_SPECIAL_LANGUAGE_TAG)) {
         return Languages.getLanguageForShortCode(locale.Variant);
@@ -1091,12 +1091,12 @@ public void trigger(String sEvent) {
           if (ltDialog != null) {
             ltDialog.closeDialog();
           }
-          SpellAndGrammarCheckDialog checkDialog = new SpellAndGrammarCheckDialog(xContext, this);
+          SpellAndGrammarCheckDialog checkDialog = new SpellAndGrammarCheckDialog(xContext, this, docLanguage);
           MessageHandler.printToLogFile("Start Spell And Grammar Check Dialog");
           checkDialog.start();
 //        }
       } else if ("nextError".equals(sEvent)) {
-        SpellAndGrammarCheckDialog checkDialog = new SpellAndGrammarCheckDialog(xContext, this);
+        SpellAndGrammarCheckDialog checkDialog = new SpellAndGrammarCheckDialog(xContext, this, docLanguage);
         checkDialog.nextError();
       } else if ("remoteHint".equals(sEvent)) {
         if(getConfiguration().useOtherServer()) {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/DateFilterHelper.java
Patch:
@@ -34,8 +34,7 @@ protected Calendar getCalendar() {
 
   @SuppressWarnings("ControlFlowStatementWithoutBraces")
   protected int getDayOfWeek(String dayStr) {
-    // quickfix for special characters like soft hyphens
-    String day = StringTools.trimSpecialCharacters(dayStr).toLowerCase();
+    String day = StringTools.trimSpecialCharacters(dayStr).toLowerCase();  // quickfix for special characters like soft hyphens
     if (day.startsWith("sonnabend")) return Calendar.SATURDAY;
     if (day.startsWith("so")) return Calendar.SUNDAY;
     if (day.startsWith("mo")) return Calendar.MONDAY;

File: languagetool-core/src/main/java/org/languagetool/Language.java
Patch:
@@ -710,6 +710,9 @@ private boolean isTheDefaultVariant() {
    * @since 3.6
    */
   protected int getPriorityForId(String id) {
+    if (id.equalsIgnoreCase("STYLE")) {  // category
+      return -50;  // don't let style issues hide more important errors
+    }
     return 0;
   }
   

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -283,7 +283,6 @@ protected int getPriorityForId(String id) {
       case "TOO_LONG_PARAGRAPH": return -15;
       // Category ids - make sure style issues don't hide overlapping "real" errors:
       case "COLLOQUIALISMS": return -15;
-      case "STYLE": return -15;
       case "REDUNDANCY": return -15;
       case "GENDER_NEUTRALITY": return -15;
       case "TYPOGRAPHY": return -15;

File: languagetool-core/src/main/java/org/languagetool/rules/LongParagraphRule.java
Patch:
@@ -47,9 +47,9 @@ public LongParagraphRule(ResourceBundle messages, Language lang, UserConfig user
     super(messages);
     super.setCategory(Categories.STYLE.getCategory(messages));
     this.lang = lang;
-    if (!defaultActive) {
-      setDefaultOff();
-    }
+    //if (!defaultActive) {
+    setDefaultOff();
+    //}
     if (defaultWords > 0) {
       this.maxWords = defaultWords;
     }

File: languagetool-language-modules/nl/src/main/java/org/languagetool/language/Dutch.java
Patch:
@@ -141,6 +141,7 @@ protected int getPriorityForId(String id) {
       case LongSentenceRule.RULE_ID: return -1;
       case "KORT_1": return -5;
       case "KORT_2": return -5;  //so that spelling errors are recognized first
+      case "EINDE_ZIN_ONVERWACHT": return -5;  //so that spelling errors are recognized first
     }
     return super.getPriorityForId(id);
   }

File: languagetool-core/src/main/java/org/languagetool/AnalyzedSentence.java
Patch:
@@ -200,7 +200,7 @@ public int getCorrectedTextLength() {
     int len = 0;
     for (int i = 0; i < tokens.length; i++) {
       AnalyzedTokenReadings element = tokens[i];
-      len += element.getToken().length();
+      len += element.getCleanToken().length();
       if (i == tokens.length - 1) {  // only apply at end, so the position fix at every token doesn't add up
         len += element.getPosFix();
       }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/LineExpander.java
Patch:
@@ -58,7 +58,7 @@ public List<String> load(@NotNull String line) {
           }
           Set<String> formSet = new HashSet<>(Arrays.asList(forms));
           for (String form : formSet) {
-            if (!form.contains("ß")) {
+            if (!form.contains("ß") && form.length() > 0 && Character.isLowerCase(form.charAt(0))) {
               // skip these, it's too risky to introduce old spellings like "gewußt" from the synthesizer
               result.add(parts[0] + form);
             }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/LineExpanderTest.java
Patch:
@@ -48,6 +48,9 @@ public void testExpansion() {
     assertThat(expand("rüber_machen  #bla #foo"), is("[rübermach, rübergemacht, rübermachest, rübermachst, rübermache, " +
                       "rübermachen, rübermachet, rübermachte, rübermachend, rübermachten, rübermacht, rübermachtest, " +
                       "rübermachtet, rüberzumachen]"));
+    assertThat(expand("rüber_verschicken"), is("[rüberverschickend, rüberverschickst, rüberverschick, rüberverschickest, " +
+                      "rüberverschicktest, rüberverschicke, rüberverschicket, rüberverschickte, rüberverschicktet, rüberverschickten, " +
+                      "rüberverschicken, rüberverschickt, rüberzuverschicken]"));
     assertThat(expand("escape\\_machen"), is("[escape_machen]"));
 
     try {

File: languagetool-core/src/main/java/org/languagetool/rules/LongSentenceRule.java
Patch:
@@ -62,7 +62,7 @@ public LongSentenceRule(ResourceBundle messages, UserConfig userConfig, int defa
     }
     setLocQualityIssueType(ITSIssueType.Style);
     if (picky) {
-      setTags(Collections.singletonList(Tags.picky.name()));
+      setTags(Collections.singletonList(Tags.picky));
     }
   }
 

File: languagetool-core/src/main/java/org/languagetool/tools/RuleMatchesAsJsonSerializer.java
Patch:
@@ -23,6 +23,7 @@
 import org.languagetool.DetectedLanguage;
 import org.languagetool.JLanguageTool;
 import org.languagetool.Language;
+import org.languagetool.Tags;
 import org.languagetool.markup.AnnotatedText;
 import org.languagetool.markup.AnnotatedTextBuilder;
 import org.languagetool.rules.*;
@@ -275,8 +276,8 @@ private void writeRule(JsonGenerator g, RuleMatch match) throws IOException {
     writeCategory(g, rule.getCategory());
     if (rule.getTags().size() > 0) {
       g.writeArrayFieldStart("tags");
-      for (String tag : rule.getTags()) {
-        g.writeString(tag);
+      for (Tags tag : rule.getTags()) {
+        g.writeString(tag.name());
       }
       g.writeEndArray();
     }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -185,7 +185,7 @@ public int size() {
   }
   
   /**
-   * size of document cache (number of all flat paragraphs)
+   * get Number of Text Paragraph from Number of Flat Paragraph
    */
   public int getNumberOfTextParagraph(int numberOfFlatParagraph) {
     return toTextMapping.get(numberOfFlatParagraph);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -203,7 +203,7 @@ ProofreadingResult getCheckResults(String paraText, Locale locale, ProofreadingR
     if(switchOff) {
       return paRes;
     }
-    paRes = documents.get(docNum).getCheckResults(paraText, locale, paRes, propertyValues, docReset, langTool);
+    paRes = documents.get(docNum).getCheckResults(paraText, paRes, propertyValues, docReset, langTool);
     if(langTool.doReset()) {
       // langTool.doReset() == true: if server connection is broken ==> switch to internal check
       MessageHandler.showMessage(messages.getString("loRemoteSwitchToLocal"));

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -172,6 +172,7 @@ protected int getPriorityForId(String id) {
       case "DIACRITICS": return 30;
       case "POR_CIERTO": return 30;
       case "LO_LOS": return 30;
+      case "SE_CREO": return 25; // less than DIACRITICS_VERB_N_ADJ
       case "PRONOMBRE_SIN_VERBO": return 25; // inside CONFUSIONS, but less than other rules ?
       case "AGREEMENT_DET_NOUN": return 20;
       //case "PRONOMBRE_SIN_VERBO": return 20;

File: languagetool-core/src/test/java/org/languagetool/rules/GRPCRuleTest.java
Patch:
@@ -44,7 +44,7 @@ public class GRPCRuleTest {
   public void setUp() throws Exception {
     config = new RemoteRuleConfig(RULE_ID, "localhost", 50000,
       0, 0L, 0.0f,
-      1, 0L, 100, Collections.emptyMap());
+      1, 0L, Collections.emptyMap());
 
     rule = new GRPCRule(JLanguageTool.getMessageBundle(), config, true) {
       @Override

File: languagetool-core/src/test/java/org/languagetool/rules/GRPCRuleTest.java
Patch:
@@ -44,7 +44,7 @@ public class GRPCRuleTest {
   public void setUp() throws Exception {
     config = new RemoteRuleConfig(RULE_ID, "localhost", 50000,
       0, 0L, 0.0f,
-      1, 0L, Collections.emptyMap());
+      1, 0L, 100, Collections.emptyMap());
 
     rule = new GRPCRule(JLanguageTool.getMessageBundle(), config, true) {
       @Override

File: languagetool-server/src/test/java/org/languagetool/server/BertResortingBugTest.java
Patch:
@@ -1,6 +1,6 @@
-/* LanguageTool, a natural language style checker 
+/* LanguageTool, a natural language style checker
  * Copyright (C) 2020 Daniel Naber (http://www.danielnaber.de)
- * 
+ *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
@@ -19,6 +19,7 @@
 package org.languagetool.server;
 
 import com.fasterxml.jackson.databind.ObjectMapper;
+
 import org.junit.Ignore;
 import org.junit.Test;
 import org.languagetool.tools.Tools;

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -193,7 +193,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
         new EnglishDiacriticsRule(messages),
         new EnglishPlainEnglishRule(messages),
         new EnglishRedundancyRule(messages),
-        new SimpleReplaceRule(messages),
+        new SimpleReplaceRule(messages, this),
         new ReadabilityRule(messages, this, userConfig, false),
         new ReadabilityRule(messages, this, userConfig, true)
     ));

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -152,7 +152,6 @@ public LanguageMaintainedState getMaintainedState() {
   @Override
   protected int getPriorityForId(String id) {
     switch (id) {
-      case "PRONOUN_IMPERATIVE": return 50;
       case "TE_TILDE": return 50;
       case "PLURAL_SEPARADO": return 50;
       case "INCORRECT_EXPRESSIONS": return 40;
@@ -162,6 +161,7 @@ protected int getPriorityForId(String id) {
       case "DIACRITICS": return 30;
       case "POR_CIERTO": return 30;
       case "LO_LOS": return 30;
+      case "PRONOMBRE_SIN_VERBO": return 25; // inside CONFUSIONS, but less than other rules ?
       case "AGREEMENT_DET_NOUN": return 20;
       //case "PRONOMBRE_SIN_VERBO": return 20;
       case "AGREEMENT_DET_ADJ": return 10;

File: languagetool-dev/src/main/java/org/languagetool/dev/bigdata/NGramLookup.java
Patch:
@@ -60,7 +60,7 @@ public static void main(String[] args) throws IOException {
           System.out.println(Arrays.toString(lookup) + " -> count:" + count + ", " + p + ", log:" + Math.log(p.getProb()));
           totalP *= p.getProb();
         }
-        System.out.printf("totalP=" + totalP);
+        System.out.println("totalP=" + totalP);
       }
     }
   }

File: languagetool-dev/src/main/java/org/languagetool/dev/httpchecker/CheckCallable.java
Patch:
@@ -152,7 +152,7 @@ private void printErr(String s) {
 
   private void writeFakeError(ObjectMapper mapper, FileWriter fw, String textToCheck, String pseudoFileName, ApiErrorException e) throws IOException {
     Language lang = Languages.getLanguageForShortCode(langCode);
-    JLanguageTool lt = new JLanguageTool(lang);
+    JLanguageTool lt = new JLanguageTool(Languages.getLanguageForShortCode("en"));
     RuleMatch ruleMatch = new RuleMatch(new FakeRule(), lt.getAnalyzedSentence(textToCheck), 0, 1, FAIL_MESSAGE + e.getMessage());
     DetectedLanguage detectedLang = new DetectedLanguage(lang, lang);
     String json = new RuleMatchesAsJsonSerializer().ruleMatchesToJson(Collections.singletonList(ruleMatch), textToCheck, 100, detectedLang);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/UnitConversionRule.java
Patch:
@@ -123,7 +123,7 @@ protected String getMessage(Message message) {
   protected String getShortMessage(Message message) {
     switch(message) {
       case CHECK:
-        return "Falsche Umrechung. Automatisch korrigieren?";
+        return "Falsche Umrechnung. Automatisch korrigieren?";
       case SUGGESTION:
         return "Metrisches Äquivalent hinzufügen?";
       case CHECK_UNKNOWN_UNIT:

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/SimpleReplaceRule.java
Patch:
@@ -101,7 +101,7 @@ protected boolean isTagged(AnalyzedTokenReadings tokenReadings) {
   }
 
   @Override
-  protected List<RuleMatch> findMatches(AnalyzedTokenReadings tokenReadings, AnalyzedSentence sentence) {
+  protected List<RuleMatch> findMatches(AnalyzedTokenReadings tokenReadings, AnalyzedSentence sentence) throws IOException {
     List<RuleMatch> matches = super.findMatches(tokenReadings, sentence);
     if( matches.isEmpty() ) {
       if( PosTagHelper.hasPosTag(tokenReadings, Pattern.compile(".*?adjp:actv.*?:bad.*")) ) {

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/SimpleReplaceSpelling1992Rule.java
Patch:
@@ -74,7 +74,7 @@ public String getShort() {
   }
 
   @Override
-  public RuleMatch[] match(AnalyzedSentence sentence) {
+  public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
     RuleMatch[] match = super.match(sentence);
     if( match.length == 0 ) {
       match = findTagged1922(sentence);

File: languagetool-server/src/main/java/org/languagetool/server/ServerMetricsCollector.java
Patch:
@@ -71,7 +71,7 @@ public enum RequestErrorType {
     7000, 7100, 7200, 7300, 7400, 7500, 7600, 7700, 7800, 7900,
     8000, 8100, 8200, 8300, 8400, 8500, 8600, 8700, 8800, 8900,
     9000, 9100, 9200, 9300, 9400, 9500, 9600, 9700, 9800, 9900,
-    10000, 15000, 20000, 25000, 30000, 400000, 50000, 100000
+    10000, 15000, 20000, 25000, 30000, 40000, 50000, 100000
 // expected max: e.g. 100 chars in 1ms = 100,000 chars/s
   };
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/tagging/de/GermanTagger.java
Patch:
@@ -226,7 +226,7 @@ public List<AnalyzedTokenReadings> tag(List<String> sentenceTokens, boolean igno
           String noPrefixForm = word.substring(verbInfo.prefix.length() + verbInfo.infix.length());   // infix can be "zu"
           List<TaggedWord> tags = tag(noPrefixForm);
           for (TaggedWord tag : tags) {
-            if (tag.getPosTag() != null && tag.getPosTag().startsWith("VER:")) {  // e.g. "schicke" is verb and adjective
+            if (tag.getPosTag() != null && (tag.getPosTag().startsWith("VER:") || tag.getPosTag().startsWith("PA2:"))) {  // e.g. "schicke" is verb and adjective
               readings.add(new AnalyzedToken(word, tag.getPosTag(), verbInfo.prefix + tag.getLemma()));
             }
           }

File: languagetool-language-modules/de/src/test/java/org/languagetool/tagging/de/GermanTaggerTest.java
Patch:
@@ -271,9 +271,10 @@ public void testPrefixVerbsFromSpellingTxt() throws IOException {
 
     List<AnalyzedTokenReadings> result3 = tagger.tag(Collections.singletonList("zurückgeschickt"));
     assertThat(result3.size(), is(1));
-    assertThat(result3.get(0).getReadings().size(), is(1));
+    assertThat(result3.get(0).getReadings().size(), is(2));
     String res3 = result3.toString();
     assertTrue(res3.contains("zurückschicken/VER:PA2:SFT*"));
+    assertTrue(res3.contains("PA2:PRD:GRU:VER*"));
     assertFalse(res3.contains("ADJ:"));
 
     List<AnalyzedTokenReadings> result4 = tagger.tag(Collections.singletonList("abzuschicken"));

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -152,6 +152,7 @@ public LanguageMaintainedState getMaintainedState() {
   @Override
   protected int getPriorityForId(String id) {
     switch (id) {
+      case "TE_TILDE": return 50;
       case "INCORRECT_EXPRESSIONS": return 40;
       case "MISSPELLING": return 40;  
       case "CONFUSIONS": return 40;

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/RussianWordRootRepeatRule.java
Patch:
@@ -39,6 +39,7 @@ public class RussianWordRootRepeatRule extends AbstractWordCoherencyRule {
 
   public RussianWordRootRepeatRule(ResourceBundle messages) throws IOException {
     super(messages);
+    setDefaultOff();
     addExamplePair(Example.wrong("Абрикос рос в саду. У меня на столе стоит <marker>абрикосный</marker> сок."),
                    Example.fixed("Абрикос рос в саду. У меня на столе стоит сок из <marker>абрикосов</marker>."));
   }

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -160,6 +160,7 @@ protected int getPriorityForId(String id) {
       case "POR_CIERTO": return 30;
       case "LO_LOS": return 30;
       case "AGREEMENT_DET_NOUN": return 20;
+      //case "PRONOMBRE_SIN_VERBO": return 20;
       case "AGREEMENT_DET_ADJ": return 10;
       case "TYPOGRAPHY": return 10;
       case "HALLA_HAYA": return 10;

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -416,7 +416,7 @@ private String readerToString(Reader reader, int maxTextLength) throws IOExcepti
       if (sb.length() > 0 && sb.length() > generousMaxLength) {
         // don't stop at maxTextLength as that's the text length, but here also other parameters
         // are included (still we need this check here so we don't OOM if someone posts a few hundred MB)...
-        throw new TextTooLongException("Your text's length exceeds this server's hard limit of " + maxTextLength + " characters.");
+        throw new TextTooLongException("Your text's length exceeds this server's hard limit of " + generousMaxLength + " characters.");
       }
       sb.append(new String(chars, 0, readBytes));
     }

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/MorfologikFrenchSpellerRule.java
Patch:
@@ -107,7 +107,6 @@ protected List<SuggestedReplacement> orderSuggestions(List<SuggestedReplacement>
       // move some split words to first place
       Matcher matcher = PARTICULA_INICIAL.matcher(suggestions.get(i).getReplacement());
       if (matcher.matches()) {
-        String newSuggestion = matcher.group(2);
         newSuggestions.add(0, suggestions.get(i));
         continue;
       }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -864,6 +864,7 @@ enum GrammarCategory {
     "denen",
     "sich",
     "aller",
+    "allen",  // "das allen bekannte Wollnashorn"
     "man",
     "beide",
     "beiden",

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -1087,14 +1087,14 @@ public void trigger(String sEvent) {
         deactivateRule();
         resetDocument();
       } else if ("checkDialog".equals(sEvent)) {
-        if (OfficeTools.DEVELOP_MODE) {
+//        if (OfficeTools.DEVELOP_MODE) {
           if (ltDialog != null) {
             ltDialog.closeDialog();
           }
           SpellAndGrammarCheckDialog checkDialog = new SpellAndGrammarCheckDialog(xContext, this);
           MessageHandler.printToLogFile("Start Spell And Grammar Check Dialog");
           checkDialog.start();
-        }
+//        }
       } else if ("nextError".equals(sEvent)) {
         SpellAndGrammarCheckDialog checkDialog = new SpellAndGrammarCheckDialog(xContext, this);
         checkDialog.nextError();

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -140,6 +140,7 @@ public GermanCompoundTokenizer(boolean strictMode) throws IOException {
     wordSplitter.addException("Siebengestirns", asList("Sieben", "gestirns"));
     wordSplitter.addException("Siebengestirnes", asList("Sieben", "gestirnes"));
     wordSplitter.addException("Alpinforum", asList("Alpin", "forum"));
+    wordSplitter.addException("Rollerskate", asList("Rollerskate"));
     wordSplitter.setStrictMode(strictMode);
     wordSplitter.setMinimumWordLength(3);
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -163,7 +163,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     putRepl("Germanistikerin(nen)?", "Germanistiker", "Germanist");
     putRepl("[iI]ns?z[ie]nie?rung(en)?", "[iI]ns?z[ie]nie?", "Inszenie");
     putRepl("[eE]rhöherung(en)?", "[eE]rhöherung", "Erhöhung");
-    putRepl("[vV]erspäterung(en)?", "er", "");
+    putRepl("[vV]erspäterung(en)?", "später", "spät");
     putRepl("[vV]orallendingen", "orallendingen", "or allen Dingen");
     putRepl("[aA]ufjede[nm]fall", "jede[nm]fall$", " jeden Fall");
     putRepl("[aA]us[vf]ersehen[dt]lich", "[vf]ersehen[dt]lich", " Versehen");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -144,6 +144,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Lieber jemanden, der einem Tipps gibt.");
     assertGood("Jainas ist sogar der Genuss jeglicher tierischer Nahrungsmittel strengstens untersagt.");
     assertGood("Es sind jegliche tierische Nahrungsmittel untersagt.");
+    assertGood("Das reicht bis weit ins heutige Hessen.");
     //assertGood("... der zu dieser Zeit aber ohnehin schon allen Einfluss verloren hatte.");
 
     assertGood("Wir machen das Januar.");

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishConfusionProbabilityRule.java
Patch:
@@ -313,8 +313,8 @@ public EnglishConfusionProbabilityRule(ResourceBundle messages, LanguageModel la
 
   public EnglishConfusionProbabilityRule(ResourceBundle messages, LanguageModel languageModel, Language language, int grams) {
     super(messages, languageModel, language, grams, EXCEPTIONS);
-    addExamplePair(Example.wrong("I did not <marker>now</marker> where it came from."),
-                   Example.fixed("I did not <marker>know</marker> where it came from."));
+    addExamplePair(Example.wrong("Don't forget to put on the <marker>breaks</marker>."),
+                   Example.fixed("Don't forget to put on the <marker>brakes</marker>."));
   }
 
   @Override

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -139,6 +139,7 @@ public GermanCompoundTokenizer(boolean strictMode) throws IOException {
     wordSplitter.addException("Siebengestirnen", asList("Sieben", "gestirnen"));
     wordSplitter.addException("Siebengestirns", asList("Sieben", "gestirns"));
     wordSplitter.addException("Siebengestirnes", asList("Sieben", "gestirnes"));
+    wordSplitter.addException("Alpinforum", asList("Alpin", "forum"));
     wordSplitter.setStrictMode(strictMode);
     wordSplitter.setMinimumWordLength(3);
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -1395,7 +1395,7 @@ private boolean hasNounReading(AnalyzedTokenReadings readings) {
         return true;
       }
       // "Die Schöne Tür": "Schöne" also has a noun reading but like "SUB:AKK:SIN:FEM:ADJ", ignore that:
-      AnalyzedTokenReadings allReadings = lookup(readings.getToken());  // unification in disambiguation.xml removes reading, so look up again
+      AnalyzedTokenReadings allReadings = lookup(readings.getToken().replaceAll("\\u00AD", ""));  // unification in disambiguation.xml removes reading, so look up again, removing soft hyphens
       if (allReadings != null) {
         for (AnalyzedToken reading : allReadings) {
           String posTag = reading.getPOSTag();

File: languagetool-dev/src/main/java/org/languagetool/dev/httpchecker/CheckCallable.java
Patch:
@@ -182,7 +182,7 @@ private CheckResult checkByPost(URL url, String postData) throws IOException, Ap
             throw new ApiErrorException(error);
           } else {
             String backendServer = httpConn.getHeaderField("x-backend-server");
-            throw new IOException("Failed posting to " + url + ", server " + backendServer + " responded with code " + httpConn.getResponseCode() + " and error: " + error);
+            throw new IOException("Failed posting to " + url + ", server " + backendServer + " responded with code " + httpConn.getResponseCode() + " and error: " + error + " for postData: " + postData);
           }
         } else {
           inputStream = httpConn.getInputStream();

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -1163,7 +1163,7 @@ private RuleMatch getCompoundError(AnalyzedTokenReadings token1, AnalyzedTokenRe
   private RuleMatch getRuleMatch(AnalyzedTokenReadings token1, AnalyzedSentence sentence, AnalyzedTokenReadings nextToken, String testPhrase, String hyphenTestPhrase) {
     try {
       initLt();
-      if (nextToken.getReadings().stream().allMatch(k -> k.getPOSTag() != null && k.getPOSTag().startsWith("EIG:"))) {
+      if (nextToken.getReadings().stream().allMatch(k -> k.getPOSTag() != null && !k.getPOSTag().startsWith("SUB:"))) {
         return null;
       }
       List<String> replacements = new ArrayList<>();

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementSuggestorTest.java
Patch:
@@ -47,6 +47,7 @@ public void testSuggestions() {
     assertSuggestion("mehrere/mehrer/PRO:IND:NOM:PLU:NEU:B/S Kabels/Kabel/SUB:GEN:SIN:MAS", "[mehrere Kabel]");
     assertSuggestion("mehrere/mehrer/PRO:IND:NOM:PLU:NEU:B/S LAN-Kabels/LAN-Kabel/SUB:GEN:SIN:MAS", "[mehrere LAN-Kabel]");
     assertSuggestion("mehrere/mehrer/PRO:IND:NOM:PLU:NEU:B/S WLAN-LAN-Kabels/WLAN-LAN-Kabel/SUB:GEN:SIN:MAS", "[mehrere WLAN-LAN-Kabel]");
+    assertSuggestion("Ihren/mein/PRO:POS:AKK:SIN:MAS:BEG Verständnis/Verständnis/SUB:NOM:SIN:NEU", "[Ihr Verständnis]");
   }
 
   private void assertSuggestion(String input, String expectedSuggestions) {

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Configuration.java
Patch:
@@ -995,7 +995,7 @@ public void setSwitchedOff(boolean switchOff, Language lang) throws IOException
    * Test if http-server URL is correct
    */
   public boolean isValidServerUrl(String url) {
-    if (url.endsWith("/") || url.endsWith("/v2") || !Pattern.matches("http://.+:\\d+.*", url)) {
+    if (url.endsWith("/") || url.endsWith("/v2") || !Pattern.matches("https?://.+(:\\d+)?.*", url)) {
       return false;
     }
     return true;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LinguisticServices.java
Patch:
@@ -256,6 +256,9 @@ public String[] getSpellAlternatives(String word, Locale locale) {
     PropertyValue[] properties = new PropertyValue[0];
     try {
       XSpellAlternatives spellAlternatives = spellChecker.spell(word, locale, properties);
+      if (spellAlternatives == null) {
+        return null;
+      }
       return spellAlternatives.getAlternatives();
     } catch (Throwable t) {
       // If anything goes wrong, give the user a stack trace

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ViewCursorTools.java
Patch:
@@ -51,7 +51,7 @@ public class ViewCursorTools {
    * Returns null if it fails
    */
   @Nullable
-  private XTextViewCursor getViewCursor() {
+  public XTextViewCursor getViewCursor() {
     try {
       XComponent xCurrentComponent = xDesktop.getCurrentComponent();
       if (xCurrentComponent == null) {

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -172,6 +172,9 @@ protected int getPriorityForId(String id) {
       case "SUBJUNTIVO_FUTURO": return -30;
       case "SUBJUNTIVO_PASADO": return -30;
       case "SUBJUNTIVO_PASADO2": return -30;
+      case "AGREEMENT_ADJ_NOUN": return -30;
+      case "AGREEMENT_PARTICIPLE_NOUN": return -30;
+      case "AGREEMENT_POSTPONED_ADJ": return -30;
       case "VOSEO": return -40;
       case "UPPERCASE_SENTENCE_START": return -50;
     }

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/RussianVerbConjugationRule.java
Patch:
@@ -73,7 +73,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
                     Pair<String, String> pronounPair = new ImmutablePair<>(pronounMatcher.group(1), pronounMatcher.group(2));
                     AnalyzedToken nextLemmaTok = nextReading.getReadings().get(0);
                     String nextPosTag = nextLemmaTok.getPOSTag();
-                    if(nextPosTag != null && !nextPosTag.isEmpty()) {
+                    if(nextPosTag != null && !(nextPosTag.isEmpty()) && !(nextLemmaTok.getToken().equals("может")) ) {  // replace check nextLemmaTok+1 && "быть"
                         Matcher verbMatcher = FUT_REAL_VERB.matcher(nextPosTag);
                         if (verbMatcher.find()) {
                             Pair<String, String> verbPair = new ImmutablePair<>(verbMatcher.group(4), verbMatcher.group(5));

File: languagetool-dev/src/main/java/org/languagetool/dev/httpchecker/CheckCallable.java
Patch:
@@ -181,7 +181,8 @@ private CheckResult checkByPost(URL url, String postData) throws IOException, Ap
             // errors where repeating the request probably won't help
             throw new ApiErrorException(error);
           } else {
-            throw new IOException("Failed posting to " + url + ", server responded with code " + httpConn.getResponseCode() + " and error: " + error);
+            String backendServer = httpConn.getHeaderField("x-backend-server");
+            throw new IOException("Failed posting to " + url + ", server " + backendServer + " responded with code " + httpConn.getResponseCode() + " and error: " + error);
           }
         } else {
           inputStream = httpConn.getInputStream();

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -142,7 +142,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     put("jeztz", "jetzt");
     put("les", "lese");
     put("wr", "wir");
-    put("be­zwei­fel", "bezweifle");
+    put("bezweifel", "bezweifle");
     put("[wW]ah?rscheindlichkeit", "Wahrscheinlichkeit");
     put("Hijab", "Hidschāb");
     put("[lL]eerequiment", "Leerequipment");

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/DateCheckFilter.java
Patch:
@@ -40,8 +40,8 @@ protected int getDayOfWeek(String dayStr) {
     if (day.startsWith("вт")) return Calendar.TUESDAY;
     if (day.startsWith("ср")) return Calendar.WEDNESDAY;
     if (day.startsWith("чт") || day.equals("четверг")) return Calendar.THURSDAY;
-    if (day.equals("пт") || day.equals("пятница")) return Calendar.FRIDAY;
-    if (day.startsWith("сб") || day.equals("суббота")) return Calendar.SATURDAY;
+    if (day.equals("пт") || day.startsWith ("пятниц")) return Calendar.FRIDAY;
+    if (day.startsWith("сб") || day.startsWith ("суббот")) return Calendar.SATURDAY;
     if (day.startsWith("вс") || day.equals("воскресенье")) return Calendar.SUNDAY;
     throw new RuntimeException("Could not find day of week for '" + dayStr + "'");
   }

File: languagetool-dev/src/main/java/org/languagetool/dev/MissingGermanPosForms.java
Patch:
@@ -29,7 +29,7 @@
 
 /**
  * Fast hack to find words which have an uppercase reading in the speller dict
- * but only a lowercase reading in the POS dict => Reading might be missing
+ * but only a lowercase reading in the POS dict =&gt; Reading might be missing
  * in POS dict.
  */
 public class MissingGermanPosForms {

File: languagetool-language-modules/en/src/main/java/org/languagetool/tagging/en/EnglishHybridDisambiguator.java
Patch:
@@ -47,7 +47,7 @@ public class EnglishHybridDisambiguator extends AbstractDisambiguator {
    * disambiguator.
    * 
    * Put the results of the MultiWordChunker in a more appropriate and useful way.
-   *   <NN></NN> becomes NN NN
+   *   &lt;NN&gt;&lt;/NN&gt; becomes NN NN
    *   The individual original tags are removed. 
    *   Add spell ignore
    */

File: languagetool-language-modules/pt/src/main/java/org/languagetool/tagging/disambiguation/pt/PortugueseHybridDisambiguator.java
Patch:
@@ -47,7 +47,7 @@ public class PortugueseHybridDisambiguator extends AbstractDisambiguator {
    * disambiguator.
    * 
    * Put the results of the MultiWordChunker in a more appropriate and useful way.
-   *   <NN></NN> becomes NN NN
+   *   &lt;NN&gt;&lt;/NN&gt; becomes NN NN
    *   The individual original tags are removed. 
    *   Add spell ignore
    */
@@ -57,7 +57,7 @@ public final AnalyzedSentence disambiguate(AnalyzedSentence input)
     AnalyzedSentence analyzedSentence = chunker.disambiguate(input);
            
     AnalyzedTokenReadings[] aTokens = analyzedSentence.getTokens();
-    int i=0;
+    int i = 0;
     String POSTag = "";
     String lemma = "";
     String nextPOSTag = "";

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/PortugueseTest.java
Patch:
@@ -35,7 +35,7 @@ public void testLanguage() throws IOException {
     testDemoText(lang, s,
       Arrays.asList("POSSESSIVE_WITHOUT_ARTICLE", "SPACE_AFTER_PUNCTUATION", "GENERAL_GENDER_AGREEMENT_ERRORS", "AFIM_DE", "PORTUGUESE_WORD_REPEAT_RULE",
               "PT_AGREEMENT_REPLACE", "TAL_VEZ", "GENERAL_NUMBER_AGREEMENT_ERRORS", "GENERAL_VERB_AGREEMENT_ERRORS", "UPPERCASE_SENTENCE_START", 
-              "HUNSPELL_RULE", "UNPAIRED_BRACKETS", "DOUBLE_PUNCTUATION", "PHRASE_REPETITION", "REPEATED_WORDS", "ARTICLES_PRECEDING_LOCATIONS",
+              "HUNSPELL_RULE", "UNPAIRED_BRACKETS", "DOUBLE_PUNCTUATION", "PHRASE_REPETITION", "ARTICLES_PRECEDING_LOCATIONS", //"REPEATED_WORDS",
               "PARONYM_ANALISE_363", "DOUBLE_PUNCTUATION", "POSSESSIVE_WITHOUT_ARTICLE", "EQUIPES", "T-V_DISTINCTION", "DATE_WEEKDAY")
     );
     runTests(lang, null, "õș");

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -203,7 +203,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
   @Override
   public List<Rule> getRelevantLanguageModelRules(ResourceBundle messages, LanguageModel languageModel, UserConfig userConfig) throws IOException {
     return Arrays.asList(
-        new UpperCaseNgramRule(messages, languageModel, this),
+        new UpperCaseNgramRule(messages, languageModel, this, userConfig),
         new EnglishConfusionProbabilityRule(messages, languageModel, this),
         new EnglishNgramProbabilityRule(messages, languageModel, this)
     );

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/UpperCaseNgramRuleTest.java
Patch:
@@ -48,7 +48,7 @@ public class UpperCaseNgramRuleTest {
   }
   private final LanguageModel lm = new FakeLanguageModel(map);
   private final Language lang = Languages.getLanguageForShortCode("en");
-  private final UpperCaseNgramRule rule = new UpperCaseNgramRule(TestTools.getEnglishMessages(), lm, lang);
+  private final UpperCaseNgramRule rule = new UpperCaseNgramRule(TestTools.getEnglishMessages(), lm, lang, null);
   private final JLanguageTool lt = new JLanguageTool(lang);
 
   @Test
@@ -94,7 +94,7 @@ public void testFirstLongWordToLeftIsUppercase() throws IOException, URISyntaxEx
     // FIXME commented out version doesn't work when running tests through maven
     //URL ngramUrl = JLanguageTool.getDataBroker().getFromResourceDirAsUrl("/yy/ngram-index");
     //try (LuceneLanguageModel lm = new LuceneLanguageModel(new File(ngramUrl.toURI()))) {
-    UpperCaseNgramRule rule = new UpperCaseNgramRule(TestTools.getEnglishMessages(), lm, lang);
+    UpperCaseNgramRule rule = new UpperCaseNgramRule(TestTools.getEnglishMessages(), lm, lang, null);
 
     AnalyzedTokenReadings[] tokens1 = lt.getAnalyzedSentence("As with Lifeboat and Rope, the principal characters were ...").getTokens();
     // left:

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -575,6 +575,7 @@ SwJLanguageTool initLanguageTool(Language currentLanguage) {
         File ngramLangDir = new File(config.getNgramDirectory(), currentLanguage.getShortCode());
         if (ngramLangDir.exists()) {  // user might have ngram data only for some languages and that's okay
           langTool.activateLanguageModelRules(ngramDirectory);
+          MessageHandler.printToLogFile("ngram Model activated for language: " + currentLanguage.getShortCode());
         }
       }
       File word2VecDirectory = config.getWord2VecDirectory();

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CompoundInfinitivRule.java
Patch:
@@ -243,7 +243,7 @@ && isRelevant(tokens[i - 1])
         && !isException(tokens, i)
         && !isMisspelled(tokens[i - 1].getToken() + tokens[i + 1].getToken())) {
         String msg = "Wenn der erweiterte Infinitv von dem Verb '" + tokens[i - 1].getToken() + tokens[i + 1].getToken()
-                   + "' abgeleitet ist, muss er zusammengeschrieben werden";
+                   + "' abgeleitet ist, sollte er zusammengeschrieben werden";
         RuleMatch ruleMatch = new RuleMatch(this, sentence, tokens[i - 1].getStartPos(), tokens[i + 1].getEndPos(), msg);
         List<String> suggestions = new ArrayList<>();
         suggestions.add(tokens[i - 1].getToken() + tokens[i].getToken() + tokens[i + 1].getToken());

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/OfficeTools.java
Patch:
@@ -54,6 +54,7 @@ class OfficeTools {
   public static final String ZERO_WIDTH_SPACE = "\u200B";  // Used to mark footnotes
   public static final String LOG_LINE_BREAK = System.lineSeparator();  //  LineBreak in Log-File (MS-Windows compatible)
   public static final int MAX_SUGGESTIONS = 15;  // Number of suggestions maximal shown in LO/OO
+  public static final int NUMBER_TEXTLEVEL_CACHE = 2;  // Number of caches for matches of text level rules
 
   
   public static int DEBUG_MODE_SD = 0;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -137,12 +137,14 @@ protected int getPriorityForId(String id) {
       case "CA_SIMPLE_REPLACE_BALEARIC": return 100;
       case "INCORRECT_EXPRESSIONS": return 50;
       case "MOTS_NO_SEPARATS": return 40;
+      case "REPETEAD_ELEMENTS": return 40;
       case "CONCORDANCES_CASOS_PARTICULARS": return 30;
       case "CONFUSIONS_ACCENT": return 20;
       case "DIACRITICS": return 20;
       case "ACCENTUATION_CHECK": return 10;
       case "HAVER_SENSE_HAC": return 10;
       case "CONCORDANCES_DET_NOM": return 5;
+      case "VENIR_NO_REFLEXIU": return 5;
       case "REGIONAL_VERBS": return -10;
       case "FALTA_COMA_FRASE_CONDICIONAL": return -20;
       case "SUBSTANTIUS_JUNTS": return -25;

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/PostponedAdjectiveConcordanceFilter.java
Patch:
@@ -93,9 +93,9 @@ public class PostponedAdjectiveConcordanceFilter extends RuleFilter {
   private static final Pattern COORDINACIO_IONI = Pattern.compile("y|e|o|u|ni");
   private static final Pattern KEEP_COUNT = Pattern.compile("A.*|N.*|D[NAIDP].*|SPS.*|SP\\+DA|.*LOC_ADV.*|V.P.*|_PUNCT.*|.*LOC_ADJ.*|PX.*");
   private static final Pattern KEEP_COUNT2 = Pattern.compile(",|y|o|ni"); // |\\d+%?|%
-  private static final Pattern STOP_COUNT = Pattern.compile(";");
+  private static final Pattern STOP_COUNT = Pattern.compile(";|lo");
   private static final Pattern PREPOSICIONS = Pattern.compile("SPS.*");
-  private static final Pattern PREPOSICIO_CANVI_NIVELL = Pattern.compile("de|del|en|sobre|a|entre|por|com|sin|contra");
+  private static final Pattern PREPOSICIO_CANVI_NIVELL = Pattern.compile("de|del|en|sobre|a|entre|por|con|sin|contra");
   private static final Pattern VERB = Pattern.compile("V.[^P].*|_GV_");
   private static final Pattern GV = Pattern.compile("_GV_");
 

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/PostponedAdjectiveConcordanceFilter.java
Patch:
@@ -88,7 +88,7 @@ public class PostponedAdjectiveConcordanceFilter extends RuleFilter {
   private static final Pattern CONJUNCIO = Pattern.compile("C.|.*LOC_CONJ.*");
   private static final Pattern PUNTUACIO = Pattern.compile("_PUNCT.*");
   private static final Pattern LOC_ADV = Pattern.compile(".*LOC_ADV.*");
-  private static final Pattern ADVERBIS_ACCEPTATS = Pattern.compile("RG");
+  private static final Pattern ADVERBIS_ACCEPTATS = Pattern.compile("RG_before");
   private static final Pattern COORDINACIO = Pattern.compile(",|y|e|o|u");
   private static final Pattern COORDINACIO_IONI = Pattern.compile("y|e|o|u|ni");
   private static final Pattern KEEP_COUNT = Pattern.compile("A.*|N.*|D[NAIDP].*|SPS.*|SP\\+DA|.*LOC_ADV.*|V.P.*|_PUNCT.*|.*LOC_ADJ.*|PX.*");

File: languagetool-language-modules/ar/src/main/java/org/languagetool/rules/ar/ArabicDarjaRule.java
Patch:
@@ -70,7 +70,7 @@ public String getShort() {
 
   @Override
   public String getSuggestion() {
-    return "الكلمة عامية يفضل أن يقال $suggestions";
+    return "الكلمة عامية  أو أجنبية يفضل أن يقال $suggestions";
   }
 
   @Override

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -162,7 +162,7 @@ protected int getPriorityForId(String id) {
       case "HALLA_HAYA": return 10;
       case "VALLA_VAYA": return 10;
       case "ES_SIMPLE_REPLACE": return 10;
-      case "SEPARADO": return 0;
+      case "SEPARADO": return 1;
       case "MORFOLOGIK_RULE_ES": return -1;
       case "EL_TILDE": return -10;
       case "PREP_VERB": return -20;

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -162,6 +162,7 @@ protected int getPriorityForId(String id) {
       case "HALLA_HAYA": return 10;
       case "VALLA_VAYA": return 10;
       case "ES_SIMPLE_REPLACE": return 10;
+      case "SEPARADO": return 0;
       case "MORFOLOGIK_RULE_ES": return -1;
       case "EL_TILDE": return -10;
       case "PREP_VERB": return -20;

File: languagetool-core/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -51,6 +51,7 @@ public class WordListValidatorTest {
           "Tromsø/S",
           "Solidarność",
           "Salihamidžić/S",
+          "Darʿā",  // de
           "veni, vidi, vici", // en
           "Food+Tech Connect", // en
           "comme ci, comme ça", // en

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/PostponedAdjectiveConcordanceFilter.java
Patch:
@@ -88,7 +88,7 @@ public class PostponedAdjectiveConcordanceFilter extends RuleFilter {
   private static final Pattern CONJUNCIO = Pattern.compile("C.|.*LOC_CONJ.*");
   private static final Pattern PUNTUACIO = Pattern.compile("_PUNCT.*");
   private static final Pattern LOC_ADV = Pattern.compile(".*LOC_ADV.*");
-  private static final Pattern ADVERBIS_ACCEPTATS = Pattern.compile("RG_anteposat");
+  private static final Pattern ADVERBIS_ACCEPTATS = Pattern.compile("RG");
   private static final Pattern COORDINACIO = Pattern.compile(",|y|e|o|u");
   private static final Pattern COORDINACIO_IONI = Pattern.compile("y|e|o|u|ni");
   private static final Pattern KEEP_COUNT = Pattern.compile("A.*|N.*|D[NAIDP].*|SPS.*|SP\\+DA|.*LOC_ADV.*|V.P.*|_PUNCT.*|.*LOC_ADJ.*|PX.*");

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -113,7 +113,8 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             // specific to French:
             new CompoundRule(messages),
             new QuestionWhitespaceStrictRule(messages, this),
-            new QuestionWhitespaceRule(messages, this)
+            new QuestionWhitespaceRule(messages, this),
+            new SimpleReplaceRule(messages)
     );
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -508,7 +508,7 @@ public class CaseRule extends Rule {
     ),
     Arrays.asList( // Hey Matt (name),
       regex("Hey|Hi|Hallo|Na|Moin|Servus"),
-      regex("Matt"),
+      regex("Matt")
     ),
     Arrays.asList( // Hey mein Süßer,
       regex("Hey|Hi|Hallo|Na|Moin|Servus"),

File: languagetool-language-modules/ca/src/test/java/org/languagetool/synthesis/ca/CatalanSynthesizerTest.java
Patch:
@@ -68,6 +68,7 @@ public final void testSynthesizeStringString() throws IOException {
     assertEquals("[les universitats, la universitat]", synthNonRegex("universitat", "DT"));
     assertEquals("[les úniques, l'única, els únics, l'únic]", synthNonRegex("únic", "DT"));
     assertEquals("[per les úniques, per l'única, pels únics, per l'únic]", synthNonRegex("únic", "DTper"));
+    assertEquals("[per la covid]", synthNonRegex("covid", "DTper"));
   }
 
   private String synth(String word, String pos) throws IOException {

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1483,7 +1483,8 @@ private List<RuleMatch> getOtherRuleMatches() {
             CommonWords commonWords = new CommonWords();
             throw new ErrorRateTooHighException("Text checking was stopped due to too many errors (more than " + String.format("%.0f", maxErrorsPerWordRate*100) +
                     "% of words seem to have an error). Are you sure you have set the correct text language? Language set: " + JLanguageTool.this.language.getName() +
-                    ", text length: " + annotatedText.getPlainText().length() + ", common word count: " + commonWords.getKnownWordsPerLanguage(annotatedText.getPlainText()));
+                    ", text length: " + annotatedText.getPlainText().length());
+            //        ", text length: " + annotatedText.getPlainText().length() + ", common word count: " + commonWords.getKnownWordsPerLanguage(annotatedText.getPlainText()));
           }
           charCount += sentence.length();
           lineCount += countLineBreaks(sentence);

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -160,6 +160,7 @@ public LanguageMaintainedState getMaintainedState() {
   @Override
   protected int getPriorityForId(String id) {
     switch (id) {
+      case "CEST_A_DIRE": return 10; // greater than A_A_ACCENT
       case "ESPACE_UNITES": return 1; // needs to have higher priority than spell checker
       case "BYTES": return 1; // needs to be higher than spell checker for 10MB style matches
       case "Y_A": return 1; // needs to be higher than spell checker for style suggestion

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/index/IndexerSearcherTest.java
Patch:
@@ -200,7 +200,7 @@ public void testIndexerSearcherWithEnglish() throws Exception {
     assertEquals(false, searcherResult.isResultIsTimeLimited());
     assertEquals(1, searcherResult.getMatchingSentences().size());
 
-    searcherResult = errorSearcher.findRuleMatchesOnIndex(getFirstRule("EYE_BROW", language), language);
+    searcherResult = errorSearcher.findRuleMatchesOnIndex(getFirstRule("EYE_COMPOUNDS", language), language);
     assertEquals(1, searcherResult.getCheckedSentences());
     assertEquals(false, searcherResult.isResultIsTimeLimited());
     assertEquals(1, searcherResult.getMatchingSentences().size());

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -168,6 +168,7 @@ public void testRule() throws IOException {
     assertGood("A) Das Haus");
     assertGood("Rabi und Polykarp Kusch an der Columbia-Universität");
     assertGood("Man geht davon aus, dass es sich dabei nicht um Reinigungsverhalten handelt.");
+    assertGood("WUrzeln");  // to be found by spell checker
 
     // https://github.com/languagetool-org/languagetool/issues/1515:
     assertGood("▶︎ Dies ist ein Test");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/CatalanWordRepeatRuleTest.java
Patch:
@@ -60,6 +60,8 @@ public void testRule() throws IOException {
     assertEquals(0, matches.length);
     matches = rule.match(langTool.getAnalyzedSentence("cada un un llibre"));
     assertEquals(0, matches.length);
+    matches = rule.match(langTool.getAnalyzedSentence("Si no no es gaudeix."));
+    assertEquals(0, matches.length);
         
     //incorrect
     matches = rule.match(langTool.getAnalyzedSentence("Tots els els homes són iguals."));

File: languagetool-core/src/main/java/org/languagetool/rules/BERTSuggestionRanking.java
Patch:
@@ -126,7 +126,7 @@ protected RemoteRequest prepareRequest(List<AnalyzedSentence> sentences, Annotat
           // build request before correcting offset, as we send only sentence as text
           requests.add(buildRequest(match));
           int fromPos = annotatedText.getOriginalTextPositionFor(match.getFromPos() + offset, false);
-          int toPos = annotatedText.getOriginalTextPositionFor(match.getToPos() + offset, true);
+          int toPos = annotatedText.getOriginalTextPositionFor(match.getToPos() + offset - 1, true) + 1;
           match.setOffsetPosition(fromPos, toPos);
         }
         Collections.addAll(matches, sentenceMatches);

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -831,7 +831,7 @@ public List<RuleMatch> check(AnnotatedText annotatedText, boolean tokenizeText,
       remoteRuleTasks = allRules.stream()
         .filter(rule -> rule instanceof RemoteRule)
         .filter(rule -> !ignoreRule(rule))
-        .map(rule -> ((RemoteRule) rule).run(analyzedSentences))
+        .map(rule -> ((RemoteRule) rule).run(analyzedSentences, annotatedText))
         .collect(Collectors.toList());
       remoteRuleTasks.forEach(remoteRulesThreadPool::submit);
     }

File: languagetool-core/src/main/java/org/languagetool/rules/GRPCRule.java
Patch:
@@ -32,6 +32,7 @@
 import io.grpc.netty.shaded.io.netty.handler.ssl.SslContextBuilder;
 import org.jetbrains.annotations.Nullable;
 import org.languagetool.AnalyzedSentence;
+import org.languagetool.markup.AnnotatedText;
 import org.languagetool.rules.ml.MLServerGrpc;
 import org.languagetool.rules.ml.MLServerProto;
 import org.slf4j.Logger;
@@ -152,7 +153,7 @@ public MLRuleRequest(MLServerProto.MatchRequest request, List<AnalyzedSentence>
   }
 
   @Override
-  protected RemoteRule.RemoteRequest prepareRequest(List<AnalyzedSentence> sentences) {
+  protected RemoteRule.RemoteRequest prepareRequest(List<AnalyzedSentence> sentences, AnnotatedText annotatedText) {
     List<String> text = sentences.stream().map(AnalyzedSentence::getText).collect(Collectors.toList());
     MLServerProto.MatchRequest req = MLServerProto.MatchRequest.newBuilder().addAllSentences(text).build();
     return new MLRuleRequest(req, sentences);

File: languagetool-server/src/test/java/org/languagetool/server/BertResortingBugTest.java
Patch:
@@ -31,7 +31,7 @@
 public class BertResortingBugTest {
 
   @Test
-  @Ignore("shows bugs - for interactive use")
+  @Ignore("used to show bug #2969 - for interactive use, requires server")
   public void testHttpApi() throws IOException {
     String s = "A teext.\nAn errör-free text.\nSo much teext.";  // must exactly match 'data'
     String data = "{\"annotation\":[{\"text\":\"A teext.\"},{\"markup\":\"\\n\",\"interpretAs\":\"\\n\\n\"},{\"text\":\"An errör-free text.\"},{\"markup\":\"\\n\",\"interpretAs\":\"\\n\\n\"},{\"text\":\"So much teext.\"}]}";

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -369,6 +369,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Dann hat das Konsequenzen.");
     assertGood("Sollte das Konsequenzen nach sich ziehen?");
     assertGood("Der Echo Show von Amazon");
+    assertGood("Die BVG kommen immer zu spät.");
 
     assertBad("Hier steht Ihre Text.");
     assertBad("Hier steht ihre Text.");

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -64,7 +64,7 @@ public class HunspellRule extends SpellingCheckRule {
   private final boolean monitorRules;
   
   //200 most common French words. They are used to avoid wrong split suggestions
-  private final List<String> commonFrenchWords = Arrays.asList(new String[]{"a", "acte", "aider", "air", "ajouter", "aller", "allé", "animal", "année", "appel", "après", "arrière", "aucun", "aussi", "autre", "avant", "avec", "avoir", "bas", "beaucoup", "besoin", "bien", "bon", "boîte", "cause", "ce", "certains", "ces", "changement", "chaque", "chaud", "chose", "comme", "comment", "construire", "côté", "dans", "de", "dehors", "deux", "différer", "dire", "dit", "donner", "droit", "déménagement", "eau", "elle", "encore", "ensemble", "essayer", "est", "et", "eu", "fabriqué", "faible", "faire", "fait", "faut", "fin", "forme", "garçon", "genre", "grand", "haut", "homme", "hommes", "ici", "il", "ils", "image", "interroger", "je", "jouer", "jour", "jusqu’à", "juste", "la", "le", "les", "leur", "lieu", "ligne", "lire", "long", "lui", "lumière", "là", "ma", "main", "maintenant", "mais", "maison", "manière", "mettre", "moi", "monde", "montrer", "mot", "mère", "même", "ne", "nom", "nombre", "notre", "nous", "nouveau", "obtenir", "ou", "où", "par", "partie", "penser", "personnes", "petit", "peu", "peut", "phrase", "plus", "point", "port", "pour", "pourquoi", "pourrait", "première", "prendre", "près", "puis", "père", "quand", "que", "qui", "regarder", "savoir", "seulement", "si", "signifier", "soi", "son", "sont", "sous", "suivre", "sur", "tel", "temps", "terre", "tour", "tous", "tout", "travail", "trois", "trop", "trouver", "très", "tête", "un", "utiliser", "venir", "venu", "vers", "vieux", "vivre", "voir", "volonté", "votre", "voudrais", "vouloir", "vous", "à", "écrire", "épeler", "étaient", "était", "été", "être"});
+  private final List<String> commonFrenchWords = Arrays.asList(new String[]{"qu'il", "qu'ils", "bon", "bonne", "bons", "bonnes", "a", "acte", "aider", "air", "ajouter", "aller", "allé", "animal", "année", "appel", "après", "arrière", "aucun", "aussi", "autre", "avant", "avec", "avoir", "bas", "beaucoup", "besoin", "bien", "bon", "boîte", "cause", "ce", "certains", "ces", "changement", "chaque", "chaud", "chose", "comme", "comment", "construire", "côté", "dans", "de", "dehors", "deux", "différer", "dire", "dit", "donner", "droit", "déménagement", "eau", "elle", "encore", "ensemble", "essayer", "est", "et", "eu", "fabriqué", "faible", "faire", "fait", "faut", "fin", "forme", "garçon", "genre", "grand", "haut", "homme", "hommes", "ici", "il", "ils", "image", "interroger", "je", "jouer", "jour", "jusqu’à", "juste", "la", "le", "les", "leur", "lieu", "ligne", "lire", "long", "lui", "lumière", "là", "ma", "main", "maintenant", "mais", "maison", "manière", "mettre", "moi", "monde", "montrer", "mot", "mère", "même", "ne", "nom", "nombre", "notre", "nous", "nouveau", "obtenir", "ou", "où", "par", "partie", "penser", "personnes", "petit", "peu", "peut", "phrase", "plus", "point", "port", "pour", "pourquoi", "pourrait", "première", "prendre", "près", "puis", "père", "quand", "que", "qui", "regarder", "savoir", "seulement", "si", "signifier", "soi", "son", "sont", "sous", "suivre", "sur", "tel", "temps", "terre", "tour", "tous", "tout", "travail", "trois", "trop", "trouver", "très", "tête", "un", "utiliser", "venir", "venu", "vers", "vieux", "vivre", "voir", "volonté", "votre", "voudrais", "vouloir", "vous", "à", "écrire", "épeler", "étaient", "était", "été", "être"});
 
   public static Queue<String> getActiveChecks() {
     return activeChecks;

File: languagetool-language-modules/fr/src/test/java/org/languagetool/rules/fr/FrenchCompoundAwareHunspellRuleTest.java
Patch:
@@ -36,6 +36,8 @@ public class FrenchCompoundAwareHunspellRuleTest {
   public void testSpellcheck() throws IOException {
     JLanguageTool lt = new JLanguageTool(Languages.getLanguageForShortCode("fr"));
     TestTools.disableAllRulesExcept(lt, "FR_SPELLING_RULE");
+    assertSuggestion(lt, "qu’il sagissait", "s'agissait"); // see #3068
+    assertSuggestion(lt, "bonne sante", "santé"); // see #3068
     assertSuggestion(lt, "et ca", "ça"); // see #2900
     assertSuggestion(lt, "La journé", "jour né"); // see #2900. Better: journée
     assertSuggestion(lt, "la sante", "santé"); // see #2900

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tagging/fr/FrenchTagger.java
Patch:
@@ -43,7 +43,7 @@ public class FrenchTagger extends BaseTagger {
   private static final Pattern PREFIXES_FOR_VERBS = Pattern.compile("(auto-|re-)(.*[aeiouêàéèíòóïü].+[aeiouêàéèíòóïü].*)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
 
   private static final Pattern NOUN_ADJ = Pattern.compile("[NJ] .+|V ppa.*");
-  private static final Pattern PREFIXES_NOUN_ADJ = Pattern.compile("(pré-|nord-|sud-|néo-|méga-|ultra-|pro-|inter-|micro-|macro-|sous-|haut-|auto-|ré-|pré-|super-|vice-|hyper-|proto-|grand-|pseudo-)(.+)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
+  private static final Pattern PREFIXES_NOUN_ADJ = Pattern.compile("(nord-|sud-|néo-|méga-|ultra-|pro-|inter-|micro-|macro-|sous-|haut-|auto-|ré-|pré-|super-|vice-|hyper-|proto-|grand-|pseudo-)(.+)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   //|nord-|sud-
   
   public FrenchTagger() {

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tagging/fr/FrenchTagger.java
Patch:
@@ -25,9 +25,6 @@
 import org.languagetool.tagging.BaseTagger;
 import org.languagetool.tools.StringTools;
 
-import morfologik.stemming.DictionaryLookup;
-import morfologik.stemming.IStemmer;
-
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Locale;

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tagging/fr/FrenchTagger.java
Patch:
@@ -46,7 +46,7 @@ public class FrenchTagger extends BaseTagger {
   private static final Pattern PREFIXES_FOR_VERBS = Pattern.compile("(auto-|re-)(.*[aeiouêàéèíòóïü].+[aeiouêàéèíòóïü].*)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
 
   private static final Pattern NOUN_ADJ = Pattern.compile("[NJ] .+|V ppa.*");
-  private static final Pattern PREFIXES_NOUN_ADJ = Pattern.compile("(nord-|sud-|néo-|méga-|ultra-|pro-|inter-|micro-|macro-|sous-|haut-|auto-|ré-|pré-|super-|vice-|hyper-|proto-|grand-|pseudo-)(.+)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
+  private static final Pattern PREFIXES_NOUN_ADJ = Pattern.compile("(pré-|nord-|sud-|néo-|méga-|ultra-|pro-|inter-|micro-|macro-|sous-|haut-|auto-|ré-|pré-|super-|vice-|hyper-|proto-|grand-|pseudo-)(.+)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   //|nord-|sud-
   
   public FrenchTagger() {

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tagging/disambiguation/fr/FrenchHybridDisambiguator.java
Patch:
@@ -41,7 +41,7 @@
 
 public class FrenchHybridDisambiguator extends AbstractDisambiguator {
 
-  private final Disambiguator chunker = new MultiWordChunker("/fr/multiwords.txt");
+  private final Disambiguator chunker = new MultiWordChunker("/fr/multiwords.txt", true); //true = allow capitalized word
   private final Disambiguator disambiguator = new XmlRuleDisambiguator(new French());
 
   /**

File: languagetool-language-modules/fr/src/test/java/org/languagetool/tagging/fr/FrenchTaggerTest.java
Patch:
@@ -58,6 +58,9 @@ public void testTagger() throws IOException {
     TestTools.myAssert("micro-plastiques","micro-plastiques/[micro-plastique]J e p|micro-plastiques/[micro-plastique]N e p", tokenizer, tagger);
     TestTools.myAssert("sous-espace","sous-espace/[sous-espace]N m s", tokenizer, tagger);
     TestTools.myAssert("sous-corps","sous-corps/[sous-corps]N m sp", tokenizer, tagger);
+    TestTools.myAssert("auto-empoisonnement","auto-empoisonnement/[auto-empoisonnement]N m s", tokenizer, tagger);
+    TestTools.myAssert("auto-équilibrage","auto-équilibrage/[auto-équilibrage]N m s", tokenizer, tagger);
+    TestTools.myAssert("Grand-Chambre","Grand-Chambre/[grand-chambre]N f s", tokenizer, tagger);
     
     TestTools.myAssert("d’aujourd’hui","d'/[de]D e s|d'/[de]P -- aujourd'hui/[aujourd'hui]A", tokenizer, tagger);
     TestTools.myAssert("d'aujourd’hui","d'/[de]D e s|d'/[de]P -- aujourd'hui/[aujourd'hui]A", tokenizer, tagger);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ConfigThread.java
Patch:
@@ -71,7 +71,7 @@ public void run() {
         documents.setDisabledRules(disabledRulesUI);
         config.removeDisabledRuleIds(disabledRulesUI);
         config.saveConfiguration(docLanguage);
-        documents.resetDocument();
+        documents.resetConfiguration();
       } else {
         config.removeDisabledRuleIds(documents.getDisabledRules());
       }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -144,6 +144,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Andere formale Systeme, deren Semantiken jeweils...");
     assertGood("Gesetz zur Änderung des Kündigungsrechts und anderer arbeitsrechtlicher Vorschriften");
     assertGood("Die dauerhafte Abgrenzung des später Niedersachsen genannten Gebietes von Westfalen begann im 12. Jahrhundert.");
+    assertGood("Lieber jemanden, der einem Tipps gibt.");
     //assertGood("... der zu dieser Zeit aber ohnehin schon allen Einfluss verloren hatte.");
 
     assertGood("Wir machen das Januar.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -1185,6 +1185,9 @@ private RuleMatch checkDetAdjNounAgreement(AnalyzedTokenReadings token1,
       if (compoundMatch != null) {
         return compoundMatch;
       }
+      if (token3.hasPartialPosTag("ABK")) {
+        return null;
+      }
       String msg = "Möglicherweise fehlende grammatische Übereinstimmung " +
             "von Kasus, Numerus oder Genus. Beispiel: 'mein kleiner Haus' " +
             "statt 'mein kleines Haus'";

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -68,7 +68,7 @@ public void testCompoundMatch() throws IOException {
   @Test
   public void testDetNounRule() throws IOException {
     // correct sentences:
-	assertGood("Die Einen sagen dies, die Anderen das.");
+	  assertGood("Die Einen sagen dies, die Anderen das.");
     assertGood("So ist es in den USA.");
     assertGood("Das ist der Tisch.");
     assertGood("Das ist das Haus.");
@@ -442,6 +442,7 @@ public void testDetAdjNounRule() throws IOException {
     assertGood("Der riesigen Tische wegen.");
     assertGood("An der roten Ampel.");
     assertGood("Dann hat das natürlich Nachteile.");
+    assertGood("Ihre erste Nr. 1");
 
     // incorrect sentences:
     assertBad("Es sind die riesigen Tisch.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -143,6 +143,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Den 2019er Wert hatten sie geschätzt.");
     assertGood("Andere formale Systeme, deren Semantiken jeweils...");
     assertGood("Gesetz zur Änderung des Kündigungsrechts und anderer arbeitsrechtlicher Vorschriften");
+    //assertGood("... der zu dieser Zeit aber ohnehin schon allen Einfluss verloren hatte.");
 
     assertGood("Wir machen das Januar.");
     assertGood("Wir teilen das Morgen mit.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -342,7 +342,8 @@ public void testRule() throws IOException {
     assertBad("Bis Bald!");
     assertGood("#4 Aktuelle Situation");
     assertGood("* [ ] Ein GitHub Markdown Listenpunkt");
-    
+    assertGood("Tom ist ein engagierter, gutaussehender Vierzigjähriger, der...");
+
     // uppercased adjective compounds
     assertGood("Er isst UV-bestrahltes Obst.");
     assertGood("Er isst Na-haltiges Obst.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule2.java
Patch:
@@ -47,6 +47,7 @@
 public class AgreementRule2 extends Rule {
 
   private static final List<List<PatternToken>> ANTI_PATTERNS = asList(
+    asList(token("Gesetzlich"), token("Krankenversicherte")),
     asList(token("weitgehend"), token("Einigkeit")),      // feste Phrase
     asList(token("Ernst")),      // Vorname
     asList(token("Anders")),     // Vorname

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/MissingCommaRelativeClauseRule.java
Patch:
@@ -54,7 +54,7 @@ public class MissingCommaRelativeClauseRule extends Rule {
 
   private static final List<List<PatternToken>> ANTI_PATTERNS = Arrays.asList(
       Arrays.asList(
-        token("wenn"),
+        regex("gerade|wenn"),
         token("das")
       ),
       Arrays.asList(

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -100,9 +100,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
     return Arrays.asList(
             new CommaWhitespaceRule(messages),
             new DoublePunctuationRule(messages),
-            new GenericUnpairedBracketsRule(messages,
-                    Arrays.asList("[", "(", "{", "“", "«", "»"),
-                    Arrays.asList("]", ")", "}", "”", "»", "«")),
+            new SpanishUnpairedBracketsRule(messages),
             new QuestionMarkRule(messages),
             new MorfologikSpanishSpellerRule(messages, this, userConfig, altLanguages),
             new UppercaseSentenceStartRule(messages, this),

File: languagetool-language-modules/es/src/test/java/org/languagetool/tokenizers/es/SpanishSentenceTokenizerTest.java
Patch:
@@ -51,6 +51,7 @@ public final void testTokenize() {
     testSplit("N.º operación 220130000138.");  
 
     // Abbreviations
+    testSplit("las Sras. diputadas");
     testSplit("No Mr. Spock sino otro.");
     testSplit("Ver el cap. 24 del libro.");
     testSplit("Ver el cap. IX del libro.");

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/LightRuleMatchParser.java
Patch:
@@ -76,6 +76,7 @@ private LightRuleMatch nodeToLightMatch(String title, JsonNode match) {
     int offset = match.get("offset").asInt();
     JsonNode rule = match.get("rule");
     String ruleId = rule.get("id").asText();
+    String fullRuleId = rule.get("subId") != null ? ruleId + "[" + rule.get("subId").asText() + "]" : ruleId;
     String message = match.get("message").asText();
     int contextOffset = match.get("context").get("offset").asInt();
     int contextLength = match.get("context").get("length").asInt();
@@ -108,7 +109,7 @@ private LightRuleMatch nodeToLightMatch(String title, JsonNode match) {
     if (rule.get("tempOff") != null && rule.get("tempOff").asBoolean()) {
       status = LightRuleMatch.Status.temp_off;
     }
-    return new LightRuleMatch(0, offset, ruleId, message, context, coveredText, suggestions, ruleSource, title, status);
+    return new LightRuleMatch(0, offset, fullRuleId, message, context, coveredText, suggestions, ruleSource, title, status);
   }
 
   List<LightRuleMatch> parseOutput(Reader reader) {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -887,7 +887,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     putRepl("voluptös(e|ere|este)?[mnrs]?$", "tös", "tuös");
     putRepl("[pP]flanzig(e[mnrs]?)?", "ig", "lich");
     putRepl("geblogt(e[mnrs]?)?$", "gt", "ggt");
-    putRepl("herraus.*", "herraus", "heraus");  }
+    putRepl("herraus.*", "herraus", "heraus");
     put("aufgehangen", "aufgehängt");
     put("Ehrenamtpauschale", "Ehrenamtspauschale");
     put("Geborgsamkeit", "Geborgenheit");
@@ -899,6 +899,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     put("Werksresett", "Werksreset");
     put("wiederfahren", "widerfahren");
     put("wiederspiegelten", "widerspiegelten");
+  }
 
   private static void putRepl(String wordPattern, String pattern, String replacement) {
     ADDITIONAL_SUGGESTIONS.put(Pattern.compile(wordPattern), w -> Collections.singletonList(w.replaceFirst(pattern, replacement)));

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -830,6 +830,7 @@ public List<RuleMatch> check(AnnotatedText annotatedText, boolean tokenizeText,
     if (remoteRulesThreadPool != null && mode != Mode.TEXTLEVEL_ONLY) {
       remoteRuleTasks = allRules.stream()
         .filter(rule -> rule instanceof RemoteRule)
+        .filter(rule -> !ignoreRule(rule))
         .map(rule -> ((RemoteRule) rule).run(analyzedSentences))
         .collect(Collectors.toList());
       remoteRuleTasks.forEach(remoteRulesThreadPool::submit);

File: languagetool-core/src/main/java/org/languagetool/language/CommonWords.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.language;
 
+import org.apache.commons.lang3.StringUtils;
 import org.languagetool.*;
 import org.languagetool.broker.ResourceDataBroker;
 
@@ -93,7 +94,7 @@ public CommonWords() throws IOException {
 
   public Map<Language, Integer> getKnownWordsPerLanguage(String text) {
     Map<Language,Integer> result = new HashMap<>();
-    if (!text.endsWith(" ")) {
+    if (!text.endsWith(" ") && StringUtils.countMatches(text, " ") > 0) {
       // last word might not be finished yet, so ignore
       text = text.replaceFirst("\\p{L}+$", "");
     }

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -163,6 +163,7 @@ public int getPriorityForId(String id) {
       case "SUBJUNTIVO_FUTURO": return -30;
       case "SUBJUNTIVO_PASADO": return -30;
       case "SUBJUNTIVO_PASADO2": return -30;
+      case "VOSEO": return -40;
     }
     return super.getPriorityForId(id);
   }

File: languagetool-language-modules/es/src/main/java/org/languagetool/tagging/es/SpanishTagger.java
Patch:
@@ -67,7 +67,7 @@ public List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens) {
         addTokens(lowerTaggerTokens, l);
       }
       // tag all-uppercase proper nouns (ex. FRANCIA)
-      if (l.isEmpty() && isAllUpper) {
+      if (isAllUpper) {
         final String firstUpper = StringTools.uppercaseFirstChar(lowerWord);
         List<AnalyzedToken> firstupperTaggerTokens = asAnalyzedTokenListForTaggedWords(word,
             getWordTagger().tag(firstUpper));

File: languagetool-language-modules/es/src/test/java/org/languagetool/tagging/es/SpanishTaggerTest.java
Patch:
@@ -49,6 +49,9 @@ public void testTagger() throws IOException {
     TestTools.myAssert("alucinadamente", "alucinadamente/[alucinadamente]RG", tokenizer, tagger);
     TestTools.myAssert("disputadamente", "disputadamente/[disputadamente]RG", tokenizer, tagger);
     
+    // all-upper case that is common noun & proper noun
+    TestTools.myAssert("RIOJA", "RIOJA/[Rioja]NPCNG00|RIOJA/[rioja]NCMS000", tokenizer, tagger);
+    
     TestTools.myAssert("dímelo", "dímelo/[decir]VMM02S0+PP1CS000+PP3MSA00", tokenizer, tagger);
 
     TestTools.myAssert("Soy un hombre muy honrado.",

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingletonFactory.java
Patch:
@@ -31,7 +31,8 @@
  */
 public class SingletonFactory implements XSingleComponentFactory, XServiceInfo {
 
-  private transient org.languagetool.openoffice.Main instance;
+//  private transient org.languagetool.openoffice.Main instance;
+  private static org.languagetool.openoffice.Main instance = null;
 
   @Override
   public final Object createInstanceWithArgumentsAndContext(Object[] arguments, 

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/MorfologikUkrainianSpellerRule.java
Patch:
@@ -163,10 +163,10 @@ protected List<SuggestedReplacement> filterSuggestions(List<SuggestedReplacement
   MorfologikMultiSpeller getSpeller1() {
     if( speller1 == null ) {
       try {
-        // we can't call initSpellers() as it's private
+        // we can't call initSpellers() as it's private so we're calling method we can
         isMisspelled("1");
       } catch (IOException e) {
-        e.printStackTrace();
+        throw new RuntimeException(e);
       }
     }
     return speller1;

File: languagetool-language-modules/ru/src/main/java/org/languagetool/language/Russian.java
Patch:
@@ -116,9 +116,10 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
         //  new PunctuationMarkAtParagraphEnd2(messages, this),
         //  new ReadabilityRule(messages, this, userConfig, false), // need use localise rule
         //  new ReadabilityRule(messages, this, userConfig, true),  // need use localise rule
-        
+     
             
                 // specific to Russian :
+            new MorfologikRussianYOSpellerRule(messages, this, userConfig, altLanguages), // This rule must set off by default!!!
             new RussianUnpairedBracketsRule(messages, this),
             new RussianCompoundRule(messages),
             new RussianSimpleReplaceRule(messages),

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/RuleMatchDiffFinder.java
Patch:
@@ -215,7 +215,7 @@ private void run(LightRuleMatchParser parser, File file1, File file2, File file3
       print(diffs, fw);
       fw.write("<script>\n" +
                "var tf = new TableFilter(document.querySelector('.sortable_table'), {\n" +
-               "    base_path: '../tablefilter/',\n" +
+               "    base_path: 'https://unpkg.com/tablefilter@0.7.0/dist/tablefilter/',\n" +
                "    col_0: 'select',\n" +
                "    col_1: 'select',\n" +
                "    auto_filter: { delay: 100 },\n" +

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/RuleMatchDiffFinder.java
Patch:
@@ -202,7 +202,7 @@ private void run(LightRuleMatchParser parser, File file1, File file2, File file3
       fw.write("<head>\n");
       fw.write("  <title>" + title + "</title>\n");
       fw.write("  <meta charset='utf-8'>\n");
-      fw.write("  <script src='/regression-tests/tablefilter/tablefilter.js'></script>\n");  // https://github.com/koalyptus/TableFilter/
+      fw.write("  <script src='https://unpkg.com/tablefilter@0.7.0/dist/tablefilter/tablefilter.js'></script>\n");  // https://github.com/koalyptus/TableFilter/
       fw.write("  <style>\n");
       fw.write("    .sentence { color: #666; }\n");
       fw.write("    .marker { text-decoration: underline; }\n");

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/RussianWordRepeatRule.java
Patch:
@@ -52,10 +52,10 @@ public class RussianWordRepeatRule extends AdvancedWordRepeatRule {
   /**
    * Excluded part of speech classes.
    */
-  private static final Pattern EXC_POS = Pattern.compile("INTERJECTION|PRDC|PREP|CONJ|PARTICLE|PNN:.*|NumC:.*|Num:.*");
+  private static final Pattern EXC_POS = Pattern.compile("INTERJECTION|PRDC|PREP|CONJ|PARTICLE|NumC:.*|Num:.*"); 
 
   /**
-   * Excluded non-words (special symbols, Roman numerals etc.)
+   * Excluded non-words (special symbols, Roman numerals etc.) (remove from exclude PNN:.*)
    */
   private static final Pattern EXC_NONWORDS = Pattern
       .compile("&quot|&gt|&lt|&amp|[0-9].*|"

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Tools.java
Patch:
@@ -324,7 +324,7 @@ private static String getExampleSentences(Rule rule, ResourceBundle messages) {
     } else if (incorrectExamples.size() > 0) {
       IncorrectExample incorrectExample = incorrectExamples.iterator().next();
       List<String> corrections = incorrectExample.getCorrections();
-      if (!corrections.isEmpty()) {
+      if (!corrections.isEmpty() && !corrections.get(0).isEmpty()) {
         String incorrectSentence = incorrectExamples.iterator().next().getExample();
         String correctedSentence = incorrectSentence.replaceAll("<marker>.*?</marker>",
                 "<span style='background-color:#80ff80'>" + corrections.get(0) + "</span>");

File: languagetool-language-modules/uk/src/main/java/org/languagetool/tagging/uk/UkrainianTagger.java
Patch:
@@ -47,7 +47,7 @@ public class UkrainianTagger extends BaseTagger {
 
   private static final Pattern NUMBER = Pattern.compile("[+-±]?[€₴\\$]?[0-9]+(,[0-9]+)?([-–—][0-9]+(,[0-9]+)?)?(%|°С?)?|\\d{1,3}([\\s\u00A0\u202F]\\d{3})+");
   // full latin number regex: M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})
-  private static final Pattern LATIN_NUMBER = Pattern.compile("(XC|XL|L?X{1,3})?(IX|IV|V?I{1,3})");
+  private static final Pattern LATIN_NUMBER = Pattern.compile("(XC|XL|L?X{1,3})?(IX|IV|V?I{1,3})|X");
   private static final Pattern LATIN_NUMBER_CYR = Pattern.compile("[IXІХ]|[IІ]V|V?[IІ]{1,3}");
 
   private static final Pattern DATE = Pattern.compile("[\\d]{2}\\.[\\d]{2}\\.[\\d]{4}");

File: languagetool-language-modules/uk/src/test/java/org/languagetool/tagging/uk/UkrainianTaggerTest.java
Patch:
@@ -89,6 +89,7 @@ public void testNumberTagging() throws IOException {
 
     TestTools.myAssert("XIX", "XIX/[XIX]number:latin", tokenizer, tagger);
     TestTools.myAssert("II", "II/[II]number:latin", tokenizer, tagger);
+    TestTools.myAssert("X", "X/[X]number:latin", tokenizer, tagger);
 
     // latin number with cyrillic
     TestTools.myAssert("ХІХ", "ХІХ/[ХІХ]number:latin:bad", tokenizer, tagger);
@@ -511,7 +512,7 @@ public void testDynamicTaggingOWithAdj() throws IOException {
     TestTools.myAssert("три-чотириметровий", "три-чотириметровий/[три-чотириметровий]adj:m:v_kly|три-чотириметровий/[три-чотириметровий]adj:m:v_naz|три-чотириметровий/[три-чотириметровий]adj:m:v_zna:rinanim", tokenizer, tagger);
 
     // :bad
-    TestTools.myAssert("трьох-чотирьохметровий", "трьох-чотирьохметровий/[трьох-чотирьохметровий]adj:m:v_kly:bad|трьох-чотирьохметровий/[трьох-чотирьохметровий]adj:m:v_naz:bad|трьох-чотирьохметровий/[трьох-чотирьохметровий]adj:m:v_zna:rinanim:bad", tokenizer, tagger);
+//    TestTools.myAssert("трьох-чотирьохметровий", "трьох-чотирьохметровий/[трьох-чотирьохметровий]adj:m:v_kly:bad|трьох-чотирьохметровий/[трьох-чотирьохметровий]adj:m:v_naz:bad|трьох-чотирьохметровий/[трьох-чотирьохметровий]adj:m:v_zna:rinanim:bad", tokenizer, tagger);
 //    TestTools.myAssert("двох-сторонній", "двох-сторонній/[двох-сторонній]adj:f:v_dav:bad|двох-сторонній/[двох-сторонній]adj:f:v_mis:bad|двох-сторонній/[двох-сторонній]adj:m:v_kly:bad|двох-сторонній/[двох-сторонній]adj:m:v_naz:bad|двох-сторонній/[двох-сторонній]adj:m:v_zna:rinanim:bad", tokenizer, tagger);
 
     TestTools.myAssert("Художньо-культурний", "Художньо-культурний/[художньо-культурний]adj:m:v_kly|Художньо-культурний/[художньо-культурний]adj:m:v_naz|Художньо-культурний/[художньо-культурний]adj:m:v_zna:rinanim", tokenizer, tagger);

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/QuestionMarkRule.java
Patch:
@@ -82,11 +82,11 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) {
           }
           // put the question mark in: ¿de qué... ¿para cuál... ¿cómo...
           if (i > 2 && i + 1 < tokens.length) {
-            if (tokens[i].hasPosTag("SPS00")
+            if (tokens[i - 1].getToken().equals(",") && tokens[i].hasPosTag("SPS00")
                 && (tokens[i + 1].hasPosTagStartingWith("PT") || tokens[i + 1].hasPosTagStartingWith("DT"))) {
               firstToken = tokens[i];
             }
-            if (!tokens[i - 1].hasPosTag("SPS00")
+            if (tokens[i - 1].getToken().equals(",")
                 && (tokens[i].hasPosTagStartingWith("PT") || tokens[i].hasPosTagStartingWith("DT"))) {
               firstToken = tokens[i];
             }

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/UpperCaseNgramRule.java
Patch:
@@ -172,7 +172,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
           double ratio = lcProb.getProb() / ucProb.getProb();
           //System.out.println("-->" + ucProb + ", lc: " + lcProb + " ==> " + ratio);
           if (ratio > THRESHOLD) {
-            String msg = "Only proper nouns start with an uppercase character (there are exceptions for headlines). " + ratio;
+            String msg = "Only proper nouns start with an uppercase character (there are exceptions for headlines).";
             RuleMatch match = new RuleMatch(this, sentence, token.getStartPos(), token.getEndPos(), msg);
             match.setSuggestedReplacement(StringTools.lowercaseFirstChar(tokenStr));
             matches.add(match);

File: languagetool-language-modules/uk/src/main/java/org/languagetool/tagging/uk/UkrainianTagger.java
Patch:
@@ -47,7 +47,7 @@ public class UkrainianTagger extends BaseTagger {
 
   private static final Pattern NUMBER = Pattern.compile("[+-±]?[€₴\\$]?[0-9]+(,[0-9]+)?([-–—][0-9]+(,[0-9]+)?)?(%|°С?)?|\\d{1,3}([\\s\u00A0\u202F]\\d{3})+");
   // full latin number regex: M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})
-  private static final Pattern LATIN_NUMBER = Pattern.compile("(XC|XL|L?X{1,3})(IX|IV|V?I{0,3})");
+  private static final Pattern LATIN_NUMBER = Pattern.compile("(XC|XL|L?X{1,3})?(IX|IV|V?I{1,3})");
   private static final Pattern LATIN_NUMBER_CYR = Pattern.compile("[IXІХ]|[IІ]V|V?[IІ]{1,3}");
 
   private static final Pattern DATE = Pattern.compile("[\\d]{2}\\.[\\d]{2}\\.[\\d]{4}");

File: languagetool-language-modules/uk/src/test/java/org/languagetool/rules/uk/SimpleReplaceRuleTest.java
Patch:
@@ -78,6 +78,9 @@ public void testRule() throws IOException {
 
     matches = rule.match(langTool.getAnalyzedSentence("щедроти"));
     assertEquals(0, matches.length);
+
+    matches = rule.match(langTool.getAnalyzedSentence("Конрадом II і Генріхом III"));
+    assertEquals(0, matches.length);
   }
 
   @Test

File: languagetool-language-modules/uk/src/test/java/org/languagetool/tagging/uk/UkrainianTaggerTest.java
Patch:
@@ -88,6 +88,8 @@ public void testNumberTagging() throws IOException {
     TestTools.myAssert("3,5-5,6% 7° 7,4°С", "3,5-5,6%/[3,5-5,6%]number -- 7°/[7°]number -- 7,4°С/[7,4°С]number", tokenizer, tagger);
 
     TestTools.myAssert("XIX", "XIX/[XIX]number:latin", tokenizer, tagger);
+    TestTools.myAssert("II", "II/[II]number:latin", tokenizer, tagger);
+
     // latin number with cyrillic
     TestTools.myAssert("ХІХ", "ХІХ/[ХІХ]number:latin:bad", tokenizer, tagger);
     TestTools.myAssert("ІV", "ІV/[ІV]number:latin:bad", tokenizer, tagger);

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -155,12 +155,14 @@ public int getPriorityForId(String id) {
       case "CONFUSIONS": return 40;
       case "NO_SEPARADO": return 40;
       case "DIACRITICS": return 30;
-      case "ACCENTUATION_CHECK_ES": return 30;
       case "AGREEMENT_DET_NOUN": return 20;
       case "TYPOGRAPHY": return 10;
       case "HALLA_HAYA": return 10;
       case "EL_TILDE": return -10;
       case "PREPOSICION_VERBO": return -20;
+      case "SUBJUNTIVO_FUTURO": return -30;
+      case "SUBJUNTIVO_PASADO": return -30;
+      case "SUBJUNTIVO_PASADO2": return -30;
     }
     return super.getPriorityForId(id);
   }

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/DiacriticsCheckFilter.java
Patch:
@@ -48,7 +48,8 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
     if (gendernumber_from != null) {
       int i = Integer.parseInt(gendernumber_from);
       if (i < 1 || i > patternTokens.length) {
-        throw new IllegalArgumentException("Index out of bounds in "+match.getRule().getFullId() + " DiacriticsCheckFilter: " + i);
+        throw new IllegalArgumentException(
+            "DiacriticsCheckFilter: Index out of bounds in " + match.getRule().getFullId() + ", value: " + i);
       }
       AnalyzedTokenReadings atr = patternTokens[i - 1];
       if (atr.matchesPosTagRegex(".+MS.*")) { desiredGenderNumberPattern = MS;}

File: languagetool-dev/src/main/java/org/languagetool/dev/httpchecker/CheckCallable.java
Patch:
@@ -81,7 +81,9 @@ public File call() throws Exception {
           String textToCheck = String.join("\n\n", tempLines);
           URL url = Tools.getUrl(baseUrl + "/v2/check");
           //System.out.println("textToCheck: " + textToCheck);
-          String postData = "language=" + langCode + "&text=" + URLEncoder.encode(textToCheck, "UTF-8");
+          String postData = "language=" + langCode +
+              "&text=" + URLEncoder.encode(textToCheck, "UTF-8") +
+              "&enableTempOffRules=true";
           postData += token != null ? "&token=" + URLEncoder.encode(token, "UTF-8"): "";
           String tokenInfo = token != null ? " with token" : " without token";
           float progress = (float)i / allLines.size() * 100.0f;

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/UpperCaseNgramRuleTest.java
Patch:
@@ -65,7 +65,6 @@ public void testFirstLongWordToLeftIsUppercase() throws IOException, URISyntaxEx
       assertFalse(rule.firstLongWordToRightIsUppercase(tokens1, 10));  // 10 = ","
 
       AnalyzedTokenReadings[] tokens2 = lt.getAnalyzedSentence("From Theory to Practice, followed by some other words").getTokens();
-      System.out.println(">" + tokens2[3]);
       // left:
       assertFalse(rule.firstLongWordToLeftIsUppercase(tokens2, 3));  // 3 = "Theory"
       assertTrue(rule.firstLongWordToLeftIsUppercase(tokens2, 4));   // 4 = "to"

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/LightRuleMatch.java
Patch:
@@ -41,7 +41,7 @@ enum Status {
 
   LightRuleMatch(int line, int column, String ruleId, String message, String context, String coveredText,
                  String suggestions, String ruleSource, String title, Status status) {
-    this.line =  line;
+    this.line = line;
     this.column = column;
     this.fullRuleId = Objects.requireNonNull(ruleId);
     this.message = Objects.requireNonNull(message);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -80,6 +80,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     putRepl("wiederleg(e|st|t|en|te|ten)?", "wieder", "wider");
     putRepl("wiederhall(e|st|t|en|te|ten)?", "wieder", "wider");
     putRepl("wiedersetz(e|t|en|te|ten)?", "wieder", "wider");
+    putRepl("wiederstreb(e|st|t|en|te|ten)?", "wieder", "wider");
     put("wiederspiegelten", "widerspiegelten");
     put("wiedererwarten", "wider Erwarten");
     put("wiederhohlen", "wiederholen");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -283,6 +283,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Die Präsent AG.");
     assertGood("In New York war er der Titelheld in Richard III. und spielte den Mark Anton in Julius Cäsar.");
     assertGood("Vielen Dank fürs Bescheid geben.");
+    assertGood("Welche Display Ads?");
 
     // incorrect sentences:
     assertBad("Ein Buch mit einem ganz ähnlichem Titel.");

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/dumpcheck/SentenceSourceChecker.java
Patch:
@@ -171,7 +171,7 @@ private void run(File propFile, Set<String> disabledRules, String langCode,
         boolean enable = false;
         if (rule instanceof AbstractPatternRule) {
           String sourceFile = ((AbstractPatternRule) rule).getSourceFile();
-          if (sourceFile != null && sourceFile.endsWith("/" + ruleSource)) {
+          if (sourceFile != null && sourceFile.endsWith("/" + ruleSource) && !rule.isDefaultOff()) {
             enable = true;
             activatedBySource++;
           }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -81,6 +81,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     putRepl("wiedersetz(e|t|en|te|ten)?", "wieder", "wider");
     put("wiederspiegelten", "widerspiegelten");
     put("wiedererwarten", "wider Erwarten");
+    put("wiederhohlen", "wiederholen");
     put("herrunterladen", "herunterladen");
     put("dastellen", "darstellen");
     put("zuviel", "zu viel");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -78,9 +78,11 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     putRepl("wiederrief(st|t|en)?", "wieder", "wider");
     putRepl("wiederleg(e|st|t|en|te|ten)?", "wieder", "wider");
     putRepl("wiederhall(e|st|t|en|te|ten)?", "wieder", "wider");
+    putRepl("wiedersetz(e|t|en|te|ten)?", "wieder", "wider");
     put("wiederspiegelten", "widerspiegelten");
     put("wiedererwarten", "wider Erwarten");
     put("herrunterladen", "herunterladen");
+    put("dastellen", "darstellen");
     put("zuviel", "zu viel");
     put("abgekatertes", "abgekartetes");
     put("wiederspiegelt", "widerspiegelt");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -77,6 +77,9 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     putRepl("wiederruf(e|st|t|en)?", "wieder", "wider");
     putRepl("wiederrief(st|t|en)?", "wieder", "wider");
     putRepl("wiederleg(e|st|t|en|te|ten)?", "wieder", "wider");
+    putRepl("wiederhall(e|st|t|en|te|ten)?", "wieder", "wider");
+    put("wiederspiegelten", "widerspiegelten");
+    put("wiedererwarten", "wider Erwarten");
     put("herrunterladen", "herunterladen");
     put("zuviel", "zu viel");
     put("abgekatertes", "abgekartetes");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -70,6 +70,9 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
   static {
     put("lieder", w -> Arrays.asList("leider", "Lieder"));
     put("inbetracht", "in Betracht");
+    put("einlogen", "einloggen");
+    putRepl("wiedersteh(en|st|t)", "wieder", "wider");
+    putRepl("wiederstan(d|den|dest)", "wieder", "wider");
     put("zuviel", "zu viel");
     put("abgekatertes", "abgekartetes");
     put("wiederspiegelt", "widerspiegelt");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanTest.java
Patch:
@@ -161,7 +161,8 @@ public void testSwissSpellingVariants() throws IOException {
   private boolean lacksSwitzerlandSpelling(String pattern) {
     return pattern != null && pattern.contains("ß") 
       && !pattern.contains("(ß|ss)") 
-      && !containsSwitzerlandSpelling(pattern) 
+      && !pattern.contains("(ss|ß)")
+      && !containsSwitzerlandSpelling(pattern)
       && !allInBrackets('ß', pattern);
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -869,6 +869,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     put("wiederfahren", "widerfahren");
     put("wiederspiegelten", "widerspiegelten");
     putRepl("herraus.*", "herraus", "heraus");
+    put("aufgehangen", "aufgehängt");
   }
 
   private static void putRepl(String wordPattern, String pattern, String replacement) {

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/SimpleReplaceSpelling1992Rule.java
Patch:
@@ -89,7 +89,7 @@ private RuleMatch[] findTagged1922(AnalyzedSentence sentence) {
     for (int i = 1; i < tokens.length; i++) {
       AnalyzedTokenReadings tokenReadings = tokens[i];
 
-      if( PosTagHelper.hasPosTagPart(tokenReadings, "ua_1992") ) {
+      if( PosTagHelper.hasPosTagPartAll(tokenReadings, "ua_1992") ) {
         RuleMatch potentialRuleMatch = new RuleMatch(this, sentence, tokenReadings.getStartPos(), tokenReadings.getEndPos(), 
             getShort(), getShort());
         

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LinguisticServices.java
Patch:
@@ -152,7 +152,7 @@ private static void printMessage(Throwable t) {
     MessageHandler.printException(t);
   }
   
-  private static Locale getLocale(Language lang) {
+  public static Locale getLocale(Language lang) {
     Locale locale = new Locale();
     locale.Language = lang.getShortCode();
     locale.Country = lang.getCountries()[0];

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -78,6 +78,7 @@ public class MultiDocumentsHandler {
   private SortedTextRules sortedTextRules;
   private Set<String> disabledRulesUI;      //  Rules disabled by context menu or spell dialog
   private final List<Rule> extraRemoteRules;      //  store of rules supported by remote server but not locally
+  private LtDictionary dictionary;
   
   private XComponentContext xContext;       //  The context of the document
   private List<SingleDocument> documents;   //  The List of LO documents to be checked
@@ -106,6 +107,7 @@ public class MultiDocumentsHandler {
     documents = new ArrayList<>();
     disabledRulesUI = new HashSet<>();
     extraRemoteRules = new ArrayList<>();
+    dictionary = new LtDictionary();
   }
   
   /**
@@ -581,6 +583,7 @@ void initDocuments() {
     for (SingleDocument document : documents) {
       document.resetCache();
     }
+    dictionary.setLtDictionary(xContext, langTool, configDir.getPath());
     if(useQueue) {
       if(textLevelQueue == null) {
         textLevelQueue = new TextLevelCheckQueue(this);

File: languagetool-core/src/main/java/org/languagetool/rules/Rule.java
Patch:
@@ -42,6 +42,7 @@
  * @author Daniel Naber
  */
 public abstract class Rule {
+  private static final Category MISC = new Category(CategoryIds.MISC, "Miscellaneous");
 
   protected final ResourceBundle messages;
 
@@ -68,7 +69,7 @@ public Rule(ResourceBundle messages) {
     if (messages != null) {
       setCategory(Categories.MISC.getCategory(messages));  // the default, sub classes may overwrite this
     } else {
-      setCategory(new Category(CategoryIds.MISC, "Miscellaneous"));
+      setCategory(MISC);
     }
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/MatchState.java
Patch:
@@ -308,7 +308,7 @@ public final String[] toFinalString(Language lang) throws IOException {
       for (int i = 0; i < formattedString.length; i++) {
         AnalyzedToken analyzedToken = analyzed.get(i).getAnalyzedToken(0);
         if (analyzedToken.getLemma() == null && analyzedToken.hasNoTag()) {
-          formattedString[i] = "";
+          formattedString[i] = PatternRuleMatcher.MISTAKE;
         }
       }
     }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/AccentuationCheckRule.java
Patch:
@@ -194,7 +194,8 @@ && matchPostagRegexp(tokens[i - 2], VERB_CONJUGAT)
           replacement = relevantWords.get(token).getToken();
         }
      // les vertebres properes
-        else if (i < tokens.length - 1 &&
+        else if (i < tokens.length - 1 && !token.equals("tenia") && !token.equals("tenies") 
+            && !token.equals("faria") && !token.equals("faries") && 
             ((mArticleELMS.matches() && matchPostagRegexp(relevantWords.get(token), NOM_MS) && matchPostagRegexp(tokens[i + 1], ADJECTIU_MS))
             || (mArticleELMP.matches() && matchPostagRegexp(relevantWords.get(token), NOM_MP) && matchPostagRegexp(tokens[i + 1], ADJECTIU_MP))
             || (mArticleELFS.matches() && matchPostagRegexp(relevantWords.get(token), NOM_FS) && matchPostagRegexp(tokens[i + 1], ADJECTIU_FS)) 

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -47,6 +47,9 @@ public void setUp() throws IOException {
   public void testRule() throws IOException {
 
     // correct sentences:
+    assertCorrect("I la faria desgraciada");
+    assertCorrect("jo ja la tenia incorporada abans");
+    assertCorrect("tu ja les tenies incorporades abans");
     assertCorrect("Quan anunciïs una votació, especifica de quina es tracta");
     //assertCorrect("Quina classe de política practica la UE.");
     assertCorrect("Tu practiques tècniques de ioga");

File: languagetool-language-modules/nl/src/main/java/org/languagetool/language/Dutch.java
Patch:
@@ -136,7 +136,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new SimpleReplaceRule(messages),
             new LongSentenceRule(messages, userConfig, -1, true),
             new PreferredWordRule(messages),
-            new MissingSpaceRule(messages),
+            new SpaceInCompoundRule(messages),
             new SentenceWhitespaceRule(messages)
     );
   }

File: languagetool-language-modules/nl/src/main/java/org/languagetool/rules/nl/SpaceInCompoundRule.java
Patch:
@@ -26,12 +26,12 @@
 
 import java.util.*;
 
-public class MissingSpaceRule extends Rule {
+public class SpaceInCompoundRule extends Rule {
 
   private static final Map<String, String> normalizedCompound2message = new HashMap<>();
   private static final AhoCorasickDoubleArrayTrie<String> trie = getTrie();
 
-  public MissingSpaceRule(ResourceBundle messages) {
+  public SpaceInCompoundRule(ResourceBundle messages) {
     setDefaultTempOff();  // TODO
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -117,8 +117,8 @@ public SpellingCheckRule(ResourceBundle messages, Language language, UserConfig
 
   /**
    *  @param word misspelled word that suggestions should be generated for
-   * @param userCandidates candidates from personal dictionary
-   * @param candidates candidates from default dictionary
+   * @param userCandidatesList candidates from personal dictionary
+   * @param candidatesList candidates from default dictionary
    * @param orderer model to rank suggestions / extract features, or null
    * @param match rule match to add suggestions to
    */

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -254,10 +254,10 @@ public void setConsiderIgnoreWords(boolean considerIgnoreWords) {
    */
   protected List<SuggestedReplacement> getAdditionalTopSuggestions(List<SuggestedReplacement> suggestions, String word) throws IOException {
     List<String> moreSuggestions = new ArrayList<>();
-    if (("Languagetool".equals(word) || "languagetool".equals(word)) && !suggestions.contains(LANGUAGETOOL)) {
+    if (("Languagetool".equals(word) || "languagetool".equals(word)) && suggestions.stream().noneMatch(k -> k.getReplacement().equals(LANGUAGETOOL))) {
       moreSuggestions.add(LANGUAGETOOL);
     }
-    if (("Languagetooler".equals(word) || "languagetooler".equals(word)) && !suggestions.contains(LANGUAGETOOLER)) {
+    if (("Languagetooler".equals(word) || "languagetooler".equals(word)) && suggestions.stream().noneMatch(k -> k.getReplacement().equals(LANGUAGETOOLER))) {
       moreSuggestions.add(LANGUAGETOOLER);
     }
     return SuggestedReplacement.convert(moreSuggestions);

File: languagetool-server/src/test/java/org/languagetool/server/HTTPSServerTest.java
Patch:
@@ -142,7 +142,7 @@ private void runTests() throws IOException {
 
     StringBuilder longText = new StringBuilder();
     while (longText.length() < 490) {
-      longText.append("B ");
+      longText.append("Run ");
     }
     String result2 = HTTPTools.checkAtUrl(new URL(httpsPrefix + "?text=" + encode(longText.toString()) + "&language=en"));
     assertTrue("Got " + result2, !result2.contains("UPPERCASE_SENTENCE_START"));

File: languagetool-core/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -44,6 +44,7 @@ public class WordListValidatorTest {
   private static final Set<String> VALID_WORDS = new HashSet<>(Arrays.asList(
           "Będzin",
           "Bhagavad-gītā",
+          "Sønderjylland/S",
           "Božena/S",
           "Brăila/S",
           "Timișoara/S",

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/FrenchCompoundAwareHunspellRule.java
Patch:
@@ -97,7 +97,7 @@ protected List<SuggestedReplacement> getAdditionalTopSuggestions(List<SuggestedR
     return SuggestedReplacement.convert(s);
   }
 
-  /*@Override
+  @Override
   protected boolean ignoreWord(String word) throws IOException {
     boolean ignore = super.ignoreWord(word);
     if (ignore) {
@@ -112,6 +112,6 @@ protected boolean ignoreWord(String word) throws IOException {
       }
     }
     return false;
-  }*/
+  }
 
 }

File: languagetool-language-modules/fr/src/test/java/org/languagetool/rules/fr/FrenchCompoundAwareHunspellRuleTest.java
Patch:
@@ -50,6 +50,7 @@ public void testSpellcheck() throws IOException {
     assertSuggestion(lt, "skype", "Skype");
     assertSuggestion(lt, "Wordpress", "WordPress");
     assertSuggestion(lt, "wordpress", "WordPress");
+    assertThat(lt.check("Et d'Harvard").size(), is(0));
   }
 
   private void assertSuggestion(JLanguageTool lt, String input, String... expected) throws IOException {

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -105,7 +105,7 @@ public class JLanguageTool {
   @Nullable
   private static String getBuildDate() {
     try {
-      URL res = JLanguageTool.class.getResource(JLanguageTool.class.getSimpleName() + ".class");
+      URL res = getDataBroker().getAsURL("/" + JLanguageTool.class.getName().replace('.', '/') + ".class");
       if (res == null) {
         // this will happen on Android, see http://stackoverflow.com/questions/15371274/
         return null;
@@ -129,7 +129,7 @@ private static String getBuildDate() {
   @Nullable
   private static String getShortGitId() {
     try {
-      InputStream in = getDataBroker().getAsStream("git.properties");
+      InputStream in = getDataBroker().getAsStream("/git.properties");
       if (in != null) {
         Properties props = new Properties();
         props.load(in);

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -105,7 +105,7 @@ public class JLanguageTool {
   @Nullable
   private static String getBuildDate() {
     try {
-      URL res = getDataBroker().getAsURL(JLanguageTool.class.getSimpleName() + ".class");
+      URL res = JLanguageTool.class.getResource(JLanguageTool.class.getSimpleName() + ".class");
       if (res == null) {
         // this will happen on Android, see http://stackoverflow.com/questions/15371274/
         return null;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -118,10 +118,11 @@ ProofreadingResult getCheckResults(String paraText, Locale locale, ProofreadingR
       return paRes;
     }
     if(!switchOff) {
+      boolean isSameLanguage = true;
       if(fixedLanguage == null || langForShortName == null) {
         langForShortName = getLanguage(locale);
+        isSameLanguage = langForShortName.equals(docLanguage);
       }
-      boolean isSameLanguage = langForShortName.equals(docLanguage);
       if (!isSameLanguage || langTool == null || recheck) {
         if (!isSameLanguage) {
           docLanguage = langForShortName;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -537,6 +537,9 @@ private int getParaFromViewCursorOrDialog(String chPara) {
       }
     }
     isMouseOrDialog = false;
+    if (debugMode > 0) {
+      MessageHandler.printToLogFile("From Dialog: Paragraph not found: return -1" + OfficeTools.LOG_LINE_BREAK);
+    }
     return -1;
   }
   

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/TextLevelCheckQueue.java
Patch:
@@ -48,12 +48,13 @@ public class TextLevelCheckQueue {
   private boolean queueRuns = false;
   private boolean queueWaits = false;
 
-  private static final boolean debugMode = false;   //  should be false except for testing
+  private static boolean debugMode = false;   //  should be false except for testing
   
   TextLevelCheckQueue(MultiDocumentsHandler multiDocumentsHandler) {
     multiDocHandler = multiDocumentsHandler;
     queueIterator = new QueueIterator();
     queueIterator.start();
+    debugMode = OfficeTools.DEBUG_MODE_TQ;
   }
  
  /**
@@ -204,6 +205,7 @@ public void interruptCheck(String docId) {
    */
   private void waitForInterrupt() {
     interruptCheck = true;
+    wakeupQueue();
     while(interruptCheck) {
       try {
         Thread.sleep(1);

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/SimpleReplaceAnglicismRule.java
Patch:
@@ -57,7 +57,7 @@ public SimpleReplaceAnglicismRule(final ResourceBundle messages) throws IOExcept
 
   @Override
   public final String getId() {
-    return "ES_SIMPLE_REPLACE";
+    return "ES_SIMPLE_REPLACE_ANGLICISM";
   }
 
  @Override

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -196,7 +196,7 @@ public int getEndOfParaCheck(int numCurPara, int parasToCheck, boolean textIsCha
     if(headingAfter == numCurPara) {
       return headingAfter + 1;
     }
-    if(headingAfter < numCurPara) {
+    if(headingAfter < numCurPara || headingAfter > toParaMapping.size()) {
       headingAfter = toParaMapping.size();
     }
     if(parasToCheck < 0) {

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishDiacriticsRule.java
Patch:
@@ -32,7 +32,7 @@
 import java.net.URL;
 
 /**
- * A rule that matches words which are complex and suggests easier to understand alternatives. 
+ * A rule that matches words which require specific diacritics (e.g, {@code a la} instead of {@code à la}).
  *
  * @author Tiago F. Santos 
  * @since 4.8

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/SpecificCaseRule.java
Patch:
@@ -27,7 +27,7 @@
 import java.util.*;
 
 /**
- * A rule that matches words which are complex and suggests easier to understand alternatives. 
+ * A rule that matches words which need a specific upper/lowercase spelling.
  * @since 4.8
  */
 public class SpecificCaseRule extends Rule {

File: languagetool-language-modules/ga/src/main/java/org/languagetool/rules/ga/IrishSpecificCaseRule.java
Patch:
@@ -27,7 +27,7 @@
 import java.util.*;
 
 /**
- * A rule that matches words which are complex and suggests easier to understand alternatives. 
+ * A rule that matches words which need a specific upper/lowercase spelling.
  * @since 4.8
  */
 public class IrishSpecificCaseRule extends Rule {

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseDiacriticsRule.java
Patch:
@@ -32,7 +32,7 @@
 import java.net.URL;
 
 /**
- * A rule that matches words which are complex and suggests easier to understand alternatives. 
+ * A rule that matches words which require specific diacritics (e.g, {@code a la} instead of {@code à la}).
  *
  * @author Tiago F. Santos 
  * @since 4.7

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -509,8 +509,8 @@ private void assertSuggestions(String sentence, Language lang, List<String> expe
       } else {
         if (!expectedCorrections.equals(realSuggestions)) {
           ruleErrors.addError(new PatternRuleTestFailure(rule,
-            "Incorrect suggestions: " + expectedCorrections + " != "
-              + realSuggestions + " on input: " + sentence));
+            "Incorrect suggestions: " + String.join("|", expectedCorrections) + " != "
+              + String.join("|", realSuggestions) + " on input: " + sentence));
         }
       }
     }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/FlatParagraphTools.java
Patch:
@@ -101,7 +101,7 @@ private XFlatParagraph getCurrentFlatParagraph() {
         }
         return null;
       }
-      XFlatParagraph tmpFlatPara = xFlatParaIter.getLastPara();
+      XFlatParagraph tmpFlatPara = xFlatParaIter.getNextPara();
       if (tmpFlatPara != null) {
         lastFlatPara = tmpFlatPara;
       }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/TextLevelCheckQueue.java
Patch:
@@ -166,7 +166,9 @@ public void setReset() {
     synchronized(textRuleQueue) {
       textRuleQueue.clear();
     }
-    waitForInterrupt();
+    if(!queueWaits && lastStart >= 0) {
+      waitForInterrupt();
+    }
     if(debugMode) {
       MessageHandler.printToLogFile("reset queue");
     }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -112,7 +112,7 @@ enum GrammarCategory {
       posRegex("SUB:.*")
     ),
     Arrays.asList(  // "... kein anderer Unrecht hat."
-      regex("keine?"),
+      regex("diese[rs]?|keine?"),
       regex("anderer?"),
       posRegex("SUB:.*")
     ),

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -28,7 +28,7 @@
  */
 public class DocumentCache {
   
-  private static final boolean debugMode = false; //  should be false except for testing
+  private static boolean debugMode;         //  should be false except for testing
 
   List<String> paragraphs = null;            //  stores the flat paragraphs of document
   List<Integer> headings = null;             //  stores the paragraphs formated as headings; is used to subdivide the document in chapters
@@ -37,6 +37,7 @@ public class DocumentCache {
   int defaultParaCheck;
 
   DocumentCache(DocumentCursorTools docCursor, FlatParagraphTools flatPara, int defaultParaCheck) {
+    debugMode = OfficeTools.DEBUG_MODE_DC;
     this.defaultParaCheck = defaultParaCheck;
     reset(docCursor, flatPara);
   }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/FlatParagraphTools.java
Patch:
@@ -45,13 +45,14 @@
  */
 public class FlatParagraphTools {
   
-  private static final boolean debugMode = false; //  should be false except for testing
+  private static boolean debugMode; //  should be false except for testing
   
   private XFlatParagraphIterator xFlatParaIter;
   private XFlatParagraph lastFlatPara;
   private XComponent xComponent;
   
   FlatParagraphTools(XComponent xComponent) {
+    debugMode = OfficeTools.DEBUG_MODE_FP;
     this.xComponent = xComponent;
     xFlatParaIter = getXFlatParagraphIterator(xComponent);
     lastFlatPara = getCurrentFlatParagraph();

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LanguageToolMenus.java
Patch:
@@ -59,7 +59,7 @@ public class LanguageToolMenus {
   
   private static final ResourceBundle MESSAGES = JLanguageTool.getMessageBundle();
 
-  private static final boolean debugMode = false;   //  should be false except for testing
+  private static boolean debugMode;   //  should be false except for testing
   
   private XComponentContext xContext;
   private SingleDocument document;
@@ -70,6 +70,7 @@ public class LanguageToolMenus {
   private ContextMenuInterceptor ltContextMenu;
 
   LanguageToolMenus(XComponentContext xContext, SingleDocument document, Configuration config) {
+    debugMode = OfficeTools.DEBUG_MODE_LM;
     this.document = document;
     this.xContext = xContext;
     setConfigValues(config);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -72,7 +72,7 @@ class SingleDocument {
   private static final int PARA_CHECK_DEFAULT = 50;  //  Factor for parameter checked at once at iteration (no text change)
   private static final int MAX_SUGGESTIONS = 15;
 
-  private static int debugMode = 0;               //  should be 0 except for testing; 1 = low level; 2 = advanced level
+  private static int debugMode;               //  should be 0 except for testing; 1 = low level; 2 = advanced level
   
   private Configuration config;
 
@@ -118,6 +118,7 @@ class SingleDocument {
 
   SingleDocument(XComponentContext xContext, Configuration config, String docID, 
       XComponent xComponent, MultiDocumentsHandler mDH) {
+    debugMode = OfficeTools.DEBUG_MODE_SD;
     this.xContext = xContext;
     this.config = config;
     this.docID = docID;

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Configuration.java
Patch:
@@ -66,7 +66,7 @@ public class Configuration {
   static final boolean DEFAULT_DO_RESET = false;
   static final boolean DEFAULT_MULTI_THREAD = false;
   static final boolean DEFAULT_FULL_CHECK_FIRST = true;
-  static final boolean DEFAULT_USE_QUEUE = false;
+  static final boolean DEFAULT_USE_QUEUE = true;
   static final boolean DEFAULT_USE_DOC_LANGUAGE = true;
   static final boolean DEFAULT_DO_REMOTE_CHECK = false;
   static final boolean DEFAULT_USE_OTHER_SERVER = false;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -19,9 +19,7 @@
 package org.languagetool.openoffice;
 
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
 
 /**
  * Class to store the Text of a LO document 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/DocumentCache.java
Patch:
@@ -58,7 +58,7 @@ public void reset(DocumentCursorTools docCursor, FlatParagraphTools flatPara) {
     if(textParas != null && !textParas.isEmpty()) {
       int n = 0; 
       for(int i = 0; i < paragraphs.size(); i++) {
-        if(footnotes.get(i).length > 0 || paragraphs.get(i).equals(textParas.get(n))) {
+        if(footnotes.get(i).length > 0 || (n < textParas.size() && paragraphs.get(i).equals(textParas.get(n)))) {
           toTextMapping.add(n);
           toParaMapping.add(i);
           n++;
@@ -71,7 +71,8 @@ public void reset(DocumentCursorTools docCursor, FlatParagraphTools flatPara) {
     if(debugMode) {
       MessageHandler.printToLogFile("toParaMapping:");
       for(int i = 0; i < toParaMapping.size(); i++) {
-        MessageHandler.printToLogFile("Doc: " + i + " Flat: " + toParaMapping.get(i));
+        MessageHandler.printToLogFile("Doc: " + i + " Flat: " + toParaMapping.get(i)
+        + OfficeTools.LOG_LINE_BREAK + getTextParagraph(i));
       }
       MessageHandler.printToLogFile("toTextMapping:");
       for(int i = 0; i < toTextMapping.size(); i++) {

File: languagetool-core/src/main/java/org/languagetool/broker/ClassBroker.java
Patch:
@@ -31,7 +31,7 @@
  * load class do always use {@link JLanguageTool#getClassBroker()}
  * which provides proper method for loading classes.
  *
- * @since 4.9
+ * @since 5.0
  */
 public interface ClassBroker {
     /**

File: languagetool-core/src/main/java/org/languagetool/broker/ResourceDataBroker.java
Patch:
@@ -118,7 +118,7 @@ public interface ResourceDataBroker {
    * Get from resource broker by a path file
    * @param path Path to an item
    * @return An {@link URL} object to the requested item
-   * @since 4.9
+   * @since 5.0
    */
   URL getAsURL(String path);
 
@@ -158,7 +158,7 @@ public interface ResourceDataBroker {
    * @param baseName the base name of the resource bundle, a fully qualified class name
    * @param locale the locale for which a resource bundle is desired
    * @return a resource bundle for the given base name and locale
-   * @since 4.9
+   * @since 5.0
    */
   ResourceBundle getResourceBundle(String baseName, Locale locale);
 }

File: languagetool-core/src/main/java/org/languagetool/ShortDescriptionProvider.java
Patch:
@@ -19,7 +19,7 @@
 package org.languagetool;
 
 import org.jetbrains.annotations.Nullable;
-import org.languagetool.databroker.ResourceDataBroker;
+import org.languagetool.broker.ResourceDataBroker;
 
 import java.util.*;
 

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/RuleFilterCreator.java
Patch:
@@ -18,6 +18,8 @@
  */
 package org.languagetool.rules.patterns;
 
+import org.languagetool.JLanguageTool;
+
 import java.lang.reflect.Constructor;
 
 /**
@@ -31,7 +33,7 @@ public class RuleFilterCreator {
    */
   public RuleFilter getFilter(String className) {
     try {
-      Class<?> aClass = Class.forName(className);
+      Class<?> aClass = JLanguageTool.getClassBroker().forName(className);
       Constructor<?>[] constructors = aClass.getConstructors();
       if (constructors.length != 1) {
         throw new RuntimeException("Constructor of filter class '"

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/RuleIdValidator.java
Patch:
@@ -48,7 +48,7 @@ void validateUniqueness() {
       }
     }
     for (String fileName : fileNames) {
-      try (InputStream is = this.getClass().getResourceAsStream(fileName)) {
+      try (InputStream is = JLanguageTool.getDataBroker().getAsStream(fileName)) {
         if (is == null) {
           System.out.println("Skipping " + fileName + " - not found");  // e.g. nl/grammar-test-1.xml
           continue;

File: languagetool-language-modules/sr/src/main/java/org/languagetool/language/Serbian.java
Patch:
@@ -22,7 +22,7 @@
 import org.languagetool.Language;
 import org.languagetool.LanguageMaintainedState;
 import org.languagetool.UserConfig;
-import org.languagetool.databroker.ResourceDataBroker;
+import org.languagetool.broker.ResourceDataBroker;
 import org.languagetool.rules.*;
 import org.languagetool.rules.sr.ekavian.MorfologikEkavianSpellerRule;
 import org.languagetool.rules.sr.ekavian.SimpleGrammarEkavianReplaceRule;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/AccentuationCheckRule.java
Patch:
@@ -53,8 +53,8 @@ public class AccentuationCheckRule extends Rule {
   private static final Pattern ARTICLE_EL_MP = Pattern.compile("els|Els");
   private static final Pattern ARTICLE_EL_FP = Pattern.compile("les|Les");
   private static final Pattern DETERMINANT = Pattern.compile("D[^R].*");
-  private static final Pattern DETERMINANT_MS = Pattern.compile("D[^R].[MC][SN].*");
-  private static final Pattern DETERMINANT_FS = Pattern.compile("D[^R].[FC][SN].*");
+  private static final Pattern DETERMINANT_MS = Pattern.compile("D[^RN].[MC][SN].*");
+  private static final Pattern DETERMINANT_FS = Pattern.compile("D[^RN].[FC][SN].*");
   private static final Pattern DETERMINANT_MP = Pattern.compile("D[^R].[MC][PN].*");
   private static final Pattern DETERMINANT_FP = Pattern.compile("D[^R].[FC][PN].*");
   private static final Pattern NOM_MS = Pattern.compile("NC[MC][SN].*");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -47,6 +47,8 @@ public void setUp() throws IOException {
   public void testRule() throws IOException {
 
     // correct sentences:
+    assertCorrect("L'article primer estipula que és així.");
+    assertCorrect("L'article 1 estipula que és així.");
     assertCorrect("L'informe estipula que ha de ser així.");
     assertCorrect("Si presencies males pràctiques en la botiga.");
     assertCorrect("—I continues mantenint que això va succeir");

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/MorfologikCatalanSpellerRule.java
Patch:
@@ -36,7 +36,7 @@ public final class MorfologikCatalanSpellerRule extends MorfologikSpellerRule {
   private static final String SPELLING_FILE = "/ca/spelling.txt";
   
   private static final Pattern PARTICULA_INICIAL = Pattern.compile("^(els?|als?|pels?|dels?|de|per|uns?|una|unes|la|les|[tms]eus?) (..+)$",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
-  private static final Pattern PREFIX_AMB_ESPAI = Pattern.compile("^(avant|auto|ex|extra|macro|mega|meta|micro|multi|mono|mini|post|retro|semi|super|trans) (..+)$",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
+  private static final Pattern PREFIX_AMB_ESPAI = Pattern.compile("^(des|avant|auto|ex|extra|macro|mega|meta|micro|multi|mono|mini|post|retro|semi|super|trans) (..+)$",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   
   private static final Pattern APOSTROF_INICI_VERBS = Pattern.compile("^([lnmts])(h?[aeiouàéèíòóú].*)$",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   private static final Pattern APOSTROF_INICI_NOM_SING = Pattern.compile("^([ld])(h?[aeiouàéèíòóú].+)$",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1240,7 +1240,7 @@ public List<Rule> getAllActiveRules() {
    * Get all spelling check rules for the current language that are built-in or
    * that have been added using {@link #addRule(Rule)}.
    * @return a List of {@link SpellingCheckRule} objects
-   * @since 4.9
+   * @since 5.0
    */
   public List<SpellingCheckRule> getAllSpellingCheckRules() {
     List<SpellingCheckRule> rules = new ArrayList<>();

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LanguageToolMenus.java
Patch:
@@ -74,7 +74,7 @@ public class LanguageToolMenus {
     this.xContext = xContext;
     setConfigValues(config);
     ltHeadMenu = new LTHeadMenu();
-    ltContextMenu = new ContextMenuInterceptor();
+    ltContextMenu = new ContextMenuInterceptor(xContext);
   }
   
   void setConfigValues(Configuration config) {

File: languagetool-core/src/main/java/org/languagetool/ShortDescriptionProvider.java
Patch:
@@ -19,7 +19,7 @@
 package org.languagetool;
 
 import org.jetbrains.annotations.Nullable;
-import org.languagetool.databroker.ResourceDataBroker;
+import org.languagetool.broker.ResourceDataBroker;
 
 import java.util.*;
 

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/RuleFilterCreator.java
Patch:
@@ -18,6 +18,8 @@
  */
 package org.languagetool.rules.patterns;
 
+import org.languagetool.JLanguageTool;
+
 import java.lang.reflect.Constructor;
 
 /**
@@ -31,7 +33,7 @@ public class RuleFilterCreator {
    */
   public RuleFilter getFilter(String className) {
     try {
-      Class<?> aClass = Class.forName(className);
+      Class<?> aClass = JLanguageTool.getClassBroker().forName(className);
       Constructor<?>[] constructors = aClass.getConstructors();
       if (constructors.length != 1) {
         throw new RuntimeException("Constructor of filter class '"

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/RuleIdValidator.java
Patch:
@@ -48,7 +48,7 @@ void validateUniqueness() {
       }
     }
     for (String fileName : fileNames) {
-      try (InputStream is = this.getClass().getResourceAsStream(fileName)) {
+      try (InputStream is = JLanguageTool.getDataBroker().getAsStream(fileName)) {
         if (is == null) {
           System.out.println("Skipping " + fileName + " - not found");  // e.g. nl/grammar-test-1.xml
           continue;

File: languagetool-language-modules/sr/src/main/java/org/languagetool/language/Serbian.java
Patch:
@@ -22,7 +22,7 @@
 import org.languagetool.Language;
 import org.languagetool.LanguageMaintainedState;
 import org.languagetool.UserConfig;
-import org.languagetool.databroker.ResourceDataBroker;
+import org.languagetool.broker.ResourceDataBroker;
 import org.languagetool.rules.*;
 import org.languagetool.rules.sr.ekavian.MorfologikEkavianSpellerRule;
 import org.languagetool.rules.sr.ekavian.SimpleGrammarEkavianReplaceRule;

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -602,6 +602,9 @@ enum GrammarCategory {
     ));
 
   private static final Set<String> VIELE_WENIGE_LOWERCASE = new HashSet<>(Arrays.asList(
+    "andere",
+    "anderer",
+    "anderen",
     "sämtlicher",
     "etliche",
     "etlicher",

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -140,6 +140,8 @@ public void testDetNounRule() throws IOException {
     assertGood("Das kostet dich Zinsen.");
     assertGood("Sie hatten keine Chance gegen das kleinere Preußen.");
     assertGood("Den 2019er Wert hatten sie geschätzt.");
+    assertGood("Andere formale Systeme, deren Semantiken jeweils...");
+    assertGood("Gesetz zur Änderung des Kündigungsrechts und anderer arbeitsrechtlicher Vorschriften");
 
     assertGood("Wir machen das Januar.");
     assertGood("Wir teilen das Morgen mit.");

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/CompoundAwareHunspellRule.java
Patch:
@@ -109,7 +109,7 @@ public List<String> getSuggestions(String word) throws IOException {
     }
     //System.out.println("suggestions (mixed from simpleSuggestions, noSplitSuggestions, noSplitLowerCaseSuggestions): " + suggestions);
 
-    filterDupes(suggestions);
+    suggestions = filterDupes(suggestions);
     filterForLanguage(suggestions);
 
     List<String> sortedSuggestions = sortSuggestionByQuality(word, suggestions);

File: languagetool-language-modules/fr/src/test/java/org/languagetool/rules/fr/QuestionWhitespaceRuleTest.java
Patch:
@@ -55,7 +55,8 @@ public final void testRule() throws IOException {
       assertEquals(0, rule.match(lt.getAnalyzedSentence("00:80:41:ae:fd:7e")).length);
 
       TestTools.disableAllRulesExcept(lt, "FRENCH_WHITESPACE");
-      //assertEquals(0, lt.check("« Je suis Chris… »").size());
+      assertEquals(0, lt.check("« Je suis Chris… »").size());
+      assertEquals(0, lt.check("« Je suis Chris ! »").size());
 
       // errors:
       assertThat(rule.match(lt.getAnalyzedSentence("C'est vrai!")).length, is(1));

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/ProhibitedCompoundRule.java
Patch:
@@ -155,6 +155,7 @@ public class ProhibitedCompoundRule extends Rule {
           "Maskenhersteller", // vs Marken
           "Maskenherstellers",
           "Maskenherstellern",
+          "Firmenvokabular",
           "Maskenproduktion"
   ));
 

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/PronomFebleDuplicateRule.java
Patch:
@@ -43,7 +43,7 @@ public String getDescription() {
   public PronomFebleDuplicateRule(ResourceBundle messages) throws IOException {
     super.setCategory(new Category(new CategoryId("PRONOMS_FEBLES"), "Pronoms febles"));
     setLocQualityIssueType(ITSIssueType.Grammar);
-    addExamplePair(Example.wrong("<marker>S'ha de fer-se</marker>.."), Example.fixed("<marker>S'ha de fer</marker>."));
+    addExamplePair(Example.wrong("<marker>S'ha de fer-se</marker>."), Example.fixed("<marker>S'ha de fer</marker>."));
   }
 
   @Override
@@ -95,7 +95,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
           }
           ruleMatch.addSuggestedReplacement(suggestion.toString());
           ruleMatches.add(ruleMatch);
-        } else if (!tokens[i].isWhitespaceBefore() &&
+        } else if (!tokens[i].isWhitespaceBefore() && isPrevInfinitive &&
             (PFLemma.equals("en") && PFLemma2.equals("hi") 
             || PFLemma.equals("hi") && PFLemma2.equals("en"))) 
         {

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/PronomFebleDuplicateRuleTest.java
Patch:
@@ -24,6 +24,7 @@ public void setUp() throws IOException {
   @Test
   public void testRule() throws IOException { 
     
+    assertCorrect("N'hi ha d'haver.");
     assertCorrect("Hi podria haver un error.");
     assertCorrect("Es divertien llançant-se pedres.");
     assertCorrect("Es recomana tapar-se la boca.");

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -167,8 +167,6 @@ class SingleDocument {
    * 
    * @param paraText          paragraph text
    * @param paRes             proof reading result
-   * @param footnotePositions position of footnotes
-   * @param isParallelThread  true: check runs as parallel thread
    * @return                  proof reading result
    */
   ProofreadingResult getCheckResults(String paraText, Locale locale, ProofreadingResult paRes, 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -234,6 +234,9 @@ ProofreadingResult getCheckResults(String paraText, Locale locale, ProofreadingR
       }
       if(resetCheck) {
         if(numParasToCheck != 0 && paraNum >= 0 && !useQueue) {
+          if (docCursor == null) {
+            docCursor = new DocumentCursorTools(xComponent);
+          }
           remarkChangedParagraphs(changedParas, docCursor.getParagraphCursor(), flatPara);
         }
         resetCheck = false;

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Configuration.java
Patch:
@@ -66,7 +66,7 @@ public class Configuration {
   static final boolean DEFAULT_DO_RESET = false;
   static final boolean DEFAULT_MULTI_THREAD = false;
   static final boolean DEFAULT_FULL_CHECK_FIRST = true;
-  static final boolean DEFAULT_USE_QUEUE = true;
+  static final boolean DEFAULT_USE_QUEUE = false;
   static final boolean DEFAULT_USE_DOC_LANGUAGE = true;
   static final boolean DEFAULT_DO_REMOTE_CHECK = false;
   static final boolean DEFAULT_USE_OTHER_SERVER = false;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -546,7 +546,7 @@ public void disposing(EventObject source) {
       MessageHandler.printToLogFile("xComponent of closed document is null");
     } else {
       documents.setContextOfClosedDoc(goneContext);
-      documents.removeMenuListener(goneContext);
+//      documents.removeMenuListener(goneContext);
     }
     goneContext.removeEventListener(this); 
   }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -1204,6 +1204,8 @@ private void addParaErrorsToCache(int paraNum, SwJLanguageTool langTool, int cac
     DocumentCursorTools docCursor = this.docCursor;
     List<String> allParas = this.allParas;
     List<Integer> headings = this.headings;
+    List<ResultCache> paragraphsCache = this.paragraphsCache;
+    ResultCache sentencesCache = this.sentencesCache;
     boolean textIsChanged = this.textIsChanged;
     int divNum = this.divNum;
     try {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanWordRepeatBeginningRule.java
Patch:
@@ -29,7 +29,7 @@
 import org.languagetool.rules.WordRepeatBeginningRule;
 
 /**
- * Extends {@link WordRepeatBeginningRule} by a list of German adverbs ("Konjunktionaladverben")
+ * Extends {@link WordRepeatBeginningRule} by a list of German adverbs ("Konjunktionaladverbien")
  * for a more precise error message.
  * 
  * @author Markus Brenneis

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -227,6 +227,7 @@ public int getPriorityForId(String id) {
       case "HOMOPHONE_AS_CARD":         return  5;
       case "TODOS_FOLLOWED_BY_NOUN_PLURAL":    return  3;
       case "TODOS_FOLLOWED_BY_NOUN_SINGULAR":  return  2;
+      case "EMAIL":                     return  1;
       case "UNPAIRED_BRACKETS":         return -5;
       case "PROFANITY":                 return -6;
       case "PT_BARBARISMS_REPLACE":     return -10;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tokenizers/ca/CatalanWordTokenizer.java
Patch:
@@ -213,7 +213,7 @@ private List<String> wordsToAdd(String s) {
             l.add(s);
           }
           // some camel-case words containing hyphen (is there any better fix?)
-          if (s.equalsIgnoreCase("mers-cov") || s.equalsIgnoreCase("mcgraw-hill") 
+          else if (s.equalsIgnoreCase("mers-cov") || s.equalsIgnoreCase("mcgraw-hill") 
               || s.equalsIgnoreCase("sars-cov-2") || s.equalsIgnoreCase("ph-metre") 
               || s.equalsIgnoreCase("ph-metres")) {
             l.add(s);

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -130,7 +130,8 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new WordRepeatRule(messages, this),
             new MultipleWhitespaceRule(messages, this),
             new SpanishWikipediaRule(messages),
-            new SpanishDiacriticsCheckRule(messages)
+            new SpanishDiacriticsCheckRule(messages),
+            new SpanishWrongWordInContextRule(messages)
     );
   }
 

File: languagetool-language-modules/ga/src/main/java/org/languagetool/tagging/ga/Utils.java
Patch:
@@ -141,8 +141,6 @@ public static String unEclipse(String in) {
    * Attempts to unlenite a string (See {@link #lenite(String)})
    * Deliberately does not check if first character is one
    * that ought to be lenited (this can be checked in XML rules)
-   * @param in
-   * @return
    */
   public static String unLenite(String in) {
     if (in.length() < 2) {
@@ -210,7 +208,7 @@ public static String unEclipseF(String in) {
 
   /**
    * Helper to uneclipse single-letter consonant eclipsis (i.e., not bhfear or
-   *  n-éin), handling miscapitalised eclipsed words: Gcarr -> Carr, etc.
+   *  n-éin), handling miscapitalised eclipsed words: Gcarr -&gt; Carr, etc.
    * @param in string to uneclipse
    * @param first first (eclipsis) character
    * @param second second character; first character of the word proper

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServerConfig.java
Patch:
@@ -1003,7 +1003,7 @@ public void setAbTest(@Nullable String abTest) {
   }
 
   /**
-   * Clients that a A/B test runs on; null -> disabled
+   * Clients that a A/B test runs on; null -&gt; disabled
    * @since 4.9
    */
   @Experimental
@@ -1013,7 +1013,7 @@ public Pattern getAbTestClients() {
   }
 
   /**
-   * Clients that a A/B test runs on; null -> disabled
+   * Clients that a A/B test runs on; null -&gt; disabled
    * @since 4.9
    */
   @Experimental

File: languagetool-language-modules/ml/src/test/java/org/languagetool/rules/ml/MorfologikMalayalamSpellerRuleTest.java
Patch:
@@ -51,11 +51,11 @@ public void testMorfologikSpeller() throws IOException {
 
     //incorrect sentences:
 
-    matches = rule.match(langTool.getAnalyzedSentence("Zohw"));
+    matches = rule.match(langTool.getAnalyzedSentence("Aagohw"));
     // check match positions:
     assertEquals(1, matches.length);
     assertEquals(0, matches[0].getFromPos());
-    assertEquals(4, matches[0].getToPos());
+    assertEquals(6, matches[0].getToPos());
     assertTrue(matches[0].getSuggestedReplacements().isEmpty());
 
     matches = rule.match(langTool.getAnalyzedSentence("എaങ്ങനെ"));

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -1093,6 +1093,7 @@ private void potentiallyAddUppercaseMatch(List<RuleMatch> ruleMatches, AnalyzedT
         !isSpecialCase(i, tokens) &&
         !isAdjectiveAsNoun(i, tokens, lowercaseReadings) &&
         !isExceptionPhrase(i, tokens) &&
+        !(i == 2 && "“".equals(tokens[i-1].getToken())) &&   // closing quote at sentence start (https://github.com/languagetool-org/languagetool/issues/2558)
         !isNounWithVerbReading(i, tokens)) {
       String fixedWord = StringTools.lowercaseFirstChar(tokens[i].getToken());
       if (":".equals(tokens[i - 1].getToken())) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -163,6 +163,8 @@ public void testRule() throws IOException {
     assertGood("Zur Versöhnung: Jüdische Gläubige sollen beten.");
     assertGood("Fast im Stundentakt wurden neue Infizierte gemeldet.");
     assertGood("Bert Van Den Brink");
+    assertGood("“In den meisten Bundesländern werden solche Studien per se nicht durchgeführt.”");
+    assertGood("Aber “in den meisten Bundesländern werden solche Studien per se nicht durchgeführt.”");
 
     // https://github.com/languagetool-org/languagetool/issues/1515:
     assertGood("▶︎ Dies ist ein Test");

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ResultCache.java
Patch:
@@ -43,7 +43,9 @@ class ResultCache {
 
   ResultCache(ResultCache cache) {
     this.entries = new HashMap<>();
-    this.entries.putAll(cache.entries);
+    if(cache != null) {
+      this.entries.putAll(cache.entries);
+    }
   }
 
   /**

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -406,7 +406,9 @@ && getFrequency(speller1, nextWord) < MAX_FREQUENCY_FOR_SPLITTING) {
           for (TranslationEntry translation : translations) {
             for (String s : translation.getL2()) {
               String suffix = translator.getTranslationSuffix(s);
-              l.add(new SuggestedReplacement(translator.cleanTranslationForReplace(s, prevWord), String.join(", ", translation.getL1()), suffix.isEmpty() ? null : suffix));
+              SuggestedReplacement repl = new SuggestedReplacement(translator.cleanTranslationForReplace(s, prevWord), String.join(", ", translation.getL1()), suffix.isEmpty() ? null : suffix);
+              repl.setType(SuggestedReplacement.SuggestionType.Translation);
+              l.add(repl);
             }
           }
           List<SuggestedReplacement> mergedRepl = mergeSuggestionsWithSameTranslation(l);

File: languagetool-core/src/main/java/org/languagetool/tools/RuleMatchesAsJsonSerializer.java
Patch:
@@ -193,6 +193,9 @@ private void writeReplacements(JsonGenerator g, RuleMatch match) throws IOExcept
       if (replacement.getSuffix() != null) {
         g.writeStringField("suffix", replacement.getSuffix());
       }
+      if (replacement.getType() != SuggestedReplacement.SuggestionType.Default) {
+        g.writeStringField("type", replacement.getType().name());
+      }
       if (autoCorrect) {
         g.writeBooleanField("autoCorrect", true);
         autoCorrect = false; // only for first replacement

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -949,7 +949,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
       } else if (analyzedToken.hasPosTagStartingWith("SUB:") &&
                  i < tokens.length-1 &&
                  Character.isLowerCase(tokens[i+1].getToken().charAt(0)) &&
-                 tokens[i+1].matchesPosTagRegex("VER:[123]:.+")) {
+                 tokens[i+1].matchesPosTagRegex("(VER:[123]:|PA2).+")) {
         // "Viele Minderjährige sind" but not "Das wirklich Wichtige Verfahren ist"
         continue;  
       }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -161,6 +161,7 @@ public void testRule() throws IOException {
     assertGood("Das ist ein Satz !!! Das auch.");
     assertGood("Der russische Erdölmagnat Emanuel Nobel, der Erbauer des ersten Dieselmotorschiffes.");
     assertGood("Zur Versöhnung: Jüdische Gläubige sollen beten.");
+    assertGood("Fast im Stundentakt wurden neue Infizierte gemeldet.");
 
     // https://github.com/languagetool-org/languagetool/issues/1515:
     assertGood("▶︎ Dies ist ein Test");
@@ -424,4 +425,4 @@ public void testCompareLists() throws IOException {
     assertTrue(rule.compareLists(sentence2.getTokensWithoutWhitespace(), 0, 4, new Pattern[]{Pattern.compile(""), Pattern.compile("das"), Pattern.compile("Heilige"), Pattern.compile("Römische"), Pattern.compile("Reich")}));
     assertFalse(rule.compareLists(sentence2.getTokensWithoutWhitespace(), 8, 11, new Pattern[]{Pattern.compile(""), Pattern.compile("das"), Pattern.compile("Heilige"), Pattern.compile("Römische"), Pattern.compile("Reich")}));
   }
-}
\ No newline at end of file
+}

File: languagetool-language-modules/el/src/test/java/org/languagetool/rules/el/GreekTest.java
Patch:
@@ -35,6 +35,6 @@ public void testLanguage() throws IOException {
     testDemoText(lang, s,
       Arrays.asList("GREEK_PUNC_2", "GREEK_ART_FEM_MISSING_N", "WORD_REPEAT_RULE", "MORFOLOGIK_RULE_EL_GR", "DOUBLE_PUNCTUATION")
     );
-    runTests(lang);
+    runTests(lang, null, "ισότπς");
   }
 }

File: languagetool-standalone/src/test/java/org/languagetool/spelling/HunspellRuleTest.java
Patch:
@@ -38,7 +38,7 @@ public void testRuleWithGermanAndAltLang() throws Exception {
     JLanguageTool lt = new JLanguageTool(Languages.getLanguageForShortCode("de-DE"), altLangs, null, null, null, null);
     List<RuleMatch> matches = lt.check("Der ROI ist schoon.");
     assertThat(matches.size(), is(1));
-    assertTrue(matches.get(0).getMessage().contains("Rechtschreibfehler"));
+    assertTrue(matches.get(0).getMessage().contains("Tippfehler"));
   }
   
 }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -1391,7 +1391,7 @@ private SingleProofreadingError createOOoError(RuleMatch ruleMatch, int startInd
     if(underlineColor != Color.blue) {
       nDim++;
     }
-    if(underlineType != Configuration.UNDERLINE_WAVE) {
+    if(underlineType != Configuration.UNDERLINE_WAVE || (config.markSingleCharBold() && aError.nErrorLength == 1)) {
       nDim++;
     }
     if(nDim > 0) {
@@ -1408,6 +1408,8 @@ private SingleProofreadingError createOOoError(RuleMatch ruleMatch, int startInd
       }
       if(underlineType != Configuration.UNDERLINE_WAVE) {
         propertyValues[n] = new PropertyValue("LineType", -1, underlineType, PropertyState.DIRECT_VALUE);
+      } else if(config.markSingleCharBold() && aError.nErrorLength == 1) {
+        propertyValues[n] = new PropertyValue("LineType", -1, Configuration.UNDERLINE_BOLDWAVE, PropertyState.DIRECT_VALUE);
       }
       aError.aProperties = propertyValues;
     } else {

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServerConfig.java
Patch:
@@ -119,7 +119,8 @@ enum Mode { LanguageTool }
     "maxTextLength", "maxTextLengthWithApiKey", "maxWorkQueueSize", "neuralNetworkModel", "pipelineCaching",
     "pipelineExpireTimeInSeconds", "pipelinePrewarming", "prometheusMonitoring", "prometheusPort", "remoteRulesFile",
     "requestLimit", "requestLimitInBytes", "requestLimitPeriodInSeconds", "rulesFile", "secretTokenKey", "serverURL",
-    "skipLoggingChecks", "skipLoggingRuleMatches", "timeoutRequestLimit", "trustXForwardForHeader", "warmUp", "word2vecModel");
+    "skipLoggingChecks", "skipLoggingRuleMatches", "timeoutRequestLimit", "trustXForwardForHeader", "warmUp", "word2vecModel",
+    "keystore", "password");
 
   /**
    * Create a server configuration for the default port ({@link #DEFAULT_PORT}).

File: languagetool-language-modules/ml/src/test/java/org/languagetool/rules/ml/MorfologikMalayalamSpellerRuleTest.java
Patch:
@@ -51,7 +51,7 @@ public void testMorfologikSpeller() throws IOException {
 
     //incorrect sentences:
 
-    matches = rule.match(langTool.getAnalyzedSentence("Zolw"));
+    matches = rule.match(langTool.getAnalyzedSentence("Zohw"));
     // check match positions:
     assertEquals(1, matches.length);
     assertEquals(0, matches[0].getFromPos());

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -57,10 +57,11 @@ public PatternRuleTestFailure(AbstractPatternRule rule, String message) {
     }
 
     @Override
-    public String toString() {
+    public String getMessage() {
       return String.format("Test failure for rule %s in file %s: %s",
         rule.getFullId(), rule.getSourceFile(), message);
     }
+
   }
 
   public void testFake() {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -139,6 +139,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Und nur, weil mich psychische Erkrankungen aus der Bahn werfen");
     assertGood("Das kostet dich Zinsen.");
     assertGood("Sie hatten keine Chance gegen das kleinere Preußen.");
+    assertGood("Den 2019er Wert hatten sie geschätzt.");
 
     assertGood("Wir machen das Januar.");
     assertGood("Wir teilen das Morgen mit.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -138,6 +138,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Besonders reizen mich Fahrräder.");
     assertGood("Und nur, weil mich psychische Erkrankungen aus der Bahn werfen");
     assertGood("Das kostet dich Zinsen.");
+    assertGood("Sie hatten keine Chance gegen das kleinere Preußen.");
 
     assertGood("Wir machen das Januar.");
     assertGood("Wir teilen das Morgen mit.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -136,6 +136,8 @@ public void testDetNounRule() throws IOException {
     assertGood("Die Tiroler Küche");
     assertGood("Was ist denn das für ein ungewöhnlicher Name?");
     assertGood("Besonders reizen mich Fahrräder.");
+    assertGood("Und nur, weil mich psychische Erkrankungen aus der Bahn werfen");
+    assertGood("Das kostet dich Zinsen.");
 
     assertGood("Wir machen das Januar.");
     assertGood("Wir teilen das Morgen mit.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -135,6 +135,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Dieses leise Summen stört nicht.");
     assertGood("Die Tiroler Küche");
     assertGood("Was ist denn das für ein ungewöhnlicher Name?");
+    assertGood("Besonders reizen mich Fahrräder.");
 
     assertGood("Wir machen das Januar.");
     assertGood("Wir teilen das Morgen mit.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -134,6 +134,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Das, plus ein eigener Firmenwagen.");
     assertGood("Dieses leise Summen stört nicht.");
     assertGood("Die Tiroler Küche");
+    assertGood("Was ist denn das für ein ungewöhnlicher Name?");
 
     assertGood("Wir machen das Januar.");
     assertGood("Wir teilen das Morgen mit.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -133,6 +133,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Ich werde mich zurücknehmen und mich frischen Ideen zuwenden.");
     assertGood("Das, plus ein eigener Firmenwagen.");
     assertGood("Dieses leise Summen stört nicht.");
+    assertGood("Die Tiroler Küche");
 
     assertGood("Wir machen das Januar.");
     assertGood("Wir teilen das Morgen mit.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -132,6 +132,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Aber das ignorierte Herr Müller bewusst.");
     assertGood("Ich werde mich zurücknehmen und mich frischen Ideen zuwenden.");
     assertGood("Das, plus ein eigener Firmenwagen.");
+    assertGood("Dieses leise Summen stört nicht.");
 
     assertGood("Wir machen das Januar.");
     assertGood("Wir teilen das Morgen mit.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -131,6 +131,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Aber das ignorierte Herr Grey bewusst.");
     assertGood("Aber das ignorierte Herr Müller bewusst.");
     assertGood("Ich werde mich zurücknehmen und mich frischen Ideen zuwenden.");
+    assertGood("Das, plus ein eigener Firmenwagen.");
 
     assertGood("Wir machen das Januar.");
     assertGood("Wir teilen das Morgen mit.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -130,6 +130,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Sie legen ein Teilstück jenes Weges zurück, den die Tausenden Juden 1945 auf sich nehmen mussten.");
     assertGood("Aber das ignorierte Herr Grey bewusst.");
     assertGood("Aber das ignorierte Herr Müller bewusst.");
+    assertGood("Ich werde mich zurücknehmen und mich frischen Ideen zuwenden.");
 
     assertGood("Wir machen das Januar.");
     assertGood("Wir teilen das Morgen mit.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -269,6 +269,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Das hängt davon ab, ob die Deutsch sprechen");
     assertGood("Die meisten Coaches wissen nichts.");
     assertGood("Die Präsent AG.");
+    assertGood("In New York war er der Titelheld in Richard III. und spielte den Mark Anton in Julius Cäsar.");
 
     // incorrect sentences:
     assertBad("Ein Buch mit einem ganz ähnlichem Titel.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -567,7 +567,9 @@ public class CaseRule extends Rule {
     "Frevel",
     "Genüge",
     "Gefallen", // Gefallen finden
+    "Gläubige",
     "Gläubiger",
+    "Gläubigen",
     "Hechte",
     "Herzöge",
     "Herzögen",

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -202,6 +202,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Jede*r Mitarbeiter*in ist davon betroffen.");
     assertGood("Alle Professor*innen");
     assertGood("Gleichzeitig wünscht sich Ihr frostresistenter Mitbewohner einige Grad weniger im eigenen Zimmer?");
+    assertGood("Ein Trainer, der zum einen Fußballspiele sehr gut lesen und analysieren kann");
 
     // relative clauses:
     assertGood("Das Recht, das Frauen eingeräumt wird.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -160,6 +160,7 @@ public void testRule() throws IOException {
     assertGood("Ist das eine Frage ? Müsste das nicht anders sein?");
     assertGood("Das ist ein Satz !!! Das auch.");
     assertGood("Der russische Erdölmagnat Emanuel Nobel, der Erbauer des ersten Dieselmotorschiffes.");
+    assertGood("Zur Versöhnung: Jüdische Gläubige sollen beten.");
 
     // https://github.com/languagetool-org/languagetool/issues/1515:
     assertGood("▶︎ Dies ist ein Test");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -914,6 +914,9 @@ private RuleMatch getCompoundError(AnalyzedTokenReadings token1, AnalyzedTokenRe
   private RuleMatch getRuleMatch(AnalyzedTokenReadings token1, AnalyzedSentence sentence, AnalyzedTokenReadings nextToken, String testPhrase, String hyphenTestPhrase) {
     try {
       initLt();
+      if (nextToken.getReadings().stream().allMatch(k -> k.getPOSTag() != null && k.getPOSTag().startsWith("EIG:"))) {
+        return null;
+      }
       List<String> replacements = new ArrayList<>();
       if (lt.check(testPhrase).size() == 0 && nextToken.isTagged()) {
         replacements.add(testPhrase);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -60,6 +60,9 @@ public void testCompoundMatch() throws IOException {
     assertBad("Wir gehen durchs Fitness Studio", "durchs Fitnessstudio", "durchs Fitness-Studio");
     //assertBad("Die Bad Taste Party von Susi", "Die Bad-Taste-Party");   // not supported yet
     //assertBad("Die Update Liste.", "Die Updateliste");  // not accepted by speller
+    List<RuleMatch> matches = lt.check("Er folgt damit dem Tipp des Autoren Michael Müller.");
+    assertThat(matches.size(), is(1));
+    assertFalse(matches.get(0).getMessage().contains("zusammengesetztes Nomen"));
   }
   
   @Test

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -348,7 +348,7 @@ private void testBadSentences(JLanguageTool lt, JLanguageTool allRulesLt, Langua
       // necessary for XML Pattern rules containing <or>
       List<RuleMatch> matches = new ArrayList<>();
       for (Rule auxRule : rules) {
-        if (lang.getShortCode().matches("gl|eo|ar|br|ca|zh")) {
+        if (lang.getShortCode().matches("gl|eo|br|ca|zh")) {
           // this is less strict, getMatchesForText() should be used. Language maintainers
           // should make sure their tests work even when in the strict mode:
           matches.addAll(getMatchesForSingleSentence(auxRule, badSentence, lt));

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -348,7 +348,7 @@ private void testBadSentences(JLanguageTool lt, JLanguageTool allRulesLt, Langua
       // necessary for XML Pattern rules containing <or>
       List<RuleMatch> matches = new ArrayList<>();
       for (Rule auxRule : rules) {
-        if (lang.getShortCode().matches("gl|eo|ar|br|ca|zh|uk")) {
+        if (lang.getShortCode().matches("gl|eo|ar|br|ca|zh")) {
           // this is less strict, getMatchesForText() should be used. Language maintainers
           // should make sure their tests work even when in the strict mode:
           matches.addAll(getMatchesForSingleSentence(auxRule, badSentence, lt));

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -114,6 +114,8 @@ public void testWrongVerb() throws IOException {
     assertGood("Wie ich sehe, benötigt ihr Nachschub.");
     assertGood("Einer wie du kennt doch bestimmt viele Studenten.");
     assertGood("Für Sie mache ich eine Ausnahme.");
+    assertGood("Ohne sie hätte ich das nicht geschafft.");
+    assertGood("Ohne Sie hätte ich das nicht geschafft.");
     // incorrect sentences:
     assertBad("Als Borcarbid weißt es eine hohe Härte auf.");
     assertBad("Das greift auf Vorläuferinstitutionen bist auf die Zeit von 1234 zurück.");

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/RussianSimpleReplaceRule.java
Patch:
@@ -68,7 +68,7 @@ public final String getId() {
 
   @Override
   public String getDescription() {
-    return "Поиск ошибочных слов/фраз";
+    return "Поиск просторечий и ошибочных фраз";
   }
 
   @Override
@@ -78,7 +78,7 @@ public String getShort() {
 
   @Override
   public String getSuggestion() {
-    return "«$match» — ошибочное слово/фраза, исправление: $suggestions";
+    return "«$match» — просторечие, исправление: $suggestions";
   }
 
   @Override

File: languagetool-language-modules/uk/src/test/java/org/languagetool/tokenizers/uk/UkrainianWordTokenizerTest.java
Patch:
@@ -206,6 +206,9 @@ public void testAbbreviations() {
     testList = w.tokenize("297 грн...");
     assertEquals(Arrays.asList("297", " ", "грн", "..."), testList);
 
+    testList = w.tokenize("297 грн.");
+    assertEquals(Arrays.asList("297", " ", "грн", "."), testList);
+
 //    testList = w.tokenize("297 грн.!!!");
 //    assertEquals(Arrays.asList("297", " ", "грн.", "!!!"), testList);
 

File: languagetool-language-modules/nl/src/test/java/org/languagetool/rules/nl/DutchTest.java
Patch:
@@ -30,7 +30,7 @@ public class DutchTest extends LanguageSpecificTest {
   @Test
   public void testLanguage() throws IOException {
     // NOTE: this text needs to be kept in sync with WelcomeController.php's getDefaultDemoTexts():
-    String s = "Languagetool doet van zelfsprekend veel meer dan spellingcontrole. Het ziet het ook fouten die minder inde gaten lopen, die je zelf geen eens ziet. De meldingen komen uit regels die door vrijwilligers gemaakt zijn aan de hand van suggesties van gebruikers en tips van taaldeskundigen. Ondanks het feit dat er veel aandacht aan de regels wordt besteed, blijven suggesties altijd welkom op het forum of op Twitter: @languagetool_nl. Probeer het rustig zelf eens uit hier, of download een van de plugins op deze pagina.";
+    String s = "Languagetool doet van zelfsprekend veel meer dan spellingcontrole. Het ziet ook fouten die minder inde gaten lopen, die je zelf geen eens ziet. De meldingen komen uit regels die door vrijwilligers gemaakt zijn aan de hand van suggesties van gebruikers en tips van taaldeskundigen. Ondanks het feit dat er veel aandacht aan de regels wordt besteed, blijven suggesties altijd welkom op het forum of op Twitter: @languagetool_nl. Probeer het rustig zelf eens uit hier, of download een van de plugins op deze pagina.";
     Dutch lang = new Dutch();
     testDemoText(lang, s,
       Arrays.asList("MORFOLOGIK_RULE_NL_NL", "NL_SIMPLE_REPLACE", "IN_DE", "GEEN_EENS", "AAN_DE_HAND_VAN", "ONDANKS_HET_FEIT_DAT", "MORFOLOGIK_RULE_NL_NL")

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1022,7 +1022,7 @@ private List<SuggestedReplacement> extendSuggestions(List<SuggestedReplacement>
       if (replacement.getShortDescription() == null) {  // don't overwrite more specific suggestions from the rule
         String descOrNull = descProvider.getShortDescription(replacement.getReplacement(), language);
         newReplacement.setShortDescription(descOrNull);
-        newReplacement.setDisplayValue(replacement.getDisplayValue());
+        newReplacement.setSuffix(replacement.getSuffix());
       }
       extended.add(newReplacement);
     }

File: languagetool-core/src/main/java/org/languagetool/tools/RuleMatchesAsJsonSerializer.java
Patch:
@@ -190,8 +190,8 @@ private void writeReplacements(JsonGenerator g, RuleMatch match) throws IOExcept
       if (replacement.getShortDescription() != null) {
         g.writeStringField("shortDescription", replacement.getShortDescription());
       }
-      if (replacement.getDisplayValue() != null) {
-        g.writeStringField("displayValue", replacement.getDisplayValue());
+      if (replacement.getSuffix() != null) {
+        g.writeStringField("suffix", replacement.getSuffix());
       }
       if (autoCorrect) {
         g.writeBooleanField("autoCorrect", true);

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/translation/BeoLingusTranslator.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.languagetool.rules.en.translation;
 
-import org.jetbrains.annotations.Nullable;
 import org.languagetool.GlobalConfig;
 import org.languagetool.rules.translation.DataSource;
 import org.languagetool.rules.translation.TranslationEntry;
@@ -44,7 +43,6 @@ public class BeoLingusTranslator implements Translator {
   private final Map<String,List<TranslationEntry>> de2en = new HashMap<>();
   private final Map<String,List<TranslationEntry>> en2de = new HashMap<>();
 
-  @Nullable
   static synchronized public BeoLingusTranslator getInstance(GlobalConfig globalConfig) throws IOException {
     if (instance == null && globalConfig != null && globalConfig.getBeolingusFile() != null) {
       long t1 = System.currentTimeMillis();
@@ -80,6 +78,7 @@ private BeoLingusTranslator(File file) throws IOException {
   }
 
   private void handleItem(Map<String, List<TranslationEntry>> map, String[] germanParts, String[] englishParts, int i, String germanPart) {
+    germanPart = germanPart.replaceAll("/.*?/", "");    // e.g. "oder {conj} /o.; od./"
     List<String> germanSubParts = split(germanPart);
     for (String germanSubPart : germanSubParts) {
       String key = cleanForLookup(germanSubPart);
@@ -92,7 +91,7 @@ private void handleItem(Map<String, List<TranslationEntry>> map, String[] german
         l.add(new TranslationEntry(split(germanPart), split(englishParts[i]), germanParts.length));
         map.put(key, l);
       }
-      //System.out.println(cleanForLookup(germanSubPart) + " ==> " + new Entry(germanPart, englishParts[i]));
+      //System.out.println(cleanForLookup(germanSubPart) + " ==> " + new TranslationEntry(split(germanPart), split(englishParts[i]), germanParts.length));
     }
   }
 
@@ -127,6 +126,7 @@ private String cleanForLookup(String s) {
     return s.replaceAll("\\{.*?\\}", "")
             .replaceAll("\\[.*?\\]", "")
             .replaceAll("\\(.*?\\)", "")
+            .replaceAll("/.*?/\\b", "")   // abbreviations, e.g. "oder {conj} /o.; od./"
             .trim()
             .toLowerCase();
   }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/UnicodeLanguageDetector.java
Patch:
@@ -19,7 +19,7 @@
 package org.languagetool.openoffice;
 
 /**
- * Helps detecting the language of strings by the Unicode range used by the characters.
+ * Helps to detect the language of strings by the Unicode range used by the characters.
  * @since 2.7
  */
 abstract class UnicodeLanguageDetector {

File: languagetool-core/src/main/java/org/languagetool/rules/BERTSuggestionRanking.java
Patch:
@@ -113,6 +113,7 @@ protected RemoteRequest prepareRequest(List<AnalyzedSentence> sentences) {
       }
       return new MatchesForReordering(matches, requests);
     } catch (IOException e) {
+      logger.error("Error while executing rule " + wrappedRule.getId(), e);
       return new MatchesForReordering(Collections.emptyList(), Collections.emptyList());
     }
   }

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/AmericanEnglish.java
Patch:
@@ -74,7 +74,7 @@ public List<Rule> getRelevantRemoteRules(ResourceBundle messageBundle, List<Remo
                                            UserConfig userConfig, Language motherTongue, List<Language> altLanguages)
     throws IOException {
     List<Rule> rules = new ArrayList<>(super.getRelevantRemoteRules(messageBundle, configs, userConfig, motherTongue, altLanguages));
-    RemoteRuleConfig bert = RemoteRuleConfig.getRelevantConfig("BERT", configs);
+    RemoteRuleConfig bert = RemoteRuleConfig.getRelevantConfig(BERTSuggestionRanking.RULE_ID, configs);
     if (UserConfig.hasABTestsEnabled()) {
       Rule speller = new MorfologikAmericanSpellerRule(messageBundle, this, userConfig, altLanguages);
       if (bert != null) {

File: languagetool-commandline/src/main/java/org/languagetool/commandline/Main.java
Patch:
@@ -83,9 +83,7 @@ class Main {
     if (options.getNeuralNetworkModel() != null) {
       lt.activateNeuralNetworkRules(options.getNeuralNetworkModel());
     }
-    if (options.getRemoteRulesFile() != null) {
-      lt.activateRemoteRules(new File(options.getRemoteRulesFile()));
-    }
+    lt.activateRemoteRules(options.getRemoteRulesFile() != null ? new File(options.getRemoteRulesFile()) : null);
     Tools.selectRules(lt, options.getDisabledCategories(), options.getEnabledCategories(),
             new HashSet<>(options.getDisabledRules()), new HashSet<>(options.getEnabledRules()), options.isUseEnabledOnly());
   }

File: languagetool-core/src/main/java/org/languagetool/Language.java
Patch:
@@ -194,6 +194,9 @@ public List<Rule> getRelevantLanguageModelCapableRules(ResourceBundle messages,
   }
 
 
+  /**
+   * Can return non-remote rules (e.g. if configuration missing, or for A/B tests), will be executed normally
+   */
   public List<Rule> getRelevantRemoteRules(ResourceBundle messageBundle, List<RemoteRuleConfig> configs,
                                            UserConfig userConfig, Language motherTongue, List<Language> altLanguages)
     throws IOException {

File: languagetool-core/src/main/java/org/languagetool/rules/BERTSuggestionRanking.java
Patch:
@@ -40,6 +40,7 @@
  */
 public class BERTSuggestionRanking extends RemoteRule {
   private static final Logger logger = LoggerFactory.getLogger(BERTSuggestionRanking.class);
+  public static final String RULE_ID = "BERT_SUGGESTION_RANKING";
 
   private final int suggestionLimit = 10;
 
@@ -58,7 +59,7 @@ public BERTSuggestionRanking(Rule rule, RemoteRuleConfig config, UserConfig user
     String ca = serviceConfiguration.getOptions().get("rootCertificate");
 
     RemoteLanguageModel model = null;
-    if (userConfig.isAbTestEnabled() && getId().equals(userConfig.getAbTest())) {
+    if (getId().equals(userConfig.getAbTest())) {
       try {
         model = new RemoteLanguageModel(host, port, ssl, key, cert, ca);
       } catch (Exception e) {
@@ -148,7 +149,7 @@ protected Callable<RemoteRuleResult> executeRequest(RemoteRequest request) {
 
   @Override
   public String getId() {
-    return "BERT_SUGGESTION_RANKING";
+    return RULE_ID;
   }
 
   @Override

File: languagetool-server/src/main/java/org/languagetool/server/PipelinePool.java
Patch:
@@ -206,9 +206,7 @@ Pipeline createPipeline(Language lang, Language motherTongue, TextChecker.QueryP
     } else {
       configureFromGUI(lt, lang);
     }
-    if (config.getRemoteRulesConfigFile() != null) {
-      lt.activateRemoteRules(config.getRemoteRulesConfigFile());
-    }
+    lt.activateRemoteRules(config.getRemoteRulesConfigFile());
     if (params.useQuerySettings) {
       Tools.selectRules(lt, new HashSet<>(params.disabledCategories), new HashSet<>(params.enabledCategories),
         new HashSet<>(params.disabledRules), new HashSet<>(params.enabledRules), params.useEnabledOnly);

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/dumpcheck/SentenceSourceChecker.java
Patch:
@@ -183,9 +183,7 @@ private void run(File propFile, Set<String> disabledRules, String langCode, List
         lt.enableRule(rule.getId());
       }
     }
-    if (remoteRules != null) {
-      lt.activateRemoteRules(remoteRules);
-    }
+    lt.activateRemoteRules(remoteRules);
     if (ruleIds != null) {
       enableOnlySpecifiedRules(ruleIds, lt);
     } else {

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -945,7 +945,7 @@ public RuleMatch adjustRuleMatchPos(RuleMatch match, int charCount,
       toPos = annotatedText.getOriginalTextPositionFor(toPos -1, true) + 1;
     }
     RuleMatch thisMatch = new RuleMatch(match);
-    thisMatch.setOffsetPosition(fromPos, toPos, thisMatch);
+    thisMatch.setOffsetPosition(fromPos, toPos);
     List<SuggestedReplacement> replacements = match.getSuggestedReplacementObjects();
     thisMatch.setSuggestedReplacementObjects(extendSuggestions(replacements));
 
@@ -1330,7 +1330,7 @@ private List<RuleMatch> getTextLevelRuleMatches() throws IOException {
             int newFromPos = annotatedText.getOriginalTextPositionFor(match.getFromPos(), false);
             int newToPos = annotatedText.getOriginalTextPositionFor(match.getToPos() - 1, true) + 1;
             RuleMatch newMatch = new RuleMatch(match);
-            newMatch.setOffsetPosition(newFromPos, newToPos, newMatch);
+            newMatch.setOffsetPosition(newFromPos, newToPos);
             newMatch.setLine(range.from.line);
             newMatch.setEndLine(range.to.line);
             if (match.getLine() == 0) {

File: languagetool-core/src/main/java/org/languagetool/rules/RuleMatch.java
Patch:
@@ -271,9 +271,9 @@ public int getToPos() {
     return offsetPosition.getEnd();
   }
 
-  public void setOffsetPosition(int fromPos, int toPos, RuleMatch ruleMatch) {
+  public void setOffsetPosition(int fromPos, int toPos) {
     if (toPos <= fromPos) {
-      throw new RuntimeException("fromPos (" + fromPos + ") must be less than toPos (" + toPos + ") for match: " + ruleMatch);
+      throw new RuntimeException("fromPos (" + fromPos + ") must be less than toPos (" + toPos + ") for match: " + this);
     }
     offsetPosition = new OffsetPosition(fromPos, toPos);
   }

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -159,7 +159,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
             if( token.getEndPos() < ruleMatch.getToPos() ) // done by multi-token speller, no need to adjust
               continue;
 
-            ruleMatch.setOffsetPosition(ruleMatch.getFromPos(), ruleMatch.getToPos()+hiddenCharOffset, ruleMatch);
+            ruleMatch.setOffsetPosition(ruleMatch.getFromPos(), ruleMatch.getToPos()+hiddenCharOffset);
           }
         }
       }

File: languagetool-core/src/main/java/org/languagetool/rules/RemoteRuleMetrics.java
Patch:
@@ -33,6 +33,7 @@ private RemoteRuleMetrics() {
 
   public enum RequestResult {
     SUCCESS,
+    SKIPPED,
     TIMEOUT,
     INTERRUPTED,
     DOWN,

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServer.java
Patch:
@@ -20,16 +20,15 @@
 
 import com.sun.net.httpserver.HttpServer;
 import org.languagetool.JLanguageTool;
-import org.languagetool.RuleLoggerManager;
-import org.languagetool.SlowRuleLogger;
 import org.languagetool.tools.Tools;
 
 import javax.management.ObjectName;
 import java.lang.management.ManagementFactory;
 import java.net.InetSocketAddress;
 import java.util.ResourceBundle;
 import java.util.Set;
-import java.util.concurrent.*;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.LinkedBlockingQueue;
 
 import static org.languagetool.server.HTTPServerConfig.DEFAULT_HOST;
 

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -76,6 +76,7 @@ class LanguageToolHttpHandler implements HttpHandler {
 
   /** @since 2.6 */
   void shutdown() {
+    textCheckerV2.shutdownNow();
   }
 
   @Override

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -31,6 +31,7 @@
 import org.languagetool.markup.AnnotatedText;
 import org.languagetool.markup.AnnotatedTextBuilder;
 import org.languagetool.rules.CategoryId;
+import org.languagetool.rules.RemoteRule;
 import org.languagetool.rules.DictionaryMatchFilter;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.rules.bitext.BitextRule;
@@ -180,6 +181,7 @@ private void prewarmPipelinePool() {
 
   void shutdownNow() {
     executorService.shutdownNow();
+    RemoteRule.shutdown();
   }
   
   void checkText(AnnotatedText aText, HttpExchange httpExchange, Map<String, String> parameters, ErrorRequestLimiter errorRequestLimiter,

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -56,6 +56,8 @@ public void testCompoundMatch() throws IOException {
     assertBad("Ein neuer LanguageTool Account", "Ein neuer LanguageTool-Account");
     assertBad("Danke für deine Account Daten", "deine Accountdaten", "deine Account-Daten");
     assertBad("Mit seinem Konkurrent Alistair Müller", "sein Konkurrent", "seinem Konkurrenten");
+    assertBad("Wir gehen ins Fitness Studio", "ins Fitnessstudio", "ins Fitness-Studio");
+    assertBad("Wir gehen durchs Fitness Studio", "durchs Fitnessstudio", "durchs Fitness-Studio");
     //assertBad("Die Bad Taste Party von Susi", "Die Bad-Taste-Party");   // not supported yet
     //assertBad("Die Update Liste.", "Die Updateliste");  // not accepted by speller
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -205,7 +205,7 @@ enum GrammarCategory {
       posRegex("PKT|KON:NEB|ZUS")// "Ist das Kunst?" / "Ist das Kunst oder Abfall?" / "Sind das Eier aus Bodenhaltung"
     ),
     Arrays.asList( // Die Präsent AG
-      tokenRegex("Präsent"),
+      token("Präsent"),
       token("AG")
     ),
     Arrays.asList(

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -261,7 +261,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Warum das Sinn macht?");
     assertGood("Das hängt davon ab, ob die Deutsch sprechen");
     assertGood("Die meisten Coaches wissen nichts.");
-    assertGood("Die Präsent AG.")
+    assertGood("Die Präsent AG.");
 
     // incorrect sentences:
     assertBad("Ein Buch mit einem ganz ähnlichem Titel.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -42,7 +42,7 @@ public class AgreementRuleTest {
   private JLanguageTool lt;
 
   @Before
-  public void setUp() throws IOException {
+  public void setUp() {
     rule = new AgreementRule(TestTools.getMessages("de"), (GermanyGerman)Languages.getLanguageForShortCode("de-DE"));
     lt = new JLanguageTool(Languages.getLanguageForShortCode("de-DE"));
   }
@@ -123,6 +123,8 @@ public void testDetNounRule() throws IOException {
     assertGood("Sie fragte verwirrt: „Ist das Zucker?“");
     assertGood("Er versuchte sich vorzustellen, was sein Klient für ein Mensch sei.");
     assertGood("Sie legen ein Teilstück jenes Weges zurück, den die Tausenden Juden 1945 auf sich nehmen mussten.");
+    assertGood("Aber das ignorierte Herr Grey bewusst.");
+    assertGood("Aber das ignorierte Herr Müller bewusst.");
 
     assertGood("Wir machen das Januar.");
     assertGood("Wir teilen das Morgen mit.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/SubjectVerbAgreementRule.java
Patch:
@@ -211,7 +211,9 @@ private RuleMatch getPluralMatchOrNull(AnalyzedTokenReadings[] tokens, int i, An
     if (plural.contains(tokenStr)) {
       AnalyzedTokenReadings prevToken = tokens[i - 1];
       List<ChunkTag> prevChunkTags = prevToken.getChunkTags();
+      AnalyzedTokenReadings nextToken = i + 1 < tokens.length ? tokens[i + 1] : null;
       boolean match = prevChunkTags.contains(NPS)
+                      && !(nextToken != null && nextToken.getToken().equals("Sie"))   // 'Eine Persönlichkeit sind Sie selbst.'
                       && !prevChunkTags.contains(NPP)
                       && !prevChunkTags.contains(PP)
                       && !isCurrency(prevToken)

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SubjectVerbAgreementRuleTest.java
Patch:
@@ -330,6 +330,7 @@ public void testRuleWithIncorrectPluralVerb() throws IOException {
   @Test
   public void testRuleWithCorrectPluralVerb() throws IOException {
     List<String> sentences = Arrays.asList(
+        "Eine Persönlichkeit sind Sie selbst.",
         "Die Katzen sind schön.",
         "Frau Meier und Herr Müller sind alt.",
         "Frau Julia Meier und Herr Karsten Müller sind alt.",

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -257,6 +257,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Unser Hund vergräbt seine Knochen im Garten.");
     assertGood("Ob das Mehrwert bringt?");
     assertGood("Warum das Sinn macht?");
+    assertGood("Das hängt davon ab, ob die Deutsch sprechen");
 
     // incorrect sentences:
     assertBad("Ein Buch mit einem ganz ähnlichem Titel.");

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/SpecificCaseRule.java
Patch:
@@ -98,7 +98,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) {
           } else {
             msg = "If the term is a proper noun, use the suggested capitalization.";
           }
-          RuleMatch match = new RuleMatch(this, sentence, tokens[i].getStartPos(), tokens[i].getStartPos() + phrase.length(), msg);
+          RuleMatch match = new RuleMatch(this, sentence, tokens[i].getStartPos(), tokens[i+j-1].getEndPos(), msg);
           match.setSuggestedReplacement(properSpelling);
           matches.add(match);
         }

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -229,7 +229,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
             boolean isSpecialCase = cleanWord.matches(".+-[A-ZÖÄÜ].*");
             if (acceptingLanguage != null && !isSpecialCase) {
               if (isAcceptedWordFromLanguage(acceptingLanguage, cleanWord)) {
-                break;
+                continue;
               }
               // e.g. "Der Typ ist in UK echt famous" -> could be German 'famos'
               ruleMatch = new RuleMatch(this, sentence,

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -418,6 +418,7 @@ private File getLOConfigDir() {
         MessageHandler.showError(new RuntimeException("Could not get home directory"));
         directory = null;
       } else if (SystemUtils.IS_OS_WINDOWS) {
+        // Path: \\user\<YourUserName>\AppData\Roaming\languagetool.org\LanguageTool\LibreOffice  
         File appDataDir = null;
         try {
           String appData = System.getenv("APPDATA");
@@ -434,6 +435,7 @@ private File getLOConfigDir() {
           directory = new File(userHome, path);
         }
       } else if (SystemUtils.IS_OS_LINUX) {
+        // Path: /home/<YourUserName>/.config/LanguageTool/LibreOffice  
         File appDataDir = null;
         try {
           String xdgConfigHome = System.getenv("XDG_CONFIG_HOME");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -557,7 +557,9 @@ public class CaseRule extends Rule {
     "Hinfahrt",
     "Hilfsstoff",
     "Hilfsstoffe",
-    "Hundert",   // je nach Kontext groß (TODO) 
+    "Hundert",   // groß und klein möglich 
+    "Zehntausend",   // groß und klein möglich 
+    "Hunderttausend",   // groß und klein möglich 
     "Hyperwallet", // Anglizismus
     "Ihnen",
     "Ihr",

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ResultCache.java
Patch:
@@ -82,11 +82,11 @@ void removeAndShift(int firstParagraph, int lastParagraph, int shift) {
     
     Map<Integer, CacheSentenceEntries> tmpEntries = entries;
     entries = new HashMap<>();
-    for(int i : entries.keySet()) {
+    for(int i : tmpEntries.keySet()) {
       if(i > lastParagraph) {
-        entries.put(i + shift, entries.get(i));
+        entries.put(i + shift, tmpEntries.get(i));
       } else {
-        entries.put(i, entries.get(i));
+        entries.put(i, tmpEntries.get(i));
       } 
     }
   }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -122,6 +122,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Eine lückenlose Aufklärung sämtlicher physiologischer Gehirnprozesse");
     assertGood("Sie fragte verwirrt: „Ist das Zucker?“");
     assertGood("Er versuchte sich vorzustellen, was sein Klient für ein Mensch sei.");
+    assertGood("Sie legen ein Teilstück jenes Weges zurück, den die Tausenden Juden 1945 auf sich nehmen mussten.");
 
     assertGood("Wir machen das Januar.");
     assertGood("Wir teilen das Morgen mit.");

File: languagetool-core/src/main/java/org/languagetool/rules/EmptyLineRule.java
Patch:
@@ -25,6 +25,7 @@
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.AnalyzedTokenReadings;
 import org.languagetool.Language;
+import org.languagetool.tools.Tools;
 
 /**
  * A rule that checks for empty lines. Useful especially for office extension
@@ -68,7 +69,7 @@ public org.languagetool.rules.RuleMatch[] match(List<AnalyzedSentence> sentences
     int pos = 0;
     for (int n = 0; n < sentences.size() - 1; n++) {
       AnalyzedSentence sentence = sentences.get(n);
-      if(sentence.hasParagraphEndMark(lang)) {
+      if(Tools.isParagraphEnd(sentences, n, lang)) {
         if(isSecondParagraphEndMark(sentence.getText())) {
           AnalyzedTokenReadings[] tokens = sentence.getTokensWithoutWhitespace();
           if(tokens.length > 1) {

File: languagetool-core/src/main/java/org/languagetool/rules/ParagraphRepeatBeginningRule.java
Patch:
@@ -27,6 +27,7 @@
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.AnalyzedTokenReadings;
 import org.languagetool.Language;
+import org.languagetool.tools.Tools;
 
 /**
  * Check if to paragraphs begin with the same word.
@@ -117,7 +118,7 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
     
     for (int n = 0; n < sentences.size() - 1; n++) {
       nextPos += sentences.get(n).getText().length();
-      if(sentences.get(n).hasParagraphEndMark(lang)) {
+      if(Tools.isParagraphEnd(sentences, n, lang)) {
         nextSentence = sentences.get(n + 1);
         nextTokens = nextSentence.getTokensWithoutWhitespace();
         endPos = numCharEqualBeginning(lastTokens, nextTokens);

File: languagetool-core/src/main/java/org/languagetool/rules/ReadabilityRule.java
Patch:
@@ -34,6 +34,7 @@
 import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.rules.TextLevelRule;
+import org.languagetool.tools.Tools;
 import org.languagetool.rules.Category.Location;
 
 /**
@@ -290,7 +291,7 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
           }
         }
       }
-      if(sentence.hasParagraphEndMark(lang) || n == sentences.size() - 1) {
+      if(Tools.isParagraphEnd(sentences, n, lang)) {
         if (nWords >= MIN_WORDS) {
           /* Equation for readability
            * FRE = Flesch-Reading-Ease

File: languagetool-core/src/main/java/org/languagetool/rules/WhiteSpaceBeforeParagraphEnd.java
Patch:
@@ -26,6 +26,7 @@
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.AnalyzedTokenReadings;
 import org.languagetool.Language;
+import org.languagetool.tools.Tools;
 
 /**
  * A rule that checks for a whitespace at the end of a paragraph
@@ -66,7 +67,7 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
     int pos = 0; 
     for (int n = 0; n < sentences.size(); n++) {
       AnalyzedSentence sentence = sentences.get(n);
-      if(n == sentences.size() - 1 || sentence.hasParagraphEndMark(lang)) {
+      if(Tools.isParagraphEnd(sentences, n, lang)) {
         AnalyzedTokenReadings[] tokens = sentence.getTokens();
         int lb;
         int lw;

File: languagetool-core/src/main/java/org/languagetool/rules/ConfusionSetLoader.java
Patch:
@@ -93,6 +93,9 @@ public Map<String,List<ConfusionPair>> loadConfusionPairs(InputStream stream) th
             pairs.add(confusionSet);
             map.put(key, pairs);
           }
+          if (!bidirectional) {
+            break;   // "A -> B", so only consider that direction
+          }
         }
       }
     }

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -346,7 +346,7 @@ protected void filterDupes(List<String> words) {
     }
   }
 
-  protected void init() throws IOException {
+  protected synchronized void init() throws IOException {
     for (String ignoreWord : wordListLoader.loadWords(getIgnoreFileName())) {
       addIgnoreWords(ignoreWord);
     }

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -359,7 +359,7 @@ else if (token.length() < 20) {
   }
 
   @Override
-  protected void init() throws IOException {
+  protected synchronized void init() throws IOException {
     super.init();
     String langCountry = language.getShortCode();
     if (language.getCountries().length > 0) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanCompoundRuleTest.java
Patch:
@@ -108,6 +108,7 @@ private void runTests() throws IOException {
     check(0, "Aggregatzustand");
     check(0, "Aggregat-Zustand");
     check(1, "Aggregat Zustand", "Aggregatzustand");
+    check(1, "Billard Kugel", "Billardkugel");
   }
   
 }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/LineExpanderTest.java
Patch:
@@ -38,7 +38,6 @@ public void testExpansion() {
     assertThat(expand("klein/A"), is("[klein, kleine, kleiner, kleines, kleinen, kleinem]"));
     assertThat(expand("x/NSE"), is("[x, xn, xs, xe]"));
     assertThat(expand("x/NA"), is("[x, xn, xe, xer, xes, xen, xem]"));
-    assertThat(expand("xxx/V"), is("[xxxn, xxxe, xxxst, xxxt, xxxte, xxxtest, xxxten]"));  // note: no "xxx"
     assertThat(expand("viertjüngste/A"), is("[viertjüngste, viertjüngster, viertjüngstes, viertjüngsten, viertjüngstem]"));
     assertThat(expand("Das  #foo"), is("[Das]"));
     assertThat(expand("Tisch/E  #bla #foo"), is("[Tisch, Tische]"));

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -990,7 +990,7 @@ private static MorfologikMultiSpeller getSpeller(Language language, UserConfig u
           BufferedReader variantReader = null;
           if (languageVariantPlainTextDict != null && !languageVariantPlainTextDict.isEmpty()) {
             InputStream variantStream = JLanguageTool.getDataBroker().getFromResourceDirAsStream(languageVariantPlainTextDict);
-            variantReader = new ExpandingReader (new BufferedReader(new InputStreamReader(variantStream, UTF_8)));
+            variantReader = new ExpandingReader(new BufferedReader(new InputStreamReader(variantStream, UTF_8)));
           }
           return new MorfologikMultiSpeller(morfoFile, new ExpandingReader(br), paths,
             variantReader, languageVariantPlainTextDict, userConfig != null ? userConfig.getAcceptedWords(): Collections.emptyList(), MAX_EDIT_DISTANCE);

File: languagetool-core/src/main/java/org/languagetool/rules/PunctuationMarkAtParagraphEnd.java
Patch:
@@ -100,7 +100,7 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
     boolean isFirstWord;
     for (int n = 0; n < sentences.size(); n++) {
       AnalyzedSentence sentence = sentences.get(n);
-      if (sentence.hasParagraphEndMark(lang) || n == sentences.size() - 1) {
+      if (sentence.hasParagraphEndMark(lang) || (n == sentences.size() - 1)) {
         AnalyzedTokenReadings[] tokens = sentence.getTokensWithoutWhitespace();
         if (tokens.length > 2) {
           isFirstWord = (isWord(tokens[1]) && !isPunctuationMark(tokens[2]))
@@ -114,6 +114,7 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
             if (tokens[tokens.length-2].getToken().equalsIgnoreCase(":") &&
                 WordTokenizer.isUrl(tokens[tokens.length-1].getToken())) {
               // e.g. "find it at: http://example.com" should not be an error
+              lastPara = n;
               pos += sentence.getText().length();
               continue;
             }
@@ -131,8 +132,8 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
               ruleMatches.add(ruleMatch);
             }
           }
-          lastPara = n;
         }
+        lastPara = n;
       }
       pos += sentence.getText().length();
     }

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractUnitConversionRule.java
Patch:
@@ -204,9 +204,10 @@ protected AbstractUnitConversionRule(ResourceBundle messages) {
 
     addUnit("mi", MILE, "mi", 1, false);
     addUnit("yd", YARD, "yd", 1, false);
-    addUnit("(?:ft|′|')", FEET, "ft", 1, false);
+    // negative lookahead here to avoid matching "'s" and so on
+    addUnit("(?:ft|′|')(?!(\\w|\\d))", FEET, "ft", 1, false);
     // removed 'in', " because of many false positives
-    addUnit("(?:inch|″)", INCH, "inch", 1, false);
+    addUnit("(?:inch|″)(?!(\\w|\\d))", INCH, "inch", 1, false);
 
     addUnit("(?:km/h|kmh)", KILOMETRE_PER_HOUR, "km/h", 1, true);
     addUnit("(?:mph)", MILE.divide(HOUR), "mph", 1, false);

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractUnitConversionRule.java
Patch:
@@ -204,9 +204,10 @@ protected AbstractUnitConversionRule(ResourceBundle messages) {
 
     addUnit("mi", MILE, "mi", 1, false);
     addUnit("yd", YARD, "yd", 1, false);
-    addUnit("(?:ft|′|')", FEET, "ft", 1, false);
+    // negative lookahead here to avoid matching "'s" and so on
+    addUnit("(?:ft|′|')(?!(\\w|\\d))", FEET, "ft", 1, false);
     // removed 'in', " because of many false positives
-    addUnit("(?:inch|″)", INCH, "inch", 1, false);
+    addUnit("(?:inch|″)(?!(\\w|\\d))", INCH, "inch", 1, false);
 
     addUnit("(?:km/h|kmh)", KILOMETRE_PER_HOUR, "km/h", 1, true);
     addUnit("(?:mph)", MILE.divide(HOUR), "mph", 1, false);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -816,7 +816,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     putRepl("repetativ(ere|ste)[mnrs]?$", "repetat", "repetit");
     putRepl("voluptös(e|ere|este)?[mnrs]?$", "tös", "tuös");
     putRepl("[pP]flanzig(e[mnrs]?)?", "ig", "lich");
-    putRepl("geblogt(e[mnrs]?)?$", "g", "gg");
+    putRepl("geblogt(e[mnrs]?)?$", "gt", "ggt");
   }
 
   private static void putRepl(String wordPattern, String pattern, String replacement) {

File: languagetool-server/src/main/java/org/languagetool/server/V2TextChecker.java
Patch:
@@ -119,7 +119,7 @@ protected List<String> getPreferredVariants(Map<String, String> parameters) {
     List<String> preferredVariants;
     if (parameters.get("preferredVariants") != null) {
       preferredVariants = Arrays.asList(parameters.get("preferredVariants").split(",\\s*"));
-      if (!"auto".equals(parameters.get("language"))) {
+      if (!"auto".equals(parameters.get("language")) && (parameters.get("multilingual") == null || parameters.get("multilingual").equals("false"))) {
         throw new IllegalArgumentException("You specified 'preferredVariants' but you didn't specify 'language=auto'");
       }
     } else {

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/EnglishUnpairedBracketsRuleTest.java
Patch:
@@ -64,6 +64,7 @@ public void testRule() throws IOException {
     assertCorrect("This is what he said: \"We believe in freedom. This is what we do.\"");
     assertCorrect("(([20] [20] [20]))");
     assertCorrect("I'm not goin'");
+    assertCorrect("He's an 'admin'.");
     // test for a case that created a false alarm after disambiguation
     assertCorrect("This is a \"special test\", right?");
     // numerical bullets

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/RuleMatchDiffFinder.java
Patch:
@@ -113,6 +113,9 @@ private void print(List<RuleMatchDiff> diffs, FileWriter fw) throws IOException
   }
 
   private String cleanSource(String ruleSource) {
+    if (ruleSource == null) {
+      return "java";
+    }
     return ruleSource.replaceFirst("^.*/grammar", "gram.").replaceFirst("gram.-premium", "prem").replaceFirst(".xml", "");
   }
 

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/EnglishUnpairedBracketsRuleTest.java
Patch:
@@ -63,6 +63,7 @@ public void testRule() throws IOException {
     assertCorrect("The plight of Tamil refugees caused a surge of support from most of the Tamil political parties.[90]");
     assertCorrect("This is what he said: \"We believe in freedom. This is what we do.\"");
     assertCorrect("(([20] [20] [20]))");
+    assertCorrect("I'm not goin'");
     // test for a case that created a false alarm after disambiguation
     assertCorrect("This is a \"special test\", right?");
     // numerical bullets

File: languagetool-dev/src/main/java/org/languagetool/dev/bigdata/AllConfusionRulesEvaluator.java
Patch:
@@ -43,7 +43,7 @@ private AllConfusionRulesEvaluator() {
 
   public static void main(String[] args) throws IOException {
     if (args.length < 3 || args.length > 4) {
-      System.err.println("Usage: " + ConfusionRuleEvaluator.class.getSimpleName()
+      System.err.println("Usage: " + AllConfusionRulesEvaluator.class.getSimpleName()
               + " <langCode> <languageModelTopDir> <wikipediaXml|tatoebaFile|dir>...");
       System.err.println("   <languageModelTopDir> is a directory with sub-directories '1grams', '2grams', and '3grams' with Lucene indexes");
       System.err.println("   <wikipediaXml|tatoebaFile|dir> either a Wikipedia XML dump, or a Tatoeba file or");
@@ -66,7 +66,7 @@ public static void main(String[] args) throws IOException {
     ConfusionRuleEvaluator eval = new ConfusionRuleEvaluator(lang, languageModel, false, true); // TODO: consider bidirectional
     eval.setVerboseMode(false);
     ConfusionSetLoader confusionSetLoader = new ConfusionSetLoader();
-    InputStream inputStream = JLanguageTool.getDataBroker().getFromResourceDirAsStream("/en/confusion_sets.txt");
+    InputStream inputStream = JLanguageTool.getDataBroker().getFromResourceDirAsStream("/" + lang.getShortCode() +"/confusion_sets.txt");
     Map<String,List<ConfusionPair>> confusionSetMap = confusionSetLoader.loadConfusionPairs(inputStream);
     Set<String> done = new HashSet<>();
     int fMeasureCount = 0;

File: languagetool-language-modules/fr/src/test/java/org/languagetool/rules/fr/FrenchCompoundAwareHunspellRuleTest.java
Patch:
@@ -48,6 +48,8 @@ public void testSpellcheck() throws IOException {
     assertSuggestion(lt, "coulurs", "couleurs"); 
     assertSuggestion(lt, "boton", "bot on", "bâton", "béton");  // "bouton" would be better? 
     assertSuggestion(lt, "skype", "Skype");
+    assertSuggestion(lt, "Wordpress", "WordPress");
+    assertSuggestion(lt, "wordpress", "WordPress");
   }
 
   private void assertSuggestion(JLanguageTool lt, String input, String... expected) throws IOException {
@@ -59,4 +61,4 @@ private void assertSuggestion(JLanguageTool lt, String input, String... expected
     }
   }
 
-}
\ No newline at end of file
+}

File: languagetool-language-modules/ar/src/main/java/org/languagetool/tagging/ar/ArabicTagger.java
Patch:
@@ -27,7 +27,6 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import java.lang.StringBuilder;
 import java.util.Locale;
 
 /**
@@ -64,11 +63,12 @@ public List<AnalyzedTokenReadings> tag(List<String> sentenceTokens) {
     int pos = 0;
     for (String word : sentenceTokens) {
       List<AnalyzedToken> l = new ArrayList<>();
-      List<AnalyzedToken> taggerTokens = asAnalyzedTokenListForTaggedWords(word, getWordTagger().tag(word));
+      String striped = word.replaceAll("[\u064B\u064C\u064D\u064E\u064F\u0650\u0651\u0652\u0653\u0654\u0655\u0656\u0640]", "");
+      List<AnalyzedToken> taggerTokens = asAnalyzedTokenListForTaggedWords(word, getWordTagger().tag(striped));
       addTokens(taggerTokens, l);
       // additional tagging with prefixes
       if (l.isEmpty()) {
-        addTokens(additionalTags(word, dictLookup), l);
+        addTokens(additionalTags(striped, dictLookup), l);
       }
       if (l.isEmpty()) {
         l.add(new AnalyzedToken(word, null, null));

File: languagetool-core/src/main/java/org/languagetool/language/CommonWords.java
Patch:
@@ -40,7 +40,8 @@ public CommonWords() throws IOException {
     synchronized (word2langs) {
       if (word2langs.isEmpty()) {
         for (Language lang : Languages.get()) {
-          if (lang.isVariant()) {
+          if (lang.isVariant() &&
+              !lang.getShortCode().equals("no")) {  // ugly hack to quick fix https://github.com/languagetooler-gmbh/languagetool-premium/issues/822 
             continue;
           }
           ResourceDataBroker dataBroker = JLanguageTool.getDataBroker();

File: languagetool-language-modules/ar/src/main/java/org/languagetool/tagging/ar/ArabicTagger.java
Patch:
@@ -47,11 +47,11 @@ public String getManualAdditionsFileName() {
   /* Add the flag to an encoded tag */
   public String addTag(String postag, String flag) {
     StringBuilder tmp = new StringBuilder(postag);
-    if (flag == "W") {
+    if (flag.equals("W")) {
       tmp.setCharAt(postag.length() - 3, 'W');
-    } else if (flag == "K") {
+    } else if (flag.equals("K")) {
       tmp.setCharAt(postag.length() - 2, 'K');
-    } else if (flag == "L") {
+    } else if (flag.equals("L")) {
       tmp.setCharAt(postag.length() - 2, 'L');
     }
     return tmp.toString();

File: languagetool-server/src/main/java/org/languagetool/server/HTTPSServer.java
Patch:
@@ -71,7 +71,7 @@ public HTTPSServer(HTTPSServerConfig config, boolean runInternally, String host,
       RequestLimiter limiter = getRequestLimiterOrNull(config);
       ErrorRequestLimiter errorLimiter = getErrorRequestLimiterOrNull(config);
       LinkedBlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>();
-      httpHandler = new LanguageToolHttpHandler(config, allowedIps, runInternally, limiter, errorLimiter, workQueue);
+      httpHandler = new LanguageToolHttpHandler(config, allowedIps, runInternally, limiter, errorLimiter, workQueue, this);
       server.createContext("/", httpHandler);
       executorService = getExecutorService(workQueue, config);
       server.setExecutor(executorService);

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServer.java
Patch:
@@ -103,7 +103,7 @@ public HTTPServer(HTTPServerConfig config, boolean runInternally, String host, S
       RequestLimiter limiter = getRequestLimiterOrNull(config);
       ErrorRequestLimiter errorLimiter = getErrorRequestLimiterOrNull(config);
       LinkedBlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>();
-      httpHandler = new LanguageToolHttpHandler(config, allowedIps, runInternally, limiter, errorLimiter, workQueue);
+      httpHandler = new LanguageToolHttpHandler(config, allowedIps, runInternally, limiter, errorLimiter, workQueue, this);
 
       InetSocketAddress address = host != null ? new InetSocketAddress(host, port) : new InetSocketAddress(port);
       server = HttpServer.create(address, 0);

File: languagetool-core/src/main/java/org/languagetool/synthesis/Synthesizer.java
Patch:
@@ -57,7 +57,7 @@ public interface Synthesizer {
   
   /**
    * Spells out a number
-   * @param Number in arabic numerals 
+   * @param arabicNumeral in arabic numerals 
    * @return String of the spelled out number
    */
   

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikAmericanSpellerRuleTest.java
Patch:
@@ -98,6 +98,7 @@ public void testMorfologikSpeller() throws IOException {
     assertEquals(0, rule.match(lt.getAnalyzedSentence("123454")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("I like my emoji 😾")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("μ")).length);
+    assertEquals(0, rule.match(lt.getAnalyzedSentence("I like my emoji ❤️")).length);
 
     // test words in language-specific spelling_en-US.txt
     assertEquals(0, rule.match(lt.getAnalyzedSentence("USTestWordToBeIgnored")).length);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/SubjectVerbAgreementRule.java
Patch:
@@ -95,9 +95,9 @@ public class SubjectVerbAgreementRule extends Rule {
       tokenRegex("ist|war")
     ),
     Arrays.asList(
-      pos(JLanguageTool.SENTENCE_START_TAGNAME),
-      posRegex("EIG:.*"),
-      new PatternTokenBuilder().csToken("und").setSkip(2).build(),
+      posRegex(JLanguageTool.SENTENCE_START_TAGNAME+"|KON:UNT"),
+      posRegex("(EIG|SUB):.*"),
+      new PatternTokenBuilder().csToken("und").setSkip(3).build(),
       tokenRegex("sind|waren")
     ),
     Arrays.asList(

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -84,7 +84,7 @@ public class VerbAgreementRule extends TextLevelRule {
       token("anstelle")
     ),
     Arrays.asList( // "Ok bin ab morgen bei euch." (umgangssprachlich, benötigt eigene Regel)
-      tokenRegex("ok|okay|ja|nein|vielleiecht|oh"),
+      tokenRegex("ok(ay)?|ja|nein|vielleicht|oh"),
       tokenRegex("bin|sind")
     ),
     Arrays.asList(

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SubjectVerbAgreementRuleTest.java
Patch:
@@ -413,7 +413,8 @@ public void testRuleWithCorrectPluralVerb() throws IOException {
         "Details, Dialoge, wie auch die Typologie der Charaktere sind frei erfunden.",
         "Die internen Ermittler und auch die Staatsanwaltschaft sind nun am Zug.",
         "Sie sind so erfolgreich, weil sie eine Einheit sind.",
-        "Auch Polizisten zu Fuß sind unterwegs."
+        "Auch Polizisten zu Fuß sind unterwegs.",
+        "Julia sagte, dass Vater und Mutter zu Hause sind."
     );
     for (String sentence : sentences) {
       assertGood(sentence);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -204,7 +204,7 @@ public class CaseRule extends Rule {
       csToken("das"),
       posRegex("VER:.+"),
       new PatternTokenBuilder().pos("KON:NEB").setSkip(5).build(),
-      posRegex("VER:AUX:.*"),
+      posRegex("VER:(AUX|MOD):.*"),
       posRegex("PKT|KON:NEB")
     ),
     Arrays.asList(

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -64,6 +64,7 @@ public void testRule() throws IOException {
     assertGood("Das Winseln stört.");
     assertGood("Das schlägt nicht so zu Buche.");
     assertGood("Dirk Hetzel ist ein Name.");
+    assertGood("Aber sie tat es, sodass unsere Klasse das sehen und fotografieren konnte.");
     assertGood("Sein Verhalten war okay.");
     assertGood("Hier ein Satz. \"Ein Zitat.\"");
     assertGood("Hier ein Satz. 'Ein Zitat.'");

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternTestTools.java
Patch:
@@ -54,7 +54,7 @@ public final class PatternTestTools {
    * These strings are not be recognized as a regular expression
    */
   private static final Set<String> NO_REGEXP = new HashSet<>(Arrays.asList(
-    "PRP:LOK+TMP+MOD:DAT+AKK", "AUX:ind+pres+3+p", "PRP:TMP+MOD+CAU:DAT"
+    "PRP:LOK+TMP+MOD:DAT+AKK", "AUX:ind+pres+3+p", "PRP:TMP+MOD+CAU:DAT", "PRP:LOK+TMP:DAT"
     ));
 
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -926,7 +926,7 @@ private boolean isPotentialUpperCaseError (int pos, AnalyzedTokenReadings[] toke
         && tokens[pos].hasAnyPartialPosTag("SUB:NOM:SIN:NEU:INF", "SUB:DAT:PLU:")
         && ("zu".equals(tokens[pos-1].getToken()) || hasPartialTag(tokens[pos-1], "SUB", "EIG", "VER:AUX:3:", "ADV:TMP", "ABK"))) {
       // find error in: "Der Brief wird morgen Übergeben." / "Die Ausgaben haben eine Mrd. Euro Überschritten."
-      isPotentialError |= lowercaseReadings.hasPosTag("PA2:PRD:GRU:VER") && !tokens[pos-1].hasPosTagStartingWith("VER:AUX:3");
+      isPotentialError |= lowercaseReadings.hasPosTag("PA2:PRD:GRU:VER") && !tokens[pos-1].hasPosTagStartingWith("VER:AUX:3") && !lowercaseReadings.hasPosTag("VER:3:PLU:PRT:NON");
       // find error in: "Er lässt das Arktisbohrverbot Überprüfen."
       // find error in: "Sie bat ihn, es zu Überprüfen."
       // find error in: "Das Geld wird Überwiesen."

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -56,6 +56,7 @@ public void testRule() throws IOException {
     assertGood("Das ist eine Abkehr von Gottes Geboten.");
     assertGood("Dem Hund Futter geben");
     assertGood("Heute spricht Frau Stieg.");
+    assertGood("So könnte es auch den Handwerksbetrieben gehen, die ausbilden und deren Ausbildung dann Industriebetrieben zugutekäme.");
     assertGood("Die Firma Drosch hat nicht pünktlich geliefert.");
     assertGood("3.1 Technische Dokumentation");
     assertGood("Ein einfacher Satz zum Testen.");

File: languagetool-language-modules/en/src/main/java/org/languagetool/synthesis/en/EnglishSynthesizer.java
Patch:
@@ -110,7 +110,7 @@ public String[] synthesize(AnalyzedToken token, String posTag,
 
       for (String tag : possibleTags) {
         Matcher m = p.matcher(tag);
-        if (m.matches()) {
+        if (m.matches() && token.getLemma() != null) {
           lookup(token.getLemma(), tag, results, det);
         }
       }

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -115,11 +115,8 @@ protected void runGrammarRulesFromXmlTest(Language ignoredLanguage) throws IOExc
    * and that's only the demo language for languagetool-core.
    */
   protected void runGrammarRulesFromXmlTest() throws IOException {
-    int i = 0;
     for (Language lang : Languages.get()) {
-      if (i>0)
         runGrammarRuleForLanguage(lang);
-      i++;
     }
     if (Languages.get().isEmpty()) {
       System.err.println("Warning: no languages found in classpath - cannot run any grammar rule tests");

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -64,7 +64,7 @@ public class ReflexiveVerbsRule extends Rule {
   private static final List<String> verbsSovintAmbComplement = Arrays.asList ("deixar","fer","veure","costar");
   private static final List<String> verbsDeixarFer= Arrays.asList ("deixar", "fer");
   private static final List<String> verbsPortarDur = Arrays.asList ("portar", "dur");
-  private static final List<String> lemesEnPerifrasis = Arrays.asList ("soler", "tornar", "haver", "anar", "deure", "poder", "voler");//, "a", "de", "en", "pas");
+  private static final List<String> lemesEnPerifrasis = Arrays.asList ("pensar", "intentar", "deixar", "estar", "anar", "acabar", "començar", "soler", "tornar", "haver", "anar", "deure", "poder", "voler");//, "a", "de", "en", "pas");
   
   
   private static final List<String> verbsPotencialmentPronominals = Arrays.asList("abaixar", "abandonar", "abarrocar", "abellir", "abismar", "abissar", "ablamar", "ablanir", "abocar", "aboldronar", "abonançar", "abonar", "abonir", "abonyegar", "abordar", "abraonar", "abraçar", "abrivar", "abroquerar", "abrusar", "absentar", "abstraure", "abstreure", "aburgesar", "acabar", "acalar", "acalorar", "acantonar", "acarrerar", "acastellanar", "acatalanar", "accelerar", "acetificar", "acidificar", "aclarir", "aclimatar", "aclivellar", "aclucar", "acoblar", "acollir", "acollonir", "acomiadar", "acomodar", "acomplexar", "acomplir", "aconductar", "aconsellar", "acontentar", "acopar", "acoquinar", "acordar", "acorruar", "acostar", "acostumar", "acotar", "acotxar", "acovardir", "acreditar", "acréixer", "acubar", "acubillar", "acudir", "acugular", "acuitar", "acular", "acumular", "acusar", "adaptar", "adargar", "adherir", "adjudicar", "adollar", "adolorir", "adondar", "adormir", "adossar", "adotzenar", "adreçar", "adscriure", "adunar", "afalconar", "afanyar", "afartar", "afeblir", "afectar", "afermar", "aferrar", "afigurar", "afilar", "afilerar", "afiliar", "afillar", "afinar", "aflaquir", "afligir", "aflonjar", "afluixar", "afogar", "afollar", "afrancesar", "afrevolir", "afuar", "afusar", "agabellar", "agafar", "agarbar", "agarbonar", "agitar", "aglomerar", "aglutinar", "agombolar", "agostejar", "agradar", "agregar", "agremiar", "agreujar", "agrir", "agrisar", "agrumar", "aguantar", "aguditzar", "aigualir", "airejar", "aixecar", "aixoplugar", "ajaure", "ajaçar", "ajeure", "ajornalar", "ajudar", "ajuntar", "ajupir", "ajustar", "alabar", "alarmar", "alcalinitzar", "alcoholitzar", "alegrar", "alentir", "aliar", "alimentar", "alinear", "allarar", "allargar", "allargassar", "allerar", "alleugerir", "alleujar", "alliberar", "alligar", "allistar", "allitar", "allotjar", "allunyar", "alterar", "alzinar", "alçar", "amagar", "amagrir", "amanerar", "amanir", "amansar", "amansir", "amassar", "ambientar", "americanitzar", "amistançar", "amistar", "amollar", "amorar", "amorosir", "amorrar", "amorriar", "amotinar", "amoïnar", "amuntegar", "anastomitzar", "angoixar", "anguniejar", "animar", "anomenar", "anticipar", "apagar", "apaivagar", "apanyar", "aparellar", "apariar", "apartar", "aparèixer", "apassionar", "apercebre", "apilotar", "apinyar", "apitrar", "aplanar", "aplaçar", "aplicar", "apocar", "apoderar", "aposentar", "apostar", "apostemar", "apregonar", "aprendre", "apressar", "aprimar", "aprofitar", "apropar", "apropiar", "aprovisionar", "aproximar", "apujar", "apuntalar", "aquedar", "aquietar", "aquilotar", "arborar", "arbrar", "arcar", "argollar", "aristocratitzar", "armar", "arquejar", "arraconar", "arramadar", "arrambar", "arramellar", "arranjar", "arrapar", "arraulir", "arrear", "arrecerar", "arredossar", "arreglar", "arrelar", "arremangar", "arremolinar", "arremorar", "arrenglerar", "arreplegar", "arrestar", "arribar", "arrimar", "arriscar", "arrissar", "arrodonir", "arromangar", "arrombollar", "arronsar", "arrossegar", "arrufar", "arrugar", "arruïnar", "articular", "asfixiar", "assabentar", "assaonar", "assecar", "assegurar", "assentar", "assenyalar", "asserenar", "assessorar", "asseure", "assimilar", "associar", "assolar", "assolellar", "assossegar", "assotar", "astorar", "atabalar", "ataconar", "atalaiar", "atandar", "atansar", "atapeir", "atardar", "atavellar", "aterrir", "aterrossar", "atipar", "atiplar", "atonir", "atorrollar", "atracar", "atribolar", "atribuir", "atrinxerar", "atrofiar", "atropellar", "atrotinar", "aturar", "avalotar", "avançar", "avarar", "avariar", "avenir", "aventurar", "avergonyir", "avesar", "aviar", "aviciar", "avidar", "avivar", "avorrir", "aïllar", "aïrar", "badar", "balancejar", "balandrejar", "baldar", "banyar", "barallar", "barrejar", "basar", "basquejar", "bastar", "batre", "befar", "bellugar", "beneficiar", "bleir", "blocar", "bolcar", "bombar", "bonificar", "botir", "brindar", "brossar", "bufar", "buidar", "burocratitzar", "cabrejar", "cabussar", "cagar", "calar", "calmar", "calçar", "campar", "cansar", "cap", "capalçar", "capbussar", "capficar", "capgirar", "captar", "captrencar", "caracteritzar", "caragirar", "carbonar", "carbonatar", "carbonitzar", "cardar", "cargolar", "carregar", "cartejar", "casar", "cascar", "cenyir", "cerciorar", "cicatritzar", "circumscriure", "clamar", "classificar", "clavar", "clivellar", "cloure", "coagular", "cobrir", "colar", "colgar", "colltorçar", "colltòrcer", "colrar", "coltellejar", "col·lapsar", "col·legiar", "col·locar", "comanar", "combinar", "compadir", "compaginar", "compatir", "compensar", "complementar", "complexificar", "complicar", "complir", "complànyer", "compondre", "comportar", "comprendre", "comprimir", "comprometre", "compungir", "comunicar", "concentrar", "concertar", "conciliar", "concordar", "concretar", "condemnar", "condensar", "conduir", "confabular", "confederar", "confessar", "confinar", "confirmar", "confitar", "conformar", "congelar", "congestionar", "conglomerar", "conglutinar", "congratular", "congregar", "congriar", "conhortar", "conjuminar", "conjunyir", "conjurar", "connaturalitzar", "consagrar", "conscienciar", "consentir", "conservar", "consolar", "consolidar", "constipar", "consumir", "contagiar", "contaminar", "contemperar", "contenir", "contorbar", "contornar", "contradir", "contraposar", "contreure", "controlar", "convertir", "convèncer", "corbar", "corcar", "cordar", "coronar", "corporificar", "corregir", "correspondre", "corrompre", "corsecar", "cotitzar", "covar", "crebantar", "cremar", "creure", "criar", "crispar", "cucar", "cuidar", "cuixatrencar", "curar", "curullar", "damnar", "debatre", "decantar", "decidir", "declarar", "decuplicar", "decurvar", "dedicar", "defendre", "defensar", "definir", "deformar", "defugir", "degradar", "deixar", "deixatar", "deixondar", "deixondir", "deixuplinar", "delectar", "delir", "delitar", "denudar", "departir", "depauperar", "depilar", "deportar", "depositar", "depravar", "deprimir", "depurar", "derivar", "desabillar", "desabonar", "desabrigar", "desacalorar", "desacoblar", "desaconductar", "desaconduir", "desacordar", "desacostumar", "desacreditar", "desadherir", "desaferrar", "desafinar", "desagafar", "desagermanar", "desagradar", "desagregar", "desajustar", "desalinear", "desamarrar", "desamigar", "desamistançar", "desamorrar", "desanar", "desanimar", "desaparellar", "desapariar", "desaparroquianar", "desaplicar", "desapropiar", "desar", "desarborar", "desarmar", "desarramadar", "desarrambar", "desarranjar", "desarrapar", "desarreglar", "desarregussar", "desarrelar", "desarrengar", "desarrenglar", "desarrenglerar", "desarrimar", "desarrissar", "desarromangar", "desarrufar", "desarrugar", "desarticular", "desassossegar", "desatansar", "desatapeir", "desatendar", "desavesar", "desaveïnar", "desballestar", "desbaratar", "desbarbar", "desbarrar", "desbordar", "desbrancar", "desbraonar", "descabalar", "descabdellar", "descabellar", "descalcificar", "descalçar", "descaminar", "descantellar", "descarbonatar", "descarbonitzar", "descarburar", "descargolar", "descarnar", "descarregar", "descarrerar", "descartar", "descastellanitzar", "descatalanitzar", "descelerar", "descentrar", "descenyir", "desclassar", "desclavar", "descloure", "descoagular", "descobrir", "descolgar", "descollar", "descolorar", "descolorir", "descol·locar", "descompassar", "descompensar", "descompondre", "descomprometre", "descomptar", "desconceptuar", "desconcertar", "desconfortar", "descongelar", "descongestionar", "desconhortar", "desconjuntar", "desconnectar", "descoratjar", "descordar", "descosir", "descotxar", "descrostar", "descular", "desdaurar", "desdelitar", "desdenyar", "desdibuixar", "desdinerar", "desdir", "desdoblar", "desdoblegar", "deseixir", "deselectritzar", "desembabaiar", "desembadalir", "desembadocar", "desemballestar", "desemboirar", "desembolcallar", "desembolcar", "desembolicar", "desembotir", "desembotjar", "desembotornar", "desemboçar", "desembravir", "desembrocar", "desembromallar", "desembromar", "desembullar", "desembussar", "desembutllofar", "desemmandrir", "desemmurriar", "desempallar", "desempastar", "desemperesir", "desempernar", "desempipar", "desempobrir", "desempolainar", "desempolsar", "desempolvorar", "desenamorar", "desencadenar", "desencaixar", "desencalimar", "desencalitjar", "desencallar", "desencaminar", "desencantar", "desencaparrar", "desencapotar", "desencaputxar", "desencarar", "desencarcarar", "desencarranquinar", "desencartonar", "desencastar", "desencaterinar", "desencauar", "desencavalcar", "desencavallar", "desencebar", "desencerclar", "desencercolar", "desencimbellar", "desencisar", "desenclavar", "desencoblar", "desencolar", "desencongir", "desencoratjar", "desencorbar", "desencordillar", "desencrespar", "desencrostar", "desendegar", "desendeutar", "desendogalar", "desendolcir", "desendollar", "desendropir", "desenfadar", "desenfadeir", "desenfarfegar", "desenfellonir", "desenferrissar", "desenfetgegar", "desenfilar", "desenfitar", "desenflocar", "desenfocar", "desenfrenar", "desenfuriar", "desenfurismar", "desengandulir", "desenganxar", "desenganyar", "desengatjar", "desengavanyar", "desengomar", "desengormandir", "desengorronir", "desengreixar", "desengrescar", "desengruixir", "desengrutar", "desenguantar", "desenguerxir", "desenllaminir", "desenllaçar", "desenlleganyar", "desenllepolir", "desenllorar", "desenlluernar", "desenllustrar", "desennuegar", "desennuvolar", "desenquadernar", "desenquadrar", "desenquimerar", "desenrampar", "desenredar", "desenrederar", "desenrolar", "desenrotllar", "desensabonar", "desensenyorir", "desensonyar", "desensopir", "desensuperbir", "desentaular", "desentelar", "desentendre", "desentenebrar", "desentenebrir", "desenterbolir", "desenterrar", "desentestar", "desentortolligar", "desentrampar", "desentranyar", "desentravessar", "desentrecuixar", "desentrenar", "desentristir", "desentumir", "desentusiasmar", "desenutjar", "desenvelar", "desenvernissar", "desenvescar", "desenvolupar", "desenyorar", "desequilibrar", "desertitzar", "desesmar", "desesperançar", "desesperar", "desespessir", "desestancar", "desestanyar", "desestovar", "desfaixar", "desfaiçonar", "desfanatitzar", "desfardar", "desfasar", "desfermar", "desferrar", "desficiar", "desficiejar", "desfigurar", "desfilar", "desflorir", "desfocar", "desfogar", "desfonar", "desfrarar", "desfrenar", "desfrunzir", "desfullar", "desganar", "desgastar", "desgavellar", "desglaçar", "desgraciar", "desgranar", "desgruixar", "desguarnir", "desguerxar", "desguitarrar", "deshabitar", "deshabituar", "deshidratar", "deshumanitzar", "desigualar", "desil·lusionar", "desimantar", "desincorporar", "desincrustar", "desinfatuar", "desinflamar", "desinflar", "desinhibir", "desintegrar", "desinteressar", "desintoxicar", "desionitzar", "desjunyir", "deslligar", "deslliurar", "desllodrigar", "desllogar", "deslloriguerar", "deslluir", "desllustrar", "desmagnetitzar", "desmaiar", "desmallar", "desmanegar", "desmaquillar", "desmarcar", "desmembrar", "desmillorar", "desmoralitzar", "desmorriar", "desmudar", "desmuntar", "desnacionalitzar", "desnaturar", "desniar", "desnierar", "desnivellar", "desnuar", "desnucar", "desobligar", "desobstruir", "desocupar", "desorbitar", "desordenar", "desorganitzar", "desorientar", "despacientar", "desparar", "desparellar", "despariar", "despassar", "despenjar", "despentinar", "despenyar", "despersonalitzar", "despertar", "despintar", "despistar", "despitar", "desplaçar", "desplegar", "desplomar", "despoblar", "despolir", "desposseir", "desprendre", "desprestigiar", "desprisar", "despullar", "despuntar", "desrengar", "desroentar", "dessaborir", "dessagnar", "dessecar", "dessolar", "dessoldar", "dessonillar", "dessoterrar", "dessuar", "dessucar", "destacar", "destapar", "destarotar", "destemprar", "destenyir", "desteular", "destintar", "destorçar", "destravar", "destrempar", "destrenar", "destriar", "destrossar", "destòrcer", "desunglar", "desunir", "desusar", "desvariar", "desvariejar", "desvesar", "desvestir", "desvetllar", "desviar", "desvincular", "desvitrificar", "detenir", "deteriorar", "determinar", "deturar", "devaluar", "dialitzar", "dibuixar", "diferenciar", "difondre", "diftongar", "difuminar", "dignificar", "dilatar", "diluir", "dipositar", "dirigir", "disbauxar", "disciplinar", "disculpar", "disfressar", "disgregar", "disgustar", "dislocar", "disparar", "dispersar", "disposar", "disputar", "disseminar", "dissimilar", "dissipar", "dissociar", "dissoldre", "distanciar", "distendre", "distingir", "distreure", "distribuir", "diversificar", "divertir", "dividir", "divorciar", "divulgar", "doblar", "doblegar", "doctorar", "documentar", "doldre", "domesticar", "domiciliar", "dominar", "donar", "dopar", "dreçar", "drogar", "dubtar", "dulcificar", "duplicar", "dutxar", "eclipsar", "efectuar", "efeminar", "eixamar", "eixamenar", "eixamorar", "eixamplar", "eixancar", "eixancarrar", "eixarrancar", "eixarreir", "eixorivir", "eixugar", "electritzar", "electrocutar", "elevar", "elidir", "emancipar", "embabaiar", "embadalir", "embadocar", "embajanir", "embalar", "embalbar", "embalbir", "embancar", "embarbollar", "embarcar", "embardissar", "embarracar", "embarrancar", "embarranquinar", "embarrar", "embarumar", "embarzerar", "embasardir", "embassar", "embastardir", "embellir", "embeure", "embicar", "emblanquir", "emblavir", "embofegar", "embogir", "emboirar", "embolicar", "emborbollar", "emborratxar", "emboscar", "embossar", "embotinar", "embotir", "emboçar", "embrancar", "embravir", "embretolir", "embriagar", "embrocar", "embrollar", "embromar", "embrossar", "embrunir", "embrutar", "embrutir", "embullar", "embussar", "embutllofar", "embutxacar", "emmagrir", "emmalaltir", "emmaleir", "emmallar", "emmandrir", "emmarcir", "emmaridar", "emmascarar", "emmatxucar", "emmerdar", "emmerdissar", "emmetzinar", "emmirallar", "emmotllar", "emmudir", "emmusteir", "emmustigar", "emocionar", "empadronar", "empal·lidir", "empantanar", "empantanegar", "empanxonar", "empapatxar", "emparar", "emparaular", "emparentar", "emparrar", "empastellar", "empastifar", "empastissar", "empatxar", "empedreir", "empeguntar", "empellar", "empeltar", "empenyorar", "emperesir", "emperlar", "empernar", "empetitir", "empilar", "empinar", "empipar", "empitjorar", "empitrar", "empixonar", "emplenar", "emplomallar", "empobrir", "empolainar", "empolistrar", "empolsar", "empolsegar", "empolsimar", "empolsinar", "empolvorar", "empoquir", "emporcar", "emporprar", "empotingar", "emprendre", "emprenyar", "emprovar", "enagrir", "enamorar", "enamoriscar", "enarborar", "enarbrar", "enarcar", "enardir", "enasprar", "enasprir", "encabassar", "encabir", "encaboriar", "encadarnar", "encadenar", "encaixar", "encalbir", "encalimar", "encalitjar", "encallar", "encallir", "encambrar", "encamellar", "encaminar", "encamisar", "encantar", "encaparrar", "encapellar", "encaperonar", "encaperullar", "encaperutxar", "encapirotar", "encapotar", "encapsular", "encapullar", "encaputxar", "encaramel·lar", "encarar", "encarbonar", "encarir", "encarnar", "encarranquinar", "encarregar", "encarrerar", "encarrilar", "encartonar", "encasquetar", "encastellar", "encauar", "encavallar", "encegar", "encendre", "encepar", "encertir", "encetar", "encimbellar", "enciriar", "enclaustrar", "enclotar", "encloure", "encoblar", "encofurnar", "encoixir", "encomanar", "enconar", "enconcar", "encongir", "encontrar", "encoratjar", "encorbar", "encordar", "encotillar", "encotxar", "encovar", "encrespar", "encreuar", "encrostar", "encrostimar", "encrostissar", "encruelir", "endarreriar", "endarrerir", "endegar", "endentar", "endenyar", "enderrocar", "endeutar", "endinsar", "endogalar", "endolcir", "endolentir", "endossar", "endropir", "endurir", "enemistar", "enervar", "enfadar", "enfadeir", "enfangar", "enfarfegar", "enfarinar", "enfastidir", "enfastijar", "enfellonir", "enfervorir", "enfetgegar", "enfigassar", "enfilar", "enfistular", "enfitar", "enflocar", "enflorar", "enfondir", "enfonsar", "enfonyar", "enforfoguir", "enforinyar", "enfortir", "enfosquir", "enfredar", "enfredolicar", "enfredorar", "enfredorir", "enfrontar", "enfuriar", "enfurir", "enfurismar", "engabiar", "engalavernar", "engallar", "engallardir", "engallir", "engallofir", "engalonar", "engalvanir", "enganar", "engandulir", "enganxar", "enganyar", "engatar", "engatjar", "engelosir", "enginjolar", "enginyar", "engiponar", "englotir", "engolar", "engolir", "engordir", "engorjar", "engormandir", "engorronir", "engrandir", "engreixar", "engrescar", "engrevir", "engroguir", "engronsar", "engronyar", "engrossir", "engruixar", "engruixir", "engrutar", "enguantar", "enguerxir", "enherbar", "enjoiar", "enjoiellar", "enjoncar", "enjullar", "enlairar", "enllacar", "enllaminir", "enllangorir", "enllardar", "enllardissar", "enllaçar", "enllefernar", "enllefiscar", "enllepissar", "enllepolir", "enllestir", "enlletgir", "enllistar", "enllorar", "enllordar", "enllotar", "enllustrar", "ennegrir", "ennoblir", "ennovar", "ennuegar", "ennuvolar", "enorgullar", "enquadrar", "enquibir", "enquimerar", "enrabiar", "enramar", "enrampar", "enrancir", "enrarir", "enrasar", "enravenar", "enredar", "enrederar", "enrederir", "enrellentir", "enretirar", "enrevenxinar", "enriallar", "enrigidir", "enrinxolar", "enriquir", "enrobustir", "enrocar", "enrogir", "enrolar", "enronquir", "enrosar", "enrossir", "enrotllar", "enrullar", "enrunar", "ensabonar", "ensagnar", "ensalivar", "ensangonar", "enseguir", "ensenyorir", "ensonyar", "ensopegar", "ensopir", "ensordir", "ensorrar", "ensotar", "ensulsir", "ensuperbir", "entaforar", "entatxonar", "entaular", "entebeir", "entebionar", "entelar", "entendre", "entendrir", "entenebrar", "entenebrir", "enterbolir", "enterrar", "enterrossar", "entestar", "entollar", "entonar", "entornar", "entortellar", "entortolligar", "entrampar", "entrapar", "entravessar", "entrebancar", "entregar", "entregirar", "entrellaçar", "entrelligar", "entremesclar", "entrenar", "entretenir", "entreveure", "entrevistar", "entristar", "entristir", "entumir", "enturar", "entusiasmar", "enutjar", "envanir", "envellir", "envellutar", "enverdir", "enverinar", "envermellir", "envescar", "enviar", "envigorir", "envilir", "environar", "enviscar", "enviscolar", "envitricollar", "envoltar", "enxarxar", "enxiquir", "enyorar", "equilibrar", "equivaler", "equivocar", "erigir", "eriçar", "errar", "esbadiar", "esbadinar", "esbadocar", "esbalair", "esbaldir", "esbaldregar", "esbandir", "esbardellar", "esbargir", "esbarriar", "esbarzerar", "esberlar", "esbocinar", "esboirar", "esboldregar", "esbombar", "esbombolar", "esborifar", "esborrar", "esborrifar", "esborronar", "esbotifarrar", "esbotzar", "esbrancar", "esbraonar", "esbraveir", "esbullar", "escabellar", "escabellonar", "escabotar", "escaldar", "escaldufar", "escalfar", "escalfeir", "escalivar", "escalonar", "escamarlar", "escamnar", "escampar", "escandalitzar", "escantellar", "escantonar", "escanyar", "escapar", "escarmentar", "escarrabillar", "escarxar", "escaure", "escindir", "esclafar", "esclafassar", "esclarir", "esclerosar", "escolar", "escoltar", "escometre", "escondir", "escotar", "escridar", "escridassar", "escrostar", "escrostissar", "escrostonar", "escruixir", "escuar", "escudar", "escuixar", "escular", "escurçar", "escórrer", "esdernegar", "esdevenir", "esduir", "esfacelar", "esfereir", "esfilagarsar", "esfondrar", "esfreixurar", "esfullar", "esfumar", "esgallar", "esgardissar", "esgarrar", "esgarrifar", "esgarrinxar", "esgarrinyar", "esgarronar", "esgavellar", "esglaonar", "esgotar", "esgratinyar", "esguardar", "esguerrar", "esllenegar", "esllomar", "esmadeixar", "esmalucar", "esmenar", "esmicar", "esmicolar", "esmolar", "esmorrellar", "esmorronar", "esmortir", "esmunyir", "esmussar", "espalmar", "espantar", "espanyolitzar", "espaordir", "espargir", "esparpallar", "esparpillar", "esparracar", "esparverar", "espassar", "espatllar", "espaventar", "espavilar", "especejar", "especialitzar", "espedaçar", "espellifar", "espellir", "espellissar", "espenyar", "esperançar", "esperar", "espesseir", "espessir", "espicassar", "espigar", "espinar", "espitrar", "esplaiar", "esplugar", "espolsar", "espoltrir", "esponjar", "esporuguir", "esposar", "esprémer", "espuar", "espuntar", "espunyir", "espuçar", "esqueixar", "esquerar", "esquerdar", "esquerdillar", "esquerdissar", "esquinçar", "esquitxar", "esquivar", "est", "estabilitzar", "establir", "estacionar", "estalviar", "estamordir", "estancar", "estandarditzar", "estantolar", "estanyar", "estarrufar", "estellar", "estendre", "estepitzar", "estilitzar", "estimbar", "estintolar", "estirar", "estireganyar", "estiuar", "estontolar", "estovar", "estrangeritzar", "estranyar", "estratificar", "estrenar", "estressar", "estretir", "estrinxolar", "estripar", "estroncar", "estropellar", "estrènyer", "estubar", "estufar", "esvair", "esvalotar", "esventar", "esvorar", "esvorellar", "eternitzar", "europeïtzar", "evadir", "evaporar", "exacerbar", "exaltar", "examinar", "exasperar", "excedir", "excitar", "exclamar", "excloure", "exculpar", "excusar", "exercitar", "exfoliar", "exhalar", "exhaurir", "exhibir", "exiliar", "eximir", "exornar", "expandir", "expatriar", "explicar", "exposar", "expressar", "extasiar", "extenuar", "exterioritzar", "extingir", "extraviar", "extremar", "faixar", "familiaritzar", "fanatitzar", "fastiguejar", "fatigar", "federar", "felicitar", "feminitzar", "ferir", "fiar", "ficar", "figurar", "filtrar", "fingir", "firar", "fixar", "flagel·lar", "florir", "folrar", "foraviar", "forcar", "forjar", "formalitzar", "formar", "fortificar", "fossilitzar", "fotre", "fraccionar", "fracturar", "fragmentar", "francesitzar", "franquejar", "fregar", "fregir", "frisar", "fumar", "fundar", "gabar", "gastar", "gaudir", "gelar", "generalitzar", "gestar", "ginyar", "girar", "gitar", "glaçar", "gloriejar", "governar", "graduar", "gramaticalitzar", "gratar", "gratular", "gravar", "grecitzar", "grillar", "gronxar", "gronxejar", "gronxolar", "guanyar", "guardar", "guarir", "guarnir", "guerxar", "guiar", "guillar", "habituar", "hebraïtzar", "hel·lenitzar", "hemodialitzar", "herniar", "hibridar", "hidratar", "hissar", "honorar", "honrar", "horripilar", "horroritzar", "hostatjar", "humanitzar", "humiliar", "humitejar", "identificar", "igualar", "il·luminar", "il·lusionar", "il·lustrar", "imaginar", "immergir", "immolar", "impacientar", "implicar", "imposar", "impressionar", "imprimir", "impurificar", "incarcerar", "incendiar", "inclinar", "incomodar", "incorporar", "incrementar", "incrustar", "independitzar", "indignar", "indisposar", "inebriar", "infatuar", "infectar", "infestar", "infiltrar", "inflamar", "inflar", "informar", "ingerir", "inhabilitar", "inhibir", "iniciar", "inquietar", "inscriure", "insinuar", "inspirar", "instal·lar", "instruir", "insubordinar", "insultar", "insurreccionar", "integrar", "intensificar", "interessar", "interferir", "internar", "interposar", "interrompre", "intranquil·litzar", "introduir", "inundar", "invaginar", "inventar", "ionitzar", "irritar", "islamitzar", "isolar", "jubilar", "jugar", "junyir", "justificar", "lamentar", "laxar", "lignificar", "limitar", "llampar", "llançar", "llassar", "llatinitzar", "llepar", "lletrejar", "llevar", "llicenciar", "lligar", "lliurar", "llogar", "lluir", "localitzar", "lucrar", "macerar", "malacostumar", "malavesar", "maliciar", "mallar", "malpensar", "mamar", "mancomunar", "manegar", "manejar", "manifestar", "mantenir", "maquillar", "marcir", "marejar", "marginar", "maridar", "marinejar", "mascarar", "massificar", "masturbar", "matar", "materialitzar", "matricular", "matxucar", "mecanitzar", "mediumitzar", "menar", "menjar", "mentalitzar", "menysprear", "meravellar", "merèixer", "mesclar", "metal·litzar", "metamorfosar", "meteoritzar", "migrar", "millorar", "mineralitzar", "mirar", "mobilitzar", "mocar", "moderar", "modernitzar", "modificar", "molestar", "morfondre", "morir", "morrejar", "mortificar", "mossegar", "mostrar", "moure", "mudar", "mullar", "multiplicar", "musteir", "mustiar", "mustigar", "mutilar", "nacionalitzar", "naturalitzar", "necrosar", "negar", "neguitejar", "netejar", "nonuplicar", "normalitzar", "nuar", "oblidar", "obligar", "obnubilar", "obscurir", "occidentalitzar", "occitanitzar", "ocultar", "ocupar", "ofegar", "oferir", "ofuscar", "ombrar", "omplir", "operar", "oposar", "ordenar", "orejar", "organitzar", "orgullar", "orientalitzar", "orientar", "originar", "orinar", "oscar", "oxigenar", "pacificar", "paganitzar", "pagar", "pansir", "parapetar", "parar", "parlar", "particularitzar", "partir", "passar", "passejar", "pedregar", "pedrejar", "pellar", "penjar", "pensar", "pentinar", "percaçar", "perfeccionar", "perfilar", "permetre", "persignar", "persuadir", "pessigar", "petar", "picar", "pintar", "pirar", "plantar", "plantejar", "plantificar", "podrir", "polaritzar", "polir", "pol·linitzar", "pondre", "popularitzar", "portar", "posar", "possessionar", "posticar", "postrar", "prear", "precipitar", "prendre", "preocupar", "preparar", "presentar", "prestar", "prevaler", "privar", "proclamar", "prodigar", "produir", "professionalitzar", "proletaritzar", "prometre", "pronunciar", "propagar", "propalar", "proposar", "prostituir", "prostrar", "prou", "proveir", "pujar", "punxar", "purificar", "putejar", "quadrar", "qualificar", "quallar", "quedar", "quitar", "rabejar", "radicalitzar", "rarificar", "ratificar", "reafirmar", "realitzar", "rebaixar", "rebentar", "reblir", "rebolcar", "rebullir", "recargolar", "reciclar", "reciprocar", "recloure", "recobrar", "recollir", "recolzar", "reconcentrar", "reconciliar", "reconstituir", "recordar", "recrear", "recriminar", "rectificar", "reencarnar", "reenganxar", "refer", "referir", "refermar", "reflectir", "refocil·lar", "reforçar", "refractar", "refredar", "refrenar", "refrescar", "refringir", "refugiar", "refusar", "regalar", "regelar", "regirar", "rehabilitar", "rehidratar", "reincorporar", "reinflar", "reinstal·lar", "reintegrar", "rejovenir", "relacionar", "relaxar", "rellentir", "relligar", "rellogar", "remenar", "remetre", "remirar", "remollir", "remudar", "remuntar", "rendir", "renovar", "renovellar", "rentar", "repatriar", "repenjar", "repensar", "repetir", "repintar", "replegar", "replujar", "repodrir", "reportar", "reposar", "representar", "reprimir", "reproduir", "repuntar", "rescabalar", "reservar", "resguardar", "resignar", "resinificar", "resistir", "resoldre", "responsabilitzar", "resquitar", "ressecar", "ressobinar", "restablir", "retardar", "retenir", "retintar", "retirar", "retractar", "retre", "retreure", "retrobar", "reunir", "reveixinar", "revelar", "revellir", "revenxinar", "revestir", "revifar", "reviscolar", "revoltar", "rifar", "rinxolar", "riure", "romanitzar", "rombollar", "rompre", "rostir", "rovellar", "ruboritzar", "russificar", "sacrificar", "salmorrar", "salsir", "salvar", "santificar", "satel·litzar", "secularitzar", "sedimentar", "segar", "segregar", "seguir", "sentir", "senyar", "separar", "significar", "silicificar", "sincerar", "sindicar", "singularitzar", "sinitzar", "situar", "sobrealimentar", "sobreexcitar", "sobreposar", "sobresaltar", "sobresanar", "sobresaturar", "sobtar", "socarrar", "solapar", "solar", "solaçar", "soldar", "solidaritzar", "solidificar", "sollar", "sollevar", "solvatar", "somorgollar", "soplujar", "sostreure", "sotaplujar", "sotmetre", "suberificar", "suberitzar", "subestimar", "submergir", "subscriure", "suggestionar", "sulfatar", "sulfurar", "sumar", "sumir", "superar", "tallar", "tancar", "tant", "tapar", "temperar", "tenyir", "terraplenar", "tirar", "titular", "tocar", "tombar", "torbar", "torejar", "tornar", "torrar", "trabucar", "tractar", "tranquil·litzar", "transfigurar", "transformar", "translimitar", "transmetre", "transmutar", "transparentar", "transvasar", "trasmudar", "trasplantar", "trastocar", "trastornar", "triar", "tribular", "trifurcar", "trobar", "tòrcer", "ulcerar", "ullar", "unir", "universalitzar", "untar", "vaporitzar", "velar", "venjar", "ventar", "vessar", "vestir", "viciar", "vinclar", "vincular", "vitrificar", "volar", "volatilitzar", "xalar", "xutar");

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/AbstractPatternRuleTest.java
Patch:
@@ -94,7 +94,8 @@ protected List<String> getGrammarFileNames(Language lang) {
       if (shortNameWithVariant.contains("-x-")) {
         fileName = lang.getShortCode() + "/" + nameOnly;
       } else if (shortNameWithVariant.contains("-") && !shortNameWithVariant.equals("xx-XX")
-              && !shortNameWithVariant.endsWith("-ANY") && Languages.get().size() > 1) {
+          && !shortNameWithVariant.endsWith("-ANY") && Languages.get().size() > 1
+          && !shortNameWithVariant.equals("ca-ES")) { // TODO: change Catalan language definitions?
         fileName = lang.getShortCode() + "/" + shortNameWithVariant + "/" + nameOnly;
       } else {
         fileName = lang.getShortCode() + "/" + nameOnly;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -64,7 +64,7 @@ public class ReflexiveVerbsRule extends Rule {
   private static final List<String> verbsSovintAmbComplement = Arrays.asList ("deixar","fer","veure","costar");
   private static final List<String> verbsDeixarFer= Arrays.asList ("deixar", "fer");
   private static final List<String> verbsPortarDur = Arrays.asList ("portar", "dur");
-  private static final List<String> lemesEnPerifrasis = Arrays.asList ("tornar", "haver", "anar", "deure", "poder", "voler");//, "a", "de", "en", "pas");
+  private static final List<String> lemesEnPerifrasis = Arrays.asList ("soler", "tornar", "haver", "anar", "deure", "poder", "voler");//, "a", "de", "en", "pas");
   
   
   private static final List<String> verbsPotencialmentPronominals = Arrays.asList("abaixar", "abandonar", "abarrocar", "abellir", "abismar", "abissar", "ablamar", "ablanir", "abocar", "aboldronar", "abonançar", "abonar", "abonir", "abonyegar", "abordar", "abraonar", "abraçar", "abrivar", "abroquerar", "abrusar", "absentar", "abstraure", "abstreure", "aburgesar", "acabar", "acalar", "acalorar", "acantonar", "acarrerar", "acastellanar", "acatalanar", "accelerar", "acetificar", "acidificar", "aclarir", "aclimatar", "aclivellar", "aclucar", "acoblar", "acollir", "acollonir", "acomiadar", "acomodar", "acomplexar", "acomplir", "aconductar", "aconsellar", "acontentar", "acopar", "acoquinar", "acordar", "acorruar", "acostar", "acostumar", "acotar", "acotxar", "acovardir", "acreditar", "acréixer", "acubar", "acubillar", "acudir", "acugular", "acuitar", "acular", "acumular", "acusar", "adaptar", "adargar", "adherir", "adjudicar", "adollar", "adolorir", "adondar", "adormir", "adossar", "adotzenar", "adreçar", "adscriure", "adunar", "afalconar", "afanyar", "afartar", "afeblir", "afectar", "afermar", "aferrar", "afigurar", "afilar", "afilerar", "afiliar", "afillar", "afinar", "aflaquir", "afligir", "aflonjar", "afluixar", "afogar", "afollar", "afrancesar", "afrevolir", "afuar", "afusar", "agabellar", "agafar", "agarbar", "agarbonar", "agitar", "aglomerar", "aglutinar", "agombolar", "agostejar", "agradar", "agregar", "agremiar", "agreujar", "agrir", "agrisar", "agrumar", "aguantar", "aguditzar", "aigualir", "airejar", "aixecar", "aixoplugar", "ajaure", "ajaçar", "ajeure", "ajornalar", "ajudar", "ajuntar", "ajupir", "ajustar", "alabar", "alarmar", "alcalinitzar", "alcoholitzar", "alegrar", "alentir", "aliar", "alimentar", "alinear", "allarar", "allargar", "allargassar", "allerar", "alleugerir", "alleujar", "alliberar", "alligar", "allistar", "allitar", "allotjar", "allunyar", "alterar", "alzinar", "alçar", "amagar", "amagrir", "amanerar", "amanir", "amansar", "amansir", "amassar", "ambientar", "americanitzar", "amistançar", "amistar", "amollar", "amorar", "amorosir", "amorrar", "amorriar", "amotinar", "amoïnar", "amuntegar", "anastomitzar", "angoixar", "anguniejar", "animar", "anomenar", "anticipar", "apagar", "apaivagar", "apanyar", "aparellar", "apariar", "apartar", "aparèixer", "apassionar", "apercebre", "apilotar", "apinyar", "apitrar", "aplanar", "aplaçar", "aplicar", "apocar", "apoderar", "aposentar", "apostar", "apostemar", "apregonar", "aprendre", "apressar", "aprimar", "aprofitar", "apropar", "apropiar", "aprovisionar", "aproximar", "apujar", "apuntalar", "aquedar", "aquietar", "aquilotar", "arborar", "arbrar", "arcar", "argollar", "aristocratitzar", "armar", "arquejar", "arraconar", "arramadar", "arrambar", "arramellar", "arranjar", "arrapar", "arraulir", "arrear", "arrecerar", "arredossar", "arreglar", "arrelar", "arremangar", "arremolinar", "arremorar", "arrenglerar", "arreplegar", "arrestar", "arribar", "arrimar", "arriscar", "arrissar", "arrodonir", "arromangar", "arrombollar", "arronsar", "arrossegar", "arrufar", "arrugar", "arruïnar", "articular", "asfixiar", "assabentar", "assaonar", "assecar", "assegurar", "assentar", "assenyalar", "asserenar", "assessorar", "asseure", "assimilar", "associar", "assolar", "assolellar", "assossegar", "assotar", "astorar", "atabalar", "ataconar", "atalaiar", "atandar", "atansar", "atapeir", "atardar", "atavellar", "aterrir", "aterrossar", "atipar", "atiplar", "atonir", "atorrollar", "atracar", "atribolar", "atribuir", "atrinxerar", "atrofiar", "atropellar", "atrotinar", "aturar", "avalotar", "avançar", "avarar", "avariar", "avenir", "aventurar", "avergonyir", "avesar", "aviar", "aviciar", "avidar", "avivar", "avorrir", "aïllar", "aïrar", "badar", "balancejar", "balandrejar", "baldar", "banyar", "barallar", "barrejar", "basar", "basquejar", "bastar", "batre", "befar", "bellugar", "beneficiar", "bleir", "blocar", "bolcar", "bombar", "bonificar", "botir", "brindar", "brossar", "bufar", "buidar", "burocratitzar", "cabrejar", "cabussar", "cagar", "calar", "calmar", "calçar", "campar", "cansar", "cap", "capalçar", "capbussar", "capficar", "capgirar", "captar", "captrencar", "caracteritzar", "caragirar", "carbonar", "carbonatar", "carbonitzar", "cardar", "cargolar", "carregar", "cartejar", "casar", "cascar", "cenyir", "cerciorar", "cicatritzar", "circumscriure", "clamar", "classificar", "clavar", "clivellar", "cloure", "coagular", "cobrir", "colar", "colgar", "colltorçar", "colltòrcer", "colrar", "coltellejar", "col·lapsar", "col·legiar", "col·locar", "comanar", "combinar", "compadir", "compaginar", "compatir", "compensar", "complementar", "complexificar", "complicar", "complir", "complànyer", "compondre", "comportar", "comprendre", "comprimir", "comprometre", "compungir", "comunicar", "concentrar", "concertar", "conciliar", "concordar", "concretar", "condemnar", "condensar", "conduir", "confabular", "confederar", "confessar", "confinar", "confirmar", "confitar", "conformar", "congelar", "congestionar", "conglomerar", "conglutinar", "congratular", "congregar", "congriar", "conhortar", "conjuminar", "conjunyir", "conjurar", "connaturalitzar", "consagrar", "conscienciar", "consentir", "conservar", "consolar", "consolidar", "constipar", "consumir", "contagiar", "contaminar", "contemperar", "contenir", "contorbar", "contornar", "contradir", "contraposar", "contreure", "controlar", "convertir", "convèncer", "corbar", "corcar", "cordar", "coronar", "corporificar", "corregir", "correspondre", "corrompre", "corsecar", "cotitzar", "covar", "crebantar", "cremar", "creure", "criar", "crispar", "cucar", "cuidar", "cuixatrencar", "curar", "curullar", "damnar", "debatre", "decantar", "decidir", "declarar", "decuplicar", "decurvar", "dedicar", "defendre", "defensar", "definir", "deformar", "defugir", "degradar", "deixar", "deixatar", "deixondar", "deixondir", "deixuplinar", "delectar", "delir", "delitar", "denudar", "departir", "depauperar", "depilar", "deportar", "depositar", "depravar", "deprimir", "depurar", "derivar", "desabillar", "desabonar", "desabrigar", "desacalorar", "desacoblar", "desaconductar", "desaconduir", "desacordar", "desacostumar", "desacreditar", "desadherir", "desaferrar", "desafinar", "desagafar", "desagermanar", "desagradar", "desagregar", "desajustar", "desalinear", "desamarrar", "desamigar", "desamistançar", "desamorrar", "desanar", "desanimar", "desaparellar", "desapariar", "desaparroquianar", "desaplicar", "desapropiar", "desar", "desarborar", "desarmar", "desarramadar", "desarrambar", "desarranjar", "desarrapar", "desarreglar", "desarregussar", "desarrelar", "desarrengar", "desarrenglar", "desarrenglerar", "desarrimar", "desarrissar", "desarromangar", "desarrufar", "desarrugar", "desarticular", "desassossegar", "desatansar", "desatapeir", "desatendar", "desavesar", "desaveïnar", "desballestar", "desbaratar", "desbarbar", "desbarrar", "desbordar", "desbrancar", "desbraonar", "descabalar", "descabdellar", "descabellar", "descalcificar", "descalçar", "descaminar", "descantellar", "descarbonatar", "descarbonitzar", "descarburar", "descargolar", "descarnar", "descarregar", "descarrerar", "descartar", "descastellanitzar", "descatalanitzar", "descelerar", "descentrar", "descenyir", "desclassar", "desclavar", "descloure", "descoagular", "descobrir", "descolgar", "descollar", "descolorar", "descolorir", "descol·locar", "descompassar", "descompensar", "descompondre", "descomprometre", "descomptar", "desconceptuar", "desconcertar", "desconfortar", "descongelar", "descongestionar", "desconhortar", "desconjuntar", "desconnectar", "descoratjar", "descordar", "descosir", "descotxar", "descrostar", "descular", "desdaurar", "desdelitar", "desdenyar", "desdibuixar", "desdinerar", "desdir", "desdoblar", "desdoblegar", "deseixir", "deselectritzar", "desembabaiar", "desembadalir", "desembadocar", "desemballestar", "desemboirar", "desembolcallar", "desembolcar", "desembolicar", "desembotir", "desembotjar", "desembotornar", "desemboçar", "desembravir", "desembrocar", "desembromallar", "desembromar", "desembullar", "desembussar", "desembutllofar", "desemmandrir", "desemmurriar", "desempallar", "desempastar", "desemperesir", "desempernar", "desempipar", "desempobrir", "desempolainar", "desempolsar", "desempolvorar", "desenamorar", "desencadenar", "desencaixar", "desencalimar", "desencalitjar", "desencallar", "desencaminar", "desencantar", "desencaparrar", "desencapotar", "desencaputxar", "desencarar", "desencarcarar", "desencarranquinar", "desencartonar", "desencastar", "desencaterinar", "desencauar", "desencavalcar", "desencavallar", "desencebar", "desencerclar", "desencercolar", "desencimbellar", "desencisar", "desenclavar", "desencoblar", "desencolar", "desencongir", "desencoratjar", "desencorbar", "desencordillar", "desencrespar", "desencrostar", "desendegar", "desendeutar", "desendogalar", "desendolcir", "desendollar", "desendropir", "desenfadar", "desenfadeir", "desenfarfegar", "desenfellonir", "desenferrissar", "desenfetgegar", "desenfilar", "desenfitar", "desenflocar", "desenfocar", "desenfrenar", "desenfuriar", "desenfurismar", "desengandulir", "desenganxar", "desenganyar", "desengatjar", "desengavanyar", "desengomar", "desengormandir", "desengorronir", "desengreixar", "desengrescar", "desengruixir", "desengrutar", "desenguantar", "desenguerxir", "desenllaminir", "desenllaçar", "desenlleganyar", "desenllepolir", "desenllorar", "desenlluernar", "desenllustrar", "desennuegar", "desennuvolar", "desenquadernar", "desenquadrar", "desenquimerar", "desenrampar", "desenredar", "desenrederar", "desenrolar", "desenrotllar", "desensabonar", "desensenyorir", "desensonyar", "desensopir", "desensuperbir", "desentaular", "desentelar", "desentendre", "desentenebrar", "desentenebrir", "desenterbolir", "desenterrar", "desentestar", "desentortolligar", "desentrampar", "desentranyar", "desentravessar", "desentrecuixar", "desentrenar", "desentristir", "desentumir", "desentusiasmar", "desenutjar", "desenvelar", "desenvernissar", "desenvescar", "desenvolupar", "desenyorar", "desequilibrar", "desertitzar", "desesmar", "desesperançar", "desesperar", "desespessir", "desestancar", "desestanyar", "desestovar", "desfaixar", "desfaiçonar", "desfanatitzar", "desfardar", "desfasar", "desfermar", "desferrar", "desficiar", "desficiejar", "desfigurar", "desfilar", "desflorir", "desfocar", "desfogar", "desfonar", "desfrarar", "desfrenar", "desfrunzir", "desfullar", "desganar", "desgastar", "desgavellar", "desglaçar", "desgraciar", "desgranar", "desgruixar", "desguarnir", "desguerxar", "desguitarrar", "deshabitar", "deshabituar", "deshidratar", "deshumanitzar", "desigualar", "desil·lusionar", "desimantar", "desincorporar", "desincrustar", "desinfatuar", "desinflamar", "desinflar", "desinhibir", "desintegrar", "desinteressar", "desintoxicar", "desionitzar", "desjunyir", "deslligar", "deslliurar", "desllodrigar", "desllogar", "deslloriguerar", "deslluir", "desllustrar", "desmagnetitzar", "desmaiar", "desmallar", "desmanegar", "desmaquillar", "desmarcar", "desmembrar", "desmillorar", "desmoralitzar", "desmorriar", "desmudar", "desmuntar", "desnacionalitzar", "desnaturar", "desniar", "desnierar", "desnivellar", "desnuar", "desnucar", "desobligar", "desobstruir", "desocupar", "desorbitar", "desordenar", "desorganitzar", "desorientar", "despacientar", "desparar", "desparellar", "despariar", "despassar", "despenjar", "despentinar", "despenyar", "despersonalitzar", "despertar", "despintar", "despistar", "despitar", "desplaçar", "desplegar", "desplomar", "despoblar", "despolir", "desposseir", "desprendre", "desprestigiar", "desprisar", "despullar", "despuntar", "desrengar", "desroentar", "dessaborir", "dessagnar", "dessecar", "dessolar", "dessoldar", "dessonillar", "dessoterrar", "dessuar", "dessucar", "destacar", "destapar", "destarotar", "destemprar", "destenyir", "desteular", "destintar", "destorçar", "destravar", "destrempar", "destrenar", "destriar", "destrossar", "destòrcer", "desunglar", "desunir", "desusar", "desvariar", "desvariejar", "desvesar", "desvestir", "desvetllar", "desviar", "desvincular", "desvitrificar", "detenir", "deteriorar", "determinar", "deturar", "devaluar", "dialitzar", "dibuixar", "diferenciar", "difondre", "diftongar", "difuminar", "dignificar", "dilatar", "diluir", "dipositar", "dirigir", "disbauxar", "disciplinar", "disculpar", "disfressar", "disgregar", "disgustar", "dislocar", "disparar", "dispersar", "disposar", "disputar", "disseminar", "dissimilar", "dissipar", "dissociar", "dissoldre", "distanciar", "distendre", "distingir", "distreure", "distribuir", "diversificar", "divertir", "dividir", "divorciar", "divulgar", "doblar", "doblegar", "doctorar", "documentar", "doldre", "domesticar", "domiciliar", "dominar", "donar", "dopar", "dreçar", "drogar", "dubtar", "dulcificar", "duplicar", "dutxar", "eclipsar", "efectuar", "efeminar", "eixamar", "eixamenar", "eixamorar", "eixamplar", "eixancar", "eixancarrar", "eixarrancar", "eixarreir", "eixorivir", "eixugar", "electritzar", "electrocutar", "elevar", "elidir", "emancipar", "embabaiar", "embadalir", "embadocar", "embajanir", "embalar", "embalbar", "embalbir", "embancar", "embarbollar", "embarcar", "embardissar", "embarracar", "embarrancar", "embarranquinar", "embarrar", "embarumar", "embarzerar", "embasardir", "embassar", "embastardir", "embellir", "embeure", "embicar", "emblanquir", "emblavir", "embofegar", "embogir", "emboirar", "embolicar", "emborbollar", "emborratxar", "emboscar", "embossar", "embotinar", "embotir", "emboçar", "embrancar", "embravir", "embretolir", "embriagar", "embrocar", "embrollar", "embromar", "embrossar", "embrunir", "embrutar", "embrutir", "embullar", "embussar", "embutllofar", "embutxacar", "emmagrir", "emmalaltir", "emmaleir", "emmallar", "emmandrir", "emmarcir", "emmaridar", "emmascarar", "emmatxucar", "emmerdar", "emmerdissar", "emmetzinar", "emmirallar", "emmotllar", "emmudir", "emmusteir", "emmustigar", "emocionar", "empadronar", "empal·lidir", "empantanar", "empantanegar", "empanxonar", "empapatxar", "emparar", "emparaular", "emparentar", "emparrar", "empastellar", "empastifar", "empastissar", "empatxar", "empedreir", "empeguntar", "empellar", "empeltar", "empenyorar", "emperesir", "emperlar", "empernar", "empetitir", "empilar", "empinar", "empipar", "empitjorar", "empitrar", "empixonar", "emplenar", "emplomallar", "empobrir", "empolainar", "empolistrar", "empolsar", "empolsegar", "empolsimar", "empolsinar", "empolvorar", "empoquir", "emporcar", "emporprar", "empotingar", "emprendre", "emprenyar", "emprovar", "enagrir", "enamorar", "enamoriscar", "enarborar", "enarbrar", "enarcar", "enardir", "enasprar", "enasprir", "encabassar", "encabir", "encaboriar", "encadarnar", "encadenar", "encaixar", "encalbir", "encalimar", "encalitjar", "encallar", "encallir", "encambrar", "encamellar", "encaminar", "encamisar", "encantar", "encaparrar", "encapellar", "encaperonar", "encaperullar", "encaperutxar", "encapirotar", "encapotar", "encapsular", "encapullar", "encaputxar", "encaramel·lar", "encarar", "encarbonar", "encarir", "encarnar", "encarranquinar", "encarregar", "encarrerar", "encarrilar", "encartonar", "encasquetar", "encastellar", "encauar", "encavallar", "encegar", "encendre", "encepar", "encertir", "encetar", "encimbellar", "enciriar", "enclaustrar", "enclotar", "encloure", "encoblar", "encofurnar", "encoixir", "encomanar", "enconar", "enconcar", "encongir", "encontrar", "encoratjar", "encorbar", "encordar", "encotillar", "encotxar", "encovar", "encrespar", "encreuar", "encrostar", "encrostimar", "encrostissar", "encruelir", "endarreriar", "endarrerir", "endegar", "endentar", "endenyar", "enderrocar", "endeutar", "endinsar", "endogalar", "endolcir", "endolentir", "endossar", "endropir", "endurir", "enemistar", "enervar", "enfadar", "enfadeir", "enfangar", "enfarfegar", "enfarinar", "enfastidir", "enfastijar", "enfellonir", "enfervorir", "enfetgegar", "enfigassar", "enfilar", "enfistular", "enfitar", "enflocar", "enflorar", "enfondir", "enfonsar", "enfonyar", "enforfoguir", "enforinyar", "enfortir", "enfosquir", "enfredar", "enfredolicar", "enfredorar", "enfredorir", "enfrontar", "enfuriar", "enfurir", "enfurismar", "engabiar", "engalavernar", "engallar", "engallardir", "engallir", "engallofir", "engalonar", "engalvanir", "enganar", "engandulir", "enganxar", "enganyar", "engatar", "engatjar", "engelosir", "enginjolar", "enginyar", "engiponar", "englotir", "engolar", "engolir", "engordir", "engorjar", "engormandir", "engorronir", "engrandir", "engreixar", "engrescar", "engrevir", "engroguir", "engronsar", "engronyar", "engrossir", "engruixar", "engruixir", "engrutar", "enguantar", "enguerxir", "enherbar", "enjoiar", "enjoiellar", "enjoncar", "enjullar", "enlairar", "enllacar", "enllaminir", "enllangorir", "enllardar", "enllardissar", "enllaçar", "enllefernar", "enllefiscar", "enllepissar", "enllepolir", "enllestir", "enlletgir", "enllistar", "enllorar", "enllordar", "enllotar", "enllustrar", "ennegrir", "ennoblir", "ennovar", "ennuegar", "ennuvolar", "enorgullar", "enquadrar", "enquibir", "enquimerar", "enrabiar", "enramar", "enrampar", "enrancir", "enrarir", "enrasar", "enravenar", "enredar", "enrederar", "enrederir", "enrellentir", "enretirar", "enrevenxinar", "enriallar", "enrigidir", "enrinxolar", "enriquir", "enrobustir", "enrocar", "enrogir", "enrolar", "enronquir", "enrosar", "enrossir", "enrotllar", "enrullar", "enrunar", "ensabonar", "ensagnar", "ensalivar", "ensangonar", "enseguir", "ensenyorir", "ensonyar", "ensopegar", "ensopir", "ensordir", "ensorrar", "ensotar", "ensulsir", "ensuperbir", "entaforar", "entatxonar", "entaular", "entebeir", "entebionar", "entelar", "entendre", "entendrir", "entenebrar", "entenebrir", "enterbolir", "enterrar", "enterrossar", "entestar", "entollar", "entonar", "entornar", "entortellar", "entortolligar", "entrampar", "entrapar", "entravessar", "entrebancar", "entregar", "entregirar", "entrellaçar", "entrelligar", "entremesclar", "entrenar", "entretenir", "entreveure", "entrevistar", "entristar", "entristir", "entumir", "enturar", "entusiasmar", "enutjar", "envanir", "envellir", "envellutar", "enverdir", "enverinar", "envermellir", "envescar", "enviar", "envigorir", "envilir", "environar", "enviscar", "enviscolar", "envitricollar", "envoltar", "enxarxar", "enxiquir", "enyorar", "equilibrar", "equivaler", "equivocar", "erigir", "eriçar", "errar", "esbadiar", "esbadinar", "esbadocar", "esbalair", "esbaldir", "esbaldregar", "esbandir", "esbardellar", "esbargir", "esbarriar", "esbarzerar", "esberlar", "esbocinar", "esboirar", "esboldregar", "esbombar", "esbombolar", "esborifar", "esborrar", "esborrifar", "esborronar", "esbotifarrar", "esbotzar", "esbrancar", "esbraonar", "esbraveir", "esbullar", "escabellar", "escabellonar", "escabotar", "escaldar", "escaldufar", "escalfar", "escalfeir", "escalivar", "escalonar", "escamarlar", "escamnar", "escampar", "escandalitzar", "escantellar", "escantonar", "escanyar", "escapar", "escarmentar", "escarrabillar", "escarxar", "escaure", "escindir", "esclafar", "esclafassar", "esclarir", "esclerosar", "escolar", "escoltar", "escometre", "escondir", "escotar", "escridar", "escridassar", "escrostar", "escrostissar", "escrostonar", "escruixir", "escuar", "escudar", "escuixar", "escular", "escurçar", "escórrer", "esdernegar", "esdevenir", "esduir", "esfacelar", "esfereir", "esfilagarsar", "esfondrar", "esfreixurar", "esfullar", "esfumar", "esgallar", "esgardissar", "esgarrar", "esgarrifar", "esgarrinxar", "esgarrinyar", "esgarronar", "esgavellar", "esglaonar", "esgotar", "esgratinyar", "esguardar", "esguerrar", "esllenegar", "esllomar", "esmadeixar", "esmalucar", "esmenar", "esmicar", "esmicolar", "esmolar", "esmorrellar", "esmorronar", "esmortir", "esmunyir", "esmussar", "espalmar", "espantar", "espanyolitzar", "espaordir", "espargir", "esparpallar", "esparpillar", "esparracar", "esparverar", "espassar", "espatllar", "espaventar", "espavilar", "especejar", "especialitzar", "espedaçar", "espellifar", "espellir", "espellissar", "espenyar", "esperançar", "esperar", "espesseir", "espessir", "espicassar", "espigar", "espinar", "espitrar", "esplaiar", "esplugar", "espolsar", "espoltrir", "esponjar", "esporuguir", "esposar", "esprémer", "espuar", "espuntar", "espunyir", "espuçar", "esqueixar", "esquerar", "esquerdar", "esquerdillar", "esquerdissar", "esquinçar", "esquitxar", "esquivar", "est", "estabilitzar", "establir", "estacionar", "estalviar", "estamordir", "estancar", "estandarditzar", "estantolar", "estanyar", "estarrufar", "estellar", "estendre", "estepitzar", "estilitzar", "estimbar", "estintolar", "estirar", "estireganyar", "estiuar", "estontolar", "estovar", "estrangeritzar", "estranyar", "estratificar", "estrenar", "estressar", "estretir", "estrinxolar", "estripar", "estroncar", "estropellar", "estrènyer", "estubar", "estufar", "esvair", "esvalotar", "esventar", "esvorar", "esvorellar", "eternitzar", "europeïtzar", "evadir", "evaporar", "exacerbar", "exaltar", "examinar", "exasperar", "excedir", "excitar", "exclamar", "excloure", "exculpar", "excusar", "exercitar", "exfoliar", "exhalar", "exhaurir", "exhibir", "exiliar", "eximir", "exornar", "expandir", "expatriar", "explicar", "exposar", "expressar", "extasiar", "extenuar", "exterioritzar", "extingir", "extraviar", "extremar", "faixar", "familiaritzar", "fanatitzar", "fastiguejar", "fatigar", "federar", "felicitar", "feminitzar", "ferir", "fiar", "ficar", "figurar", "filtrar", "fingir", "firar", "fixar", "flagel·lar", "florir", "folrar", "foraviar", "forcar", "forjar", "formalitzar", "formar", "fortificar", "fossilitzar", "fotre", "fraccionar", "fracturar", "fragmentar", "francesitzar", "franquejar", "fregar", "fregir", "frisar", "fumar", "fundar", "gabar", "gastar", "gaudir", "gelar", "generalitzar", "gestar", "ginyar", "girar", "gitar", "glaçar", "gloriejar", "governar", "graduar", "gramaticalitzar", "gratar", "gratular", "gravar", "grecitzar", "grillar", "gronxar", "gronxejar", "gronxolar", "guanyar", "guardar", "guarir", "guarnir", "guerxar", "guiar", "guillar", "habituar", "hebraïtzar", "hel·lenitzar", "hemodialitzar", "herniar", "hibridar", "hidratar", "hissar", "honorar", "honrar", "horripilar", "horroritzar", "hostatjar", "humanitzar", "humiliar", "humitejar", "identificar", "igualar", "il·luminar", "il·lusionar", "il·lustrar", "imaginar", "immergir", "immolar", "impacientar", "implicar", "imposar", "impressionar", "imprimir", "impurificar", "incarcerar", "incendiar", "inclinar", "incomodar", "incorporar", "incrementar", "incrustar", "independitzar", "indignar", "indisposar", "inebriar", "infatuar", "infectar", "infestar", "infiltrar", "inflamar", "inflar", "informar", "ingerir", "inhabilitar", "inhibir", "iniciar", "inquietar", "inscriure", "insinuar", "inspirar", "instal·lar", "instruir", "insubordinar", "insultar", "insurreccionar", "integrar", "intensificar", "interessar", "interferir", "internar", "interposar", "interrompre", "intranquil·litzar", "introduir", "inundar", "invaginar", "inventar", "ionitzar", "irritar", "islamitzar", "isolar", "jubilar", "jugar", "junyir", "justificar", "lamentar", "laxar", "lignificar", "limitar", "llampar", "llançar", "llassar", "llatinitzar", "llepar", "lletrejar", "llevar", "llicenciar", "lligar", "lliurar", "llogar", "lluir", "localitzar", "lucrar", "macerar", "malacostumar", "malavesar", "maliciar", "mallar", "malpensar", "mamar", "mancomunar", "manegar", "manejar", "manifestar", "mantenir", "maquillar", "marcir", "marejar", "marginar", "maridar", "marinejar", "mascarar", "massificar", "masturbar", "matar", "materialitzar", "matricular", "matxucar", "mecanitzar", "mediumitzar", "menar", "menjar", "mentalitzar", "menysprear", "meravellar", "merèixer", "mesclar", "metal·litzar", "metamorfosar", "meteoritzar", "migrar", "millorar", "mineralitzar", "mirar", "mobilitzar", "mocar", "moderar", "modernitzar", "modificar", "molestar", "morfondre", "morir", "morrejar", "mortificar", "mossegar", "mostrar", "moure", "mudar", "mullar", "multiplicar", "musteir", "mustiar", "mustigar", "mutilar", "nacionalitzar", "naturalitzar", "necrosar", "negar", "neguitejar", "netejar", "nonuplicar", "normalitzar", "nuar", "oblidar", "obligar", "obnubilar", "obscurir", "occidentalitzar", "occitanitzar", "ocultar", "ocupar", "ofegar", "oferir", "ofuscar", "ombrar", "omplir", "operar", "oposar", "ordenar", "orejar", "organitzar", "orgullar", "orientalitzar", "orientar", "originar", "orinar", "oscar", "oxigenar", "pacificar", "paganitzar", "pagar", "pansir", "parapetar", "parar", "parlar", "particularitzar", "partir", "passar", "passejar", "pedregar", "pedrejar", "pellar", "penjar", "pensar", "pentinar", "percaçar", "perfeccionar", "perfilar", "permetre", "persignar", "persuadir", "pessigar", "petar", "picar", "pintar", "pirar", "plantar", "plantejar", "plantificar", "podrir", "polaritzar", "polir", "pol·linitzar", "pondre", "popularitzar", "portar", "posar", "possessionar", "posticar", "postrar", "prear", "precipitar", "prendre", "preocupar", "preparar", "presentar", "prestar", "prevaler", "privar", "proclamar", "prodigar", "produir", "professionalitzar", "proletaritzar", "prometre", "pronunciar", "propagar", "propalar", "proposar", "prostituir", "prostrar", "prou", "proveir", "pujar", "punxar", "purificar", "putejar", "quadrar", "qualificar", "quallar", "quedar", "quitar", "rabejar", "radicalitzar", "rarificar", "ratificar", "reafirmar", "realitzar", "rebaixar", "rebentar", "reblir", "rebolcar", "rebullir", "recargolar", "reciclar", "reciprocar", "recloure", "recobrar", "recollir", "recolzar", "reconcentrar", "reconciliar", "reconstituir", "recordar", "recrear", "recriminar", "rectificar", "reencarnar", "reenganxar", "refer", "referir", "refermar", "reflectir", "refocil·lar", "reforçar", "refractar", "refredar", "refrenar", "refrescar", "refringir", "refugiar", "refusar", "regalar", "regelar", "regirar", "rehabilitar", "rehidratar", "reincorporar", "reinflar", "reinstal·lar", "reintegrar", "rejovenir", "relacionar", "relaxar", "rellentir", "relligar", "rellogar", "remenar", "remetre", "remirar", "remollir", "remudar", "remuntar", "rendir", "renovar", "renovellar", "rentar", "repatriar", "repenjar", "repensar", "repetir", "repintar", "replegar", "replujar", "repodrir", "reportar", "reposar", "representar", "reprimir", "reproduir", "repuntar", "rescabalar", "reservar", "resguardar", "resignar", "resinificar", "resistir", "resoldre", "responsabilitzar", "resquitar", "ressecar", "ressobinar", "restablir", "retardar", "retenir", "retintar", "retirar", "retractar", "retre", "retreure", "retrobar", "reunir", "reveixinar", "revelar", "revellir", "revenxinar", "revestir", "revifar", "reviscolar", "revoltar", "rifar", "rinxolar", "riure", "romanitzar", "rombollar", "rompre", "rostir", "rovellar", "ruboritzar", "russificar", "sacrificar", "salmorrar", "salsir", "salvar", "santificar", "satel·litzar", "secularitzar", "sedimentar", "segar", "segregar", "seguir", "sentir", "senyar", "separar", "significar", "silicificar", "sincerar", "sindicar", "singularitzar", "sinitzar", "situar", "sobrealimentar", "sobreexcitar", "sobreposar", "sobresaltar", "sobresanar", "sobresaturar", "sobtar", "socarrar", "solapar", "solar", "solaçar", "soldar", "solidaritzar", "solidificar", "sollar", "sollevar", "solvatar", "somorgollar", "soplujar", "sostreure", "sotaplujar", "sotmetre", "suberificar", "suberitzar", "subestimar", "submergir", "subscriure", "suggestionar", "sulfatar", "sulfurar", "sumar", "sumir", "superar", "tallar", "tancar", "tant", "tapar", "temperar", "tenyir", "terraplenar", "tirar", "titular", "tocar", "tombar", "torbar", "torejar", "tornar", "torrar", "trabucar", "tractar", "tranquil·litzar", "transfigurar", "transformar", "translimitar", "transmetre", "transmutar", "transparentar", "transvasar", "trasmudar", "trasplantar", "trastocar", "trastornar", "triar", "tribular", "trifurcar", "trobar", "tòrcer", "ulcerar", "ullar", "unir", "universalitzar", "untar", "vaporitzar", "velar", "venjar", "ventar", "vessar", "vestir", "viciar", "vinclar", "vincular", "vitrificar", "volar", "volatilitzar", "xalar", "xutar");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -48,6 +48,7 @@ public void testRule() throws IOException {
 
     //TODO: se'n vola / s'envola
     // correct sentences:
+    assertCorrect("Ella se sol endur les garrotades.");
     assertCorrect("L'ha a baixar desde."); //nonsense sentence with spelling error!
     assertCorrect("El tauler es pot construir baixant amb cartes.");
     assertCorrect("El botó del ratolí es configura per anar endavant i endarrere.");
@@ -122,6 +123,7 @@ public void testRule() throws IOException {
     assertCorrect("La mort del pare m’havia portat la imatge d’aquests morts");
     assertCorrect("Una onada de foc em pujava del pit a la cara.");
 
+    assertIncorrect("Ens vàrem marxar amb tren.");
     //donar-se compte
     assertCorrect("D'aquest Decret se n'ha donat compte al Ple de l'Ajuntament");
     assertCorrect("Encara em cal donar compte d'un altre recull");

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -64,6 +64,7 @@ public class ReflexiveVerbsRule extends Rule {
   private static final List<String> verbsSovintAmbComplement = Arrays.asList ("deixar","fer","veure","costar");
   private static final List<String> verbsDeixarFer= Arrays.asList ("deixar", "fer");
   private static final List<String> verbsPortarDur = Arrays.asList ("portar", "dur");
+  private static final List<String> lemesEnPerifrasis = Arrays.asList ("tornar", "haver", "anar", "deure", "poder", "voler");//, "a", "de", "en", "pas");
   
   
   private static final List<String> verbsPotencialmentPronominals = Arrays.asList("abaixar", "abandonar", "abarrocar", "abellir", "abismar", "abissar", "ablamar", "ablanir", "abocar", "aboldronar", "abonançar", "abonar", "abonir", "abonyegar", "abordar", "abraonar", "abraçar", "abrivar", "abroquerar", "abrusar", "absentar", "abstraure", "abstreure", "aburgesar", "acabar", "acalar", "acalorar", "acantonar", "acarrerar", "acastellanar", "acatalanar", "accelerar", "acetificar", "acidificar", "aclarir", "aclimatar", "aclivellar", "aclucar", "acoblar", "acollir", "acollonir", "acomiadar", "acomodar", "acomplexar", "acomplir", "aconductar", "aconsellar", "acontentar", "acopar", "acoquinar", "acordar", "acorruar", "acostar", "acostumar", "acotar", "acotxar", "acovardir", "acreditar", "acréixer", "acubar", "acubillar", "acudir", "acugular", "acuitar", "acular", "acumular", "acusar", "adaptar", "adargar", "adherir", "adjudicar", "adollar", "adolorir", "adondar", "adormir", "adossar", "adotzenar", "adreçar", "adscriure", "adunar", "afalconar", "afanyar", "afartar", "afeblir", "afectar", "afermar", "aferrar", "afigurar", "afilar", "afilerar", "afiliar", "afillar", "afinar", "aflaquir", "afligir", "aflonjar", "afluixar", "afogar", "afollar", "afrancesar", "afrevolir", "afuar", "afusar", "agabellar", "agafar", "agarbar", "agarbonar", "agitar", "aglomerar", "aglutinar", "agombolar", "agostejar", "agradar", "agregar", "agremiar", "agreujar", "agrir", "agrisar", "agrumar", "aguantar", "aguditzar", "aigualir", "airejar", "aixecar", "aixoplugar", "ajaure", "ajaçar", "ajeure", "ajornalar", "ajudar", "ajuntar", "ajupir", "ajustar", "alabar", "alarmar", "alcalinitzar", "alcoholitzar", "alegrar", "alentir", "aliar", "alimentar", "alinear", "allarar", "allargar", "allargassar", "allerar", "alleugerir", "alleujar", "alliberar", "alligar", "allistar", "allitar", "allotjar", "allunyar", "alterar", "alzinar", "alçar", "amagar", "amagrir", "amanerar", "amanir", "amansar", "amansir", "amassar", "ambientar", "americanitzar", "amistançar", "amistar", "amollar", "amorar", "amorosir", "amorrar", "amorriar", "amotinar", "amoïnar", "amuntegar", "anastomitzar", "angoixar", "anguniejar", "animar", "anomenar", "anticipar", "apagar", "apaivagar", "apanyar", "aparellar", "apariar", "apartar", "aparèixer", "apassionar", "apercebre", "apilotar", "apinyar", "apitrar", "aplanar", "aplaçar", "aplicar", "apocar", "apoderar", "aposentar", "apostar", "apostemar", "apregonar", "aprendre", "apressar", "aprimar", "aprofitar", "apropar", "apropiar", "aprovisionar", "aproximar", "apujar", "apuntalar", "aquedar", "aquietar", "aquilotar", "arborar", "arbrar", "arcar", "argollar", "aristocratitzar", "armar", "arquejar", "arraconar", "arramadar", "arrambar", "arramellar", "arranjar", "arrapar", "arraulir", "arrear", "arrecerar", "arredossar", "arreglar", "arrelar", "arremangar", "arremolinar", "arremorar", "arrenglerar", "arreplegar", "arrestar", "arribar", "arrimar", "arriscar", "arrissar", "arrodonir", "arromangar", "arrombollar", "arronsar", "arrossegar", "arrufar", "arrugar", "arruïnar", "articular", "asfixiar", "assabentar", "assaonar", "assecar", "assegurar", "assentar", "assenyalar", "asserenar", "assessorar", "asseure", "assimilar", "associar", "assolar", "assolellar", "assossegar", "assotar", "astorar", "atabalar", "ataconar", "atalaiar", "atandar", "atansar", "atapeir", "atardar", "atavellar", "aterrir", "aterrossar", "atipar", "atiplar", "atonir", "atorrollar", "atracar", "atribolar", "atribuir", "atrinxerar", "atrofiar", "atropellar", "atrotinar", "aturar", "avalotar", "avançar", "avarar", "avariar", "avenir", "aventurar", "avergonyir", "avesar", "aviar", "aviciar", "avidar", "avivar", "avorrir", "aïllar", "aïrar", "badar", "balancejar", "balandrejar", "baldar", "banyar", "barallar", "barrejar", "basar", "basquejar", "bastar", "batre", "befar", "bellugar", "beneficiar", "bleir", "blocar", "bolcar", "bombar", "bonificar", "botir", "brindar", "brossar", "bufar", "buidar", "burocratitzar", "cabrejar", "cabussar", "cagar", "calar", "calmar", "calçar", "campar", "cansar", "cap", "capalçar", "capbussar", "capficar", "capgirar", "captar", "captrencar", "caracteritzar", "caragirar", "carbonar", "carbonatar", "carbonitzar", "cardar", "cargolar", "carregar", "cartejar", "casar", "cascar", "cenyir", "cerciorar", "cicatritzar", "circumscriure", "clamar", "classificar", "clavar", "clivellar", "cloure", "coagular", "cobrir", "colar", "colgar", "colltorçar", "colltòrcer", "colrar", "coltellejar", "col·lapsar", "col·legiar", "col·locar", "comanar", "combinar", "compadir", "compaginar", "compatir", "compensar", "complementar", "complexificar", "complicar", "complir", "complànyer", "compondre", "comportar", "comprendre", "comprimir", "comprometre", "compungir", "comunicar", "concentrar", "concertar", "conciliar", "concordar", "concretar", "condemnar", "condensar", "conduir", "confabular", "confederar", "confessar", "confinar", "confirmar", "confitar", "conformar", "congelar", "congestionar", "conglomerar", "conglutinar", "congratular", "congregar", "congriar", "conhortar", "conjuminar", "conjunyir", "conjurar", "connaturalitzar", "consagrar", "conscienciar", "consentir", "conservar", "consolar", "consolidar", "constipar", "consumir", "contagiar", "contaminar", "contemperar", "contenir", "contorbar", "contornar", "contradir", "contraposar", "contreure", "controlar", "convertir", "convèncer", "corbar", "corcar", "cordar", "coronar", "corporificar", "corregir", "correspondre", "corrompre", "corsecar", "cotitzar", "covar", "crebantar", "cremar", "creure", "criar", "crispar", "cucar", "cuidar", "cuixatrencar", "curar", "curullar", "damnar", "debatre", "decantar", "decidir", "declarar", "decuplicar", "decurvar", "dedicar", "defendre", "defensar", "definir", "deformar", "defugir", "degradar", "deixar", "deixatar", "deixondar", "deixondir", "deixuplinar", "delectar", "delir", "delitar", "denudar", "departir", "depauperar", "depilar", "deportar", "depositar", "depravar", "deprimir", "depurar", "derivar", "desabillar", "desabonar", "desabrigar", "desacalorar", "desacoblar", "desaconductar", "desaconduir", "desacordar", "desacostumar", "desacreditar", "desadherir", "desaferrar", "desafinar", "desagafar", "desagermanar", "desagradar", "desagregar", "desajustar", "desalinear", "desamarrar", "desamigar", "desamistançar", "desamorrar", "desanar", "desanimar", "desaparellar", "desapariar", "desaparroquianar", "desaplicar", "desapropiar", "desar", "desarborar", "desarmar", "desarramadar", "desarrambar", "desarranjar", "desarrapar", "desarreglar", "desarregussar", "desarrelar", "desarrengar", "desarrenglar", "desarrenglerar", "desarrimar", "desarrissar", "desarromangar", "desarrufar", "desarrugar", "desarticular", "desassossegar", "desatansar", "desatapeir", "desatendar", "desavesar", "desaveïnar", "desballestar", "desbaratar", "desbarbar", "desbarrar", "desbordar", "desbrancar", "desbraonar", "descabalar", "descabdellar", "descabellar", "descalcificar", "descalçar", "descaminar", "descantellar", "descarbonatar", "descarbonitzar", "descarburar", "descargolar", "descarnar", "descarregar", "descarrerar", "descartar", "descastellanitzar", "descatalanitzar", "descelerar", "descentrar", "descenyir", "desclassar", "desclavar", "descloure", "descoagular", "descobrir", "descolgar", "descollar", "descolorar", "descolorir", "descol·locar", "descompassar", "descompensar", "descompondre", "descomprometre", "descomptar", "desconceptuar", "desconcertar", "desconfortar", "descongelar", "descongestionar", "desconhortar", "desconjuntar", "desconnectar", "descoratjar", "descordar", "descosir", "descotxar", "descrostar", "descular", "desdaurar", "desdelitar", "desdenyar", "desdibuixar", "desdinerar", "desdir", "desdoblar", "desdoblegar", "deseixir", "deselectritzar", "desembabaiar", "desembadalir", "desembadocar", "desemballestar", "desemboirar", "desembolcallar", "desembolcar", "desembolicar", "desembotir", "desembotjar", "desembotornar", "desemboçar", "desembravir", "desembrocar", "desembromallar", "desembromar", "desembullar", "desembussar", "desembutllofar", "desemmandrir", "desemmurriar", "desempallar", "desempastar", "desemperesir", "desempernar", "desempipar", "desempobrir", "desempolainar", "desempolsar", "desempolvorar", "desenamorar", "desencadenar", "desencaixar", "desencalimar", "desencalitjar", "desencallar", "desencaminar", "desencantar", "desencaparrar", "desencapotar", "desencaputxar", "desencarar", "desencarcarar", "desencarranquinar", "desencartonar", "desencastar", "desencaterinar", "desencauar", "desencavalcar", "desencavallar", "desencebar", "desencerclar", "desencercolar", "desencimbellar", "desencisar", "desenclavar", "desencoblar", "desencolar", "desencongir", "desencoratjar", "desencorbar", "desencordillar", "desencrespar", "desencrostar", "desendegar", "desendeutar", "desendogalar", "desendolcir", "desendollar", "desendropir", "desenfadar", "desenfadeir", "desenfarfegar", "desenfellonir", "desenferrissar", "desenfetgegar", "desenfilar", "desenfitar", "desenflocar", "desenfocar", "desenfrenar", "desenfuriar", "desenfurismar", "desengandulir", "desenganxar", "desenganyar", "desengatjar", "desengavanyar", "desengomar", "desengormandir", "desengorronir", "desengreixar", "desengrescar", "desengruixir", "desengrutar", "desenguantar", "desenguerxir", "desenllaminir", "desenllaçar", "desenlleganyar", "desenllepolir", "desenllorar", "desenlluernar", "desenllustrar", "desennuegar", "desennuvolar", "desenquadernar", "desenquadrar", "desenquimerar", "desenrampar", "desenredar", "desenrederar", "desenrolar", "desenrotllar", "desensabonar", "desensenyorir", "desensonyar", "desensopir", "desensuperbir", "desentaular", "desentelar", "desentendre", "desentenebrar", "desentenebrir", "desenterbolir", "desenterrar", "desentestar", "desentortolligar", "desentrampar", "desentranyar", "desentravessar", "desentrecuixar", "desentrenar", "desentristir", "desentumir", "desentusiasmar", "desenutjar", "desenvelar", "desenvernissar", "desenvescar", "desenvolupar", "desenyorar", "desequilibrar", "desertitzar", "desesmar", "desesperançar", "desesperar", "desespessir", "desestancar", "desestanyar", "desestovar", "desfaixar", "desfaiçonar", "desfanatitzar", "desfardar", "desfasar", "desfermar", "desferrar", "desficiar", "desficiejar", "desfigurar", "desfilar", "desflorir", "desfocar", "desfogar", "desfonar", "desfrarar", "desfrenar", "desfrunzir", "desfullar", "desganar", "desgastar", "desgavellar", "desglaçar", "desgraciar", "desgranar", "desgruixar", "desguarnir", "desguerxar", "desguitarrar", "deshabitar", "deshabituar", "deshidratar", "deshumanitzar", "desigualar", "desil·lusionar", "desimantar", "desincorporar", "desincrustar", "desinfatuar", "desinflamar", "desinflar", "desinhibir", "desintegrar", "desinteressar", "desintoxicar", "desionitzar", "desjunyir", "deslligar", "deslliurar", "desllodrigar", "desllogar", "deslloriguerar", "deslluir", "desllustrar", "desmagnetitzar", "desmaiar", "desmallar", "desmanegar", "desmaquillar", "desmarcar", "desmembrar", "desmillorar", "desmoralitzar", "desmorriar", "desmudar", "desmuntar", "desnacionalitzar", "desnaturar", "desniar", "desnierar", "desnivellar", "desnuar", "desnucar", "desobligar", "desobstruir", "desocupar", "desorbitar", "desordenar", "desorganitzar", "desorientar", "despacientar", "desparar", "desparellar", "despariar", "despassar", "despenjar", "despentinar", "despenyar", "despersonalitzar", "despertar", "despintar", "despistar", "despitar", "desplaçar", "desplegar", "desplomar", "despoblar", "despolir", "desposseir", "desprendre", "desprestigiar", "desprisar", "despullar", "despuntar", "desrengar", "desroentar", "dessaborir", "dessagnar", "dessecar", "dessolar", "dessoldar", "dessonillar", "dessoterrar", "dessuar", "dessucar", "destacar", "destapar", "destarotar", "destemprar", "destenyir", "desteular", "destintar", "destorçar", "destravar", "destrempar", "destrenar", "destriar", "destrossar", "destòrcer", "desunglar", "desunir", "desusar", "desvariar", "desvariejar", "desvesar", "desvestir", "desvetllar", "desviar", "desvincular", "desvitrificar", "detenir", "deteriorar", "determinar", "deturar", "devaluar", "dialitzar", "dibuixar", "diferenciar", "difondre", "diftongar", "difuminar", "dignificar", "dilatar", "diluir", "dipositar", "dirigir", "disbauxar", "disciplinar", "disculpar", "disfressar", "disgregar", "disgustar", "dislocar", "disparar", "dispersar", "disposar", "disputar", "disseminar", "dissimilar", "dissipar", "dissociar", "dissoldre", "distanciar", "distendre", "distingir", "distreure", "distribuir", "diversificar", "divertir", "dividir", "divorciar", "divulgar", "doblar", "doblegar", "doctorar", "documentar", "doldre", "domesticar", "domiciliar", "dominar", "donar", "dopar", "dreçar", "drogar", "dubtar", "dulcificar", "duplicar", "dutxar", "eclipsar", "efectuar", "efeminar", "eixamar", "eixamenar", "eixamorar", "eixamplar", "eixancar", "eixancarrar", "eixarrancar", "eixarreir", "eixorivir", "eixugar", "electritzar", "electrocutar", "elevar", "elidir", "emancipar", "embabaiar", "embadalir", "embadocar", "embajanir", "embalar", "embalbar", "embalbir", "embancar", "embarbollar", "embarcar", "embardissar", "embarracar", "embarrancar", "embarranquinar", "embarrar", "embarumar", "embarzerar", "embasardir", "embassar", "embastardir", "embellir", "embeure", "embicar", "emblanquir", "emblavir", "embofegar", "embogir", "emboirar", "embolicar", "emborbollar", "emborratxar", "emboscar", "embossar", "embotinar", "embotir", "emboçar", "embrancar", "embravir", "embretolir", "embriagar", "embrocar", "embrollar", "embromar", "embrossar", "embrunir", "embrutar", "embrutir", "embullar", "embussar", "embutllofar", "embutxacar", "emmagrir", "emmalaltir", "emmaleir", "emmallar", "emmandrir", "emmarcir", "emmaridar", "emmascarar", "emmatxucar", "emmerdar", "emmerdissar", "emmetzinar", "emmirallar", "emmotllar", "emmudir", "emmusteir", "emmustigar", "emocionar", "empadronar", "empal·lidir", "empantanar", "empantanegar", "empanxonar", "empapatxar", "emparar", "emparaular", "emparentar", "emparrar", "empastellar", "empastifar", "empastissar", "empatxar", "empedreir", "empeguntar", "empellar", "empeltar", "empenyorar", "emperesir", "emperlar", "empernar", "empetitir", "empilar", "empinar", "empipar", "empitjorar", "empitrar", "empixonar", "emplenar", "emplomallar", "empobrir", "empolainar", "empolistrar", "empolsar", "empolsegar", "empolsimar", "empolsinar", "empolvorar", "empoquir", "emporcar", "emporprar", "empotingar", "emprendre", "emprenyar", "emprovar", "enagrir", "enamorar", "enamoriscar", "enarborar", "enarbrar", "enarcar", "enardir", "enasprar", "enasprir", "encabassar", "encabir", "encaboriar", "encadarnar", "encadenar", "encaixar", "encalbir", "encalimar", "encalitjar", "encallar", "encallir", "encambrar", "encamellar", "encaminar", "encamisar", "encantar", "encaparrar", "encapellar", "encaperonar", "encaperullar", "encaperutxar", "encapirotar", "encapotar", "encapsular", "encapullar", "encaputxar", "encaramel·lar", "encarar", "encarbonar", "encarir", "encarnar", "encarranquinar", "encarregar", "encarrerar", "encarrilar", "encartonar", "encasquetar", "encastellar", "encauar", "encavallar", "encegar", "encendre", "encepar", "encertir", "encetar", "encimbellar", "enciriar", "enclaustrar", "enclotar", "encloure", "encoblar", "encofurnar", "encoixir", "encomanar", "enconar", "enconcar", "encongir", "encontrar", "encoratjar", "encorbar", "encordar", "encotillar", "encotxar", "encovar", "encrespar", "encreuar", "encrostar", "encrostimar", "encrostissar", "encruelir", "endarreriar", "endarrerir", "endegar", "endentar", "endenyar", "enderrocar", "endeutar", "endinsar", "endogalar", "endolcir", "endolentir", "endossar", "endropir", "endurir", "enemistar", "enervar", "enfadar", "enfadeir", "enfangar", "enfarfegar", "enfarinar", "enfastidir", "enfastijar", "enfellonir", "enfervorir", "enfetgegar", "enfigassar", "enfilar", "enfistular", "enfitar", "enflocar", "enflorar", "enfondir", "enfonsar", "enfonyar", "enforfoguir", "enforinyar", "enfortir", "enfosquir", "enfredar", "enfredolicar", "enfredorar", "enfredorir", "enfrontar", "enfuriar", "enfurir", "enfurismar", "engabiar", "engalavernar", "engallar", "engallardir", "engallir", "engallofir", "engalonar", "engalvanir", "enganar", "engandulir", "enganxar", "enganyar", "engatar", "engatjar", "engelosir", "enginjolar", "enginyar", "engiponar", "englotir", "engolar", "engolir", "engordir", "engorjar", "engormandir", "engorronir", "engrandir", "engreixar", "engrescar", "engrevir", "engroguir", "engronsar", "engronyar", "engrossir", "engruixar", "engruixir", "engrutar", "enguantar", "enguerxir", "enherbar", "enjoiar", "enjoiellar", "enjoncar", "enjullar", "enlairar", "enllacar", "enllaminir", "enllangorir", "enllardar", "enllardissar", "enllaçar", "enllefernar", "enllefiscar", "enllepissar", "enllepolir", "enllestir", "enlletgir", "enllistar", "enllorar", "enllordar", "enllotar", "enllustrar", "ennegrir", "ennoblir", "ennovar", "ennuegar", "ennuvolar", "enorgullar", "enquadrar", "enquibir", "enquimerar", "enrabiar", "enramar", "enrampar", "enrancir", "enrarir", "enrasar", "enravenar", "enredar", "enrederar", "enrederir", "enrellentir", "enretirar", "enrevenxinar", "enriallar", "enrigidir", "enrinxolar", "enriquir", "enrobustir", "enrocar", "enrogir", "enrolar", "enronquir", "enrosar", "enrossir", "enrotllar", "enrullar", "enrunar", "ensabonar", "ensagnar", "ensalivar", "ensangonar", "enseguir", "ensenyorir", "ensonyar", "ensopegar", "ensopir", "ensordir", "ensorrar", "ensotar", "ensulsir", "ensuperbir", "entaforar", "entatxonar", "entaular", "entebeir", "entebionar", "entelar", "entendre", "entendrir", "entenebrar", "entenebrir", "enterbolir", "enterrar", "enterrossar", "entestar", "entollar", "entonar", "entornar", "entortellar", "entortolligar", "entrampar", "entrapar", "entravessar", "entrebancar", "entregar", "entregirar", "entrellaçar", "entrelligar", "entremesclar", "entrenar", "entretenir", "entreveure", "entrevistar", "entristar", "entristir", "entumir", "enturar", "entusiasmar", "enutjar", "envanir", "envellir", "envellutar", "enverdir", "enverinar", "envermellir", "envescar", "enviar", "envigorir", "envilir", "environar", "enviscar", "enviscolar", "envitricollar", "envoltar", "enxarxar", "enxiquir", "enyorar", "equilibrar", "equivaler", "equivocar", "erigir", "eriçar", "errar", "esbadiar", "esbadinar", "esbadocar", "esbalair", "esbaldir", "esbaldregar", "esbandir", "esbardellar", "esbargir", "esbarriar", "esbarzerar", "esberlar", "esbocinar", "esboirar", "esboldregar", "esbombar", "esbombolar", "esborifar", "esborrar", "esborrifar", "esborronar", "esbotifarrar", "esbotzar", "esbrancar", "esbraonar", "esbraveir", "esbullar", "escabellar", "escabellonar", "escabotar", "escaldar", "escaldufar", "escalfar", "escalfeir", "escalivar", "escalonar", "escamarlar", "escamnar", "escampar", "escandalitzar", "escantellar", "escantonar", "escanyar", "escapar", "escarmentar", "escarrabillar", "escarxar", "escaure", "escindir", "esclafar", "esclafassar", "esclarir", "esclerosar", "escolar", "escoltar", "escometre", "escondir", "escotar", "escridar", "escridassar", "escrostar", "escrostissar", "escrostonar", "escruixir", "escuar", "escudar", "escuixar", "escular", "escurçar", "escórrer", "esdernegar", "esdevenir", "esduir", "esfacelar", "esfereir", "esfilagarsar", "esfondrar", "esfreixurar", "esfullar", "esfumar", "esgallar", "esgardissar", "esgarrar", "esgarrifar", "esgarrinxar", "esgarrinyar", "esgarronar", "esgavellar", "esglaonar", "esgotar", "esgratinyar", "esguardar", "esguerrar", "esllenegar", "esllomar", "esmadeixar", "esmalucar", "esmenar", "esmicar", "esmicolar", "esmolar", "esmorrellar", "esmorronar", "esmortir", "esmunyir", "esmussar", "espalmar", "espantar", "espanyolitzar", "espaordir", "espargir", "esparpallar", "esparpillar", "esparracar", "esparverar", "espassar", "espatllar", "espaventar", "espavilar", "especejar", "especialitzar", "espedaçar", "espellifar", "espellir", "espellissar", "espenyar", "esperançar", "esperar", "espesseir", "espessir", "espicassar", "espigar", "espinar", "espitrar", "esplaiar", "esplugar", "espolsar", "espoltrir", "esponjar", "esporuguir", "esposar", "esprémer", "espuar", "espuntar", "espunyir", "espuçar", "esqueixar", "esquerar", "esquerdar", "esquerdillar", "esquerdissar", "esquinçar", "esquitxar", "esquivar", "est", "estabilitzar", "establir", "estacionar", "estalviar", "estamordir", "estancar", "estandarditzar", "estantolar", "estanyar", "estarrufar", "estellar", "estendre", "estepitzar", "estilitzar", "estimbar", "estintolar", "estirar", "estireganyar", "estiuar", "estontolar", "estovar", "estrangeritzar", "estranyar", "estratificar", "estrenar", "estressar", "estretir", "estrinxolar", "estripar", "estroncar", "estropellar", "estrènyer", "estubar", "estufar", "esvair", "esvalotar", "esventar", "esvorar", "esvorellar", "eternitzar", "europeïtzar", "evadir", "evaporar", "exacerbar", "exaltar", "examinar", "exasperar", "excedir", "excitar", "exclamar", "excloure", "exculpar", "excusar", "exercitar", "exfoliar", "exhalar", "exhaurir", "exhibir", "exiliar", "eximir", "exornar", "expandir", "expatriar", "explicar", "exposar", "expressar", "extasiar", "extenuar", "exterioritzar", "extingir", "extraviar", "extremar", "faixar", "familiaritzar", "fanatitzar", "fastiguejar", "fatigar", "federar", "felicitar", "feminitzar", "ferir", "fiar", "ficar", "figurar", "filtrar", "fingir", "firar", "fixar", "flagel·lar", "florir", "folrar", "foraviar", "forcar", "forjar", "formalitzar", "formar", "fortificar", "fossilitzar", "fotre", "fraccionar", "fracturar", "fragmentar", "francesitzar", "franquejar", "fregar", "fregir", "frisar", "fumar", "fundar", "gabar", "gastar", "gaudir", "gelar", "generalitzar", "gestar", "ginyar", "girar", "gitar", "glaçar", "gloriejar", "governar", "graduar", "gramaticalitzar", "gratar", "gratular", "gravar", "grecitzar", "grillar", "gronxar", "gronxejar", "gronxolar", "guanyar", "guardar", "guarir", "guarnir", "guerxar", "guiar", "guillar", "habituar", "hebraïtzar", "hel·lenitzar", "hemodialitzar", "herniar", "hibridar", "hidratar", "hissar", "honorar", "honrar", "horripilar", "horroritzar", "hostatjar", "humanitzar", "humiliar", "humitejar", "identificar", "igualar", "il·luminar", "il·lusionar", "il·lustrar", "imaginar", "immergir", "immolar", "impacientar", "implicar", "imposar", "impressionar", "imprimir", "impurificar", "incarcerar", "incendiar", "inclinar", "incomodar", "incorporar", "incrementar", "incrustar", "independitzar", "indignar", "indisposar", "inebriar", "infatuar", "infectar", "infestar", "infiltrar", "inflamar", "inflar", "informar", "ingerir", "inhabilitar", "inhibir", "iniciar", "inquietar", "inscriure", "insinuar", "inspirar", "instal·lar", "instruir", "insubordinar", "insultar", "insurreccionar", "integrar", "intensificar", "interessar", "interferir", "internar", "interposar", "interrompre", "intranquil·litzar", "introduir", "inundar", "invaginar", "inventar", "ionitzar", "irritar", "islamitzar", "isolar", "jubilar", "jugar", "junyir", "justificar", "lamentar", "laxar", "lignificar", "limitar", "llampar", "llançar", "llassar", "llatinitzar", "llepar", "lletrejar", "llevar", "llicenciar", "lligar", "lliurar", "llogar", "lluir", "localitzar", "lucrar", "macerar", "malacostumar", "malavesar", "maliciar", "mallar", "malpensar", "mamar", "mancomunar", "manegar", "manejar", "manifestar", "mantenir", "maquillar", "marcir", "marejar", "marginar", "maridar", "marinejar", "mascarar", "massificar", "masturbar", "matar", "materialitzar", "matricular", "matxucar", "mecanitzar", "mediumitzar", "menar", "menjar", "mentalitzar", "menysprear", "meravellar", "merèixer", "mesclar", "metal·litzar", "metamorfosar", "meteoritzar", "migrar", "millorar", "mineralitzar", "mirar", "mobilitzar", "mocar", "moderar", "modernitzar", "modificar", "molestar", "morfondre", "morir", "morrejar", "mortificar", "mossegar", "mostrar", "moure", "mudar", "mullar", "multiplicar", "musteir", "mustiar", "mustigar", "mutilar", "nacionalitzar", "naturalitzar", "necrosar", "negar", "neguitejar", "netejar", "nonuplicar", "normalitzar", "nuar", "oblidar", "obligar", "obnubilar", "obscurir", "occidentalitzar", "occitanitzar", "ocultar", "ocupar", "ofegar", "oferir", "ofuscar", "ombrar", "omplir", "operar", "oposar", "ordenar", "orejar", "organitzar", "orgullar", "orientalitzar", "orientar", "originar", "orinar", "oscar", "oxigenar", "pacificar", "paganitzar", "pagar", "pansir", "parapetar", "parar", "parlar", "particularitzar", "partir", "passar", "passejar", "pedregar", "pedrejar", "pellar", "penjar", "pensar", "pentinar", "percaçar", "perfeccionar", "perfilar", "permetre", "persignar", "persuadir", "pessigar", "petar", "picar", "pintar", "pirar", "plantar", "plantejar", "plantificar", "podrir", "polaritzar", "polir", "pol·linitzar", "pondre", "popularitzar", "portar", "posar", "possessionar", "posticar", "postrar", "prear", "precipitar", "prendre", "preocupar", "preparar", "presentar", "prestar", "prevaler", "privar", "proclamar", "prodigar", "produir", "professionalitzar", "proletaritzar", "prometre", "pronunciar", "propagar", "propalar", "proposar", "prostituir", "prostrar", "prou", "proveir", "pujar", "punxar", "purificar", "putejar", "quadrar", "qualificar", "quallar", "quedar", "quitar", "rabejar", "radicalitzar", "rarificar", "ratificar", "reafirmar", "realitzar", "rebaixar", "rebentar", "reblir", "rebolcar", "rebullir", "recargolar", "reciclar", "reciprocar", "recloure", "recobrar", "recollir", "recolzar", "reconcentrar", "reconciliar", "reconstituir", "recordar", "recrear", "recriminar", "rectificar", "reencarnar", "reenganxar", "refer", "referir", "refermar", "reflectir", "refocil·lar", "reforçar", "refractar", "refredar", "refrenar", "refrescar", "refringir", "refugiar", "refusar", "regalar", "regelar", "regirar", "rehabilitar", "rehidratar", "reincorporar", "reinflar", "reinstal·lar", "reintegrar", "rejovenir", "relacionar", "relaxar", "rellentir", "relligar", "rellogar", "remenar", "remetre", "remirar", "remollir", "remudar", "remuntar", "rendir", "renovar", "renovellar", "rentar", "repatriar", "repenjar", "repensar", "repetir", "repintar", "replegar", "replujar", "repodrir", "reportar", "reposar", "representar", "reprimir", "reproduir", "repuntar", "rescabalar", "reservar", "resguardar", "resignar", "resinificar", "resistir", "resoldre", "responsabilitzar", "resquitar", "ressecar", "ressobinar", "restablir", "retardar", "retenir", "retintar", "retirar", "retractar", "retre", "retreure", "retrobar", "reunir", "reveixinar", "revelar", "revellir", "revenxinar", "revestir", "revifar", "reviscolar", "revoltar", "rifar", "rinxolar", "riure", "romanitzar", "rombollar", "rompre", "rostir", "rovellar", "ruboritzar", "russificar", "sacrificar", "salmorrar", "salsir", "salvar", "santificar", "satel·litzar", "secularitzar", "sedimentar", "segar", "segregar", "seguir", "sentir", "senyar", "separar", "significar", "silicificar", "sincerar", "sindicar", "singularitzar", "sinitzar", "situar", "sobrealimentar", "sobreexcitar", "sobreposar", "sobresaltar", "sobresanar", "sobresaturar", "sobtar", "socarrar", "solapar", "solar", "solaçar", "soldar", "solidaritzar", "solidificar", "sollar", "sollevar", "solvatar", "somorgollar", "soplujar", "sostreure", "sotaplujar", "sotmetre", "suberificar", "suberitzar", "subestimar", "submergir", "subscriure", "suggestionar", "sulfatar", "sulfurar", "sumar", "sumir", "superar", "tallar", "tancar", "tant", "tapar", "temperar", "tenyir", "terraplenar", "tirar", "titular", "tocar", "tombar", "torbar", "torejar", "tornar", "torrar", "trabucar", "tractar", "tranquil·litzar", "transfigurar", "transformar", "translimitar", "transmetre", "transmutar", "transparentar", "transvasar", "trasmudar", "trasplantar", "trastocar", "trastornar", "triar", "tribular", "trifurcar", "trobar", "tòrcer", "ulcerar", "ullar", "unir", "universalitzar", "untar", "vaporitzar", "velar", "venjar", "ventar", "vessar", "vestir", "viciar", "vinclar", "vincular", "vitrificar", "volar", "volatilitzar", "xalar", "xutar");
@@ -669,6 +670,7 @@ && matchRegexp(tokens[i + 1].getToken(), REFLEXIU_POSPOSAT))
                 && !(matchRegexp(tokens[i - j].getToken(), REFLEXIU_POSPOSAT) && j>k))
               return true;
             keepCounting = matchPostagRegexp(tokens[i - j], PREP_VERB_PRONOM)
+                && (matchLemmaList(tokens[i - j], lemesEnPerifrasis) || !matchPostagRegexp(tokens[i - j], VERB))
                 && !(j>k-1 && matchPostagRegexp(tokens[i - j], VERB_PARTICIPI))
                 && !matchPostagRegexp(tokens[i - j], TRENCA_COMPTE2);
             if (tokens[i-j].getToken().equalsIgnoreCase("per")

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -49,7 +49,9 @@ public void testRule() throws IOException {
     //TODO: se'n vola / s'envola
     // correct sentences:
     assertCorrect("L'ha a baixar desde."); //nonsense sentence with spelling error!
-    //assertCorrect("la festa de Rams es commemora anant a l'església a beneir el palmó");
+    assertCorrect("El tauler es pot construir baixant amb cartes.");
+    assertCorrect("El botó del ratolí es configura per anar endavant i endarrere.");
+    assertCorrect("la festa de Rams es commemora anant a l'església a beneir el palmó");
     assertCorrect("les circumstàncies m'obliguen a gloriar-me"); 
     //assertCorrect("es van agenollar i prosternar");
     //assertCorrect("Una equivocació tan gran no es pot callar.");

File: languagetool-language-modules/es/src/main/java/org/languagetool/tokenizers/es/SpanishWordTokenizer.java
Patch:
@@ -42,7 +42,7 @@ public List<String> tokenize(String text) {
                     + "\u2028\u2029\u202a\u202b\u202c\u202d\u202e\u202f"
                     + "\u205F\u2060\u2061\u2062\u2063\u206A\u206b\u206c\u206d"
                     + "\u206E\u206F\u3000\u3164\ufeff\uffa0\ufff9\ufffa\ufffb"
-                    + ",.;()[]{}<>!?:=*#∗×·+÷/\\\"'«»„”“‘`’…¿¡\t\n\r", true);
+                    + "-,.;()[]{}<>!?:=*#∗×·+÷/\\\"'«»„”“‘`’…¿¡\t\n\r", true);
     while (st.hasMoreElements()) {
       tokenList.add(st.nextToken());
     }

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishConfusionProbabilityRule.java
Patch:
@@ -46,6 +46,7 @@ public class EnglishConfusionProbabilityRule extends ConfusionProbabilityRule {
       "thank you for the patience",
       "your patience regarding",
       "your fix",  // fix = bug fix
+      "your commit",
       "on point",
       "chapter one",
       "usb port",

File: languagetool-core/src/main/java/org/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -107,8 +107,9 @@ public AnalyzedTokenReadings(AnalyzedTokenReadings oldAtr, List<AnalyzedToken> n
       this.immunize();
     }
     if (oldAtr.isIgnoredBySpeller()) {
-      this.isIgnoredBySpeller();
+      this.ignoreSpelling();
     }
+    this.setHistoricalAnnotations(oldAtr.getHistoricalAnnotations());
     addHistoricalAnnotations(oldAtr.toString(), ruleApplied); 
   }
 
@@ -431,7 +432,7 @@ public void setSentEnd() {
     if (!isSentenceEnd()) {
       AnalyzedToken sentenceEnd = new AnalyzedToken(getToken(),
           SENTENCE_END_TAGNAME, getAnalyzedToken(0).getLemma());
-      addReading(sentenceEnd, "add_sentence_end");
+      addReading(sentenceEnd, "");
     }
   }
 

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/MultiWordChunker.java
Patch:
@@ -225,8 +225,7 @@ private AnalyzedTokenReadings prepareNewReading(String tokens, String tok, Analy
   }
 
   private AnalyzedTokenReadings setAndAnnotate(AnalyzedTokenReadings oldReading, AnalyzedToken newReading) {  
-    AnalyzedTokenReadings newAtr = new AnalyzedTokenReadings(oldReading.getReadings(),
-            oldReading.getStartPos());
+    AnalyzedTokenReadings newAtr = oldReading;
     newAtr.addReading(newReading, "MULTIWORD_CHUNKER");
     return newAtr;
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanStyleRepeatedWordRule.java
Patch:
@@ -86,10 +86,10 @@ private static boolean isUnknownWord(AnalyzedTokenReadings token) {
    * Only substantive, names, verbs and adjectives are checked
    */
   protected boolean isTokenToCheck(AnalyzedTokenReadings token) {
-    return (token.matchesPosTagRegex("(SUB|EIG|VER|ADJ):.*") 
+    return ((token.matchesPosTagRegex("(SUB|EIG|VER|ADJ):.*") 
         && !token.matchesPosTagRegex("(PRO|A(RT|DV)|VER:(AUX|MOD)):.*")
-        && !StringUtils.equalsAny(token.getToken(), "sicher", "weit", "Sie", "Ich"))
-        || isUnknownWord(token);
+        || isUnknownWord(token))
+        && !StringUtils.equalsAny(token.getToken(), "sicher", "weit", "Sie", "Ich", "Euch", "Eure"));
   }
 
   /*

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule2.java
Patch:
@@ -74,8 +74,8 @@ public AgreementRule2(ResourceBundle messages, Language language) {
     this.language = language;
     setDefaultTempOff();
     super.setCategory(Categories.GRAMMAR.getCategory(messages));
-    addExamplePair(Example.wrong("<marker>Der Haus</marker> wurde letztes Jahr gebaut."),
-                   Example.fixed("<marker>Das Haus</marker> wurde letztes Jahr gebaut."));
+    addExamplePair(Example.wrong("<marker>Kleiner Haus</marker> am Waldrand"),
+                   Example.fixed("<marker>Kleines Haus</marker> am Waldrand"));
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/rules/Rule.java
Patch:
@@ -324,9 +324,9 @@ public final void setDefaultOff() {
 
   /**
    * Turns the pattern rule off by default, expect for internal regression tests.
-   * <b>WARNING:</b> currently only works for XML rules
    */
   public final void setDefaultTempOff() {
+    defaultOff = true;
     defaultTempOff = true;
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -680,7 +680,6 @@ protected void prepareRule(AbstractPatternRule rule) {
       rule.setDefaultOff();
     }
     if (defaultTempOff) {
-      rule.setDefaultOff();
       rule.setDefaultTempOff();
     }
     if (url != null && url.length() > 0) {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule2.java
Patch:
@@ -72,6 +72,7 @@ public class AgreementRule2 extends Rule {
 
   public AgreementRule2(ResourceBundle messages, Language language) {
     this.language = language;
+    setDefaultTempOff();
     super.setCategory(Categories.GRAMMAR.getCategory(messages));
     addExamplePair(Example.wrong("<marker>Der Haus</marker> wurde letztes Jahr gebaut."),
                    Example.fixed("<marker>Das Haus</marker> wurde letztes Jahr gebaut."));

File: languagetool-core/src/main/java/org/languagetool/rules/Rule.java
Patch:
@@ -323,7 +323,8 @@ public final void setDefaultOff() {
   }
 
   /**
-   * Turns the rule off by default, expect for internal regression tests.
+   * Turns the pattern rule off by default, expect for internal regression tests.
+   * <b>WARNING:</b> currently only works for XML rules
    */
   public final void setDefaultTempOff() {
     defaultTempOff = true;

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -278,6 +278,7 @@ public int getPriorityForId(String id) {
       case "APPSTORE":                  return 1;   // prefer over spell checker
       case "DONT_T":                    return 1;   // prefer over EN_CONTRACTION_SPELLING
       case "WHATS_APP":                 return 1;   // prefer over EN_CONTRACTION_SPELLING
+      case "NON_STANDARD_COMMA":        return 1;   // prefer over spell checker
       case "PROFANITY":                 return 5;   // prefer over spell checker
       case "RUDE_SARCASTIC":            return 6;   // prefer over spell checker
       case "CHILDISH_LANGUAGE":         return 8;   // prefer over spell checker

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/dumpcheck/SentenceSourceChecker.java
Patch:
@@ -225,7 +225,7 @@ private void run(File propFile, Set<String> disabledRules, String langCode, List
         System.out.printf(lang + ": %d total matches\n", ruleMatchCount);
         System.out.printf(Locale.ENGLISH, lang + ": ø%.2f rule matches per sentence\n", matchesPerSentence);
         long runTimeMillis = System.currentTimeMillis() - startTime;
-        System.out.printf(Locale.ENGLISH, lang + ": Time: %.2f minutes\n", runTimeMillis/1000.0/60.0);
+        //System.out.printf(Locale.ENGLISH, lang + ": Time: %.2f minutes\n", runTimeMillis/1000.0/60.0);
         try {
           resultHandler.close();
         } catch (Exception e) {

File: languagetool-dev/src/main/java/org/languagetool/dev/diff/RuleMatchDiffFinder.java
Patch:
@@ -173,7 +173,7 @@ public static void main(String[] args) throws IOException {
       fw.write("<head>\n");
       fw.write("  <title>" + title + "</title>\n");
       fw.write("  <meta charset='utf-8'>\n");
-      fw.write("  <script src='tablefilter/tablefilter.js'></script>\n");  // https://github.com/koalyptus/TableFilter/
+      fw.write("  <script src='../tablefilter/tablefilter.js'></script>\n");  // https://github.com/koalyptus/TableFilter/
       fw.write("  <style>\n");
       fw.write("    .sentence { color: #666; }\n");
       fw.write("    .marker { text-decoration: underline; }\n");
@@ -185,7 +185,7 @@ public static void main(String[] args) throws IOException {
       diffFinder.print(diffs, fw);
       fw.write("<script>\n" +
                "var tf = new TableFilter(document.querySelector('.sortable_table'), {\n" +
-               "    base_path: './tablefilter/',\n" +
+               "    base_path: '../tablefilter/',\n" +
                "    col_0: 'select',\n" +
                "    col_1: 'select',\n" +
                "    auto_filter: { delay: 100 },\n" +

File: languagetool-standalone/src/main/java/org/languagetool/gui/Main.java
Patch:
@@ -276,6 +276,8 @@ private void addLanguage() throws InstantiationException, IllegalAccessException
     languageBox.setModel(LanguageComboBoxModel.create(messages,
             EXTERNAL_LANGUAGE_SUFFIX, false, externalLanguages, null));
     languageBox.selectLanguage(ltSupport.getLanguage());
+    ltSupport.setLanguage(languageBox.getSelectedLanguage());
+    checkTextAndDisplayResults();
   }
 
   private void showOptions() {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/MissingCommaRelativeClauseRule.java
Patch:
@@ -74,8 +74,6 @@ public MissingCommaRelativeClauseRule(ResourceBundle messages, boolean behind) {
     super.setCategory(new Category(new CategoryId("HILFESTELLUNG_KOMMASETZUNG"),
         "Hilfestellung für Kommasetzung", Location.INTERNAL, true));
     super.makeAntiPatterns(ANTI_PATTERNS, GERMAN);
-    addExamplePair(Example.wrong("Das <marker>Auto das</marker> am Straßenrand steht, parkt im Halteverbot."),
-        Example.fixed("Das <marker>Auto, das</marker> am Straßenrand steht, parkt im Halteverbot."));
     this.behind = behind;
   }
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/MissingCommaRelativeClauseRuleTest.java
Patch:
@@ -48,7 +48,6 @@ public void testMatch() throws Exception {
     assertNoMatch("Computer machen die Leute dumm.", rule, lt);
     assertNoMatch("Die Unstimmigkeit zwischen den Geschichten der zwei Unfallbeteiligten war groß.", rule, lt);
     assertNoMatch("Ebenso darf keine schwerere Strafe als die zum Zeitpunkt der Begehung der strafbaren Handlung angedrohte Strafe verhängt werden.", rule, lt);
-    assertNoMatch("Es ist die Wiederkehr der Panikmache, die der neue Nationalismus mit dem der Sprachreiniger verbindet und die Geschichte der Sprachreinigung zu einem Lehrstück macht.", rule, lt);
     
     rule = new MissingCommaRelativeClauseRule(TestTools.getMessages("de"), true);
     
@@ -61,7 +60,7 @@ public void testMatch() throws Exception {
     assertNoMatch("Ich habe einige Fehler begangen, die ich vermeiden hätte können sollen.", rule, lt);
     assertNoMatch("Wenn du alles, was du meinst nicht zu können, von anderen erledigen lässt, wirst du es niemals selbst lernen.", rule, lt);
     assertNoMatch("Er hat einen Zeitraum durchlebt, in dem seine Gedanken verträumt auf den weiten Feldern der Mysterien umherirrten.", rule, lt);
-    
+    assertNoMatch("Es ist die Wiederkehr der Panikmache, die der neue Nationalismus mit dem der Sprachreiniger verbindet und die Geschichte der Sprachreinigung zu einem Lehrstück macht.", rule, lt);   
   
   }
   

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleBuilderHelper.java
Patch:
@@ -46,5 +46,4 @@ public static PatternToken token(String s) {
   public static PatternToken regex(String regex) {
     return new PatternTokenBuilder().tokenRegex(regex).build();
   }
-
 }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/MissingCommaRelativeClauseRuleTest.java
Patch:
@@ -48,6 +48,7 @@ public void testMatch() throws Exception {
     assertNoMatch("Computer machen die Leute dumm.", rule, lt);
     assertNoMatch("Die Unstimmigkeit zwischen den Geschichten der zwei Unfallbeteiligten war groß.", rule, lt);
     assertNoMatch("Ebenso darf keine schwerere Strafe als die zum Zeitpunkt der Begehung der strafbaren Handlung angedrohte Strafe verhängt werden.", rule, lt);
+    assertNoMatch("Es ist die Wiederkehr der Panikmache, die der neue Nationalismus mit dem der Sprachreiniger verbindet und die Geschichte der Sprachreinigung zu einem Lehrstück macht.", rule, lt);
     
     rule = new MissingCommaRelativeClauseRule(TestTools.getMessages("de"), true);
     

File: languagetool-core/src/test/java/org/languagetool/rules/CommaWhitespaceRuleTest.java
Patch:
@@ -71,6 +71,8 @@ public void testRule() throws IOException {
     assertMatches("This is a sentence with an orphaned full stop .", 1);
     assertMatches("This is a test with a OOo footnote\u0002, which is denoted by 0x2 in the text.", 0);
     assertMatches("A sentence ' with ' ten \" incorrect \" examples of ’ using ’ quotation “ marks ” at « once » in it.", 10);
+    assertMatches("A sentence ' with' one examples of wrong quotations marks in it.", 1);
+    assertMatches("A sentence 'with ' one examples of wrong quotations marks in it.", 1);
 
     RuleMatch[] matches = rule.match(langTool.getAnalyzedSentence("ABB (  z.B. )"));
     assertEquals(2, matches.length);

File: languagetool-core/src/test/java/org/languagetool/rules/CommaWhitespaceRuleTest.java
Patch:
@@ -55,6 +55,7 @@ public void testRule() throws IOException {
     assertMatches("In his book,\u0002 Einstein proved this to be true.", 0);
     assertMatches("- [ ] A checkbox at GitHub", 0);
     assertMatches("- [x] A checked checkbox at GitHub", 0);
+    assertMatches("A sentence 'with' ten \"correct\" examples of ’using’ quotation “marks” at «once» in it.", 0);
 
     // errors:
     assertMatches("This,is a test sentence.", 1);
@@ -69,6 +70,7 @@ public void testRule() throws IOException {
     assertMatches("This (foo bar } is a test!.", 1);
     assertMatches("This is a sentence with an orphaned full stop .", 1);
     assertMatches("This is a test with a OOo footnote\u0002, which is denoted by 0x2 in the text.", 0);
+    assertMatches("A sentence ' with ' ten \" incorrect \" examples of ’ using ’ quotation “ marks ” at « once » in it.", 10);
 
     RuleMatch[] matches = rule.match(langTool.getAnalyzedSentence("ABB (  z.B. )"));
     assertEquals(2, matches.length);

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -107,7 +107,7 @@ public Contributor[] getMaintainers() {
   @Override
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, Language motherTongue, List<Language> altLanguages) throws IOException {
     return Arrays.asList(
-            new CommaWhitespaceRule(messages),
+            new CommaWhitespaceRule(messages, false),
             new DoublePunctuationRule(messages),
             new GenericUnpairedBracketsRule(messages,
                     Arrays.asList("[", "(", "{" /*"«", "‘"*/),

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/SpecificCaseRuleTest.java
Patch:
@@ -39,9 +39,12 @@ public void testRule() throws IOException {
     assertGood("Harry Potter");
     assertGood("I like Harry Potter.");
     assertGood("I like HARRY POTTER.");
+    assertGood("Vitamin C is good for you.");
+    assertGood("But vitamin C is good for you.");
     assertBad("harry potter");
     assertBad("harry Potter");
     assertBad("Harry potter");
+    assertBad("But Vitamin C is good for you.");
     RuleMatch[] matches = assertBad("I like Harry potter.");
     assertThat(matches[0].getFromPos(), is(7));
     assertThat(matches[0].getToPos(), is(19));

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleMatcher.java
Patch:
@@ -41,12 +41,14 @@
  * Matches a pattern rule against text.
  */
 final public class PatternRuleMatcher extends AbstractPatternRulePerformer implements RuleMatcher {
+
+  public static final String MISTAKE = "<mistake/>";
+
   private static final Map<String,Integer> currentlyActiveRules = new ConcurrentHashMap<>();
 
   //private static final Logger logger = LoggerFactory.getLogger(PatternRuleMatcher.class);
   private static final String SUGGESTION_START_TAG = "<suggestion>";
   private static final String SUGGESTION_END_TAG = "</suggestion>";
-  private static final String MISTAKE = "<mistake/>";
 
   private final boolean useList;
   private final List<PatternTokenMatcher> patternTokenMatchers;

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/EnglishUnpairedBracketsRuleTest.java
Patch:
@@ -75,6 +75,7 @@ public void testRule() throws IOException {
     assertCorrect("Paradise lost to the alleged water needs of Texas' big cities Thursday.");
     assertCorrect("Kill 'em all!");
     assertCorrect("Puttin' on the Ritz");
+    assertCorrect("Dunkin' Donuts");
     //some more cases
     assertCorrect("(Ketab fi Isti'mal al-'Adad al-Hindi)");
     assertCorrect("On their 'host' societies.");

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -393,7 +393,7 @@ public String getSpellingFileName() {
    */
   public List<String> getAdditionalSpellingFileNames() {
     // NOTE: also add to GermanSpellerRule.getSpeller() when adding items here:
-    return Arrays.asList(language.getShortCode() + CUSTOM_SPELLING_FILE/*, GLOBAL_SPELLING_FILE -- TODO: causes crash with dynamic languages */);
+    return Arrays.asList(language.getShortCode() + CUSTOM_SPELLING_FILE, GLOBAL_SPELLING_FILE);
   }
 
   /**

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -393,7 +393,7 @@ public String getSpellingFileName() {
    */
   public List<String> getAdditionalSpellingFileNames() {
     // NOTE: also add to GermanSpellerRule.getSpeller() when adding items here:
-    return Arrays.asList(language.getShortCode() + CUSTOM_SPELLING_FILE, GLOBAL_SPELLING_FILE);
+    return Arrays.asList(language.getShortCode() + CUSTOM_SPELLING_FILE/*, GLOBAL_SPELLING_FILE -- TODO: causes crash with dynamic languages */);
   }
 
   /**

File: languagetool-dev/src/main/java/org/languagetool/rules/spelling/suggestions/SuggestionChangesTest.java
Patch:
@@ -53,7 +53,7 @@
 
 /**
  * needs to run with classpath of languagetool-standalone (needs access to language modules)
- * configure via JSON file, format specified in SuggestionChangesTestCenfig.java
+ * configure via JSON file, format specified in SuggestionChangesTestConfig.java
  * specify path via JVM parameter -Dconfig=... (system property)
  * used to create training data (features) for suggestion ranking models or test how code changes affect LT's performance
  *

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -392,6 +392,7 @@ public String getSpellingFileName() {
    * @since 4.8
    */
   public List<String> getAdditionalSpellingFileNames() {
+    // NOTE: also add to GermanSpellerRule.getSpeller() when adding items here:
     return Arrays.asList(language.getShortCode() + CUSTOM_SPELLING_FILE, GLOBAL_SPELLING_FILE);
   }
 

File: languagetool-dev/src/main/java/org/languagetool/dev/eval/AtDEvaluator.java
Patch:
@@ -106,7 +106,7 @@ private List<RuleMatch> getRuleMatches(String resultXml, AnnotatedText text) thr
       int toPos = fromPos + string.length();
       NodeList suggestions = (NodeList)xPath.evaluate("suggestions", error, XPathConstants.NODESET);
       RuleMatch ruleMatch = new RuleMatch(new AtdRule(), null, 
-              text.getOriginalTextPositionFor(fromPos), text.getOriginalTextPositionFor(toPos), description);
+              text.getOriginalTextPositionFor(fromPos, false), text.getOriginalTextPositionFor(toPos -1, true) +1, description);
       for (int j = 0; j < suggestions.getLength(); j++) {
         Node option = suggestions.item(j);
         String optionStr = xPath.evaluate("option", option);

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternTokenBuilder.java
Patch:
@@ -119,13 +119,14 @@ public PatternToken build() {
     if (posTag != null) {
       patternToken = new PatternToken(null, false, false, false);
       patternToken.setPosToken(new PatternToken.PosToken(posTag, regexp, false));
-      patternToken.setNegation(negation);
     } else {
       patternToken = new PatternToken(token, caseSensitive, regexp, matchInflectedForms);
     }
     if (isWhiteSpaceSet) {
       patternToken.setWhitespaceBefore(isWhiteSpaceBefore);
     }
+
+    patternToken.setNegation(negation);
     patternToken.setSkipNext(skip);
     patternToken.setInsideMarker(marker);
     return patternToken;

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/SubjectVerbAgreementRule.java
Patch:
@@ -102,7 +102,7 @@ public class SubjectVerbAgreementRule extends Rule {
     ),
     Arrays.asList(
       pos("KON:UNT"),
-      new PatternTokenBuilder().csToken("sie").setSkip(3).build(),
+      new PatternTokenBuilder().token("sie").setSkip(3).build(),
       tokenRegex("sind|waren")
     ),
     Arrays.asList( //Bei komplexen und andauernden Störungen ist der Stress-Stoffwechsel des Hundes entgleist.

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SubjectVerbAgreementRuleTest.java
Patch:
@@ -150,6 +150,9 @@ public void testRuleWithIncorrectSingularVerb() throws IOException {
   public void testRuleWithCorrectSingularVerb() throws IOException {
     List<String> sentences = Arrays.asList(
         "All diesen Bereichen ist gemeinsam, dass sie unterfinanziert sind.",
+        "Nicht entmutigen lassen, nur weil Sie kein Genie sind.",
+        "Denken Sie daran, dass Sie hier zu Gast sind und sich entsprechend verhalten sollten.",
+        "Ist es wahr, dass Sie ein guter Mensch sind?",
         "Die Katze ist schön.",
         "Die eine Katze ist schön.",
         "Eine Katze ist schön.",

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/TokenAgreementAdjNounExceptionHelper.java
Patch:
@@ -443,7 +443,7 @@ && hasOverlapIgnoreGender(InflectionHelper.getAdjInflections(tokens[i-3].getRead
     if( i < tokens.length-1 
         && LemmaHelper.hasLemma(tokens[i], Arrays.asList("пара", "низка", "ряд", "купа", "більшість", "десятка", "сотня", "тисяча", "мільйон"))
         && (PosTagHelper.hasPosTag(tokens[i+1], "noun.*?:p:v_rod.*")
-          || (i < tokens.length-1
+          || (i < tokens.length-2
             && PosTagHelper.hasPosTag(tokens[i+1], "adj:p:v_rod.*")
             && PosTagHelper.hasPosTag(tokens[i+2], "noun.*?:p:v_rod.*")) ) ) {
       logException();

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -78,7 +78,6 @@ public abstract class SpellingCheckRule extends Rule {
   private static final Comparator<String> STRING_LENGTH_COMPARATOR = Comparator.comparingInt(String::length);
 
   private final UserConfig userConfig;
-  private final Set<String> wordsToBeIgnored = new HashSet<>();
   private final Set<String> wordsToBeProhibited = new HashSet<>();
   private final List<RuleWithLanguage> altRules;
 
@@ -88,6 +87,7 @@ public abstract class SpellingCheckRule extends Rule {
   private List<DisambiguationPatternRule> antiPatterns = new ArrayList<>();
   private boolean considerIgnoreWords = true;
   private boolean convertsCase = false;
+  protected final Set<String> wordsToBeIgnored = new HashSet<>();
   protected int ignoreWordsWithLength = 0;
 
   public SpellingCheckRule(ResourceBundle messages, Language language, UserConfig userConfig) {

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/CompoundAwareHunspellRule.java
Patch:
@@ -143,7 +143,7 @@ protected List<String> getCandidates(List<String> parts) {
     int partCount = 0;
     List<String> candidates = new ArrayList<>();
     for (String part : parts) {
-      if (hunspellDict.misspelled(part)) {
+      if (!hunspell.spell(part)) {
         // assume noun, so use uppercase:
         boolean doUpperCase = partCount > 0 && !StringTools.startsWithUppercase(part);
         List<String> suggestions = morfoSpeller.getSuggestions(doUpperCase ? StringTools.uppercaseFirstChar(part) : part);
@@ -213,7 +213,7 @@ private List<String> getCorrectWords(List<String> wordsOrPhrases) {
       String[] words = tokenizeText(wordOrPhrase);
       boolean wordIsOkay = true;
       for (String word : words) {
-        if (hunspellDict.misspelled(word)) {
+        if (!hunspell.spell(word)) {
           wordIsOkay = false;
           break;
         }

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -78,6 +78,7 @@ public abstract class SpellingCheckRule extends Rule {
   private static final Comparator<String> STRING_LENGTH_COMPARATOR = Comparator.comparingInt(String::length);
 
   private final UserConfig userConfig;
+  private final Set<String> wordsToBeIgnored = new HashSet<>();
   private final Set<String> wordsToBeProhibited = new HashSet<>();
   private final List<RuleWithLanguage> altRules;
 
@@ -87,7 +88,6 @@ public abstract class SpellingCheckRule extends Rule {
   private List<DisambiguationPatternRule> antiPatterns = new ArrayList<>();
   private boolean considerIgnoreWords = true;
   private boolean convertsCase = false;
-  protected final Set<String> wordsToBeIgnored = new HashSet<>();
   protected int ignoreWordsWithLength = 0;
 
   public SpellingCheckRule(ResourceBundle messages, Language language, UserConfig userConfig) {

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/CompoundAwareHunspellRule.java
Patch:
@@ -143,7 +143,7 @@ protected List<String> getCandidates(List<String> parts) {
     int partCount = 0;
     List<String> candidates = new ArrayList<>();
     for (String part : parts) {
-      if (!hunspell.spell(part)) {
+      if (hunspellDict.misspelled(part)) {
         // assume noun, so use uppercase:
         boolean doUpperCase = partCount > 0 && !StringTools.startsWithUppercase(part);
         List<String> suggestions = morfoSpeller.getSuggestions(doUpperCase ? StringTools.uppercaseFirstChar(part) : part);
@@ -213,7 +213,7 @@ private List<String> getCorrectWords(List<String> wordsOrPhrases) {
       String[] words = tokenizeText(wordOrPhrase);
       boolean wordIsOkay = true;
       for (String word : words) {
-        if (!hunspell.spell(word)) {
+        if (hunspellDict.misspelled(word)) {
           wordIsOkay = false;
           break;
         }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -53,7 +53,7 @@ public void testCompoundMatch() throws IOException {
     assertBad("Die Standard Priorität ist 5.", "Die Standardpriorität", "Die Standard-Priorität");
     assertBad("Die derzeitige Standard Priorität ist 5.", "Die derzeitige Standardpriorität", "Die derzeitige Standard-Priorität");
     assertBad("Ein neuer LanguageTool Account", "Ein neuer LanguageTool-Account");
-    assertBad("Danke für deine Account Daten", "deine Account-Daten");
+    assertBad("Danke für deine Account Daten", "deine Accountdaten", "deine Account-Daten");
     assertBad("Mit seinem Konkurrent Alistair Müller", "sein Konkurrent", "seinem Konkurrenten");
     //assertBad("Die Bad Taste Party von Susi", "Die Bad-Taste-Party");   // not supported yet
     //assertBad("Die Update Liste.", "Die Updateliste");  // not accepted by speller

File: languagetool-core/src/main/java/org/languagetool/language/CommonWords.java
Patch:
@@ -65,6 +65,9 @@ public CommonWords() throws IOException {
                 continue;
               }
               String key = line.toLowerCase();
+              if (key.length() == 1 && Character.isSpaceChar(key.charAt(0))) {
+                continue;
+              }
               List<Language> languages = word2langs.get(key);
               if (languages == null) {
                 // word2langs is static, so this can be accessed from multiple threads concurrently -> prevent exceptions

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/SpellingCheckRuleTest.java
Patch:
@@ -54,7 +54,7 @@ public void testIgnoreSuggestionsWithMorfologik() throws IOException {
     assertThat(lt.check("This is anotherArtificialTestWordForLanguageTol.")  // note the typo
                .get(0).getSuggestedReplacements().toString(), is("[anotherArtificialTestWordForLanguageTool]"));
 
-    assertThat(lt.check("This is Michaels new song.").get(0).getSuggestedReplacements().toString(), is("[Michael's, Michael]"));
+    assertThat(lt.check("This is Michaels new song.").get(0).getSuggestedReplacements().toString(), is("[Michael's, Michael, Michaela]"));
     assertThat(lt.check("This is Microsofts new product.").get(0).getSuggestedReplacements().toString(), is("[Microsoft's, Microsoft]"));
     //assertThat(lt.check("This is Googles new product.").get(0).getSuggestedReplacements().toString(), is("[Googles, Googles's]"));  // "Googles" is accepted...
   }

File: languagetool-core/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -58,6 +58,7 @@ public class WordListValidatorTest {
           "Kazanlǎk",
           "Kesäranta",
           "Kŭrdzhali",
+          "Malko Tŭrnovo",
           "Rígsþula",
           "Savitṛ",
           "Vafþrúðnismál",

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -48,6 +48,7 @@ static class ExtendedGermanWordSplitter extends GermanWordSplitter {
     static Set<String> extendedList() {
       Set<String> words = new HashSet<>(EmbeddedGermanDictionary.getWords());
       // add compound parts here so we don't need to update JWordSplitter for every missing word we find:
+      words.add("thermostat");
       words.add("fehl");
       words.add("circus");
       words.add("schi");

File: languagetool-language-modules/ru/src/main/java/org/languagetool/tagging/ru/RussianTagger.java
Patch:
@@ -84,7 +84,7 @@ public List<AnalyzedTokenReadings> tag(List<String> sentenceTokens) throws IOExc
                 word = word.replace("ʼ", "ъ");
             }
                 word_ie=word.replace("е","ё");
-               
+                word_ie=word_ie.toLowerCase();
 
             List<AnalyzedToken> l = getAnalyzedTokens(word);
 

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/AccentuationCheckRule.java
Patch:
@@ -268,6 +268,7 @@ else if ((matchPostagRegexp(relevantWords.get(token), NOM_MS) && matchPostagRege
         }
         //una nova formula que (fórmula)
         else if (nextToken.equals("que") && i>2
+            && !token.equals("estipula")
             && ((matchPostagRegexp(relevantWords.get(token), NOM_MS) && matchPostagRegexp(tokens[i - 1], ADJECTIU_MS)
                 && matchPostagRegexp(tokens[i - 2], DETERMINANT_MS))
             || (matchPostagRegexp(relevantWords.get(token), NOM_FS) && matchPostagRegexp(tokens[i - 1], ADJECTIU_FS)

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -47,6 +47,7 @@ public void setUp() throws IOException {
   public void testRule() throws IOException {
 
     // correct sentences:
+    assertCorrect("L'informe estipula que ha de ser així.");
     assertCorrect("Si presencies males pràctiques en la botiga.");
     assertCorrect("—I continues mantenint que això va succeir");
     assertCorrect("No hi ha ningú aquí que begui vi?");

File: languagetool-core/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -47,6 +47,7 @@ public class WordListValidatorTest {
   // Words that are valid but with special characters so that we don't want to
   // allow them in general:
   private static final Set<String> VALID_WORDS = new HashSet<>(Arrays.asList(
+          "art.º",
           "Klaipėda",
           "Mondelēz",
           "chef-d’œuvre",

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -48,7 +48,7 @@ public void testRule() throws IOException {
 
     //TODO: se'n vola / s'envola
     // correct sentences:
-    
+    assertCorrect("L'ha a baixar desde."); //nonsense sentence with spelling error!
     //assertCorrect("la festa de Rams es commemora anant a l'església a beneir el palmó");
     assertCorrect("les circumstàncies m'obliguen a gloriar-me"); 
     //assertCorrect("es van agenollar i prosternar");

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseDiacriticsRule.java
Patch:
@@ -51,7 +51,7 @@ public final String getFileName() {
 
   public PortugueseDiacriticsRule(ResourceBundle messages) throws IOException {
     super(messages, new Portuguese());
-    // setDefaultOff();
+    setDefaultOff();
     super.setCategory(Categories.TYPOS.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Misspelling);
     addExamplePair(Example.wrong("<marker>coupe</marker>"),

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -37,7 +37,6 @@
 import org.languagetool.tools.Tools;
 
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
 import java.net.HttpURLConnection;
 import java.nio.file.Files;
 import java.nio.file.Path;
@@ -334,7 +333,9 @@ public List<RuleMatch> call() throws Exception {
         logger.log(new DatabaseCheckErrorLogEntry("ErrorRateTooHigh", logServerId, agentId, userId, lang, detLang.getDetectedLanguage(), textSize, "matches: " + ruleMatchesSoFar.size()));
       }
       if (params.allowIncompleteResults && ExceptionUtils.getRootCause(e) instanceof ErrorRateTooHighException) {
-        print(e.getMessage() + " - returning " + ruleMatchesSoFar.size() + " matches found so far. Detected language: " + detLang);
+        print(e.getMessage() + " - returning " + ruleMatchesSoFar.size() + " matches found so far. " +
+          "Detected language: " + detLang + ", " + ServerTools.getLoggingInfo(remoteAddress, null, -1, httpExchange,
+          parameters, System.currentTimeMillis()-timeStart, reqCounter));
         matches = new ArrayList<>(ruleMatchesSoFar);  // threads might still be running, so make a copy
         incompleteResultReason = "Results are incomplete: " + ExceptionUtils.getRootCause(e).getMessage();
       } else if (e.getCause() != null && e.getCause() instanceof OutOfMemoryError) {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -525,6 +525,7 @@ public void ignoreRule(String ruleId, Locale locale) {
   public void resetIgnoreRules() {
     documents.resetDisabledRules();
     documents.setRecheck();
+    documents.resetIgnoreOnce();
     docReset = true;
   }
 

File: languagetool-core/src/test/java/org/languagetool/LanguageSpecificTest.java
Patch:
@@ -187,8 +187,9 @@ private void countTempOffRules(Language lang) {
     int limit = 10;
     if (count > limit) {
       System.out.println("################################################################################################");
-      System.out.println("WARNING: More than " + limit + " default='temp_off' rules for " + lang + ", please make sure to turn on these");
+      System.out.println("WARNING: " + count + " default='temp_off' rules for " + lang + ", please make sure to turn on these");
       System.out.println("WARNING: rules after they have been tested (or use default='off' to turn them off permanently)");
+      System.out.println("WARNING: (this warning appears if there are more than " + limit + " default='temp_off' rules)");
       System.out.println("################################################################################################");
     }
   }

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/dumpcheck/CommonCrawlSentenceSource.java
Patch:
@@ -29,7 +29,7 @@
 import java.util.regex.Pattern;
 
 /**
- * Provides access to the sentences of a Wikipedia XML dump. Note that
+ * Provides access to the sentences of CommonCrawl data. Note that
  * conversion exceptions are logged to STDERR and are otherwise ignored.
  * 
  * Get data from http://data.statmt.org/ngrams/deduped/

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -108,6 +108,8 @@ public void testWrongVerb() throws IOException {
     assertGood("Kannst mich gerne anrufen.");
     assertGood("Kannst ihn gerne anrufen.");
     assertGood("Kannst sie gerne anrufen.");
+    assertGood("Aber wie ich sehe, benötigt ihr Nachschub.");
+    assertGood("Wie ich sehe, benötigt ihr Nachschub.");
     // incorrect sentences:
     assertBad("Als Borcarbid weißt es eine hohe Härte auf.");
     assertBad("Das greift auf Vorläuferinstitutionen bist auf die Zeit von 1234 zurück.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CompoundInfinitivRuleTest.java
Patch:
@@ -52,6 +52,7 @@ public void testRule() throws IOException {
     assertThat(rule.match(lt.getAnalyzedSentence("Fang an zu zählen.")).length, is(0));
     assertThat(rule.match(lt.getAnalyzedSentence("Sie strengte sich an zu schwimmen.")).length, is(0));
     assertThat(rule.match(lt.getAnalyzedSentence("Tom stand auf und fing an, auf und ab zu gehen.")).length, is(0));
+    assertThat(rule.match(lt.getAnalyzedSentence("Aber um auf Nummer sicher zu gehen, schrieb er es auf.")).length, is(0));
   }
 
-}
\ No newline at end of file
+}

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/SpanishWikipediaRule.java
Patch:
@@ -53,7 +53,7 @@ public final String getFileName() {
   public SpanishWikipediaRule(ResourceBundle messages) throws IOException {
     super(messages, new Spanish());
     super.setCategory(Categories.WIKIPEDIA.getCategory(messages));
-    setLocQualityIssueType(ITSIssueType.Style);
+    setLocQualityIssueType(ITSIssueType.Grammar);
     addExamplePair(Example.wrong("<marker>a basto</marker>"),
                    Example.fixed("<marker>abasto</marker>"));
   }

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/index/Searcher.java
Patch:
@@ -72,7 +72,7 @@ public class Searcher {
   private String fieldName;
 
   public Searcher(Directory directory) {
-    this(directory, FIELD_NAME);
+    this(directory, FIELD_NAME_LOWERCASE);
   }
 
   public Searcher(Directory directory, String fieldName) {

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/index/Searcher.java
Patch:
@@ -265,6 +265,9 @@ private MatchingSentencesResult findMatchingSentences(IndexSearcher indexSearche
       }
       Document doc = indexSearcher.doc(match.doc);
       String sentence = doc.get(fieldName);
+      if (sentence == null) {
+        throw new RuntimeException("No field '" + fieldName + "' found in doc " + match.doc);
+      }
       List<RuleMatch> ruleMatches = languageTool.check(sentence);
       docsChecked++;
       if (ruleMatches.size() > 0) {

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/XMLRuleHandler.java
Patch:
@@ -56,6 +56,7 @@ enum RegexpMode {
   /** Definitions of values in XML files. */
   protected static final String YES = "yes";
   protected static final String OFF = "off";
+  protected static final String TEMP_OFF = "temp_off";
   protected static final String ON = "on";
   protected static final String POSTAG = "postag";
   protected static final String CHUNKTAG = "chunk";

File: languagetool-standalone/src/test/java/org/languagetool/gui/ConfigurationTest.java
Patch:
@@ -95,8 +95,6 @@ public void testSaveAndLoadConfigurationForManyLanguages() throws Exception {
       enabledRuleIds = conf.getEnabledRuleIds();
       assertTrue(enabledRuleIds.contains("enabledRule"));
       assertEquals(1, enabledRuleIds.size());
-
-
     } finally {
       Files.delete(tempFile.toPath());
     }

File: languagetool-standalone/src/test/java/org/languagetool/rules/patterns/FalseFriendRuleTest.java
Patch:
@@ -35,7 +35,7 @@
 public class FalseFriendRuleTest {
 
   @Test
-  @Ignore("not active for German anymore - repalced by ngram-based false friend rule")
+  @Ignore("not active for German anymore - replaced by ngram-based false friend rule")
   public void testHintsForGermanSpeakers() throws IOException {
     JLanguageTool lt = new JLanguageTool(new English(), new German());
     List<RuleMatch> matches = assertErrors(1, "We will berate you.", lt);
@@ -47,7 +47,7 @@ public void testHintsForGermanSpeakers() throws IOException {
   }
 
   @Test
-  @Ignore("not active for German anymore - repalced by ngram-based false friend rule")
+  @Ignore("not active for German anymore - replaced by ngram-based false friend rule")
   public void testHintsForGermanSpeakersWithVariant() throws IOException {
     JLanguageTool lt = new JLanguageTool(new BritishEnglish(), new SwissGerman());
     List<RuleMatch> matches = assertErrors(1, "We will berate you.", lt);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/ProhibitedCompoundRule.java
Patch:
@@ -75,6 +75,7 @@ public class ProhibitedCompoundRule extends Rule {
           "Korrekturlösung",
           "Regelschreiber",
           "Glasreinigern",
+          "Holzstele",
           "Testbahn",
           "Reiszwecke"
   ));

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -504,6 +504,7 @@ private static PatternToken token(String s) {
     ));
 
   private static final Set<String> VIELE_WENIGE_LOWERCASE = new HashSet<>(Arrays.asList(
+    "sämtlicher",
     "etliche",
     "viele",
     "vieler",

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -115,6 +115,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Das Dach von meinen Autos.");
     assertGood("Da stellt sich die Frage: Ist das Science-Fiction oder moderne Mobilität?");
     assertGood("Er hat einen Post veröffentlicht.");
+    assertGood("Eine lückenlose Aufklärung sämtlicher physiologischer Gehirnprozesse");
 
     assertGood("Wir machen das Januar.");
     assertGood("Wir teilen das Morgen mit.");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -72,6 +72,8 @@ public void testRule() throws IOException {
     // (en especial si hi ha un adverbi entremig: en algun grau més distintes
     //assertCorrect("Es van somriure l'una a l'altra encara dretes, suades i panteixants,");
     //assertCorrect("una combinació de dos o més metalls obtinguda generalment");
+    assertCorrect("El programari baixa el cost i millora la qualitat dels serveis.");
+    assertCorrect("Quan un satèl·lit baixa a 180 km");
     assertCorrect("ja que sovint causa baixes entre els gossos i ovelles");
     assertCorrect("La raó sol allunyar-se dels extrems");
     assertCorrect("L'URL introduït");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -72,6 +72,7 @@ public void testRule() throws IOException {
     // (en especial si hi ha un adverbi entremig: en algun grau més distintes
     //assertCorrect("Es van somriure l'una a l'altra encara dretes, suades i panteixants,");
     //assertCorrect("una combinació de dos o més metalls obtinguda generalment");
+    assertCorrect("ja que sovint causa baixes entre els gossos i ovelles");
     assertCorrect("La raó sol allunyar-se dels extrems");
     assertCorrect("L'URL introduït");
     assertCorrect("Som els més antisistema");

File: languagetool-server/src/main/java/org/languagetool/server/ServerTools.java
Patch:
@@ -99,12 +99,11 @@ static UserLimits getUserLimits(Map<String, String> params, HTTPServerConfig con
         throw new IllegalArgumentException("With 'username' set, you also need to specify either 'apiKey' (recommended) or 'password'");
       }
     } else {
-      // TODO: throw exception (but first log to see how often this happens)
       if (params.get("apiKey") != null) {
-        print("WARN: apiKey was set, but username was not: " + params.get("apiKey"), System.err);
+        throw new IllegalArgumentException("apiKey was set, but username was not: " + params.get("apiKey"));
       }
       if (params.get("password") != null) {
-        print("WARN: password was set, but username was not", System.err);
+        throw new IllegalArgumentException("password was set, but username was not");
       }
       return UserLimits.getDefaultLimits(config);
     }

File: languagetool-standalone/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -56,6 +56,7 @@ public class WordListValidatorTest {
           "chef-d’œuvre",
           "chefs-d’œuvre",
           "Brač",
+          "Qur’an",
           "Djuveč",
           "Djuvečreis",
           "Hidschāb/S",

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishRedundancyRule.java
Patch:
@@ -54,7 +54,7 @@ public EnglishRedundancyRule(ResourceBundle messages) throws IOException {
     super(messages, new English());
     super.setCategory(Categories.REDUNDANCY.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Style);
-    // setDefaultOff();
+    setDefaultOff();  // see #1997
     addExamplePair(Example.wrong("<marker>tuna fish</marker>"),
                    Example.fixed("<marker>tuna</marker>"));
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -500,6 +500,7 @@ private static PatternToken token(String s) {
     ));
 
   private static final Set<String> VIELE_WENIGE_LOWERCASE = new HashSet<>(Arrays.asList(
+    "etliche",
     "viele",
     "vieler",
     "wenige",

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/AccentuationCheckRule.java
Patch:
@@ -249,7 +249,7 @@ else if (!token.equals("pronuncia") && !token.equals("espero") && !token.equals(
             && !token.equals("venia") && !token.equals("venies") && !token.equals("tenia")
             && !token.equals("tenies") && !token.equals("continua") && !token.equals("continues")
             && !token.equals("faria") && !token.equals("faries") && !token.equals("genera")
-            && !token.equals("figuri")
+            && !token.equals("figuri") && !token.equals("presencies") 
             && (i < tokens.length - 1)
             && ((matchPostagRegexp(relevantWords.get(token), NOM_MS) && matchPostagRegexp(tokens[i + 1], ADJECTIU_MS))
                 || (matchPostagRegexp(relevantWords.get(token), NOM_FS) && matchPostagRegexp(tokens[i + 1], ADJECTIU_FS))

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -47,6 +47,7 @@ public void setUp() throws IOException {
   public void testRule() throws IOException {
 
     // correct sentences:
+    assertCorrect("Si presencies males pràctiques en la botiga.");
     assertCorrect("—I continues mantenint que això va succeir");
     assertCorrect("No hi ha ningú aquí que begui vi?");
     assertCorrect("Va tocar l'ària da capo de les variacions Goldberg.");

File: languagetool-core/src/main/java/org/languagetool/rules/Categories.java
Patch:
@@ -37,7 +37,7 @@ public final class Categories {
 
 
   /** Created to match PLAIN_ENGLISH XML category. */
-  public static final Categories PLAIN_ENGLISH = make("PLAIN_ENGLISH", "category_style");
+  public static final Categories PLAIN_ENGLISH = make("PLAIN_ENGLISH", "category_plain_english");
 
   public static final Categories GENDER_NEUTRALITY = make("GENDER_NEUTRALITY", "category_gender_neutrality");
 

File: languagetool-core/src/main/java/org/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -129,7 +129,6 @@ public boolean hasPosTag(String posTag) {
   /**
    * Checks if there is at least one POS tag
    * @since 4.7
-   * @param posTag POS tag to look for
    */
   public boolean hasReading() {
     return anTokReadings != null && anTokReadings.length > 0;

File: languagetool-core/src/main/java/org/languagetool/rules/TextLevelRule.java
Patch:
@@ -72,11 +72,11 @@ public final RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
    * Gives back the minimum number of paragraphs to check to give back a correct result
    * only used by LO office extension
    * return n;
-   * n == -1  --> need to check full text (use only if really needed / bad performance)
+   * n == -1  --&gt; need to check full text (use only if really needed / bad performance)
    *              examples: AbstractWordCoherencyRule, GenericUnpairedBracketsRule, ...
-   * n == 0   --> need only to check the current paragraph
+   * n == 0   --&gt; need only to check the current paragraph
    *              examples: MultipleWhitespaceRule, LongParagraphRule, ...
-   * n >= 1   --> need only to check n paragraphs around the current paragraph
+   * n &gt;= 1   --&gt; need only to check n paragraphs around the current paragraph
    *              examples: ParagraphRepeatBeginningRule (n == 1), WordRepeatBeginningRule (n == 2), ...
    */
   public abstract int minToCheckParagraph();

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishDiacriticsRule.java
Patch:
@@ -51,7 +51,7 @@ public final String getFileName() {
 
   public EnglishDiacriticsRule(ResourceBundle messages) throws IOException {
     super(messages, new English());
-    // setDefaultOff();  test, disable and reactivate after feature freeze
+    setDefaultOff();  // reactivate after feature freeze
     super.setCategory(Categories.TYPOS.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Misspelling);
     addExamplePair(Example.wrong("<marker>blase</marker>"),

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java
Patch:
@@ -437,6 +437,9 @@ protected List<String> getAdditionalTopSuggestions(List<String> suggestions, Str
     } else if ("womans".equals(word)) {
       return Arrays.asList("women");
       // AtD irregular plurals - END
+    } else if ("tippy-top".equals(word) || "tippytop".equals(word)) {
+      // "tippy-top" is an often used word by Donald Trump
+      return Arrays.asList("tip-top", "top most");
     } else if (word.endsWith("ys")) {
       String suggestion = word.replaceFirst("ys$", "ies");
       if (!speller1.isMisspelled(suggestion)) {

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -129,7 +129,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new WordRepeatRule(messages, this),
             new MultipleWhitespaceRule(messages, this),
             new SpanishWikipediaRule(messages),
-            new SpanishAccentuationCheckRule(messages)
+            new SpanishDiacriticsCheckRule(messages)
     );
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishRedundancyRule.java
Patch:
@@ -54,8 +54,8 @@ public EnglishRedundancyRule(ResourceBundle messages) throws IOException {
     super(messages, new English());
     super.setCategory(Categories.REDUNDANCY.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Style);
-    addExamplePair(Example.wrong("<marker>somewhat unique</marker>"),
-                   Example.fixed("<marker>unique</marker>"));
+    addExamplePair(Example.wrong("<marker>tuna fish</marker>"),
+                   Example.fixed("<marker>tuna</marker>"));
   }
 
   @Override

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishPlainEnglishRule.java
Patch:
@@ -35,7 +35,7 @@
  * A rule that matches words which are complex and suggests easier to understand alternatives. 
  *
  * @author Tiago F. Santos 
- * @since 4.7
+ * @since 4.8
  */
 public class EnglishPlainEnglishRule extends AbstractSimpleReplaceRule2 {
 
@@ -51,6 +51,7 @@ public final String getFileName() {
 
   public EnglishPlainEnglishRule(ResourceBundle messages) throws IOException {
     super(messages, new English());
+    setDefaultOff();  // reactivate after feature freeze
     super.setCategory(Categories.STYLE.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Style);
     addExamplePair(Example.wrong("<marker>fatal outcome</marker>"),

File: languagetool-core/src/test/java/org/languagetool/languagemodel/LuceneSingleIndexLanguageModelTest.java
Patch:
@@ -34,7 +34,7 @@ public class LuceneSingleIndexLanguageModelTest extends LanguageModelTest {
   @Test
   public void testLanguageModel() throws Exception {
     URL ngramUrl = JLanguageTool.getDataBroker().getFromResourceDirAsUrl("/yy/ngram-index");
-    try (LuceneLanguageModel model = new LuceneLanguageModel(new File(ngramUrl.getFile()))) {
+    try (LuceneLanguageModel model = new LuceneLanguageModel(new File(ngramUrl.toURI()))) {
       assertThat(model.getCount("the"), is(55L));
       assertThat(model.getCount(Arrays.asList("the", "nice")), is(3L));
       assertThat(model.getCount(Arrays.asList("the", "nice", "building")), is(1L));

File: languagetool-standalone/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -40,6 +40,7 @@ public class WordListValidatorTest {
           "[0-9a-zA-ZöäüÖÄÜßëçèéáàóòÈÉÁÀÓÒãñíîş&" +
           "Œ€ūαΑβΒγɣΓδΔεΕζΖηΗθΘιΙκΚλΛμΜνΝξΞοΟπΠρΡσΣτΤυΥφΦχΧψΨωΩάΆέΈίΊήΉύΎϊϋΰΐœţłń" +
           "ŚśōżúïÎôêâû" +
+          "Ææ" +  // English
           "ÍÚÑ" + // for Spanish
           "õ" +   // for Portuguese
           "·" +   // for Catalan

File: languagetool-server/src/main/java/org/languagetool/server/ApiV2.java
Patch:
@@ -47,6 +47,7 @@
 class ApiV2 {
 
   private static final String JSON_CONTENT_TYPE = "application/json";
+  private static final String TEXT_CONTENT_TYPE = "text/plain";
   private static final String ENCODING = "UTF-8";
 
   private final TextChecker textChecker;
@@ -92,7 +93,7 @@ private void handleLanguagesRequest(HttpExchange httpExchange) throws IOExceptio
 
   private void handleMaxTextLengthRequest(HttpExchange httpExchange, HTTPServerConfig config) throws IOException {
     String response = Integer.toString(config.maxTextLength);
-    ServerTools.setCommonHeaders(httpExchange, JSON_CONTENT_TYPE, allowOriginUrl);
+    ServerTools.setCommonHeaders(httpExchange, TEXT_CONTENT_TYPE, allowOriginUrl);
     httpExchange.sendResponseHeaders(HttpURLConnection.HTTP_OK, response.getBytes(ENCODING).length);
     httpExchange.getResponseBody().write(response.getBytes(ENCODING));
     ServerMetricsCollector.getInstance().logResponse(HttpURLConnection.HTTP_OK);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -83,8 +83,8 @@ class SingleDocument {
    */
   private static final ResourceBundle MESSAGES = JLanguageTool.getMessageBundle();
   private static final String SINGLE_END_OF_PARAGRAPH = "\n";
-  private static final String END_OF_PARAGRAPH = "\n\n";  //  Paragraph Separator like in standalone GUI
-  private static final int NUMBER_PARAGRAPH_CHARS = END_OF_PARAGRAPH.length();  //  number of end of paragraph characters
+  public static final String END_OF_PARAGRAPH = "\n\n";  //  Paragraph Separator like in standalone GUI
+  public static final int NUMBER_PARAGRAPH_CHARS = END_OF_PARAGRAPH.length();  //  number of end of paragraph characters
   private static final String MANUAL_LINEBREAK = "\r";  //  to distinguish from paragraph separator
   private static final String ZERO_WIDTH_SPACE = "\u200B";  // Used to mark footnotes
   private static final String logLineBreak = System.getProperty("line.separator");  //  LineBreak in Log-File (MS-Windows compatible)

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -29,7 +29,6 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import org.apache.commons.lang3.StringUtils;
 import org.jetbrains.annotations.Nullable;
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.AnalyzedTokenReadings;
@@ -266,7 +265,7 @@ protected List<RuleMatch> getRuleMatches(String word, int startPos, AnalyzedSent
           }
           // "g oing-> "going"
           String sugg = prevWord + word;
-          if (StringUtils.isAllLowerCase(word) && !isMisspelled(speller1, sugg)) {
+          if (word.equals(word.toLowerCase()) && !isMisspelled(speller1, sugg)) {
             if (ruleMatch == null) {
               if (getFrequency(speller1, sugg) >= getFrequency(speller1, prevWord)) {
                 ruleMatch = new RuleMatch(this, sentence, prevStartPos, startPos + word.length(),
@@ -306,7 +305,7 @@ protected List<RuleMatch> getRuleMatches(String word, int startPos, AnalyzedSent
             }
           }
           String sugg = word + nextWord;
-          if (StringUtils.isAllLowerCase(nextWord) && !isMisspelled(speller1, sugg)) {
+          if (nextWord.equals(nextWord.toLowerCase()) && !isMisspelled(speller1, sugg)) {
             if (ruleMatch == null) {
               if (getFrequency(speller1, sugg) >= getFrequency(speller1, nextWord)) {
                 ruleMatch = new RuleMatch(this, sentence, startPos, nextStartPos + nextWord.length(),

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/MorfologikCatalanSpellerRuleTest.java
Patch:
@@ -441,6 +441,8 @@ public void testMorfologikSpeller() throws IOException {
         matches = rule.match(langTool.getAnalyzedSentence("estimad es")); 
         assertEquals("estima des", matches[0].getSuggestedReplacements().get(0));
         assertEquals("estimades", matches[0].getSuggestedReplacements().get(1));
+        matches = rule.match(langTool.getAnalyzedSentence("co nstel·lació")); 
+        assertEquals("constel·lació", matches[0].getSuggestedReplacements().get(0));
         
         matches = rule.match(langTool.getAnalyzedSentence("rà dio")); 
         assertEquals("ràdio", matches[0].getSuggestedReplacements().get(0));

File: languagetool-tools/src/main/java/org/languagetool/tools/DictionaryBuilder.java
Patch:
@@ -78,7 +78,7 @@ protected String getOutputFilename() {
   protected File buildDict(File inputFile) throws Exception {
     File outputFile = new File(outputFilename);
     String infoPath = inputFile.toString().replaceAll("\\.txt$", ".info");
-    File resultFile = new File (inputFile.toString().replaceAll("\\.txt$", JLanguageTool.DICTIONARY_FILETYPE_EXTENSION)));
+    File resultFile = new File (inputFile.toString().replaceAll("\\.txt$", JLanguageTool.DICTIONARY_FILENAME_EXTENSION));
     File infoFile = new File(infoPath);
     // save info file in the same path of input text file and with the same name
     props.store(new FileOutputStream(infoFile), "");

File: languagetool-language-modules/uk/src/test/java/org/languagetool/rules/uk/UppercaseSentenceStartRuleTest.java
Patch:
@@ -46,7 +46,7 @@ public void testUkrainian() throws IOException {
 
     assertEquals(0, rule.match(lt.analyzeText("Він приїхав в с. Вижівка.")).length);
 
-    //assertEquals(0, rule.match(lt.analyzeText("         http://narodna.pravda.com.ua")).length);
+    assertEquals(0, rule.match(lt.analyzeText("         http://narodna.pravda.com.ua")).length);
 
     RuleMatch[] matches = rule.match(lt.analyzeText("автор написав це речення з маленької літери."));
     assertEquals(1, matches.length);

File: languagetool-language-modules/uk/src/test/java/org/languagetool/rules/uk/UppercaseSentenceStartRuleTest.java
Patch:
@@ -46,7 +46,7 @@ public void testUkrainian() throws IOException {
 
     assertEquals(0, rule.match(lt.analyzeText("Він приїхав в с. Вижівка.")).length);
 
-    assertEquals(0, rule.match(lt.analyzeText("         http://narodna.pravda.com.ua")).length);
+    //assertEquals(0, rule.match(lt.analyzeText("         http://narodna.pravda.com.ua")).length);
 
     RuleMatch[] matches = rule.match(lt.analyzeText("автор написав це речення з маленької літери."));
     assertEquals(1, matches.length);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -455,9 +455,7 @@ private void removeDoc(String docID) {
 
   private void initLanguageTool() {
     try {
-      if(xContext != null) {
-        linguServices = new LinguisticServices(xContext);
-      }
+      linguServices = new LinguisticServices(xContext);
       config = new Configuration(configDir, configFile, oldConfigFile, docLanguage, linguServices);
       fixedLanguage = config.getDefaultLanguage();
       if(fixedLanguage != null) {

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/AbstractEnglishSpellerRuleTest.java
Patch:
@@ -40,7 +40,7 @@ public class AbstractEnglishSpellerRuleTest {
   public void testNonVariantSpecificSuggestions(Rule rule, Language language) throws IOException {
     this.lt = new JLanguageTool(language);
     this.rule = rule;
-//    assertFirstMatch("teh", "the");
+    assertFirstMatch("teh", "the");
 
     // from http://waxy.org/2003/04/typo_popularity/:
     //assertFirstMatch("didnt", "didn't"); - covered by ContractionSpellingRule
@@ -63,7 +63,7 @@ public void testNonVariantSpecificSuggestions(Rule rule, Language language) thro
     assertFirstMatch("foriegn", "foreign");
     assertFirstMatch("chemcial", "chemical");
     assertFirstMatch("developement", "development");
-//    assertFirstMatch("maintainance", "maintenance");
+    assertFirstMatch("maintainance", "maintenance");
     assertFirstMatch("restaraunt", "restaurant");
     assertFirstMatch("garentee", "guarantee");
     assertFirstMatch("greatful", "grateful");

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java
Patch:
@@ -275,6 +275,8 @@ protected List<String> getAdditionalTopSuggestions(List<String> suggestions, Str
       return Arrays.asList("your", "you are");
     } else if ("Ure".equals(word)) {
       return Arrays.asList("Your", "You are");
+    } else if ("mins".equals(word)) {
+      return Arrays.asList("minutes", "min");
     } else if (word.endsWith("ys")) {
       String suggestion = word.replaceFirst("ys$", "ies");
       if (!speller1.isMisspelled(suggestion)) {

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/MorfologikRussianSpellerRule.java
Patch:
@@ -36,7 +36,7 @@ public final class MorfologikRussianSpellerRule extends MorfologikSpellerRule {
   public static final String RULE_ID = "MORFOLOGIK_RULE_RU_RU";
 
   private static final String RESOURCE_FILENAME = "/ru/hunspell/ru_RU.dict";
-  private static final Pattern RUSSIAN_LETTERS = Pattern.compile("[а-яёА-ЯЁ]*");
+  private static final Pattern RUSSIAN_LETTERS = Pattern.compile("[-а-яёА-ЯЁ]*");
 
   public MorfologikRussianSpellerRule(ResourceBundle messages, Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
     super(messages, language, userConfig, altLanguages);

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/index/IndexerSearcherTest.java
Patch:
@@ -196,17 +196,17 @@ public void testIndexerSearcherWithEnglish() throws Exception {
     English language = new English();
     SearcherResult searcherResult =
         errorSearcher.findRuleMatchesOnIndex(getFirstRule("BACK_AND_FOURTH", language), language);
-    assertEquals(2, searcherResult.getCheckedSentences());
+    assertEquals(1, searcherResult.getCheckedSentences());
     assertEquals(false, searcherResult.isResultIsTimeLimited());
     assertEquals(1, searcherResult.getMatchingSentences().size());
 
     searcherResult = errorSearcher.findRuleMatchesOnIndex(getFirstRule("EYE_BROW", language), language);
-    assertEquals(2, searcherResult.getCheckedSentences());
+    assertEquals(1, searcherResult.getCheckedSentences());
     assertEquals(false, searcherResult.isResultIsTimeLimited());
     assertEquals(1, searcherResult.getMatchingSentences().size());
 
     searcherResult = errorSearcher.findRuleMatchesOnIndex(getFirstRule("ALL_OVER_THE_WORD", language), language);
-    assertEquals(2, searcherResult.getCheckedSentences());
+    assertEquals(0, searcherResult.getCheckedSentences());
     assertEquals(false, searcherResult.isResultIsTimeLimited());
     assertEquals(0, searcherResult.getMatchingSentences().size());
 

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1136,10 +1136,10 @@ public List<Rule> getAllActiveOfficeRules() {
     for (Rule rule : rules) {
       if (!ignoreRule(rule) && !rule.isOfficeDefaultOff()) {
         rulesActive.add(rule);
-      } else if (rule.isOfficeDefaultOn()) {
+      } else if (rule.isOfficeDefaultOn() && !disabledRules.contains(rule.getId())) {
         rulesActive.add(rule);
         enableRule(rule.getId());
-      } else if (!ignoreRule(rule) && rule.isOfficeDefaultOff()) {
+      } else if (!ignoreRule(rule) && rule.isOfficeDefaultOff() && !enabledRules.contains(rule.getId())) {
         disableRule(rule.getId());
       }
     }    

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanConfusionProbabilityRule.java
Patch:
@@ -44,7 +44,8 @@ public class GermanConfusionProbabilityRule extends ConfusionProbabilityRule {
     "wie erinnern sie sich",
     "dürfen wir nicht",
     "kann dich auch",
-    "wie schicken wir"
+    "wie schicken wir",
+    "ich drei bin" // seit ich drei bin.
   );
 
   public GermanConfusionProbabilityRule(ResourceBundle messages, LanguageModel languageModel, Language language) {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -1200,7 +1200,7 @@ protected List<String> getAdditionalTopSuggestions(List<String> suggestions, Str
     }
     if (!StringTools.startsWithUppercase(word)) {
       String ucWord = StringTools.uppercaseFirstChar(word);
-      if (!suggestions.contains(ucWord) && !hunspellDict.misspelled(ucWord)) {
+      if (!suggestions.contains(ucWord) && !hunspellDict.misspelled(ucWord) && !ucWord.endsWith(".")) {
         // Hunspell doesn't always automatically offer the most obvious suggestion for compounds:
         return Collections.singletonList(ucWord);
       }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -386,7 +386,8 @@ public void testGetAdditionalTopSuggestions() throws Exception {
     assertFirstSuggestion("rethorisch", "rhetorisch", rule, lt);
     assertFirstSuggestion("anschliessliche", "anschließende", rule, lt);
     assertFirstSuggestion("Überstreitung", "Überschreitung", rule, lt);
-    assertFirstSuggestion("werkzeug.", "Werkzeug.", rule, lt);
+    assertFirstSuggestion("werkzeug.", "Werkzeug", rule, lt);
+    assertFirstSuggestion("Wärkzeug.", "Werkzeug", rule, lt);
   }
 
   @Test

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishConfusionProbabilityRule.java
Patch:
@@ -37,7 +37,8 @@ public class EnglishConfusionProbabilityRule extends ConfusionProbabilityRule {
       // See https://github.com/languagetool-org/languagetool/issues/1678
       "your move makes",
       "your move is",
-      "he unchecked the"
+      "he unchecked the",
+      "your fix"  // fix = bug fix
   );
     
   public EnglishConfusionProbabilityRule(ResourceBundle messages, LanguageModel languageModel, Language language) {

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -198,7 +198,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
             List<String> additionalTopSuggestions = getAdditionalTopSuggestions(suggestions, cleanWord);
             if (additionalTopSuggestions.isEmpty() && word.endsWith(".")) {
               additionalTopSuggestions = getAdditionalTopSuggestions(suggestions, word).
-                stream().map(k -> k + ".").collect(Collectors.toList());
+                stream().map(k -> k.endsWith(".") ? k : k + ".").collect(Collectors.toList());
             }
             Collections.reverse(additionalTopSuggestions);
             for (String additionalTopSuggestion : additionalTopSuggestions) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -386,6 +386,7 @@ public void testGetAdditionalTopSuggestions() throws Exception {
     assertFirstSuggestion("rethorisch", "rhetorisch", rule, lt);
     assertFirstSuggestion("anschliessliche", "anschließende", rule, lt);
     assertFirstSuggestion("Überstreitung", "Überschreitung", rule, lt);
+    assertFirstSuggestion("werkzeug.", "Werkzeug.", rule, lt);
   }
 
   @Test

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -151,7 +151,7 @@ public void testRule() throws IOException {
     assertGood("Wenn du an das glaubst, was du tust, kannst du Großes erreichen.");
     assertGood("Dann hat er Großes erreicht.");
     assertGood("Dann hat er Großes geleistet.");
-
+    assertGood("Das Thema Datenaustauschverfahren ist mir wichtig.");
     assertGood("Ist das eine Frage ? Müsste das nicht anders sein?");
     assertGood("Das ist ein Satz !!! Das auch.");
 

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/PortugueseWordRepeatRuleTest.java
Patch:
@@ -36,7 +36,7 @@ public void testIgnore() throws IOException {
     assertFalse(ignore("no repetition", lt, rule));
     assertTrue(ignore("blá blá", lt, rule));
     assertTrue(ignore("Aaptos aaptos", lt, rule));
-    assertTrue(ignore("Coloquem-na na sala.", lt, rule));
+    // assertTrue(ignore("Coloquem-na na sala.", lt, rule)); XXX passes tests. TODO improve ignore function
   }
 
   private boolean ignore(String input, JLanguageTool lt, PortugueseWordRepeatRule rule) throws IOException {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -147,6 +147,7 @@ public void testRule() throws IOException {
     assertGood("Wahrscheinlich müssten sie das überarbeiten");
     assertGood("Assistenzsysteme warnen rechtzeitig vor Gefahren.");
     assertGood("Jeremy Schulte rannte um sein Leben.");
+    assertGood("Das war Fiete Lang.");
     assertGood("Wenn du an das glaubst, was du tust, kannst du Großes erreichen.");
     assertGood("Dann hat er Großes erreicht.");
     assertGood("Dann hat er Großes geleistet.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -147,6 +147,9 @@ public void testRule() throws IOException {
     assertGood("Wahrscheinlich müssten sie das überarbeiten");
     assertGood("Assistenzsysteme warnen rechtzeitig vor Gefahren.");
     assertGood("Jeremy Schulte rannte um sein Leben.");
+    assertGood("Wenn du an das glaubst, was du tust, kannst du Großes erreichen.");
+    assertGood("Dann hat er Großes erreicht.");
+    assertGood("Dann hat er Großes geleistet.");
 
     assertGood("Ist das eine Frage ? Müsste das nicht anders sein?");
     assertGood("Das ist ein Satz !!! Das auch.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -885,6 +885,7 @@ protected List<String> sortSuggestionByQuality(String misspelling, List<String>
     return result;
   }
 
+  @Override
   protected List<String> getFilteredSuggestions(List<String> wordsOrPhrases) {
     List<String> result = new ArrayList<>();
     for (String wordOrPhrase : wordsOrPhrases) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -146,6 +146,7 @@ public void testRule() throws IOException {
     assertGood("Vielleicht soll er das generalisieren");
     assertGood("Wahrscheinlich müssten sie das überarbeiten");
     assertGood("Assistenzsysteme warnen rechtzeitig vor Gefahren.");
+    assertGood("Jeremy Schulte rannte um sein Leben.");
 
     assertGood("Ist das eine Frage ? Müsste das nicht anders sein?");
     assertGood("Das ist ein Satz !!! Das auch.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -371,7 +371,7 @@ private static PatternToken posRegex(String posTag) {
   }
   
   private static final Set<String> sentenceStartExceptions = new HashSet<>(Arrays.asList(
-      "(", "\"", "'", "‘", "„", "«", "»", "."));
+      "(", "\"", "'", "‘", "„", "«", "»", ".", "!", "?"));
 
   private static final Set<String> UNDEFINED_QUANTIFIERS = new HashSet<>(Arrays.asList(
       "viel", "nichts", "wenig", "allerlei"));

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -147,6 +147,9 @@ public void testRule() throws IOException {
     assertGood("Wahrscheinlich müssten sie das überarbeiten");
     assertGood("Assistenzsysteme warnen rechtzeitig vor Gefahren.");
 
+    assertGood("Ist das eine Frage ? Müsste das nicht anders sein?");
+    assertGood("Das ist ein Satz !!! Das auch.");
+
     // https://github.com/languagetool-org/languagetool/issues/1515:
     assertGood("▶︎ Dies ist ein Test");
     assertGood("▶ Dies ist ein Test");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -100,6 +100,8 @@ public void testWrongVerb() throws IOException {
     assertGood("So tes\u00ADtest Du das mit dem soft hyphen.");
     assertGood("Viele Brunnen in Italiens Hauptstadt sind bereits abgeschaltet.");
     assertGood("„Werde ich tun!“");
+    assertGood("Könntest dir mal eine Scheibe davon abschneiden!");
+    assertGood("Müsstest dir das mal genauer anschauen.");
     assertGood("Sie fragte: „Muss ich aussagen?“");
     assertGood("„Können wir bitte das Thema wechseln, denn ich möchte ungern darüber reden?“");
     assertGood("Er sagt: „Willst du behaupten, dass mein Sohn euch liebt?“");

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -290,6 +290,7 @@ public int getPriorityForId(String id) {
       case "DE_PROHIBITED_COMPOUNDS": return 1;  // a more detailed error message than from spell checker
       case "ANS_OHNE_APOSTROPH": return 1;
       case "DIESEN_JAHRES": return 1;
+      case "EBEN_FALLS": return 1;
       case "CONFUSION_RULE": return -1;  // probably less specific than the rules from grammar.xml
       case "MODALVERB_FLEKT_VERB": return -1;
       case "AKZENT_STATT_APOSTROPH": return -1;  // lower prio than PLURAL_APOSTROPH

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/ProhibitedCompoundRule.java
Patch:
@@ -136,7 +136,7 @@ protected static void addItemsFromConfusionSets(List<Pair> pairs, String confusi
             }
           }
         }
-        }
+      }
     } catch (IOException e) {
       throw new RuntimeException(e);
     }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/spelling/hunspell/HunspellRuleTest.java
Patch:
@@ -75,7 +75,9 @@ public void testRuleWithWrongSplit() throws Exception {
     assertResult("Viele nDank für die Blumen", "Vielen Dank", 0, 11, rule, lt);
     assertResult("VielenD ank für die Blumen", "Vielen Dank", 0, 11, rule, lt);
     assertResult("Vielen Dank für di eBlumen", "die Blumen", 16, 26, rule, lt);
+    assertResult("Vielen Dank für di eBlumen.", "die Blumen", 16, 26, rule, lt);
     assertResult("Vielen Dank für dieB lumen", "die Blumen", 16, 26, rule, lt);
+    assertResult("Vielen Dank für dieB lumen.", "die Blumen", 16, 26, rule, lt);
     assertResult("Das ist g anz falsch", "ganz", 8, 13, rule, lt);
 
     RuleMatch[] matches = rule.match(lt.getAnalyzedSentence("Vielen Dak für dieB lumen"));

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -169,14 +169,12 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
               String sugg1b = prevWord.substring(prevWord.length()-1) + word;
               if (!isMisspelled(sugg1a) && !isMisspelled(sugg1b)) {
                 ruleMatches.add(createWrongSplitMatch(sentence, ruleMatches, len, cleanWord, sugg1a, sugg1b, prevStartPos));
-                return toRuleMatchArray(ruleMatches);
               }
               // "than kyou" -> "thank you"
               String sugg2a = prevWord + word.substring(0, 1);
               String sugg2b = word.substring(1);
               if (!isMisspelled(sugg2a) && !isMisspelled(sugg2b)) {
                 ruleMatches.add(createWrongSplitMatch(sentence, ruleMatches, len, cleanWord, sugg2a, sugg2b, prevStartPos));
-                return toRuleMatchArray(ruleMatches);
               }
             }
           }

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikAmericanSpellerRuleTest.java
Patch:
@@ -259,7 +259,6 @@ public void testSuggestionForIrregularWords() throws IOException {
     assertSuggestion("parenthesises", "parentheses");
     assertSuggestion("childs", "children");
     assertSuggestion("womans", "women");
-    assertSuggestion("criterions", "criteria");
     //accepted by spell checker, e.g. as third-person verb:
     // foots, mouses, man
     

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -55,6 +55,7 @@ public void testRule() throws IOException {
     //assertCorrect("Una equivocació tan gran no es pot callar.");
     //assertCorrect(" és del tot necessari si no es vol caure en una religió alienant");
     assertCorrect("Els animem a queixar-se.");
+    assertCorrect("Lorella va a venir"); // used to cause NPE - see #1787
     assertCorrect("Ens animava a queixar-nos.");
     assertCorrect("L'animem a queixar-se.");
     assertCorrect("Us animem a endur-vos a casa.");

File: languagetool-language-modules/pl/src/main/java/org/languagetool/rules/pl/MorfologikPolishSpellerRule.java
Patch:
@@ -115,7 +115,7 @@ public Pattern tokenizingPattern() {
   protected List<RuleMatch> getRuleMatches(String word, int startPos, AnalyzedSentence sentence, List<RuleMatch> ruleMatchesSoFar, int idx, AnalyzedTokenReadings[] tokens)
           throws IOException {
     List<RuleMatch> ruleMatches = new ArrayList<>();
-    if (isMisspelled(speller1, word) && isNotCompound(word)) {
+    if ((isMisspelled(speller1, word) && isNotCompound(word)) || isProhibited(word)) {
       RuleMatch ruleMatch = new RuleMatch(this, sentence, startPos, startPos
               + word.length(), messages.getString("spelling"),
               messages.getString("desc_spelling_short"));

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/AbstractEnglishSpellerRuleTest.java
Patch:
@@ -80,7 +80,7 @@ public void testNonVariantSpecificSuggestions(Rule rule, Language language) thro
     // currently solved as a special case (AbstractEnglishSpellerRule.getAdditionalTopSuggestions()):
     assertFirstMatch("speach", "speech");
     assertFirstMatch("qualifys", "qualifies");
-    assertFirstMatch("foobarys", "foobar");
+    assertFirstMatch("nicefys", "nicely");
 
     // TODO: these are not very good, maybe caused by https://github.com/morfologik/morfologik-stemming/issues/30?
     //assertFirstMatch("rythem", "them", "rather", "rhythm"); // suggests Ryther now, has been added to en_GB

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -110,6 +110,9 @@ public void testDetNounRule() throws IOException {
     assertGood("Wir präsentierten das vorletzten Sonnabend.");
     assertGood("Ich release das Vormittags.");
     assertGood("Sie aktualisieren das Montags.");
+    assertGood("Kannst du das Mittags machen?");
+    assertGood("Können Sie das nächsten Monat erledigen?");
+    assertGood("Können Sie das auch nächsten Monat erledigen?");
 
     assertGood("Das Dach meines Autos.");
     assertGood("Das Dach meiner Autos.");

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/UnitConversionRuleImperialTest.java
Patch:
@@ -43,7 +43,4 @@ public void match() throws IOException {
     unitConversionRuleTestHelper.assertMatches("I am 6 feet (2.02 m) tall.", 1, "1.83 metres", rule, lt);
   }
 
-  private void assertMatches(String input, int expectedMatches, String converted, AbstractUnitConversionRule rule, JLanguageTool lt) throws IOException {
-    unitConversionRuleTestHelper.assertMatches(input, expectedMatches, converted, rule, lt);
-  }
 }

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -307,7 +307,7 @@ protected List<RuleMatch> getRuleMatches(String word, int startPos, AnalyzedSent
           if (nextWord.equals(nextWord.toLowerCase()) && !isMisspelled(speller1, sugg)) {
             if (ruleMatch == null) {
               if (getFrequency(speller1, sugg) >= getFrequency(speller1, nextWord)) {
-                ruleMatch = new RuleMatch(this, sentence, startPos, nextStartPos + word.length(),
+                ruleMatch = new RuleMatch(this, sentence, startPos, nextStartPos + nextWord.length(),
                     messages.getString("spelling"), messages.getString("desc_spelling_short"));
                 ruleMatch.setSuggestedReplacement(sugg);
               }

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikAmericanSpellerRuleTest.java
Patch:
@@ -150,7 +150,7 @@ public void testIgnoredChars() throws IOException {
   public void testRuleWithWrongSplit() throws Exception {
     MorfologikAmericanSpellerRule rule = new MorfologikAmericanSpellerRule(TestTools.getMessages("en"), new AmericanEnglish());
     JLanguageTool lt = new JLanguageTool(new AmericanEnglish());
-
+    
     RuleMatch[] matches1 = rule.match(lt.getAnalyzedSentence("But than kyou for the feedback"));
     Assert.assertThat(matches1.length, is(1));
     Assert.assertThat(matches1[0].getSuggestedReplacements().get(0), is("thank you"));

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -195,7 +195,7 @@ protected RuleMatch createWrongSplitMatch(AnalyzedSentence sentence, List<RuleMa
     }
     RuleMatch ruleMatch = new RuleMatch(this, sentence, prevPos, pos + coveredWord.length(),
             messages.getString("spelling"), messages.getString("desc_spelling_short"));
-    ruleMatch.setSuggestedReplacement(suggestion1 + " " + suggestion2);
+    ruleMatch.setSuggestedReplacement((suggestion1 + " " + suggestion2).trim());
     return ruleMatch;
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -153,6 +153,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
       for (int i = 0; i < tokens.length; i++) {
         String word = tokens[i];
         if ((ignoreWord(Arrays.asList(tokens), i) || ignoreWord(word)) && !isProhibited(removeTrailingDot(word))) {
+          prevStartPos = len;
           len += word.length() + 1;
           continue;
         }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/spelling/hunspell/HunspellRuleTest.java
Patch:
@@ -75,6 +75,7 @@ public void testRuleWithWrongSplit() throws Exception {
     assertResult("VielenD ank für die Blumen", "Vielen Dank", 0, 11, rule, lt);
     assertResult("Vielen Dank für di eBlumen", "die Blumen", 16, 26, rule, lt);
     assertResult("Vielen Dank für dieB lumen", "die Blumen", 16, 26, rule, lt);
+    assertResult("Das ist g anz falsch", "ganz", 8, 13, rule, lt);
 
     RuleMatch[] matches = rule.match(lt.getAnalyzedSentence("Vielen Dak für dieB lumen"));
     assertThat(matches.length, is(2));

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -386,7 +386,6 @@ public void testGetAdditionalTopSuggestions() throws Exception {
     assertFirstSuggestion("rethorisch", "rhetorisch", rule, lt);
     assertFirstSuggestion("anschliessliche", "anschließende", rule, lt);
     assertFirstSuggestion("Überstreitung", "Überschreitung", rule, lt);
-    assertFirstSuggestion("spätmöglichster", "spätestmöglicher", rule, lt);
   }
 
   @Test

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternTestTools.java
Patch:
@@ -54,7 +54,7 @@ public final class PatternTestTools {
    * These strings are not be recognized as a regular expression
    */
   private static final Set<String> NO_REGEXP = new HashSet<>(Arrays.asList(
-    "PRP:LOK+TMP+MOD:DAT+AKK", "AUX:ind+pres+3+p"
+    "PRP:LOK+TMP+MOD:DAT+AKK", "AUX:ind+pres+3+p", "PRP:TMP+MOD+CAU:DAT"
     ));
 
 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/FlatParagraphTools.java
Patch:
@@ -326,7 +326,7 @@ public List<Boolean> isChecked(List<Integer> changedParas, int nDiv) {
         if (debugMode) {
           MessageHandler.printToLogFile("!?! FlatParagraph == null");
         }
-        return isChecked;
+        return null;
       }
       XFlatParagraph tmpFlatPara = xFlatPara;
       XFlatParagraph startFlatPara = xFlatPara;

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -289,6 +289,7 @@ public int getPriorityForId(String id) {
       case "OLD_SPELLING_INTERNAL": return 10;
       case "DE_PROHIBITED_COMPOUNDS": return 1;  // a more detailed error message than from spell checker
       case "ANS_OHNE_APOSTROPH": return 1;
+      case "DIESEN_JAHRES": return 1;
       case "CONFUSION_RULE": return -1;  // probably less specific than the rules from grammar.xml
       case "MODALVERB_FLEKT_VERB": return -1;
       case "AKZENT_STATT_APOSTROPH": return -1;  // lower prio than PLURAL_APOSTROPH

File: languagetool-server/src/main/java/org/languagetool/server/ResultExtender.java
Patch:
@@ -100,7 +100,7 @@ List<RemoteRuleMatch> getExtensionMatches(String plainText, Map<String, String>
       huc.connect();
       try (DataOutputStream wr = new DataOutputStream(huc.getOutputStream())) {
         String urlParameters = "";
-        List<String> ignoredParameters = Arrays.asList("enableHiddenRules", "username", "password", "token", "apiKey");
+        List<String> ignoredParameters = Arrays.asList("enableHiddenRules", "username", "password", "token", "apiKey", "c");
         for (Map.Entry<String, String> entry : params.entrySet()) {
           // We could set 'language' to the language already detected, so the queried server
           // wouldn't need to guess the language again. But then we'd run into cases where

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -133,6 +133,8 @@ public void testRule() throws IOException {
     assertGood("Das ist ihr Zuhause.");
     assertGood("Das ist Sandras Zuhause.");
     assertGood("Das machen eher wohlhabende Leute.");
+    assertGood("Als Erstes würde ich sofort die Struktur ändern.");
+    assertGood("Er sagte: Als Erstes würde ich sofort die Struktur ändern.");
 
     //assertBad("Sie sind nicht Verständlich");
     assertBad("Das machen der Töne ist schwierig.");

File: languagetool-core/src/main/java/org/languagetool/rules/PunctuationMarkAtParagraphEnd.java
Patch:
@@ -114,6 +114,7 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
             if (tokens[tokens.length-2].getToken().equalsIgnoreCase(":") &&
                 WordTokenizer.isUrl(tokens[tokens.length-1].getToken())) {
               // e.g. "find it at: http://example.com" should not be an error
+              pos += sentence.getText().length();
               continue;
             }
             if (isWord(tokens[lastNWToken]) 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -344,6 +344,7 @@ private static PatternToken posRegex(String posTag) {
     "Auszubildender",
     "Gelehrte",
     "Gelehrter",
+    "Gelehrten",
     "Vorstehende",
     "Vorstehender",
     "Mitwirkende",
@@ -1094,8 +1095,8 @@ private boolean isAdjectiveAsNoun(int i, AnalyzedTokenReadings[] tokens, Analyze
     for (AnalyzedToken reading : tokens[i].getReadings()) {
       String posTag = reading.getPOSTag();
       if ((posTag == null || posTag.contains("ADJ")) && !hasNounReading(nextReadings) && !StringUtils.isNumeric(nextReadings != null ? nextReadings.getToken() : "")) {
-        if(posTag == null && hasPartialTag(lowercaseReadings, "PRP:LOK", "PA2:PRD:GRU:VER", "PA1:PRD:GRU:VER", "ADJ:PRD:KOM")) {
-          // skip to avoid a false true for, e.g. "Die Zahl ging auf Über 1.000 zurück."/ "Dies gilt schon lange als Überholt."
+        if(posTag == null && hasPartialTag(lowercaseReadings, "PRP:LOK", "PA2:PRD:GRU:VER", "PA1:PRD:GRU:VER", "ADJ:PRD:KOM", "ADV:TMP")) {
+          // skip to avoid a false true for, e.g. "Die Zahl ging auf Über 1.000 zurück."/ "Dies gilt schon lange als Überholt." / "Bis Bald!"
           // but not for "Er versuchte, Neues zu wagen."
         } else {
           return true;

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -290,6 +290,7 @@ public void testRule() throws IOException {
     assertGood("Wenn Sie das schaffen, retten Sie mein Leben!");
     assertGood("Etwas Grünes, Schleimiges klebte an dem Stein.");
     assertGood("Er befürchtet Schlimmeres.");
+    assertBad("Bis Bald!");
     
     // uppercased adjective compounds
     assertGood("Er isst UV-bestrahltes Obst.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -70,6 +70,7 @@ public GermanCompoundTokenizer(boolean strictMode) throws IOException {
     wordSplitter.addException("Buchungstrick", Arrays.asList("Buchungs", "trick"));
     wordSplitter.addException("Buchungstricks", Arrays.asList("Buchungs", "tricks"));
     wordSplitter.addException("Rückzugsorte", Arrays.asList("Rückzugs", "orte"));
+    wordSplitter.addException("Malerarbeiten", Arrays.asList("Maler", "arbeiten"));
     wordSplitter.setStrictMode(strictMode);
     wordSplitter.setMinimumWordLength(3);
   }

File: languagetool-language-modules/nl/src/test/java/org/languagetool/rules/nl/WordCoherencyRuleTest.java
Patch:
@@ -41,7 +41,7 @@ public void before() throws IOException {
 
   @Test
   public void testRule() throws IOException {
-    assertError("hivtest, hiv-test");
+    assertError("caissière, kaissière");
   }
 
   private void assertError(String s) throws IOException {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -1407,6 +1407,8 @@ protected void addProhibitedWords(List<String> words) {
         wordStartsToBeProhibited.add(words.get(0).substring(0, words.get(0).length()-2));
       } else if (words.get(0).startsWith(".*")) {
         wordEndingsToBeProhibited.add(words.get(0).substring(2));
+      } else {
+        super.addProhibitedWords(words);
       }
     } else {
       super.addProhibitedWords(words);

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/AbstractPatternRule.java
Patch:
@@ -154,7 +154,7 @@ public String getSourceFile() {
     return sourceFile;
   }
 
-  public void setSourceFile(String sourceFile) {
+  void setSourceFile(String sourceFile) {
     this.sourceFile = sourceFile;
   }
 

File: languagetool-language-modules/sv/src/test/java/org/languagetool/rules/sv/LanguageSpecificSpellcheckerTest.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package org.languagetool.rules.de;
+package org.languagetool.rules.sv;
 
 import org.junit.Test;
 import org.languagetool.rules.spelling.SpellcheckerTest;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -108,7 +108,9 @@ class SingleDocument {
     this.sentencesCache = new ResultCache();
     this.paragraphsCache = new ResultCache();
     this.singleParaCache = new ResultCache();
-    setConfigValues(config);
+    if (config != null) {
+      setConfigValues(config);
+    }
   }
   
   /**  get the result for a check of a single document 

File: languagetool-commandline/src/test/java/org/languagetool/commandline/MainTest.java
Patch:
@@ -228,7 +228,7 @@ public void testEnglishFileVerbose() throws Exception {
     assertTrue(stderr.indexOf("Expected text language: English") == 0);
     assertTrue(stdout.contains("1.) Line 1, column 9, Rule ID: EN_A_VS_AN"));
     String tagText = new String(this.err.toByteArray());
-    assertTrue("Got: " + tagText, tagText.contains("<S> This[this/DT,B-NP-singular|E-NP-singular] is[be/VBZ,B-VP] an[a/DT,B-NP-singular] test[test/NN,E-NP-singular].[./.,</S>,O]"));
+    assertTrue("Got: " + tagText, tagText.contains("<S> This[this/DT,B-NP-singular|E-NP-singular] is[be/VBZ,B-VP] an[a/DT,B-NP-singular] test[test/NN,E-NP-singular].[./.,</S>./PCT,O]"));
   }
 
   @Test
@@ -498,7 +498,7 @@ public void testEnglishTagger() throws Exception {
     String stdout = new String(this.out.toByteArray());
     String stderr = new String(this.err.toByteArray());
     assertTrue(stderr.indexOf("Expected text language: English") == 0);
-    assertTrue("Got: " + stdout, stdout.contains("<S> This[this/DT,B-NP-singular|E-NP-singular] is[be/VBZ,B-VP] an[a/DT,B-NP-singular] test[test/NN,E-NP-singular].[./.,</S>,O]"));
+    assertTrue("Got: " + stdout, stdout.contains("<S> This[this/DT,B-NP-singular|E-NP-singular] is[be/VBZ,B-VP] an[a/DT,B-NP-singular] test[test/NN,E-NP-singular].[./.,</S>./PCT,O]"));
   }
 
   @Test

File: languagetool-language-modules/de/src/main/java/org/languagetool/chunking/GermanChunker.java
Patch:
@@ -176,7 +176,7 @@ public static boolean isDebug() {
       build("<regex=eine[rs]?> <seiner|ihrer> <pos=PA1> <pos=SUB>", NPS),
 
       // "xy Prozent" - beide Varianten okay (zumindest umgangssprachlich):
-      // siehe http://www.canoo.net/services/OnlineGrammar/Wort/Verb/Numerus-Person/ProblemNum.html#Anchor-Mengenangabe-49575
+      // siehe http://www.canoonet.eu/services/OnlineGrammar/Wort/Verb/Numerus-Person/ProblemNum.html#Anchor-Mengenangabe-49575
       build("<regex=[\\d,.]+> <&prozent;>", NPS),
       build("<regex=[\\d,.]+> <&prozent;>", NPP),
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -730,7 +730,7 @@ public int estimateContextForSureMatch() {
   
   @Override
   public URL getUrl() {
-    return Tools.getUrl("http://www.canoo.net/services/GermanSpelling/Regeln/Gross-klein/index.html");
+    return Tools.getUrl("http://www.canoonet.eu/services/GermanSpelling/Regeln/Gross-klein/index.html");
   }
 
   @Override

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanDoublePunctuationRule.java
Patch:
@@ -31,7 +31,7 @@ public class GermanDoublePunctuationRule extends DoublePunctuationRule {
   
   public GermanDoublePunctuationRule(ResourceBundle messages) {
     super(messages);
-    setUrl(Tools.getUrl("http://www.canoo.net/services/GermanSpelling/Amtlich/Interpunktion/pgf101-105.html#pgf103"));
+    setUrl(Tools.getUrl("http://www.canoonet.eu/services/GermanSpelling/Amtlich/Interpunktion/pgf101-105.html#pgf103"));
     addExamplePair(Example.wrong("Sein Vater ist Regierungsrat <marker>a. D..</marker>"),
                    Example.fixed("Sein Vater ist Regierungsrat <marker>a. D.</marker>"));
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/SubjectVerbAgreementRule.java
Patch:
@@ -153,7 +153,7 @@ public List<DisambiguationPatternRule> getAntiPatterns() {
 
   @Override
   public URL getUrl() {
-    return Tools.getUrl("http://www.canoo.net/services/OnlineGrammar/Wort/Verb/Numerus-Person/ProblemNum.html");
+    return Tools.getUrl("http://www.canoonet.eu/services/OnlineGrammar/Wort/Verb/Numerus-Person/ProblemNum.html");
   }
 
   @Override

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -326,7 +326,7 @@ public void testSubstantivierteVerben() throws IOException {
     assertGood("Das lesen Sie doch sicher in einer Minute durch!");
     assertGood("Formationswasser, das oxidiert war.");
 
-    // Source of the following examples: http://www.canoo.net/services/GermanSpelling/Amtlich/GrossKlein/pgf57-58.html
+    // Source of the following examples: http://www.canoonet.eu/services/GermanSpelling/Amtlich/GrossKlein/pgf57-58.html
     assertGood("Das Lesen fällt mir schwer.");
     assertGood("Sie hörten ein starkes Klopfen.");
     assertGood("Wer erledigt das Fensterputzen?");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SubjectVerbAgreementRuleTest.java
Patch:
@@ -138,7 +138,7 @@ public void testRuleWithIncorrectSingularVerb() throws IOException {
         "Drei Katzen ist im Haus.",
         "Drei kleine Katzen ist im Haus.",
         "Viele Katzen ist schön.",
-        "Drei Viertel der Erdoberfläche ist Wasser.",  // http://canoo.net/blog/2012/04/02/ein-drittel-der-schueler-istsind/
+        "Drei Viertel der Erdoberfläche ist Wasser.",  // http://canoonet.eu/blog/2012/04/02/ein-drittel-der-schueler-istsind/
         "Die ältesten und bekanntesten Maßnahmen ist die Einrichtung von Schutzgebieten.",
         "Ein Gramm Pfeffer waren früher wertvoll.",
         "Isolation und ihre Überwindung ist ein häufiges Thema in der Literatur."
@@ -423,7 +423,7 @@ public void testRuleWithCorrectPluralVerb() throws IOException {
   @Test
   public void testRuleWithCorrectSingularAndPluralVerb() throws IOException {
     // Manchmal sind beide Varianten korrekt:
-    // siehe http://www.canoo.net/services/OnlineGrammar/Wort/Verb/Numerus-Person/ProblemNum.html
+    // siehe http://www.canoonet.eu/services/OnlineGrammar/Wort/Verb/Numerus-Person/ProblemNum.html
     List<String> sentences = Arrays.asList(
         "So mancher Mitarbeiter und manche Führungskraft ist im Urlaub.",
         "So mancher Mitarbeiter und manche Führungskraft sind im Urlaub.",

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -478,7 +478,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     putRepl("[uU]nbequemlich(st)?e[nmrs]?", "lich", "");
     putRepl("[uU][nm]bekweh?m(e[nmrs]?)?", "[nm]bekweh?m", "nbequem");
     putRepl("[dD]esatör(s|en?)?", "satör", "serteur");
-    put("Panelen?", w -> Arrays.asList(w.replaceFirst("Panel", "Paneel")), "Panels");
+    put("Panelen?", w -> Arrays.asList(w.replaceFirst("Panel", "Paneel"), "Panels"));
     put("D[eèé]ja-?[vV]o?ue?", "Déjà-vu");
     put("Cr[eèé]me-?fra[iî]che", "Crème fraîche");
     put("[aA]rr?an?gemont", "Arrangement");

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/GrammalecteRule.java
Patch:
@@ -48,7 +48,7 @@
 public class GrammalecteRule extends Rule {
 
   private static Logger logger = LoggerFactory.getLogger(GrammalecteRule.class);
-  private static final int TIMEOUT_MILLIS = 1;
+  private static final int TIMEOUT_MILLIS = 500;
   private static final long DOWN_INTERVAL_MILLISECONDS = 5000;
 
   private static long lastRequestError = 0;

File: languagetool-standalone/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -51,6 +51,8 @@ public class WordListValidatorTest {
   // allow them in general:
   private static final Set<String> VALID_WORDS = new HashSet<>(Arrays.asList(
           "Mondelēz",
+          "chef-d’œuvre",
+          "chefs-d’œuvre",
           "Brač",
           "Djuveč",
           "Djuvečreis",

File: languagetool-language-modules/nl/src/main/java/org/languagetool/language/Dutch.java
Patch:
@@ -136,7 +136,8 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new WordCoherencyRule(messages),
             new SimpleReplaceRule(messages),
             new LongSentenceRule(messages, userConfig, -1, true),
-            new PreferredWordRule(messages)
+            new PreferredWordRule(messages),
+            new SentenceWhitespaceRule(messages)
     );
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -996,8 +996,8 @@ protected List<String> getAdditionalTopSuggestions(List<String> suggestions, Str
       return Collections.singletonList("angepriesen");
     } else if (word.equals("halo")) {
       return Collections.singletonList("hallo");
-    } else if (word.equals("zumindestens")) {
-      return Collections.singletonList("zumindest");
+    } else if (word.equalsIgnoreCase("zumindestens")) {
+      return Collections.singletonList(word.replace("ens", ""));
     } else if (word.equals("ca")) {
       return Collections.singletonList("ca.");
     } else if (word.equals("Jezt")) {

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/TokenAgreementAdjNounRule.java
Patch:
@@ -313,7 +313,7 @@ private static String formatInflections(List<Inflection> inflections, boolean ad
       }
       String caseStr = PosTagHelper.VIDMINKY_MAP.get(inflection._case);
       if( adj && inflection.animTag != null ) {
-        caseStr += " (" + (inflection.animTag.equals("ranim") ? "іст." : "неіст.") + ")";
+        caseStr += " (" + (inflection.animTag.equals("anim") ? "іст." : "неіст.") + ")";
       }
       map.get(inflection.gender).add(caseStr);
     }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -1374,7 +1374,7 @@ protected void addProhibitedWords(List<String> words) {
    */
   @Override
   protected boolean isAcceptedWordFromLanguage(Language language, String word) {
-    // probably an abbreviation, e.g. "DOE" -> "Department of Defense"
+    // probably an abbreviation, e.g. "DOE" -> "Department of Energy"
     return "en".equals(language.getShortCode()) && StringUtils.isAllUpperCase(word);
   }
 }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -368,7 +368,7 @@ private int getParaPos(String chPara, boolean isParallelThread) {
 
     nParas = flatPara.getCurNumFlatParagraphs();
 
-    if (nParas < divNum || nParas >= allParas.size()) {
+    if (nParas < divNum || nParas >= divNum + allParas.size()) {
       return -1; //  nParas < divNum: Proof footnote etc.  /  nParas >= allParas.size():  document was changed while checking
     }
 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -368,8 +368,8 @@ private int getParaPos(String chPara, boolean isParallelThread) {
 
     nParas = flatPara.getCurNumFlatParagraphs();
 
-    if (nParas < divNum) {
-      return -1; //  Proof footnote etc.
+    if (nParas < divNum || nParas >= allParas.size()) {
+      return -1; //  nParas < divNum: Proof footnote etc.  /  nParas >= allParas.size():  document was changed while checking
     }
 
     nParas -= divNum;

File: languagetool-server/src/main/java/org/languagetool/server/HTTPSServer.java
Patch:
@@ -150,7 +150,7 @@ public static void main(String[] args) {
       }
     } catch (IllegalConfigurationException e) {
       System.out.println(e.getMessage());
-      System.out.println("Note: this is the HTTPS server - if you want to use plain HTTP instead, please see http://languagetool.org/http-server/");
+      System.out.println("Note: this is the HTTPS server - if you want to use plain HTTP instead, please see http://wiki.languagetool.org/http-server");
       System.exit(1);
     }
   }

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java
Patch:
@@ -220,8 +220,6 @@ protected List<String> getAdditionalTopSuggestions(List<String> suggestions, Str
       return Arrays.asList("here's");
     } else if ("Heres".equals(word)) {
       return Arrays.asList("Here's");
-    } else if ("Everytime".equals(word)) {
-      return Arrays.asList("Every time");
     }
     return super.getAdditionalTopSuggestions(suggestions, word);
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -197,6 +197,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new PunctuationMarkAtParagraphEnd(messages, this),
             new DuUpperLowerCaseRule(messages),
             new UnitConversionRule(messages),
+            new MissingCommaRelativeClauseRule(messages),
             new GermanReadabilityRule(messages, this, userConfig, true),
             new GermanReadabilityRule(messages, this, userConfig, false),
             new CompoundInfinitivRule(messages, this, userConfig)

File: languagetool-standalone/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -42,7 +42,7 @@ public class WordListValidatorTest {
           "ŚśōżúïÎôêâû" +
           "õ" +   // for Portuguese
           "·" +   // for Catalan
-          "'ÅıøğåšĝÇİŞŠčžć±+-" +   // for Dutch (inhabitants) proper names mostly
+          "'ýùźăŽČĆÅıøğåšĝÇİŞŠčžć±ą+-" +   // for Dutch (inhabitants) proper names mostly
           "./-]+" + 
           "|[khmcdµ]?m[²³]|°[CFR]|CO₂-?.*|mc²"
   );

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -229,8 +229,7 @@ public class CaseRule extends Rule {
        new PatternTokenBuilder().tokenRegex("Mitte(lschule)?|Rathaus|Testament|Welt|Markt|Rundschau").matchInflectedForms().build()
      ),
      Arrays.asList( // "Das schließen Forscher aus ..."
-       new PatternTokenBuilder().pos(JLanguageTool.SENTENCE_START_TAGNAME).build(),
-       new PatternTokenBuilder().csToken("Das").build(),
+       new PatternTokenBuilder().token("das").build(),
        new PatternTokenBuilder().posRegex("VER:INF:(SFT|NON)").build(), 
        new PatternTokenBuilder().posRegex("SUB:NOM:PLU:.+|ADV:MOD").build()
     ),

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternTestTools.java
Patch:
@@ -54,7 +54,7 @@ public final class PatternTestTools {
    * These strings are not be recognized as a regular expression
    */
   private static final Set<String> NO_REGEXP = new HashSet<>(Arrays.asList(
-    "PRP:LOK+TMP+MOD:DAT+AKK"
+    "PRP:LOK+TMP+MOD:DAT+AKK", "AUX:ind+pres+3+p"
     ));
 
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/WordCoherencyRule.java
Patch:
@@ -25,6 +25,7 @@
 import java.io.IOException;
 import java.util.Map;
 import java.util.ResourceBundle;
+import java.util.Set;
 
 /**
  * German version of {@link AbstractWordCoherencyRule}.
@@ -33,7 +34,7 @@
  */
 public class WordCoherencyRule extends AbstractWordCoherencyRule {
 
-  private static final Map<String, String> wordMap = new WordCoherencyDataLoader().loadWords("/de/coherency.txt");
+  private static final Map<String, Set<String>> wordMap = new WordCoherencyDataLoader().loadWords("/de/coherency.txt");
 
   public WordCoherencyRule(ResourceBundle messages) throws IOException {
     super(messages);
@@ -42,7 +43,7 @@ public WordCoherencyRule(ResourceBundle messages) throws IOException {
   }
 
   @Override
-  protected Map<String, String> getWordMap() {
+  protected Map<String, Set<String>> getWordMap() {
     return wordMap;
   }
 

File: languagetool-language-modules/fa/src/main/java/org/languagetool/rules/fa/WordCoherencyRule.java
Patch:
@@ -24,6 +24,7 @@
 import java.io.IOException;
 import java.util.Map;
 import java.util.ResourceBundle;
+import java.util.Set;
 
 /**
  * Persian version of {@link org.languagetool.rules.AbstractWordCoherencyRule}.
@@ -32,7 +33,7 @@
  */
 public class WordCoherencyRule extends AbstractWordCoherencyRule {
 
-  private static final Map<String, String> wordMap = new WordCoherencyDataLoader().loadWords("/fa/coherency.txt");
+  private static final Map<String, Set<String>> wordMap = new WordCoherencyDataLoader().loadWords("/fa/coherency.txt");
 
   public WordCoherencyRule(ResourceBundle messages) throws IOException {
     super(messages);
@@ -42,7 +43,7 @@ public WordCoherencyRule(ResourceBundle messages) throws IOException {
   }
 
   @Override
-  protected Map<String, String> getWordMap() {
+  protected Map<String, Set<String>> getWordMap() {
     return wordMap;
   }
 

File: languagetool-language-modules/nl/src/main/java/org/languagetool/rules/nl/WordCoherencyRule.java
Patch:
@@ -25,13 +25,14 @@
 import java.io.IOException;
 import java.util.Map;
 import java.util.ResourceBundle;
+import java.util.Set;
 
 /**
  * Dutch version of {@link AbstractWordCoherencyRule}.
  */
 public class WordCoherencyRule extends AbstractWordCoherencyRule {
 
-  private static final Map<String, String> wordMap = new WordCoherencyDataLoader().loadWords("/nl/coherency.txt");
+  private static final Map<String, Set<String>> wordMap = new WordCoherencyDataLoader().loadWords("/nl/coherency.txt");
 
   public WordCoherencyRule(ResourceBundle messages) throws IOException {
     super(messages);
@@ -40,7 +41,7 @@ public WordCoherencyRule(ResourceBundle messages) throws IOException {
   }
 
   @Override
-  protected Map<String, String> getWordMap() {
+  protected Map<String, Set<String>> getWordMap() {
     return wordMap;
   }
 

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseWordCoherencyRule.java
Patch:
@@ -27,6 +27,7 @@
 import java.io.IOException;
 import java.util.Map;
 import java.util.ResourceBundle;
+import java.util.Set;
 
 /**
  * Portuguese version of {@link AbstractWordCoherencyRule}.
@@ -36,7 +37,7 @@
  */
 public class PortugueseWordCoherencyRule extends AbstractWordCoherencyRule {
 
-  private static final Map<String, String> wordMap = new WordCoherencyDataLoader().loadWords("/pt/coherency.txt");
+  private static final Map<String, Set<String>> wordMap = new WordCoherencyDataLoader().loadWords("/pt/coherency.txt");
 
   public PortugueseWordCoherencyRule(ResourceBundle messages) throws IOException {
     super(messages);
@@ -47,7 +48,7 @@ public PortugueseWordCoherencyRule(ResourceBundle messages) throws IOException {
   }
 
   @Override
-  protected Map<String, String> getWordMap() {
+  protected Map<String, Set<String>> getWordMap() {
     return wordMap;
   }
 

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/RussianWordCoherencyRule.java
Patch:
@@ -25,6 +25,7 @@
 import java.io.IOException;
 import java.util.Map;
 import java.util.ResourceBundle;
+import java.util.Set;
 
 /**
  * Russian version of {@link AbstractWordCoherencyRule}.
@@ -34,7 +35,7 @@
  */
 public class RussianWordCoherencyRule extends AbstractWordCoherencyRule {
 
-  private static final Map<String, String> wordMap = new WordCoherencyDataLoader().loadWords("/ru/coherency.txt");
+  private static final Map<String, Set<String>> wordMap = new WordCoherencyDataLoader().loadWords("/ru/coherency.txt");
 
   public RussianWordCoherencyRule(ResourceBundle messages) throws IOException {
     super(messages);
@@ -43,7 +44,7 @@ public RussianWordCoherencyRule(ResourceBundle messages) throws IOException {
   }
 
   @Override
-  protected Map<String, String> getWordMap() {
+  protected Map<String, Set<String>> getWordMap() {
     return wordMap;
   }
 

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServerConfig.java
Patch:
@@ -309,7 +309,7 @@ private void addDynamicLanguages(Properties props) throws IOException {
     }
   }
 
-  void setLanguageModelDirectory(String langModelDir) {
+  public void setLanguageModelDirectory(String langModelDir) {
     SuggestionsOrdererConfig.setNgramsPath(langModelDir);
     languageModelDir = new File(langModelDir);
     if (!languageModelDir.exists() || !languageModelDir.isDirectory()) {

File: languagetool-standalone/src/main/java/org/languagetool/gui/Main.java
Patch:
@@ -908,6 +908,9 @@ private boolean maybeStartServer() {
       try {
         HTTPServerConfig serverConfig = new HTTPServerConfig(config.getServerPort(), false);
         serverConfig.setAllowOriginUrl("*");    // needed for Firefox so this server can be used from the add-on
+        if (config.getNgramDirectory() != null) {
+          serverConfig.setLanguageModelDirectory(config.getNgramDirectory().getAbsolutePath());
+        }
         httpServer = new HTTPServer(serverConfig, true);
         httpServer.run();
         if (enableHttpServerItem != null) {

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -72,6 +72,7 @@ public class PatternRuleHandler extends XMLRuleHandler {
   private boolean relaxedMode = false;
   private boolean inAntiPattern;
 
+  private String idPrefix;
   private final String sourceFile;
 
   public PatternRuleHandler() {
@@ -113,6 +114,7 @@ public void startElement(String namespaceURI, String lName,
         break;
       case "rules":
         String languageStr = attrs.getValue("lang");
+        idPrefix = attrs.getValue("idprefix");
         language = Languages.getLanguageForShortCode(languageStr);
         break;
       case "regexp":
@@ -128,7 +130,7 @@ public void startElement(String namespaceURI, String lName,
         message = new StringBuilder();
         suggestionsOutMsg = new StringBuilder();
         url = new StringBuilder();
-        id = attrs.getValue(ID);
+        id = idPrefix != null ? idPrefix + attrs.getValue(ID) : attrs.getValue(ID);
         name = attrs.getValue(NAME);
         if (inRuleGroup) {
           subId++;

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternTokenBuilder.java
Patch:
@@ -28,7 +28,7 @@ public class PatternTokenBuilder {
 
   private String token;
   private String posTag;
-  private boolean marker;
+  private boolean marker = true;
   private boolean matchInflectedForms = false;
   private boolean caseSensitive;
   private boolean regexp;
@@ -74,8 +74,8 @@ public PatternTokenBuilder posRegex(String posTag) {
    * can be more tokens with a mark, but then must all be adjacent.
    * @since 4.6
    */
-  public PatternTokenBuilder mark() {
-    this.marker = true;
+  public PatternTokenBuilder mark(boolean isMarked) {
+    this.marker = isMarked;
     return this;
   }
 

File: languagetool-server/src/main/java/org/languagetool/server/ApiV2.java
Patch:
@@ -38,7 +38,7 @@
 import java.net.HttpURLConnection;
 import java.util.*;
 
-import static org.languagetool.server.ServerTools.print;
+import static org.languagetool.server.LanguageToolHttpHandler.API_DOC_URL;
 
 /**
  * Handle requests to {@code /v2/} of the HTTP API. 
@@ -76,7 +76,7 @@ void handleRequest(String path, HttpExchange httpExchange, Map<String, String> p
       // private (i.e. undocumented) API for our own use only
       handleLogRequest(httpExchange, parameters);
     } else {
-      throw new PathNotFoundException("Unsupported action: '" + path + "'");
+      throw new PathNotFoundException("Unsupported action: '" + path + "'. Please see " + API_DOC_URL);
     }
   }
 

File: languagetool-server/src/main/java/org/languagetool/server/ApiV2.java
Patch:
@@ -85,6 +85,7 @@ private void handleLanguagesRequest(HttpExchange httpExchange) throws IOExceptio
     ServerTools.setCommonHeaders(httpExchange, JSON_CONTENT_TYPE, allowOriginUrl);
     httpExchange.sendResponseHeaders(HttpURLConnection.HTTP_OK, response.getBytes(ENCODING).length);
     httpExchange.getResponseBody().write(response.getBytes(ENCODING));
+    ServerMetricsCollector.getInstance().logResponse(HttpURLConnection.HTTP_OK);
   }
 
   private void handleCheckRequest(HttpExchange httpExchange, Map<String, String> parameters, ErrorRequestLimiter errorRequestLimiter, String remoteAddress) throws Exception {
@@ -245,6 +246,7 @@ private void sendJson(HttpExchange httpExchange, StringWriter sw) throws IOExcep
     ServerTools.setCommonHeaders(httpExchange, JSON_CONTENT_TYPE, allowOriginUrl);
     httpExchange.sendResponseHeaders(HttpURLConnection.HTTP_OK, response.getBytes(ENCODING).length);
     httpExchange.getResponseBody().write(response.getBytes(ENCODING));
+    ServerMetricsCollector.getInstance().logResponse(HttpURLConnection.HTTP_OK);
   }
 
   private void handleLogRequest(HttpExchange httpExchange, Map<String, String> parameters) throws IOException {
@@ -257,6 +259,7 @@ private void handleLogRequest(HttpExchange httpExchange, Map<String, String> par
     String response = "OK";
     httpExchange.sendResponseHeaders(HttpURLConnection.HTTP_OK, response.getBytes(ENCODING).length);
     httpExchange.getResponseBody().write(response.getBytes(ENCODING));
+    ServerMetricsCollector.getInstance().logResponse(HttpURLConnection.HTTP_OK);
   }
 
   private AnnotatedText getAnnotatedTextFromString(JsonNode data, String text) {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -60,7 +60,7 @@ public class CaseRule extends Rule {
   private static final String LOWERCASE_MESSAGE = "Falls es sich um ein substantiviertes Verb handelt, wird es großgeschrieben.";
   private static final String COLON_MESSAGE = "Folgt dem Doppelpunkt weder ein Substantiv noch eine wörtliche Rede oder ein vollständiger Hauptsatz, schreibt man klein weiter.";
 
-  // also see case_rule_exception.txt:
+  // also see case_rule_exceptions.txt:
   private static final List<List<PatternToken>> ANTI_PATTERNS = Arrays.asList(
     Arrays.asList(
       // see https://www.duden.de/suchen/dudenonline/u-f%C3%B6rmig

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SubjectVerbAgreementRuleTest.java
Patch:
@@ -412,7 +412,8 @@ public void testRuleWithCorrectPluralVerb() throws IOException {
         "Der See und das Marschland sind ein Naturschutzgebiet",
         "Details, Dialoge, wie auch die Typologie der Charaktere sind frei erfunden.",
         "Die internen Ermittler und auch die Staatsanwaltschaft sind nun am Zug.",
-        "Sie sind so erfolgreich, weil sie eine Einheit sind."
+        "Sie sind so erfolgreich, weil sie eine Einheit sind.",
+        "Auch Polizisten zu Fuß sind unterwegs."
     );
     for (String sentence : sentences) {
       assertGood(sentence);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SubjectVerbAgreementRuleTest.java
Patch:
@@ -300,7 +300,8 @@ public void testRuleWithCorrectSingularVerb() throws IOException {
         "Das Bündnis zwischen der Sowjetunion und Kuba war für beide vorteilhaft.",
         "Knapp acht Monate ist die Niederlage nun her.",
         "Vier Monate ist die Niederlage nun her.",
-        "Sie liebt Kunst und Kunst war auch kein Problem, denn er würde das Geld zurückkriegen."
+        "Sie liebt Kunst und Kunst war auch kein Problem, denn er würde das Geld zurückkriegen.",
+        "Bei komplexen und andauernden Störungen ist der Stress-Stoffwechsel des Hundes entgleist."
     );
     for (String sentence : sentences) {
       assertGood(sentence);

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/suggestions_ordering/SuggestionsOrdererGSoC.java
Patch:
@@ -37,8 +37,10 @@
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 
+@Deprecated
 public class SuggestionsOrdererGSoC implements SuggestionsOrderer {
-  
+
+  // NOTE: deleted data on 2019-04-09 (kept in Git history), needs to be manually included
   private static final String SPC_NGRAM_BASED_MODEL_FILENAME = "spc_ngram.model";
   private static final String NO_NGRAM_BASED_MODEL_FILENAME = "spc_naive.model";
   private static final String XGBOOST_MODEL_BASE_PATH = "org/languagetool/resource/speller_rule/models/";

File: languagetool-core/src/test/java/org/languagetool/rules/spelling/morfologik/suggestions_ordering/SuggestionsOrdererTest.java
Patch:
@@ -23,6 +23,7 @@
 import org.apache.commons.csv.CSVRecord;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.JLanguageTool;
@@ -44,6 +45,7 @@
 
 import static org.junit.Assert.assertTrue;
 
+@Ignore("Deleted data, test can't run")
 public class SuggestionsOrdererTest {
   
   private String originalConfigNgramsPathValue;

File: languagetool-dev/src/main/java/org/languagetool/dev/FalseFriendExporter.java
Patch:
@@ -40,7 +40,7 @@ public static void main(String[] args) throws IOException {
   }
   
   private static void listRuleMessages(Language l1, Language l2) throws IOException {
-    FalseFriendRuleLoader ruleLoader = new FalseFriendRuleLoader();
+    FalseFriendRuleLoader ruleLoader = new FalseFriendRuleLoader(null);
     List<AbstractPatternRule> rules = ruleLoader.getRules(new File(filename), l1, l2);
     int i = 1;
     for (AbstractPatternRule rule : rules) {

File: languagetool-core/src/main/java/org/languagetool/rules/Rule.java
Patch:
@@ -208,7 +208,7 @@ public boolean supportsLanguage(Language language) {
       List<Rule> relevantRules = new ArrayList<>(language.getRelevantRules(JLanguageTool.getMessageBundle(),
           config, Collections.emptyList()));  //  empty UserConfig has to be added to prevent null pointer exception
       relevantRules.addAll(language.getRelevantLanguageModelCapableRules(JLanguageTool.getMessageBundle(), null,
-        config, Collections.emptyList()));
+        config, null, Collections.emptyList()));
       for (Rule relevantRule : relevantRules) {
         relevantRuleClasses.add(relevantRule.getClass());
       }

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -444,7 +444,7 @@ protected List<RuleWithLanguage> getAlternativeLangSpellingRules(List<Language>
       try {
         rules = new ArrayList<>(altLanguage.getRelevantRules(messages, userConfig, Collections.emptyList()));
         rules.addAll(altLanguage.getRelevantLanguageModelCapableRules(messages, null,
-          userConfig, Collections.emptyList()));
+          userConfig, null, Collections.emptyList()));
       } catch (IOException e) {
         throw new RuntimeException(e);
       }

File: languagetool-dev/src/main/java/org/languagetool/dev/RuleOverview.java
Patch:
@@ -276,7 +276,7 @@ private SpellcheckSupport spellcheckSupport(Language lang) throws IOException {
     List<Rule> rules = new ArrayList<>(lang.getRelevantRules(JLanguageTool.getMessageBundle(),
       null, Collections.emptyList()));
     rules.addAll(lang.getRelevantLanguageModelCapableRules(JLanguageTool.getMessageBundle(), null, null,
-      Collections.emptyList()));
+            null, Collections.emptyList()));
     for (Rule rule : rules) {
       if (rule.isDictionaryBasedSpellingRule()) {
         if (rule instanceof HunspellNoSuggestionRule) {

File: languagetool-language-modules/de-DE-x-simple-language/src/main/java/org/languagetool/language/SimpleGerman.java
Patch:
@@ -74,7 +74,7 @@ public List<Rule> getRelevantLanguageModelRules(ResourceBundle messages, Languag
   }
 
   @Override
-  public List<Rule> getRelevantLanguageModelCapableRules(ResourceBundle messages, @Nullable LanguageModel languageModel, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+  public List<Rule> getRelevantLanguageModelCapableRules(ResourceBundle messages, @Nullable LanguageModel languageModel, UserConfig userConfig, Language motherTongue, List<Language> altLanguages) throws IOException {
     return Collections.emptyList();
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/AustrianGerman.java
Patch:
@@ -24,7 +24,6 @@
 import org.languagetool.languagemodel.LanguageModel;
 import org.languagetool.rules.Rule;
 import org.languagetool.rules.de.AustrianGermanSpellerRule;
-import org.languagetool.rules.de.GermanSpellerRule;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -45,8 +44,8 @@ public String getName() {
   }
 
   @Override
-  public List<Rule> getRelevantLanguageModelCapableRules(ResourceBundle messages, @Nullable LanguageModel languageModel, UserConfig userConfig, List<Language> altLanguages) throws IOException {
-    List<Rule> rules = new ArrayList<>(super.getRelevantLanguageModelCapableRules(messages, languageModel, userConfig, altLanguages));
+  public List<Rule> getRelevantLanguageModelCapableRules(ResourceBundle messages, @Nullable LanguageModel languageModel, UserConfig userConfig, Language motherTongue, List<Language> altLanguages) throws IOException {
+    List<Rule> rules = new ArrayList<>(super.getRelevantLanguageModelCapableRules(messages, languageModel, userConfig, motherTongue, altLanguages));
     rules.add(new AustrianGermanSpellerRule(messages, this,
       userConfig, languageModel));
     return rules;

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/GermanyGerman.java
Patch:
@@ -43,8 +43,8 @@ public String getName() {
   }
 
   @Override
-  public List<Rule> getRelevantLanguageModelCapableRules(ResourceBundle messages, @Nullable LanguageModel languageModel, UserConfig userConfig, List<Language> altLanguages) throws IOException {
-    List<Rule> rules = new ArrayList<>(super.getRelevantLanguageModelCapableRules(messages, languageModel, userConfig, altLanguages));
+  public List<Rule> getRelevantLanguageModelCapableRules(ResourceBundle messages, @Nullable LanguageModel languageModel, UserConfig userConfig, Language motherTongue, List<Language> altLanguages) throws IOException {
+    List<Rule> rules = new ArrayList<>(super.getRelevantLanguageModelCapableRules(messages, languageModel, userConfig, motherTongue, altLanguages));
     rules.add(new GermanSpellerRule(messages, this,
       userConfig, null, altLanguages, languageModel));
     return rules;

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/SwissGerman.java
Patch:
@@ -49,8 +49,8 @@ public String getName() {
   }
 
   @Override
-  public List<Rule> getRelevantLanguageModelCapableRules(ResourceBundle messages, @Nullable LanguageModel languageModel, UserConfig userConfig, List<Language> altLanguages) throws IOException {
-    List<Rule> rules = new ArrayList<>(super.getRelevantLanguageModelCapableRules(messages, languageModel, userConfig, altLanguages));
+  public List<Rule> getRelevantLanguageModelCapableRules(ResourceBundle messages, @Nullable LanguageModel languageModel, UserConfig userConfig, Language motherTongue, List<Language> altLanguages) throws IOException {
+    List<Rule> rules = new ArrayList<>(super.getRelevantLanguageModelCapableRules(messages, languageModel, userConfig, motherTongue, altLanguages));
     rules.add(new SwissGermanSpellerRule(messages, this,
       userConfig, languageModel));
     return rules;

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/AmericanEnglish.java
Patch:
@@ -54,8 +54,8 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
   }
 
   @Override
-  public List<Rule> getRelevantLanguageModelCapableRules(ResourceBundle messages, @Nullable LanguageModel languageModel, UserConfig userConfig, List<Language> altLanguages) throws IOException {
-    List<Rule> rules = new ArrayList<>(super.getRelevantLanguageModelCapableRules(messages, languageModel, userConfig, altLanguages));
+  public List<Rule> getRelevantLanguageModelCapableRules(ResourceBundle messages, @Nullable LanguageModel languageModel, UserConfig userConfig, Language motherTongue, List<Language> altLanguages) throws IOException {
+    List<Rule> rules = new ArrayList<>(super.getRelevantLanguageModelCapableRules(messages, languageModel, userConfig, motherTongue, altLanguages));
     if (SuggestionsChanges.isRunningExperiment("SymSpell") || SuggestionsChanges.isRunningExperiment("SymSpell+NewSuggestionsOrderer")) {
       rules.add(new SymSpellRule(messages, this, userConfig, altLanguages, languageModel));
     } else {

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/suggestions/XGBoostSuggestionsOrderer.java
Patch:
@@ -107,7 +107,7 @@ public XGBoostSuggestionsOrderer(Language lang, LanguageModel languageModel) {
       return;
     } else if (System.getProperty("os.name").toLowerCase().startsWith("windows")) {
       xgboostNotSupported = true;
-      logger.warn("At the moment, your platform (Windows) is not supported by the official XGBoost maven package;" +
+      System.err.println("Warning: At the moment, your platform (Windows) is not supported by the official XGBoost maven package;" +
         " ML-based suggestion reordering is disabled.");
       return;
     }

File: languagetool-dev/src/main/java/org/languagetool/dev/bigdata/ConfusionRuleEvaluator.java
Patch:
@@ -122,7 +122,7 @@ Map<Long, RuleEvalResult> run(List<String> inputsOrDir, String token, String hom
   @SuppressWarnings("ConstantConditions")
   private void evaluate(List<Sentence> sentences, boolean isCorrect, String token, String homophoneToken, List<Long> evalFactors) throws IOException {
     println("======================");
-    printf("Starting evaluation on " + sentences.size() + " sentences with %s/%s:\n", token, homophoneToken);
+    printf("Starting evaluation on " + sentences.size() + " " + (isCorrect ? "correct" : "incorrect") + " sentences with %s/%s:\n", token, homophoneToken);
     JLanguageTool lt = new JLanguageTool(language);
     List<Rule> allActiveRules = lt.getAllActiveRules();
     for (Rule activeRule : allActiveRules) {
@@ -135,10 +135,11 @@ private void evaluate(List<Sentence> sentences, boolean isCorrect, String token,
       String replacedTokenSentence = isCorrect ? plainText : plainText.replaceFirst("(?i)\\b" + textToken + "\\b", replacement);
       AnalyzedSentence analyzedSentence = lt.getAnalyzedSentence(replacedTokenSentence);
       for (Long factor : evalFactors) {
-        rule.setConfusionPair(new ConfusionPair(homophoneToken, token, factor, bothDirections));
+        rule.setConfusionPair(new ConfusionPair(token, homophoneToken, factor, bothDirections));
         RuleMatch[] matches = rule.match(analyzedSentence);
         boolean consideredCorrect = matches.length == 0;
         String displayStr = plainText.replaceFirst("(?i)\\b" + textToken + "\\b", "**" + replacement + "**");
+        //System.out.println("consideredCorrect=" + consideredCorrect + ", correct=" + isCorrect + ": " + replacedTokenSentence);
         if (consideredCorrect && isCorrect) {
           evalValues.get(factor).trueNegatives++;
         } else if (!consideredCorrect && isCorrect) {

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -195,7 +195,9 @@ public void testRule() throws IOException {
     assertCorrect("un Do dues octaves més alt que l'anterior");
     assertCorrect("són pràcticament dos graus més baixes");
     assertCorrect("és unes vint vegades més gran que l'espermatozou.");
+    assertCorrect("és unes quantes vegades més gran que l'espermatozou.");
     assertCorrect("és unes 20 vegades més gran que l'espermatozou.");
+    assertCorrect("Una casa cinquanta vegades més gran.");
     assertCorrect("eren quatre vegades més alts");
     assertCorrect("eren uns fets cada volta més inexplicables");
     assertCorrect("El castell està totalment en ruïnes i completament cobert de vegetació.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -115,6 +115,8 @@ public void testWrongVerb() throws IOException {
     assertBad("„Du muss gehen.“");
     assertBad("Du weiß es doch.");
     assertBad("Sie sagte zu mir: „Du muss gehen.“");
+    assertBad("„Ich müsst alles machen.“");
+    assertBad("„Ich könnt mich sowieso nicht verstehen.“");
   }
 
   @Test

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -182,6 +182,9 @@ public void handle(HttpExchange httpExchange) throws IOException {
       } else if (e instanceof IllegalArgumentException || rootCause instanceof IllegalArgumentException) {
         errorCode = HttpURLConnection.HTTP_BAD_REQUEST;
         response = e.getMessage();
+      } else if (e instanceof PathNotFoundException || rootCause instanceof PathNotFoundException) {
+        errorCode = HttpURLConnection.HTTP_NOT_FOUND;
+        response = e.getMessage();
       } else if (e instanceof TimeoutException || rootCause instanceof TimeoutException) {
         errorCode = HttpURLConnection.HTTP_INTERNAL_ERROR;
         response = "Checking took longer than " + config.getMaxCheckTimeMillis()/1000.0f + " seconds, which is this server's limit. " +

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -446,7 +446,7 @@ private List<RuleMatch> getRuleMatches(AnnotatedText aText, Language lang,
 
     if (parameters.get("sourceText") != null) {
       if (parameters.get("sourceLanguage") == null) {
-        throw new RuntimeException("'sourceLanguage' parameter missing - must be set when 'sourceText' is set");
+        throw new IllegalArgumentException("'sourceLanguage' parameter missing - must be set when 'sourceText' is set");
       }
       Language sourceLanguage = Languages.getLanguageForShortCode(parameters.get("sourceLanguage"));
       JLanguageTool sourceLt = new JLanguageTool(sourceLanguage);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -217,9 +217,6 @@ void optimizeReset() {
    */
   @Nullable
   public Language getLanguage() {
-    if(docLanguage != null) {
-      return docLanguage;
-    }
     XComponent xComponent = OfficeTools.getCurrentComponent(xContext);
     Locale charLocale;
     XPropertySet xCursorProps;

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -124,7 +124,6 @@ public SpellingCheckRule(ResourceBundle messages, Language language, UserConfig
    * @param candidates candidates from default dictionary
    * @param orderer model to rank suggestions / extract features, or null
    * @param match rule match to add suggestions to
-   * @return modified match with suggestions and (possibly) extracted features
    */
   protected static void addSuggestionsToRuleMatch(String word, List<String> userCandidates, List<String> candidates,
                                                   @Nullable SuggestionsOrderer orderer, RuleMatch match) {

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/suggestions/SuggestionsChanges.java
Patch:
@@ -33,7 +33,7 @@
 
 /**
  * Helper class for SuggestionChangesTest, tracks experiment configuration and results
- * Rules should use getInstance() != null -> getInstance().getCurrentExperiment() in constructors to fetch relevant parameters
+ * Rules should use getInstance() != null -&gt; getInstance().getCurrentExperiment() in constructors to fetch relevant parameters
  * Use isRunningExperiment if no parameters are needed
  */
 public class SuggestionsChanges {

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -155,7 +155,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new WhiteSpaceAtBeginOfParagraph(messages),
             new EmptyLineRule(messages, this),
             new ParagraphRepeatBeginningRule(messages, this),
-            new PunctuationMarkAtParagraphEnd(messages, this),
+            new PunctuationMarkAtParagraphEnd(messages, this, true),
             //Specific to Portuguese:
             new PostReformPortugueseCompoundRule(messages),
             new PortugueseReplaceRule(messages),

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -186,6 +186,6 @@ public int getPriorityForId(String id) {
       case "NOMBRES_ROMANS": return -400;
       case "UPPERCASE_SENTENCE_START": return -500;
     }
-    return 0;
+    return super.getPriorityForId(id);
   }
 }

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -297,8 +297,8 @@ public int getPriorityForId(String id) {
       case "AKZENT_STATT_APOSTROPH": return -1;  // lower prio than PLURAL_APOSTROPH
       case "PUNKT_ENDE_ABSATZ": return -10;  // should never hide other errors, as chance for a false alarm is quite high
       case "KOMMA_ZWISCHEN_HAUPT_UND_NEBENSATZ": return -10;
-      default: return 0;
     }
+    return super.getPriorityForId(id);
   }
 
 }

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/BritishEnglish.java
Patch:
@@ -60,6 +60,6 @@ public int getPriorityForId(String id) {
       case "OXFORD_SPELLING_ISE_VERBS":     return -21;
       case "OXFORD_SPELLING_IZE":           return -22;
     }
-    return 0;
+    return super.getPriorityForId(id);
   }
 }

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -234,6 +234,6 @@ public int getPriorityForId(String id) {
       case LongSentenceRule.RULE_ID:    return -997;
       case LongParagraphRule.RULE_ID:   return -998;
     }
-    return 0;
+    return super.getPriorityForId(id);
   }
 }

File: languagetool-language-modules/gl/src/main/java/org/languagetool/language/Galician.java
Patch:
@@ -192,6 +192,6 @@ public int getPriorityForId(String id) {
       case "TOO_LONG_SENTENCE_60":      return -1004;
       // case "CACOPHONY":                 return -2000;
     }
-    return 0;
+    return super.getPriorityForId(id);
   }
 }

File: languagetool-language-modules/nl/src/main/java/org/languagetool/language/Dutch.java
Patch:
@@ -162,7 +162,7 @@ public int getPriorityForId(String id) {
     switch (id) {
       case LongSentenceRule.RULE_ID: return -1;
     }
-    return 0;
+    return super.getPriorityForId(id);
   }
 
   @Override

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/PortugalPortuguese.java
Patch:
@@ -60,6 +60,6 @@ public int getPriorityForId(String id) {
       case "PT_COMPOUNDS_POST_REFORM":         return  1;
       case "PORTUGUESE_OLD_SPELLING_INTERNAL": return -9;
     }
-    return 0;
+    return super.getPriorityForId(id);
   }
 }

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -543,7 +543,7 @@ static class QueryParams {
       this.enableHiddenRules = enableHiddenRules;
       this.mode = Objects.requireNonNull(mode);
       if (callback != null && !callback.matches("[a-zA-Z]+")) {
-        throw new IllegalArgumentException("'callback' value must match [a-zA-Z]+");
+        throw new IllegalArgumentException("'callback' value must match [a-zA-Z]+: '" + callback + "'");
       }
       this.callback = callback;
     }

File: languagetool-standalone/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -44,7 +44,7 @@ public class WordListValidatorTest {
           "·" +   // for Catalan
           "'ÅıøğåšĝÇİŞŠśčžć" +   // for Dutch (inhabitants) proper names mostly
           "./-]+" + 
-          "|[khmcdµ]?m[²³]|°[CFR]|CO₂-?.*"
+          "|[khmcdµ]?m[²³]|°[CFR]|CO₂-?.*|mc²"
   );
 
   // Words that are valid but with special characters so that we don't want to

File: languagetool-core/src/main/java/org/languagetool/rules/ngrams/Probability.java
Patch:
@@ -51,6 +51,9 @@ public double getProb() {
     return prob;
   }
 
+  public double getLogProb() {
+    return Math.log(prob);
+  }
   /**
    * The fraction of lookups that had occurrence counts &gt; 0. This
    * might be used to ignore the whole probability for low coverage items.

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleLoaderPermissionTest.java
Patch:
@@ -20,7 +20,7 @@
 
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
-//import org.junit.Ignore;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.ByteArrayInputStream;
@@ -44,7 +44,8 @@ public static void startup() throws Exception {
     System.setSecurityManager(new SecurityManager());
   }
 
-  //@Ignore("doesn't work with Gradle, see http://stackoverflow.com/questions/32584997/")
+  @Ignore("doesn't work with Gradle, see http://stackoverflow.com/questions/32584997/;" +
+    " also caused seemingly random exceptions after PR #1443 was merged")
   @Test
   public void testPermissionManager() throws Exception {
     try {

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServerConfig.java
Patch:
@@ -304,7 +304,7 @@ private void addDynamicLanguages(Properties props) throws IOException {
     }
   }
 
-  private void setLanguageModelDirectory(String langModelDir) {
+  void setLanguageModelDirectory(String langModelDir) {
     SuggestionsOrdererConfig.setNgramsPath(langModelDir);
     languageModelDir = new File(langModelDir);
     if (!languageModelDir.exists() || !languageModelDir.isDirectory()) {
@@ -847,7 +847,7 @@ public String getAbTest() {
    */
   @Experimental
   public void setAbTest(@Nullable String abTest) {
-    List<String> values = Arrays.asList("SuggestionsOrderer");
+    List<String> values = Arrays.asList("SuggestionsOrderer", "SuggestionsRanker");
     if (abTest != null && !values.contains(abTest)) {
         throw new IllegalConfigurationException("Unknown value for 'abTest' property: Must be one of: " + values);
     }

File: languagetool-server/src/main/java/org/languagetool/server/PipelinePool.java
Patch:
@@ -43,6 +43,7 @@
 
 /**
  * Caches pre-configured JLanguageTool instances to avoid costly setup time of rules, etc.
+ * TODO: reimplement using apache commons KeyedObjectPool
  */
 class PipelinePool {
 

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/dumpcheck/SentenceSourceIndexer.java
Patch:
@@ -30,7 +30,7 @@
 import org.languagetool.Languages;
 import org.languagetool.dev.index.Indexer;
 import org.xml.sax.helpers.DefaultHandler;
-import sun.misc.Signal;
+//import sun.misc.Signal;
 
 import java.io.File;
 import java.io.IOException;
@@ -65,7 +65,7 @@ public class SentenceSourceIndexer extends DefaultHandler implements AutoCloseab
     }
     this.indexer.setLowercaseOnly(LC_ONLY);
     this.maxSentences = maxSentences;
-    Signal.handle(new Signal("HUP"), signal -> {
+/*    Signal.handle(new Signal("HUP"), signal -> {
       stopped = true;
       System.out.println("----- Got SIGHUP, will commit and exit ----");
       try {
@@ -75,7 +75,7 @@ public class SentenceSourceIndexer extends DefaultHandler implements AutoCloseab
         e.printStackTrace();
       }
       System.exit(1);
-    });
+    });*/
   }
 
   SentenceSourceIndexer(Directory dir, Language language, int maxSentences) {

File: languagetool-core/src/test/java/org/languagetool/rules/spelling/morfologik/suggestions_ordering/DetailedDamerauLevenstheinDistanceTest.java
Patch:
@@ -22,6 +22,7 @@
 package org.languagetool.rules.spelling.morfologik.suggestions_ordering;
 
 import org.apache.commons.lang3.tuple.Pair;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.languagetool.rules.spelling.symspell.implementation.EditDistance;
 
@@ -53,6 +54,7 @@ private Pair<String, Distance> modifyString(String s, int distance) {
   }
 
   @Test
+  @Ignore("Needs further debugging, but since this is only used as a feature in ML models errors are tolerable for now.")
   public void testDistanceComputation() {
     String text = "This is a test text. Random edits will occur here. Foo bar baz. Bla bla. Lorem ipsum dolor sit amet.";
     Random random = new Random(0L);
@@ -77,6 +79,7 @@ public void testDistanceComputation() {
   }
 
   @Test
+  @Ignore("WIP")
   public void testDistanceDetails() {
     assertEquals(new Distance().delete(), DetailedDamerauLevenstheinDistance.compare("Test", "Tet"));
     assertEquals(new Distance().insert(), DetailedDamerauLevenstheinDistance.compare("Test", "Teste"));

File: languagetool-language-modules/pl/src/main/java/org/languagetool/rules/pl/MorfologikPolishSpellerRule.java
Patch:
@@ -112,10 +112,8 @@ public Pattern tokenizingPattern() {
   }
 
   @Override
-  protected List<RuleMatch> getRuleMatches(AnalyzedTokenReadings token, AnalyzedSentence sentence, List<RuleMatch> ruleMatchesSoFar)
+  protected List<RuleMatch> getRuleMatches(String word, int startPos, AnalyzedSentence sentence, List<RuleMatch> ruleMatchesSoFar)
           throws IOException {
-    String word = token.getToken();
-    int startPos = token.getStartPos();
     final List<RuleMatch> ruleMatches = new ArrayList<>();
     if (isMisspelled(speller1, word) && isNotCompound(word)) {
       final RuleMatch ruleMatch = new RuleMatch(this, sentence, startPos, startPos

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/CompoundAwareHunspellRule.java
Patch:
@@ -84,7 +84,7 @@ public List<String> getSuggestions(String word) throws IOException {
     List<String> simpleSuggestions = getCorrectWords(candidates);
     //System.out.println("simpleSuggestions: " + simpleSuggestions);
 
-    if (SpellingCheckRule.isTestingChange("sortSuggestionByFrequency")) {
+    if (isTestingChange("sortSuggestionByFrequency")) {
       simpleSuggestions = sortSuggestionByFrequency(word, simpleSuggestions);
     }
 
@@ -117,7 +117,7 @@ public List<String> getSuggestions(String word) throws IOException {
     filterDupes(suggestions);
     filterForLanguage(suggestions);
 
-    if (SpellingCheckRule.isTestingChange("sortAfterSuggestionOrderer")) {
+    if (isTestingChange("sortAfterSuggestionOrderer")) {
       return suggestions.subList(0, Math.min(MAX_SUGGESTIONS, suggestions.size()));
     }
 

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -97,7 +97,7 @@ public HunspellRule(ResourceBundle messages, Language language, UserConfig userC
     this.userConfig = userConfig;
     this.monitorRules = System.getProperty("monitorActiveRules") != null;
 
-     if (SpellingCheckRule.isTestingChange("NewSuggestionsOrderer")) {
+     if (isTestingChange("NewSuggestionsOrderer")) {
        suggestionsOrderer = new NewSuggestionsOrderer(language, this.languageModel);
      } else {
        suggestionsOrderer = null;
@@ -213,7 +213,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
               }
             }
 
-            if (SpellingCheckRule.isTestingChange("sortAfterSuggestionOrderer")) {
+            if (isTestingChange("sortAfterSuggestionOrderer")) {
               suggestions = sortSuggestionByQuality(word, suggestions);
             }
 

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -81,7 +81,7 @@ public MorfologikSpellerRule(ResourceBundle messages, Language language, UserCon
     init();
     setLocQualityIssueType(ITSIssueType.Misspelling);
 
-    if (SpellingCheckRule.isTestingChange("NewSuggestionsOrderer")) {
+    if (isTestingChange("NewSuggestionsOrderer")) {
       suggestionsOrderer = new NewSuggestionsOrderer(language, this.languageModel);
     } else {
       suggestionsOrderer = new SuggestionsOrdererGSoC(language, this.languageModel, this.getId());

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java
Patch:
@@ -93,7 +93,7 @@ protected static Map<String,String> loadWordlist(String path, int column) {
     }
     return words;
   }
-  
+
   @Override
   protected List<RuleMatch> getRuleMatches(String word, int startPos, AnalyzedSentence sentence, List<RuleMatch> ruleMatchesSoFar) throws IOException {
     List<RuleMatch> ruleMatches = super.getRuleMatches(word, startPos, sentence, ruleMatchesSoFar);
@@ -123,7 +123,7 @@ protected List<RuleMatch> getRuleMatches(String word, int startPos, AnalyzedSent
   protected VariantInfo isValidInOtherVariant(String word) {
     return null;
   }
-  
+
   private void addFormsToFirstMatch(String message, AnalyzedSentence sentence, List<RuleMatch> ruleMatches, List<String> forms) {
     RuleMatch oldMatch = ruleMatches.get(0);
     RuleMatch newMatch = new RuleMatch(this, sentence, oldMatch.getFromPos(), oldMatch.getToPos(), message);

File: languagetool-language-modules/uk/src/main/java/org/languagetool/tagging/disambiguation/uk/UkrainianHybridDisambiguator.java
Patch:
@@ -393,6 +393,7 @@ private static AnalyzedTokenReadings getInitialReadings(AnalyzedTokenReadings in
 
       String initialsToken = initialsReadings.getAnalyzedToken(0).getToken();
       AnalyzedToken newToken = new AnalyzedToken(initialsToken, lnamePosTag.replace(LAST_NAME_TAG, ":"+initialType+":abbr"), initialsToken);
+      newToken.setWhitespaceBefore(initialsReadings.isWhitespaceBefore());
       newTokens.add(newToken);
     }
     return new AnalyzedTokenReadings(newTokens, initialsReadings.getStartPos());

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/index/PatternRuleQueryBuilder.java
Patch:
@@ -254,7 +254,7 @@ private void checkUnsupportedElement(PatternToken patternPatternToken)
     if (patternPatternToken.isUnified()) {
       throw new UnsupportedPatternRuleException("Elements with unified tokens are not supported.");
     }
-    if (patternPatternToken.getString().matches("\\\\\\d+")) { // e.g. "\1"
+    if (patternPatternToken.getString() != null && patternPatternToken.getString().matches("\\\\\\d+")) { // e.g. "\1"
       throw new UnsupportedPatternRuleException("Elements with only match references (e.g. \\1) are not supported.");
     }
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -603,7 +603,7 @@ public GermanSpellerRule(ResourceBundle messages, German language, UserConfig us
   @Override
   protected void init() throws IOException {
     super.init();
-    super.ignoreGreekLetters();
+    super.ignoreWordsWithLength = 1;
     String pattern = "(" + nonWordPattern.pattern() + "|(?<=[\\d°])-|-(?=\\d+))";
     nonWordPattern = Pattern.compile(pattern);
     needsInit = false;

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java
Patch:
@@ -44,7 +44,7 @@ public AbstractEnglishSpellerRule(ResourceBundle messages, Language language) th
    */
   public AbstractEnglishSpellerRule(ResourceBundle messages, Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
     super(messages, language, userConfig, altLanguages);
-    super.ignoreGreekLetters();
+    super.ignoreWordsWithLength = 1;
     setCheckCompound(true);
     addExamplePair(Example.wrong("This <marker>sentenc</marker> contains a spelling mistake."),
                    Example.fixed("This <marker>sentence</marker> contains a spelling mistake."));

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikAmericanSpellerRuleTest.java
Patch:
@@ -99,6 +99,7 @@ public void testMorfologikSpeller() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence(",")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("123454")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("I like my emoji 😾")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("μ")).length);
 
     // test words in language-specific spelling_en-US.txt
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("USTestWordToBeIgnored")).length);

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/CompoundAwareHunspellRule.java
Patch:
@@ -27,7 +27,6 @@
 import java.io.IOException;
 import java.util.*;
 import java.util.stream.IntStream;
-import java.util.stream.Stream;
 
 /**
  * A spell checker that combines Hunspell und Morfologik spell checking

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -603,6 +603,7 @@ public GermanSpellerRule(ResourceBundle messages, German language, UserConfig us
   @Override
   protected void init() throws IOException {
     super.init();
+    super.ignoreGreekLetters();
     String pattern = "(" + nonWordPattern.pattern() + "|(?<=[\\d°])-|-(?=\\d+))";
     nonWordPattern = Pattern.compile(pattern);
     needsInit = false;
@@ -1178,7 +1179,7 @@ private String getWordAfterEnumerationOrNull(List<String> words, int idx) {
   // check whether a <code>word<code> is a valid compound (e.g., "Feynmandiagramm" or "Feynman-Diagramm")
   // that contains an ignored word from spelling.txt (e.g., "Feynman")
   private boolean ignoreCompoundWithIgnoredWord(String word) throws IOException {
-    if (!StringTools.startsWithUppercase(word) && !StringUtils.startsWithAny(word, "nord", "west", "ost", "süd", "α-", "β-", "ɣ-")) {
+    if (!StringTools.startsWithUppercase(word) && !StringUtils.startsWithAny(word, "nord", "west", "ost", "süd")) {
       // otherwise stuff like "rumfangreichen" gets accepted
       return false;
     }

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java
Patch:
@@ -44,6 +44,7 @@ public AbstractEnglishSpellerRule(ResourceBundle messages, Language language) th
    */
   public AbstractEnglishSpellerRule(ResourceBundle messages, Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
     super(messages, language, userConfig, altLanguages);
+    super.ignoreGreekLetters();
     setCheckCompound(true);
     addExamplePair(Example.wrong("This <marker>sentenc</marker> contains a spelling mistake."),
                    Example.fixed("This <marker>sentence</marker> contains a spelling mistake."));

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikAustralianSpellerRuleTest.java
Patch:
@@ -64,6 +64,7 @@ public void testMorfologikSpeller() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence(",")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("123454")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("I like my emoji 😍!")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("μ")).length);
 
     //Australian dict:
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Dinkum")).length);

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikBritishSpellerRuleTest.java
Patch:
@@ -76,6 +76,8 @@ public void testMorfologikSpeller() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("This is my Ph.D. thesis.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence(",")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("123454")).length);
+    // Greek letters
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("μ")).length);
 
     //incorrect sentences:
 

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikCanadianSpellerRuleTest.java
Patch:
@@ -63,6 +63,7 @@ public void testMorfologikSpeller() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence(",")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("123454")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("I like my emoji (😥)...")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("μ")).length);
 
     //incorrect sentences:
 

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikNewZealandSpellerRuleTest.java
Patch:
@@ -55,6 +55,7 @@ public void testMorfologikSpeller() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("He doesn't know what to do.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence(",")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("123454")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("μ")).length);
 
     //special New Zealand content:
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Abercrombie")).length);

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikSouthAfricanSpellerRuleTest.java
Patch:
@@ -62,6 +62,7 @@ public void testMorfologikSpeller() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("He doesn't know what to do.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence(",")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("123454")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("μ")).length);
 
     //South African dict:
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Amanzimnyama")).length);

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/EnglishUnpairedBracketsRuleTest.java
Patch:
@@ -119,13 +119,13 @@ public void testMultipleSentences() throws IOException {
     JLanguageTool lt = new JLanguageTool(new English());
 
     assertEquals(0, getMatches("This is multiple sentence text that contains a bracket: "
-                             + "[This is bracket. With some text.] and this continues.\n", lt));
+                             + "[This is a bracket. With some text.] and this continues.\n", lt));
 
     assertEquals(0, getMatches("This is multiple sentence text that contains a bracket. "
-                             + "(This is bracket. \n\n With some text.) and this continues.", lt));
+                             + "(This is a bracket. \n\n With some text.) and this continues.", lt));
 
     assertEquals(1, getMatches("This is multiple sentence text that contains a bracket: "
-                             + "[This is bracket. With some text. And this continues.\n\n", lt));
+                             + "[This is a bracket. With some text. And this continues.\n\n", lt));
   }
 
   private int getMatches(String input, JLanguageTool lt) throws IOException {

File: languagetool-core/src/main/java/org/languagetool/tools/RuleMatchesAsJsonSerializer.java
Patch:
@@ -145,6 +145,7 @@ private void writeMatchesSection(String sectionName, JsonGenerator g, List<RuleM
       g.writeEndObject();
       writeRule(g, match);
       g.writeBooleanField("ignoreForIncompleteSentence", RuleInformation.ignoreForIncompleteSentences(match.getRule().getId(), lang));
+      g.writeNumberField("contextForSureMatch", match.getRule().estimateContextForSureMatch());
       g.writeEndObject();
     }
     g.writeEndArray();

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/CaseGovernmentHelper.java
Patch:
@@ -58,8 +58,8 @@ public static Set<String> getCaseGovernments(AnalyzedTokenReadings analyzedToken
     LinkedHashSet<String> list = new LinkedHashSet<>();
     for(AnalyzedToken token: analyzedTokenReadings.getReadings()) {
       if( ! token.hasNoTag()
-          && (token.getPOSTag().startsWith(startPosTag) 
-              || (startPosTag == "prep" && token.getPOSTag().equals("<prep>")) )
+          && (token.getPOSTag() != null && token.getPOSTag().startsWith(startPosTag) 
+              || (startPosTag.equals("prep") && token.getPOSTag() != null && token.getPOSTag().equals("<prep>")) )
           && CASE_GOVERNMENT_MAP.containsKey(token.getLemma()) ) {
 
         Set<String> rvList = CASE_GOVERNMENT_MAP.get(token.getLemma());

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/TokenAgreementAdjNounRule.java
Patch:
@@ -52,7 +52,7 @@
  */
 public class TokenAgreementAdjNounRule extends Rule {
   private static Logger logger = LoggerFactory.getLogger(TokenAgreementAdjNounRule.class);
-  
+
   static final Pattern ADJ_INFLECTION_PATTERN = Pattern.compile(":([mfnp]):(v_...)(:r(in)?anim)?");
   static final Pattern NOUN_INFLECTION_PATTERN = Pattern.compile("(?::((?:[iu]n)?anim))?:([mfnps]):(v_...)");
 

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/TokenAgreementNounVerbExceptionHelper.java
Patch:
@@ -466,7 +466,7 @@ private static Set<String> extendSet(Set<String> loadSet, String string) {
     return loadSet;
   }
 
-  
+
   private static void logException() {
     if( logger.isDebugEnabled() ) {
       StackTraceElement stackTraceElement = Thread.currentThread().getStackTrace()[2];

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/TokenAgreementNounVerbRule.java
Patch:
@@ -48,7 +48,7 @@
  */
 public class TokenAgreementNounVerbRule extends Rule {
   private static Logger logger = LoggerFactory.getLogger(TokenAgreementNounVerbRule.class);
-  
+
   private static final Pattern VERB_INFLECTION_PATTERN = Pattern.compile(":([mfnps])(:([123])?|$)");
   private static final Pattern NOUN_INFLECTION_PATTERN = Pattern.compile("(?::((?:[iu]n)?anim))?:([mfnps]):(v_naz)");
   private static final Pattern NOUN_PERSON_PATTERN = Pattern.compile(":([123])");

File: languagetool-commandline/src/test/java/org/languagetool/commandline/MainTest.java
Patch:
@@ -447,13 +447,13 @@ public void testGermanFileWithURL() throws Exception {
     assertTrue(output.indexOf("<?xml version=\"1.0\" encoding=\"UTF-8\"?>") == 0);
     assertTrue(output.contains("ruleId=\"WARD_VS_WART\" subId=\"1\""));
     //check URL part
-    assertTrue(output.contains("url=\"http://www.korrekturen.de/beliebte_fehler/ward.shtml\""));
+    assertTrue(output.contains("url=\"https://www.korrekturen.de/beliebte_fehler/ward.shtml\""));
 
     //now check in normal mode and check for URL
     String[] args2 = {"-l", "de", input.getAbsolutePath()};
     Main.main(args2);
     String output2 = new String(this.out.toByteArray());
-    assertTrue(output2.contains("More info: http://www.korrekturen.de/beliebte_fehler/ward.shtml"));
+    assertTrue(output2.contains("More info: https://www.korrekturen.de/beliebte_fehler/ward.shtml"));
   }
 
   @Test

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -98,7 +98,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Sie kann einem Angst einjagen.");
     assertGood("Damit sollten zum einen neue Energien gefördert werden, zum anderen der Sozialbereich.");
     assertGood("Nichts ist mit dieser einen Nacht zu vergleichen.");
-
+    assertGood("dann muss Schule dem Rechnung tragen.");
     assertGood("Das Dach von meinem Auto.");
     assertGood("Das Dach von meinen Autos.");
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -176,6 +176,7 @@ public void testRule() throws IOException {
     assertGood("Anders als physikalische Konstanten werden mathematische Konstanten unabhängig von jedem physikalischen Maß definiert.");
     assertGood("Eine besonders einfache Klasse bilden die polylogarithmischen Konstanten.");
     assertGood("Das südlich von Berlin gelegene Dörfchen.");
+    assertGood("Weil er das kommen sah, traf er Vorkehrungen.");
     
     assertGood("Sie werden im Allgemeinen gefasst.");
     assertGood("Sie werden im allgemeinen Fall gefasst.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SubjectVerbAgreementRuleTest.java
Patch:
@@ -410,7 +410,8 @@ public void testRuleWithCorrectPluralVerb() throws IOException {
         "Die Ursachen der vorliegenden Durchblutungsstörung sind noch unbekannt.",
         "Der See und das Marschland sind ein Naturschutzgebiet",
         "Details, Dialoge, wie auch die Typologie der Charaktere sind frei erfunden.",
-        "Die internen Ermittler und auch die Staatsanwaltschaft sind nun am Zug."
+        "Die internen Ermittler und auch die Staatsanwaltschaft sind nun am Zug.",
+        "Sie sind so erfolgreich, weil sie eine Einheit sind."
     );
     for (String sentence : sentences) {
       assertGood(sentence);

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/QuestionWhitespaceRule.java
Patch:
@@ -56,11 +56,11 @@ public class QuestionWhitespaceRule extends Rule {
       Arrays.asList( // ignore smileys, such as :-)
         new PatternTokenBuilder().tokenRegex("[:;]").build(),
         new PatternTokenBuilder().csToken("-").setIsWhiteSpaceBefore(false).build(),
-        new PatternTokenBuilder().tokenRegex("[\\(\\)]").setIsWhiteSpaceBefore(false).build()
+        new PatternTokenBuilder().tokenRegex("[\\(\\)D]").setIsWhiteSpaceBefore(false).build()
       ),
       Arrays.asList( // ignore smileys, such as :)
         new PatternTokenBuilder().tokenRegex("[:;]").build(),
-        new PatternTokenBuilder().tokenRegex("[\\(\\)]").setIsWhiteSpaceBefore(false).build()
+        new PatternTokenBuilder().tokenRegex("[\\(\\)D]").setIsWhiteSpaceBefore(false).build()
       )
     );
 

File: languagetool-server/src/main/java/org/languagetool/server/ResultExtender.java
Patch:
@@ -34,6 +34,7 @@
 import java.io.InputStream;
 import java.net.HttpURLConnection;
 import java.net.URL;
+import java.net.URLEncoder;
 import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.List;
@@ -93,7 +94,8 @@ List<RemoteRuleMatch> getExtensionMatches(String plainText, Language lang) throw
     try {
       huc.connect();
       try (DataOutputStream wr = new DataOutputStream(huc.getOutputStream())) {
-        String urlParameters = "language=" + lang.getShortCodeWithCountryAndVariant() + "&text=" + plainText;
+        String urlParameters = "language=" + lang.getShortCodeWithCountryAndVariant() +
+                "&text=" + URLEncoder.encode(plainText, StandardCharsets.UTF_8.name());
         byte[] postData = urlParameters.getBytes(StandardCharsets.UTF_8);
         wr.write(postData);
       }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/DashRuleTest.java
Patch:
@@ -44,13 +44,16 @@ public void testRule() throws IOException {
     assertGood("Die große Diäten- oder Gehaltserhöhung kam dann doch.", lt);
     assertGood("Erst so - Karl-Heinz dann blah.", lt);
     assertGood("Erst so -- Karl-Heinz aber...", lt);
+    assertGood("Nord- und Südkorea", lt);
     assertGood("NORD- UND SÜDKOREA", lt);
+    assertGood("NORD- BZW. SÜDKOREA", lt);
     
     // incorrect sentences:
     assertBad("Die große Diäten- Erhöhung kam dann doch.", lt);
     assertBad("Die große Diäten-  Erhöhung kam dann doch.", lt);
     assertBad("Die große Diäten-Erhöhungs- Manie kam dann doch.", lt);
     assertBad("Die große Diäten- Erhöhungs-Manie kam dann doch.", lt);
+    assertBad("MAZEDONIEN- SKOPJE Str.", lt);
   }
 
   private void assertGood(String text, JLanguageTool lt) throws IOException {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -38,6 +38,7 @@
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 
+import org.apache.commons.lang3.RegExUtils;
 import org.apache.commons.lang3.StringUtils;
 import org.jetbrains.annotations.Nullable;
 import org.languagetool.AnalyzedSentence;
@@ -47,7 +48,6 @@
 import org.languagetool.Language;
 import org.languagetool.UserConfig;
 import org.languagetool.language.German;
-import org.languagetool.languagemodel.BaseLanguageModel;
 import org.languagetool.languagemodel.LanguageModel;
 import org.languagetool.rules.Example;
 import org.languagetool.rules.ngrams.Probability;
@@ -135,6 +135,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     putRepl("[nN]amenhaft(e[mnrs]?)?", "amen", "am");
     putRepl("hom(o?e|ö)ophatisch(e[mnrs]?)?", "hom(o?e|ö)ophat", "homöopath");
     putRepl("Geschwindlichkeit(en)?", "lich", "ig");
+    putRepl("[DN]r", "r", "r.");
     put("Investion", "Investition");
     put("Pakur", w -> Arrays.asList("Parcours", "Parkuhr"));
     put("Erstsemesterin", w -> Arrays.asList("Erstsemester", "Erstsemesters"));
@@ -726,7 +727,7 @@ protected List<String> sortSuggestionByQuality(String misspelling, List<String>
   private boolean ignoreElative(String word) {
     if (StringUtils.startsWithAny(word, "bitter", "dunkel", "erz", "extra", "früh",
         "gemein", "hyper", "lau", "mega", "minder", "stock", "super", "tod", "ultra", "ur")) {
-      String lastPart = StringUtils.removePattern(word, "^(bitter|dunkel|erz|extra|früh|gemein|grund|hyper|lau|mega|minder|stock|super|tod|ultra|ur|voll)");
+      String lastPart = RegExUtils.removePattern(word, "^(bitter|dunkel|erz|extra|früh|gemein|grund|hyper|lau|mega|minder|stock|super|tod|ultra|ur|voll)");
       return !isMisspelled(lastPart);
     }
     return false;

File: languagetool-core/src/main/java/org/languagetool/rules/PartialPosTagFilter.java
Patch:
@@ -70,7 +70,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> args, Anal
     if (matcher.matches()) {
       String partialToken = matcher.group(1);
       if (matcher.groupCount() == 2) {
-      partialToken = partialToken + matcher.group(2);
+        partialToken += matcher.group(2);
       } 
       List<AnalyzedTokenReadings> tags = tag(partialToken);
       if (tags != null && partialTagHasRequiredTag(tags, requiredTagRegexp, negatePos)) {

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -357,7 +357,8 @@ public static ResourceBundle getMessageBundle(Language lang) {
   
   private List<Rule> getAllBuiltinRules(Language language, ResourceBundle messages, UserConfig userConfig) {
     try {
-      return language.getRelevantRules(messages, userConfig, altLanguages);
+      List<Rule> rules = new ArrayList<>(language.getRelevantRules(messages, userConfig, altLanguages));
+      return rules;
     } catch (IOException e) {
       throw new RuntimeException("Could not get rules of language " + language, e);
     }

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -26,10 +26,10 @@
 import org.languagetool.chunking.GermanChunker;
 import org.languagetool.languagemodel.LanguageModel;
 import org.languagetool.languagemodel.LuceneLanguageModel;
-import org.languagetool.rules.*;
-import org.languagetool.rules.de.*;
 import org.languagetool.rules.de.LongSentenceRule;
 import org.languagetool.rules.de.SentenceWhitespaceRule;
+import org.languagetool.rules.*;
+import org.languagetool.rules.de.*;
 import org.languagetool.rules.neuralnetwork.NeuralNetworkRuleCreator;
 import org.languagetool.rules.neuralnetwork.Word2VecModel;
 import org.languagetool.synthesis.GermanSynthesizer;
@@ -38,7 +38,6 @@
 import org.languagetool.tagging.de.GermanTagger;
 import org.languagetool.tagging.disambiguation.Disambiguator;
 import org.languagetool.tagging.disambiguation.rules.de.GermanRuleDisambiguator;
-import org.languagetool.tagging.xx.DemoTagger;
 import org.languagetool.tokenizers.CompoundWordTokenizer;
 import org.languagetool.tokenizers.SRXSentenceTokenizer;
 import org.languagetool.tokenizers.SentenceTokenizer;

File: languagetool-standalone/src/test/java/org/languagetool/rules/SpellingTest.java
Patch:
@@ -37,7 +37,7 @@ public class SpellingTest {
 
   @Test
   public void testEnglishWords() throws Exception {
-    HunspellRule rule = new GermanSpellerRule(TestTools.getMessages("de"), GERMAN_DE, null, null, Collections.singletonList(Languages.getLanguageForShortCode("en-US")));
+    HunspellRule rule = new GermanSpellerRule(TestTools.getMessages("de"), GERMAN_DE, null, null, Collections.singletonList(Languages.getLanguageForShortCode("en-US")), null);
     JLanguageTool lt = new JLanguageTool(GERMAN_DE);
     assertHintMatch("Ein deutscher Text mit dem englischen Wort incomprehensible", rule, lt);
     assertHintMatch("Das Fahrrad heißt auf Englisch bicycle.", rule, lt);

File: languagetool-language-modules/de-DE-x-simple-language/src/main/java/org/languagetool/language/SimpleGerman.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.language;
 
+import org.apache.commons.lang3.StringUtils;
 import org.languagetool.Language;
 import org.languagetool.UserConfig;
 import org.languagetool.languagemodel.LanguageModel;

File: languagetool-language-modules/de-DE-x-simple-language/src/main/java/org/languagetool/language/SimpleGerman.java
Patch:
@@ -76,6 +76,8 @@ public List<Rule> getRelevantLanguageModelRules(ResourceBundle messages, Languag
   public int getPriorityForId(String id) {
     if (id == LongSentenceRule.RULE_ID) {
       return 10;
+    } else if (id == "LANGES_WORT") {
+      return -1;
     }
     return super.getPriorityForId(id);
   }

File: languagetool-core/src/test/java/org/languagetool/rules/LongSentenceRuleTest.java
Patch:
@@ -51,13 +51,14 @@ public void testMatch() throws Exception {
     assertNoMatch("one two three four five six.", shortRule, lt);
     assertNoMatch("one two three (four) five six.", shortRule, lt);
     assertMatch("one two three four five six seven.", 24, 33, shortRule, lt);
+    assertNoMatch("Eins zwei drei vier fünf sechs.", shortRule, lt);
   }
 
-  private void assertNoMatch(String input, LongSentenceRule rule, JLanguageTool lt) throws IOException {
+  protected void assertNoMatch(String input, LongSentenceRule rule, JLanguageTool lt) throws IOException {
     assertThat(rule.match(lt.getAnalyzedSentence(input)).length, is(0));
   }
 
-  private void assertMatch(String input, int from, int to, LongSentenceRule rule, JLanguageTool lt) throws IOException {
+  protected void assertMatch(String input, int from, int to, LongSentenceRule rule, JLanguageTool lt) throws IOException {
     RuleMatch[] matches = rule.match(lt.getAnalyzedSentence(input));
     assertThat(matches.length, is(1));
     assertThat(matches[0].getFromPos(), is(from));

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -442,7 +442,9 @@ private List<RuleMatch> getRuleMatches(AnnotatedText aText, Language lang,
         lt = pipelinePool.getPipeline(settings);
         return lt.check(aText, true, JLanguageTool.ParagraphHandling.NORMAL, listener, params.mode);
       } finally {
-        pipelinePool.returnPipeline(settings, lt);
+        if (lt != null) {
+          pipelinePool.returnPipeline(settings, lt);
+        }
       }
     }
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -323,7 +323,7 @@ public class CaseRule extends Rule {
       csToken("Zuhause")
     ),
     Arrays.asList( // Ein anderes Zuhause habe ich nicht.
-      csToken("anderes"),
+      regex("altes|anderes|k?ein|neues"),
       csToken("Zuhause")
     )
   );

File: languagetool-language-modules/ro/src/test/java/org/languagetool/tokenizers/ro/RomanianWordTokenizerTest.java
Patch:
@@ -121,5 +121,7 @@ public void testTokenize() {
     assertEquals(testList.size(), 4);
     assertEquals("[pere, \n, \r, mere]",
         testList.toString());
+    // test for URLs  
+    testList = w.tokenize("www.LanguageTool.org");
   }
 }

File: languagetool-core/src/main/java/org/languagetool/Languages.java
Patch:
@@ -115,7 +115,7 @@ private static Language createLanguageObjects(URL url, String className) {
     } catch (ClassNotFoundException e) {
       throw new RuntimeException("Class '" + className + "' specified in " + url + " could not be found in classpath", e);
     } catch (Exception e) {
-      throw new RuntimeException("Object for class '" + className + "' specified in " + url + " could not created", e);
+      throw new RuntimeException("Object for class '" + className + "' specified in " + url + " could not be created", e);
     }
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/ReadabilityRule.java
Patch:
@@ -38,8 +38,8 @@
 
 /**
  * A rule that checks the readability of English text (using the Flesch-Reading-Ease Formula)
- * If tooEasyTest == true, the rule tests if paragraph level > level (readability is too easy)
- * If tooEasyTest == false, the rule tests if paragraph level < level (readability is too difficult)
+ * If tooEasyTest == true, the rule tests if paragraph level &gt; level (readability is too easy)
+ * If tooEasyTest == false, the rule tests if paragraph level &lt; level (readability is too difficult)
  * @author Fred Kruse
  * @since 4.4
  */

File: languagetool-dev/src/main/java/org/languagetool/dev/RuleActivityOverview.java
Patch:
@@ -72,7 +72,7 @@ int getActivityFor(Language lang, int pastDays) {
       List<File> xmlFiles = getAllXmlFiles(lang, langCode);
       int commits = 0;
       for (File file : xmlFiles) {
-        if (!file.exists()) {
+        if (!file.getName().contains("-test-") && !file.exists()) {
           throw new RuntimeException("Not found: " + file);
         }
         String command = "git log --after=" + pastString + " " + file;

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanReadabilityRule.java
Patch:
@@ -31,8 +31,8 @@
 
 /**
  * A rule that checks the readability of German text (using the Flesch-Reading-Ease Formula)
- * If tooEasyTest == true, the rule tests if paragraph level > level (readability is too easy)
- * If tooEasyTest == false, the rule tests if paragraph level < level (readability is too difficult)
+ * If tooEasyTest == true, the rule tests if paragraph level &gt; level (readability is too easy)
+ * If tooEasyTest == false, the rule tests if paragraph level &lt; level (readability is too difficult)
  * @author Fred Kruse
  * @since 4.4
  */

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseReadabilityRule.java
Patch:
@@ -31,8 +31,8 @@
 
 /**
  * A rule that checks the readability of Portuguese text (using the Flesch-Reading-Ease Formula)
- * If tooEasyTest == true, the rule tests if paragraph level > level (readability is too easy)
- * If tooEasyTest == false, the rule tests if paragraph level < level (readability is too difficult)
+ * If tooEasyTest == true, the rule tests if paragraph level &gt; level (readability is too easy)
+ * If tooEasyTest == false, the rule tests if paragraph level &lt; level (readability is too difficult)
  * @author Fred Kruse
  * @since 4.4
  */

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -186,7 +186,7 @@ public void testWrongVerbSubject() throws IOException {
     assertGood("Wyrjtjbst du?"); // make sure that "UNKNOWN" is handled correctly
     assertGood("Wenn ich du wäre, würde ich das nicht machen.");
     assertGood("Er sagte: „Darf ich bitten, mir zu folgen?“");
-    assertBad("Er fragte irritiert: „Darf ich fragen, die an dich gerichtet werden, beantworten?“");
+    // TODO: assertBad("Er fragte irritiert: „Darf ich fragen, die an dich gerichtet werden, beantworten?“");
 //     assertGood("Angenommen, du wärst ich."); TODO
     assertGood("Ich denke, dass das Haus, in das er gehen will, heute Morgen gestrichen worden ist.");
     // incorrect sentences:

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -102,6 +102,7 @@ public void testWrongVerb() throws IOException {
     assertGood("„Werde ich tun!“");
     assertGood("Sie fragte: „Muss ich aussagen?“");
     assertGood("„Können wir bitte das Thema wechseln, denn ich möchte ungern darüber reden?“");
+    assertGood("Er sagt: „Willst du behaupten, dass mein Sohn euch liebt?“");
     // incorrect sentences:
     assertBad("Als Borcarbid weißt es eine hohe Härte auf.");
     assertBad("Das greift auf Vorläuferinstitutionen bist auf die Zeit von 1234 zurück.");

File: languagetool-core/src/main/java/org/languagetool/language/CommonWords.java
Patch:
@@ -34,7 +34,7 @@
  */
 public class CommonWords {
 
-  private final static Map<String, List<Language>> word2langs = new HashMap<>();
+  private final static Map<String, List<Language>> word2langs = Collections.synchronizedMap(new HashMap<>());
   private final static Pattern numberPattern = Pattern.compile("[0-9-.,]+");
 
   public CommonWords() {

File: languagetool-core/src/main/java/org/languagetool/language/CommonWords.java
Patch:
@@ -56,7 +56,8 @@ public CommonWords() {
               String key = line.toLowerCase();
               List<Language> languages = word2langs.get(key);
               if (languages == null) {
-                ArrayList<Language> l = new ArrayList<>();
+                // word2langs is static, so this can be accessed from multiple threads concurrently -> prevent exceptions
+                List<Language> l = Collections.synchronizedList(new LinkedList<>());
                 l.add(lang);
                 word2langs.put(key, l);
               } else {

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -122,7 +122,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new SentenceWhitespaceRule(messages),
             // specific to French:
             new CompoundRule(messages),
-            new QuestionWhitespaceRule(messages)
+            new QuestionWhitespaceRule(messages, this)
     );
   }
 

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -122,7 +122,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new SentenceWhitespaceRule(messages),
             // specific to French:
             new CompoundRule(messages),
-            new QuestionWhitespaceRule(messages, this)
+            new QuestionWhitespaceRule(messages)
     );
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -321,7 +321,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     put("Begierigkeiten", "Begehrlichkeiten");
     put("selblosigkeit", "Selbstlosigkeit");
     put("gestyled", "gestylt");
-    put("umstimigkeiten", "Unstimigkeiten");
+    put("umstimigkeiten", "Unstimmigkeiten");
     put("unann?äh?ml?ichkeiten", "Unannehmlichkeiten");
     put("unn?ann?ehmichkeiten", "Unannehmlichkeiten");
     put("übertr[äa]gte", "übertrug");

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -122,7 +122,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new SentenceWhitespaceRule(messages),
             // specific to French:
             new CompoundRule(messages),
-            new QuestionWhitespaceRule(messages)
+            new QuestionWhitespaceRule(messages, this)
     );
   }
 

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/index/IndexerSearcherTest.java
Patch:
@@ -40,11 +40,12 @@
 import org.languagetool.Language;
 import org.languagetool.language.English;
 import org.languagetool.language.German;
+import org.languagetool.language.GermanyGerman;
 import org.languagetool.rules.IncorrectExample;
 import org.languagetool.rules.Rule;
 import org.languagetool.rules.RuleMatch;
-import org.languagetool.rules.patterns.PatternToken;
 import org.languagetool.rules.patterns.PatternRule;
+import org.languagetool.rules.patterns.PatternToken;
 
 public class IndexerSearcherTest extends LuceneTestCase {
 
@@ -183,7 +184,7 @@ public void testForDebugging() throws Exception {
     // Note that the second sentence ends with "lid" instead of "lids" (the inflated one)
     //createIndex("I thin so");
     useRealIndex();
-    German language = new German();
+    German language = new GermanyGerman();
     PatternRule rule = getFirstRule("I_THIN", language);
     SearcherResult searcherResult = errorSearcher.findRuleMatchesOnIndex(rule, language);
     System.out.println("Matches: " + searcherResult.getMatchingSentences());

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -296,8 +296,8 @@ public int getPriorityForId(String id) {
       case "AKZENT_STATT_APOSTROPH": return -1;  // lower prio than PLURAL_APOSTROPH
       case "PUNKT_ENDE_ABSATZ": return -10;  // should never hide other errors, as chance for a false alarm is quite high
       case "KOMMA_ZWISCHEN_HAUPT_UND_NEBENSATZ": return -10;
+      default: return 0;
     }
-    return 0;
   }
 
 }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CompoundRuleTest.java
Patch:
@@ -24,14 +24,14 @@
 import org.junit.Test;
 import org.languagetool.JLanguageTool;
 import org.languagetool.TestTools;
-import org.languagetool.language.German;
+import org.languagetool.language.GermanyGerman;
 import org.languagetool.rules.AbstractCompoundRuleTest;
 
 public class CompoundRuleTest extends AbstractCompoundRuleTest {
 
   @Before
   public void setUp() throws Exception {
-    lt = new JLanguageTool(new German());
+    lt = new JLanguageTool(new GermanyGerman());
     rule = new CompoundRule(TestTools.getMessages("de"));
   }
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/spelling/hunspell/HunspellRuleTest.java
Patch:
@@ -42,7 +42,7 @@ public class HunspellRuleTest {
   @Test
   public void testRuleWithGerman() throws Exception {
     HunspellRule rule = new HunspellRule(TestTools.getMessages("de"), new GermanyGerman(), null);
-    JLanguageTool langTool = new JLanguageTool(new German());
+    JLanguageTool langTool = new JLanguageTool(new GermanyGerman());
     commonGermanAsserts(rule, langTool);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Der äußere Übeltäter.")).length);  // umlauts
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Der äussere Übeltäter.")).length);
@@ -66,7 +66,7 @@ public void testRuleWithGerman() throws Exception {
   @Test
   public void testRuleWithAustrianGerman() throws Exception {
     HunspellRule rule = new HunspellRule(TestTools.getMessages("de"), new AustrianGerman(), null);
-    JLanguageTool langTool = new JLanguageTool(new German());
+    JLanguageTool langTool = new JLanguageTool(new GermanyGerman());
     commonGermanAsserts(rule, langTool);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Der äußere Übeltäter.")).length);  // umlauts
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Der äussere Übeltäter.")).length);
@@ -75,7 +75,7 @@ public void testRuleWithAustrianGerman() throws Exception {
   @Test
   public void testRuleWithSwissGerman() throws Exception {
     HunspellRule rule = new HunspellRule(TestTools.getMessages("de"), new SwissGerman(), null);
-    JLanguageTool langTool = new JLanguageTool(new German());
+    JLanguageTool langTool = new JLanguageTool(new GermanyGerman());
     commonGermanAsserts(rule, langTool);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Der äußere Übeltäter.")).length);  // ß not allowed in Swiss
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Der äussere Übeltäter.")).length);  // ss is used instead of ß

File: languagetool-language-modules/de/src/test/java/org/languagetool/tokenizers/de/GermanSRXSentenceTokenizerTest.java
Patch:
@@ -20,15 +20,15 @@
 
 import org.junit.Test;
 import org.languagetool.TestTools;
-import org.languagetool.language.German;
+import org.languagetool.language.GermanyGerman;
 import org.languagetool.tokenizers.SRXSentenceTokenizer;
 
 /**
  * @author Daniel Naber
  */
 public class GermanSRXSentenceTokenizerTest {
 
-  private final SRXSentenceTokenizer stokenizer = new SRXSentenceTokenizer(new German());
+  private final SRXSentenceTokenizer stokenizer = new SRXSentenceTokenizer(new GermanyGerman());
 
   @Test
   public void testTokenize() {

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/wikipedia/atom/AtomFeedCheckerTest.java
Patch:
@@ -61,7 +61,7 @@ public void testCheckManually() throws IOException {
 
   @Test
   public void testCheck() throws IOException {
-    AtomFeedChecker atomFeedChecker = new AtomFeedChecker(new German());
+    AtomFeedChecker atomFeedChecker = new AtomFeedChecker(new GermanyGerman());
     CheckResult checkResult = atomFeedChecker.checkChanges(getStream());
     List<ChangeAnalysis> changeAnalysis = checkResult.getCheckResults();
     assertThat(changeAnalysis.size(), is(3));

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractDateCheckFilter.java
Patch:
@@ -71,7 +71,7 @@ protected int getDayOfMonth(String localizedDayOfMonth) {
    */
   @Override
   public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> args, AnalyzedTokenReadings[] patternTokens) {
-    int dayOfWeekFromString = getDayOfWeek(getRequired("weekDay", args));
+    int dayOfWeekFromString = getDayOfWeek(getRequired("weekDay", args).replace("\u00AD", ""));  // replace soft hyphen
     Calendar dateFromDate = getDate(args);
     int dayOfWeekFromDate;
     try {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -510,7 +510,7 @@ public GermanSpellerRule(ResourceBundle messages, German language, UserConfig us
   @Override
   protected void init() throws IOException {
     super.init();
-    String pattern = "(" + nonWordPattern.pattern() + "|(?<=\\d)-|-(?=\\d+))";
+    String pattern = "(" + nonWordPattern.pattern() + "|(?<=[\\d°])-|-(?=\\d+))";
     nonWordPattern = Pattern.compile(pattern);
     needsInit = false;
   }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -384,6 +384,7 @@ public void testDashAndHyphen() throws Exception {
     assertEquals(0, rule.match(lt.getAnalyzedSentence("α-Strahlung")).length); // compound with ignored word from spelling.txt
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Primär-α-Mischkristallen")).length); // compound with ignored word from spelling.txt
     assertEquals(0, rule.match(lt.getAnalyzedSentence("supergut")).length); // elativ meaning "sehr gut"
+    assertEquals(0, rule.match(lt.getAnalyzedSentence("90°-Winkel")).length);
 
     assertEquals(1, rule.match(lt.getAnalyzedSentence("Miet und Zinseinkünfte")).length);
     assertEquals(1, rule.match(lt.getAnalyzedSentence("Stil- und Grammatik gut")).length);

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -287,6 +287,7 @@ private void logError(String remoteAddress, Exception e, int errorCode, HttpExch
     if (text != null) {
       message += "text length: " + text.length() + ", ";
     }
+    message += "m: " + ServerTools.getMode(params) + ", ";
     if (logStacktrace) {
       message += "Stacktrace follows:";
       message += ExceptionUtils.getStackTrace(e);

File: languagetool-core/src/main/java/org/languagetool/tokenizers/WordTokenizer.java
Patch:
@@ -50,7 +50,7 @@ public class WordTokenizer implements Tokenizer {
       + "\u2028\u2029\u202a\u202b\u202c\u202d\u202e\u202f"
       + "\u205F\u2060\u2061\u2062\u2063\u206A\u206b\u206c\u206d"
       + "\u206E\u206F\u3000\u3164\ufeff\uffa0\ufff9\ufffa\ufffb"
-      + ",.;()[]{}=*#∗×·+÷<>!?:/|\\\"'«»„”“`´‘’‛′›‹…¿¡→‼⁇⁈⁉"
+      + ",.;()[]{}=*#∗×·+÷<>!?:/|\\\"'«»„”“`´‘’‛′›‹…¿¡→‼⁇⁈⁉_"
       + "—"  // em dash
       + "\t\n\r";
 

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tokenizers/ca/CatalanWordTokenizer.java
Patch:
@@ -41,7 +41,7 @@ public class CatalanWordTokenizer extends WordTokenizer {
   //all possible forms of "pronoms febles" after a verb.
   private static final String PF = "(['’]en|['’]hi|['’]ho|['’]l|['’]ls|['’]m|['’]n|['’]ns|['’]s|['’]t|-el|-els|-em|-en|-ens|-hi|-ho|-l|-la|-les|-li|-lo|-los|-m|-me|-n|-ne|-nos|-s|-se|-t|-te|-us|-vos)";
 
-  private final int maxPatterns = 11;
+  private static final int maxPatterns = 11;
   private final Pattern[] patterns = new Pattern[maxPatterns];
   
   private static final String DICT_FILENAME = "/ca/ca-ES-valencia.dict";

File: languagetool-language-modules/en/src/main/java/org/languagetool/tokenizers/en/EnglishWordTokenizer.java
Patch:
@@ -32,7 +32,7 @@ public class EnglishWordTokenizer extends WordTokenizer {
 
   @Override
   public String getTokenizingCharacters() {
-    return super.getTokenizingCharacters() + "_–";  // n-dash
+    return super.getTokenizingCharacters() + "–";  // n-dash
   }
 
   /**

File: languagetool-language-modules/fr/src/test/java/org/languagetool/tagging/fr/FrenchTaggerTest.java
Patch:
@@ -50,7 +50,7 @@ public void testTagger() throws IOException {
         "Je/[je]R pers suj 1 s -- ne/[null]null -- parle/[parler]V imp pres 2 s|parle/[parler]V ind pres 1 s|parle/[parler]V ind pres 3 s|parle/[parler]V sub pres 1 s|parle/[parler]V sub pres 3 s -- pas/[pas]N m sp -- français/[français]J m sp|français/[français]N m sp", tokenizer, tagger);
     TestTools.myAssert("blablabla","blablabla/[blablabla]N m s", tokenizer, tagger);
     TestTools.myAssert("passagère","passagère/[passager]J f s|passagère/[passager]N f s", tokenizer, tagger);
-    TestTools.myAssert("non_existing_word","non_existing_word/[null]null", tokenizer, tagger);
+    TestTools.myAssert("non-existing-word","non-existing-word/[null]null", tokenizer, tagger);
   }
 
 }

File: languagetool-language-modules/tl/src/main/java/org/languagetool/language/tokenizers/TagalogWordTokenizer.java
Patch:
@@ -28,6 +28,5 @@ public class TagalogWordTokenizer extends WordTokenizer {
   @Override
   public String getTokenizingCharacters() {
     return super.getTokenizingCharacters() + "-";
-  }
-  
+  } 
 }

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -228,6 +228,7 @@ public void close() throws Exception {
   @Override
   public int getPriorityForId(String id) {
     switch (id) {
+      case "MISSING_HYPHEN":            return 5;
       case "TWO_CONNECTED_MODAL_VERBS": return -5;
       case "CONFUSION_RULE":            return -10;
       case LongSentenceRule.RULE_ID:    return -997;

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -58,7 +58,7 @@ public class German extends Language implements AutoCloseable {
 
   private static final Language GERMANY_GERMAN = new GermanyGerman();
   
-  private Tagger tagger;
+  protected Tagger tagger;
   private Synthesizer synthesizer;
   private SentenceTokenizer sentenceTokenizer;
   private Disambiguator disambiguator;

File: languagetool-language-modules/de/src/test/java/org/languagetool/tagging/de/GermanTaggerTest.java
Patch:
@@ -210,7 +210,7 @@ public void testDictionary() throws IOException {
    * Returns a string representation like {@code toString()}, but sorts
    * the elements alphabetically.
    */
-  private String toSortedString(AnalyzedTokenReadings tokenReadings) {
+  public static String toSortedString(AnalyzedTokenReadings tokenReadings) {
     StringBuilder sb = new StringBuilder(tokenReadings.getToken());
     Set<String> elements = new TreeSet<>();
     sb.append('[');
@@ -223,5 +223,4 @@ private String toSortedString(AnalyzedTokenReadings tokenReadings) {
     sb.append(']');
     return sb.toString();
   }
-
 }

File: languagetool-core/src/main/java/org/languagetool/language/LanguageIdentifier.java
Patch:
@@ -188,7 +188,7 @@ public DetectedLanguage detectLanguage(String text, List<String> noopLangs) {
         logger.warn("Cannot consider noopLanguages because not in fastText mode: " + noopLangs);
       }
     }
-    if (result != null && canLanguageBeDetected(result.getKey(), noopLangs)) {
+    if (result != null && result.getKey() != null && canLanguageBeDetected(result.getKey(), noopLangs)) {
       return new DetectedLanguage(null,
         Languages.getLanguageForShortCode(result.getKey(), noopLangs),
         result.getValue().floatValue());

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -286,9 +286,8 @@ private void logError(String remoteAddress, Exception e, int errorCode, HttpExch
     }
     if (logStacktrace) {
       message += "Stacktrace follows:";
+      message += ExceptionUtils.getStackTrace(e);
       print(message, System.err);
-      //noinspection CallToPrintStackTrace
-      e.printStackTrace();
     } else {
       message += "(no stacktrace logged)";
       print(message, System.err);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -296,8 +296,7 @@ public void testGetAdditionalTopSuggestions() throws Exception {
     assertFirstSuggestion("Einzigste", "Einzige", rule, lt);
     assertFirstSuggestion("namenhafte", "namhafte", rule, lt);
     assertFirstSuggestion("homeophatisch", "homöopathisch", rule, lt);
-    assertFirstSuggestion("verswindet
-", "verschwindet", rule, lt);
+    assertFirstSuggestion("verswindet", "verschwindet", rule, lt);
   }
 
   @Test

File: languagetool-language-modules/da/src/main/java/org/languagetool/language/Danish.java
Patch:
@@ -95,7 +95,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new GenericUnpairedBracketsRule(messages,
                     Arrays.asList("[", "(", "{", "\"", "”"),
                     Arrays.asList("]", ")", "}", "\"", "”")),
-            new HunspellNoSuggestionRule(messages, this, null, altLanguages),
+            new HunspellNoSuggestionRule(messages, this, userConfig, altLanguages),
             new UppercaseSentenceStartRule(messages, this),  // abbreviation exceptions, done in DanishSentenceTokenizer
             // "WORD_REPEAT_RULE" implemented in grammar.xml
             new MultipleWhitespaceRule(messages, this)

File: languagetool-language-modules/el/src/main/java/org/languagetool/language/Greek.java
Patch:
@@ -84,7 +84,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
                     Arrays.asList("[", "(", "{", "“", "\"", "«"),
                     Arrays.asList("]", ")", "}", "”", "\"", "»")),
             new LongSentenceRule(messages, userConfig),
-            new MorfologikGreekSpellerRule(messages, this, null, altLanguages),
+            new MorfologikGreekSpellerRule(messages, this, userConfig, altLanguages),
             new UppercaseSentenceStartRule(messages, this,
                     Example.wrong("Η τελεία είναι σημείο στίξης. <marker>δείχνει</marker> το τέλος μίας πρότασης."),
                     Example.fixed("Η τελεία είναι σημείο στίξης. <marker>Δείχνει</marker> το τέλος μίας πρότασης.")),

File: languagetool-language-modules/ml/src/main/java/org/languagetool/language/Malayalam.java
Patch:
@@ -94,7 +94,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new CommaWhitespaceRule(messages),
             new DoublePunctuationRule(messages),
             new GenericUnpairedBracketsRule(messages),
-            new MorfologikMalayalamSpellerRule(messages, this, null, altLanguages),
+            new MorfologikMalayalamSpellerRule(messages, this, userConfig, altLanguages),
             new UppercaseSentenceStartRule(messages, this),
             new WordRepeatRule(messages, this),
             new MultipleWhitespaceRule(messages, this)

File: languagetool-language-modules/sr/src/main/java/org/languagetool/language/JekavianSerbian.java
Patch:
@@ -66,7 +66,7 @@ public Synthesizer getSynthesizer() {
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, List<Language> altLanguages) throws IOException {
     List<Rule> rules = new ArrayList<>(getBasicRules(messages));
     // Rules specific for Jekavian Serbian
-    rules.add(new MorfologikJekavianSpellerRule(messages, this, null, altLanguages));
+    rules.add(new MorfologikJekavianSpellerRule(messages, this, userConfig, altLanguages));
     rules.add(new SimpleGrammarJekavianReplaceRule(messages));
     rules.add(new SimpleStyleJekavianReplaceRule(messages));
     return rules;

File: languagetool-language-modules/sr/src/main/java/org/languagetool/language/Serbian.java
Patch:
@@ -163,7 +163,7 @@ protected List<Rule> getBasicRules(ResourceBundle messages) {
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, List<Language> altLanguages)
           throws IOException {
     List<Rule> rules = new ArrayList<>(getBasicRules(messages));
-    rules.add(new MorfologikEkavianSpellerRule(messages, this, null, altLanguages));
+    rules.add(new MorfologikEkavianSpellerRule(messages, this, userConfig, altLanguages));
     rules.add(new SimpleGrammarEkavianReplaceRule(messages));
     rules.add(new SimpleStyleEkavianReplaceRule(messages));
     return rules;

File: languagetool-language-modules/tl/src/main/java/org/languagetool/language/Tagalog.java
Patch:
@@ -102,7 +102,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new UppercaseSentenceStartRule(messages, this),
             new MultipleWhitespaceRule(messages, this),
             // specific to Tagalog:
-            new MorfologikTagalogSpellerRule(messages, this, null, altLanguages)
+            new MorfologikTagalogSpellerRule(messages, this, userConfig, altLanguages)
     );
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/CompoundAwareHunspellRule.java
Patch:
@@ -50,8 +50,8 @@ public CompoundAwareHunspellRule(ResourceBundle messages, Language language, Com
    * @since 4.3
    */
   public CompoundAwareHunspellRule(ResourceBundle messages, Language language, CompoundWordTokenizer compoundSplitter, 
-                                   MorfologikMultiSpeller morfoSpeller, UserConfig userConfig, List<Language> alternativeLanguages) {
-    super(messages, language, userConfig, alternativeLanguages);
+                                   MorfologikMultiSpeller morfoSpeller, UserConfig userConfig, List<Language> altLanguages) {
+    super(messages, language, userConfig, altLanguages);
     this.compoundSplitter = compoundSplitter;
     this.morfoSpeller = morfoSpeller;
   }

File: languagetool-language-modules/ast/src/main/java/org/languagetool/language/Asturian.java
Patch:
@@ -67,7 +67,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new CommaWhitespaceRule(messages),
             new DoublePunctuationRule(messages),
             new GenericUnpairedBracketsRule(messages),
-            new MorfologikAsturianSpellerRule(messages, this, userConfig),
+            new MorfologikAsturianSpellerRule(messages, this, userConfig, altLanguages),
             new UppercaseSentenceStartRule(messages, this),
             new MultipleWhitespaceRule(messages, this)
     );

File: languagetool-language-modules/ast/src/main/java/org/languagetool/language/rules/ast/MorfologikAsturianSpellerRule.java
Patch:
@@ -23,15 +23,16 @@
 import org.languagetool.rules.spelling.morfologik.MorfologikSpellerRule;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 /**
  * @since 2.8
  */
 public class MorfologikAsturianSpellerRule extends MorfologikSpellerRule {
 
-  public MorfologikAsturianSpellerRule(ResourceBundle messages, Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+  public MorfologikAsturianSpellerRule(ResourceBundle messages, Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
   }
 
   @Override

File: languagetool-language-modules/ast/src/test/java/org/languagetool/language/rules/ast/MorfologikAsturianSpellerRuleTest.java
Patch:
@@ -25,6 +25,7 @@
 import org.languagetool.rules.RuleMatch;
 
 import java.io.IOException;
+import java.util.Collections;
 
 import static org.junit.Assert.assertEquals;
 
@@ -33,7 +34,7 @@ public class MorfologikAsturianSpellerRuleTest {
   @Test
   public void testMorfologikSpeller() throws IOException {
     Asturian language = new Asturian();
-    MorfologikAsturianSpellerRule rule = new MorfologikAsturianSpellerRule(TestTools.getMessages("en"), language, null);
+    MorfologikAsturianSpellerRule rule = new MorfologikAsturianSpellerRule(TestTools.getMessages("en"), language, null, Collections.emptyList());
     JLanguageTool langTool = new JLanguageTool(language);
 
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("¿Festeyate colos correutores gramaticales?")).length);

File: languagetool-language-modules/be/src/main/java/org/languagetool/language/Belarusian.java
Patch:
@@ -85,7 +85,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
     return Arrays.asList(
             new CommaWhitespaceRule(messages),
             new DoublePunctuationRule(messages),
-            new MorfologikBelarusianSpellerRule(messages, this, userConfig),
+            new MorfologikBelarusianSpellerRule(messages, this, userConfig, altLanguages),
             new UppercaseSentenceStartRule(messages, this),
             new MultipleWhitespaceRule(messages, this)
     );

File: languagetool-language-modules/be/src/main/java/org/languagetool/rules/be/MorfologikBelarusianSpellerRule.java
Patch:
@@ -20,6 +20,7 @@
 package org.languagetool.rules.be;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 import org.languagetool.Language;
@@ -31,8 +32,8 @@ public final class MorfologikBelarusianSpellerRule extends MorfologikSpellerRule
   private static final String RESOURCE_FILENAME = "/be/hunspell/be_BY.dict";
 
   public MorfologikBelarusianSpellerRule(ResourceBundle messages,
-                                     Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+                                         Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
   }
 
   @Override

File: languagetool-language-modules/br/src/main/java/org/languagetool/language/Breton.java
Patch:
@@ -108,7 +108,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
     return Arrays.asList(
             new CommaWhitespaceRule(messages),
             new DoublePunctuationRule(messages),
-            new MorfologikBretonSpellerRule(messages, this, userConfig),
+            new MorfologikBretonSpellerRule(messages, this, userConfig, altLanguages),
             new UppercaseSentenceStartRule(messages, this),
             new MultipleWhitespaceRule(messages, this),
             new SentenceWhitespaceRule(messages),

File: languagetool-language-modules/br/src/main/java/org/languagetool/rules/br/MorfologikBretonSpellerRule.java
Patch:
@@ -20,6 +20,7 @@
 package org.languagetool.rules.br;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 import java.util.regex.Pattern;
 
@@ -34,8 +35,8 @@ public final class MorfologikBretonSpellerRule extends MorfologikSpellerRule {
   private static final Pattern BRETON_TOKENIZING_CHARS = Pattern.compile("-");
 
   public MorfologikBretonSpellerRule(ResourceBundle messages,
-                                     Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+                                     Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
     this.setIgnoreTaggedWords();
   }
 

File: languagetool-language-modules/br/src/test/java/org/languagetool/rules/br/MorfologikBretonSpellerRuleTest.java
Patch:
@@ -25,6 +25,7 @@
 import org.languagetool.rules.RuleMatch;
 
 import java.io.IOException;
+import java.util.Collections;
 
 import static org.junit.Assert.assertEquals;
 
@@ -33,7 +34,7 @@ public class MorfologikBretonSpellerRuleTest {
   @Test
   public void testMorfologikSpeller() throws IOException {
     final MorfologikBretonSpellerRule rule =
-            new MorfologikBretonSpellerRule (TestTools.getMessages("br"), new Breton(), null);
+            new MorfologikBretonSpellerRule (TestTools.getMessages("br"), new Breton(), null, Collections.emptyList());
 
     RuleMatch[] matches;
     final JLanguageTool langTool = new JLanguageTool(new Breton());

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -105,7 +105,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new LongSentenceRule(messages, userConfig),
             // specific to Catalan:
             new CatalanWordRepeatRule(messages, this),
-            new MorfologikCatalanSpellerRule(messages, this, userConfig),
+            new MorfologikCatalanSpellerRule(messages, this, userConfig, altLanguages),
             new CatalanUnpairedQuestionMarksRule(messages, this),
             new CatalanUnpairedExclamationMarksRule(messages, this),
             new AccentuationCheckRule(messages),

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/ValencianCatalan.java
Patch:
@@ -85,7 +85,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new LongSentenceRule(messages, userConfig),
             // specific to Catalan:
             new CatalanWordRepeatRule(messages, this),
-            new MorfologikCatalanSpellerRule(messages, this, userConfig),
+            new MorfologikCatalanSpellerRule(messages, this, userConfig, altLanguages),
             new CatalanUnpairedQuestionMarksRule(messages, this),
             new CatalanUnpairedExclamationMarksRule(messages, this),
             new AccentuationCheckRule(messages),

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/MorfologikCatalanSpellerRule.java
Patch:
@@ -53,8 +53,8 @@ public final class MorfologikCatalanSpellerRule extends MorfologikSpellerRule {
   private static final Pattern VERB_INFGERIMP = Pattern.compile("V.[NGM].*");
   private CatalanTagger tagger;
 
-  public MorfologikCatalanSpellerRule(ResourceBundle messages, Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+  public MorfologikCatalanSpellerRule(ResourceBundle messages, Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
     this.setIgnoreTaggedWords();
     tagger = new CatalanTagger(language);
     dictFilename = "/ca/" + language.getShortCodeWithCountryAndVariant() + ".dict";

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/MorfologikCatalanSpellerRuleTest.java
Patch:
@@ -27,6 +27,7 @@
 import org.languagetool.rules.RuleMatch;
 
 import java.io.IOException;
+import java.util.Collections;
 
 import static org.junit.Assert.assertEquals;
 
@@ -35,7 +36,7 @@ public class MorfologikCatalanSpellerRuleTest {
     @Test
     public void testMorfologikSpeller() throws IOException {
         MorfologikCatalanSpellerRule rule =
-                new MorfologikCatalanSpellerRule (TestTools.getMessages("ca"), new Catalan(), null);
+                new MorfologikCatalanSpellerRule (TestTools.getMessages("ca"), new Catalan(), null, Collections.emptyList());
 
         RuleMatch[] matches;
         JLanguageTool langTool = new JLanguageTool(new Catalan());

File: languagetool-language-modules/da/src/main/java/org/languagetool/language/Danish.java
Patch:
@@ -95,7 +95,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new GenericUnpairedBracketsRule(messages,
                     Arrays.asList("[", "(", "{", "\"", "”"),
                     Arrays.asList("]", ")", "}", "\"", "”")),
-            new HunspellNoSuggestionRule(messages, this, null),
+            new HunspellNoSuggestionRule(messages, this, null, altLanguages),
             new UppercaseSentenceStartRule(messages, this),  // abbreviation exceptions, done in DanishSentenceTokenizer
             // "WORD_REPEAT_RULE" implemented in grammar.xml
             new MultipleWhitespaceRule(messages, this)

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/MorfologikGermanyGermanSpellerRule.java
Patch:
@@ -20,6 +20,7 @@
 package org.languagetool.rules.de;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 import org.languagetool.Language;
@@ -37,8 +38,8 @@ public final class MorfologikGermanyGermanSpellerRule extends MorfologikSpellerR
   private static final String RESOURCE_FILENAME = "/de/hunspell/de_DE.dict";
 
   public MorfologikGermanyGermanSpellerRule(ResourceBundle messages,
-                                            Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+                                            Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
     addExamplePair(Example.wrong("LanguageTool kann mehr als eine <marker>nromale</marker> Rechtschreibprüfung."),
                    Example.fixed("LanguageTool kann mehr als eine <marker>normale</marker> Rechtschreibprüfung."));
   }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/MorfologikGermanyGermanSpellerRuleTest.java
Patch:
@@ -32,6 +32,7 @@
 import java.net.URL;
 import java.nio.charset.CharacterCodingException;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
 import static org.hamcrest.CoreMatchers.is;
@@ -44,7 +45,7 @@ public class MorfologikGermanyGermanSpellerRuleTest {
   @Test
   public void testMorfologikSpeller() throws IOException {
     MorfologikGermanyGermanSpellerRule rule =
-          new MorfologikGermanyGermanSpellerRule(TestTools.getMessages("en"), new German(), null);
+          new MorfologikGermanyGermanSpellerRule(TestTools.getMessages("en"), new German(), null, Collections.emptyList());
     JLanguageTool lt = new JLanguageTool(new German());
 
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Hier stimmt jedes Wort!")).length);

File: languagetool-language-modules/el/src/main/java/org/languagetool/language/Greek.java
Patch:
@@ -84,7 +84,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
                     Arrays.asList("[", "(", "{", "“", "\"", "«"),
                     Arrays.asList("]", ")", "}", "”", "\"", "»")),
             new LongSentenceRule(messages, userConfig),
-            new MorfologikGreekSpellerRule(messages, this, null),
+            new MorfologikGreekSpellerRule(messages, this, null, altLanguages),
             new UppercaseSentenceStartRule(messages, this,
                     Example.wrong("Η τελεία είναι σημείο στίξης. <marker>δείχνει</marker> το τέλος μίας πρότασης."),
                     Example.fixed("Η τελεία είναι σημείο στίξης. <marker>Δείχνει</marker> το τέλος μίας πρότασης.")),

File: languagetool-language-modules/el/src/main/java/org/languagetool/rules/el/MorfologikGreekSpellerRule.java
Patch:
@@ -20,6 +20,7 @@
 package org.languagetool.rules.el;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 import org.languagetool.Language;
@@ -31,8 +32,8 @@ public final class MorfologikGreekSpellerRule extends MorfologikSpellerRule {
   private static final String RESOURCE_FILENAME = "/el/hunspell/el_GR.dict";
 
   public MorfologikGreekSpellerRule(ResourceBundle messages,
-                                    Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+                                    Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
   }
 
   @Override

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/AmericanEnglish.java
Patch:
@@ -46,7 +46,7 @@ public String getName() {
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, List<Language> altLanguages) throws IOException {
     List<Rule> rules = new ArrayList<>();
     rules.addAll(super.getRelevantRules(messages, userConfig, altLanguages));
-    rules.add(new MorfologikAmericanSpellerRule(messages, this, userConfig));
+    rules.add(new MorfologikAmericanSpellerRule(messages, this, userConfig, altLanguages));
     rules.add(new UnitConversionRuleUS(messages));
     return rules;
   }

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/AustralianEnglish.java
Patch:
@@ -46,7 +46,7 @@ public String getName() {
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, List<Language> altLanguages) throws IOException {
     List<Rule> rules = new ArrayList<>();
     rules.addAll(super.getRelevantRules(messages, userConfig, altLanguages));    
-    rules.add(new MorfologikAustralianSpellerRule(messages, this, userConfig));
+    rules.add(new MorfologikAustralianSpellerRule(messages, this, userConfig, altLanguages));
     rules.add(new UnitConversionRuleImperial(messages));
     return rules;
   }

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/BritishEnglish.java
Patch:
@@ -48,7 +48,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
     List<Rule> rules = new ArrayList<>();
     rules.addAll(super.getRelevantRules(messages, userConfig, altLanguages));
     rules.add(new BritishReplaceRule(messages));
-    rules.add(new MorfologikBritishSpellerRule(messages, this, userConfig));
+    rules.add(new MorfologikBritishSpellerRule(messages, this, userConfig, altLanguages));
     rules.add(new UnitConversionRuleImperial(messages));
     return rules;
   }

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/CanadianEnglish.java
Patch:
@@ -46,7 +46,7 @@ public String getName() {
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, List<Language> altLanguages) throws IOException {
     List<Rule> rules = new ArrayList<>();
     rules.addAll(super.getRelevantRules(messages, userConfig, altLanguages));
-    rules.add(new MorfologikCanadianSpellerRule(messages, this, userConfig));
+    rules.add(new MorfologikCanadianSpellerRule(messages, this, userConfig, altLanguages));
     rules.add(new UnitConversionRuleImperial(messages));
     return rules;
   }

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/NewZealandEnglish.java
Patch:
@@ -47,7 +47,7 @@ public String getName() {
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, List<Language> altLanguages) throws IOException {
     List<Rule> rules = new ArrayList<>();
     rules.addAll(super.getRelevantRules(messages, userConfig, altLanguages));
-    rules.add(new MorfologikNewZealandSpellerRule(messages, this, userConfig));
+    rules.add(new MorfologikNewZealandSpellerRule(messages, this, userConfig, altLanguages));
     rules.add(new NewZealandReplaceRule(messages));
     rules.add(new UnitConversionRuleImperial(messages));
     return rules;

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/SouthAfricanEnglish.java
Patch:
@@ -45,7 +45,7 @@ public String getName() {
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, List<Language> altLanguages) throws IOException {
     List<Rule> rules = new ArrayList<>();
     rules.addAll(super.getRelevantRules(messages, userConfig, altLanguages));
-    rules.add(new MorfologikSouthAfricanSpellerRule(messages, this, userConfig));
+    rules.add(new MorfologikSouthAfricanSpellerRule(messages, this, userConfig, altLanguages));
     return rules;
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/MorfologikAustralianSpellerRule.java
Patch:
@@ -20,6 +20,7 @@
 package org.languagetool.rules.en;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 import org.languagetool.Language;
@@ -31,8 +32,8 @@ public final class MorfologikAustralianSpellerRule extends AbstractEnglishSpelle
   private static final String LANGUAGE_SPECIFIC_PLAIN_TEXT_DICT = "en/hunspell/spelling_en-AU.txt";
 
   public MorfologikAustralianSpellerRule(ResourceBundle messages,
-                                         Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+                                         Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
   }
 
   @Override

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/MorfologikBritishSpellerRule.java
Patch:
@@ -20,6 +20,7 @@
 package org.languagetool.rules.en;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 import org.languagetool.Language;
@@ -32,8 +33,8 @@ public final class MorfologikBritishSpellerRule extends AbstractEnglishSpellerRu
   private static final String RESOURCE_FILENAME = "/en/hunspell/en_GB.dict";
   private static final String LANGUAGE_SPECIFIC_PLAIN_TEXT_DICT = "en/hunspell/spelling_en-GB.txt";
 
-  public MorfologikBritishSpellerRule(ResourceBundle messages, Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+  public MorfologikBritishSpellerRule(ResourceBundle messages, Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
   }
 
   @Override

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/MorfologikCanadianSpellerRule.java
Patch:
@@ -20,6 +20,7 @@
 package org.languagetool.rules.en;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 import org.languagetool.Language;
@@ -31,8 +32,8 @@ public final class MorfologikCanadianSpellerRule extends AbstractEnglishSpellerR
   private static final String LANGUAGE_SPECIFIC_PLAIN_TEXT_DICT = "en/hunspell/spelling_en-CA.txt";
 
   public MorfologikCanadianSpellerRule(ResourceBundle messages,
-                                       Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+                                       Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
   }
 
   @Override

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/MorfologikNewZealandSpellerRule.java
Patch:
@@ -20,6 +20,7 @@
 package org.languagetool.rules.en;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 import org.languagetool.Language;
@@ -31,8 +32,8 @@ public final class MorfologikNewZealandSpellerRule extends AbstractEnglishSpelle
   private static final String LANGUAGE_SPECIFIC_PLAIN_TEXT_DICT = "en/hunspell/spelling_en-NZ.txt";
 
   public MorfologikNewZealandSpellerRule(ResourceBundle messages,
-                                         Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+                                         Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
   }
 
   @Override

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/MorfologikSouthAfricanSpellerRule.java
Patch:
@@ -20,6 +20,7 @@
 package org.languagetool.rules.en;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 import org.languagetool.Language;
@@ -31,8 +32,8 @@ public final class MorfologikSouthAfricanSpellerRule extends AbstractEnglishSpel
   private static final String LANGUAGE_SPECIFIC_PLAIN_TEXT_DICT = "en/hunspell/spelling_en-ZA.txt";
 
   public MorfologikSouthAfricanSpellerRule(ResourceBundle messages,
-                                           Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+                                           Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
   }
 
   @Override

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikAmericanSpellerRuleTest.java
Patch:
@@ -31,6 +31,7 @@
 
 import java.io.IOException;
 import java.util.Arrays;
+import java.util.Collections;
 
 import static org.hamcrest.CoreMatchers.is;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -51,7 +52,7 @@ public static void setup() throws IOException {
     rule = new MorfologikAmericanSpellerRule(TestTools.getMessages("en"), language);
     langTool = new JLanguageTool(language);
     CanadianEnglish canadianEnglish = new CanadianEnglish();
-    caRule = new MorfologikCanadianSpellerRule(TestTools.getMessages("en"), canadianEnglish, null);
+    caRule = new MorfologikCanadianSpellerRule(TestTools.getMessages("en"), canadianEnglish, null, Collections.emptyList());
     caLangTool = new JLanguageTool(canadianEnglish);
   }
 
@@ -66,7 +67,7 @@ public void testSuggestions() throws IOException {
   public void testUserDict() throws IOException {
     Language language = new AmericanEnglish();
     UserConfig userConfig = new UserConfig(Arrays.asList("mytestword", "mytesttwo"));
-    Rule rule = new MorfologikAmericanSpellerRule(TestTools.getMessages("en"), language, userConfig);
+    Rule rule = new MorfologikAmericanSpellerRule(TestTools.getMessages("en"), language, userConfig, Collections.emptyList());
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("mytestword")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("mytesttwo")).length);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("mytestthree")).length);

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikAustralianSpellerRuleTest.java
Patch:
@@ -24,6 +24,7 @@
 import static org.junit.Assert.assertTrue;
 
 import java.io.IOException;
+import java.util.Collections;
 
 import org.junit.Test;
 import org.languagetool.JLanguageTool;
@@ -38,7 +39,7 @@ public class MorfologikAustralianSpellerRuleTest extends AbstractEnglishSpellerR
   @Test
   public void testSuggestions() throws IOException {
     Language language = new AustralianEnglish();
-    Rule rule = new MorfologikAustralianSpellerRule(TestTools.getMessages("en"), language, null);
+    Rule rule = new MorfologikAustralianSpellerRule(TestTools.getMessages("en"), language, null, Collections.emptyList());
     super.testNonVariantSpecificSuggestions(rule, language);
 
     JLanguageTool langTool = new JLanguageTool(language);
@@ -50,7 +51,7 @@ public void testSuggestions() throws IOException {
   public void testMorfologikSpeller() throws IOException {
     AustralianEnglish language = new AustralianEnglish();
     MorfologikAustralianSpellerRule rule =
-            new MorfologikAustralianSpellerRule(TestTools.getMessages("en"), language, null);
+            new MorfologikAustralianSpellerRule(TestTools.getMessages("en"), language, null, Collections.emptyList());
 
     JLanguageTool langTool = new JLanguageTool(language);
 

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikBritishSpellerRuleTest.java
Patch:
@@ -24,6 +24,7 @@
 import static org.junit.Assert.assertTrue;
 
 import java.io.IOException;
+import java.util.Collections;
 
 import org.junit.Test;
 import org.languagetool.JLanguageTool;
@@ -38,7 +39,7 @@ public class MorfologikBritishSpellerRuleTest extends AbstractEnglishSpellerRule
   @Test
   public void testSuggestions() throws IOException {
     Language language = new BritishEnglish();
-    Rule rule = new MorfologikBritishSpellerRule(TestTools.getMessages("en"), language, null);
+    Rule rule = new MorfologikBritishSpellerRule(TestTools.getMessages("en"), language, null, Collections.emptyList());
     super.testNonVariantSpecificSuggestions(rule, language);
 
     JLanguageTool langTool = new JLanguageTool(language);
@@ -50,7 +51,7 @@ public void testSuggestions() throws IOException {
   public void testMorfologikSpeller() throws IOException {
     BritishEnglish language = new BritishEnglish();
     MorfologikBritishSpellerRule rule =
-            new MorfologikBritishSpellerRule(TestTools.getMessages("en"), language, null);
+            new MorfologikBritishSpellerRule(TestTools.getMessages("en"), language, null, Collections.emptyList());
 
     JLanguageTool langTool = new JLanguageTool(language);
 

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikCanadianSpellerRuleTest.java
Patch:
@@ -24,6 +24,7 @@
 import static org.junit.Assert.assertTrue;
 
 import java.io.IOException;
+import java.util.Collections;
 
 import org.junit.Test;
 import org.languagetool.JLanguageTool;
@@ -38,7 +39,7 @@ public class MorfologikCanadianSpellerRuleTest extends AbstractEnglishSpellerRul
   @Test
   public void testSuggestions() throws IOException {
     Language language = new CanadianEnglish();
-    Rule rule = new MorfologikCanadianSpellerRule(TestTools.getMessages("en"), language, null);
+    Rule rule = new MorfologikCanadianSpellerRule(TestTools.getMessages("en"), language, null, Collections.emptyList());
     super.testNonVariantSpecificSuggestions(rule, language);
 
     JLanguageTool langTool = new JLanguageTool(language);
@@ -50,7 +51,7 @@ public void testSuggestions() throws IOException {
   public void testMorfologikSpeller() throws IOException {
     CanadianEnglish language = new CanadianEnglish();
     MorfologikBritishSpellerRule rule =
-            new MorfologikBritishSpellerRule(TestTools.getMessages("en"), language, null);
+            new MorfologikBritishSpellerRule(TestTools.getMessages("en"), language, null, Collections.emptyList());
 
     JLanguageTool langTool = new JLanguageTool(language);
 

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikNewZealandSpellerRuleTest.java
Patch:
@@ -21,6 +21,7 @@
 import static org.junit.Assert.assertEquals;
 
 import java.io.IOException;
+import java.util.Collections;
 
 import org.junit.Test;
 import org.languagetool.JLanguageTool;
@@ -35,15 +36,15 @@ public class MorfologikNewZealandSpellerRuleTest extends AbstractEnglishSpellerR
   @Test
   public void testSuggestions() throws IOException {
     Language language = new NewZealandEnglish();
-    Rule rule = new MorfologikNewZealandSpellerRule(TestTools.getMessages("en"), language, null);
+    Rule rule = new MorfologikNewZealandSpellerRule(TestTools.getMessages("en"), language, null, Collections.emptyList());
     super.testNonVariantSpecificSuggestions(rule, language);
   }
 
   @Test
   public void testMorfologikSpeller() throws IOException {
     NewZealandEnglish language = new NewZealandEnglish();
     MorfologikNewZealandSpellerRule rule =
-            new MorfologikNewZealandSpellerRule(TestTools.getMessages("en"), language, null);
+            new MorfologikNewZealandSpellerRule(TestTools.getMessages("en"), language, null, Collections.emptyList());
 
     JLanguageTool langTool = new JLanguageTool(language);
 

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikSouthAfricanSpellerRuleTest.java
Patch:
@@ -24,6 +24,7 @@
 import static org.junit.Assert.assertTrue;
 
 import java.io.IOException;
+import java.util.Collections;
 
 import org.junit.Test;
 import org.languagetool.JLanguageTool;
@@ -38,7 +39,7 @@ public class MorfologikSouthAfricanSpellerRuleTest extends AbstractEnglishSpelle
   @Test
   public void testSuggestions() throws IOException {
     Language language = new SouthAfricanEnglish();
-    Rule rule = new MorfologikSouthAfricanSpellerRule(TestTools.getMessages("en"), language, null);
+    Rule rule = new MorfologikSouthAfricanSpellerRule(TestTools.getMessages("en"), language, null, Collections.emptyList());
     super.testNonVariantSpecificSuggestions(rule, language);
 
     JLanguageTool langTool = new JLanguageTool(language);
@@ -50,7 +51,7 @@ public void testSuggestions() throws IOException {
   public void testMorfologikSpeller() throws IOException {
     SouthAfricanEnglish language = new SouthAfricanEnglish();
     MorfologikSouthAfricanSpellerRule rule =
-            new MorfologikSouthAfricanSpellerRule (TestTools.getMessages("en"), language, null);
+            new MorfologikSouthAfricanSpellerRule (TestTools.getMessages("en"), language, null, Collections.emptyList());
 
     JLanguageTool langTool = new JLanguageTool(language);
 

File: languagetool-language-modules/eo/src/main/java/org/languagetool/language/Esperanto.java
Patch:
@@ -97,7 +97,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new CommaWhitespaceRule(messages),
             new DoublePunctuationRule(messages),
             new GenericUnpairedBracketsRule(messages),
-            new HunspellNoSuggestionRule(messages, this, userConfig),
+            new HunspellNoSuggestionRule(messages, this, userConfig, altLanguages),
             new UppercaseSentenceStartRule(messages, this),
             new WordRepeatRule(messages, this),
             new MultipleWhitespaceRule(messages, this),

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -125,7 +125,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new GenericUnpairedBracketsRule(messages,
                     Arrays.asList("[", "(", "{", "“", "«", "»", "¿", "¡"),
                     Arrays.asList("]", ")", "}", "”", "»", "«", "?", "!")),
-            new MorfologikSpanishSpellerRule(messages, this, userConfig),
+            new MorfologikSpanishSpellerRule(messages, this, userConfig, altLanguages),
             new UppercaseSentenceStartRule(messages, this),
             new WordRepeatRule(messages, this),
             new MultipleWhitespaceRule(messages, this),

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/MorfologikSpanishSpellerRule.java
Patch:
@@ -23,15 +23,16 @@
 import org.languagetool.rules.spelling.morfologik.MorfologikSpellerRule;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 /**
  * @since 2.8
  */
 public class MorfologikSpanishSpellerRule extends MorfologikSpellerRule {
 
-  public MorfologikSpanishSpellerRule(ResourceBundle messages, Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+  public MorfologikSpanishSpellerRule(ResourceBundle messages, Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
   }
 
   @Override

File: languagetool-language-modules/es/src/test/java/org/languagetool/rules/es/MorfologikSpanishSpellerRuleTest.java
Patch:
@@ -25,6 +25,7 @@
 import org.languagetool.rules.RuleMatch;
 
 import java.io.IOException;
+import java.util.Collections;
 
 import static org.junit.Assert.assertEquals;
 
@@ -33,7 +34,7 @@ public class MorfologikSpanishSpellerRuleTest {
   @Test
   public void testMorfologikSpeller() throws IOException {
     Spanish language = new Spanish();
-    MorfologikSpanishSpellerRule rule = new MorfologikSpanishSpellerRule(TestTools.getMessages("en"), language, null);
+    MorfologikSpanishSpellerRule rule = new MorfologikSpanishSpellerRule(TestTools.getMessages("en"), language, null, Collections.emptyList());
     JLanguageTool langTool = new JLanguageTool(language);
 
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Escriba un texto aquí. LanguageTool le ayudará a afrontar algunas dificultades propias de la escritura.")).length);

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -116,7 +116,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             // very fast, but no suggestions:
             //new HunspellNoSuggestionRule(messages, this, Example.wrong("Le <marker>chein</marker> noir"), Example.fixed("Le <marker>chien</marker> noir")),
             // slower than HunspellNoSuggestionRule but with suggestions:
-            new FrenchCompoundAwareHunspellRule(messages, this, userConfig),
+            new FrenchCompoundAwareHunspellRule(messages, this, userConfig, altLanguages),
             new UppercaseSentenceStartRule(messages, this),
             new MultipleWhitespaceRule(messages, this),
             new SentenceWhitespaceRule(messages),

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/FrenchCompoundAwareHunspellRule.java
Patch:
@@ -36,8 +36,8 @@
  */
 public class FrenchCompoundAwareHunspellRule extends CompoundAwareHunspellRule {
   
-  public FrenchCompoundAwareHunspellRule(ResourceBundle messages, Language language, UserConfig userConfig) {
-    super(messages, language, new NonSplittingTokenizer(), getSpeller(language, userConfig), userConfig);
+  public FrenchCompoundAwareHunspellRule(ResourceBundle messages, Language language, UserConfig userConfig, List<Language> altLanguages) {
+    super(messages, language, new NonSplittingTokenizer(), getSpeller(language, userConfig), userConfig, altLanguages);
     addExamplePair(Example.wrong("Le <marker>chein</marker> noir"),
                    Example.fixed("Le <marker>chien</marker> noir"));
   }

File: languagetool-language-modules/gl/src/main/java/org/languagetool/language/Galician.java
Patch:
@@ -126,7 +126,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new GenericUnpairedBracketsRule(messages,
                     Arrays.asList("[", "(", "{", "“", "«", "»", "‘", "\"", "'"),
                     Arrays.asList("]", ")", "}", "”", "»", "«", "’", "\"", "'")),
-            new HunspellRule(messages, this, userConfig),
+            new HunspellRule(messages, this, userConfig, altLanguages),
             new UppercaseSentenceStartRule(messages, this,
                 Example.wrong("Esta casa é vella. <marker>foi</marker> construida en 1950."),
                 Example.fixed("Esta casa é vella. <marker>Foi</marker> construida en 1950.")),

File: languagetool-language-modules/is/src/main/java/org/languagetool/language/Icelandic.java
Patch:
@@ -84,7 +84,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new CommaWhitespaceRule(messages),
             new DoublePunctuationRule(messages),
             new GenericUnpairedBracketsRule(messages),
-            new HunspellNoSuggestionRule(messages, this, userConfig),
+            new HunspellNoSuggestionRule(messages, this, userConfig, altLanguages),
             new UppercaseSentenceStartRule(messages, this),
             new WordRepeatRule(messages, this),
             new MultipleWhitespaceRule(messages, this)

File: languagetool-language-modules/it/src/main/java/org/languagetool/language/Italian.java
Patch:
@@ -95,7 +95,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new GenericUnpairedBracketsRule(messages,
                     Arrays.asList("[", "(", "{", "»", "«" /*"‘"*/),
                     Arrays.asList("]", ")", "}", "«", "»" /*"’"*/)),
-            new MorfologikItalianSpellerRule(messages, this, userConfig),
+            new MorfologikItalianSpellerRule(messages, this, userConfig, altLanguages),
             new UppercaseSentenceStartRule(messages, this),
             new ItalianWordRepeatRule(messages, this),
             new MultipleWhitespaceRule(messages, this)

File: languagetool-language-modules/it/src/main/java/org/languagetool/rules/it/MorfologikItalianSpellerRule.java
Patch:
@@ -20,6 +20,7 @@
 package org.languagetool.rules.it;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 import org.languagetool.Language;
@@ -31,8 +32,8 @@ public final class MorfologikItalianSpellerRule extends MorfologikSpellerRule {
   private static final String RESOURCE_FILENAME = "/it/hunspell/it_IT.dict";
 
   public MorfologikItalianSpellerRule(ResourceBundle messages,
-                                      Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+                                      Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
   }
 
   @Override

File: languagetool-language-modules/km/src/main/java/org/languagetool/language/Khmer.java
Patch:
@@ -102,7 +102,7 @@ public Contributor[] getMaintainers() {
   @Override
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, List<Language> altLanguages) throws IOException {
     return Arrays.asList(
-      new HunspellRule(messages, this, userConfig),
+      new HunspellRule(messages, this, userConfig, altLanguages),
       // specific to Khmer:
       new KhmerSimpleReplaceRule(messages),
       new KhmerWordRepeatRule(messages, this),

File: languagetool-language-modules/lt/src/main/java/org/languagetool/language/Lithuanian.java
Patch:
@@ -83,7 +83,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new CommaWhitespaceRule(messages),
             new DoublePunctuationRule(messages),
             new GenericUnpairedBracketsRule(messages),
-            new MorfologikLithuanianSpellerRule(messages, this, userConfig),
+            new MorfologikLithuanianSpellerRule(messages, this, userConfig, altLanguages),
             new UppercaseSentenceStartRule(messages, this),
             new MultipleWhitespaceRule(messages, this)
     );

File: languagetool-language-modules/lt/src/main/java/org/languagetool/rules/lt/MorfologikLithuanianSpellerRule.java
Patch:
@@ -20,6 +20,7 @@
 package org.languagetool.rules.lt;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 import org.languagetool.Language;
@@ -31,8 +32,8 @@ public final class MorfologikLithuanianSpellerRule extends MorfologikSpellerRule
   private static final String RESOURCE_FILENAME = "/lt/hunspell/lt_LT.dict";
 
   public MorfologikLithuanianSpellerRule(ResourceBundle messages,
-                                         Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+                                         Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
   }
 
   @Override

File: languagetool-language-modules/ml/src/main/java/org/languagetool/language/Malayalam.java
Patch:
@@ -94,7 +94,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new CommaWhitespaceRule(messages),
             new DoublePunctuationRule(messages),
             new GenericUnpairedBracketsRule(messages),
-            new MorfologikMalayalamSpellerRule(messages, this, null),
+            new MorfologikMalayalamSpellerRule(messages, this, null, altLanguages),
             new UppercaseSentenceStartRule(messages, this),
             new WordRepeatRule(messages, this),
             new MultipleWhitespaceRule(messages, this)

File: languagetool-language-modules/ml/src/main/java/org/languagetool/rules/ml/MorfologikMalayalamSpellerRule.java
Patch:
@@ -20,6 +20,7 @@
 package org.languagetool.rules.ml;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 import org.languagetool.Language;
@@ -31,8 +32,8 @@ public final class MorfologikMalayalamSpellerRule extends MorfologikSpellerRule
   private static final String RESOURCE_FILENAME = "/ml/hunspell/ml_IN.dict";
 
   public MorfologikMalayalamSpellerRule(ResourceBundle messages,
-                                        Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+                                        Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
   }
 
   @Override

File: languagetool-language-modules/nl/src/main/java/org/languagetool/language/Dutch.java
Patch:
@@ -125,7 +125,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
                     Arrays.asList("[", "(", "{", "“", "‹", "“", "„", "\""),
                     Arrays.asList("]", ")", "}", "”", "›", "”", "”", "\"")),
             new UppercaseSentenceStartRule(messages, this),
-            new MorfologikDutchSpellerRule(messages, this, userConfig),
+            new MorfologikDutchSpellerRule(messages, this, userConfig, altLanguages),
             new MultipleWhitespaceRule(messages, this),
             new CompoundRule(messages),
             new DutchWrongWordInContextRule(messages),

File: languagetool-language-modules/pl/src/main/java/org/languagetool/language/Polish.java
Patch:
@@ -119,7 +119,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
         new SentenceWhitespaceRule(messages),
         // specific to Polish:
         new PolishUnpairedBracketsRule(messages, this),
-        new MorfologikPolishSpellerRule(messages, this, userConfig),
+        new MorfologikPolishSpellerRule(messages, this, userConfig, altLanguages),
         new PolishWordRepeatRule(messages),
         new CompoundRule(messages),
         new SimpleReplaceRule(messages),

File: languagetool-language-modules/pl/src/main/java/org/languagetool/rules/pl/MorfologikPolishSpellerRule.java
Patch:
@@ -88,8 +88,8 @@ public final class MorfologikPolishSpellerRule extends MorfologikSpellerRule {
   private final UserConfig userConfig;
 
   public MorfologikPolishSpellerRule(ResourceBundle messages,
-                                     Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+                                     Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
     setCategory(Categories.TYPOS.getCategory(messages));
     addExamplePair(Example.wrong("To jest zdanie z <marker>bledem</marker>"),
                    Example.fixed("To jest zdanie z <marker>błędem</marker>."));

File: languagetool-language-modules/pl/src/test/java/org/languagetool/rules/pl/CompoundRuleTest.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.Collections;
 import java.util.Scanner;
 
 import org.junit.Before;
@@ -52,7 +53,7 @@ public void testRule() throws IOException {
   @Test
   public void testCompoundFile() throws IOException {
     final MorfologikPolishSpellerRule spellRule =
-        new MorfologikPolishSpellerRule (TestTools.getMessages("pl"), new Polish(), null);
+        new MorfologikPolishSpellerRule (TestTools.getMessages("pl"), new Polish(), null, Collections.emptyList());
     final InputStream   file = JLanguageTool.getDataBroker().getFromResourceDirAsStream("/pl/compounds.txt");
     try (Scanner scanner = new Scanner(file, "UTF-8")) {
       while (scanner.hasNextLine()) {

File: languagetool-language-modules/pl/src/test/java/org/languagetool/rules/pl/MorfologikPolishSpellerRuleTest.java
Patch:
@@ -25,6 +25,7 @@
 import org.languagetool.rules.RuleMatch;
 
 import java.io.IOException;
+import java.util.Collections;
 
 import static org.junit.Assert.assertEquals;
 
@@ -33,7 +34,7 @@ public class MorfologikPolishSpellerRuleTest {
   @Test
   public void testMorfologikSpeller() throws IOException {
     final MorfologikPolishSpellerRule rule =
-        new MorfologikPolishSpellerRule (TestTools.getMessages("pl"), new Polish(), null);
+        new MorfologikPolishSpellerRule (TestTools.getMessages("pl"), new Polish(), null, Collections.emptyList());
 
     final JLanguageTool langTool = new JLanguageTool(new Polish());
 

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -143,7 +143,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new GenericUnpairedBracketsRule(messages,
                     Arrays.asList("[", "(", "{", "\"", "“" /*, "«", "'", "‘" */),
                     Arrays.asList("]", ")", "}", "\"", "”" /*, "»", "'", "’" */)),
-            new HunspellRule(messages, this, userConfig),
+            new HunspellRule(messages, this, userConfig, altLanguages),
             new LongSentenceRule(messages, userConfig, -1, true),
             new LongParagraphRule(messages, this, userConfig),
             new UppercaseSentenceStartRule(messages, this,

File: languagetool-language-modules/ro/src/main/java/org/languagetool/language/Romanian.java
Patch:
@@ -96,7 +96,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
                     Arrays.asList("]", ")", "}", "”", "»", "«")),
             new WordRepeatRule(messages, this),
             // specific to Romanian:
-            new MorfologikRomanianSpellerRule(messages, this, userConfig),
+            new MorfologikRomanianSpellerRule(messages, this, userConfig, altLanguages),
             new RomanianWordRepeatBeginningRule(messages, this),
             new SimpleReplaceRule(messages),
             new CompoundRule(messages)

File: languagetool-language-modules/ro/src/main/java/org/languagetool/rules/ro/MorfologikRomanianSpellerRule.java
Patch:
@@ -20,6 +20,7 @@
 package org.languagetool.rules.ro;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 import org.languagetool.Language;
@@ -31,8 +32,8 @@ public final class MorfologikRomanianSpellerRule extends MorfologikSpellerRule {
   private static final String RESOURCE_FILENAME = "/ro/hunspell/ro_RO.dict";
 
   public MorfologikRomanianSpellerRule(ResourceBundle messages,
-                                       Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+                                       Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
   }
 
   @Override

File: languagetool-language-modules/ru/src/main/java/org/languagetool/language/Russian.java
Patch:
@@ -118,7 +118,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new UppercaseSentenceStartRule(messages, this,
                     Example.wrong("Закончилось лето. <marker>дети</marker> снова сели за школьные парты."),
                     Example.fixed("Закончилось лето. <marker>Дети</marker> снова сели за школьные парты.")),
-            new MorfologikRussianSpellerRule(messages, this, userConfig),
+            new MorfologikRussianSpellerRule(messages, this, userConfig, altLanguages),
             new WordRepeatRule(messages, this),
             new MultipleWhitespaceRule(messages, this),
             // specific to Russian :

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/MorfologikRussianSpellerRule.java
Patch:
@@ -38,8 +38,8 @@ public final class MorfologikRussianSpellerRule extends MorfologikSpellerRule {
   private static final String RESOURCE_FILENAME = "/ru/hunspell/ru_RU.dict";
   private static final Pattern RUSSIAN_LETTERS = Pattern.compile(".*[а-яёА-ЯЁ].*");
 
-  public MorfologikRussianSpellerRule(ResourceBundle messages, Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+  public MorfologikRussianSpellerRule(ResourceBundle messages, Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
     addExamplePair(Example.wrong("Все счастливые семьи похожи друг на друга, <marker>каждя</marker> несчастливая семья несчастлива по-своему."),
                    Example.fixed("Все счастливые семьи похожи друг на друга, <marker>каждая</marker> несчастливая семья несчастлива по-своему."));
   }

File: languagetool-language-modules/sk/src/main/java/org/languagetool/language/Slovak.java
Patch:
@@ -106,7 +106,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new MultipleWhitespaceRule(messages, this),
             // specific to Slovak:
             new CompoundRule(messages),
-            new MorfologikSlovakSpellerRule(messages, this, userConfig)
+            new MorfologikSlovakSpellerRule(messages, this, userConfig, altLanguages)
             //new SlovakVesRule(messages)
     );
   }

File: languagetool-language-modules/sk/src/main/java/org/languagetool/rules/sk/MorfologikSlovakSpellerRule.java
Patch:
@@ -20,6 +20,7 @@
 package org.languagetool.rules.sk;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 import org.languagetool.Language;
@@ -31,8 +32,8 @@ public final class MorfologikSlovakSpellerRule extends MorfologikSpellerRule {
   private static final String RESOURCE_FILENAME = "/sk/hunspell/sk_SK.dict";
 
   public MorfologikSlovakSpellerRule(ResourceBundle messages,
-                                     Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+                                     Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
   }
 
   @Override

File: languagetool-language-modules/sl/src/main/java/org/languagetool/language/Slovenian.java
Patch:
@@ -74,7 +74,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new GenericUnpairedBracketsRule(messages,
                     Arrays.asList("[", "(", "{", "„", "»", "«", "\""),
                     Arrays.asList("]", ")", "}", "”", "«", "»", "\"")),
-            new MorfologikSlovenianSpellerRule(messages, this, userConfig),
+            new MorfologikSlovenianSpellerRule(messages, this, userConfig, altLanguages),
             new UppercaseSentenceStartRule(messages, this),
             new WordRepeatRule(messages, this),
             new MultipleWhitespaceRule(messages, this)

File: languagetool-language-modules/sl/src/main/java/org/languagetool/rules/sl/MorfologikSlovenianSpellerRule.java
Patch:
@@ -20,6 +20,7 @@
 package org.languagetool.rules.sl;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 import org.languagetool.Language;
@@ -31,8 +32,8 @@ public final class MorfologikSlovenianSpellerRule extends MorfologikSpellerRule
   private static final String RESOURCE_FILENAME = "/sl/hunspell/sl_SI.dict";
 
   public MorfologikSlovenianSpellerRule(ResourceBundle messages,
-                                        Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+                                        Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
   }
 
   @Override

File: languagetool-language-modules/sr/src/main/java/org/languagetool/language/JekavianSerbian.java
Patch:
@@ -66,7 +66,7 @@ public Synthesizer getSynthesizer() {
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, List<Language> altLanguages) throws IOException {
     List<Rule> rules = new ArrayList<>(getBasicRules(messages));
     // Rules specific for Jekavian Serbian
-    rules.add(new MorfologikJekavianSpellerRule(messages, this, null));
+    rules.add(new MorfologikJekavianSpellerRule(messages, this, null, altLanguages));
     rules.add(new SimpleGrammarJekavianReplaceRule(messages));
     rules.add(new SimpleStyleJekavianReplaceRule(messages));
     return rules;

File: languagetool-language-modules/sr/src/main/java/org/languagetool/language/Serbian.java
Patch:
@@ -163,7 +163,7 @@ protected List<Rule> getBasicRules(ResourceBundle messages) {
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig, List<Language> altLanguages)
           throws IOException {
     List<Rule> rules = new ArrayList<>(getBasicRules(messages));
-    rules.add(new MorfologikEkavianSpellerRule(messages, this, null));
+    rules.add(new MorfologikEkavianSpellerRule(messages, this, null, altLanguages));
     rules.add(new SimpleGrammarEkavianReplaceRule(messages));
     rules.add(new SimpleStyleEkavianReplaceRule(messages));
     return rules;

File: languagetool-language-modules/sr/src/main/java/org/languagetool/rules/sr/ekavian/MorfologikEkavianSpellerRule.java
Patch:
@@ -20,11 +20,11 @@
 
 import org.languagetool.Language;
 import org.languagetool.UserConfig;
-import org.languagetool.language.SerbianSerbian;
 import org.languagetool.rules.Example;
 import org.languagetool.rules.spelling.morfologik.MorfologikSpellerRule;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 
@@ -37,8 +37,8 @@ public class MorfologikEkavianSpellerRule extends MorfologikSpellerRule {
 
   public MorfologikEkavianSpellerRule(
           ResourceBundle messages,
-          Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+          Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
     addExamplePair(
             Example.wrong("Изгубила све сам <marker>бткие</marker>, ал' још водим рат."),
             Example.fixed("Изгубила све сам <marker>битке</marker>, ал' још водим рат.")

File: languagetool-language-modules/sr/src/main/java/org/languagetool/rules/sr/jekavian/MorfologikJekavianSpellerRule.java
Patch:
@@ -23,6 +23,7 @@
 import org.languagetool.rules.spelling.morfologik.MorfologikSpellerRule;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 
@@ -35,9 +36,8 @@ public final class MorfologikJekavianSpellerRule extends MorfologikSpellerRule {
 
   public MorfologikJekavianSpellerRule(
           ResourceBundle messages,
-          Language language, UserConfig userConfig) throws IOException {
-
-    super(messages, language, userConfig);
+          Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
     /*addExamplePair(
             Example.wrong("Двије сам <marker>зивдјезе</marker> видјела."),
             Example.fixed("Двије сам <marker>звијезде</marker> видјела.")

File: languagetool-language-modules/sr/src/test/java/org/languagetool/rules/sr/ekavian/MorfologikEkavianSpellerRuleTest.java
Patch:
@@ -26,6 +26,7 @@
 import org.languagetool.rules.Rule;
 
 import java.io.IOException;
+import java.util.Collections;
 
 import static org.junit.Assert.assertEquals;
 
@@ -36,7 +37,7 @@ public class MorfologikEkavianSpellerRuleTest {
 
   @Before
   public void setUp() throws Exception {
-    rule = new MorfologikEkavianSpellerRule(TestTools.getMessages("sr"), new SerbianSerbian(), null);
+    rule = new MorfologikEkavianSpellerRule(TestTools.getMessages("sr"), new SerbianSerbian(), null, Collections.emptyList());
     languageTool = new JLanguageTool(new SerbianSerbian());
   }
 

File: languagetool-language-modules/sr/src/test/java/org/languagetool/rules/sr/jekavian/MorfologikJekavianSpellerRuleTest.java
Patch:
@@ -26,6 +26,7 @@
 import org.languagetool.rules.Rule;
 
 import java.io.IOException;
+import java.util.Collections;
 
 import static org.junit.Assert.*;
 
@@ -36,7 +37,7 @@ public class MorfologikJekavianSpellerRuleTest {
 
   @Before
   public void setUp() throws Exception {
-    rule = new MorfologikJekavianSpellerRule(TestTools.getMessages("sr"), new JekavianSerbian(), null);
+    rule = new MorfologikJekavianSpellerRule(TestTools.getMessages("sr"), new JekavianSerbian(), null, Collections.emptyList());
     languageTool = new JLanguageTool(new JekavianSerbian());
   }
 

File: languagetool-language-modules/sv/src/main/java/org/languagetool/language/Swedish.java
Patch:
@@ -84,7 +84,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new CommaWhitespaceRule(messages),
             new DoublePunctuationRule(messages),
             new GenericUnpairedBracketsRule(messages),
-            new HunspellRule(messages, this, userConfig),
+            new HunspellRule(messages, this, userConfig, altLanguages),
             new UppercaseSentenceStartRule(messages, this),
             new WordRepeatRule(messages, this),
             new MultipleWhitespaceRule(messages, this),

File: languagetool-language-modules/tl/src/main/java/org/languagetool/language/Tagalog.java
Patch:
@@ -102,7 +102,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new UppercaseSentenceStartRule(messages, this),
             new MultipleWhitespaceRule(messages, this),
             // specific to Tagalog:
-            new MorfologikTagalogSpellerRule(messages, this, null)
+            new MorfologikTagalogSpellerRule(messages, this, null, altLanguages)
     );
   }
 

File: languagetool-language-modules/tl/src/main/java/org/languagetool/language/tl/MorfologikTagalogSpellerRule.java
Patch:
@@ -23,15 +23,16 @@
 import org.languagetool.rules.spelling.morfologik.MorfologikSpellerRule;
 
 import java.io.IOException;
+import java.util.List;
 import java.util.ResourceBundle;
 
 /**
  * @since 2.8
  */
 public class MorfologikTagalogSpellerRule extends MorfologikSpellerRule {
 
-  public MorfologikTagalogSpellerRule(ResourceBundle messages, Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+  public MorfologikTagalogSpellerRule(ResourceBundle messages, Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
   }
 
   @Override

File: languagetool-language-modules/tl/src/test/java/org/languagetool/language/tl/MorfologikTagalogSpellerRuleTest.java
Patch:
@@ -25,6 +25,7 @@
 import org.languagetool.rules.RuleMatch;
 
 import java.io.IOException;
+import java.util.Collections;
 
 import static org.junit.Assert.assertEquals;
 
@@ -33,7 +34,7 @@ public class MorfologikTagalogSpellerRuleTest {
   @Test
   public void testMorfologikSpeller() throws IOException {
     Tagalog language = new Tagalog();
-    MorfologikTagalogSpellerRule rule = new MorfologikTagalogSpellerRule(TestTools.getMessages("en"), language, null);
+    MorfologikTagalogSpellerRule rule = new MorfologikTagalogSpellerRule(TestTools.getMessages("en"), language, null, Collections.emptyList());
     JLanguageTool langTool = new JLanguageTool(language);
 
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Ang talatang ito ay nagpapakita ng ng kakayahan ng LanguageTool at halimbawa kung paano ito gamitin.")).length);

File: languagetool-language-modules/uk/src/main/java/org/languagetool/language/Ukrainian.java
Patch:
@@ -160,7 +160,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
 
         // TODO: does not handle !.. and ?..
         //            new DoublePunctuationRule(messages),
-        new MorfologikUkrainianSpellerRule(messages, this, userConfig),
+        new MorfologikUkrainianSpellerRule(messages, this, userConfig, altLanguages),
 
         new MissingHyphenRule(messages, ((UkrainianTagger)getTagger()).getWordTagger()),
         

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/MorfologikUkrainianSpellerRule.java
Patch:
@@ -40,8 +40,8 @@ public final class MorfologikUkrainianSpellerRule extends MorfologikSpellerRule
 
 
   public MorfologikUkrainianSpellerRule(ResourceBundle messages,
-                                        Language language, UserConfig userConfig) throws IOException {
-    super(messages, language, userConfig);
+                                        Language language, UserConfig userConfig, List<Language> altLanguages) throws IOException {
+    super(messages, language, userConfig, altLanguages);
 //    setCheckCompound(true);
   }
 

File: languagetool-standalone/src/test/java/org/languagetool/rules/SpellingTest.java
Patch:
@@ -51,7 +51,7 @@ private void assertHintMatch(String text, HunspellRule rule, JLanguageTool lt) t
       System.out.println(match.getSuggestedReplacements());
     }*/
     assertEquals(1, matches.length);
-    assertEquals(matches[0].getType(), RuleMatch.Type.Hint);
+    assertEquals(RuleMatch.Type.Hint, matches[0].getType());
   }
 
 }

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1179,7 +1179,7 @@ private List<RuleMatch> getOtherRuleMatches() {
           if (cache != null) {
             cacheKey = new InputSentence(analyzedSentence.getText(), language, motherTongue,
                     disabledRules, disabledRuleCategories,
-                    enabledRules, enabledRuleCategories, userConfig, mode);
+                    enabledRules, enabledRuleCategories, userConfig, altLanguages, mode);
             sentenceMatches = cache.getIfPresent(cacheKey);
           }
           if (sentenceMatches == null) {

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServer.java
Patch:
@@ -98,12 +98,13 @@ public HTTPServer(HTTPServerConfig config, boolean runInternally, String host, S
         ManagementFactory.getPlatformMBeanServer().registerMBean(new ActiveRules(),
           ObjectName.getInstance("org.languagetool:name=ActiveRules, type=ActiveRules"));
       }
-      InetSocketAddress address = host != null ? new InetSocketAddress(host, port) : new InetSocketAddress(port);
-      server = HttpServer.create(address, 0);
       RequestLimiter limiter = getRequestLimiterOrNull(config);
       ErrorRequestLimiter errorLimiter = getErrorRequestLimiterOrNull(config);
       LinkedBlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>();
       httpHandler = new LanguageToolHttpHandler(config, allowedIps, runInternally, limiter, errorLimiter, workQueue);
+
+      InetSocketAddress address = host != null ? new InetSocketAddress(host, port) : new InetSocketAddress(port);
+      server = HttpServer.create(address, 0);
       server.createContext("/", httpHandler);
       executorService = getExecutorService(workQueue, config);
       server.setExecutor(executorService);

File: languagetool-server/src/main/java/org/languagetool/server/ErrorRequestLimiter.java
Patch:
@@ -41,9 +41,9 @@ class ErrorRequestLimiter extends RequestLimiter {
    * @param ipAddress the client's IP address
    * @return true if access is allowed because the request limit is not reached yet
    */
-  boolean wouldAccessBeOkay(String ipAddress, Map<String, List<String>> httpHeader) {
+  boolean wouldAccessBeOkay(String ipAddress, Map<String, String> parameters, Map<String, List<String>> httpHeader) {
     try {
-      checkLimit(ipAddress, httpHeader);
+      checkLimit(ipAddress, parameters, httpHeader);
       return true;
     } catch (TooManyRequestsException e) {
       return false;

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -125,7 +125,7 @@ public void handle(HttpExchange httpExchange) throws IOException {
           return;
         }
       }
-      if (errorRequestLimiter != null && !errorRequestLimiter.wouldAccessBeOkay(remoteAddress, httpExchange.getRequestHeaders())) {
+      if (errorRequestLimiter != null && !errorRequestLimiter.wouldAccessBeOkay(remoteAddress, parameters, httpExchange.getRequestHeaders())) {
         String textSizeMessage = getTextOrDataSizeMessage(parameters);
         String errorMessage = "Error: Access from " + remoteAddress + " denied - too many recent timeouts. " +
                 textSizeMessage +

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -579,7 +579,7 @@ private boolean isNonPredicativeAdjective(AnalyzedTokenReadings tokensReadings)
   }
 
   private boolean isParticiple(AnalyzedTokenReadings tokensReadings) {
-    return tokensReadings.hasPosTagStartingWith("PA");
+    return tokensReadings.hasPartialPosTag("PA1") || tokensReadings.hasPartialPosTag("PA2");
   }
 
   private boolean isRelevantPronoun(AnalyzedTokenReadings[] tokens, int pos) {

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/WordCoherencyRuleTest.java
Patch:
@@ -76,6 +76,7 @@ public void testRuleCompleteTexts() throws IOException {
     assertEquals(0, lt.check("He likes archaeology. Really? She likes archaeology, too.").size());
     assertEquals(1, lt.check("He likes archaeology. Really? She likes archeology, too.").size());
     assertEquals(1, lt.check("He likes archeology. Really? She likes archaeology, too.").size());
+    assertEquals(1, lt.check("Mix of upper case and lower case: Westernize and westernise.").size());
   }
 
   private void assertError(String s) throws IOException {

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseUnitConversionRule.java
Patch:
@@ -58,8 +58,8 @@ public PortugueseUnitConversionRule(ResourceBundle messages) {
     addUnit("milhas por hora", MILE.divide(HOUR), "milhas por hora", 1, false);
 
     addUnit("metros?", METRE, "metros", 1, true);
-    // TODO: this causes errors with input "Quilómetro" (NullPointerException)
-    //addUnit("kilómetros?|Quilómetros?", METRE, "quilómetros", 1e3, true);
+    addUnit("Quilómetros?", METRE, "quilómetros", 1e3, true);
+    addUnit("kilómetros?", METRE, "quilómetros", 1e3, true);
     addUnit("decímetros?", METRE, "decímetros", 1e-1, false); // metric, but should not be suggested
     addUnit("centímetros?", METRE, "centímetros", 1e-2, true);
     addUnit("milímetros?", METRE, "milímetros", 1e-3, true);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -102,7 +102,9 @@ public Main(XComponentContext xCompContext) {
   private Configuration prepareConfig() {
     try {
       Configuration config = documents.getConfiguration();
-      disabledRules = config.getDisabledRuleIds();
+      if (config != null) {
+        disabledRules = config.getDisabledRuleIds();
+      }
       if (disabledRules == null) {
         disabledRules = new HashSet<>();
       }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -1061,7 +1061,8 @@ private boolean isNominalization(int i, AnalyzedTokenReadings[] tokens, String t
     // TODO: wir finden den Fehler in "Die moderne Wissenschaftlich" nicht, weil nicht alle
     // Substantivierungen in den Morphy-Daten stehen (z.B. "Größte" fehlt) und wir deshalb nur
     // eine Abfrage machen, ob der erste Buchstabe groß ist.
-    if (StringTools.startsWithUppercase(token) && !isNumber(token) && !(hasNounReading(nextReadings) || StringUtils.isNumeric(nextReadings.getToken())) && !token.matches("Alle[nm]")) {
+    if (StringTools.startsWithUppercase(token) && !isNumber(token) && !(hasNounReading(nextReadings) ||
+        (nextReadings != null && StringUtils.isNumeric(nextReadings.getToken()))) && !token.matches("Alle[nm]")) {
       if (lowercaseReadings != null && lowercaseReadings.hasPosTag("PRP:LOK+TMP+CAU:DAT+AKK")) {
         return false;
       }
@@ -1245,4 +1246,4 @@ private AnalyzedTokenReadings lookup(String word) {
     }
     return lookupResult;
   }
-}
\ No newline at end of file
+}

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -247,7 +247,7 @@ public class CaseRule extends Rule {
      ),
      Arrays.asList(
         // "Vor Betreten des" / "Trotz Verboten seiner Eltern"
-        posRegex("PRP:.*|ADV:MOD"),
+        posRegex("PRP:.+|ADV:MOD"),
         pos("VER:PA2:NON"),
         posRegex("(ART|PRO):(IND|DE[FM]|POS):GEN:.*")
      ),
@@ -281,7 +281,7 @@ public class CaseRule extends Rule {
      Arrays.asList( // "Das schließen Forscher aus ..."
        new PatternTokenBuilder().pos(JLanguageTool.SENTENCE_START_TAGNAME).build(),
        new PatternTokenBuilder().csToken("Das").build(),
-       new PatternTokenBuilder().pos("VER:INF:NON").build(), 
+       new PatternTokenBuilder().posRegex("VER:INF:(SFT|NON)").build(), 
        new PatternTokenBuilder().posRegex("SUB:NOM:PLU:.+|ADV:MOD").build()
     ),
     Arrays.asList( // "Tausende Gläubige kamen, um ihn zu sehen."

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -131,8 +131,10 @@ public void testRule() throws IOException {
     assertGood("Das machen eher die Erwachsenen.");
     assertGood("Das ist ihr Zuhause.");
     assertGood("Das ist Sandras Zuhause.");
+    assertGood("Das machen eher wohlhabende Leute.");
 
     //assertBad("Sie sind nicht Verständlich");
+    assertBad("Das machen der Töne ist schwierig.");
     assertBad("Sie Vertraute niemandem.");
     assertBad("Beten Lernt man in Nöten.");
     assertBad("Ich gehe gerne Joggen.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -142,7 +142,8 @@ public class VerbAgreementRule extends TextLevelRule {
      new PatternTokenBuilder().tokenRegex("D[au]rf.*|Muss.*").build(),
      new PatternTokenBuilder().posRegex("PRO:PER:NOM:.+").build(),
      new PatternTokenBuilder().posRegex("VER:INF:.+").build(),
-     new PatternTokenBuilder().pos("PKT").build()
+     new PatternTokenBuilder().pos("PKT").build(),
+     new PatternTokenBuilder().tokenRegex("(?!die).+").build()
     ),
     Arrays.asList(
      new PatternTokenBuilder().csToken("(").build(),

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -183,6 +183,8 @@ public void testWrongVerbSubject() throws IOException {
     assertGood("Wünschst du dir mehr Zeit?");
     assertGood("Wyrjtjbst du?"); // make sure that "UNKNOWN" is handled correctly
     assertGood("Wenn ich du wäre, würde ich das nicht machen.");
+    assertGood("Er sagte: „Darf ich bitten, mir zu folgen?“");
+    assertBad("Er fragte irritiert: „Darf ich fragen, die an dich gerichtet werden, beantworten?“");
 //     assertGood("Angenommen, du wärst ich."); TODO
     assertGood("Ich denke, dass das Haus, in das er gehen will, heute Morgen gestrichen worden ist.");
     // incorrect sentences:

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -142,7 +142,7 @@ public class VerbAgreementRule extends TextLevelRule {
      new PatternTokenBuilder().tokenRegex("D[au]rf.*|Muss.*").build(),
      new PatternTokenBuilder().posRegex("PRO:PER:NOM:.+").build(),
      new PatternTokenBuilder().posRegex("VER:INF:.+").build(),
-     new PatternTokenBuilder().csToken("?").build()
+     new PatternTokenBuilder().pos("PKT").build()
     ),
     Arrays.asList(
      new PatternTokenBuilder().csToken("(").build(),

File: languagetool-language-modules/nl/src/main/java/org/languagetool/rules/nl/DateCheckFilter.java
Patch:
@@ -77,7 +77,7 @@ protected int getMonth(String monthStr) {
     if (mon.startsWith("jul")) return 7;
     if (mon.startsWith("aug")) return 8;
     if (mon.startsWith("sep")) return 9;
-    if (mon.startsWith("okt")) return 10;
+    if (mon.startsWith("okt") || mon.startsWith("oct")) return 10;
     if (mon.startsWith("nov")) return 11;
     if (mon.startsWith("dec")) return 12;
     throw new RuntimeException("Could not find month '" + monthStr + "'");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanReadabilityRule.java
Patch:
@@ -118,7 +118,7 @@ protected String getMessage(int level, int FRE, int ASL, int ASW) {
 
   @Override
   public String getConfigureText() {
-    return "Grad der Lebarkeit 0 (sehr schwierig) bis 6 (sehr einfach):";
+    return "Grad der Lesbarkeit 0 (sehr schwierig) bis 6 (sehr einfach):";
   }
 
   @Override

File: languagetool-core/src/test/java/org/languagetool/tokenizers/WordTokenizerTest.java
Patch:
@@ -85,6 +85,7 @@ public void testUrlTokenize() {
   public void testUrlTokenizeWithQuote() {
     assertEquals("This| |'|http://foo.org|'| |blah", tokenize("This 'http://foo.org' blah"));
     assertEquals("This| |\"|http://foo.org|\"| |blah", tokenize("This \"http://foo.org\" blah"));
+    assertEquals("This| |(|\"|http://foo.org|\"|)| |blah", tokenize("This (\"http://foo.org\") blah"));   // issue #1226
   }
 
   @Test

File: languagetool-standalone/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -52,6 +52,8 @@ public class WordListValidatorTest {
   private static final Set<String> VALID_WORDS = new HashSet<>(Arrays.asList(
           "Mondelēz",
           "Brač",
+          "Djuveč",
+          "Djuvečreis",
           "Hidschāb/S",
           "Dvořák/S",
           "Erdoğan/S",

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -173,6 +173,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     putRepl("verblüte[mnrs]?", "blü", "blüh");
     putRepl("Einzigste[mnrs]?", "zigst", "zig");
     putRepl("(aller)?einzigste[mnrs]?", "(aller)?einzigst", "einzig");
+    putRepl("[iI]nterkurell(e[nmrs]?)?", "ku", "kultu");
     putRepl("[iI]ntersannt(e[mnrs]?)?", "sannt", "essant");
     putRepl("ubera(g|sch)end(e[nmrs]?)?", "uber", "überr");
     putRepl("[wW]olt$", "lt", "llt");

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -374,6 +374,7 @@ private void initLanguageTool() {
       // not using MultiThreadedJLanguageTool here fixes "osl::Thread::Create failed", see https://bugs.documentfoundation.org/show_bug.cgi?id=90740:
       langTool = new JLanguageTool(docLanguage, config.getMotherTongue(), null, 
           new UserConfig(config.getConfigurableValues(), linguServices));
+      config.initStyleCategories(langTool.getAllRules());
       docLanguage.getSentenceTokenizer().setSingleLineBreaksMarksParagraph(true);
       File ngramDirectory = config.getNgramDirectory();
       if (ngramDirectory != null) {

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageToolSupport.java
Patch:
@@ -157,6 +157,7 @@ void reloadConfig() {
     Language language = languageTool.getLanguage();
     languageTool = new MultiThreadedJLanguageTool(language, config.getMotherTongue(), 
         new UserConfig(config.getConfigurableValues()));
+    config.initStyleCategories(languageTool.getAllRules());
 
     Set<String> disabledRules = config.getDisabledRuleIds();
     if (disabledRules == null) {
@@ -252,6 +253,7 @@ private void reloadLanguageTool(Language language) {
       //}
       languageTool = new MultiThreadedJLanguageTool(language, config.getMotherTongue(), 
           new UserConfig(config.getConfigurableValues()));
+      config.initStyleCategories(languageTool.getAllRules());
       languageTool.setCleanOverlappingMatches(false);
       Tools.configureFromRules(languageTool, config);
       activateLanguageModelRules(language);

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -562,7 +562,7 @@ private void createRules(List<PatternToken> elemList,
         if (ruleAntiPatterns.size() > 0 || rulegroupAntiPatterns.size() > 0) {
           throw new RuntimeException("<regexp> rules currently cannot be used together with <antipattern>. Rule id: " + id + "[" + subId + "]");
         }
-        rule = new RegexPatternRule(id, name, message.toString(), suggestionsOutMsg.toString(), language, Pattern.compile(regexStr, flags), regexpMark);
+        rule = new RegexPatternRule(id, name, message.toString(), shortMessage, suggestionsOutMsg.toString(), language, Pattern.compile(regexStr, flags), regexpMark);
       } else {
         throw new IllegalStateException("Neither '<pattern>' tokens nor '<regex>' is set in rule '" + id + "'");
       }

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/RegexPatternRuleTest.java
Patch:
@@ -69,5 +69,4 @@ public void testMatchWithMark() throws IOException {
     assertThat(matches2[0].getFromPos(), is(8));
     assertThat(matches2[0].getToPos(), is(11));
  }
-  
 }
\ No newline at end of file

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/SingleDocument.java
Patch:
@@ -72,7 +72,7 @@ class SingleDocument {
 
 
   private static int debugMode = 0;               //  should be 0 except for testing; 1 = low level; 2 = advanced level
-  private static boolean specialOptimization = false;   //  special optimization switched off; TODO: fix the optimization or delete it
+  private static boolean specialOptimization = true;   //  special optimization switched on; TODO: test this version and delete switch, if it is OK
   
   private Configuration config;
 
@@ -255,8 +255,6 @@ private int getParaPos(String chPara, boolean isParallelThread) {
     boolean isReset = false;
     textIsChanged = false;
     resetCheck = false;
-    resetFrom = 0;
-    resetTo = 0;
 
     if (allParas == null || allParas.size() < 1) {
       if (isParallelThread) {              //  if numThread > 0: Thread may only read allParas

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/CachingWordListLoader.java
Patch:
@@ -57,6 +57,9 @@ private static List<String> loadWordsFromPath(String filePath) throws IOExceptio
          Scanner scanner = new Scanner(inputStream, "utf-8")) {
       while (scanner.hasNextLine()) {
         String line = scanner.nextLine();
+        if (line.isEmpty()) {
+          continue;
+        }
         if (line.startsWith("#")) {
           continue;
         }

File: languagetool-core/src/main/java/org/languagetool/rules/ReadabilityRule.java
Patch:
@@ -171,7 +171,7 @@ protected String getMessage(int level, int FRE, int ASL, int ASW) {
       few = "many";
     }
     return "Readability: The text of this paragraph is too " + simple + printMessageLevel(level) + ". Too "
-        + few + " words per sentence and to " + few + " syllables per word.";
+        + few + " words per sentence and too " + few + " syllables per word.";
   }
   
   /**

File: languagetool-core/src/main/java/org/languagetool/rules/ReadabilityRule.java
Patch:
@@ -105,9 +105,9 @@ public String getId() {
   @Override
   public String getDescription() {
     if(isToEasy) {
-      return "Readability: To easy text";
+      return "Readability: Too easy text";
     } else {
-      return "Readability: To difficult text";
+      return "Readability: Too difficult text";
     }
   }
 
@@ -170,7 +170,7 @@ protected String getMessage(int level, int FRE, int ASL, int ASW) {
       simple = "difficult";
       few = "many";
     }
-    return "Readability: The text of this paragraph is to " + simple + printMessageLevel(level) + ". To "
+    return "Readability: The text of this paragraph is too " + simple + printMessageLevel(level) + ". Too "
         + few + " words per sentence and to " + few + " syllables per word.";
   }
   

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -64,7 +64,7 @@ public void setRelaxedMode(boolean relaxedMode) {
    */
   public final List<AbstractPatternRule> getRules(InputStream is, String filename) throws IOException {
     try {
-      PatternRuleHandler handler = new PatternRuleHandler();
+      PatternRuleHandler handler = new PatternRuleHandler(filename);
       handler.setRelaxedMode(relaxedMode);
       SAXParserFactory factory = SAXParserFactory.newInstance();
       SAXParser saxParser = factory.newSAXParser();

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -115,7 +115,7 @@ public void handle(HttpExchange httpExchange) throws IOException {
       parameters = getRequestQuery(httpExchange, requestedUri);
       if (requestLimiter != null) {
         try {
-          requestLimiter.checkAccess(remoteAddress, parameters);
+          requestLimiter.checkAccess(remoteAddress, parameters, httpExchange.getRequestHeaders());
         } catch (TooManyRequestsException e) {
           String errorMessage = "Error: Access from " + remoteAddress + " denied: " + e.getMessage();
           int code = HttpURLConnection.HTTP_FORBIDDEN;
@@ -124,7 +124,7 @@ public void handle(HttpExchange httpExchange) throws IOException {
           return;
         }
       }
-      if (errorRequestLimiter != null && !errorRequestLimiter.wouldAccessBeOkay(remoteAddress)) {
+      if (errorRequestLimiter != null && !errorRequestLimiter.wouldAccessBeOkay(remoteAddress, httpExchange.getRequestHeaders())) {
         String textSizeMessage = getTextOrDataSizeMessage(parameters);
         String errorMessage = "Error: Access from " + remoteAddress + " denied - too many recent timeouts. " +
                 textSizeMessage +

File: languagetool-server/src/main/java/org/languagetool/server/Server.java
Patch:
@@ -95,8 +95,9 @@ protected RequestLimiter getRequestLimiterOrNull(HTTPServerConfig config) {
     int requestLimit = config.getRequestLimit();
     int requestLimitInBytes = config.getRequestLimitInBytes();
     int requestLimitPeriodInSeconds = config.getRequestLimitPeriodInSeconds();
-    if ((requestLimit > 0 || requestLimitInBytes > 0) && requestLimitPeriodInSeconds > 0) {
-      return new RequestLimiter(requestLimit, requestLimitInBytes, requestLimitPeriodInSeconds);
+    int ipFingerprintFactor = config.getIpFingerprintFactor();
+    if ((requestLimit > 0 || requestLimitInBytes > 0) && requestLimitPeriodInSeconds > 0 && ipFingerprintFactor >= 1) {
+      return new RequestLimiter(requestLimit, requestLimitInBytes, requestLimitPeriodInSeconds, ipFingerprintFactor);
     }
     return null;
   }

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -219,7 +219,7 @@ public List<RuleMatch> call() throws Exception {
         Path loadFile = Paths.get("/proc/loadavg");  // works in Linux only(?)
         String loadInfo = loadFile.toFile().exists() ? Files.readAllLines(loadFile).toString() : "(unknown)";
         if (errorRequestLimiter != null) {
-          errorRequestLimiter.logAccess(remoteAddress);
+          errorRequestLimiter.logAccess(remoteAddress, httpExchange.getRequestHeaders());
         }
         String message = "Text checking took longer than allowed maximum of " + limits.getMaxCheckTimeMillis() +
                          " milliseconds (cancelled: " + cancelled +

File: languagetool-server/src/main/java/org/languagetool/server/ErrorRequestLimiter.java
Patch:
@@ -41,7 +41,7 @@ class ErrorRequestLimiter extends RequestLimiter {
    */
   boolean wouldAccessBeOkay(String ipAddress) {
     try {
-      checkLimit(ipAddress, JLanguageTool.Mode.ALL);
+      checkLimit(ipAddress);
       return true;
     } catch (TooManyRequestsException e) {
       return false;
@@ -55,7 +55,7 @@ void logAccess(String ipAddress) {
     while (requestEvents.size() > REQUEST_QUEUE_SIZE) {
       requestEvents.remove(0);
     }
-    requestEvents.add(new RequestEvent(ipAddress, new Date(), 0));
+    requestEvents.add(new RequestEvent(ipAddress, new Date(), 0, JLanguageTool.Mode.ALL));
   }
   
 }

File: languagetool-server/src/main/java/org/languagetool/server/DatabaseAccess.java
Patch:
@@ -244,7 +244,7 @@ Long getOrCreateServerId() {
             }
           }
         } catch (PersistenceException e) {
-          print("Error: Could not get fetch/register server id from database: " + e);
+          print("Error: Could not fetch/register server id from database for server: " + hostname + " caused by " + e);
           return -1L;
         }
       });
@@ -285,7 +285,7 @@ Long getOrCreateClientId(String client) {
             }
           }
         } catch (PersistenceException e) {
-          print("Error: Could not get/register id for this client: " + e);
+          print("Error: Could not get/register id for this client: " + client + " caused by " + e);
           return -1L;
         }
       });

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishWordRepeatRule.java
Patch:
@@ -46,7 +46,7 @@ public boolean ignore(AnalyzedTokenReadings[] tokens, int position) {
     if (position == 0) {
       return false;
     }
-    if (wordRepetitionOf("had", tokens, position) && posIsIn(tokens, position - 2, "PRP")) {
+    if (wordRepetitionOf("had", tokens, position) && posIsIn(tokens, position - 2, "PRP", "NN")) {
       return true;   // "If I had had time, I would have gone to see him."
     }
     if (wordRepetitionOf("that", tokens, position) && posIsIn(tokens, position+1, "NN", "PRP$", "JJ", "VBZ", "VBD")) {

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/EnglishWordRepeatRuleTest.java
Patch:
@@ -47,6 +47,7 @@ public void testRepeatRule() throws IOException {
     assertGood("The can can hold the water.");
     assertGood("May May awake up?");
     assertGood("May may awake up.");
+    assertGood("Not all options or implications had had been fully considered");
     assertBad("I may may awake up.");
     assertBad("That is May May.");
     assertGood("Will Will awake up?");

File: languagetool-server/src/main/java/org/languagetool/server/Server.java
Patch:
@@ -75,8 +75,8 @@ public void stop() {
       httpHandler.shutdown();
     }
     if (server != null) {
-      System.out.println("Stopping server");
-      server.stop(0);
+      System.out.println("Stopping server...");
+      server.stop(5);
       isRunning = false;
       System.out.println("Server stopped");
     }

File: languagetool-server/src/main/java/org/languagetool/server/UserLimits.java
Patch:
@@ -135,7 +135,7 @@ private static String getTokenFromServer(String username, String password) {
         return StringTools.streamToString(conn.getInputStream(), "UTF-8");
       } catch (IOException e) {
         if (conn.getResponseCode() == 403) {
-          throw new RuntimeException("Could not get token for user '" + username + "' from " + url + ", invalid username or password (code: 403)", e);
+          throw new AuthException("Could not get token for user '" + username + "' from " + url + ", invalid username or password (code: 403)", e);
         } else {
           throw new RuntimeException("Could not get token for user '" + username + "' from " + url, e);
         }

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikAmericanSpellerRuleTest.java
Patch:
@@ -83,6 +83,7 @@ public void testMorfologikSpeller() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("He doesn't know what to do.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence(",")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("123454")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("I like my emoji 😾")).length);
 
     // test words in language-specific spelling_en-US.txt
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("USTestWordToBeIgnored")).length);

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikAustralianSpellerRuleTest.java
Patch:
@@ -62,6 +62,7 @@ public void testMorfologikSpeller() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("He doesn't know what to do.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence(",")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("123454")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("I like my emoji 😍!")).length);
 
     //Australian dict:
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Agnathia")).length);

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikCanadianSpellerRuleTest.java
Patch:
@@ -61,6 +61,7 @@ public void testMorfologikSpeller() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("He doesn't know what to do.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence(",")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("123454")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("I like my emoji (😥)...")).length);
 
     //incorrect sentences:
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -133,7 +133,7 @@ private enum GrammarCategory {
       new PatternTokenBuilder().token("Gaul").build()
     ),
     Arrays.asList(
-      new PatternTokenBuilder().token("keingit").build(),
+      new PatternTokenBuilder().token("kein").build(),
       new PatternTokenBuilder().token("schöner").build(),
       new PatternTokenBuilder().token("Land").build()  // https://de.wikipedia.org/wiki/Kein_sch%C3%B6ner_Land
     ),

File: languagetool-core/src/main/java/org/languagetool/rules/UppercaseSentenceStartRule.java
Patch:
@@ -162,7 +162,7 @@ private String dutchSpecialCase(String firstToken,
     if (!language.getShortCode().equals("nl")) {
       return null;
     }
-    if (tokens.length >= 3 && firstToken.equals("'")
+    if (tokens.length > 3 && firstToken.equals("'")
         && isDutchSpecialCase(secondToken)) {
       return tokens[3].getToken();
     }

File: languagetool-language-modules/nl/src/test/java/org/languagetool/rules/nl/UppercaseSentenceStartRuleTest.java
Patch:
@@ -46,6 +46,7 @@ protected synchronized List<AbstractPatternRule> getPatternRules() {
     assertEquals(2, lt.check("a sentence.").size());
     assertEquals(1, lt.check("'s morgens...").size());
     assertEquals(2, lt.check("s sentence.").size());
+    assertEquals(1, lt.check("'t").size());
   }
   
 }

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -765,6 +765,7 @@ public RuleMatch adjustRuleMatchPos(RuleMatch match, int charCount,
     thisMatch.setSuggestedReplacements(match.getSuggestedReplacements());
     thisMatch.setUrl(match.getUrl());
     thisMatch.setSynonymsFor(match.getSynonymsFor());
+    thisMatch.setType(match.getType());
     String sentencePartToError = sentence.substring(0, match.getFromPos());
     String sentencePartToEndOfError = sentence.substring(0, match.getToPos());
     int lastLineBreakPos = sentencePartToError.lastIndexOf('\n');
@@ -1113,6 +1114,7 @@ private List<RuleMatch> getTextLevelRuleMatches() throws IOException {
             newMatch.setEndColumn(range.to.column);
             newMatch.setSuggestedReplacements(match.getSuggestedReplacements());
             newMatch.setSynonymsFor(match.getSynonymsFor());
+            newMatch.setType(match.getType());
             adaptedMatches.add(newMatch);
           }
           ruleMatches.addAll(adaptedMatches);

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractDateCheckFilter.java
Patch:
@@ -87,7 +87,9 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> args, Anal
               .replace("{realDay}", getDayOfWeek(dateFromDate))
               .replace("{day}", getDayOfWeek(calFromDateString))
               .replace("{currentYear}", Integer.toString(Calendar.getInstance().get(Calendar.YEAR)));
-      return new RuleMatch(match.getRule(),match.getSentence(), match.getFromPos(), match.getToPos(), message, match.getShortMessage());
+      RuleMatch ruleMatch = new RuleMatch(match.getRule(), match.getSentence(), match.getFromPos(), match.getToPos(), message, match.getShortMessage());
+      ruleMatch.setType(match.getType());
+      return ruleMatch;
     } else {
       return null;
     }

File: languagetool-core/src/main/java/org/languagetool/rules/DateRangeChecker.java
Patch:
@@ -43,7 +43,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
       int x = Integer.parseInt(arguments.get("x"));
       int y = Integer.parseInt(arguments.get("y"));
       if (x >= y) {
-        return new RuleMatch(match.getRule(), match.getSentence(), match.getFromPos(), match.getToPos(), match.getMessage(), match.getShortMessage());
+        return match;
       }
     } catch (IllegalArgumentException ignore) {
       // if something's fishy with the number – ignore it silently,

File: languagetool-core/src/main/java/org/languagetool/rules/ShortenedYearRangeChecker.java
Patch:
@@ -43,7 +43,7 @@ public RuleMatch acceptRuleMatch(RuleMatch match, Map<String, String> arguments,
       String centuryPrefix = arguments.get("x").substring(0, 2);
       int y = Integer.parseInt(centuryPrefix + arguments.get("y"));
       if (x >= y) {
-        return new RuleMatch(match.getRule(), match.getSentence(), match.getFromPos(), match.getToPos(), match.getMessage(), match.getShortMessage());
+        return match;
       }
     } catch (IllegalArgumentException ignore) {
       // if something's fishy with the number – ignore it silently,

File: languagetool-core/src/main/java/org/languagetool/rules/YMDDateHelper.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.languagetool.rules;
 
-import java.util.Calendar;
 import java.util.Map;
 
 /**
@@ -52,7 +51,9 @@ public RuleMatch correctDate(RuleMatch match, Map<String, String> args) {
     String correctDate = String.format("%d-%s-%s", correctYear, month, day);
     String message = match.getMessage()
             .replace("{realDate}", correctDate);
-    return new RuleMatch(match.getRule(), match.getSentence(), match.getFromPos(),
+    RuleMatch ruleMatch = new RuleMatch(match.getRule(), match.getSentence(), match.getFromPos(),
             match.getToPos(), message, match.getShortMessage());
+    ruleMatch.setType(match.getType());
+    return ruleMatch;
   }
 }
\ No newline at end of file

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -116,6 +116,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
             len, len + word.length(),
             messages.getString("spelling"),
             messages.getString("desc_spelling_short"));
+        ruleMatch.setType(RuleMatch.Type.UnknownWord);
         if (userConfig == null || userConfig.getMaxSpellingSuggestions() == 0 || ruleMatches.size() <= userConfig.getMaxSpellingSuggestions()) {
           List<String> suggestions = getSuggestions(word);
           List<String> additionalTopSuggestions = getAdditionalTopSuggestions(suggestions, word);

File: languagetool-core/src/main/java/org/languagetool/tools/RuleMatchesAsJsonSerializer.java
Patch:
@@ -142,6 +142,9 @@ private void writeMatchesSection(String sectionName, JsonGenerator g, List<RuleM
       g.writeNumberField("offset", match.getFromPos());
       g.writeNumberField("length", match.getToPos()-match.getFromPos());
       writeContext(g, match, text, contextTools);
+      g.writeObjectFieldStart("type");
+      g.writeStringField("typeName", match.getType().toString());
+      g.writeEndObject();
       writeRule(g, match);
       g.writeEndObject();
     }

File: languagetool-language-modules/nl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -39,7 +39,7 @@ public void testDutch() throws IOException {
     assertEquals("Als Afdeling geen deel uitmaakt van de naam, dan is juist:<suggestion>afdeling</suggestion>", matches.get(0).getMessage());
      */
     // Dutch rule has no effect with English error but they are spelling mistakes:
-    assertEquals(5, tool.check("I can give you more a detailed description.").size());
+    assertEquals(3, tool.check("I can give you more a detailed description.").size());
   }
   
 }

File: languagetool-server/src/main/java/org/languagetool/server/DatabaseCheckErrorLogEntry.java
Patch:
@@ -60,7 +60,7 @@ public Map<Object, Object> getMapping() {
     parameters.put("server", server);
     parameters.put("client", client);
     parameters.put("user", user);
-    parameters.put("language_set", languageSet.getShortCodeWithCountryAndVariant());
+    parameters.put("language", languageSet.getShortCodeWithCountryAndVariant());
     parameters.put("language_detected", languageDetected.getShortCodeWithCountryAndVariant());
     parameters.put("text_length", textLength);
     parameters.put("extra", extra);

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -113,7 +113,8 @@ void checkText(AnnotatedText aText, HttpExchange httpExchange, Map<String, Strin
     String userAgent = httpExchange.getRequestHeaders().getFirst("User-Agent");
 
     if (aText.getPlainText().length() > limits.getMaxTextLength()) {
-      logger.log(new DatabaseAccessLimitLogEntry("MaxCharacterSizeExceeded", logServerId, agentId, userId, referrer, userAgent, "limit: " + limits.getMaxTextLength() + ", size: " + aText.getPlainText().length()));
+      String msg = "limit: " + limits.getMaxTextLength() + ", size: " + aText.getPlainText().length();
+      logger.log(new DatabaseAccessLimitLogEntry("MaxCharacterSizeExceeded", logServerId, agentId, userId, msg, referrer, userAgent));
       throw new TextTooLongException("Your text exceeds the limit of " + limits.getMaxTextLength() +
               " characters (it's " + aText.getPlainText().length() + " characters). Please submit a shorter text.");
     }

File: languagetool-server/src/main/java/org/languagetool/server/DatabaseCheckLogEntry.java
Patch:
@@ -87,7 +87,7 @@ public void followup(Map<Object, Object> parameters) {
       System.err.println("Could not get generated key for check log entry in database.");
       return;
     }
-    DatabaseLogger logger = DatabaseAccess.getInstance().getDatabaseLogger();
+    DatabaseLogger logger = DatabaseLogger.getInstance();
     for (DatabaseRuleMatchLogEntry entry : ruleMatches) {
       entry.setCheckId(checkId);
       logger.log(entry);

File: languagetool-server/src/test/java/org/languagetool/server/DatabaseLoggerTest.java
Patch:
@@ -49,10 +49,11 @@ public void testHTTPServer() throws Exception {
     config.setCacheSize(100);
     DatabaseAccess.init(config);
     db = DatabaseAccess.getInstance();
-    logger = db.getDatabaseLogger();
+    logger = DatabaseLogger.getInstance();
     try {
       logger.createTestTables();
       DatabaseAccess.createAndFillTestTables();
+
       HTTPServer server = new HTTPServer(config);
       Language en = Languages.getLanguageForShortCode("en-US");
       try {

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerLoadTest.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.server;
 
+import org.junit.Before;
 import org.junit.Test;
 
 import java.util.ArrayList;

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerMultiLangLoadTest.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.server;
 
+import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
 import org.languagetool.Language;
@@ -51,6 +52,7 @@ public class HTTPServerMultiLangLoadTest extends HTTPServerLoadTest {
   final Random random = new Random(1234);
   final AtomicInteger counter = new AtomicInteger();
 
+
   @Test
   @Override
   public void testHTTPServer() throws Exception {

File: languagetool-server/src/test/java/org/languagetool/server/UserDictTest.java
Patch:
@@ -52,7 +52,7 @@ public void testHTTPServer() throws Exception {
     config.setCacheSize(100);
     DatabaseAccess.init(config);
     // no need to also create test tables for logging
-    DatabaseAccess.getInstance().getDatabaseLogger().disableLogging();
+    DatabaseLogger.getInstance().disableLogging();
     try {
       DatabaseAccess.createAndFillTestTables();
       HTTPServer server = new HTTPServer(config);

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -192,7 +192,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new CompoundCoherencyRule(messages),
             new LongSentenceRule(messages, userConfig),
             new LongParagraphRule(messages, this, userConfig),
-            new GermanFillerWordsRule(messages, userConfig),
+            new GermanFillerWordsRule(messages, this, userConfig),
             new GermanParagraphRepeatBeginningRule(messages, this),
             new PunctuationMarkAtParagraphEnd(messages, this),
             new DuUpperLowerCaseRule(messages),

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -161,7 +161,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new PortugueseReplaceRule(messages),
             new PortugueseBarbarismsRule(messages),
             new PortugueseClicheRule(messages),
-            new PortugueseFillerWordsRule(messages, userConfig),
+            new PortugueseFillerWordsRule(messages, this, userConfig),
             new PortugueseRedundancyRule(messages),
             new PortugueseWordinessRule(messages),
             new PortugueseWeaselWordsRule(messages),

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -193,7 +193,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new LongSentenceRule(messages, userConfig),
             new LongParagraphRule(messages, this, userConfig),
             new GermanFillerWordsRule(messages, userConfig),
-            new GermanParagraphRepeatBeginningRule(messages),
+            new GermanParagraphRepeatBeginningRule(messages, this),
             new PunctuationMarkAtParagraphEnd(messages, this),
             new DuUpperLowerCaseRule(messages),
             new UnitConversionRule(messages)

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanParagraphRepeatBeginningRule.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.ResourceBundle;
 
 import org.languagetool.AnalyzedTokenReadings;
+import org.languagetool.Language;
 import org.languagetool.rules.ParagraphRepeatBeginningRule;
 
 /**
@@ -32,8 +33,8 @@
  */
 public class GermanParagraphRepeatBeginningRule extends ParagraphRepeatBeginningRule {
 
-  public GermanParagraphRepeatBeginningRule(ResourceBundle messages) {
-    super(messages);
+  public GermanParagraphRepeatBeginningRule(ResourceBundle messages, Language lang) {
+    super(messages, lang);
   }
 
   @Override

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -184,7 +184,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
         new LongSentenceRule(messages, userConfig),
         new LongParagraphRule(messages, this, userConfig),
         //new OpenNMTRule(),     // commented out because of #903
-        new ParagraphRepeatBeginningRule(messages),
+        new ParagraphRepeatBeginningRule(messages, this),
         new PunctuationMarkAtParagraphEnd(messages, this),
         // specific to English:
         new EnglishUnpairedBracketsRule(messages, this),

File: languagetool-language-modules/gl/src/main/java/org/languagetool/language/Galician.java
Patch:
@@ -137,7 +137,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new WhiteSpaceBeforeParagraphEnd(messages, this),
             new WhiteSpaceAtBeginOfParagraph(messages),
             new EmptyLineRule(messages, this),
-            new ParagraphRepeatBeginningRule(messages),
+            new ParagraphRepeatBeginningRule(messages, this),
             new PunctuationMarkAtParagraphEnd(messages, this),
             // Specific to Galician:
             new SimpleReplaceRule(messages),

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -154,7 +154,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new WhiteSpaceBeforeParagraphEnd(messages, this),
             new WhiteSpaceAtBeginOfParagraph(messages),
             new EmptyLineRule(messages, this),
-            new ParagraphRepeatBeginningRule(messages),
+            new ParagraphRepeatBeginningRule(messages, this),
             new PunctuationMarkAtParagraphEnd(messages, this),
             //Specific to Portuguese:
             new PostReformPortugueseCompoundRule(messages),

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -191,7 +191,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new GermanStyleRepeatedWordRule(messages, userConfig),
             new CompoundCoherencyRule(messages),
             new LongSentenceRule(messages, userConfig),
-            new LongParagraphRule(messages, userConfig),
+            new LongParagraphRule(messages, this, userConfig),
             new GermanFillerWordsRule(messages, userConfig),
             new GermanParagraphRepeatBeginningRule(messages),
             new PunctuationMarkAtParagraphEnd(messages, this),

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -182,7 +182,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
         new WhiteSpaceAtBeginOfParagraph(messages),
         new EmptyLineRule(messages, this),
         new LongSentenceRule(messages, userConfig),
-        new LongParagraphRule(messages, userConfig),
+        new LongParagraphRule(messages, this, userConfig),
         //new OpenNMTRule(),     // commented out because of #903
         new ParagraphRepeatBeginningRule(messages),
         new PunctuationMarkAtParagraphEnd(messages, this),

File: languagetool-language-modules/gl/src/main/java/org/languagetool/language/Galician.java
Patch:
@@ -132,7 +132,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
                 Example.fixed("Esta casa é vella. <marker>Foi</marker> construida en 1950.")),
             new MultipleWhitespaceRule(messages, this),
             new LongSentenceRule(messages, userConfig, -1, true),
-            new LongParagraphRule(messages, userConfig),
+            new LongParagraphRule(messages, this, userConfig),
             new SentenceWhitespaceRule(messages),
             new WhiteSpaceBeforeParagraphEnd(messages, this),
             new WhiteSpaceAtBeginOfParagraph(messages),

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -145,7 +145,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
                     Arrays.asList("]", ")", "}", "\"", "”" /*, "»", "'", "’" */)),
             new HunspellRule(messages, this, userConfig),
             new LongSentenceRule(messages, userConfig, -1, true),
-            new LongParagraphRule(messages, userConfig),
+            new LongParagraphRule(messages, this, userConfig),
             new UppercaseSentenceStartRule(messages, this,
                 Example.wrong("Esta casa é velha. <marker>foi</marker> construida em 1950."),
                 Example.fixed("Esta casa é velha. <marker>Foi</marker> construida em 1950.")),

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -187,7 +187,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new WiederVsWiderRule(messages),
             new WhiteSpaceBeforeParagraphEnd(messages, this),
             new WhiteSpaceAtBeginOfParagraph(messages),
-            new EmptyLineRule(messages),
+            new EmptyLineRule(messages, this),
             new GermanStyleRepeatedWordRule(messages, userConfig),
             new CompoundCoherencyRule(messages),
             new LongSentenceRule(messages, userConfig),

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -180,7 +180,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
         new SentenceWhitespaceRule(messages),
         new WhiteSpaceBeforeParagraphEnd(messages, this),
         new WhiteSpaceAtBeginOfParagraph(messages),
-        new EmptyLineRule(messages),
+        new EmptyLineRule(messages, this),
         new LongSentenceRule(messages, userConfig),
         new LongParagraphRule(messages, userConfig),
         //new OpenNMTRule(),     // commented out because of #903

File: languagetool-language-modules/gl/src/main/java/org/languagetool/language/Galician.java
Patch:
@@ -136,7 +136,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new SentenceWhitespaceRule(messages),
             new WhiteSpaceBeforeParagraphEnd(messages, this),
             new WhiteSpaceAtBeginOfParagraph(messages),
-            new EmptyLineRule(messages),
+            new EmptyLineRule(messages, this),
             new ParagraphRepeatBeginningRule(messages),
             new PunctuationMarkAtParagraphEnd(messages, this),
             // Specific to Galician:

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -153,7 +153,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new SentenceWhitespaceRule(messages),
             new WhiteSpaceBeforeParagraphEnd(messages, this),
             new WhiteSpaceAtBeginOfParagraph(messages),
-            new EmptyLineRule(messages),
+            new EmptyLineRule(messages, this),
             new ParagraphRepeatBeginningRule(messages),
             new PunctuationMarkAtParagraphEnd(messages, this),
             //Specific to Portuguese:

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -185,7 +185,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new WordCoherencyRule(messages),
             new SimilarNameRule(messages),
             new WiederVsWiderRule(messages),
-            new WhiteSpaceBeforeParagraphEnd(messages),
+            new WhiteSpaceBeforeParagraphEnd(messages, this),
             new WhiteSpaceAtBeginOfParagraph(messages),
             new EmptyLineRule(messages),
             new GermanStyleRepeatedWordRule(messages, userConfig),

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -178,7 +178,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
                 Example.fixed("This house is old. <marker>It</marker> was built in 1950.")),
         new MultipleWhitespaceRule(messages, this),
         new SentenceWhitespaceRule(messages),
-        new WhiteSpaceBeforeParagraphEnd(messages),
+        new WhiteSpaceBeforeParagraphEnd(messages, this),
         new WhiteSpaceAtBeginOfParagraph(messages),
         new EmptyLineRule(messages),
         new LongSentenceRule(messages, userConfig),

File: languagetool-language-modules/gl/src/main/java/org/languagetool/language/Galician.java
Patch:
@@ -134,7 +134,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new LongSentenceRule(messages, userConfig, -1, true),
             new LongParagraphRule(messages, userConfig),
             new SentenceWhitespaceRule(messages),
-            new WhiteSpaceBeforeParagraphEnd(messages),
+            new WhiteSpaceBeforeParagraphEnd(messages, this),
             new WhiteSpaceAtBeginOfParagraph(messages),
             new EmptyLineRule(messages),
             new ParagraphRepeatBeginningRule(messages),

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -151,7 +151,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
                 Example.fixed("Esta casa é velha. <marker>Foi</marker> construida em 1950.")),
             new MultipleWhitespaceRule(messages, this),
             new SentenceWhitespaceRule(messages),
-            new WhiteSpaceBeforeParagraphEnd(messages),
+            new WhiteSpaceBeforeParagraphEnd(messages, this),
             new WhiteSpaceAtBeginOfParagraph(messages),
             new EmptyLineRule(messages),
             new ParagraphRepeatBeginningRule(messages),

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractUnitConversionRule.java
Patch:
@@ -277,8 +277,9 @@ protected AbstractUnitConversionRule(ResourceBundle messages) {
       }
       return feet + inch / 12.0;
     };
-    specialPatterns.put(Pattern.compile("(?:(?<=[^º°\\d]))\\s(\\d+)(?:ft|′|')\\s*(\\d+)\\s*(?:in|\"|″)?|(?:(?<=[^º°\\d\\s]))(\\d+)(?:ft|′|')\\s*(\\d+)\\s*(?:in|\"|″)?"),
-      new AbstractMap.SimpleImmutableEntry<>( FEET, parseFeetAndInch ));
+    Map.Entry<Unit, Function<MatchResult, Double>> feetAndInchEntry = new AbstractMap.SimpleImmutableEntry<>( FEET, parseFeetAndInch );
+    specialPatterns.put(Pattern.compile("(?:(?<=[^º°\\d]))\\s(\\d+)(?:ft|′|')\\s*(\\d+)\\s*(?:in|\"|″)?"), feetAndInchEntry);
+    specialPatterns.put(Pattern.compile("(?:(?<=[^º°\\d\\s]))(\\d+)(?:ft|′|')\\s*(\\d+)\\s*(?:in|\"|″)?"), feetAndInchEntry);
   }
 
   /**

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractUnitConversionRule.java
Patch:
@@ -277,7 +277,7 @@ protected AbstractUnitConversionRule(ResourceBundle messages) {
       }
       return feet + inch / 12.0;
     };
-    specialPatterns.put(Pattern.compile("(?<=[^º°\\d])\\s(\\d+)(?:ft|′|')\\s*(\\d+)\\s*(?:in|\"|″)?|(?<=[^º°\\d\\s])(\\d+)(?:ft|′|')\\s*(\\d+)\\s*(?:in|\"|″)?"),
+    specialPatterns.put(Pattern.compile("(?:(?<=[^º°\\d]))\\s(\\d+)(?:ft|′|')\\s*(\\d+)\\s*(?:in|\"|″)?|(?:(?<=[^º°\\d\\s]))(\\d+)(?:ft|′|')\\s*(\\d+)\\s*(?:in|\"|″)?"),
       new AbstractMap.SimpleImmutableEntry<>( FEET, parseFeetAndInch ));
   }
 

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1183,7 +1183,7 @@ private List<RuleMatch> getOtherRuleMatches() {
           throw e;
         } catch (Exception e) {
           throw new RuntimeException("Could not check sentence (language: " + language + "): '"
-                  + StringUtils.abbreviate(analyzedSentence.toTextString(), 200) + "'", e);
+                  + StringUtils.abbreviate(analyzedSentence.toTextString(), 500) + "'", e);
         }
       }
       return ruleMatches;

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseUnitConversionRule.java
Patch:
@@ -126,9 +126,9 @@ protected String getShortMessage(Message message) {
       case SUGGESTION:
         return "Adicionar equivalência de métrica?";
       case CHECK_UNKNOWN_UNIT:
-        return "Unbekannte Einheit.";
-      case UNIT_MISMATCH:
         return "Unidade desconhecida.";
+      case UNIT_MISMATCH:
+        return "Unidade não relacionada.";
       default:
         throw new RuntimeException("Unknown message type." + message);
     }

File: languagetool-core/src/main/java/org/languagetool/language/LanguageIdentifier.java
Patch:
@@ -156,6 +156,7 @@ private List<LanguageProfile> loadProfiles(List<String> langCodes) throws IOExce
   @Nullable
   public Language detectLanguage(String text) {
     String shortText = text.length() > maxLength ? text.substring(0, maxLength) : text;
+    shortText = textObjectFactory.forText(shortText).toString();
     String languageCode = null;
     if (fasttextEnabled) {
       try {
@@ -223,8 +224,7 @@ private synchronized Map<String, Double> runFasttext(String text) throws IOExcep
    */
   @Nullable
   private String detectLanguageCode(String text) {
-    TextObject textObject = textObjectFactory.forText(text);
-    Optional<LdLocale> lang = languageDetector.detect(textObject);
+    Optional<LdLocale> lang = languageDetector.detect(text);
     // comment in for debugging:
     //System.out.println(languageDetector.getProbabilities(textObject));
     if (lang.isPresent()) {

File: languagetool-core/src/main/java/org/languagetool/AnalyzedSentence.java
Patch:
@@ -45,7 +45,7 @@ public AnalyzedSentence(AnalyzedTokenReadings[] tokens) {
     int[] mapping = new int[tokens.length + 1];
     List<AnalyzedTokenReadings> l = new ArrayList<>();
     for (AnalyzedTokenReadings token : tokens) {
-      if (!token.isWhitespace() || token.isSentenceStart() || token.isSentenceEnd()) {
+      if (!token.isWhitespace() || token.isSentenceStart() || token.isSentenceEnd() || token.isParagraphEnd()) {
         l.add(token);
         mapping[nonWhCounter] = whCounter;
         nonWhCounter++;

File: languagetool-core/src/test/java/org/languagetool/rules/PunctuationMarkAtParagraphEndTest.java
Patch:
@@ -52,7 +52,7 @@ private void setUpRule(JLanguageTool lt) {
     for (Rule rule : lt.getAllRules()) {
       lt.disableRule(rule.getId());
     }
-    PunctuationMarkAtParagraphEnd rule = new PunctuationMarkAtParagraphEnd(TestTools.getEnglishMessages());
+    PunctuationMarkAtParagraphEnd rule = new PunctuationMarkAtParagraphEnd(TestTools.getEnglishMessages(), TestTools.getDemoLanguage());
     lt.addRule(rule);
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -194,7 +194,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new LongParagraphRule(messages, userConfig),
             new GermanFillerWordsRule(messages, userConfig),
             new GermanParagraphRepeatBeginningRule(messages),
-            new PunctuationMarkAtParagraphEnd(messages),
+            new PunctuationMarkAtParagraphEnd(messages, this),
             new DuUpperLowerCaseRule(messages),
             new UnitConversionRule(messages)
     );

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -185,7 +185,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
         new LongParagraphRule(messages, userConfig),
         //new OpenNMTRule(),     // commented out because of #903
         new ParagraphRepeatBeginningRule(messages),
-        new PunctuationMarkAtParagraphEnd(messages),
+        new PunctuationMarkAtParagraphEnd(messages, this),
         // specific to English:
         new EnglishUnpairedBracketsRule(messages, this),
         new EnglishWordRepeatRule(messages, this),

File: languagetool-language-modules/gl/src/main/java/org/languagetool/language/Galician.java
Patch:
@@ -138,7 +138,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new WhiteSpaceAtBeginOfParagraph(messages),
             new EmptyLineRule(messages),
             new ParagraphRepeatBeginningRule(messages),
-            new PunctuationMarkAtParagraphEnd(messages),
+            new PunctuationMarkAtParagraphEnd(messages, this),
             // Specific to Galician:
             new SimpleReplaceRule(messages),
             new CastWordsRule(messages),

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -155,7 +155,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new WhiteSpaceAtBeginOfParagraph(messages),
             new EmptyLineRule(messages),
             new ParagraphRepeatBeginningRule(messages),
-            new PunctuationMarkAtParagraphEnd(messages),
+            new PunctuationMarkAtParagraphEnd(messages, this),
             //Specific to Portuguese:
             new PostReformPortugueseCompoundRule(messages),
             new PortugueseReplaceRule(messages),

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/wikipedia/SuggestionReplacerTest.java
Patch:
@@ -94,7 +94,7 @@ public void testErrorAtTextBeginning() throws Exception {
 
   @Test
   public void testErrorAtParagraphBeginning() throws Exception {
-    String markup = "X\n\nA hour ago\n";
+    String markup = "X\n\nA hour ago.\n";
     applySuggestion(englishLangTool, filter, markup, markup.replace("A", "<s>An</s>"));
   }
 
@@ -144,6 +144,7 @@ protected synchronized List<AbstractPatternRule> getPatternRules() {
     langTool.disableRule("TYPOGRAFISCHE_ANFUEHRUNGSZEICHEN");
     langTool.disableRule("OLD_SPELLING");
     langTool.disableRule("DE_TOO_LONG_SENTENCE_40");
+    langTool.disableRule("PUNCTUATION_PARAGRAPH_END");
     PlainTextMapping mapping = filter.filter(origMarkup);
     List<RuleMatch> matches = langTool.check(mapping.getPlainText());
     assertThat("Expected 3 matches, got: " + matches, matches.size(), is(3));

File: languagetool-core/src/main/java/org/languagetool/language/LanguageIdentifier.java
Patch:
@@ -34,6 +34,7 @@
 import org.slf4j.LoggerFactory;
 
 import java.io.*;
+import java.nio.charset.StandardCharsets;
 import java.util.*;
 import java.util.regex.Pattern;
 
@@ -178,8 +179,8 @@ public Language detectLanguage(String text) {
 
   private void startFasttext(File modelPath, File binaryPath) throws IOException {
     fasttextProcess = new ProcessBuilder(binaryPath.getPath(), "predict-prob", modelPath.getPath(), "-", "" + K_HIGHEST_SCORES).start();
-    fasttextIn = new BufferedReader(new InputStreamReader(fasttextProcess.getInputStream()));
-    fasttextOut = new BufferedWriter(new OutputStreamWriter(fasttextProcess.getOutputStream()));
+    fasttextIn = new BufferedReader(new InputStreamReader(fasttextProcess.getInputStream(), StandardCharsets.UTF_8));
+    fasttextOut = new BufferedWriter(new OutputStreamWriter(fasttextProcess.getOutputStream(), StandardCharsets.UTF_8));
   }
 
   private String getHighestScoringResult(Map<String, Double> probs) {

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -648,8 +648,7 @@ protected List<AnalyzedSentence> analyzeSentences(List<String> sentences) throws
       if (++j == sentences.size() || isParaEnd) {
         AnalyzedTokenReadings[] anTokens = analyzedSentence.getTokens();
         int offset = j >= sentences.size() || singleLineBreaksMarksPara ? 1 : 2;
-        int markerOffset = Math.min(anTokens.length-1, offset);
-        anTokens[anTokens.length - markerOffset].setParagraphEnd();
+        anTokens[Math.max(0, anTokens.length - offset)].setParagraphEnd();
         analyzedSentence = new AnalyzedSentence(anTokens);
       }
       analyzedSentences.add(analyzedSentence);

File: languagetool-core/src/main/java/org/languagetool/MultiThreadedJLanguageTool.java
Patch:
@@ -241,8 +241,7 @@ private ParagraphEndAnalyzeSentenceCallable(String sentence, int offset) {
     public AnalyzedSentence call() throws Exception {
       AnalyzedSentence analyzedSentence = super.call();
       AnalyzedTokenReadings[] anTokens = analyzedSentence.getTokens();
-      int markerOffset = Math.min(anTokens.length-1, offset);
-      anTokens[anTokens.length - markerOffset].setParagraphEnd();
+      anTokens[Math.max(0, anTokens.length - offset)].setParagraphEnd();
       analyzedSentence = new AnalyzedSentence(anTokens);  ///TODO: why???
       return analyzedSentence;
     }

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -84,7 +84,7 @@ public String getDescription() {
 
   /**
    * Is the given token part of a hyphenated compound preceded by a quoted token (e.g., „Spiegel“-Magazin) 
-   * and should be treated as an ordinary hypenated compound (e.g., „Spiegel-Magazin“)
+   * and should be treated as an ordinary hyphenated compound (e.g., „Spiegel-Magazin“)
    */
   protected boolean isQuotedCompound (AnalyzedSentence analyzedSentence, int idx, String token) {
     return false;

File: languagetool-office-extension/src/test/java/org/languagetool/openoffice/MainTest.java
Patch:
@@ -87,7 +87,7 @@ public void testVariants() {
   public void testCleanFootnotes() {
     Main main = new Main(null);
     main.setTestMode(true);
-    SingleDocument prog = new SingleDocument(null, null, null, null, null);
+    SingleDocument prog = new SingleDocument(null, null, null, null);
     assertEquals("A house.¹ Here comes more text.", prog.cleanFootnotes("A house.1 Here comes more text."));
     assertEquals("A road that's 3.4 miles long.", prog.cleanFootnotes("A road that's 3.4 miles long."));
     assertEquals("A house.1234 Here comes more text.", prog.cleanFootnotes("A house.1234 Here comes more text."));  // too many digits for a footnote

File: languagetool-core/src/main/java/org/languagetool/language/LanguageIdentifier.java
Patch:
@@ -35,6 +35,7 @@
 
 import java.io.*;
 import java.util.*;
+import java.util.regex.Pattern;
 
 /**
  * Identify the language of a text. Note that some languages might never be
@@ -51,6 +52,7 @@ public class LanguageIdentifier {
   private static final double MINIMAL_CONFIDENCE = 0.9;
   private static final int K_HIGHEST_SCORES = 5;
   private static final int SHORT_ALGO_THRESHOLD = 50;
+  private static final Pattern SIGNATURE = Pattern.compile("\n-- \n.*", Pattern.DOTALL);
 
   // ast and gl often prevent the correct detection of Spanish (as the are quite similar
   // to Spanish, I assume) so we disable them for now. See LanguageDetectionEval.java:
@@ -234,7 +236,7 @@ private String detectLanguageCode(String text) {
   class RemoveEMailSignatureFilter implements TextFilter {
     @Override
     public String filter(CharSequence text) {
-      return text.toString().replaceFirst("\n-- \n.*", "");
+      return SIGNATURE.matcher(text.toString()).replaceFirst("");
     }
   }
 }

File: languagetool-standalone/src/test/java/org/languagetool/language/LanguageIdentifierTest.java
Patch:
@@ -98,8 +98,8 @@ public void testKnownLimitations() {
 
   @Test
   public void testIgnoreSignature() {
-    langAssert("de", "Das ist ein deutscher Text\n-- \nBut this is an English text in the signature, and it's much longer than the original text.");
-    langAssert("en", "This is an English text.\n-- \nDas ist ein deutscher Text in der Signatur, der länger ist als der Haupttext.");
+    langAssert("de", "Das ist ein deutscher Text\n-- \nBut this is an\nEnglish text in the signature, and it's much longer than the original text.");
+    langAssert("en", "This is an English text.\n-- \nDas ist ein\ndeutscher Text in der Signatur, der länger ist als der Haupttext.");
   }
   
   private void langAssert(String expectedLangCode, String text) {

File: languagetool-http-client/src/main/java/org/languagetool/remote/RemoteResult.java
Patch:
@@ -18,8 +18,7 @@
  */
 package org.languagetool.remote;
 
-import com.sun.istack.internal.Nullable;
-
+import org.jetbrains.annotations.Nullable;
 import java.util.Collections;
 import java.util.List;
 import java.util.Objects;

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerLoadTest.java
Patch:
@@ -98,7 +98,7 @@ public void run() {
           throw new RuntimeException(e);
         } finally {
           int count = runningTests.decrementAndGet();
-          System.out.println("Tests currently running: " + count);
+          //System.out.println("Tests currently running: " + count);
         }
       }
     }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/LineExpander.java
Patch:
@@ -45,6 +45,8 @@ List<String> expandLine(String line) {
           result.add(word + "n");
         } else if (c == 'E') {
           result.add(word + "e");
+        } else if (c == 'F') {
+          result.add(word + "in"); // (m/f)
         } else if (c == 'A') {  // Adjektiv
           result.add(word + "e");
           result.add(word + "er");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/ProhibitedCompoundRule.java
Patch:
@@ -44,6 +44,7 @@ public class ProhibitedCompoundRule extends Rule {
   private static final List<Pair> lowercasePairs = Arrays.asList(
           // NOTE: words here must be all-lowercase
           // NOTE: no need to add words from confusion_sets.txt, they will be used automatically (if starting with uppercase char)
+          new Pair("uhr", "Instrument zur Zeitmessung", "ur", "ursprünglich"),
           new Pair("abschluss", "Ende", "abschuss", "Vorgang des Abschießens, z.B. mit einer Waffe"),
           new Pair("brache", "verlassenes Grundstück", "branche", "Wirtschaftszweig"),
           new Pair("wieder", "erneut, wiederholt, nochmal (Wiederholung, Wiedervorlage, ...)", "wider", "gegen, entgegen (Widerwille, Widerstand, Widerspruch, ...)"),

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -214,7 +214,7 @@ public final Locale[] getLocales() {
           }
         }
       }
-      return locales.toArray(new Locale[locales.size()]);
+      return locales.toArray(new Locale[0]);
     } catch (Throwable t) {
       messageHandler.showError(t);
       return new Locale[0];

File: languagetool-office-extension/src/test/java/org/languagetool/openoffice/MainTest.java
Patch:
@@ -87,7 +87,7 @@ public void testVariants() {
   public void testCleanFootnotes() {
     Main main = new Main(null);
     main.setTestMode(true);
-    SingleDocument prog = new SingleDocument(null, null, null, null, null, null);
+    SingleDocument prog = new SingleDocument(null, null, null, null, null);
     assertEquals("A house.¹ Here comes more text.", prog.cleanFootnotes("A house.1 Here comes more text."));
     assertEquals("A road that's 3.4 miles long.", prog.cleanFootnotes("A road that's 3.4 miles long."));
     assertEquals("A house.1234 Here comes more text.", prog.cleanFootnotes("A house.1234 Here comes more text."));  // too many digits for a footnote

File: languagetool-language-modules/en/src/main/java/org/languagetool/tagging/en/EnglishTagger.java
Patch:
@@ -42,6 +42,6 @@ public String getManualRemovalsFileName() {
   }
 
   public EnglishTagger() {
-    super("/en/english.dict", Locale.ENGLISH);
+    super("/en/english.dict", Locale.ENGLISH, false);
   }
 }

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -101,7 +101,7 @@ public void handle(HttpExchange httpExchange) throws IOException {
           if (referrer != null && referrer.startsWith(ref)) {
             errorMessage = "Error: Access with referrer " + referrer + " denied.";
           } else if (origin != null && origin.startsWith(ref)) {
-            errorMessage = "Error: Access with origin " + referrer + " denied.";
+            errorMessage = "Error: Access with origin " + origin + " denied.";
           }
         }
         if (errorMessage != null) {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -537,7 +537,7 @@ protected List<String> getAdditionalTopSuggestions(List<String> suggestions, Str
       return Arrays.asList("jetzt", "geht's");
     } else if ("Trons".equals(word)) {
       return Collections.singletonList("Trance");
-    } else if (word.endsWith("ibel[hk]eit")) {
+    } else if (word.matches(".*ibel[hk]eit$")) {
       suggestion = word.replaceFirst("el[hk]eit$", "ilität");
       if (!hunspellDict.misspelled(suggestion)) {
         return Collections.singletonList(suggestion);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -537,7 +537,7 @@ protected List<String> getAdditionalTopSuggestions(List<String> suggestions, Str
     } else if ("Trons".equals(word)) {
       return Collections.singletonList("Trance");
     } else if (word.endsWith("ibel[hk]eit")) {
-      suggestion = word.replaceFirst("el[ħk]eit$", "ilität");
+      suggestion = word.replaceFirst("el[hk]eit$", "ilität");
       if (!hunspellDict.misspelled(suggestion)) {
         return Collections.singletonList(suggestion);
       }

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Configuration.java
Patch:
@@ -718,7 +718,7 @@ private void parseErrorColors(String colorsString) {
     if (StringUtils.isNotEmpty(colorsString)) {
       String[] typeToColorList = colorsString.split(COLOR_SPLITTER_REGEXP);
       for (String typeToColor : typeToColorList) {
-        String[] typeAndColor = typeToColor.split(":");
+        String[] typeAndColor = typeToColor.split(COLOR_SPLITTER_REGEXP_COLON);
         if (typeAndColor.length != 2) {
           throw new RuntimeException("Could not parse type and color, colon expected: '" + typeToColor + "'");
         }

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Configuration.java
Patch:
@@ -75,6 +75,8 @@ public class Configuration {
   // find all comma followed by zero or more white space characters that are preceded by ":" AND a valid 6-digit hex code
   // example: ":#44ffee,"
   private static final String COLOR_SPLITTER_REGEXP = "(?<=:#[0-9A-Fa-f]{6}),\\s*";
+ //find all colon followed by a valid 6-digit hex code, e.g., ":#44ffee"
+ private static final String COLOR_SPLITTER_REGEXP_COLON = ":(?=#[0-9A-Fa-f]{6})";
   // find all comma followed by zero or more white space characters that are preceded by at least one digit
   // example: "4,"
   private static final String CONFIGURABLE_RULE_SPLITTER_REGEXP = "(?<=[0-9]),\\s*";
@@ -731,7 +733,7 @@ private void parseUnderlineColors(String colorsString) {
     if (StringUtils.isNotEmpty(colorsString)) {
       String[] typeToColorList = colorsString.split(COLOR_SPLITTER_REGEXP);
       for (String typeToColor : typeToColorList) {
-        String[] typeAndColor = typeToColor.split(":");
+        String[] typeAndColor = typeToColor.split(COLOR_SPLITTER_REGEXP_COLON);
         if (typeAndColor.length != 2) {
           throw new RuntimeException("Could not parse type and color, colon expected: '" + typeToColor + "'");
         }

File: languagetool-core/src/main/java/org/languagetool/language/LanguageIdentifier.java
Patch:
@@ -56,6 +56,7 @@ public class LanguageIdentifier {
 
   // languages that we offer profiles for as they are not yet supported by language-detector:
   private static final List<String> externalLangCodes = Arrays.asList("eo");
+  private static final int SHORT_ALGO_THRESHOLD = 50;
 
   private final LanguageDetector languageDetector;
   private final TextObjectFactory textObjectFactory;
@@ -77,6 +78,7 @@ public LanguageIdentifier(int maxLength) {
       List<LanguageProfile> profiles = loadProfiles(getLanguageCodes());
       languageDetector = LanguageDetectorBuilder.create(NgramExtractors.standard())
               .minimalConfidence(MINIMAL_CONFIDENCE)
+              .shortTextAlgorithm(SHORT_ALGO_THRESHOLD)
               .withProfiles(profiles)
               .build();
       textObjectFactory = CommonTextObjectFactories.forDetectingOnLargeText();

File: languagetool-dev/src/test/java/org/languagetool/dev/eval/LanguageDetectionEval.java
Patch:
@@ -42,7 +42,7 @@ class LanguageDetectionEval {
   private int totalInputs = 0;
   private int totalFailures = 0;
 
-  LanguageDetectionEval() {
+  private LanguageDetectionEval() {
     languageIdentifier = new LanguageIdentifier();
   }
 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MessageHandler.java
Patch:
@@ -100,8 +100,8 @@ private String getLogPath() {
     File parentDir = new File(path).getParentFile();
     if (parentDir != null) {
       boolean success = parentDir.mkdirs();
-      if(!success) {
-        showMessage("Can't create dirctory: " + path);
+      if(!testMode && !success) {
+        showMessage("Can't create directory: " + path);
       }
     }
     return path;

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -113,7 +113,7 @@ private void prepareConfig(Language lang) {
     }
   }
 
-  private void changeContext(XComponentContext xCompContext) {
+  void changeContext(XComponentContext xCompContext) {
     xContext = xCompContext;
   }
 
@@ -300,7 +300,7 @@ public String[] getSupportedServiceNames() {
     return getServiceNames();
   }
 
-  private static String[] getServiceNames() {
+  static String[] getServiceNames() {
     return SERVICE_NAMES;
   }
 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/MultiDocumentsHandler.java
Patch:
@@ -113,7 +113,7 @@ ProofreadingResult getCheckResults(String paraText, Locale locale, ProofreadingR
     }
     
     docNum = getNumDoc(paRes.aDocumentIdentifier);
-    paRes = documents.get(docNum).getCheckResults(paraText, locale, paRes, footnotePositions, isParallelThread);
+    paRes = documents.get(docNum).getCheckResults(paraText, paRes, footnotePositions, isParallelThread);
     
     if(isParallelThread) {
       isParallelThread = false;

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -129,6 +129,8 @@ public void testRule() throws IOException {
     assertGood("Er fragte, ob das gelingen oder scheitern wird.");
     assertGood("Einen Tag nach Bekanntwerden des Skandals");
     assertGood("Das machen eher die Erwachsenen.");
+    assertGood("Das ist ihr Zuhause.");
+    assertGood("Das ist Sandras Zuhause.");
 
     //assertBad("Sie sind nicht Verständlich");
     assertBad("Sie Vertraute niemandem.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/OldSpellingRule.java
Patch:
@@ -35,11 +35,12 @@ public class OldSpellingRule extends Rule {
   private static final String MESSAGE = "Diese Schreibweise war nur in der alten Rechtschreibung korrekt.";
   private static final String SHORT_MESSAGE = "alte Rechtschreibung";
   private static final String RULE_INTERNAL = "OLD_SPELLING_INTERNAL";
-  private static final SpellingData DATA = new SpellingData(DESC, FILE_PATH, MESSAGE, SHORT_MESSAGE, RULE_INTERNAL);
+  private static final ITSIssueType ISSUE_TYPE = ITSIssueType.Misspelling;
+  private static final SpellingData DATA = new SpellingData(DESC, FILE_PATH, MESSAGE, SHORT_MESSAGE, RULE_INTERNAL, ISSUE_TYPE);
 
   public OldSpellingRule(ResourceBundle messages) {
     super.setCategory(Categories.TYPOS.getCategory(messages));
-    setLocQualityIssueType(ITSIssueType.Misspelling);
+    setLocQualityIssueType(ISSUE_TYPE);
     addExamplePair(Example.wrong("Der <marker>Abfluß</marker> ist schon wieder verstopft."),
                    Example.fixed("Der <marker>Abfluss</marker> ist schon wieder verstopft."));
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/SpellingData.java
Patch:
@@ -23,6 +23,7 @@
 import org.languagetool.JLanguageTool;
 import org.languagetool.Language;
 import org.languagetool.Languages;
+import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.patterns.PatternRule;
 import org.languagetool.rules.patterns.PatternToken;
 import org.languagetool.rules.patterns.PatternTokenBuilder;
@@ -42,7 +43,7 @@ class SpellingData {
 
   private final List<SpellingRuleWithSuggestion> spellingRules = new ArrayList<>();
   
-  SpellingData(String ruleDesc, String filePath, String message, String shortMessage, String ruleId) {
+  SpellingData(String ruleDesc, String filePath, String message, String shortMessage, String ruleId, ITSIssueType issueType) {
     try (InputStream inputStream = JLanguageTool.getDataBroker().getFromResourceDirAsStream(filePath);
          Scanner scanner = new Scanner(inputStream, "utf-8")) {
       Language german = Languages.getLanguageForShortCode("de");
@@ -59,6 +60,7 @@ class SpellingData {
         String suggestion = parts[1];
         List<PatternToken> patternTokens = getTokens(alternative, german);
         PatternRule rule = new PatternRule(ruleId, german, patternTokens, ruleDesc, message, shortMessage);
+        rule.setLocQualityIssueType(issueType);
         spellingRules.add(new SpellingRuleWithSuggestion(rule, alternative, suggestion));
       }
     } catch (IOException e) {

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerTest.java
Patch:
@@ -45,7 +45,7 @@ public class HTTPServerTest {
 
   @Test
   public void testHTTPServer() throws Exception {
-    HTTPServer server = new HTTPServer();
+    HTTPServer server = new HTTPServer(new HTTPServerConfig(HTTPTools.getDefaultPort(), true));
     assertFalse(server.isRunning());
     try {
       server.run();

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractDateCheckFilter.java
Patch:
@@ -34,7 +34,6 @@
  */
 public abstract class AbstractDateCheckFilter extends RuleFilter {
 
-  private final TestHackHelper testHackHelper = new TestHackHelper();
   // The day of the month may contain not only digits but also extra letters
   // such as"22nd" in English or "22-an" in Esperanto. The regexp extracts
   // the numerical part.
@@ -106,7 +105,7 @@ protected String getRequired(String key, Map<String, String> map) {
   private Calendar getDate(Map<String, String> args) {
     String yearArg = args.get("year");
     int year;
-    if (yearArg == null && testHackHelper.isJUnitTest()) {
+    if (yearArg == null && TestHackHelper.isJUnitTest()) {
       // Volkswagen-style testing
       // Hack for tests of date - weekday match with missing year
       // in production, we assume the current year

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/YMDNewYearDateFilter.java
Patch:
@@ -1,5 +1,5 @@
 /* LanguageTool, a natural language style checker
- * Copyright (C) 2015 Daniel Naber (http://www.danielnaber.de)
+ * Copyright (C) 2018 Fabian Richter
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -25,9 +25,9 @@
 import java.util.Map;
 
 /**
- * Date filter that expects a 'date' argument in the format 'yyyy-mm-dd'.
+ * New year date filter that expects a 'date' argument in the format 'yyyy-mm-dd'.
  *
- * @since 3.2
+ * @since 4.3
  */
 public class YMDNewYearDateFilter extends NewYearDateFilter {
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/YMDNewYearDateFilter.java
Patch:
@@ -1,5 +1,5 @@
 /* LanguageTool, a natural language style checker
- * Copyright (C) 2015 Daniel Naber (http://www.danielnaber.de)
+ * Copyright (C) 2018 Fabian Richter
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -25,8 +25,8 @@
 import java.util.Map;
 
 /**
- * Date filter that expects a 'date' argument in the format 'yyyy-mm-dd'.
- * @since 3.2
+ * New year date filter that expects a 'date' argument in the format 'yyyy-mm-dd'.
+ * @since 4.3
  */
 public class YMDNewYearDateFilter extends NewYearDateFilter {
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/OldSpellingRule.java
Patch:
@@ -57,8 +57,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
     for (OldSpellingRuleWithSuggestion ruleWithSuggestion : data.get()) {
       Rule rule = ruleWithSuggestion.rule;
       RuleMatch[] matches = rule.match(sentence);
-      if (matches.length > 0) {
-        RuleMatch match = matches[0];
+      for (RuleMatch match : matches) {
         String matchedText = sentence.getText().substring(match.getFromPos(), match.getToPos());
         String textFromMatch = sentence.getText().substring(match.getFromPos());
         if (textFromMatch.startsWith("Schloß Holte")) {
@@ -67,7 +66,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
         String suggestion = matchedText.replace(ruleWithSuggestion.oldSpelling, ruleWithSuggestion.newSpelling);
         if (!suggestion.equals(matchedText)) {   // "Schlüsse" etc. is otherwise considered incorrect (inflected form of "Schluß")
           match.setSuggestedReplacement(suggestion);
-          ruleMatches.addAll(Arrays.asList(matches));
+          ruleMatches.add(match);
         }
       }
     }

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Configuration.java
Patch:
@@ -106,7 +106,7 @@ public class Configuration {
   private int fontSize = FONT_SIZE_INVALID;
   private int serverPort = DEFAULT_SERVER_PORT;
   private int numParasToCheck = DEFAULT_NUM_CHECK_PARAS;
-  private boolean doResetCheck = true;
+  private boolean doResetCheck = false;
   private String externalRuleDirectory;
   private String lookAndFeelName;
 

File: languagetool-server/src/test/java/org/languagetool/server/UserDictTest.java
Patch:
@@ -40,7 +40,7 @@ public class UserDictTest {
   private static final String API_KEY1 = "foo";
   private static final String USERNAME2 = "two@test.de";
   private static final String API_KEY2 = "foo-two";
-   
+  
   @Test
   public void testHTTPServer() throws Exception {
     HTTPServerConfig config = new HTTPServerConfig(HTTPTools.getDefaultPort());

File: languagetool-server/src/test/java/org/languagetool/server/UserDictTest.java
Patch:
@@ -40,7 +40,7 @@ public class UserDictTest {
   private static final String API_KEY1 = "foo";
   private static final String USERNAME2 = "two@test.de";
   private static final String API_KEY2 = "foo-two";
-     
+   
   @Test
   public void testHTTPServer() throws Exception {
     HTTPServerConfig config = new HTTPServerConfig(HTTPTools.getDefaultPort());

File: languagetool-server/src/test/java/org/languagetool/server/UserDictTest.java
Patch:
@@ -40,7 +40,7 @@ public class UserDictTest {
   private static final String API_KEY1 = "foo";
   private static final String USERNAME2 = "two@test.de";
   private static final String API_KEY2 = "foo-two";
-    
+     
   @Test
   public void testHTTPServer() throws Exception {
     HTTPServerConfig config = new HTTPServerConfig(HTTPTools.getDefaultPort());

File: languagetool-server/src/test/java/org/languagetool/server/UserDictTest.java
Patch:
@@ -40,7 +40,7 @@ public class UserDictTest {
   private static final String API_KEY1 = "foo";
   private static final String USERNAME2 = "two@test.de";
   private static final String API_KEY2 = "foo-two";
-
+    
   @Test
   public void testHTTPServer() throws Exception {
     HTTPServerConfig config = new HTTPServerConfig(HTTPTools.getDefaultPort());

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -138,8 +138,8 @@ public class VerbAgreementRule extends TextLevelRule {
      new PatternTokenBuilder().token("sein").matchInflectedForms().build(),
      new PatternTokenBuilder().tokenRegex("[\\.,]").build()
     ),
-    Arrays.asList(
-     new PatternTokenBuilder().csToken("„D[au]rf.*|Musst.*").build(),
+    Arrays.asList( // Must du gehen?
+     new PatternTokenBuilder().tokenRegex("D[au]rf.*|Musst.*").build(),
      new PatternTokenBuilder().tokenRegex("PRO:PER:NOM:.+").build(),
      new PatternTokenBuilder().tokenRegex("VER:INF:.+").build(),
      new PatternTokenBuilder().csToken("?").matchInflectedForms().build()

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -159,7 +159,6 @@ public class CaseRule extends Rule {
        regex("Konstanten?")
     ),
     Arrays.asList(
-        //token("dass"),
         token("das"),
         posRegex("PA2:.*"),
         posRegex("VER:AUX:.*")
@@ -283,7 +282,7 @@ public class CaseRule extends Rule {
        new PatternTokenBuilder().pos(JLanguageTool.SENTENCE_START_TAGNAME).build(),
        new PatternTokenBuilder().csToken("Das").build(),
        new PatternTokenBuilder().pos("VER:INF:NON").build(), 
-       new PatternTokenBuilder().posRegex("SUB:NOM:PLU:.+").build()
+       new PatternTokenBuilder().posRegex("SUB:NOM:PLU:.+|ADV:MOD").build()
     ),
     Arrays.asList( // "Tausende Gläubige kamen, um ihn zu sehen."
       new PatternTokenBuilder().tokenRegex("[tT]ausende?").build(),

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -128,6 +128,7 @@ public void testRule() throws IOException {
     assertGood("Dabei werden im Wesentlichen zwei Prinzipien verwendet:");
     assertGood("Er fragte, ob das gelingen oder scheitern wird.");
     assertGood("Einen Tag nach Bekanntwerden des Skandals");
+    assertGood("Das machen eher die Erwachsenen.");
 
     //assertBad("Sie sind nicht Verständlich");
     assertBad("Sie Vertraute niemandem.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -100,6 +100,7 @@ public void testWrongVerb() throws IOException {
     assertGood("So tes\u00ADtest Du das mit dem soft hyphen.");
     assertGood("Viele Brunnen in Italiens Hauptstadt sind bereits abgeschaltet.");
     assertGood("„Werde ich tun!“");
+    assertGood("Sie fragte: „Muss ich aussagen?“");
     // incorrect sentences:
     assertBad("Als Borcarbid weißt es eine hohe Härte auf.");
     assertBad("Das greift auf Vorläuferinstitutionen bist auf die Zeit von 1234 zurück.");

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -1248,7 +1248,7 @@ private int getParaPos(String chPara, int numThread, int docNum) {
           resetCheck();
           if(numParasToCheck > 0) {
             int from;
-            for(from = 0; from < allParas.get(docNum).size() 
+            for(from = 0; from < allParas.get(docNum).size() && from < oldParas.size() 
                 && allParas.get(docNum).get(from).equals(oldParas.get(from)); from++);
             from -= 1 + numParasToCheck;
             int to;

File: languagetool-server/src/main/java/org/languagetool/server/DatabaseAccess.java
Patch:
@@ -104,7 +104,7 @@ List<String> getUserDictWords(Long userId) {
             dictEntries.add(userDictEntry.getWord());
           }
         } else {
-          print("ERROR: Could not get words from database for user " + userId + ": " + e.getMessage() + " - also, could not use version from cache, user if not fond in cache, will use empty list. Full stack trace follows:", System.err);
+          print("ERROR: Could not get words from database for user " + userId + ": " + e.getMessage() + " - also, could not use version from cache, user id not found in cache, will use empty dict. Full stack trace follows:", System.err);
         }
         e.printStackTrace();
       }

File: languagetool-standalone/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -40,7 +40,7 @@ public class WordListValidatorTest {
           "[0-9a-zA-ZöäüÖÄÜßëçèéáàóòÈÉÁÀÓÒãñíîş&" +
           "âêôõû" +  // for Portuguese
           "Œ€ūαΑβΒγɣΓδΔεΕζΖηΗθΘιΙκΚλΛμΜνΝξΞοΟπΠρΡσΣτΤυΥφΦχΧψΨωΩάΆέΈίΊήΉύΎϊϋΰΐœţ" +
-          "Śśōżúï" +
+          "ŚśōżúïÎ" +
           "·" +   // for Catalan
           "./-]+" + 
           "|[khmcdµ]?m[²³]|°[CFR]"

File: languagetool-core/src/main/java/org/languagetool/rules/DoublePunctuationRule.java
Patch:
@@ -55,7 +55,7 @@ public String getCommaCharacter() {
   @Override
   public final RuleMatch[] match(AnalyzedSentence sentence) {
     List<RuleMatch> ruleMatches = new ArrayList<>();
-    AnalyzedTokenReadings[] tokens = sentence.getTokens();
+    AnalyzedTokenReadings[] tokens = sentence.getTokensWithoutWhitespace();
     int startPos = 0;
     int dotCount = 0;
     int commaCount = 0;

File: languagetool-core/src/test/java/org/languagetool/rules/DoublePunctuationRuleTest.java
Patch:
@@ -42,7 +42,7 @@ public void testRule() throws IOException {
     assertEquals(0, matches.length);
     matches = rule.match(langTool.getAnalyzedSentence("Это тестовое предложение?.."));
     assertEquals(0, matches.length);
-    matches = rule.match(langTool.getAnalyzedSentence("Это тестовое предложение!.."));
+    matches = rule.match(langTool.getAnalyzedSentence("Это тестовое предложение!.. "));
     assertEquals(0, matches.length);
     matches = rule.match(langTool.getAnalyzedSentence("This is a test sentence... More stuff...."));
     assertEquals(0, matches.length);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -290,6 +290,7 @@ public void testDetNounRule() throws IOException {
     
     assertBad("Ich weiß nicht mehr, was unser langweiligen Thema war.");
     assertGood("Aber mein Wissen über die Antike ist ausbaufähig.");
+    assertGood("Er ging ins Küche.");
 
     // TODO: not yet detected:
     //assertBad("Erst recht wir fleißiges Arbeiter.");

File: languagetool-core/src/test/java/org/languagetool/rules/spelling/morfologik/MorfologikMultiSpellerTest.java
Patch:
@@ -63,16 +63,16 @@ public void testGetSuggestions() throws IOException {
 
   @Test(expected = RuntimeException.class)
   public void testInvalidFileName() throws IOException {
-    new MorfologikMultiSpeller("/xx/spelling/test.dict.README", "/xx/spelling/test2.txt", 1);
+    new MorfologikMultiSpeller("/xx/spelling/test.dict.README", "/xx/spelling/test2.txt", null, 1);
   }
 
   @Test(expected = RuntimeException.class)
   public void testInvalidFile() throws IOException {
-    new MorfologikMultiSpeller("/xx/spelling/no-such-file", "/xx/spelling/test2.txt", 1);
+    new MorfologikMultiSpeller("/xx/spelling/no-such-file", "/xx/spelling/test2.txt", null, 1);
   }
 
   private MorfologikMultiSpeller getSpeller() throws IOException {
-    return new MorfologikMultiSpeller("/xx/spelling/test.dict", "/xx/spelling/test2.txt", 1);
+    return new MorfologikMultiSpeller("/xx/spelling/test.dict", "/xx/spelling/test2.txt", null, 1);
   }
 
 }
\ No newline at end of file

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/GermanyGerman.java
Patch:
@@ -42,7 +42,7 @@ public String getName() {
   @Override
   public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfig) throws IOException {
     List<Rule> rules = new ArrayList<>(super.getRelevantRules(messages, userConfig));
-    rules.add(new GermanSpellerRule(messages, this, userConfig));
+    rules.add(new GermanSpellerRule(messages, this, userConfig, null));
     return rules;
   }
   

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/ProhibitedCompoundRule.java
Patch:
@@ -58,7 +58,7 @@ public class ProhibitedCompoundRule extends Rule {
           new Pair("verklärung", "Beschönigung, Darstellung in einem besseren Licht", "erklärung", "Darstellung, Erläuterung"),
           new Pair("spitze", "spitzes Ende eines Gegenstandes", "spritze", "medizinisches Instrument zur Injektion")
   );
-  private static final GermanSpellerRule spellerRule = new GermanSpellerRule(JLanguageTool.getMessageBundle(), new GermanyGerman(), null);
+  private static final GermanSpellerRule spellerRule = new GermanSpellerRule(JLanguageTool.getMessageBundle(), new GermanyGerman(), null, null);
   private static final List<String> ignoreWords = Arrays.asList("Die", "De");
   private static final List<Pair> pairs = new ArrayList<>();
   static {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -377,7 +377,7 @@ public void testIgnoreWord() throws Exception {
 
   private static class MyGermanSpellerRule extends GermanSpellerRule {
     MyGermanSpellerRule(ResourceBundle messages, German language) throws IOException {
-      super(messages, language, null);
+      super(messages, language, null, null);
       init();
     }
     boolean doIgnoreWord(String word) throws IOException {

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikAmericanSpellerRuleTest.java
Patch:
@@ -169,6 +169,8 @@ public void testSuggestionForIrregularWords() throws IOException {
     assertSuggestion("farest", "furthest", "farthest");
     //double consonants not yet supported:
     //assertSuggestion("baddest", "worst");
+    // suggestions from language specific spelling_en-XX.txt
+    assertSuggestion("USTestWordToBeIgnore", "USTestWordToBeIgnored");
   }
 
   private void assertSuggestion(String input, String... expectedSuggestions) throws IOException {

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/FrenchCompoundAwareHunspellRule.java
Patch:
@@ -63,7 +63,7 @@ private static MorfologikMultiSpeller getSpeller(Language language, UserConfig u
         String path = "/fr/hunspell/spelling.txt";
         try (InputStream stream = JLanguageTool.getDataBroker().getFromResourceDirAsStream(path);
              BufferedReader br = new BufferedReader(new InputStreamReader(stream, "utf-8"))) {
-          return new MorfologikMultiSpeller(morfoFile, br, path, userConfig != null ? userConfig.getAcceptedWords(): Collections.emptyList(), 2);
+          return new MorfologikMultiSpeller(morfoFile, br, path, null, null, userConfig != null ? userConfig.getAcceptedWords(): Collections.emptyList(), 2);
         }
       } else {
         return null;

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternTestTools.java
Patch:
@@ -426,7 +426,7 @@ private static void warnIfElementNotKosher(
                   + ruleId + ", token [" + tokenIndex + "], contains empty "
                   + "disjunction | within " + "\"" + stringValue + "\".");
         }
-        String[] groups = stringValue.split("\\)");
+        String[] groups = stringValue.split("\\)|\\(");
         for (String group : groups) {
           String[] alt = group.split("\\|");
           Set<String> partSet = new HashSet<>();

File: languagetool-core/src/main/java/org/languagetool/language/LanguageIdentifier.java
Patch:
@@ -69,7 +69,7 @@ public LanguageIdentifier() {
    * @param maxLength the maximum number of characters that will be considered - can help
    *                  with performance. Don't use values below 100, as this would decrease
    *                  accuracy.
-   * @throws IllegalArgumentException if {@code maxLength} is < 10
+   * @throws IllegalArgumentException if {@code maxLength} is less than 10
    * @since 4.2
    */
   public LanguageIdentifier(int maxLength) {

File: languagetool-dev/src/main/java/org/languagetool/dev/RuleOverview.java
Patch:
@@ -67,8 +67,8 @@ private RuleOverview() {
   }
   
   private void run(File webRoot) throws IOException {
-    System.out.println("<b>Rules in LanguageTool " + JLanguageTool.VERSION + "</b><br />");
-    System.out.println("Date: " + new SimpleDateFormat("yyyy-MM-dd").format(new Date()) + "<br /><br />\n");
+    System.out.println("<p><b>Rules in LanguageTool " + JLanguageTool.VERSION + "</b><br />");
+    System.out.println("Date: " + new SimpleDateFormat("yyyy-MM-dd").format(new Date()) + "</p>\n");
     System.out.println("<table class=\"tablesorter sortable\" style=\"width: auto\">");
     System.out.println("<thead>");
     System.out.println("<tr>");
@@ -80,7 +80,7 @@ private void run(File webRoot) throws IOException {
     System.out.println("  <th align=\"left\" width=\"60\">Spell<br/>check*</th>");
     System.out.println("  <th align=\"left\" width=\"60\">Confusion<br/>pairs</th>");
     //System.out.println("  <th valign='bottom' width=\"65\">Auto-<br/>detected</th>");
-    System.out.println("  <th valign='bottom' align=\"left\" width=\"70\">Activity</th>");
+    System.out.println("  <th valign='bottom' align=\"left\" width=\"90\">Activity</th>");
     System.out.println("  <th valign='bottom' align=\"left\">Rule Maintainers</th>");
     System.out.println("</tr>");
     System.out.println("</thead>");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -150,6 +150,9 @@ public void testRule() throws IOException {
     assertBad("Damit sollen sie die Versorgung in der Region Übernehmen.");
     assertBad("Die Unfallursache scheint geklärt, ein Lichtsignal wurde Überfahren.");
     assertBad("Der Lenker hatte die Höchstgeschwindigkeit um 76 km/h Überschritten.");
+    assertBad("Das Extreme Sportfest");
+    assertBad("Das Extreme Sportfest findet morgen statt.");
+    assertGood("Stets suchte er das Extreme.");
     assertGood("Ich möchte zwei Kilo Zwiebeln.");
     // "NIL" reading in Morphy that used to confuse CaseRule:
     assertGood("Ein Menschenfreund.");

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -94,7 +94,7 @@ public void handle(HttpExchange httpExchange) throws IOException {
       }
       String referrer = httpExchange.getRequestHeaders().getFirst("Referer");
       for (String ref : config.getBlockedReferrers()) {
-        if (referrer != null && referrer.startsWith(ref)) {
+        if (referrer != null && ref != null && !ref.isEmpty() && referrer.startsWith(ref)) {
           String errorMessage = "Error: Access with referrer " + referrer + " denied.";
           sendError(httpExchange, HttpURLConnection.HTTP_FORBIDDEN, errorMessage);
           logError(errorMessage, HttpURLConnection.HTTP_FORBIDDEN, parameters, httpExchange);

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Configuration.java
Patch:
@@ -592,7 +592,7 @@ private void loadConfiguration(Language lang) throws IOException {
 
   private void parseErrorColors(String colorsString) {
     if (StringUtils.isNotEmpty(colorsString)) {
-      String[] typeToColorList = colorsString.split(",\\s*");
+      String[] typeToColorList = colorsString.split("(?<=:#[0-9A-Fa-f]{6}),\\s*");
       for (String typeToColor : typeToColorList) {
         String[] typeAndColor = typeToColor.split(":");
         if (typeAndColor.length != 2) {
@@ -607,7 +607,7 @@ private void parseErrorColors(String colorsString) {
 
   private void parseUnderlineColors(String colorsString) {
     if (StringUtils.isNotEmpty(colorsString)) {
-      String[] typeToColorList = colorsString.split(",\\s*");
+      String[] typeToColorList = colorsString.split("(?<=:#[0-9A-Fa-f]{6}),\\s*");
       for (String typeToColor : typeToColorList) {
         String[] typeAndColor = typeToColor.split(":");
         if (typeAndColor.length != 2) {
@@ -620,7 +620,7 @@ private void parseUnderlineColors(String colorsString) {
 
   private void parseConfigurableRuleValues(String rulesValueString) {
     if (StringUtils.isNotEmpty(rulesValueString)) {
-      String[] ruleToValueList = rulesValueString.split(",\\s*");
+      String[] ruleToValueList = rulesValueString.split("(?<=:#[0-9A-Fa-f]{6}),\\s*");
       for (String ruleToValue : ruleToValueList) {
         String[] ruleAndValue = ruleToValue.split(":");
         if (ruleAndValue.length != 2) {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -171,6 +171,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     putRepl("([eE]r|[bB]e|unter)?hälst", "hälst", "hältst");
     put("[wW]ohlfühlseins?", w -> Arrays.asList("Wellness", w.replaceFirst("[wW]ohlfühlsein", "Wohlbefinden"), w.replaceFirst("[wW]ohlfühlsein", "Wohlfühlen")));
     putRepl("[sS]chmett?e?rling(s|en?)?", "[sS]chmett?e?rling", "Schmetterling");
+    putRepl("^[eE]inlamie?nie?r(st|en?|(t(e[nmrs]?)?))?", "^einlamie?nie?r", "laminier");
     putRepl("[bB]ravurös(e[nrms]?)?", "vur", "vour");
     putRepl("[aA]ss?ecoires?", "[aA]ss?ec", "Access");
     putRepl("[aA]ufwechse?lungsreich(er|st)?(e[nmrs]?)?", "ufwechse?lung", "bwechslung");

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -115,7 +115,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
             len, len + word.length(),
             messages.getString("spelling"),
             messages.getString("desc_spelling_short"));
-        if (userConfig.getMaxSpellingSuggestions() == 0 || ruleMatches.size() <= userConfig.getMaxSpellingSuggestions()) {
+        if (userConfig == null || userConfig.getMaxSpellingSuggestions() == 0 || ruleMatches.size() <= userConfig.getMaxSpellingSuggestions()) {
           List<String> suggestions = getSuggestions(word);
           List<String> additionalTopSuggestions = getAdditionalTopSuggestions(suggestions, word);
           Collections.reverse(additionalTopSuggestions);

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Configuration.java
Patch:
@@ -40,7 +40,7 @@
 public class Configuration {
   
   static final int DEFAULT_SERVER_PORT = 8081;  // should be HTTPServerConfig.DEFAULT_PORT but we don't have that dependency
-  static final int DEFAULT_NUM_CHECK_PARAS = 5;  //  default number of parameters to be checked by TextLevelRules in LO/OO 
+  static final int DEFAULT_NUM_CHECK_PARAS = 0;  //  default number of parameters to be checked by TextLevelRules in LO/OO 
   static final int FONT_STYLE_INVALID = -1;
   static final int FONT_SIZE_INVALID = -1;
 
@@ -95,7 +95,7 @@ public class Configuration {
   private int fontSize = FONT_SIZE_INVALID;
   private int serverPort = DEFAULT_SERVER_PORT;
   private int numParasToCheck = DEFAULT_NUM_CHECK_PARAS;
-  private boolean doResetCheck = true;
+  private boolean doResetCheck = false;
   private String externalRuleDirectory;
   private String lookAndFeelName;
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -224,7 +224,7 @@ public class CaseRule extends Rule {
     ),
     Arrays.asList(
        // "... etwas Interessantes und Spannendes suchte"
-       regex("etwas|nichts|viel|wenig|allerlei"),
+       regex("etwas|nichts|viel|wenig|allerlei|was"),
        regex("[A-ZÄÖÜ].*es"),
        regex("und|oder|,"),
        regex("[A-ZÄÖÜ].*es")

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanStyleRepeatedWordRule.java
Patch:
@@ -76,7 +76,8 @@ private static boolean isUnknownWord(AnalyzedTokenReadings token) {
    */
   protected boolean isTokenToCheck(AnalyzedTokenReadings token) {
     return (token.matchesPosTagRegex("(SUB|EIG|VER|ADJ):.*") 
-        && !token.matchesPosTagRegex("(PRO|ART|ADV|VER:(AUX|MOD)):.*"))
+        && !token.matchesPosTagRegex("(PRO|ART|ADV|VER:(AUX|MOD)):.*")
+        && !token.getToken().equals("Ich"))
         || isUnknownWord(token);
   }
 

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -91,7 +91,7 @@ public void handle(HttpExchange httpExchange) throws IOException {
         } catch (TooManyRequestsException e) {
           String errorMessage = "Error: Access from " + remoteAddress + " denied: " + e.getMessage();
           sendError(httpExchange, HttpURLConnection.HTTP_FORBIDDEN, errorMessage);
-          print(errorMessage + " - useragent: " + parameters.get("useragent") +
+          print(errorMessage + ", sending code 403 - useragent: " + parameters.get("useragent") +
                   " - HTTP UserAgent: " + getHttpUserAgent(httpExchange) + ", r:" + reqCounter.getRequestCount());
           return;
         }
@@ -103,13 +103,13 @@ public void handle(HttpExchange httpExchange) throws IOException {
                 " Allowed maximum timeouts: " + errorRequestLimiter.getRequestLimit() +
                 " per " + errorRequestLimiter.getRequestLimitPeriodInSeconds() + " seconds";
         sendError(httpExchange, HttpURLConnection.HTTP_FORBIDDEN, errorMessage);
-        print(errorMessage + " - useragent: " + parameters.get("useragent") +
+        print(errorMessage + ", sending code 403 - useragent: " + parameters.get("useragent") +
                 " - HTTP UserAgent: " + getHttpUserAgent(httpExchange) + ", r:" + reqCounter.getRequestCount());
         return;
       }
       if (config.getMaxWorkQueueSize() != 0 && workQueue.size() > config.getMaxWorkQueueSize()) {
         String response = "Error: There are currently too many parallel requests. Please try again later.";
-        print(response + " Queue size: " + workQueue.size() + ", maximum size: " + config.getMaxWorkQueueSize() +
+        print(response + ", sending code 503. Queue size: " + workQueue.size() + ", maximum size: " + config.getMaxWorkQueueSize() +
                 ", handlers:" + reqCounter.getHandleCount() + ", r:" + reqCounter.getRequestCount());
         sendError(httpExchange, HttpURLConnection.HTTP_UNAVAILABLE, "Error: " + response);
         return;

File: languagetool-core/src/main/java/org/languagetool/rules/LongParagraphRule.java
Patch:
@@ -46,8 +46,8 @@ public class LongParagraphRule extends TextLevelRule {
 
   public LongParagraphRule(ResourceBundle messages, UserConfig userConfig, int defaultWords, boolean defaultActive) {
     super(messages);
-    super.setCategory(new Category(new CategoryId("CREATIV_WRITING"), 
-        messages.getString("category_creativ_writing"), Location.INTERNAL, false));
+    super.setCategory(new Category(new CategoryId("CREATIVE_WRITING"), 
+        messages.getString("category_creative_writing"), Location.INTERNAL, false));
     if (!defaultActive) {
       setDefaultOff();
     }

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -191,6 +191,8 @@ public List<Rule> getRelevantRules(ResourceBundle messages, UserConfig userConfi
             new GermanStyleRepeatedWordRule(messages, userConfig),
             new CompoundCoherencyRule(messages),
             new LongSentenceRule(messages, userConfig),
+            new LongParagraphRule(messages, userConfig),
+            new GermanFillerWordsRule(messages, userConfig),
             new GermanParagraphRepeatBeginningRule(messages),
             new PunctuationMarkAtParagraphEnd(messages),
             new DuUpperLowerCaseRule(messages)

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SimpleReplaceBalearicRule.java
Patch:
@@ -51,6 +51,7 @@ public SimpleReplaceBalearicRule(final ResourceBundle messages) throws IOExcepti
     super(messages);
     super.setCategory(Categories.TYPOS.getCategory(messages));
     super.setLocQualityIssueType(ITSIssueType.Misspelling);
+    this.setCheckLemmas(false);
     //this.setIgnoreTaggedWords();
   }  
 

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SimpleReplaceDiacriticsIEC.java
Patch:
@@ -52,6 +52,7 @@ public SimpleReplaceDiacriticsIEC(final ResourceBundle messages) throws IOExcept
     super.setCategory(new Category(new CategoryId("DIACRITICS_IEC"), "Z) Accents diacrítics segons l'IEC"));
     super.setLocQualityIssueType(ITSIssueType.Misspelling);
     super.setDefaultOff();
+    this.setCheckLemmas(false);
   }  
 
   @Override

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SimpleReplaceDiacriticsTraditional.java
Patch:
@@ -52,6 +52,7 @@ public SimpleReplaceDiacriticsTraditional(final ResourceBundle messages) throws
     super.setCategory(new Category(new CategoryId("DIACRITICS_TRADITIONAL"), "Z) Accents diacrítics tradicionals"));
     super.setLocQualityIssueType(ITSIssueType.Misspelling);
     super.setDefaultOn();
+    this.setCheckLemmas(false);
   }  
 
   @Override

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SimpleReplaceRule.java
Patch:
@@ -52,6 +52,7 @@ public SimpleReplaceRule(final ResourceBundle messages) throws IOException {
     super.setCategory(Categories.TYPOS.getCategory(messages));
     super.setLocQualityIssueType(ITSIssueType.Misspelling);
     this.setIgnoreTaggedWords();
+    this.setCheckLemmas(false);
   }  
 
   @Override

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/RussianDashRule.java
Patch:
@@ -37,6 +37,7 @@ public class RussianDashRule extends AbstractDashRule {
 
   public RussianDashRule() throws IOException {
     super(dashRules);
+     setDefaultOff(); // Slows down start up. See GitHub issue #1016.
   }
 
   @Override

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/ConfigurationDialog.java
Patch:
@@ -274,6 +274,8 @@ public void actionPerformed(@SuppressWarnings("unused") ActionEvent actionEvent)
     cons.fill = GridBagConstraints.HORIZONTAL;
     cons.anchor = GridBagConstraints.WEST;
     for(JPanel extra : extraPanels) {
+      //in case it wasn't in a containment hierarchy when user changed L&F
+      SwingUtilities.updateComponentTreeUI(extra);
       cons.gridy++;
       jPane.add(extra, cons);
     }

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/ConfigurationDialog.java
Patch:
@@ -359,7 +359,6 @@ public void actionPerformed(@SuppressWarnings("unused") ActionEvent actionEvent)
     contentPane.add(buttonPanel, cons);
 
     dialog.pack();
-    dialog.setSize(520, 500);
     // center on screen:
     Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
     Dimension frameSize = dialog.getSize();

File: languagetool-server/src/test/java/org/languagetool/server/LargeUserDictTest.java
Patch:
@@ -42,7 +42,7 @@ public class LargeUserDictTest {
   @Test
   @Ignore("requires real database and modifies it")
   public void testHTTPServer() throws Exception {
-    HTTPServerConfig config = new HTTPServerConfig();
+    HTTPServerConfig config = new HTTPServerConfig(HTTPTools.getDefaultPort());
     config.setDatabaseDriver("org.mariadb.jdbc.Driver");
     config.setDatabaseUrl("jdbc:mysql://localhost:3306/languagetoolpremium");
     config.setDatabaseUsername("root");

File: languagetool-server/src/test/java/org/languagetool/server/UserDictTest.java
Patch:
@@ -39,7 +39,7 @@ public class UserDictTest {
   
   @Test
   public void testHTTPServer() throws Exception {
-    HTTPServerConfig config = new HTTPServerConfig();
+    HTTPServerConfig config = new HTTPServerConfig(HTTPTools.getDefaultPort());
     config.setDatabaseDriver("org.hsqldb.jdbcDriver");
     config.setDatabaseUrl("jdbc:hsqldb:mem:testdb");
     config.setDatabaseUsername("");

File: languagetool-server/src/test/java/org/languagetool/server/HTTPTools.java
Patch:
@@ -39,6 +39,9 @@ final class HTTPTools {
   private HTTPTools() {
   }
 
+  /**
+   * Get default port, but considering property {@code lt.default.port}.
+   */
   public static int getDefaultPort() {
     String defaultPort = System.getProperty("lt.default.port");
     return defaultPort != null ? Integer.parseInt(defaultPort) : HTTPServerConfig.DEFAULT_PORT;

File: languagetool-server/src/test/java/org/languagetool/server/TextCheckerTest.java
Patch:
@@ -50,7 +50,7 @@ public void testMaxTextLength() throws Exception {
     Map<String, String> params = new HashMap<>();
     params.put("text", "not used");
     params.put("language", "en");
-    HTTPServerConfig config1 = new HTTPServerConfig();
+    HTTPServerConfig config1 = new HTTPServerConfig(HTTPTools.getDefaultPort());
     config1.setMaxTextLength(10);
     TextChecker checker = new V2TextChecker(config1, false, null, new RequestCounter());
     try {

File: languagetool-server/src/test/java/org/languagetool/server/UserDictTest.java
Patch:
@@ -56,8 +56,7 @@ public void testHTTPServer() throws Exception {
         runTests(enUS, "This is Mysurname.", "This is Mxsurname.", "Mysurname", "MORFOLOGIK_RULE_EN_US");
         runTests(enUS, "Mysurname is my name.", "Mxsurname is my name.", "Mysurname", "MORFOLOGIK_RULE_EN_US");
         Language deDE = Languages.getLanguageForShortCode("de-DE");
-        //TODO: issue with '.'???
-        //runTests(deDE, "Das ist Meinname.", "Das ist Mxinname.", "Meinname", "GERMAN_SPELLER_RULE");
+        runTests(deDE, "Das ist Meinname.", "Das ist Mxinname.", "Meinname", "GERMAN_SPELLER_RULE");
         runTests(deDE, "Meinname steht hier.", "Mxinname steht hier.", "Meinname", "GERMAN_SPELLER_RULE");
         try {
           addWord("multi word", USERNAME1, API_KEY1);
@@ -81,7 +80,7 @@ private void runTests(Language lang, String input, String inputWithTypo, String
     assertRuleMatch(1, input, lang, errorRuleId, null, null);  // anonymous user
     assertRuleMatch(0, input, lang, errorRuleId, USERNAME1, API_KEY1);
     String json = assertRuleMatch(1, inputWithTypo, lang, errorRuleId, USERNAME1, API_KEY1);
-    assertTrue("Missing suggestion '" + name + "': " + json, json.contains("\"" + name + "\""));
+    assertTrue("Missing suggestion '" + name + "': " + json, json.contains("\"" + name + "\"") || json.contains("\"" + name + ".\""));
     deleteWord(name, USERNAME1, API_KEY1);
     assertRuleMatch(1, input, lang, errorRuleId, USERNAME1, API_KEY1);
     assertRuleMatch(1, input, lang, errorRuleId, USERNAME2, API_KEY2);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanWordRepeatRuleTest.java
Patch:
@@ -44,6 +44,9 @@ public void testRule() throws IOException {
     assertThat(rule.match(lt.getAnalyzedSentence("Wie bei Honda, die die Bezahlung erhöht haben.")).length, is(0));
     assertThat(rule.match(lt.getAnalyzedSentence("Dann warfen sie sie weg.")).length, is(0));
     assertThat(rule.match(lt.getAnalyzedSentence("Dann konnte sie sie sehen.")).length, is(0));
+    assertThat(rule.match(lt.getAnalyzedSentence("Hat sie sie")).length, is(1));  // used to crash, issue #1010
+    assertThat(rule.match(lt.getAnalyzedSentence("Hat hat")).length, is(1));
+    assertThat(rule.match(lt.getAnalyzedSentence("hat hat")).length, is(1));
   }
 
 }
\ No newline at end of file

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanWordRepeatRule.java
Patch:
@@ -74,7 +74,7 @@ public boolean ignore(AnalyzedTokenReadings[] tokens, int position) {
         // "Sie tut das, damit sie sie nicht fortschickt"
         return true;
       }
-      if (tokens.length+1 > position) {
+      if (tokens.length-1 > position) {
         if (tokens[position - 2].matchesPosTagRegex("VER:3:.+") && tokens[position + 1].hasPosTag("ZUS")) {
           // "Dann warfen sie sie weg."
           return true;

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -293,7 +293,7 @@ protected void addIgnoreWords(String line) {
   }
 
   /**
-   * @param list of words to be prohibited.
+   * @param words list of words to be prohibited.
    * @since 4.2
    */
   protected void addProhibitedWords(List<String> words) {

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -144,7 +144,7 @@ public synchronized LanguageModel getLanguageModel(File indexDir) throws IOExcep
   /** @since 3.1 */
   @Override
   public List<Rule> getRelevantLanguageModelRules(ResourceBundle messages, LanguageModel languageModel) throws IOException {
-    return Arrays.<Rule>asList(
+    return Arrays.asList(
             new SpanishConfusionProbabilityRule(messages, languageModel, this)
     );
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/LongSentenceRule.java
Patch:
@@ -89,13 +89,13 @@ private boolean isWordCount(String tokenText) {
   public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
     List<RuleMatch> ruleMatches = new ArrayList<>();
     AnalyzedTokenReadings[] tokens = sentence.getTokensWithoutWhitespace();
-    String msg = getMessage();
     if (configValue >= 0) {
       maxWords = configValue;
     }
     if (tokens.length < maxWords + 1) {   // just a short-circuit
       return toRuleMatchArray(ruleMatches);
     }
+    String msg = getMessage();
     int i = 0;
     List<Integer> fromPos = new ArrayList<>();
     List<Integer> toPos = new ArrayList<>();

File: languagetool-language-modules/ru/src/test/java/org/languagetool/rules/ru/RussianVerbConjugationRuleTest.java
Patch:
@@ -35,7 +35,7 @@ public class RussianVerbConjugationRuleTest {
     private Set<String> rightSentences = ImmutableSet.of("Я иду", "Она сидит", "Оно думает",
             "Они пишут", "Мы думаем", "Ты читаешь", "Он творит", "Вы идёте",
             "Я ходил", "Они ходили", "Мы ходили", "Она ходила", "Оно ходило", "Я ходила",
-            "Я пойду", "Она пойдёт", "Оно пойдёт", "Мы пойдём", "Ты пойдёшь");
+            "Я пойду", "Она пойдёт", "Оно пойдёт", "Мы пойдём", "Ты пойдёшь", "Я согласился на предложение.", "Джек и я согласились" );
 
     private Set<String> wrongSentences = ImmutableSet.of("Я идёт", "Она сидят",
             "Оно думаешь","Они идёте","Мы думаю","Ты читает", "Он творю",

File: languagetool-standalone/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -43,7 +43,7 @@ public class WordListValidatorTest {
           "Śśōżúï" +
           "·" +   // for Catalan
           "./-]+" + 
-          "|[khmcdµ]?m[²³]|°[CFK]"
+          "|[khmcdµ]?m[²³]|°[CFR]"
   );
 
   // Words that are valid but with special characters so that we don't want to

File: languagetool-standalone/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -43,7 +43,7 @@ public class WordListValidatorTest {
           "Śśōżúï" +
           "·" +   // for Catalan
           "./-]+" + 
-          "|[khmcdµ]?m[²³]"
+          "|[khmcdµ]?m[²³]|°[CFK]"
   );
 
   // Words that are valid but with special characters so that we don't want to

File: languagetool-core/src/main/java/org/languagetool/Languages.java
Patch:
@@ -135,7 +135,7 @@ public static Language getLanguageForName(String languageName) {
 
   /**
    * Get the Language object for the given language code.
-   * @param langCode e.g. <code>en</code> or <code>es-US</code>
+   * @param langCode e.g. <code>en</code> or <code>en-US</code>
    * @throws IllegalArgumentException if the language is not supported or if the language code is invalid
    * @since 3.6
    */

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -321,7 +321,7 @@ private enum GrammarCategory {
     ),
     Arrays.asList(
       new PatternTokenBuilder().token("wenn").setSkip(1).build(),
-      new PatternTokenBuilder().csToken("einer").setSkip(1).build(),
+      new PatternTokenBuilder().csToken("einer").build(),
       new PatternTokenBuilder().posRegex("SUB:AKK:.+").build(),
       new PatternTokenBuilder().posRegex("VER:(MOD:)?3:SIN:.+").build(),
       new PatternTokenBuilder().csToken(",").build(),

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/DuUpperLowerCaseRule.java
Patch:
@@ -18,6 +18,7 @@
  */
 package org.languagetool.rules.de;
 
+import org.apache.commons.lang3.StringUtils;
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.AnalyzedTokenReadings;
 import org.languagetool.rules.Categories;
@@ -98,7 +99,7 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
                 msg = "Vorher wurde bereits '" + firstUse + "' großgeschrieben. " +
                         "Aus Gründen der Einheitlichkeit '" + replacement + "' hier auch großschreiben?";
               }
-            } else if (!firstUseIsUpper && StringTools.startsWithUppercase(word)) {
+            } else if (!firstUseIsUpper && StringTools.startsWithUppercase(word) && !StringUtils.isAllUpperCase(word)) {
               replacement = StringTools.lowercaseFirstChar(word);
               msg = "Vorher wurde bereits '" + firstUse + "' kleingeschrieben. " +
                       "Aus Gründen der Einheitlichkeit '" + replacement + "' hier auch kleinschreiben?";

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -202,6 +202,8 @@ public void testDetNounRule() throws IOException {
     assertGood("Karl sagte, dass sie niemandem Bescheid gegeben habe.");
     assertGood("Es blieb nur dieser eine Satz.");
     assertGood("Oder ist das Mathematikern vorbehalten?");
+    assertGood("Wenn hier einer Fragen stellt, dann ich.");
+    assertGood("Wenn einer Katzen mag, dann meine Schwester.");
 
     // incorrect sentences:
     assertBad("Meiner Chef raucht.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -184,6 +184,7 @@ public void testRule() throws IOException {
     assertGood("Die ersten Gespanne erreichen Köln.");
     assertGood("Er beschrieb den Angeklagten wie einen Schuldigen");
     assertGood("Er beschrieb den Angeklagten wie einen Schuldigen.");
+    assertGood("Es dauerte bis ins neunzehnte Jahrhundert");
 
     assertGood("Das ist das Dümmste, was ich je gesagt habe.");
     assertBad("Das ist das Dümmste Kind.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/DuUpperLowerCaseRuleTest.java
Patch:
@@ -68,6 +68,7 @@ public void testRule() throws IOException {
     
     assertErrors("\"Du sagtest, du würdest es schaffen!\"", 0);
     assertErrors("Egal, was du tust: Du musst dein Bestes geben.", 0);
+    assertErrors("Was auch immer du tust: ICH UND DU KÖNNEN ES SCHAFFEN.", 0);
   }
 
   private void assertErrors(String input, int expectedMatches) throws IOException {

File: languagetool-core/src/main/java/org/languagetool/rules/Rule.java
Patch:
@@ -157,7 +157,7 @@ protected List<DisambiguationPatternRule> makeAntiPatterns(List<List<PatternToke
       rules.add(new DisambiguationPatternRule("INTERNAL_ANTIPATTERN", "(no description)", language,
               patternTokens, null, null, DisambiguationPatternRule.DisambiguatorAction.IMMUNIZE));
     }
-    return Collections.unmodifiableList(rules);
+    return rules;
   }
   
   /**

File: languagetool-language-modules/ca/src/test/java/org/languagetool/tagging/ca/CatalanTaggerTest.java
Patch:
@@ -48,7 +48,7 @@ public void testTagger() throws IOException {
     TestTools
         .myAssert(
             "Sóc un home molt honrat.",
-            "Sóc/[ser]VSIP1S00 -- un/[un]DI0MS0|un/[un]PI0MS000 -- home/[home]I|home/[home]NCMS000 -- molt/[molt]DI0MS0|molt/[molt]PI0MS000|molt/[molt]RG -- honrat/[honrar]VMP00SM0",
+            "Sóc/[ser]VSIP1S00 -- un/[un]DI0MS0|un/[un]PI0MS000 -- home/[home]I|home/[home]NCMS000 -- molt/[molt]DI0MS0|molt/[molt]PI0MS000|molt/[molt]RG -- honrat/[honrar]VMP00SM0|honrat/[honrat]AQ0MS0",
             tokenizer, tagger);
     TestTools.myAssert("blablabla", "blablabla/[null]null", tokenizer, tagger);
     TestTools.myAssert("inajornablement",

File: languagetool-language-modules/de/src/main/java/org/languagetool/tagging/de/GermanTagger.java
Patch:
@@ -278,7 +278,7 @@ private List<AnalyzedToken> getImperativeForm(String word, List<String> sentence
 
   /*
    * Tag substantivated adjectives and participles, which are currently tagged not tagged correctly
-   * (e.g., "Verletzter" in "Ein Verletzter kam in Krankenhaus" needs to be tagged as "SUB:NOM:SIN:MAS") 
+   * (e.g., "Verletzter" in "Ein Verletzter kam ins Krankenhaus" needs to be tagged as "SUB:NOM:SIN:MAS")
    * @param word to be checked
    */
   private List<AnalyzedToken> getSubstantivatedForms(String word, List<String> sentenceTokens, int pos) {

File: languagetool-standalone/src/main/java/org/languagetool/gui/Main.java
Patch:
@@ -906,6 +906,7 @@ private boolean maybeStartServer() {
     if (config.getRunServer()) {
       try {
         HTTPServerConfig serverConfig = new HTTPServerConfig(config.getServerPort(), false);
+        serverConfig.setAllowOriginUrl("*");    // needed for Firefox so this server can be used from the add-on
         httpServer = new HTTPServer(serverConfig, true);
         httpServer.run();
         if (enableHttpServerItem != null) {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -1408,6 +1408,7 @@ private static String getLogPath() {
     if (null != parent_directory) {
       parent_directory.mkdirs();
     }
+    return path;
   }
 
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -182,7 +182,7 @@ public void testRule() throws IOException {
     assertGood("Die ersten Gespanne erreichen Köln.");
     assertGood("Er beschrieb den Angeklagten wie einen Schuldigen");
     assertGood("Er beschrieb den Angeklagten wie einen Schuldigen.");
-    assertGood("Dabei werden im Wesenlichen zwei Prinzipien verwendet:");
+    assertGood("Dabei werden im Wesentlichen zwei Prinzipien verwendet:");
     assertGood("Er fragte, ob das gelingen oder scheitern wird.");
 
     assertGood("Das ist das Dümmste, was ich je gesagt habe.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -182,6 +182,8 @@ public void testRule() throws IOException {
     assertGood("Die ersten Gespanne erreichen Köln.");
     assertGood("Er beschrieb den Angeklagten wie einen Schuldigen");
     assertGood("Er beschrieb den Angeklagten wie einen Schuldigen.");
+    assertGood("Dabei werden im Wesenlichen zwei Prinzipien verwendet:");
+    assertGood("Er fragte, ob das gelingen oder scheitern wird.");
 
     assertGood("Das ist das Dümmste, was ich je gesagt habe.");
     assertBad("Das ist das Dümmste Kind.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -1052,7 +1052,7 @@ private boolean isNominalization(int i, AnalyzedTokenReadings[] tokens, String t
     // TODO: wir finden den Fehler in "Die moderne Wissenschaftlich" nicht, weil nicht alle
     // Substantivierungen in den Morphy-Daten stehen (z.B. "Größte" fehlt) und wir deshalb nur
     // eine Abfrage machen, ob der erste Buchstabe groß ist.
-    if (StringTools.startsWithUppercase(token) && !isNumber(token) && !hasNounReading(nextReadings) && !token.matches("Alle[nm]")) {
+    if (StringTools.startsWithUppercase(token) && !isNumber(token) && !(hasNounReading(nextReadings) || StringUtils.isNumeric(nextReadings.getToken())) && !token.matches("Alle[nm]")) {
       if (lowercaseReadings != null && lowercaseReadings.hasPosTag("PRP:LOK+TMP+CAU:DAT+AKK")) {
         return false;
       }
@@ -1168,7 +1168,7 @@ private boolean isAdjectiveAsNoun(int i, AnalyzedTokenReadings[] tokens, Analyze
     // ignore "die Ausgewählten" but not "die Ausgewählten Leute":
     for (AnalyzedToken reading : tokens[i].getReadings()) {
       String posTag = reading.getPOSTag();
-      if ((posTag == null || posTag.contains("ADJ")) && !hasNounReading(nextReadings)) {
+      if ((posTag == null || posTag.contains("ADJ")) && !hasNounReading(nextReadings) && !isNumber(nextReadings != null ? nextReadings.getToken() : "")) {
         if(posTag == null && hasPartialTag(lowercaseReadings, "PRP:LOK", "PA2:PRD:GRU:VER", "PA1:PRD:GRU:VER", "ADJ:PRD:KOM")) {
           // skip to avoid a false true for, e.g. "Die Zahl ging auf Über 1.000 zurück."/ "Dies gilt schon lange als Überholt."
           // but not for "Er versuchte, Neues zu wagen."

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -193,6 +193,7 @@ public void testRule() throws IOException {
     assertBad("Er ist begeistert Von der Fülle.");
     assertBad("Er wohnt Über einer Garage.");
     assertBad("„Weißer Rauch“ Über Athen");
+    assertBad("Die Anderen 90 Prozent waren krank.");
 
     assertGood("Man sagt, Liebe mache blind.");
     assertGood("Die Deutschen sind sehr listig.");

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/RussianCompoundRule.java
Patch:
@@ -46,7 +46,7 @@ public RussianCompoundRule(ResourceBundle messages) throws IOException {
             "Эти слова могут быть написаны через дефис или слитно.");
     addExamplePair(Example.wrong("Собрание состоится в <marker>конференц зале</marker>."),
                    Example.fixed("Собрание состоится в <marker>конференц-зале</marker>."));
-//   super.sentenceStartsWithUpperCase = true;
+   super.sentenceStartsWithUpperCase = true;
   }
 
   

File: languagetool-language-modules/ru/src/test/java/org/languagetool/rules/ru/RussianCompoundRuleTest.java
Patch:
@@ -64,7 +64,9 @@ public void testRule() throws IOException {
     // first part is a single character:
     check(0, "во-первых");
     check(1, "во первых", new String[]{"во-первых"});
-//    check(1, "Во первых, мы были довольно высоко над уровнем моря.");
+    check(1, "Лос Анджелес", new String[]{"Лос-Анджелес"});
+    check(1, "Ведь сейчас в Лос Анджелесе");
+    check(1, "Во первых, мы были довольно высоко над уровнем моря.");
     check(1, "Мы, во первых, были довольно высоко над уровнем моря.");
     // incorrect sentences:
   }

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/RussianCompoundRule.java
Patch:
@@ -46,7 +46,7 @@ public RussianCompoundRule(ResourceBundle messages) throws IOException {
             "Эти слова могут быть написаны через дефис или слитно.");
     addExamplePair(Example.wrong("Собрание состоится в <marker>конференц зале</marker>."),
                    Example.fixed("Собрание состоится в <marker>конференц-зале</marker>."));
-   super.sentenceStartsWithUpperCase = true;
+//   super.sentenceStartsWithUpperCase = true;
   }
 
   

File: languagetool-language-modules/ru/src/test/java/org/languagetool/rules/ru/RussianCompoundRuleTest.java
Patch:
@@ -64,7 +64,7 @@ public void testRule() throws IOException {
     // first part is a single character:
     check(0, "во-первых");
     check(1, "во первых", new String[]{"во-первых"});
-    check(1, "Во первых, мы были довольно высоко над уровнем моря.");
+//    check(1, "Во первых, мы были довольно высоко над уровнем моря.");
     check(1, "Мы, во первых, были довольно высоко над уровнем моря.");
     // incorrect sentences:
   }

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/MultiWordChunker2.java
Patch:
@@ -35,8 +35,9 @@
 /**
  * Multiword tagger-chunker.
  * Note: currently does not support:
- * <li> overlapping tagging (first matching multiword entry wins)
- *
+ * <ul>
+ *  <li> overlapping tagging (first matching multiword entry wins)
+ * </ul>
  * @author Andriy Rysin
  */
 public class MultiWordChunker2 extends AbstractDisambiguator {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -111,6 +111,7 @@ public void testWrongVerb() throws IOException {
     assertBad("Ich geht jetzt nach Hause, weil ich schon zu spät bin.");
     assertBad("„Du muss gehen.“");
     assertBad("Du weiß es doch.");
+    assertBad("Sie sagte zu mir: „Du muss gehen.“");
   }
 
   @Test

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -155,7 +155,7 @@ public void handle(HttpExchange httpExchange) throws IOException {
         errorCode = HttpURLConnection.HTTP_BAD_REQUEST;
         response = e.getMessage();
       } else if (e.getCause() != null && e.getCause() instanceof TimeoutException) {
-        errorCode = HttpURLConnection.HTTP_UNAVAILABLE;
+        errorCode = HttpURLConnection.HTTP_INTERNAL_ERROR;
         response = "Checking took longer than " + config.getMaxCheckTimeMillis()/1000.0f + " seconds, which is this server's limit. " +
                    "Please make sure you have selected the proper language or consider submitting a shorter text.";
       } else {

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerTest.java
Patch:
@@ -184,8 +184,8 @@ public void testTimeout() throws Exception {
         fail("Check was expected to be stopped because it took too long (> 1ms), it took " +
                 (System.currentTimeMillis()-t + "ms when measured from client side"));
       } catch (IOException expected) {
-        if (!expected.toString().contains(" 503 ")) {
-          fail("Expected exception with error 503, got: " + expected);
+        if (!expected.toString().contains(" 500 ")) {
+          fail("Expected exception with error 500, got: " + expected);
         }
       }
     } finally {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -905,7 +905,7 @@ static void showError(Throwable e) {
       throw new RuntimeException(e);
     }
     String msg = "An error has occurred in LanguageTool "
-        + JLanguageTool.VERSION + ":\n" + e + "\nStacktrace:\n";
+        + JLanguageTool.VERSION + " (" + JLanguageTool.BUILD_DATE + "):\n" + e + "\nStacktrace:\n";
     msg += Tools.getFullStackTrace(e);
     String metaInfo = "OS: " + System.getProperty("os.name") + " on "
         + System.getProperty("os.arch") + ", Java version "

File: languagetool-server/src/main/java/org/languagetool/server/UserLimits.java
Patch:
@@ -67,9 +67,9 @@ static UserLimits getLimitsFromToken(HTTPServerConfig config, String token) {
         throw new RuntimeException("You specified a 'token' parameter but this server doesn't accept tokens");
       }
       Algorithm algorithm = Algorithm.HMAC256(secretKey);
-      JWT.require(algorithm).build().verify(token);
       DecodedJWT decodedToken;
       try {
+        JWT.require(algorithm).build().verify(token);
         decodedToken = JWT.decode(token);
       } catch (JWTDecodeException e) {
         throw new AuthException("Could not decode token '" + token + "'", e);

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/RussianCompoundRule.java
Patch:
@@ -46,7 +46,9 @@ public RussianCompoundRule(ResourceBundle messages) throws IOException {
             "Эти слова могут быть написаны через дефис или слитно.");
     addExamplePair(Example.wrong("Собрание состоится в <marker>конференц зале</marker>."),
                    Example.fixed("Собрание состоится в <marker>конференц-зале</marker>."));
+   super.sentenceStartsWithUpperCase = true;
   }
+
   
   @Override
   public String getId() {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -171,7 +171,8 @@ public class VerbAgreementRule extends TextLevelRule {
   
   private static final Set<String> CONJUNCTIONS = new HashSet<>(Arrays.asList(
     "weil",
-    "obwohl"/*,
+    "obwohl",
+    "dass"/*,
     "damit",
     "wenn"*/
   ));

File: languagetool-core/src/main/java/org/languagetool/rules/PunctuationMarkAtParagraphEnd.java
Patch:
@@ -77,7 +77,7 @@ private static boolean isParaBreak (AnalyzedTokenReadings token) {
   @Override
   public RuleMatch[] match(List<AnalyzedSentence> sentences) throws IOException {
     List<RuleMatch> ruleMatches = new ArrayList<>();
-    int lastPara = 0;
+    int lastPara = -1;
     int pos = 0;
     boolean doCheck = true;
     boolean isFirstWord = false;

File: languagetool-core/src/main/java/org/languagetool/rules/CommaWhitespaceRule.java
Patch:
@@ -76,8 +76,8 @@ public final RuleMatch[] match(AnalyzedSentence sentence) {
     boolean prevWhite = false;
     for (int i = 0; i < tokens.length; i++) {
       String token = tokens[i].getToken();
-      boolean isWhitespace = tokens[i].isWhitespace() || StringTools.isNonBreakingWhitespace(token)
-          || tokens[i].isFieldCode();
+      boolean isWhitespace = (tokens[i].isWhitespace() || StringTools.isNonBreakingWhitespace(token)
+          || tokens[i].isFieldCode()) && !token.equals("\u200B");
       String msg = null;
       String suggestionText = null;
       if (isWhitespace && isLeftBracket(prevToken)) {

File: languagetool-language-modules/nl/src/test/java/org/languagetool/synthesis/nl/DutchSynthesizerTest.java
Patch:
@@ -40,7 +40,7 @@ public final void testSynthesizeStringString() throws IOException {
     assertEquals("[hebt, heeft]", Arrays.toString(synth.synthesize(dummyToken("hebben"), "WKW:TGW:3EP", true)));
     //with regular expressions
     assertEquals("[doorgeseind]", Arrays.toString(synth.synthesize(dummyToken("doorseinen"), "WKW:VTD:ONV", true)));    
-    assertEquals("[doorseine, doorseinenden, doorseinend, doorseinende, doorsein, doorseint, doorseinen, doorseinde, doorseinden, doorgeseind, doorgeseinde, doorgeseinden]", Arrays.toString(synth.synthesize(dummyToken("doorseinen"), "WKW.*", true)));
+    assertEquals("[doorseine, doorseinenden, doorseinend, doorseinende, doorsein, doorseint, doorseinen, doorseinde, doorseinden, doorgeseind, doorgeseinde]", Arrays.toString(synth.synthesize(dummyToken("doorseinen"), "WKW.*", true)));
   }
 
   private AnalyzedToken dummyToken(String tokenStr) {

File: languagetool-tools/src/main/java/org/languagetool/tools/SynthDictionaryBuilder.java
Patch:
@@ -58,7 +58,9 @@ public static void main(String[] args) throws Exception {
   }
   
   File build(File plainTextDictFile, File infoFile) throws Exception {
-    File tempFile = File.createTempFile(SynthDictionaryBuilder.class.getSimpleName(), ".txt");
+    String outputFilename = this.getOutputFilename();
+    File outputDirectory = new File(outputFilename).getParentFile();
+    File tempFile = File.createTempFile(SynthDictionaryBuilder.class.getSimpleName(), ".txt", outputDirectory);
     File reversedFile = null;
     try {
       Set<String> itemsToBeIgnored = getIgnoreItems(new File(infoFile.getParent(), "filter-archaic.txt"));

File: languagetool-standalone/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -39,7 +39,7 @@ public class WordListValidatorTest {
   private static final Pattern VALID_CHARS = Pattern.compile(
           "[0-9a-zA-ZöäüÖÄÜßëçèéáàóòÈÉÁÀÓÒãñíîş&" +
           "âêôõû" +  // for Portuguese
-          "Œ€ūαΑβΒγΓδΔεΕζΖηΗθΘιΙκΚλΛμΜνΝξΞοΟπΠρΡσΣτΤυΥφΦχΧψΨωΩάΆέΈίΊήΉύΎϊϋΰΐœţ" +
+          "Œ€ūαΑβΒγɣΓδΔεΕζΖηΗθΘιΙκΚλΛμΜνΝξΞοΟπΠρΡσΣτΤυΥφΦχΧψΨωΩάΆέΈίΊήΉύΎϊϋΰΐœţ" +
           "Śśōżúï" +
           "·" +   // for Catalan
           "./-]+" + 

File: languagetool-language-modules/nl/src/test/java/org/languagetool/rules/nl/PreferredWordRuleTest.java
Patch:
@@ -23,6 +23,7 @@
 
 import java.io.IOException;
 
+import org.junit.Ignore;
 import org.junit.Test;
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.JLanguageTool;
@@ -32,6 +33,7 @@
 public class PreferredWordRuleTest {
   
   @Test
+  @Ignore("don't run, as preferredwords.csv has been emptied")
   public void test() throws IOException {
     Language dutch = Languages.getLanguageForShortCode("nl");
     PreferredWordRule rule = new PreferredWordRule(JLanguageTool.getMessageBundle());

File: languagetool-language-modules/nl/src/test/java/org/languagetool/rules/nl/CompoundRuleTest.java
Patch:
@@ -37,8 +37,8 @@ public void setUp() throws Exception {
   @Test
   public void testRule() throws IOException {
     // correct sentences:
-	check(0, "Dit is een zee-egel.");
-	check(0, "Zee-egel is een woord.");
+    check(0, "Dit is een zee-egel.");
+    check(0, "Zee-egel is een woord.");
     // incorrect sentences:
     check(1, "Dit is een zee egel.");
     check(1, "Zee egel is een woord.");

File: languagetool-language-modules/nl/src/main/java/org/languagetool/rules/nl/CompoundRule.java
Patch:
@@ -37,6 +37,7 @@ public CompoundRule(ResourceBundle messages) throws IOException {
             "Dit woord hoort waarschijnlijk aaneengeschreven.",
             "Deze uitdrukking hoort mogelijk aan elkaar, eventueel met een koppelteken.",
             "Koppeltekenprobleem");
+    super.sentenceStartsWithUpperCase = true;
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/RegexPatternRule.java
Patch:
@@ -55,7 +55,7 @@ class RegexPatternRule extends AbstractPatternRule implements RuleMatcher {
     this.message = message;
     this.pattern = regex;
     this.suggestionsOutMsg = suggestionsOutMsg;
-    this.markGroup = regexpMark;
+    markGroup = regexpMark;
   }
 
   public Pattern getPattern() {

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/RegexPatternRuleTest.java
Patch:
@@ -25,8 +25,6 @@
 import org.languagetool.rules.RuleMatch;
 
 import java.io.IOException;
-import java.util.List;
-import java.util.regex.Pattern;
 
 import static org.hamcrest.core.Is.is;
 import static org.junit.Assert.*;

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/RegexPatternRule.java
Patch:
@@ -55,7 +55,7 @@ class RegexPatternRule extends AbstractPatternRule implements RuleMatcher {
     this.message = message;
     this.pattern = regex;
     this.suggestionsOutMsg = suggestionsOutMsg;
-    markGroup = regexpMark;
+    this.markGroup = regexpMark;
   }
 
   public Pattern getPattern() {

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/XMLRuleHandler.java
Patch:
@@ -519,7 +519,7 @@ protected List<Match> addLegacyMatches(List <Match> existingSugMatches, String m
     int ind = 0;
     int matchCounter = 0;
     while (pos != -1) {
-      pos = messageStr.indexOf('\\', ind + 1);
+      pos = messageStr.indexOf('\\', ind);
       if (pos != -1 && messageStr.length() > pos && Character.isDigit(messageStr.charAt(pos + 1))) {
         if (pos == 0 || messageStr.charAt(pos - 1) != '\u0001') {
           Match mWorker = new Match(null, null, false, null,
@@ -536,7 +536,7 @@ protected List<Match> addLegacyMatches(List <Match> existingSugMatches, String m
           matchCounter++;
         }
       }
-      ind = pos;
+      ind = pos + 1;
     }
 
     if (sugMatch.isEmpty()) {

File: languagetool-core/src/test/java/org/languagetool/rules/Issue373Test.java
Patch:
@@ -35,7 +35,7 @@ public void setUp() throws Exception {
 
   @Test
   public void testIssueSuggestionInside() throws Exception {
-    String wrongString = "Xnel vola nén Xnel vola nén";
+    String wrongString = "Xnel vola nén";
     String correctString = "Vo nel la nén";
     testString(wrongString, correctString, ISSUE_373_TEST_SUGGESTION_INSIDE);
   }

File: languagetool-standalone/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -307,6 +307,7 @@ private String getRuleMessage(Rule rule, JLanguageTool languageTool) throws Exce
   public void testRuleMessages() throws Exception {
     JLanguageTool langTool = new JLanguageTool(english);
     //JLanguageTool langTool = new JLanguageTool(new German());
+    //JLanguageTool langTool = new JLanguageTool(new Russian());
     String[] rulesDisabled = {
             // en:
             "EN_QUOTES", "UPPERCASE_SENTENCE_START", "WHITESPACE_RULE",

File: languagetool-standalone/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -342,6 +342,8 @@ public void testRuleMessages() throws Exception {
         }
         System.out.println(String.format("Rule: %s\nMessage: %s\nMatch:\n%s: %s",
                 rule.getId(), message, ruleMatch.getRule().getId(), ruleMatch.getMessage()));
+        System.out.println(String.format("Error in [%d,%d]: \"%s\"", ruleMatch.getFromPos(),
+                ruleMatch.getToPos(), message.substring(ruleMatch.getFromPos(), ruleMatch.getToPos())));
         System.out.println("-------");
         matchesCounter++;
       }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -329,9 +329,9 @@ else if (hasUnambiguouslyPersonAndNumber(tokens[i], "2", "SIN") && !"Probst".equ
       int plus1 = ((posDu + 1) == tokens.length) ? 0 : +1;
       BooleanAndFiniteVerb check = verbDoesMatchPersonAndNumber(tokens[posDu - 1], tokens[posDu + plus1], "2", "SIN", finiteVerb);
       if (!check.verbDoesMatchPersonAndNumber &&
-          !tokens[posDu+plus1].hasPartialPosTag("VER:1:SIN:KJ2") && // "Wenn ich du wäre"
-          !tokens[posDu+plus1].hasPartialPosTag("ADJ:") && // "dass du  billige Klamotten..."
-          !tokens[posDu-1].hasPartialPosTag("VER:1:SIN:KJ2")) {
+          !tokens[posDu+plus1].hasPosTagStartingWith("VER:1:SIN:KJ2") && // "Wenn ich du wäre"
+          !(tokens[posDu+plus1].hasPosTagStartingWith("ADJ:") && !tokens[posDu+plus1].hasPosTag("ADJ:PRD:GRU"))&& // "dass du  billige Klamotten..."
+          !tokens[posDu-1].hasPosTagStartingWith("VER:1:SIN:KJ2")) {
         if (!nextButOneIsModal(tokens, posDu)) {
           ruleMatches.add(ruleMatchWrongVerbSubject(tokens[posDu], check.finiteVerb, "2:SIN", pos, sentence));
         }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -110,6 +110,7 @@ public void testWrongVerb() throws IOException {
     assertBad("Weiter befindest sich im Osten die Gemeinde Dorf.");
     assertBad("Ich geht jetzt nach Hause, weil ich schon zu spät bin.");
     assertBad("„Du muss gehen.“");
+    assertBad("Du weiß es doch.");
   }
 
   @Test

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -273,7 +273,7 @@ private List<RuleMatch> match(AnalyzedSentence sentence, int pos) {
       }
       
       if (tokens[i].hasPartialPosTag("VER")
-          && (Character.isLowerCase(tokens[i].getToken().charAt(0)) || i == 1 || StringUtils.equalsAny(tokens[i-1].getToken(), "„", "\"")) ) {
+          && (Character.isLowerCase(tokens[i].getToken().charAt(0)) || i == 1 || isQuotationMark(tokens[i-1])) ) {
         if (hasUnambiguouslyPersonAndNumber(tokens[i], "1", "SIN")
             && !(strToken.equals("bin") && (BIN_IGNORE.contains(tokens[i-1].getToken())
                   || (tokens.length != i + 1 && tokens[i+1].getToken().startsWith("Laden")) ))) {
@@ -325,7 +325,7 @@ else if (hasUnambiguouslyPersonAndNumber(tokens[i], "2", "SIN") && !"Probst".equ
     
     if (posVer2Sin != -1 && posDu == -1 && !isQuotationMark(tokens[posVer2Sin-1])) {
       ruleMatches.add(ruleMatchWrongVerb(tokens[posVer2Sin], pos, sentence));
-    } else if (posDu > 0 && !isNear(posPossibleVer2Sin, posDu) && !isQuotationMark(tokens[posDu-1])) {
+    } else if (posDu > 0 && !isNear(posPossibleVer2Sin, posDu) && (!isQuotationMark(tokens[posDu-1]) || posDu < 3)) {
       int plus1 = ((posDu + 1) == tokens.length) ? 0 : +1;
       BooleanAndFiniteVerb check = verbDoesMatchPersonAndNumber(tokens[posDu - 1], tokens[posDu + plus1], "2", "SIN", finiteVerb);
       if (!check.verbDoesMatchPersonAndNumber &&

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -109,6 +109,7 @@ public void testWrongVerb() throws IOException {
     assertBad("Solltest ihr das machen?", "Subjekt und Prädikat (Solltest)");
     assertBad("Weiter befindest sich im Osten die Gemeinde Dorf.");
     assertBad("Ich geht jetzt nach Hause, weil ich schon zu spät bin.");
+    assertBad("„Du muss gehen.“");
   }
 
   @Test

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -26,6 +26,7 @@
 import java.util.ResourceBundle;
 import java.util.Set;
 
+import org.apache.commons.lang3.StringUtils;
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.AnalyzedToken;
 import org.languagetool.AnalyzedTokenReadings;
@@ -272,7 +273,7 @@ private List<RuleMatch> match(AnalyzedSentence sentence, int pos) {
       }
       
       if (tokens[i].hasPartialPosTag("VER")
-          && (Character.isLowerCase(tokens[i].getToken().charAt(0)) || i == 1 || "„".equals(tokens[i-1].getToken())) ) {
+          && (Character.isLowerCase(tokens[i].getToken().charAt(0)) || i == 1 || StringUtils.equalsAny(tokens[i-1].getToken(), "„", "\"")) ) {
         if (hasUnambiguouslyPersonAndNumber(tokens[i], "1", "SIN")
             && !(strToken.equals("bin") && (BIN_IGNORE.contains(tokens[i-1].getToken())
                   || (tokens.length != i + 1 && tokens[i+1].getToken().startsWith("Laden")) ))) {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -272,7 +272,7 @@ private List<RuleMatch> match(AnalyzedSentence sentence, int pos) {
       }
       
       if (tokens[i].hasPartialPosTag("VER")
-          && (Character.isLowerCase(tokens[i].getToken().charAt(0)) || i == 1) ) {
+          && (Character.isLowerCase(tokens[i].getToken().charAt(0)) || i == 1 || "„".equals(tokens[i-1].getToken())) ) {
         if (hasUnambiguouslyPersonAndNumber(tokens[i], "1", "SIN")
             && !(strToken.equals("bin") && (BIN_IGNORE.contains(tokens[i-1].getToken())
                   || (tokens.length != i + 1 && tokens[i+1].getToken().startsWith("Laden")) ))) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -99,6 +99,7 @@ public void testWrongVerb() throws IOException {
     assertGood("Das ist mir nicht klar, kannst ja mal beim Kunden nachfragen.");
     assertGood("So tes\u00ADtest Du das mit dem soft hyphen.");
     assertGood("Viele Brunnen in Italiens Hauptstadt sind bereits abgeschaltet.");
+    assertGood("„Werde ich tun!“");
     // incorrect sentences:
     assertBad("Als Borcarbid weißt es eine hohe Härte auf.");
     assertBad("Das greift auf Vorläuferinstitutionen bist auf die Zeit von 1234 zurück.");

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -74,8 +74,8 @@ public void handle(HttpExchange httpExchange) throws IOException {
     long startTime = System.currentTimeMillis();
     String remoteAddress = null;
     Map<String, String> parameters = new HashMap<>();
+    int reqId = reqCounter.incrementRequestCount();
     try {
-      int reqId = reqCounter.incrementRequestCount();
       URI requestedUri = httpExchange.getRequestURI();
       String origAddress = httpExchange.getRemoteAddress().getAddress().getHostAddress();
       String realAddressOrNull = getRealRemoteAddressOrNull(httpExchange);
@@ -167,7 +167,7 @@ public void handle(HttpExchange httpExchange) throws IOException {
       sendError(httpExchange, errorCode, "Error: " + response);
     } finally {
       httpExchange.close();
-      reqCounter.decrementHandleCount(reqCounter.getRequestCount());
+      reqCounter.decrementHandleCount(reqId);
       ServerTools.print("Total check time: " + (System.currentTimeMillis() - startTime) + "ms, r:" + reqCounter.getRequestCount());
     }
   }

File: languagetool-server/src/main/java/org/languagetool/server/V2TextChecker.java
Patch:
@@ -39,8 +39,8 @@ class V2TextChecker extends TextChecker {
 
   private static final String JSON_CONTENT_TYPE = "application/json";
 
-  V2TextChecker(HTTPServerConfig config, boolean internalServer, Queue<Runnable> workQueue, AtomicInteger handleCount, AtomicInteger reqCount) {
-    super(config, internalServer, workQueue, handleCount, reqCount);
+  V2TextChecker(HTTPServerConfig config, boolean internalServer, Queue<Runnable> workQueue, RequestCounter reqCounter) {
+    super(config, internalServer, workQueue, reqCounter);
   }
 
   @Override

File: languagetool-server/src/test/java/org/languagetool/server/TextCheckerTest.java
Patch:
@@ -36,15 +36,14 @@
 import java.util.Date;
 import java.util.HashMap;
 import java.util.Map;
-import java.util.concurrent.atomic.AtomicInteger;
 
 import static org.hamcrest.core.Is.is;
 import static org.junit.Assert.*;
 
 public class TextCheckerTest {
 
   private final String english = "This is clearly an English text, should be easy to detect.";
-  private final TextChecker checker = new V2TextChecker(new HTTPServerConfig(), false, null, new AtomicInteger(), new AtomicInteger());
+  private final TextChecker checker = new V2TextChecker(new HTTPServerConfig(), false, null, new RequestCounter());
 
   @Test
   public void testMaxTextLength() throws Exception {
@@ -53,7 +52,7 @@ public void testMaxTextLength() throws Exception {
     params.put("language", "en");
     HTTPServerConfig config1 = new HTTPServerConfig();
     config1.setMaxTextLength(10);
-    TextChecker checker = new V2TextChecker(config1, false, null, new AtomicInteger(), new AtomicInteger());
+    TextChecker checker = new V2TextChecker(config1, false, null, new RequestCounter());
     try {
       checker.checkText(new AnnotatedTextBuilder().addText("longer than 10 chars").build(), new FakeHttpExchange(), params, null, null);
       fail();

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -108,7 +108,7 @@ public void handle(HttpExchange httpExchange) throws IOException {
       }
       if (config.getMaxWorkQueueSize() != 0 && workQueue.size() > config.getMaxWorkQueueSize()) {
         String response = "Error: There are currently too many parallel requests. Please try again later.";
-        print(response + " Queue size: " + workQueue.size() + ", maximum size: " + config.getMaxWorkQueueSize());
+        print(response + " Queue size: " + workQueue.size() + ", maximum size: " + config.getMaxWorkQueueSize() + ", handlers:" + handleCount.get());
         sendError(httpExchange, HttpURLConnection.HTTP_UNAVAILABLE, "Error: " + response);
         return;
       }

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -172,7 +172,8 @@ public List<RuleMatch> call() throws Exception {
         String message = "Text checking took longer than allowed maximum of " + limits.getMaxCheckTimeMillis() +
                          " milliseconds (cancelled: " + cancelled +
                          ", language: " + lang.getShortCodeWithCountryAndVariant() + ", #" + count +
-                         ", " + aText.getPlainText().length() + " characters of text, system load: " + loadInfo + ")";
+                         ", " + aText.getPlainText().length() + " characters of text" +
+                         ", h: " + handleCount.get() + ", system load: " + loadInfo + ")";
         if (params.allowIncompleteResults) {
           print(message + " - returning " + ruleMatchesSoFar.size() + " matches found so far");
           matches = new ArrayList<>(ruleMatchesSoFar);  // threads might still be running, so make a copy

File: languagetool-language-modules/nl/src/main/java/org/languagetool/language/Dutch.java
Patch:
@@ -129,6 +129,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
             new DutchWrongWordInContextRule(messages),
             new WordCoherencyRule(messages),
             new SimpleReplaceRule(messages),
+            new LongSentenceRule(messages, false),
             new PreferredWordRule(messages)
     );
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/LongSentenceRule.java
Patch:
@@ -43,7 +43,7 @@ public LongSentenceRule(ResourceBundle messages, boolean defaultActive) {
     super.setCategory(Categories.STYLE.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Style);
     addExamplePair(Example.wrong("<marker>Dies ist ein Bandwurmsatz, der immer weiter geht, obwohl das kein guter Stil ist, den man eigentlich berücksichtigen sollte, obwohl es auch andere Meinungen gibt, die aber in der Minderzahl sind, weil die meisten Autoren sich doch an die Stilvorgaben halten, wenn auch nicht alle, was aber letztendlich wiederum eine Sache des Geschmacks ist</marker>."),
-            Example.fixed("<marker>Dies ist ein kurzer Satz.</marker>"));
+                   Example.fixed("<marker>Dies ist ein kurzer Satz.</marker>"));
     if (defaultActive) {
       setDefaultOn();
     }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -169,7 +169,7 @@ public class CaseRule extends Rule {
         csToken("das"),
         posRegex("VER:.*"),
         posRegex("VER:AUX:.*"),
-        pos("PKT")
+        posRegex("PKT|KON:NEB")
     ),
     Arrays.asList(
         // um ihren eigenen Glauben an das Gute, Wahre und Schöne zu stärken.

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/FrenchCompoundAwareHunspellRule.java
Patch:
@@ -30,7 +30,7 @@
 import java.util.*;
 
 /**
- * A French spell checke that uses hunspell for checking but Morfologik for suggestions (for performance reasons).
+ * A French spell checker that uses hunspell for checking but Morfologik for suggestions (for performance reasons).
  * @since 4.0
  */
 public class FrenchCompoundAwareHunspellRule extends CompoundAwareHunspellRule {

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/MorfologikCatalanSpellerRuleTest.java
Patch:
@@ -228,7 +228,8 @@ public void testMorfologikSpeller() throws IOException {
         
         matches = rule.match(langTool.getAnalyzedSentence("col·laborÀ"));
         assertEquals(1, matches.length);
-        assertEquals("col·laborà", matches[0].getSuggestedReplacements().get(0));
+        assertEquals("col·labora", matches[0].getSuggestedReplacements().get(0));
+        assertEquals("col·laborà", matches[0].getSuggestedReplacements().get(1));
         
         matches = rule.match(langTool.getAnalyzedSentence("después"));
         assertEquals(1, matches.length);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -96,11 +96,11 @@ public void testProhibited() throws Exception {
   public void testGetAdditionalTopSuggestions() throws Exception {
     GermanSpellerRule rule = new GermanSpellerRule(TestTools.getMessages("de"), GERMAN_DE);
     JLanguageTool lt = new JLanguageTool(GERMAN_DE);
-    assertThat(rule.match(lt.getAnalyzedSentence("konservierungsstoffe"))[0].getSuggestedReplacements().toString(), is("[Konservierungsstoffe]"));
     assertThat(rule.match(lt.getAnalyzedSentence("konservierungsstoffstatistik"))[0].getSuggestedReplacements().toString(), is("[Konservierungsstoffstatistik]"));
     assertThat(rule.match(lt.getAnalyzedSentence("konservierungsstoffsasdsasda"))[0].getSuggestedReplacements().size(), is(0));
     assertThat(rule.match(lt.getAnalyzedSentence("Ventrolateral")).length, is(0));
     assertThat(rule.match(lt.getAnalyzedSentence("Majonäse."))[0].getSuggestedReplacements().toString(), is("[Mayonnaise.]"));
+    assertFirstSuggestion("konservierungsstoffe", "Konservierungsstoffe", rule, lt);
     assertFirstSuggestion("Ist Ventrolateral", "ventrolateral", rule, lt);
     assertFirstSuggestion("denkte", "dachte", rule, lt);
     assertFirstSuggestion("schwimmte", "schwamm", rule, lt);

File: languagetool-language-modules/eo/src/main/java/org/languagetool/rules/eo/DateCheckFilter.java
Patch:
@@ -66,6 +66,7 @@ protected int getDayOfMonth(String dayStr) {
     if (day.equals("sepa"))  n += 7;
     if (day.equals("oka"))   n += 8;
     if (day.equals("naŭa"))  n += 9;
+    if (day.equals("nauxa")) n += 9;
     return n;
   }
 

File: languagetool-core/src/main/java/org/languagetool/ResultCache.java
Patch:
@@ -32,7 +32,7 @@
  * the JLanguageTool objects all use the same rules.</strong> For example, if you call {@code JLanguageTool.addRule()}
  * in different ways for the different instances that you use the same cache for, the cache will return invalid results.
  * Using a cache with bitext rules isn't supported either.
- * It is okay however, to use same same cache for {@link JLanguageTool} objects with different languages, as
+ * It is okay however, to use the same cache for {@link JLanguageTool} objects with different languages, as
  * cached results are not used for a different language.
  * @since 3.7
  */

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/DashRuleTest.java
Patch:
@@ -44,6 +44,7 @@ public void testRule() throws IOException {
     assertGood("Die große Diäten- oder Gehaltserhöhung kam dann doch.", lt);
     assertGood("Erst so - Karl-Heinz dann blah.", lt);
     assertGood("Erst so -- Karl-Heinz aber...", lt);
+    assertGood("NORD- UND SÜDKOREA", lt);
     
     // incorrect sentences:
     assertBad("Die große Diäten- Erhöhung kam dann doch.", lt);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -109,7 +109,7 @@ public class CaseRule extends Rule {
     ),
     Arrays.asList(
       regex("Vereinigte[ns]?"),
-      regex("Staaten|Königreiche?s?")
+      regex("Staaten|Königreiche?s?|Bühnen")
     ),
     Arrays.asList(
       csToken("Den"),

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -251,7 +251,7 @@ public class CaseRule extends Rule {
      ),
      Arrays.asList(
        // "Das Aus für Italien kam unerwartet." / "Müller drängt auf Aus bei Pflichtmitgliedschaft"
-       regex("auf|das|vor|an"),
+       regex("auf|das|vor|a[mn]"),
        csToken("Aus"),
        posRegex("^PRP:.+|VER:[1-3]:.+")
      ),

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -251,7 +251,7 @@ public class CaseRule extends Rule {
      ),
      Arrays.asList(
        // "Das Aus für Italien kam unerwartet." / "Müller drängt auf Aus bei Pflichtmitgliedschaft"
-       regex("auf|das|vor"),
+       regex("auf|das|vor|an"),
        csToken("Aus"),
        posRegex("^PRP:.+|VER:[1-3]:.+")
      ),

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -624,7 +624,8 @@ protected List<String> getAdditionalTopSuggestions(List<String> suggestions, Str
             }
             additionalSuggestions = newList;
           }
-          return additionalSuggestions;
+          // avoid overly long lists of suggestions (we just take the first results, although we don't know whether they are better):
+          return additionalSuggestions.subList(0, Math.min(5, additionalSuggestions.size()));
         }
       }
     }

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -120,6 +120,8 @@ public void handle(HttpExchange httpExchange) throws IOException {
           throw new IllegalArgumentException("Missing arguments for LanguageTool API. Please see https://languagetool.org/http-api/swagger-ui/#/default");
         } else if (requestedUri.getRawPath().contains("/v2/")) {
           throw new IllegalArgumentException("You have '/v2/' in your path, but not at the root. Try an URL like 'http://server/v2/...' ");
+        } else if (requestedUri.getRawPath().equals("/favicon.ico")) {
+          sendError(httpExchange, HttpURLConnection.HTTP_NOT_FOUND, "Not found");
         } else {
           throw new IllegalArgumentException("Seems like you're using an old version of our API that's not supported anymore. Please see https://languagetool.org/http-api/migration.php");
         }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -210,6 +210,7 @@ public void testGetAdditionalTopSuggestions() throws Exception {
     assertFirstSuggestion("okey", "okay", rule, lt);
     assertFirstSuggestion("Energiesparung", "Energieeinsparung", rule, lt);
     assertFirstSuggestion("Deluxe-Version", "De-luxe-Version", rule, lt);
+    assertFirstSuggestion("De-luxe-Champagnr", "De-luxe-Champagner", rule, lt);
   }
 
   @Test

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -65,7 +65,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
   
   // some exceptions for changes to the spelling in 2017 - just a workaround so we don't have to touch the binary dict:
   private static final Pattern PREVENT_SUGGESTION = Pattern.compile(
-          ".*(?i:Majonäse|Bravur|Anschovis|Belkanto|Campagne|Frotté|Grisli|Jokei|Joga|Kalvinismus|Kanossa|Kargo|Ketschup|" +
+          ".*(?i:Majonäse|Bravur|Anschovis|Belkanto|Campagne|Frotté|Grisli|Jockei|Joga|Kalvinismus|Kanossa|Kargo|Ketschup|" +
           "Kollier|Kommunikee|Masurka|Negligee|Nessessär|Poulard|Varietee|Wandalismus|kalvinist).*");
   private static final Pattern GEOGRAPHICAL_PREFIXES = Pattern.compile("(nord|ost|süd|west).+");
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -282,6 +282,7 @@ public int getPriorityForId(String id) {
       case "OLD_SPELLING_INTERNAL": return 10;
       case "ANS_OHNE_APOSTROPH": return 1;
       case "CONFUSION_RULE": return -1;  // probably less specific than the rules from grammar.xml
+      case "AKZENT_STATT_APOSTROPH": return -1;  // lower prio than PLURAL_APOSTROPH
       case "PUNKT_ENDE_ABSATZ": return -10;  // should never hide other errors, as chance for a false alarm is quite high
       case "KOMMA_ZWISCHEN_HAUPT_UND_NEBENSATZ": return -10;
     }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -260,6 +260,7 @@ public void testDashAndHyphen() throws Exception {
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Des World Wide Webs")).length); // expanded multi-word entry from spelling.txt
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Der westperuanische Ferienort.")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("„Pumpe“-Nachfolge")).length);
+    assertEquals(0, rule.match(lt.getAnalyzedSentence("ÖVP- und FPÖ-Chefverhandler")).length); // first part is from spelling.txt
 
     assertEquals(1, rule.match(lt.getAnalyzedSentence("Miet und Zinseinkünfte")).length);
     assertEquals(1, rule.match(lt.getAnalyzedSentence("Stil- und Grammatik gut")).length);

File: languagetool-language-modules/sr/src/main/java/org/languagetool/rules/sr/jekavian/MorfologikJekavianSpellerRule.java
Patch:
@@ -30,7 +30,7 @@ public final class MorfologikJekavianSpellerRule extends MorfologikSpellerRule {
 
   public static final String RULE_ID = "MORFOLOGIK_RULE_SR_JEKAVIAN";
   
-  private static final String BASE_DICTIONARY_PATH = "/sr/dictionary/јekavian/";
+  private static final String BASE_DICTIONARY_PATH = "/sr/dictionary/jekavian/";
 
   public MorfologikJekavianSpellerRule(
           ResourceBundle messages,

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -280,6 +280,7 @@ public LanguageMaintainedState getMaintainedState() {
   public int getPriorityForId(String id) {
     switch (id) {
       case "KOMMA_ZWISCHEN_HAUPT_UND_NEBENSATZ": return -10;
+      case "PUNKT_ENDE_ABSATZ": return -10;  // should never hide other errors, as chance for a false alarm is quite high
       case "OLD_SPELLING_INTERNAL": return 10;
       case "CONFUSION_RULE": return -1;  // probably less specific than the rules from grammar.xml
       case "ANS_OHNE_APOSTROPH": return 1;

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -246,7 +246,9 @@ public void testDetNounRule() throws IOException {
     assertGood("Außerdem unterstützt mich Herr Müller beim abheften");
     assertGood("Außerdem unterstützt mich Frau Müller beim abheften");
     assertBad("Der Zustand meiner Gehirns.");
-    
+
+    assertBad("Lebensmittel sind da, um den menschliche Körper zu ernähren.");
+    assertBad("Geld ist da, um den menschliche Überleben sicherzustellen.");
     assertBad("Sie hatte das kleinen Kaninchen.");
     assertBad("Frau Müller hat das wichtigen Dokument gefunden.");
     assertBad("Ich gebe dir ein kleine Kaninchen.");

File: languagetool-core/src/test/java/org/languagetool/rules/LongSentenceRuleTest.java
Patch:
@@ -39,6 +39,7 @@ public void testMatch() throws Exception {
             "a a a a a a a a a a a " +
             "a a a a a a a a a a a " +
             "a a a a a a a a a a a " +
+            "a a a a a a a a a a a " +
             "rather that short text.", rule, languageTool);
     
     LongSentenceRule shortRule = new LongSentenceRule(TestTools.getEnglishMessages());

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/LongSentenceRule.java
Patch:
@@ -33,7 +33,7 @@
  */
 public class LongSentenceRule extends org.languagetool.rules.LongSentenceRule {
 
-  private static final boolean DEFAULT_INACTIVE = true;
+  private static final boolean DEFAULT_INACTIVE = false;
 
   /**
    * @param defaultActive allows default granularity
@@ -54,7 +54,6 @@ public LongSentenceRule(ResourceBundle messages, boolean defaultActive) {
    */
   public LongSentenceRule(ResourceBundle messages) {
     this(messages, DEFAULT_INACTIVE);
-    setDefaultOn();
   }
 
   @Override

File: languagetool-core/src/test/java/org/languagetool/rules/LongSentenceRuleTest.java
Patch:
@@ -41,7 +41,8 @@ public void testMatch() throws Exception {
             "a a a a a a a a a a a " +
             "rather that short text.", rule, languageTool);
     
-    LongSentenceRule shortRule = new LongSentenceRule(TestTools.getEnglishMessages(), 6);
+    LongSentenceRule shortRule = new LongSentenceRule(TestTools.getEnglishMessages());
+    shortRule.setDefaultValue(6);
     assertNoMatch("This is a rather short text.", shortRule, languageTool);
     assertMatch("This is also a rather short text.", shortRule, languageTool);
     assertNoMatch("These ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ don't count.", shortRule, languageTool);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -119,6 +119,7 @@ public void testRule() throws IOException {
     assertGood("Tausende Gläubige kamen.");
     assertGood("Es kamen Tausende Gläubige.");
     assertGood("Das schließen Forscher aus den gefundenen Spuren.");
+    assertGood("Wieder Verletzter bei Unfall");
 
     //assertBad("Sie sind nicht Verständlich");
     assertBad("Sie Vertraute niemandem.");

File: languagetool-standalone/src/main/java/org/languagetool/gui/Main.java
Patch:
@@ -1753,7 +1753,6 @@ public float getDigitAlignment() {
      *  <li>TextLineNumber.CENTER
      *  <li>TextLineNumber.RIGHT (default)
      *  </ul>
-     *  @param currentLineForeground  the Color used to render the current line
      */
     public void setDigitAlignment(float digitAlignment)  {
       this.digitAlignment =

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServer.java
Patch:
@@ -120,7 +120,7 @@ public void stop() {
   }
 
   public static void main(String[] args) {
-    if (args.length > 7 || usageRequested(args)) {
+    if (args.length > 9 || usageRequested(args)) {
       System.out.println("Usage: " + HTTPServer.class.getSimpleName() + " [--config propertyFile] [--port|-p port] [--public]");
       System.out.println("  --config FILE  a Java property file (one key=value entry per line) with values for:");
       printCommonConfigFileOptions();

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -275,6 +275,7 @@ public int getPriorityForId(String id) {
       case "KOMMA_ZWISCHEN_HAUPT_UND_NEBENSATZ": return -10;
       case "OLD_SPELLING_INTERNAL": return 10;
       case "CONFUSION_RULE": return -1;  // probably less specific than the rules from grammar.xml
+      case "ANS_OHNE_APOSTROPH": return 1;
     }
     return 0;
   }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/AbstractSimpleReplaceLemmasRule.java
Patch:
@@ -107,7 +107,7 @@ public final RuleMatch[] match(final AnalyzedSentence sentence) {
             } catch (IOException e) {
               throw new RuntimeException("Could not synthesize: " + replacementLemma + " with tag " + replacePOSTag, e);
             }   
-          } // add the suggestion without flexion
+          } // add the suggestion without inflection
           if (synthesized.length == 0 && replacementLemma.length()>1) {
             possibleReplacements.add(replacementLemma);
           } else {

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -144,7 +144,7 @@ public List<RuleMatch> call() throws Exception {
         if (params.allowIncompleteResults && ExceptionUtils.getRootCause(e) instanceof ErrorRateTooHighException) {
           print(e.getMessage() + " - returning " + ruleMatchesSoFar.size() + " matches found so far");
           matches = new ArrayList<>(ruleMatchesSoFar);  // threads might still be running, so make a copy
-          incompleteResultReason = ExceptionUtils.getRootCause(e).getMessage();
+          incompleteResultReason = "Results are incomplete: " + ExceptionUtils.getRootCause(e).getMessage();
         } else if (e.getCause() != null && e.getCause() instanceof OutOfMemoryError) {
           throw (OutOfMemoryError)e.getCause();
         } else {
@@ -164,7 +164,7 @@ public List<RuleMatch> call() throws Exception {
         if (params.allowIncompleteResults) {
           print(message + " - returning " + ruleMatchesSoFar.size() + " matches found so far");
           matches = new ArrayList<>(ruleMatchesSoFar);  // threads might still be running, so make a copy
-          incompleteResultReason = "Text checking took longer than allowed maximum of " + 
+          incompleteResultReason = "Results are incomplete: text checking took longer than allowed maximum of " + 
                   String.format(Locale.ENGLISH, "%.2f", limits.getMaxCheckTimeMillis()/1000.0) + " seconds";
         } else {
           throw new RuntimeException(message, e);

File: languagetool-server/src/main/java/org/languagetool/server/V2TextChecker.java
Patch:
@@ -48,9 +48,9 @@ protected void setHeaders(HttpExchange httpExchange) {
   }
 
   @Override
-  protected String getResponse(String text, Language lang, Language motherTongue, List<RuleMatch> matches, boolean incompleteResult) {
+  protected String getResponse(String text, Language lang, Language motherTongue, List<RuleMatch> matches, String incompleteResultsReason) {
     RuleMatchesAsJsonSerializer serializer = new RuleMatchesAsJsonSerializer();
-    return serializer.ruleMatchesToJson(matches, text, CONTEXT_SIZE, lang, incompleteResult);
+    return serializer.ruleMatchesToJson(matches, text, CONTEXT_SIZE, lang, incompleteResultsReason);
   }
 
   @NotNull

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1063,7 +1063,7 @@ private List<RuleMatch> getOtherRuleMatches() {
       int wordCounter = 0;
       for (AnalyzedSentence analyzedSentence : analyzedSentences) {
         String sentence = sentences.get(i++);
-        wordCounter += analyzedSentence.getTokens().length;
+        wordCounter += analyzedSentence.getTokensWithoutWhitespace().length;
         try {
           List<RuleMatch> sentenceMatches = null;
           InputSentence cacheKey = null;
@@ -1090,7 +1090,7 @@ private List<RuleMatch> getOtherRuleMatches() {
           }
           ruleMatches.addAll(adaptedMatches);
           float errorsPerWord = ruleMatches.size() / (float)wordCounter;
-          //System.out.println("errorPerWord " + errorsPerWord + " (matches: " + ruleMatches.size() + " / " + wordCounter + ")");   // de-DE: 0.3
+          //System.out.println("errorPerWord " + errorsPerWord + " (matches: " + ruleMatches.size() + " / " + wordCounter + ")");
           if (maxErrorsPerWordRate > 0 && errorsPerWord > maxErrorsPerWordRate && wordCounter > 25) {
             throw new ErrorRateTooHighException("Text checking was stopped due to too many errors (more than " + String.format("%.0f", maxErrorsPerWordRate*100) +
                     "% of words seem to have an error). Are you sure you have set the correct text language? Language set: " + language.getName());

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -246,8 +246,8 @@ public class CaseRule extends Rule {
         regex("[A-ZÄÖÜ0-9]+[a-zäöüß0-9]-[a-zäöüß]+")
      ),
      Arrays.asList(
-       // "Das Aus für Italien kam unerwartet."
-       token("das"),
+       // "Das Aus für Italien kam unerwartet." / "Müller drängt auf Aus bei Pflichtmitgliedschaft"
+       regex("auf|das|vor"),
        csToken("Aus"),
        posRegex("^PRP:.+|VER:[1-3]:.+")
      ),

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -729,10 +729,11 @@ private boolean ignoreCompoundWithIgnoredWord(String word) throws IOException{
       }
       String ignoredWord = word.substring(0, end);
       String partialWord = word.substring(end);
+      boolean isAllLowerCasePartialWord = StringUtils.isAllLowerCase(partialWord);
       boolean needFugenS = ENDINGS_NEEDING_FUGENS.matcher(ignoredWord).matches();
-      if (!needFugenS && partialWord.length() > 1) {
+      if (isAllLowerCasePartialWord && !needFugenS && partialWord.length() > 1) {
         return !hunspellDict.misspelled(partialWord) || !hunspellDict.misspelled(StringUtils.capitalize(partialWord));
-      } else if (needFugenS && partialWord.length() > 2) {
+      } else if (isAllLowerCasePartialWord && needFugenS && partialWord.length() > 2) {
         partialWord = partialWord.startsWith("s") ? partialWord.substring(1) : partialWord;
         return !hunspellDict.misspelled(partialWord) || !hunspellDict.misspelled(StringUtils.capitalize(partialWord));
       }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -296,6 +296,7 @@ public void testIgnoreWord() throws Exception {
     assertFalse(ruleGermany.doIgnoreWord("Frauversteher"));             // compound formed from two valid words, but still incorrect
     assertFalse(ruleGermany.doIgnoreWord("Wodkasglas"));                // compound formed from two valid words, but still incorrect
     assertFalse(ruleGermany.doIgnoreWord("Author"));
+    assertFalse(ruleGermany.doIgnoreWord("SecondhandWare"));             // from spelling.txt formed compound
     MyGermanSpellerRule ruleSwiss = new MyGermanSpellerRule(TestTools.getMessages("de"), GERMAN_CH);
     assertTrue(ruleSwiss.doIgnoreWord("einPseudoWortFürLanguageToolTests"));
     assertFalse(ruleSwiss.doIgnoreWord("Ligafußball"));        // 'ß' never accepted for Swiss

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -1077,8 +1077,8 @@ private List<RuleMatch> getOtherRuleMatches() {
           float errorsPerWord = ruleMatches.size() / (float)wordCounter;
           //System.out.println("errorPerWord " + errorsPerWord + " (matches: " + ruleMatches.size() + " / " + wordCounter + ")");   // de-DE: 0.3
           if (maxErrorsPerWordRate > 0 && errorsPerWord > maxErrorsPerWordRate && wordCounter > 25) {
-            throw new ErrorRateTooHighException("Text checking was stopped due to too many errors (more than " + maxErrorsPerWordRate +
-                    " errors per word on average). Are you sure you have set the correct text language? Language set: " + language.getName());
+            throw new ErrorRateTooHighException("Text checking was stopped due to too many errors (more than " + String.format("%.0f", maxErrorsPerWordRate*100) +
+                    "% of words seem to have an error). Are you sure you have set the correct text language? Language set: " + language.getName());
           }
           charCount += sentence.length();
           lineCount += countLineBreaks(sentence);

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -136,9 +136,9 @@ public void handle(HttpExchange httpExchange) throws IOException {
         errorCode = HttpURLConnection.HTTP_ENTITY_TOO_LARGE;
         response = e.getMessage();
         logStacktrace = false;
-      } else if (e instanceof ErrorRateTooHighException || ExceptionUtils.getRootCause(e) instanceof ErrorRateTooHighException) {
+      } else if (ExceptionUtils.getRootCause(e) instanceof ErrorRateTooHighException) {
         errorCode = HttpURLConnection.HTTP_BAD_REQUEST;
-        response = e.getMessage();
+        response = ExceptionUtils.getRootCause(e).getMessage();
         logStacktrace = false;
       } else if (e instanceof AuthException || e.getCause() != null && e.getCause() instanceof AuthException) {
         errorCode = HttpURLConnection.HTTP_FORBIDDEN;

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -20,6 +20,7 @@
 
 import com.sun.net.httpserver.HttpExchange;
 import com.sun.net.httpserver.HttpHandler;
+import org.apache.commons.lang.exception.ExceptionUtils;
 import org.apache.commons.lang3.StringUtils;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
@@ -135,7 +136,7 @@ public void handle(HttpExchange httpExchange) throws IOException {
         errorCode = HttpURLConnection.HTTP_ENTITY_TOO_LARGE;
         response = e.getMessage();
         logStacktrace = false;
-      } else if (e instanceof ErrorRateTooHighException || e.getCause() != null && e.getCause() instanceof ErrorRateTooHighException) {
+      } else if (e instanceof ErrorRateTooHighException || ExceptionUtils.getRootCause(e) instanceof ErrorRateTooHighException) {
         errorCode = HttpURLConnection.HTTP_BAD_REQUEST;
         response = e.getMessage();
         logStacktrace = false;

File: languagetool-server/src/main/java/org/languagetool/server/Server.java
Patch:
@@ -121,6 +121,7 @@ protected static void printCommonConfigFileOptions() {
     System.out.println("                 'maxTextHardLength' - maximum text length, applies even to users with a special secret 'token' parameter (optional)");
     System.out.println("                 'secretTokenKey' - secret JWT token key, if set by user and valid, maxTextLength can be increased by the user (optional)");
     System.out.println("                 'maxCheckTimeMillis' - maximum time in milliseconds allowed per check (optional)");
+    System.out.println("                 'maxErrorsPerWordRate' - checking will stop with error if there are more rules matches per word (optional)");
     System.out.println("                 'maxCheckThreads' - maximum number of threads working in parallel (optional)");
     System.out.println("                 'cacheSize' - size of internal cache in number of sentences (optional, default: 0)");
     System.out.println("                 'requestLimit' - maximum number of requests per requestLimitPeriodInSeconds (optional)");

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -273,6 +273,7 @@ Language detectLanguageOfString(String text, String fallbackLanguage, List<Strin
    */
   private JLanguageTool getLanguageToolInstance(Language lang, Language motherTongue, QueryParams params) throws Exception {
     JLanguageTool lt = new JLanguageTool(lang, motherTongue, cache);
+    lt.setMaxErrorsPerWordRate(config.getMaxErrorsPerWordRate());
     if (config.getLanguageModelDir() != null) {
       lt.activateLanguageModelRules(config.getLanguageModelDir());
     }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -143,7 +143,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     putRepl("[mM]atschscheiben?", "[mM]atschsch", "Mattsch");
     put("schafen?", w -> Arrays.asList(w.replaceFirst("sch", "schl"), w.replaceFirst("af", "arf"), w.replaceFirst("af", "aff")));
     putRepl("[hH]ofen?", "of", "off");
-    putRepl("[sS]ommerverien?", "[sS]ommerverie", "Sommerferien");
+    putRepl("[sS]ommerverien?", "[sS]ommerverien?", "Sommerferien");
     putRepl("[rR]ecourcen?", "[rR]ec", "Ress");
     putRepl("[fF]amm?ill?i?arisch(e[mnrs]?)?", "amm?ill?i?arisch", "amiliär");
     put("[tT]h?elepath?ie", "Telepathie");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -249,7 +249,7 @@ public class CaseRule extends Rule {
        // "Das Aus für Italien kam unerwartet."
        token("das"),
        csToken("Aus"),
-       posRegex("^PRP:.+")
+       posRegex("^PRP:.+|VER:[1-3]:.+")
      ),
      Arrays.asList(
        // "Bündnis 90/Die Grünen"

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -941,7 +941,7 @@ private int returnNParaCheck() {
   /**
    * Reset allParas
    */
-  private void ResetAllParas(LOCursor loCursor) {
+  private void ResetAllParas(LOCursor loCursor) throws Exception {
     allParas = loCursor.getAllTextParagraphs();
     textIsChecked = false;
   }
@@ -993,6 +993,7 @@ private int getStartOfParagraph(int nPara) {
    */
   private int findNextParaPos(int startPara, String paraStr) {
     if (allParas == null || allParas.size() < 1) return -1;
+    if (startPara >= allParas.size() || startPara < 0) startPara = 0;
     int i;
     for (i = startPara + 1; i < allParas.size() && allParas.get(i).length() < 1; i++);
     if (i < allParas.size() && paraStr.equals(allParas.get(i))) return i;

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/TokenAgreementPrepNounRule.java
Patch:
@@ -50,6 +50,7 @@
  * @author Andriy Rysin
  */
 public class TokenAgreementPrepNounRule extends Rule {
+  private static final Pattern NOUN_ANIM_V_NAZ_PATTERN = Pattern.compile("noun:anim.*:v_naz.*");
   private static final String NO_VIDMINOK_SUBSTR = ":nv";
   private static final String VIDMINOK_SUBSTR = ":v_";
   private static final Pattern VIDMINOK_REGEX = Pattern.compile(":(v_[a-z]+)");
@@ -492,11 +493,10 @@ private RuleMatch createRuleMatch(AnalyzedTokenReadings tokenReadings, AnalyzedT
     }
     else if( reqTokenReadings.getToken().equalsIgnoreCase("о") ) {
       for(AnalyzedToken token: tokenReadings.getReadings()) {
-        String posTag2 = token.getPOSTag();
-        if( posTag2.matches("noun:anim.*:v_naz.*") ) {
+        if( PosTagHelper.hasPosTag(token, NOUN_ANIM_V_NAZ_PATTERN) ) {
           msg += ". Можливо тут «о» — це вигук і потрібно кличний відмінок?";
           try {
-            String newPostag = posTag2.replace("v_naz", "v_kly");
+            String newPostag = token.getPOSTag().replace("v_naz", "v_kly");
             String[] synthesized = ukrainianSynthesizer.synthesize(token, newPostag, false);
             for (String string : synthesized) {
               if( ! string.equals(token.getToken()) && ! suggestions.contains(string) ) {

File: languagetool-language-modules/gl/src/main/java/org/languagetool/language/Galician.java
Patch:
@@ -176,7 +176,7 @@ public int getPriorityForId(String id) {
       // case "BIASED_OPINION_WORDS":      return -31;
       // case "WEAK_WORDS":                return -32;
       // case "PT_AGREEMENT_REPLACE":      return -35;
-      // case "GL_WIKIPEDIA_COMMON_ERRORS":   return -45; XXX Temporarily disabled to see regression results again. Re-enable afterwards.
+      case "GL_WIKIPEDIA_COMMON_ERRORS":return -45;
       case "HUNSPELL_RULE":             return -50;
       // case "NO_VERB":                   return -52;
       // case "CRASE_CONFUSION":           return -55;

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/PortugueseWordRepeatBeginningRuleTest.java
Patch:
@@ -38,7 +38,7 @@ public void testRule() throws IOException {
     // correct sentences:
     assertEquals(0, langTool.check("Este exemplo está correto. Este exemplo também está.").size());
     assertEquals(0, langTool.check("2011: Setembro já passou. 2011: Outubro também já passou. 2011: Novembro já se foi.").size());
-     assertEquals(1, langTool.check("Certo, isto está bem. Este exemplo está correto. Certo que este também.").size()); // 1 error from NO_VERB, 1 error from INCOMPLETE_SENTENCE.
+     assertEquals(0, langTool.check("Certo, isto está bem. Este exemplo está correto. Certo que este também.").size()); // 1 error from NO_VERB
     // errors:
     assertEquals(1, langTool.check("Este exemplo está correto. Este segundo também. Este terceiro exemplo não.").size()); //1 error from NO_VERB
     assertEquals(1, langTool.check("Então, este está correto. Então, este está errado, por causa da repetição.").size());

File: languagetool-language-modules/gl/src/main/java/org/languagetool/language/Galician.java
Patch:
@@ -176,7 +176,7 @@ public int getPriorityForId(String id) {
       // case "BIASED_OPINION_WORDS":      return -31;
       // case "WEAK_WORDS":                return -32;
       // case "PT_AGREEMENT_REPLACE":      return -35;
-      case "GL_WIKIPEDIA_COMMON_ERRORS":   return -45;
+      // case "GL_WIKIPEDIA_COMMON_ERRORS":   return -45; XXX Temporarily disabled to see regression results again. Re-enable afterwards.
       case "HUNSPELL_RULE":             return -50;
       // case "NO_VERB":                   return -52;
       // case "CRASE_CONFUSION":           return -55;

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -243,6 +243,7 @@ public void testDashAndHyphen() throws Exception {
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Bund-Länder-Kommission")).length);
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Des World Wide Webs")).length); // expanded multi-word entry from spelling.txt
     assertEquals(0, rule.match(lt.getAnalyzedSentence("Der westperuanische Ferienort.")).length);
+    assertEquals(0, rule.match(lt.getAnalyzedSentence("„Pumpe“-Nachfolge")).length);
 
     assertEquals(1, rule.match(lt.getAnalyzedSentence("Miet und Zinseinkünfte")).length);
     assertEquals(1, rule.match(lt.getAnalyzedSentence("Stil- und Grammatik gut")).length);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -115,6 +115,9 @@ public void testRule() throws IOException {
     assertGood("Das Aus für Italien ist bitter.");
     assertGood("Anmeldung bis Fr. 1.12.");
     assertGood("Weil er Unmündige sexuell missbraucht haben soll, wurde ein Lehrer verhaftet.");
+    assertGood("Tausende Gläubige kamen.");
+    assertGood("Es kamen Tausende Gläubige.");
+    assertGood("Das schließen Forscher aus den gefundenen Spuren.");
 
     assertBad("Sie Vertraute niemandem.");
     assertBad("Beten Lernt man in Nöten.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -1136,6 +1136,9 @@ private boolean isAdjectiveAsNoun(int i, AnalyzedTokenReadings[] tokens, Analyze
       if (!isPrecededByVerb && lowercaseReadings != null && prevToken != null) {
         if (prevToken.hasPartialPosTag("SUB:") && lowercaseReadings.matchesPosTagRegex("(ADJ|PA2):GEN:PLU:MAS:GRU:SOL.*")) {
           return nextReadings != null && !nextReadings.hasPartialPosTag("SUB:");
+        } else if (nextReadings.getReadingsLength() == 1 && prevToken.hasPosTagStartingWith("PRO:PER:NOM:") && nextReadings.hasPosTag("ADJ:PRD:GRU")) {
+          // avoid false alarm "Weil er Unmündige sexuell missbraucht haben soll,..."
+          return true;
         }
       }
       // Another check to avoid false alarms for "ein politischer Revolutionär"

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -114,6 +114,7 @@ public void testRule() throws IOException {
     assertGood("Bei Betreten des Hauses.");
     assertGood("Das Aus für Italien ist bitter.");
     assertGood("Anmeldung bis Fr. 1.12.");
+    assertGood("Weil er Unmündige sexuell missbraucht haben soll, wurde ein Lehrer verhaftet.");
 
     assertBad("Sie Vertraute niemandem.");
     assertBad("Beten Lernt man in Nöten.");

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/PortugueseWordRepeatBeginningRuleTest.java
Patch:
@@ -38,7 +38,7 @@ public void testRule() throws IOException {
     // correct sentences:
     assertEquals(0, langTool.check("Este exemplo está correto. Este exemplo também está.").size());
     assertEquals(0, langTool.check("2011: Setembro já passou. 2011: Outubro também já passou. 2011: Novembro já se foi.").size());
-     assertEquals(0, langTool.check("Certo, isto está bem. Este exemplo está correto. Certo que este também.").size()); // 1 error from NO_VERB
+     assertEquals(1, langTool.check("Certo, isto está bem. Este exemplo está correto. Certo que este também.").size()); // 1 error from NO_VERB, 1 error from INCOMPLETE_SENTENCE.
     // errors:
     assertEquals(1, langTool.check("Este exemplo está correto. Este segundo também. Este terceiro exemplo não.").size()); //1 error from NO_VERB
     assertEquals(1, langTool.check("Então, este está correto. Então, este está errado, por causa da repetição.").size());

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/LOCursor.java
Patch:
@@ -112,7 +112,7 @@ private static XTextViewCursor getViewCursor(XComponentContext xContext) throws
   }
 
  /** Returns Number of all Paragraphs of Document without footnotes etc.  */
-  public int getNumberOfAllTextParagraphs() {
+  public int getNumberOfAllTextParagraphs() throws Exception {
     if (xPCursor == null) return 0;
     xPCursor.gotoStart(false);
     int npara = 1;
@@ -121,7 +121,7 @@ public int getNumberOfAllTextParagraphs() {
   }
 
   /** Returns all Paragraphs of Document without footnotes etc.  */
-  public List<String> getAllTextParagraphs() {
+  public List<String> getAllTextParagraphs() throws Exception {
     List<String> allParas = new ArrayList<>();
     if (xPCursor == null) return allParas;
     xPCursor.gotoStart(false);
@@ -137,7 +137,7 @@ public List<String> getAllTextParagraphs() {
   }
 
   /** Returns Paragraph number under ViewCursor */
-  public int getViewCursorParagraph() {
+  public int getViewCursorParagraph() throws Exception {
     if(xVCursor == null) return -4;
     XText xDocumentText = xVCursor.getText();
     if(xDocumentText == null) return -3;

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -113,6 +113,7 @@ public void testRule() throws IOException {
     assertGood("Eine Gruppe Betrunkener singt.");
     assertGood("Bei Betreten des Hauses.");
     assertGood("Das Aus für Italien ist bitter.");
+    assertGood("Anmeldung bis Fr. 1.12.");
 
     assertBad("Sie Vertraute niemandem.");
     assertBad("Beten Lernt man in Nöten.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -1205,7 +1205,7 @@ boolean compareLists(AnalyzedTokenReadings[] tokens, int startIndex, int endInde
       if (i >= parts.length || j >= tokens.length) {
         return false;
       }
-      if (!tokens[j].getToken().equals(parts[i])) {
+      if (!tokens[j].getToken().matches(parts[i])) {
         return false;
       }
       i++;

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -146,6 +146,8 @@ public void testRule() throws IOException {
     assertGood("Schon Le Monde schrieb das.");
     // unknown word:
     assertGood("In Blubberdorf macht man das so.");
+    // Exception definied in case_rule_exceptions.txt:
+    assertGood("Der Thriller spielt zur Zeit des Zweiten Weltkriegs");
 
     assertGood("Anders als physikalische Konstanten werden mathematische Konstanten unabhängig von jedem physikalischen Maß definiert.");
     assertGood("Eine besonders einfache Klasse bilden die polylogarithmischen Konstanten.");

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -130,7 +130,7 @@ boolean isMisspelled(String word) {
     if (word.length() == 1) { // hunspell dictionaries usually do not contain punctuation
       isAlphabetic = Character.isAlphabetic(word.charAt(0));
     }
-    return (isAlphabetic && !word.equals("--") && hunspellDict.misspelled(word)) || isProhibited(removeTrailingDot(word));
+    return (isAlphabetic && !"--".equals(word) && hunspellDict.misspelled(word)) || isProhibited(removeTrailingDot(word));
   }
   
   void filterDupes(List<String> words) {
@@ -168,7 +168,7 @@ private String getSentenceTextWithoutUrlsAndImmunizedTokens(AnalyzedSentence sen
     AnalyzedTokenReadings[] sentenceTokens = getSentenceWithImmunization(sentence).getTokens();
     for (int i = 1; i < sentenceTokens.length; i++) {
       String token = sentenceTokens[i].getToken();
-      if (isUrl(token) || isEMail(token) || sentenceTokens[i].isImmunized() || sentenceTokens[i].isIgnoredBySpeller()) {
+      if (sentenceTokens[i].isImmunized() || isUrl(token) || isEMail(token) || sentenceTokens[i].isIgnoredBySpeller() || (token.length() == 2 && Character.isSurrogatePair(token.charAt(0), token.charAt(1)))) {
         // replace URLs and immunized tokens with whitespace to ignore them for spell checking:
         for (int j = 0; j < token.length(); j++) {
           sb.append(' ');

File: languagetool-core/src/main/java/org/languagetool/rules/WordRepeatRule.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.List;
 import java.util.ResourceBundle;
 
+import org.apache.commons.lang3.StringUtils;
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.AnalyzedTokenReadings;
 import org.languagetool.Language;
@@ -94,15 +95,13 @@ protected RuleMatch createRuleMatch(String prevToken, String token, int prevPos,
   // avoid "..." etc. to be matched:
   private boolean isWord(String token) {
     boolean isWord = true;
-    if (token.length() == 0) {
+    if (token.isEmpty() || StringUtils.isNumeric(token)) {
       isWord = false;
     } else if (token.length() == 1) {
       char c = token.charAt(0);
       if (!Character.isLetter(c)) {
         isWord = false;
       }
-    } else if (token.matches("0+")) {  // e.g. "1 000 000"
-      isWord = false;
     }
     return isWord;
   }

File: languagetool-language-modules/gl/src/main/java/org/languagetool/rules/gl/GalicianWikipediaRule.java
Patch:
@@ -33,8 +33,8 @@
 
 /**
  * A rule that matches common Wikipedia errors. 
- * Portuguese implementations. Loads the list of words from
- * <code>/pt/wikipedia.txt</code>.
+ * Galician implementations. Loads the list of words from
+ * <code>/gl/wikipedia.txt</code>.
  *
  * @author Tiago F. Santos 
  * @since 4.0

File: languagetool-language-modules/gl/src/main/java/org/languagetool/language/Galician.java
Patch:
@@ -176,7 +176,7 @@ public int getPriorityForId(String id) {
       // case "BIASED_OPINION_WORDS":      return -31;
       // case "WEAK_WORDS":                return -32;
       // case "PT_AGREEMENT_REPLACE":      return -35;
-      case "WIKIPEDIA_COMMON_ERRORS":   return -45;
+      case "GL_WIKIPEDIA_COMMON_ERRORS":   return -45;
       case "HUNSPELL_RULE":             return -50;
       // case "NO_VERB":                   return -52;
       // case "CRASE_CONFUSION":           return -55;

File: languagetool-language-modules/gl/src/main/java/org/languagetool/rules/gl/GalicianWikipediaRule.java
Patch:
@@ -41,7 +41,7 @@
  */
 public class GalicianWikipediaRule extends AbstractSimpleReplaceRule2 {
 
-  public static final String WIKIPEDIA_COMMON_ERRORS = "WIKIPEDIA_COMMON_ERRORS";
+  public static final String WIKIPEDIA_COMMON_ERRORS = "GL_WIKIPEDIA_COMMON_ERRORS";
 
   private static final String FILE_NAME = "/gl/wikipedia.txt";
   private static final Locale GL_LOCALE = new Locale("gl");// locale used on case-conversion

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -236,7 +236,7 @@ public int getPriorityForId(String id) {
       case "T-V_DISTINCTION_ALL":       return -101;
       case "REPEATED_WORDS":            return -210;
       case "REPEATED_WORDS_3X":         return -211;
-      case "WIKIPEDIA_COMMON_ERRORS":   return -500;
+      case "PT_WIKIPEDIA_COMMON_ERRORS":   return -500;
       case "TOO_LONG_SENTENCE_20":      return -997;
       case "TOO_LONG_SENTENCE_25":      return -998;
       case "TOO_LONG_SENTENCE_30":      return -999;

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseWikipediaRule.java
Patch:
@@ -41,7 +41,7 @@
  */
 public class PortugueseWikipediaRule extends AbstractSimpleReplaceRule2 {
 
-  public static final String WIKIPEDIA_COMMON_ERRORS = "WIKIPEDIA_COMMON_ERRORS";
+  public static final String WIKIPEDIA_COMMON_ERRORS = "PT_WIKIPEDIA_COMMON_ERRORS";
 
   private static final String FILE_NAME = "/pt/wikipedia.txt";
   private static final Locale PT_LOCALE = new Locale("pt");// locale used on case-conversion

File: languagetool-language-modules/gl/src/main/java/org/languagetool/language/Galician.java
Patch:
@@ -147,7 +147,8 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
             new CastWordsRule(messages),
             new GalicianRedundancyRule(messages),
             new GalicianWordinessRule(messages),
-            new GalicianBarbarismsRule(messages)
+            new GalicianBarbarismsRule(messages),
+            new GalicianWikipediaRule(messages)
     );
   }
 
@@ -175,6 +176,7 @@ public int getPriorityForId(String id) {
       // case "BIASED_OPINION_WORDS":      return -31;
       // case "WEAK_WORDS":                return -32;
       // case "PT_AGREEMENT_REPLACE":      return -35;
+      case "WIKIPEDIA_COMMON_ERRORS":   return -45;
       case "HUNSPELL_RULE":             return -50;
       // case "NO_VERB":                   return -52;
       // case "CRASE_CONFUSION":           return -55;
@@ -183,7 +185,6 @@ public int getPriorityForId(String id) {
       // case "T-V_DISTINCTION_ALL":       return -101;
       // case "REPEATED_WORDS":            return -210;
       // case "REPEATED_WORDS_3X":         return -211;
-      // case "WIKIPEDIA_COMMON_ERRORS":   return -500;
       case "TOO_LONG_SENTENCE_20":      return -997;
       case "TOO_LONG_SENTENCE_25":      return -998;
       case "TOO_LONG_SENTENCE_30":      return -999;

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -190,7 +190,8 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
         new CompoundRule(messages),
         new ContractionSpellingRule(messages),
         new EnglishWrongWordInContextRule(messages),
-        new EnglishDashRule()
+        new EnglishDashRule(),
+        new WordCoherencyRule(messages)
     );
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -64,7 +64,7 @@ public abstract class SpellingCheckRule extends Rule {
   private Map<String,Set<String>> wordsToBeIgnoredDictionaryIgnoreCase = new HashMap<>();
   private final Set<String> wordsToBeIgnored = new HashSet<>();
   private final Set<String> wordsToBeProhibited = new HashSet<>();
-  private final CachingWordListLoader wordListLoader = new CachingWordListLoader();
+  protected final CachingWordListLoader wordListLoader = new CachingWordListLoader();
   
   private List<DisambiguationPatternRule> antiPatterns = new ArrayList<>();
   private boolean considerIgnoreWords = true;

File: languagetool-server/src/main/java/org/languagetool/server/ApiV2.java
Patch:
@@ -51,7 +51,7 @@ class ApiV2 {
     this.allowOriginUrl = allowOriginUrl;
   }
 
-  void handleRequest(String path, HttpExchange httpExchange, Map<String, String> parameters) throws Exception {
+  void handleRequest(String path, HttpExchange httpExchange, Map<String, String> parameters, ErrorRequestLimiter errorRequestLimiter, String remoteAddress) throws Exception {
     if (path.equals("languages")) {
       String response = getLanguages();
       ServerTools.setCommonHeaders(httpExchange, JSON_CONTENT_TYPE, allowOriginUrl);
@@ -68,7 +68,7 @@ void handleRequest(String path, HttpExchange httpExchange, Map<String, String> p
       } else {
         throw new RuntimeException("Missing 'text' or 'data' parameter");
       }
-      textChecker.checkText(aText, httpExchange, parameters);
+      textChecker.checkText(aText, httpExchange, parameters, errorRequestLimiter, remoteAddress);
     } else if (path.equals("log")) {
       // used so the client (especially the browser add-ons) can report internal issues:
       String message = parameters.get("message");

File: languagetool-server/src/main/java/org/languagetool/server/HTTPSServer.java
Patch:
@@ -69,8 +69,9 @@ public HTTPSServer(HTTPSServerConfig config, boolean runInternally, String host,
       HttpsConfigurator configurator = getConfigurator(sslContext);
       ((HttpsServer)server).setHttpsConfigurator(configurator);
       RequestLimiter limiter = getRequestLimiterOrNull(config);
+      ErrorRequestLimiter errorLimiter = getErrorRequestLimiterOrNull(config);
       LinkedBlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>();
-      httpHandler = new LanguageToolHttpHandler(config, allowedIps, runInternally, limiter, workQueue);
+      httpHandler = new LanguageToolHttpHandler(config, allowedIps, runInternally, limiter, errorLimiter, workQueue);
       server.createContext("/", httpHandler);
       executorService = getExecutorService(workQueue, config);
       server.setExecutor(executorService);

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServer.java
Patch:
@@ -95,8 +95,9 @@ public HTTPServer(HTTPServerConfig config, boolean runInternally, String host, S
       InetSocketAddress address = host != null ? new InetSocketAddress(host, port) : new InetSocketAddress(port);
       server = HttpServer.create(address, 0);
       RequestLimiter limiter = getRequestLimiterOrNull(config);
+      ErrorRequestLimiter errorLimiter = getErrorRequestLimiterOrNull(config);
       LinkedBlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>();
-      httpHandler = new LanguageToolHttpHandler(config, allowedIps, runInternally, limiter, workQueue);
+      httpHandler = new LanguageToolHttpHandler(config, allowedIps, runInternally, limiter, errorLimiter, workQueue);
       server.createContext("/", httpHandler);
       executorService = getExecutorService(workQueue, config);
       server.setExecutor(executorService);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanWordRepeatRule.java
Patch:
@@ -78,7 +78,7 @@ public boolean ignore(AnalyzedTokenReadings[] tokens, int position) {
       return true;
     }
     // "Dann warfen sie sie weg."
-    if (tokens.length > position && position > 2 && tokens[position - 2].matchesPosTagRegex("VER:3:PLU:.+") && tokens[position - 1].getToken().equals("sie") &&
+    if (tokens.length+1 > position && position > 2 && tokens[position - 2].matchesPosTagRegex("VER:3:PLU:.+") && tokens[position - 1].getToken().equals("sie") &&
       tokens[position].getToken().equals("sie") && (tokens[position + 1].hasPosTag("ZUS"))) {
       return true;
     }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -112,6 +112,7 @@ public void testRule() throws IOException {
     assertGood("Bei einer Veranstaltung Rechtsextremer passierte es.");
     assertGood("Eine Gruppe Betrunkener singt.");
     assertGood("Bei Betreten des Hauses.");
+    assertGood("Das Aus für Italien ist bitter.");
 
     assertBad("Sie Vertraute niemandem.");
     assertBad("Beten Lernt man in Nöten.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanWordRepeatRuleTest.java
Patch:
@@ -42,6 +42,7 @@ public void testRule() throws IOException {
     assertThat(rule.match(lt.getAnalyzedSentence("Warum fragen Sie sie nicht selbst?")).length, is(0));
     assertThat(rule.match(lt.getAnalyzedSentence("Er will nur sein Leben leben.")).length, is(0));
     assertThat(rule.match(lt.getAnalyzedSentence("Wie bei Honda, die die Bezahlung erhöht haben.")).length, is(0));
+    assertThat(rule.match(lt.getAnalyzedSentence("Dann warfen sie sie weg.")).length, is(0));
   }
 
 }
\ No newline at end of file

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -194,6 +194,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Karl sagte, dass sie niemandem Bescheid gegeben habe.");
 
     // incorrect sentences:
+    assertBad("Meiner Chef raucht.");
     assertBad("Er hat eine 34-jährigen Sohn.");
     assertBad("Es sind die Tisch.", "dem Tisch", "den Tisch", "der Tisch", "die Tische");
     assertBad("Es sind das Tisch.", "dem Tisch", "den Tisch", "der Tisch");

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -145,6 +145,7 @@ private void logError(String remoteAddress, Exception e, int errorCode, HttpExch
     String message = "An error has occurred: '" +  e.getMessage() + "', sending HTTP code " + errorCode + ". ";
     message += "Access from " + remoteAddress + ", ";
     message += "HTTP user agent: " + getHttpUserAgent(httpExchange) + ", ";
+    message += "User agent param: " + params.get("useragent") + ", ";
     message += "Referrer: " + getHttpReferrer(httpExchange) + ", ";
     message += "language: " + params.get("language") + ", ";
     String text = params.get("text");
@@ -161,10 +162,12 @@ private void logError(String remoteAddress, Exception e, int errorCode, HttpExch
     }
   }
 
+  @Nullable
   private String getHttpUserAgent(HttpExchange httpExchange) {
     return httpExchange.getRequestHeaders().getFirst("User-Agent");
   }
 
+  @Nullable
   private String getHttpReferrer(HttpExchange httpExchange) {
     return httpExchange.getRequestHeaders().getFirst("Referer");
   }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -191,6 +191,7 @@ public void testDetNounRule() throws IOException {
     //assertGood("Zum Teil sind das Krebsvorstufen.");
     assertGood("Er sagt, dass das Rache bedeutet.");
     assertGood("Wenn das Kühe sind, bin ich ein Elefant.");
+    assertGood("Karl sagte, dass sie niemandem Bescheid gegeben habe.");
 
     // incorrect sentences:
     assertBad("Er hat eine 34-jährigen Sohn.");

File: languagetool-language-modules/gl/src/main/java/org/languagetool/language/Galician.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.ResourceBundle;
 
 import org.languagetool.Language;
+import org.languagetool.LanguageMaintainedState;
 import org.languagetool.rules.*;
 import org.languagetool.rules.gl.*;
 import org.languagetool.rules.spelling.hunspell.HunspellRule;

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanWordRepeatRule.java
Patch:
@@ -73,10 +73,10 @@ public boolean ignore(AnalyzedTokenReadings[] tokens, int position) {
       return true;
     }
     // "Sie tut das, damit sie sie nicht fortschickt"
-    /*if (position > 2 && tokens[position - 2].hasPosTag("KON:UNT") && tokens[position - 1].getToken().equals("sie") &&
+    if (position > 2 && tokens[position - 2].hasPosTag("KON:UNT") && tokens[position - 1].getToken().equals("sie") &&
         tokens[position].getToken().equals("sie")) {
       return true;
-    }*/
+    }
     return false;
   }
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/WordRepeatRuleTest.java
Patch:
@@ -41,7 +41,7 @@ public void testRuleGerman() throws IOException {
     assertGood("Sätze, die die testen.", lt);
     assertGood("Das Haus, auf das das Mädchen zeigt.", lt);
     assertGood("Warum fragen Sie sie nicht selbst?", lt);
-    //assertGood("Er tut das, damit sie sie nicht sieht.", lt);
+    assertGood("Er tut das, damit sie sie nicht sieht.", lt);
 
     assertBad("Die die Sätze zum testen.", lt);
     assertBad("Und die die Sätze zum testen.", lt);

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -119,7 +119,7 @@ public void handle(HttpExchange httpExchange) throws IOException {
       if (e instanceof TextTooLongException) {
         errorCode = HttpURLConnection.HTTP_ENTITY_TOO_LARGE;
         response = e.getMessage();
-      } else if (e instanceof AuthException) {
+      } else if (e instanceof AuthException ||  e.getCause() != null && e.getCause() instanceof AuthException) {
         errorCode = HttpURLConnection.HTTP_FORBIDDEN;
         response = e.getMessage();
       } else if (e instanceof IllegalArgumentException) {

File: languagetool-core/src/main/java/org/languagetool/rules/EmptyLineRule.java
Patch:
@@ -67,7 +67,7 @@ public org.languagetool.rules.RuleMatch[] match(AnalyzedSentence sentence) throw
     for(int i = 2; i < tokens.length; i++) {
       if(tokens[i].isLinebreak() && !tokens[i - 1].isLinebreak()) {
         int firstLB = i;
-        for (i++; i < tokens.length && tokens[i].isWhitespace() && !tokens[i].isLinebreak(); i++);  
+        for (i++; i < tokens.length && tokens[i].isWhitespace() && !tokens[i].isLinebreak() && !tokens[i].getToken().equals("\u200B"); i++);  
         if (i == tokens.length || tokens[i].isLinebreak()) { 
           int fromPos = tokens[firstLB - 1].getStartPos();
           int toPos = tokens[firstLB - 1].getEndPos();

File: languagetool-language-modules/gl/src/main/java/org/languagetool/tagging/gl/GalicianTagger.java
Patch:
@@ -56,7 +56,7 @@ public String getManualAdditionsFileName() {
 
   @Override
   public String getManualRemovalsFileName() {
-    return "/pt/removed.txt";
+    return "/gl/removed.txt";
   }
 
   public GalicianTagger() {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -188,6 +188,8 @@ public void testDetNounRule() throws IOException {
     assertGood("Stell dich dem Leben lächelnd!");
     assertGood("Die Messe wird auf das vor der Stadt liegende Ausstellungsgelände verlegt.");
     assertGood("Sie sind ein den Frieden liebendes Volk.");
+    //assertGood("Zum Teil sind das Krebsvorstufen.");
+    assertGood("Er sagt, dass das Rache bedeutet.");
 
     // incorrect sentences:
     assertBad("Er hat eine 34-jährigen Sohn.");

File: languagetool-core/src/main/java/org/languagetool/rules/EmptyLineRule.java
Patch:
@@ -41,6 +41,7 @@ public EmptyLineRule(ResourceBundle messages, boolean defaultActive) {
     if (!defaultActive) {
         setDefaultOff();   //  Default is Off
     }
+    setOfficeDefaultOn();  // Default for LO/OO is always On
       
     setLocQualityIssueType(ITSIssueType.Style);
   }

File: languagetool-core/src/main/java/org/languagetool/rules/WhiteSpaceBeforeParagraphEnd.java
Patch:
@@ -41,6 +41,7 @@ public WhiteSpaceBeforeParagraphEnd(ResourceBundle messages, boolean defaultActi
     if (!defaultActive) {
         setDefaultOff();   //  Default is Off
     }
+    setOfficeDefaultOn();  // Default for LO/OO is always On
     
     setLocQualityIssueType(ITSIssueType.Style);
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -181,6 +181,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
             new SimilarNameRule(messages),
             new WiederVsWiderRule(messages),
             new WhiteSpaceBeforeParagraphEnd(messages),
+            new WhiteSpaceAtBeginOfParagraph(messages),
             new EmptyLineRule(messages),
             new LongSentenceRule(messages, 20, false),
             new LongSentenceRule(messages, 30, false),

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -388,7 +388,7 @@ private void initLanguageTool() {
           langTool.activateLanguageModelRules(ngramDirectory);
         }
       }
-      for (Rule rule : langTool.getAllActiveRules()) {
+      for (Rule rule : langTool.getAllActiveOfficeRules()) {
         if (rule.isDictionaryBasedSpellingRule()) {
           langTool.disableRule(rule.getId());
         }

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -182,7 +182,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
             new WiederVsWiderRule(messages),
             new LongSentenceRule(messages, 20, false),
             new LongSentenceRule(messages, 30, false),
-            new LongSentenceRule(messages, 40, false),
+            new LongSentenceRule(messages, 40, true),
             new LongSentenceRule(messages, 50, false)
     );
   }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -438,7 +438,7 @@ public void testGetSuggestionOrder() throws Exception {
     assertCorrectionsByOrder(rule, "Fänomen", "Phänomen");
     assertCorrectionsByOrder(rule, "homofob", "homophob");
     assertCorrectionsByOrder(rule, "ueber", "über");
-    assertCorrectionsByOrder(rule, "uebel", "übel");
+    //assertCorrectionsByOrder(rule, "uebel", "übel");
     assertCorrectionsByOrder(rule, "Aerger", "Ärger");
     assertCorrectionsByOrder(rule, "Walt", "Wald");
     assertCorrectionsByOrder(rule, "Rythmus", "Rhythmus");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -587,8 +587,8 @@ private List<String> getCategoriesCausingError(AnalyzedTokenReadings token1, Ana
 
   private RuleMatch checkDetAdjNounAgreement(AnalyzedTokenReadings token1,
       AnalyzedTokenReadings token2, AnalyzedTokenReadings token3) {
-	// TODO: remove (token3 == null || token3.getToken().length() < 2) 
-	// see Daniel's comment from 20.12.2016 at https://github.com/languagetool-org/languagetool/issues/635
+    // TODO: remove (token3 == null || token3.getToken().length() < 2) 
+    // see Daniel's comment from 20.12.2016 at https://github.com/languagetool-org/languagetool/issues/635
     if(token3 == null || token3.getToken().length() < 2) {
       return null;
     }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -183,6 +183,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Er hat einen 34-jährigen Sohn.");
     assertGood("Die Polizei erwischte die Diebin, weil diese Ausweis und Visitenkarte hinterließ.");
     assertGood("Dieses Versäumnis soll vertuscht worden sein - es wurde Anzeige erstattet.");
+    assertGood("Die Firmen - nicht nur die ausländischen, auch die katalanischen - treibt diese Frage um.");
     // TODO: assertGood("Der Obst und Getränke führende Fachmarkt.");
     assertGood("Stell dich dem Leben lächelnd!");
     assertGood("Die Messe wird auf das vor der Stadt liegende Ausstellungsgelände verlegt.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -215,7 +215,7 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) {
       }
       partialSentence = new AnalyzedSentence(Arrays.copyOfRange(tokens, idx, tokens.length));
       ruleMatches.addAll(match(partialSentence, pos));
-      pos += partialSentence.getText().length();
+      pos += sentence.getText().length();
     }
     return toRuleMatchArray(ruleMatches);
   }

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerTest.java
Patch:
@@ -61,7 +61,7 @@ void runTestsV2() throws IOException, SAXException, ParserConfigurationException
     German german = new German();
     String result1 = checkV2(german, "");
     assertTrue("Got " + result1 + ", expected " + emptyResultPattern, result1.matches(emptyResultPattern));
-    String result2 = checkV2(german, "Ein kleiner test");
+    String result2 = checkV2(german, "Ein kleiner Test");
     assertTrue("Got " + result2 + ", expected " + emptyResultPattern, result2.matches(emptyResultPattern));
     // one error:
     assertTrue(checkV2(german, "ein kleiner test.").contains("UPPERCASE_SENTENCE_START"));

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -182,7 +182,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
             new WiederVsWiderRule(messages),
             new LongSentenceRule(messages, 20, false),
             new LongSentenceRule(messages, 30, false),
-            new LongSentenceRule(messages, 40, true),
+            new LongSentenceRule(messages, 40, false),
             new LongSentenceRule(messages, 50, false)
     );
   }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -453,8 +453,8 @@ private synchronized SingleProofreadingError[] checkParaRules(
       for (RuleMatch myRuleMatch : paragraphMatches) {
         int startErrPos = myRuleMatch.getFromPos();
         int endErrPos = myRuleMatch.getToPos();
-        if (startErrPos >= startPos && startErrPos < endPos
-            && endErrPos >= startPos && endErrPos < endPos) {
+        if (startErrPos >= startPos && startErrPos <= endPos
+            && endErrPos >= startPos && endErrPos <= endPos) {
           errorList.add(createOOoError(myRuleMatch, 0, myRuleMatch.getToPos(), 
         		                            paraText.charAt(myRuleMatch.getToPos()-1)));
         }

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -182,7 +182,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
             new WiederVsWiderRule(messages),
             new LongSentenceRule(messages, 20, false),
             new LongSentenceRule(messages, 30, false),
-            new LongSentenceRule(messages, 40, false),
+            new LongSentenceRule(messages, 40, true),
             new LongSentenceRule(messages, 50, false)
     );
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -111,7 +111,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     putRepl("([eE]r|[bB]e|unter)?hälst", "hälst", "hältst");
     put("[wW]ohlfühlseins?", w -> Arrays.asList("Wellness", w.replaceFirst("[wW]ohlfühlsein", "Wohlbefinden"), w.replaceFirst("[wW]ohlfühlsein", "Wohlfühlen")));
     putRepl("[sS]chmett?e?rling(s|en?)?", "[sS]chmett?e?rling", "Schmetterling");
-    putRepl("^[eE]inlamie?nie?r(st|en?|(t(e(nmrs)?)?))?", "^einlamie?nie?r", "laminier");
+    putRepl("^[eE]inlamie?nie?r(st|en?|(t(e[nmrs]?)?))?", "^einlamie?nie?r", "laminier");
     putRepl("bravuröse?[nrms]?", "bravur", "bravour");
     putRepl("[aA]ss?ecoires?", "[aA]ss?ecoire", "Accessoire");
     put("zucc?h?inis?", "Zucchini");

File: languagetool-language-modules/nl/src/test/java/org/languagetool/synthesis/nl/DutchSynthesizerTest.java
Patch:
@@ -40,7 +40,7 @@ public final void testSynthesizeStringString() throws IOException {
     assertEquals("[hebt, heeft]", Arrays.toString(synth.synthesize(dummyToken("hebben"), "WKW:TGW:3EP", true)));
     //with regular expressions
     assertEquals("[doorgeseind]", Arrays.toString(synth.synthesize(dummyToken("doorseinen"), "WKW:VTD:ONV", true)));    
-    assertEquals("[doorseine, doorseinenden, doorseinend, doorseinende, doorseint, doorsein, doorseinen, doorseinde, doorseinden, doorgeseind, doorgeseinde, doorgeseinden]", Arrays.toString(synth.synthesize(dummyToken("doorseinen"), "WKW.*", true)));
+    assertEquals("[doorseine, doorseinenden, doorseinend, doorseinende, doorsein, doorseint, doorseinen, doorseinde, doorseinden, doorgeseind, doorgeseinde, doorgeseinden]", Arrays.toString(synth.synthesize(dummyToken("doorseinen"), "WKW.*", true)));
   }
 
   private AnalyzedToken dummyToken(String tokenStr) {

File: languagetool-core/src/main/java/org/languagetool/rules/LongSentenceRule.java
Patch:
@@ -91,7 +91,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
     AnalyzedTokenReadings[] tokens = sentence.getTokensWithoutWhitespace();
     String msg = getMessage();
     int numWords = 0;
-    int pos = sentence.getText().length();   //  marks the whole sentence
+    int pos = sentence.getText().length() - 1;   //  marks the whole sentence
     if (tokens.length < maxWords + 1) {   // just a short-circuit
       return toRuleMatchArray(ruleMatches);
     } else {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -108,6 +108,7 @@ public class GermanSpellerRule extends CompoundAwareHunspellRule {
     ADDITIONAL_SUGGESTIONS.put(Pattern.compile("[uU]nnützlich(e[nmrs]?)?"), (String w) -> Collections.singletonList(w.replaceFirst("nützlich", "nütz")));
     ADDITIONAL_SUGGESTIONS.put(Pattern.compile("([eE]r|[bB]e|unter)?hälst"), (String w) -> Collections.singletonList(w.replaceFirst("hälst", "hältst")));
     ADDITIONAL_SUGGESTIONS.put(Pattern.compile("[wW]ohlfühlseins?"), (String w) -> Arrays.asList("Wellness", w.replaceFirst("[wW]ohlfühlsein", "Wohlbefinden"), w.replaceFirst("[wW]ohlfühlsein", "Wohlfühlen")));
+    ADDITIONAL_SUGGESTIONS.put(Pattern.compile("[sS]chmett?e?rling(s|en?)?"), (String w) -> Collections.singletonList(w.replaceFirst("[sS]chmett?e?rling", "Schmetterling")));
     ADDITIONAL_SUGGESTIONS.put(Pattern.compile("zucc?h?inis?"), (String w) -> Collections.singletonList("Zucchini"));
     ADDITIONAL_SUGGESTIONS.put(Pattern.compile("[mM]itag"), (String w) -> Collections.singletonList("Mittag"));
   }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -149,6 +149,7 @@ public void testGetAdditionalTopSuggestions() throws Exception {
     assertFirstSuggestion("erhälst", "erhältst", rule, lt);
     assertFirstSuggestion("Verstehendnis", "Verständnis", rule, lt);
     assertFirstSuggestion("Wohlfühlsein", "Wellness", rule, lt);
+    assertFirstSuggestion("schmetrlinge", "Schmetterlinge", rule, lt);
   }
 
   @Test

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/BrazilianPortuguese.java
Patch:
@@ -41,7 +41,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
     rules.addAll(super.getRelevantRules(messages));
     rules.add(new PostReformPortugueseCompoundRule(messages));
     rules.add(new BrazilianPortugueseReplaceRule(messages));
-    // rules.add(new PostReformPortugueseDashRule(messages));
+    rules.add(new PostReformPortugueseDashRule(messages));
     return rules;
   }
 

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/PortugalPortuguese.java
Patch:
@@ -46,7 +46,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
     List<Rule> rules = new ArrayList<>();
     rules.addAll(super.getRelevantRules(messages));
     rules.add(new PostReformPortugueseCompoundRule(messages));
-    rules.add(new PostReformPortugueseDashRule());
+    // rules.add(new PostReformPortugueseDashRule());
     rules.add(new PortugalPortugueseReplaceRule(messages));
     rules.add(new PortugueseAgreementReplaceRule(messages));
     return rules;

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PostReformPortugueseDashRule.java
Patch:
@@ -42,7 +42,8 @@ public PostReformPortugueseDashRule() throws IOException {
     super(dashRules);
     // super.setCategory(Categories.TYPOGRAPHY.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Typographical);
-    setDefaultOff(); // Slows down start up and checking time too much. See: http://forum.languagetool.org/t/checking-portuguese-slow/1669/10
+    // setDefaultOff(); // XXX Tempoary activation to see if performance issue is solved. Checked only on pt-BR.
+                        //     Slows down start up and checking time too much. See: http://forum.languagetool.org/t/checking-portuguese-slow/1669/10
   }
 
   @Override

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Configuration.java
Patch:
@@ -99,8 +99,8 @@ public Configuration(File baseDir, Language lang) throws IOException {
   }
 
   public Configuration(File baseDir, String filename, Language lang) throws IOException {
-    if (!baseDir.isDirectory()) {
-      throw new IllegalArgumentException("Not a directory: " + baseDir);
+    if (baseDir == null || !baseDir.isDirectory()) {
+      throw new IllegalArgumentException("Cannot open file " + filename + " in directory " + baseDir);
     }
     configFile = new File(baseDir, filename);
     loadConfiguration(lang);

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -303,8 +303,8 @@ private void configureFromRulesFile(JLanguageTool langTool, Language lang) throw
     print("Using options configured in " + config.getRulesConfigFile());
     // If we are explicitly configuring from rules, ignore the useGUIConfig flag
     if (config.getRulesConfigFile() != null) {
-      org.languagetool.gui.Tools.configureFromRules(langTool, new Configuration(config.getRulesConfigFile().getParentFile(),
-              config.getRulesConfigFile().getName(), lang));
+      org.languagetool.gui.Tools.configureFromRules(langTool, new Configuration(config.getRulesConfigFile()
+          .getCanonicalFile().getParentFile(), config.getRulesConfigFile().getName(), lang));
     } else {
       throw new RuntimeException("config.getRulesConfigFile() is null");
     }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CompoundRuleTest.java
Patch:
@@ -65,7 +65,6 @@ public void testRule() throws IOException {
     check(1, "Start Ziel Sieg");
     check(1, "Start Ziel Sieg!");
     check(1, "Doppler Effekt");
-    check(1, "Doppler effekt");
     check(2, "Der dumme System Administrator legt die CD ROM");
     check(2, "Der dumme System Administrator legt die CD ROM.");
     check(2, "Der dumme System Administrator legt die CD ROM ein blah");

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternTestTools.java
Patch:
@@ -40,11 +40,11 @@ public final class PatternTestTools {
   // These characters should not be present in token values as they split tokens in all languages.
   private static final Pattern TOKEN_SEPARATOR_PATTERN = Pattern.compile("[ 	.,:;…!?(){}<>«»\"]");
 
-  private static final Pattern PROBABLE_PATTERN = Pattern.compile(".*([^*]\\*|[.+?{}()|\\[\\]].*|\\\\d).*");
+  private static final Pattern PROBABLE_PATTERN = Pattern.compile("(\\\\[dDsSwW])|.*([^*]\\*|[.+?{}()|\\[\\]].*|\\\\d).*");
 
   // Polish POS tags use dots, so do not consider the presence of a dot
   // as indicating a probable regular expression.
-  private static final Pattern PROBABLE_PATTERN_PL_POS = Pattern.compile(".*([^*]\\*|[+?{}()|\\[\\]].*|\\\\d).*");
+  private static final Pattern PROBABLE_PATTERN_PL_POS = Pattern.compile("(\\\\[dDsSwW])|.*([^*]\\*|[+?{}()|\\[\\]].*|\\\\d).*");
 
   private static final Pattern CHAR_SET_PATTERN = Pattern.compile("\\[^?([^\\]]+)\\]");
   private static final Pattern STRICT_CHAR_SET_PATTERN = Pattern.compile("(\\(\\?-i\\))?.*(?<!\\\\)\\[^?([^\\]]+)\\]");

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -241,7 +241,7 @@ private String readerToString(Reader reader, int maxTextLength) throws IOExcepti
       if (readBytes <= 0) {
         break;
       }
-      int generousMaxLength = maxTextLength * 3 + 1000;  // once character can be encoded as e.g. "%D8" plus space for other parameters
+      int generousMaxLength = maxTextLength * 3 + 1000;  // one character can be encoded as e.g. "%D8", plus space for other parameters
       if (generousMaxLength < 0) {  // might happen as it can overflow
         generousMaxLength = Integer.MAX_VALUE;
       }

File: languagetool-core/src/main/java/org/languagetool/rules/MultipleWhitespaceRule.java
Patch:
@@ -71,12 +71,13 @@ public RuleMatch[] match(AnalyzedSentence sentence) {
           StringTools.isNonBreakingWhitespace(tokens[i].getToken())) && prevWhite && !tokenIsTab && !prevTokenIsLinebreak && !isLineBreakContinuation) {
         int pos = tokens[i -1].getStartPos();
         while (i < tokens.length && (tokens[i].isWhitespace() ||
-            StringTools.isNonBreakingWhitespace(tokens[i].getToken()))) {
+            StringTools.isNonBreakingWhitespace(tokens[i].getToken())) 
+        		&& !tokens[i].isLinebreak()) {    // preserve LF because LO/OO can't handle grammar errors including LF
           prevLen += tokens[i].getToken().length();
           i++;
         }
         String message = messages.getString("whitespace_repetition");
-        if (prevLen > 0) {
+        if (prevLen > 1) {
           if (prevPos >= 2 && sentence.getText().substring(prevPos-2, pos + prevLen).equals("-- \n")) {
             // no match for typical email signature delimiter
             continue;

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -308,8 +308,10 @@ protected List<String> getAdditionalTopSuggestions(List<String> suggestions, Str
       return Collections.singletonList(suggestion);
     } else if (word.matches("[wW]ikich(e[nmrs]?)?")) {
       suggestion = word.replaceFirst("k", "rkl");
+      return Collections.singletonList(suggestion);
     } else if (word.matches("[kK]ongratulier(en?|t(en?)?|st)")) {
       suggestion = word.replaceFirst("[kK]on", "");
+      return Collections.singletonList(suggestion);
     } else if (word.matches("[kKdD]an$")) {
       suggestion = word.replaceFirst("n$", "nn");
       return Collections.singletonList(suggestion);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -134,6 +134,7 @@ public void testGetAdditionalTopSuggestions() throws Exception {
     assertFirstSuggestion("Allmähllig", "Allmählich", rule, lt);
     assertFirstSuggestion("Probiren", "Probieren", rule, lt);
     assertFirstSuggestion("gesetztreu", "gesetzestreu", rule, lt);
+    assertFirstSuggestion("wikiche", "wirkliche", rule, lt);
     assertFirstSuggestion("kongratulierst", "gratulierst", rule, lt);
   }
 

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -440,7 +440,7 @@ private synchronized SingleProofreadingError[] checkParaRules(
       int endPos, String docID) {
     if (startPos == 0) {
       try {
-        paragraphMatches = langTool.check(paraText, false,
+        paragraphMatches = langTool.check(paraText, true,
             JLanguageTool.ParagraphHandling.ONLYPARA);
         this.docID = docID;
       } catch (Throwable t) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SubjectVerbAgreementRuleTest.java
Patch:
@@ -298,7 +298,8 @@ public void testRuleWithCorrectSingularVerb() throws IOException {
         "Der Abzug der Besatzungssoldaten und deren mittlerweile ansässigen Angehörigen der Besatzungsmächte war vereinbart.",
         "Das Bündnis zwischen der Sowjetunion und Kuba war für beide vorteilhaft.",
         "Knapp acht Monate ist die Niederlage nun her.",
-        "Vier Monate ist die Niederlage nun her."
+        "Vier Monate ist die Niederlage nun her.",
+        "Sie liebt Kunst und Kunst war auch kein Problem, denn er würde das Geld zurückkriegen."
     );
     for (String sentence : sentences) {
       assertGood(sentence);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -214,7 +214,7 @@ public RuleMatch[] match(List<AnalyzedSentence> sentences) {
         }
       }
       partialSentence = new AnalyzedSentence(Arrays.copyOfRange(tokens, idx, tokens.length));
-      ruleMatches.addAll(match(partialSentence, 0));
+      ruleMatches.addAll(match(partialSentence, pos));
       pos += partialSentence.getText().length();
     }
     return toRuleMatchArray(ruleMatches);

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseWeaselWordsRule.java
Patch:
@@ -32,8 +32,8 @@
 import java.net.URL;
 
 /**
- * A rule that matches known empty expresions. 
- * Portuguese implementations. Loads the list of words from
+ * A rule that matches known empty expressions. 
+ * Portuguese implementation. Loads the list of words from
  * <code>/pt/weaselwords.txt</code>.
  *
  * @author Tiago F. Santos 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -245,7 +245,7 @@ public class CaseRule extends Rule {
         posRegex("SUB:.*:ADJ")
      ),
      Arrays.asList(
-        // "Vor Betreten des" / "Trotz Verboten seine"
+        // "Vor Betreten des" / "Trotz Verboten seiner Eltern"
         posRegex("PRP:.*|ADV:MOD"),
         pos("VER:PA2:NON"),
         posRegex("(ART|PRO):(IND|DE[FM]|POS):GEN:.*")

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/SubjectVerbAgreementRule.java
Patch:
@@ -188,6 +188,7 @@ private RuleMatch getPluralMatchOrNull(AnalyzedTokenReadings[] tokens, int i, An
                       && prevChunkIsNominative(tokens, i-1)
                       && !hasUnknownTokenToTheLeft(tokens, i)
                       && !hasUnknownTokenToTheRight(tokens, i+1)
+                      && !tokens[1].getToken().matches("Alle|Viele") // "Viele Brunnen in Italiens Hauptstadt sind bereits abgeschaltet."
                       && !isFollowedByNominativePlural(tokens, i+1);  // z.B. "Die Zielgruppe sind Männer." - beides Nominativ, aber 'Männer' ist das Subjekt
       if (match) {
         String message = "Bitte prüfen, ob hier <suggestion>" + getSingularFor(tokenStr) + "</suggestion> stehen sollte.";

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -82,6 +82,7 @@ public void testWrongVerb() throws IOException {
     assertGood("Das sind Leute, die viel mehr als ich wissen.");
     assertGood("Das ist mir nicht klar, kannst ja mal beim Kunden nachfragen.");
     assertGood("So tes\u00ADtest Du das mit dem soft hyphen.");
+    assertGood("Viele Brunnen in Italiens Hauptstadt sind bereits abgeschaltet.");
     // incorrect sentences:
     assertBad("Als Borcarbid weißt es eine hohe Härte auf.");
     assertBad("Das greift auf Vorläuferinstitutionen bist auf die Zeit von 1234 zurück.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -284,7 +284,7 @@ private static PatternToken posRegex(String posTag) {
   }
 
   private static final Set<String> UNDEFINED_QUANTIFIERS = new HashSet<>(Arrays.asList(
-      "viel", "nichts", "wenig", "zuviel"));
+      "viel", "nichts", "wenig"));
 
   private static final Set<String> INTERROGATIVE_PARTICLES = new HashSet<>(Arrays.asList(
       "was", "wodurch", "wofür", "womit", "woran", "worauf", "woraus", "wovon", "wie"));

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -109,6 +109,8 @@ public void testRule() throws IOException {
     assertGood("Vor dem Aus stehen.");
     assertGood("Ich Armer!");
     assertGood("Parks Vertraute Choi Soon Sil ist zu drei Jahren Haft verurteilt worden.");
+    assertGood("Bei einer Veranstaltung Rechtsextremer passierte es.");
+    assertGood("Eine Gruppe Betrunkener singt.");
 
     assertBad("Sie Vertraute niemandem.");
     assertBad("Beten Lernt man in Nöten.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -63,7 +63,6 @@ public GermanSpellerRule(ResourceBundle messages, German language) {
     } catch (IOException e) {
       throw new RuntimeException(e);
     }
-    setConvertsCase(true);
   }
 
   @Override

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -195,8 +195,8 @@ public void testIgnoreWord() throws Exception {
     assertFalse(ruleGermany.doIgnoreWord("wichtelmännchens"));          // from spelling.txt with suffix, no reason to accept it as lowercase
     assertTrue(ruleGermany.doIgnoreWord("vorgehängt"));                 // from spelling.txt
     assertTrue(ruleGermany.doIgnoreWord("vorgehängten"));               // from spelling.txt with suffix
-    assertTrue(ruleGermany.doIgnoreWord("Vorgehängt"));                 // from spelling.txt, it's lowercase there but we accept uppercase
-    assertTrue(ruleGermany.doIgnoreWord("Vorgehängten"));               // from spelling.txt with suffix, it's lowercase there but we accept uppercase
+    assertTrue(ruleGermany.doIgnoreWord("Vorgehängt"));                 // from spelling.txt, it's lowercase there but we accept uppercase at idx = 0
+    assertTrue(ruleGermany.doIgnoreWord("Vorgehängten"));               // from spelling.txt with suffix, it's lowercase there but we accept uppercase at idx = 0
     assertTrue(ruleGermany.doIgnoreWord("Wichtelmännchen-vorgehängt")); // from spelling.txt formed hyphenated compound
     assertTrue(ruleGermany.doIgnoreWord("Wichtelmännchen-Au-pair"));    // from spelling.txt formed hyphenated compound
     assertTrue(ruleGermany.doIgnoreWord("Fermi-Dirac-Statistik"));      // from spelling.txt formed hyphenated compound

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -126,7 +126,7 @@ public void handle(HttpExchange httpExchange) throws IOException {
         response = "Checking took longer than " + config.getMaxCheckTimeMillis()/1000 + " seconds, which is this server's limit. " +
                    "Please make sure you have selected the proper language or consider submitting a shorter text.";
       } else {
-        response = "Internal Error. Please contact the site administrator.";
+        response = "Internal Error: " + e.getMessage();
         errorCode = HttpURLConnection.HTTP_INTERNAL_ERROR;
       }
       logError(remoteAddress, e, errorCode, httpExchange, parameters);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -280,7 +280,7 @@ public void testGetSuggestions() throws Exception {
     HunspellRule rule = new GermanSpellerRule(TestTools.getMessages("de"), GERMAN_DE);
 
     assertCorrection(rule, "Hauk", "Haus", "Haut");
-    assertCorrection(rule, "Eisnbahn", "Einbahn", "Eisbahn", "Eisenbahn"); 
+    assertCorrection(rule, "Eisnbahn", "Eisbahn", "Eisenbahn"); 
     assertCorrection(rule, "Rechtschreipreform", "Rechtschreibreform");
     assertCorrection(rule, "Theatrekasse", "Theaterkasse");
     assertCorrection(rule, "Traprennen", "Trabrennen");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -166,8 +166,8 @@ protected void filterForLanguage(List<String> suggestions) {
         suggestions.set(i, s.replace("ß", "ss"));
       }
     }
-    // Remove suggestions like "Mafiosi s":
-    suggestions.removeIf(s -> Arrays.stream(s.split(" ")).anyMatch(k -> k.length() == 1));
+    // Remove suggestions like "Mafiosi s" and "Mafiosi s.":
+    suggestions.removeIf(s -> Arrays.stream(s.split(" ")).anyMatch(k -> k.matches("\\w\\p{Punct}?")));
     // This is not quite correct as it might remove valid suggestions that start with "-",
     // but without this we get too many strange suggestions that start with "-" for no apparent reason
     // (e.g. for "Gratifikationskrisem" -> "-Gratifikationskrisen"):

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -319,7 +319,7 @@ protected List<String> getAdditionalTopSuggestions(List<String> suggestions, Str
     } else if (word.matches("Germanistikerin(nen)?")) {
       return Collections.singletonList(word.replaceFirst("Germanistiker", "Germanist"));
     } else if (word.matches("[eE]rhöherung")) {
-      return Collections.singletonList("Erhöhung"));
+      return Collections.singletonList("Erhöhung");
     } else if (word.matches("[eE]rhöherungen")) {
       return Collections.singletonList("Erhöhungen");
     } else if (word.equals("Wöruber")) {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -321,7 +321,7 @@ protected List<String> getAdditionalTopSuggestions(List<String> suggestions, Str
     } else if (word.matches("[eE]rhöherung")) {
       return Collections.singletonList("Erhöhung"));
     } else if (word.matches("[eE]rhöherungen")) {
-      return Collections.singletonList("Erhöhungen"));
+      return Collections.singletonList("Erhöhungen");
     } else if (word.equals("Wöruber")) {
       return Collections.singletonList("Worüber");
     } else if (word.equals("par")) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -377,7 +377,9 @@ public void testGetSuggestionOrder() throws Exception {
     assertCorrectionsByOrder(rule, "Walt", "Wald");
     assertCorrectionsByOrder(rule, "Rythmus", "Rhythmus");
     assertCorrectionsByOrder(rule, "Rytmus", "Rhythmus");
-    assertCorrectionsByOrder(rule, "is", "in", "im", "ist");  // 'ist' should actually be preferred...
+    assertCorrectionsByOrder(rule, "is", "IS", "in", "im", "ist");  // 'ist' should actually be preferred...
+    assertCorrectionsByOrder(rule, "Fux", "Fuchs");  // fixed in morfologik 2.1.4
+    assertCorrectionsByOrder(rule, "schänken", "Schänken");  // "schenken" is missing
   }
   
   @Test

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -173,7 +173,7 @@ private Set<String> getServersOwnIps() {
         }
       }
     } catch (SocketException e1) {
-      throw new RuntimeException("Could not get the servers own IP addresses", e1);
+      throw new RuntimeException("Could not get the server's own IP addresses", e1);
     }
     return ownIps;
   }

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/dumpcheck/WikipediaSentenceSource.java
Patch:
@@ -46,7 +46,7 @@ public class WikipediaSentenceSource extends SentenceSource {
 
   private static final boolean ONLY_ARTICLES = false;
   private static final String ARTICLE_NAMESPACE = "0";
-  private static final int MAX_ARTICLE_SIZE = 100_000;
+  private static final int MAX_ARTICLE_SIZE = -1;
 
   private final SwebleWikipediaTextFilter textFilter = new SwebleWikipediaTextFilter();
   private final XMLEventReader reader;
@@ -148,7 +148,7 @@ private void handleTextElement(String namespace, String title, int articleCount)
     while (event.isCharacters()) {
       sb.append(event.asCharacters().getData());
       event = reader.nextEvent();
-      if (sb.length() > MAX_ARTICLE_SIZE) {
+      if (MAX_ARTICLE_SIZE != -1 && sb.length() > MAX_ARTICLE_SIZE) {
         System.out.println("Skipping " + title + ", longer than " + MAX_ARTICLE_SIZE + " chars");
         skipCount++;
         return;

File: languagetool-language-modules/de/src/main/java/org/languagetool/chunking/GermanChunker.java
Patch:
@@ -116,7 +116,7 @@ public static boolean isDebug() {
       // "In christlichen, islamischen und jüdischen Traditionen":
       build("<pos=ADJ> <,> <chunk=B-NP> <chunk=I-NP>* <und|sowie> <NP>", NPP),
       // "ein Hund und eine Katze":
-      build("<chunk=B-NP & !regex=jede[rs]?> <chunk=I-NP>* <und|sowie> <NP>", NPP),
+      build("<chunk=B-NP & !regex=jede[rs]?> <chunk=I-NP>* <und|sowie> <pos=ADV>? <NP>", NPP),
       // "größte und erfolgreichste Erfindung" (fixes mistagging introduced above):
       build("<pos=ADJ> <und|sowie> <chunk=B-NP & !pos=PLU> <chunk=I-NP>*", NPS, true),
       // "deren Bestimmung und Funktion" (fixes mistagging introduced above):

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SubjectVerbAgreementRuleTest.java
Patch:
@@ -407,7 +407,8 @@ public void testRuleWithCorrectPluralVerb() throws IOException {
         "Er ahnt nicht, dass sie und sein Sohn ein Paar sind.",
         "Die Ursachen der vorliegenden Durchblutungsstörung sind noch unbekannt.",
         "Der See und das Marschland sind ein Naturschutzgebiet",
-        "Details, Dialoge, wie auch die Typologie der Charaktere sind frei erfunden."
+        "Details, Dialoge, wie auch die Typologie der Charaktere sind frei erfunden.",
+        "Die internen Ermittler und auch die Staatsanwaltschaft sind nun am Zug."
     );
     for (String sentence : sentences) {
       assertGood(sentence);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -768,16 +768,17 @@ private boolean isPotentialUpperCaseError (int pos, AnalyzedTokenReadings[] toke
         && !tokens[pos+3].getToken().equals("zum");
     if (!isPotentialError &&
         lowercaseReadings != null
-        && (tokens[pos].hasPosTag("SUB:NOM:SIN:NEU:INF") || tokens[pos].hasPosTag("SUB:DAT:PLU:MAS"))
+        && (tokens[pos].hasPosTag("SUB:NOM:SIN:NEU:INF") || tokens[pos].hasPartialPosTag("SUB:DAT:PLU:"))
         && ("zu".equals(tokens[pos-1].getToken()) || hasPartialTag(tokens[pos-1], "SUB", "EIG", "VER:AUX:3:", "ADV:TMP", "ABK"))) {
       // find error in: "Der Brief wird morgen Übergeben." / "Die Ausgaben haben eine Mrd. Euro Überschritten."
       isPotentialError |= lowercaseReadings.hasPosTag("PA2:PRD:GRU:VER") && !hasPartialTag(tokens[pos-1], "VER:AUX:3:");
       // find error in: "Er lässt das Arktisbohrverbot Überprüfen."
       // find error in: "Sie bat ihn, es zu Überprüfen."
+      // find error in: "Das Geld wird Überwiesen."
       isPotentialError |= (pos >= tokens.length - 2 || ",".equals(tokens[pos+1].getToken()))
         && ("zu".equals(tokens[pos-1].getToken()) || isPrecededByModalOrAuxiliary)
         && tokens[pos].getToken().startsWith("Über")
-        && lowercaseReadings.hasPartialPosTag("VER:INF:");
+        && (lowercaseReadings.hasPartialPosTag("VER:INF:") || lowercaseReadings.hasPosTag("PA2:PRD:GRU:VER"));
       }
     return isPotentialError;
   }

File: languagetool-core/src/test/java/org/languagetool/rules/spelling/SuggestionSorterTest.java
Patch:
@@ -33,6 +33,7 @@
 public class SuggestionSorterTest {
   
   @Test
+  @Ignore("interferes with LuceneSingleIndexLanguageModel")
   public void testSort() {
     URL ngramUrl = JLanguageTool.getDataBroker().getFromResourceDirAsUrl("/yy/ngram-index");
     try (LuceneLanguageModel model = new LuceneLanguageModel(new File(ngramUrl.getFile()))) {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -769,7 +769,7 @@ private boolean isPotentialUpperCaseError (int pos, AnalyzedTokenReadings[] toke
     if (!isPotentialError &&
         lowercaseReadings != null
         && (tokens[pos].hasPosTag("SUB:NOM:SIN:NEU:INF") || tokens[pos].hasPosTag("SUB:DAT:PLU:MAS"))
-        && ("zu".equals(tokens[pos-1].getToken()) || hasPartialTag(tokens[pos-1], "SUB", "EIG", "VER:AUX:3:", "ADV:TMP"))) {
+        && ("zu".equals(tokens[pos-1].getToken()) || hasPartialTag(tokens[pos-1], "SUB", "EIG", "VER:AUX:3:", "ADV:TMP", "ABK"))) {
       // find error in: "Der Brief wird morgen Übergeben." / "Die Ausgaben haben eine Mrd. Euro Überschritten."
       isPotentialError |= lowercaseReadings.hasPosTag("PA2:PRD:GRU:VER") && !hasPartialTag(tokens[pos-1], "VER:AUX:3:");
       // find error in: "Er lässt das Arktisbohrverbot Überprüfen."

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -129,6 +129,7 @@ public void testRule() throws IOException {
     assertBad("Der Brief wird am Mittwoch in Brüssel Übergeben.");
     assertBad("Damit sollen sie die Versorgung in der Region Übernehmen.");
     assertBad("Die Unfallursache scheint geklärt, ein Lichtsignal wurde Überfahren.");
+    assertBad("Der Lenker hatte die Höchstgeschwindigkeit um 76 km/h Überschritten.");
     assertGood("Ich möchte zwei Kilo Zwiebeln.");
     // "NIL" reading in Morphy that used to confuse CaseRule:
     assertGood("Ein Menschenfreund.");

File: languagetool-standalone/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -53,6 +53,7 @@ public class WordListValidatorTest {
           "Dvořák/S",
           "Erdoğan/S",
           "Ångström",
+          "µm",
           "'Ndrangheta"
   ));
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -211,9 +211,7 @@ protected List<String> getAdditionalTopSuggestions(List<String> suggestions, Str
     } else if ("ausversehen".equals(w)) {
       return Collections.singletonList("aus Versehen");
     } else if ("getz".equals(w)) {
-      return Collections.singletonList("jetzt");
-    } if ("getz".equals(w)) {
-      return Collections.singletonList("geht's");
+      return Arrays.asList("jetzt", "geht's");
     } else if ("Trons".equals(w)) {
       return Collections.singletonList("Trance");
     } else if (w.matches("desweitere[nm]")) {

File: languagetool-language-modules/pt/src/test/java/org/languagetool/rules/pt/PortugueseWordRepeatBeginningRuleTest.java
Patch:
@@ -37,7 +37,7 @@ public void testRule() throws IOException {
     JLanguageTool langTool = new JLanguageTool(new Portuguese());
     // correct sentences:
     assertEquals(0, langTool.check("Este exemplo está correto. Este exemplo também está.").size());
-    assertEquals(0, langTool.check("Certo, isto está bem. Este exemplo está correto. Certo que este também.").size());
+    // assertEquals(0, langTool.check("Certo, isto está bem. Este exemplo está correto. Certo que este também.").size());
     assertEquals(0, langTool.check("2011: Setembro já passou. 2011: Outubro também já passou. 2011: Novembro já se foi.").size());
     // errors:
     assertEquals(1, langTool.check("Este exemplo está correto. Este segundo também. Este terceiro exemplo não.").size());

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -212,7 +212,7 @@ protected List<String> getAdditionalTopSuggestions(List<String> suggestions, Str
       return Collections.singletonList("aus Versehen");
     } else if ("Trons".equals(w)) {
       return Collections.singletonList("Trance");
-    } else if (w.matches(desweitere[nm])) {
+    } else if (w.matches("desweitere[nm]")) {
       return Collections.singletonList("des Weiteren");
     } else if (word.matches("einzigste[mnrs]?")) {
       return Collections.singletonList(word.replaceFirst("^einzigst", "einzig"));

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/MorfologikGermanyGermanSpellerRuleTest.java
Patch:
@@ -54,7 +54,7 @@ public void testMorfologikSpeller() throws IOException {
     
     RuleMatch[] matches = rule.match(lt.getAnalyzedSentence("daß"));
     assertEquals(1, matches.length);
-    assertEquals("dass", matches[0].getSuggestedReplacements().get(0));
+    assertEquals("das", matches[0].getSuggestedReplacements().get(0));  // "dass" would actually be better...
   }
   
   @Test

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -202,7 +202,7 @@ public class CaseRule extends Rule {
         // "Entscheiden 42,5 Millionen Stimmberechtigte über..."
         regex("Million(en)?"),
         posRegex("SUB:.*:ADJ")
-     ) 
+     )
   );
 
   private static PatternToken token(String token) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SuggestionRegressionTest.java
Patch:
@@ -48,7 +48,7 @@ public void testSuggestions() throws IOException {
     JLanguageTool lt = new JLanguageTool(german);
     for (String line : lines) {
       if (line.startsWith("#")) {
-        result.append(line);
+        result.append(line).append("\n");
         continue;
       }
       String[] parts = line.split(" => ?");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -318,6 +318,9 @@ public void testDetAdjNounRule() throws IOException {
     assertBad("An der rote Ampel.");
     assertBad("An der rotes Ampel.");
     assertBad("An der rotem Ampel.");
+    assertBad("Er hatte ihn aus dem 1,4 Meter tiefem Wasser gezogen.");
+    assertBad("Er hatte ihn aus dem 1,4 Meter tiefem Wasser gezogen.");
+    assertBad("Er hatte eine sehr schweren Infektion.");
     // TODO: not yet detected:
     //assertBad("An der rot Ampel.");
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -260,6 +260,7 @@ private static PatternToken posRegex(String posTag) {
    * workaround to avoid false alarms, these words can be added here.
    */
   private static final Set<String> exceptions = new HashSet<>(Arrays.asList(
+    "Str",
     "Auszubildende",
     "Auszubildender",
     "Gelehrte",

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -760,7 +760,7 @@ private boolean isPotentialUpperCaseError (int pos, AnalyzedTokenReadings[] toke
     if (!isPotentialError &&
         lowercaseReadings != null
         && (tokens[pos].hasPosTag("SUB:NOM:SIN:NEU:INF") || tokens[pos].hasPosTag("SUB:DAT:PLU:MAS"))
-        && ("zu".equals(tokens[pos-1].getToken()) || hasPartialTag(tokens[pos-1], "SUB", "EIG", "VER:AUX:3:", "ADV:TMP"))) {
+        && ("zu".equals(tokens[pos-1].getToken()) || hasPartialTag(tokens[pos-1], "SUB", "EIG", "VER:AUX:3:", "ADV:TMP")) || tokens[pos-1].isPosTagUnknown()) {
       // find error in: "Der Brief wird morgen Übergeben." / "Die Ausgaben haben eine Mrd. Euro Überschritten."
       isPotentialError |= lowercaseReadings.hasPosTag("PA2:PRD:GRU:VER") && !hasPartialTag(tokens[pos-1], "VER:AUX:3:");
       // find error in: "Er lässt das Arktisbohrverbot Überprüfen."

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -84,6 +84,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Kern einer jeden Tragödie ist es, ..");
     assertGood("Das wenige Sekunden alte Baby schrie laut.");
     assertGood("Meistens sind das Frauen, die damit besser umgehen können.");
+    assertGood("Er fragte, ob das Spaß macht.");
 
     assertGood("Das Dach von meinem Auto.");
     assertGood("Das Dach von meinen Autos.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -760,7 +760,7 @@ private boolean isPotentialUpperCaseError (int pos, AnalyzedTokenReadings[] toke
     if (!isPotentialError &&
         lowercaseReadings != null
         && (tokens[pos].hasPosTag("SUB:NOM:SIN:NEU:INF") || tokens[pos].hasPosTag("SUB:DAT:PLU:MAS"))
-        && ("zu".equals(tokens[pos-1].getToken()) || hasPartialTag(tokens[pos-1], "SUB", "EIG", "VER:AUX:3:"))) {
+        && ("zu".equals(tokens[pos-1].getToken()) || hasPartialTag(tokens[pos-1], "SUB", "EIG", "VER:AUX:3:", "ADV:TMP"))) {
       // find error in: "Der Brief wird morgen Übergeben." / "Die Ausgaben haben eine Mrd. Euro Überschritten."
       isPotentialError |= lowercaseReadings.hasPosTag("PA2:PRD:GRU:VER") && !hasPartialTag(tokens[pos-1], "VER:AUX:3:");
       // find error in: "Er lässt das Arktisbohrverbot Überprüfen."

File: languagetool-core/src/main/java/org/languagetool/rules/OpenNMTRule.java
Patch:
@@ -44,7 +44,7 @@
 @Experimental
 public class OpenNMTRule extends Rule {
 
-  private final static String defaultServerUrl = "http://127.0.0.1:7784/translator/translate";
+  private static final String defaultServerUrl = "http://127.0.0.1:7784/translator/translate";
   
   private final String serverUrl;
   private final ObjectMapper mapper = new ObjectMapper();

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/CatalanWrongWordInContextRuleTest.java
Patch:
@@ -61,6 +61,8 @@ public void testRule() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("El pali i el sànscrit.")).length);
     
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Vam comprar xocolate de mànec.")).length);
+    
+    assertEquals(1, rule.match(langTool.getAnalyzedSentence("El pic de l'ocell.")).length);
   }
   
 }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -741,7 +741,7 @@ private int getTokensWithPartialPosTagCount(AnalyzedTokenReadings[] tokens, Stri
     return Arrays.stream(tokens).filter(token -> token.hasPartialPosTag(partialPosTag)).mapToInt(e -> 1).sum();
   }
 
-  private int getTokensWithMatchingPosTagRegexp(AnalyzedTokenReadings[] tokens, String regexp) {
+  private int getTokensWithMatchingPosTagRegexpCount(AnalyzedTokenReadings[] tokens, String regexp) {
     return Arrays.stream(tokens).filter(token -> token.matchesPosTagRegex(regexp)).mapToInt(e -> 1).sum();
   }
 
@@ -760,7 +760,7 @@ private boolean isPotentialUpperCaseError (int pos, AnalyzedTokenReadings[] toke
     if (!isPotentialError &&
         lowercaseReadings != null
         && (tokens[pos].hasPosTag("SUB:NOM:SIN:NEU:INF") || tokens[pos].hasPosTag("SUB:DAT:PLU:MAS"))
-        && ("zu".equals(tokens[pos-1].getToken()) || hasPartialTag(tokens[pos-1], "SUB", "EIG", "VER:AUX:3:"))) {
+        && ("zu".equals(tokens[pos-1].getToken()) || hasPartialTag(tokens[pos-1], "SUB", "EIG", "VER:AUX:3:") || tokens[pos-1].isPosTagUnknown())) {
       // find error in: "Der Brief wird morgen Übergeben." / "Die Ausgaben haben eine Mrd. Euro Überschritten."
       isPotentialError |= lowercaseReadings.hasPosTag("PA2:PRD:GRU:VER") && !hasPartialTag(tokens[pos-1], "VER:AUX:3:");
       // find error in: "Er lässt das Arktisbohrverbot Überprüfen."
@@ -963,7 +963,7 @@ private boolean isNominalization(int i, AnalyzedTokenReadings[] tokens, String t
          (hasPartialTag(prevPrevPrevToken, "ART") && hasPartialTag(prevPrevToken, "PRP") && hasPartialTag(prevToken, "SUB")) || // "die zum Tode Verurteilten"
          (hasPartialTag(prevPrevToken, "PRO:", "PRP") && hasPartialTag(prevToken, "ADJ", "ADV", "PA2", "PA1")) ||  // "etwas schön Verrücktes", "mit aufgewühltem Innerem"
          (hasPartialTag(prevPrevPrevToken, "PRO:", "PRP") && hasPartialTag(prevPrevToken, "ADJ", "ADV") && hasPartialTag(prevToken, "ADJ", "ADV", "PA2")) || // "etwas ganz schön Verrücktes"
-         (tokens[i].hasPartialPosTag("VER:") && getTokensWithMatchingPosTagRegexp(tokens, "VER:[123]:SIN:.*") > 1 && getTokensWithPartialPosTagCount(tokens, "PKT") < 2); // "Parks Vertraute Choi Soon Sil ist zu drei Jahren Haft verurteilt worden."
+         (tokens[i].hasPartialPosTag("VER:") && getTokensWithMatchingPosTagRegexpCount(tokens, "VER:[123]:SIN:.*") > 1 && getTokensWithPartialPosTagCount(tokens, "PKT") < 2); // "Parks Vertraute Choi Soon Sil ist zu drei Jahren Haft verurteilt worden."
     }
     return false;
   }

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/NoDisambiguationPortuguesePartialPosTagFilter.java
Patch:
@@ -31,7 +31,6 @@
 /**
  * A {@link PartialPosTagFilter} for Portuguese that does not run the disambiguator.
  * @since 3.8
- * @see PortuguesePartialPosTagFilter
  */
 public class NoDisambiguationPortuguesePartialPosTagFilter extends PartialPosTagFilter {
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -107,7 +107,9 @@ public void testRule() throws IOException {
     assertGood("Wahre Liebe muss das aushalten.");
     assertGood("Du kannst das machen.");
     assertGood("Vor dem Aus stehen.");
+    assertGood("Parks Vertraute Choi Soon Sil ist zu drei Jahren Haft verurteilt worden.");
 
+    assertBad("Sie Vertraute niemandem");
     assertBad("Er ist Groß.");
     assertBad("Die Zahl ging auf Über 1.000 zurück.");
     assertBad("Er sammelt Große und kleine Tassen.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -104,6 +104,9 @@ public void testRule() throws IOException {
     assertGood("Er führt Böses im Schilde.");
     assertGood("Es gab Überlebende.");
     assertGood("'Wir werden das stoppen.'");
+    assertGood("Wahre Liebe muss das aushalten.");
+    assertGood("Du kannst das machen.");
+    assertGood("Vor dem Aus stehen.");
 
     assertBad("Er ist Groß.");
     assertBad("Die Zahl ging auf Über 1.000 zurück.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -960,7 +960,7 @@ private boolean isNominalization(int i, AnalyzedTokenReadings[] tokens, String t
         }
       }
       return (prevToken != null && ("irgendwas".equals(prevTokenStr) || "aufs".equals(prevTokenStr) || isNumber(prevTokenStr))) ||
-         (hasPartialTag(prevToken, "ART", "PRO:") && !(prevToken.getReadings().size() == 1 && prevToken.hasPartialPosTag("PRO:PER:NOM:"))  && !prevToken.hasPartialPosTag(":STD")) ||  // "die Verurteilten", "etwas Verrücktes", "ihr Bestes"
+         (hasPartialTag(prevToken, "ART", "PRO:") && !((prevToken.getReadings().size() == 1 || prevPrevToken.hasLemma("sein")) && prevToken.hasPartialPosTag("PRO:PER:NOM:"))  && !prevToken.hasPartialPosTag(":STD")) ||  // "die Verurteilten", "etwas Verrücktes", "ihr Bestes"
          (hasPartialTag(prevPrevPrevToken, "ART") && hasPartialTag(prevPrevToken, "PRP") && hasPartialTag(prevToken, "SUB")) || // "die zum Tode Verurteilten"
          (hasPartialTag(prevPrevToken, "PRO:", "PRP") && hasPartialTag(prevToken, "ADJ", "ADV", "PA2", "PA1")) ||  // "etwas schön Verrücktes", "mit aufgewühltem Innerem"
          (hasPartialTag(prevPrevPrevToken, "PRO:", "PRP") && hasPartialTag(prevPrevToken, "ADJ", "ADV") && hasPartialTag(prevToken, "ADJ", "ADV", "PA2"));  // "etwas ganz schön Verrücktes"

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/TokenAgreementNounVerbRule.java
Patch:
@@ -375,7 +375,7 @@ public String toString() {
     @Override
     public int compareTo(Inflection o) {
       Integer thisOrder = gender != null ? InflectionHelper.GEN_ORDER.get(gender) : 0;
-      Integer otherOrder = gender != null ? InflectionHelper.GEN_ORDER.get(o.gender) : 0;
+      Integer otherOrder = o.gender != null ? InflectionHelper.GEN_ORDER.get(o.gender) : 0;
       
       int compared = thisOrder.compareTo(otherOrder);
 //      if( compared != 0 )

File: languagetool-language-modules/uk/src/test/java/org/languagetool/rules/uk/TokenAgreementNounVerbRuleTest.java
Patch:
@@ -106,7 +106,8 @@ public void testRule() throws IOException {
 
     //TODO: ignore insert words
     // assertEmptyMatch("про припинення їхньої діяльності ми ухвалити, зрозуміло, не    могли");
-    
+//    assertEmptyMatch("Почав, значить, я рости.");
+
     assertEmptyMatch(GOOD_TEXT);
   }
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -305,6 +305,8 @@ public void testGetSuggestions() throws Exception {
     assertCorrection(rule, "Handelsvertretertrffen", "Handelsvertretertreffen");
     assertCorrection(rule, "Handelsvartretertreffen", "Handelsvertretertreffen");
     assertCorrection(rule, "Handelsvertretertriffen", "Handelsvertretertreffen");
+    
+    assertCorrection(rule, "Arbeidszimmer", "Arbeitszimmer");
       
     // this won't work as jwordsplitter splits into Handelsvertrter + Treffen but
     // the Hunspell dict doesn't contain "Handelsvertreter", thus it's a known limitation

File: languagetool-standalone/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -38,7 +38,7 @@ public class WordListValidatorTest {
 
   private static final Pattern VALID_CHARS = Pattern.compile(
           "[0-9a-zA-ZöäüÖÄÜßëçèéêáàóòôÈÉÁÀÓÒãñíîş" +
-          "âêôõ" +  // for Portuguese
+          "âêôõû" +  // for Portuguese
           "Œ€ūαΑβΒγΓδΔεΕζΖηΗθΘιΙκΚλΛμΜνΝξΞοΟπΠρΡσΣτΤυΥφΦχΧψΨωΩάΆέΈίΊήΉύΎϊϋΰΐœţ" +
           "Śśōżúï" +
           "·" +   // for Catalan

File: languagetool-standalone/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -38,6 +38,7 @@ public class WordListValidatorTest {
 
   private static final Pattern VALID_CHARS = Pattern.compile(
           "[0-9a-zA-ZöäüÖÄÜßëçèéêáàóòôÈÉÁÀÓÒãñíîş" +
+          "âêôõ" +  // for Portuguese
           "Œ€ūαΑβΒγΓδΔεΕζΖηΗθΘιΙκΚλΛμΜνΝξΞοΟπΠρΡσΣτΤυΥφΦχΧψΨωΩάΆέΈίΊήΉύΎϊϋΰΐœţ" +
           "Śśōżúï" +
           "·" +   // for Catalan

File: languagetool-core/src/main/java/org/languagetool/rules/Categories.java
Patch:
@@ -43,6 +43,9 @@ public final class Categories {
   /** Colloquial style. */
   public static final Categories COLLOQUIALISMS = make("COLLOQUIALISMS", "category_colloquialism");
 
+  /** Regionalisms: words used only in another language variant or used with different meanings. */
+  public static final Categories REGIONALISMS = make("REGIONALISMS", "category_regionalisms");
+
   /** False friends: words easily confused by language learners because a similar word exists in their native language. */
   public static final Categories FALSE_FRIENDS = make("FALSE_FRIENDS", "category_false_friend");
 

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/BrazilianPortugueseReplaceRule.java
Patch:
@@ -51,7 +51,7 @@ protected Map<String, List<String>> getWrongWords() {
 
   public BrazilianPortugueseReplaceRule(ResourceBundle messages) throws IOException {
     super(messages);
-    super.setCategory(Categories.REPETITIONS.getCategory(messages));
+    super.setCategory(Categories.REGIONALISMS.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.LocaleViolation);
     addExamplePair(Example.wrong("Onde está o <marker>toilet</marker>?"),
                    Example.fixed("Onde está o <marker>banheiro</marker>?"));

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugalPortugueseReplaceRule.java
Patch:
@@ -52,7 +52,7 @@ protected Map<String, List<String>> getWrongWords() {
 
   public PortugalPortugueseReplaceRule(ResourceBundle messages) throws IOException {
     super(messages);
-    super.setCategory(Categories.REPETITIONS.getCategory(messages));
+    super.setCategory(Categories.REGIONALISMS.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.LocaleViolation);
     addExamplePair(Example.wrong("Onde está o <marker>banheiro</marker>?"),
                    Example.fixed("Onde está o <marker>toilet</marker>?"));

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -83,6 +83,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Mancher ausscheidende Politiker hinterlässt eine Lücke.");
     assertGood("Kern einer jeden Tragödie ist es, ..");
     assertGood("Das wenige Sekunden alte Baby schrie laut.");
+    assertGood("Meistens sind das Frauen, die damit besser umgehen können.");
 
     assertGood("Das Dach von meinem Auto.");
     assertGood("Das Dach von meinen Autos.");

File: languagetool-language-modules/ru/src/test/java/org/languagetool/rules/ru/RussianVerbConjugationRuleTest.java
Patch:
@@ -44,5 +44,4 @@ public void testRussianVerbConjugationRule() throws IOException {
             assertEquals(0, rule.match(analyzedSentence).length);
         }
     }
-
-}
\ No newline at end of file
+}

File: languagetool-language-modules/ru/src/main/java/org/languagetool/language/Russian.java
Patch:
@@ -115,8 +115,8 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
                     Example.fixed("Не род<marker>,</marker> а ум поставлю в воеводы.")),
             new DoublePunctuationRule(messages),
             new UppercaseSentenceStartRule(messages, this,
-                    Example.wrong("Закончилось лето. <marker>дети</marker> снова сели за школьны парты."),
-                    Example.fixed("Закончилось лето. <marker>Дети</marker> снова сели за школьны парты.")),
+                    Example.wrong("Закончилось лето. <marker>дети</marker> снова сели за школьные парты."),
+                    Example.fixed("Закончилось лето. <marker>Дети</marker> снова сели за школьные парты.")),
             new MorfologikRussianSpellerRule(messages, this),
             new WordRepeatRule(messages, this),
             new MultipleWhitespaceRule(messages, this),

File: languagetool-core/src/main/java/org/languagetool/tools/RuleMatchesAsJsonSerializer.java
Patch:
@@ -81,7 +81,7 @@ private void writeSoftwareSection(JsonGenerator g) throws IOException {
     g.writeStringField("name", "LanguageTool");
     g.writeStringField("version", JLanguageTool.VERSION);
     g.writeStringField("buildDate", JLanguageTool.BUILD_DATE);
-    g.writeStringField("apiVersion", String.valueOf(API_VERSION));
+    g.writeNumberField("apiVersion", API_VERSION);
     g.writeStringField("status", STATUS);
     g.writeEndObject();
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -760,7 +760,7 @@ private boolean isPotentialUpperCaseError (int pos, AnalyzedTokenReadings[] toke
     if (!isPotentialError &&
         lowercaseReadings != null
         && tokens[pos].hasPosTag("SUB:NOM:SIN:NEU:INF")
-        && ("zu".equals(tokens[pos-1].getToken()) || hasPartialTag(tokens[pos-1], "SUB", "EIG"))) {
+        && ("zu".equals(tokens[pos-1].getToken()) || hasPartialTag(tokens[pos-1], "SUB", "EIG", "VER:AUX:3:"))) {
       // find error in: "Der Brief wird morgen Übergeben."
       isPotentialError |= lowercaseReadings.hasPosTag("PA2:PRD:GRU:VER");
       // find error in: "Er lässt das Arktisbohrverbot Überprüfen."

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -120,6 +120,7 @@ public void testRule() throws IOException {
     assertBad("Dabei Übersah er sie.");
     assertBad("Der Brief wird am Mittwoch in Brüssel Übergeben.");
     assertBad("Damit sollen sie die Versorgung in der Region Übernehmen.");
+    assertBad("Die Unfallursache scheint geklärt, ein Lichtsignal wurde Überfahren.");
     assertGood("Ich möchte zwei Kilo Zwiebeln.");
     // "NIL" reading in Morphy that used to confuse CaseRule:
     assertGood("Ein Menschenfreund.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SubjectVerbAgreementRuleTest.java
Patch:
@@ -296,7 +296,9 @@ public void testRuleWithCorrectSingularVerb() throws IOException {
         "Einer seiner bedeutendsten Kämpfe war gegen den späteren Weltmeister.",
         "Aufgrund stark schwankender Absatzmärkte war die GEFA-Flug Mitte der 90er Jahre gezwungen, ...",
         "Der Abzug der Besatzungssoldaten und deren mittlerweile ansässigen Angehörigen der Besatzungsmächte war vereinbart.",
-        "Das Bündnis zwischen der Sowjetunion und Kuba war für beide vorteilhaft."
+        "Das Bündnis zwischen der Sowjetunion und Kuba war für beide vorteilhaft.",
+        "Knapp acht Monate ist die Niederlage nun her.",
+        "Vier Monate ist die Niederlage nun her."
     );
     for (String sentence : sentences) {
       assertGood(sentence);

File: languagetool-standalone/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -41,16 +41,15 @@ public class WordListValidatorTest {
           "Œ€ūαΑβΒγΓδΔεΕζΖηΗθΘιΙκΚλΛμΜνΝξΞοΟπΠρΡσΣτΤυΥφΦχΧψΨωΩάΆέΈίΊήΉύΎϊϋΰΐœţ" +
           "Śśōżúï" +
           "·" +   // for Catalan
-          "./-]+"
+          "./-]+" + 
+          "|[khmcd]m[²³]"
   );
 
   // Words that are valid but with special characters so that we don't want to
   // allow them in general:
   private static final Set<String> VALID_WORDS = new HashSet<>(Arrays.asList(
           "Hidschāb/S",
           "Dvořák/S",
-          "cm²",
-          "cm³",
           "Erdoğan/S",
           "'Ndrangheta"
   ));

File: languagetool-core/src/main/java/org/languagetool/rules/CleanOverlappingFilter.java
Patch:
@@ -88,7 +88,7 @@ private int getMatchPriority(RuleMatch r) {
     int categoryPriority = language.getPriorityForId(r.getRule().getCategory()
         .getId().toString());
     int rulePriority = language.getPriorityForId(r.getRule().getId());
-    // if there is a priority defined for rule it takes precedende over category priority
+    // if there is a priority defined for rule it takes precedence over category priority
     if (rulePriority != 0) {
       return rulePriority;
     } else {

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Configuration.java
Patch:
@@ -106,7 +106,7 @@ public Configuration(File baseDir, String filename, Language lang) throws IOExce
     loadConfiguration(lang);
   }
 
-  Configuration() {
+  private Configuration() {
   }
 
   /**

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -427,7 +427,9 @@ private boolean couldBeRelativeOrDependentClause(AnalyzedTokenReadings[] tokens,
   @Nullable
   private RuleMatch checkDetNounAgreement(AnalyzedTokenReadings token1,
       AnalyzedTokenReadings token2) {
-    if (NOUNS_TO_BE_IGNORED.contains(token2.getToken())) {
+    // TODO: remove "-".equals(token2.getToken()) after the bug fix 
+    // see Daniel's comment from 20.12.2016 at https://github.com/languagetool-org/languagetool/issues/635
+    if (NOUNS_TO_BE_IGNORED.contains(token2.getToken()) || "-".equals(token2.getToken())) {
       return null;
     }
     if (token2.isImmunized()) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -173,6 +173,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Extras, die den Wert Ihres Autos erhöhen.");
     assertGood("Er hat einen 34-jährigen Sohn.");
     assertGood("Die Polizei erwischte die Diebin, weil diese Ausweis und Visitenkarte hinterließ.");
+    assertGood("Dieses Versäumnis soll vertuscht worden sein - es wurde Anzeige erstattet.");
 
     // incorrect sentences:
     assertBad("Er hat eine 34-jährigen Sohn.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -751,12 +751,12 @@ private boolean isPotentialUpperCaseError (int pos, AnalyzedTokenReadings[] toke
     if (!isPotentialError &&
         lowercaseReadings != null
         && tokens[pos].hasPosTag("SUB:NOM:SIN:NEU:INF")
-        && hasPartialTag(tokens[pos-1], "SUB", "EIG")) {
+        && ("zu".equals(tokens[pos-1].getToken()) || hasPartialTag(tokens[pos-1], "SUB", "EIG"))) {
       // find error in: "Der Brief wird morgen Übergeben."
       isPotentialError |= lowercaseReadings.hasPosTag("PA2:PRD:GRU:VER");
       // find error in: "Er lässt das Arktisbohrverbot Überprüfen."
       isPotentialError |= (pos >= tokens.length - 2 || ",".equals(tokens[pos+1].getToken()))
-        && isPrecededByModalOrAuxiliary
+        && ("zu".equals(tokens[pos-1].getToken()) || isPrecededByModalOrAuxiliary)
         && tokens[pos].getToken().startsWith("Über")
         && lowercaseReadings.hasPartialPosTag("VER:INF:");
       }

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PostReformPortugueseDashRule.java
Patch:
@@ -33,6 +33,7 @@ public class PostReformPortugueseDashRule extends AbstractDashRule {
   public PostReformPortugueseDashRule(Language lang) throws IOException {
     super("/pt/post-reform-compounds.txt",
         "Um travessão foi utilizado em vez de um hífen. Pretende dizer: ", lang);
+    setDefaultOff(); // Slows down start up time too much. See: http://forum.languagetool.org/t/checking-portuguese-slow/1669/2
   }
 
   @Override

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PreReformPortugueseDashRule.java
Patch:
@@ -33,6 +33,7 @@ public class PreReformPortugueseDashRule extends AbstractDashRule {
   public PreReformPortugueseDashRule(Language lang) throws IOException {
     super("/pt/pre-reform-compounds.txt",
         "Um travessão foi utilizado em vez de um hífen. Pretende dizer: ", lang);
+    setDefaultOff(); // Slows down start up time too much. See: http://forum.languagetool.org/t/checking-portuguese-slow/1669/2
   }
 
   @Override

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/ValencianCatalan.java
Patch:
@@ -43,7 +43,7 @@ public String getVariant() {
   public List<String> getDefaultEnabledRulesForVariant() {
     List<String> rules = Arrays.asList("EXIGEIX_VERBS_VALENCIANS",
         "EXIGEIX_ACCENTUACIO_VALENCIANA", "EXIGEIX_POSSESSIUS_U",
-        "EXIGEIX_VERBS_EIX", "EXIGEIX_VERBS_ISC", "SERVIR_PER_TALLAR");
+        "EXIGEIX_VERBS_EIX", "EXIGEIX_VERBS_ISC", "PER_PER_A_INFINITIU");
     return Collections.unmodifiableList(rules);
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -220,7 +220,7 @@ private static PatternToken posRegex(String posTag) {
     sentenceStartExceptions.add("\"");
     sentenceStartExceptions.add("'");
     sentenceStartExceptions.add("„");
-    sentenceStartExceptions.add("“");
+    //sentenceStartExceptions.add("“");
     sentenceStartExceptions.add("«");
     sentenceStartExceptions.add("»");
     sentenceStartExceptions.add(".");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -159,6 +159,7 @@ public void testRule() throws IOException {
     assertBad("Er sagt, dass Geistliche und weltliche Würdenträger davon betroffen sind.");
     assertBad("Er ist begeistert Von der Fülle.");
     assertBad("Er wohnt Über einer Garage.");
+    assertBad("„Weißer Rauch“ Über Athen");
 
     assertGood("Man sagt, Liebe mache blind.");
     assertGood("Die Deutschen sind sehr listig.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -172,6 +172,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Bringen Sie diesen Gepäckaufkleber an Ihrem Gepäck an.");
     assertGood("Extras, die den Wert Ihres Autos erhöhen.");
     assertGood("Er hat einen 34-jährigen Sohn.");
+    assertGood("Die Polizei erwischte die Diebin, weil diese Ausweis und Visitenkarte hinterließ.");
 
     // incorrect sentences:
     assertBad("Er hat eine 34-jährigen Sohn.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -118,6 +118,8 @@ public void testRule() throws IOException {
     assertBad("Tom kann mit fast Allem umgehen.");
     assertBad("Dabei Übersah er sie.");
     assertBad("Der Brief wird am Mittwoch in Brüssel Übergeben.");
+    assertBad("Damit sollen sie die Versorgung in der Region Übernehmen.");
+    assertGood("Ich möchte zwei Kilo Zwiebeln.");
     // "NIL" reading in Morphy that used to confuse CaseRule:
     assertGood("Ein Menschenfreund.");
     // works only thanks to addex.txt:

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -86,7 +86,7 @@ private enum GrammarCategory {
       new PatternTokenBuilder().posRegex("ADJ:AKK:.*").build()  // "Ein für viele wichtiges Anliegen."
     ),
     Arrays.asList(
-      new PatternTokenBuilder().tokenRegex("das|die").build(),
+      new PatternTokenBuilder().tokenRegex("das|die|der").build(),
       new PatternTokenBuilder().token("einem").build(),
       new PatternTokenBuilder().token("Angst").build()  // "Dinge, die/ Etwas, das einem Angst macht"
     ),

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -217,7 +217,6 @@ private static PatternToken posRegex(String posTag) {
   private static final Set<String> sentenceStartExceptions = new HashSet<>();
   static {
     sentenceStartExceptions.add("(");
-    //sentenceStartExceptions.add(":");
     sentenceStartExceptions.add("\"");
     sentenceStartExceptions.add("'");
     sentenceStartExceptions.add("„");

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseRedundancyRule.java
Patch:
@@ -50,10 +50,10 @@ public final String getFileName() {
 
   public PortugueseRedundancyRule(ResourceBundle messages) throws IOException {
     super(messages, new Portuguese());
-    super.setCategory(Categories.STYLE.getCategory(messages));
+    super.setCategory(Categories.REDUNDANCY.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Style);
-    addExamplePair(Example.wrong("<marker>quente como uma fornalha</marker>"),
-                   Example.fixed("<marker>quente</marker>"));
+    addExamplePair(Example.wrong("<marker>duna de areia</marker>"),
+                   Example.fixed("<marker>duna</marker>"));
   }
 
   @Override

File: languagetool-language-modules/en/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -160,7 +160,7 @@ public void testAnalyzedSentence() throws IOException {
     //test soft-hyphen ignoring:
     assertEquals("<S> This[this/DT,B-NP-singular|E-NP-singular] " +
         "is[be/VBZ,B-VP] a[a/DT,B-NP-singular] " +
-        "test­ed[tested/JJ,test/VBD,test/VBN,test­ed/null,I-NP-singular] " +
+        "test­ed[tested/JJ,I-NP-singular] " +
         "sentence[sentence/NN,E-NP-singular].[./.,</S>,O]",
         tool.getAnalyzedSentence("This is a test\u00aded sentence.").toString());
     //test paragraph ends adding

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -166,6 +166,7 @@ public void testIgnoreWord() throws Exception {
     assertTrue(ruleGermany.doIgnoreWord("Secondhandware"));             // from spelling.txt formed compound
     assertTrue(ruleGermany.doIgnoreWord("Feynmandiagramme"));           // from spelling.txt formed compound
     assertTrue(ruleGermany.doIgnoreWord("Helizitätsoperator"));         // from spelling.txt formed compound
+    assertTrue(ruleGermany.doIgnoreWord("Wodkaherstellung"));
     assertFalse(ruleGermany.doIgnoreWord("Helizitätso"));               // from spelling.txt formed compound (second part is too short)
     assertFalse(ruleGermany.doIgnoreWord("Feynmand"));                  // from spelling.txt formed compound (second part is too short)
     MyGermanSpellerRule ruleSwiss = new MyGermanSpellerRule(TestTools.getMessages("de"), GERMAN_CH);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -171,8 +171,10 @@ public void testDetNounRule() throws IOException {
     assertGood("Darf ich Ihren Füller für ein paar Minuten ausleihen?");
     assertGood("Bringen Sie diesen Gepäckaufkleber an Ihrem Gepäck an.");
     assertGood("Extras, die den Wert Ihres Autos erhöhen.");
+    assertGood("Er hat einen 34-jährigen Sohn.");
 
     // incorrect sentences:
+    assertBad("Er hat eine 34-jährigen Sohn.");
     assertBad("Es sind die Tisch.", "dem Tisch", "den Tisch", "der Tisch", "die Tische");
     assertBad("Es sind das Tisch.", "dem Tisch", "den Tisch", "der Tisch");
     assertBad("Es sind die Haus.", "das Haus", "dem Haus", "die Häuser");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -117,6 +117,7 @@ public void testRule() throws IOException {
     assertBad("Unser warten wird sich lohnen.");
     assertBad("Tom kann mit fast Allem umgehen.");
     assertBad("Dabei Übersah er sie.");
+    assertBad("Der Brief wird am Mittwoch in Brüssel Übergeben.");
     // "NIL" reading in Morphy that used to confuse CaseRule:
     assertGood("Ein Menschenfreund.");
     // works only thanks to addex.txt:

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -874,7 +874,7 @@ private boolean isNominalization(int i, AnalyzedTokenReadings[] tokens, String t
           }
         }
       }
-      return (prevToken != null && ("irgendwas".equals(prevTokenStr) || "aufs".equals(prevTokenStr) || "als".equals(prevTokenStr) || isNumber(prevTokenStr))) ||
+      return (prevToken != null && ("irgendwas".equals(prevTokenStr) || "aufs".equals(prevTokenStr) || isNumber(prevTokenStr))) ||
          (hasPartialTag(prevToken, "ART", "PRO:") && !(prevToken.getReadings().size() == 1 && prevToken.hasPartialPosTag("PRO:PER:NOM:"))  && !prevToken.hasPartialPosTag(":STD")) ||  // "die Verurteilten", "etwas Verrücktes", "ihr Bestes"
          (hasPartialTag(prevPrevPrevToken, "ART") && hasPartialTag(prevPrevToken, "PRP") && hasPartialTag(prevToken, "SUB")) || // "die zum Tode Verurteilten"
          (hasPartialTag(prevPrevToken, "PRO:", "PRP") && hasPartialTag(prevToken, "ADJ", "ADV", "PA2", "PA1")) ||  // "etwas schön Verrücktes", "mit aufgewühltem Innerem"
@@ -963,8 +963,8 @@ private boolean isAdjectiveAsNoun(int i, AnalyzedTokenReadings[] tokens, Analyze
     for (AnalyzedToken reading : tokens[i].getReadings()) {
       String posTag = reading.getPOSTag();
       if ((posTag == null || posTag.contains("ADJ")) && !hasNounReading(nextReadings)) {
-        if(posTag == null && hasPartialTag(lowercaseReadings, "PRP:LOK")) {
-          // skip to avoid a false true for, e.g. "Die Zahl ging auf Über 1.000 zurück."
+        if(posTag == null && hasPartialTag(lowercaseReadings, "PRP:LOK", "PA2:PRD:GRU:VER")) {
+          // skip to avoid a false true for, e.g. "Die Zahl ging auf Über 1.000 zurück."/ "Dies gilt schon lange als Überholt."
           // but not for "Er versuchte, Neues zu wagen."
         } else {
           return true;

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -209,6 +209,7 @@ public void testRule() throws IOException {
     assertGood("Das dabei Erlernte und Erlebte ist sehr nützlich.");
     assertBad("Das dabei erlernte und Erlebte Wissen ist sehr nützlich.");
     assertGood("Ein Kapitän verlässt als Letzter das sinkende Schiff.");
+    assertBad("Diese Regelung wurde als Überholt bezeichnet.");
     assertBad("Die Dolmetscherin und Der Vorleser gehen spazieren.");
     assertGood("Es hilft, die Harmonie zwischen Führer und Geführten zu stützen.");
     assertGood("Das Gebäude des Auswärtigen Amts.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -105,6 +105,7 @@ public void testRule() throws IOException {
     assertGood("Es gab Überlebende.");
 
     assertBad("Er ist Groß.");
+    assertBad("Die Zahl ging auf Über 1.000 zurück.");
     assertBad("Er sammelt Große und kleine Tassen.");
     assertBad("Er sammelt Große, mittlere und kleine Tassen.");
     assertBad("Dann will sie mit London Über das Referendum verhandeln.");

File: languagetool-language-modules/en/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -111,7 +111,7 @@ public void testEnglish() throws IOException {
       assertOneError("A test test that should give errors.", lt);
       assertOneError("I can give you more a detailed description.", lt);
       assertTrue(lt.getAllRules().size() > 1000);
-      assertNoError("The sea ice is highly variable - frozen solid during cold, calm weather and broke...", lt);
+      assertNoError("The sea ice is highly variable — frozen solid during cold, calm weather and broke...", lt);
       assertTrue(lt.getAllRules().size() > 3);
       assertOneError("I can give you more a detailed description.", lt);
       lt.disableRule("MORE_A_JJ");

File: languagetool-core/src/main/java/org/languagetool/rules/WrongWordInContextRule.java
Patch:
@@ -222,11 +222,11 @@ private String addBoundaries(String str) {
       return ignoreCase + "\\b(" + str + ")\\b";
     }
     
-    public void setWord(int i, String word) {
+    void setWord(int i, String word) {
       words[i] = Pattern.compile(addBoundaries(word));
     }
     
-    public void setContext(int i, String context) {
+    void setContext(int i, String context) {
       contexts[i] = Pattern.compile(addBoundaries(context));
     }
     

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -171,6 +171,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
         new MultipleWhitespaceRule(messages, this),
         new LongSentenceRule(messages),
         new SentenceWhitespaceRule(messages),
+        new OpenNMTRule(),
         // specific to English:
         new EnglishUnpairedBracketsRule(messages, this),
         new EnglishWordRepeatRule(messages, this),

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -97,6 +97,8 @@ public void testRule() throws IOException {
     assertGood("Er will die Ausgaben für Umweltschutz und Soziales kürzen.");
     assertGood("Die Musicalverfilmung „Die Schöne und das Biest“ bricht mehrere Rekorde.");
 
+    assertBad("Dann will sie mit London Über das Referendum verhandeln.");
+    assertBad("Sie kann sich täglich Über vieles freuen.");
     assertBad("Der Vater (51) Fuhr nach Rom.");
     assertBad("Er müsse Überlegen, wie er das Problem löst.");
     assertBad("Er sagte, dass er Über einen Stein stolperte.");

File: languagetool-standalone/src/test/java/org/languagetool/rules/WordListValidatorTest.java
Patch:
@@ -48,7 +48,7 @@ public class WordListValidatorTest {
   // allow them in general:
   private static final Set<String> VALID_WORDS = new HashSet<>(Arrays.asList(
           "Hidschāb/S",
-	    "Erdoğan/S"
+          "Erdoğan/S"
   ));
 
   @Test

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -825,7 +825,8 @@ private void addRuleMatch(List<RuleMatch> ruleMatches, String msg, AnalyzedToken
   private boolean isNumbering(int i, AnalyzedTokenReadings[] tokens) {
     return i >= 2
             && (tokens[i-1].getToken().equals(")") || tokens[i-1].getToken().equals("]"))
-            && NUMERALS_EN.matcher(tokens[i-2].getToken()).matches();
+            && NUMERALS_EN.matcher(tokens[i-2].getToken()).matches()
+            && !(i > 3 && tokens[i-4].hasPartialPosTag("SUB:")); // no numbering "Der Vater (51) fuhr nach Rom."
   }
 
   private boolean isEllipsis(int i, AnalyzedTokenReadings[] tokens) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -97,6 +97,7 @@ public void testRule() throws IOException {
     assertGood("Er will die Ausgaben für Umweltschutz und Soziales kürzen.");
     assertGood("Die Musicalverfilmung „Die Schöne und das Biest“ bricht mehrere Rekorde.");
 
+    assertBad("Der Vater (51) Fuhr nach Rom.");
     assertBad("Er müsse Überlegen, wie er das Problem löst.");
     assertBad("Er sagte, dass er Über einen Stein stolperte.");
     assertBad("Tom ist etwas über Dreißig.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -95,6 +95,7 @@ public void testRule() throws IOException {
     assertGood("Er fragte, ob das gelingen wird.");
     assertGood("Er mag Obst, wie zum Beispel Apfelsinen.");
     assertGood("Er will die Ausgaben für Umweltschutz und Soziales kürzen.");
+    assertGood("Die Musicalverfilmung „Die Schöne und das Biest“ bricht mehrere Rekorde.");
 
     assertBad("Er müsse Überlegen, wie er das Problem löst.");
     assertBad("Er sagte, dass er Über einen Stein stolperte.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -94,6 +94,7 @@ public void testRule() throws IOException {
     assertGood("Er kann ihr das bieten, was sie verdient.");
     assertGood("Er fragte, ob das gelingen wird.");
     assertGood("Er mag Obst, wie zum Beispel Apfelsinen.");
+    assertGood("Er will die Ausgaben für Umweltschutz und Soziales kürzen.");
 
     assertBad("Er müsse Überlegen, wie er das Problem löst.");
     assertBad("Er sagte, dass er Über einen Stein stolperte.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -847,7 +847,7 @@ private boolean isNominalization(int i, AnalyzedTokenReadings[] tokens) {
         }
       }
       return (prevToken != null && ("irgendwas".equals(prevTokenStr) || "aufs".equals(prevTokenStr) || "als".equals(prevTokenStr) || isNumber(prevTokenStr))) ||
-         (hasPartialTag(prevToken, "ART", "PRO:") && !(prevToken.getReadings().size() == 1 && prevToken.hasPartialPosTag("PRO:PER:NOM:"))) ||  // "die Verurteilten wurden", "etwas Verrücktes", "unser Jüngster", "ihr Bestes"
+         (hasPartialTag(prevToken, "ART", "PRO:") && !(prevToken.getReadings().size() == 1 && prevToken.hasPartialPosTag("PRO:PER:NOM:"))) ||  // "die Verurteilten", "etwas Verrücktes", "ihr Bestes"
          (hasPartialTag(prevPrevPrevToken, "ART") && hasPartialTag(prevPrevToken, "PRP") && hasPartialTag(prevToken, "SUB")) || // "die zum Tode Verurteilten"
          (hasPartialTag(prevPrevToken, "PRO", "PRP") && hasPartialTag(prevToken, "ADJ", "ADV", "PA2", "PA1")) ||  // "etwas schön Verrücktes", "mit aufgewühltem Innerem"
          (hasPartialTag(prevPrevPrevToken, "PRO", "PRP") && hasPartialTag(prevPrevToken, "ADJ", "ADV") && hasPartialTag(prevToken, "ADJ", "ADV", "PA2"));  // "etwas ganz schön Verrücktes"

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -847,7 +847,7 @@ private boolean isNominalization(int i, AnalyzedTokenReadings[] tokens) {
         }
       }
       return (prevToken != null && ("irgendwas".equals(prevTokenStr) || "aufs".equals(prevTokenStr) || "als".equals(prevTokenStr) || isNumber(prevTokenStr))) ||
-         hasPartialTag(prevToken, "ART", "PRO:") ||  // "die Verurteilten wurden", "etwas Verrücktes"
+         (hasPartialTag(prevToken, "ART", "PRO:") && !(prevToken.getReadings().size() == 1 && prevToken.hasPartialPosTag("PRO:PER:NOM:"))) ||  // "die Verurteilten wurden", "etwas Verrücktes", "unser Jüngster", "ihr Bestes"
          (hasPartialTag(prevPrevPrevToken, "ART") && hasPartialTag(prevPrevToken, "PRP") && hasPartialTag(prevToken, "SUB")) || // "die zum Tode Verurteilten"
          (hasPartialTag(prevPrevToken, "PRO", "PRP") && hasPartialTag(prevToken, "ADJ", "ADV", "PA2", "PA1")) ||  // "etwas schön Verrücktes", "mit aufgewühltem Innerem"
          (hasPartialTag(prevPrevPrevToken, "PRO", "PRP") && hasPartialTag(prevPrevToken, "ADJ", "ADV") && hasPartialTag(prevToken, "ADJ", "ADV", "PA2"));  // "etwas ganz schön Verrücktes"

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -96,6 +96,7 @@ public void testRule() throws IOException {
     assertGood("Er mag Obst, wie zum Beispel Apfelsinen.");
 
     assertBad("Er müsse Überlegen, wie er das Problem löst.");
+    assertBad("Er sagte, dass er Über einen Stein stolperte.");
     assertBad("Tom ist etwas über Dreißig.");
     assertBad("Unser warten wird sich lohnen.");
     assertBad("Tom kann mit fast Allem umgehen.");

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseWrongWordInContextRule.java
Patch:
@@ -35,8 +35,8 @@ public PortugueseWrongWordInContextRule(ResourceBundle messages) {
     super(messages);
     super.setCategory(Categories.SEMANTICS.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Grammar);
-    addExamplePair(Example.wrong("A fruta vem da <marker>arvore</marker>."),
-                   Example.fixed("A fruta vem da <marker>árvore</marker>."));
+    addExamplePair(Example.wrong("O acidente <marker>infringiu</marker> grandes danos."),
+                   Example.fixed("O acidente <marker>infligiu</marker> grandes danos."));
   }
   
   @Override

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -93,7 +93,9 @@ public void testRule() throws IOException {
     assertGood("Du musst das wissen, damit du die Prüfung bestehst");
     assertGood("Er kann ihr das bieten, was sie verdient.");
     assertGood("Er fragte, ob das gelingen wird.");
+    assertGood("Er mag Obst, wie zum Beispel Apfelsinen.");
 
+    assertBad("Er müsse Überlegen, wie er das Problem löst.");
     assertBad("Tom ist etwas über Dreißig.");
     assertBad("Unser warten wird sich lohnen.");
     assertBad("Tom kann mit fast Allem umgehen.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -838,7 +838,7 @@ private boolean isNominalization(int i, AnalyzedTokenReadings[] tokens) {
         }
       }
       return (prevToken != null && ("irgendwas".equals(prevTokenStr) || "aufs".equals(prevTokenStr) || "als".equals(prevTokenStr) || isNumber(prevTokenStr))) ||
-         hasPartialTag(prevToken, "ART", "PRO") ||  // "die Verurteilten wurden", "etwas Verrücktes"
+         hasPartialTag(prevToken, "ART", "PRO:") ||  // "die Verurteilten wurden", "etwas Verrücktes"
          (hasPartialTag(prevPrevPrevToken, "ART") && hasPartialTag(prevPrevToken, "PRP") && hasPartialTag(prevToken, "SUB")) || // "die zum Tode Verurteilten"
          (hasPartialTag(prevPrevToken, "PRO", "PRP") && hasPartialTag(prevToken, "ADJ", "ADV", "PA2", "PA1")) ||  // "etwas schön Verrücktes", "mit aufgewühltem Innerem"
          (hasPartialTag(prevPrevPrevToken, "PRO", "PRP") && hasPartialTag(prevPrevToken, "ADJ", "ADV") && hasPartialTag(prevToken, "ADJ", "ADV", "PA2"));  // "etwas ganz schön Verrücktes"

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -97,6 +97,7 @@ public void testRule() throws IOException {
     assertBad("Tom ist etwas über Dreißig.");
     assertBad("Unser warten wird sich lohnen.");
     assertBad("Tom kann mit fast Allem umgehen.");
+    assertBad("Dabei Übersah er sie.");
     // "NIL" reading in Morphy that used to confuse CaseRule:
     assertGood("Ein Menschenfreund.");
     // works only thanks to addex.txt:

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -147,7 +147,7 @@ public void testGetSuggestionsFromSpellingTxt() throws Exception {
     assertThat(ruleSwiss.getSuggestions("Ligafußboll").toString(), is("[Ligafussball, Ligafussballs]"));
     assertThat(ruleSwiss.getSuggestions("konfliktbereid").toString(), is("[konfliktbereit, konfliktbereite]"));
     assertThat(ruleSwiss.getSuggestions("konfliktbereitel").toString(),
-               is("[konfliktbereite, konfliktbereitem, konfliktbereiten, konfliktbereiter, konfliktbereites, konfliktbereit]"));
+               is("[konfliktbereiten, konfliktbereite, konfliktbereiter, konfliktbereitem, konfliktbereites, konfliktbereit]"));
   }
 
   @Test
@@ -249,6 +249,8 @@ public void testGetSuggestions() throws Exception {
     assertCorrection(rule, "bw.", "bzw.");
     assertCorrection(rule, "kan", "kann", "an");
     assertCorrection(rule, "kan.", "kann.", "an.");
+    assertCorrection(rule, "Einzahlungschein", "Einzahlungsschein");
+    assertCorrection(rule, "Arbeitamt", "Arbeitet", "Arbeitsamt");
 
     //TODO: requires morfologik-speller change (suggestions for known words):
     //assertCorrection(rule, "Arbeitamt", "Arbeitsamt");

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractCompoundRule.java
Patch:
@@ -86,7 +86,7 @@ public boolean isHyphenIgnored() {
   @Override
   public RuleMatch[] match(AnalyzedSentence sentence) {
     List<RuleMatch> ruleMatches = new ArrayList<>();
-    AnalyzedTokenReadings[] tokens = sentence.getTokensWithoutWhitespace();
+    AnalyzedTokenReadings[] tokens = getSentenceWithImmunization(sentence).getTokensWithoutWhitespace();
 
     RuleMatch prevRuleMatch = null;
     Queue<AnalyzedTokenReadings> prevTokens = new ArrayBlockingQueue<>(MAX_TERMS);

File: languagetool-core/src/test/java/org/languagetool/rules/AbstractCompoundRuleTest.java
Patch:
@@ -53,7 +53,7 @@ public void check(int expectedErrors, String text, String[] expSuggestions) thro
     assertNotNull("Please initialize langTool!", lt);
     assertNotNull("Please initialize 'rule'!", rule);
     RuleMatch[] ruleMatches = rule.match(lt.getAnalyzedSentence(text));
-    assertEquals("Expected " + expectedErrors + "errors, but got: " + Arrays.toString(ruleMatches),
+    assertEquals("Expected " + expectedErrors + " error(s), but got: " + Arrays.toString(ruleMatches),
             expectedErrors, ruleMatches.length);
     if (expSuggestions != null && expectedErrors != 1) {
       throw new RuntimeException("Sorry, test case can only check suggestion if there's one rule match");

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -564,8 +564,6 @@ protected String cleanXML(String str) {
   }
 
   private boolean match(Rule rule, String sentence, JLanguageTool languageTool) throws IOException {
-	  if(rule.getId()=="KOMMA_ZWISCHEN_HAUPT_UND_NEBENSATZ" )
-		  System.out.println("");
     AnalyzedSentence analyzedSentence = languageTool.getAnalyzedSentence(sentence);
     RuleMatch[] matches = rule.match(analyzedSentence);
     return matches.length > 0;

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/CompoundAwareHunspellRule.java
Patch:
@@ -64,7 +64,7 @@ public List<String> getSuggestions(String word) throws IOException {
     if (StringTools.startsWithUppercase(word) && !StringTools.isAllUppercase(word)) {
       // almost all words can be uppercase because they can appear at the start of a sentence:
       List<String> noSplitLowercaseSuggestions = morfoSpeller.getSuggestions(word.toLowerCase());
-      int pos = noSplitSuggestions.size() == 0 ? 0 : 1;  // first item comes from getSuggestion() above, if any
+      int pos = noSplitSuggestions.isEmpty() ? 0 : 1;  // first item comes from getSuggestion() above, if any
       for (String suggestion : noSplitLowercaseSuggestions) {
         noSplitSuggestions.add(pos, StringTools.uppercaseFirstChar(suggestion));
         // we don't know about the quality of the results here, so mix both lists together,

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -354,7 +354,7 @@ private String baseForThirdPersonSingularVerb(String word) throws IOException {
   @Nullable
   private String getParticipleSuggestion(String word) {
     if (word.startsWith("ge") && word.endsWith("t")) {
-      // strip leading "ge" and trailing "t":
+      // strip leading "ge" and replace trailing "t" with "en":
       String baseform = word.substring(2, word.length()-1) + "en";
       try {
         String participle = getParticipleForBaseform(baseform);

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReplaceOperationNamesRule.java
Patch:
@@ -159,7 +159,7 @@ public final RuleMatch[] match(final AnalyzedSentence sentence) {
                   replacementLemma, "NCMS000", replacementLemma), "NC.P.*");
             } catch (IOException e) {
               throw new RuntimeException("Could not synthesize: "
-                  + replacementLemma + " with tag NC.P.*.");
+                  + replacementLemma + " with tag NC.P.*.", e);
             }
             possibleReplacements.addAll(Arrays.asList(synthesized));
           }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SimpleReplaceVerbsRule.java
Patch:
@@ -142,7 +142,7 @@ public final RuleMatch[] match(final AnalyzedSentence sentence) {
             try {
               analyzedTokenReadingsList = tagger.tag(wordAsArray);
             } catch (IOException e) {
-              throw new RuntimeException("Could not tag sentence: " + wordAsArray );
+              throw new RuntimeException("Could not tag sentence: " + wordAsArray, e);
             }
             if (analyzedTokenReadingsList != null) {
               analyzedTokenReadings = analyzedTokenReadingsList.get(0);
@@ -171,8 +171,8 @@ public final RuleMatch[] match(final AnalyzedSentence sentence) {
                     analyzedToken.getPOSTag());
               } catch (IOException e) {
                 throw new RuntimeException("Could not synthesize: "
-                    + infinitiveAsAnTkn.toString() + " with tag "
-                    + analyzedToken.getPOSTag());
+                    + infinitiveAsAnTkn + " with tag "
+                    + analyzedToken.getPOSTag(), e);
               }
               for (String s : synthesized) {
                 for (int j = 1; j < parts.length; j++) {

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractSimpleReplaceRule.java
Patch:
@@ -41,7 +41,7 @@
  */
 public abstract class AbstractSimpleReplaceRule extends Rule {
 
-  private boolean ignoreTaggedWords = false;
+  protected boolean ignoreTaggedWords = false;
   private boolean checkLemmas = true;
 
   protected abstract Map<String, List<String>> getWrongWords();

File: languagetool-core/src/main/java/org/languagetool/MultiThreadedJLanguageTool.java
Patch:
@@ -218,7 +218,8 @@ private List<Callable<List<RuleMatch>>> createTextCheckCallables(ParagraphHandli
       } else {
         subRules = allRules.subList(firstItem, firstItem + chunkSize);
       }
-      callables.add(new TextCheckCallable(subRules, sentences, analyzedSentences, paraMode, annotatedText, charCount, lineCount, columnCount));
+      // TODO: set listener here:
+      callables.add(new TextCheckCallable(subRules, sentences, analyzedSentences, paraMode, annotatedText, charCount, lineCount, columnCount, null));
       firstItem = firstItem + chunkSize;
     }
     return callables;

File: languagetool-server/src/main/java/org/languagetool/server/V1EOLTextChecker.java
Patch:
@@ -46,7 +46,7 @@ protected void setHeaders(HttpExchange httpExchange) {
   }
 
   @Override
-  protected String getResponse(String text, Language lang, Language motherTongue, List<RuleMatch> matches) {
+  protected String getResponse(String text, Language lang, Language motherTongue, List<RuleMatch> matches, boolean incompleteResult) {
     if (config.getMode() == HTTPServerConfig.Mode.AfterTheDeadline) {
       AtDXmlSerializer serializer = new AtDXmlSerializer();
       return serializer.ruleMatchesToXml(matches, text);

File: languagetool-server/src/main/java/org/languagetool/server/V1TextChecker.java
Patch:
@@ -47,7 +47,7 @@ protected void setHeaders(HttpExchange httpExchange) {
   }
 
   @Override
-  protected String getResponse(String text, Language lang, Language motherTongue, List<RuleMatch> matches) {
+  protected String getResponse(String text, Language lang, Language motherTongue, List<RuleMatch> matches, boolean incompleteResult) {
     if (config.getMode() == HTTPServerConfig.Mode.AfterTheDeadline) {
       AtDXmlSerializer serializer = new AtDXmlSerializer();
       return serializer.ruleMatchesToXml(matches, text);

File: languagetool-server/src/main/java/org/languagetool/server/V2TextChecker.java
Patch:
@@ -48,9 +48,9 @@ protected void setHeaders(HttpExchange httpExchange) {
   }
 
   @Override
-  protected String getResponse(String text, Language lang, Language motherTongue, List<RuleMatch> matches) {
+  protected String getResponse(String text, Language lang, Language motherTongue, List<RuleMatch> matches, boolean incompleteResult) {
     RuleMatchesAsJsonSerializer serializer = new RuleMatchesAsJsonSerializer();
-    return serializer.ruleMatchesToJson(matches, text, CONTEXT_SIZE, lang);
+    return serializer.ruleMatchesToJson(matches, text, CONTEXT_SIZE, lang, incompleteResult);
   }
 
   @NotNull

File: languagetool-server/src/main/java/org/languagetool/server/TextChecker.java
Patch:
@@ -143,13 +143,13 @@ public List<RuleMatch> call() throws Exception {
     }
 
     setHeaders(httpExchange);
-    String xmlResponse = getResponse(text, lang, motherTongue, matches);
+    String response = getResponse(text, lang, motherTongue, matches);
     String messageSent = "sent";
     String languageMessage = lang.getShortCodeWithCountryAndVariant();
     String referrer = httpExchange.getRequestHeaders().getFirst("Referer");
     try {
-      httpExchange.sendResponseHeaders(HttpURLConnection.HTTP_OK, xmlResponse.getBytes(ENCODING).length);
-      httpExchange.getResponseBody().write(xmlResponse.getBytes(ENCODING));
+      httpExchange.sendResponseHeaders(HttpURLConnection.HTTP_OK, response.getBytes(ENCODING).length);
+      httpExchange.getResponseBody().write(response.getBytes(ENCODING));
     } catch (IOException exception) {
       // the client is disconnected
       messageSent = "notSent: " + exception.getMessage();

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseReplaceRule2.java
Patch:
@@ -50,7 +50,7 @@ public final String getFileName() {
 
   public PortugueseReplaceRule2(ResourceBundle messages) throws IOException {
     super(messages, new Portuguese());
-    super.setCategory(Categories.MISC.getCategory(messages));
+    super.setCategory(Categories.STYLE.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.LocaleViolation);
     addExamplePair(Example.wrong("<marker>curriculum vitae</marker>"),
                    Example.fixed("<marker>currículo</marker>"));

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseAccentuationCheckRule.java
Patch:
@@ -40,7 +40,7 @@
  * @author Jaume Ortolà i Font
  * l18n by Tiago F. Santos
  * TODO Verify all exceptions that apply to Portuguese
- * FIXME Cnverte all chunking tags to the ones used in Portuguese
+ * FIXME Convert all chunking tags to the ones used in Portuguese
  */
 public class PortugueseAccentuationCheckRule extends Rule {
 

File: languagetool-core/src/test/java/org/languagetool/rules/GenericUnpairedBracketsRuleTest.java
Patch:
@@ -75,7 +75,7 @@ public void testRuleMatchPositions() throws IOException {
     assertThat(match1.getToPos(), is(6));
     assertThat(match1.getLine(), is(0));
     assertThat(match1.getEndLine(), is(0));
-    assertThat(match1.getColumn(), is(6));
+    assertThat(match1.getColumn(), is(5));
     assertThat(match1.getEndColumn(), is(6));
 
     RuleMatch match2 = lt.check("This.\nSome stuff.\nIt »is a test.").get(0);

File: languagetool-core/src/test/java/org/languagetool/rules/GenericUnpairedBracketsRuleTest.java
Patch:
@@ -75,7 +75,7 @@ public void testRuleMatchPositions() throws IOException {
     assertThat(match1.getToPos(), is(6));
     assertThat(match1.getLine(), is(0));
     assertThat(match1.getEndLine(), is(0));
-    assertThat(match1.getColumn(), is(5));
+    assertThat(match1.getColumn(), is(6));
     assertThat(match1.getEndColumn(), is(6));
 
     RuleMatch match2 = lt.check("This.\nSome stuff.\nIt »is a test.").get(0);

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServerConfig.java
Patch:
@@ -128,15 +128,15 @@ private void parseConfigFile(File file, boolean loadLangModel) {
         trustXForwardForHeader = Boolean.valueOf(getOptionalProperty(props, "trustXForwardForHeader", "false"));
         maxWorkQueueSize = Integer.parseInt(getOptionalProperty(props, "maxWorkQueueSize", "0"));
         if (maxWorkQueueSize < 0) {
-          throw new IllegalArgumentException("Max queue size must be >= 0: " + maxWorkQueueSize);
+          throw new IllegalArgumentException("maxWorkQueueSize must be >= 0: " + maxWorkQueueSize);
         }
         String langModel = getOptionalProperty(props, "languageModel", null);
         if (langModel != null && loadLangModel) {
           setLanguageModelDirectory(langModel);
         }
         maxCheckThreads = Integer.parseInt(getOptionalProperty(props, "maxCheckThreads", "10"));
         if (maxCheckThreads < 1) {
-          throw new IllegalArgumentException("Invalid value for maxCheckThreads: " + maxCheckThreads);
+          throw new IllegalArgumentException("Invalid value for maxCheckThreads, must be >= 1: " + maxCheckThreads);
         }
         mode = getOptionalProperty(props, "mode", "LanguageTool").equalsIgnoreCase("AfterTheDeadline") ? Mode.AfterTheDeadline : Mode.LanguageTool;
         if (mode == Mode.AfterTheDeadline) {
@@ -152,7 +152,7 @@ private void parseConfigFile(File file, boolean loadLangModel) {
         }
         cacheSize = Integer.parseInt(getOptionalProperty(props, "cacheSize", "0"));
         if (cacheSize < 0) {
-          throw new IllegalArgumentException("Invalid cacheSize " + cacheSize + ", use 0 to deactivate cache");
+          throw new IllegalArgumentException("Invalid value for cacheSize " + cacheSize + ", use 0 to deactivate cache");
         }
       }
     } catch (IOException e) {

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerMultiLangLoadTest.java
Patch:
@@ -65,6 +65,9 @@ public void testHTTPServer() throws Exception {
         System.err.println("Using " + content.length() + " bytes of data for " + language);
       }
     }
+    if (langCodeToText.size() == 0) {
+      throw new RuntimeException("No input data found in " + dir);
+    }
     System.out.println("Testing " + langCodeToText.keySet().size() + " languages and variants");
     //super.testHTTPServer();  // start server in this JVM
     super.doTest();  // assume server has been started manually in its own JVM

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -139,7 +139,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
                 Example.fixed("Tomamos café<marker>,</marker> queijo, bolachas e uvas")),
             new GenericUnpairedBracketsRule(messages),
             new HunspellRule(messages, this),
-            new LongSentenceRule(messages),
+            new LongSentenceRule(messages, 45, true),
             new UppercaseSentenceStartRule(messages, this,
                 Example.wrong("Esta casa é velha. <marker>foi</marker> construida em 1950."),
                 Example.fixed("Esta casa é velha. <marker>Foi</marker> construida em 1950.")),
@@ -198,6 +198,7 @@ public int getPriorityForId(String id) {
       case "REPEATED_WORDS":            return -90;
       case "REPEATED_WORDS_3X":         return -91;
       case "WIKIPEDIA_COMMON_ERRORS":   return -100;
+      case "TOO_LONG_SENTENCE":         return -1000;
     }
     return 0;
   }

File: languagetool-server/src/main/java/org/languagetool/server/V2TextChecker.java
Patch:
@@ -79,7 +79,7 @@ protected boolean getLanguageAutoDetect(Map<String, String> parameters) {
   protected void checkParams(Map<String, String> parameters) {
     super.checkParams(parameters);
     if (StringTools.isEmpty(parameters.get("language"))) {
-      throw new IllegalArgumentException("Missing 'language' parameter");
+      throw new IllegalArgumentException("Missing 'language' parameter, e.g. 'language=en-US' for American English or 'language=fr' for French");
     }
     if (parameters.get("enabled") != null) {
       throw new IllegalArgumentException("You specified 'enabled' but the parameter is now called 'enabledRules' in v2 of the API");

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -164,7 +164,7 @@ public int getPriorityForId(String id) {
       case "ACCENTUATION_CHECK": return 10;
       case "CONCORDANCES_DET_NOM": return 5;
       case "REGIONAL_VERBS": return -10;
-      case "FALTA_ELEMENT_ENTRE_VERB": return -10;
+      case "FALTA_ELEMENT_ENTRE_VERBS": return -10;
       case "FALTA_COMA_FRASE_CONDICIONAL": return -20;
       case "MORFOLOGIK_RULE_CA_ES": return -100;
       case "UPPERCASE_SENTENCE_START": return -500;

File: languagetool-language-modules/ca/src/test/java/org/languagetool/tokenizers/ca/CatalanSentenceTokenizerTest.java
Patch:
@@ -49,7 +49,7 @@ public final void testTokenize() {
             "»La Maria va engegar el cotxe");
     testSplit("diu que va dir. ", "A mi em feia estrany.");
     
-    // N.
+    // N., t.
     testSplit("Vés-te’n. ", "A mi em feia estrany.");  
     testSplit("Vés-te'n. ", "A mi em feia estrany.");
     testSplit("VÉS-TE'N. ", "A mi em feia estrany.");
@@ -59,6 +59,8 @@ public final void testTokenize() {
     testSplit(" n. 3");
     testSplit("n. 3");
     testSplit("(\"n. 3\".");
+    testSplit("En el t. 2 de la col·lecció");
+    testSplit("Llança't. ", "Fes-ho.");
     
     // Initials
     testSplit("A l'atenció d'A. Comes.");

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -191,7 +191,7 @@ public void close() throws Exception {
   @Override
   public int getPriorityForId(String id) {
     switch (id) {
-      case "FRAGMENT_TWO_ARTICLES":     return 50
+      case "FRAGMENT_TWO_ARTICLES":     return 50;
       case "T-V_DISTINCTION":           return -20;
       case "T-V_DISTINCTION_ALL":       return -21;
       case "REPEATED_WORDS":            return -90;

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseClicheRule.java
Patch:
@@ -34,7 +34,7 @@
  * <code>/ro/replace.txt</code>.
  *
  * @author Tiago F. Santos 
- * since 3.6
+ * @since 3.6
  */
 public class PortugueseClicheRule extends AbstractSimpleReplaceRule2 {
 

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseReplaceRule2.java
Patch:
@@ -34,7 +34,7 @@
  * <code>/ro/replace.txt</code>.
  *
  * @author Tiago F. Santos (localized from romanian)
- * since 3.6
+ * @since 3.6
  */
 public class PortugueseReplaceRule2 extends AbstractSimpleReplaceRule2 {
 

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseWikipediaRule.java
Patch:
@@ -34,7 +34,7 @@
  * <code>/ro/replace.txt</code>.
  *
  * @author Tiago F. Santos 
- * since 3.6
+ * @since 3.6
  */
 public class PortugueseWikipediaRule extends AbstractSimpleReplaceRule2 {
 

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -193,6 +193,8 @@ public int getPriorityForId(String id) {
     switch (id) {
       case "T-V_DISTINCTION": return -10;
       case "T-V_DISTINCTION_ALL": return -11;
+      case "REPEATED_WORDS": return -90;
+      case "REPEATED_WORDS_3X": return -91;
       case "WIKIPEDIA_COMMON_ERRORS": return -100;
     }
     return 0;

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/TokenInflectionAgreementRule.java
Patch:
@@ -184,7 +184,7 @@ else if ( nounPosTag.equals(JLanguageTool.SENTENCE_END_TAGNAME)
       }
 
       if( DEBUG ) {
-        System.err.println(MessageFormat.format("=== Checking:\n\t{0}\n\t{0}", adjTokenReadings, slaveTokenReadings));
+        System.err.println(MessageFormat.format("=== Checking:\n\t{0}\n\t{1}", adjTokenReadings, slaveTokenReadings));
       }
 
       // perform the check

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/TokenInflectionAgreementRule.java
Patch:
@@ -213,7 +213,7 @@ else if ( nounPosTag.equals(JLanguageTool.SENTENCE_END_TAGNAME)
         if( PosTagHelper.hasPosTagPart(adjTokenReadings, ":m:v_rod")
             && tokens[i].getToken().matches(".*[ую]")
             && PosTagHelper.hasPosTag(slaveTokenReadings, "noun.*:m:v_dav.*") ) {
-          msg += ". Можливо вжито неунормований родовий відмінок ч.р. з закінченням -у/ю замість -а/я?";
+          msg += ". Можливо вжито невнормований родовий відмінок ч.р. з закінченням -у/-ю замість -а/-я (така тенденція є в сучасній мові)?";
         }
 
         RuleMatch potentialRuleMatch = new RuleMatch(this, adjAnalyzedTokenReadings.getStartPos(), tokenReadings.getEndPos(), msg, getShort());

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/TokenInflectionAgreementRule.java
Patch:
@@ -184,7 +184,7 @@ else if ( nounPosTag.equals(JLanguageTool.SENTENCE_END_TAGNAME)
       }
 
       if( DEBUG ) {
-        System.err.println(MessageFormat.format("=== Checking:\n\t{}\n\t{}", adjTokenReadings, slaveTokenReadings));
+        System.err.println(MessageFormat.format("=== Checking:\n\t{0}\n\t{0}", adjTokenReadings, slaveTokenReadings));
       }
 
       // perform the check
@@ -201,7 +201,7 @@ else if ( nounPosTag.equals(JLanguageTool.SENTENCE_END_TAGNAME)
         }
 
         if( DEBUG ) {
-          System.err.println(MessageFormat.format("=== Found:\n\t{}\n\t",
+          System.err.println(MessageFormat.format("=== Found:\n\t{0}\n\t",
             adjAnalyzedTokenReadings.getToken() + ": " + masterInflections + " // " + adjAnalyzedTokenReadings,
             slaveTokenReadings.get(0).getToken() + ": " + slaveInflections+ " // " + slaveTokenReadings));
         }

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -192,7 +192,7 @@ public void close() throws Exception {
   public int getPriorityForId(String id) {
     switch (id) {
       case "T-V_DISTINCTION": return -10;
-      case "V_DISTINCTION_ALL": return -11;
+      case "T-V_DISTINCTION_ALL": return -11;
       case "WIKIPEDIA_COMMON_ERRORS": return -100;
     }
     return 0;

File: languagetool-commandline/src/main/java/org/languagetool/commandline/CommandLineTools.java
Patch:
@@ -206,7 +206,6 @@ private static void printMatches(List<RuleMatch> ruleMatches,
    * @param srcLt Source JLanguageTool (used to analyze the text).
    * @param trgLt Target JLanguageTool (used to analyze the text).
    * @param bRules  Bilingual rules used in addition to target standard rules.
-   * @param apiFormat Whether API format should be used.
    * @return The number of rules matched on the bitext.
    * @since 1.0.1
    */

File: languagetool-language-modules/pt/src/test/java/org/languagetool/tagging/pt/PortugueseTaggerTest.java
Patch:
@@ -48,7 +48,7 @@ public void testTagger() throws IOException {
         "Estes/[este]DD0MP0|Estes/[este]PD0MP000 -- "
             + "são/[ser]VMIP3P0|são/[são]AQ0MS0|são/[são]NCMS000 -- "
             + "os/[o]DA0MP0|os/[o]PD0MP000|os/[o]PP3MPA00 -- "
-            + "meus/[meu]DP1MPS|meus/[meu]PX1MP0S0 -- "
+            + "meus/[meu]AP0MP1S|meus/[meu]DP1MPS -- "
             + "amigos/[amigo]AQ0MP0|amigos/[amigo]NCMP000", tokenizer, tagger);
   }
 }

File: languagetool-language-modules/de/src/main/java/org/languagetool/tagging/de/GermanTagger.java
Patch:
@@ -84,10 +84,10 @@ public List<AnalyzedTokenReadings> tag(List<String> sentenceTokens, boolean igno
     for (String word : sentenceTokens) {
       List<AnalyzedToken> l = new ArrayList<>();
       List<TaggedWord> taggerTokens = getWordTagger().tag(word);
-      if (firstWord && taggerTokens.size() == 0 && ignoreCase) { // e.g. "Das" -> "das" at start of sentence
+      if (firstWord && taggerTokens.isEmpty() && ignoreCase) { // e.g. "Das" -> "das" at start of sentence
         taggerTokens = getWordTagger().tag(word.toLowerCase());
         firstWord = word.matches("^\\W?$");
-      } else if (pos == 0 && ignoreCase && word.endsWith("en")) {   // "Haben", "Sollen", "Können" etc. at start of sentence
+      } else if (pos == 0 && ignoreCase) {   // "Haben", "Sollen", "Können", "Gerade" etc. at start of sentence
         taggerTokens.addAll(getWordTagger().tag(word.toLowerCase()));
       }
       if (taggerTokens.size() > 0) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/chunking/GermanChunkerTest.java
Patch:
@@ -92,7 +92,7 @@ public void testChunking() throws Exception {
     assertFullChunks("Nach/PP sachlichen/PP und/PP militärischen/PP Kriterien/PP war das unnötig.");
     assertFullChunks("Mit/PP über/PP 1000/PP Handschriften/PP ist es die/NPS größte/NPS Sammlung/NPS");
     assertFullChunks("Es gab Beschwerden/NPP über/PP laufende/PP Sanierungsmaßnahmen/PP");
-    assertFullChunks("Gesteigerte/NPS Effizienz/NPS durch/PP Einsatz/PP größerer/PP Maschinen/PP und/PP bessere/PP Kapazitätsplanung/PP");
+    assertFullChunks("Gesteigerte/B Effizienz/I durch/PP Einsatz/PP größerer/PP Maschinen/PP und/PP bessere/PP Kapazitätsplanung/PP");
     assertFullChunks("Bei/PP sehr/PP guten/PP Beobachtungsbedingungen/PP bin ich dabei");
     assertFullChunks("Die/NPP Beziehungen/NPP zwischen/NPP Kanada/NPP und/NPP dem/NPP Iran/NPP sind unterkühlt");
     assertFullChunks("Die/PP darauffolgenden/PP Jahre/PP war es kalt");

File: languagetool-language-modules/de/src/test/java/org/languagetool/tagging/de/GermanTaggerTest.java
Patch:
@@ -62,6 +62,7 @@ public void testTagger() throws IOException {
     // checks for github issue #635: Some German verbs on the beginning of a sentences are identified only as substantive
     assertTrue(tagger.tag(Collections.singletonList("Haben"), true).toString().contains("VER"));
     assertTrue(tagger.tag(Collections.singletonList("Können"), true).toString().contains("VER"));
+    assertTrue(tagger.tag(Collections.singletonList("Gerade"), true).toString().contains("ADJ"));
 
     // from both german.dict and added.txt:
     AnalyzedTokenReadings aToken4 = tagger.lookup("Interessen");

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -155,6 +155,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
             new PortugueseReplaceRule(messages),
             new PortugueseReplaceRule2(messages),
             new PortugueseClicheRule(messages),
+            new PortugueseWikipediaRule(messages),
             new PortugueseWordRepeatRule(messages, this),
             new PortugueseWordRepeatBeginningRule(messages, this),
             new PortugueseAccentuationCheckRule(messages)

File: languagetool-core/src/main/java/org/languagetool/rules/CleanOverlappingFilter.java
Patch:
@@ -52,14 +52,13 @@ public final List<RuleMatch> filter(List<RuleMatch> ruleMatches) {
         throw new RuntimeException(
             "The list of rule matches is not ordered. Make sure it is sorted by start position.");
       }
-      // no overlapping
-      if (ruleMatch.getFromPos() > prevRuleMatch.getToPos()) {
+      // no overlapping (juxtaposed errors are not removed)
+      if (ruleMatch.getFromPos() >= prevRuleMatch.getToPos()) {
         cleanList.add(prevRuleMatch);
         prevRuleMatch = ruleMatch;
         continue;
       }
       //overlapping
-      
       // get priorities
       int currentPriority = getMatchPriority(ruleMatch);
       int prevPriority = getMatchPriority(prevRuleMatch);

File: languagetool-commandline/src/main/java/org/languagetool/commandline/Main.java
Patch:
@@ -77,6 +77,7 @@ class Main {
     srcLt = null;
     bRules = null;
     lt = new MultiThreadedJLanguageTool(options.getLanguage(), options.getMotherTongue());
+    lt.setCleanOverlappingMatches(false);
     if (options.getRuleFile() != null) {
       addExternalRules(options.getRuleFile());
     }

File: languagetool-core/src/test/java/org/languagetool/MultiThreadedJLanguageToolTest.java
Patch:
@@ -41,12 +41,14 @@ public class MultiThreadedJLanguageToolTest {
   @Test
   public void testCheck() throws IOException {
     MultiThreadedJLanguageTool lt1 = new MultiThreadedJLanguageTool(new Demo());
+    lt1.setCleanOverlappingMatches(false);
     List<String> ruleMatchIds1 = getRuleMatchIds(lt1);
-    assertEquals(9, ruleMatchIds1.size());
+    assertEquals(9, ruleMatchIds1.size()); 
     assertEquals(4, lt1.getSentenceCount());
     lt1.shutdown();
 
     JLanguageTool lt2 = new JLanguageTool(new Demo());
+    lt2.setCleanOverlappingMatches(false);
     List<String> ruleMatchIds2 = getRuleMatchIds(lt2);
     assertEquals(ruleMatchIds1, ruleMatchIds2);
     assertEquals(4, lt1.getSentenceCount());

File: languagetool-language-modules/pl/src/test/java/org/languagetool/tools/ToolsTest.java
Patch:
@@ -47,6 +47,7 @@ public void testCheck() throws IOException, ParserConfigurationException, SAXExc
   @Test
   public void testCorrect() throws IOException, ParserConfigurationException, SAXException {
     JLanguageTool tool = new JLanguageTool(new Polish());
+    tool.setCleanOverlappingMatches(false);
 
     String correct = Tools.correctText("To jest całkowicie prawidłowe zdanie.", tool);
     assertEquals("To jest całkowicie prawidłowe zdanie.", correct);

File: languagetool-commandline/src/main/java/org/languagetool/commandline/Main.java
Patch:
@@ -77,6 +77,7 @@ class Main {
     srcLt = null;
     bRules = null;
     lt = new MultiThreadedJLanguageTool(options.getLanguage(), options.getMotherTongue());
+    lt.setCleanOverlappingMatches(false);
     if (options.getRuleFile() != null) {
       addExternalRules(options.getRuleFile());
     }

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -54,7 +54,7 @@ public void testRule() throws IOException {
     //assertCorrect("es van agenollar i prosternar");
     //assertCorrect("Una equivocació tan gran no es pot callar.");
     //assertCorrect(" és del tot necessari si no es vol caure en una religió alienant");
-
+    assertCorrect("T'enduràs això.");
     assertCorrect("Alguns ens adonàrem que era veritat");
     assertCorrect("M'he baixat moltes imatges");
     assertCorrect("baixeu-vos l'Aspell des de http://aspell.net/win32/");

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseAccentuationCheckRule.java
Patch:
@@ -95,7 +95,7 @@ public PortugueseAccentuationCheckRule(ResourceBundle messages) throws IOExcepti
 
   @Override
   public String getId() {
-    return "ACCENTUATION_CHECK_2";
+    return "ACCENTUATION_CHECK_PT";
   }
 
   @Override

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugueseAccentuationCheckRule.java
Patch:
@@ -95,7 +95,7 @@ public PortugueseAccentuationCheckRule(ResourceBundle messages) throws IOExcepti
 
   @Override
   public String getId() {
-    return "ACCENTUATION_CHECK";
+    return "ACCENTUATION_CHECK_2";
   }
 
   @Override

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -153,7 +153,8 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
             new PortugueseReplaceRule2(messages),
             new PortugueseClicheRule(messages),
             new PortugueseWordRepeatRule(messages, this),
-            new PortugueseWordRepeatBeginningRule(messages, this)
+            new PortugueseWordRepeatBeginningRule(messages, this),
+            new PortugueseAccentuationCheckRule(messages)
             //new PortugueseWrongWordInContextRule(messages)
     );
   }

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugalPortugueseReplaceRule.java
Patch:
@@ -19,6 +19,7 @@
 package org.languagetool.rules.pt;
 
 import org.languagetool.rules.AbstractSimpleReplaceRule;
+import org.languagetool.rules.Categories;
 import org.languagetool.rules.Example;
 import org.languagetool.rules.ITSIssueType;
 
@@ -51,6 +52,7 @@ protected Map<String, List<String>> getWrongWords() {
 
   public PortugalPortugueseReplaceRule(ResourceBundle messages) throws IOException {
     super(messages);
+    super.setCategory(Categories.MISC.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.LocaleViolation);
     addExamplePair(Example.wrong("Onde está o <marker>banheiro</marker>?"),
                    Example.fixed("Onde está o <marker>toilet</marker>?"));

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -90,7 +90,7 @@ public void testSupportsLanguage() {
   }
   
   @Test
-  public void shortMessageIsSmallerThanErrorMessage() throws IOException {
+  public void shortMessageIsLongerThanErrorMessage() throws IOException {
     for (Language lang : Languages.get()) {
       MultiThreadedJLanguageTool languageTool = new MultiThreadedJLanguageTool(lang);
       for (AbstractPatternRule rule : getAllPatternRules(lang, languageTool)) {

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/dumpcheck/WikipediaSentenceSource.java
Patch:
@@ -66,6 +66,7 @@ public WikipediaSentenceSource(InputStream xmlInput, Language language, Pattern
     super(language, filter);
     textFilter.enableMapping(false);  // improves performance
     try {
+      System.setProperty("jdk.xml.totalEntitySizeLimit", String.valueOf(Integer.MAX_VALUE));  // see https://github.com/dbpedia/extraction-framework/issues/487
       XMLInputFactory factory = XMLInputFactory.newInstance();
       reader = factory.createXMLEventReader(xmlInput);
       sentenceTokenizer = language.getSentenceTokenizer();

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/HiddenCharacterRule.java
Patch:
@@ -31,7 +31,7 @@
 import org.languagetool.rules.RuleMatch;
 
 /**
- * A rule that matches words Latin and Cyrillic characters in them
+ * A rule that finds hidden characters in the text
  * 
  * @author Andriy Rysin
  * @since 2.9

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -86,7 +86,8 @@ protected void runGrammarRulesFromXmlTest(Language ignoredLanguage) throws IOExc
   }
   
   /**
-   * To be called from language modules. Language.REAL_LANGUAGES knows only the languages that's in the classpath.
+   * To be called from language modules. Languages.get() only knows the languages that are in the classpath,
+   * and that's only the demo language for languagetool-core.
    */
   protected void runGrammarRulesFromXmlTest() throws IOException {
     for (Language lang : Languages.get()) {

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -119,8 +119,8 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
             //Specific to Portuguese:
             new PostReformPortugueseCompoundRule(messages),
             new PortugueseReplaceRule(messages),
-            new PortugueseWordRepeatRule(messages, this),
-            new PortugueseWrongWordInContextRule(messages)
+            new PortugueseWordRepeatRule(messages, this)
+            //new PortugueseWrongWordInContextRule(messages)
     );
   }
 

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugalPortugueseReplaceRule.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.languagetool.rules.pt;
 
-import org.apache.commons.lang.StringUtils;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Example;
 import org.languagetool.rules.ITSIssueType;
@@ -74,7 +73,7 @@ public String getShort() {
   @Override
   public String getMessage(String tokenStr, List<String> replacements) {
     return tokenStr + " é uma expressão brasileira, em Português de Portugal utiliza-se: "
-        + StringUtils.join(replacements, ", ") + ".";
+        + String.join(", ", replacements) + ".";
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/rules/UppercaseSentenceStartRule.java
Patch:
@@ -107,7 +107,7 @@ public final RuleMatch[] match(AnalyzedSentence sentence) {
     }
 
     String lastToken = tokens[tokens.length - 1].getToken();
-    if (tokens.length >= 2 && WHITESPACE_OR_QUOTE.matcher(lastToken).matches()) {
+    if (WHITESPACE_OR_QUOTE.matcher(lastToken).matches()) {
       // ignore trailing whitespace or quote
       lastToken = tokens[tokens.length - 2].getToken();
     }

File: languagetool-core/src/test/java/org/languagetool/languagemodel/LanguageModelTest.java
Patch:
@@ -59,7 +59,7 @@ protected void testPerformance(LuceneLanguageModel model, int ngramLength) throw
           long timeMillis = timeMicros/1000;
           if (ngramLength == 2) {
             System.out.println(count + "\t\t" + prevWord + " " + word + ": " + timeMicros + "µs = " + timeMillis + "ms");
-          } else if (ngramLength == 3) {
+          } else {
             System.out.println(count + "\t\t" + prevPrevWord + " " + prevWord + " " + word + ": " + timeMicros + "µs = " + timeMillis + "ms");
           }
           if (i > SKIP_FIRST_ITEMS) {

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/HiddenCharacterRule.java
Patch:
@@ -31,7 +31,7 @@
 import org.languagetool.rules.RuleMatch;
 
 /**
- * A rule that matches words Latin and Cyrillic characters in them
+ * A rule that finds hidden characters in the text
  * 
  * @author Andriy Rysin
  * @since 2.9

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -86,7 +86,8 @@ protected void runGrammarRulesFromXmlTest(Language ignoredLanguage) throws IOExc
   }
   
   /**
-   * To be called from language modules. Language.REAL_LANGUAGES knows only the languages that's in the classpath.
+   * To be called from language modules. Languages.get() only knows the languages that are in the classpath,
+   * and that's only the demo language for languagetool-core.
    */
   protected void runGrammarRulesFromXmlTest() throws IOException {
     for (Language lang : Languages.get()) {

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -119,8 +119,8 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
             //Specific to Portuguese:
             new PostReformPortugueseCompoundRule(messages),
             new PortugueseReplaceRule(messages),
-            new PortugueseWordRepeatRule(messages, this),
-            new PortugueseWrongWordInContextRule(messages)
+            new PortugueseWordRepeatRule(messages, this)
+            //new PortugueseWrongWordInContextRule(messages)
     );
   }
 

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PortugalPortugueseReplaceRule.java
Patch:
@@ -18,7 +18,6 @@
  */
 package org.languagetool.rules.pt;
 
-import org.apache.commons.lang.StringUtils;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Example;
 import org.languagetool.rules.ITSIssueType;
@@ -74,7 +73,7 @@ public String getShort() {
   @Override
   public String getMessage(String tokenStr, List<String> replacements) {
     return tokenStr + " é uma expressão brasileira, em Português de Portugal utiliza-se: "
-        + StringUtils.join(replacements, ", ") + ".";
+        + String.join(", ", replacements) + ".";
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/rules/UppercaseSentenceStartRule.java
Patch:
@@ -107,7 +107,7 @@ public final RuleMatch[] match(AnalyzedSentence sentence) {
     }
 
     String lastToken = tokens[tokens.length - 1].getToken();
-    if (tokens.length >= 2 && WHITESPACE_OR_QUOTE.matcher(lastToken).matches()) {
+    if (WHITESPACE_OR_QUOTE.matcher(lastToken).matches()) {
       // ignore trailing whitespace or quote
       lastToken = tokens[tokens.length - 2].getToken();
     }

File: languagetool-core/src/test/java/org/languagetool/languagemodel/LanguageModelTest.java
Patch:
@@ -59,7 +59,7 @@ protected void testPerformance(LuceneLanguageModel model, int ngramLength) throw
           long timeMillis = timeMicros/1000;
           if (ngramLength == 2) {
             System.out.println(count + "\t\t" + prevWord + " " + word + ": " + timeMicros + "µs = " + timeMillis + "ms");
-          } else if (ngramLength == 3) {
+          } else {
             System.out.println(count + "\t\t" + prevPrevWord + " " + prevWord + " " + word + ": " + timeMicros + "µs = " + timeMillis + "ms");
           }
           if (i > SKIP_FIRST_ITEMS) {

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -181,7 +181,7 @@ protected List<RuleMatch> getRuleMatches(String word, int startPos) throws IOExc
           messages.getString("desc_spelling_short"));
       List<String> suggestions = speller1.getSuggestions(word);
       if (suggestions.size() == 0 && word.length() >= 5) {
-        // speller1 uses a maximum edit distance of 1, it won't find suggestion for "garentee", "greatful" ezc.
+        // speller1 uses a maximum edit distance of 1, it won't find suggestion for "garentee", "greatful" etc.
         suggestions.addAll(speller2.getSuggestions(word));
       }
       suggestions.addAll(0, getAdditionalTopSuggestions(suggestions, word));

File: languagetool-language-modules/el/src/main/java/org/languagetool/tokenizers/el/GreekWordTokenizerImpl.java
Patch:
@@ -142,7 +142,7 @@ private static int zzUnpackTrans(String packed, int offset, int [] result) {
 
   /* error messages for the codes above */
   private static final String ZZ_ERROR_MSG[] = {
-    "Unkown internal scanner error",
+    "Unknown internal scanner error",
     "Error: could not match input",
     "Error: pushback value was too large"
   };
@@ -413,7 +413,7 @@ public final int yylength() {
 
 
   /**
-   * Reports an error that occured while scanning.
+   * Reports an error that occurred while scanning.
    *
    * In a wellformed scanner (no or only correct usage of 
    * yypushback(int) and a match-all fallback rule) this method 

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PostReformPortugueseCompoundRule.java
Patch:
@@ -42,7 +42,7 @@ public PostReformPortugueseCompoundRule(ResourceBundle messages) throws IOExcept
 
   @Override
   public String getId() {
-    return "PT_COMPOUNDS_PRE_REFORM";
+    return "PT_COMPOUNDS_POST_REFORM";
   }
 
   @Override

File: languagetool-language-modules/pt/src/main/java/org/languagetool/rules/pt/PreReformPortugueseCompoundRule.java
Patch:
@@ -42,7 +42,7 @@ public PreReformPortugueseCompoundRule(ResourceBundle messages) throws IOExcepti
 
   @Override
   public String getId() {
-    return "PT_COMPOUNDS_POST_REFORM";
+    return "PT_COMPOUNDS_PRE_REFORM";
   }
 
   @Override

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -23,7 +23,7 @@
 import org.languagetool.rules.*;
 import org.languagetool.synthesis.Synthesizer;
 import org.languagetool.synthesis.pt.PortugueseSynthesizer;
-import org.languagetool.rules.pt.PreReformPortugueseCompoundRule;
+import org.languagetool.rules.pt.PostReformPortugueseCompoundRule;
 import org.languagetool.rules.pt.PortugueseReplaceRule;
 import org.languagetool.rules.spelling.hunspell.HunspellNoSuggestionRule;
 import org.languagetool.tagging.Tagger;
@@ -117,7 +117,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
             new MultipleWhitespaceRule(messages, this),
             new SentenceWhitespaceRule(messages),
             //Specific to Portuguese:
-            new PreReformPortugueseCompoundRule(messages),
+            new PostReformPortugueseCompoundRule(messages),
             new PortugueseReplaceRule(messages)
     );
   }

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleMatcher.java
Patch:
@@ -279,7 +279,7 @@ private String formatMatches(AnalyzedTokenReadings[] tokenReadings,
       if (backslashPos >= 0 && StringTools.isPositiveNumber(errorMessage.charAt(backslashPos + 1))) {
         int numLen = 1;
         while (backslashPos + numLen < errorMessage.length()
-            && StringTools.isPositiveNumber(errorMessage.charAt(backslashPos + numLen))) {
+            && Character.isDigit(errorMessage.charAt(backslashPos + numLen))) {
           numLen++;
         }
         int j = Integer.parseInt(errorMessage.substring(backslashPos + 1, backslashPos

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java
Patch:
@@ -50,7 +50,7 @@ protected List<RuleMatch> getRuleMatches(String word, int startPos) throws IOExc
         RuleMatch oldMatch = ruleMatches.get(0);
         RuleMatch newMatch = new RuleMatch(this, oldMatch.getFromPos(), oldMatch.getToPos(), 
                 "Possible spelling mistake. Did you mean <suggestion>" + forms.forms.get(0) +
-                "</suggestion>, the irregular " + forms.formName + " form of the " + forms.posName +
+                "</suggestion>, the " + forms.formName + " form of the " + forms.posName +
                 " '" + forms.baseform + "'?");
         List<String> allSuggestions = new ArrayList<>();
         allSuggestions.addAll(forms.forms);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -104,7 +104,7 @@ public GermanSpellerRule(ResourceBundle messages, German language) {
   @Override
   protected void init() throws IOException {
     super.init();
-    String pattern = "(" + nonWordPattern.pattern() + "|(?<=\\d)\\-|\\-(?=\\d+)|[.])";
+    String pattern = "(" + nonWordPattern.pattern() + "|(?<=\\d)\\-|\\-(?=\\d+))";
     nonWordPattern = Pattern.compile(pattern);
     needsInit = false;
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -104,7 +104,7 @@ public GermanSpellerRule(ResourceBundle messages, German language) {
   @Override
   protected void init() throws IOException {
     super.init();
-    String pattern = "(" + nonWordPattern.pattern() + "|(?<=\\d)\\-|\\-(?=\\d+))";
+    String pattern = "(" + nonWordPattern.pattern() + "|(?<=\\d)\\-|\\-(?=\\d+)|[.])";
     nonWordPattern = Pattern.compile(pattern);
     needsInit = false;
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -168,6 +168,8 @@ private static PatternToken posRegex(String posTag) {
    * workaround to avoid false alarms, these words can be added here.
    */
   private static final Set<String> exceptions = new HashSet<>(Arrays.asList(
+    "Mitwirkende",
+    "Mitwirkender",
     "Selbstständige",
     "Selbstständiger",
     "Genaueres",

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -62,8 +62,7 @@ class LanguageToolHttpHandler implements HttpHandler {
       this.ownIps = new HashSet<>();
     }
     afterTheDeadlineMode = config.getMode() == HTTPServerConfig.Mode.AfterTheDeadline;
-    this.textCheckerV1 = new V1TextChecker(config, internal);
-    //this.textCheckerV1 = new V1EOLTextChecker(config, internal);
+    this.textCheckerV1 = new V1EOLTextChecker(config, internal);
     this.textCheckerV2 = new V2TextChecker(config, internal);
   }
 

File: languagetool-server/src/test/java/org/languagetool/server/HTTPSServerTest.java
Patch:
@@ -85,7 +85,7 @@ private void runTests() throws IOException {
       fail("HTTP should not work, only HTTPS");
     } catch (SocketException ignored) {}
 
-    String httpsPrefix = "https://localhost:" + HTTPTools.getDefaultPort() + "/";
+    String httpsPrefix = "https://localhost:" + HTTPTools.getDefaultPort() + "/v2/check";
 
     String result = HTTPTools.checkAtUrl(new URL(httpsPrefix + "?text=a+test.&language=en"));
     assertTrue("Got " + result, result.contains("UPPERCASE_SENTENCE_START"));

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerLoadTest.java
Patch:
@@ -92,7 +92,6 @@ public void run() {
       for (int i = 0; i < getRepeatCount(); i++) {
         runningTests.incrementAndGet();
         try {
-          runTestsV1();
           runTestsV2();
         } catch (Exception e) {
           throw new RuntimeException(e);

File: languagetool-server/src/test/java/org/languagetool/server/TextCheckerTest.java
Patch:
@@ -28,7 +28,7 @@
 public class TextCheckerTest {
 
   private final String english = "This is clearly an English text, should be easy to detect.";
-  private final TextChecker checker = new V1TextChecker(new HTTPServerConfig(), false);
+  private final TextChecker checker = new V2TextChecker(new HTTPServerConfig(), false);
 
   @Test
   public void testDetectLanguageOfString() {

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -332,7 +332,7 @@ public List<DisambiguationPatternRule> getAntiPatterns() {
   }
   
   /**
-   * Checks whether a <code>word<code> starts with an ignored word
+   * Checks whether a <code>word</code> starts with an ignored word
    * @param word - entire word
    * @param caseSensitive - determines whether the check is case-sensitive
    * @return length of the ignored word (i.e., return value is 0, if the word does not start with an ignored word).

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java
Patch:
@@ -115,7 +115,6 @@ private IrregularForms getIrregularFormsOrNull(String word, String wordSuffix, L
   }
 
   /**
-   * @throws IOException 
    * @since 2.7
    */
   @Override

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -71,7 +71,8 @@ public void testRule() throws IOException {
      */
     // (en especial si hi ha un adverbi entremig: en algun grau més distintes
     //assertCorrect("Es van somriure l'una a l'altra encara dretes, suades i panteixants,");
-//    assertCorrect("una combinació de dos o més metalls obtinguda generalment");
+    //assertCorrect("una combinació de dos o més metalls obtinguda generalment");
+    assertCorrect("La raó sol allunyar-se dels extrems");
     assertCorrect("L'URL introduït");
     assertCorrect("Som els més antisistema");
     assertCorrect("En un entorn de prova segur");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -398,9 +398,9 @@ private boolean ignoreCompoundWithIgnoredWord(String word) throws IOException{
       String ignoredWord = word.substring(0, end);
       String partialWord = word.substring(end);
       boolean needFugenS = ENDINGS_NEEDING_FUGEN_S.stream().anyMatch(ending -> ignoredWord.endsWith(ending));
-      if(!needFugenS) {
+      if(!needFugenS && partialWord.length() > 1) {
           return !hunspellDict.misspelled(partialWord) || !hunspellDict.misspelled(WordUtils.capitalize(partialWord));
-      } else if(needFugenS && partialWord.startsWith("s")) {
+      } else if(needFugenS && partialWord.startsWith("s") && partialWord.length() > 2) {
           partialWord = partialWord.substring(1);
           return !hunspellDict.misspelled(partialWord) || !hunspellDict.misspelled(WordUtils.capitalize(partialWord));
       }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -163,6 +163,8 @@ public void testIgnoreWord() throws Exception {
     assertTrue(ruleGermany.doIgnoreWord("Secondhandware"));             // from spelling.txt formed compound
     assertTrue(ruleGermany.doIgnoreWord("Feynmandiagramme"));           // from spelling.txt formed compound
     assertTrue(ruleGermany.doIgnoreWord("Helizitätsoperator"));         // from spelling.txt formed compound
+    assertFalse(ruleGermany.doIgnoreWord("Helizitätso"));               // from spelling.txt formed compound (second part is too short)
+    assertFalse(ruleGermany.doIgnoreWord("Feynmand"));                  // from spelling.txt formed compound (second part is too short)
     MyGermanSpellerRule ruleSwiss = new MyGermanSpellerRule(TestTools.getMessages("de"), GERMAN_CH);
     assertTrue(ruleSwiss.doIgnoreWord("einPseudoWortFürLanguageToolTests"));
     assertFalse(ruleSwiss.doIgnoreWord("Ligafußball"));        // 'ß' never accepted for Swiss

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/ConfigurationDialog.java
Patch:
@@ -339,7 +339,7 @@ public void treeNodesChanged(TreeModelEvent e) {
         node = (DefaultMutableTreeNode) node.getChildAt(index);
         if (node instanceof RuleNode) {
           RuleNode o = (RuleNode) node;
-          if (o.getRule().isDefaultOff()) {
+          if (o.getRule().isDefaultOff() || o.getRule().getCategory().isDefaultOff()) {
             if (o.isEnabled()) {
               config.getEnabledRuleIds().add(o.getRule().getId());
             } else {

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -63,6 +63,7 @@ class LanguageToolHttpHandler implements HttpHandler {
     }
     afterTheDeadlineMode = config.getMode() == HTTPServerConfig.Mode.AfterTheDeadline;
     this.textCheckerV1 = new V1TextChecker(config, internal);
+    //this.textCheckerV1 = new V1EOLTextChecker(config, internal);
     this.textCheckerV2 = new V2TextChecker(config, internal);
   }
 

File: languagetool-dev/src/main/java/org/languagetool/dev/ExampleSentenceCorrectionCreator.java
Patch:
@@ -75,7 +75,6 @@ private void checkCorrections(Rule rule, IncorrectExample incorrectExample, List
         tool.disableRule(r.getId());
       }
       tool.enableRule(rule.getId());
-      tool.enableDefaultOffRule(rule.getId());
       String incorrectSentence = incorrectExample.getExample().replaceAll("</?marker>", "");
       List<RuleMatch> matches = tool.check(incorrectSentence);
       System.err.println("no corrections: " + rule.getId() + ", " + matches.size() + " matches");

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageToolSupport.java
Patch:
@@ -454,7 +454,6 @@ void enableRule(String ruleId) {
     }
     if (rule.isDefaultOff()) {
       config.getEnabledRuleIds().add(ruleId);
-      languageTool.enableDefaultOffRule(ruleId);
     } else {
       config.getDisabledRuleIds().remove(ruleId);
     }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -404,8 +404,9 @@ private boolean ignoreCompoundWithIgnoredWord(String word) throws IOException{
     } else {
       for (String word1 : words) {
         if (super.ignoreWord(word1)) {
-          toSpellCheck.add(word1);
           hasIgnoredWord = true;
+        } else {
+          toSpellCheck.add(word1);
         }
       }
     }

File: languagetool-core/src/main/java/org/languagetool/languagemodel/LuceneSingleIndexLanguageModel.java
Patch:
@@ -198,6 +198,7 @@ private long getCount(Term term, LuceneSearcher luceneSearcher) {
         String countStr = luceneSearcher.reader.document(scoreDoc.doc).get("count");
         result += Long.parseLong(countStr);
       }
+      //System.out.println(term + " -> " + result);
     } catch (IOException e) {
       throw new RuntimeException(e);
     }

File: languagetool-core/src/main/java/org/languagetool/tokenizers/WordTokenizer.java
Patch:
@@ -40,7 +40,7 @@ public class WordTokenizer implements Tokenizer {
 
   private static final List<String> PROTOCOLS = Collections.unmodifiableList(Arrays.asList("http", "https", "ftp"));
   private static final Pattern URL_CHARS = Pattern.compile("[a-zA-Z0-9/%$-_.+!*'(),\\?]+");
-  private static final Pattern E_MAIL = Pattern.compile("(?<!:)\\b[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))\\b(?!:)");
+  private static final Pattern E_MAIL = Pattern.compile("(?<!:)\\b[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))\\b");
 
   private static final String TOKENIZING_CHARACTERS = "\u0020\u00A0\u115f" +
       "\u1160\u1680"

File: languagetool-language-modules/ca/src/test/java/org/languagetool/tokenizers/ca/CatalanWordTokenizerTest.java
Patch:
@@ -35,9 +35,8 @@ public void testTokenize() {
     assertEquals(tokens.size(), 1);
     tokens = wordTokenizer.tokenize("name@example.com.");
     assertEquals(tokens.size(), 2);
-    //TODO: doesn't work
-    //tokens = wordTokenizer.tokenize("name@example.com:");
-    //assertEquals(tokens.size(), 2);
+    tokens = wordTokenizer.tokenize("name@example.com:");
+    assertEquals(tokens.size(), 2);
     tokens = wordTokenizer.tokenize("L'origen de name@example.com.");
     assertEquals(tokens.size(), 7);
     assertEquals("[L', origen,  , de,  , name@example.com, .]", tokens.toString());

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractCompoundRule.java
Patch:
@@ -175,7 +175,7 @@ private Map<String, AnalyzedTokenReadings> getStringToTokenMap(Queue<AnalyzedTok
   }
 
   private String normalize(String inStr) {
-    String str = inStr.trim().toLowerCase();
+    String str = inStr.trim();
     if (str.indexOf('-') != -1 && str.indexOf(' ') != -1) {
       if (isHyphenIgnored()) {
         // e.g. "E-Mail Adresse" -> "E Mail Adresse" so the error can be detected:
@@ -207,7 +207,7 @@ private String mergeCompound(String str) {
         if (k == 0) {
           sb.append(stringParts[0]);
         } else {
-          sb.append(stringParts[k].toLowerCase());
+          sb.append(stringParts[k]);
         }
       }
     }

File: languagetool-core/src/main/java/org/languagetool/rules/CompoundRuleData.java
Patch:
@@ -80,12 +80,12 @@ private void loadCompoundFile(String path) throws IOException {
         validateLine(path, line);
         if (line.endsWith("+")) {
           line = removeLastCharacter(line);
-          noDashSuggestion.add(line.toLowerCase());
+          noDashSuggestion.add(line);
         } else if (line.endsWith("*")) {
           line = removeLastCharacter(line);
-          onlyDashSuggestion.add(line.toLowerCase());
+          onlyDashSuggestion.add(line);
         }
-        incorrectCompounds.add(line.toLowerCase());
+        incorrectCompounds.add(line);
       }
     }
   }

File: languagetool-language-modules/ro/src/test/java/org/languagetool/rules/ro/CompoundRuleTest.java
Patch:
@@ -44,7 +44,7 @@ public void testRule() throws IOException {
     check(0, "Au plecat câteșitrei.");
     // incorrect sentences:
     check(1, "câte și trei", new String[] { "câteșitrei" });
-    check(1, "Câte și trei", new String[] { "Câteșitrei" });
+//    check(1, "Câte și trei", new String[] { "Câteșitrei" });
     check(1, "câte-și-trei", new String[] { "câteșitrei" });
 
     check(1, "tus trei", new String[] { "tustrei" });

File: languagetool-language-modules/ru/src/test/java/org/languagetool/rules/ru/RussianCompoundRuleTest.java
Patch:
@@ -55,7 +55,7 @@ public void testRule() throws IOException {
     // no hyphen suggestion for some words:
     check(1, "кругло суточный", new String[]{"круглосуточный"});
     // also accept incorrect upper/lowercase spelling:
-    check(1, "Ростов на дону", new String[]{"Ростов-на-дону"});
+//    check(1, "Ростов на дону", new String[]{"Ростов-на-Дону"});
     // also detect an error if only some of the hyphens are missing:
     check(1, "Ростов-на Дону", new String[]{"Ростов-на-Дону"});
     // first part is a single character:

File: languagetool-dev/src/main/java/org/languagetool/dev/bigdata/AutomaticConfusionRuleEvaluator.java
Patch:
@@ -42,8 +42,8 @@
 @SuppressWarnings({"resource", "CallToPrintStackTrace"})
 class AutomaticConfusionRuleEvaluator {
   
-  private static final String LANGUAGE = "de";
-  private static final boolean CASE_SENSITIVE = true;
+  private static final String LANGUAGE = "en";
+  private static final boolean CASE_SENSITIVE = false;
   private static final int MAX_EXAMPLES = 1000;
   private static final List<Long> EVAL_FACTORS = Arrays.asList(10L, 100L, 1_000L, 10_000L, 100_000L, 1_000_000L, 10_000_000L);
   private static final float MIN_PRECISION = 0.99f;
@@ -143,7 +143,7 @@ private File writeExampleSentencesToTempFile(String[] words) throws IOException
 
   private void findExampleSentences(String word, FileWriter fw) throws IOException {
     Term term = new Term(TextIndexCreator.FIELD, CASE_SENSITIVE ? word.toLowerCase() : word);
-    TopDocs topDocs = searcher.search(new TermQuery(term), Integer.MAX_VALUE);
+    TopDocs topDocs = searcher.search(new TermQuery(term), CASE_SENSITIVE ? Integer.MAX_VALUE : MAX_EXAMPLES);
     int count = 0;
     for (ScoreDoc scoreDoc : topDocs.scoreDocs) {
       String sentence = searcher.doc(scoreDoc.doc).get(TextIndexCreator.FIELD);

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/ConfigurationDialog.java
Patch:
@@ -350,8 +350,10 @@ public void treeNodesChanged(TreeModelEvent e) {
             }
           } else {
             if (o.isEnabled()) {
+              config.getEnabledRuleIds().add(o.getRule().getId());
               config.getDisabledRuleIds().remove(o.getRule().getId());
             } else {
+              config.getEnabledRuleIds().remove(o.getRule().getId());
               config.getDisabledRuleIds().add(o.getRule().getId());
             }
           }

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -616,7 +616,7 @@ private boolean ignoreRule(Rule rule) {
       if (disabledCategories.contains(category.getName())) {
         return true;
       }
-      if (category.isDefaultOff() && !enabledRuleCategories.contains(category.getId())) {
+      if (category.isDefaultOff() && !enabledRuleCategories.contains(category.getId()) && !enabledRules.contains(rule.getId())) {
         return true;
       }
     }

File: languagetool-language-modules/pl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -115,7 +115,7 @@ public List<AbstractPatternRule> getPatternRules() {
             "PREP_SUBST_2[1]: powodu[powód/subst:sg:gen:m3] -> powodu[powód/subst:sg:gen:m3]\n" +
             "MULTIWORD_CHUNKER: powodu[powód/subst:sg:gen:m3] -> powodu[powód/subst:sg:gen:m3,Z powodu/</PREP:GEN>]\n" +
             "\n" +
-            "PREP_SUBST[16]: pogody[pogoda/subst:pl:acc:f,pogoda/subst:pl:nom:f,pogoda/subst:pl:voc:f,pogoda/subst:sg:gen:f] -> pogody[pogoda/subst:sg:gen:f]\n" +
+            "PREP_SUBST[17]: pogody[pogoda/subst:pl:acc:f,pogoda/subst:pl:nom:f,pogoda/subst:pl:voc:f,pogoda/subst:sg:gen:f] -> pogody[pogoda/subst:sg:gen:f]\n" +
             "\n" +
             "dobry_adj[1]: dobre[dobre/subst:pl:acc:n2,dobre/subst:pl:nom:n2,dobre/subst:pl:voc:n2,dobre/subst:sg:acc:n2,dobre/subst:sg:nom:n2,dobre/subst:sg:voc:n2,dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos,dobry/depr:pl:nom:m2,dobry/depr:pl:voc:m2,dobry/subst:pl:acc:m3,dobry/subst:pl:nom:m3,dobry/subst:pl:voc:m3] -> dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos]\n" +
             "unify_adj_subst[2]: dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos] -> dobre[dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos]\n" +

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -296,7 +296,7 @@ private boolean isRelevantPronoun(AnalyzedTokenReadings[] tokens, int pos) {
     boolean relevantPronoun = GermanHelper.hasReadingOfType(analyzedToken, POSType.PRONOMEN);
     // avoid false alarms:
     String token = tokens[pos].getToken();
-    if (pos > 0 && tokens[pos-1].getToken().equalsIgnoreCase("vor") && tokens[pos].getToken().equalsIgnoreCase("allem")) {
+    if (pos > 0 && tokens[pos-1].getToken().equalsIgnoreCase("vor") && token.equalsIgnoreCase("allem")) {
       relevantPronoun = false;
     } else if (PRONOUNS_TO_BE_IGNORED.contains(token.toLowerCase())) {
       relevantPronoun = false;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tokenizers/ca/CatalanWordTokenizer.java
Patch:
@@ -190,7 +190,7 @@ public List<String> tokenize(final String text) {
         l.addAll(wordsToAdd(s));
       }
     }
-    return joinUrls(l);
+    return joinEMailsAndUrls(l);
   }
 
   /* Splits a word containing hyphen(-) if it doesn't exist in the dictionary. */

File: languagetool-language-modules/en/src/main/java/org/languagetool/tokenizers/en/EnglishWordTokenizer.java
Patch:
@@ -63,6 +63,6 @@ public List<String> tokenize(String text) {
         l.add(token);
       }
     }
-    return joinUrls(l);
+    return joinEMailsAndUrls(l);
   }
 }

File: languagetool-language-modules/nl/src/main/java/org/languagetool/tokenizers/nl/DutchWordTokenizer.java
Patch:
@@ -83,7 +83,7 @@ public List<String> tokenize(final String text) {
         l.add(token);
       }
     }
-    return joinUrls(l);
+    return joinEMailsAndUrls(l);
   }
 
   private boolean startsWithQuote(String token) {

File: languagetool-language-modules/pl/src/main/java/org/languagetool/tokenizers/pl/PolishWordTokenizer.java
Patch:
@@ -166,7 +166,7 @@ public List<String> tokenize(final String text) {
         l.add(token);
       }
     }
-    return joinUrls(l);
+    return joinEMailsAndUrls(l);
   }
 
   /**

File: languagetool-language-modules/pl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -115,7 +115,7 @@ public List<AbstractPatternRule> getPatternRules() {
             "PREP_SUBST_2[1]: powodu[powód/subst:sg:gen:m3] -> powodu[powód/subst:sg:gen:m3]\n" +
             "MULTIWORD_CHUNKER: powodu[powód/subst:sg:gen:m3] -> powodu[powód/subst:sg:gen:m3,Z powodu/</PREP:GEN>]\n" +
             "\n" +
-            "PREP_SUBST[14]: pogody[pogoda/subst:pl:acc:f,pogoda/subst:pl:nom:f,pogoda/subst:pl:voc:f,pogoda/subst:sg:gen:f] -> pogody[pogoda/subst:sg:gen:f]\n" +
+            "PREP_SUBST[16]: pogody[pogoda/subst:pl:acc:f,pogoda/subst:pl:nom:f,pogoda/subst:pl:voc:f,pogoda/subst:sg:gen:f] -> pogody[pogoda/subst:sg:gen:f]\n" +
             "\n" +
             "dobry_adj[1]: dobre[dobre/subst:pl:acc:n2,dobre/subst:pl:nom:n2,dobre/subst:pl:voc:n2,dobre/subst:sg:acc:n2,dobre/subst:sg:nom:n2,dobre/subst:sg:voc:n2,dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos,dobry/depr:pl:nom:m2,dobry/depr:pl:voc:m2,dobry/subst:pl:acc:m3,dobry/subst:pl:nom:m3,dobry/subst:pl:voc:m3] -> dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos]\n" +
             "unify_adj_subst[2]: dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos] -> dobre[dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos]\n" +

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/RussianWordRepeatRule.java
Patch:
@@ -52,7 +52,7 @@ public class RussianWordRepeatRule extends AdvancedWordRepeatRule {
   /**
    * Excluded part of speech classes.
    */
-  private static final Pattern EXC_POS = Pattern.compile("INTERJECTION|PRDC|PNN:.*");
+  private static final Pattern EXC_POS = Pattern.compile("INTERJECTION|PRDC|CONJ|PARTICLE|PNN:.*");
 
   /**
    * Excluded non-words (special symbols, Roman numerals etc.)

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -47,6 +47,7 @@ public void setUp() throws IOException {
   public void testRule() throws IOException {
 
     // correct sentences:
+    assertCorrect("—I continues mantenint que això va succeir");
     assertCorrect("No hi ha ningú aquí que begui vi?");
     assertCorrect("Va tocar l'ària da capo de les variacions Goldberg.");
     assertCorrect("A ponent continua la serra de Fontpobra");

File: languagetool-language-modules/nl/src/main/java/org/languagetool/rules/nl/MorfologikDutchSpellerRule.java
Patch:
@@ -47,7 +47,7 @@ protected String getIgnoreFileName() {
   }
 
   @Override
-  protected String getSpellingFileName() {
+  public String getSpellingFileName() {
     return "/nl/spelling/spelling.txt";
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanDoublePunctuationRule.java
Patch:
@@ -42,7 +42,7 @@ public GermanDoublePunctuationRule(ResourceBundle messages) {
   }
   
   @Override
-  public final String getId() {
+  public String getId() {
     return "DE_DOUBLE_PUNCTUATION";
   }
 

File: languagetool-core/src/main/java/org/languagetool/AnalyzedToken.java
Patch:
@@ -56,7 +56,7 @@ public String getToken() {
   }
 
   /**
-   * @return the token's part-of-speech tag {@code null}
+   * @return the token's part-of-speech tag or {@code null}
    */
   @Nullable
   public String getPOSTag() {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -356,6 +356,9 @@ private boolean hasUnambiguouslyPersonAndNumber(final AnalyzedTokenReadings toke
     }
     for (AnalyzedToken analyzedToken : tokenReadings) {
       final String postag = analyzedToken.getPOSTag();
+      if (postag == null) {
+        continue;
+      }
       if (postag.contains("_END")) { // ignore SENT_END and PARA_END
         continue;
       }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -81,6 +81,7 @@ public void testWrongVerb() throws IOException {
     assertGood("/usr/bin/firefox");
     assertGood("Das sind Leute, die viel mehr als ich wissen.");
     assertGood("Das ist mir nicht klar, kannst ja mal beim Kunden nachfragen.");
+    assertGood("So tes\u00ADtest Du das mit dem soft hyphen.");
     // incorrect sentences:
     assertBad("Als Borcarbid weißt es eine hohe Härte auf.");
     assertBad("Das greift auf Vorläuferinstitutionen bist auf die Zeit von 1234 zurück.");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -47,6 +47,7 @@ public void setUp() throws IOException {
   public void testRule() throws IOException {
 
     // correct sentences:
+    assertCorrect("No hi ha ningú aquí que begui vi?");
     assertCorrect("Va tocar l'ària da capo de les variacions Goldberg.");
     assertCorrect("A ponent continua la serra de Fontpobra");
     assertCorrect("com a base de la categoria faria que els enllaços");

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/bitext/BitextPatternRuleHandler.java
Patch:
@@ -131,6 +131,7 @@ public void endElement(String namespaceURI, String sName,
         }
         inCorrectExample = false;
         inIncorrectExample = false;
+        inErrorTriggerExample = false;
         break;
       default:
         super.endElement(namespaceURI, sName, qName);
@@ -150,6 +151,8 @@ private IncorrectExample setExample() {
       } else {
         example = new IncorrectExample(incorrectExample.toString());
       }
+    } else if (inErrorTriggerExample) {
+      throw new RuntimeException("'triggers_error' is not supported for bitext XML");
     }
     correctExample = new StringBuilder();
     incorrectExample = new StringBuilder();

File: languagetool-core/src/test/java/org/languagetool/rules/bitext/BitextPatternRuleTest.java
Patch:
@@ -141,8 +141,8 @@ private void testBitextRule(BitextPatternRule rule, Language lang,
     JLanguageTool srcTool = new JLanguageTool(rule.getSourceLanguage());
     List<StringPair> goodSentences = rule.getCorrectBitextExamples();
     for (StringPair goodSentence : goodSentences) {
-      assertTrue(cleanSentence(goodSentence.getSource()).trim().length() > 0);
-      assertTrue(cleanSentence(goodSentence.getTarget()).trim().length() > 0);
+      assertTrue("Got good sentence: '" + goodSentence.getSource() + "'", cleanSentence(goodSentence.getSource()).trim().length() > 0);
+      assertTrue("Got good sentence: '" + goodSentence.getTarget() + "'", cleanSentence(goodSentence.getTarget()).trim().length() > 0);
       assertFalse(lang + ": Did not expect error in: " + goodSentence
               + " (Rule: " + rule + ")",
               match(rule, goodSentence.getSource(), goodSentence.getTarget(),

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -96,6 +96,7 @@ public void testRule() throws IOException {
     assertCorrect("La magnífica conservació del palau.");
 
     // errors:
+    assertIncorrect("L'ultima consideració.");
     assertIncorrect("Com s'ha dit les primaries autonòmiques s'han ajornat");
     assertIncorrect("Com sabeu les primaries s'han ajornat");
     assertIncorrect("Les continues al·lusions a la victòria.");

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/AbstractEnglishSpellerRuleTest.java
Patch:
@@ -93,7 +93,7 @@ private void assertFirstMatch(String text, String... expectedSuggestions) throws
     assertTrue("Expected at least one suggestion for '" + text + "'", suggestions.size() > 0);
     int i = 0;
     for (String expectedSuggestion : expectedSuggestions) {
-      assertThat("Expected suggestion '" + expectedSuggestion + "' not found in suggestions"
+      assertThat("Expected suggestion '" + expectedSuggestion + "' not found at position " + i + " in suggestions: "
               + suggestions, suggestions.get(i), is(expectedSuggestion));
       i++;
     }

File: languagetool-core/src/main/java/org/languagetool/rules/CommaWhitespaceRule.java
Patch:
@@ -37,7 +37,7 @@
 public class CommaWhitespaceRule extends Rule {
 
   /** @since 3.3 */
-  public CommaWhitespaceRule(ResourceBundle messages, IncorrectExample incorrectExample, String correctExample) {
+  public CommaWhitespaceRule(ResourceBundle messages, IncorrectExample incorrectExample, CorrectExample correctExample) {
     super(messages);
     super.setCategory(Categories.MISC.getCategory(messages));
     setLocQualityIssueType(ITSIssueType.Whitespace);

File: languagetool-core/src/main/java/org/languagetool/rules/UppercaseSentenceStartRule.java
Patch:
@@ -50,7 +50,7 @@ public class UppercaseSentenceStartRule extends Rule {
   private String lastParagraphString = "";
   
   /** @since 3.3 */
-  public UppercaseSentenceStartRule(ResourceBundle messages, Language language, IncorrectExample incorrectExample, String correctExample) {
+  public UppercaseSentenceStartRule(ResourceBundle messages, Language language, IncorrectExample incorrectExample, CorrectExample correctExample) {
     super(messages);
     super.setCategory(Categories.CASING.getCategory(messages));
     this.language = language;
@@ -61,7 +61,7 @@ public UppercaseSentenceStartRule(ResourceBundle messages, Language language, In
   }
 
   /**
-   * @deprecated use {@link #UppercaseSentenceStartRule(ResourceBundle, Language, IncorrectExample, String)} instead (deprecated since 3.3)
+   * @deprecated use {@link #UppercaseSentenceStartRule(ResourceBundle, Language, IncorrectExample, CorrectExample)} instead (deprecated since 3.3)
    */
   public UppercaseSentenceStartRule(ResourceBundle messages, Language language) {
     this(messages, language, null, null);

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/FalseFriendRuleHandler.java
Patch:
@@ -23,6 +23,7 @@
 import org.languagetool.Language;
 import org.languagetool.Languages;
 import org.languagetool.rules.Categories;
+import org.languagetool.rules.CorrectExample;
 import org.languagetool.rules.IncorrectExample;
 import org.xml.sax.Attributes;
 import org.xml.sax.SAXException;
@@ -169,7 +170,7 @@ public void endElement(String namespaceURI, String sName,
         break;
       case EXAMPLE:
         if (inCorrectExample) {
-          correctExamples.add(correctExample.toString());
+          correctExamples.add(new CorrectExample(correctExample.toString()));
         } else if (inIncorrectExample) {
           incorrectExamples.add(new IncorrectExample(incorrectExample.toString()));
         }

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/XMLRuleHandler.java
Patch:
@@ -28,6 +28,7 @@
 import org.jetbrains.annotations.Nullable;
 import org.languagetool.Language;
 import org.languagetool.chunking.ChunkTag;
+import org.languagetool.rules.CorrectExample;
 import org.languagetool.rules.IncorrectExample;
 import org.languagetool.tools.StringTools;
 import org.xml.sax.Attributes;
@@ -105,7 +106,7 @@ enum RegexpMode {
   protected StringBuilder elements;
   protected StringBuilder exceptions;
 
-  protected List<String> correctExamples = new ArrayList<>();
+  protected List<CorrectExample> correctExamples = new ArrayList<>();
   protected List<IncorrectExample> incorrectExamples = new ArrayList<>();
 
   protected boolean inPattern;

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellNoSuggestionRule.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.ResourceBundle;
 
 import org.languagetool.Language;
+import org.languagetool.rules.CorrectExample;
 import org.languagetool.rules.IncorrectExample;
 
 /**
@@ -41,7 +42,7 @@ public HunspellNoSuggestionRule(ResourceBundle messages, Language language) {
   /**
    * @since 3.3
    */
-  public HunspellNoSuggestionRule(ResourceBundle messages, Language language, IncorrectExample incorrectExample, String correctedExample) {
+  public HunspellNoSuggestionRule(ResourceBundle messages, Language language, IncorrectExample incorrectExample, CorrectExample correctedExample) {
     super(messages, language);
     addExamplePair(incorrectExample, correctedExample);
   }

File: languagetool-standalone/src/test/java/org/languagetool/rules/RuleTest.java
Patch:
@@ -81,9 +81,9 @@ private void testExamples(Rule rule, JLanguageTool lt) throws IOException {
   }
 
   private void testCorrectExamples(Rule rule, JLanguageTool lt) throws IOException {
-    List<String> correctExamples = rule.getCorrectExamples();
-    for (String correctExample : correctExamples) {
-      String input = cleanMarkers(correctExample);
+    List<CorrectExample> correctExamples = rule.getCorrectExamples();
+    for (CorrectExample correctExample : correctExamples) {
+      String input = cleanMarkers(correctExample.getExample());
       enableOnlyOneRule(lt, rule);
       List<RuleMatch> ruleMatches = lt.check(input);
       assertEquals("Got unexpected rule match for correct example sentence:\n"

File: languagetool-core/src/main/java/org/languagetool/rules/RuleMatch.java
Patch:
@@ -97,7 +97,9 @@ public RuleMatch(Rule rule, int fromPos, int toPos, String message, String short
       if (startWithUppercase) {
         replacement = StringTools.uppercaseFirstChar(replacement);
       }
-      suggestedReplacements.add(replacement);
+      if (!suggestedReplacements.contains(replacement)) {
+        suggestedReplacements.add(replacement);
+      }
     }
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/Hunspell.java
Patch:
@@ -322,7 +322,7 @@ public String getWordChars() {
          * Check if a word is spelled correctly
          *
          * @param word The word to check.
-         * @return true if the <code>word<code> is not correctly spelled
+         * @return true if the <code>word</code> is not correctly spelled
          */
         public boolean misspelled(String word) {
             try {

File: languagetool-core/src/main/java/org/languagetool/rules/AdvancedWordRepeatRule.java
Patch:
@@ -33,7 +33,7 @@
 import org.languagetool.tools.StringTools;
 
 /**
- * Rule for detecting same words in the sentence but not just in a row
+ * Rule for detecting same words in the sentence but not just in a row. This rule is off by default.
  *
  * @author Marcin Miłkowski
  */
@@ -133,7 +133,6 @@ public final RuleMatch[] match(AnalyzedSentence sentence) {
               inflectedWords.add(tokens[i].getToken());
             }
           }
-
         }
       }
 

File: languagetool-core/src/main/java/org/languagetool/rules/ngrams/ConfusionProbabilityRule.java
Patch:
@@ -190,11 +190,11 @@ private ConfusionString getAlternativeTerm(Set<ConfusionString> confusionSet, Go
 
   private ConfusionString getConfusionString(Set<ConfusionString> confusionSet, GoogleToken token) {
     for (ConfusionString s : confusionSet) {
-      if (s.getString().equals(token.token)) {
+      if (s.getString().equalsIgnoreCase(token.token)) {
         return s;
       }
     }
-    throw new RuntimeException("Not found in set: " + token);
+    throw new RuntimeException("Not found in set '" + confusionSet + "': " + token);
   }
 
   private ConfusionString getBetterAlternativeOrNull(GoogleToken token, List<GoogleToken> tokens, ConfusionString otherWord, long factor) {

File: languagetool-core/src/test/java/org/languagetool/languagemodel/BaseLanguageModelTest.java
Patch:
@@ -37,13 +37,13 @@ public void testPseudoProbability() throws IOException {
     try (FakeLanguageModel lm = new FakeLanguageModel()) {
       Probability prob1 = lm.getPseudoProbability(Arrays.asList("no", "data", "here"));
       double delta = 0.001;
-      assertEquals(0.010, prob1.getProb(), delta);  // artificially not zero
+      assertEquals(0.0081, prob1.getProb(), delta);  // artificially not zero
       assertThat(prob1.getCoverage(), is(0.0f));
       Probability prob2 = lm.getPseudoProbability(Arrays.asList("1", "2", "3", "4"));
-      assertEquals(0.010, prob2.getProb(), delta);  // artificially not zero
+      assertEquals(0.0081, prob2.getProb(), delta);  // artificially not zero
       assertThat(prob2.getCoverage(), is(0.0f));
       Probability prob3 = lm.getPseudoProbability(Arrays.asList("There", "are"));
-      assertEquals(0.119, prob3.getProb(), delta);
+      assertEquals(0.089, prob3.getProb(), delta);
       assertThat(prob3.getCoverage(), is(0.5f));
     }
   }

File: languagetool-core/src/test/java/org/languagetool/rules/ConfusionSetLoaderTest.java
Patch:
@@ -40,7 +40,7 @@ public void testLoadWithStrictLimits() throws IOException {
     try (InputStream inputStream = JLanguageTool.getDataBroker().getFromResourceDirAsStream("/yy/confusion_sets.txt")) {
       ConfusionSetLoader loader = new ConfusionSetLoader();
       Map<String, List<ConfusionSet>> map = loader.loadConfusionSet(inputStream);
-      assertThat(map.size(), is(8));
+      assertThat(map.size(), is(10));
 
       assertThat(map.get("there").size(), is(1));
       assertThat(map.get("there").get(0).getFactor(), is(10L));

File: languagetool-core/src/test/java/org/languagetool/rules/ngrams/ConfusionProbabilityRuleTest.java
Patch:
@@ -53,6 +53,7 @@ protected boolean isException(String sentenceText) {
       }
     };
     assertGood("Their are new ideas to explore.", ruleWithException);
+    assertMatch("İm dabei gut auszusehen.");  // bug with the special char 'İ' which, when lowercased becomes  a regular 'i'
   }
 
   @Test

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -119,6 +119,9 @@ public void handle(HttpExchange httpExchange) throws IOException {
             }
             text = text.replaceAll("</p>", "\n\n").replaceAll("<.*?>", "");  // clean up HTML, position changes don't matter for AtD
           } else {
+            if (requestedUri.getRawPath().contains("/v2/")) {
+              throw new IllegalArgumentException("You have '/v2/' in your path, but not at the root. Try an URL like 'http://server/v2/...' ");
+            }
             text = parameters.get("text");
             if (text == null) {
               throw new IllegalArgumentException("Missing 'text' parameter");

File: languagetool-server/src/main/java/org/languagetool/server/V2TextChecker.java
Patch:
@@ -81,6 +81,9 @@ protected Language getLanguage(String text, Map<String, String> parameters, List
     if (getLanguageAutoDetect(parameters)) {
       lang = detectLanguageOfString(text, null, preferredVariants);
     } else {
+      if (langParam == null) {
+        throw new IllegalArgumentException("Missing 'language' parameter");
+      }
       lang = Languages.getLanguageForShortName(langParam);
     }
     return lang;

File: languagetool-http-client/src/test/java/org/languagetool/remote/RemoteLanguageToolIntegrationTest.java
Patch:
@@ -43,12 +43,12 @@
 
 public class RemoteLanguageToolIntegrationTest {
 
-  private static final String serverUrl = "http://" + HTTPServerConfig.DEFAULT_HOST + ":" + HTTPTools.getDefaultPort() + "/v2/check";
+  private static final String serverUrl = "http://" + HTTPServerConfig.DEFAULT_HOST + ":" + HTTPTools.getDefaultPort();
 
   @Test
   @Ignore("for interactive use only")
   public void testPublicServer() throws MalformedURLException {
-    RemoteLanguageTool lt = new RemoteLanguageTool(new URL("https://languagetool.org/api/v2/check"));
+    RemoteLanguageTool lt = new RemoteLanguageTool(new URL("https://languagetool.org/api"));
     RemoteResult matches = lt.check("This is an test.", "en");
     System.out.println("matches: " + matches);
   }

File: languagetool-http-client/src/test/java/org/languagetool/remote/RemoteLanguageToolTest.java
Patch:
@@ -79,7 +79,7 @@ private static class FakeRemoteLanguageTool extends RemoteLanguageTool {
     }
 
     @Override
-    HttpURLConnection getConnection(byte[] postData) {
+    HttpURLConnection getConnection(byte[] postData, URL baseUrl) {
       URL fakeUrl;
       try {
         fakeUrl = new URL("https://fake");

File: languagetool-server/src/main/java/org/languagetool/server/RuleMatchesAsJsonSerializer.java
Patch:
@@ -129,7 +129,7 @@ private void writeRule(JsonGenerator g, RuleMatch match) throws IOException {
       }
     }
     g.writeStringField("description", match.getRule().getDescription());
-    g.writeStringField("issueType", match.getRule().getLocQualityIssueType().name());
+    g.writeStringField("issueType", match.getRule().getLocQualityIssueType().toString());
     if (match.getRule().getUrl() != null) {
       g.writeArrayFieldStart("urls");  // currently only one, but keep it extensible
       g.writeString(match.getRule().getUrl().toString());

File: languagetool-server/src/test/java/org/languagetool/server/RuleMatchesAsJsonSerializerTest.java
Patch:
@@ -56,7 +56,7 @@ public void testJson() {
     assertTrue(json.contains("\"FAKE_ID\""));
     assertTrue(json.contains("\"This is ...\""));
     assertTrue(json.contains("\"http://foobar.org/blah\""));
-    assertTrue(json.contains("\"Addition\""));
+    assertTrue(json.contains("\"addition\""));
   }
   
   @Test

File: languagetool-server/src/main/java/org/languagetool/server/RuleMatchesAsJsonSerializer.java
Patch:
@@ -129,6 +129,7 @@ private void writeRule(JsonGenerator g, RuleMatch match) throws IOException {
       }
     }
     g.writeStringField("description", match.getRule().getDescription());
+    g.writeStringField("issueType", match.getRule().getLocQualityIssueType().name());
     if (match.getRule().getUrl() != null) {
       g.writeArrayFieldStart("urls");  // currently only one, but keep it extensible
       g.writeString(match.getRule().getUrl().toString());

File: languagetool-server/src/test/java/org/languagetool/server/RuleMatchesAsJsonSerializerTest.java
Patch:
@@ -22,6 +22,7 @@
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.JLanguageTool;
 import org.languagetool.Languages;
+import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.Rule;
 import org.languagetool.rules.RuleMatch;
 
@@ -55,6 +56,7 @@ public void testJson() {
     assertTrue(json.contains("\"FAKE_ID\""));
     assertTrue(json.contains("\"This is ...\""));
     assertTrue(json.contains("\"http://foobar.org/blah\""));
+    assertTrue(json.contains("\"Addition\""));
   }
   
   @Test
@@ -71,6 +73,7 @@ public void testJsonWithWindowsLinebreak() {
   
   static class FakeRule extends Rule {
     FakeRule() {
+      setLocQualityIssueType(ITSIssueType.Addition);
       try {
         setUrl(new URL("http://foobar.org/blah"));
       } catch (MalformedURLException e) {

File: languagetool-server/src/main/java/org/languagetool/server/V2TextChecker.java
Patch:
@@ -79,7 +79,7 @@ protected Language getLanguage(String text, Map<String, String> parameters, List
     Language lang;
     String langParam = parameters.get("language");
     if (getLanguageAutoDetect(parameters)) {
-      lang = detectLanguageOfString(text, langParam, preferredVariants);
+      lang = detectLanguageOfString(text, null, preferredVariants);
     } else {
       lang = Languages.getLanguageForShortName(langParam);
     }

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerTest.java
Patch:
@@ -259,6 +259,9 @@ void runTestsV2() throws IOException, SAXException, ParserConfigurationException
 
     String result6 = checkV2(null, "This is a test of the language detection.", "&preferredVariants=de-DE,en-GB");
     assertTrue("Result: " + result6, result6.contains("\"en-GB\""));
+
+    String result7 = checkV2(null, "x");  // too short for auto-fallback, will use fallback
+    assertTrue("Result: " + result7, result7.contains("\"en-US\""));
   }
 
   @Test

File: languagetool-standalone/src/main/java/org/languagetool/gui/Main.java
Patch:
@@ -611,7 +611,7 @@ private void addLookAndFeelMenuItem(JMenu lafMenu,
     JRadioButtonMenuItem lfItem = new JRadioButtonMenuItem(new SelectLFAction(laf));
     lafMenu.add(lfItem);
     buttonGroup.add(lfItem);
-    if (laf.getName().equals(UIManager.getLookAndFeel().getName())) {
+    if (laf.getClassName().equals(UIManager.getLookAndFeel().getClass().getName())) {
       buttonGroup.setSelected(lfItem.getModel(), true);
     }
   }

File: languagetool-standalone/src/main/java/org/languagetool/gui/ResizeComponentListener.java
Patch:
@@ -25,7 +25,7 @@
 import javax.swing.JFrame;
 
 /**
- * A class that listens a window for resize events and saves it's bounds.
+ * A class that listens a window for resize events and saves its bounds.
  *
  * @author Panagiotis Minos
  * @since 3.4

File: languagetool-standalone/src/main/java/org/languagetool/gui/LocalStorage.java
Patch:
@@ -39,6 +39,7 @@ class LocalStorage {
 
   private static final String VENDOR_ID = "languagetool.org";
   private static final String APPLICATION_ID = "LanguageTool";
+  
   private final File directory;
 
   LocalStorage() {
@@ -115,9 +116,8 @@ void saveProperty(String name, Object obj) {
   }
 
   <T> T loadProperty(String name, Class<T> clazz) {
-    T result = null;
     if (directory == null) {
-      return result;
+      return null;
     }
     synchronized(directory) {
       try (XMLDecoder decoder = new XMLDecoder(new BufferedInputStream(
@@ -136,7 +136,7 @@ <T> T loadProperty(String name, Class<T> clazz) {
         //ignore, we have not saved yet a property with this name
       }
     }
-    return result;
+    return null;
   }
 
 }

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageComboBoxRenderer.java
Patch:
@@ -51,11 +51,11 @@ class LanguageComboBoxRenderer extends JLabel implements ListCellRenderer<Langua
   }
 
   private String getTranslatedName(Language language) {
+    String name = language.getTranslatedName(messages);
     if (language.isExternal()) {
-      return language.getName() + extLangSuffix;
-    } else {
-      return language.getTranslatedName(messages);
+      name += extLangSuffix;
     }
+    return name;
   }
 
   @Override

File: languagetool-standalone/src/main/java/org/languagetool/gui/Main.java
Patch:
@@ -978,6 +978,7 @@ public void run() {
       });
     } else {
       printUsage();
+      System.exit(1);
     }
   }
 

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -227,7 +227,7 @@ public void handle(HttpExchange httpExchange) throws IOException {
         response = "Checking took longer than " + maxCheckTimeMillis/1000 + " seconds, which is this server's limit. " +
                    "Please make sure you have selected the proper language or consider submitting a shorter text.";
       } else {
-        response = Tools.getFullStackTrace(e);
+        response = "Internal Error. Please contact the site administrator.";
         errorCode = HttpURLConnection.HTTP_INTERNAL_ERROR;
       }
       logError(text, remoteAddress, e, errorCode, httpExchange);

File: languagetool-http-client/src/test/java/org/languagetool/remote/RemoteLanguageToolIntegrationTest.java
Patch:
@@ -86,7 +86,7 @@ public void testClient() throws MalformedURLException {
 
       CheckConfiguration enabledConfig = new CheckConfigurationBuilder("en").enabledRuleIds("EN_A_VS_AN").build();
       RemoteResult result3 = lt.check("A sentence with a error, and and another one", enabledConfig);
-      assertThat(result1.getMatches().size(), is(2));
+      assertThat(result3.getMatches().size(), is(2));
 
       CheckConfiguration enabledOnlyConfig = new CheckConfigurationBuilder("en").enabledRuleIds("EN_A_VS_AN").enabledOnly().build();
       RemoteResult result4 = lt.check("A sentence with a error, and and another one", enabledOnlyConfig);

File: languagetool-http-client/src/test/java/org/languagetool/remote/RemoteLanguageToolIntegrationTest.java
Patch:
@@ -67,6 +67,7 @@ public void testClient() throws MalformedURLException {
       assertThat(lt.check("Sentence wiht a typo not detected.", "en").getMatches().size(), is(0));
       assertThat(lt.check("Sentence wiht a typo detected.", "en-US").getMatches().size(), is(1));
       assertThat(lt.check("A sentence with a error.", "en").getMatches().size(), is(1));
+      assertThat(lt.check("Test escape: %", "en").getMatches().size(), is(0));
 
       RemoteResult result1 = lt.check("A sentence with a error, and and another one", "en");
       assertThat(result1.getLanguage(), is("English"));

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServer.java
Patch:
@@ -126,7 +126,7 @@ public void stop() {
   }
 
   public static void main(String[] args) {
-    if (args.length > 5 || usageRequested(args)) {
+    if (args.length > 7 || usageRequested(args)) {
       System.out.println("Usage: " + HTTPServer.class.getSimpleName() + " [--config propertyFile] [--port|-p port] [--public]");
       System.out.println("  --config FILE  a Java property file (one key=value entry per line) with values for:");
       printCommonConfigFileOptions();

File: languagetool-language-modules/pl/src/main/java/org/languagetool/language/Polish.java
Patch:
@@ -116,7 +116,6 @@ public Contributor[] getMaintainers() {
   public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
     return Arrays.asList(
         new CommaWhitespaceRule(messages),
-        new DoublePunctuationRule(messages),
         new UppercaseSentenceStartRule(messages, this),
         new WordRepeatRule(messages, this),
         new MultipleWhitespaceRule(messages, this),

File: languagetool-language-modules/de/src/main/java/org/languagetool/tagging/de/GermanTagger.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.Collections;
 import java.util.List;
 
+import org.apache.commons.lang.StringUtils;
 import org.jetbrains.annotations.Nullable;
 import org.languagetool.AnalyzedToken;
 import org.languagetool.AnalyzedTokenReadings;
@@ -86,7 +87,7 @@ public List<AnalyzedTokenReadings> tag(List<String> sentenceTokens, boolean igno
       List<TaggedWord> taggerTokens = getWordTagger().tag(word);
       if (firstWord && taggerTokens.size() == 0 && ignoreCase) { // e.g. "Das" -> "das" at start of sentence
         taggerTokens = getWordTagger().tag(word.toLowerCase());
-        firstWord = false;
+        firstWord = StringUtils.isBlank(word);
       }
       if (taggerTokens.size() > 0) {
         l.addAll(getAnalyzedTokens(taggerTokens, word));

File: languagetool-language-modules/de/src/main/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -19,6 +19,7 @@
 package org.languagetool.tokenizers.de;
 
 import java.io.IOException;
+import java.util.Collections;
 import java.util.List;
 
 import de.danielnaber.jwordsplitter.GermanWordSplitter;
@@ -39,6 +40,8 @@ public GermanCompoundTokenizer() throws IOException {
   
   public GermanCompoundTokenizer(boolean strictMode) throws IOException {
     wordSplitter = new GermanWordSplitter(false);
+    // add exceptions here so we don't need to update JWordSplitter for every exception we find:  
+    wordSplitter.addException("Maskerade", Collections.singletonList("Maskerade"));
     wordSplitter.setStrictMode(strictMode);
     wordSplitter.setMinimumWordLength(3);
   }

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -219,6 +219,9 @@ public void handle(HttpExchange httpExchange) throws IOException {
       if (e instanceof TextTooLongException) {
         errorCode = HttpURLConnection.HTTP_ENTITY_TOO_LARGE;
         response = e.getMessage();
+      } else if (e instanceof IllegalArgumentException) {
+        errorCode = HttpURLConnection.HTTP_BAD_REQUEST;
+        response = e.getMessage();
       } else if (e.getCause() != null && e.getCause() instanceof TimeoutException) {
         errorCode = HttpURLConnection.HTTP_UNAVAILABLE;
         response = "Checking took longer than " + maxCheckTimeMillis/1000 + " seconds, which is this server's limit. " +

File: languagetool-core/src/main/java/org/languagetool/rules/CategoryId.java
Patch:
@@ -40,8 +40,8 @@ public CategoryId(String id) {
   public boolean equals(Object o) {
     if (this == o) return true;
     if (o == null || getClass() != o.getClass()) return false;
-    CategoryId that = (CategoryId) o;
-    if (!id.equals(that.id)) return false;
+    CategoryId other = (CategoryId) o;
+    if (!id.equals(other.id)) return false;
     return true;
   }
 

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -627,7 +627,7 @@ public static String getSupportedLanguagesAsXML() {
     return xmlBuffer.toString();
   }
 
-  private class QueryParams {
+  private static class QueryParams {
     final List<String> enabledRules;
     final List<String> disabledRules;
     final List<CategoryId> enabledCategories;

File: languagetool-server/src/main/java/org/languagetool/server/Server.java
Patch:
@@ -143,6 +143,7 @@ protected void afterExecute(Runnable r, Throwable t) {
       super.afterExecute(r, t);
       if (t != null && t instanceof OutOfMemoryError) {
         // we prefer to stop instead of being in an unstable state:
+        //noinspection CallToPrintStackTrace
         t.printStackTrace();
         System.exit(1);
       }

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/dumpcheck/CompactStdoutHandler.java
Patch:
@@ -38,6 +38,7 @@ class CompactStdoutHandler extends ResultHandler {
     contextTools.setContextSize(70);
     contextTools.setErrorMarkerStart("**");
     contextTools.setErrorMarkerEnd("**");
+    contextTools.setEscapeHtml(false);
   }
 
   @Override
@@ -47,7 +48,7 @@ protected void handleResult(Sentence sentence, List<RuleMatch> ruleMatches, Lang
         String ruleId = match.getRule().getId();
         if (match.getRule() instanceof AbstractPatternRule) {
           AbstractPatternRule pRule = (AbstractPatternRule) match.getRule();
-          ruleId += "[" + pRule.getSubId() + "]";
+          ruleId = pRule.getFullId();
         }
         System.out.println(ruleId + ": " + contextTools.getContext(match.getFromPos(), match.getToPos(), sentence.getText()));
         checkMaxErrors(++errorCount);

File: languagetool-language-modules/de/src/test/java/org/languagetool/tokenizers/de/GermanSRXSentenceTokenizerTest.java
Patch:
@@ -45,6 +45,7 @@ public void testTokenize() {
     testSplit("Natürliche Vererbungsprozesse prägten sich erst im 18. und frühen 19. Jahrhundert aus.");
     testSplit("Das ist ja 1a. ", "Und das auch.");
     testSplit("Hallo, ich bin’s. ", "Könntest du kommen?");
+    testSplit("In der 1. Bundesliga kam es zum Eklat.");
 
     testSplit("Friedrich I., auch bekannt als Friedrich der Große.");
     testSplit("Friedrich II., auch bekannt als Friedrich der Große.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -47,6 +47,9 @@ public void setUp() throws IOException {
   
   public void testWrongVerb() throws IOException {
     // correct sentences:
+    assertGood("Kümmere du dich mal nicht darum!");
+    assertGood("Ich weiß, was ich tun werde, falls etwas geschehen sollte.");
+    assertGood("...die dreißig Jahre jünger als ich ist.");
     assertGood("Ein Mann wie ich braucht einen Hut.");
     assertGood("Egal, was er sagen wird, ich habe meine Entscheidung getroffen.");
     assertGood("Du Beharrst darauf, dein Wörterbuch hätte recht, hast aber von den Feinheiten des Japanischen keine Ahnung!");

File: languagetool-language-modules/de/src/test/java/org/languagetool/tokenizers/de/GermanSRXSentenceTokenizerTest.java
Patch:
@@ -44,6 +44,7 @@ public void testTokenize() {
     testSplit("Das Schreiben ist auf den 3.10.2000 datiert.");
     testSplit("Natürliche Vererbungsprozesse prägten sich erst im 18. und frühen 19. Jahrhundert aus.");
     testSplit("Das ist ja 1a. ", "Und das auch.");
+    testSplit("Hallo, ich bin’s. ", "Könntest du kommen?");
 
     testSplit("Friedrich I., auch bekannt als Friedrich der Große.");
     testSplit("Friedrich II., auch bekannt als Friedrich der Große.");
@@ -92,7 +93,8 @@ public void testTokenize() {
     testSplit("Stimme am lautesten heraustönte …. ", "Sobald er auf der Straße war");
 //    testSplit(new String[] { "Aber nein doch, er hörte alles nur zu deutlich! ", "\n", "… ", "›Also, wenn's so ist" });
     testSplit("»Welche Wohnung?\" ", "»Die, wo wir arbeiten.");
-    testSplit("»Nun also, wie ist's?« fragte Lushin und blickte sie fest an.");
+    testSplit("»Nun also, wie ist's?« ", "fragte Lushin und blickte sie fest an.");
+    testSplit("»Nun also, wie ist es?« ", "fragte Lushin und blickte sie fest an.");
 //    testSplit(new String[] { "gezeigt hat.« ", "… ", "Hm! " });
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -108,12 +108,12 @@ public void startElement(final String namespaceURI, final String lName,
         break;
       case "regexp":
         inRegex = true;
-        regex = new StringBuilder();
         regexMode = "exact".equals(attrs.getValue("type")) ? RegexpMode.EXACT : RegexpMode.SMART;
         regexCaseSensitive = attrs.getValue(CASE_SENSITIVE) != null && YES.equals(attrs.getValue(CASE_SENSITIVE));
         regexpMark = attrs.getValue(MARK) != null ? Integer.parseInt(attrs.getValue(MARK)) : 0;
         break;
       case RULE:
+        regex = new StringBuilder();
         inRule = true;
         shortMessage = new StringBuilder();
         message = new StringBuilder();
@@ -549,7 +549,7 @@ private void createRules(List<PatternToken> elemList,
         }
         rule = new RegexPatternRule(id, name, message.toString(), suggestionsOutMsg.toString(), language, Pattern.compile(regexStr, flags), regexpMark);
       } else {
-        throw new IllegalStateException("Neither pattern tokens nor regex is set");
+        throw new IllegalStateException("Neither '<pattern>' tokens nor '<regex>' is set in rule '" + id + "'");
       }
       if (filterClassName != null && filterArgs != null) {
         RuleFilterCreator creator = new RuleFilterCreator();

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -281,7 +281,7 @@ public void testGrammarRulesFromXML(final List<AbstractPatternRule> rules,
         final AbstractPatternRule badRule = complexRules.get(aSet);
         if (badRule != null && badRule instanceof PatternRule) {
           ((PatternRule)badRule).notComplexPhrase();
-          badRule.setMessage("The rule contains a phrase that never matched any incorrect example.");
+          badRule.setMessage("The rule contains a phrase that never matched any incorrect example.\n" + ((PatternRule) badRule).toPatternString());
           badRules.add(badRule);
         }
       }

File: languagetool-core/src/main/java/org/languagetool/tagging/BaseTagger.java
Patch:
@@ -211,7 +211,7 @@ protected List<AnalyzedToken> asAnalyzedTokenListForTaggedWords(final String wor
   protected AnalyzedToken asAnalyzedToken(final String word, final WordData wd) {
     String tag = StringTools.asString(wd.getTag());
     // Remove frequency data from tags (if exists)
-    // The frequency data is in the last byte after a separator
+    // The frequency data is in the last byte (without a separator)
     if (dictionary.metadata.isFrequencyIncluded() && tag.length() > 1) {
       tag = tag.substring(0, tag.length() - 1);
     }

File: languagetool-core/src/main/java/org/languagetool/tagging/MorfologikTagger.java
Patch:
@@ -64,7 +64,7 @@ public List<TaggedWord> tag(String word) {
       for (WordData wordData : lookup) {
         String tag = wordData.getTag() == null ? null : wordData.getTag().toString();
         // Remove frequency data from tags (if exists)
-        // The frequency data is in the last byte after a separator
+        // The frequency data is in the last byte (without a separator)
         if (dictionary.metadata.isFrequencyIncluded() && tag != null && tag.length() > 1) {
           tag = tag.substring(0, tag.length() - 1);
         }

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternTestTools.java
Patch:
@@ -444,7 +444,7 @@ private static void warnIfElementNotKosher(
             // even better <token regexp="yes">[.;:]</token>
             System.err.println("The " + lang + " rule: "
                     + ruleId + ", token [" + tokenIndex + "], contains a single dot (matching any char) "
-                    + "so other single char disjunction are useless within " + "\"" + stringValue
+                    + "so other single char disjunctions are useless within " + "\"" + stringValue
                     + "\". Did you forget forget a backslash before the dot?");
           }
         }

File: languagetool-standalone/src/main/java/org/languagetool/dev/HomophoneOccurrenceDumper.java
Patch:
@@ -35,7 +35,7 @@
 
 /**
  * Dump the occurrences of homophone 3grams to STDOUT. Useful to have a more
- * compare file with homophone occurrences, as searching the homophones and
+ * compact file with homophone occurrences, as searching the homophones and
  * their contexts in the Lucene index requires iterating all terms and is
  * thus slow.
  * @since 2.8

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -176,7 +176,7 @@ public AgreementRule(final ResourceBundle messages, German language) {
     this.language = language;
     super.setCategory(new Category(CategoryIds.GRAMMAR, messages.getString("category_grammar")));
     addExamplePair(Example.wrong("<marker>Der Haus</marker> wurde letztes Jahr gebaut."),
-                   Example.fixed("<marker>Das Haus</marker> wurde letztes Jahr gebaut"));
+                   Example.fixed("<marker>Das Haus</marker> wurde letztes Jahr gebaut."));
   }
   
   @Override

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationPatternRuleReplacer.java
Patch:
@@ -366,6 +366,7 @@ private AnalyzedTokenReadings[] executeAction(final AnalyzedSentence sentence,
         // only apply filter rule when it matches previous tags:
         for (int i = 0; i < whTokens[fromPos].getReadingsLength(); i++) {
           if (!whTokens[fromPos].getAnalyzedToken(i).hasNoTag() &&
+              whTokens[fromPos].getAnalyzedToken(i).getPOSTag() != null &&
               whTokens[fromPos].getAnalyzedToken(i).getPOSTag().matches(disambiguatedPOS)) {
             newPOSmatches = true;
             break;

File: languagetool-language-modules/uk/src/main/java/org/languagetool/language/Ukrainian.java
Patch:
@@ -50,8 +50,6 @@
 import org.languagetool.tokenizers.uk.UkrainianWordTokenizer;
 
 public class Ukrainian extends Language {
-  public static final String RULE_CATEGORY_STYLE = "Стиль";
-
   private static final List<String> RULE_FILES = Arrays.asList(
       "grammar-spelling.xml",
       "grammar-grammar.xml",

File: languagetool-commandline/src/main/java/org/languagetool/commandline/CommandLineParser.java
Patch:
@@ -173,8 +173,9 @@ public void printUsage(PrintStream stream) {
             + "                             it is used in addition of standard rules\n"
             + "  --falsefriends FILE      use external false friend file to be used along with the built-in rules\n"
             + "  --bitextrules  FILE      use external bitext XML rule file (useful only in bitext mode)\n"
-            + "  --languagemodel DIR      a directory with '1grams'...'3grams' sub directories with Lucene indexes that\n"
-            + "                           contain ngram occurrence counts; activates the confusion rule if supported\n"
+            + "  --languagemodel DIR      a directory with e.g. 'en' sub directory (i.e. a language code) that contains\n"
+            + "                           '1grams'...'3grams' sub directories with Lucene indexes with\n"
+            + "                           ngram occurrence counts; activates the confusion rule if supported\n"
             + "  --xmlfilter              remove XML/HTML elements from input before checking (this is deprecated)\n"
             + "  --line-by-line           work on file line by line (for development, e.g. inside an IDE)"
     );

File: languagetool-dev/src/main/java/org/languagetool/dev/bigdata/FrequencyIndexCreator.java
Patch:
@@ -55,7 +55,7 @@ public class FrequencyIndexCreator {
   private static final String NAME_REGEX3 = "([_a-z0-9]{1,2}|other|pos|punctuation|_(ADJ|ADP|ADV|CONJ|DET|NOUN|NUM|PRON|PRT|VERB)_)";  // result of FrequencyIndexCreator with text mode
   private static final int BUFFER_SIZE = 16384;
   private static final String LT_COMPLETE_MARKER = "languagetool_index_complete";
-  private static final boolean IGNORE_POS = false;
+  private static final boolean IGNORE_POS = true;
 
   private enum Mode { PlainText, Lucene }
 

File: languagetool-core/src/main/java/org/languagetool/languagemodel/MultiLanguageModel.java
Patch:
@@ -47,7 +47,7 @@ public Probability getPseudoProbability(List<String> context) {
       //System.out.println(i + ". " + pProb.getProb() + " (" + pProb.getCoverage() + ")");
       // TODO: decide what's the proper way to combine the probabilities
       prob += pProb.getProb();
-      coverage += pProb.getProb();
+      coverage += pProb.getCoverage();
       occurrences += pProb.getOccurrences();
     }
     return new Probability(prob, coverage/lms.size(), occurrences);

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -239,11 +239,12 @@ private void validateRuleIds(Language lang, JLanguageTool languageTool) {
 
   private void assertIdUniqueness(Set<String> ids, Set<Class> ruleClasses, Language language, Rule rule) {
     final String ruleId = rule.getId();
-    if (ids.contains(ruleId) && !ruleClasses.contains(rule.getClass())) {
+    Class relevantClass = rule instanceof AbstractPatternRule ? AbstractPatternRule.class : rule.getClass();
+    if (ids.contains(ruleId) && !ruleClasses.contains(relevantClass)) {
       throw new RuntimeException("Rule id occurs more than once: '" + ruleId + "', language: " + language);
     }
     ids.add(ruleId);
-    ruleClasses.add(rule.getClass());
+    ruleClasses.add(relevantClass);
   }
 
   private void disableSpellingRules(JLanguageTool languageTool) {

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java
Patch:
@@ -128,6 +128,8 @@ protected List<String> getAdditionalTopSuggestions(List<String> suggestions, Str
       return Arrays.asList("through");
     } else if ("speach".equals(word)) {  // the replacement pairs would prefer "speak"
       return Arrays.asList("speech");
+    } else if ("icecreem".equals(word)) {
+      return Arrays.asList("ice cream");
     }
     return super.getAdditionalTopSuggestions(suggestions, word);
   }

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -99,7 +99,7 @@ protected void runGrammarRulesFromXmlTest() throws IOException {
   }
 
   private void runGrammarRuleForLanguage(Language lang) throws IOException {
-    if (skipCountryVariant(lang)) {
+    if (skipCountryVariant(lang) && !lang.getShortNameWithCountryAndVariant().equals("ca-ES")) {
       System.out.println("Skipping " + lang + " because there are no specific rules for that variant");
       return;
     }

File: languagetool-language-modules/pl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -113,7 +113,7 @@ public List<AbstractPatternRule> getPatternRules() {
             "PREP_SUBST_2[1]: powodu[powód/subst:sg:gen:m3] -> powodu[powód/subst:sg:gen:m3]\n" +
             "MULTIWORD_CHUNKER: powodu[powód/subst:sg:gen:m3] -> powodu[powód/subst:sg:gen:m3,Z powodu/</PREP:GEN>]\n" +
             "\n" +
-            "PREP_SUBST[10]: pogody[pogoda/subst:pl:acc:f,pogoda/subst:pl:nom:f,pogoda/subst:pl:voc:f,pogoda/subst:sg:gen:f] -> pogody[pogoda/subst:sg:gen:f]\n" +
+            "PREP_SUBST[11]: pogody[pogoda/subst:pl:acc:f,pogoda/subst:pl:nom:f,pogoda/subst:pl:voc:f,pogoda/subst:sg:gen:f] -> pogody[pogoda/subst:sg:gen:f]\n" +
             "\n" +
             "WIELKI_SWOJ_ADJ[1]: dobre[dobre/subst:pl:acc:n2,dobre/subst:pl:nom:n2,dobre/subst:pl:voc:n2,dobre/subst:sg:acc:n2,dobre/subst:sg:nom:n2,dobre/subst:sg:voc:n2,dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos,dobry/depr:pl:nom:m2,dobry/depr:pl:voc:m2,dobry/subst:pl:acc:m3,dobry/subst:pl:nom:m3,dobry/subst:pl:voc:m3] -> dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos]\n" +
             "unify_adj_subst[2]: dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos] -> dobre[dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos]\n" +

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/index/Searcher.java
Patch:
@@ -362,7 +362,7 @@ public static void main(String[] args) throws Exception {
     final String languageCode = args[1];
     final Language language = Languages.getLanguageForShortName(languageCode);
     final File indexDir = new File(args[2]);
-    final boolean limitSearch = args.length > 3 && "--no_limit".equals(args[3]);
+    final boolean limitSearch = !(args.length > 3 && "--no_limit".equals(args[3]));
     final Searcher searcher = new Searcher(new SimpleFSDirectory(indexDir.toPath()));
     if (!limitSearch) {
       searcher.setMaxHits(100_000);

File: languagetool-dev/src/main/java/org/languagetool/dev/bigdata/ConfusionRuleEvaluator.java
Patch:
@@ -78,7 +78,7 @@ class ConfusionRuleEvaluator {
       ConfusionProbabilityRule foundRule = null;
       for (Rule rule : rules) {
         if (rule.getId().equals(ConfusionProbabilityRule.RULE_ID)) {
-          foundRule = (ConfusionProbabilityRule)rules.get(0);
+          foundRule = (ConfusionProbabilityRule)rule;
           break;
         }
       }

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/RussianUnpairedBracketsRule.java
Patch:
@@ -38,7 +38,7 @@ public RussianUnpairedBracketsRule(final ResourceBundle messages, final Language
     super(messages, RU_START_SYMBOLS, RU_END_SYMBOLS);
     numerals = NUMERALS_RU;
     addExamplePair(Example.wrong("Самоотверженный поступок Оленина <marker>(</marker>подарок Лукашке коня вызывает лишь удивление и усиливает недоверие к нему станичников."),
-                   Example.fixed("Самоотверженный поступок Оленина <marker>(</marker>подарок Лукашке коня вызывает лишь удивление и усиливает недоверие к нему станичников."));
+                   Example.fixed("Самоотверженный поступок Оленина <marker>(</marker>подарок Лукашке коня) вызывает лишь удивление и усиливает недоверие к нему станичников."));
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/synthesis/BaseSynthesizer.java
Patch:
@@ -122,8 +122,7 @@ public String[] synthesize(final AnalyzedToken token, final String posTag,
       initPossibleTags();
       final Pattern p = Pattern.compile(posTag);
       final List<String> results = new ArrayList<>();
-
-      for (final String tag : possibleTags) {
+      for (String tag : possibleTags) {
         final Matcher m = p.matcher(tag);
         if (m.matches()) {
           lookup(token.getLemma(), tag, results);

File: languagetool-language-modules/pl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -113,7 +113,7 @@ public List<AbstractPatternRule> getPatternRules() {
             "PREP_SUBST_2[1]: powodu[powód/subst:sg:gen:m3] -> powodu[powód/subst:sg:gen:m3]\n" +
             "MULTIWORD_CHUNKER: powodu[powód/subst:sg:gen:m3] -> powodu[powód/subst:sg:gen:m3,Z powodu/</PREP:GEN>]\n" +
             "\n" +
-            "PREP_SUBST[9]: pogody[pogoda/subst:pl:acc:f,pogoda/subst:pl:nom:f,pogoda/subst:pl:voc:f,pogoda/subst:sg:gen:f] -> pogody[pogoda/subst:sg:gen:f]\n" +
+            "PREP_SUBST[10]: pogody[pogoda/subst:pl:acc:f,pogoda/subst:pl:nom:f,pogoda/subst:pl:voc:f,pogoda/subst:sg:gen:f] -> pogody[pogoda/subst:sg:gen:f]\n" +
             "\n" +
             "WIELKI_SWOJ_ADJ[1]: dobre[dobre/subst:pl:acc:n2,dobre/subst:pl:nom:n2,dobre/subst:pl:voc:n2,dobre/subst:sg:acc:n2,dobre/subst:sg:nom:n2,dobre/subst:sg:voc:n2,dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos,dobry/depr:pl:nom:m2,dobry/depr:pl:voc:m2,dobry/subst:pl:acc:m3,dobry/subst:pl:nom:m3,dobry/subst:pl:voc:m3] -> dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos]\n" +
             "unify_adj_subst[2]: dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos] -> dobre[dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos]\n" +

File: languagetool-core/src/main/java/org/languagetool/rules/ngrams/NgramProbabilityRule.java
Patch:
@@ -190,6 +190,9 @@ private Alternatives getBetterAlternatives(GoogleToken prevToken, String token,
           Probability newProb = lm.getPseudoProbability(newNgram);
           if (newProb.getProb() * 1000000L > p.getProb()) {  // TODO: this is a good factor - find the best one (3gram vs. 4gram)
             betterAlternatives.add(new Alternative(replacement, newProb));
+            debug("More probable: %s\n", replacement);
+          } else {
+            debug("Less probable: %s\n", replacement);
           }
           alternativesConsidered = true;
         }

File: languagetool-dev/src/main/java/org/languagetool/dev/errorcorpus/SimpleCorpus.java
Patch:
@@ -76,6 +76,9 @@ private ErrorSentence getIncorrectSentence(String line) {
     String normalizedNoCorrection = normalized.replaceFirst("=>.*", "").trim();
     int startError = normalized.indexOf('_');
     int endError = normalized.indexOf('_', startError+1);
+    if (startError == -1 || endError == -1) {
+      throw new RuntimeException("No '_..._' marker found: " + line);
+    }
     int startCorrectionMarker = normalized.indexOf("=>");
     if (startCorrectionMarker == -1) {
       throw new RuntimeException("No '=>' marker found: " + line);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -152,6 +152,9 @@ public void testDetNounRule() throws IOException {
     assertGood("Wenn dies großen Erfolg hat, werden wir es weiter fördern.");
     assertGood("Die Ereignisse dieses einen Jahres waren sehr schlimm.");
     assertGood("Er musste einen Hochwasser führenden Fluss nach dem anderen überqueren.");
+    assertGood("Darf ich Ihren Füller für ein paar Minuten ausleihen?");
+    assertGood("Bringen Sie diesen Gepäckaufkleber an Ihrem Gepäck an.");
+    assertGood("Extras, die den Wert Ihres Autos erhöhen.");
 
     // incorrect sentences:
     assertBad("Es sind die Tisch.", "dem Tisch", "den Tisch", "der Tisch", "die Tische");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -210,6 +210,9 @@ public void testDetNounRule() throws IOException {
     //assertBad("Ich gebe dir das kleines Kaninchen.");  // already detected by ART_ADJ_SOL
     //assertBad("Ich gebe dir das klein Kaninchen.");  // already detected by MEIN_KLEIN_HAUS
     assertGood("Ich gebe dir das kleine Kaninchen.");
+    
+    assertBad("Hier steht Ihre Text.");
+    assertBad("Hier steht ihre Text.");
 
     // TODO: not yet detected:
     //assertBad("Erst recht wir fleißiges Arbeiter.");

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationPatternRuleReplacer.java
Patch:
@@ -204,7 +204,7 @@ private AnalyzedTokenReadings[] executeAction(final AnalyzedSentence sentence,
         }
       }
 
-      for (int l = 0; l <= startPositionCorrection; l++) {
+      for (int l = 0; l <= startPositionCorrection && tokenPositionList.size() > l; l++) {
         correctedStPos += tokenPositionList.get(l);
       }
 

File: languagetool-language-modules/pl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -113,7 +113,7 @@ public List<AbstractPatternRule> getPatternRules() {
             "PREP_SUBST_2[1]: powodu[powód/subst:sg:gen:m3] -> powodu[powód/subst:sg:gen:m3]\n" +
             "MULTIWORD_CHUNKER: powodu[powód/subst:sg:gen:m3] -> powodu[powód/subst:sg:gen:m3,Z powodu/</PREP:GEN>]\n" +
             "\n" +
-            "PREP_SUBST[8]: pogody[pogoda/subst:pl:acc:f,pogoda/subst:pl:nom:f,pogoda/subst:pl:voc:f,pogoda/subst:sg:gen:f] -> pogody[pogoda/subst:sg:gen:f]\n" +
+            "PREP_SUBST[9]: pogody[pogoda/subst:pl:acc:f,pogoda/subst:pl:nom:f,pogoda/subst:pl:voc:f,pogoda/subst:sg:gen:f] -> pogody[pogoda/subst:sg:gen:f]\n" +
             "\n" +
             "WIELKI_SWOJ_ADJ[1]: dobre[dobre/subst:pl:acc:n2,dobre/subst:pl:nom:n2,dobre/subst:pl:voc:n2,dobre/subst:sg:acc:n2,dobre/subst:sg:nom:n2,dobre/subst:sg:voc:n2,dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos,dobry/depr:pl:nom:m2,dobry/depr:pl:voc:m2,dobry/subst:pl:acc:m3,dobry/subst:pl:nom:m3,dobry/subst:pl:voc:m3] -> dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos]\n" +
             "unify_adj_subst[2]: dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos] -> dobre[dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos]\n" +

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/SubjectVerbAgreementRule.java
Patch:
@@ -195,9 +195,6 @@ private boolean hasUnknownTokenToTheRight(AnalyzedTokenReadings[] tokens, int st
   }
 
   private boolean hasUnknownTokenAt(AnalyzedTokenReadings[] tokens, int startPos, int endPos) {
-    if (endPos < startPos) {
-      throw new RuntimeException("endPos < startPos: " + endPos  + " < " +  startPos);
-    }
     for (int i = startPos; i < endPos; i++) {
       AnalyzedTokenReadings token = tokens[i];
       for (AnalyzedToken analyzedToken : token.getReadings()) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -80,6 +80,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Eine Stadt, in der zurzeit eine rege Bautätigkeit herrscht.");
     assertGood("... wo es zu einer regen Bautätigkeit kam.");
     assertGood("Mancher ausscheidende Politiker hinterlässt eine Lücke.");
+    assertGood("Kern einer jeden Tragödie ist es, ..");
 
     assertGood("Das Dach von meinem Auto.");
     assertGood("Das Dach von meinen Autos.");

File: languagetool-commandline/src/test/java/org/languagetool/commandline/MainTest.java
Patch:
@@ -567,7 +567,7 @@ public void testValencianCatalan() throws Exception {
     Main.main(args);
     String stdout = new String(this.out.toByteArray());
     String stderr = new String(this.err.toByteArray());
-    assertTrue(stderr.indexOf("Expected text language: Catalan (Valencian)\n") == 0);
+    assertTrue(stderr.indexOf("Expected text language: Catalan (Valencian)") == 0);
     assertTrue(stdout.contains("EXIGEIX_VERBS_VALENCIANS"));
   }
 
@@ -577,7 +577,7 @@ public void testCatalan() throws Exception {
     Main.main(args);
     String stdout = new String(this.out.toByteArray());
     String stderr = new String(this.err.toByteArray());
-    assertTrue(stderr.indexOf("Expected text language: Catalan\n") == 0);
+    assertTrue(stderr.indexOf("Expected text language: Catalan") == 0);
     assertTrue(stdout.contains("EXIGEIX_VERBS_CENTRAL"));
   }
 
@@ -587,7 +587,7 @@ public void testCatalan2() throws Exception {
     Main.main(args);
     String stdout = new String(this.out.toByteArray());
     String stderr = new String(this.err.toByteArray());
-    assertTrue(stderr.indexOf("Expected text language: Catalan\n") == 0);
+    assertTrue(stderr.indexOf("Expected text language: Catalan") == 0);
     assertTrue(stdout.contains("EXIGEIX_VERBS_CENTRAL"));
   }
 

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternTestTools.java
Patch:
@@ -161,7 +161,7 @@ public static void warnIfRegexpSyntaxNotKosher(final List<PatternToken> patternT
                         (exception.isCaseSensitive() ? "" : "(?i)") +  pToken.getString())) {
                   System.err.println("The " + lang + " rule: "
                           + ruleId + "[" + ruleSubId + "] has exception word ["
-                          +  exception.getString() + "] which cannot match the"
+                          +  exception.getString() + "] which cannot match the "
                           + "regexp token [" + i + "] [" + pToken.getString()
                           + "] so exception seems useless, "
                           + "or did you forget skip=\"...\" or scope=\"previous\"?");

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -50,7 +50,7 @@
  */
 public class English extends Language implements AutoCloseable {
 
-  private static final Language BRITISH_ENGLISH = new BritishEnglish();
+  private static final Language AMERICAN_ENGLISH = new AmericanEnglish();
 
   private Tagger tagger;
   private Chunker chunker;
@@ -70,7 +70,7 @@ public English() {
 
   @Override
   public Language getDefaultLanguageVariant() {
-    return BRITISH_ENGLISH;
+    return AMERICAN_ENGLISH;
   }
 
   @Override

File: languagetool-standalone/src/test/java/org/languagetool/LanguagesTest.java
Patch:
@@ -146,7 +146,7 @@ public void testGetLanguageForLocale() {
     assertEquals("en-US", Languages.getLanguageForLocale(new Locale("en", "US")).getShortNameWithCountryAndVariant());
     assertEquals("en-GB", Languages.getLanguageForLocale(new Locale("en", "GB")).getShortNameWithCountryAndVariant());
     // fallback to the language's default variant if not specified:
-    assertEquals("en-GB", Languages.getLanguageForLocale(new Locale("en")).getShortNameWithCountryAndVariant());
+    assertEquals("en-US", Languages.getLanguageForLocale(new Locale("en")).getShortNameWithCountryAndVariant());
     assertEquals("de-DE", Languages.getLanguageForLocale(new Locale("de")).getShortNameWithCountryAndVariant());
     assertEquals("pl-PL", Languages.getLanguageForLocale(new Locale("pl")).getShortNameWithCountryAndVariant());
     // final fallback is everything else fails:

File: languagetool-standalone/src/test/java/org/languagetool/LanguagesTest.java
Patch:
@@ -146,7 +146,7 @@ public void testGetLanguageForLocale() {
     assertEquals("en-US", Languages.getLanguageForLocale(new Locale("en", "US")).getShortNameWithCountryAndVariant());
     assertEquals("en-GB", Languages.getLanguageForLocale(new Locale("en", "GB")).getShortNameWithCountryAndVariant());
     // fallback to the language's default variant if not specified:
-    assertEquals("en-US", Languages.getLanguageForLocale(new Locale("en")).getShortNameWithCountryAndVariant());
+    assertEquals("en-GB", Languages.getLanguageForLocale(new Locale("en")).getShortNameWithCountryAndVariant());
     assertEquals("de-DE", Languages.getLanguageForLocale(new Locale("de")).getShortNameWithCountryAndVariant());
     assertEquals("pl-PL", Languages.getLanguageForLocale(new Locale("pl")).getShortNameWithCountryAndVariant());
     // final fallback is everything else fails:

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -50,7 +50,7 @@
  */
 public class English extends Language implements AutoCloseable {
 
-  private static final Language AMERICAN_ENGLISH = new AmericanEnglish();
+  private static final Language BRITISH_ENGLISH = new BritishEnglish();
 
   private Tagger tagger;
   private Chunker chunker;
@@ -70,7 +70,7 @@ public English() {
 
   @Override
   public Language getDefaultLanguageVariant() {
-    return AMERICAN_ENGLISH;
+    return BRITISH_ENGLISH;
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/rules/ngrams/Probability.java
Patch:
@@ -45,14 +45,14 @@ public Probability(double prob, float coverage) {
   }
 
   /**
-   * A probability-like value, but can be filled with any float >= 0.
+   * A probability-like value, but can be filled with any float &gt;= 0.
    */
   public double getProb() {
     return prob;
   }
 
   /**
-   * The fraction of lookups that had occurrence counts > 0. This
+   * The fraction of lookups that had occurrence counts &gt; 0. This
    * might be used to ignore the whole probability for low coverage items.
    */
   public float getCoverage() {

File: languagetool-dev/src/main/java/org/languagetool/dev/MissingGenitiveFinder.java
Patch:
@@ -33,7 +33,7 @@
  * One-time script: find missing "-es" forms in the German tagger dictionary,
  * e.g. Morphy knows "Antrag" and "Antrags", but not "Antrages".
  * Uses Google n-gram data as a filter, but may nonetheless create
- * forms that aren't common anymore (e.g. Verb -> Verbes).
+ * forms that aren't common anymore (e.g. Verb -&gt; Verbes).
  * 
  * @author Daniel Naber
  */

File: languagetool-dev/src/main/java/org/languagetool/dev/errorcorpus/SimpleCorpus.java
Patch:
@@ -34,8 +34,8 @@
 /**
  * Access to a simple error corpus with this format:
  * <pre>
- * 1. This is _a_ error. => an
- * 2. Here _come_ another example. => comes
+ * 1. This is _a_ error. =&gt; an
+ * 2. Here _come_ another example. =&gt; comes
  * </pre>
  * @since 3.2
  */

File: languagetool-standalone/src/main/java/org/languagetool/dev/DictionaryBuilder.java
Patch:
@@ -37,7 +37,7 @@
 
 /**
  * Create a Morfologik binary dictionary from plain text data.
- * @deprecated Please use {@link org.languagetool.tools.DictionaryBuilder}
+ * @deprecated Please use {@code org.languagetool.tools.DictionaryBuilder}
  */
 @Deprecated
 class DictionaryBuilder {

File: languagetool-standalone/src/main/java/org/languagetool/dev/POSDictionaryBuilder.java
Patch:
@@ -25,7 +25,7 @@
 /**
  * Create a Morfologik binary dictionary from plain text data.
  * @since public since 2.8
- * @deprecated Please use {@link org.languagetool.tools.POSDictionaryBuilder}
+ * @deprecated Please use {@code org.languagetool.tools.POSDictionaryBuilder}
  */
 @Deprecated
 public final class POSDictionaryBuilder extends DictionaryBuilder {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -463,7 +463,7 @@ private Set<String> getAgreementCategories(final AnalyzedTokenReadings aToken, S
           set.add(makeString(reading.getCasus(), reading.getNumerus(), GermanToken.Genus.NEUTRUM, reading.getDetermination(), omit));
         }
       } else {
-        if (reading.getDetermination() == null || "jed".equals(tmpReading.getLemma())) {  // "jeder" etc. needs a special case to avoid false alarm
+        if (reading.getDetermination() == null || "jed".equals(tmpReading.getLemma()) || "manch".equals(tmpReading.getLemma())) {  // "jeder" etc. needs a special case to avoid false alarm
           set.add(makeString(reading.getCasus(), reading.getNumerus(), reading.getGenus(), GermanToken.Determination.DEFINITE, omit));
           set.add(makeString(reading.getCasus(), reading.getNumerus(), reading.getGenus(), GermanToken.Determination.INDEFINITE, omit));
         } else {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -79,6 +79,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Klebe ein Preisschild auf jedes einzelne Produkt.");
     assertGood("Eine Stadt, in der zurzeit eine rege Bautätigkeit herrscht.");
     assertGood("... wo es zu einer regen Bautätigkeit kam.");
+    assertGood("Mancher ausscheidende Politiker hinterlässt eine Lücke.");
 
     assertGood("Das Dach von meinem Auto.");
     assertGood("Das Dach von meinen Autos.");

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/Hunspell.java
Patch:
@@ -60,7 +60,7 @@ public static Hunspell getInstance() throws UnsatisfiedLinkError, UnsupportedOpe
      *
      * @param libDir Optional absolute directory where the native lib can be found. 
      */
-    public static Hunspell getInstance(String libDir) throws UnsatisfiedLinkError, UnsupportedOperationException { 
+    public static synchronized Hunspell getInstance(String libDir) throws UnsatisfiedLinkError, UnsupportedOperationException {
         if (hunspell != null) {
             return hunspell;
         }

File: languagetool-dev/src/main/java/org/languagetool/dev/eval/SimpleCorpusEvaluator.java
Patch:
@@ -52,7 +52,7 @@ public class SimpleCorpusEvaluator {
   private static final double END_THRESHOLD   = 0.00000000000000001;
   private static final double STEP_FACTOR     = 0.1;
 
-  private static EnglishNgramProbabilityRule probabilityRule;
+  private static volatile EnglishNgramProbabilityRule probabilityRule;
 
   private final Evaluator evaluator;
   private final List<String> badConfusionMatchWords = new ArrayList<>();

File: languagetool-language-modules/en/src/main/java/org/languagetool/chunking/EnglishChunker.java
Patch:
@@ -49,9 +49,9 @@ public class EnglishChunker implements Chunker {
    * that is once created there will never be released. As English has several variants,
    * we'd have as many posModels etc. as we have variants -> huge waste of memory:
    */
-  private static TokenizerModel tokenModel;
-  private static POSModel posModel;
-  private static ChunkerModel chunkerModel;
+  private static volatile TokenizerModel tokenModel;
+  private static volatile POSModel posModel;
+  private static volatile ChunkerModel chunkerModel;
 
   private final EnglishChunkFilter chunkFilter;
 

File: languagetool-language-modules/ro/src/main/java/org/languagetool/synthesis/ro/RomanianSynthesizer.java
Patch:
@@ -66,7 +66,7 @@ protected void initPossibleTags() throws IOException {
     }
   }
 
-  private void initSynth() {
+  private synchronized void initSynth() {
     if (manualSynthesizer == null) {
       try {
         try (InputStream stream = JLanguageTool.getDataBroker().getFromResourceDirAsStream(USER_DICT_FILENAME)) {

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/Hunspell.java
Patch:
@@ -60,7 +60,7 @@ public static Hunspell getInstance() throws UnsatisfiedLinkError, UnsupportedOpe
      *
      * @param libDir Optional absolute directory where the native lib can be found. 
      */
-    public static Hunspell getInstance(String libDir) throws UnsatisfiedLinkError, UnsupportedOperationException { 
+    public static synchronized Hunspell getInstance(String libDir) throws UnsatisfiedLinkError, UnsupportedOperationException {
         if (hunspell != null) {
             return hunspell;
         }

File: languagetool-dev/src/main/java/org/languagetool/dev/eval/SimpleCorpusEvaluator.java
Patch:
@@ -52,7 +52,7 @@ public class SimpleCorpusEvaluator {
   private static final double END_THRESHOLD   = 0.00000000000000001;
   private static final double STEP_FACTOR     = 0.1;
 
-  private static EnglishNgramProbabilityRule probabilityRule;
+  private static volatile EnglishNgramProbabilityRule probabilityRule;
 
   private final Evaluator evaluator;
   private final List<String> badConfusionMatchWords = new ArrayList<>();

File: languagetool-language-modules/en/src/main/java/org/languagetool/chunking/EnglishChunker.java
Patch:
@@ -49,9 +49,9 @@ public class EnglishChunker implements Chunker {
    * that is once created there will never be released. As English has several variants,
    * we'd have as many posModels etc. as we have variants -> huge waste of memory:
    */
-  private static TokenizerModel tokenModel;
-  private static POSModel posModel;
-  private static ChunkerModel chunkerModel;
+  private static volatile TokenizerModel tokenModel;
+  private static volatile POSModel posModel;
+  private static volatile ChunkerModel chunkerModel;
 
   private final EnglishChunkFilter chunkFilter;
 

File: languagetool-language-modules/ro/src/main/java/org/languagetool/synthesis/ro/RomanianSynthesizer.java
Patch:
@@ -66,7 +66,7 @@ protected void initPossibleTags() throws IOException {
     }
   }
 
-  private void initSynth() {
+  private synchronized void initSynth() {
     if (manualSynthesizer == null) {
       try {
         try (InputStream stream = JLanguageTool.getDataBroker().getFromResourceDirAsStream(USER_DICT_FILENAME)) {

File: languagetool-dev/src/main/java/org/languagetool/dev/bigdata/FrequencyIndexCreator.java
Patch:
@@ -52,7 +52,7 @@ public class FrequencyIndexCreator {
   private static final int MIN_YEAR = 1910;
   private static final String NAME_REGEX1 = "googlebooks-[a-z]{3}-all-[1-5]gram-20120701-(.*?).gz";
   private static final String NAME_REGEX2 = "[a-z0-9]+-[a-z0-9]+-[a-z0-9]+-[a-z0-9]+-[a-z0-9]+[_-](.*?).gz";  // Hive result
-  private static final String NAME_REGEX3 = "([_a-z0-9]{1,2}|other|punctuation)";  // result of FrequencyIndexCreator with text mode
+  private static final String NAME_REGEX3 = "([_a-z0-9]{1,2}|other|pos|punctuation|_(ADJ|ADP|ADV|CONJ|DET|NOUN|NUM|PRON|PRT|VERB)_)";  // result of FrequencyIndexCreator with text mode
   private static final int BUFFER_SIZE = 16384;
   private static final String LT_COMPLETE_MARKER = "languagetool_index_complete";
   private static final boolean IGNORE_POS = false;

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/MorfologikUkrainianSpellerRule.java
Patch:
@@ -81,7 +81,7 @@ protected boolean ignoreToken(AnalyzedTokenReadings[] tokens, int idx) throws IO
       }
     }
     
-    if( word.contains("-") || word.endsWith(".") ) {
+    if( word.contains("-") || word.contains("\u2011") || word.endsWith(".") ) {
       return hasGoodTag(tokens[idx]);
     }
 

File: languagetool-language-modules/uk/src/main/java/org/languagetool/tagging/uk/CompoundTagger.java
Patch:
@@ -91,7 +91,7 @@ class CompoundTagger {
 
   static {
     Map<String, List<String>> map2 = new HashMap<>();
-    map2.put("й", Arrays.asList(":m:v_naz", ":m:v_zna"));
+    map2.put("й", Arrays.asList(":m:v_naz", ":m:v_zna", ":f:v_dav", ":f:v_mis"));
     map2.put("го", Arrays.asList(":m:v_rod", ":m:v_zna", ":n:v_rod"));
     map2.put("му", Arrays.asList(":m:v_dav", ":m:v_mis", ":n:v_dav", ":n:v_mis", ":f:v_zna"));  // TODO: depends on the last digit
     map2.put("м", Arrays.asList(":m:v_oru", ":n:v_oru", ":p:v_dav"));
@@ -106,7 +106,7 @@ class CompoundTagger {
 //    map2.put("тою", Arrays.asList(":f:v_oru"));
     map2.put("те", Arrays.asList(":n:v_naz", ":n:v_zna"));
     map2.put("ті", Arrays.asList(":p:v_naz", ":p:v_zna"));
-    map2.put("х", Arrays.asList(":p:v_rod", ":p:v_zna"));
+    map2.put("х", Arrays.asList(":p:v_rod", ":p:v_zna", ":p:v_mis"));
     NUMR_ENDING_MAP = Collections.unmodifiableMap(map2);
     
     rightPartsWithLeftTagMap.put("бо", Pattern.compile("(verb(:rev)?:impr|.*pron|noun|adv|excl|part|predic).*"));

File: languagetool-language-modules/uk/src/test/java/org/languagetool/rules/uk/SimpleReplaceSoftRuleTest.java
Patch:
@@ -41,9 +41,9 @@ public void testRule() throws IOException {
     matches = rule.match(langTool.getAnalyzedSentence("Ці рядки повинні збігатися."));
     assertEquals(0, matches.length);
 
-    matches = rule.match(langTool.getAnalyzedSentence("Цей графин."));
+    matches = rule.match(langTool.getAnalyzedSentence("Цей брелок."));
     assertEquals(1, matches.length);
-    assertEquals(Arrays.asList("карафа", "карафка"), matches[0].getSuggestedReplacements());
+    assertEquals(Arrays.asList("дармовис"), matches[0].getSuggestedReplacements());
 
     // test ignoreTagged
 //    matches = rule.match(langTool.getAnalyzedSentence("щедрота"));

File: languagetool-language-modules/uk/src/test/java/org/languagetool/rules/uk/TokenAgreementRuleTest.java
Patch:
@@ -219,7 +219,7 @@ public void testSpecialChars() throws IOException {
 //    assertEquals(1, matches[1].getFromPos());
 
     assertEquals(27, matches[2].getFromPos());
-    assertEquals(Arrays.asList("воротах", "ворота"), matches[2].getSuggestedReplacements());
+    assertEquals(Arrays.asList("воротах", "воротях", "ворота"), matches[2].getSuggestedReplacements());
   }
 
 }

File: languagetool-language-modules/uk/src/test/java/org/languagetool/synthesis/uk/UkrainianSynthesizerTest.java
Patch:
@@ -37,7 +37,7 @@ public final void testSynthesizeString() throws IOException {
     assertEquals("[міста]", Arrays.toString(synth.synthesize(dummyToken("місто"), "noun:n:v_rod")));
 
     //with regular expressions
-    assertEquals("[найчервонішої, червоної, червонішої]", Arrays.toString(
+    assertEquals("[найчервонішої, червоної, червонішої, щонайчервонішої, якнайчервонішої]", Arrays.toString(
             getSortedArray(synth.synthesize(dummyToken("червоний"), "adj:f:v_rod.*", true))));
     assertEquals("[червоної]", Arrays.toString(
             getSortedArray(synth.synthesize(dummyToken("червоний"), "adj:f:v_rod:compb", true))));

File: languagetool-language-modules/uk/src/test/java/org/languagetool/tagging/disambiguation/rules/uk/UkrainianDisambiguationRuleTest.java
Patch:
@@ -57,7 +57,7 @@ public void testDisambiguator() throws IOException {
 
     TestTools.myAssert("Танцювати до впаду", 
       "/[null]SENT_START Танцювати/[танцювати]verb:inf:imperf  /[null]null до/[до впаду]<adv>|до/[до]prep:rv_rod  /[null]null " +
-      "впаду/[впасти]verb:futr:s:1:perf:v-u|впаду/[до впаду]</adv>",
+      "впаду/[впасти]verb:futr:s:1:perf:xp2:v-u|впаду/[до впаду]</adv>",
       tokenizer, sentenceTokenizer, tagger, disambiguator);
     
     TestTools.myAssert("Прийшла Люба додому.", 

File: languagetool-core/src/main/java/org/languagetool/rules/ngrams/NgramProbabilityRule.java
Patch:
@@ -93,7 +93,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) {
           //System.out.printf("%.20f for " + prevToken.token + " " + token + " " + next.token + "\n", prob);
           //System.out.printf("%.20f is minProbability\n", minProbability);
           if (prob < minProbability) {
-            String message = "The phrase '" + ngram + "' rarely occurs in the reference corpus";
+            String message = "The phrase '" + ngram + "' rarely occurs in the reference corpus (" + p.getOccurrences() + " times)";
             RuleMatch match = new RuleMatch(this, prevToken.startPos, next.endPos, message);
             matches.add(match);
           }

File: languagetool-dev/src/main/java/org/languagetool/dev/eval/SimpleCorpusEvaluator.java
Patch:
@@ -231,6 +231,7 @@ static class NgramLanguageToolEvaluator implements Evaluator {
       LuceneSingleIndexLanguageModel.clearCaches();
       System.out.println("Using Lucene language model from " + languageModel);
       probabilityRule = new EnglishNgramProbabilityRule(JLanguageTool.getMessageBundle(), languageModel, new English());
+      probabilityRule.setDefaultOn();
       langTool.addRule(probabilityRule);
     }
 

File: languagetool-core/src/main/java/org/languagetool/rules/ngrams/NgramProbabilityRule.java
Patch:
@@ -90,7 +90,8 @@ public RuleMatch[] match(AnalyzedSentence sentence) {
           //Probability bigramLeftP = getPseudoProbability(Arrays.asList(prevToken.token, token));
           //Probability bigramRightP = getPseudoProbability(Arrays.asList(token, next.token));
           //double prob = p.getProb() + bigramLeftP.getProb() + bigramRightP.getProb();
-          //System.out.println(prob + " for " + prevToken.token +" "+ token +" "+ next.token);
+          //System.out.printf("%.20f for " + prevToken.token + " " + token + " " + next.token + "\n", prob);
+          //System.out.printf("%.20f is minProbability\n", minProbability);
           if (prob < minProbability) {
             String message = "The phrase '" + ngram + "' rarely occurs in the reference corpus";
             RuleMatch match = new RuleMatch(this, prevToken.startPos, next.endPos, message);

File: languagetool-core/src/main/java/org/languagetool/rules/ngrams/NgramProbabilityRule.java
Patch:
@@ -92,7 +92,7 @@ public RuleMatch[] match(AnalyzedSentence sentence) {
           //double prob = p.getProb() + bigramLeftP.getProb() + bigramRightP.getProb();
           //System.out.println(prob + " for " + prevToken.token +" "+ token +" "+ next.token);
           if (prob < minProbability) {
-            String message = "The phrase '" + ngram + "' rarely occurs in ngram reference corpus";
+            String message = "The phrase '" + ngram + "' rarely occurs in the reference corpus";
             RuleMatch match = new RuleMatch(this, prevToken.startPos, next.endPos, message);
             matches.add(match);
           }

File: languagetool-dev/src/main/java/org/languagetool/dev/bigdata/AutomaticConfusionRuleEvaluator.java
Patch:
@@ -47,7 +47,7 @@ class AutomaticConfusionRuleEvaluator {
   private static final int MAX_EXAMPLES = 1000;
   private static final List<Long> EVAL_FACTORS = Arrays.asList(10L, 100L, 1_000L, 10_000L, 100_000L, 1_000_000L, 10_000_000L);
   private static final float MIN_PRECISION = 0.99f;
-  private static final float MIN_RECALL = 0.5f;
+  private static final float MIN_RECALL = 0.1f;
 
   private final IndexSearcher searcher;
   private final Map<String, List<ConfusionSet>> knownSets;
@@ -100,7 +100,7 @@ private void runOnPair(ConfusionRuleEvaluator evaluator, String line, String par
         System.out.println("=> " + start + spaces + "    # " + entry.getValue().getSummary());
       }
     } else {
-      System.out.println("No good result found for " + part1 + "/" + part2 + ":");
+      System.out.println("No good result found for " + part1 + "/" + part2);
     }
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -167,8 +167,8 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
   @Override
   public List<Rule> getRelevantLanguageModelRules(ResourceBundle messages, LanguageModel languageModel) throws IOException {
     return Arrays.<Rule>asList(
-        new EnglishConfusionProbabilityRule(messages, languageModel, this)
-        //new EnglishNgramProbabilityRule(messages, languageModel, this)
+        new EnglishConfusionProbabilityRule(messages, languageModel, this),
+        new EnglishNgramProbabilityRule(messages, languageModel, this)
     );
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishNgramProbabilityRule.java
Patch:
@@ -34,6 +34,7 @@ public class EnglishNgramProbabilityRule extends NgramProbabilityRule {
 
   public EnglishNgramProbabilityRule(ResourceBundle messages, LanguageModel languageModel, Language language) {
     super(messages, languageModel, language);
+    setDefaultOff();  // too many false alarms for now (2015-12)
     //addExamplePair(Example.wrong("I didn't <marker>now</marker> where it came from."),
     //               Example.fixed("I didn't <marker>know</marker> where it came from."));
   }

File: languagetool-dev/src/main/java/org/languagetool/dev/bigdata/TextIndexCreator.java
Patch:
@@ -78,7 +78,7 @@ public static void main(String[] args) throws IOException {
     if (outputDir.exists()) {
       throw new RuntimeException("Output directory already exists: " + outputDir);
     }
-    creator.index(outputDir, Arrays.copyOfRange(args, 1, args.length-1));
+    creator.index(outputDir, Arrays.copyOfRange(args, 1, args.length));
   }
   
 }

File: languagetool-dev/src/main/java/org/languagetool/dev/bigdata/CommonCrawlNGramJob.java
Patch:
@@ -113,7 +113,8 @@ public void reduce(Text key, Iterable<LongWritable> values, Context context) thr
 
   public static void main(String[] args) throws Exception {
     Configuration conf = new Configuration();
-    conf.set("io.compression.codecs","io.sensesecure.hadoop.xz.XZCodec");
+    // comment in to work on *.xz input files:
+    //conf.set("io.compression.codecs","io.sensesecure.hadoop.xz.XZCodec");
     Job job = Job.getInstance(conf, "CommonCrawl ngram indexer (see http://data.statmt.org/ngrams/)");
     job.setJarByClass(CommonCrawlNGramJob.class);
     job.setMapperClass(TokenizerMapper.class);

File: languagetool-core/src/main/java/org/languagetool/languagemodel/BaseLanguageModel.java
Patch:
@@ -42,7 +42,7 @@ public Probability getPseudoProbability(List<String> context) {
     }
     int maxCoverage = 0;
     int coverage = 0;
-    // TODO: lm.getCount("_START_") returns 0 for Google data
+    // TODO: lm.getCount("_START_") returns 0 for Google data -- see getCount(String) in LuceneLanguageModel
     long firstWordCount = getCount(context.get(0));
     maxCoverage++;
     if (firstWordCount > 0) {

File: languagetool-dev/src/main/java/org/languagetool/dev/bigdata/CommonCrawlToNgram2.java
Patch:
@@ -150,7 +150,7 @@ private void indexLines(String[] lines) throws IOException {
         System.out.printf(Locale.ENGLISH, "Indexing line %d (%.2fMB) - took %dms, avg=%.2f\n", lineCount, mb, thisTime, avgTime);
         lastTime = System.currentTimeMillis();
       }
-      if (++lineCount % 100_000 == 0) {
+      if (lineCount % 100_000 == 0) {
         System.out.println("commit");
         db.commit();
       }

File: languagetool-core/src/main/java/org/languagetool/languagemodel/LuceneLanguageModel.java
Patch:
@@ -128,9 +128,9 @@ public long getTotalTokenCount() {
       RegexpQuery query = new RegexpQuery(new Term("totalTokenCount", ".*"));
       TopDocs docs = luceneSearcher.searcher.search(query, 1000);  // Integer.MAX_VALUE might cause OOE on wrong index
       if (docs.totalHits == 0) {
-        throw new RuntimeException("Expected 'totalTokenCount' meta documents not found in 1grams index");
+        throw new RuntimeException("Expected 'totalTokenCount' meta documents not found in 1grams index: " + luceneSearcher.directory);
       } else if (docs.totalHits > 1000) {
-        throw new RuntimeException("Did not expect more than 1000 'totalTokenCount' meta documents: " + docs.totalHits);
+        throw new RuntimeException("Did not expect more than 1000 'totalTokenCount' meta documents: " + docs.totalHits + " in " + luceneSearcher.directory);
       } else {
         long result = 0;
         for (ScoreDoc scoreDoc : docs.scoreDocs) {

File: languagetool-core/src/main/java/org/languagetool/tools/Tools.java
Patch:
@@ -238,7 +238,9 @@ public static String correctTextFromMatches(
       final List<String> replacements = rm.getSuggestedReplacements();
       if (!replacements.isEmpty()) {
         //make sure the error hasn't been already corrected:
-        if (errors.get(counter).equals(sb.substring(rm.getFromPos() - offset, rm.getToPos() - offset))) {
+        if (rm.getFromPos()-offset >= 0 &&
+            rm.getToPos()-offset >= rm.getFromPos()-offset &&
+            errors.get(counter).equals(sb.substring(rm.getFromPos() - offset, rm.getToPos() - offset))) {
           sb.replace(rm.getFromPos() - offset, rm.getToPos() - offset, replacements.get(0));
           offset += rm.getToPos() - rm.getFromPos() - replacements.get(0).length();
         }

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/RegexPatternRule.java
Patch:
@@ -31,7 +31,7 @@
 import java.util.regex.Pattern;
 
 /**
- * Matches 'regex' elements from XML rules against sentences.
+ * Matches 'regexp' elements from XML rules against sentences.
  * @since 3.2
  */
 class RegexPatternRule extends AbstractPatternRule implements RuleMatcher {

File: languagetool-dev/src/main/java/org/languagetool/dev/RuleSimplifier.java
Patch:
@@ -39,7 +39,7 @@
 import java.util.regex.Pattern;
 
 /**
- * Replaces the 'pattern' element in simple rules with the 'regex' element.
+ * Replaces the 'pattern' element in simple rules with the 'regexp' element.
  * WARNING: this is a hack, the rules it produces need to be checked and modified manually!
  */
 final class RuleSimplifier {

File: languagetool-language-modules/ca/src/test/java/org/languagetool/tokenizers/ca/CatalanSentenceTokenizerTest.java
Patch:
@@ -91,6 +91,7 @@ public final void testTokenize() {
     testSplit("Ell és el número u. ", "Jo el dos.");
     testSplit("Té un trau al cap. ", "Cal portar-lo a l'hospital.");
     testSplit("Això passa en el PP. ", "Però, per altra banda,");
+    testSplit("Ceba, all, carabassa, etc. ", "En comprem a la fruiteria.");
     // Units
     testSplit("1 500 m/s. ", "Neix a");
     testSplit("Són d'1 g. ", "Han estat condicionades.");

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -549,7 +549,7 @@ private void createRules(List<PatternToken> elemList,
                 message.toString(), shortMessage,
                 suggestionsOutMsg.toString(), phrasePatternTokens.size() > 1);
       } else if (regex.length() > 0) {
-        int flags = regexCaseSensitive ? 0 : Pattern.CASE_INSENSITIVE;
+        int flags = regexCaseSensitive ? 0 : Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE;
         String regexStr = regex.toString();
         if (regexMode == RegexpMode.SMART) {
           regexStr = replaceSpacesInRegex(regexStr);

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/RegexPatternRule.java
Patch:
@@ -92,7 +92,7 @@ private List<String> getMatchSuggestions(String sentence, Matcher matcher) {
   }
 
   private List<String> extractSuggestions(Matcher matcher, String msg) {
-    Pattern suggestionPattern = Pattern.compile("<suggestion>(.*?)</suggestion>");  // TODO: this needs to be clean up, there should be no need to parse this
+    Pattern suggestionPattern = Pattern.compile("<suggestion>(.*?)</suggestion>");  // TODO: this needs to be cleaned up, there should be no need to parse this
     Matcher sMatcher = suggestionPattern.matcher(msg);
     int startPos = 0;
     List<String> result = new ArrayList<>();
@@ -116,6 +116,7 @@ private String replaceBackRefs(Matcher matcher, String msg) {
         replacedMsg = replacedMsg.replace("\\" + i, replacement);
       }
     }
+    replacedMsg = replacedMsg.replaceAll("\\\\[0-9]", "");   // optional matches need to be replaced by empty string
     return replacedMsg;
   }
 

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/QuestionWhitespaceRule.java
Patch:
@@ -66,7 +66,7 @@ public RuleMatch[] match(final AnalyzedSentence sentence) {
     String prevToken = "";
     for (int i = 1; i < tokens.length; i++) {
       final String token = tokens[i].getToken();
-      final boolean isWhiteBefore = tokens[i].isWhitespaceBefore();
+      final boolean isWhiteBefore = tokens[i].isWhitespaceBefore() && !"\u00A0".equals(prevToken);
       String msg = null;
       int fixLen = 0;
       String suggestionText = null;

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Configuration.java
Patch:
@@ -165,6 +165,7 @@ public Set<String> getDisabledCategoryNames() {
 
   public void setDisabledRuleIds(final Set<String> ruleIDs) {
     disabledRuleIds = ruleIDs;
+    enabledRuleIds.removeAll(ruleIDs);
   }
 
   public void setEnabledRuleIds(final Set<String> ruleIDs) {

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/AccentuationCheckRule.java
Patch:
@@ -165,7 +165,7 @@ public RuleMatch[] match(final AnalyzedSentence sentence) {
       final Matcher mArticleELFP = ARTICLE_EL_FP.matcher(prevToken);
 
       // VERB WITHOUT ACCENT -> NOUN WITH ACCENT
-      if (isRelevantWord && !matchPostagRegexp(tokens[i], GN)) {
+      if (isRelevantWord && !matchPostagRegexp(tokens[i], GN) && !matchPostagRegexp(tokens[i], LOCUCIONS)) {
         // amb renuncies
         if (tokens[i - 1].hasPosTag("SPS00") && !tokens[i - 1].hasPosTag("RG")
             && !matchPostagRegexp(tokens[i - 1], DETERMINANT)
@@ -301,7 +301,7 @@ else if (nextToken.equals("que")
       }
 
       // VERB WITHOUT ACCENT -> ADJECTIVE WITH ACCENT
-      if (isRelevantWord2 && !matchPostagRegexp(tokens[i], GN)) {
+      if (isRelevantWord2 && !matchPostagRegexp(tokens[i], GN) && !matchPostagRegexp(tokens[i], LOCUCIONS)) {
         // de manera obvia, circumstàncies extraordinaries.
         if ((matchPostagRegexp(relevantWords2.get(token), ADJECTIU_MS) && matchPostagRegexp(tokens[i - 1], NOM_MS)
               && !tokens[i - 1].hasPosTag("_GN_FS") && matchPostagRegexp(tokens[i], VERB_CONJUGAT) 

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -43,6 +43,7 @@ public void setUp() throws IOException {
   public void testRule() throws IOException {
 
     // correct sentences:
+    assertCorrect("Va tocar l'ària da capo de les variacions Goldberg.");
     assertCorrect("A ponent continua la serra de Fontpobra");
     assertCorrect("com a base de la categoria faria que els enllaços");
     assertCorrect("De jove faria amistat amb ells");

File: languagetool-standalone/src/main/java/org/languagetool/gui/Main.java
Patch:
@@ -537,6 +537,8 @@ private void setLookAndFeel() {
     }
     if (lookAndFeelName == null) {
       lookAndFeelName = "Nimbus";
+      // to use the system's look and feel:
+      //lookAndFeelName = UIManager.getSystemLookAndFeelClassName();
     }
     for (UIManager.LookAndFeelInfo info : UIManager.getInstalledLookAndFeels()) {
       if (lookAndFeelName.equals(info.getName())) {

File: languagetool-language-modules/uk/src/test/java/org/languagetool/tagging/disambiguation/rules/uk/UkrainianDisambiguationRuleTest.java
Patch:
@@ -61,11 +61,11 @@ public void testDisambiguator() throws IOException {
       tokenizer, sentenceTokenizer, tagger, disambiguator);
     
     TestTools.myAssert("Прийшла Люба додому.", 
-      "/[null]SENT_START Прийшла/[прийти]verb:past:f:perf  /[null]null Люба/[Люба]noun:f:v_naz:anim:fname|Люба/[любий]adj:f:v_naz  /[null]null додому/[додому]adv ./[null]null",
+      "/[null]SENT_START Прийшла/[прийти]verb:past:f:perf|Прийшла/[прийшлий]adj:f:v_naz  /[null]null Люба/[Люба]noun:f:v_naz:anim:fname|Люба/[любий]adj:f:v_naz  /[null]null додому/[додому]adv ./[null]null",
        tokenizer, sentenceTokenizer, tagger, demoDisambiguator);
 
     TestTools.myAssert("Прийшла Люба додому.", 
-      "/[null]SENT_START Прийшла/[прийти]verb:past:f:perf  /[null]null Люба/[Люба]noun:f:v_naz:anim:fname  /[null]null додому/[додому]adv ./[null]null",
+      "/[null]SENT_START Прийшла/[прийти]verb:past:f:perf|Прийшла/[прийшлий]adj:f:v_naz  /[null]null Люба/[Люба]noun:f:v_naz:anim:fname  /[null]null додому/[додому]adv ./[null]null",
        tokenizer, sentenceTokenizer, tagger, disambiguator);
       
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanConfusionProbabilityRule.java
Patch:
@@ -35,7 +35,7 @@
 public class GermanConfusionProbabilityRule extends ConfusionProbabilityRule {
 
   private static final List<Pattern> EXCEPTION_PATTERNS = Arrays.asList(
-    Pattern.compile("fiel(e|en)? .* aus|auf")
+    Pattern.compile("fiel(e|en)? .* (aus|auf)")
   );
 
   public GermanConfusionProbabilityRule(ResourceBundle messages, LanguageModel languageModel, Language language) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -66,6 +66,7 @@ public void testWrongVerb() throws IOException {
     assertGood("Dafür erhielten er sowie der Hofgoldschmied Theodor Heiden einen Preis.");
     assertGood("Probst wurde deshalb in den Medien gefeiert.");
     assertGood("/usr/bin/firefox");
+    assertGood("Das sind Leute, die viel mehr als ich wissen.");
     // incorrect sentences:
     assertBad("Als Borcarbid weißt es eine hohe Härte auf.");
     assertBad("Das greift auf Vorläuferinstitutionen bist auf die Zeit von 1234 zurück.");

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/ConfigurationDialog.java
Patch:
@@ -487,7 +487,8 @@ public void actionPerformed(ActionEvent e) {
         File newDir = Tools.openDirectoryDialog(owner, dir);
         if (newDir != null) {
           try {
-            LuceneLanguageModel.validateDirectory(newDir);
+            File checkDir = new File(newDir, config.getLanguage().getShortName());
+            LuceneLanguageModel.validateDirectory(checkDir);
             config.setNgramDirectory(newDir);
             ngramDirButton.setText(StringUtils.abbreviate(newDir.getAbsolutePath(), maxDirDisplayLength));
           } catch (Exception ex) {

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/FrenchPartialPosTagFilter.java
Patch:
@@ -35,7 +35,7 @@
  * that the disambiguator is called with a single token, so only rules
  * will apply that have a single {@code <match>} element.
  *
- * @since 2.8
+ * @since 3.1
  */
 public class FrenchPartialPosTagFilter extends PartialPosTagFilter {
 

File: languagetool-core/src/main/java/org/languagetool/rules/ConfusionProbabilityRule.java
Patch:
@@ -170,7 +170,7 @@ public void setConfusionSet(ConfusionSet set) {
   }
 
   /**
-   * Returns the ngram level uses, typically 3.
+   * Returns the ngram level used, typically 3.
    * @since 3.1
    */
   public int getNGrams() {

File: languagetool-dev/src/main/java/org/languagetool/dev/bigdata/AllConfusionRulesEvaluator.java
Patch:
@@ -82,7 +82,7 @@ public static void main(String[] args) throws IOException {
           String word2 = set2.getString();
           String key = word1 + " " + word2;
           if (!done.contains(key)) {
-            String summary = eval.run(inputsFiles, word1, word2, confusionSet.getFactor(), MAX_SENTENCES);
+            String summary = eval.run(inputsFiles, word1, word2, MAX_SENTENCES, Arrays.asList(confusionSet.getFactor()));
             String summary1 = set1.getDescription() != null ? word1 + "|" + set1.getDescription() : word1;
             String summary2 = set2.getDescription() != null ? word2 + "|" + set2.getDescription() : word2;
             String start;

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanConfusionProbabilityRule.java
Patch:
@@ -40,8 +40,8 @@ public GermanConfusionProbabilityRule(ResourceBundle messages, LanguageModel lan
 
   public GermanConfusionProbabilityRule(ResourceBundle messages, LanguageModel languageModel, Language language, int grams) {
     super(messages, languageModel, language, grams);
-    addExamplePair(Example.wrong("Dort habe ich <marker>denn</marker> Mann gesehen."),
-                   Example.fixed("Dort habe ich <marker>den</marker> Mann gesehen."));
+    addExamplePair(Example.wrong("Während Sie das Ganze <marker>mir</marker> einem Holzlöffel rühren…"),
+                   Example.fixed("Während Sie das Ganze <marker>mit</marker> einem Holzlöffel rühren…"));
   }
 
   @Override

File: languagetool-language-modules/en/src/main/java/org/languagetool/chunking/EnglishChunkFilter.java
Patch:
@@ -95,15 +95,15 @@ private ChunkType getChunkType(List<ChunkTaggedToken> tokens, int chunkStartPos)
     boolean isPlural = false;
     for (int i = chunkStartPos; i < tokens.size(); i++) {
       ChunkTaggedToken token = tokens.get(i);
+      if (!isBeginningOfNounPhrase(token) && !isContinuationOfNounPhrase(token)) {
+        break;
+      }
       if (false && "and".equals(token.getToken())) {   // e.g. "Tarzan and Jane" is a plural noun phrase
         // TODO: "Additionally, there are over 500 college and university chapter."
         isPlural = true;
       } else if (hasNounWithPluralReading(token)) {   // e.g. "ten books" is a plural noun phrase
         isPlural = true;
       }
-      if (!isBeginningOfNounPhrase(token) && !isContinuationOfNounPhrase(token)) {
-        break;
-      }
     }
     return isPlural ? ChunkType.PLURAL : ChunkType.SINGULAR;
   }

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/WikipediaQuickCheck.java
Patch:
@@ -241,7 +241,7 @@ public static void main(String[] args) throws IOException, PageNotFoundException
     // URL examples:
     //final String urlString = "http://de.wikipedia.org/wiki/Angela_Merkel";
     //final String urlString = "https://de.wikipedia.org/wiki/Benutzer_Diskussion:Dnaber";
-    //final String urlString = "https://secure.wikimedia.org/wikipedia/de/wiki/G%C3%BCtersloh";
+    //final String urlString = "https://secure.wikimedia.org/wikipedia/de/wiki/Gütersloh";
     String urlString = args[0];
     MarkupAwareWikipediaResult result = check.checkPage(new URL(urlString), new ErrorMarker("***", "***"));
     int errorCount = 0;

File: languagetool-core/src/main/java/org/languagetool/rules/WordRepeatRule.java
Patch:
@@ -101,6 +101,8 @@ private boolean isWord(String token) {
       if (!Character.isLetter(c)) {
         isWord = false;
       }
+    } else if (token.matches("0+")) {  // e.g. "1 000 000"
+      isWord = false;
     }
     return isWord;
   }

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageToolSupport.java
Patch:
@@ -287,7 +287,7 @@ private void reloadLanguageTool(Language language) {
       //config still contains old language, update it
       this.config.setLanguage(language);
       if (languageTool != null) {
-        languageTool.shutdown();
+    //    languageTool.shutdown();       // fix error "Task rejected"
       }
       languageTool = new MultiThreadedJLanguageTool(language, config.getMotherTongue());
       loadConfig();

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -721,7 +721,7 @@ private boolean isExceptionPhrase(int i, AnalyzedTokenReadings[] tokens) {
     for (String phrase : myExceptionPhrases) {
       final String[] parts = phrase.split(" ");
       for (int j = 0; j < parts.length; j++) {
-        if (parts[j].equals(tokens[i].getToken())) {
+        if (tokens[i].getToken().matches(parts[j])) {
           final int startIndex = i-j;
           if (compareLists(tokens, startIndex, startIndex+parts.length-1, parts)) {
             return true;
@@ -742,7 +742,7 @@ boolean compareLists(AnalyzedTokenReadings[] tokens, int startIndex, int endInde
       if (i >= parts.length || j >= tokens.length) {
         return false;
       }
-      if (!tokens[j].getToken().equals(parts[i])) {
+      if (!tokens[j].getToken().matches(parts[i])) {
         return false;
       }
       i++;

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -168,6 +168,8 @@ public void testRule() throws IOException {
     assertGood("Ein Kapitän verlässt als Letzter das sinkende Schiff.");
     assertBad("Die Dolmetscherin und Der Vorleser gehen spazieren.");
     assertGood("Es hilft, die Harmonie zwischen Führer und Geführten zu stützen.");
+    assertGood("Das Gebäude des Auswärtigen Amts.");
+    assertGood("Das Gebäude des Auswärtigen Amtes.");
     //assertBad("Peter Peterson, dessen Namen auf griechisch Stein bedeutet.");
   }
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -180,6 +180,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Dieses Grünkern genannte Getreide ist aber nicht backbar.");
     assertGood("Außerdem unterstützt mich Herr Müller beim abheften");
     assertGood("Außerdem unterstützt mich Frau Müller beim abheften");
+    assertBad("Der Zustand meiner Gehirns.");
 
     // TODO: not yet detected:
     //assertBad("Erst recht wir fleißiges Arbeiter.");

File: languagetool-core/src/main/java/org/languagetool/tools/ContextTools.java
Patch:
@@ -81,7 +81,7 @@ public String getContext(final int fromPos, final int toPos, final String conten
    * @since 2.3
    */
   public String getPlainTextContext(final int fromPos, final int toPos, final String contents) {
-    final String text = contents.replace('\n', ' ');
+    final String text = contents.replace('\n', ' ').replace('\r', ' ');
     // calculate context region:
     int startContent = fromPos - contextSize;
     String prefix = "...";

File: languagetool-core/src/main/java/org/languagetool/languagemodel/LuceneLanguageModel.java
Patch:
@@ -43,6 +43,7 @@ public class LuceneLanguageModel implements LanguageModel {
    * Throw RuntimeException is the given directory does not seem to be a valid ngram top directory
    * with sub directories {@code 1grams} etc.
    * @since 3.0
+   * @throws RuntimeException
    */
   public static void validateDirectory(File topIndexDir) {
     if (!topIndexDir.exists() || !topIndexDir.isDirectory()) {

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Tools.java
Patch:
@@ -140,12 +140,12 @@ public static String shortenComment(String comment) {
       while (shortComment.lastIndexOf(" [") > 0
               && shortComment.lastIndexOf(']') > shortComment.lastIndexOf(" [")
               && shortComment.length() > maxCommentLength) {
-        shortComment = shortComment.substring(0, shortComment.lastIndexOf(" [")) + shortComment.substring(comment.lastIndexOf(']')+1);
+        shortComment = shortComment.substring(0, shortComment.lastIndexOf(" [")) + shortComment.substring(shortComment.lastIndexOf(']')+1);
       }
       while (shortComment.lastIndexOf(" (") > 0
               && shortComment.lastIndexOf(')') > shortComment.lastIndexOf(" (")
               && shortComment.length() > maxCommentLength) {
-        shortComment = shortComment.substring(0, shortComment.lastIndexOf(" (")) + shortComment.substring(comment.lastIndexOf(')')+1);
+        shortComment = shortComment.substring(0, shortComment.lastIndexOf(" (")) + shortComment.substring(shortComment.lastIndexOf(')')+1);
       }
       // in case it's still not short enough, shorten at the end
       if (shortComment.length() > maxCommentLength) {

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/TokenAgreementRule.java
Patch:
@@ -308,7 +308,7 @@ else if( prep.equalsIgnoreCase("до") ) {
             if (/*prep.equalsIgnoreCase("на") &&*/ posTag.matches("adj.*:[mfn]:v_rod.*")) {
               String gender = PosTagHelper.getGender(posTag);
               if( gender == null ) {
-                System.err.println("unknown gender for " + token);
+//                System.err.println("unknown gender for " + token);
               }
               
               if ( PosTagHelper.hasPosTag(tokens[i+1], "noun.*:"+gender+":v_rod.*")) {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -577,7 +577,7 @@ private boolean isNominalization(int i, AnalyzedTokenReadings[] tokens) {
       AnalyzedTokenReadings prevPrevPrevToken = i >= 3 ? tokens[i-3] : null;
       String prevTokenStr = prevToken != null ? prevToken.getToken() : "";
       if (prevToken != null && ("und".equals(prevTokenStr) || "oder".equals(prevTokenStr))) {
-        if (prevPrevToken != null && prevPrevToken.hasPartialPosTag("SUB") && StringTools.startsWithUppercase(prevPrevToken.getToken())) {
+        if (prevPrevToken != null && tokens[i].hasPartialPosTag("SUB") && tokens[i].hasPartialPosTag(":ADJ")) {
           // "das dabei Erlernte und Erlebte ist ..." -> 'Erlebte' is correct here
           return true;
         }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -166,6 +166,8 @@ public void testRule() throws IOException {
     assertGood("Das dabei Erlernte und Erlebte ist sehr nützlich.");
     assertBad("Das dabei erlernte und Erlebte Wissen ist sehr nützlich.");
     assertGood("Ein Kapitän verlässt als Letzter das sinkende Schiff.");
+    assertBad("Die Dolmetscherin und Der Vorleser gehen spazieren.");
+    assertGood("Es hilft, die Harmonie zwischen Führer und Geführten zu stützen.");
     //assertBad("Peter Peterson, dessen Namen auf griechisch Stein bedeutet.");
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/chunking/GermanChunker.java
Patch:
@@ -234,6 +234,8 @@ public static boolean isDebug() {
       build("<pos=PRP> <chunk=NPP>+ <,> <NP>", PP, true),
       // "für die Stadtteile und selbständigen Ortsteile":
       build("<pos=PRP> <chunk=NPP>+", PP, true),
+      // "Das Bündnis zwischen der Sowjetunion und Kuba":
+      build("<pos=PRP> <der> <chunk=NPP>+", PP),
       // "in chemischen Komplexverbindungen", "für die Fische":
       build("<pos=PRP> <NP>", PP),
       // "einschließlich der biologischen und sozialen Grundlagen":

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SubjectVerbAgreementRuleTest.java
Patch:
@@ -288,7 +288,8 @@ public void testRuleWithCorrectSingularVerb() throws IOException {
         "Von ursprünglich drei Almhütten ist noch eine erhalten.",
         "Einer seiner bedeutendsten Kämpfe war gegen den späteren Weltmeister.",
         "Aufgrund stark schwankender Absatzmärkte war die GEFA-Flug Mitte der 90er Jahre gezwungen, ...",
-        "Der Abzug der Besatzungssoldaten und deren mittlerweile ansässigen Angehörigen der Besatzungsmächte war vereinbart."
+        "Der Abzug der Besatzungssoldaten und deren mittlerweile ansässigen Angehörigen der Besatzungsmächte war vereinbart.",
+        "Das Bündnis zwischen der Sowjetunion und Kuba war für beide vorteilhaft."
     );
     for (String sentence : sentences) {
       assertGood(sentence);

File: languagetool-language-modules/de/src/main/java/org/languagetool/chunking/GermanChunker.java
Patch:
@@ -202,7 +202,7 @@ public static boolean isDebug() {
       // "die Kenntnisse der Sprache":
       build("<chunk=NPP> <chunk=NPS & pos=GEN>+", NPP, true),
       // "die Pyramide des Friedens und der Eintracht":
-      build("<chunk=NPS>+ <und> <chunk=NP[SP] & pos=GEN>+", NPS, true),
+      build("<chunk=NPS>+ <und> <chunk=NP[SP] & (pos=GEN | pos=ADV)>+", NPS, true),
       // "Teil der dort ausgestellten Bestände":
       build("<chunk=NPS>+ <der> <pos=ADV> <pos=PA2> <chunk=I-NP>", NPS, true),
       // "Autor der ersten beiden Bücher":

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SubjectVerbAgreementRuleTest.java
Patch:
@@ -287,7 +287,8 @@ public void testRuleWithCorrectSingularVerb() throws IOException {
         "Für in Österreich lebende Afrikaner und Afrikanerinnen ist dies nicht üblich.",
         "Von ursprünglich drei Almhütten ist noch eine erhalten.",
         "Einer seiner bedeutendsten Kämpfe war gegen den späteren Weltmeister.",
-        "Aufgrund stark schwankender Absatzmärkte war die GEFA-Flug Mitte der 90er Jahre gezwungen, ..."
+        "Aufgrund stark schwankender Absatzmärkte war die GEFA-Flug Mitte der 90er Jahre gezwungen, ...",
+        "Der Abzug der Besatzungssoldaten und deren mittlerweile ansässigen Angehörigen der Besatzungsmächte war vereinbart."
     );
     for (String sentence : sentences) {
       assertGood(sentence);

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -575,13 +575,14 @@ private boolean isNominalization(int i, AnalyzedTokenReadings[] tokens) {
       AnalyzedTokenReadings prevToken = i > 0 ? tokens[i-1] : null;
       AnalyzedTokenReadings prevPrevToken = i >= 2 ? tokens[i-2] : null;
       AnalyzedTokenReadings prevPrevPrevToken = i >= 3 ? tokens[i-3] : null;
-      if (prevToken != null && ("und".equals(prevToken.getToken()) || "oder".equals(prevToken.getToken()))) {
+      String prevTokenStr = prevToken != null ? prevToken.getToken() : "";
+      if (prevToken != null && ("und".equals(prevTokenStr) || "oder".equals(prevTokenStr))) {
         if (prevPrevToken != null && prevPrevToken.hasPartialPosTag("SUB") && StringTools.startsWithUppercase(prevPrevToken.getToken())) {
           // "das dabei Erlernte und Erlebte ist ..." -> 'Erlebte' is correct here
           return true;
         }
       }
-      return (prevToken != null && ("irgendwas".equals(prevToken.getToken()) || "aufs".equals(prevToken.getToken()))) ||
+      return (prevToken != null && ("irgendwas".equals(prevTokenStr) || "aufs".equals(prevTokenStr) || "als".equals(prevTokenStr))) ||
          hasPartialTag(prevToken, "PRO") ||  // "etwas Verrücktes"
          (hasPartialTag(prevPrevToken, "PRO", "PRP") && hasPartialTag(prevToken, "ADJ", "ADV", "PA2")) ||  // "etwas schön Verrücktes", "mit aufgewühltem Innerem"
          (hasPartialTag(prevPrevPrevToken, "PRO", "PRP") && hasPartialTag(prevPrevToken, "ADJ", "ADV") && hasPartialTag(prevToken, "ADJ", "ADV", "PA2"));  // "etwas ganz schön Verrücktes"

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -165,6 +165,7 @@ public void testRule() throws IOException {
     assertGood("Peter Peterson, dessen Namen auf Griechisch gut klingt.");
     assertGood("Das dabei Erlernte und Erlebte ist sehr nützlich.");
     assertBad("Das dabei erlernte und Erlebte Wissen ist sehr nützlich.");
+    assertGood("Ein Kapitän verlässt als Letzter das sinkende Schiff.");
     //assertBad("Peter Peterson, dessen Namen auf griechisch Stein bedeutet.");
   }
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -64,6 +64,7 @@ public void testWrongVerb() throws IOException {
     assertGood("Wenn ihr sterben solltet, wer würde sich dann um die Katze kümmern?");
     assertGood("Wenn wir sterben sollten, wer würde sich dann um die Katze kümmern?");
     assertGood("Dafür erhielten er sowie der Hofgoldschmied Theodor Heiden einen Preis.");
+    assertGood("Probst wurde deshalb in den Medien gefeiert.");
     assertGood("/usr/bin/firefox");
     // incorrect sentences:
     assertBad("Als Borcarbid weißt es eine hohe Härte auf.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -258,7 +258,7 @@ private boolean nextButOneIsModal(AnalyzedTokenReadings[] tokens, int pos) {
   }
 
   /**
-   * @return true if |a - b| &lt; 5, and a != -1 
+   * @return true if |a - b| < 5, and a != -1 
    */
   private boolean isNear(final int a, final int b) {
     return (Math.abs(a - b) < 5) && a != -1;

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/MissingVerbRule.java
Patch:
@@ -87,16 +87,18 @@ public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
     int i = 0;
     for (AnalyzedTokenReadings readings : sentence.getTokensWithoutWhitespace()) {
       if (readings.hasPartialPosTag("VER") || (!readings.isTagged() && !StringTools.isCapitalizedWord(readings.getToken()))) {  // ignore unknown words to avoid false alarms
+        //System.out.println("Found verb: " + readings.getToken());
         verbFound = true;
         break;
       } else if (i == 1 && verbAtSentenceStart(readings)) {
+        //System.out.println("Found verb: " + readings.getToken());
         verbFound = true;
         break;
       }
       lastToken = readings;
       i++;
     }
-    if (!verbFound && lastToken != null && i - 1 >= MIN_TOKENS_FOR_ERROR) {
+    if (!verbFound && lastToken != null && sentence.getTokensWithoutWhitespace().length >= MIN_TOKENS_FOR_ERROR) {
       RuleMatch match = new RuleMatch(this, 0, lastToken.getStartPos() + lastToken.getToken().length(), "Dieser Satz scheint kein Verb zu enthalten");
       return new RuleMatch[]{ match };
     }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -163,6 +163,8 @@ public void testRule() throws IOException {
     assertBad("Dem Norwegischen Ingenieur gelingt das gut.");
     assertGood("Peter Peterson, dessen Namen auf Griechisch Stein bedeutet.");
     assertGood("Peter Peterson, dessen Namen auf Griechisch gut klingt.");
+    assertGood("Das dabei Erlernte und Erlebte ist sehr nützlich.");
+    assertBad("Das dabei erlernte und Erlebte Wissen ist sehr nützlich.");
     //assertBad("Peter Peterson, dessen Namen auf griechisch Stein bedeutet.");
   }
 

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/atom/AtomFeedCheckerCmd.java
Patch:
@@ -64,7 +64,7 @@ public static void main(String[] args) throws IOException, InterruptedException
     System.out.println("Sleep time: " + sleepTimeMillis + "ms (-1 = don't loop)");
     System.out.println("LanguageTool version: " + JLanguageTool.VERSION + " (" + JLanguageTool.BUILD_DATE + ")");
     DatabaseConfig databaseConfig = null;
-    if (args.length == 3) {
+    if (args.length >= 3) {
       String propFile = args[2];
       databaseConfig = new DatabaseConfig(propFile);
       System.out.println("Writing results to database at: " + databaseConfig.getUrl());

File: languagetool-core/src/main/java/org/languagetool/tools/Tools.java
Patch:
@@ -372,6 +372,8 @@ public static void setPasswordAuthenticator() {
         // ignore, but the feature to use user:password in the URL cannot be used now,
         // see https://github.com/languagetool-org/languagetool/issues/255
       }
+    } else {
+      Authenticator.setDefault(new PasswordAuthenticator());
     }
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -22,12 +22,12 @@
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.net.Authenticator;
 import java.util.List;
 
 import javax.xml.parsers.SAXParser;
 import javax.xml.parsers.SAXParserFactory;
 
+import org.languagetool.tools.Tools;
 import org.xml.sax.helpers.DefaultHandler;
 
 /**
@@ -68,7 +68,7 @@ public final List<PatternRule> getRules(final InputStream is, final String filen
       handler.setRelaxedMode(relaxedMode);
       final SAXParserFactory factory = SAXParserFactory.newInstance();
       final SAXParser saxParser = factory.newSAXParser();
-      Authenticator.setDefault(new PasswordAuthenticator());
+      Tools.setPasswordAuthenticator();
       saxParser.getXMLReader().setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
       saxParser.parse(is, handler);
       return handler.getRules();

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationRuleLoader.java
Patch:
@@ -18,7 +18,7 @@
  */
 package org.languagetool.tagging.disambiguation.rules;
 
-import org.languagetool.rules.patterns.PasswordAuthenticator;
+import org.languagetool.tools.Tools;
 import org.xml.sax.SAXException;
 import org.xml.sax.helpers.DefaultHandler;
 
@@ -27,7 +27,6 @@
 import javax.xml.parsers.SAXParserFactory;
 import java.io.IOException;
 import java.io.InputStream;
-import java.net.Authenticator;
 import java.util.List;
 
 /**
@@ -43,7 +42,7 @@ public final List<DisambiguationPatternRule> getRules(final InputStream stream)
     final DisambiguationRuleHandler handler = new DisambiguationRuleHandler();
     final SAXParserFactory factory = SAXParserFactory.newInstance();
     final SAXParser saxParser = factory.newSAXParser();
-    Authenticator.setDefault(new PasswordAuthenticator());
+    Tools.setPasswordAuthenticator();
     saxParser.parse(stream, handler);
     return handler.getDisambRules();
   }

File: languagetool-core/src/test/java/org/languagetool/XMLValidator.java
Patch:
@@ -22,7 +22,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.StringReader;
-import java.net.Authenticator;
 import java.net.URL;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -40,7 +39,7 @@
 import javax.xml.validation.SchemaFactory;
 import javax.xml.validation.Validator;
 
-import org.languagetool.rules.patterns.PasswordAuthenticator;
+import org.languagetool.tools.Tools;
 import org.languagetool.tools.StringTools;
 import org.w3c.dom.Document;
 import org.w3c.dom.Node;
@@ -58,7 +57,7 @@
 public final class XMLValidator {
 
   public XMLValidator() {
-    Authenticator.setDefault(new PasswordAuthenticator());
+    Tools.setPasswordAuthenticator();
   }
 
   /**

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -51,6 +51,7 @@ public void testRule() throws IOException {
     //assertCorrect("Una equivocació tan gran no es pot callar.");
     //assertCorrect(" és del tot necessari si no es vol caure en una religió alienant");
 
+    assertCorrect("Alguns ens adonàrem que era veritat");
     assertCorrect("M'he baixat moltes imatges");
     assertCorrect("baixeu-vos l'Aspell des de http://aspell.net/win32/");
     assertCorrect("els fitxers de traducció es baixaran automàticament");

File: languagetool-core/src/main/java/org/languagetool/rules/ConfusionProbabilityRule.java
Patch:
@@ -70,6 +70,9 @@ public ConfusionProbabilityRule(ResourceBundle messages, LanguageModel languageM
       throw new RuntimeException(e);
     }
     this.lm = Objects.requireNonNull(languageModel);
+    if (grams < 1 || grams > 5) {
+      throw new IllegalArgumentException("grams must be between 1 and 5: " + grams);
+    }
     this.grams = grams;
     totalTokenCount = languageModel.getTotalTokenCount();
   }

File: languagetool-dev/src/main/java/org/languagetool/dev/bigdata/ConfusionRuleEvaluator.java
Patch:
@@ -99,11 +99,11 @@ private void evaluate(List<Sentence> sentences, boolean isCorrect, String token,
       String textToken = isCorrect ? token : homophoneToken;
       String plainText = sentence.getText();
       String replacement = plainText.indexOf(textToken) == 0 ? StringTools.uppercaseFirstChar(token) : token;
-      String replacedTokenSentence = isCorrect ? plainText : plainText.replaceFirst("(?i)" + textToken, replacement);
+      String replacedTokenSentence = isCorrect ? plainText : plainText.replaceFirst("(?i)\\b" + textToken + "\\b", replacement);
       AnalyzedSentence analyzedSentence = lt.getAnalyzedSentence(replacedTokenSentence);
       RuleMatch[] matches = rule.match(analyzedSentence);
       boolean consideredCorrect = matches.length == 0;
-      String displayStr = plainText.replaceFirst("(?i)" + textToken, "**" + replacement + "**");
+      String displayStr = plainText.replaceFirst("(?i)\\b" + textToken + "\\b", "**" + replacement + "**");
       if (consideredCorrect && isCorrect) {
         trueNegatives++;
       } else if (!consideredCorrect && isCorrect) {

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -333,8 +333,8 @@ private Language detectLanguageOfString(final String text, final String fallback
   private void checkText(final String text, final HttpExchange httpExchange, final Map<String, String> parameters) throws Exception {
     final long timeStart = System.currentTimeMillis();
     if (text.length() > maxTextLength) {
-      throw new TextTooLongException("Your text is " + text.length() + " characters long, which longer " +
-              "than this server's limit of " + maxTextLength + " characters. Please consider submitting a shorter text.");
+      throw new TextTooLongException("Your text exceeds this server's limit of " + maxTextLength +
+              " characters (it's " + text.length() + " characters). Please submit a shorter text.");
     }
     //print("Check start: " + text.length() + " chars, " + langParam);
     final boolean autoDetectLanguage = getLanguageAutoDetect(parameters);

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tagging/ca/CatalanTagger.java
Patch:
@@ -48,7 +48,7 @@ public class CatalanTagger extends BaseTagger {
   private static final Pattern VERB = Pattern.compile("V.+");
   //private static final Pattern NOUN = Pattern.compile("NC.+");
 
-  private static final Pattern PREFIXES_FOR_VERBS = Pattern.compile("(auto)(.+)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
+  private static final Pattern PREFIXES_FOR_VERBS = Pattern.compile("(auto)(.*[aeiouàéèíòóïü].+[aeiouàéèíòóïü].*)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
 
   @Override
   public String getManualAdditionsFileName() {

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRule.java
Patch:
@@ -96,7 +96,7 @@ public class ComplexAdjectiveConcordanceRule extends CatalanRule {
   private static final Pattern PUNTUACIO = Pattern.compile("_PUNCT.*");
   private static final Pattern LOC_ADV = Pattern.compile(".*LOC_ADV.*");
   private static final Pattern ADVERBIS_ACCEPTATS = Pattern.compile("RG_anteposat");
-  private static final Pattern CONCORDA = Pattern.compile("_GN_.*|ignore_concordance");
+  private static final Pattern CONCORDA = Pattern.compile("_GN_.*|ignore_concordance|AQ.CN.");
   private static final Pattern UPPERCASE = Pattern.compile("\\p{Lu}[\\p{Ll}\u00B7]*");
   private static final Pattern COORDINACIO = Pattern.compile(",|i|o");
   private static final Pattern COORDINACIO_IONI = Pattern.compile("i|o|ni");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -68,6 +68,7 @@ public void testRule() throws IOException {
     // (en especial si hi ha un adverbi entremig: en algun grau més distintes
     //assertCorrect("Es van somriure l'una a l'altra encara dretes, suades i panteixants,");
 //    assertCorrect("una combinació de dos o més metalls obtinguda generalment");
+    assertCorrect("Som els més antisistema");
     assertCorrect("En un entorn de prova segur");
     assertCorrect("Amb un termini d'execució de nou mesos aproximadament.");
     assertCorrect("les causes per primera vegada explicades");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/tokenizers/ca/CatalanSentenceTokenizerTest.java
Patch:
@@ -84,6 +84,8 @@ public final void testTokenize() {
     testSplit("Art. 2.1: Són obligats els...");
     testSplit("Arriba fins a les pp. 50-52.");
     testSplit("Arriba fins a les pp. XI-XII.");
+    testSplit("i no ho vol. ", "Malgrat que és així.");
+    testSplit("i és del vol. 3 de la col·lecció");
 
     // Exception to abbreviations
     testSplit("Ell és el número u. ", "Jo el dos.");

File: languagetool-core/src/main/java/org/languagetool/rules/WordRepeatRule.java
Patch:
@@ -70,9 +70,9 @@ public RuleMatch[] match(final AnalyzedSentence sentence) {
     // we start from token 1, token no. 0 is guaranteed to be SENT_START
     for (int i = 1; i < tokens.length; i++) {
       final String token = tokens[i].getToken();
-        if (tokens[i].isImmunized()) {
-          continue;
-        }
+      if (tokens[i].isImmunized()) {
+        continue;
+      }
       if (isWord(token) && prevToken.equalsIgnoreCase(token) && !ignore(tokens, i)) {
         final String msg = messages.getString("repetition");
         final int prevPos = tokens[i - 1].getStartPos();

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -43,7 +43,7 @@
 import org.languagetool.JLanguageTool;
 import org.languagetool.Language;
 import org.languagetool.Languages;
-import org.languagetool.MultiThreadedJLanguageTool;
+// import org.languagetool.MultiThreadedJLanguageTool;
 import org.languagetool.gui.AboutDialog;
 import org.languagetool.gui.Configuration;
 import org.languagetool.markup.AnnotatedText;
@@ -379,7 +379,7 @@ private AnnotatedText getAnnotatedText(String sentence, int[] footnotePos, Proof
   private void initLanguageTool() {
     try {
       prepareConfig(docLanguage);
-      langTool = new MultiThreadedJLanguageTool(docLanguage, config.getMotherTongue());
+      langTool = new JLanguageTool(docLanguage, config.getMotherTongue());    //
       for (Rule rule : langTool.getAllActiveRules()) {
         if (rule.isDictionaryBasedSpellingRule()) {
           langTool.disableRule(rule.getId());

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -159,7 +159,7 @@ public class ReflexiveVerbsRule extends CatalanRule {
   private static final Pattern TRENCA_COMPTE2 = Pattern.compile("SENT_START|CC|_PUNCT.*|.*LOC_CONJ.*");
   
   private static final List<String> partsCos = Arrays.asList("pit", "galta", "cap", "cor", "cara", "ull", "front", "mà", "peu", "braç", "colze", "genoll", "cabell", "llavi");
-  private static final List<String> contextBaixar = Arrays.asList("fitxer", "arxiu", "paquet", "instal·lació", "versió", "programa", "programari", "software", "virus", "antivirus", "URL", "web", "pàgina", "instal·lar", "IS_URL");
+  private static final List<String> contextBaixar = Arrays.asList("fitxer", "arxiu", "paquet", "instal·lació", "versió", "programa", "programari", "software", "virus", "antivirus", "URL", "web", "pàgina", "instal·lar", "IS_URL", "imatge", "pel·lícula", "foto", "fotografia");
   
   private static final List<String> pronomJo = Arrays.asList("jo");
  // <token postag="P0.*|PP.*" postag_regexp="yes"><exception postag="_GN_.*" postag_regexp="yes"/><exception regexp="yes">jo|mi|tu|ella?|nosaltres|vosaltres|elle?s|vost[èé]s?|vós</exception><exception postag="allow_saxon_genitive">'s</exception></token>

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -68,6 +68,7 @@ public void testRule() throws IOException {
     // (en especial si hi ha un adverbi entremig: en algun grau més distintes
     //assertCorrect("Es van somriure l'una a l'altra encara dretes, suades i panteixants,");
 //    assertCorrect("una combinació de dos o més metalls obtinguda generalment");
+    assertCorrect("En un entorn de prova segur");
     assertCorrect("Amb un termini d'execució de nou mesos aproximadament.");
     assertCorrect("les causes per primera vegada explicades");
     assertCorrect("per les causes explicades fa molt difícil");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -51,6 +51,7 @@ public void testRule() throws IOException {
     //assertCorrect("Una equivocació tan gran no es pot callar.");
     //assertCorrect(" és del tot necessari si no es vol caure en una religió alienant");
 
+    assertCorrect("M'he baixat moltes imatges");
     assertCorrect("baixeu-vos l'Aspell des de http://aspell.net/win32/");
     assertCorrect("els fitxers de traducció es baixaran automàticament");
     assertCorrect("Baixeu-vos el programa de l'enllaç");

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -159,7 +159,7 @@ public class ReflexiveVerbsRule extends CatalanRule {
   private static final Pattern TRENCA_COMPTE2 = Pattern.compile("SENT_START|CC|_PUNCT.*|.*LOC_CONJ.*");
   
   private static final List<String> partsCos = Arrays.asList("pit", "galta", "cap", "cor", "cara", "ull", "front", "mà", "peu", "braç", "colze", "genoll", "cabell", "llavi");
-  private static final List<String> contextBaixar = Arrays.asList("fitxer", "arxiu", "paquet", "instal·lació", "versió", "programa", "programari", "software", "virus", "antivirus", "URL", "web", "pàgina", "instal·lar");
+  private static final List<String> contextBaixar = Arrays.asList("fitxer", "arxiu", "paquet", "instal·lació", "versió", "programa", "programari", "software", "virus", "antivirus", "URL", "web", "pàgina", "instal·lar", "IS_URL");
   
   private static final List<String> pronomJo = Arrays.asList("jo");
  // <token postag="P0.*|PP.*" postag_regexp="yes"><exception postag="_GN_.*" postag_regexp="yes"/><exception regexp="yes">jo|mi|tu|ella?|nosaltres|vosaltres|elle?s|vost[èé]s?|vós</exception><exception postag="allow_saxon_genitive">'s</exception></token>

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -51,6 +51,7 @@ public void testRule() throws IOException {
     //assertCorrect("Una equivocació tan gran no es pot callar.");
     //assertCorrect(" és del tot necessari si no es vol caure en una religió alienant");
 
+    assertCorrect("baixeu-vos l'Aspell des de http://aspell.net/win32/");
     assertCorrect("els fitxers de traducció es baixaran automàticament");
     assertCorrect("Baixeu-vos el programa de l'enllaç");
     assertCorrect("No em plantejo anar a un altre partit");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -43,7 +43,7 @@ public void setUp() throws IOException {
   public void testRule() throws IOException {
 
     // correct sentences:
-    //assertCorrect("A ponent continua la serra de Fontpobra");
+    assertCorrect("A ponent continua la serra de Fontpobra");
     assertCorrect("com a base de la categoria faria que els enllaços");
     assertCorrect("De jove faria amistat amb ells");
     assertCorrect("De jove tenia admiració");

File: languagetool-language-modules/uk/src/test/java/org/languagetool/tagging/uk/UkrainianTaggerTest.java
Patch:
@@ -199,7 +199,6 @@ public void testDynamicTagging() throws IOException {
     TestTools.myAssert("сліпуче-яскравого", "сліпуче-яскравого/[сліпуче-яскравий]adj:m:v_rod:compb|сліпуче-яскравого/[сліпуче-яскравий]adj:m:v_zna:compb|сліпуче-яскравого/[сліпуче-яскравий]adj:n:v_rod:compb", tokenizer, tagger);
     TestTools.myAssert("дво-триметровий", "дво-триметровий/[дво-триметровий]adj:m:v_naz|дво-триметровий/[дво-триметровий]adj:m:v_zna", tokenizer, tagger);
     TestTools.myAssert("україно-болгарський", "україно-болгарський/[україно-болгарський]adj:m:v_naz|україно-болгарський/[україно-болгарський]adj:m:v_zna", tokenizer, tagger);
-    TestTools.myAssert("греко-уніятський", "", tokenizer, tagger);
 
 //    TestTools.myAssert("американо-блакитний", "бірмюково-блакитний/[бірмюково-блакитний]adj:m:v_naz|бірмюково-блакитний/[бірмюково-блакитний]adj:m:v_zna", tokenizer, tagger);
 

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -159,6 +159,7 @@ public class ReflexiveVerbsRule extends CatalanRule {
   private static final Pattern TRENCA_COMPTE2 = Pattern.compile("SENT_START|CC|_PUNCT.*|.*LOC_CONJ.*");
   
   private static final List<String> partsCos = Arrays.asList("pit", "galta", "cap", "cor", "cara", "ull", "front", "mà", "peu", "braç", "colze", "genoll", "cabell", "llavi");
+  private static final List<String> contextBaixar = Arrays.asList("fitxer", "arxiu", "paquet", "instal·lació", "versió", "programa", "programari", "software", "virus", "antivirus", "URL", "web", "pàgina", "instal·lar");
   
   private static final List<String> pronomJo = Arrays.asList("jo");
  // <token postag="P0.*|PP.*" postag_regexp="yes"><exception postag="_GN_.*" postag_regexp="yes"/><exception regexp="yes">jo|mi|tu|ella?|nosaltres|vosaltres|elle?s|vost[èé]s?|vós</exception><exception postag="allow_saxon_genitive">'s</exception></token>
@@ -293,6 +294,8 @@ && matchRegexp(tokens[i + 1].getToken(), REFLEXIU_POSPOSAT) ) {
           continue loop;        
         if (!isThereReflexivePronoun(tokens, i)) 
           continue loop;
+        if (tokens[i].hasLemma("baixar") && isThereNearLemma (tokens, i, contextBaixar))
+            continue loop;
         //impersonal obligació: s'ha de baixar
         if (matchLemmaList(tokens[i],verbsNoPronominalsImpersonals2)
             && isThereBefore(tokens, i, LEMMA_ES, POSTAG_ES)

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -51,6 +51,8 @@ public void testRule() throws IOException {
     //assertCorrect("Una equivocació tan gran no es pot callar.");
     //assertCorrect(" és del tot necessari si no es vol caure en una religió alienant");
 
+    assertCorrect("els fitxers de traducció es baixaran automàticament");
+    assertCorrect("Baixeu-vos el programa de l'enllaç");
     assertCorrect("No em plantejo anar a un altre partit");
     assertCorrect("-Deixa't caure al canal i prou");
     assertCorrect("Deixa't caure al canal i prou");

File: languagetool-commandline/src/main/java/org/languagetool/commandline/CommandLineTools.java
Patch:
@@ -61,7 +61,7 @@ public static void tagText(final String contents, final JLanguageTool lt) throws
     final List<String> sentences = lt.sentenceTokenize(contents);
     for (final String sentence : sentences) {
       analyzedText = lt.getAnalyzedSentence(sentence);
-      System.out.println(analyzedText.toString());
+      System.out.println(analyzedText);
     }
   }
 
@@ -171,7 +171,7 @@ private static void printMatches(final List<RuleMatch> ruleMatches,
       }
       System.out.println(contextTools.getPlainTextContext(match.getFromPos(), match.getToPos(), contents));
       if (rule.getUrl() != null) {
-        System.out.println("More info: " + rule.getUrl().toString());
+        System.out.println("More info: " + rule.getUrl());
       }
       if (i < ruleMatches.size()) {
         System.out.println();

File: languagetool-dev/src/main/java/org/languagetool/dev/RuleOverview.java
Patch:
@@ -167,7 +167,7 @@ private void run(File webRoot) throws IOException {
       } else {
         maintainerText = "";
       }
-      System.out.print("<td valign=\"top\" align=\"left\">" + maintainerInfo.toString() + maintainerText + "</td>");
+      System.out.print("<td valign=\"top\" align=\"left\">" + maintainerInfo + maintainerText + "</td>");
       
       System.out.println("</tr>");    
     }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -725,7 +725,7 @@ static void showError(final Throwable e) {
       throw new RuntimeException(e);
     }
     String msg = "An error has occurred in LanguageTool "
-        + JLanguageTool.VERSION + ":\n" + e.toString() + "\nStacktrace:\n";
+        + JLanguageTool.VERSION + ":\n" + e + "\nStacktrace:\n";
     msg += Tools.getFullStackTrace(e);
     final String metaInfo = "OS: " + System.getProperty("os.name") + " on "
         + System.getProperty("os.arch") + ", Java version "
@@ -753,7 +753,7 @@ static void setTestMode(boolean mode) {
     testMode = mode;
   }
 
-  private class AboutDialogThread extends Thread {
+  private static class AboutDialogThread extends Thread {
 
     private final ResourceBundle messages;
 

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/dumpcheck/WikipediaSentenceSource.java
Patch:
@@ -149,12 +149,12 @@ private void handleTextElement(String namespace, String title, int articleCount)
         }
       }
     } catch (Exception e) {
-      System.err.println("Could not extract text, skipping document: " + e.toString() + ", full stacktrace follows:");
+      System.err.println("Could not extract text, skipping document: " + e + ", full stacktrace follows:");
       e.printStackTrace();
     }
   }
 
-  private class WikipediaSentence {
+  private static class WikipediaSentence {
     final String sentence;
     final String title;
     final int articleCount;

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/TextConverter.java
Patch:
@@ -415,7 +415,7 @@ private void wantSpace() {
   }
 
   private void finishLine() {
-    sb.append(line.toString());
+    sb.append(line);
     line.setLength(0);
   }
 

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/WikipediaQuickCheck.java
Patch:
@@ -128,7 +128,7 @@ MarkupAwareWikipediaResult checkWikipediaMarkup(URL url, MediaWikiContent wikiCo
         final List<RuleMatchApplication> ruleMatchApplications = replacer.applySuggestionsToOriginalText(match);
         appliedMatches.add(new AppliedRuleMatch(match, ruleMatchApplications));
       } catch (Exception e) {
-        System.err.println("Failed to apply suggestion for rule match '" + match + "' for URL " + url + ": " + e.toString());
+        System.err.println("Failed to apply suggestion for rule match '" + match + "' for URL " + url + ": " + e);
         internalErrors++;
       }
     }

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/index/LanguageToolFilterTest.java
Patch:
@@ -62,7 +62,7 @@ private static void displayTokensWithFullDetails(TokenStream stream) throws IOEx
         System.out.println();
         System.out.print(position + ": ");
       }
-      System.out.print("[" + term.toString() + ":" + offset.startOffset() + "->"
+      System.out.print("[" + term + ":" + offset.startOffset() + "->"
           + offset.endOffset() + ":" + type.type() + "] ");
     }
     System.out.println();

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -160,6 +160,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
             new VerbAgreementRule(messages, this),
             new SubjectVerbAgreementRule(messages),
             new WordCoherencyRule(messages),
+            new SimilarNameRule(messages),
             new WiederVsWiderRule(messages)
     );
   }

File: languagetool-core/src/main/java/org/languagetool/rules/GenericUnpairedBracketsRule.java
Patch:
@@ -36,7 +36,7 @@ public class GenericUnpairedBracketsRule extends TextLevelRule {
 
   private static final Pattern NUMERALS_EN =
           Pattern.compile("(?i)\\d{1,2}?[a-z']*|M*(D?C{0,3}|C[DM])(L?X{0,3}|X[LC])(V?I{0,3}|I[VX])$");
-  private static final Pattern PUNCTUATION = Pattern.compile("[\\p{Punct}–—]");
+  private static final Pattern PUNCTUATION = Pattern.compile("[\\p{Punct}…–—]");
   private static final Pattern PUNCTUATION_NO_DOT =
           Pattern.compile("[ldmnstLDMNST]'|[–—\\p{Punct}&&[^\\.]]");
   // "[ldmnst]'" allows dealing with apostrophed words in Catalan (i.e. l'«home) 

File: languagetool-commandline/src/main/java/org/languagetool/commandline/CommandLineTools.java
Patch:
@@ -102,7 +102,7 @@ public static int checkText(final String contents, final JLanguageTool lt,
     if (apiFormat) {
       final RuleAsXmlSerializer serializer = new RuleAsXmlSerializer();
       final String xml = serializer.ruleMatchesToXml(ruleMatches, contents,
-              contextSize, lt.getLanguage());
+              contextSize, xmlMode, lt.getLanguage());
       final PrintStream out = new PrintStream(System.out, true, "UTF-8");
       out.print(xml);
     } else {

File: languagetool-core/src/main/java/org/languagetool/rules/GenericUnpairedBracketsRule.java
Patch:
@@ -36,7 +36,7 @@ public class GenericUnpairedBracketsRule extends TextLevelRule {
 
   private static final Pattern NUMERALS_EN =
           Pattern.compile("(?i)\\d{1,2}?[a-z']*|M*(D?C{0,3}|C[DM])(L?X{0,3}|X[LC])(V?I{0,3}|I[VX])$");
-  private static final Pattern PUNCTUATION = Pattern.compile("\\p{Punct}");
+  private static final Pattern PUNCTUATION = Pattern.compile("[\\p{Punct}–—]");
   private static final Pattern PUNCTUATION_NO_DOT =
           Pattern.compile("[ldmnstLDMNST]'|[–—\\p{Punct}&&[^\\.]]");
   // "[ldmnst]'" allows dealing with apostrophed words in Catalan (i.e. l'«home) 

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/CatalanUnpairedBracketsRuleTest.java
Patch:
@@ -71,6 +71,8 @@ public void testRule() throws IOException {
     assertCorrect("60° 50'");
     //assertCorrect("el grau en 60 parts iguals, tenim el minut (1'):");
     //assertCorrect("el minut en 60 parts iguals, tenim el segon (1\"):");
+    assertCorrect("El tràiler té una picada d'ullet quan diu que \"no es pot fer una pel·lícula 'slasher' com si fos una sèrie\".");
+    assertCorrect("El tràiler –que té una picada d'ullet quan diu que \"no es pot fer una pel·lícula 'slasher' com si fos una sèrie\"– ja ");
     
     //assertCorrect("The screen is 20\" wide.");
     assertCorrect("This is a [test] sentence...");

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReplaceOperationNamesRule.java
Patch:
@@ -130,7 +130,8 @@ public final RuleMatch[] match(final AnalyzedSentence sentence) throws IOExcepti
         continue loop;
       }
       // Assecat el braç del riu
-      if (matchPostagRegexp(tokens[i - 1], PUNTUACIO) &&
+      if (i + 1 < tokens.length &&
+          matchPostagRegexp(tokens[i - 1], PUNTUACIO) &&
           matchPostagRegexp(tokens[i + 1], DETERMINANT)) {
         continue loop;
       }

File: languagetool-dev/src/main/java/org/languagetool/dev/RuleOverview.java
Patch:
@@ -281,11 +281,11 @@ private StringBuilder getMaintainerInfo(Language lang) {
     return maintainerInfo;
   }
 
-  private class JavaFilter implements FileFilter {
+  private static class JavaFilter implements FileFilter {
 
     private final String langName;
 
-    public JavaFilter(String langName) {
+    JavaFilter(String langName) {
       this.langName = langName;
     }
 

File: languagetool-dev/src/main/java/org/languagetool/dev/XmlUsageCounter.java
Patch:
@@ -103,10 +103,10 @@ public static void main(String[] args) throws XMLStreamException {
     counter.printResult();
   }
 
-  class ElemCount {
+  static class ElemCount {
     String elem;
     Integer count;
-    public ElemCount(String elem, Integer count) {
+    ElemCount(String elem, Integer count) {
       this.elem = elem;
       this.count = count;
     }

File: languagetool-dev/src/main/java/org/languagetool/dev/eval/AtDEvaluator.java
Patch:
@@ -56,7 +56,7 @@ class AtDEvaluator implements Evaluator {
   /**
    * @param urlPrefix e.g. {@code http://de.service.afterthedeadline.com/checkDocument?key=test&data=}
    */
-  public AtDEvaluator(String urlPrefix) {
+  AtDEvaluator(String urlPrefix) {
     this.urlPrefix = urlPrefix;
   }
 

File: languagetool-dev/src/test/java/org/languagetool/dev/eval/LanguageDetectionEval.java
Patch:
@@ -43,7 +43,7 @@ class LanguageDetectionEval {
   private int totalInputs = 0;
   private int totalFailures = 0;
 
-  public LanguageDetectionEval() {
+  LanguageDetectionEval() {
     languageIdentifier = new LanguageIdentifier();
   }
 
@@ -138,7 +138,7 @@ public static void main(String[] args) throws IOException {
   }
 
   class DetectionException extends RuntimeException {
-    public DetectionException(String s) {
+    DetectionException(String s) {
       super(s);
     }
   }

File: languagetool-server/src/main/java/org/languagetool/server/IllegalConfigurationException.java
Patch:
@@ -20,7 +20,7 @@
 
 class IllegalConfigurationException extends RuntimeException {
 
-  public IllegalConfigurationException(String message) {
+  IllegalConfigurationException(String message) {
     super(message);
   }
   

File: languagetool-server/src/test/java/org/languagetool/server/HTTPSServerTesting.java
Patch:
@@ -77,7 +77,7 @@ public void interactiveHTTPServerTest() throws Exception {
   private class TestRunnable implements Runnable {
     private final int threadNumber;
 
-    public TestRunnable(int threadNumber) {
+    TestRunnable(int threadNumber) {
       this.threadNumber = threadNumber;
     }
 

File: languagetool-standalone/src/main/java/org/languagetool/dev/RuleCreator.java
Patch:
@@ -162,10 +162,10 @@ private void initMaps(File homophoneOccurrenceFile) throws FileNotFoundException
     }
   }
 
-  class OccurrenceInfo {
+  static class OccurrenceInfo {
     private final String ngram;
     private final long occurrence;
-    public OccurrenceInfo(String ngram, long occurrence) {
+    OccurrenceInfo(String ngram, long occurrence) {
       this.ngram = ngram;
       this.occurrence = occurrence;
     }

File: languagetool-standalone/src/main/java/org/languagetool/dev/SynthDictionaryBuilder.java
Patch:
@@ -35,7 +35,7 @@ final class SynthDictionaryBuilder extends DictionaryBuilder {
    */
   private static final String POLISH_IGNORE_REGEX = ":neg|qub|depr";
 
-  public SynthDictionaryBuilder(File infoFile) throws IOException {
+  SynthDictionaryBuilder(File infoFile) throws IOException {
     super(infoFile);
   }
 

File: languagetool-standalone/src/main/java/org/languagetool/gui/RetainLineBreakTransferHandler.java
Patch:
@@ -102,7 +102,7 @@ class MyTransferable implements Transferable {
   private final String plainData;
   private final String htmlData;
 
-  public MyTransferable(String plainData, String htmlData) {
+  MyTransferable(String plainData, String htmlData) {
     this.plainData = plainData;
     this.htmlData = htmlData;
   }

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/atom/CheckResult.java
Patch:
@@ -29,7 +29,7 @@ class CheckResult {
   private final List<ChangeAnalysis> checkResults;
   private final long latestDiffId;
 
-  public CheckResult(List<ChangeAnalysis> checkResults, long latestDiffId) {
+  CheckResult(List<ChangeAnalysis> checkResults, long latestDiffId) {
     this.checkResults = Objects.requireNonNull(checkResults);
     if (latestDiffId < 0) {
       throw new IllegalArgumentException("latestDiffId must be >= 0: " + latestDiffId);

File: languagetool-commandline/src/test/java/org/languagetool/commandline/CommandLineParserTest.java
Patch:
@@ -27,7 +27,7 @@ public void testUsage() throws Exception {
     try {
       parser.parseOptions(new String[]{});
       fail();
-    } catch (WrongParameterNumberException expected) {}
+    } catch (WrongParameterNumberException ignored) {}
 
     final CommandLineOptions commandLineOptions = parser.parseOptions(new String[]{"--help"});
     assertTrue(commandLineOptions.isPrintUsage());
@@ -38,7 +38,7 @@ public void testErrors() throws Exception {
     try {
       parser.parseOptions(new String[]{"--apply", "--taggeronly"});
       fail();
-    } catch (IllegalArgumentException expected) {}
+    } catch (IllegalArgumentException ignored) {}
   }
 
   public void testSimple() throws Exception {

File: languagetool-core/src/main/java/org/languagetool/Language.java
Patch:
@@ -356,7 +356,7 @@ public final String getShortNameWithCountryAndVariant() {
   protected synchronized List<PatternRule> getPatternRules() throws IOException {
     // use lazy loading to speed up start of stand-alone LT, where all the languages get initialized:
     if (patternRules == null) {
-      patternRules = new ArrayList<>();
+      List<PatternRule> rules = new ArrayList<>();
       PatternRuleLoader ruleLoader = new PatternRuleLoader();
       for (String fileName : getRuleFileNames()) {
         InputStream is = null;
@@ -365,7 +365,8 @@ protected synchronized List<PatternRule> getPatternRules() throws IOException {
           if (is == null) {                     // files loaded via the dialog
             is = new FileInputStream(fileName);
           }
-          patternRules.addAll(ruleLoader.getRules(is, fileName));
+          rules.addAll(ruleLoader.getRules(is, fileName));
+          patternRules = Collections.unmodifiableList(rules);
         } finally {
           if (is != null) {
             is.close();

File: languagetool-core/src/main/java/org/languagetool/tokenizers/SRXSentenceTokenizer.java
Patch:
@@ -19,7 +19,6 @@
 package org.languagetool.tokenizers;
 
 import net.sourceforge.segment.srx.SrxDocument;
-import org.languagetool.JLanguageTool;
 import org.languagetool.Language;
 
 import java.util.List;
@@ -34,7 +33,7 @@
  */
 public class SRXSentenceTokenizer implements SentenceTokenizer {
 
-  private static final SrxDocument DOCUMENT = SrxTools.createSrxDocument(JLanguageTool.getDataBroker().getFromResourceDirAsStream("/segment.srx"));
+  private static final SrxDocument DOCUMENT = SrxTools.createSrxDocument("/segment.srx");
 
   private final String languageCode;
 

File: languagetool-core/src/test/java/org/languagetool/language/LanguageBuilderTest.java
Patch:
@@ -39,7 +39,7 @@ public void testIllegalFileName() throws Exception {
     try {
       LanguageBuilder.makeAdditionalLanguage(new File("foo"));
       fail();
-    } catch (RuleFilenameException expected) {}
+    } catch (RuleFilenameException ignored) {}
   }
   
 }

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleXmlCreatorTest.java
Patch:
@@ -88,7 +88,7 @@ public void testToXMLInvalidRuleId() {
     try {
       creator.toXML(fakeRuleId, new Demo());
       fail();
-    } catch(RuntimeException expected) {}
+    } catch(RuntimeException ignored) {}
   }
 
 }

File: languagetool-office-extension/src/test/java/org/languagetool/openoffice/KhmerDetectorTest.java
Patch:
@@ -37,7 +37,7 @@ public void testIsThisLanguage() {
     try {
       assertFalse(detector.isThisLanguage(null));
       fail();
-    } catch (NullPointerException expected) {}
+    } catch (NullPointerException ignored) {}
   }
   
 }

File: languagetool-office-extension/src/test/java/org/languagetool/openoffice/TamilDetectorTest.java
Patch:
@@ -41,7 +41,7 @@ public void testIsThisLanguage() {
     try {
       assertFalse(detector.isThisLanguage(null));
       fail();
-    } catch (NullPointerException expected) {}
+    } catch (NullPointerException ignored) {}
   }
 
 }

File: languagetool-server/src/test/java/org/languagetool/server/HTTPSServerConfigTest.java
Patch:
@@ -31,7 +31,7 @@ public void testArgumentParsing() {
     try {
       new HTTPSServerConfig(new String[]{});
       fail();
-    } catch (IllegalConfigurationException expected) {}
+    } catch (IllegalConfigurationException ignored) {}
 
     final String propertyFile = HTTPSServerConfigTest.class.getResource("/org/languagetool/server/https-server.properties").getFile();
 
@@ -70,7 +70,7 @@ public void testMissingPropertyFile() {
     try {
       new HTTPSServerConfig(("--config " + propertyFile).split(" "));
       fail();
-    } catch (Exception expected) {}
+    } catch (Exception ignored) {}
   }
 
   @Test
@@ -79,7 +79,7 @@ public void testIncompletePropertyFile() {
     try {
       new HTTPSServerConfig(("--config " + propertyFile).split(" "));
       fail();
-    } catch (IllegalConfigurationException expected) {}
+    } catch (IllegalConfigurationException ignored) {}
   }
 
 }

File: languagetool-standalone/src/main/java/org/languagetool/gui/FontChooser.java
Patch:
@@ -361,7 +361,6 @@ public void changedUpdate(DocumentEvent e) {
   }
 
   private void updateFont() {
-
     String fontName = this.fontNameTextField.getText();
     String styleName = this.fontStyleTextField.getText();
     Integer fontSize = null;
@@ -377,7 +376,6 @@ private void updateFont() {
     } else if (fontStylesArray[3].equals(styleName)) {
       style = Font.BOLD | Font.ITALIC;
     }
-
     if (fontName != null && fontSize != null) {
       Font newFont = new Font(fontName, style, fontSize);
       this.selectedFont = newFont;

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageToolSupport.java
Patch:
@@ -881,7 +881,7 @@ private void updateHighlights() {
           ITSIssueType issueType = span.rule.getLocQualityIssueType();
           Color colorForIssueType = getConfig().getErrorColors().get(issueType);
           Color bgColor = colorForIssueType != null ? colorForIssueType : null;
-          Color underlineColor = ITSIssueType.Misspelling.equals(span.rule.getLocQualityIssueType()) ? Color.red : Color.blue;
+          Color underlineColor = ITSIssueType.Misspelling == span.rule.getLocQualityIssueType() ? Color.red : Color.blue;
           HighlightPainter painter = new HighlightPainter(bgColor, underlineColor);
           h.addHighlight(span.start, span.end, painter);
         }

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/index/IndexerSearcherTest.java
Patch:
@@ -215,7 +215,7 @@ public void testIndexerSearcherWithEnglish() throws Exception {
     try {
       errorSearcher.findRuleMatchesOnIndex(getFirstRule("Invalid Rule Id", language), language);
       fail("Exception should be thrown for invalid rule id.");
-    } catch (PatternRuleNotFoundException expected) {}
+    } catch (PatternRuleNotFoundException ignored) {}
   }
 
   private PatternRule getFirstRule(String ruleId, Language language) throws IOException {
@@ -333,7 +333,7 @@ public void testWithOneElementWithException() throws Exception {
     try {
       errorSearcher.findRuleMatchesOnIndex(rule1, new English());
       fail();
-    } catch (UnsupportedPatternRuleException expected) {
+    } catch (UnsupportedPatternRuleException ignored) {
     }
   }
 

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/index/PatternRuleQueryBuilderTest.java
Patch:
@@ -138,15 +138,15 @@ public void testUnsupportedPatternRule() throws Exception {
     try {
       patternRuleQueryBuilder.buildRelaxedQuery(makeRule("<token skip='-1'><exception>and</exception></token>", false));
       fail("Exception should be thrown for unsupported PatternRule");
-    } catch (UnsupportedPatternRuleException expected) {}
+    } catch (UnsupportedPatternRuleException ignored) {}
   }
 
   public void testUnsupportedBackReferencePatternRule() throws Exception {
     final PatternRuleQueryBuilder patternRuleQueryBuilder = new PatternRuleQueryBuilder(language);
     try {
       patternRuleQueryBuilder.buildRelaxedQuery(makeRule("<token>\\1</token>", false));
       fail("Exception should be thrown for unsupported PatternRule");
-    } catch (UnsupportedPatternRuleException expected) {}
+    } catch (UnsupportedPatternRuleException ignored) {}
   }
 
   public void testSpecialRegexSyntax() throws Exception {

File: languagetool-standalone/src/main/java/org/languagetool/gui/Main.java
Patch:
@@ -1100,8 +1100,8 @@ class AddRulesAction extends AbstractAction {
     public void actionPerformed(ActionEvent e) {
       try {
         addLanguage();
-      } catch (InstantiationException | IllegalAccessException ex) {
-        throw new RuntimeException(ex);
+      } catch (Exception ex) {
+        Tools.showError(ex);
       }
     }
   }

File: languagetool-language-modules/uk/src/main/java/org/languagetool/tagging/uk/IPOSTag.java
Patch:
@@ -29,6 +29,7 @@ public enum IPOSTag {
   numr("numr"),
   number("number"),
   date("date"),
+  time("time"),
   advp("advp"),
   predic("predic"),
   insert("insert"),

File: languagetool-language-modules/uk/src/test/java/org/languagetool/rules/uk/UkrainianWordRepeatRuleTest.java
Patch:
@@ -47,6 +47,7 @@ public void testRule() throws IOException {
     assertEmptyMatch("без повного розрахунку");
     assertEmptyMatch("без бугіма бугіма");
     assertEmptyMatch("без 100 100");
+    assertEmptyMatch("1.30 3.20 3.20");
     assertEmptyMatch("ще в В.Кандинського");
     assertEmptyMatch("Від добра добра не шукають.");
     assertEmptyMatch("Що що, а кіно в Україні...");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ReplaceOperationNamesRuleTest.java
Patch:
@@ -75,7 +75,7 @@ public void testRule() throws IOException {
     assertIncorrect("Cal vigilar el filtrat del vi");
     assertIncorrect("El procés d'empaquetat");
     assertIncorrect("Els equilibrats de les rodes");
-    assertIncorrect("Duplicat de claus");
+    //assertIncorrect("Duplicat de claus");
     assertIncorrect("El procés d'etiquetat de les ampolles");
     assertIncorrect("El rentat de cotes");
 

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -88,6 +88,8 @@ public void testRule() throws IOException {
     assertCorrect("La magnífica conservació del palau.");
 
     // errors:
+    assertIncorrect("Com s'ha dit les primaries autonòmiques s'han ajornat");
+    assertIncorrect("Com sabeu les primaries s'han ajornat");
     assertIncorrect("Les continues al·lusions a la victòria.");
     assertIncorrect("De positiva influencia en ell.");
     assertIncorrect("tren de llarga distancia");

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -67,7 +67,7 @@ public class ReflexiveVerbsRule extends CatalanRule {
   private static final List<String> verbsPortarDur = Arrays.asList ("portar", "dur");
   
   
-  private static final List<String> verbsPotencialmentPronominals = Arrays.asList("abaixar", "abandonar", "abarrocar", "abellir", "abismar", "abissar", "ablamar", "ablanir", "abocar", "aboldronar", "abonançar", "abonar", "abonir", "abonyegar", "abordar", "abraonar", "abraçar", "abrivar", "abroquerar", "abrusar", "absentar", "abstraure", "abstreure", "aburgesar", "acabar", "acalar", "acalorar", "acantonar", "acarrerar", "acastellanar", "acatalanar", "accelerar", "acetificar", "acidificar", "aclarir", "aclimatar", "aclivellar", "aclucar", "acoblar", "acollir", "acollonir", "acomiadar", "acomodar", "acomplexar", "acomplir", "aconductar", "aconsellar", "acontentar", "acopar", "acoquinar", "acordar", "acorruar", "acostar", "acostumar", "acotar", "acotxar", "acovardir", "acreditar", "acréixer", "acubar", "acubillar", "acudir", "acugular", "acuitar", "acular", "acumular", "acusar", "adaptar", "adargar", "adherir", "adjudicar", "adollar", "adolorir", "adondar", "adormir", "adossar", "adotzenar", "adreçar", "adscriure", "adunar", "afalconar", "afanyar", "afartar", "afeblir", "afectar", "afermar", "aferrar", "afigurar", "afilar", "afilerar", "afiliar", "afillar", "afinar", "aflaquir", "afligir", "aflonjar", "afluixar", "afogar", "afollar", "afrancesar", "afrevolir", "afuar", "afusar", "agabellar", "agafar", "agarbar", "agarbonar", "agitar", "aglomerar", "aglutinar", "agombolar", "agostejar", "agradar", "agregar", "agremiar", "agreujar", "agrir", "agrisar", "agrumar", "aguantar", "aguditzar", "aigualir", "airejar", "aixecar", "aixoplugar", "ajaure", "ajaçar", "ajeure", "ajornalar", "ajudar", "ajuntar", "ajupir", "ajustar", "alabar", "alarmar", "alcalinitzar", "alcoholitzar", "alegrar", "alentir", "aliar", "alimentar", "alinear", "allarar", "allargar", "allargassar", "allerar", "alleugerir", "alleujar", "alliberar", "alligar", "allistar", "allitar", "allotjar", "allunyar", "alterar", "alzinar", "alçar", "amagar", "amagrir", "amanerar", "amanir", "amansar", "amansir", "amassar", "ambientar", "americanitzar", "amistançar", "amistar", "amollar", "amorar", "amorosir", "amorrar", "amorriar", "amotinar", "amoïnar", "amuntegar", "anastomitzar", "angoixar", "anguniejar", "animar", "anomenar", "anticipar", "apagar", "apaivagar", "apanyar", "aparellar", "apariar", "apartar", "aparèixer", "apassionar", "apercebre", "apilotar", "apinyar", "apitrar", "aplanar", "aplaçar", "aplicar", "apocar", "apoderar", "aposentar", "apostar", "apostemar", "apregonar", "aprendre", "apressar", "aprimar", "aprofitar", "apropar", "apropiar", "aprovisionar", "aproximar", "apujar", "apuntalar", "aquedar", "aquietar", "aquilotar", "arborar", "arbrar", "arcar", "argollar", "aristocratitzar", "armar", "arquejar", "arraconar", "arramadar", "arrambar", "arramellar", "arranjar", "arrapar", "arraulir", "arrear", "arrecerar", "arredossar", "arreglar", "arrelar", "arremangar", "arremolinar", "arremorar", "arrenglerar", "arreplegar", "arrestar", "arribar", "arrimar", "arriscar", "arrissar", "arrodonir", "arromangar", "arrombollar", "arronsar", "arrossegar", "arrufar", "arrugar", "arruïnar", "articular", "asfixiar", "assabentar", "assaonar", "assecar", "assegurar", "assentar", "assenyalar", "asserenar", "assessorar", "asseure", "assimilar", "associar", "assolar", "assolellar", "assossegar", "assotar", "astorar", "atabalar", "ataconar", "atalaiar", "atandar", "atansar", "atapeir", "atardar", "atavellar", "aterrir", "aterrossar", "atipar", "atiplar", "atonir", "atorrollar", "atracar", "atribolar", "atribuir", "atrinxerar", "atrofiar", "atropellar", "atrotinar", "aturar", "avalotar", "avançar", "avarar", "avariar", "avenir", "aventurar", "avergonyir", "avesar", "aviar", "aviciar", "avidar", "avivar", "avorrir", "aïllar", "aïrar", "badar", "balancejar", "balandrejar", "baldar", "banyar", "barallar", "barrejar", "basar", "basquejar", "bastar", "batre", "befar", "bellugar", "beneficiar", "bleir", "blocar", "bolcar", "bombar", "bonificar", "botir", "brindar", "brossar", "bufar", "buidar", "burocratitzar", "cabrejar", "cabussar", "cagar", "calar", "calmar", "calçar", "campar", "cansar", "cap", "capalçar", "capbussar", "capficar", "capgirar", "captar", "captrencar", "caracteritzar", "caragirar", "carbonar", "carbonatar", "carbonitzar", "cardar", "cargolar", "carregar", "cartejar", "casar", "cascar", "cenyir", "cerciorar", "cicatritzar", "circumscriure", "clamar", "classificar", "clavar", "clivellar", "cloure", "coagular", "cobrir", "colar", "colgar", "colltorçar", "colltòrcer", "colrar", "coltellejar", "col·lapsar", "col·legiar", "col·locar", "comanar", "combinar", "compadir", "compaginar", "compatir", "compensar", "complementar", "complexificar", "complicar", "complir", "complànyer", "compondre", "comportar", "comprendre", "comprimir", "comprometre", "compungir", "comunicar", "concentrar", "concertar", "conciliar", "concordar", "concretar", "condemnar", "condensar", "conduir", "confabular", "confederar", "confessar", "confinar", "confirmar", "confitar", "conformar", "congelar", "congestionar", "conglomerar", "conglutinar", "congratular", "congregar", "congriar", "conhortar", "conjuminar", "conjunyir", "conjurar", "connaturalitzar", "consagrar", "conscienciar", "consentir", "conservar", "consolar", "consolidar", "constipar", "consumir", "contagiar", "contaminar", "contemperar", "contenir", "contorbar", "contornar", "contradir", "contraposar", "contreure", "controlar", "convertir", "convèncer", "corbar", "corcar", "cordar", "coronar", "corporificar", "corregir", "correspondre", "corrompre", "corsecar", "cotitzar", "covar", "crebantar", "cremar", "creure", "criar", "crispar", "cucar", "cuidar", "cuixatrencar", "curar", "curullar", "damnar", "debatre", "decantar", "decidir", "declarar", "decuplicar", "decurvar", "dedicar", "defendre", "defensar", "definir", "deformar", "defugir", "degradar", "deixar", "deixatar", "deixondar", "deixondir", "deixuplinar", "delectar", "delir", "delitar", "denudar", "departir", "depauperar", "depilar", "deportar", "depositar", "depravar", "deprimir", "depurar", "derivar", "desabillar", "desabonar", "desabrigar", "desacalorar", "desacoblar", "desaconductar", "desaconduir", "desacordar", "desacostumar", "desacreditar", "desadherir", "desaferrar", "desafinar", "desagafar", "desagermanar", "desagradar", "desagregar", "desajustar", "desalinear", "desamarrar", "desamigar", "desamistançar", "desamorrar", "desanar", "desanimar", "desaparellar", "desapariar", "desaparroquianar", "desaplicar", "desapropiar", "desar", "desarborar", "desarmar", "desarramadar", "desarrambar", "desarranjar", "desarrapar", "desarreglar", "desarregussar", "desarrelar", "desarrengar", "desarrenglar", "desarrenglerar", "desarrimar", "desarrissar", "desarromangar", "desarrufar", "desarrugar", "desarticular", "desassossegar", "desatansar", "desatapeir", "desatendar", "desavesar", "desaveïnar", "desballestar", "desbaratar", "desbarbar", "desbarrar", "desbordar", "desbrancar", "desbraonar", "descabalar", "descabdellar", "descabellar", "descalcificar", "descalçar", "descaminar", "descantellar", "descarbonatar", "descarbonitzar", "descarburar", "descargolar", "descarnar", "descarregar", "descarrerar", "descartar", "descastellanitzar", "descatalanitzar", "descelerar", "descentrar", "descenyir", "desclassar", "desclavar", "descloure", "descoagular", "descobrir", "descolgar", "descollar", "descolorar", "descolorir", "descol·locar", "descompassar", "descompensar", "descompondre", "descomprometre", "descomptar", "desconceptuar", "desconcertar", "desconfortar", "descongelar", "descongestionar", "desconhortar", "desconjuntar", "desconnectar", "descoratjar", "descordar", "descosir", "descotxar", "descrostar", "descular", "desdaurar", "desdelitar", "desdenyar", "desdibuixar", "desdinerar", "desdir", "desdoblar", "desdoblegar", "deseixir", "deselectritzar", "desembabaiar", "desembadalir", "desembadocar", "desemballestar", "desemboirar", "desembolcallar", "desembolcar", "desembolicar", "desembotir", "desembotjar", "desembotornar", "desemboçar", "desembravir", "desembrocar", "desembromallar", "desembromar", "desembullar", "desembussar", "desembutllofar", "desemmandrir", "desemmurriar", "desempallar", "desempastar", "desemperesir", "desempernar", "desempipar", "desempobrir", "desempolainar", "desempolsar", "desempolvorar", "desenamorar", "desencadenar", "desencaixar", "desencalimar", "desencalitjar", "desencallar", "desencaminar", "desencantar", "desencaparrar", "desencapotar", "desencaputxar", "desencarar", "desencarcarar", "desencarranquinar", "desencartonar", "desencastar", "desencaterinar", "desencauar", "desencavalcar", "desencavallar", "desencebar", "desencerclar", "desencercolar", "desencimbellar", "desencisar", "desenclavar", "desencoblar", "desencolar", "desencongir", "desencoratjar", "desencorbar", "desencordillar", "desencrespar", "desencrostar", "desendegar", "desendeutar", "desendogalar", "desendolcir", "desendollar", "desendropir", "desenfadar", "desenfadeir", "desenfarfegar", "desenfellonir", "desenferrissar", "desenfetgegar", "desenfilar", "desenfitar", "desenflocar", "desenfocar", "desenfrenar", "desenfuriar", "desenfurismar", "desengandulir", "desenganxar", "desenganyar", "desengatjar", "desengavanyar", "desengomar", "desengormandir", "desengorronir", "desengreixar", "desengrescar", "desengruixir", "desengrutar", "desenguantar", "desenguerxir", "desenllaminir", "desenllaçar", "desenlleganyar", "desenllepolir", "desenllorar", "desenlluernar", "desenllustrar", "desennuegar", "desennuvolar", "desenquadernar", "desenquadrar", "desenquimerar", "desenrampar", "desenredar", "desenrederar", "desenrolar", "desenrotllar", "desensabonar", "desensenyorir", "desensonyar", "desensopir", "desensuperbir", "desentaular", "desentelar", "desentendre", "desentenebrar", "desentenebrir", "desenterbolir", "desenterrar", "desentestar", "desentortolligar", "desentrampar", "desentranyar", "desentravessar", "desentrecuixar", "desentrenar", "desentristir", "desentumir", "desentusiasmar", "desenutjar", "desenvelar", "desenvernissar", "desenvescar", "desenvolupar", "desenyorar", "desequilibrar", "desertitzar", "desesmar", "desesperançar", "desesperar", "desespessir", "desestancar", "desestanyar", "desestovar", "desfaixar", "desfaiçonar", "desfanatitzar", "desfardar", "desfasar", "desfermar", "desferrar", "desficiar", "desficiejar", "desfigurar", "desfilar", "desflorir", "desfocar", "desfogar", "desfonar", "desfrarar", "desfrenar", "desfrunzir", "desfullar", "desganar", "desgastar", "desgavellar", "desglaçar", "desgraciar", "desgranar", "desgruixar", "desguarnir", "desguerxar", "desguitarrar", "deshabitar", "deshabituar", "deshidratar", "deshumanitzar", "desigualar", "desil·lusionar", "desimantar", "desincorporar", "desincrustar", "desinfatuar", "desinflamar", "desinflar", "desinhibir", "desintegrar", "desinteressar", "desintoxicar", "desionitzar", "desjunyir", "deslligar", "deslliurar", "desllodrigar", "desllogar", "deslloriguerar", "deslluir", "desllustrar", "desmagnetitzar", "desmaiar", "desmallar", "desmanegar", "desmaquillar", "desmarcar", "desmembrar", "desmillorar", "desmoralitzar", "desmorriar", "desmudar", "desmuntar", "desnacionalitzar", "desnaturar", "desniar", "desnierar", "desnivellar", "desnuar", "desnucar", "desobligar", "desobstruir", "desocupar", "desorbitar", "desordenar", "desorganitzar", "desorientar", "despacientar", "desparar", "desparellar", "despariar", "despassar", "despenjar", "despentinar", "despenyar", "despersonalitzar", "despertar", "despintar", "despistar", "despitar", "desplaçar", "desplegar", "desplomar", "despoblar", "despolir", "desposseir", "desprendre", "desprestigiar", "desprisar", "despullar", "despuntar", "desrengar", "desroentar", "dessaborir", "dessagnar", "dessecar", "dessolar", "dessoldar", "dessonillar", "dessoterrar", "dessuar", "dessucar", "destacar", "destapar", "destarotar", "destemprar", "destenyir", "desteular", "destintar", "destorçar", "destravar", "destrempar", "destrenar", "destriar", "destrossar", "destòrcer", "desunglar", "desunir", "desusar", "desvariar", "desvariejar", "desvesar", "desvestir", "desvetllar", "desviar", "desvincular", "desvitrificar", "detenir", "deteriorar", "determinar", "deturar", "devaluar", "dialitzar", "dibuixar", "diferenciar", "difondre", "diftongar", "difuminar", "dignificar", "dilatar", "diluir", "dipositar", "dirigir", "disbauxar", "disciplinar", "disculpar", "disfressar", "disgregar", "disgustar", "dislocar", "disparar", "dispersar", "disposar", "disputar", "disseminar", "dissimilar", "dissipar", "dissociar", "dissoldre", "distanciar", "distendre", "distingir", "distreure", "distribuir", "diversificar", "divertir", "dividir", "divorciar", "divulgar", "doblar", "doblegar", "doctorar", "documentar", "doldre", "domesticar", "domiciliar", "dominar", "donar", "dopar", "dreçar", "drogar", "dubtar", "dulcificar", "duplicar", "dutxar", "eclipsar", "efectuar", "efeminar", "eixamar", "eixamenar", "eixamorar", "eixamplar", "eixancar", "eixancarrar", "eixarrancar", "eixarreir", "eixorivir", "eixugar", "electritzar", "electrocutar", "elevar", "elidir", "emancipar", "embabaiar", "embadalir", "embadocar", "embajanir", "embalar", "embalbar", "embalbir", "embancar", "embarbollar", "embarcar", "embardissar", "embarracar", "embarrancar", "embarranquinar", "embarrar", "embarumar", "embarzerar", "embasardir", "embassar", "embastardir", "embellir", "embeure", "embicar", "emblanquir", "emblavir", "embofegar", "embogir", "emboirar", "embolicar", "emborbollar", "emborratxar", "emboscar", "embossar", "embotinar", "embotir", "emboçar", "embrancar", "embravir", "embretolir", "embriagar", "embrocar", "embrollar", "embromar", "embrossar", "embrunir", "embrutar", "embrutir", "embullar", "embussar", "embutllofar", "embutxacar", "emmagrir", "emmalaltir", "emmaleir", "emmallar", "emmandrir", "emmarcir", "emmaridar", "emmascarar", "emmatxucar", "emmerdar", "emmerdissar", "emmetzinar", "emmirallar", "emmotllar", "emmudir", "emmusteir", "emmustigar", "emocionar", "empadronar", "empal·lidir", "empantanar", "empantanegar", "empanxonar", "empapatxar", "emparar", "emparaular", "emparentar", "emparrar", "empastellar", "empastifar", "empastissar", "empatxar", "empedreir", "empeguntar", "empellar", "empeltar", "empenyorar", "emperesir", "emperlar", "empernar", "empetitir", "empilar", "empinar", "empipar", "empitjorar", "empitrar", "empixonar", "emplenar", "emplomallar", "empobrir", "empolainar", "empolistrar", "empolsar", "empolsegar", "empolsimar", "empolsinar", "empolvorar", "empoquir", "emporcar", "emporprar", "empotingar", "emprendre", "emprenyar", "emprovar", "enagrir", "enamorar", "enamoriscar", "enarborar", "enarbrar", "enarcar", "enardir", "enasprar", "enasprir", "encabassar", "encabir", "encaboriar", "encadarnar", "encadenar", "encaixar", "encalbir", "encalimar", "encalitjar", "encallar", "encallir", "encambrar", "encamellar", "encaminar", "encamisar", "encantar", "encaparrar", "encapellar", "encaperonar", "encaperullar", "encaperutxar", "encapirotar", "encapotar", "encapsular", "encapullar", "encaputxar", "encaramel·lar", "encarar", "encarbonar", "encarir", "encarnar", "encarranquinar", "encarregar", "encarrerar", "encarrilar", "encartonar", "encasquetar", "encastellar", "encauar", "encavallar", "encegar", "encendre", "encepar", "encertir", "encetar", "encimbellar", "enciriar", "enclaustrar", "enclotar", "encloure", "encoblar", "encofurnar", "encoixir", "encomanar", "enconar", "enconcar", "encongir", "encontrar", "encoratjar", "encorbar", "encordar", "encotillar", "encotxar", "encovar", "encrespar", "encreuar", "encrostar", "encrostimar", "encrostissar", "encruelir", "endarreriar", "endarrerir", "endegar", "endentar", "endenyar", "enderrocar", "endeutar", "endinsar", "endogalar", "endolcir", "endolentir", "endossar", "endropir", "endurir", "enemistar", "enervar", "enfadar", "enfadeir", "enfangar", "enfarfegar", "enfarinar", "enfastidir", "enfastijar", "enfellonir", "enfervorir", "enfetgegar", "enfigassar", "enfilar", "enfistular", "enfitar", "enflocar", "enflorar", "enfondir", "enfonsar", "enfonyar", "enforfoguir", "enforinyar", "enfortir", "enfosquir", "enfredar", "enfredolicar", "enfredorar", "enfredorir", "enfrontar", "enfuriar", "enfurir", "enfurismar", "engabiar", "engalavernar", "engallar", "engallardir", "engallir", "engallofir", "engalonar", "engalvanir", "enganar", "engandulir", "enganxar", "enganyar", "engatar", "engatjar", "engelosir", "enginjolar", "enginyar", "engiponar", "englotir", "engolar", "engolir", "engordir", "engorjar", "engormandir", "engorronir", "engrandir", "engreixar", "engrescar", "engrevir", "engroguir", "engronsar", "engronyar", "engrossir", "engruixar", "engruixir", "engrutar", "enguantar", "enguerxir", "enherbar", "enjoiar", "enjoiellar", "enjoncar", "enjullar", "enlairar", "enllacar", "enllaminir", "enllangorir", "enllardar", "enllardissar", "enllaçar", "enllefernar", "enllefiscar", "enllepissar", "enllepolir", "enllestir", "enlletgir", "enllistar", "enllorar", "enllordar", "enllotar", "enllustrar", "ennegrir", "ennoblir", "ennovar", "ennuegar", "ennuvolar", "enorgullar", "enquadrar", "enquibir", "enquimerar", "enrabiar", "enramar", "enrampar", "enrancir", "enrarir", "enrasar", "enravenar", "enredar", "enrederar", "enrederir", "enrellentir", "enretirar", "enrevenxinar", "enriallar", "enrigidir", "enrinxolar", "enriquir", "enrobustir", "enrocar", "enrogir", "enrolar", "enronquir", "enrosar", "enrossir", "enrotllar", "enrullar", "enrunar", "ensabonar", "ensagnar", "ensalivar", "ensangonar", "enseguir", "ensenyorir", "ensonyar", "ensopegar", "ensopir", "ensordir", "ensorrar", "ensotar", "ensulsir", "ensuperbir", "entaforar", "entatxonar", "entaular", "entebeir", "entebionar", "entelar", "entendre", "entendrir", "entenebrar", "entenebrir", "enterbolir", "enterrar", "enterrossar", "entestar", "entollar", "entonar", "entornar", "entortellar", "entortolligar", "entrampar", "entrapar", "entravessar", "entrebancar", "entregar", "entregirar", "entrellaçar", "entrelligar", "entremesclar", "entrenar", "entretenir", "entreveure", "entrevistar", "entristar", "entristir", "entumir", "enturar", "entusiasmar", "enutjar", "envanir", "envellir", "envellutar", "enverdir", "enverinar", "envermellir", "envescar", "enviar", "envigorir", "envilir", "environar", "enviscar", "enviscolar", "envitricollar", "envoltar", "enxarxar", "enxiquir", "enyorar", "equilibrar", "equivaler", "equivocar", "erigir", "eriçar", "errar", "esbadiar", "esbadinar", "esbadocar", "esbalair", "esbaldir", "esbaldregar", "esbandir", "esbardellar", "esbargir", "esbarriar", "esbarzerar", "esberlar", "esbocinar", "esboirar", "esboldregar", "esbombar", "esbombolar", "esborifar", "esborrar", "esborrifar", "esborronar", "esbotifarrar", "esbotzar", "esbrancar", "esbraonar", "esbraveir", "esbullar", "escabellar", "escabellonar", "escabotar", "escaldar", "escaldufar", "escalfar", "escalfeir", "escalivar", "escalonar", "escamarlar", "escamnar", "escampar", "escandalitzar", "escantellar", "escantonar", "escanyar", "escapar", "escarmentar", "escarrabillar", "escarxar", "escaure", "escindir", "esclafar", "esclafassar", "esclarir", "esclerosar", "escolar", "escoltar", "escometre", "escondir", "escotar", "escridar", "escridassar", "escrostar", "escrostissar", "escrostonar", "escruixir", "escuar", "escudar", "escuixar", "escular", "escurçar", "escórrer", "esdernegar", "esdevenir", "esduir", "esfacelar", "esfereir", "esfilagarsar", "esfondrar", "esfreixurar", "esfullar", "esfumar", "esgallar", "esgardissar", "esgarrar", "esgarrifar", "esgarrinxar", "esgarrinyar", "esgarronar", "esgavellar", "esglaonar", "esgotar", "esgratinyar", "esguardar", "esguerrar", "esllenegar", "esllomar", "esmadeixar", "esmalucar", "esmenar", "esmicar", "esmicolar", "esmolar", "esmorrellar", "esmorronar", "esmortir", "esmunyir", "esmussar", "espalmar", "espantar", "espanyolitzar", "espaordir", "espargir", "esparpallar", "esparpillar", "esparracar", "esparverar", "espassar", "espatllar", "espaventar", "espavilar", "especejar", "especialitzar", "espedaçar", "espellifar", "espellir", "espellissar", "espenyar", "esperançar", "esperar", "espesseir", "espessir", "espicassar", "espigar", "espinar", "espitrar", "esplaiar", "esplugar", "espolsar", "espoltrir", "esponjar", "esporuguir", "esposar", "esprémer", "espuar", "espuntar", "espunyir", "espuçar", "esqueixar", "esquerar", "esquerdar", "esquerdillar", "esquerdissar", "esquinçar", "esquitxar", "esquivar", "est", "estabilitzar", "establir", "estacionar", "estalviar", "estamordir", "estancar", "estandarditzar", "estantolar", "estanyar", "estarrufar", "estellar", "estendre", "estepitzar", "estilitzar", "estimbar", "estintolar", "estirar", "estireganyar", "estiuar", "estontolar", "estovar", "estrangeritzar", "estranyar", "estratificar", "estrenar", "estressar", "estretir", "estrinxolar", "estripar", "estroncar", "estropellar", "estrènyer", "estubar", "estufar", "esvair", "esvalotar", "esventar", "esvorar", "esvorellar", "eternitzar", "europeïtzar", "evadir", "evaporar", "exacerbar", "exaltar", "examinar", "exasperar", "excedir", "excitar", "exclamar", "excloure", "exculpar", "excusar", "exercitar", "exfoliar", "exhalar", "exhaurir", "exhibir", "exiliar", "eximir", "exornar", "expandir", "expatriar", "explicar", "exposar", "expressar", "extasiar", "extenuar", "exterioritzar", "extingir", "extraviar", "extremar", "faixar", "familiaritzar", "fanatitzar", "fastiguejar", "fatigar", "federar", "felicitar", "feminitzar", "ferir", "fiar", "ficar", "figurar", "filtrar", "fingir", "firar", "fixar", "flagel·lar", "florir", "folrar", "foraviar", "forcar", "forjar", "formalitzar", "formar", "fortificar", "fossilitzar", "fotre", "fraccionar", "fracturar", "fragmentar", "francesitzar", "franquejar", "fregar", "fregir", "frisar", "fumar", "fundar", "gabar", "gastar", "gaudir", "gelar", "generalitzar", "gestar", "ginyar", "girar", "gitar", "glaçar", "gloriejar", "governar", "graduar", "gramaticalitzar", "gratar", "gratular", "gravar", "grecitzar", "grillar", "gronxar", "gronxejar", "gronxolar", "guanyar", "guardar", "guarir", "guarnir", "guerxar", "guiar", "guillar", "habituar", "hebraïtzar", "hel·lenitzar", "hemodialitzar", "herniar", "hibridar", "hidratar", "hissar", "honorar", "honrar", "horripilar", "horroritzar", "hostatjar", "humanitzar", "humiliar", "humitejar", "identificar", "igualar", "il·luminar", "il·lusionar", "il·lustrar", "imaginar", "immergir", "immolar", "impacientar", "implicar", "imposar", "impressionar", "imprimir", "impurificar", "incarcerar", "incendiar", "inclinar", "incomodar", "incorporar", "incrementar", "incrustar", "independitzar", "indignar", "indisposar", "inebriar", "infatuar", "infectar", "infestar", "infiltrar", "inflamar", "inflar", "informar", "ingerir", "inhabilitar", "inhibir", "iniciar", "inquietar", "inscriure", "insinuar", "inspirar", "instal·lar", "instruir", "insubordinar", "insultar", "insurreccionar", "integrar", "intensificar", "interessar", "interferir", "internar", "interposar", "interrompre", "intranquil·litzar", "introduir", "inundar", "invaginar", "inventar", "ionitzar", "irritar", "islamitzar", "isolar", "jubilar", "jugar", "junyir", "justificar", "lamentar", "laxar", "lignificar", "limitar", "llampar", "llançar", "llassar", "llatinitzar", "llepar", "lletrejar", "llevar", "llicenciar", "lligar", "lliurar", "llogar", "lluir", "localitzar", "lucrar", "macerar", "malacostumar", "malavesar", "maliciar", "mallar", "malpensar", "mamar", "mancomunar", "manegar", "manejar", "manifestar", "mantenir", "maquillar", "marcir", "marejar", "marginar", "maridar", "marinejar", "mascarar", "massificar", "masturbar", "matar", "materialitzar", "matricular", "matxucar", "mecanitzar", "mediumitzar", "menar", "menjar", "mentalitzar", "menysprear", "meravellar", "merèixer", "mesclar", "metal·litzar", "metamorfosar", "meteoritzar", "migrar", "millorar", "mineralitzar", "mirar", "mobilitzar", "mocar", "moderar", "modernitzar", "modificar", "molestar", "morfondre", "morir", "morrejar", "mortificar", "mossegar", "mostrar", "moure", "mudar", "mullar", "multiplicar", "musteir", "mustiar", "mustigar", "mutilar", "nacionalitzar", "naturalitzar", "necrosar", "negar", "neguitejar", "netejar", "nonuplicar", "normalitzar", "nuar", "oblidar", "obligar", "obnubilar", "obscurir", "occidentalitzar", "occitanitzar", "ocultar", "ocupar", "ofegar", "oferir", "ofuscar", "ombrar", "omplir", "operar", "oposar", "ordenar", "orejar", "organitzar", "orgullar", "orientalitzar", "orientar", "originar", "orinar", "oscar", "oxigenar", "pacificar", "paganitzar", "pagar", "pansir", "parapetar", "parar", "parlar", "particularitzar", "partir", "passar", "passejar", "pedregar", "pedrejar", "pellar", "penjar", "pensar", "pentinar", "percaçar", "perfeccionar", "perfilar", "permetre", "persignar", "persuadir", "pessigar", "petar", "picar", "pintar", "pirar", "plantar", "plantificar", "podrir", "polaritzar", "polir", "pol·linitzar", "pondre", "popularitzar", "portar", "posar", "possessionar", "posticar", "postrar", "prear", "precipitar", "prendre", "preocupar", "preparar", "presentar", "prestar", "prevaler", "privar", "proclamar", "prodigar", "produir", "professionalitzar", "proletaritzar", "prometre", "pronunciar", "propagar", "propalar", "proposar", "prostituir", "prostrar", "prou", "proveir", "pujar", "punxar", "purificar", "putejar", "quadrar", "qualificar", "quallar", "quedar", "quitar", "rabejar", "radicalitzar", "rarificar", "ratificar", "reafirmar", "realitzar", "rebaixar", "rebentar", "reblir", "rebolcar", "rebullir", "recargolar", "reciclar", "reciprocar", "recloure", "recobrar", "recollir", "recolzar", "reconcentrar", "reconciliar", "reconstituir", "recordar", "recrear", "recriminar", "rectificar", "reencarnar", "reenganxar", "refer", "referir", "refermar", "reflectir", "refocil·lar", "reforçar", "refractar", "refredar", "refrenar", "refrescar", "refringir", "refugiar", "refusar", "regalar", "regelar", "regirar", "rehabilitar", "rehidratar", "reincorporar", "reinflar", "reinstal·lar", "reintegrar", "rejovenir", "relacionar", "relaxar", "rellentir", "relligar", "rellogar", "remenar", "remetre", "remirar", "remollir", "remudar", "remuntar", "rendir", "renovar", "renovellar", "rentar", "repatriar", "repenjar", "repensar", "repetir", "repintar", "replegar", "replujar", "repodrir", "reportar", "reposar", "representar", "reprimir", "reproduir", "repuntar", "rescabalar", "reservar", "resguardar", "resignar", "resinificar", "resistir", "resoldre", "responsabilitzar", "resquitar", "ressecar", "ressobinar", "restablir", "retardar", "retenir", "retintar", "retirar", "retractar", "retre", "retreure", "retrobar", "reunir", "reveixinar", "revelar", "revellir", "revenxinar", "revestir", "revifar", "reviscolar", "revoltar", "rifar", "rinxolar", "riure", "romanitzar", "rombollar", "rompre", "rostir", "rovellar", "ruboritzar", "russificar", "sacrificar", "salmorrar", "salsir", "salvar", "santificar", "satel·litzar", "secularitzar", "sedimentar", "segar", "segregar", "seguir", "sentir", "senyar", "separar", "significar", "silicificar", "sincerar", "sindicar", "singularitzar", "sinitzar", "situar", "sobrealimentar", "sobreexcitar", "sobreposar", "sobresaltar", "sobresanar", "sobresaturar", "sobtar", "socarrar", "solapar", "solar", "solaçar", "soldar", "solidaritzar", "solidificar", "sollar", "sollevar", "solvatar", "somorgollar", "soplujar", "sostreure", "sotaplujar", "sotmetre", "suberificar", "suberitzar", "subestimar", "submergir", "subscriure", "suggestionar", "sulfatar", "sulfurar", "sumar", "sumir", "superar", "tallar", "tancar", "tant", "tapar", "temperar", "tenyir", "terraplenar", "tirar", "titular", "tocar", "tombar", "torbar", "torejar", "tornar", "torrar", "trabucar", "tractar", "tranquil·litzar", "transfigurar", "transformar", "translimitar", "transmetre", "transmutar", "transparentar", "transvasar", "trasmudar", "trasplantar", "trastocar", "trastornar", "triar", "tribular", "trifurcar", "trobar", "tòrcer", "ulcerar", "ullar", "unir", "universalitzar", "untar", "vaporitzar", "velar", "venjar", "ventar", "vessar", "vestir", "viciar", "vinclar", "vincular", "vitrificar", "volar", "volatilitzar", "xalar", "xutar");
+  private static final List<String> verbsPotencialmentPronominals = Arrays.asList("abaixar", "abandonar", "abarrocar", "abellir", "abismar", "abissar", "ablamar", "ablanir", "abocar", "aboldronar", "abonançar", "abonar", "abonir", "abonyegar", "abordar", "abraonar", "abraçar", "abrivar", "abroquerar", "abrusar", "absentar", "abstraure", "abstreure", "aburgesar", "acabar", "acalar", "acalorar", "acantonar", "acarrerar", "acastellanar", "acatalanar", "accelerar", "acetificar", "acidificar", "aclarir", "aclimatar", "aclivellar", "aclucar", "acoblar", "acollir", "acollonir", "acomiadar", "acomodar", "acomplexar", "acomplir", "aconductar", "aconsellar", "acontentar", "acopar", "acoquinar", "acordar", "acorruar", "acostar", "acostumar", "acotar", "acotxar", "acovardir", "acreditar", "acréixer", "acubar", "acubillar", "acudir", "acugular", "acuitar", "acular", "acumular", "acusar", "adaptar", "adargar", "adherir", "adjudicar", "adollar", "adolorir", "adondar", "adormir", "adossar", "adotzenar", "adreçar", "adscriure", "adunar", "afalconar", "afanyar", "afartar", "afeblir", "afectar", "afermar", "aferrar", "afigurar", "afilar", "afilerar", "afiliar", "afillar", "afinar", "aflaquir", "afligir", "aflonjar", "afluixar", "afogar", "afollar", "afrancesar", "afrevolir", "afuar", "afusar", "agabellar", "agafar", "agarbar", "agarbonar", "agitar", "aglomerar", "aglutinar", "agombolar", "agostejar", "agradar", "agregar", "agremiar", "agreujar", "agrir", "agrisar", "agrumar", "aguantar", "aguditzar", "aigualir", "airejar", "aixecar", "aixoplugar", "ajaure", "ajaçar", "ajeure", "ajornalar", "ajudar", "ajuntar", "ajupir", "ajustar", "alabar", "alarmar", "alcalinitzar", "alcoholitzar", "alegrar", "alentir", "aliar", "alimentar", "alinear", "allarar", "allargar", "allargassar", "allerar", "alleugerir", "alleujar", "alliberar", "alligar", "allistar", "allitar", "allotjar", "allunyar", "alterar", "alzinar", "alçar", "amagar", "amagrir", "amanerar", "amanir", "amansar", "amansir", "amassar", "ambientar", "americanitzar", "amistançar", "amistar", "amollar", "amorar", "amorosir", "amorrar", "amorriar", "amotinar", "amoïnar", "amuntegar", "anastomitzar", "angoixar", "anguniejar", "animar", "anomenar", "anticipar", "apagar", "apaivagar", "apanyar", "aparellar", "apariar", "apartar", "aparèixer", "apassionar", "apercebre", "apilotar", "apinyar", "apitrar", "aplanar", "aplaçar", "aplicar", "apocar", "apoderar", "aposentar", "apostar", "apostemar", "apregonar", "aprendre", "apressar", "aprimar", "aprofitar", "apropar", "apropiar", "aprovisionar", "aproximar", "apujar", "apuntalar", "aquedar", "aquietar", "aquilotar", "arborar", "arbrar", "arcar", "argollar", "aristocratitzar", "armar", "arquejar", "arraconar", "arramadar", "arrambar", "arramellar", "arranjar", "arrapar", "arraulir", "arrear", "arrecerar", "arredossar", "arreglar", "arrelar", "arremangar", "arremolinar", "arremorar", "arrenglerar", "arreplegar", "arrestar", "arribar", "arrimar", "arriscar", "arrissar", "arrodonir", "arromangar", "arrombollar", "arronsar", "arrossegar", "arrufar", "arrugar", "arruïnar", "articular", "asfixiar", "assabentar", "assaonar", "assecar", "assegurar", "assentar", "assenyalar", "asserenar", "assessorar", "asseure", "assimilar", "associar", "assolar", "assolellar", "assossegar", "assotar", "astorar", "atabalar", "ataconar", "atalaiar", "atandar", "atansar", "atapeir", "atardar", "atavellar", "aterrir", "aterrossar", "atipar", "atiplar", "atonir", "atorrollar", "atracar", "atribolar", "atribuir", "atrinxerar", "atrofiar", "atropellar", "atrotinar", "aturar", "avalotar", "avançar", "avarar", "avariar", "avenir", "aventurar", "avergonyir", "avesar", "aviar", "aviciar", "avidar", "avivar", "avorrir", "aïllar", "aïrar", "badar", "balancejar", "balandrejar", "baldar", "banyar", "barallar", "barrejar", "basar", "basquejar", "bastar", "batre", "befar", "bellugar", "beneficiar", "bleir", "blocar", "bolcar", "bombar", "bonificar", "botir", "brindar", "brossar", "bufar", "buidar", "burocratitzar", "cabrejar", "cabussar", "cagar", "calar", "calmar", "calçar", "campar", "cansar", "cap", "capalçar", "capbussar", "capficar", "capgirar", "captar", "captrencar", "caracteritzar", "caragirar", "carbonar", "carbonatar", "carbonitzar", "cardar", "cargolar", "carregar", "cartejar", "casar", "cascar", "cenyir", "cerciorar", "cicatritzar", "circumscriure", "clamar", "classificar", "clavar", "clivellar", "cloure", "coagular", "cobrir", "colar", "colgar", "colltorçar", "colltòrcer", "colrar", "coltellejar", "col·lapsar", "col·legiar", "col·locar", "comanar", "combinar", "compadir", "compaginar", "compatir", "compensar", "complementar", "complexificar", "complicar", "complir", "complànyer", "compondre", "comportar", "comprendre", "comprimir", "comprometre", "compungir", "comunicar", "concentrar", "concertar", "conciliar", "concordar", "concretar", "condemnar", "condensar", "conduir", "confabular", "confederar", "confessar", "confinar", "confirmar", "confitar", "conformar", "congelar", "congestionar", "conglomerar", "conglutinar", "congratular", "congregar", "congriar", "conhortar", "conjuminar", "conjunyir", "conjurar", "connaturalitzar", "consagrar", "conscienciar", "consentir", "conservar", "consolar", "consolidar", "constipar", "consumir", "contagiar", "contaminar", "contemperar", "contenir", "contorbar", "contornar", "contradir", "contraposar", "contreure", "controlar", "convertir", "convèncer", "corbar", "corcar", "cordar", "coronar", "corporificar", "corregir", "correspondre", "corrompre", "corsecar", "cotitzar", "covar", "crebantar", "cremar", "creure", "criar", "crispar", "cucar", "cuidar", "cuixatrencar", "curar", "curullar", "damnar", "debatre", "decantar", "decidir", "declarar", "decuplicar", "decurvar", "dedicar", "defendre", "defensar", "definir", "deformar", "defugir", "degradar", "deixar", "deixatar", "deixondar", "deixondir", "deixuplinar", "delectar", "delir", "delitar", "denudar", "departir", "depauperar", "depilar", "deportar", "depositar", "depravar", "deprimir", "depurar", "derivar", "desabillar", "desabonar", "desabrigar", "desacalorar", "desacoblar", "desaconductar", "desaconduir", "desacordar", "desacostumar", "desacreditar", "desadherir", "desaferrar", "desafinar", "desagafar", "desagermanar", "desagradar", "desagregar", "desajustar", "desalinear", "desamarrar", "desamigar", "desamistançar", "desamorrar", "desanar", "desanimar", "desaparellar", "desapariar", "desaparroquianar", "desaplicar", "desapropiar", "desar", "desarborar", "desarmar", "desarramadar", "desarrambar", "desarranjar", "desarrapar", "desarreglar", "desarregussar", "desarrelar", "desarrengar", "desarrenglar", "desarrenglerar", "desarrimar", "desarrissar", "desarromangar", "desarrufar", "desarrugar", "desarticular", "desassossegar", "desatansar", "desatapeir", "desatendar", "desavesar", "desaveïnar", "desballestar", "desbaratar", "desbarbar", "desbarrar", "desbordar", "desbrancar", "desbraonar", "descabalar", "descabdellar", "descabellar", "descalcificar", "descalçar", "descaminar", "descantellar", "descarbonatar", "descarbonitzar", "descarburar", "descargolar", "descarnar", "descarregar", "descarrerar", "descartar", "descastellanitzar", "descatalanitzar", "descelerar", "descentrar", "descenyir", "desclassar", "desclavar", "descloure", "descoagular", "descobrir", "descolgar", "descollar", "descolorar", "descolorir", "descol·locar", "descompassar", "descompensar", "descompondre", "descomprometre", "descomptar", "desconceptuar", "desconcertar", "desconfortar", "descongelar", "descongestionar", "desconhortar", "desconjuntar", "desconnectar", "descoratjar", "descordar", "descosir", "descotxar", "descrostar", "descular", "desdaurar", "desdelitar", "desdenyar", "desdibuixar", "desdinerar", "desdir", "desdoblar", "desdoblegar", "deseixir", "deselectritzar", "desembabaiar", "desembadalir", "desembadocar", "desemballestar", "desemboirar", "desembolcallar", "desembolcar", "desembolicar", "desembotir", "desembotjar", "desembotornar", "desemboçar", "desembravir", "desembrocar", "desembromallar", "desembromar", "desembullar", "desembussar", "desembutllofar", "desemmandrir", "desemmurriar", "desempallar", "desempastar", "desemperesir", "desempernar", "desempipar", "desempobrir", "desempolainar", "desempolsar", "desempolvorar", "desenamorar", "desencadenar", "desencaixar", "desencalimar", "desencalitjar", "desencallar", "desencaminar", "desencantar", "desencaparrar", "desencapotar", "desencaputxar", "desencarar", "desencarcarar", "desencarranquinar", "desencartonar", "desencastar", "desencaterinar", "desencauar", "desencavalcar", "desencavallar", "desencebar", "desencerclar", "desencercolar", "desencimbellar", "desencisar", "desenclavar", "desencoblar", "desencolar", "desencongir", "desencoratjar", "desencorbar", "desencordillar", "desencrespar", "desencrostar", "desendegar", "desendeutar", "desendogalar", "desendolcir", "desendollar", "desendropir", "desenfadar", "desenfadeir", "desenfarfegar", "desenfellonir", "desenferrissar", "desenfetgegar", "desenfilar", "desenfitar", "desenflocar", "desenfocar", "desenfrenar", "desenfuriar", "desenfurismar", "desengandulir", "desenganxar", "desenganyar", "desengatjar", "desengavanyar", "desengomar", "desengormandir", "desengorronir", "desengreixar", "desengrescar", "desengruixir", "desengrutar", "desenguantar", "desenguerxir", "desenllaminir", "desenllaçar", "desenlleganyar", "desenllepolir", "desenllorar", "desenlluernar", "desenllustrar", "desennuegar", "desennuvolar", "desenquadernar", "desenquadrar", "desenquimerar", "desenrampar", "desenredar", "desenrederar", "desenrolar", "desenrotllar", "desensabonar", "desensenyorir", "desensonyar", "desensopir", "desensuperbir", "desentaular", "desentelar", "desentendre", "desentenebrar", "desentenebrir", "desenterbolir", "desenterrar", "desentestar", "desentortolligar", "desentrampar", "desentranyar", "desentravessar", "desentrecuixar", "desentrenar", "desentristir", "desentumir", "desentusiasmar", "desenutjar", "desenvelar", "desenvernissar", "desenvescar", "desenvolupar", "desenyorar", "desequilibrar", "desertitzar", "desesmar", "desesperançar", "desesperar", "desespessir", "desestancar", "desestanyar", "desestovar", "desfaixar", "desfaiçonar", "desfanatitzar", "desfardar", "desfasar", "desfermar", "desferrar", "desficiar", "desficiejar", "desfigurar", "desfilar", "desflorir", "desfocar", "desfogar", "desfonar", "desfrarar", "desfrenar", "desfrunzir", "desfullar", "desganar", "desgastar", "desgavellar", "desglaçar", "desgraciar", "desgranar", "desgruixar", "desguarnir", "desguerxar", "desguitarrar", "deshabitar", "deshabituar", "deshidratar", "deshumanitzar", "desigualar", "desil·lusionar", "desimantar", "desincorporar", "desincrustar", "desinfatuar", "desinflamar", "desinflar", "desinhibir", "desintegrar", "desinteressar", "desintoxicar", "desionitzar", "desjunyir", "deslligar", "deslliurar", "desllodrigar", "desllogar", "deslloriguerar", "deslluir", "desllustrar", "desmagnetitzar", "desmaiar", "desmallar", "desmanegar", "desmaquillar", "desmarcar", "desmembrar", "desmillorar", "desmoralitzar", "desmorriar", "desmudar", "desmuntar", "desnacionalitzar", "desnaturar", "desniar", "desnierar", "desnivellar", "desnuar", "desnucar", "desobligar", "desobstruir", "desocupar", "desorbitar", "desordenar", "desorganitzar", "desorientar", "despacientar", "desparar", "desparellar", "despariar", "despassar", "despenjar", "despentinar", "despenyar", "despersonalitzar", "despertar", "despintar", "despistar", "despitar", "desplaçar", "desplegar", "desplomar", "despoblar", "despolir", "desposseir", "desprendre", "desprestigiar", "desprisar", "despullar", "despuntar", "desrengar", "desroentar", "dessaborir", "dessagnar", "dessecar", "dessolar", "dessoldar", "dessonillar", "dessoterrar", "dessuar", "dessucar", "destacar", "destapar", "destarotar", "destemprar", "destenyir", "desteular", "destintar", "destorçar", "destravar", "destrempar", "destrenar", "destriar", "destrossar", "destòrcer", "desunglar", "desunir", "desusar", "desvariar", "desvariejar", "desvesar", "desvestir", "desvetllar", "desviar", "desvincular", "desvitrificar", "detenir", "deteriorar", "determinar", "deturar", "devaluar", "dialitzar", "dibuixar", "diferenciar", "difondre", "diftongar", "difuminar", "dignificar", "dilatar", "diluir", "dipositar", "dirigir", "disbauxar", "disciplinar", "disculpar", "disfressar", "disgregar", "disgustar", "dislocar", "disparar", "dispersar", "disposar", "disputar", "disseminar", "dissimilar", "dissipar", "dissociar", "dissoldre", "distanciar", "distendre", "distingir", "distreure", "distribuir", "diversificar", "divertir", "dividir", "divorciar", "divulgar", "doblar", "doblegar", "doctorar", "documentar", "doldre", "domesticar", "domiciliar", "dominar", "donar", "dopar", "dreçar", "drogar", "dubtar", "dulcificar", "duplicar", "dutxar", "eclipsar", "efectuar", "efeminar", "eixamar", "eixamenar", "eixamorar", "eixamplar", "eixancar", "eixancarrar", "eixarrancar", "eixarreir", "eixorivir", "eixugar", "electritzar", "electrocutar", "elevar", "elidir", "emancipar", "embabaiar", "embadalir", "embadocar", "embajanir", "embalar", "embalbar", "embalbir", "embancar", "embarbollar", "embarcar", "embardissar", "embarracar", "embarrancar", "embarranquinar", "embarrar", "embarumar", "embarzerar", "embasardir", "embassar", "embastardir", "embellir", "embeure", "embicar", "emblanquir", "emblavir", "embofegar", "embogir", "emboirar", "embolicar", "emborbollar", "emborratxar", "emboscar", "embossar", "embotinar", "embotir", "emboçar", "embrancar", "embravir", "embretolir", "embriagar", "embrocar", "embrollar", "embromar", "embrossar", "embrunir", "embrutar", "embrutir", "embullar", "embussar", "embutllofar", "embutxacar", "emmagrir", "emmalaltir", "emmaleir", "emmallar", "emmandrir", "emmarcir", "emmaridar", "emmascarar", "emmatxucar", "emmerdar", "emmerdissar", "emmetzinar", "emmirallar", "emmotllar", "emmudir", "emmusteir", "emmustigar", "emocionar", "empadronar", "empal·lidir", "empantanar", "empantanegar", "empanxonar", "empapatxar", "emparar", "emparaular", "emparentar", "emparrar", "empastellar", "empastifar", "empastissar", "empatxar", "empedreir", "empeguntar", "empellar", "empeltar", "empenyorar", "emperesir", "emperlar", "empernar", "empetitir", "empilar", "empinar", "empipar", "empitjorar", "empitrar", "empixonar", "emplenar", "emplomallar", "empobrir", "empolainar", "empolistrar", "empolsar", "empolsegar", "empolsimar", "empolsinar", "empolvorar", "empoquir", "emporcar", "emporprar", "empotingar", "emprendre", "emprenyar", "emprovar", "enagrir", "enamorar", "enamoriscar", "enarborar", "enarbrar", "enarcar", "enardir", "enasprar", "enasprir", "encabassar", "encabir", "encaboriar", "encadarnar", "encadenar", "encaixar", "encalbir", "encalimar", "encalitjar", "encallar", "encallir", "encambrar", "encamellar", "encaminar", "encamisar", "encantar", "encaparrar", "encapellar", "encaperonar", "encaperullar", "encaperutxar", "encapirotar", "encapotar", "encapsular", "encapullar", "encaputxar", "encaramel·lar", "encarar", "encarbonar", "encarir", "encarnar", "encarranquinar", "encarregar", "encarrerar", "encarrilar", "encartonar", "encasquetar", "encastellar", "encauar", "encavallar", "encegar", "encendre", "encepar", "encertir", "encetar", "encimbellar", "enciriar", "enclaustrar", "enclotar", "encloure", "encoblar", "encofurnar", "encoixir", "encomanar", "enconar", "enconcar", "encongir", "encontrar", "encoratjar", "encorbar", "encordar", "encotillar", "encotxar", "encovar", "encrespar", "encreuar", "encrostar", "encrostimar", "encrostissar", "encruelir", "endarreriar", "endarrerir", "endegar", "endentar", "endenyar", "enderrocar", "endeutar", "endinsar", "endogalar", "endolcir", "endolentir", "endossar", "endropir", "endurir", "enemistar", "enervar", "enfadar", "enfadeir", "enfangar", "enfarfegar", "enfarinar", "enfastidir", "enfastijar", "enfellonir", "enfervorir", "enfetgegar", "enfigassar", "enfilar", "enfistular", "enfitar", "enflocar", "enflorar", "enfondir", "enfonsar", "enfonyar", "enforfoguir", "enforinyar", "enfortir", "enfosquir", "enfredar", "enfredolicar", "enfredorar", "enfredorir", "enfrontar", "enfuriar", "enfurir", "enfurismar", "engabiar", "engalavernar", "engallar", "engallardir", "engallir", "engallofir", "engalonar", "engalvanir", "enganar", "engandulir", "enganxar", "enganyar", "engatar", "engatjar", "engelosir", "enginjolar", "enginyar", "engiponar", "englotir", "engolar", "engolir", "engordir", "engorjar", "engormandir", "engorronir", "engrandir", "engreixar", "engrescar", "engrevir", "engroguir", "engronsar", "engronyar", "engrossir", "engruixar", "engruixir", "engrutar", "enguantar", "enguerxir", "enherbar", "enjoiar", "enjoiellar", "enjoncar", "enjullar", "enlairar", "enllacar", "enllaminir", "enllangorir", "enllardar", "enllardissar", "enllaçar", "enllefernar", "enllefiscar", "enllepissar", "enllepolir", "enllestir", "enlletgir", "enllistar", "enllorar", "enllordar", "enllotar", "enllustrar", "ennegrir", "ennoblir", "ennovar", "ennuegar", "ennuvolar", "enorgullar", "enquadrar", "enquibir", "enquimerar", "enrabiar", "enramar", "enrampar", "enrancir", "enrarir", "enrasar", "enravenar", "enredar", "enrederar", "enrederir", "enrellentir", "enretirar", "enrevenxinar", "enriallar", "enrigidir", "enrinxolar", "enriquir", "enrobustir", "enrocar", "enrogir", "enrolar", "enronquir", "enrosar", "enrossir", "enrotllar", "enrullar", "enrunar", "ensabonar", "ensagnar", "ensalivar", "ensangonar", "enseguir", "ensenyorir", "ensonyar", "ensopegar", "ensopir", "ensordir", "ensorrar", "ensotar", "ensulsir", "ensuperbir", "entaforar", "entatxonar", "entaular", "entebeir", "entebionar", "entelar", "entendre", "entendrir", "entenebrar", "entenebrir", "enterbolir", "enterrar", "enterrossar", "entestar", "entollar", "entonar", "entornar", "entortellar", "entortolligar", "entrampar", "entrapar", "entravessar", "entrebancar", "entregar", "entregirar", "entrellaçar", "entrelligar", "entremesclar", "entrenar", "entretenir", "entreveure", "entrevistar", "entristar", "entristir", "entumir", "enturar", "entusiasmar", "enutjar", "envanir", "envellir", "envellutar", "enverdir", "enverinar", "envermellir", "envescar", "enviar", "envigorir", "envilir", "environar", "enviscar", "enviscolar", "envitricollar", "envoltar", "enxarxar", "enxiquir", "enyorar", "equilibrar", "equivaler", "equivocar", "erigir", "eriçar", "errar", "esbadiar", "esbadinar", "esbadocar", "esbalair", "esbaldir", "esbaldregar", "esbandir", "esbardellar", "esbargir", "esbarriar", "esbarzerar", "esberlar", "esbocinar", "esboirar", "esboldregar", "esbombar", "esbombolar", "esborifar", "esborrar", "esborrifar", "esborronar", "esbotifarrar", "esbotzar", "esbrancar", "esbraonar", "esbraveir", "esbullar", "escabellar", "escabellonar", "escabotar", "escaldar", "escaldufar", "escalfar", "escalfeir", "escalivar", "escalonar", "escamarlar", "escamnar", "escampar", "escandalitzar", "escantellar", "escantonar", "escanyar", "escapar", "escarmentar", "escarrabillar", "escarxar", "escaure", "escindir", "esclafar", "esclafassar", "esclarir", "esclerosar", "escolar", "escoltar", "escometre", "escondir", "escotar", "escridar", "escridassar", "escrostar", "escrostissar", "escrostonar", "escruixir", "escuar", "escudar", "escuixar", "escular", "escurçar", "escórrer", "esdernegar", "esdevenir", "esduir", "esfacelar", "esfereir", "esfilagarsar", "esfondrar", "esfreixurar", "esfullar", "esfumar", "esgallar", "esgardissar", "esgarrar", "esgarrifar", "esgarrinxar", "esgarrinyar", "esgarronar", "esgavellar", "esglaonar", "esgotar", "esgratinyar", "esguardar", "esguerrar", "esllenegar", "esllomar", "esmadeixar", "esmalucar", "esmenar", "esmicar", "esmicolar", "esmolar", "esmorrellar", "esmorronar", "esmortir", "esmunyir", "esmussar", "espalmar", "espantar", "espanyolitzar", "espaordir", "espargir", "esparpallar", "esparpillar", "esparracar", "esparverar", "espassar", "espatllar", "espaventar", "espavilar", "especejar", "especialitzar", "espedaçar", "espellifar", "espellir", "espellissar", "espenyar", "esperançar", "esperar", "espesseir", "espessir", "espicassar", "espigar", "espinar", "espitrar", "esplaiar", "esplugar", "espolsar", "espoltrir", "esponjar", "esporuguir", "esposar", "esprémer", "espuar", "espuntar", "espunyir", "espuçar", "esqueixar", "esquerar", "esquerdar", "esquerdillar", "esquerdissar", "esquinçar", "esquitxar", "esquivar", "est", "estabilitzar", "establir", "estacionar", "estalviar", "estamordir", "estancar", "estandarditzar", "estantolar", "estanyar", "estarrufar", "estellar", "estendre", "estepitzar", "estilitzar", "estimbar", "estintolar", "estirar", "estireganyar", "estiuar", "estontolar", "estovar", "estrangeritzar", "estranyar", "estratificar", "estrenar", "estressar", "estretir", "estrinxolar", "estripar", "estroncar", "estropellar", "estrènyer", "estubar", "estufar", "esvair", "esvalotar", "esventar", "esvorar", "esvorellar", "eternitzar", "europeïtzar", "evadir", "evaporar", "exacerbar", "exaltar", "examinar", "exasperar", "excedir", "excitar", "exclamar", "excloure", "exculpar", "excusar", "exercitar", "exfoliar", "exhalar", "exhaurir", "exhibir", "exiliar", "eximir", "exornar", "expandir", "expatriar", "explicar", "exposar", "expressar", "extasiar", "extenuar", "exterioritzar", "extingir", "extraviar", "extremar", "faixar", "familiaritzar", "fanatitzar", "fastiguejar", "fatigar", "federar", "felicitar", "feminitzar", "ferir", "fiar", "ficar", "figurar", "filtrar", "fingir", "firar", "fixar", "flagel·lar", "florir", "folrar", "foraviar", "forcar", "forjar", "formalitzar", "formar", "fortificar", "fossilitzar", "fotre", "fraccionar", "fracturar", "fragmentar", "francesitzar", "franquejar", "fregar", "fregir", "frisar", "fumar", "fundar", "gabar", "gastar", "gaudir", "gelar", "generalitzar", "gestar", "ginyar", "girar", "gitar", "glaçar", "gloriejar", "governar", "graduar", "gramaticalitzar", "gratar", "gratular", "gravar", "grecitzar", "grillar", "gronxar", "gronxejar", "gronxolar", "guanyar", "guardar", "guarir", "guarnir", "guerxar", "guiar", "guillar", "habituar", "hebraïtzar", "hel·lenitzar", "hemodialitzar", "herniar", "hibridar", "hidratar", "hissar", "honorar", "honrar", "horripilar", "horroritzar", "hostatjar", "humanitzar", "humiliar", "humitejar", "identificar", "igualar", "il·luminar", "il·lusionar", "il·lustrar", "imaginar", "immergir", "immolar", "impacientar", "implicar", "imposar", "impressionar", "imprimir", "impurificar", "incarcerar", "incendiar", "inclinar", "incomodar", "incorporar", "incrementar", "incrustar", "independitzar", "indignar", "indisposar", "inebriar", "infatuar", "infectar", "infestar", "infiltrar", "inflamar", "inflar", "informar", "ingerir", "inhabilitar", "inhibir", "iniciar", "inquietar", "inscriure", "insinuar", "inspirar", "instal·lar", "instruir", "insubordinar", "insultar", "insurreccionar", "integrar", "intensificar", "interessar", "interferir", "internar", "interposar", "interrompre", "intranquil·litzar", "introduir", "inundar", "invaginar", "inventar", "ionitzar", "irritar", "islamitzar", "isolar", "jubilar", "jugar", "junyir", "justificar", "lamentar", "laxar", "lignificar", "limitar", "llampar", "llançar", "llassar", "llatinitzar", "llepar", "lletrejar", "llevar", "llicenciar", "lligar", "lliurar", "llogar", "lluir", "localitzar", "lucrar", "macerar", "malacostumar", "malavesar", "maliciar", "mallar", "malpensar", "mamar", "mancomunar", "manegar", "manejar", "manifestar", "mantenir", "maquillar", "marcir", "marejar", "marginar", "maridar", "marinejar", "mascarar", "massificar", "masturbar", "matar", "materialitzar", "matricular", "matxucar", "mecanitzar", "mediumitzar", "menar", "menjar", "mentalitzar", "menysprear", "meravellar", "merèixer", "mesclar", "metal·litzar", "metamorfosar", "meteoritzar", "migrar", "millorar", "mineralitzar", "mirar", "mobilitzar", "mocar", "moderar", "modernitzar", "modificar", "molestar", "morfondre", "morir", "morrejar", "mortificar", "mossegar", "mostrar", "moure", "mudar", "mullar", "multiplicar", "musteir", "mustiar", "mustigar", "mutilar", "nacionalitzar", "naturalitzar", "necrosar", "negar", "neguitejar", "netejar", "nonuplicar", "normalitzar", "nuar", "oblidar", "obligar", "obnubilar", "obscurir", "occidentalitzar", "occitanitzar", "ocultar", "ocupar", "ofegar", "oferir", "ofuscar", "ombrar", "omplir", "operar", "oposar", "ordenar", "orejar", "organitzar", "orgullar", "orientalitzar", "orientar", "originar", "orinar", "oscar", "oxigenar", "pacificar", "paganitzar", "pagar", "pansir", "parapetar", "parar", "parlar", "particularitzar", "partir", "passar", "passejar", "pedregar", "pedrejar", "pellar", "penjar", "pensar", "pentinar", "percaçar", "perfeccionar", "perfilar", "permetre", "persignar", "persuadir", "pessigar", "petar", "picar", "pintar", "pirar", "plantar", "plantejar", "plantificar", "podrir", "polaritzar", "polir", "pol·linitzar", "pondre", "popularitzar", "portar", "posar", "possessionar", "posticar", "postrar", "prear", "precipitar", "prendre", "preocupar", "preparar", "presentar", "prestar", "prevaler", "privar", "proclamar", "prodigar", "produir", "professionalitzar", "proletaritzar", "prometre", "pronunciar", "propagar", "propalar", "proposar", "prostituir", "prostrar", "prou", "proveir", "pujar", "punxar", "purificar", "putejar", "quadrar", "qualificar", "quallar", "quedar", "quitar", "rabejar", "radicalitzar", "rarificar", "ratificar", "reafirmar", "realitzar", "rebaixar", "rebentar", "reblir", "rebolcar", "rebullir", "recargolar", "reciclar", "reciprocar", "recloure", "recobrar", "recollir", "recolzar", "reconcentrar", "reconciliar", "reconstituir", "recordar", "recrear", "recriminar", "rectificar", "reencarnar", "reenganxar", "refer", "referir", "refermar", "reflectir", "refocil·lar", "reforçar", "refractar", "refredar", "refrenar", "refrescar", "refringir", "refugiar", "refusar", "regalar", "regelar", "regirar", "rehabilitar", "rehidratar", "reincorporar", "reinflar", "reinstal·lar", "reintegrar", "rejovenir", "relacionar", "relaxar", "rellentir", "relligar", "rellogar", "remenar", "remetre", "remirar", "remollir", "remudar", "remuntar", "rendir", "renovar", "renovellar", "rentar", "repatriar", "repenjar", "repensar", "repetir", "repintar", "replegar", "replujar", "repodrir", "reportar", "reposar", "representar", "reprimir", "reproduir", "repuntar", "rescabalar", "reservar", "resguardar", "resignar", "resinificar", "resistir", "resoldre", "responsabilitzar", "resquitar", "ressecar", "ressobinar", "restablir", "retardar", "retenir", "retintar", "retirar", "retractar", "retre", "retreure", "retrobar", "reunir", "reveixinar", "revelar", "revellir", "revenxinar", "revestir", "revifar", "reviscolar", "revoltar", "rifar", "rinxolar", "riure", "romanitzar", "rombollar", "rompre", "rostir", "rovellar", "ruboritzar", "russificar", "sacrificar", "salmorrar", "salsir", "salvar", "santificar", "satel·litzar", "secularitzar", "sedimentar", "segar", "segregar", "seguir", "sentir", "senyar", "separar", "significar", "silicificar", "sincerar", "sindicar", "singularitzar", "sinitzar", "situar", "sobrealimentar", "sobreexcitar", "sobreposar", "sobresaltar", "sobresanar", "sobresaturar", "sobtar", "socarrar", "solapar", "solar", "solaçar", "soldar", "solidaritzar", "solidificar", "sollar", "sollevar", "solvatar", "somorgollar", "soplujar", "sostreure", "sotaplujar", "sotmetre", "suberificar", "suberitzar", "subestimar", "submergir", "subscriure", "suggestionar", "sulfatar", "sulfurar", "sumar", "sumir", "superar", "tallar", "tancar", "tant", "tapar", "temperar", "tenyir", "terraplenar", "tirar", "titular", "tocar", "tombar", "torbar", "torejar", "tornar", "torrar", "trabucar", "tractar", "tranquil·litzar", "transfigurar", "transformar", "translimitar", "transmetre", "transmutar", "transparentar", "transvasar", "trasmudar", "trasplantar", "trastocar", "trastornar", "triar", "tribular", "trifurcar", "trobar", "tòrcer", "ulcerar", "ullar", "unir", "universalitzar", "untar", "vaporitzar", "velar", "venjar", "ventar", "vessar", "vestir", "viciar", "vinclar", "vincular", "vitrificar", "volar", "volatilitzar", "xalar", "xutar");
   private static final List<String> excepVerbsPotencialmentPronominals = Arrays.asList("voler");
   
   private static final List<String> verbHaver= Arrays.asList("haver");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -51,6 +51,7 @@ public void testRule() throws IOException {
     //assertCorrect("Una equivocació tan gran no es pot callar.");
     //assertCorrect(" és del tot necessari si no es vol caure en una religió alienant");
 
+    assertCorrect("No em plantejo anar a un altre partit");
     assertCorrect("-Deixa't caure al canal i prou");
     assertCorrect("Deixa't caure al canal i prou");
     assertCorrect("Durant el 2010 s'ha crescut molt");

File: languagetool-language-modules/en/src/main/java/org/languagetool/synthesis/en/EnglishSynthesizer.java
Patch:
@@ -132,7 +132,7 @@ private void lookup(String lemma, String posTag, List<String> results, String de
     synchronized (this) { // the stemmer is not thread-safe
       final List<WordData> wordForms = getStemmer().lookup(lemma + "|" + posTag);
       for (WordData wd : wordForms) {
-        results.add(determiner + wd.getStem().toString());
+        results.add(determiner + wd.getStem());
       }
     }
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/chunking/TokenPredicate.java
Patch:
@@ -18,12 +18,13 @@
  */
 package org.languagetool.chunking;
 
+import edu.washington.cs.knowitall.logic.Expression;
 import org.languagetool.AnalyzedToken;
 import org.languagetool.AnalyzedTokenReadings;
 
 import java.util.regex.Pattern;
 
-final class TokenPredicate extends edu.washington.cs.knowitall.logic.Expression.Arg.Pred<ChunkTaggedToken> {
+final class TokenPredicate extends Expression.Arg.Pred<ChunkTaggedToken> {
 
   private final boolean caseSensitive;
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -60,7 +60,7 @@ private enum GrammarCategory {
     NUMERUS("Numerus (Einzahl, Mehrzahl - Beispiel: 'das Fahrräder' statt 'die Fahrräder')");
     
     private final String displayName;
-    private GrammarCategory(String displayName) {
+    GrammarCategory(String displayName) {
       this.displayName = displayName;
     }
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -232,8 +232,8 @@ private boolean ignoreSuggestion(String suggestion) {
   }
 
   private static class Replacement {
-    String key;
-    String value;
+    final String key;
+    final String value;
     private Replacement(String key, String value) {
       this.key = key;
       this.value = value;

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -29,7 +29,6 @@
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.AnalyzedToken;
 import org.languagetool.AnalyzedTokenReadings;
-import org.languagetool.Language;
 import org.languagetool.language.German;
 import org.languagetool.rules.Category;
 import org.languagetool.rules.Example;

File: languagetool-language-modules/de/src/test/java/org/languagetool/chunking/TokenPredicateTest.java
Patch:
@@ -52,7 +52,9 @@ public void test() {
     try {
       assertNoMatch("invalid=token", chunkTaggedToken);
       fail();
-    } catch (RuntimeException expected) {}
+    } catch (RuntimeException expected) {
+      //expected
+    }
   }
 
   private void assertMatch(String expr, ChunkTaggedToken chunkTaggedToken) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -102,7 +102,7 @@ public void testIgnoreWord() throws Exception {
     assertFalse(ruleSwiss.doIgnoreWord("Ligafußball"));  // 'ß' never accepted for Swiss
   }
 
-  private class MyGermanSpellerRule extends GermanSpellerRule {
+  private static class MyGermanSpellerRule extends GermanSpellerRule {
     MyGermanSpellerRule(ResourceBundle messages, German language) throws IOException {
       super(messages, language);
       init();

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -433,6 +433,7 @@ public class CaseRule extends GermanRule {
 
   private static final Set<String> substVerbenExceptions = new HashSet<>();
   static {
+    substVerbenExceptions.add("helfen");
     substVerbenExceptions.add("lassen");
     substVerbenExceptions.add("passieren");  // "das Schlimmste, das passieren könnte"
     substVerbenExceptions.add("machen");  // "Du kannst das machen."

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -63,6 +63,7 @@ public void testWrongVerb() throws IOException {
     assertGood("Wenn es sterben sollte, wer würde sich dann um die Katze kümmern?");
     assertGood("Wenn ihr sterben solltet, wer würde sich dann um die Katze kümmern?");
     assertGood("Wenn wir sterben sollten, wer würde sich dann um die Katze kümmern?");
+    assertGood("Dafür erhielten er sowie der Hofgoldschmied Theodor Heiden einen Preis.");
     assertGood("/usr/bin/firefox");
     // incorrect sentences:
     assertBad("Als Borcarbid weißt es eine hohe Härte auf.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/chunking/GermanChunker.java
Patch:
@@ -211,6 +211,8 @@ public static boolean isDebug() {
 
       // ===== prepositional phrases ===========================================================
 
+      // "laut den meisten Quellen":
+      build("<laut> <regex=.*>{0,3} <Quellen>", PP, true),
       // "bei den sehr niedrigen Oberflächentemperaturen" (OpenNLP doesn't find this)
       build("<pos=PRP> <pos=ART:> <pos=ADV>* <pos=ADJ> <NP>", PP, true),
       // "in den alten Religionen, Mythen und Sagen":

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SubjectVerbAgreementRuleTest.java
Patch:
@@ -280,7 +280,8 @@ public void testRuleWithCorrectSingularVerb() throws IOException {
         "In christlichen, islamischen und jüdischen Traditionen ist das höchste Ziel der meditativen Praxis.",
         "Der Autor der beiden Spielbücher war Markus Heitz selbst.",
         "Der Autor der ersten beiden Spielbücher war Markus Heitz selbst.",
-        "Das Ziel der elf neuen Vorstandmitglieder ist klar definiert."
+        "Das Ziel der elf neuen Vorstandmitglieder ist klar definiert.",
+        "Laut den meisten Quellen ist das Seitenverhältnis der Nationalflagge..."
     );
     for (String sentence : sentences) {
       assertGood(sentence);

File: languagetool-language-modules/de/src/main/java/org/languagetool/chunking/GermanChunker.java
Patch:
@@ -113,6 +113,8 @@ public static boolean isDebug() {
 
   private static final List<RegularExpressionWithPhraseType> REGEXES2 = Arrays.asList(
       // ===== plural and singular noun phrases, based on OpenNLP chunker output ===============
+      // "In christlichen, islamischen und jüdischen Traditionen":
+      build("<pos=ADJ> <,> <chunk=B-NP> <chunk=I-NP>* <und|sowie> <NP>", NPP),
       // "ein Hund und eine Katze":
       build("<chunk=B-NP & !regex=jede[rs]?> <chunk=I-NP>* <und|sowie> <NP>", NPP),
       // "größte und erfolgreichste Erfindung" (fixes mistagging introduced above):

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SubjectVerbAgreementRuleTest.java
Patch:
@@ -276,7 +276,8 @@ public void testRuleWithCorrectSingularVerb() throws IOException {
         "Ja, die Milch ist sehr gut.",
         "Der als Befestigung gedachte östliche Teil der Burg ist weitgehend verfallen.",
         "Das Kopieren und Einfügen ist sehr nützlich.",
-        "Der letzte der vier großen Flüsse ist die Kolyma."
+        "Der letzte der vier großen Flüsse ist die Kolyma.",
+        "In christlichen, islamischen und jüdischen Traditionen ist das höchste Ziel der meditativen Praxis."
     );
     for (String sentence : sentences) {
       assertGood(sentence);

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/MorfologikCatalanSpellerRuleTest.java
Patch:
@@ -265,6 +265,8 @@ public void testMorfologikSpeller() throws IOException {
         assertEquals("atemptats", matches[0].getSuggestedReplacements().get(0));
         matches = rule.match(langTool.getAnalyzedSentence("contable"));
         assertEquals("comptable", matches[0].getSuggestedReplacements().get(0));
+        matches = rule.match(langTool.getAnalyzedSentence("desició"));
+        assertEquals("decisió", matches[0].getSuggestedReplacements().get(0));
         
         matches = rule.match(langTool.getAnalyzedSentence("España"));
         assertEquals("Espanya", matches[0].getSuggestedReplacements().get(0));

File: languagetool-office-extension/src/test/java/org/languagetool/openoffice/MainTest.java
Patch:
@@ -28,6 +28,7 @@ public class MainTest extends TestCase {
   
   public void testDoProofreading() {
     final Main prog = new Main(null);
+    Main.setTestMode(true);
     final String testString = "To jest trudne zdanie. A to następne.  A to przedostatnie jest.\u0002 Test ostatniego.";
     final Locale plLoc = new Locale("pl", "PL", "");
     final PropertyValue[] prop = new PropertyValue[0];
@@ -55,6 +56,7 @@ public void testDoProofreading() {
 
   public void testVariants() {
     final Main prog = new Main(null);
+    Main.setTestMode(true);
     final String testString = "Sigui quina siga la teva intenció. Això és una prova.";
     // LibreOffice config for languages with variants
     final Locale cavaLoc = new Locale("qlt", "ES", "ca-ES-valencia"); 
@@ -78,6 +80,7 @@ public void testVariants() {
 
   public void testCleanFootnotes() {
     final Main prog = new Main(null);
+    Main.setTestMode(true);
     assertEquals("A house.¹ Here comes more text.", prog.cleanFootnotes("A house.1 Here comes more text."));
     assertEquals("A road that's 3.4 miles long.", prog.cleanFootnotes("A road that's 3.4 miles long."));
     assertEquals("A house.1234 Here comes more text.", prog.cleanFootnotes("A house.1234 Here comes more text."));  // too many digits for a footnote

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/MorfologikCatalanSpellerRule.java
Patch:
@@ -74,6 +74,9 @@ public boolean useInOffice() {
   protected List<String> getAdditionalTopSuggestions(List<String> suggestions,
       String word) throws IOException {
     //TODO try other combinations. Ex. daconseguirlos
+    if (word.length() < 5 || word.endsWith("as")) {
+      return Collections.emptyList();
+    }
     String suggestion = "";
     suggestion = findSuggestion(suggestion, word, APOSTROF_INICI_VERBS, VERB_INDSUBJ, 2, "'");
     suggestion = findSuggestion(suggestion, word, APOSTROF_INICI_NOM_SING, NOM_SING, 2, "'");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/MorfologikCatalanSpellerRuleTest.java
Patch:
@@ -310,6 +310,8 @@ public void testMorfologikSpeller() throws IOException {
         assertEquals("veure-les", matches[0].getSuggestedReplacements().get(0));
         matches = rule.match(langTool.getAnalyzedSentence("lilla"));
         assertEquals("l'illa", matches[0].getSuggestedReplacements().get(0));
+        matches = rule.match(langTool.getAnalyzedSentence("portas"));
+        assertEquals("portes", matches[0].getSuggestedReplacements().get(0));
 
     }
     

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AbstractEnglishSpellerRule.java
Patch:
@@ -114,10 +114,11 @@ private IrregularForms getIrregularFormsOrNull(String word, String wordSuffix, L
   }
 
   /**
+   * @throws IOException 
    * @since 2.7
    */
   @Override
-  protected List<String> getAdditionalTopSuggestions(List<String> suggestions, String word) {
+  protected List<String> getAdditionalTopSuggestions(List<String> suggestions, String word) throws IOException {
     if ("Alot".equals(word)) {
       return Arrays.asList("A lot");
     } else if ("alot".equals(word)) {

File: languagetool-language-modules/uk/src/main/java/org/languagetool/tagging/uk/UkrainianTagger.java
Patch:
@@ -129,19 +129,19 @@ public class UkrainianTagger extends BaseTagger {
       Scanner scanner = new Scanner(is,"UTF-8");
       String text = scanner.useDelimiter("\\A").next();
       scanner.close();
-      dashPrefixes = new HashSet<>( java.util.Arrays.asList(text.split("\n")) );
+      dashPrefixes = new HashSet<>( java.util.Arrays.asList(text.split("[\r\n]+")) );
       
       is = JLanguageTool.getDataBroker().getFromResourceDirAsStream("/uk/dash_left_master.txt");
       scanner = new Scanner(is,"UTF-8");
       text = scanner.useDelimiter("\\A").next();
       scanner.close();
-      leftMasterSet = new HashSet<>( java.util.Arrays.asList(text.split("\n")) );
+      leftMasterSet = new HashSet<>( java.util.Arrays.asList(text.split("[\r\n]+")) );
 
       is = JLanguageTool.getDataBroker().getFromResourceDirAsStream("/uk/dash_slaves.txt");
       scanner = new Scanner(is,"UTF-8");
       text = scanner.useDelimiter("\\A").next();
       scanner.close();
-      slaveSet = new HashSet<>( java.util.Arrays.asList(text.split("\n")) );
+      slaveSet = new HashSet<>( java.util.Arrays.asList(text.split("[\r\n]+")) );
       // TODO: "бабуся", "лялька", "рятівник" - not quite slaves, could be masters too
 
     }

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -341,6 +341,9 @@ private void activateDefaultFalseFriendRules()
     final String falseFriendRulesFilename = JLanguageTool.getDataBroker().getRulesDir() + "/" + FALSE_FRIEND_FILE;
     final List<PatternRule> patternRules = loadFalseFriendRules(falseFriendRulesFilename);
     userRules.addAll(patternRules);
+    for (final String fileName : language.getExternalFalseFriendFiles()) {
+      userRules.addAll(loadFalseFriendRules(fileName));
+    }
   }
 
   /**

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/SubjectVerbAgreementRule.java
Patch:
@@ -239,7 +239,7 @@ boolean isFollowedByNominativePlural(AnalyzedTokenReadings[] tokens, int startPo
     for (int i = startPos; i < tokens.length; i++) {
       AnalyzedTokenReadings token = tokens[i];
       if (token.hasPartialPosTag("SUB") || token.hasPartialPosTag("PRO")) {
-        if (token.hasPartialPosTag("NOM") && token.hasPartialPosTag("PLU")) {
+        if (token.hasPartialPosTag("NOM:PLU") || token.getChunkTags().contains(new ChunkTag("NPP"))) {  // NPP catches 'und' phrases
           return true;
         }
       }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SubjectVerbAgreementRuleTest.java
Patch:
@@ -379,7 +379,9 @@ public void testRuleWithCorrectPluralVerb() throws IOException {
         "Kommentare, Korrekturen, Kritik sind verboten.",
         "Letztere sind wichtig, um die Datensicherheit zu garantieren.",
         "Jüngere sind oft davon überzeugt, im Recht zu sein.",
-        "Verwandte sind selten mehr als Bekannte."
+        "Verwandte sind selten mehr als Bekannte.",
+        "Ursache waren die hohe Arbeitslosigkeit und die Wohnungsnot.",
+        "Ursache waren unter anderem die hohe Arbeitslosigkeit und die Wohnungsnot."
     );
     for (String sentence : sentences) {
       assertGood(sentence);

File: languagetool-language-modules/de/src/main/java/org/languagetool/chunking/GermanChunker.java
Patch:
@@ -195,6 +195,8 @@ public static boolean isDebug() {
       build("<chunk=NPS>+ <der> <pos=ADJ> <pos=ADV> <pos=PA2> <NP>", NPS, true),
       // "die Krankheit unserer heutigen Städte und Siedlungen":
       build("<chunk=NPS>+ <pos=PRO:POS> <pos=ADJ> <NP>", NPS, true),
+      // "der letzte der vier großen Flüsse":
+      build("<der|das> <pos=ADJ> <der> <pos=ZAL> <NP>", NPS, true),
       // "Elemente eines axiomatischen Systems":  -- führt zu Fehlalarm anderswo
       //build("<chunk=B-NP & pos=PLU> <chunk=I-NP>* <chunk=B-NP & pos=GEN> <chunk=I-NP>*", NPP),
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/SubjectVerbAgreementRuleTest.java
Patch:
@@ -275,7 +275,8 @@ public void testRuleWithCorrectSingularVerb() throws IOException {
         "Sie hat eine Tochter, die Pianistin ist.",
         "Ja, die Milch ist sehr gut.",
         "Der als Befestigung gedachte östliche Teil der Burg ist weitgehend verfallen.",
-        "Das Kopieren und Einfügen ist sehr nützlich."
+        "Das Kopieren und Einfügen ist sehr nützlich.",
+        "Der letzte der vier großen Flüsse ist die Kolyma."
     );
     for (String sentence : sentences) {
       assertGood(sentence);

File: languagetool-core/src/test/java/org/languagetool/FakeLanguage.java
Patch:
@@ -48,7 +48,7 @@ public FakeLanguage(String langCode, String country) {
   }
 
   @Override
-  synchronized List<PatternRule> getPatternRules() throws IOException {
+  protected synchronized List<PatternRule> getPatternRules() throws IOException {
     return Collections.emptyList();
   }
 

File: languagetool-core/src/test/java/org/languagetool/MultiThreadedJLanguageToolTest.java
Patch:
@@ -82,7 +82,7 @@ private List<String> getRuleMatchIds(JLanguageTool langTool) throws IOException
   public void testTwoRulesOnly() throws IOException {
     MultiThreadedJLanguageTool langTool = new MultiThreadedJLanguageTool(new FakeLanguage() {
       @Override
-      synchronized List<PatternRule> getPatternRules() {
+      protected synchronized List<PatternRule> getPatternRules() {
         return Collections.emptyList();
       }
 

File: languagetool-commandline/src/test/java/org/languagetool/commandline/CommandLineToolsTest.java
Patch:
@@ -57,8 +57,6 @@ public void tearDown() throws Exception {
 
   public void testCheck() throws IOException, ParserConfigurationException, SAXException {
     final JLanguageTool tool = new JLanguageTool(TestTools.getDemoLanguage());
-    tool.activateDefaultPatternRules();
-    tool.activateDefaultFalseFriendRules();
 
     int matches = CommandLineTools.checkText("Foo.", tool);
     String output = new String(this.out.toByteArray());

File: languagetool-core/src/main/java/org/languagetool/Language.java
Patch:
@@ -471,7 +471,7 @@ public String[] getUnpairedRuleEndSymbols() {
    * @since 2.7
    */
   @Experimental
-  synchronized List<PatternRule> getPatternRules() throws IOException {
+  protected synchronized List<PatternRule> getPatternRules() throws IOException {
     if (patternRules == null) {
       patternRules = new ArrayList<>();
       PatternRuleLoader ruleLoader = new PatternRuleLoader();

File: languagetool-core/src/test/java/org/languagetool/language/AbstractLanguageConcurrencyTest.java
Patch:
@@ -91,9 +91,6 @@ public void run() {
       for (int i = 0; i < this.testRuns; i++) {
         try {
           JLanguageTool tool = new JLanguageTool(this.language);
-          tool.activateDefaultPatternRules();
-          tool.activateDefaultFalseFriendRules();
-          
           Assert.assertNotNull(tool.check(this.sampleText));
         } catch (Exception e) {          
           failedTests += 1;

File: languagetool-core/src/test/java/org/languagetool/rules/SentenceWhitespaceRuleTest.java
Patch:
@@ -19,6 +19,7 @@
 package org.languagetool.rules;
 
 import org.junit.Test;
+import org.languagetool.FakeLanguage;
 import org.languagetool.JLanguageTool;
 import org.languagetool.TestTools;
 
@@ -32,7 +33,7 @@ public class SentenceWhitespaceRuleTest {
   @Test
   public void testMatch() throws Exception {
     SentenceWhitespaceRule rule = new SentenceWhitespaceRule(TestTools.getEnglishMessages());
-    JLanguageTool languageTool = new JLanguageTool(TestTools.getDemoLanguage());
+    JLanguageTool languageTool = new JLanguageTool(new FakeLanguage());
     languageTool.addRule(rule);
 
     assertGood("This is a text. And there's the next sentence.", rule, languageTool);

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/DemoPatternRuleTest.java
Patch:
@@ -42,7 +42,6 @@ public void testGrammarRulesFromXML2() throws IOException {
 
   public void testMakeSuggestionUppercase() throws IOException {
     final JLanguageTool langTool = new JLanguageTool(language);
-    langTool.activateDefaultPatternRules();
 
     final Element element = new Element("Were", false, false, false);
     final String message = "Did you mean: <suggestion>where</suggestion> or <suggestion>we</suggestion>?";

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -150,11 +150,9 @@ public void runTestForLanguage(Language lang) throws IOException {
     System.out.print("Running pattern rule tests for " + lang.getName() + "... ");
     final JLanguageTool languageTool = new MultiThreadedJLanguageTool(lang);
     if (CHECK_WITH_SENTENCE_SPLITTING) {
-      languageTool.activateDefaultPatternRules();
       disableSpellingRules(languageTool);
     }
     final JLanguageTool allRulesLanguageTool = new MultiThreadedJLanguageTool(lang);
-    allRulesLanguageTool.activateDefaultPatternRules();
     validateRuleIds(lang, allRulesLanguageTool);
     final List<PatternRule> rules = new ArrayList<>();
     for (String patternRuleFileName : lang.getRuleFileNames()) {

File: languagetool-dev/src/main/java/org/languagetool/dev/ExampleSentenceCorrectionCreator.java
Patch:
@@ -54,7 +54,6 @@ private void run(Language lang) throws IOException {
     File xml = new File(basePath, "/" + langCode + "/src/main/resources/org/languagetool/rules/" + langCode + "/grammar.xml");
     List<String> xmlLines = IOUtils.readLines(new FileReader(xml));
     JLanguageTool tool = new JLanguageTool(lang);
-    tool.activateDefaultPatternRules();
     for (Rule rule : tool.getAllRules()) {
       if (!(rule instanceof PatternRule)) {
         continue;

File: languagetool-dev/src/main/java/org/languagetool/dev/SentenceChecker.java
Patch:
@@ -37,7 +37,6 @@ class SentenceChecker {
 
   private void run(Language language, File file) throws IOException {
     JLanguageTool lt = new JLanguageTool(language);
-    lt.activateDefaultPatternRules();
     Scanner scanner = new Scanner(file);
     int count = 0;
     long startTime = System.currentTimeMillis();

File: languagetool-dev/src/main/java/org/languagetool/dev/UselessExampleFinder.java
Patch:
@@ -56,7 +56,6 @@ private void run(Language lang) throws IOException {
     File xml = new File(basePath, "/" + langCode + "/src/main/resources/org/languagetool/rules/" + langCode + "/grammar.xml");
     List<String> xmlLines = IOUtils.readLines(new FileReader(xml));
     JLanguageTool tool = new JLanguageTool(lang);
-    tool.activateDefaultPatternRules();
     for (Rule rule : tool.getAllActiveRules()) {
       List<String> correctExamples = rule.getCorrectExamples();
       List<IncorrectExample> incorrectExamples = rule.getIncorrectExamples();

File: languagetool-dev/src/main/java/org/languagetool/dev/conversion/RuleCoverage.java
Patch:
@@ -67,7 +67,6 @@ public class RuleCoverage {
     public RuleCoverage() throws IOException {
       language = new English();
       tool = new JLanguageTool(language);
-        tool.activateDefaultPatternRules();
         tool.disableRule("UPPERCASE_SENTENCE_START");
         tool.disableRule("EN_UNPAIRED_BRACKETS");
         tool.disableRule("EN_A_VS_AN");
@@ -80,15 +79,13 @@ public RuleCoverage() throws IOException {
     public RuleCoverage(Language language) throws IOException {
       this.language = language;
       tool = new JLanguageTool(language);
-        tool.activateDefaultPatternRules();
         setupDictionaryFiles();
     }
     
     // for testing purposes, defaults to English
     public RuleCoverage(String dictFileName) throws IOException {
       language = new English();
       tool = new JLanguageTool(language);
-        tool.activateDefaultPatternRules();
         tool.disableRule("UPPERCASE_SENTENCE_START");
         tool.disableRule("EN_UNPAIRED_BRACKETS");
         tool.disableRule("EN_A_VS_AN");

File: languagetool-dev/src/main/java/org/languagetool/dev/eval/AfterTheDeadlineEvaluator.java
Patch:
@@ -95,7 +95,6 @@ private void run(Language lang) throws IOException, InterruptedException {
 
   private List<Rule> getRules(Language lang) throws IOException {
     JLanguageTool langTool = new JLanguageTool(lang);
-    langTool.activateDefaultPatternRules();
     return langTool.getAllActiveRules();
   }
 

File: languagetool-dev/src/main/java/org/languagetool/dev/eval/CheckBNC.java
Patch:
@@ -53,7 +53,6 @@ public static void main(String[] args) throws Exception {
   
   private CheckBNC() throws IOException {
     langTool = new JLanguageTool(new English());
-    langTool.activateDefaultPatternRules();
     final String[] disRules = {"UPPERCASE_SENTENCE_START", "COMMA_PARENTHESIS_WHITESPACE",
         "WORD_REPEAT_RULE", "DOUBLE_PUNCTUATION"};
     System.err.println("Note: disabling the following rules:");

File: languagetool-dev/src/main/java/org/languagetool/dev/eval/LanguageToolEvaluator.java
Patch:
@@ -42,7 +42,6 @@ class LanguageToolEvaluator implements Evaluator {
 
   LanguageToolEvaluator(File indexTopDir) throws IOException {
     langTool = new JLanguageTool(new BritishEnglish());
-    langTool.activateDefaultPatternRules();
     disableRules();
     if (indexTopDir != null) {
       if (indexTopDir.isDirectory()) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -32,7 +32,6 @@ public void testGerman() throws IOException {
     final JLanguageTool tool = new JLanguageTool(new German());
     assertEquals(0, tool.check("Ein Test, der keine Fehler geben sollte.").size());
     assertEquals(1, tool.check("Ein Test Test, der Fehler geben sollte.").size());
-    tool.activateDefaultPatternRules();
     tool.setListUnknownWords(true);
     // no spelling mistakes as we have not created a variant:
     assertEquals(0, tool.check("I can give you more a detailed description").size());
@@ -44,7 +43,6 @@ public void testGermanyGerman() throws IOException {
     final JLanguageTool tool = new JLanguageTool(new GermanyGerman());
     assertEquals(0, tool.check("Ein Test, der keine Fehler geben sollte.").size());
     assertEquals(1, tool.check("Ein Test Test, der Fehler geben sollte.").size());
-    tool.activateDefaultPatternRules();
     tool.setListUnknownWords(true);
     // German rule has no effect with English error, but they are spelling mistakes:
     assertEquals(6, tool.check("I can give you more a detailed description").size());
@@ -54,7 +52,6 @@ public void testGermanyGerman() throws IOException {
 
   public void testPositionsWithGerman() throws IOException {
     final JLanguageTool tool = new JLanguageTool(new German());
-    tool.activateDefaultPatternRules();
     final List<RuleMatch> matches = tool.check("Stundenkilometer");
     assertEquals(1, matches.size());
     final RuleMatch match = matches.get(0);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -221,11 +221,10 @@ public void testDetNounRuleErrorMessages() throws IOException {
   }
   
   public void testRegression() throws IOException {
-      JLanguageTool gramCheckerEngine = new JLanguageTool(new German());
-      gramCheckerEngine.activateDefaultPatternRules();
+      JLanguageTool lt = new JLanguageTool(new German());
       // used to be not detected > 1.0.1:
       String str = "Und so.\r\nDie Bier.";
-      List<RuleMatch> matches = gramCheckerEngine.check(str);
+      List<RuleMatch> matches = lt.check(str);
       assertEquals(1, matches.size());
   }
   

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/EnglishPatternRuleTest.java
Patch:
@@ -33,7 +33,6 @@ public void testRules() throws IOException {
   // used to cause an ArrayIndexOutOfBoundsException in MatchState.setToken()
   public void testBug() throws Exception {
     JLanguageTool langTool = new JLanguageTool(new English());
-    langTool.activateDefaultPatternRules();
     langTool.check("Alexander between 369 and 358 BC\n\nAlexander");
   }
 

File: languagetool-language-modules/en/src/test/java/org/languagetool/tools/ToolsTest.java
Patch:
@@ -30,8 +30,6 @@ public class ToolsTest extends TestCase {
 
   public void testCorrect() throws IOException, ParserConfigurationException, SAXException {
     final JLanguageTool tool = new JLanguageTool(new English());
-    tool.activateDefaultPatternRules();
-    tool.activateDefaultFalseFriendRules();
     assertEquals("This is a test.", Tools.correctText("This is an test.", tool));
   }
   

File: languagetool-language-modules/ja/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -27,7 +27,6 @@ public class JLanguageToolTest extends TestCase {
 
   public void testJapanese() throws IOException {
     final JLanguageTool tool = new JLanguageTool(new Japanese());
-    tool.activateDefaultPatternRules();
     assertEquals(0, tool.check("エラーを含まないテスト文です。").size());
     assertEquals(1, tool.check("エラーお含むテスト文です。").size());
   }

File: languagetool-language-modules/nl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -27,7 +27,6 @@ public class JLanguageToolTest extends TestCase {
 
   public void testDutch() throws IOException {
     final JLanguageTool tool = new JLanguageTool(new Dutch());
-    tool.activateDefaultPatternRules();
     assertEquals(0, tool.check("Een test, die geen fouten mag geven.").size());
     assertEquals(1, tool.check("Dit is fout.!").size());
     //test uppercasing rule:

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/ConfigThread.java
Patch:
@@ -50,8 +50,6 @@ class ConfigThread extends Thread {
   public void run() {
     try {
       final JLanguageTool langTool = new JLanguageTool(docLanguage, config.getMotherTongue());
-      langTool.activateDefaultPatternRules();
-      langTool.activateDefaultFalseFriendRules();
       cfgDialog.show(langTool.getAllRules());
       config.saveConfiguration(docLanguage);
       if (mainThread != null) {

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -374,8 +374,6 @@ private void initLanguageTool() {
     try {
       prepareConfig(docLanguage);
       langTool = new MultiThreadedJLanguageTool(docLanguage, config.getMotherTongue());
-      langTool.activateDefaultPatternRules();
-      langTool.activateDefaultFalseFriendRules();
       for (Rule rule : langTool.getAllActiveRules()) {
         if (rule.isDictionaryBasedSpellingRule()) {
           langTool.disableRule(rule.getId());

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -475,8 +475,6 @@ private static void print(String s, PrintStream outputStream) {
    */
   private JLanguageTool getLanguageToolInstance(Language lang, Language motherTongue, QueryParams params) throws Exception {
     final JLanguageTool newLanguageTool = new JLanguageTool(lang, motherTongue);
-    newLanguageTool.activateDefaultPatternRules();
-    newLanguageTool.activateDefaultFalseFriendRules();
     if (languageModelDir != null) {
       newLanguageTool.activateLanguageModelRules(languageModelDir);
     }

File: languagetool-server/src/test/java/org/languagetool/server/ExampleSentenceProvider.java
Patch:
@@ -55,7 +55,6 @@ class ExampleSentenceProvider {
 
   private void initExampleSentences(Language language) throws IOException {
     final JLanguageTool lt = new JLanguageTool(language);
-    lt.activateDefaultPatternRules();
     final List<Rule> rules = lt.getAllActiveRules();
     final List<ExampleSentence> sentences = new ArrayList<>();
     for (Rule rule : rules) {

File: languagetool-standalone/src/main/java/org/languagetool/dev/SuggestionExtractorTool.java
Patch:
@@ -79,7 +79,6 @@ private Map<Language, Set<String>> getLanguageToIgnoreTokensMapping() throws IOE
         System.out.println("No spellchecker rule found for " + lang);
         continue;
       }
-      languageTool.activateDefaultPatternRules();
       final List<Rule> rules = languageTool.getAllRules();
       int tokenCount = 0;
       int noErrorCount = 0;

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageToolSupport.java
Patch:
@@ -285,8 +285,6 @@ private void reloadLanguageTool(Language language) {
       //config still contains old language, update it
       this.config.setLanguage(language);
       languageTool = new MultiThreadedJLanguageTool(language, config.getMotherTongue());
-      languageTool.activateDefaultPatternRules();
-      languageTool.activateDefaultFalseFriendRules();
       loadConfig();
     } catch (Exception e) {
       throw new RuntimeException(e);

File: languagetool-standalone/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -46,7 +46,6 @@ public class JLanguageToolTest {
   @Test
   public void testGetAllActiveRules() throws Exception {
     JLanguageTool langTool = new JLanguageTool(new Demo());
-    langTool.activateDefaultPatternRules();
     List<String> ruleIds = getActiveRuleIds(langTool);
     assertTrue(ruleIds.contains("DEMO_RULE"));
     assertFalse(ruleIds.contains("DEMO_RULE_OFF"));

File: languagetool-standalone/src/test/java/org/languagetool/dev/MultiThreadingTest1.java
Patch:
@@ -102,7 +102,6 @@ public void test() throws Exception {
   private void initExpectedResults(List<Language> languages) throws IOException {
     for (Language lang : languages) {
       JLanguageTool lt = new JLanguageTool(lang);
-      lt.activateDefaultPatternRules();
       String input = examples.get(lang.getShortNameWithCountryAndVariant());
       if (input != null) {
         List<RuleMatch> matches = lt.check(input);
@@ -137,7 +136,6 @@ public void run() {
       if (input != null) {
         try {
           JLanguageTool lt = new JLanguageTool(lang);
-          lt.activateDefaultPatternRules();
           //System.out.println("Running with " + lang.getShortNameWithCountryAndVariant());
           List<RuleMatch> matches = lt.check(input);
           //System.out.println("=>" + matches);

File: languagetool-standalone/src/test/java/org/languagetool/dev/MultiThreadingTest2.java
Patch:
@@ -74,7 +74,6 @@ public void test() throws Exception {
 
   private void initExpectedResults() throws IOException {
     JLanguageTool lt = new JLanguageTool(LANG);
-    lt.activateDefaultPatternRules();
     for (String sentence : sentences) {
       List<RuleMatch> matches = lt.check(sentence);
       expectedResults.put(sentence, matches.toString());
@@ -95,7 +94,6 @@ class Handler implements Runnable {
     public void run() {
       try {
         JLanguageTool lt = new JLanguageTool(lang);
-        lt.activateDefaultPatternRules();
         List<RuleMatch> matches = lt.check(sentence);
         //System.out.println("=>" + matches);
         String expected = expectedResults.get(sentence);

File: languagetool-standalone/src/test/java/org/languagetool/rules/RuleTest.java
Patch:
@@ -45,9 +45,7 @@ public void testJavaRules() throws IOException {
       final JLanguageTool lt = new JLanguageTool(language);
       final List<Rule> allRules = lt.getAllRules();
       for (Rule rule : allRules) {
-        if (rule instanceof PatternRule) {
-          throw new RuntimeException("Did not expect PatternRule here: " + rule);
-        } else {
+        if (!(rule instanceof PatternRule)) {
           assertIdUniqueness(ids, ruleClasses, language, rule);
           assertIdValidity(language, rule);
           assertTrue(rule.supportsLanguage(language));

File: languagetool-standalone/src/test/java/org/languagetool/rules/patterns/PerformanceTest.java
Patch:
@@ -38,7 +38,6 @@ private PerformanceTest() {
   private void run(JLanguageTool langTool, File textFile) throws IOException {
     String text = StringTools.readStream(new FileInputStream(textFile), "utf-8");
     int sentenceCount = langTool.sentenceTokenize(text).size();
-    langTool.activateDefaultPatternRules();
     //langTool.activateLanguageModelRules(new File("/data/google-ngram-index/"));
     System.out.println("Language: " +  langTool.getLanguage() +
                        ", Text length: " + text.length() + " chars, " + sentenceCount + " sentences");

File: languagetool-standalone/src/test/java/org/languagetool/rules/patterns/PerformanceTest2.java
Patch:
@@ -55,7 +55,6 @@ private void run(String languageCode, File textFile) throws IOException {
       String subText = text.substring(beginIndex, endIndex);
       long startTime = System.currentTimeMillis();
       JLanguageTool langTool = new MultiThreadedJLanguageTool(language);
-      langTool.activateDefaultPatternRules();
       List<RuleMatch> matches = langTool.check(subText);
       long runTime = System.currentTimeMillis() - startTime;
       if (i >= SKIP) {

File: languagetool-standalone/src/test/java/org/languagetool/rules/patterns/RuleNumberScalabilityTest.java
Patch:
@@ -38,7 +38,6 @@ public static void main(String[] args) throws IOException {
     }
     JLanguageTool langTool = new JLanguageTool(Languages.getLanguageForShortName(args[0]));
     String text = StringTools.readStream(new FileInputStream(args[1]), "utf-8");
-    langTool.activateDefaultPatternRules();
     System.out.println("Warmup...");
     langTool.check(text);
     langTool.check(text);

File: languagetool-standalone/src/test/java/org/languagetool/tools/ToolsTest.java
Patch:
@@ -61,8 +61,7 @@ public void testBitextCheck() throws IOException, ParserConfigurationException,
     final JLanguageTool srcTool = new JLanguageTool(english);
     final Polish polish = new Polish();
     final JLanguageTool trgTool = new JLanguageTool(polish);
-    trgTool.activateDefaultPatternRules();
-    
+
     final List<BitextRule> rules = Tools.getBitextRules(english, polish);
     
     int matches1 = Tools.checkBitext(

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/dumpcheck/SentenceSourceChecker.java
Patch:
@@ -139,7 +139,6 @@ private void run(File propFile, Set<String> disabledRules, String langCode, List
                    String[] additionalCategoryIds, int maxSentences, int maxErrors, File languageModelDir) throws IOException {
     final Language lang = Languages.getLanguageForShortName(langCode);
     final JLanguageTool languageTool = new MultiThreadedJLanguageTool(lang);
-    languageTool.activateDefaultPatternRules();
     if (languageModelDir != null) {
       languageTool.activateLanguageModelRules(languageModelDir);
     }

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/index/Searcher.java
Patch:
@@ -224,7 +224,6 @@ public void run() {
   List<PatternRule> getRuleById(String ruleId, Language language) throws IOException {
     List<PatternRule> rules = new ArrayList<>();
     JLanguageTool langTool = new JLanguageTool(language);
-    langTool.activateDefaultPatternRules();
     for (Rule rule : langTool.getAllRules()) {
       if (rule.getId().equals(ruleId) && rule instanceof PatternRule) {
         rules.add((PatternRule) rule);
@@ -265,7 +264,9 @@ private List<MatchingSentence> findMatchingSentences(IndexSearcher indexSearcher
   private JLanguageTool getLanguageToolWithOneRule(Language lang, PatternRule patternRule) {
     final JLanguageTool langTool = new JLanguageTool(lang);
     for (Rule rule : langTool.getAllActiveRules()) {
-      langTool.disableRule(rule.getId());
+      if (!rule.getId().equals(patternRule.getId())) {
+        langTool.disableRule(rule.getId());
+      }
     }
     langTool.addRule(patternRule);
     langTool.enableDefaultOffRule(patternRule.getId()); // rule might be off by default

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/WikipediaQuickCheck.java
Patch:
@@ -193,7 +193,6 @@ private MediaWikiContent getRevisionContent(String completeWikiContent) {
 
   private JLanguageTool getLanguageTool(Language lang) throws IOException {
     final JLanguageTool langTool = new MultiThreadedJLanguageTool(lang);
-    langTool.activateDefaultPatternRules();
     enableWikipediaRules(langTool);
     for (String disabledRuleId : disabledRuleIds) {
       langTool.disableRule(disabledRuleId);

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/atom/AtomFeedChecker.java
Patch:
@@ -61,7 +61,6 @@ class AtomFeedChecker {
   AtomFeedChecker(Language language, DatabaseConfig dbConfig) throws IOException {
     this.language = Objects.requireNonNull(language);
     langTool = new JLanguageTool(language);
-    langTool.activateDefaultPatternRules();
     // disable because they create too many false alarms:
     langTool.disableRule("UNPAIRED_BRACKETS");
     langTool.disableRule("EN_UNPAIRED_BRACKETS");

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/index/IndexerSearcherTest.java
Patch:
@@ -79,7 +79,6 @@ public void testAllRules() throws Exception {
     //final Language language = new Polish();
     //final Language language = new German();
     final JLanguageTool lt = new JLanguageTool(language);
-    lt.activateDefaultPatternRules();
 
     System.out.println("Creating index for " + language + "...");
     final int ruleCount = createIndex(lt);

File: languagetool-standalone/src/main/java/org/languagetool/gui/FontChooser.java
Patch:
@@ -197,7 +197,7 @@ public void windowClosing(WindowEvent e) {
     c.weightx = 1.0;
     c.weighty = 1;
     c.fill = GridBagConstraints.BOTH;
-    fontNameList = new JList(fontNamesArray);
+    fontNameList = new JList<>(fontNamesArray);
     fontNameList.addListSelectionListener(this);
     fontNameList.setVisibleRowCount(5);
     fontNameList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
@@ -209,7 +209,7 @@ public void windowClosing(WindowEvent e) {
     c.gridx = 1;
     c.gridy = 2;
     c.weightx = 0.5;
-    fontStyleList = new JList(fontStylesArray);
+    fontStyleList = new JList<>(fontStylesArray);
     fontStyleList.addListSelectionListener(this);
     fontStyleList.setVisibleRowCount(5);
     fontStyleList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
@@ -220,7 +220,7 @@ public void windowClosing(WindowEvent e) {
 
     c.gridx = 2;
     c.gridy = 2;
-    fontSizeList = new JList(fontSizesArray);
+    fontSizeList = new JList<>(fontSizesArray);
     fontSizeList.addListSelectionListener(this);
     fontSizeList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
     fontSizeList.setVisibleRowCount(5);

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -50,6 +50,7 @@ public void testRule() throws IOException {
     //assertCorrect("Una equivocació tan gran no es pot callar.");
     //assertCorrect(" és del tot necessari si no es vol caure en una religió alienant");
 
+    assertCorrect("de què tant ens queixem");
     assertCorrect("cada zona més meridional esdevingué adient per als éssers àrtics");
     assertCorrect("cereals, garrofers, vinya i olivar.");
     assertCorrect("m'aniria bé probablement posar els quilos");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/CatalanWrongWordInContextRuleTest.java
Patch:
@@ -41,6 +41,9 @@ public void testRule() throws IOException {
     assertEquals("rendibles", rule.match(langTool.getAnalyzedSentence("Uns projectes molt rentables."))[0].getSuggestedReplacements().get(0));
     //assertEquals("rentable", rule.match(langTool.getAnalyzedSentence("Un teixit rendible."))[0].getSuggestedReplacements().get(0));
     
+    assertEquals(1, rule.match(langTool.getAnalyzedSentence("La policia feia d'escolta.")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("La policia feia escoltes telefòniques.")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("La policia feia escoltes il·legals.")).length);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Van escoltar el detingut fins al calabós.")).length);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Li va infringir un mal terrible.")).length);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("És un terreny abonat per als problemes.")).length);

File: languagetool-core/src/main/java/org/languagetool/rules/AdvancedWordRepeatRule.java
Patch:
@@ -82,7 +82,6 @@ public final RuleMatch[] match(final AnalyzedSentence sentence) {
             isWord = false;
             break;
           }
-          // FIXME: too many false alarms here:
           final String lemma = analyzedToken.getLemma();
           if (lemma == null) {
             hasLemma = false;

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/UnifierConfiguration.java
Patch:
@@ -42,7 +42,7 @@ public class UnifierConfiguration {
   private final Map<String, List<String>> equivalenceFeatures;
 
   public UnifierConfiguration() {
-    // FIXME: workaround for issue #13
+    // workaround for issue #13
     equivalenceTypes = new ConcurrentHashMap<>();
     equivalenceFeatures = new ConcurrentHashMap<>();
   }
@@ -58,7 +58,7 @@ public UnifierConfiguration() {
    */
   public final void setEquivalence(final String feature, final String type,
                                    final Element elem) {
-    
+
     EquivalenceTypeLocator typeKey = new EquivalenceTypeLocator(feature, type);
     if (equivalenceTypes.containsKey(typeKey)) {
       return;
@@ -69,7 +69,7 @@ public final void setEquivalence(final String feature, final String type,
     if (equivalenceFeatures.containsKey(feature)) {
       lTypes = equivalenceFeatures.get(feature);
     } else {
-      // FIXME: workaround for issue #13
+      // workaround for issue #13
       lTypes = new CopyOnWriteArrayList<>();
       equivalenceFeatures.put(feature, lTypes);
     }

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -202,6 +202,7 @@ protected boolean isUrl(String token) {
   
   protected void init() throws IOException {
     loadWordsToBeIgnored(getIgnoreFileName());
+    loadWordsToBeIgnored(getSpellingFileName());
     loadWordsToBeProhibited(getProhibitFileName());
   }
 

File: languagetool-commandline/src/test/java/org/languagetool/commandline/MainTest.java
Patch:
@@ -281,8 +281,8 @@ public void testEnglishFileAPI() throws Exception {
     final String output = new String(this.out.toByteArray());
     assertTrue(output.indexOf("<?xml version=\"1.0\" encoding=\"UTF-8\"?>") == 0);
     assertTrue(output.contains("<error fromy=\"0\" fromx=\"8\" toy=\"0\" tox=\"10\" ruleId=\"EN_A_VS_AN\" " +
-        "msg=\"Use 'a' instead of 'an' if the following word doesn't start with a vowel sound, e.g. 'a sentence', " +
-        "'a university'\" replacements=\"a\" context=\"This is an test.  This is a test of of language tool.  ...\" " +
+        "msg=\"Use &apos;a&apos; instead of &apos;an&apos; if the following word doesn&apos;t start with a vowel sound, e.g. &apos;a sentence&apos;, " +
+        "&apos;a university&apos;\" replacements=\"a\" context=\"This is an test.  This is a test of of language tool.  ...\" " +
         "contextoffset=\"8\" offset=\"8\" errorlength=\"2\" category=\"Miscellaneous\" locqualityissuetype=\"misspelling\"/>"));
   }
 
@@ -315,7 +315,7 @@ public void testPolishFileAPI() throws Exception {
     assertTrue(output.indexOf("<?xml version=\"1.0\" encoding=\"UTF-8\"?>") == 0);
     assertTrue(output.contains("<error fromy=\"0\" fromx=\"8\" toy=\"0\" tox=\"20\" ruleId=\"BRAK_PRZECINKA_KTORY\""));
     //This tests whether XML encoding is actually UTF-8:
-    assertTrue(output.contains("msg=\"Brak przecinka w tym fragmencie zdania. Przecinek prawdopodobnie należy postawić tak: 'świnia, która'.\" replacements=\"świnia, która\" "));
+    assertTrue(output.contains("msg=\"Brak przecinka w tym fragmencie zdania. Przecinek prawdopodobnie należy postawić tak: &apos;świnia, która&apos;.\" replacements=\"świnia, która\" "));
     assertTrue(output.contains("context=\"To jest świnia która się ślini."));
     assertTrue(output.contains("contextoffset=\"8\" offset=\"8\" errorlength=\"12\" category=\"Błędy interpunkcyjne\""));
   }

File: languagetool-core/src/main/java/org/languagetool/tools/RuleAsXmlSerializer.java
Patch:
@@ -106,7 +106,7 @@ public String ruleMatchesToXmlSnippet(List<RuleMatch> ruleMatches, String text,
       int contextOffset = context.indexOf(startMarker);
       context = context.replaceFirst(startMarker, "");
       context = context.replaceAll("[\n\r]", " ");
-      xml.append(" context=\"").append(StringTools.escapeXML(context)).append('"')
+      xml.append(" context=\"").append(StringTools.escapeForXmlAttribute(context)).append('"')
               .append(" contextoffset=\"").append(contextOffset).append('"')
               .append(" offset=\"").append(match.getFromPos()).append('"')
               .append(" errorlength=\"").append(match.getToPos() - match.getFromPos()).append('"');
@@ -148,7 +148,7 @@ public String ruleMatchesToXml(List<RuleMatch> ruleMatches, String text, int con
 
   private static String escapeXMLForAPIOutput(String s) {
     // this is simplified XML, i.e. put the "<error>" in one line:
-    return StringTools.escapeXML(s).replaceAll("[\n\r]", " ");
+    return StringTools.escapeForXmlAttribute(s).replaceAll("[\n\r]", " ");
   }
 
 }

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -38,7 +38,7 @@
 import com.sun.net.httpserver.HttpExchange;
 import com.sun.net.httpserver.HttpHandler;
 
-import static org.apache.commons.lang.StringEscapeUtils.escapeXml;
+import static org.languagetool.tools.StringTools.escapeForXmlContent;
 
 class LanguageToolHttpHandler implements HttpHandler {
 
@@ -147,7 +147,7 @@ public void handle(HttpExchange httpExchange) throws IOException {
       // so we consume the request now, even before checking for request limits:
       final Map<String, String> parameters = getRequestQuery(httpExchange, requestedUri);
       if (requestLimiter != null && !requestLimiter.isAccessOkay(remoteAddress)) {
-        final String errorMessage = "Error: Access from " + StringTools.escapeXML(remoteAddress) +
+        final String errorMessage = "Error: Access from " + remoteAddress +
                 " denied - too many requests. Allowed maximum requests: " + requestLimiter.getRequestLimit() +
                 " requests per " + requestLimiter.getRequestLimitPeriodInSeconds() + " seconds";
         sendError(httpExchange, HttpURLConnection.HTTP_FORBIDDEN, errorMessage);
@@ -258,7 +258,7 @@ private String getLastIpIgnoringOwn(List<String> forwardedIps) {
 
   private void sendError(HttpExchange httpExchange, int returnCode, String response) throws IOException {
     if (afterTheDeadlineMode) {
-      String xmlResponse = "<results><message>" + escapeXml(response) + "</message></results>";
+      String xmlResponse = "<results><message>" + escapeForXmlContent(response) + "</message></results>";
       httpExchange.sendResponseHeaders(returnCode, xmlResponse.getBytes(ENCODING).length);
       httpExchange.getResponseBody().write(xmlResponse.getBytes(ENCODING));
     } else {

File: languagetool-language-modules/pl/src/main/java/org/languagetool/rules/pl/MorfologikPolishSpellerRule.java
Patch:
@@ -150,9 +150,10 @@ private boolean isNotCompound(String word) throws IOException {
       final String first = word.substring(0, i);
       final String second = word.substring(i, word.length());
       if (prefixes.contains(first.toLowerCase(conversionLocale))
-              && !isMisspelled(speller1, second)) {
+              && !isMisspelled(speller1, second)
+              && second.length() > first.length()) { // but not for short words such as "premoc"
         // ignore this match, it's fine
-        probablyCorrectWords.add(word);
+        probablyCorrectWords.add(word); // FIXME: some strange words are being accepted, like prekupa
       } else {
         testedTokens.clear();
         testedTokens.add(first);

File: languagetool-core/src/test/java/org/languagetool/tagging/disambiguation/rules/DisambiguationRuleTest.java
Patch:
@@ -140,7 +140,7 @@ private void testDisambiguationRulesFromXML(
           final String inputForms = example.getAmbiguous();
           assertTrue("No input form found for: " + id, inputForms != null);
           assertTrue(inputForms.trim().length() > 0);
-          assertTrue("Input and output forms for rule " + id + "are the same!",
+          assertTrue("Input and output forms for rule " + id + " are the same!",
               !outputForms.equals(inputForms));
           final AnalyzedSentence cleanInput = languageTool
               .getRawAnalyzedSentence(cleanXML(example.getExample()));

File: languagetool-core/src/main/java/org/languagetool/rules/DoublePunctuationRule.java
Patch:
@@ -59,7 +59,7 @@ public final RuleMatch[] match(final AnalyzedSentence sentence) {
     int startPos = 0;
     int dotCount = 0;
     int commaCount = 0;
-    for (int i = 0; i < tokens.length; i++) {
+    for (int i = 1; i < tokens.length; i++) {
       final String token = tokens[i].getToken();
       String nextToken = null;
       String prevToken = null;

File: languagetool-language-modules/uk/src/main/java/org/languagetool/tagging/uk/IPOSTag.java
Patch:
@@ -56,6 +56,9 @@ public static boolean contains(String posTag, String postagMatch) {
     return posTag != null && posTag.contains(postagMatch);
   }
 
+  /**
+   * @since 2.9
+   */
   public static boolean startsWith(String posTagPrefix, IPOSTag... posTags) {
     if( posTagPrefix == null )
       return false;

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -80,6 +80,7 @@ public class CaseRule extends GermanRule {
    * workaround to avoid false alarms, these words can be added here.
    */
   private static final Set<String> exceptions = new HashSet<>(Arrays.asList(
+    "Äußeres",
     "Abseits",
     "Beschäftigter",
     "Beschäftigte",

File: languagetool-language-modules/ca/src/test/java/org/languagetool/tokenizers/ca/CatalanSentenceTokenizerTest.java
Patch:
@@ -71,6 +71,7 @@ public final void testTokenize() {
     testSplit("de Sant Nicolau (del s. XII; cor gòtic del s. XIV) i de Sant ");
     testSplit("Va ser el 5è. classificat.");
     testSplit("Va ser el 5è. ", "I l'altre el 4t.");
+    testSplit("Art. 2.1: Són obligats els...");
 
     // Exception to abbreviations
     testSplit("Ell és el número u. ", "Jo el dos.");

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -272,8 +272,7 @@ private void testBadSentences(JLanguageTool languageTool, JLanguageTool allRules
                                 Map<String, PatternRule> complexRules, PatternRule rule) throws IOException {
     final List<IncorrectExample> badSentences = rule.getIncorrectExamples();
     if (badSentences.size() == 0) {
-      // TODO: comment in
-      //fail("No incorrect examples found for rule " + rule);
+      fail("No incorrect examples found for rule " + rule);
     }
     // necessary for XML Pattern rules containing <or>
     List<PatternRule> rules = allRulesLanguageTool.getPatternRulesByIdAndSubId(rule.getId(), rule.getSubId());

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleXmlCreatorTest.java
Patch:
@@ -37,7 +37,7 @@ public void testToXML() throws IOException {
             "  </pattern>\n" +
             "  <message>Did you mean <suggestion><match no=\"1\"/> fuu bah</suggestion>?</message>\n" +
             "  <url>http://fake-server.org/foo-bar-error-explained</url>\n" +
-            "  <example type=\"correct\">This is <marker>fuu bah</marker>.</example>\n" +
+            "  <example>This is <marker>fuu bah</marker>.</example>\n" +
             "  <example correction=\"foo fuu bah\">This is <marker>foo bar</marker>.</example>\n" +
             "</rule>", xml);
   }

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -415,7 +415,7 @@ public void endElement(final String namespaceURI, final String sName,
           final IncorrectExample example;
           final List<String> corrections = new ArrayList<>();
           corrections.addAll(Arrays.asList(exampleCorrection.toString().split("\\|")));
-          if (corrections.size() > 0 && corrections.get(0).length() > 0) {
+          if (corrections.size() > 0) {
             if (exampleCorrection.toString().endsWith("|")) {  // split() will ignore trailing empty items
               corrections.add("");
             }

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -181,7 +181,7 @@ public void runTestForLanguage(Language lang) throws IOException {
         }
         if (!correctionExists) {
           fail("Rule " + rule.getId() + "[" + rule.getSubId() + "]" + " in language " + lang
-                  + " needs at least one <example> of type='incorrect' and with a 'correction' attribute"
+                  + " needs at least one <example> with a 'correction' attribute"
                   + " or one <example> of type='correct'.");
         }
       }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -59,6 +59,7 @@ public class CaseRule extends GermanRule {
     nounIndicators.add("mein");
     nounIndicators.add("dein");
     nounIndicators.add("euer");
+    nounIndicators.add("unser");
     //indicator.add("ihres");
     //indicator.add("ihren");
   }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -73,6 +73,7 @@ public void testRule() throws IOException {
     assertGood("Ihr sollt mich das wissen lassen.");
     assertGood("Wenn er mich das rechtzeitig wissen lässt, gerne.");
     assertBad("Tom ist etwas über Dreißig.");
+    assertBad("Unser warten wird sich lohnen.");
     // "NIL" reading in Morphy that used to confuse CaseRule:
     assertGood("Ein Menschenfreund.");
     // works only thanks to addex.txt:

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -70,6 +70,8 @@ public void testRule() throws IOException {
     assertGood("Er wird etwas so Verrücktes träumen.");
     assertGood("Tom ist etwas über dreißig.");
     assertGood("Diese Angriffe bleiben im Verborgenen.");
+    assertGood("Ihr sollt mich das wissen lassen.");
+    assertGood("Wenn er mich das rechtzeitig wissen lässt, gerne.");
     assertBad("Tom ist etwas über Dreißig.");
     // "NIL" reading in Morphy that used to confuse CaseRule:
     assertGood("Ein Menschenfreund.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -83,6 +83,7 @@ public class CaseRule extends GermanRule {
      * solution is to add all those to our Morphy data, but as a simple
      * workaround to avoid false alarms, these words can be added here.
      */
+    exceptions.add("Abseits");
     exceptions.add("Beschäftigter");
     exceptions.add("Beschäftigte");
     exceptions.add("Beschäftigten");

File: languagetool-core/src/main/java/org/languagetool/language/LanguageIdentifier.java
Patch:
@@ -117,6 +117,8 @@ public Language detectLanguage(String text) {
   private String detectLanguageCode(String text) {
     TextObject textObject = textObjectFactory.forText(text);
     Optional<String> lang = languageDetector.detect(textObject);
+    // comment in for debugging:
+    //System.out.println(languageDetector.getProbabilities(textObject));
     if (lang.isPresent()) {
       if ("zh-cn".equals(lang.get()) || "zh-tw".equals(lang.get())) {
         return "zh";

File: languagetool-standalone/src/test/java/org/languagetool/language/LanguageIdentifierTest.java
Patch:
@@ -38,7 +38,8 @@ public void testDetection() {
     langAssert("en", "This is an English text");
     langAssert("fr", "Le mont Revard est un sommet du département français ...");
     // some test sentences from the "Linux" article of Wikipedia:
-    langAssert("be", "Першапачаткова Linux распрацоўваўся і выкарыстоўваўся асобнымі аматарамі на сваіх персанальных камп'ютарах.");
+    // TODO: results not stable - comment in once https://github.com/optimaize/language-detector/issues/14 is resolved
+    /*langAssert("be", "Першапачаткова Linux распрацоўваўся і выкарыстоўваўся асобнымі аматарамі на сваіх персанальных камп'ютарах.");
     langAssert("ca", "Aquest sistema operatiu va créixer gràcies al treball col·laboratiu de programadors de tot el món ...");
     langAssert("zh", "Linux最初是作为支持英特尔x86架构的个人电脑的一个自由操作系统。目前Linux已经被移植到更多的计算机硬件平台");
     langAssert("da", "Linux-distributionerne har traditionelt deres største udbredelse på servere, men er hastigt på vej på almindelige pc'er.");
@@ -62,6 +63,7 @@ public void testDetection() {
     langAssert("tl", "Ang Linux ay isang operating system kernel para sa mga operating system na humahalintulad sa Unix.");
     langAssert("ta", "Linux பற்றி பிற கட்டுரைகளில் தேடிப்பாருங்கள்.");
     langAssert("uk", "Лі́нукс — загальна назва UNIX-подібних операційних систем на основі однойменного ядра.");
+    */
     // not yet in language-detector 0.4:
     langAssert("km", "អ្នក\u200Bអាច\u200Bជួយ\u200Bលើក\u200Bស្ទួយ\u200Bវិគីភីឌាភាសាខ្មែរ\u200Bនេះ\u200Bឱ្យ\u200Bមាន\u200Bលក្ខណៈ");
     langAssert("eo", "Imperiestraj pingvenoj manĝas ĉefe krustacojn kaj malgrandajn ...");

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/atom/MatchDatabase.java
Patch:
@@ -134,7 +134,7 @@ int markedFixed(WikipediaRuleMatch ruleMatch) {
   void createTables() throws SQLException {
     try (PreparedStatement prepSt = conn.prepareStatement("CREATE TABLE pings (" +
             "  language_code VARCHAR(5) NOT NULL," +
-            "  ping_date TIMESTAMP NOT NULL" +
+            "  check_date TIMESTAMP NOT NULL" +
             ")")) {
       prepSt.executeUpdate();
     }

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/atom/AtomFeedChecker.java
Patch:
@@ -162,6 +162,9 @@ CheckResult checkChanges(InputStream xml) throws IOException {
       List<AtomFeedItem> items = new AtomFeedParser().getAtomFeedItems(xml);
       Collections.reverse(items);   // older items must come first so we iterate in the order in which the changes were made
       printDates(items, lastDateOfPreviousRun);
+      if (matchDatabase != null) {
+        matchDatabase.updateRuleMatchPingDate(language, new Date());
+      }
       for (AtomFeedItem item : items) {
         // Note: this skipping is not always exact:
         //   A resolution of one second may not be enough, considering the amount of changes happening,

File: languagetool-core/src/main/java/org/languagetool/rules/TextLevelRule.java
Patch:
@@ -42,7 +42,7 @@ public TextLevelRule(ResourceBundle messages) {
 
   @Override
   public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
-    throw new RuntimeException("No implemented for a text-level rule");
+    throw new RuntimeException("Not implemented for a text-level rule");
   }
 
   public RuleMatch[] match(List<AnalyzedSentence> sentence) throws IOException {

File: languagetool-core/src/main/java/org/languagetool/rules/TextLevelRule.java
Patch:
@@ -42,7 +42,7 @@ public TextLevelRule(ResourceBundle messages) {
 
   @Override
   public RuleMatch[] match(AnalyzedSentence sentence) throws IOException {
-    throw new RuntimeException("No implemented for a text-level rule");
+    throw new RuntimeException("Not implemented for a text-level rule");
   }
 
   public RuleMatch[] match(List<AnalyzedSentence> sentence) throws IOException {

File: languagetool-language-modules/pl/src/main/java/org/languagetool/rules/pl/DateCheckFilter.java
Patch:
@@ -40,7 +40,7 @@ protected int getDayOfWeek(String dayStr) {
     if (day.startsWith("wt")) return Calendar.TUESDAY;
     if (day.startsWith("śr")) return Calendar.WEDNESDAY;
     if (day.startsWith("czw")) return Calendar.THURSDAY;
-    if (day.equals("pt") || day.equals("piątek")) return Calendar.FRIDAY;
+    if (day.equals("pt") || day.startsWith("piątk") || day.equals("piątek")) return Calendar.FRIDAY;
     if (day.startsWith("sob")) return Calendar.SATURDAY;
     if (day.startsWith("niedz")) return Calendar.SUNDAY;
     throw new RuntimeException("Could not find day of week for '" + dayStr + "'");

File: languagetool-core/src/main/java/org/languagetool/rules/GenericUnpairedBracketsRule.java
Patch:
@@ -39,7 +39,7 @@ public class GenericUnpairedBracketsRule extends TextLevelRule {
           Pattern.compile("(?i)\\d{1,2}?[a-z']*|M*(D?C{0,3}|C[DM])(L?X{0,3}|X[LC])(V?I{0,3}|I[VX])$");
   private static final Pattern PUNCTUATION = Pattern.compile("\\p{Punct}");
   private static final Pattern PUNCTUATION_NO_DOT =
-          Pattern.compile("[ldmnst]'|[–—\\p{Punct}&&[^\\.]]");
+          Pattern.compile("[ldmnstLDMNST]'|[–—\\p{Punct}&&[^\\.]]");
   // "[ldmnst]'" allows dealing with apostrophed words in Catalan (i.e. l'«home) 
 
   protected Pattern numerals;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tokenizers/ca/CatalanWordTokenizer.java
Patch:
@@ -84,7 +84,7 @@ public CatalanWordTokenizer() {
 
     // Apostrophe at the beginning of a word. Ex.: l'home, s'estima, n'omple, hivern, etc.
     // It creates 2 tokens: <token>l'</token><token>home</token>
-    patterns[0] = Pattern.compile("^([lnmtsd]['’])([^'\\-]*)$",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
+    patterns[0] = Pattern.compile("^([lnmtsd]['’])([^'’\\-]*)$",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
 
     // Exceptions to (Match verb+1 pronom feble)
     // It creates 1 token: <token>qui-sap-lo</token>

File: languagetool-language-modules/ca/src/test/java/org/languagetool/tokenizers/ca/CatalanWordTokenizerTest.java
Patch:
@@ -47,6 +47,9 @@ public void testTokenize() {
     tokens = wordTokenizer.tokenize("El tren Barcelona-València");
     assertEquals(tokens.size(), 7);
     assertEquals("[El,  , tren,  , Barcelona, -, València]", tokens.toString());
+    tokens = wordTokenizer.tokenize("No acabava d’entendre’l bé");
+    assertEquals(tokens.size(), 9);
+    assertEquals("[No,  , acabava,  , d’, entendre, ’l,  , bé]", tokens.toString());
     tokens = wordTokenizer.tokenize("N'hi ha vint-i-quatre");
     assertEquals(tokens.size(), 6);
     assertEquals("[N', hi,  , ha,  , vint-i-quatre]", tokens.toString());

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/MultiWordChunker.java
Patch:
@@ -188,6 +188,7 @@ private AnalyzedTokenReadings setAndAnnotate(final AnalyzedTokenReadings oldRead
     newAtr.addReading(newReading);
     newAtr.setHistoricalAnnotations(
             annotateToken(prevAnot, old, newAtr.toString()));
+    newAtr.setChunkTags(oldReading.getChunkTags());
     return newAtr;
   }
   

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/ValencianCatalan.java
Patch:
@@ -55,7 +55,7 @@ public List<String> getDefaultEnabledRulesForVariant() {
   public List<String> getDefaultDisabledRulesForVariant() {
     List<String> rules = Arrays.asList("EXIGEIX_VERBS_CENTRAL",
         "EXIGEIX_ACCENTUACIO_GENERAL", "EXIGEIX_POSSESSIUS_V",
-        "EVITA_PRONOMS_VALENCIANS", "EVITA_DEMOSTRATIUS_EIXE");
+        "EVITA_PRONOMS_VALENCIANS", "EVITA_DEMOSTRATIUS_EIXE", "VOCABULARI_VALENCIA");
     return rules;
   }
   

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -156,7 +156,7 @@ protected boolean isMisspelled(MorfologikSpeller speller, String word) {
 
   protected List<RuleMatch> getRuleMatches(final String word, final int startPos) throws IOException {
     final List<RuleMatch> ruleMatches = new ArrayList<>();
-    if (isMisspelled(speller1, word)) {
+    if (isMisspelled(speller1, word) || isProhibited(word)) {
       final RuleMatch ruleMatch = new RuleMatch(this, startPos, startPos
           + word.length(), messages.getString("spelling"),
           messages.getString("desc_spelling_short"));
@@ -168,6 +168,7 @@ protected List<RuleMatch> getRuleMatches(final String word, final int startPos)
       suggestions.addAll(0, getAdditionalTopSuggestions(suggestions, word));
       suggestions.addAll(getAdditionalSuggestions(suggestions, word));
       if (!suggestions.isEmpty()) {
+        filterSuggestions(suggestions);
         ruleMatch.setSuggestedReplacements(orderSuggestions(suggestions, word));
       }
       ruleMatches.add(ruleMatch);

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -62,6 +62,8 @@ public void testRule() throws IOException {
      */
     // (en especial si hi ha un adverbi entremig: en algun grau més distintes
     //assertCorrect("Es van somriure l'una a l'altra encara dretes, suades i panteixants,");
+    assertCorrect("el text de més àmplia i persistent influència");
+    assertCorrect("el text de més àmplia influència");
     assertCorrect("Ell i jo som una altra vegada partidaris del rei"); 
     assertCorrect("despres de la revolta contra el poder pontifici iniciada a Bolonya");
     assertCorrect("-Així, ¿viatges sola? -va dir");

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRule.java
Patch:
@@ -377,9 +377,9 @@ && matchPostagRegexp(tokens[i], ADJECTIU_FP) && matchPostagRegexp(
           continue goToNextToken;
         }
         // exceptions: un cop, una volta, una vegada...
-        if (((prevPrevToken.equals("un") && (prevToken.equals("cop") || prevToken
-            .equals("colp"))) || (prevPrevToken.equals("una") && (prevToken
-            .equals("volta") || prevToken.equals("vegada"))))) {
+        if ((((prevPrevToken.equals("un") || prevPrevToken.equals("altre")) && (prevToken.equals("cop") || prevToken.equals("colp"))) 
+            || ((prevPrevToken.equals("una") || prevPrevToken.equals("altra")) && (prevToken.equals("volta") || prevToken.equals("vegada"))))
+            ) {
           continue goToNextToken;
         }
         // exceptions: segur que, just a

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -62,6 +62,7 @@ public void testRule() throws IOException {
      */
     // (en especial si hi ha un adverbi entremig: en algun grau més distintes
     //assertCorrect("Es van somriure l'una a l'altra encara dretes, suades i panteixants,");
+    assertCorrect("Ell i jo som una altra vegada partidaris del rei"); 
     assertCorrect("despres de la revolta contra el poder pontifici iniciada a Bolonya");
     assertCorrect("-Així, ¿viatges sola? -va dir");
     assertCorrect("El riu passa engorjat en aquest sector ");

File: languagetool-language-modules/uk/src/main/java/org/languagetool/rules/uk/TokenAgreementRule.java
Patch:
@@ -175,7 +175,7 @@ public final RuleMatch[] match(final AnalyzedSentence text) {
           }
         }
 
-        if( prep.equalsIgnoreCase("в") || prep.equalsIgnoreCase("у") ) {
+        if( prep.equalsIgnoreCase("в") || prep.equalsIgnoreCase("у") || prep.equals("межи") || prep.equals("між") ) {
           if( hasRequiredPosTag(Arrays.asList("p:v_naz"), tokenReadings) ) {  //TODO: only for subset: президенти/депутати/мери/гості... or by verb піти/йти/балотуватися/записатися...
             reqTokenReadings = null;
             continue;

File: languagetool-language-modules/uk/src/test/java/org/languagetool/rules/uk/TokenAgreementRuleTest.java
Patch:
@@ -61,6 +61,7 @@ public void testRule() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("хто їде на заробітки за кордон")).length);
 
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("піти в президенти")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("піти межі люди")).length);
 
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("що то була за людина")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("що за людина")).length);

File: languagetool-language-modules/uk/src/test/java/org/languagetool/tagging/uk/UkrainianTaggerTest.java
Patch:
@@ -42,7 +42,7 @@ public void testDictionary() throws IOException {
   
   public void testTagger() throws IOException {
     TestTools.myAssert("300 р. до н. е.", 
-      "300/[300]number -- р/[р]unknown:abbr -- до/[до]noun:n:nv|до/[до]prep:rv_rod -- н/[null]null -- е/[null]null",
+      "300/[300]number -- р/[р]unknown:abbr -- до/[до]noun:n:nv|до/[до]prep:rv_rod -- н/[null]null -- е/[е]excl",
        tokenizer, tagger);
 
     TestTools.myAssert("101,234", "101,234/[101,234]number", tokenizer, tagger);
@@ -67,7 +67,7 @@ public void testTagger() throws IOException {
     String expected = 
       "Майже/[майже]adv -- два/[два]numr:m:v_naz|два/[два]numr:m:v_zna|два/[два]numr:n:v_naz|два/[два]numr:n:v_zna -- роки/[рік]noun:p:v_naz|роки/[рік]noun:p:v_zna"
     + " -- тому/[той]pron:m:v_dav|тому/[той]pron:m:v_mis|тому/[той]pron:n:v_dav|тому/[той]pron:n:v_mis|тому/[том]noun:m:v_dav|тому/[том]noun:m:v_mis|тому/[том]noun:m:v_rod"
-    + " -- Люба/[Люба]noun:f:v_naz:ist|Люба/[любий]adj:f:v_naz -- разом/[раз]noun:m:v_oru -- із/[із]prep:rv_rod:rv_zna:rv_oru"
+    + " -- Люба/[Люба]noun:f:v_naz:ist|Люба/[любий]adj:f:v_naz -- разом/[раз]noun:m:v_oru|разом/[разом]adv -- із/[із]prep:rv_rod:rv_zna:rv_oru"
     + " -- чоловіком/[чоловік]noun:m:v_oru:ist -- Степаном/[Степан]noun:m:v_oru:ist -- виїхали/[виїхати]verb:past:m:perf -- туди/[туди]adv"
     + " -- на/[на]excl|на/[на]part|на/[на]prep:rv_zna:rv_mis -- "
     + "проживання/[проживання]noun:n:v_naz|проживання/[проживання]noun:n:v_rod|проживання/[проживання]noun:n:v_zna|проживання/[проживання]noun:p:v_naz|проживання/[проживання]noun:p:v_zna";

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageToolSupport.java
Patch:
@@ -811,7 +811,9 @@ public void run() {
 
   private void removeHighlights() {
     for (Highlighter.Highlight hl : textComponent.getHighlighter().getHighlights()) {
-      textComponent.getHighlighter().removeHighlight(hl);
+      if (hl.getPainter() instanceof HighlightPainter) {
+        textComponent.getHighlighter().removeHighlight(hl);
+      }
     }
   }
 

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/AccentuationCheckRule.java
Patch:
@@ -246,6 +246,7 @@ else if (!token.equals("venia")
         }
         // circumstancies extraordinàries
         else if (!token.equals("pronuncia")
+            && !token.equals("espero")
             && !token.equals("pronuncies")
             && !token.equals("venia")
             && !token.equals("venies")

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -43,6 +43,7 @@ public void testRule() throws IOException {
 
     // correct sentences:
     //assertCorrect("A ponent continua la serra de Fontpobra");
+    assertCorrect("Per tant, espero ansiós.");
     assertCorrect("M'espero qualsevol cosa.");
     assertCorrect("Carrega de nou l'arxiu.");
     assertCorrect("Espero d'ell moltes coses");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -108,7 +108,6 @@ public void testRule() throws IOException {
     // assertIncorrect("Va deixar els nens atonits."); del v. "atonir" (=esbalair)
     assertIncorrect("La sureda ocupa amplies extensions en la muntanya.");
     assertIncorrect("Féu una magnifica digitació.");
-    assertIncorrect("Els habitats de la comarca.");
     assertIncorrect("La magnifica conservació del palau.");
 
     final RuleMatch[] matches = rule

File: languagetool-core/src/main/java/org/languagetool/rules/Rule.java
Patch:
@@ -231,7 +231,7 @@ public ITSIssueType getLocQualityIssueType() {
    * @since 2.5
    */
   public void setLocQualityIssueType(ITSIssueType locQualityIssueType) {
-    this.locQualityIssueType = locQualityIssueType;
+    this.locQualityIssueType = Objects.requireNonNull(locQualityIssueType);
   }
 
   /**

File: languagetool-core/src/main/java/org/languagetool/tools/Tools.java
Patch:
@@ -70,7 +70,7 @@ public static List<RuleMatch> checkBitext(final String src, final String trg,
             match.setColumn(1);
           }
           if (match.getEndColumn() < 0) {
-            match.setEndColumn(trg.length());
+            match.setEndColumn(trg.length() + 1); // we count from 0
           }
           if (match.getLine() < 0) {
             match.setLine(1);

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerTest.java
Patch:
@@ -154,6 +154,7 @@ void runTests() throws IOException, SAXException, ParserConfigurationException {
     //check disabling bitext rules:
     String result5 = bitextCheckDisabled(polish, english, "a", "To jest okropnie długi tekst, naprawdę!", nothing);
     assertTrue(result5.contains("TRANSLATION_LENGTH"));
+    assertFalse(result5.contains("-2"));
 
     final String[] disableTranslationLen = {"TRANSLATION_LENGTH"};
     String result6 = bitextCheckDisabled(polish, english, "a", "This is a very long text. Really!", disableTranslationLen);

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -425,7 +425,8 @@ private List<RuleMatch> getRuleMatches(String text, Map<String, String> paramete
           motherTongue + " and target language " + lang.getShortNameWithCountryAndVariant());
       final JLanguageTool sourceLt = getLanguageToolInstance(motherTongue, null, params);
       final JLanguageTool targetLt = getLanguageToolInstance(lang, null, params);
-      final List<BitextRule> bRules = Tools.getBitextRules(motherTongue, lang);
+      final List<BitextRule> bRules = Tools.selectBitextRules(Tools.getBitextRules(motherTongue, lang),
+          params.disabledRules, params.enabledRules, params.useEnabledOnly);
       return Tools.checkBitext(sourceText, text, sourceLt, targetLt, bRules);
     }
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -383,6 +383,9 @@ public class CaseRule extends GermanRule {
     myExceptionPhrases.add("Russischen Reichs");
     myExceptionPhrases.add("Russischen Reiches");
     myExceptionPhrases.add("Tel Aviv");
+    myExceptionPhrases.add("Dreißigjährige Krieg");
+    myExceptionPhrases.add("Dreißigjährigen Kriegs");
+    myExceptionPhrases.add("Dreißigjährigen Krieges");
     myExceptionPhrases.add("Erster Weltkrieg");
     myExceptionPhrases.add("Ersten Weltkriegs");
     myExceptionPhrases.add("Ersten Weltkrieg");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -179,7 +179,8 @@ private GrammarCategory(String displayName) {
   private static final Set<String> NOUNS_TO_BE_IGNORED = new HashSet<>(Arrays.asList(
     "Prozent",   // Plural "Prozente", trotzdem ist "mehrere Prozent" korrekt
     "Gramm",
-    "Kilogramm"
+    "Kilogramm",
+    "Uhr"   // "um ein Uhr"
   ));
     
   public AgreementRule(final ResourceBundle messages, German language) {

File: languagetool-dev/src/main/java/org/languagetool/dev/conversion/RuleCoverage.java
Patch:
@@ -206,7 +206,7 @@ public String generateIncorrectExample(PatternRule patternrule) {
         StringBuilder sb = new StringBuilder();
         //TODO: doesn't deal with spacebefore=no
         for (String example : examples) {
-          sb.append(example + " ");
+          sb.append(example).append(" ");
         }
         String s = sb.toString().replaceAll("\\ \\.\\ ", "").trim();  // to fix the period problem 
         return s;

File: languagetool-dev/src/main/java/org/languagetool/dev/conversion/cg/CgCompositeTag.java
Patch:
@@ -19,9 +19,9 @@ public String toString() {
       sb.append("(");
       for (int i=0;i<tags.size();i++) {
         if (i == tags.size() - 1) {
-          sb.append(tags.get(i).tag + ")");
+          sb.append(tags.get(i).tag).append(")");
         } else {
-          sb.append(tags.get(i).tag + " ");
+          sb.append(tags.get(i).tag).append(" ");
         }
       }
       return sb.toString();

File: languagetool-dev/src/main/java/org/languagetool/dev/conversion/cg/CgSet.java
Patch:
@@ -280,7 +280,7 @@ public String toString(CgGrammar grammar) {
             for (CgCompositeTag ctag : this.tags) {
                 sb.append("(");
                 for (CgTag stag : ctag.tags ) {
-                    sb.append(stag + " ");
+                    sb.append(stag).append(" ");
                 }
                 sb.append(")");
             }

File: languagetool-server/src/main/java/org/languagetool/server/AtDXmlSerializer.java
Patch:
@@ -37,7 +37,7 @@ public class AtDXmlSerializer {
   public String ruleMatchesToXml(List<RuleMatch> matches, String text) {
     StringBuilder sb = new StringBuilder();
     sb.append("<results>\n");
-    sb.append("<!-- Server: LanguageTool " + JLanguageTool.VERSION + " (" + JLanguageTool.BUILD_DATE + ") -->\n");
+    sb.append("<!-- Server: LanguageTool " + JLanguageTool.VERSION + " (").append(JLanguageTool.BUILD_DATE).append(") -->\n");
     for (RuleMatch match : matches) {
       addRuleMatch(sb, match, text);
     }

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageManagerDialog.java
Patch:
@@ -161,6 +161,9 @@ public void actionPerformed(ActionEvent e) {
       } else {
           ruleFile = Tools.openFileDialog(owner, new XMLFileFilter());
       }
+      if (ruleFile == null) {
+        return; // dialog was canceled
+      }
       if (config != null) {
         config.setExternalRuleDirectory(ruleFile.getParent());
         try {

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageManagerDialog.java
Patch:
@@ -161,6 +161,9 @@ public void actionPerformed(ActionEvent e) {
       } else {
           ruleFile = Tools.openFileDialog(owner, new XMLFileFilter());
       }
+      if (ruleFile == null) {
+        return; // dialog was canceled
+      }
       if (config != null) {
         config.setExternalRuleDirectory(ruleFile.getParent());
         try {

File: languagetool-core/src/main/java/org/languagetool/rules/RuleMatch.java
Patch:
@@ -204,7 +204,7 @@ public String getMessage() {
   }  
 
   /**
-   * A shorter human-readable explanation describing the error or {@code null}
+   * A shorter human-readable explanation describing the error or an empty string
    * if no such explanation is available.
    * @see #getMessage()
    */

File: languagetool-core/src/main/java/org/languagetool/rules/ITSIssueType.java
Patch:
@@ -19,6 +19,7 @@
 package org.languagetool.rules;
 
 import java.util.Arrays;
+import java.util.Locale;
 
 /**
  * Some constants for Localization Quality Issue Type from the
@@ -61,7 +62,7 @@ public static ITSIssueType getIssueType(String name) {
    */
   @Override
   public String toString() {
-    return name.toLowerCase();
+    return name.toLowerCase(Locale.ENGLISH);
   }
 
 }

File: languagetool-language-modules/br/src/main/java/org/languagetool/rules/br/DateCheckFilter.java
Patch:
@@ -60,7 +60,7 @@ protected int getDayOfMonth(String dayStr) {
     if (day.equals("unnek"))                            return 11;
     if (day.equals("daouzek"))                          return 12;
     if (day.equals("drizek"))                           return 13;
-    if (day.equals("bevazek"))                          return 14;
+    if (day.equals("bevarzek"))                         return 14;
     if (day.equals("bemzek"))                           return 15;
     if (day.equals("c’hwezek"))                         return 16;
     if (day.equals("seitek"))                           return 17;

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/MultiWordChunker.java
Patch:
@@ -64,6 +64,9 @@ private void lazyInit() {
     final List<String> posTokens = loadWords(JLanguageTool.getDataBroker().getFromResourceDirAsStream(filename));
     for (String posToken : posTokens) {
       final String[] tokenAndTag = posToken.split("\t");
+      if (tokenAndTag.length != 2) {
+        throw new RuntimeException("Invalid format in " + filename + ": '" + posToken + "', expected two tab-separated parts");
+      }
       final boolean containsSpace = tokenAndTag[0].indexOf(' ') > 0;
       String firstToken;
       final String[] firstTokens;

File: languagetool-language-modules/es/src/main/java/org/languagetool/rules/es/MorfologikSpanishSpellerRule.java
Patch:
@@ -40,6 +40,6 @@ public String getFileName() {
 
   @Override
   public final String getId() {
-    return "MORFOLOGIK_RULE_ES_US";
+    return "MORFOLOGIK_RULE_ES";
   }
 }

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerLoadTest.java
Patch:
@@ -45,7 +45,7 @@ public class HTTPServerLoadTest extends HTTPServerTest {
   @Override
   public void testHTTPServer() throws Exception {
     final long startTime = System.currentTimeMillis();
-    HTTPServerConfig config = new HTTPServerConfig(HTTPServerConfig.DEFAULT_PORT, true);
+    HTTPServerConfig config = new HTTPServerConfig(HTTPTools.getDefaultPort(), true);
     final HTTPServer server = new HTTPServer(config);
     assertFalse(server.isRunning());
     try {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/SentenceWhitespaceRule.java
Patch:
@@ -69,11 +69,11 @@ public String getMessage() {
   @Override
   public RuleMatch[] match(AnalyzedSentence sentence) {
     AnalyzedTokenReadings[] tokens = sentence.getTokens();
+    List<RuleMatch> matches = Arrays.asList(super.match(sentence));
     if (tokens.length > 1) {
       String prevLastToken = tokens[tokens.length-2].getToken();
       prevSentenceEndsWithNumber = NUMBER_REGEX.matcher(prevLastToken).matches();
     }
-    List<RuleMatch> matches = Arrays.asList(super.match(sentence));
     return toRuleMatchArray(matches);
   }
 

File: languagetool-language-modules/nl/src/main/java/org/languagetool/rules/nl/DateCheckFilter.java
Patch:
@@ -68,7 +68,7 @@ protected int getMonth(String monthStr) {
     String mon = monthStr.toLowerCase();
     if (mon.startsWith("jan")) return 1;
     if (mon.startsWith("feb")) return 2;
-    if (mon.startsWith("mar")) return 3;
+    if (mon.startsWith("maa")) return 3;
     if (mon.startsWith("apr")) return 4;
     if (mon.startsWith("mei")) return 5;
     if (mon.startsWith("jun")) return 6;

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/index/Searcher.java
Patch:
@@ -279,7 +279,7 @@ class PossiblyLimitedTopDocs {
 
   private static void ensureCorrectUsageOrExit(String[] args) {
     if (args.length < 3 || (args.length == 4 && !"--no_limit".equals(args[3]))) {
-      System.err.println("Usage: Searcher <ruleId> <ruleXML> <languageCode> <indexDir> <--no_limit>");
+      System.err.println("Usage: Searcher <ruleId> <languageCode> <indexDir> [--no_limit]");
       System.err.println("\truleId       Id of the rule to search for (or comma-separated list of ids)");
       System.err.println("\tlanguageCode short language code, e.g. 'en' for English");
       System.err.println("\tindexDir     path to a directory containing the index");

File: languagetool-core/src/main/java/org/languagetool/rules/SentenceWhitespaceRule.java
Patch:
@@ -62,10 +62,10 @@ public RuleMatch[] match(AnalyzedSentence sentence) {
     } else {
       if (!prevSentenceEndsWithWhitespace && tokens.length > 1) {
         int startPos = 0;
-        String firsToken = tokens[1].getToken();
-        int endPos = firsToken.length();
+        String firstToken = tokens[1].getToken();
+        int endPos = firstToken.length();
         RuleMatch ruleMatch = new RuleMatch(this, startPos, endPos, messages.getString("addSpaceBetweenSentences"));
-        ruleMatch.setSuggestedReplacement(" " + firsToken);
+        ruleMatch.setSuggestedReplacement(" " + firstToken);
         ruleMatches.add(ruleMatch);
       }
     }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CompoundRuleTest.java
Patch:
@@ -49,6 +49,7 @@ public void testRule() throws IOException {
     check(0, "Start, Ziel, Sieg");
     check(0, "Roll-on-roll-off-Schiff");
     check(0, "Halswirbelsäule");
+    check(0, "Castrop-Rauxel");
     check(0, "Hals-Wirbel-Säule");   // doubtful whether this is correct...
     // incorrect sentences:
     check(1, "System Administrator", new String[]{"System-Administrator", "Systemadministrator"});
@@ -69,6 +70,7 @@ public void testRule() throws IOException {
     check(2, "System Administrator CD ROM");
     check(2, "Hals Wirbel Säule");
     check(1, "Und herum zu knobeln können.", new String[]{"herumzuknobeln"});
+    check(1, "Castrop Rauxel", new String[]{"Castrop-Rauxel"});
     //FIXME: suggestions / longest match
     //check(1, "Roll on roll off Schiff", new String[]{"Roll-on-roll-off-Schiff"});
     check(1, "Spin off");

File: languagetool-language-modules/nl/src/test/java/org/languagetool/rules/nl/MorfologikDutchSpellerRuleTest.java
Patch:
@@ -38,8 +38,8 @@ public void testSpeller() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Amsterdam")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("ipv")).length);  // in ignore.txt
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("voorzover")).length);  // in ignore.txt
-    assertEquals(0, rule.match(langTool.getAnalyzedSentence("FoobarWrongxx")).length);  // camel case is ignored
-
+    
+    assertEquals(1, rule.match(langTool.getAnalyzedSentence("FoobarWrongxx")).length);  // camel case is not ignored
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("foobarwrong")).length);
   }
 }

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractSpaceBeforeRule.java
Patch:
@@ -35,6 +35,8 @@
  */
 public abstract class AbstractSpaceBeforeRule extends Rule {
 
+  protected abstract Pattern getConjunctions();
+
   public AbstractSpaceBeforeRule(final ResourceBundle messages, final Language language) {
     super.setCategory(new Category(messages.getString("category_misc")));
   }
@@ -49,8 +51,6 @@ public String getDescription() {
     return "Checks for missing space before some conjunctions";
   }
 
-  abstract protected Pattern getConjuntions();
-
   protected String getShort() {
     return "Missing white space";
   }
@@ -66,7 +66,7 @@ public final RuleMatch[] match(final AnalyzedSentence sentence) {
 
     for (int i = 1; i < tokens.length; i++) {
       final String token = tokens[i].getToken();
-      Matcher matcher = getConjuntions().matcher(token);
+      Matcher matcher = getConjunctions().matcher(token);
       if (matcher.matches()) {
         final String previousToken = tokens[i - 1].getToken();
         if (!(previousToken.equals(" ") || previousToken.equals("("))) {

File: languagetool-language-modules/fa/src/main/java/org/languagetool/rules/fa/PersianSpaceBeforeRule.java
Patch:
@@ -31,14 +31,14 @@
  */
 public class PersianSpaceBeforeRule extends AbstractSpaceBeforeRule {
 
+  private static final Pattern CONJUNCTIONS = Pattern.compile("و|به|با|تا|زیرا|چون|بنابراین|چونکه");
+
   public PersianSpaceBeforeRule(ResourceBundle messages, Language language) {
     super(messages, language);
   }
 
-  private static final Pattern CONJUNCTIONS = Pattern.compile("و|به|با|تا|زیرا|چون|بنابراین|چونکه");
-
   @Override
-  protected Pattern getConjuntions() {
+  protected Pattern getConjunctions() {
     return CONJUNCTIONS;
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractSpaceBeforeRule.java
Patch:
@@ -68,7 +68,8 @@ public final RuleMatch[] match(final AnalyzedSentence sentence) {
       final String token = tokens[i].getToken();
       Matcher matcher = getConjuntions().matcher(token);
       if (matcher.matches()) {
-        if (!tokens[i - 1].getToken().equals(" ")) {
+        final String previousToken = tokens[i - 1].getToken();
+        if (!(previousToken.equals(" ") || previousToken.equals("("))) {
           final String replacement = " " + token;
           final String msg = getSuggestion();
           final int pos = tokens[i].getStartPos();

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractSpaceBeforeRule.java
Patch:
@@ -68,7 +68,8 @@ public final RuleMatch[] match(final AnalyzedSentence sentence) {
       final String token = tokens[i].getToken();
       Matcher matcher = getConjuntions().matcher(token);
       if (matcher.matches()) {
-        if (!tokens[i - 1].getToken().equals(" ")) {
+        final String previousToken = tokens[i - 1].getToken();
+        if (!(previousToken.equals(" ") || previousToken.equals("("))) {
           final String replacement = " " + token;
           final String msg = getSuggestion();
           final int pos = tokens[i].getStartPos();

File: languagetool-language-modules/br/src/main/java/org/languagetool/rules/br/DateCheckFilter.java
Patch:
@@ -41,7 +41,7 @@ protected int getDayOfWeek(String dayStr) {
     if (day.equals("sul"))      return Calendar.SUNDAY;
     if (day.equals("lun"))      return Calendar.MONDAY;
     if (day.equals("meurzh"))   return Calendar.TUESDAY;
-    if (day.equals("merc'her")) return Calendar.WEDNESDAY;
+    if (day.equals("merc’her")) return Calendar.WEDNESDAY;
     if (day.equals("yaou"))     return Calendar.THURSDAY;
     if (day.equals("gwener"))   return Calendar.FRIDAY;
     if (day.equals("sadorn"))   return Calendar.SATURDAY;
@@ -66,7 +66,7 @@ protected String getDayOfWeek(Calendar date) {
   protected int getMonth(String monthStr) {
     String mon = monthStr.toLowerCase();
     if (mon.equals("genver"))    return 1;
-    if (mon.equals("c'hwevrer")) return 2;
+    if (mon.equals("c’hwevrer")) return 2;
     if (mon.equals("meurzh"))    return 3;
     if (mon.equals("ebrel"))     return 4;
     if (mon.equals("mae"))       return 5;

File: languagetool-language-modules/br/src/main/java/org/languagetool/rules/br/DateCheckFilter.java
Patch:
@@ -43,7 +43,7 @@ protected int getDayOfWeek(String dayStr) {
     if (day.equals("meurzh"))   return Calendar.TUESDAY;
     if (day.equals("merc'her")) return Calendar.WEDNESDAY;
     if (day.equals("yaou"))     return Calendar.THURSDAY;
-    if (day.equals("gwengolo")) return Calendar.FRIDAY;
+    if (day.equals("gwener"))   return Calendar.FRIDAY;
     if (day.equals("sadorn"))   return Calendar.SATURDAY;
     throw new RuntimeException("Could not find day of week for '" + dayStr + "'");
   }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -81,6 +81,9 @@ public class CaseRule extends GermanRule {
      * solution is to add all those to our Morphy data, but as a simple
      * workaround to avoid false alarms, these words can be added here.
      */
+    exceptions.add("Beschäftigter");
+    exceptions.add("Beschäftigte");
+    exceptions.add("Beschäftigten");
     exceptions.add("Üblichen");
     exceptions.add("Bekannter");
     exceptions.add("Bekannte");

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/dumpcheck/SentenceSourceChecker.java
Patch:
@@ -173,6 +173,8 @@ private void run(File propFile, Set<String> disabledRules, String langCode, List
             System.err.printf("%s sentences checked...\n", NumberFormat.getNumberInstance(Locale.US).format(sentenceCount));
           }
           ruleMatchCount += matches.size();
+        } catch (DocumentLimitReachedException | ErrorLimitReachedException e) {
+          throw e;
         } catch (Exception e) {
           throw new RuntimeException("Check failed on sentence: " + StringUtils.abbreviate(sentence.getText(), 250), e);
         }

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationPatternRuleReplacer.java
Patch:
@@ -301,15 +301,15 @@ private AnalyzedTokenReadings[] executeAction(final AnalyzedSentence sentence,
       for (int i = 0; i < matchingTokensWithCorrection - startPositionCorrection + endPositionCorrection; i++) {
         final int position = sentence.getOriginalPosition(firstMatchToken + correctedStPos + i);
         Element myEl;
-      if (elementsMatched.get(i + startPositionCorrection)) {
-        myEl = rule.getPatternElements().get(i + startPositionCorrection);
+        if (elementsMatched.get(i + startPositionCorrection)) {
+          myEl = rule.getPatternElements().get(i + startPositionCorrection);
         } else {
           int k = 1;
           while (i + startPositionCorrection + k < rule.getPatternElements().size() + endPositionCorrection &&
               !elementsMatched.get(i + startPositionCorrection + k)) {
             k++;
           }
-        //FIXME: this is left to see whether this fails anywhere
+         //FIXME: this is left to see whether this fails anywhere
          assert(i + k + startPositionCorrection < rule.getPatternElements().size());
          myEl = rule.getPatternElements().get(i + k + startPositionCorrection);
         }

File: languagetool-core/src/main/java/org/languagetool/rules/GenericUnpairedBracketsRule.java
Patch:
@@ -80,7 +80,7 @@ public String getDescription() {
   }
 
   /**
-   * @deprecated (will become protected; deprecated since 2.7)
+   * @deprecated will become protected (deprecated since 2.7)
    */
   @Deprecated
   public void uniqueMapInit() {

File: languagetool-language-modules/br/src/test/java/org/languagetool/rules/br/MorfologikBretonSpellerRuleTest.java
Patch:
@@ -33,7 +33,7 @@ public class MorfologikBretonSpellerRuleTest {
   @Test
   public void testMorfologikSpeller() throws IOException {
     final MorfologikBretonSpellerRule rule =
-            new MorfologikBretonSpellerRule (TestTools.getMessages("Breton"), new Breton());
+            new MorfologikBretonSpellerRule (TestTools.getMessages("br"), new Breton());
 
     RuleMatch[] matches;
     final JLanguageTool langTool = new JLanguageTool(new Breton());

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/CatalanWordRepeatRuleTest.java
Patch:
@@ -34,7 +34,7 @@ public class CatalanWordRepeatRuleTest extends TestCase {
    * Test method for 'org.languagetool.rules.ca.CatalanWordRepeatRule.match(AnalyzedSentence)'
    */
   public void testRule() throws IOException {
-    final CatalanWordRepeatRule rule = new CatalanWordRepeatRule(TestTools.getMessages("Catalan"), new Catalan());
+    final CatalanWordRepeatRule rule = new CatalanWordRepeatRule(TestTools.getMessages("ca"), new Catalan());
     RuleMatch[] matches;
     JLanguageTool langTool = new JLanguageTool(new Catalan());
     //correct

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/MorfologikCatalanSpellerRuleTest.java
Patch:
@@ -35,7 +35,7 @@ public class MorfologikCatalanSpellerRuleTest {
     @Test
     public void testMorfologikSpeller() throws IOException {
         MorfologikCatalanSpellerRule rule =
-                new MorfologikCatalanSpellerRule (TestTools.getMessages("Catalan"), new Catalan());
+                new MorfologikCatalanSpellerRule (TestTools.getMessages("ca"), new Catalan());
 
         RuleMatch[] matches;
         JLanguageTool langTool = new JLanguageTool(new Catalan());

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/MorfologikGermanyGermanSpellerRuleTest.java
Patch:
@@ -32,7 +32,7 @@ public class MorfologikGermanyGermanSpellerRuleTest {
   @Test
   public void testMorfologikSpeller() throws IOException {
     final MorfologikGermanyGermanSpellerRule rule =
-          new MorfologikGermanyGermanSpellerRule(TestTools.getMessages("English"), new German());
+          new MorfologikGermanyGermanSpellerRule(TestTools.getMessages("en"), new German());
     final JLanguageTool langTool = new JLanguageTool(new German());
 
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Hier stimmt jedes Wort!")).length);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/spelling/hunspell/HunspellRuleTest.java
Patch:
@@ -40,7 +40,7 @@ public class HunspellRuleTest {
 
   @Test
   public void testRuleWithGerman() throws Exception {
-    final HunspellRule rule = new HunspellRule(TestTools.getMessages("German"), new GermanyGerman());
+    final HunspellRule rule = new HunspellRule(TestTools.getMessages("de"), new GermanyGerman());
     final JLanguageTool langTool = new JLanguageTool(new German());
     commonGermanAsserts(rule, langTool);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Der äußere Übeltäter.")).length);  // umlauts
@@ -53,7 +53,7 @@ public void testRuleWithGerman() throws Exception {
 
   @Test
   public void testRuleWithAustrianGerman() throws Exception {
-    final HunspellRule rule = new HunspellRule(TestTools.getMessages("German"), new AustrianGerman());
+    final HunspellRule rule = new HunspellRule(TestTools.getMessages("de"), new AustrianGerman());
     final JLanguageTool langTool = new JLanguageTool(new German());
     commonGermanAsserts(rule, langTool);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Der äußere Übeltäter.")).length);  // umlauts
@@ -62,7 +62,7 @@ public void testRuleWithAustrianGerman() throws Exception {
 
   @Test
   public void testRuleWithSwissGerman() throws Exception {
-    final HunspellRule rule = new HunspellRule(TestTools.getMessages("German"), new SwissGerman());
+    final HunspellRule rule = new HunspellRule(TestTools.getMessages("de"), new SwissGerman());
     final JLanguageTool langTool = new JLanguageTool(new German());
     commonGermanAsserts(rule, langTool);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Der äußere Übeltäter.")).length);  // ß not allowed in Swiss

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikAmericanSpellerRuleTest.java
Patch:
@@ -41,7 +41,7 @@ public class MorfologikAmericanSpellerRuleTest {
 
   @BeforeClass
   public static void setup() throws IOException {
-    rule = new MorfologikAmericanSpellerRule(TestTools.getMessages("English"), language);
+    rule = new MorfologikAmericanSpellerRule(TestTools.getMessages("en"), language);
     langTool = new JLanguageTool(language);
   }
 

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikAustralianSpellerRuleTest.java
Patch:
@@ -34,7 +34,7 @@ public class MorfologikAustralianSpellerRuleTest {
   public void testMorfologikSpeller() throws IOException {
     final AustralianEnglish language = new AustralianEnglish();
     final MorfologikAustralianSpellerRule rule =
-            new MorfologikAustralianSpellerRule (TestTools.getMessages("English"), language);
+            new MorfologikAustralianSpellerRule (TestTools.getMessages("en"), language);
 
     final JLanguageTool langTool = new JLanguageTool(language);
 

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikBritishSpellerRuleTest.java
Patch:
@@ -34,7 +34,7 @@ public class MorfologikBritishSpellerRuleTest {
   public void testMorfologikSpeller() throws IOException {
     final BritishEnglish language = new BritishEnglish();
     final MorfologikBritishSpellerRule rule =
-            new MorfologikBritishSpellerRule (TestTools.getMessages("English"), language);
+            new MorfologikBritishSpellerRule (TestTools.getMessages("en"), language);
 
     final JLanguageTool langTool = new JLanguageTool(language);
 

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikCanadianSpellerRuleTest.java
Patch:
@@ -34,7 +34,7 @@ public class MorfologikCanadianSpellerRuleTest {
   public void testMorfologikSpeller() throws IOException {
     final CanadianEnglish language = new CanadianEnglish();
     final MorfologikBritishSpellerRule rule =
-            new MorfologikBritishSpellerRule (TestTools.getMessages("English"), language);
+            new MorfologikBritishSpellerRule (TestTools.getMessages("en"), language);
 
     final JLanguageTool langTool = new JLanguageTool(language);
 

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikNewZealandSpellerRuleTest.java
Patch:
@@ -34,7 +34,7 @@ public class MorfologikNewZealandSpellerRuleTest {
   public void testMorfologikSpeller() throws IOException {
     final NewZealandEnglish language = new NewZealandEnglish();
     final MorfologikNewZealandSpellerRule rule =
-            new MorfologikNewZealandSpellerRule (TestTools.getMessages("English"), language);
+            new MorfologikNewZealandSpellerRule (TestTools.getMessages("en"), language);
 
     final JLanguageTool langTool = new JLanguageTool(language);
 

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/MorfologikSouthAfricanSpellerRuleTest.java
Patch:
@@ -34,7 +34,7 @@ public class MorfologikSouthAfricanSpellerRuleTest {
   public void testMorfologikSpeller() throws IOException {
     final SouthAfricanEnglish language = new SouthAfricanEnglish();
     final MorfologikSouthAfricanSpellerRule rule =
-            new MorfologikSouthAfricanSpellerRule (TestTools.getMessages("English"), language);
+            new MorfologikSouthAfricanSpellerRule (TestTools.getMessages("en"), language);
 
     final JLanguageTool langTool = new JLanguageTool(language);
 

File: languagetool-language-modules/fa/src/test/java/org/languagetool/rules/fa/WordCoherencyRuleTest.java
Patch:
@@ -36,7 +36,7 @@ public class WordCoherencyRuleTest extends PatternRuleTest {
   protected void setUp() throws Exception {
     super.setUp();
     langTool = new JLanguageTool(new Persian());
-    rule = new WordCoherencyRule(TestTools.getMessages("Persian"));
+    rule = new WordCoherencyRule(TestTools.getMessages("fa"));
   }
 
   public void testRules() throws IOException {

File: languagetool-language-modules/fr/src/test/java/org/languagetool/rules/spelling/hunspell/HunspellRuleTest.java
Patch:
@@ -32,7 +32,7 @@ public class HunspellRuleTest {
   @Test
   public void testRuleWithFrench() throws Exception {
     final French french = new French();
-    final HunspellRule rule = new HunspellRule(TestTools.getMessages("French"), french);
+    final HunspellRule rule = new HunspellRule(TestTools.getMessages("fr"), french);
     final JLanguageTool langTool = new JLanguageTool(french);
 
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Un test simple.")).length);
@@ -56,7 +56,7 @@ public void testRuleWithFrench() throws Exception {
   @Test
   public void testImmunizedFrenchWord() throws Exception {
     final French french = new French();
-    final HunspellRule rule = new HunspellRule(TestTools.getMessages("French"), french);
+    final HunspellRule rule = new HunspellRule(TestTools.getMessages("fr"), french);
     JLanguageTool langTool = new JLanguageTool(french);
 
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("languageTool est génial.")).length);

File: languagetool-language-modules/ml/src/test/java/org/languagetool/rules/ml/MorfologikMalayalamSpellerRuleTest.java
Patch:
@@ -34,7 +34,7 @@ public class MorfologikMalayalamSpellerRuleTest {
   public void testMorfologikSpeller() throws IOException {
     final Malayalam language = new Malayalam();
     final MorfologikMalayalamSpellerRule rule =
-            new MorfologikMalayalamSpellerRule (TestTools.getMessages("Malayalam"), language);
+            new MorfologikMalayalamSpellerRule (TestTools.getMessages("ml"), language);
 
     RuleMatch[] matches;
     final JLanguageTool langTool = new JLanguageTool(language);

File: languagetool-language-modules/pl/src/test/java/org/languagetool/rules/pl/CompoundRuleTest.java
Patch:
@@ -50,7 +50,7 @@ public void testRule() throws IOException {
 
   public void testCompoundFile() throws IOException {
     final MorfologikPolishSpellerRule spellRule =
-        new MorfologikPolishSpellerRule (TestTools.getMessages("Polish"), new Polish());
+        new MorfologikPolishSpellerRule (TestTools.getMessages("pl"), new Polish());
     final InputStream   file = JLanguageTool.getDataBroker().getFromResourceDirAsStream("/pl/compounds.txt");
     try (Scanner scanner = new Scanner(file, "UTF-8")) {
       while (scanner.hasNextLine()) {

File: languagetool-language-modules/pl/src/test/java/org/languagetool/rules/pl/MorfologikPolishSpellerRuleTest.java
Patch:
@@ -33,7 +33,7 @@ public class MorfologikPolishSpellerRuleTest {
   @Test
   public void testMorfologikSpeller() throws IOException {
     final MorfologikPolishSpellerRule rule =
-        new MorfologikPolishSpellerRule (TestTools.getMessages("Polish"), new Polish());
+        new MorfologikPolishSpellerRule (TestTools.getMessages("pl"), new Polish());
 
     final JLanguageTool langTool = new JLanguageTool(new Polish());
 

File: languagetool-language-modules/uk/src/test/java/org/languagetool/rules/uk/MixedAlphabetsRuleTest.java
Patch:
@@ -33,7 +33,7 @@ public class MixedAlphabetsRuleTest {
 
   @Test
   public void testRule() throws IOException {
-    final MixedAlphabetsRule rule = new MixedAlphabetsRule(TestTools.getMessages("Ukrainian"));
+    final MixedAlphabetsRule rule = new MixedAlphabetsRule(TestTools.getMessages("uk"));
 
     final JLanguageTool langTool = new JLanguageTool(new Ukrainian());
 

File: languagetool-language-modules/uk/src/test/java/org/languagetool/rules/uk/MorfologikUkrainianSpellerRuleTest.java
Patch:
@@ -34,7 +34,7 @@ public class MorfologikUkrainianSpellerRuleTest {
 
   @Test
   public void testMorfologikSpeller() throws IOException {
-    MorfologikUkrainianSpellerRule rule = new MorfologikUkrainianSpellerRule (TestTools.getMessages("Ukrainian"), new Ukrainian());
+    MorfologikUkrainianSpellerRule rule = new MorfologikUkrainianSpellerRule (TestTools.getMessages("uk"), new Ukrainian());
 
     JLanguageTool langTool = new JLanguageTool(new Ukrainian());
 

File: languagetool-language-modules/uk/src/test/java/org/languagetool/rules/uk/TokenAgreementRuleTest.java
Patch:
@@ -36,7 +36,7 @@ public class TokenAgreementRuleTest {
 
   @Test
   public void testRule() throws IOException {
-    TokenAgreementRule rule = new TokenAgreementRule(TestTools.getMessages("Ukrainian"));
+    TokenAgreementRule rule = new TokenAgreementRule(TestTools.getMessages("uk"));
 
     JLanguageTool langTool = new JLanguageTool(new Ukrainian());
 

File: languagetool-language-modules/nl/src/test/java/org/languagetool/tokenizers/nl/DutchWordTokenizerTest.java
Patch:
@@ -40,6 +40,6 @@ public void testTokenize() {
 
   private void assertTokenize(String input, String expected) {
     List<String> result = wordTokenizer.tokenize(input);
-    assertEquals(result.toString(), expected);
+    assertEquals(expected, result.toString());
   }
 }

File: languagetool-dev/src/main/java/org/languagetool/dev/ConfusionSetUrlGenerator.java
Patch:
@@ -35,7 +35,7 @@ final class ConfusionSetUrlGenerator {
 
   public static void main(String[] args) throws IOException {
     ConfusionSetLoader confusionSetLoader =  new ConfusionSetLoader();
-    InputStream inputStream = JLanguageTool.getDataBroker().getFromRulesDirAsStream("homophones.txt");
+    InputStream inputStream = JLanguageTool.getDataBroker().getFromResourceDirAsStream("/en/homophones.txt");
     Map<String,ConfusionProbabilityRule.ConfusionSet> map = confusionSetLoader.loadConfusionSet(inputStream);
     String url = "http://storage.googleapis.com/books/ngrams/books/googlebooks-eng-all-2gram-20120701-<XX>.gz";
     Set<String> nameSet = new HashSet<>();

File: languagetool-dev/src/main/java/org/languagetool/dev/eval/RealWordFalseAlarmEvaluator.java
Patch:
@@ -59,10 +59,10 @@ class RealWordFalseAlarmEvaluator {
   private int globalRuleMatches;
 
   RealWordFalseAlarmEvaluator(File languageModelIndexDir) throws IOException {
-    InputStream inputStream = JLanguageTool.getDataBroker().getFromRulesDirAsStream("homophones.txt");
+    InputStream inputStream = JLanguageTool.getDataBroker().getFromResourceDirAsStream("/en/homophones.txt");
     ConfusionSetLoader confusionSetLoader;
     if (EVAL_MODE) {
-      InputStream infoStream = JLanguageTool.getDataBroker().getFromRulesDirAsStream("homophones-info.txt");
+      InputStream infoStream = JLanguageTool.getDataBroker().getFromResourceDirAsStream("/en/homophones-info.txt");
       confusionSetLoader =  new ConfusionSetLoader(infoStream, MIN_SENTENCES, MAX_ERROR_RATE);
     } else {
       confusionSetLoader =  new ConfusionSetLoader();

File: languagetool-dev/src/test/java/org/languagetool/dev/ConfusionSetCoverage.java
Patch:
@@ -63,7 +63,7 @@ private void run(String filename) throws IOException {
 
   private Map<String, ConfusionProbabilityRule.ConfusionSet> getConfusionSet() throws IOException {
     ConfusionSetLoader loader = new ConfusionSetLoader();
-    InputStream homophoneStream = JLanguageTool.getDataBroker().getFromRulesDirAsStream("homophones.txt");
+    InputStream homophoneStream = JLanguageTool.getDataBroker().getFromResourceDirAsStream("/en/homophones.txt");
     return loader.loadConfusionSet(homophoneStream);
   }
 

File: languagetool-dev/src/test/java/org/languagetool/dev/eval/RealWordCorpusEvaluatorTest.java
Patch:
@@ -30,10 +30,10 @@
 
 public class RealWordCorpusEvaluatorTest {
 
-  @Ignore
+  @Ignore("requires local ngram index")
   @Test
   public void testCheck() throws IOException {
-    RealWordCorpusEvaluator evaluator = new RealWordCorpusEvaluator();
+    RealWordCorpusEvaluator evaluator = new RealWordCorpusEvaluator(new File("/data/google-ngram-index/"));
     URL errors = RealWordCorpusEvaluatorTest.class.getResource("/org/languagetool/dev/eval");
     evaluator.run(new File(errors.getFile()));
     assertThat(evaluator.getSentencesChecked(), is(3));

File: languagetool-server/src/main/java/org/languagetool/server/HTTPServer.java
Patch:
@@ -102,6 +102,7 @@ public HTTPServer(HTTPServerConfig config, boolean runInternally, String host, S
       if (config.getMode() == HTTPServerConfig.Mode.AfterTheDeadline) {
         httpHandler.setAfterTheDeadlineMode(config.getAfterTheDeadlineLanguage());
       }
+      httpHandler.setLanguageModel(config.getLanguageModelDir());
       server.createContext("/", httpHandler);
       executorService = getExecutorService(workQueue, config);
       server.setExecutor(executorService);
@@ -128,7 +129,7 @@ public static void main(String[] args) {
       System.out.println("                 'afterTheDeadlineLanguage' - language code like 'en' or 'en-GB' (required if mode is 'AfterTheDeadline')");
       System.out.println("                 'maxTextLength' - maximum text length, longer texts will cause an error (optional)");
       System.out.println("                 'maxCheckTimeMillis' - maximum time in milliseconds allowed per check (optional)");
-      System.out.println("                 'maxCheckThreads' - maximum number of threads working in parallel (optional)");
+      printCommonConfigFileOptions();
       printCommonOptions();
       System.exit(1);
     }

File: languagetool-standalone/src/test/java/org/languagetool/rules/patterns/PerformanceTest.java
Patch:
@@ -39,6 +39,7 @@ private void run(JLanguageTool langTool, File textFile) throws IOException {
     String text = StringTools.readStream(new FileInputStream(textFile), "utf-8");
     int sentenceCount = langTool.sentenceTokenize(text).size();
     langTool.activateDefaultPatternRules();
+    //langTool.activateLanguageModelRules(new File("/data/google-ngram-index/"));
     System.out.println("Text length: " + text.length() + " chars, " + sentenceCount + " sentences");
 
     System.out.println("Warmup...");

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleXmlCreator.java
Patch:
@@ -116,8 +116,10 @@ private String nodeToString(Node node) {
       .replace("<and", "\n    <and")
       .replace("</and>", "\n    </and>")
       .replace("<phraseref", "\n    <phraseref")
+      .replace("<antipattern", "\n  <antipattern")
       .replace("<pattern", "\n  <pattern")
       .replace("</pattern", "\n  </pattern")
+      .replace("</antipattern", "\n  </antipattern")
       .replace("</rule>", "\n</rule>")
       .replace("<message", "\n  <message")
       .replace("<short", "\n  <short")

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -680,8 +680,10 @@ private boolean isLanguage(int i, AnalyzedTokenReadings[] tokens) {
     boolean maybeLanguage = languages.contains(token) ||
                             languages.contains(token.replaceFirst("e$", "")) ||  // z.B. "ins Japanische übersetzt"
                             languages.contains(token.replaceFirst("en$", ""));   // z.B. "im Japanischen"
+    AnalyzedTokenReadings prevToken = i > 0 ? tokens[i-1] : null;
     AnalyzedTokenReadings nextReadings = i < tokens.length-1 ? tokens[i+1] : null;
-    return nextReadings != null && !hasNounReading(nextReadings) && maybeLanguage;
+    return maybeLanguage && ((nextReadings != null && !hasNounReading(nextReadings)) ||
+                             (prevToken != null && prevToken.getToken().equals("auf")));
   }
 
   private boolean isExceptionPhrase(int i, AnalyzedTokenReadings[] tokens) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -148,6 +148,9 @@ public void testRule() throws IOException {
     assertGood("Übersetzt aus dem Norwegischen von Ingenieur Frederik Dingsbums.");
     assertGood("Dem norwegischen Ingenieur gelingt das gut.");
     assertBad("Dem Norwegischen Ingenieur gelingt das gut.");
+    assertGood("Peter Peterson, dessen Namen auf Griechisch Stein bedeutet.");
+    assertGood("Peter Peterson, dessen Namen auf Griechisch gut klingt.");
+    //assertBad("Peter Peterson, dessen Namen auf griechisch Stein bedeutet.");
   }
 
   private void assertGood(String input) throws IOException {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -69,6 +69,7 @@ public void testRule() throws IOException {
     assertGood("Er wird etwas schön Verrücktes träumen.");
     assertGood("Er wird etwas so Verrücktes träumen.");
     assertGood("Tom ist etwas über dreißig.");
+    assertGood("Diese Angriffe bleiben im Verborgenen.");
     assertBad("Tom ist etwas über Dreißig.");
     // "NIL" reading in Morphy that used to confuse CaseRule:
     assertGood("Ein Menschenfreund.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -567,6 +567,7 @@ private void potentiallyAddUppercaseMatch(List<RuleMatch> ruleMatches, AnalyzedT
         !exceptions.contains(token) &&
         !languages.contains(token) &&
         !languages.contains(token.replaceFirst("e$", "")) &&  // z.B. "ins Japanische übersetzt"
+        !languages.contains(token.replaceFirst("en$", "")) &&  // z.B. "im Japanischen"
         !GermanHelper.hasReadingOfType(analyzedToken, POSType.PROPER_NOUN) &&
         !analyzedToken.isSentenceEnd() &&
         !isEllipsis(i, tokens) &&

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/DateCheckFilter.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.Locale;
 
 /**
- * English localization of {@link AbstractDateCheckFilter}.
+ * Catalan localization of {@link AbstractDateCheckFilter}.
  * @since 2.7
  */
 public class DateCheckFilter extends AbstractDateCheckFilter {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -57,8 +57,11 @@
  */
 public class VerbAgreementRule extends GermanRule {
   
+  // Words that prevent a rule match when they occur directly before "bin":
   private static final Set<String> BIN_IGNORE = new HashSet<>(Arrays.asList(
     "al-Aziz",
+    "Asis",
+    "Numan",
     "Hussein",
     "Abdul",
     "Abdulla",

File: languagetool-language-modules/fa/src/main/java/org/languagetool/language/Persian.java
Patch:
@@ -94,6 +94,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
         new MultipleWhitespaceRule(messages, this),
         new LongSentenceRule(messages),
         // specific to Persian:
+        new PersianCommaWhitespaceRule(messages),
         new PersianWordRepeatBeginningRule(messages, this),
         new PersianWordRepeatRule(messages, this),
         new SimpleReplaceRule(messages),

File: languagetool-language-modules/fa/src/main/java/org/languagetool/language/Persian.java
Patch:
@@ -94,6 +94,7 @@ public List<Rule> getRelevantRules(ResourceBundle messages) throws IOException {
         new MultipleWhitespaceRule(messages, this),
         new LongSentenceRule(messages),
         // specific to Persian:
+        new PersianCommaWhitespaceRule(messages),
         new PersianWordRepeatBeginningRule(messages, this),
         new PersianWordRepeatRule(messages, this),
         new SimpleReplaceRule(messages),

File: languagetool-language-modules/fa/src/main/java/org/languagetool/rules/fa/PersianWordRepeatBeginningRule.java
Patch:
@@ -36,8 +36,8 @@ public class PersianWordRepeatBeginningRule extends WordRepeatBeginningRule {
   
   public PersianWordRepeatBeginningRule(final ResourceBundle messages, final Language language) {
     super(messages, language);
-    addExamplePair(Example.wrong("همچنین، خیابان تقریباً کاملاً مسکونی است. <marker>همچنین</marker>، به اغتخار یک شاعر نامگذاری شده‌است."),
-                   Example.fixed("همچنین، خیابان تقریباً مسکونی است. <marker>این خیابان</marker> به اغتخار یک شاعر نامگذاری شده‌است."));
+    addExamplePair(Example.wrong("همچنین، خیابان تقریباً کاملاً مسکونی است. <marker>همچنین</marker>، به افتخار یک شاعر نامگذاری شده‌است."),
+                   Example.fixed("همچنین، خیابان تقریباً مسکونی است. <marker>این خیابان</marker> به افتخار یک شاعر نامگذاری شده‌است."));
   }
   
   @Override

File: languagetool-language-modules/en/src/test/java/org/languagetool/tokenizers/EnglishSRXSentenceTokenizerTest.java
Patch:
@@ -22,7 +22,7 @@
 import org.languagetool.TestTools;
 import org.languagetool.language.English;
 
-public class SRXSentenceTokenizerTest extends TestCase {
+public class EnglishSRXSentenceTokenizerTest extends TestCase {
 
   // accept \n as paragraph:
   private final SentenceTokenizer stokenizer = new SRXSentenceTokenizer(new English());

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -81,6 +81,7 @@ public class CaseRule extends GermanRule {
      * solution is to add all those to our Morphy data, but as a simple
      * workaround to avoid false alarms, these words can be added here.
      */
+    exceptions.add("Üblichen");
     exceptions.add("Bekannter");
     exceptions.add("Bekannte");
     exceptions.add("Tel");  // Tel. = Telefon

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -205,7 +205,9 @@ else if (hasUnambiguouslyPersonAndNumber(tokens[i], "2", "SIN")) {
     if (posEr > 0 && !isNear(posPossibleVer3Sin, posEr) && !isQuotationMark(tokens[posEr-1])) {
       final int plus1 = ((posEr + 1) == tokens.length) ? 0 : +1;
       if (!verbDoesMatchPersonAndNumber(tokens[posEr-1], tokens[posEr+plus1], "3", "SIN") 
-              && !nextButOneIsModal(tokens, posEr) && !"äußerst".equals(finiteVerb.getToken())) {
+              && !nextButOneIsModal(tokens, posEr)
+              && !"äußerst".equals(finiteVerb.getToken())
+              && !"regen".equals(finiteVerb.getToken())) {  // "wo er regen Anteil nahm"
         ruleMatches.add(ruleMatchWrongVerbSubject(tokens[posEr], finiteVerb, "3:SIN"));
       }
     }

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -698,8 +698,8 @@ private void rememberUnknownWords(final AnalyzedSentence analyzedText) {
       final AnalyzedTokenReadings[] atr = analyzedText
           .getTokensWithoutWhitespace();
       for (final AnalyzedTokenReadings reading : atr) {
-      if (!reading.isTagged()) {
-        unknownWords.add(reading.getToken());
+        if (!reading.isTagged()) {
+          unknownWords.add(reading.getToken());
         }
       }
     }

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractCompoundRule.java
Patch:
@@ -106,6 +106,9 @@ public RuleMatch[] match(final AnalyzedSentence sentence) {
         addToQueue(token, prevTokens);
         continue;
       }
+      if (token.isImmunized()) {
+        continue;
+      }
 
       final StringBuilder sb = new StringBuilder();
       int j = 0;

File: languagetool-language-modules/ru/src/main/java/org/languagetool/rules/ru/RussianUnpairedBracketsRule.java
Patch:
@@ -26,8 +26,8 @@
 
 public class RussianUnpairedBracketsRule extends GenericUnpairedBracketsRule {
 
-    private static final String[] RU_START_SYMBOLS = {"(", "{", "„", "«", "\"", "'"};
-    private static final String[] RU_END_SYMBOLS = {")", "}", "“", "»", "\"", "'"};
+    private static final String[] RU_START_SYMBOLS = {"(", "{", "„",  "\"", "'"};
+    private static final String[] RU_END_SYMBOLS = {")", "}", "“", "\"", "'"};
     private static final Pattern NUMERALS_RU = Pattern.compile("(?i)\\d{1,2}?[а-я]*|[а-я]|[А-Я]|[а-я][а-я]|[А-Я][А-Я]|(?i)\\d{1,2}?[a-z']*|M*(D?C{0,3}|C[DM])(L?X{0,3}|X[LC])(V?I{0,3}|I[VX])$");
 
     public RussianUnpairedBracketsRule(final ResourceBundle messages,

File: languagetool-language-modules/ru/src/test/java/org/languagetool/rules/ru/RussianUnpairedBracketsRuleTest.java
Patch:
@@ -29,7 +29,7 @@
 
 public class RussianUnpairedBracketsRuleTest extends TestCase {
 
-  public void testRulePolish() throws IOException {
+  public void testRuleRussian() throws IOException {
     RussianUnpairedBracketsRule rule = new RussianUnpairedBracketsRule(TestTools
         .getEnglishMessages(), new Russian());
     RuleMatch[] matches;
@@ -49,7 +49,7 @@ public void testRulePolish() throws IOException {
     assertEquals(0, matches.length);
     // incorrect sentences:
     matches = rule.match(langTool
-        .getAnalyzedSentence("В таком ключе был начат в мае 1823 в Кишинёве роман в стихах «Евгений Онегин."));
+        .getAnalyzedSentence("В таком ключе был начат в мае 1823 в Кишинёве роман в стихах 'Евгений Онегин."));
     assertEquals(1, matches.length);
   }
   

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/ValencianCatalan.java
Patch:
@@ -47,7 +47,7 @@ public String getShortName() {
   public List<String> getDefaultEnabledRulesForVariant() {
     List<String> rules = Arrays.asList("EXIGEIX_VERBS_VALENCIANS",
         "EXIGEIX_ACCENTUACIO_VALENCIANA", "EXIGEIX_POSSESSIUS_U",
-        "EXIGEIX_VERBS_EIX", "EXIGEIX_VERBS_ISC", "PER_PER_A_INFINITIU");
+        "EXIGEIX_VERBS_EIX", "EXIGEIX_VERBS_ISC", "SERVIR_PER_TALLAR");
     return rules;
   }
 

File: languagetool-language-modules/pt/src/main/java/org/languagetool/tagging/pt/PortugueseTagger.java
Patch:
@@ -22,7 +22,7 @@
 
 import org.languagetool.tagging.BaseTagger;
 
-/** Galician Part-of-speech tagger.
+/** Portuguese Part-of-speech tagger.
  * Based on English tagger.
  *
  * @author Marcin Milkowski

File: languagetool-core/src/main/java/org/languagetool/rules/WordRepeatRule.java
Patch:
@@ -90,7 +90,9 @@ public RuleMatch[] match(final AnalyzedSentence sentence) {
   // avoid "..." etc. to be matched:
   private boolean isWord(String token) {
     boolean isWord = true;
-    if (token.length() == 1) {
+    if (token.length() == 0) {
+      isWord = false;
+    } else if (token.length() == 1) {
       final char c = token.charAt(0);
       if (!Character.isLetter(c)) {
         isWord = false;

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -486,7 +486,7 @@ private Set<String> getAgreementCategories(final AnalyzedTokenReadings aToken, S
     final Set<String> set = new HashSet<>();
     final List<AnalyzedToken> readings = aToken.getReadings();
     for (AnalyzedToken tmpReading : readings) {
-      if (skipSol && tmpReading.getPOSTag().endsWith(":SOL")) {
+      if (skipSol && tmpReading.getPOSTag() != null && tmpReading.getPOSTag().endsWith(":SOL")) {
         // SOL = alleinstehend - needs to be skipped so we find errors like "An der roter Ampel."
         continue;
       }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -373,6 +373,8 @@ public class CaseRule extends GermanRule {
     myExceptionPhrases.add("aus dem Nichts");
     myExceptionPhrases.add("Kleiner Bär");   // das Sternbild
     myExceptionPhrases.add("Zehn Gebote");
+    myExceptionPhrases.add("Heiliges Römisches Reich");
+    myExceptionPhrases.add("Heilige Römische Reich");
     myExceptionPhrases.add("Römische Reich Deutscher Nation");
     myExceptionPhrases.add("ein absolutes Muss");
     myExceptionPhrases.add("ein Muss");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -657,13 +657,14 @@ private boolean isExceptionPhrase(int i, AnalyzedTokenReadings[] tokens) {
     return false;
   }
 
-  private boolean compareLists(AnalyzedTokenReadings[] tokens, int startIndex, int endIndex, String[] parts) {
+  // non-private for tests
+  boolean compareLists(AnalyzedTokenReadings[] tokens, int startIndex, int endIndex, String[] parts) {
     if (startIndex < 0) {
       return false;
     }
     int i = 0;
     for (int j = startIndex; j <= endIndex; j++) {
-      if (i >= parts.length) {
+      if (i >= parts.length || j >= tokens.length) {
         return false;
       }
       if (!tokens[j].getToken().equals(parts[i])) {

File: languagetool-commandline/src/main/java/org/languagetool/commandline/Main.java
Patch:
@@ -178,7 +178,6 @@ private void runOnFile(final String filename, final String encoding,
 
   private void runOnFileInOneGo(String filename, String encoding, boolean listUnknownWords, boolean xmlFiltering) throws IOException {
     if (bitextMode) {
-      //TODO: add parameter to set different readers
       final TabBitextReader reader = new TabBitextReader(filename, encoding);
       if (applySuggestions) {
         CommandLineTools.correctBitext(reader, srcLt, lt, bRules);
@@ -547,7 +546,6 @@ private static void printLanguages() {
   }
 
   // for language auto detect
-  // TODO: alter tika's language profiles so they are in line with LT's supported languages
   private static Language detectLanguageOfFile(final String filename, final String encoding) throws IOException {
     final String text = StringTools.readStream(new FileInputStream(filename), encoding);
     return detectLanguageOfString(text);

File: languagetool-language-modules/de/src/main/java/org/languagetool/tagging/de/AnalyzedGermanToken.java
Patch:
@@ -61,8 +61,6 @@ private void init() {
     }
     final String[] parts = getPOSTag().split(":");
     if (parts.length < 3) {
-      //FIXME ??
-      //System.err.println(posTagString);
       return;
     }
     

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -216,7 +216,7 @@ public void testDetNounRuleErrorMessages() throws IOException {
     assertBadWithMessage("Die Tischen sind ecking.", "bezüglich Kasus");
     assertBadWithMessage("Die Tischen sind ecking.", "und Genus");
     //TODO: input is actually correct
-    assertBadWithMessage("Bei dem Papierabzüge von Digitalbildern bestellte werden.", "bezüglich Kasus, Genus oder Numerus.");
+    assertBadWithMessage("Bei dem Papierabzüge von Digitalbildern bestellt werden.", "bezüglich Kasus, Genus oder Numerus.");
   }
   
   public void testRegression() throws IOException {

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -136,7 +136,7 @@ public void testRule() throws IOException {
     assertCorrect("fins i tot us vendríeu un amic");
     assertCorrect("ens hem esforçat molt per venir-vos a veure");
     assertCorrect("Un altre dia s'anava a l'Ermita i un tercer dia se solia anar a altres indrets de caràcter comarcal.");
-    assertCorrect("La Nit de sant Joan es baixaven falles de la muntanya."); //solucions: marcar "la nit..." com a CC o comprovar la concordança subj/verb
+    assertCorrect("La nit de sant Joan es baixaven falles de la muntanya."); //solucions: marcar "la nit..." com a CC o comprovar la concordança subj/verb
     assertCorrect("que no pertanyen a ells mateixos es cau en una contradicció.");
     assertCorrect("Els salts els fan impulsant-se amb les cames");
     assertCorrect("Zheng, adonant-se que gairebé totes les forces singaleses");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -67,6 +67,8 @@ public void testRule() throws IOException {
     assertGood("Er wird etwas Verrücktes träumen.");
     assertGood("Er wird etwas schön Verrücktes träumen.");
     assertGood("Er wird etwas so Verrücktes träumen.");
+    assertGood("Tom ist etwas über dreißig.");
+    assertBad("Tom ist etwas über Dreißig.");
     // "NIL" reading in Morphy that used to confuse CaseRule:
     assertGood("Ein Menschenfreund.");
     // works only thanks to addex.txt:

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -172,7 +172,8 @@ private GrammarCategory(String displayName) {
     "was",
     "wer",
     "jenen",      // "...und mit jenen anderer Arbeitsgruppen verwoben"
-    "diejenigen"
+    "diejenigen",
+    "niemand"
   ));
   
   private static final Set<String> NOUNS_TO_BE_IGNORED = new HashSet<>(Arrays.asList(

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/TextConverter.java
Patch:
@@ -209,7 +209,7 @@ public void visit(XmlCharRef cr) {
   public void visit(XmlEntityRef er) {
     addMapping(er);
     if ("nbsp".equals(er.getName())) {
-      write(' ');
+      write('\u00A0');  // non-breaking space
     } else {
       String ch = StringEscapeUtils.unescapeHtml("&" + er.getName() + ";");
       write(ch);

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/wikipedia/WikipediaQuickCheckTest.java
Patch:
@@ -82,7 +82,7 @@ public void testGetPlainText() {
                     "</normalized><pages><page pageid=\"143424\" ns=\"3\" title=\"Benutzer Diskussion:Dnaber\"><revisions><rev xml:space=\"preserve\">\n" +
                     "Test [[Link]] Foo&amp;nbsp;bar.\n" +
                     "</rev></revisions></page></pages></query></api>");
-    assertEquals("Test Link Foo bar.", filteredContent);
+    assertEquals("Test Link Foo\u00A0bar.", filteredContent);
   }
 
   public void testGetPlainTextMapping() {
@@ -94,7 +94,7 @@ public void testGetPlainTextMapping() {
                     text +
                     "</rev></revisions></page></pages></query></api>");
 
-    assertEquals("Test Link und noch einer und external link Foo bar.", filteredContent.getPlainText());
+    assertEquals("Test Link und noch einer und external link Foo\u00A0bar.", filteredContent.getPlainText());
     assertEquals(1, filteredContent.getOriginalTextPositionFor(1).line);
     assertEquals(1, filteredContent.getOriginalTextPositionFor(1).column);
     assertEquals(filteredContent.getPlainText().charAt(0), text.charAt(0));

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/wikipedia/WikipediaTextFilterTest.java
Patch:
@@ -43,7 +43,7 @@ public void testLink2() throws Exception {
   }
 
   public void testEntity() throws Exception {
-    assertExtract("rund 20&nbsp;Kilometer südlich", "rund 20 Kilometer südlich");
+    assertExtract("rund 20&nbsp;Kilometer südlich", "rund 20\u00A0Kilometer südlich");
     assertExtract("one&lt;br/&gt;two", "one<br/>two");
     assertExtract("one &ndash; two", "one – two");
     assertExtract("one &mdash; two", "one — two");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -58,6 +58,7 @@
 public class VerbAgreementRule extends GermanRule {
   
   private static final Set<String> BIN_IGNORE = new HashSet<>(Arrays.asList(
+    "Hussein",
     "Abdul",
     "Abdulla",
     "Abdullah",

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/CatalanWordRepeatRule.java
Patch:
@@ -40,7 +40,7 @@ public String getId() {
 
   @Override
   public boolean ignore(AnalyzedTokenReadings[] tokens, int position) {
-    if (position > 0 && (tokens[position].isImmunized() || tokens[position-1].isImmunized())) {
+    if (position > 0 && (tokens[position].hasPosTag("_allow_repeat") || tokens[position-1].hasPosTag("_allow_repeat"))) {
       return true;
     }
     return false;

File: languagetool-language-modules/sv/src/main/java/org/languagetool/rules/sv/CompoundRule.java
Patch:
@@ -34,9 +34,9 @@ public class CompoundRule extends AbstractCompoundRule {
 
   public CompoundRule(final ResourceBundle messages) throws IOException {
     super(messages, FILE_NAME,
-            "Dessa ord skrivs samman med bindesträck.",
+            "Dessa ord skrivs samman med bindestreck.",
             "Dessa ord skrivs samman.",
-            "Dessa ord skrivs samman med eller utan bindesträck.");
+            "Dessa ord skrivs samman med eller utan bindestreck.");
   }
 
   @Override

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -42,6 +42,7 @@ public void setUp() throws IOException {
   public void testRule() throws IOException {
 
     // correct sentences:
+    //assertCorrect("A ponent continua la serra de Fontpobra");
     assertCorrect("M'espero qualsevol cosa.");
     assertCorrect("Carrega de nou l'arxiu.");
     assertCorrect("Espero d'ell moltes coses");
@@ -86,6 +87,7 @@ public void testRule() throws IOException {
 
     // errors:
     assertIncorrect("De positiva influencia en ell.");
+    assertIncorrect("tren de llarga distancia");
 //    assertIncorrect("com la nostra pròpia desgracia");
 //  assertIncorrect("la seva influencia");
     assertIncorrect("Cal una nova formula que substitueixi el caduc Estat del benestar.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -101,7 +101,8 @@ private GrammarCategory(String displayName) {
     "weniger",
     "einige",
     "einiger",
-    "mehrerer"
+    "mehrerer",
+    "mehrere"
   ));
   
   private static final Set<String> REL_PRONOUN = new HashSet<>();
@@ -143,6 +144,7 @@ private GrammarCategory(String displayName) {
 
   private static final Set<String> PRONOUNS_TO_BE_IGNORED = new HashSet<>(Arrays.asList(
     "ich",
+    "dir",
     "du",
     "er", "sie", "es",
     "wir",

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -155,6 +155,7 @@ private GrammarCategory(String displayName) {
     "ihn",
     "dessen",
     "deren",
+    "denen",
     "sich",
     "unser",
     "aller",

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -72,6 +72,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Die erwähnte Konferenz ist am Samstag.");
     assertGood("Sie erreichten 5 Prozent.");
     assertGood("Sie erreichten mehrere Prozent Zustimmung.");
+    assertGood("Die Bestandteile, aus denen Schwefel besteht.");
 
     assertGood("Das Dach von meinem Auto.");
     assertGood("Das Dach von meinen Autos.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -520,7 +520,7 @@ private boolean hasNounReading(AnalyzedTokenReadings readings) {
   private void potentiallyAddLowercaseMatch(List<RuleMatch> ruleMatches, AnalyzedTokenReadings tokenReadings, boolean prevTokenIsDas, String token, boolean nextTokenIsPersonalPronoun) {
     if (prevTokenIsDas && !nextTokenIsPersonalPronoun) {
       // e.g. essen -> Essen
-      if (Character.isLowerCase(token.charAt(0)) && !substVerbenExceptions.contains(token)) {
+      if (Character.isLowerCase(token.charAt(0)) && !substVerbenExceptions.contains(token) && tokenReadings.hasPartialPosTag("VER:INF")) {
         final String msg = "Substantivierte Verben werden großgeschrieben.";
         final RuleMatch ruleMatch = new RuleMatch(this, tokenReadings.getStartPos(),
             tokenReadings.getStartPos() + token.length(), msg);

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -162,6 +162,7 @@ public void testSubstantivierteVerben() throws IOException {
     assertGood("Das haben wir schon.");
     assertGood("Das lesen sie doch sicher in einer Minute durch.");
     assertGood("Das lesen Sie doch sicher in einer Minute durch!");
+    assertGood("Formationswasser, das oxidiert war.");
 
     // Source of the following examples: http://www.canoo.net/services/GermanSpelling/Amtlich/GrossKlein/pgf57-58.html
     assertGood("Das Lesen fällt mir schwer.");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -419,6 +419,7 @@ public class CaseRule extends GermanRule {
     substVerbenExceptions.add("bestätigte");
     substVerbenExceptions.add("bestätigten");
     substVerbenExceptions.add("bekommen");
+    substVerbenExceptions.add("sauer");
   }
   
   public CaseRule(final ResourceBundle messages, final German german) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -70,6 +70,8 @@ public void testDetNounRule() throws IOException {
     assertGood("Und nach der Nummerierung kommt die Überschrift.");
     assertGood("Sie wiesen dieselben Verzierungen auf.");
     assertGood("Die erwähnte Konferenz ist am Samstag.");
+    assertGood("Sie erreichten 5 Prozent.");
+    assertGood("Sie erreichten mehrere Prozent Zustimmung.");
 
     assertGood("Das Dach von meinem Auto.");
     assertGood("Das Dach von meinen Autos.");

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleMatcher.java
Patch:
@@ -32,7 +32,7 @@
 import java.util.List;
 
 /**
- * Matches a pattern rule against plain text.
+ * Matches a pattern rule against text.
  */
 class PatternRuleMatcher extends AbstractPatternRulePerformer {
 

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -89,7 +89,7 @@ public void testRule() throws IOException {
     assertIncorrect("Porta-la i nosaltres fem la copia i la compulsem.");
     assertIncorrect("Carrega d'arxius.");
     assertIncorrect("Vaig arribar a fer una radio que no va funcionar mai.");
-    assertIncorrect("No em fumaré cap faria com feia abans.");
+    assertIncorrect("No em fumaré una faria com feia abans.");
     assertIncorrect("M'he fumat una faria.");
     assertIncorrect("Les seues contraries.");
     assertIncorrect("Amb renuncies i esforç.");

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tagging/fr/FrenchTagger.java
Patch:
@@ -38,5 +38,6 @@ public final String getFileName() {
   public FrenchTagger() {
     super();
     setLocale(Locale.FRENCH);
+    dontTagLowercaseWithUppercase();
   }
 }

File: languagetool-language-modules/fr/src/main/java/org/languagetool/tagging/fr/FrenchTagger.java
Patch:
@@ -24,7 +24,7 @@
 
 /** French Tagger
  * 
- * Based on Dicollete (http://www.dicollecte.org/) implemented in FSA.
+ * Based on Dicollecte (http://www.dicollecte.org/) implemented in FSA.
  * 
  * @author Marcin Milkowski
  */

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -901,7 +901,8 @@ public List<Rule> getAllActiveRules() {
     // to keep the state information if we're checking a continuous text.    
     for (final Rule rule : rules) {
       rule.reset();
-      if (!disabledRules.contains(rule.getId())) {
+      boolean isDisabled = disabledRules.contains(rule.getId()) || (rule.isDefaultOff() && !enabledRules.contains(rule.getId()));
+      if (!isDisabled) {
         rulesActive.add(rule);
       }
     }    

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementSuggestorTest.java
Patch:
@@ -19,9 +19,9 @@
 package org.languagetool.rules.de;
 
 import org.junit.Test;
+import org.languagetool.AnalyzedToken;
 import org.languagetool.AnalyzedTokenReadings;
 import org.languagetool.language.German;
-import org.languagetool.tagging.de.AnalyzedGermanToken;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -49,7 +49,7 @@ private void assertSuggestion(String input, String expectedSuggestions) {
       String token = parts[0];
       String lemma = parts[1];
       String posTag = parts[2];
-      tokenReadings.add(new AnalyzedTokenReadings(new AnalyzedGermanToken(token, posTag, lemma), pos++));
+      tokenReadings.add(new AnalyzedTokenReadings(new AnalyzedToken(token, posTag, lemma), pos++));
     }
     if (tokenReadings.size() != 2) {
       throw new RuntimeException("Size of input not yet supported: " + tokenReadings.size());

File: languagetool-dev/src/main/java/org/languagetool/dev/eval/AfterTheDeadlineEvaluator.java
Patch:
@@ -116,8 +116,8 @@ private String removeMarker(String sentence) {
     return sentence.replace("<marker>", "").replace("</marker>", "");
   }
 
-  private String getContent(URL wikipediaUrl) throws IOException {
-    final InputStream contentStream = (InputStream) wikipediaUrl.getContent();
+  private String getContent(URL url) throws IOException {
+    final InputStream contentStream = (InputStream) url.getContent();
     return StringTools.streamToString(contentStream, "UTF-8");
   }
 

File: languagetool-core/src/test/java/org/languagetool/MultiThreadedJLanguageToolTest.java
Patch:
@@ -43,7 +43,7 @@ public void testCheck() throws IOException {
     
     tool = new MultiThreadedJLanguageTool(new Demo());
     final List<String> ruleMatchIds1 = getRuleMatchIds(tool);
-    assertTrue(ruleMatchIds1.size() >= 10);
+    assertTrue(ruleMatchIds1.size() == 10);
     Assert.assertEquals(4, tool.getSentenceCount());
     
     tool = new JLanguageTool(new Demo());

File: languagetool-standalone/src/main/java/org/languagetool/gui/Main.java
Patch:
@@ -173,6 +173,7 @@ private void showOptions() {
     } catch (IOException e) {
       Tools.showError(e);
     }
+    ltSupport.reloadConfig();
     // Stop server, start new server if requested:
     stopServer();
     maybeStartServer();

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRule.java
Patch:
@@ -95,7 +95,7 @@ public class ComplexAdjectiveConcordanceRule extends CatalanRule {
   private static final Pattern UPPERCASE = Pattern.compile("\\p{Lu}[\\p{Ll}\u00B7]*");
   private static final Pattern COORDINACIO = Pattern.compile(",|i|o");
   private static final Pattern COORDINACIO_IONI = Pattern.compile("i|o|ni");
-  private static final Pattern KEEP_COUNT = Pattern.compile("A.*|N.*|D[NAIDP].*|SPS.*|.*LOC_ADV.*|V.P.*|_PUNCT.*|.*LOC_ADJ.*|PX.*|complement");
+  private static final Pattern KEEP_COUNT = Pattern.compile("A.*|N.*|D[NAIDP].*|SPS.*|.*LOC_ADV.*|V.P.*|_PUNCT.*|.*LOC_ADJ.*|PX.*");
   private static final Pattern KEEP_COUNT2 = Pattern.compile(",|i|o|ni"); //|\\d+%?|%
   private static final Pattern STOP_COUNT = Pattern.compile(";");
   private static final Pattern PREPOSICIONS = Pattern.compile("SPS.*");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -93,7 +93,7 @@ public void testRule() throws IOException {
     assertCorrect("La part superior esquerra");
     assertCorrect("I sí, la crisi serà llarga, molt llarga, potser eterna.");
     assertCorrect("El rei ha trobat l'excusa i l'explicació adequada.");
-    assertCorrect("té una manera de jugar aquestes gires tan femenina");
+    //assertCorrect("té una manera de jugar aquestes gires tan femenina");
     assertCorrect("des de la tradicional divisió en dos regnes establida per Linnaeus");
     assertCorrect("aquestes activitats avui residuals donada ja la manca de territori");
     assertCorrect("instruments de càlcul basats en boles anomenats yupana.");
@@ -155,6 +155,7 @@ public void testRule() throws IOException {
     assertCorrect("Era un home força misteriós");
 
     // errors:
+    assertIncorrect("La petició de tramitar el cas per lesions dolosa.");
     // policia i justícia són més usualment femenins, encara que poden ser masculins
     assertIncorrect("Especialment en matèria de policia i justícia autonòmics");
     assertIncorrect("amb rigor i honor barrejades.");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -58,6 +58,7 @@ public void testRule() throws IOException {
      * exterminades
      */
     // (en especial si hi ha un adverbi entremig: en algun grau més distintes
+    assertCorrect("En l'eix esquerra-dreta.");
     assertCorrect("podrien també esdevenir correlacionades"); 
     assertCorrect("Cada polinomi en forma expandida");
     assertCorrect("El 1967 una partida de liberals rebel al govern");

File: languagetool-dev/src/main/java/org/languagetool/dev/eval/RealWordCorpusEvaluator.java
Patch:
@@ -72,7 +72,9 @@ int getRealErrorsFound() {
 
   void run(File dir) throws IOException {
     File[] files = dir.listFiles();
-    //noinspection ConstantConditions
+    if (files == null) {
+      throw new RuntimeException("Directory not found: " + dir);
+    }
     for (File file : files) {
       if (!file.getName().endsWith(".txt")) {
         System.out.println("Ignoring " + file + ", does not match *.txt");

File: languagetool-dev/src/main/java/org/languagetool/dev/RuleActivityOverview.java
Patch:
@@ -35,7 +35,7 @@
 
 /**
  * Command line tool to list activity for grammar files. Requires a typical developer setup,
- * i.e. a local "svn" command and the sources checked out from SVN. 
+ * i.e. a local "git" command and the sources cloned from git. 
  * 
  * @author Daniel Naber
  */

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternTestTools.java
Patch:
@@ -101,7 +101,8 @@ public static void warnIfRegexpSyntaxNotKosher(final List<Element> elements,
                 && element.isInflected()   == false 
                 && exception.getNegation() == false
                 && exception.isInflected() == false
-                && element.getSkipNext() == 0) {
+                && element.getSkipNext() == 0
+                && element.isCaseSensitive() == exception.isCaseSensitive()) {
 
                 if (exception.isRegularExpression()) {
                   if (element.isRegularExpression()) {

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageToolSupport.java
Patch:
@@ -186,6 +186,7 @@ private void warmUpChecker() {
   ConfigurationDialog getCurrentConfigDialog() {
     Language language = this.currentLanguage;
     final ConfigurationDialog configDialog;
+    this.config.setLanguage(language);
     if (configDialogs.containsKey(language)) {
       configDialog = configDialogs.get(language);
     } else {

File: languagetool-language-modules/pl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -113,10 +113,10 @@ public void testPolish() throws IOException {
         "unify_adj_subst:2 dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos] -> dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos]\n" +
             "\n" +
             "unify_adj_subst:2 buty[but/subst:pl:acc:m2,but/subst:pl:acc:m3,but/subst:pl:nom:m2,but/subst:pl:nom:m3,but/subst:pl:voc:m2,but/subst:pl:voc:m3,buta/subst:pl:acc:f,buta/subst:pl:nom:f,buta/subst:pl:voc:f,buta/subst:sg:gen:f] -> buty[but/subst:pl:acc:m2,but/subst:pl:acc:m3,but/subst:pl:nom:m2,but/subst:pl:nom:m3,but/subst:pl:voc:m2,but/subst:pl:voc:m3,buta/subst:pl:acc:f,buta/subst:pl:nom:f,buta/subst:pl:voc:f]\n" +
-            "SUBST_NOM_VOC_VERB:3 buty[but/subst:pl:acc:m2,but/subst:pl:acc:m3,but/subst:pl:nom:m2,but/subst:pl:nom:m3,but/subst:pl:voc:m2,but/subst:pl:voc:m3,buta/subst:pl:acc:f,buta/subst:pl:nom:f,buta/subst:pl:voc:f] -> buty[but/subst:pl:nom:m2,but/subst:pl:nom:m3,buta/subst:pl:nom:f]\n" +
+            "SUBST_NOM_VOC_VERB:5 buty[but/subst:pl:acc:m2,but/subst:pl:acc:m3,but/subst:pl:nom:m2,but/subst:pl:nom:m3,but/subst:pl:voc:m2,but/subst:pl:voc:m3,buta/subst:pl:acc:f,buta/subst:pl:nom:f,buta/subst:pl:voc:f] -> buty[but/subst:pl:nom:m2,but/subst:pl:nom:m3,buta/subst:pl:nom:f]\n" +
             "\n" +
             "ppas_jest:1 są[być/verb:fin:pl:ter:imperf:nonrefl] -> są[być/verb:fin:pl:ter:imperf:nonrefl]\n" +
-            "SUBST_NOM_VOC_VERB:3 są[być/verb:fin:pl:ter:imperf:nonrefl] -> są[być/verb:fin:pl:ter:imperf:nonrefl]\n" +
+            "SUBST_NOM_VOC_VERB:5 są[być/verb:fin:pl:ter:imperf:nonrefl] -> są[być/verb:fin:pl:ter:imperf:nonrefl]\n" +
             "BYC_ADJ_ACC_NOM:1 są[być/verb:fin:pl:ter:imperf:nonrefl] -> są[być/verb:fin:pl:ter:imperf:nonrefl]\n" +
             "\n" +
             "ppas_jest:1 wskazane[wskazany/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,wskazany/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,wskazany/adj:sg:acc:n1.n2:pos,wskazany/adj:sg:nom.voc:n1.n2:pos,wskazać/ppas:pl:nom.acc.voc:m2.m3.f.n1.n2.p2.p3:perf:aff,wskazać/ppas:sg:nom.acc.voc:n1.n2:perf:aff] -> wskazane[wskazać/ppas:pl:nom.acc.voc:m2.m3.f.n1.n2.p2.p3:perf:aff]\n" +

File: languagetool-language-modules/pl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -108,10 +108,10 @@ public void testPolish() throws IOException {
         "PREP_SUBST:8 pogody[pogoda/subst:pl:acc:f,pogoda/subst:pl:nom:f,pogoda/subst:pl:voc:f,pogoda/subst:sg:gen:f] -> pogody[pogoda/subst:sg:gen:f]\n" +
         "\n" +
         "WIELKI_SWOJ_ADJ:1 dobre[dobre/subst:pl:acc:n2,dobre/subst:pl:nom:n2,dobre/subst:pl:voc:n2,dobre/subst:sg:acc:n2,dobre/subst:sg:nom:n2,dobre/subst:sg:voc:n2,dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos,dobry/depr:pl:nom:m2,dobry/depr:pl:voc:m2,dobry/subst:pl:acc:m3,dobry/subst:pl:nom:m3,dobry/subst:pl:voc:m3] -> dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos]\n" +
-        "unify_adj_subst:2 dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos] -> dobre[dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos]\n" +
+        "unify_adj_subst:1 dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos] -> dobre[dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos]\n" +
         "\n" +
         "SUBST_NOM_VOC_VERB:3 buty[but/subst:pl:acc:m2,but/subst:pl:acc:m3,but/subst:pl:nom:m2,but/subst:pl:nom:m3,but/subst:pl:voc:m2,but/subst:pl:voc:m3,buta/subst:pl:acc:f,buta/subst:pl:nom:f,buta/subst:pl:voc:f,buta/subst:sg:gen:f] -> buty[but/subst:pl:nom:m2,but/subst:pl:nom:m3,buta/subst:pl:nom:f]\n" +
-            "unify_adj_subst:2 buty[but/subst:pl:nom:m2,but/subst:pl:nom:m3,buta/subst:pl:nom:f] -> buty[but/subst:pl:nom:m2,but/subst:pl:nom:m3,buta/subst:pl:nom:f]\n" +
+            "unify_adj_subst:1 buty[but/subst:pl:nom:m2,but/subst:pl:nom:m3,buta/subst:pl:nom:f] -> buty[but/subst:pl:nom:m2,but/subst:pl:nom:m3,buta/subst:pl:nom:f]\n" +
             "\n" +
             "ppas_jest:1 są[być/verb:fin:pl:ter:imperf:nonrefl] -> są[być/verb:fin:pl:ter:imperf:nonrefl]\n" +
             "SUBST_NOM_VOC_VERB:3 są[być/verb:fin:pl:ter:imperf:nonrefl] -> są[być/verb:fin:pl:ter:imperf:nonrefl]\n" +

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/AbstractPatternRulePerformer.java
Patch:
@@ -147,15 +147,15 @@ protected boolean testUnificationAndGroups(final boolean matched, final boolean
             thisMatched = unifier.isUnified(matchToken,
                 elem.getUniFeatures(), lastReading,
                 elemIsMatched);
+            if (thisMatched && rule.isGetUnified()) {
+              unifiedTokens = unifier.getFinalUnified();
+            }
           } else { // we don't care about the truth value, let it run
             unifier.isUnified(matchToken,
                 elem.getUniFeatures(), lastReading,
                 elemIsMatched);
           }
         }
-        if (thisMatched && rule.isGetUnified()) {
-          unifiedTokens = unifier.getFinalUnified();
-        }
       }
       if (!elem.isUnified()) {
         unifier.reset();

File: languagetool-language-modules/pl/src/main/java/org/languagetool/rules/pl/MorfologikPolishSpellerRule.java
Patch:
@@ -20,6 +20,7 @@
 
 import org.languagetool.AnalyzedTokenReadings;
 import org.languagetool.Language;
+import org.languagetool.rules.Category;
 import org.languagetool.rules.Example;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.rules.spelling.morfologik.MorfologikSpellerRule;
@@ -87,6 +88,7 @@ public final class MorfologikPolishSpellerRule extends MorfologikSpellerRule {
   public MorfologikPolishSpellerRule(ResourceBundle messages,
                                      Language language) throws IOException {
     super(messages, language);
+    setCategory(new Category("Prawdopodobne literówki"));
     addExamplePair(Example.wrong("To jest zdanie z <marker>bledem</marker>"),
                    Example.fixed("To jest zdanie z <marker>błędem</marker>."));
   }

File: languagetool-language-modules/pl/src/main/java/org/languagetool/rules/pl/SimpleReplaceRule.java
Patch:
@@ -25,6 +25,7 @@
 
 import org.apache.commons.lang.StringUtils;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
+import org.languagetool.rules.Category;
 import org.languagetool.rules.Example;
 import org.languagetool.rules.ITSIssueType;
 
@@ -53,6 +54,7 @@ public final String getFileName() {
   public SimpleReplaceRule(final ResourceBundle messages) throws IOException {
     super(messages);
     setLocQualityIssueType(ITSIssueType.Misspelling);
+    setCategory(new Category("Prawdopodobne literówki"));
     setCheckLemmas(false);
     addExamplePair(Example.wrong("Uspokój <marker>sei</marker>."),
                    Example.fixed("Uspokój <marker>się</marker>."));
@@ -65,7 +67,7 @@ public final String getId() {
 
   @Override
   public String getDescription() {
-    return "Typowe literówki";
+    return "Typowe literówki i niepoprawne wyrazy (domowi, sie, niewiadomo, duh, cie…)";
   }
 
   @Override

File: languagetool-standalone/src/main/java/org/languagetool/dev/RealWordCorpusEvaluator.java
Patch:
@@ -40,7 +40,7 @@
  * <pre>
  * 673 lines checked.
  * 132 errors found that are marked as errors in the corpus (this does not count whether LanguageTool's correction was perfect)
- * => 19,61% recall
+ * => 19,91% recall
  * </pre>
  * 
  * <p>After the Deadline has a recall of 27.1% ("The Design of a Proofreading Software Service"), even
@@ -123,8 +123,8 @@ private ErrorSentence getIncorrectSentence(String line) {
     int startPos = 0;
     while (normalized.indexOf("<ERR targ=", startPos) != -1) {
       int startTagStart = normalized.indexOf("<ERR targ=", startPos);
-      int startTagEnd = normalized.indexOf(">", startPos + startTagStart);
-      int endTagStart = normalized.indexOf("</ERR>", startPos + startTagStart);
+      int startTagEnd = normalized.indexOf(">", startTagStart);
+      int endTagStart = normalized.indexOf("</ERR>", startTagStart);
       errors.add(new Error(startTagEnd + 1, endTagStart));
       startPos = startTagStart + 1;
     }

File: languagetool-language-modules/pl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -108,10 +108,10 @@ public void testPolish() throws IOException {
         "PREP_SUBST:8 pogody[pogoda/subst:pl:acc:f,pogoda/subst:pl:nom:f,pogoda/subst:pl:voc:f,pogoda/subst:sg:gen:f] -> pogody[pogoda/subst:sg:gen:f]\n" +
         "\n" +
         "WIELKI_SWOJ_ADJ:1 dobre[dobre/subst:pl:acc:n2,dobre/subst:pl:nom:n2,dobre/subst:pl:voc:n2,dobre/subst:sg:acc:n2,dobre/subst:sg:nom:n2,dobre/subst:sg:voc:n2,dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos,dobry/depr:pl:nom:m2,dobry/depr:pl:voc:m2,dobry/subst:pl:acc:m3,dobry/subst:pl:nom:m3,dobry/subst:pl:voc:m3] -> dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos]\n" +
-        "unify_adj_subst:1 dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos] -> dobre[dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos]\n" +
+        "unify_adj_subst:2 dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos] -> dobre[dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos]\n" +
         "\n" +
         "SUBST_NOM_VOC_VERB:3 buty[but/subst:pl:acc:m2,but/subst:pl:acc:m3,but/subst:pl:nom:m2,but/subst:pl:nom:m3,but/subst:pl:voc:m2,but/subst:pl:voc:m3,buta/subst:pl:acc:f,buta/subst:pl:nom:f,buta/subst:pl:voc:f,buta/subst:sg:gen:f] -> buty[but/subst:pl:nom:m2,but/subst:pl:nom:m3,buta/subst:pl:nom:f]\n" +
-            "unify_adj_subst:1 buty[but/subst:pl:nom:m2,but/subst:pl:nom:m3,buta/subst:pl:nom:f] -> buty[but/subst:pl:nom:m2,but/subst:pl:nom:m3,buta/subst:pl:nom:f]\n" +
+            "unify_adj_subst:2 buty[but/subst:pl:nom:m2,but/subst:pl:nom:m3,buta/subst:pl:nom:f] -> buty[but/subst:pl:nom:m2,but/subst:pl:nom:m3,buta/subst:pl:nom:f]\n" +
             "\n" +
             "ppas_jest:1 są[być/verb:fin:pl:ter:imperf:nonrefl] -> są[być/verb:fin:pl:ter:imperf:nonrefl]\n" +
             "SUBST_NOM_VOC_VERB:3 są[być/verb:fin:pl:ter:imperf:nonrefl] -> są[być/verb:fin:pl:ter:imperf:nonrefl]\n" +

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -42,6 +42,7 @@ public void setUp() throws IOException {
   public void testRule() throws IOException {
 
     // correct sentences:
+    assertCorrect("M'espero qualsevol cosa.");
     assertCorrect("Carrega de nou l'arxiu.");
     assertCorrect("Espero d'ell moltes coses");
     assertCorrect("cal que abans figuri inscrit en l'Ordre del dia");

File: languagetool-language-modules/pl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -105,7 +105,7 @@ public void testPolish() throws IOException {
 
         "MULTIWORD_CHUNKER: powodu[powód/subst:sg:gen:m3] -> powodu[powód/subst:sg:gen:m3,Z powodu/</PREP:GEN>]\n" +
         "\n" +
-        "PREP_SUBST:7 pogody[pogoda/subst:pl:acc:f,pogoda/subst:pl:nom:f,pogoda/subst:pl:voc:f,pogoda/subst:sg:gen:f] -> pogody[pogoda/subst:sg:gen:f]\n" +
+        "PREP_SUBST:8 pogody[pogoda/subst:pl:acc:f,pogoda/subst:pl:nom:f,pogoda/subst:pl:voc:f,pogoda/subst:sg:gen:f] -> pogody[pogoda/subst:sg:gen:f]\n" +
         "\n" +
         "WIELKI_SWOJ_ADJ:1 dobre[dobre/subst:pl:acc:n2,dobre/subst:pl:nom:n2,dobre/subst:pl:voc:n2,dobre/subst:sg:acc:n2,dobre/subst:sg:nom:n2,dobre/subst:sg:voc:n2,dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos,dobry/depr:pl:nom:m2,dobry/depr:pl:voc:m2,dobry/subst:pl:acc:m3,dobry/subst:pl:nom:m3,dobry/subst:pl:voc:m3] -> dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos]\n" +
         "unify_adj_subst:1 dobre[dobry/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,dobry/adj:sg:acc:n1.n2:pos,dobry/adj:sg:nom.voc:n1.n2:pos] -> dobre[dobry/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos]\n" +

File: languagetool-standalone/src/main/dev/org/languagetool/dev/conversion/RuleConverterMain.java
Patch:
@@ -25,7 +25,7 @@
 import java.io.PrintWriter;
 import java.util.List;
 
-import org.languagetool.Language;
+import org.languagetool.language.English;
 
 public class RuleConverterMain {
     
@@ -112,7 +112,7 @@ public static void main(String[] args) throws IOException {
         //TODO: fix this so we can have this functionality
         try {
           if (args[0].equals("--check")) {
-            RuleCoverage checker = new RuleCoverage(Language.ENGLISH);
+            RuleCoverage checker = new RuleCoverage(new English());
             String inFile = args[1];
             checker.evaluateRules(inFile);
             System.exit(1);

File: languagetool-standalone/src/main/dev/org/languagetool/dev/conversion/RuleCoverage.java
Patch:
@@ -41,6 +41,7 @@
 
 import org.languagetool.JLanguageTool;
 import org.languagetool.Language;
+import org.languagetool.language.English;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.rules.patterns.Element;
 import org.languagetool.rules.patterns.PatternRule;
@@ -64,7 +65,7 @@ public class RuleCoverage {
 
     // default constructor; defaults to English
     public RuleCoverage() throws IOException {
-      language = Language.ENGLISH;
+      language = new English();
       tool = new JLanguageTool(language);
         tool.activateDefaultPatternRules();
         tool.disableRule("UPPERCASE_SENTENCE_START");
@@ -85,7 +86,7 @@ public RuleCoverage(Language language) throws IOException {
     
     // for testing purposes, defaults to English
     public RuleCoverage(String dictFileName) throws IOException {
-      language = Language.ENGLISH;
+      language = new English();
       tool = new JLanguageTool(language);
         tool.activateDefaultPatternRules();
         tool.disableRule("UPPERCASE_SENTENCE_START");

File: languagetool-standalone/src/main/dev/org/languagetool/dev/ExportGermanNouns.java
Patch:
@@ -50,12 +50,12 @@ private ExportGermanNouns() {
   private Set<String> getWords() throws IOException {
     final FSA fsa = FSA.read(JLanguageTool.getDataBroker().getFromResourceDirAsStream(DICT_FILENAME));
     String lastTerm = null;
-    final Set<String> set = new HashSet<String>();
+    final Set<String> set = new HashSet<>();
     for (ByteBuffer bb : fsa) {
       final byte [] sequence = new byte [bb.remaining()];
       bb.get(sequence);
       final String output = new String(sequence, "iso-8859-1");
-      if (output.indexOf("+SUB:") != -1 && output.indexOf(":ADJ") == -1) {
+      if (output.contains("+SUB:") && !output.contains(":ADJ")) {
         final String[] parts = output.split("\\+");
         final String term = parts[0].toLowerCase();
         if (lastTerm == null || !lastTerm.equals(parts[0])) {

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageComboBox.java
Patch:
@@ -55,8 +55,8 @@ void selectLanguage(Language language) {
 
   private void initAllLanguages() {
     languages.clear();
-    for (Language language : Language.LANGUAGES) {
-      final boolean skip = language.hasVariant() || "Testlanguage".equals(language.getName());
+    for (Language language : Language.REAL_LANGUAGES) {
+      final boolean skip = language.hasVariant();
       // TODO: "Simple German" would hide "German (Germany)" - find a proper solution
       final boolean simpleGermanWorkaround = language.getShortNameWithCountryAndVariant().equals("de-DE");
       if (!skip || simpleGermanWorkaround) {

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageComboBox.java
Patch:
@@ -55,8 +55,8 @@ void selectLanguage(Language language) {
 
   private void initAllLanguages() {
     languages.clear();
-    for (Language language : Language.REAL_LANGUAGES) {
-      final boolean skip = language.hasVariant();
+    for (Language language : Language.LANGUAGES) {
+      final boolean skip = language.hasVariant() || "Testlanguage".equals(language.getName());
       // TODO: "Simple German" would hide "German (Germany)" - find a proper solution
       final boolean simpleGermanWorkaround = language.getShortNameWithCountryAndVariant().equals("de-DE");
       if (!skip || simpleGermanWorkaround) {

File: languagetool-standalone/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -102,7 +102,7 @@ public void testAnnotateTextCheckMultipleSentences() throws IOException {
   }
 
   @Test
-  public void testAnnotateTextCheckMultipleSentencesFIXME() throws IOException {
+  public void testAnnotateTextCheckMultipleSentences2() throws IOException {
     JLanguageTool languageTool = new JLanguageTool(new English());
     AnnotatedText annotatedText = new AnnotatedTextBuilder()
             .addText("here")

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/SuggestionReplacer.java
Patch:
@@ -42,8 +42,8 @@ public class SuggestionReplacer {
   public SuggestionReplacer(PlainTextMapping textMapping, String originalText) {
     this.textMapping = textMapping;
     this.originalText = originalText;
-    this.errorMarkerStart = "<span class=\"error\">";
-    this.errorMarkerEnd = "</span>";
+    this.errorMarkerStart = "<<span class=\"error\">>";  // use <<span>> to avoid clashes with <span> in original markup
+    this.errorMarkerEnd = "<</span>>";
   }
 
   public SuggestionReplacer(PlainTextMapping textMapping, String originalText, String errorMarkerStart, String errorMarkerEnd) {

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/wikipedia/WikipediaQuickCheckTest.java
Patch:
@@ -69,9 +69,9 @@ public void testCheckWikipediaMarkup() throws IOException {
     assertThat(firstAppliedMatch.getRuleMatchApplications().size(), is(1));
     RuleMatchApplication ruleMatchApplication = firstAppliedMatch.getRuleMatchApplications().get(0);
     assertTrue("Got: " + ruleMatchApplication.getTextWithCorrection(),
-            ruleMatchApplication.getTextWithCorrection().contains("<span class=\"error\">wegen dem</span> Leerzeichen."));
-    assertThat(ruleMatchApplication.getOriginalErrorContext(10), is(" richtig, <span class=\"error\">wegen dem</span> Le"));
-    assertThat(ruleMatchApplication.getCorrectedErrorContext(10), is(" richtig, <span class=\"error\">wegen dem</span> Le"));
+            ruleMatchApplication.getTextWithCorrection().contains("<<span class=\"error\">>wegen dem<</span>> Leerzeichen."));
+    assertThat(ruleMatchApplication.getOriginalErrorContext(12), is("st richtig, <<span class=\"error\">>wegen dem<</span>> Le"));
+    assertThat(ruleMatchApplication.getCorrectedErrorContext(12), is("st richtig, <<span class=\"error\">>wegen dem<</span>> Le"));
   }
 
   public void testGetPlainText() {

File: languagetool-core/src/main/java/org/languagetool/Language.java
Patch:
@@ -239,7 +239,7 @@ public List<String> getRuleFileName() {
   }
 
   /**
-   * Get the location of the rule file(s).
+   * Get the location of the rule file(s) in a form like {@code /org/languagetool/rules/de/grammar.xml}.
    */
   public List<String> getRuleFileNames() {
     final List<String> ruleFiles = new ArrayList<>();

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleMatcher.java
Patch:
@@ -332,7 +332,7 @@ private static String formatMultipleSynthesis(final String[] matches,
     String suggestionRight = "";
     String rightSideNew = rightSide;
     final int sPos = leftSide.lastIndexOf(SUGGESTION_START_TAG);
-    if (sPos > 0) {
+    if (sPos >= 0) {
       suggestionLeft = leftSide.substring(sPos + SUGGESTION_START_TAG.length());
     }
     if (StringTools.isEmpty(suggestionLeft)) {
@@ -341,7 +341,7 @@ private static String formatMultipleSynthesis(final String[] matches,
       errorMessage = leftSide.substring(0, leftSide.lastIndexOf(SUGGESTION_START_TAG)) + SUGGESTION_START_TAG;
     }
     final int rPos = rightSide.indexOf(SUGGESTION_END_TAG);
-    if (rPos > 0) {
+    if (rPos >= 0) {
       suggestionRight = rightSide.substring(0, rPos);
     }
     if (!StringTools.isEmpty(suggestionRight)) {

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationPatternRuleReplacer.java
Patch:
@@ -238,7 +238,9 @@ private AnalyzedTokenReadings[] executeAction(final AnalyzedSentence sentence,
             unifiedTokens[i].setStartPos(whTokens[position].getStartPos());
             final String prevValue = whTokens[position].toString();
             final String prevAnot = whTokens[position].getHistoricalAnnotations();
+            List<ChunkTag> chTags = whTokens[position].getChunkTags();
             whTokens[position] = unifiedTokens[i];
+            whTokens[position].setChunkTags(chTags);
             annotateChange(whTokens[position], prevValue, prevAnot);
           }
         }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -368,6 +368,7 @@ public class CaseRule extends GermanRule {
 
   private static final Set<String> substVerbenExceptions = new HashSet<>();
   static {
+    substVerbenExceptions.add("scheinen");
     substVerbenExceptions.add("klar");
     substVerbenExceptions.add("heißen");
     substVerbenExceptions.add("einen");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -258,7 +258,8 @@ private boolean isFiniteVerb(final AnalyzedTokenReadings token) {
         || !token.hasPartialPosTag("VER")
         || token.hasPartialPosTag("PA2")
         || token.hasPartialPosTag("PRO:")
-        || token.hasPartialPosTag("ZAL")) {
+        || token.hasPartialPosTag("ZAL")
+        || "einst".equals(token.getToken())) {
       return false;
     }
     return (token.hasPartialPosTag(":1:") || token.hasPartialPosTag(":2:") || token.hasPartialPosTag(":3:"));

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -53,6 +53,7 @@ public void testWrongVerb() throws IOException {
     assertGood("Max und ich sollten das machen.");
     assertGood("Osama bin Laden stammt aus Saudi-Arabien.");
     assertGood("Solltet ihr das machen?");
+    assertGood("Ein Geschenk, das er einst von Aphrodite erhalten hatte.");
     assertGood("/usr/bin/firefox");
     // incorrect sentences:
     assertBad("Als Borcarbid weißt es eine hohe Härte auf.");

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishUnpairedBracketsRule.java
Patch:
@@ -34,7 +34,7 @@ public class EnglishUnpairedBracketsRule extends GenericUnpairedBracketsRule {
   private static final String[] EN_END_SYMBOLS   = { "]", ")", "}", "”", "\"", "'" };
 
   private static final Pattern NUMBER = Pattern.compile("\\d+(?:-\\d+)?");
-  private static final Pattern YEAR_NUMBER = Pattern.compile("\\d\\d");
+  private static final Pattern YEAR_NUMBER = Pattern.compile("\\d\\ds?");
   private static final Pattern ALPHA = Pattern.compile("\\p{L}+");
 
   public EnglishUnpairedBracketsRule(final ResourceBundle messages,
@@ -59,7 +59,6 @@ protected boolean isNoException(final String tokenStr,
 
     //TODO: add an', o', 'till, 'tain't, 'cept, 'fore in the disambiguator
     //and mark up as contractions somehow
-    // add exception for dates like '52
 
     if (i <= 1) {
       return true;

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/EnglishUnpairedBracketsRuleTest.java
Patch:
@@ -73,13 +73,15 @@ public void testRule() throws IOException {
     assertCorrect("On their 'host society'.");
     assertCorrect("Burke-rostagno the Richard S. Burkes' home in Wayne may be the setting for the wedding reception for their daughter.");
     assertCorrect("The '49 team was off to a so-so 5-5 beginning");
+    assertCorrect("The best reason that can be advanced for the state adopting the practice was the advent of expanded highway construction during the 1920s and '30s.");
     assertCorrect("A Republican survey says Kennedy won the '60 election on the religious issue.");
     assertCorrect("Economy class seats have a seat pitch of 31-33\", with newer aircraft having thinner seats that have a 31\" pitch.");
     assertCorrect("\"02\" will sort before \"10\" as expected so it will have size of 10\".");
     assertCorrect("\"02\" will sort before \"10\" as expected so it will have size of 10\""); // inch symbol is at the sentence end
     assertCorrect("\"02\" will sort before \"10\""); // quotation mark is at the sentence end
 
 
+
     //Should be correct!
     //assertCorrect("On their 'host societies'.");
 

File: languagetool-core/src/main/java/org/languagetool/rules/GenericUnpairedBracketsRule.java
Patch:
@@ -152,7 +152,7 @@ public final RuleMatch[] match(final AnalyzedSentence sentence) {
                   && token.equals(startSymbols[j])) {
             symbolStack.push(new SymbolLocator(startSymbols[j], i));
             break;
-          } else if (noException && followedByWhitespace
+          } else if (noException && (followedByWhitespace || tokens[i].isSentenceEnd())
                   && token.equals(endSymbols[j])) {
             if (i > 1 && endSymbols[j].equals(")")
                     && (numerals.matcher(tokens[i - 1].getToken()).matches()

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/EnglishUnpairedBracketsRuleTest.java
Patch:
@@ -75,6 +75,9 @@ public void testRule() throws IOException {
     assertCorrect("The '49 team was off to a so-so 5-5 beginning");
     assertCorrect("A Republican survey says Kennedy won the '60 election on the religious issue.");
     assertCorrect("Economy class seats have a seat pitch of 31-33\", with newer aircraft having thinner seats that have a 31\" pitch.");
+    assertCorrect("\"02\" will sort before \"10\" as expected so it will have size of 10\".");
+    assertCorrect("\"02\" will sort before \"10\" as expected so it will have size of 10\""); // inch symbol is at the sentence end
+    assertCorrect("\"02\" will sort before \"10\""); // quotation mark is at the sentence end
 
 
     //Should be correct!

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishUnpairedBracketsRule.java
Patch:
@@ -87,7 +87,7 @@ protected boolean isNoException(final String tokenStr,
         return false;
       }
       // Exception for English plural Saxon genitive
-      if ("'".equals(tokenStr) && tokens[i].hasPosTag("POS")) {
+      if (("'".equals(tokenStr) || "’".equals(tokenStr)) && tokens[i].hasPosTag("POS")) {
         return false;
       }
       // puttin' on the Ritz

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/EnglishUnpairedBracketsRule.java
Patch:
@@ -32,7 +32,7 @@ public class EnglishUnpairedBracketsRule extends GenericUnpairedBracketsRule {
   private static final String[] EN_START_SYMBOLS = { "[", "(", "{", "“", "\"", "'" };
   private static final String[] EN_END_SYMBOLS   = { "]", ")", "}", "”", "\"", "'" };
 
-  private static final Pattern NUMBER = Pattern.compile("\\d+");
+  private static final Pattern NUMBER = Pattern.compile("\\d+(?:-\\d+)?");
   private static final Pattern YEAR_NUMBER = Pattern.compile("\\d\\d");
   private static final Pattern ALPHA = Pattern.compile("\\p{L}+");
 

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/EnglishUnpairedBracketsRuleTest.java
Patch:
@@ -74,6 +74,7 @@ public void testRule() throws IOException {
     assertCorrect("Burke-rostagno the Richard S. Burkes' home in Wayne may be the setting for the wedding reception for their daughter.");
     assertCorrect("The '49 team was off to a so-so 5-5 beginning");
     assertCorrect("A Republican survey says Kennedy won the '60 election on the religious issue.");
+    assertCorrect("Economy class seats have a seat pitch of 31-33\", with newer aircraft having thinner seats that have a 31\" pitch.");
 
 
     //Should be correct!

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/MatchState.java
Patch:
@@ -165,6 +165,9 @@ public final AnalyzedTokenReadings filterReadings() {
     if (!formattedToken.getChunkTags().isEmpty()) {
       anTkRead.setChunkTags(formattedToken.getChunkTags());
     }
+    if (formattedToken.isImmunized()) {
+     anTkRead.immunize();
+    }
     return anTkRead;
   }
 

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationPatternRuleReplacer.java
Patch:
@@ -437,6 +437,9 @@ private AnalyzedTokenReadings replaceTokens(AnalyzedTokenReadings oldAtr,
     newAtr.setWhitespaceBefore(spaceBefore);
     newAtr.setStartPos(startPosition);
     newAtr.setChunkTags(chunkTags);
+    if (oldAtr.isImmunized()) {
+      newAtr.immunize();
+    }
     annotateChange(newAtr, prevValue, prevAnot);
     return newAtr;
   }

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/index/LanguageToolFilter.java
Patch:
@@ -146,7 +146,7 @@ public boolean incrementToken() throws IOException {
         if (toLowerCase) {
           posStack.push(LEMMA_PREFIX.toLowerCase() + token.getLemma().toLowerCase());
         } else {
-          // changes are good this is the same for all loop iterations, store it anyway...
+          // chances are good this is the same for all loop iterations, store it anyway...
           posStack.push(LEMMA_PREFIX + token.getLemma());
         }
       }

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/index/IndexerSearcherTest.java
Patch:
@@ -78,7 +78,7 @@ public void testAllRules() throws Exception {
     final Language language = new English();
     //final Language language = new French();
     //final Language language = new Spanish();
-    //final Language language = new Polish(); // TODO: still "Clauses must have same field"
+    //final Language language = new Polish();
     //final Language language = new German();
     final JLanguageTool lt = new JLanguageTool(language);
     lt.activateDefaultPatternRules();

File: languagetool-core/src/main/java/org/languagetool/AnalyzedSentence.java
Patch:
@@ -256,6 +256,8 @@ public synchronized Set<String> getLemmaSet() {
         for (AnalyzedToken lemmaTok : token.getReadings()) {
           if (lemmaTok.getLemma() != null) {
             lemmaSet.add(lemmaTok.getLemma().toLowerCase());
+          } else {
+            lemmaSet.add(lemmaTok.getToken().toLowerCase());
           }
         }
       }

File: languagetool-language-modules/pl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -39,6 +39,7 @@ public void testPolish() throws IOException {
     assertEquals(1, matches.size());
     //no error thanks to disambiguation
     assertEquals(0, tool.check("Mają one niemałe znaczenie.").size());
+    assertEquals(0, tool.check("Często wystarczy obrócić na wspak wyroki świata, aby trafnie osądzić jakąś osobę.").size());
     //with immunization
     assertEquals(0, tool.check("A teraz każcie mi dać jaki bądź posiłek.").size());
     assertEquals(0, tool.check("Kiedym wóz zobaczył, byłbym przysiągł, że wielka przygoda mnie czeka.").size());

File: languagetool-core/src/main/java/org/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -223,6 +223,7 @@ public final void removeReading(final AnalyzedToken token) {
     }
     if (l.isEmpty()) {
       l.add(new AnalyzedToken(this.token, null, null));
+      l.get(0).setWhitespaceBefore(isWhitespaceBefore);
     }
     anTokReadings = l.toArray(new AnalyzedToken[l.size()]);
     setNoRealPOStag();
@@ -245,6 +246,7 @@ public final void leaveReading(final AnalyzedToken token) {
     }
     if (l.isEmpty()) {
       l.add(new AnalyzedToken(this.token, null, null));
+      l.get(0).setWhitespaceBefore(isWhitespaceBefore);
     }
     anTokReadings = l.toArray(new AnalyzedToken[l.size()]);
     setNoRealPOStag();

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationPatternRuleReplacer.java
Patch:
@@ -227,6 +227,7 @@ private AnalyzedTokenReadings[] executeAction(final AnalyzedSentence sentence,
     switch (disAction) {
     case UNIFY:
       if (unifiedTokens != null) {
+        //TODO: unifiedTokens.length is larger > matchingTokensWithCorrection in cases where there are no markers...
         if (unifiedTokens.length == matchingTokensWithCorrection - startPositionCorrection + endPositionCorrection) {
           if (whTokens[sentence.getOriginalPosition(firstMatchToken
               + correctedStPos + unifiedTokens.length - 1)].isSentenceEnd()) {

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationPatternRuleReplacer.java
Patch:
@@ -188,7 +188,7 @@ private AnalyzedTokenReadings[] executeAction(final AnalyzedSentence sentence,
     }
 
     // adjust positions in case elements with min="0" were not matched before the starting position
-    for (int j = 0; j <= startPositionCorrection; j++) {
+    for (int j = 0; j <= startPositionCorrection && j < elementsMatched.size(); j++) {
       if (!elementsMatched.get(j)) {
         correctedStPos -= tokenPositions[j];
       }

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -403,7 +403,7 @@ private synchronized String getSentence(final String paraText,
   // See https://bugs.freedesktop.org/show_bug.cgi?id=69416
   // non-private for test case
   String cleanFootnotes(String paraText) {
-    return paraText.replaceAll("([.!?])\\d ", "$1¹ ");
+    return paraText.replaceAll("([^\\d][.!?])\\d ", "$1¹ ");
   }
 
   private synchronized SingleProofreadingError[] checkParaRules(

File: languagetool-office-extension/src/test/java/org/languagetool/openoffice/MainTest.java
Patch:
@@ -79,6 +79,7 @@ public void testVariants() {
   public void testCleanFootnotes() {
     final Main prog = new Main(null);
     assertEquals("A house.¹ Here comes more text.", prog.cleanFootnotes("A house.1 Here comes more text."));
+    assertEquals("A road that's 3.4 miles long.", prog.cleanFootnotes("A road that's 3.4 miles long."));
     assertEquals("A house.1234 Here comes more text.", prog.cleanFootnotes("A house.1234 Here comes more text."));  // too many digits for a footnote
     String input    = "Das Haus.1 Hier kommt mehr Text2. Und nochmal!3 Und schon wieder ein Satz?4 Jetzt ist aber Schluss.";
     String expected = "Das Haus.¹ Hier kommt mehr Text2. Und nochmal!¹ Und schon wieder ein Satz?¹ Jetzt ist aber Schluss.";

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -58,6 +58,7 @@ public void testRule() throws IOException {
      * exterminades
      */
     // (en especial si hi ha un adverbi entremig: en algun grau més distintes
+    assertCorrect("Cada polinomi en forma expandida");
     assertCorrect("El 1967 una partida de liberals rebel al govern");
     assertCorrect("El 1640 una junta de nobles reunida a Lisboa");
     assertCorrect("amb una expressió de dolor i de por barrejats.");

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/index/Searcher.java
Patch:
@@ -277,7 +277,7 @@ class PossiblyLimitedTopDocs {
   }
 
   private static void ensureCorrectUsageOrExit(String[] args) {
-    if (args.length < 4 || !(args.length == 5 || !"--no_limit".equals(args[4]))) {
+    if (args.length < 4 || (args.length == 5 && !"--no_limit".equals(args[4]))) {
       System.err.println("Usage: Searcher <ruleId> <ruleXML> <languageCode> <indexDir> <--no_limit>");
       System.err.println("\truleId       Id of the rule to search for");
       System.err.println("\truleXML      path to a rule file, e.g. en/grammar.xml");
@@ -355,7 +355,7 @@ public static void main(String[] args) throws Exception {
     final String languageCode = args[2];
     final Language language = Language.getLanguageForShortName(languageCode);
     final File indexDir = new File(args[3]);
-    if (args.length > 3 && "--no_limit".equals(args[4])) {
+    if (args.length > 4 && "--no_limit".equals(args[4])) {
       limitSearch = false;
     }
     final Searcher searcher = new Searcher(new SimpleFSDirectory(indexDir));

File: languagetool-language-modules/pl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -109,7 +109,7 @@ public void testPolish() throws IOException {
         "BYC_ADJ_ACC_NOM:1 są[być/verb:fin:pl:ter:imperf:nonrefl] -> są[być/verb:fin:pl:ter:imperf:nonrefl]\n" +
         "SUBST_NOM_VOC_VERB:2 są[być/verb:fin:pl:ter:imperf:nonrefl] -> są[być/verb:fin:pl:ter:imperf:nonrefl]\n" +
         "\n" +
-        "BYC_ADJ_ACC_NOM:1 wskazane[wskazany/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,wskazany/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,wskazany/adj:sg:acc:n1.n2:pos,wskazany/adj:sg:nom.voc:n1.n2:pos,wskazać/ppas:pl:nom.acc.voc:m2.m3.f.n1.n2.p2.p3:perf:aff,wskazać/ppas:sg:nom.acc.voc:n1.n2:perf:aff] -> wskazane[wskazany/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos]\n",
+        "BYC_ADJ_ACC_NOM:1 wskazane[wskazany/adj:pl:acc:m2.m3.f.n1.n2.p2.p3:pos,wskazany/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,wskazany/adj:sg:acc:n1.n2:pos,wskazany/adj:sg:nom.voc:n1.n2:pos,wskazać/ppas:pl:nom.acc.voc:m2.m3.f.n1.n2.p2.p3:perf:aff,wskazać/ppas:sg:nom.acc.voc:n1.n2:perf:aff] -> wskazane[wskazany/adj:pl:nom.voc:m2.m3.f.n1.n2.p2.p3:pos,wskazać/ppas:pl:nom.acc.voc:m2.m3.f.n1.n2.p2.p3:perf:aff]\n",
         sent.getAnnotations());
 
   }

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -60,6 +60,8 @@ public void testRule() throws IOException {
 	      han estat de fet exterminades
 	   */
 	  // (en especial si hi ha un adverbi entremig: en algun grau més distintes
+	  //amb una expressió de dolor i de por barrejats.
+	  //un tram més tou, amb morfologia i color diferents.
 	  assertCorrect("tenen en canvi altres parts de llur estructura certament molt anormals:");
     assertCorrect("constitueix l'única comunitat autònoma amb menys aturats");
 	  assertCorrect("durant tot l'any, i del sud-est, més notoris a la primavera");

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationPatternRuleReplacer.java
Patch:
@@ -177,7 +177,9 @@ private AnalyzedTokenReadings[] executeAction(final AnalyzedSentence sentence,
         }
       } else if (!StringTools.isEmpty(disambiguatedPOS)) { // negative filtering
         Pattern p = Pattern.compile(disambiguatedPOS);
-        for (AnalyzedToken analyzedToken : whTokens[fromPos]) {
+        AnalyzedTokenReadings tmp = new AnalyzedTokenReadings(whTokens[fromPos].getReadings(),
+            whTokens[fromPos].getStartPos());
+        for (AnalyzedToken analyzedToken : tmp) {
           if (analyzedToken.getPOSTag() != null) {
             final Matcher mPos = p.matcher(analyzedToken.getPOSTag());
             if (mPos.matches()) {

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageToolSupport.java
Patch:
@@ -894,13 +894,13 @@ private String getExampleSentences(Rule rule) {
     List<IncorrectExample> incorrectExamples = rule.getIncorrectExamples();
     if (incorrectExamples.size() > 0) {
       String incorrectExample = incorrectExamples.iterator().next().getExample();
-      String sentence = incorrectExample.replace("<marker>", "<span style='color:red'>").replace("</marker>", "</span>");
+      String sentence = incorrectExample.replace("<marker>", "<span style='background-color:#ff8080'>").replace("</marker>", "</span>");
       examples.append("<br/>").append(sentence).append("&nbsp;<span style='color:red;font-style:italic;font-weight:bold'>x</span>");
     }
     List<String> correctExamples = rule.getCorrectExamples();
     if (correctExamples.size() > 0) {
       String correctExample = correctExamples.iterator().next();
-      String sentence = correctExample.replace("<marker>", "<span style='color:green'>").replace("</marker>", "</span>");
+      String sentence = correctExample.replace("<marker>", "<span style='background-color:#80ff80'>").replace("</marker>", "</span>");
       examples.append("<br/>").append(sentence).append("&nbsp;<span style='color:green'>✓</span>");
     }
     if (examples.length() > 0) {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -81,6 +81,7 @@ public class CaseRule extends GermanRule {
      * solution is to add all those to our Morphy data, but as a simple
      * workaround to avoid false alarms, these words can be added here.
      */
+    exceptions.add("Tel");  // Tel. = Telefon
     exceptions.add("Unschuldiger");
     exceptions.add("Vorgesetzter");
     exceptions.add("Abs");   // Abs. = Abkürzung für Absatz, Absender, ...

File: languagetool-language-modules/pl/src/main/java/org/languagetool/rules/pl/PolishWordRepeatRule.java
Patch:
@@ -86,7 +86,7 @@ public class PolishWordRepeatRule extends AdvancedWordRepeatRule {
 
   public PolishWordRepeatRule(final ResourceBundle messages) {
     super(messages);
-    addExamplePair(Example.wrong("To było słowo, które <marker>które</marker> się źle kojarzyło."),
+    addExamplePair(Example.wrong("To było słowo, <marker>które które</marker> się źle kojarzyło."),
         Example.fixed("To było słowo, <marker>które</marker> się źle kojarzyło."));
   }
 

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tagging/ca/CatalanTagger.java
Patch:
@@ -174,7 +174,7 @@ public List<AnalyzedToken> additionalTags(String word) {
       return additionalTaggedTokens;
     }
     // Any well-formed noun with prefix ex- is tagged as a noun copying the original tags
-    if (word.startsWith("ex")) {
+    /*if (word.startsWith("ex")) {
       final String lowerWord = word.toLowerCase(conversionLocale);
       final String possibleNoun = lowerWord.replaceAll("^ex(.+)$", "$1");
       List<AnalyzedToken> taggerTokens;
@@ -190,7 +190,7 @@ public List<AnalyzedToken> additionalTags(String word) {
         }
       }
       return additionalTaggedTokens;
-    }
+    }*/
     // Interpret deprecated characters of "ela geminada"
     // U+013F LATIN CAPITAL LETTER L WITH MIDDLE DOT
     // U+0140 LATIN SMALL LETTER L WITH MIDDLE DOT

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/MorfologikCatalanSpellerRuleTest.java
Patch:
@@ -43,7 +43,7 @@ public void testMorfologikSpeller() throws IOException {
         // prefixes and suffixes.
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("S'autodefineixin com a populars.")).length);
         //assertEquals(0, rule.match(langTool.getAnalyzedSentence("Redibuixen el futur.")).length);
-        assertEquals(0, rule.match(langTool.getAnalyzedSentence("L'exdirigent del partit.")).length);
+        //assertEquals(0, rule.match(langTool.getAnalyzedSentence("L'exdirigent del partit.")).length);
 
         // correct sentences:
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("Abacallanada")).length);

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tagging/ca/CatalanTagger.java
Patch:
@@ -53,7 +53,7 @@ public class CatalanTagger extends BaseTagger {
   private static final Pattern VERB = Pattern.compile("V.+");
   private static final Pattern NOUN = Pattern.compile("NC.+");
 
-  private static final Pattern PREFIXES_FOR_VERBS = Pattern.compile("(auto|re)(.+)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
+  private static final Pattern PREFIXES_FOR_VERBS = Pattern.compile("(auto)(.+)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
 
   @Override
   public final String getFileName() {

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/MorfologikCatalanSpellerRuleTest.java
Patch:
@@ -42,7 +42,7 @@ public void testMorfologikSpeller() throws IOException {
 
         // prefixes and suffixes.
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("S'autodefineixin com a populars.")).length);
-        assertEquals(0, rule.match(langTool.getAnalyzedSentence("Redibuixen el futur.")).length);
+        //assertEquals(0, rule.match(langTool.getAnalyzedSentence("Redibuixen el futur.")).length);
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("L'exdirigent del partit.")).length);
 
         // correct sentences:

File: languagetool-core/src/main/java/org/languagetool/rules/WordRepeatRule.java
Patch:
@@ -70,6 +70,9 @@ public RuleMatch[] match(final AnalyzedSentence sentence) {
     // we start from token 1, token no. 0 is guaranteed to be SENT_START
     for (int i = 1; i < tokens.length; i++) {
       final String token = tokens[i].getToken();
+        if (tokens[i].isImmunized()) {
+          continue;
+        }
       if (isWord(token) && prevToken.equalsIgnoreCase(token) && !ignore(tokens, i)) {
         final String msg = messages.getString("repetition");
         final int prevPos = tokens[i - 1].getStartPos();

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationPatternRuleReplacer.java
Patch:
@@ -78,7 +78,7 @@ public final AnalyzedSentence replace(final AnalyzedSentence sentence)
               prevElement, m, firstMatchToken, prevSkipNext);
           if (elem.getElement().getMinOccurrence() == 0) {
             final ElementMatcher nextElement = elementMatchers.get(k + 1);
-            final boolean nextElementMatch = !tokens[m].isImmunized() && testAllReadings(tokens, nextElement, elem, m,
+            final boolean nextElementMatch = testAllReadings(tokens, nextElement, elem, m,
                 firstMatchToken, prevSkipNext);
             if (nextElementMatch) {
               // this element doesn't match, but it's optional so accept this and continue

File: languagetool-language-modules/pl/src/main/java/org/languagetool/language/Polish.java
Patch:
@@ -1,5 +1,5 @@
-/*
- * Copyright (C) 2007 Daniel Naber (http://www.danielnaber.de)
+/* LanguageTool, a natural language style checker
+ * Copyright (C) 2014 Daniel Naber & Marcin Miłkowski (http://www.languagetool.org)
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -142,6 +142,7 @@ public List<Class<? extends Rule>> getRelevantRules() {
             GenericUnpairedBracketsRule.class,
             UppercaseSentenceStartRule.class,
             WhitespaceRule.class,
+            SentenceWhitespaceRule.class,
             // specific to German:
             GermanWordRepeatRule.class,
             GermanWordRepeatBeginningRule.class,
@@ -152,8 +153,7 @@ public List<Class<? extends Rule>> getRelevantRules() {
             DashRule.class,
             VerbAgreementRule.class,
             WordCoherencyRule.class,
-            WiederVsWiderRule.class,
-            SentenceWhitespaceRule.class
+            WiederVsWiderRule.class
     );
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -142,13 +142,13 @@ public List<Class<? extends Rule>> getRelevantRules() {
         UppercaseSentenceStartRule.class,
         WhitespaceRule.class,
         LongSentenceRule.class,
+        SentenceWhitespaceRule.class,
         // specific to English:
         EnglishWordRepeatRule.class,
         AvsAnRule.class,
         EnglishWordRepeatBeginningRule.class,
         CompoundRule.class,
-        ContractionSpellingRule.class,
-        SentenceWhitespaceRule.class
+        ContractionSpellingRule.class
     );
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -325,6 +325,8 @@ public class CaseRule extends GermanRule {
   private static final Set<String> myExceptionPhrases = new HashSet<>();
   static {
     // use proper upper/lowercase spelling here:
+    myExceptionPhrases.add("nichts Wichtigeres");
+    myExceptionPhrases.add("nichts Schöneres");
     myExceptionPhrases.add("ohne Wenn und Aber");
     myExceptionPhrases.add("Große Koalition");
     myExceptionPhrases.add("Großen Koalition");

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -211,7 +211,8 @@ public RuleMatch[] match(final AnalyzedSentence sentence) {
       // avoid false alarm on "Art. 1" and "bisherigen Art. 1" (Art. = Artikel):
       boolean detAbbrev = i < tokens.length-2 && tokens[i+1].getToken().equals("Art") && tokens[i+2].getToken().equals(".");
       boolean detAdjAbbrev = i < tokens.length-3 && tokens[i+2].getToken().equals("Art") && tokens[i+3].getToken().equals(".");
-      if (detAbbrev || detAdjAbbrev) {
+      boolean followingParticiple = i < tokens.length-3 && tokens[i+2].hasPartialPosTag("PA1"); //  "einen Hochwasser führenden Fluss"
+      if (detAbbrev || detAdjAbbrev || followingParticiple) {
         ignore = true;
       }
 

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -125,6 +125,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Dieser ist nun in den Ortungsbereich des einen Roboters gefahren.");
     assertGood("Wenn dies großen Erfolg hat, werden wir es weiter fördern.");
     assertGood("Die Ereignisse dieses einen Jahres waren sehr schlimm.");
+    assertGood("Er musste einen Hochwasser führenden Fluss nach dem anderen überqueren.");
 
     // incorrect sentences:
     assertBad("Es sind die Tisch.", "dem Tisch", "den Tisch", "der Tisch", "die Tische");

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageToolSupport.java
Patch:
@@ -1029,8 +1029,8 @@ public void run() {
       }
       try {
         checkText(caller);
-      } catch (IOException ex) {
-        ex.printStackTrace();
+      } catch (Exception ex) {
+        Tools.showError(ex);
       }
     }
   }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -156,6 +156,8 @@ public void testDetNounRule() throws IOException {
 
     assertBad("Der Haus ist groß", "Das Haus", "Dem Haus", "Der Häuser");
     assertBad("Aber der Haus ist groß", "das Haus", "dem Haus", "der Häuser");
+    
+    assertBad("Ich habe einen Feder gefunden.", "eine Feder", "einer Feder");
 
     // TODO: not yet detected:
     //assertBad("Erst recht wir fleißiges Arbeiter.");

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageToolSupport.java
Patch:
@@ -84,6 +84,7 @@
 import org.languagetool.JLanguageTool;
 import org.languagetool.Language;
 import org.languagetool.MultiThreadedJLanguageTool;
+import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.IncorrectExample;
 import org.languagetool.rules.Rule;
 import org.languagetool.rules.RuleMatch;
@@ -794,7 +795,7 @@ private void updateHighlights() {
       if (span.start == span.end) {
         continue;
       }
-      if ("misspelling".equals(span.rule.getLocQualityIssueType())) {
+      if (ITSIssueType.Misspelling.equals(span.rule.getLocQualityIssueType())) {
         spellErrors.add(span);
       } else {
         grammarErrors.add(span);

File: languagetool-standalone/src/main/java/org/languagetool/gui/ResultArea.java
Patch:
@@ -33,6 +33,7 @@
 
 import org.apache.commons.lang.StringUtils;
 import org.languagetool.Language;
+import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.Rule;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.tools.ContextTools;
@@ -124,7 +125,7 @@ private String getRuleMatchHtml(List<RuleMatch> ruleMatches, String text, String
         final String replacement = StringTools.listToString(match.getSuggestedReplacements(), "; ");
         sb.append("<b>").append(messages.getString("correctionMessage")).append("</b> ").append(replacement).append("<br>\n");
       }
-      if ("misspelling".equals(match.getRule().getLocQualityIssueType())) {
+      if (ITSIssueType.Misspelling.equals(match.getRule().getLocQualityIssueType())) {
         contextTools.setErrorMarkerStart(SPELL_ERROR_MARKER_START);
       } else {
         contextTools.setErrorMarkerStart(LT_ERROR_MARKER_START);

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractCompoundRule.java
Patch:
@@ -73,7 +73,7 @@ public AbstractCompoundRule(final ResourceBundle messages, final String fileName
     this.withHyphenMessage = withHyphenMessage;
     this.withoutHyphenMessage = withoutHyphenMessage;
     this.withOrWithoutHyphenMessage = withOrWithoutHyphenMessage;
-    setLocQualityIssueType("misspelling");
+    setLocQualityIssueType(ITSIssueType.Misspelling);
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/rules/AdvancedWordRepeatRule.java
Patch:
@@ -44,7 +44,7 @@ public AdvancedWordRepeatRule(final ResourceBundle messages) {
       super.setCategory(new Category(messages.getString("category_misc")));
     }
     setDefaultOff();
-    setLocQualityIssueType("style");
+    setLocQualityIssueType(ITSIssueType.Style);
   }
 
   protected abstract Set<String> getExcludedWordsPattern();

File: languagetool-core/src/main/java/org/languagetool/rules/CommaWhitespaceRule.java
Patch:
@@ -37,7 +37,7 @@ public class CommaWhitespaceRule extends Rule {
   public CommaWhitespaceRule(final ResourceBundle messages) {
     super(messages);
     super.setCategory(new Category(messages.getString("category_misc")));
-    setLocQualityIssueType("whitespace");
+    setLocQualityIssueType(ITSIssueType.Whitespace);
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/rules/DoublePunctuationRule.java
Patch:
@@ -35,7 +35,7 @@ public class DoublePunctuationRule extends Rule {
   public DoublePunctuationRule(final ResourceBundle messages) {
     super(messages);
     super.setCategory(new Category(messages.getString("category_misc")));
-    setLocQualityIssueType("typographical");
+    setLocQualityIssueType(ITSIssueType.Typographical);
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/rules/GenericUnpairedBracketsRule.java
Patch:
@@ -67,7 +67,7 @@ public GenericUnpairedBracketsRule(final ResourceBundle messages,
     endSymbols = language.getUnpairedRuleEndSymbols();
     numerals = NUMERALS_EN;
     uniqueMapInit();
-    setLocQualityIssueType("typographical");
+    setLocQualityIssueType(ITSIssueType.Typographical);
   }
 
   

File: languagetool-core/src/main/java/org/languagetool/rules/LongSentenceRule.java
Patch:
@@ -47,7 +47,7 @@ public LongSentenceRule(final ResourceBundle messages, int maxSentenceLength) {
     }
     maxWords = maxSentenceLength;
     setDefaultOff();
-    setLocQualityIssueType("style");
+    setLocQualityIssueType(ITSIssueType.Style);
   }
 
   public LongSentenceRule(final ResourceBundle messages) {

File: languagetool-core/src/main/java/org/languagetool/rules/UppercaseSentenceStartRule.java
Patch:
@@ -52,7 +52,7 @@ public UppercaseSentenceStartRule(final ResourceBundle messages,
     super(messages);
     super.setCategory(new Category(messages.getString("category_case")));
     this.language = language;
-    setLocQualityIssueType("typographical");
+    setLocQualityIssueType(ITSIssueType.Typographical);
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/rules/WhitespaceBeforePunctuationRule.java
Patch:
@@ -44,7 +44,7 @@ public class WhitespaceBeforePunctuationRule extends Rule {
   public WhitespaceBeforePunctuationRule(final ResourceBundle messages) {
     super(messages);
     super.setCategory(new Category(messages.getString("category_misc")));
-    setLocQualityIssueType("whitespace");
+    setLocQualityIssueType(ITSIssueType.Whitespace);
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/rules/WhitespaceRule.java
Patch:
@@ -39,7 +39,7 @@ public class WhitespaceRule extends Rule {
   public WhitespaceRule(final ResourceBundle messages, final Language language) {
     super(messages);
     super.setCategory(new Category(messages.getString("category_misc")));
-    setLocQualityIssueType("whitespace");
+    setLocQualityIssueType(ITSIssueType.Whitespace);
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/rules/WordRepeatBeginningRule.java
Patch:
@@ -40,7 +40,7 @@ public class WordRepeatBeginningRule extends Rule {
   public WordRepeatBeginningRule(final ResourceBundle messages, final Language language) {
     super(messages);
     super.setCategory(new Category(messages.getString("category_misc")));
-    setLocQualityIssueType("style");
+    setLocQualityIssueType(ITSIssueType.Style);
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/rules/WordRepeatRule.java
Patch:
@@ -36,7 +36,7 @@ public class WordRepeatRule extends Rule {
   public WordRepeatRule(final ResourceBundle messages, final Language language) {
     super(messages);
     super.setCategory(new Category(messages.getString("category_misc")));
-    setLocQualityIssueType("duplication");
+    setLocQualityIssueType(ITSIssueType.Duplication);
   }
 
   /**

File: languagetool-core/src/main/java/org/languagetool/rules/WrongWordInContextRule.java
Patch:
@@ -45,7 +45,7 @@ public WrongWordInContextRule(final ResourceBundle messages) {
       super.setCategory(new Category(getCategoryString()));
     }
     contextWordsSet = loadContextWords(JLanguageTool.getDataBroker().getFromRulesDirAsStream(getFilename()));
-    setLocQualityIssueType("misspelling");
+    setLocQualityIssueType(ITSIssueType.Misspelling);
   }
 
   protected abstract String getFilename();

File: languagetool-core/src/main/java/org/languagetool/rules/bitext/DifferentLengthRule.java
Patch:
@@ -22,6 +22,7 @@
 
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.AnalyzedTokenReadings;
+import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.RuleMatch;
 
 /**
@@ -33,7 +34,7 @@
 public class DifferentLengthRule extends BitextRule {
 
   public DifferentLengthRule() {
-    setLocQualityIssueType("length");
+    setLocQualityIssueType(ITSIssueType.Length);
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/rules/bitext/SameTranslationRule.java
Patch:
@@ -22,6 +22,7 @@
 
 import org.languagetool.AnalyzedSentence;
 import org.languagetool.AnalyzedTokenReadings;
+import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.RuleMatch;
 
 /**
@@ -33,7 +34,7 @@
 public class SameTranslationRule extends BitextRule {
 
   public SameTranslationRule() {
-    setLocQualityIssueType("untranslated");
+    setLocQualityIssueType(ITSIssueType.Untranslated);
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -26,6 +26,7 @@
 import org.languagetool.AnalyzedTokenReadings;
 import org.languagetool.JLanguageTool;
 import org.languagetool.Language;
+import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.Rule;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.tokenizers.WordTokenizer;
@@ -60,7 +61,7 @@ public abstract class SpellingCheckRule extends Rule {
   public SpellingCheckRule(final ResourceBundle messages, final Language language) {
     super(messages);
     this.language = language;
-    setLocQualityIssueType("misspelling");
+    setLocQualityIssueType(ITSIssueType.Misspelling);
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -24,6 +24,7 @@
 import org.languagetool.JLanguageTool;
 import org.languagetool.Language;
 import org.languagetool.rules.Category;
+import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.rules.spelling.SpellingCheckRule;
 
@@ -50,7 +51,7 @@ public MorfologikSpellerRule(ResourceBundle messages, Language language) throws
     super.setCategory(new Category(messages.getString("category_typo")));
     this.conversionLocale = conversionLocale != null ? conversionLocale : Locale.getDefault();
     init();
-    setLocQualityIssueType("misspelling");
+    setLocQualityIssueType(ITSIssueType.Misspelling);
   }
 
   @Override

File: languagetool-core/src/main/java/org/languagetool/tools/StringTools.java
Patch:
@@ -21,6 +21,7 @@
 import org.languagetool.JLanguageTool;
 import org.languagetool.Language;
 import org.languagetool.rules.Category;
+import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.rules.patterns.PatternRule;
 
@@ -378,9 +379,9 @@ public static String ruleMatchesToXML(final List<RuleMatch> ruleMatches,
       if (category != null) {
         xml.append(" category=\"").append(escapeXMLForAPIOutput(category.getName())).append('"');
       }
-      final String type = match.getRule().getLocQualityIssueType();
+      final ITSIssueType type = match.getRule().getLocQualityIssueType();
       if (type != null) {
-        xml.append(" locqualityissuetype=\"").append(escapeXMLForAPIOutput(type)).append('"');
+        xml.append(" locqualityissuetype=\"").append(escapeXMLForAPIOutput(type.toString())).append('"');
       }
       xml.append("/>\n");
     }

File: languagetool-core/src/test/java/org/languagetool/tools/StringToolsTest.java
Patch:
@@ -23,6 +23,7 @@
 import org.languagetool.Language;
 import org.languagetool.language.Contributor;
 import org.languagetool.rules.Category;
+import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.Rule;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.rules.patterns.Element;
@@ -317,8 +318,8 @@ public FakeRule() {
               "My fake description", "Fake message", "Fake short message");
     }
     @Override
-    public String getLocQualityIssueType() {
-      return "misspelling";
+    public ITSIssueType getLocQualityIssueType() {
+      return ITSIssueType.Misspelling;
     }
   }
   

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/AccentuationCheckRule.java
Patch:
@@ -34,6 +34,7 @@
 import org.languagetool.AnalyzedTokenReadings;
 import org.languagetool.JLanguageTool;
 import org.languagetool.rules.Category;
+import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.tools.StringTools;
 
@@ -92,7 +93,7 @@ public AccentuationCheckRule(ResourceBundle messages) throws IOException {
     if (messages != null) {
       super.setCategory(new Category(messages.getString("category_misc")));
     }
-    setLocQualityIssueType("grammar");
+    setLocQualityIssueType(ITSIssueType.Grammar);
     relevantWords = loadWords(FILE_NAME);
     relevantWords2 = loadWords(FILE_NAME2);
   }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/CatalanUnpairedExclamationMarksRule.java
Patch:
@@ -23,6 +23,7 @@
 
 import org.languagetool.Language;
 import org.languagetool.rules.GenericUnpairedBracketsRule;
+import org.languagetool.rules.ITSIssueType;
 
 public class CatalanUnpairedExclamationMarksRule extends GenericUnpairedBracketsRule {
   
@@ -32,7 +33,7 @@ public class CatalanUnpairedExclamationMarksRule extends GenericUnpairedBrackets
   public CatalanUnpairedExclamationMarksRule(final ResourceBundle messages,
       final Language language) {
     super(messages, language);
-    setLocQualityIssueType("style");
+    setLocQualityIssueType(ITSIssueType.Style);
     setDefaultOff();
     startSymbols = CA_START_SYMBOLS;
     endSymbols = CA_END_SYMBOLS;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/CatalanUnpairedQuestionMarksRule.java
Patch:
@@ -23,6 +23,7 @@
 
 import org.languagetool.Language;
 import org.languagetool.rules.GenericUnpairedBracketsRule;
+import org.languagetool.rules.ITSIssueType;
 
 public class CatalanUnpairedQuestionMarksRule extends GenericUnpairedBracketsRule {
   
@@ -32,7 +33,7 @@ public class CatalanUnpairedQuestionMarksRule extends GenericUnpairedBracketsRul
   public CatalanUnpairedQuestionMarksRule(final ResourceBundle messages,
       final Language language) {
     super(messages, language);
-    setLocQualityIssueType("style");
+    setLocQualityIssueType(ITSIssueType.Style);
     setDefaultOff();
     startSymbols = CA_START_SYMBOLS;
     endSymbols = CA_END_SYMBOLS;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/CatalanWrongWordInContextRule.java
Patch:
@@ -21,13 +21,14 @@
 import java.io.IOException;
 import java.util.ResourceBundle;
 
+import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.WrongWordInContextRule;
 
 public class CatalanWrongWordInContextRule extends WrongWordInContextRule {
   
   public CatalanWrongWordInContextRule(final ResourceBundle messages) throws IOException {
     super(messages);
-    setLocQualityIssueType("grammar");
+    setLocQualityIssueType(ITSIssueType.Grammar);
   }
   
   @Override

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRule.java
Patch:
@@ -29,6 +29,7 @@
 import org.languagetool.AnalyzedToken;
 import org.languagetool.AnalyzedTokenReadings;
 import org.languagetool.rules.Category;
+import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.RuleMatch;
 
 /**
@@ -107,7 +108,7 @@ public ComplexAdjectiveConcordanceRule(ResourceBundle messages)
     if (messages != null) {
       super.setCategory(new Category("Z) Concordances en grups nominals"));
     }
-    setLocQualityIssueType("grammar");
+    setLocQualityIssueType(ITSIssueType.Grammar);
   }
 
   @Override

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -30,6 +30,7 @@
 import org.languagetool.AnalyzedToken;
 import org.languagetool.AnalyzedTokenReadings;
 import org.languagetool.rules.Category;
+import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.tools.StringTools;
 
@@ -165,7 +166,7 @@ public ReflexiveVerbsRule(ResourceBundle messages) throws IOException {
     if (messages != null) {
       super.setCategory(new Category("Verbs"));
     }
-    setLocQualityIssueType("grammar");
+    setLocQualityIssueType(ITSIssueType.Grammar);
   }
 
   

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SimpleReplaceRule.java
Patch:
@@ -25,6 +25,7 @@
 
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Category;
+import org.languagetool.rules.ITSIssueType;
 
 /**
  * A rule that matches words which should not be used and suggests
@@ -48,7 +49,7 @@ public final String getFileName() {
   public SimpleReplaceRule(final ResourceBundle messages) throws IOException {
     super(messages);
     super.setCategory(new Category("Errors ortogràfics"));
-    super.setLocQualityIssueType("misspelling");
+    super.setLocQualityIssueType(ITSIssueType.Misspelling);
     this.setIgnoreTaggedWords();
   }  
 

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/SimpleReplaceVerbsRule.java
Patch:
@@ -36,6 +36,7 @@
 import org.languagetool.AnalyzedTokenReadings;
 import org.languagetool.JLanguageTool;
 import org.languagetool.rules.Category;
+import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.Rule;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.synthesis.ca.CatalanSynthesizer;
@@ -74,7 +75,7 @@ public String getEncoding() {
   }
   
   public SimpleReplaceVerbsRule(final ResourceBundle messages) throws IOException {
-    super.setLocQualityIssueType("misspelling");
+    super.setLocQualityIssueType(ITSIssueType.Misspelling);
     if (messages != null) {
       super.setCategory(new Category("Errors ortogràfics"));
     }

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/AvsAnRule.java
Patch:
@@ -31,6 +31,7 @@
 import org.languagetool.AnalyzedTokenReadings;
 import org.languagetool.JLanguageTool;
 import org.languagetool.rules.Category;
+import org.languagetool.rules.ITSIssueType;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.tools.StringTools;
 
@@ -58,7 +59,7 @@ public AvsAnRule(final ResourceBundle messages) throws IOException {
     }
     requiresA = loadWords(JLanguageTool.getDataBroker().getFromRulesDirAsStream(FILENAME_A));
     requiresAn = loadWords(JLanguageTool.getDataBroker().getFromRulesDirAsStream(FILENAME_AN));
-    setLocQualityIssueType("misspelling");
+    setLocQualityIssueType(ITSIssueType.Misspelling);
   }
 
   @Override

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/BritishReplaceRule.java
Patch:
@@ -25,6 +25,7 @@
 
 import org.apache.commons.lang.StringUtils;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
+import org.languagetool.rules.ITSIssueType;
 
 /**
  * A rule that matches words or phrases which should not be used and suggests
@@ -47,7 +48,7 @@ public final String getFileName() {
 
   public BritishReplaceRule(final ResourceBundle messages) throws IOException {
     super(messages);
-    setLocQualityIssueType("locale-violation");
+    setLocQualityIssueType(ITSIssueType.LocaleViolation);
   }
 
   @Override

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/ContractionSpellingRule.java
Patch:
@@ -25,6 +25,7 @@
 
 import org.languagetool.rules.AbstractSimpleReplaceRule;
 import org.languagetool.rules.Category;
+import org.languagetool.rules.ITSIssueType;
 
 /**
  * A rule that matches words or phrases which should not be used and suggests
@@ -49,7 +50,7 @@ public final String getFileName() {
   public ContractionSpellingRule(final ResourceBundle messages) throws IOException {
     super(messages);
     super.setCategory(new Category("Possible Typo"));
-    setLocQualityIssueType("misspelling");
+    setLocQualityIssueType(ITSIssueType.Misspelling);
   }
 
   @Override

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/NewZealandReplaceRule.java
Patch:
@@ -25,6 +25,7 @@
 
 import org.apache.commons.lang.StringUtils;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
+import org.languagetool.rules.ITSIssueType;
 
 /**
  * A rule that matches words or phrases which should not be used and suggests
@@ -47,7 +48,7 @@ public final String getFileName() {
 
   public NewZealandReplaceRule(final ResourceBundle messages) throws IOException {
     super(messages);
-    setLocQualityIssueType("locale-violation");
+    setLocQualityIssueType(ITSIssueType.LocaleViolation);
   }
 
   @Override

File: languagetool-language-modules/pl/src/main/java/org/languagetool/rules/pl/SimpleReplaceRule.java
Patch:
@@ -25,6 +25,7 @@
 
 import org.apache.commons.lang.StringUtils;
 import org.languagetool.rules.AbstractSimpleReplaceRule;
+import org.languagetool.rules.ITSIssueType;
 
 /**
  * A rule that matches words or phrases which should not be used and suggests
@@ -50,7 +51,7 @@ public final String getFileName() {
 
   public SimpleReplaceRule(final ResourceBundle messages) throws IOException {
     super(messages);
-    setLocQualityIssueType("misspelling");
+    setLocQualityIssueType(ITSIssueType.Misspelling);
     setCheckLemmas(false);
   }
 

File: languagetool-language-modules/pl/src/test/java/org/languagetool/synthesis/pl/PolishSynthesizerTest.java
Patch:
@@ -51,7 +51,7 @@ private AnalyzedToken dummyToken(String tokenStr) {
     return new AnalyzedToken(tokenStr, tokenStr, tokenStr);
   }
 
-  private String[] getSortedArray(String[] ar) {
+  private String[] getSortedArray(String... ar) {
     String[] newAr = ar.clone();
     Arrays.sort(newAr);
     return newAr;

File: languagetool-language-modules/pl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -76,12 +76,12 @@ public void testPolish() throws IOException {
     //and let's test other feats
     AnalyzedSentence sent = tool.getAnalyzedSentence("Z powodu pogody dobre buty są wskazane.");
     assertEquals("Disambiguator log: \n\n"+
-        "prep_verb:2 Z[z/prep:acc:nwok*,z/prep:gen:nwok*,z/prep:inst:nwok*] -> Z[z/prep:gen:nwok*]\n"+
+        "prep_verb:4 Z[z/prep:acc:nwok*,z/prep:gen:nwok*,z/prep:inst:nwok*] -> Z[z/prep:gen:nwok*]\n"+
         "PREP_SUBST:1 Z[z/prep:gen:nwok*] -> Z[z/prep:gen:nwok*]\n"+
         "PREP_SUBST_2:1 Z[z/prep:gen:nwok*] -> Z[z/prep:gen:nwok*]\n"+
         "MULTIWORD_CHUNKER: Z[z/prep:gen:nwok*] -> Z[z/prep:gen:nwok*,Z powodu/<PREP:GEN>*]\n\n" +
 
-        "prep_verb:2 powodu[powód/subst:sg:gen:m3] -> powodu[powód/subst:sg:gen:m3]\n"+
+        "prep_verb:4 powodu[powód/subst:sg:gen:m3] -> powodu[powód/subst:sg:gen:m3]\n"+
         "PREP_SUBST:1 powodu[powód/subst:sg:gen:m3] -> powodu[powód/subst:sg:gen:m3]\n"+
         "PREP_SUBST_2:1 powodu[powód/subst:sg:gen:m3] -> powodu[powód/subst:sg:gen:m3]\n"+
 

File: languagetool-language-modules/pl/src/main/java/org/languagetool/rules/pl/MorfologikPolishSpellerRule.java
Patch:
@@ -135,7 +135,8 @@ private boolean isNotCompound(String word) throws IOException {
                 if (taggedToks.size() == 2
                         // "białozielony", trzynastobitowy
                         && (taggedToks.get(0).hasPosTag("adja")
-                        || taggedToks.get(0).hasPosTag("num:comp"))
+                        || (taggedToks.get(0).hasPosTag("num:comp")
+                           && !taggedToks.get(0).hasPosTag("adv")))
                         && taggedToks.get(1).hasPartialPosTag("adj:")) {
                     probablyCorrectWords.add(word);
                 }

File: languagetool-language-modules/pl/src/main/java/org/languagetool/rules/pl/SimpleReplaceRule.java
Patch:
@@ -51,6 +51,7 @@ public final String getFileName() {
   public SimpleReplaceRule(final ResourceBundle messages) throws IOException {
     super(messages);
     setLocQualityIssueType("misspelling");
+    setCheckLemmas(false);
   }
 
   @Override

File: languagetool-language-modules/pl/src/test/java/org/languagetool/tokenizers/pl/PolishWordTokenizerTest.java
Patch:
@@ -69,6 +69,9 @@ public void testTokenize() {
     assertEquals("[To,  , jest,  , kobieta, -, wojownik,  , " +
         "w,  , polsko, -, czeskim,  , ubraniu, ,,  " +
         ", która,  , wysłała,  , dwa,  , SMS-y, .]", compoundTokens.toString());
+    compoundTokens = wordTokenizer.tokenize("Miała osiemnaście-dwadzieścia lat.");
+    assertEquals(8, compoundTokens.size());
+    assertEquals("[Miała,  , osiemnaście, -, dwadzieścia,  , lat, .]", compoundTokens.toString());
   }
 
 }

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRule.java
Patch:
@@ -244,7 +244,7 @@ private synchronized Set<String> getSimpleTokens() {
         if (!element.getNegation() && !element.isRegularExpression() 
                 && !element.isReferenceElement() && !element.isInflected() && element.getMinOccurrence() > 0) {
           String str = element.getString();
-          if (!str.isEmpty()) {
+          if (!StringTools.isEmpty(str)) {
             tokenSet.add(str.toLowerCase());
           }
         }

File: languagetool-core/src/main/java/org/languagetool/AnalyzedSentence.java
Patch:
@@ -168,7 +168,7 @@ private String toString(String readingDelimiter, boolean includeChunks) {
    * Get disambiguator actions log.
    */
   public final String getAnnotations() {
-    final StringBuilder sb = new StringBuilder();
+    final StringBuilder sb = new StringBuilder(40);
     sb.append("Disambiguator log: \n");
     for (final AnalyzedTokenReadings element : tokens) {
       if (!element.isWhitespace() &&

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/MultiWordChunker.java
Patch:
@@ -189,7 +189,7 @@ private AnalyzedTokenReadings setAndAnnotate(final AnalyzedTokenReadings oldRead
   }
   
   private String annotateToken(final String prevAnot, final String oldReading, final String newReading) {
-    final StringBuilder sb = new StringBuilder();
+    final StringBuilder sb = new StringBuilder(40);
     sb.append(prevAnot);
     sb.append("\nMULTIWORD_CHUNKER: ");
     sb.append(oldReading);

File: languagetool-core/src/main/java/org/languagetool/tools/StringTools.java
Patch:
@@ -316,7 +316,7 @@ public static String ruleMatchesToXML(final List<RuleMatch> ruleMatches,
     //
     // IMPORTANT: people rely on this format, don't change it!
     //
-    final StringBuilder xml = new StringBuilder();
+    final StringBuilder xml = new StringBuilder(200);
 
     if (xmlMode == XmlPrintMode.NORMAL_XML || xmlMode == XmlPrintMode.START_XML) {
       xml.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");

File: languagetool-language-modules/pl/src/main/java/org/languagetool/tokenizers/pl/PolishWordTokenizer.java
Patch:
@@ -102,7 +102,7 @@ public List<String> tokenize(final String text) {
         if (token.endsWith("-")) {
           l.add(token.substring(0, token.length() - 1));
           l.add("-");
-        } else if (token.startsWith("-")) {
+        } else if (token.charAt(0) == '-') {
           l.add("-");
           l.add(token.substring(1, token.length()));
         } else if (token.contains("-")) {

File: languagetool-standalone/src/main/java/org/languagetool/gui/ResultArea.java
Patch:
@@ -106,7 +106,7 @@ public void languageToolEventOccurred(LanguageToolEvent event) {
 
   private String getRuleMatchHtml(List<RuleMatch> ruleMatches, String text, String startCheckText) {
     final ContextTools contextTools = new ContextTools();
-    final StringBuilder sb = new StringBuilder();
+    final StringBuilder sb = new StringBuilder(200);
     sb.append(startCheckText);
     sb.append("<br>\n");
     int i = 0;
@@ -151,7 +151,7 @@ private String getRuleMatchHtml(List<RuleMatch> ruleMatches, String text, String
   }
 
   private String getDisabledRulesHtml() {
-    final StringBuilder sb = new StringBuilder();
+    final StringBuilder sb = new StringBuilder(40);
     sb.append(messages.getString("deactivatedRulesText"));
     int i = 0;
     int deactivatedRuleCount = 0;

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/ConfigurationDialog.java
Patch:
@@ -477,7 +477,7 @@ public int getServerPort() {
     return Integer.parseInt(serverPortField.getText());
   }
 
-  class CategoryComparator implements Comparator<Rule> {
+  static class CategoryComparator implements Comparator<Rule> {
 
     @Override
     public int compare(final Rule r1, final Rule r2) {

File: languagetool-core/src/main/java/org/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -189,9 +189,7 @@ public final boolean hasPartialPosTag(final String posTag) {
    */
   public final void addReading(final AnalyzedToken token) {
     final ArrayList<AnalyzedToken> l = new ArrayList<>();
-    for (int i = 0; i < anTokReadings.length - 1; i++) {
-      l.add(anTokReadings[i]);
-    }
+      l.addAll(Arrays.asList(anTokReadings).subList(0, anTokReadings.length - 1));
     if (anTokReadings[anTokReadings.length - 1].getPOSTag() != null) {
       l.add(anTokReadings[anTokReadings.length - 1]);
     }

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/Unifier.java
Patch:
@@ -320,9 +320,7 @@ public final AnalyzedTokenReadings[] getUnifiedTokens() {
       }
       firstUnified = true;
     }
-    final AnalyzedTokenReadings[] atr =
-        tokSequence.toArray(new AnalyzedTokenReadings[tokSequence.size()]);
-    return atr;
+      return tokSequence.toArray(new AnalyzedTokenReadings[tokSequence.size()]);
   }
 
   /**

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/MultiWordChunker.java
Patch:
@@ -71,7 +71,7 @@ private void lazyInit() {
         firstTokens = new String[tokenAndTag[0].length()];
         firstToken = tokenAndTag[0].substring(0, 1);
         for (int i = 1; i < tokenAndTag[0].length(); i++) {
-          firstTokens[i] = tokenAndTag[0].substring(0 + (i - 1), i);
+          firstTokens[i] = tokenAndTag[0].substring((i - 1), i);
         }
         if (mStartNoSpace.containsKey(firstToken)) {
           if (mStartNoSpace.get(firstToken) < firstTokens.length) {

File: languagetool-core/src/main/java/org/languagetool/tokenizers/SRXSentenceTokenizer.java
Patch:
@@ -58,8 +58,7 @@ private static SrxDocument createSrxDocument() {
       final Map<String, Object> parserParameters = new HashMap<>();
       parserParameters.put(Srx2SaxParser.VALIDATE_PARAMETER, true);
       final SrxParser srxParser = new Srx2SaxParser(parserParameters);
-      final SrxDocument document = srxParser.parse(srxReader);
-      return document;
+        return srxParser.parse(srxReader);
     } catch (IOException e) {
       throw new RuntimeException("Could not load rules " + RULES + " from resource dir "
               + JLanguageTool.getDataBroker().getResourceDir(), e);

File: languagetool-language-modules/ja/src/main/java/org/languagetool/tagging/ja/JapaneseTagger.java
Patch:
@@ -68,7 +68,7 @@ private AnalyzedToken asAnalyzedToken(final String word) {
   public static final String arrayToString(byte[] bytes) {
     StringBuffer buff = new StringBuffer();
     for (int i = 0; i < bytes.length; i++) {
-      buff.append(bytes[i] + " ");
+      buff.append(bytes[i]).append(" ");
     }
     return buff.toString();
   }

File: languagetool-language-modules/km/src/main/java/org/languagetool/rules/km/KhmerSimpleReplaceRule.java
Patch:
@@ -49,6 +49,7 @@
  * @version $Id: SimpleReplaceRule.java,v 1.9 2010/10/03 13:21:16 archeus Exp $
  *
  */
+@SuppressWarnings("ToArrayCallWithZeroLengthArrayArgument")
 public class KhmerSimpleReplaceRule extends Rule {
 
   public static final String KHMER_SIMPLE_REPLACE_RULE = "KM_SIMPLE_REPLACE";
@@ -219,7 +220,8 @@ public RuleMatch[] match(final AnalyzedSentence text) {
       addToQueue(tokens[i], prevTokens);
       final StringBuilder sb = new StringBuilder();
       final ArrayList<String> variants = new ArrayList<>();
-      final List<AnalyzedTokenReadings> prevTokensList = Arrays.asList(prevTokens.toArray(new AnalyzedTokenReadings[] {}));
+      final List<AnalyzedTokenReadings> prevTokensList =
+              Arrays.asList(prevTokens.toArray(new AnalyzedTokenReadings[prevTokens.size()]));
       for (int j = prevTokensList.size() - 1; j >= 0; j--) {
         if (j != prevTokensList.size() - 1 && prevTokensList.get(j + 1).isWhitespaceBefore())
           sb.insert(0, " ");

File: languagetool-language-modules/ro/src/main/java/org/languagetool/rules/ro/SimpleReplaceRule.java
Patch:
@@ -225,7 +225,8 @@ public RuleMatch[] match(final AnalyzedSentence text) {
       addToQueue(tokens[i], prevTokens);
       final StringBuilder sb = new StringBuilder();
       final ArrayList<String> variants = new ArrayList<>();
-      final List<AnalyzedTokenReadings> prevTokensList = Arrays.asList(prevTokens.toArray(new AnalyzedTokenReadings[] {}));
+      final List<AnalyzedTokenReadings> prevTokensList =
+              Arrays.asList(prevTokens.toArray(new AnalyzedTokenReadings[prevTokens.size()]));
       for (int j = prevTokensList.size() - 1; j >= 0; j--) {
         if (j != prevTokensList.size() - 1 && prevTokensList.get(j + 1).isWhitespaceBefore())
           sb.insert(0, " ");

File: languagetool-language-modules/zh/src/main/java/org/languagetool/tagging/zh/ChineseTagger.java
Patch:
@@ -72,7 +72,7 @@ public static final String arrayToString(byte[] bytes) {
     StringBuffer buff = new StringBuffer();
 
     for (int i = 0; i < bytes.length; i++) {
-      buff.append(bytes[i] + " ");
+      buff.append(bytes[i]).append(" ");
     }
     return buff.toString();
   }

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/index/LanguageToolFilter.java
Patch:
@@ -110,9 +110,9 @@ public boolean incrementToken() throws IOException {
       //termAtt.append("SENT_START");
       typeAtt.setType("pos");
       if (toLowerCase) {
-        termAtt.append(POS_PREFIX.toLowerCase() + tr.getAnalyzedToken(0).getPOSTag().toLowerCase());
+        termAtt.append(POS_PREFIX.toLowerCase()).append(tr.getAnalyzedToken(0).getPOSTag().toLowerCase());
       } else {
-        termAtt.append(POS_PREFIX + tr.getAnalyzedToken(0).getPOSTag());
+        termAtt.append(POS_PREFIX).append(tr.getAnalyzedToken(0).getPOSTag());
       }
       return true;
     }

File: languagetool-core/src/main/java/org/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -505,8 +505,8 @@ private boolean areLemmasSame() {
     String previousLemma = anTokReadings[0].getLemma();
     if (previousLemma == null) {
       for (AnalyzedToken element : anTokReadings) {
-        if (element.getLemma() == null) {
-          continue;
+        if (element.getLemma() != null) {
+          return false;
         }
       }
       return true;

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractSimpleReplaceRule.java
Patch:
@@ -125,7 +125,9 @@ public final RuleMatch[] match(final AnalyzedSentence text) {
 
     for (AnalyzedTokenReadings tokenReadings : tokens) {
 
-      if (tokenReadings.isImmunized()) {
+      //this rule is used mostly for spelling, so ignore both immunized
+      // and speller-ignorable rules
+      if (tokenReadings.isImmunized() || tokenReadings.isIgnoredBySpeller()) {
         continue;
       }
 

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -100,7 +100,7 @@ public RuleMatch[] match(AnalyzedSentence text) throws IOException {
       if (isUrl(token.getToken())) {
         continue;
       }
-      if (ignoreToken(tokens, idx) || token.isImmunized()) {
+      if (ignoreToken(tokens, idx) || token.isImmunized() || token.isIgnoredBySpeller()) {
         continue;
       }
       if (ignoreTaggedWords && token.isTagged()) {

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleMatcherTest.java
Patch:
@@ -159,7 +159,6 @@ public void testZeroMinTwoMaxOccurrences() throws Exception {
   }
 
   @Test
-  // @Ignore("currently fails")
   public void testTwoMaxOccurrencesWithAnyToken() throws Exception {
     final Element anyElement = makeElement(null);
     anyElement.setMaxOccurrence(2);
@@ -170,7 +169,6 @@ public void testTwoMaxOccurrencesWithAnyToken() throws Exception {
   }
 
   @Test
-  // @Ignore("currently fails")
   public void testThreeMaxOccurrencesWithAnyToken() throws Exception {
     final Element anyElement = makeElement(null);
     anyElement.setMaxOccurrence(3);
@@ -182,7 +180,6 @@ public void testThreeMaxOccurrencesWithAnyToken() throws Exception {
   }
 
   @Test
-  // @Ignore("currently fails")
   public void testZeroMinTwoMaxOccurrencesWithAnyToken() throws Exception {
     final Element anyElement = makeElement(null);
     anyElement.setMinOccurrence(0);

File: languagetool-language-modules/pl/src/main/java/org/languagetool/tokenizers/pl/PolishWordTokenizer.java
Patch:
@@ -124,7 +124,7 @@ public List<String> tokenize(final String text) {
                 if (taggedToks.size() == 3
                     && !taggedToks.get(2).isTagged()
                     // "niemiecko-indonezyjski"
-                    && (taggedToks.get(0).hasPosTag("adv:pos")
+                    && (taggedToks.get(0).hasPosTag("adja")
                         && taggedToks.get(1).hasPartialPosTag("adj:")
                         // "kobieta-wojownik"
                         || taggedToks.get(0).hasPartialPosTag("subst:")

File: languagetool-language-modules/pl/src/test/java/org/languagetool/rules/pl/MorfologikPolishSpellerRuleTest.java
Patch:
@@ -45,6 +45,9 @@ public void testMorfologikSpeller() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence(",")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("123454")).length);
 
+    //compound word with ignored part "techniczno"
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("Bogactwo nie rośnie proporcjonalnie do jej rozwoju techniczno-terytorialnego.")).length);
+
     //incorrect sentences:
 
     final RuleMatch[] matches = rule.match(langTool.getAnalyzedSentence("Zolw"));

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -80,6 +80,8 @@ public class CaseRule extends GermanRule {
      * solution is to add all those to our Morphy data, but as a simple
      * workaround to avoid false alarms, these words can be added here.
      */
+    exceptions.add("Abs");   // Abs. = Abkürzung für Absatz, Absender, ...
+    exceptions.add("Klappe");
     exceptions.add("Vorfahre");
     exceptions.add("Mittler");
     exceptions.add("Hr");   // Hr. = Abkürzung für Herr

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -360,6 +360,7 @@ public class CaseRule extends GermanRule {
 
   private static final Set<String> substVerbenExceptions = new HashSet<>();
   static {
+    substVerbenExceptions.add("klar");
     substVerbenExceptions.add("heißen");
     substVerbenExceptions.add("einen");
     substVerbenExceptions.add("gehören");

File: languagetool-language-modules/en/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -89,6 +89,7 @@ public void testEnglish() throws IOException {
     assertEquals(0, tool.check("Later, you shall know it better.").size());
     assertEquals(0, tool.check("And the few must win what the many lose, for the opposite arrangement would not support markets as we know them at all, and is, in fact, unimaginable.").size());
     assertEquals(0, tool.check("He explained his errand, but without bothering much to make it plausible, for he felt something well up in him which was the reason why he had fled the army.").size());
+    assertEquals(0, tool.check("I think it's better, and it's not a big deal.").size());
 
     assertEquals(1, tool.check("A test test that should give errors.").size());
     assertEquals(0, tool.check("I can give you more a detailed description.").size());

File: languagetool-language-modules/en/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -88,6 +88,7 @@ public void testEnglish() throws IOException {
     assertEquals(0, tool.check("It's a kind of agreement in which each party gives something to the other, Jack said.").size());
     assertEquals(0, tool.check("Later, you shall know it better.").size());
     assertEquals(0, tool.check("And the few must win what the many lose, for the opposite arrangement would not support markets as we know them at all, and is, in fact, unimaginable.").size());
+    assertEquals(0, tool.check("He explained his errand, but without bothering much to make it plausible, for he felt something well up in him which was the reason why he had fled the army.").size());
 
     assertEquals(1, tool.check("A test test that should give errors.").size());
     assertEquals(0, tool.check("I can give you more a detailed description.").size());

File: languagetool-language-modules/en/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -86,6 +86,8 @@ public void testEnglish() throws IOException {
     assertEquals(0, tool.check("Anatomy and geometry are fused in one, and each does something to the other.").size());
     assertEquals(0, tool.check("Certain frogs that lay eggs underground have unpigmented eggs.").size());
     assertEquals(0, tool.check("It's a kind of agreement in which each party gives something to the other, Jack said.").size());
+    assertEquals(0, tool.check("Later, you shall know it better.").size());
+    assertEquals(0, tool.check("And the few must win what the many lose, for the opposite arrangement would not support markets as we know them at all, and is, in fact, unimaginable.").size());
 
     assertEquals(1, tool.check("A test test that should give errors.").size());
     assertEquals(0, tool.check("I can give you more a detailed description.").size());

File: languagetool-language-modules/en/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -84,6 +84,7 @@ public void testEnglish() throws IOException {
     assertEquals(0, tool.check("No one trusts him any more.").size());
     assertEquals(0, tool.check("A member of the United Nations since 1992, Azerbaijan was elected to membership in the newly established Human Rights Council by the United Nations General Assembly on May 9, 2006 (the term of office began on June 19, 2006).").size());
     assertEquals(0, tool.check("Anatomy and geometry are fused in one, and each does something to the other.").size());
+    assertEquals(0, tool.check("Certain frogs that lay eggs underground have unpigmented eggs.").size());
 
     assertEquals(1, tool.check("A test test that should give errors.").size());
     assertEquals(0, tool.check("I can give you more a detailed description.").size());

File: languagetool-language-modules/en/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -83,6 +83,7 @@ public void testEnglish() throws IOException {
     assertEquals(0, tool.check("Dog mushing is more of a sport than a true means of transportation.").size());
     assertEquals(0, tool.check("No one trusts him any more.").size());
     assertEquals(0, tool.check("A member of the United Nations since 1992, Azerbaijan was elected to membership in the newly established Human Rights Council by the United Nations General Assembly on May 9, 2006 (the term of office began on June 19, 2006).").size());
+    assertEquals(0, tool.check("Anatomy and geometry are fused in one, and each does something to the other.").size());
 
     assertEquals(1, tool.check("A test test that should give errors.").size());
     assertEquals(0, tool.check("I can give you more a detailed description.").size());

File: languagetool-language-modules/en/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -73,14 +73,16 @@ public void spellCheckerDemoCodeForHomepage() throws IOException {
   public void testEnglish() throws IOException {
     final JLanguageTool tool = new JLanguageTool(new English());
     assertEquals(0, tool.check("A test that should not give errors.").size());
+
     //more error-free sentences to deal with possible regressions
     assertEquals(0, tool.check("As long as you have hope, a chance remains.").size());
     assertEquals(0, tool.check("A rolling stone gathers no moss.").size());
     assertEquals(0, tool.check("Hard work causes fitness.").size());
     assertEquals(0, tool.check("Gershwin overlays the slow blues theme from section B in the final “Grandioso.”").size());
     assertEquals(0, tool.check("Making ingroup membership more noticeable increases cooperativeness.").size());
     assertEquals(0, tool.check("Dog mushing is more of a sport than a true means of transportation.").size());
-    assertEquals(0, tool.check("Criminal cases may lead to fines or other punishment, such as imprisonment.").size());
+    assertEquals(0, tool.check("No one trusts him any more.").size());
+    assertEquals(0, tool.check("A member of the United Nations since 1992, Azerbaijan was elected to membership in the newly established Human Rights Council by the United Nations General Assembly on May 9, 2006 (the term of office began on June 19, 2006).").size());
 
     assertEquals(1, tool.check("A test test that should give errors.").size());
     assertEquals(0, tool.check("I can give you more a detailed description.").size());

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/atom/MatchDatabase.java
Patch:
@@ -116,7 +116,7 @@ int markedFixed(WikipediaRuleMatch ruleMatch) {
       prepSt.setString(6, ruleMatch.getErrorContext());
       return prepSt.executeUpdate();
     } catch (SQLException e) {
-      throw new RuntimeException("Could not make rule match " + ruleMatch + " as fixed in database", e);
+      throw new RuntimeException("Could not mark rule match " + ruleMatch + " as fixed in database", e);
     }
   }
 

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tagging/ca/CatalanTagger.java
Patch:
@@ -92,7 +92,7 @@ public List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens)
       final boolean isLowercase = word.equals(lowerWord);
       final boolean isMixedCase = StringTools.isMixedCase(word);
       List<AnalyzedToken> manualTaggerTokens=manualTagsAsAnalyzedTokenList(word, manualTagger.lookup(word));
-      List<AnalyzedToken> manualLowerTaggerTokens=manualTagsAsAnalyzedTokenList(lowerWord, manualTagger.lookup(lowerWord));
+      List<AnalyzedToken> manualLowerTaggerTokens=manualTagsAsAnalyzedTokenList(word, manualTagger.lookup(lowerWord));
 
       // normal case, manual tagger
       addTokens(manualTaggerTokens, l);

File: languagetool-language-modules/ca/src/test/java/org/languagetool/tagging/ca/CatalanTaggerTest.java
Patch:
@@ -41,6 +41,7 @@ public void testDictionary() throws IOException {
   }
 
   public void testTagger() throws IOException {
+    TestTools.myAssert("Color", "Color/[color]NCFS000|Color/[color]NCMS000", tokenizer, tagger);
     TestTools.myAssert("UPF", "UPF/[UPF]NPFSO00", tokenizer, tagger);
     TestTools
         .myAssert(

File: languagetool-commandline/src/test/java/org/languagetool/commandline/MainTest.java
Patch:
@@ -316,7 +316,8 @@ public void testPolishFileAPI() throws Exception {
     assertTrue(output.contains("<error fromy=\"0\" fromx=\"8\" toy=\"0\" tox=\"20\" ruleId=\"BRAK_PRZECINKA_KTORY\""));
     //This tests whether XML encoding is actually UTF-8:
     assertTrue(output.contains("msg=\"Brak przecinka w tym fragmencie zdania. Przecinek prawdopodobnie należy postawić tak: 'świnia, która'.\" replacements=\"świnia, która\" "));
-    assertTrue(output.contains("context=\"To jest świnia która się ślini.  \" contextoffset=\"8\" offset=\"8\" errorlength=\"12\" category=\"Błędy interpunkcyjne\""));
+    assertTrue(output.contains("context=\"To jest świnia która się ślini."));
+    assertTrue(output.contains("contextoffset=\"8\" offset=\"8\" errorlength=\"12\" category=\"Błędy interpunkcyjne\""));
   }
 
   public void testPolishLineNumbers() throws Exception {

File: languagetool-language-modules/en/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -110,9 +110,10 @@ public void testPositionsWithEnglishTwoLineBreaks() throws IOException {
   public void testAnalyzedSentence() throws IOException {
     final JLanguageTool tool = new JLanguageTool(new English());
     //test soft-hyphen ignoring:
-    assertEquals("<S> This[this/DT,B-NP-singular|E-NP-singular] is[be/VBZ,B-VP] a[a/DT,B-NP-singular] " +
+    assertEquals("<S> This[this/DT,B-NP-singular|E-NP-singular] " +
+        "is[be/VBZ,B-VP] a[a/DT,B-NP-singular] " +
         "test­ed[tested/JJ,test/VBD,test/VBN,test­ed/null,I-NP-singular] " +
-        "sentence[sentence/NN,sentence/VB,sentence/VBP,E-NP-singular].[./.,</S>,O]",
+        "sentence[sentence/NN,E-NP-singular].[./.,</S>,O]",
         tool.getAnalyzedSentence("This is a test\u00aded sentence.").toString());
     //test paragraph ends adding
     assertEquals("<S> </S><P/> ", tool.getAnalyzedSentence("\n").toString());

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/CatalanUnpairedBracketsRule.java
Patch:
@@ -36,7 +36,7 @@ public class CatalanUnpairedBracketsRule extends GenericUnpairedBracketsRule {
   
   private static final Pattern VALID_BEFORE_CLOSING_PARENTHESIS = Pattern
       .compile("\\d+|[a-zA-Z]", Pattern.UNICODE_CASE);
-  private static final Pattern NUMBER = Pattern.compile("[\\d., ]+", Pattern.UNICODE_CASE);
+  private static final Pattern NUMBER = Pattern.compile("\\d[\\d., ]+\\d|\\d{1,2}", Pattern.UNICODE_CASE);
 
   public CatalanUnpairedBracketsRule(final ResourceBundle messages,
       final Language language) {
@@ -69,8 +69,8 @@ protected boolean isNoException(final String tokenStr,
     if (("\"".equals(tokenStr) || "'".equals(tokenStr))
         && NUMBER.matcher(tokens[i - 1].getToken()).matches()
         && !tokens[i].isWhitespaceBefore()
-        && ((i > 3 && tokens[i - 2].getToken().contains("º") || tokens[i - 2].getToken().contains("°"))
-        || (i > 5 && tokens[i - 4].getToken().contains("º") || tokens[i - 4].getToken().contains("°")))) {
+        && ((i > 2 && (tokens[i - 2].getToken().contains("º") || tokens[i - 2].getToken().contains("°")))
+        || (i > 4 && (tokens[i - 4].getToken().contains("º") || tokens[i - 4].getToken().contains("°"))))) {
       return false;
     }
 

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/CatalanUnpairedBracketsRuleTest.java
Patch:
@@ -85,6 +85,7 @@ public void testRule() throws IOException {
     assertCorrect ("Porta-me'n cinquanta!");
 
     // incorrect sentences:
+    assertIncorrect("Ploraria.\"");
     assertIncorrect("Aquesta és l555’hora de les decisions.");
     assertIncorrect("Vine\", li va dir.");
     assertIncorrect("Aquesta és l‘hora de les decisions.");

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tokenizers/ca/CatalanWordTokenizer.java
Patch:
@@ -88,8 +88,9 @@ public CatalanWordTokenizer() {
 
     // match verb+1 pronom feble. Ex: Emporta't, vés-hi, porta'm.
     // It creates 2 tokens: <token>Emporta</token><token>'t</token>
+    // ^(.+[^cbfhjkovwyzCBFHJKOVWYZ])
     patterns[6] = Pattern.compile("^([lnmtsd]')(.{2,})"+PF+"$",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
-    patterns[7] = Pattern.compile("^(.+[^cbfhjkovwyzCBFHJKOVWYZ])"+PF+"$",Pattern.UNICODE_CASE);
+    patterns[7] = Pattern.compile("^(.{2,})"+PF+"$",Pattern.UNICODE_CASE);
 
     // d'emportar
     patterns[8] = Pattern.compile("^([lnmtsd]')(.*)$",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/ContractionSpellingRuleTest.java
Patch:
@@ -44,6 +44,8 @@ public void testRule() throws IOException {
 
     // correct sentences:
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("It wasn't me.")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("I'm ill.")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("Staatszerfall im südlichen Afrika.")).length);
 
     // incorrect sentences:
 

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -60,6 +60,7 @@ public void testRule() throws IOException {
 	      han estat de fet exterminades
 	   */
 	  // (en especial si hi ha un adverbi entremig: en algun grau més distintes
+	  assertCorrect("tenen en canvi altres parts de llur estructura certament molt anormals:");
     assertCorrect("constitueix l'única comunitat autònoma amb menys aturats");
 	  assertCorrect("durant tot l'any, i del sud-est, més notoris a la primavera");
 	  assertCorrect("amb la veu i el posat cada cop més agressius");

File: languagetool-standalone/src/main/java/org/languagetool/gui/ResultArea.java
Patch:
@@ -124,7 +124,7 @@ private String getRuleMatchHtml(List<RuleMatch> ruleMatches, String text, String
         final String replacement = StringTools.listToString(match.getSuggestedReplacements(), "; ");
         sb.append("<b>").append(messages.getString("correctionMessage")).append("</b> ").append(replacement).append("<br>\n");
       }
-      if (match.getRule().isSpellingRule()) {
+      if ("misspelling".equals(match.getRule().getLocQualityIssueType())) {
         contextTools.setErrorMarkerStart(SPELL_ERROR_MARKER_START);
       } else {
         contextTools.setErrorMarkerStart(LT_ERROR_MARKER_START);

File: languagetool-office-extension/src/main/java/org/languagetool/openoffice/Main.java
Patch:
@@ -745,8 +745,7 @@ public void run() {
   }
 
   /**
-   * Called from grammar/spell checking dialog to ignore a rule (not called when
-   * "Ignore" is selected in the context menu for an error.)
+   * Called when "Ignore" is selected e.g. in the context menu for an error.
    */
   @Override
   public void ignoreRule(final String ruleId, final Locale locale)

File: languagetool-language-modules/en/src/main/java/org/languagetool/tokenizers/en/EnglishWordTokenizer.java
Patch:
@@ -43,7 +43,7 @@ public List<String> tokenize(final String text) {
             + "\u2028\u2029\u202a\u202b\u202c\u202d\u202e\u202f"
             + "\u205F\u2060\u2061\u2062\u2063\u206A\u206b\u206c\u206d"
             + "\u206E\u206F\u3000\u3164\ufeff\uffa0\ufff9\ufffa\ufffb"
-            + ",.;=#()[]{}<>!?:/|\\\"'«»„”“`´‘’‛′…¿¡\t\n\r", true);
+            + ",.;=#*()[]{}<>!?:/|\\\"'«»„”“`´‘’‛′…¿¡\t\n\r", true);
     while (st.hasMoreElements()) {
       final String token = st.nextToken();
       if (token.length() > 1 && token.endsWith("-")) {

File: languagetool-language-modules/en/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -77,6 +77,7 @@ public void testEnglish() throws IOException {
     assertEquals(0, tool.check("I can give you more a detailed description.").size());
     assertEquals(11, tool.getAllRules().size());
     tool.activateDefaultPatternRules();
+    assertEquals(0, tool.check("The sea ice is highly variable - frozen solid during cold, calm weather and broke...").size());
     assertTrue(tool.getAllRules().size() > 3);
     assertEquals(1, tool.check("I can give you more a detailed description.").size());
     tool.disableRule("MORE_A_JJ");

File: languagetool-language-modules/en/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -77,7 +77,6 @@ public void testEnglish() throws IOException {
     assertEquals(0, tool.check("I can give you more a detailed description.").size());
     assertEquals(11, tool.getAllRules().size());
     tool.activateDefaultPatternRules();
-    assertEquals(0, tool.check("The sea ice is highly variable - frozen solid during cold, calm weather and broke...").size());
     assertTrue(tool.getAllRules().size() > 3);
     assertEquals(1, tool.check("I can give you more a detailed description.").size());
     tool.disableRule("MORE_A_JJ");

File: languagetool-language-modules/en/src/test/java/org/languagetool/rules/en/EnglishWordTokenizerTest.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package org.languagetool.tokenizers;
+package org.languagetool.rules.en;
 
 import java.util.List;
 
@@ -44,8 +44,8 @@ public void testTokenize() {
     assertEquals("[Now,  , this,  , is-really, !, -a,  , test, .]", tokens3.toString());
     //hyphen at the end of the word
     final List <String> tokens4 = wordTokenizer.tokenize("Now this is- really!- a test.");
-    assertEquals(tokens4.size(), 15);
-    assertEquals("[Now,  , this,  , is, -,  , really, !, -,  , a,  , test, .]", tokens4.toString());
+    assertEquals(tokens4.size(), 16);
+    assertEquals("[Now,  , this,  , is, -,  , really, !, , -,  , a,  , test, .]", tokens4.toString());
   }
 
   public void testUrlTokenize() {

File: languagetool-language-modules/en/src/main/java/org/languagetool/tokenizers/en/EnglishWordTokenizer.java
Patch:
@@ -18,7 +18,7 @@
  */
 package org.languagetool.tokenizers.en;
 
-import java.util.ArrayList;
+ import java.util.ArrayList;
 import java.util.List;
 import java.util.StringTokenizer;
 

File: languagetool-language-modules/en/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -77,6 +77,7 @@ public void testEnglish() throws IOException {
     assertEquals(0, tool.check("I can give you more a detailed description.").size());
     assertEquals(11, tool.getAllRules().size());
     tool.activateDefaultPatternRules();
+    assertEquals(0, tool.check("The sea ice is highly variable - frozen solid during cold, calm weather and broke...").size());
     assertTrue(tool.getAllRules().size() > 3);
     assertEquals(1, tool.check("I can give you more a detailed description.").size());
     tool.disableRule("MORE_A_JJ");

File: languagetool-language-modules/en/src/test/java/org/languagetool/tokenizers/EnglishWordTokenizerTest.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package org.languagetool.rules.en;
+package org.languagetool.tokenizers;
 
 import java.util.List;
 
@@ -44,8 +44,8 @@ public void testTokenize() {
     assertEquals("[Now,  , this,  , is-really, !, -a,  , test, .]", tokens3.toString());
     //hyphen at the end of the word
     final List <String> tokens4 = wordTokenizer.tokenize("Now this is- really!- a test.");
-    assertEquals(tokens4.size(), 16);
-    assertEquals("[Now,  , this,  , is, -,  , really, !, , -,  , a,  , test, .]", tokens4.toString());
+    assertEquals(tokens4.size(), 15);
+    assertEquals("[Now,  , this,  , is, -,  , really, !, -,  , a,  , test, .]", tokens4.toString());
   }
 
   public void testUrlTokenize() {

File: languagetool-language-modules/en/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -77,6 +77,7 @@ public void testEnglish() throws IOException {
     assertEquals(0, tool.check("I can give you more a detailed description.").size());
     assertEquals(11, tool.getAllRules().size());
     tool.activateDefaultPatternRules();
+    assertEquals(0, tool.check("The sea ice is highly variable - frozen solid during cold, calm weather and broke...").size());
     assertTrue(tool.getAllRules().size() > 3);
     assertEquals(1, tool.check("I can give you more a detailed description.").size());
     tool.disableRule("MORE_A_JJ");

File: languagetool-language-modules/en/src/test/java/org/languagetool/tokenizers/EnglishWordTokenizerTest.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package org.languagetool.rules.en;
+package org.languagetool.tokenizers;
 
 import java.util.List;
 
@@ -44,8 +44,8 @@ public void testTokenize() {
     assertEquals("[Now,  , this,  , is-really, !, -a,  , test, .]", tokens3.toString());
     //hyphen at the end of the word
     final List <String> tokens4 = wordTokenizer.tokenize("Now this is- really!- a test.");
-    assertEquals(tokens4.size(), 16);
-    assertEquals("[Now,  , this,  , is, -,  , really, !, , -,  , a,  , test, .]", tokens4.toString());
+    assertEquals(tokens4.size(), 15);
+    assertEquals("[Now,  , this,  , is, -,  , really, !, -,  , a,  , test, .]", tokens4.toString());
   }
 
   public void testUrlTokenize() {

File: languagetool-language-modules/en/src/main/java/org/languagetool/rules/en/MorfologikAmericanSpellerRule.java
Patch:
@@ -1,4 +1,4 @@
-/* LanguageTool, a natural language style checker 
+/* LanguageTool, a natural language style checker
  * Copyright (C) 2012 Marcin Miłkowski (http://www.languagetool.org)
  * 
  * This library is free software; you can redistribute it and/or

File: languagetool-language-modules/de/src/main/java/org/languagetool/tagging/de/GermanTagger.java
Patch:
@@ -39,7 +39,7 @@
 /**
  * German part-of-speech tagger, requires data file in <code>resource/de/german.dict</code>.
  * The POS tagset is described in
- * <a href="https://https://github.com/languagetool-org/languagetool/blob/master/languagetool-language-modules/de/src/main/resources/org/languagetool/resource/de/tagset.txt">tagset.txt</a>
+ * <a href="https://github.com/languagetool-org/languagetool/blob/master/languagetool-language-modules/de/src/main/resources/org/languagetool/resource/de/tagset.txt">tagset.txt</a>
  *
  * @author Marcin Milkowski, Daniel Naber
  */

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -121,6 +121,8 @@ private GrammarCategory(String displayName) {
     PREPOSITIONS.add("bei");
     PREPOSITIONS.add("nach");
     PREPOSITIONS.add("über");
+    PREPOSITIONS.add("von");
+    PREPOSITIONS.add("mit");
     // TODO: add more
   }
   

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -124,6 +124,9 @@ public void testWrongVerbSubject() throws IOException {
     assertGood("Wobei wir benutzt haben, dass der Satz gilt.");
     assertGood("Wünschst du dir mehr Zeit?");
     assertGood("Wyrjtjbst du?"); // make sure that "UNKNOWN" is handled correctly
+    assertGood("Wenn ich du wäre, würde ich das nicht machen.");
+//     assertGood("Angenommen, du wärst ich."); TODO
+//     assertGood("Ich denke, dass das Haus, in das er gehen will, heute Morgen gestrichen worden ist."); TODO
     // incorrect sentences:
     assertBad("Auch morgen leben du.");
     assertBad("Auch morgen leben du"); // do not segfault because "du" is the last token

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -60,6 +60,7 @@ public void testRule() throws IOException {
 	      han estat de fet exterminades
 	   */
 	  // (en especial si hi ha un adverbi entremig: en algun grau més distintes
+    assertCorrect("constitueix l'única comunitat autònoma amb menys aturats");
 	  assertCorrect("durant tot l'any, i del sud-est, més notoris a la primavera");
 	  assertCorrect("amb la veu i el posat cada cop més agressius");
 	  assertCorrect("l'experiència sensitiva i la raó, degudament combinades.");

File: languagetool-standalone/src/main/java/org/languagetool/dev/DictionaryBuilder.java
Patch:
@@ -152,7 +152,7 @@ protected void readFreqList(File freqListFile) {
   
   protected File addFreqData(File dictFile) throws Exception {
     if (!isOptionTrue("fsa.dict.frequency-included")) {
-      throw new IOException("In order to use frequency data add the line 'dict.fsa.frequency-included=true' to the dictionary info file.");
+      throw new IOException("In order to use frequency data add the line 'fsa.dict.frequency-included=true' to the dictionary info file.");
     }
     String separator = getOption("fsa.dict.separator");
     if (separator == null || separator.trim().isEmpty()) {

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/atom/AtomFeedChecker.java
Patch:
@@ -138,7 +138,7 @@ CheckResult checkChanges(URL atomFeedUrl) throws IOException {
   }
 
   CheckResult checkChanges(InputStream xml) throws IOException {
-    Date lastDateOfPreviousRun = matchDatabase != null ? matchDatabase.getLatestDate() : null;
+    Date lastDateOfPreviousRun = matchDatabase != null ? matchDatabase.getLatestDate(language) : null;
     List<ChangeAnalysis> result = new ArrayList<>();
     long latestDiffId = 0;
     int skipCount = 0;

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/wikipedia/atom/MatchDatabaseTest.java
Patch:
@@ -38,7 +38,7 @@ public void test() throws SQLException, ClassNotFoundException {
     MatchDatabase database = new MatchDatabase("jdbc:derby:atomFeedChecksDB;create=true", "user", "pass");
     database.drop();
     database.createTable();
-    assertThat(database.getLatestDate(), is(new Date(0)));
+    assertThat(database.getLatestDate(language), is(new Date(0)));
     assertThat(database.list().size(), is(0));
     FakeRule rule1 = new FakeRule(1);
     rule1.setCategory(new Category("My Category"));
@@ -55,7 +55,7 @@ public void test() throws SQLException, ClassNotFoundException {
     assertThat(database.list().get(0).getDiffId(), is(123L));
     assertThat(database.list().get(0).getFixDiffId(), is(0L));
     assertThat(database.list().get(0).getEditDate(), is(new Date(10000)));
-    assertThat(database.getLatestDate(), is(new Date(10000)));
+    assertThat(database.getLatestDate(language), is(new Date(10000)));
     assertNull(database.list().get(0).getRuleSubId());
     assertNull(database.list().get(0).getFixDate());
 
@@ -67,7 +67,7 @@ public void test() throws SQLException, ClassNotFoundException {
     assertThat(database.list().get(0).getFixDate(), is(new Date(9000000000L)));
     assertThat(database.list().get(0).getDiffId(), is(123L));
     assertThat(database.list().get(0).getFixDiffId(), is(124L));
-    assertThat(database.getLatestDate(), is(new Date(9000000000L)));
+    assertThat(database.getLatestDate(language), is(new Date(9000000000L)));
   }
   
 }

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/atom/MatchDatabase.java
Patch:
@@ -67,7 +67,7 @@ void add(WikipediaRuleMatch ruleMatch) {
       } else {
         prepSt.setString(7, "<no category>");
       }
-      prepSt.setString(8, ruleMatch.getErrorContext());
+      prepSt.setString(8, StringUtils.abbreviate(ruleMatch.getErrorContext(), 500));
       prepSt.setTimestamp(9, new Timestamp(ruleMatch.getEditDate().getTime()));
       prepSt.setLong(10, ruleMatch.getDiffId());
       prepSt.execute();

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/dumpcheck/DatabaseHandler.java
Patch:
@@ -115,7 +115,7 @@ protected void handleResult(Sentence sentence, List<RuleMatch> ruleMatches, Lang
           continue;
         }
         insertSt.setString(7, context);
-        insertSt.setString(8, smallContext);
+        insertSt.setString(8, StringUtils.abbreviate(smallContext, 255));
         
         insertSt.setDate(9, nowDate);  // should actually be the dump's date, but isn't really used anyway...
         insertSt.setDate(10, nowDate);

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -296,6 +296,7 @@ public void testRule() throws IOException {
     assertIncorrect("tot l'auditori es callà");
     assertIncorrect("les gotes que es van caure fora"); 
     assertIncorrect("Ells s'han baixat del tren.");
+    assertIncorrect("Ximo Puig i Rubalcaba no s'han baixat del cotxe oficial des del 79.");
     assertIncorrect("Se'ns va callar.");
     assertIncorrect("Tothom es va callar.");
     assertIncorrect("Els nens van poder-se caure");  

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/LocationHelper.java
Patch:
@@ -20,15 +20,15 @@
 
 import xtc.tree.Location;
 
-class LocationHelper {
+public class LocationHelper {
 
   private LocationHelper() {
   }
 
   /**
    * Get an absolute position (character-based) for a line/column-based location.
    */
-  static int absolutePositionFor(Location location, String text) {
+  public static int absolutePositionFor(Location location, String text) {
     int line = 1;
     int col = 1;
     int pos = 0;

File: languagetool-core/src/main/java/org/languagetool/rules/Rule.java
Patch:
@@ -67,7 +67,7 @@ public Rule(final ResourceBundle messages) {
   }
 
   /**
-   * An ASCII-only string used to identify the rule in e.g. configuration files.
+   * A string used to identify the rule in e.g. configuration files.
    * This string is supposed to be unique and to stay the same in all upcoming
    * versions of LanguageTool.
    */

File: languagetool-standalone/src/main/java/org/languagetool/gui/Main.java
Patch:
@@ -318,7 +318,7 @@ private void createGUI() {
     languageBox.addItemListener(new ItemListener() {
       @Override
       public void itemStateChanged(ItemEvent e) {
-        if(e.getStateChange() == ItemEvent.SELECTED) {
+        if (e.getStateChange() == ItemEvent.SELECTED) {
           // we cannot re-use the existing LT object anymore
           ltSupport.setLanguage((Language) languageBox.getSelectedItem());
         }
@@ -342,13 +342,13 @@ public void languageToolEventOccurred(LanguageToolEvent event) {
         if (event.getType() == LanguageToolEvent.Type.CHECKING_STARTED) {
           final String msg = Tools.makeTexti18n(messages, "checkStart");
           statusLabel.setText(msg);
-          if(event.getCaller() == getFrame()) {
+          if (event.getCaller() == getFrame()) {
             startTime = System.currentTimeMillis();
             setWaitCursor();
             checkAction.setEnabled(false);
           }
         } else if (event.getType() == LanguageToolEvent.Type.CHECKING_FINISHED) {
-          if(event.getCaller() == getFrame()) {
+          if (event.getCaller() == getFrame()) {
             checkAction.setEnabled(true);
             unsetWaitCursor();
             resultAreaHelper.setRunTime(System.currentTimeMillis() - startTime);

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRule.java
Patch:
@@ -280,8 +280,8 @@ && matchRegexp(tokens[i - j].getToken(), COORDINACIO_IONI)) {
           //stop searching if there is some of these combinations: 
           //adverb+comma, adverb+conjunction, comma+conjunction
           adverbAppeared |= matchPostagRegexp(tokens[i - j], ADVERBI);
-          conjunctionAppeared |= matchPostagRegexp(tokens[i - j], CONJUNCIO);;
-          punctuationAppeared |= matchPostagRegexp(tokens[i - j], PUNTUACIO);;
+          conjunctionAppeared |= matchPostagRegexp(tokens[i - j], CONJUNCIO);
+          punctuationAppeared |= matchPostagRegexp(tokens[i - j], PUNTUACIO);
           if ((adverbAppeared && conjunctionAppeared) 
               || (adverbAppeared && punctuationAppeared)
               || (conjunctionAppeared && punctuationAppeared)) {

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleMatcher.java
Patch:
@@ -178,6 +178,8 @@ private RuleMatch createRuleMatch(final int[] tokenPositions,
     final PatternRule rule = (PatternRule) this.rule;
     final String errMessage = formatMatches(tokens, tokenPositions,
         firstMatchToken, rule.getMessage(), rule.getSuggestionMatches());
+    final String shortErrMessage = formatMatches(tokens, tokenPositions,
+        firstMatchToken, rule.getShortMessage(), rule.getSuggestionMatches());
     final String suggestionsOutMsg = formatMatches(tokens, tokenPositions,
         firstMatchToken, rule.getSuggestionsOutMsg(), rule.getSuggestionMatchesOutMsg());
     int correctedStPos = 0;
@@ -221,7 +223,7 @@ private RuleMatch createRuleMatch(final int[] tokenPositions,
       if (!(errMessage.contains(PatternRuleHandler.PLEASE_SPELL_ME) && errMessage.contains(MISTAKE))) {
         final String clearMsg = errMessage.replaceAll(PatternRuleHandler.PLEASE_SPELL_ME, "").replaceAll(MISTAKE, "");
         return new RuleMatch(rule, fromPos, toPos, clearMsg,
-            rule.getShortMessage(), startsWithUppercase, suggestionsOutMsg);
+                shortErrMessage, startsWithUppercase, suggestionsOutMsg);
       }
     } // failed to create any rule match...
     return null;

File: languagetool-language-modules/de/src/test/java/org/languagetool/tokenizers/de/GermanSRXSentenceTokenizerTest.java
Patch:
@@ -35,6 +35,7 @@ public void testTokenize() {
     // have correct whitespace when appended:
     testSplit("Dies ist ein Satz.");
     testSplit("Dies ist ein Satz. ", "Noch einer.");
+    testSplit("Dies ist ein Satz.¹ ", "Noch einer.");
     testSplit("Ein Satz! ", "Noch einer.");
     testSplit("Ein Satz... ", "Noch einer.");
     testSplit("Unter http://www.test.de gibt es eine Website.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -93,6 +93,9 @@ public void testDetNounRule() throws IOException {
 
     assertGood("... wo Krieg den Unschuldigen Leid und Tod bringt.");
     assertGood("Der Abschuss eines Papageien.");
+    
+    assertGood("Die Beibehaltung des Art. 1 ist geplant.");
+    assertGood("Die Verschiebung des bisherigen Art. 1 ist geplant.");
 
     // relative clauses:
     assertGood("Das Recht, das Frauen eingeräumt wird.");

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -420,6 +420,9 @@ protected void prepareRule(final PatternRule rule) {
     if (defaultOff) {
       rule.setDefaultOff();
     }
+    if (category == null) {
+      throw new RuntimeException("Cannot activate rule '" + id + "', it is outside of a <category>...</category>");
+    }
     if (category.isDefaultOff() && !defaultOn) {
       rule.setDefaultOff();
     }

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/dumpcheck/SentenceSourceChecker.java
Patch:
@@ -150,6 +150,7 @@ private void run(File propFile, Set<String> disabledRules, String langCode, List
         resultHandler = new StdoutHandler(maxSentences, maxErrors);
       }
       JLanguageTool langTool = new JLanguageTool(lang);
+      langTool.activateDefaultPatternRules();
       MixingSentenceSource mixingSource = MixingSentenceSource.create(fileNames, lang);
       while (mixingSource.hasNext()) {
         Sentence sentence = mixingSource.next();

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/dumpcheck/SentenceSource.java
Patch:
@@ -32,7 +32,7 @@
 abstract class SentenceSource implements Iterator<Sentence> {
 
   private static final int MIN_SENTENCE_SIZE = 10;
-  private static final int MIN_SENTENCE_TOKEN_COUNT = 3;
+  private static final int MIN_SENTENCE_TOKEN_COUNT = 4;
   private static final int MAX_SENTENCE_LENGTH = 300;
 
   private final Tokenizer wordTokenizer;
@@ -73,7 +73,7 @@ private int countTokens(String sentence) {
     int realTokens = 0;
     List<String> allTokens = wordTokenizer.tokenize(sentence);
     for (String token : allTokens) {
-      if (token.trim().isEmpty()) {
+      if (!token.trim().isEmpty()) {
         realTokens++;
       }
     }

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/dumpcheck/SentenceSourceIndexer.java
Patch:
@@ -27,7 +27,6 @@
 import org.languagetool.dev.index.Indexer;
 import org.xml.sax.helpers.DefaultHandler;
 
-import javax.xml.stream.XMLStreamException;
 import java.io.File;
 import java.io.IOException;
 import java.util.Arrays;
@@ -58,7 +57,7 @@ public void close() throws Exception {
     indexer.close();
   }
 
-  private void run(List<String> dumpFilesNames, Language language) throws IOException, XMLStreamException {
+  private void run(List<String> dumpFilesNames, Language language) throws IOException {
     MixingSentenceSource mixingSource = MixingSentenceSource.create(dumpFilesNames, language);
     while (mixingSource.hasNext()) {
       Sentence sentence = mixingSource.next();

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/dumpcheck/WikipediaSentenceSource.java
Patch:
@@ -51,6 +51,7 @@ class WikipediaSentenceSource extends SentenceSource {
   private final Language language;
 
   WikipediaSentenceSource(InputStream xmlInput, Language language) {
+    super(language);
     try {
       XMLInputFactory factory = XMLInputFactory.newInstance();
       reader = factory.createXMLEventReader(xmlInput);

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/dumpcheck/TatoebaSentenceSourceTest.java
Patch:
@@ -19,6 +19,7 @@
 package org.languagetool.dev.dumpcheck;
 
 import org.junit.Test;
+import org.languagetool.language.English;
 
 import java.io.InputStream;
 
@@ -32,7 +33,7 @@ public class TatoebaSentenceSourceTest {
   @Test
   public void testTatoebaSource() {
     InputStream stream = WikipediaSentenceSourceTest.class.getResourceAsStream("/org/languagetool/dev/wikipedia/tatoeba-en.txt");
-    TatoebaSentenceSource source = new TatoebaSentenceSource(stream);
+    TatoebaSentenceSource source = new TatoebaSentenceSource(stream, new English());
     assertTrue(source.hasNext());
     assertThat(source.next().getText(), is("\"What is your wish?\" asked the little white rabbit."));
     assertThat(source.next().getText(), is("The mother wakes up her daughter."));

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/SentenceSourceIndexer.java
Patch:
@@ -71,7 +71,7 @@ private void run(List<String> dumpFilesNames, Language language) throws IOExcept
       }
       indexer.index(sentence.getSentence(), sentence.getSource(), true, sentenceCount);
       sentenceCount++;
-      if (sentenceCount > maxDocs) {
+      if (sentenceCount >= maxDocs) {
         throw new DocumentLimitReachedException(maxDocs);
       }
     }

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/Unifier.java
Patch:
@@ -209,7 +209,7 @@ private boolean checkNext(final AnalyzedToken aToken,
           }
           allFeatsUnified &= featUnified;
         }
-        tokenFeaturesFound.set(i, allFeatsUnified);
+        tokenFeaturesFound.set(i, tokenFeaturesFound.get(i) & allFeatsUnified);
         anyFeatUnified = anyFeatUnified || allFeatsUnified;
       }
       unifiedNext &= anyFeatUnified;
@@ -308,7 +308,7 @@ public final AnalyzedTokenReadings[] getUnifiedTokens() {
       }
       tmpFeaturesFound.remove(tmpFeaturesFound.size() - 1);
       final int numRead = tokSequence.get(0).getReadingsLength();
-      if (numRead > 1) { // no need to filter if there is just one reading
+      if (numRead > 1 && first < numRead) { // no need to filter if there is just one reading
         tmpATR = new AnalyzedTokenReadings(tokSequence.get(0).getAnalyzedToken(
             first), 0);
         for (int i = first + 1; i <= Math.min(numRead - 1, tokCnt); i++) {

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/wikipedia/WikipediaQuickCheckTest.java
Patch:
@@ -31,7 +31,7 @@
 public class WikipediaQuickCheckTest extends TestCase {
 
   // only for interactive use, as it accesses a remote API
-  public void noTestCheckPage() throws IOException {
+  public void noTestCheckPage() throws IOException, PageNotFoundException {
     final WikipediaQuickCheck check = new WikipediaQuickCheck();
     //final String url = "http://de.wikipedia.org/wiki/Benutzer_Diskussion:Dnaber";
     //final String url = "http://de.wikipedia.org/wiki/OpenThesaurus";

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageToolListener.java
Patch:
@@ -27,5 +27,5 @@
  */
 interface LanguageToolListener extends EventListener {
 
-  public void languageToolEventOccured(LanguageToolEvent event);
+  public void languageToolEventOccurred(LanguageToolEvent event);
 }

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageToolSupport.java
Patch:
@@ -143,7 +143,7 @@ private void fireEvent(LanguageToolEvent.Type type, Object caller) {
     for (int i = listeners.length - 2; i >= 0; i -= 2) {
       if (listeners[i] == LanguageToolListener.class) {
         // Lazily create the event:
-        ((LanguageToolListener) listeners[i + 1]).languageToolEventOccured(event);
+        ((LanguageToolListener) listeners[i + 1]).languageToolEventOccurred(event);
       }
     }
   }

File: languagetool-standalone/src/main/java/org/languagetool/gui/Main.java
Patch:
@@ -332,7 +332,7 @@ public void itemStateChanged(ItemEvent e) {
     });    
     ltSupport.addLanguageToolListener(new LanguageToolListener() {
       @Override
-      public void languageToolEventOccured(LanguageToolEvent event) {
+      public void languageToolEventOccurred(LanguageToolEvent event) {
         if (event.getType() == LanguageToolEvent.Type.CHECKING_STARTED) {
           if(event.getCaller() == getFrame()) {
             startTime = System.currentTimeMillis();

File: languagetool-standalone/src/main/java/org/languagetool/gui/ResultArea.java
Patch:
@@ -70,7 +70,7 @@ class ResultArea {
     statusPane.setTransferHandler(new RetainLineBreakTransferHandler());
     ltSupport.addLanguageToolListener(new LanguageToolListener() {
       @Override
-      public void languageToolEventOccured(LanguageToolEvent event) {
+      public void languageToolEventOccurred(LanguageToolEvent event) {
         if (event.getType() == LanguageToolEvent.Type.CHECKING_STARTED) {
           final Language lang = ltSupport.getLanguageTool().getLanguage();
           final String langName;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -342,7 +342,8 @@ && isThereVerbBeforeList(tokens,i,verbHaver) )
             && isThereNearLemma(tokens, i, partsCos))
           continue loop;
         if (tokens[i].hasLemma("venir") || tokens[i].hasLemma("anar")) { //Em va bé
-          if (isVerbNumberPerson(tokens,i,VERB_3S) 
+          if (i+1<tokens.length 
+              && isVerbNumberPerson(tokens,i,VERB_3S) 
               && !isThereBefore(tokens, i, LEMMA_ES, POSTAG_ES)
               && matchPostagRegexp(tokens[i+1],POSTAG_ADVERBI)
               && !isThereNearWord(tokens, i, pronomJo) )

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/TextConverter.java
Patch:
@@ -204,6 +204,8 @@ public void visit(XmlEntityRef er) {
     String ch = EntityReferences.resolve(er.getName());
     if ("nbsp".equals(er.getName())) {
       write(' ');
+    } else if ("ndash".equals(er.getName()) || "mdash".equals(er.getName())) {
+      write('-');
     } else if (ch == null) {
       write('&');
       write(er.getName());

File: languagetool-core/src/main/java/org/languagetool/synthesis/BaseSynthesizer.java
Patch:
@@ -54,7 +54,6 @@ public BaseSynthesizer(final String resourceFileName, final String tagFileName)
    * Returns the {@link Dictionary} used for this synthesizer.
    * The dictionary file can be defined in the {@link #BaseSynthesizer(String, String) constructor}.
    * 
-   * @return
    * @throws IOException In case the dictionary cannot be loaded.
    */
   protected Dictionary getDictionary() throws IOException {
@@ -72,10 +71,8 @@ protected Dictionary getDictionary() throws IOException {
 
   /**
    * Creates a new {@link IStemmer} based on the configured {@link #getDictionary() dictionary}.
-   * 
    * The result must not be shared among threads.
    * 
-   * @return
    * @since 2.3
    */
   protected IStemmer createStemmer() {

File: languagetool-standalone/src/main/java/org/languagetool/gui/Main.java
Patch:
@@ -692,7 +692,9 @@ private void setTrayMode(boolean trayMode) {
   }
   
   public static void main(final String[] args) {
-    JnaTools.setBugWorkaroundProperty();
+      if (System.getSecurityManager() == null) {
+          JnaTools.setBugWorkaroundProperty();
+      }
     final Main prg = new Main();
     if (args.length == 1 && (args[0].equals("-t") || args[0].equals("--tray"))) {
       // dock to systray on startup

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -49,6 +49,8 @@ public void testRule() throws IOException {
     //assertCorrect("es van agenollar i prosternar");
     //assertCorrect("Una equivocació tan gran no es pot callar.");
     //assertCorrect(" és del tot necessari si no es vol caure en una religió alienant");
+    assertCorrect("cada zona més meridional esdevingué adient per als éssers àrtics");
+    assertCorrect("cereals, garrofers, vinya i olivar.");
     assertCorrect("m'aniria bé probablement posar els quilos");
     assertCorrect("tot m'aniria bé");
     assertCorrect("tot m'havia anat bé");

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/GeneralCatalan.java
Patch:
@@ -35,4 +35,4 @@ public String getShortName() {
     return "ca";
   }
   
-}
+}
\ No newline at end of file

File: languagetool-commandline/src/main/java/org/languagetool/commandline/CommandLineTools.java
Patch:
@@ -300,7 +300,7 @@ public static void profileRulesOnText(final String contents,
     final long[] workTime = new long[10];
     final List<Rule> rules = lt.getAllActiveRules();
     final int ruleCount = rules.size();
-    System.out.printf("Testing %d rules\n", ruleCount);
+    System.out.printf("Testing %d rules%n", ruleCount);
     System.out.println("Rule ID\tTime\tSentences\tMatches\tSentences per sec.");
     final List<String> sentences = lt.sentenceTokenize(contents);
     for (Rule rule : rules) {

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationPatternRuleReplacer.java
Patch:
@@ -217,6 +217,7 @@ private AnalyzedTokenReadings[] executeAction(final AnalyzedSentence text,
         for (int i = 0; i < matchingTokens - startPositionCorrection + endPositionCorrection; i++) {
           whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos + i)].immunize();
         }
+        break;
       case FILTER:
         if (matchElement == null) { // same as REPLACE if using <match>
           final Match tmpMatchToken = new Match(disambiguatedPOS, null,

File: languagetool-core/src/test/java/org/languagetool/rules/LongSentenceRuleTest.java
Patch:
@@ -38,7 +38,7 @@ public void testMatch() throws Exception {
             "a a a a a a a a a a a " +
             "a a a a a a a a a a a " +
             "rather that short text.")).length, is(1));
-    LongSentenceRule shortRule = new LongSentenceRule(6, TestTools.getEnglishMessages());
+    LongSentenceRule shortRule = new LongSentenceRule(TestTools.getEnglishMessages(), 6);
     assertThat(shortRule.match(languageTool.getAnalyzedSentence("This is a rather short text.")).length, is(0));
     assertThat(shortRule.match(languageTool.getAnalyzedSentence("This is also a rather short text.")).length, is(1));
   }

File: languagetool-core/src/main/java/org/languagetool/rules/LongSentenceRule.java
Patch:
@@ -59,7 +59,7 @@ public RuleMatch[] match(AnalyzedSentence text) throws IOException {
       for (AnalyzedTokenReadings aToken : tokens) {
         final String token = aToken.getToken();
         pos += token.length();  // won't match the whole offending sentence, but much of it
-        if (!token.matches("[!-~’]") && !aToken.isSentenceStart()) {
+        if (!token.matches("[?!:;,~’-]") && !aToken.isSentenceStart()) {
           numWords++;
         }
       }

File: languagetool-server/src/main/java/org/languagetool/server/HTTPSServerConfig.java
Patch:
@@ -84,7 +84,7 @@ public HTTPSServerConfig(int serverPort, boolean verbose, File keystore, String
       }
     }
     if (config == null) {
-      throw new IllegalArgumentException("Parameter --config must be set and point to a property file");
+      throw new IllegalConfigurationException("Parameter --config must be set and point to a property file");
     }
     try {
       final Properties props = new Properties();
@@ -132,7 +132,7 @@ int getRequestLimitPeriodInSeconds() {
   private String getProperty(Properties props, String propertyName, File config) {
     final String propertyValue = (String)props.get(propertyName);
     if (propertyValue == null || propertyValue.trim().isEmpty()) {
-      throw new IllegalArgumentException("Property '" + propertyName + "' must be set in " + config);
+      throw new IllegalConfigurationException("Property '" + propertyName + "' must be set in " + config);
     }
     return propertyValue;
   }

File: languagetool-server/src/test/java/org/languagetool/server/HTTPSServerConfigTest.java
Patch:
@@ -31,7 +31,7 @@ public void testArgumentParsing() {
     try {
       new HTTPSServerConfig(new String[]{});
       fail();
-    } catch (IllegalArgumentException expected) {}
+    } catch (IllegalConfigurationException expected) {}
 
     final String propertyFile = HTTPSServerConfigTest.class.getResource("/org/languagetool/server/https-server.properties").getFile();
 
@@ -79,7 +79,7 @@ public void testIncompletePropertyFile() {
     try {
       new HTTPSServerConfig(("--config " + propertyFile).split(" "));
       fail();
-    } catch (IllegalArgumentException expected) {}
+    } catch (IllegalConfigurationException expected) {}
   }
 
 }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRule.java
Patch:
@@ -351,8 +351,8 @@ && matchPostagRegexp(tokens[i - 1], EXCEPCIONS_PREVIA_POSTAG)) {
         }
         // exceptions: llevat de, tret de, majúsucula inicial
         if (!isException
-            && (((token.equals("tret") || token.equals("llevat")) && nextToken
-                .equals("de"))
+            && (((token.equals("tret") || token.equals("llevat")) 
+                && (nextToken.equals("de") || nextToken.equals("que")))
                 || token.equals("primer")
                 || token.equals("junts") || token.equals("plegats") || isUpperCase
                   .matches())) {

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -43,7 +43,7 @@ public class ReflexiveVerbsRule extends CatalanRule {
    */
   
 //List of only pronominal verbs from GDLC (eliminats: assolar, enfundar, burlar, traslluir, intersecar) (afegits: delir, desomplir, encaramallar, rojar)
-  private static final Pattern VERBS_PRONOMINALS = Pattern.compile("auto.+|rojar|encaramallar|desomplir|delir|fugar|abacallanar|abalançar|ablenar|aborrallonar|abotifarrar|abrinar|abromar|abstenir|acagallonar|acanyar|acarcanyar|acarnissar|acatarrar|aciutadanar|aclocar|acopar|acorriolar|adir|adonar|adormissar|afal·lerar|afarrossar|afeccionar|aferrallar|aferrissar|aferrussar|agallinar|agarbir|agarrofar|agemolir|agenollar|agotzonar|aiguabarrejar|allocar|alçurar|amatinar|amelar|amigar|amoixir|amoltonar|amotar|amullerar|amunionar|antullar|aparroquianar|aparroquiar|aperduar|apergaminar|apiadar|aponentar|apropinquar|apugonar|arguellar|arrapinyar|arrasir|arravatar|arraïmar|arrepapar|arrepenjar|arrepetellar|arrigolar|arrodir|arrogar|arrossar|arruar|assemblar|assocarrar|atendar|atenir|atorrentar|atrafegar|atrevir|avencar|avidolar|avinençar|balbar|balcar|balir|balmar|bescomptar|boirar|boixar|botinflar|bromar|cagaferrar|candir|capbaixar|capmassar|captenir|cariar|carnificar|carpir|coalitzar|colltrencar|collvinclar|compenetrar|condoldre|condolir|congraciar|contorçar|contrapuntar|contòrcer|corcorcar|coresforçar|cornuar|corruixar|crisalidar|desafeccionar|desalenar|desamorar|desaparroquiar|desapassionar|desaplegar|desavenir|desbocar|descantar|descarar|descontrolar|descovar|desdubtar|desempallegar|desenrojolar|desentossudir|desfeinar|desmemoriar|desnodrir|despondre|despreocupar|dessolidaritzar|desteixinar|desvagar|desvergonyir|desviure|dignar|embarbussar|embascar|embessonar|embordeir|embordir|emborrascar|emborrossar|embotifarrar|embotzegar|embromallar|embromar|embroquerar|emmainadar|emmalurar|emmalurir|emmarar|emmarranar|emmatar|emmigranyar|emmorronar|emmurriar|empassar|empassolar|empegueir|empenyalar|empescar|empillocar|empinyar|empiocar|empitarrar|emplomissar|emplujar|emportar|encabotar|encabritar|encalmar|encalostrar|encelar|encinglar|encirar|encistar|enclaperar|encolerir|encordar|encruar|endoblir|endur|enfarfollar|enfaristolar|enfavar|enfereir|enferotgir|enferritjar|enfugir|enfurrunyar|enfutimar|enfutismar|engelabrir|engolfar|engorgar|engripar|enguerxinar|enllagrimar|enlleganyar|enlleir|ennavegar|enneguitar|enquistar|enrinxar|enseriosir|ensobecar|entonyinar|entossudir|entotsolar|entreabaltir|entrebadar|entrebatre|entrebesar|entrecavalcar|entredevorar|entreferir|entreforcar|entrematar|entremetre|entremirar|entrenyorar|entresaludar|entreseguir|entresoldar|entretocar|entretzenar|entrigar|envidreir|envidriar|envolar|enxautar|esbafar|esbafegar|esbatussar|esblamar|esbojarrar|esborneiar|esbromar|escabridar|escamotar|escanyellar|escanyolir|escanyussar|escapolar|escapolir|escarcanyar|escarramicar|escarrassar|escarxofar|escatifenyar|esconillar|escorporar|escullar|escunçar|esfarinar|esfetgegar|esforçar|esgargamellar|esgatinyar|esgolar|esguimbar|esllanguir|esllavissar|esperitar|espitellar|espitxar|espollinar|espoltrar|esporcellar|espotonar|esprimatxar|esquifir|esquitllar|estilar|estritllar|esvedellar|esventegar|esvomegar|etiolar|extralimitar|extravasar|extravenar|gamar|gaspar|gatinyar|gaubar|gloriar|grifar|immiscir|indigestar|industriar|innivar|insolentar|insurgir|inveterar|irèixer|jactar|juramentar|lateritzar|llufar|malfiar|malfixar|migrolar|mofar|mullerar|neulir|obstinar|octubrar|olivar|pellobrir|pellpartir|pelltrencar|penedir|penjolar|pollar|prosternar|queixar|querar|querellar|quillar|ramificar|rancurar|realegrar|rebel·lar|rebordeir|refiar|repanxolar|repapar|repetellar|reressagar|resclosir|ressagar|ressentir|revenjar|salinar|suïcidar|tinyar|tolir|transvestir|traspostar|trufar|vanagloriar|vanagloriejar|vanar|vantar|vergonyar|xautar");
+  private static final Pattern VERBS_PRONOMINALS = Pattern.compile("auto.+|rojar|personar|encaramallar|desomplir|delir|fugar|abacallanar|abalançar|ablenar|aborrallonar|abotifarrar|abrinar|abromar|abstenir|acagallonar|acanyar|acarcanyar|acarnissar|acatarrar|aciutadanar|aclocar|acopar|acorriolar|adir|adonar|adormissar|afal·lerar|afarrossar|afeccionar|aferrallar|aferrissar|aferrussar|agallinar|agarbir|agarrofar|agemolir|agenollar|agotzonar|aiguabarrejar|allocar|alçurar|amatinar|amelar|amigar|amoixir|amoltonar|amotar|amullerar|amunionar|antullar|aparroquianar|aparroquiar|aperduar|apergaminar|apiadar|aponentar|apropinquar|apugonar|arguellar|arrapinyar|arrasir|arravatar|arraïmar|arrepapar|arrepenjar|arrepetellar|arrigolar|arrodir|arrogar|arrossar|arruar|assemblar|assocarrar|atendar|atenir|atorrentar|atrafegar|atrevir|avencar|avidolar|avinençar|balbar|balcar|balir|balmar|bescomptar|boirar|boixar|botinflar|bromar|cagaferrar|candir|capbaixar|capmassar|captenir|cariar|carnificar|carpir|coalitzar|colltrencar|collvinclar|compenetrar|condoldre|condolir|congraciar|contorçar|contrapuntar|contòrcer|corcorcar|coresforçar|cornuar|corruixar|crisalidar|desafeccionar|desalenar|desamorar|desaparroquiar|desapassionar|desaplegar|desavenir|desbocar|descantar|descarar|descontrolar|descovar|desdubtar|desempallegar|desenrojolar|desentossudir|desfeinar|desmemoriar|desnodrir|despondre|despreocupar|dessolidaritzar|desteixinar|desvagar|desvergonyir|desviure|dignar|embarbussar|embascar|embessonar|embordeir|embordir|emborrascar|emborrossar|embotifarrar|embotzegar|embromallar|embromar|embroquerar|emmainadar|emmalurar|emmalurir|emmarar|emmarranar|emmatar|emmigranyar|emmorronar|emmurriar|empassar|empassolar|empegueir|empenyalar|empescar|empillocar|empinyar|empiocar|empitarrar|emplomissar|emplujar|emportar|encabotar|encabritar|encalmar|encalostrar|encelar|encinglar|encirar|encistar|enclaperar|encolerir|encordar|encruar|endoblir|endur|enfarfollar|enfaristolar|enfavar|enfereir|enferotgir|enferritjar|enfugir|enfurrunyar|enfutimar|enfutismar|engelabrir|engolfar|engorgar|engripar|enguerxinar|enllagrimar|enlleganyar|enlleir|ennavegar|enneguitar|enquistar|enrinxar|enseriosir|ensobecar|entonyinar|entossudir|entotsolar|entreabaltir|entrebadar|entrebatre|entrebesar|entrecavalcar|entredevorar|entreferir|entreforcar|entrematar|entremetre|entremirar|entrenyorar|entresaludar|entreseguir|entresoldar|entretocar|entretzenar|entrigar|envidreir|envidriar|envolar|enxautar|esbafar|esbafegar|esbatussar|esblamar|esbojarrar|esborneiar|esbromar|escabridar|escamotar|escanyellar|escanyolir|escanyussar|escapolar|escapolir|escarcanyar|escarramicar|escarrassar|escarxofar|escatifenyar|esconillar|escorporar|escullar|escunçar|esfarinar|esfetgegar|esforçar|esgargamellar|esgatinyar|esgolar|esguimbar|esllanguir|esllavissar|esperitar|espitellar|espitxar|espollinar|espoltrar|esporcellar|espotonar|esprimatxar|esquifir|esquitllar|estilar|estritllar|esvedellar|esventegar|esvomegar|etiolar|extralimitar|extravasar|extravenar|gamar|gaspar|gatinyar|gaubar|gloriar|grifar|immiscir|indigestar|industriar|innivar|insolentar|insurgir|inveterar|irèixer|jactar|juramentar|lateritzar|llufar|malfiar|malfixar|migrolar|mofar|mullerar|neulir|obstinar|octubrar|olivar|pellobrir|pellpartir|pelltrencar|penedir|penjolar|pollar|prosternar|queixar|querar|querellar|quillar|ramificar|rancurar|realegrar|rebel·lar|rebordeir|refiar|repanxolar|repapar|repetellar|reressagar|resclosir|ressagar|ressentir|revenjar|salinar|suïcidar|tinyar|tolir|transvestir|traspostar|trufar|vanagloriar|vanagloriejar|vanar|vantar|vergonyar|xautar");
   private static final Pattern NO_VERBS_PRONOMINALS = Pattern.compile("atendre|escollir|assolir|autofinançar|autografiar|automatitzar|autoritzar");
   //Eliminats: témer
   private static final Pattern VERBS_NO_PRONOMINALS = Pattern.compile("baixar|caure|callar|marxar|albergar|olorar|seure");

File: languagetool-standalone/src/main/java/org/languagetool/dev/RuleOverview.java
Patch:
@@ -65,7 +65,7 @@ private void run(File webRoot) throws IOException {
     System.out.println("<tr>");
     System.out.println("  <th valign='bottom' width=\"70\">Language</th>");
     System.out.println("  <th valign='bottom' align=\"left\" width=\"60\">XML<br/>rules</th>");
-    System.out.println("  <th width=\"120\"></th>");
+    System.out.println("  <th></th>");
     System.out.println("  <th align=\"left\" width=\"60\">Java<br/>rules</th>");
     System.out.println("  <th align=\"left\" width=\"60\">False<br/>friends</th>");
     //System.out.println("  <th valign='bottom' width=\"65\">Auto-<br/>detected</th>");
@@ -114,8 +114,8 @@ private void run(File webRoot) throws IOException {
         System.out.print("<td valign=\"top\" align=\"right\">" + (count + countInRuleGroup) + "</td>");
         System.out.print("<td valign=\"top\" align=\"right\">" +
             //"<a href=\"" + ruleBase + langCode + "/grammar.xml" + "\">Show</a> / " +
-            "<a href=\"" + ruleBase + langCode + "/grammar.xml\">XML</a> / " +
-            "<a href=\"http://community.languagetool.org/rule/list?lang=" + langCode + "\">Browse</a>" +
+            "<a href=\"http://community.languagetool.org/rule/list?lang=" + langCode + "\">Browse</a>,&nbsp;" +
+            "<a href=\"" + ruleBase + langCode + "/grammar.xml\">XML</a>" +
             "</td>");
       }
 

File: languagetool-commandline/src/main/java/org/languagetool/commandline/CommandLineParser.java
Patch:
@@ -171,7 +171,7 @@ private Language getLanguage(String userSuppliedLangCode) {
     } catch (IllegalArgumentException e){
       final List<String> supportedLanguages = new ArrayList<>();
       for (final Language lang : Language.LANGUAGES) {
-        supportedLanguages.add(lang.getShortNameWithVariant());
+        supportedLanguages.add(lang.getShortNameWithCountryAndVariant());
       }
       Collections.sort(supportedLanguages);
       throw new IllegalArgumentException("Unknown language '" + userSuppliedLangCode

File: languagetool-commandline/src/main/java/org/languagetool/commandline/Main.java
Patch:
@@ -518,7 +518,7 @@ public static void main(final String[] args) throws IOException, ParserConfigura
   private static void printLanguages() {
     final List<String> languages = new ArrayList<>();
     for (Language language : Language.REAL_LANGUAGES) {
-      languages.add(language.getShortNameWithVariant() + " " + language.getName());
+      languages.add(language.getShortNameWithCountryAndVariant() + " " + language.getName());
     }
     Collections.sort(languages);
     for (String s : languages) {

File: languagetool-core/src/main/java/org/languagetool/language/Demo.java
Patch:
@@ -52,7 +52,7 @@ public String getShortName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[] {"XX"};
   }
   

File: languagetool-core/src/main/java/org/languagetool/language/LanguageBuilder.java
Patch:
@@ -76,7 +76,7 @@ public String getShortName() {
         return  parts[1].split("_")[0]; //en as in en_US
       }
       @Override
-      public String[] getCountryVariants() {
+      public String[] getCountries() {
         if (parts[1].length() == 2) {
           return new String[] {""};
         }

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -156,7 +156,7 @@ private void loadWordsToBeIgnored(String ignoreFile) throws IOException {
           if (isComment) {
             continue;
           }
-          if (language.getShortNameWithVariant().equals("de-CH")) {
+          if (language.getShortNameWithCountryAndVariant().equals("de-CH")) {
             // hack: Swiss German doesn't use "ß" but always "ss" - replace this, otherwise
             // misspellings (from Swiss point-of-view) like "äußere" wouldn't be found:
             wordsToBeIgnored.add(line.replace("ß", "ss"));

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/SuggestionExtractor.java
Patch:
@@ -164,7 +164,7 @@ private Map<Language, Set<String>> getLanguageToIgnoreTokensMapping() throws IOE
         }
       }
       System.out.println(lang + ": " + noErrorCount + " out of " + tokenCount + " words ignored because they are known to spellchecker anyway");
-      final Language noVariantLanguage = lang.getDefaultVariant() == null ? lang : lang.getDefaultVariant();
+      final Language noVariantLanguage = lang.getDefaultCountry() == null ? lang : lang.getDefaultCountry();
       final Set<String> existingTokens = langToIgnoreTokens.get(noVariantLanguage);
       if (existingTokens != null) {
         existingTokens.addAll(suggestionTokens);

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -147,7 +147,7 @@ protected void init() throws IOException {
     super.init();
     final String langCountry = language.getShortName()
             + "_"
-            + language.getCountryVariants()[0];
+            + language.getCountries()[0];
     final String shortDicPath = "/"
             + language.getShortName()
             + "/hunspell/"

File: languagetool-core/src/main/java/org/languagetool/tools/StringTools.java
Patch:
@@ -333,9 +333,9 @@ public static String ruleMatchesToXML(final List<RuleMatch> ruleMatches,
       String languageXml;
       languageXml = "<language ";
       if (lang != null) {
-        languageXml += "shortname=\"" + lang.getShortNameWithVariant() + "\" name=\"" + lang.getName() + "\"";
+        languageXml += "shortname=\"" + lang.getShortNameWithCountryAndVariant() + "\" name=\"" + lang.getName() + "\"";
       }
-      if(null != motherTongue && (lang == null || !motherTongue.getShortName().equals(lang.getShortNameWithVariant()))) {
+      if(null != motherTongue && (lang == null || !motherTongue.getShortName().equals(lang.getShortNameWithCountryAndVariant()))) {
         languageXml += " mothertongueshortname=\"" + motherTongue.getShortName() + "\" mothertonguename=\"" + motherTongue.getName() + "\"";
       }
       languageXml += "/>\n";

File: languagetool-core/src/test/java/org/languagetool/MultiThreadedJLanguageToolTest.java
Patch:
@@ -94,7 +94,7 @@ public String getName() {
         return "Fake Language";
       }
       @Override
-      public String[] getCountryVariants() {
+      public String[] getCountries() {
         return new String[0];
       }
       @Override

File: languagetool-core/src/test/java/org/languagetool/rules/bitext/FakeLanguage.java
Patch:
@@ -38,7 +38,7 @@ public String getName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[] {"YY"};
   }
 

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -55,7 +55,7 @@ public void testFake() {
   protected void runGrammarRulesFromXmlTest(Language ignoredLanguage) throws IOException {
     int count = 0;
     for (final Language lang : Language.REAL_LANGUAGES) {
-      if (ignoredLanguage.getShortNameWithVariant().equals(lang.getShortNameWithVariant())) {
+      if (ignoredLanguage.getShortNameWithCountryAndVariant().equals(lang.getShortNameWithCountryAndVariant())) {
         continue;
       }
       runGrammarRuleForLanguage(lang);
@@ -92,7 +92,7 @@ private boolean skipCountryVariant(Language lang) {
   }
 
   private String getGrammarFileName(Language lang) {
-    final String shortNameWithVariant = lang.getShortNameWithVariant();
+    final String shortNameWithVariant = lang.getShortNameWithCountryAndVariant();
     final String fileName;
     if (shortNameWithVariant.contains("-x-")) {
       fileName = lang.getShortName() + "/" + JLanguageTool.PATTERN_FILE;

File: languagetool-core/src/test/java/org/languagetool/tools/StringToolsTest.java
Patch:
@@ -358,7 +358,7 @@ public String getName() {
     }
 
     @Override
-    public String[] getCountryVariants() {
+    public String[] getCountries() {
       return new String[] {"XX"};
     }
 

File: languagetool-gui-commons/src/main/java/org/languagetool/gui/Configuration.java
Patch:
@@ -198,15 +198,15 @@ private void loadConfiguration(final Language lang) throws IOException {
   private String getQualifier(final Language lang) {
     String qualifier = "";
     if (lang != null) {
-      qualifier = "." + lang.getShortNameWithVariant();
+      qualifier = "." + lang.getShortNameWithCountryAndVariant();
     }
     return qualifier;
   }
 
   private void loadConfigForOtherLanguages(final Language lang, final Properties prop) {
     for (Language otherLang : Language.getAllLanguages()) {
       if (!otherLang.equals(lang)) {
-        final String languageSuffix = "." + otherLang.getShortNameWithVariant();
+        final String languageSuffix = "." + otherLang.getShortNameWithCountryAndVariant();
         storeConfigKeyFromProp(prop, DISABLED_RULES_CONFIG_KEY + languageSuffix);
         storeConfigKeyFromProp(prop, ENABLED_RULES_CONFIG_KEY + languageSuffix);
         storeConfigKeyFromProp(prop, DISABLED_CATEGORIES_CONFIG_KEY + languageSuffix);
@@ -239,7 +239,7 @@ public void saveConfiguration(final Language lang) throws IOException {
     addListToProperties(props, ENABLED_RULES_CONFIG_KEY + qualifier, enabledRuleIds);
     addListToProperties(props, DISABLED_CATEGORIES_CONFIG_KEY + qualifier, disabledCategoryNames);
     if (language != null) {
-      props.setProperty(LANGUAGE_CONFIG_KEY, language.getShortNameWithVariant());
+      props.setProperty(LANGUAGE_CONFIG_KEY, language.getShortNameWithCountryAndVariant());
     }
     if (motherTongue != null) {
       props.setProperty(MOTHER_TONGUE_CONFIG_KEY, motherTongue.getShortName());

File: languagetool-language-modules/ast/src/main/java/org/languagetool/language/Asturian.java
Patch:
@@ -47,7 +47,7 @@ public String getShortName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{"ES"};
   }
 

File: languagetool-language-modules/be/src/main/java/org/languagetool/language/Belarusian.java
Patch:
@@ -54,7 +54,7 @@ public String getShortName() {
     }
 
     @Override
-    public String[] getCountryVariants() {
+    public String[] getCountries() {
         return new String[]{"BY"};
     }
 

File: languagetool-language-modules/br/src/main/java/org/languagetool/language/Breton.java
Patch:
@@ -65,7 +65,7 @@ public String getShortName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[] {"FR"};
   }
   

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -65,7 +65,7 @@ public String getName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{"ANY"};
   }
   
@@ -75,7 +75,7 @@ public String getShortName() {
   }
   
   @Override
-  public Language getDefaultVariant() {
+  public Language getDefaultCountry() {
     return GENERAL_CATALAN;
   }
 

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/GeneralCatalan.java
Patch:
@@ -26,7 +26,7 @@ public String getName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{"ES"};
   }
   

File: languagetool-language-modules/da/src/main/java/org/languagetool/language/Danish.java
Patch:
@@ -53,7 +53,7 @@ public final String getShortName() {
   }
 
   @Override
-  public final String[] getCountryVariants() {
+  public final String[] getCountries() {
     return new String[]{"DK"};
   }
   

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/AustrianGerman.java
Patch:
@@ -27,7 +27,7 @@
 public class AustrianGerman extends German {
 
   @Override
-  public final String[] getCountryVariants() {
+  public final String[] getCountries() {
     return new String[]{"AT"};
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/German.java
Patch:
@@ -56,7 +56,7 @@ public class German extends Language {
   private Disambiguator disambiguator;
 
   @Override
-  public Language getDefaultVariant() {
+  public Language getDefaultCountry() {
     return new GermanyGerman();
   }
   
@@ -79,7 +79,7 @@ public String getShortName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{"LU", "LI", "BE"};
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/GermanyGerman.java
Patch:
@@ -27,7 +27,7 @@
 public class GermanyGerman extends German {
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{"DE"};
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/language/SwissGerman.java
Patch:
@@ -27,7 +27,7 @@
 public class SwissGerman extends German {
 
   @Override
-  public final String[] getCountryVariants() {
+  public final String[] getCountries() {
     return new String[]{"CH"};
   }
 

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -93,7 +93,7 @@ private static MorfologikSpeller getSpeller(Language language) {
       throw new RuntimeException("Language is not a variant of German: " + language);
     }
     try {
-      final String morfoFile = "/de/hunspell/de_" + language.getCountryVariants()[0] + ".dict";
+      final String morfoFile = "/de/hunspell/de_" + language.getCountries()[0] + ".dict";
       return new MorfologikSpeller(morfoFile, Locale.getDefault(), MAX_EDIT_DISTANCE);
     } catch (IOException e) {
       throw new RuntimeException("Could not set up morfologik spell checker", e);

File: languagetool-language-modules/el/src/main/java/org/languagetool/language/Greek.java
Patch:
@@ -65,7 +65,7 @@ public final String getName() {
   }
 
   @Override
-  public final String[] getCountryVariants() {
+  public final String[] getCountries() {
     return new String[]{"GR"};
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/AmericanEnglish.java
Patch:
@@ -28,7 +28,7 @@
 public class AmericanEnglish extends English {
 
   @Override
-  public final String[] getCountryVariants() {
+  public final String[] getCountries() {
     return new String[]{"US"};
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/AustralianEnglish.java
Patch:
@@ -28,7 +28,7 @@
 public class AustralianEnglish extends English {
 
   @Override
-  public final String[] getCountryVariants() {
+  public final String[] getCountries() {
     return new String[]{"AU"};
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/BritishEnglish.java
Patch:
@@ -29,7 +29,7 @@
 public class BritishEnglish extends English {
 
   @Override
-  public final String[] getCountryVariants() {
+  public final String[] getCountries() {
     return new String[]{"GB"};
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/CanadianEnglish.java
Patch:
@@ -28,7 +28,7 @@
 public class CanadianEnglish extends English {
 
   @Override
-  public final String[] getCountryVariants() {
+  public final String[] getCountries() {
     return new String[]{"CA"};
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/English.java
Patch:
@@ -59,7 +59,7 @@ public class English extends Language {
   private Disambiguator disambiguator;
 
   @Override
-  public Language getDefaultVariant() {
+  public Language getDefaultCountry() {
     return AMERICAN_ENGLISH;
   }
 
@@ -82,7 +82,7 @@ public final String getShortName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{"ANY"}; //?
   }
   

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/NewZealandEnglish.java
Patch:
@@ -28,7 +28,7 @@
 public class NewZealandEnglish extends English {
 
   @Override
-  public final String[] getCountryVariants() {
+  public final String[] getCountries() {
     return new String[]{"NZ"};
   }
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/language/SouthAfricanEnglish.java
Patch:
@@ -28,7 +28,7 @@
 public class SouthAfricanEnglish extends English {
 
   @Override
-  public final String[] getCountryVariants() {
+  public final String[] getCountries() {
     return new String[]{"ZA"};
   }
 

File: languagetool-language-modules/eo/src/main/java/org/languagetool/language/Esperanto.java
Patch:
@@ -72,7 +72,7 @@ public String getShortName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     /* return "ANY" country code as a "country-less" placeholder for OOo: */
     return new String[] {"ANY"};
   }

File: languagetool-language-modules/es/src/main/java/org/languagetool/language/Spanish.java
Patch:
@@ -60,7 +60,7 @@ public String getShortName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{
             "ES", "", "MX", "GT", "CR", "PA", "DO",
             "VE", "PE", "AR", "EC", "CL", "UY", "PY",

File: languagetool-language-modules/fr/src/main/java/org/languagetool/language/French.java
Patch:
@@ -62,7 +62,7 @@ public String getShortName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{"FR", "", "BE", "CH", "CA", "LU", "MC", "CM",
             "CI", "HI", "ML", "SN", "CD", "MA", "RE"};
   }

File: languagetool-language-modules/gl/src/main/java/org/languagetool/language/Galician.java
Patch:
@@ -69,7 +69,7 @@ public final String getShortName() {
   }
 
   @Override
-  public final String[] getCountryVariants() {
+  public final String[] getCountries() {
     return new String[]{"ES"};
   }
   

File: languagetool-language-modules/is/src/main/java/org/languagetool/language/Icelandic.java
Patch:
@@ -55,7 +55,7 @@ public String getShortName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{"IS"};
   }
 

File: languagetool-language-modules/it/src/main/java/org/languagetool/language/Italian.java
Patch:
@@ -55,7 +55,7 @@ public String getShortName() {
   }
   
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{"IT", "CH"};
   }
 

File: languagetool-language-modules/ja/src/main/java/org/languagetool/language/Japanese.java
Patch:
@@ -48,7 +48,7 @@ public String getName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[] { "JP" };
   }
 

File: languagetool-language-modules/km/src/main/java/org/languagetool/language/Khmer.java
Patch:
@@ -55,7 +55,7 @@ public String getShortName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{"KH"};
   }
   

File: languagetool-language-modules/lt/src/main/java/org/languagetool/language/Lithuanian.java
Patch:
@@ -42,7 +42,7 @@ public String getName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{"LT"};
   }
   

File: languagetool-language-modules/ml/src/main/java/org/languagetool/language/Malayalam.java
Patch:
@@ -53,7 +53,7 @@ public final Tokenizer getWordTokenizer() {
   }
   
   @Override
-  public final String[] getCountryVariants() {
+  public final String[] getCountries() {
     return new String[]{"IN"};
   }
   

File: languagetool-language-modules/nl/src/main/java/org/languagetool/language/Dutch.java
Patch:
@@ -61,7 +61,7 @@ public final String getShortName() {
   }
 
   @Override
-  public final String[] getCountryVariants() {
+  public final String[] getCountries() {
     return new String[]{"NL", "BE"};
   }
 

File: languagetool-language-modules/pl/src/main/java/org/languagetool/language/Polish.java
Patch:
@@ -60,7 +60,7 @@ public String getShortName() {
   }
   
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{"PL"};
   }
   

File: languagetool-language-modules/pl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -31,7 +31,7 @@ public class JLanguageToolTest extends TestCase {
   public void testPolish() throws IOException {
     final Polish polish = new Polish();
     JLanguageTool tool = new JLanguageTool(polish);
-    assertEquals("[PL]", Arrays.toString(polish.getCountryVariants()));
+    assertEquals("[PL]", Arrays.toString(polish.getCountries()));
     List<RuleMatch> matches = tool.check("To jest całkowicie prawidłowe zdanie.");
     assertEquals(0, matches.size());
     matches = tool.check("To jest jest problem.");

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/Portuguese.java
Patch:
@@ -52,12 +52,12 @@ public String getShortName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{"AO", "MZ"};
   }
 
   @Override
-  public Language getDefaultVariant() {
+  public Language getDefaultCountry() {
     return new PortuguesePortugal();
   }
 

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/PortugueseBrazil.java
Patch:
@@ -26,7 +26,7 @@ public String getName() {
 	  }
 
 	  @Override
-	  public String[] getCountryVariants() {
+	  public String[] getCountries() {
 	    return new String[]{"BR"};
 	  }
 

File: languagetool-language-modules/pt/src/main/java/org/languagetool/language/PortuguesePortugal.java
Patch:
@@ -26,7 +26,7 @@ public String getName() {
 	  }
 
 	  @Override
-	  public String[] getCountryVariants() {
+	  public String[] getCountries() {
 	    return new String[]{"PT"};
 	  }
 

File: languagetool-language-modules/ro/src/main/java/org/languagetool/language/Romanian.java
Patch:
@@ -68,7 +68,7 @@ public String getShortName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{"RO"};
   }
 

File: languagetool-language-modules/ru/src/main/java/org/languagetool/language/Russian.java
Patch:
@@ -61,7 +61,7 @@ public String getShortName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[] {"RU"};
   }
   

File: languagetool-language-modules/sk/src/main/java/org/languagetool/language/Slovak.java
Patch:
@@ -55,7 +55,7 @@ public String getShortName() {
   }
   
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{"SK"};
   }
 

File: languagetool-language-modules/sl/src/main/java/org/languagetool/language/Slovenian.java
Patch:
@@ -48,7 +48,7 @@ public String getShortName() {
   }
   
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{"SI"};
   }
 

File: languagetool-language-modules/sv/src/main/java/org/languagetool/language/Swedish.java
Patch:
@@ -49,7 +49,7 @@ public final String getShortName() {
   }
 
   @Override
-  public final String[] getCountryVariants() {
+  public final String[] getCountries() {
     return new String[]{"SE", "FI"};
   }
   

File: languagetool-language-modules/tl/src/main/java/org/languagetool/language/Tagalog.java
Patch:
@@ -51,7 +51,7 @@ public String getShortName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[] {"PH"};
   }
   

File: languagetool-language-modules/uk/src/main/java/org/languagetool/language/Ukrainian.java
Patch:
@@ -64,7 +64,7 @@ public String getShortName() {
   }
 
   @Override
-  public String[] getCountryVariants() {
+  public String[] getCountries() {
     return new String[]{"UA"};
   }
   

File: languagetool-language-modules/zh/src/main/java/org/languagetool/language/Chinese.java
Patch:
@@ -49,7 +49,7 @@ public String getName() {
 	}
 
 	@Override
-	public String[] getCountryVariants() {
+	public String[] getCountries() {
 		return new String[] { "CN" };
 	}
 

File: languagetool-server/src/test/java/org/languagetool/server/HTTPSServerTesting.java
Patch:
@@ -97,7 +97,7 @@ private void runTests(int threadNumber) throws IOException {
     final Language lang = languages[rnd.nextInt(languages.length)];
     final List<ExampleSentence> sentences = provider.getRandomSentences(lang);
     final String text = getSentencesAsText(sentences);
-    final String data = "language=" + lang.getShortNameWithVariant() + "&text=" + URLEncoder.encode(text, "utf-8");
+    final String data = "language=" + lang.getShortNameWithCountryAndVariant() + "&text=" + URLEncoder.encode(text, "utf-8");
     final String resultXml = checkAtUrl(new URL(SERVER_URL), data, threadNumber);
     for (ExampleSentence sentence : sentences) {
       assertTrue("Expected " + sentence.getRuleId() + " for '" + text + "' (" + sentences.size() + " sentences)", resultXml.contains(sentence.getRuleId()));

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageComboBox.java
Patch:
@@ -58,7 +58,7 @@ private void initAllLanguages() {
     for (Language language : Language.LANGUAGES) {
       final boolean skip = (language == Language.DEMO) || language.hasVariant();
       // TODO: "Simple German" would hide "German (Germany)" - find a proper solution
-      final boolean simpleGermanWorkaround = language.getShortNameWithVariant().equals("de-DE");
+      final boolean simpleGermanWorkaround = language.getShortNameWithCountryAndVariant().equals("de-DE");
       if (!skip || simpleGermanWorkaround) {
         languages.add(language);
       }

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageToolSupport.java
Patch:
@@ -552,7 +552,7 @@ Language autoDetectLanguage(String text) {
     }
     if (lang.hasVariant()) {
       // UI only shows variants like "English (American)", not just "English", so use that:
-      lang = lang.getDefaultVariant();
+      lang = lang.getDefaultCountry();
     }
     return lang;
   }

File: languagetool-standalone/src/test/java/org/languagetool/TranslationTest.java
Patch:
@@ -107,7 +107,7 @@ private File getTranslationFile(Language lang) {
   private File getTranslationFileWithVariant(Language lang) {
     final String langCode = lang.getShortName();
     final String name = "../languagetool-language-modules/" + langCode + "/src/main/resources/org/languagetool" 
-            + "/MessagesBundle_" + lang.getShortNameWithVariant().replace('-', '_') + ".properties";
+            + "/MessagesBundle_" + lang.getShortNameWithCountryAndVariant().replace('-', '_') + ".properties";
     return new File(name.replace("/", File.separator));
   }
 

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/BaseWikipediaDumpHandler.java
Patch:
@@ -105,6 +105,8 @@ public void endElement(String namespaceURI, String sName, String qName) {
     } else if (qName.equals("text")) {
       try {
         handleEndText();
+      } catch (ErrorLimitReachedException | ArticleLimitReachedException e) {
+        throw e;
       } catch (Exception e) {
         System.err.println("Error checking text of '" + title + "', ignoring document. Stacktrace:");
         e.printStackTrace();

File: languagetool-language-modules/ca/src/test/java/org/languagetool/tokenizers/ca/CatalanSentenceTokenizerTest.java
Patch:
@@ -61,6 +61,8 @@ public final void testTokenize() {
     testSplit(new String[] { "convidar el seu heroi –del ram que sigui–… a prendre cafè." });
 
     // Abbreviations
+    testSplit(new String[] { "Vegeu el cap. 24 del llibre." });
+    testSplit(new String[] { "Vegeu el cap. IX del llibre." });
     testSplit(new String[] { "Viu al núm. 24 del carrer de l'Hort." });
     testSplit(new String[] { "El Dr. Joan no vindrà." });
     testSplit(new String[] { "Distingit Sr. Joan," });
@@ -69,6 +71,7 @@ public final void testTokenize() {
 
     // Exception to abbreviations
     testSplit(new String[] { "Ell és el número u. ", "Jo el dos." });
+    testSplit(new String[] { "Té un trau al cap. ", "Cal portar-lo a l'hospital." });
     // Units
     testSplit(new String[] { "1 500 m/s. ", "Neix a" });
     

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -40,7 +40,7 @@ public void setUp() throws IOException {
   }
 
   public void testRule() throws IOException {
-
+	  
     // correct sentences:
 	assertCorrect("Carrega de nou l'arxiu.");
     assertCorrect("Espero d'ell moltes coses");
@@ -84,6 +84,7 @@ public void testRule() throws IOException {
     assertCorrect("La magnífica conservació del palau.");
 
     // errors:
+    assertIncorrect("Porta-la i nosaltres fem la copia i la compulsem.");
     assertIncorrect("Carrega d'arxius.");
     assertIncorrect("Vaig arribar a fer una radio que no va funcionar mai.");
     assertIncorrect("No em fumaré cap faria com feia abans.");

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -97,7 +97,7 @@ public RuleMatch[] match(AnalyzedSentence text) throws IOException {
       if (word.length() == 1) { // hunspell dictionaries usually do not contain punctuation
         isAlphabetic = StringTools.isAlphabetic(word.charAt(0));
       }
-      if (isAlphabetic && dictionary.misspelled(word)) {
+      if (isAlphabetic && !word.equals("--") && dictionary.misspelled(word)) {
         final RuleMatch ruleMatch = new RuleMatch(this,
                 len, len + word.length(),
                 messages.getString("spelling"),

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/AccentuationCheckRule.java
Patch:
@@ -83,6 +83,7 @@ public class AccentuationCheckRule extends CatalanRule {
   private static final Pattern BEFORE_ADJECTIVE_FP = Pattern.compile("SPS00|D[^R].[FC][PN].*|V.[^NGP].*|PX.*");
   private static final Pattern GN = Pattern.compile("_GN_.*|<?/?N[CP].*");
   private static final Pattern EXCEPCIONS_DARRERE_DE = Pattern.compile("forma|manera|por|costat",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
+  private static final Pattern LOCUCIONS = Pattern.compile(".*LOC.*");
       
   private final Map<String, AnalyzedTokenReadings> relevantWords;
   private final Map<String, AnalyzedTokenReadings> relevantWords2;
@@ -91,7 +92,7 @@ public AccentuationCheckRule(ResourceBundle messages) throws IOException {
     if (messages != null) {
       super.setCategory(new Category(messages.getString("category_misc")));
     }
-    setLocQualityIssueType("misspelling");
+    setLocQualityIssueType("grammar");
     relevantWords = loadWords(FILE_NAME);
     relevantWords2 = loadWords(FILE_NAME2);
   }
@@ -185,6 +186,7 @@ else if  ( !matchPostagRegexp(tokens[i],PARTICIPI_MS)
       	           && !token.equals("continua") && !token.equals("continues") && !token.equals("cantar")
       	           && !prevToken.equals("que") && !prevToken.equals("qui") && !prevToken.equals("què")
       	           && mPreposicioDE.matches() && !matchPostagRegexp(tokens[i-1],NOT_IN_PREV_TOKEN)
+      	           && !matchPostagRegexp(tokens[i+1],LOCUCIONS)
       	           && (i<tokens.length-2) && !matchPostagRegexp(tokens[i+2],INFINITIU)
       	           && !mExcepcionsDE.matches()
       	           && !tokens[i-1].hasPosTag("RG") )

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -42,6 +42,7 @@ public void setUp() throws IOException {
   public void testRule() throws IOException {
 
     // correct sentences:
+	assertCorrect("Carrega de nou l'arxiu.");
     assertCorrect("Espero d'ell moltes coses");
     assertCorrect("cal que abans figuri inscrit en l'Ordre del dia");
     assertCorrect("El lloc era, però, habitat de molt abans,");
@@ -83,6 +84,7 @@ public void testRule() throws IOException {
     assertCorrect("La magnífica conservació del palau.");
 
     // errors:
+    assertIncorrect("Carrega d'arxius.");
     assertIncorrect("Vaig arribar a fer una radio que no va funcionar mai.");
     assertIncorrect("No em fumaré cap faria com feia abans.");
     assertIncorrect("M'he fumat una faria.");

File: languagetool-core/src/main/java/org/languagetool/rules/AbstractSimpleReplaceRule.java
Patch:
@@ -51,8 +51,7 @@ public String getEncoding() {
   }
 
   /**
-   * Indicates if the rule is case-sensitive. Default value is <code>true</code>
-   * .
+   * Indicates if the rule is case-sensitive. Default value is <code>true</code>.
    * 
    * @return true if the rule is case-sensitive, false otherwise.
    */
@@ -140,7 +139,7 @@ public final RuleMatch[] match(final AnalyzedSentence text) {
       List<String> possibleReplacements=wrongWords.get(tokenString);     
 
       if (possibleReplacements != null && possibleReplacements.size() > 0) {
-    	List<String> replacements = new ArrayList<>();  
+        List<String> replacements = new ArrayList<>();  
         replacements.addAll(possibleReplacements);
         if (replacements.contains(originalTokenStr)) {
           replacements.remove(originalTokenStr);

File: languagetool-core/src/main/java/org/languagetool/synthesis/SynthesizerTools.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.ArrayList;
 import java.util.Scanner;
 
-public class SynthesizerTools {
+public final class SynthesizerTools {
   
   private SynthesizerTools() {
     // static methods only, no public constructor

File: languagetool-core/src/main/java/org/languagetool/tagging/ManualTagger.java
Patch:
@@ -50,7 +50,6 @@ public ManualTagger(final InputStream inputStream) throws IOException {
   /**
    * Look up a word's baseform and POS information.
    * 
-   * @param term
    * @return an array with the baseform (at position 0, 2, ...) and the POS
    *         information (at position 1, 3, ...) or <code>null</code> if the
    *         word is unknown
@@ -69,7 +68,7 @@ public String[] lookup(final String term) {
     if (plainResult.isEmpty()) {
       return null;
     }
-    return plainResult.toArray(new String[]{});
+    return plainResult.toArray(new String[plainResult.size()]);
   }
 
   private Map<String, List<LookedUpTerm>> loadMapping(final InputStream inputStream, final String encoding) throws IOException {

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/WikipediaIndexHandler.java
Patch:
@@ -183,7 +183,7 @@ public static void main(String... args) throws Exception {
   }
 
   private class DocumentLimitReachedException extends RuntimeException {
-    int limit;
+    final int limit;
     DocumentLimitReachedException(int limit) {
       this.limit = limit;
     }

File: languagetool-core/src/main/java/org/languagetool/JLanguageTool.java
Patch:
@@ -835,7 +835,7 @@ public List<Rule> getAllActiveRules() {
   }
   
   /**
-   * Get Pattern rules by Id and SubId
+   * Get pattern rules by Id and SubId
    * 
    * @return a List of {@link Rule} objects
    */

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/Element.java
Patch:
@@ -246,7 +246,7 @@ public final boolean hasOrGroup() {
   }
 
   /**
-   * Returns the group of elements linked with AND operator.
+   * Returns the group of elements linked with OR operator.
    * @return List of Elements.
    */
   public final List<Element> getOrGroup() {

File: languagetool-core/src/main/java/org/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -425,6 +425,7 @@ public String toString() {
     }
     sb.delete(sb.length() - 1, sb.length());
     if (chunkTags.size() > 0) {
+      sb.append(",");
       sb.append(StringUtils.join(chunkTags, "|"));
     }
     sb.append("]");

File: languagetool-core/src/main/java/org/languagetool/AnalyzedSentence.java
Patch:
@@ -153,10 +153,10 @@ private String toString(String readingDelimiter, boolean includeChunks) {
         }
       }
       if (!element.isWhitespace()) {
-        /*if (includeChunks) {
+        if (includeChunks) {
           sb.append(",");
           sb.append(StringUtils.join(element.getChunkTags(), "|"));
-        }*/
+        }
         sb.append(']');
       } else {
         sb.append(' ');

File: languagetool-commandline/src/test/java/org/languagetool/commandline/MainTest.java
Patch:
@@ -132,7 +132,7 @@ public void testEnglishFileVerbose() throws Exception {
     assertTrue(output.indexOf("Expected text language: English") == 0);
     assertTrue(output.contains("1.) Line 1, column 9, Rule ID: EN_A_VS_AN"));
     final String tagText = new String(this.err.toByteArray());
-    assertTrue(tagText.contains("<S> This[this/DT]  is[be/VBZ/B-VP]  an[a/DT/B-NP-singular]  test[test/NN].[././O,</S>]"));
+    assertTrue("Got: " + tagText, tagText.contains("<S> This[this/DT/B-NP-singular,E-NP-singular] is[be/VBZ/B-VP] an[a/DT/B-NP-singular] test[test/NN/E-NP-singular].[././O,</S>]"));
   }
 
   public void testEnglishFileApplySuggestions() throws Exception {
@@ -343,7 +343,7 @@ public void testEnglishTagger() throws Exception {
     Main.main(args);
     final String output = new String(this.out.toByteArray());
     assertTrue(output.indexOf("Expected text language: English") == 0);
-    assertTrue(output.contains("<S> This[this/DT]  is[be/VBZ]  an[a/DT]  test[test/NN].[./.,</S>]"));
+    assertTrue("Got: " + output, output.contains("<S> This[this/DT/B-NP-singular,E-NP-singular] is[be/VBZ/B-VP] an[a/DT/B-NP-singular] test[test/NN/E-NP-singular].[././O,</S>]"));
   }
 
   public void testBitextMode() throws Exception {

File: languagetool-core/src/main/java/org/languagetool/AnalyzedSentence.java
Patch:
@@ -139,7 +139,7 @@ private String toString(String readingDelimiter, boolean includeChunks) {
           sb.append("</S>");
         } else if (JLanguageTool.PARAGRAPH_END_TAGNAME.equals(token.getPOSTag())) {
           sb.append("<P/>");
-        } else if (posTag == null) {
+        } else if (posTag == null && !includeChunks) {
           sb.append(token.getToken());
         } else {
           if (!element.isWhitespace()) {

File: languagetool-core/src/main/java/org/languagetool/chunking/xx/DemoChunker.java
Patch:
@@ -23,6 +23,7 @@
 import org.languagetool.chunking.ChunkTag;
 import org.languagetool.chunking.Chunker;
 
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -37,7 +38,7 @@ public void addChunkTags(List<AnalyzedTokenReadings> tokenReadings) {
       if ("chunkbar".equals(tokenReading.getToken())) {
         List<AnalyzedToken> readings = tokenReading.getReadings();
         for (AnalyzedToken reading : readings) {
-          reading.setChunkTag(new ChunkTag("B-NP-singular"));
+          reading.setChunkTags(Collections.singletonList(new ChunkTag("B-NP-singular")));
         }
       }
     }

File: languagetool-core/src/test/java/org/languagetool/AnalyzedTokenTest.java
Patch:
@@ -22,6 +22,8 @@
 import junit.framework.TestCase;
 import org.languagetool.chunking.ChunkTag;
 
+import java.util.Collections;
+
 public class AnalyzedTokenTest extends TestCase {
 
   public void testToString() {
@@ -58,7 +60,7 @@ public void testMatches() {
   private AnalyzedToken makeToken(String token, String pos, String lemma, String chunk) {
     AnalyzedToken analyzedToken = new AnalyzedToken(token, pos, lemma);
     if (chunk != null) {
-      analyzedToken.setChunkTag(new ChunkTag(chunk));
+      analyzedToken.setChunkTags(Collections.singletonList(new ChunkTag(chunk)));
     }
     return analyzedToken;
   }

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/ElementTest.java
Patch:
@@ -25,6 +25,8 @@
 import org.languagetool.JLanguageTool;
 import org.languagetool.chunking.ChunkTag;
 
+import java.util.Collections;
+
 public class ElementTest extends TestCase {
 
   public void testSentenceStart() {
@@ -142,7 +144,7 @@ public void testMatchRequiresChunk() {
   private AnalyzedToken makeToken(String token, String pos, String lemma, String chunk) {
     AnalyzedToken analyzedToken = new AnalyzedToken(token, pos, lemma);
     if (chunk != null) {
-      analyzedToken.setChunkTag(new ChunkTag(chunk));
+      analyzedToken.setChunkTags(Collections.singletonList(new ChunkTag(chunk)));
     }
     return analyzedToken;
   }

File: languagetool-language-modules/en/src/main/java/org/languagetool/chunking/EnglishChunker.java
Patch:
@@ -30,6 +30,7 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -104,7 +105,7 @@ private List<ChunkTaggedToken> getTokensWithTokenReadings(List<AnalyzedTokenRead
       int endPos = startPos + tokens[i].length();
       //System.out.println("OPEN: " + tokens[i]);
       AnalyzedTokenReadings readings = getAnalyzedTokenReadingsFor(startPos, endPos, tokenReadings);
-      result.add(new ChunkTaggedToken(tokens[i], new ChunkTag(chunkTag), readings));
+      result.add(new ChunkTaggedToken(tokens[i], Collections.singletonList(new ChunkTag(chunkTag)), readings));
       pos = endPos;
       i++;
     }
@@ -119,7 +120,7 @@ private void assignChunksToReadings(List<ChunkTaggedToken> chunkTaggedTokens) {
           // In theory, each reading could have a different chunk tag, but with
           // our approach that uses its own tokenizer and POS tagger this is not
           // the case, so we add the chunk tag to all readings:
-          analyzedToken.setChunkTag(taggedToken.getChunkTag());
+          analyzedToken.setChunkTags(taggedToken.getChunkTags());
         }
       }
     }

File: languagetool-commandline/src/test/java/org/languagetool/commandline/MainTest.java
Patch:
@@ -132,7 +132,7 @@ public void testEnglishFileVerbose() throws Exception {
     assertTrue(output.indexOf("Expected text language: English") == 0);
     assertTrue(output.contains("1.) Line 1, column 9, Rule ID: EN_A_VS_AN"));
     final String tagText = new String(this.err.toByteArray());
-    assertTrue(tagText.contains("<S> This[this/DT]  is[be/VBZ]  an[a/DT]  test[test/NN].[./.,</S>]"));
+    assertTrue(tagText.contains("<S> This[this/DT]  is[be/VBZ/B-VP]  an[a/DT/B-NP-singular]  test[test/NN].[././O,</S>]"));
   }
 
   public void testEnglishFileApplySuggestions() throws Exception {

File: languagetool-language-modules/en/src/main/java/org/languagetool/chunking/EnglishChunkFilter.java
Patch:
@@ -83,6 +83,7 @@ private ChunkType getChunkType(List<ChunkTaggedToken> tokens, int chunkStartPos)
     for (int i = chunkStartPos; i < tokens.size(); i++) {
       ChunkTaggedToken token = tokens.get(i);
       if (false && "and".equals(token.getToken())) {   // e.g. "Tarzan and Jane" is a plural noun phrase
+        // TODO: "Additionally, there are over 500 college and university chapter."
         isPlural = true;
       } else if (hasNounWithPluralReading(token)) {   // e.g. "ten books" is a plural noun phrase
         isPlural = true;

File: languagetool-language-modules/en/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -108,7 +108,7 @@ public void testPositionsWithEnglishTwoLineBreaks() throws IOException {
   public void testAnalyzedSentence() throws IOException {
     final JLanguageTool tool = new JLanguageTool(new English());
     //test soft-hyphen ignoring:
-    assertEquals("<S> This[this/DT]  is[be/VBZ]  a[a/DT]  test­ed[tested/JJ,test/VBD,test/VBN,test­ed]  sentence[sentence/NN,sentence/VB,sentence/VBP].[./.,</S>]", tool.getAnalyzedSentence("This is a test\u00aded sentence.").toString());
+    assertEquals("<S> This[this/DT]  is[be/VBZ/B-VP]  a[a/DT/B-NP-singular]  test­ed[tested/JJ/I-NP-singular,test/VBD/I-NP-singular,test/VBN/I-NP-singular,test­ed]  sentence[sentence/NN/I-NP-singular,sentence/VB/I-NP-singular,sentence/VBP/I-NP-singular].[././O,</S>]", tool.getAnalyzedSentence("This is a test\u00aded sentence.").toString());
     //test paragraph ends adding
     assertEquals("<S> </S><P/> ", tool.getAnalyzedSentence("\n").toString());
   }  

File: languagetool-language-modules/en/src/test/java/org/languagetool/chunking/EnglishChunkFilterTest.java
Patch:
@@ -19,6 +19,7 @@
 package org.languagetool.chunking;
 
 import org.apache.commons.lang.StringUtils;
+import org.junit.Ignore;
 import org.junit.Test;
 import org.languagetool.AnalyzedToken;
 import org.languagetool.AnalyzedTokenReadings;
@@ -40,6 +41,7 @@ public void testSingular() {
   }
 
   @Test
+  @Ignore("fails...")
   public void testPluralByAnd() {
     assertChunks("He/B-NP owns/B-VP a/B-NP large/I-NP house/I-NP and/I-NP a/I-NP ship/I-NP in/X Berlin/B-NP ./.",
                  "He/B-NP-singular owns/B-VP a/B-NP-plural large/I-NP-plural house/I-NP-plural and/I-NP-plural a/I-NP-plural ship/I-NP-plural in/X Berlin/B-NP-singular ./.");

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/ElementMatcher.java
Patch:
@@ -103,7 +103,7 @@ void prepareAndGroup(int firstMatchToken, AnalyzedTokenReadings[] tokens, Langua
    * Doesn't test exceptions.
    *
    * Works as logical AND operator only if preceded with
-   * {@link #setupAndGroup()}, and followed by {@link #checkAndGroup(boolean)}
+   * {@link #prepareAndGroup(int, org.languagetool.AnalyzedTokenReadings[], org.languagetool.Language)}, and followed by {@link #checkAndGroup(boolean)}
    *
    * @param token the token checked.
    */

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/PatternRuleMatcher.java
Patch:
@@ -60,9 +60,9 @@ final RuleMatch[] match(final AnalyzedSentence text) throws IOException {
     final int limit = Math.max(0, tokens.length - patternSize + 1);
     ElementMatcher elem = null;
     int i = 0;
-    int skipShiftTotal = 0;
     int minOccurCorrection = getMinOccurrenceCorrection();
     while (i < limit + minOccurCorrection && !(rule.sentStart && i > 0)) {
+      int skipShiftTotal = 0;
       boolean allElementsMatch = false;
       int firstMatchToken = -1;
       int firstMarkerMatchToken = -1;

File: languagetool-standalone/src/main/java/org/languagetool/gui/ResultArea.java
Patch:
@@ -71,7 +71,7 @@ class ResultArea {
     ltSupport.addLanguageToolListener(new LanguageToolListener() {
       @Override
       public void languageToolEventOccured(LanguageToolEvent event) {
-        if (event.getType() == LanguageToolEvent.CHECKING_STARTED) {
+        if (event.getType() == LanguageToolEvent.Type.CHECKING_STARTED) {
           final Language lang = ltSupport.getLanguageTool().getLanguage();
           final String langName;
           if (lang.isExternal()) {
@@ -86,7 +86,7 @@ public void languageToolEventOccured(LanguageToolEvent event) {
           if (event.getCaller() == marker) {
             statusPane.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
           }
-        } else if (event.getType() == LanguageToolEvent.CHECKING_FINISHED) {
+        } else if (event.getType() == LanguageToolEvent.Type.CHECKING_FINISHED) {
           inputText = event.getSource().getTextComponent().getText();
           setRuleMatches(event.getSource().getMatches());
           if (event.getCaller() == marker || event.getCaller() == null) {
@@ -95,7 +95,7 @@ public void languageToolEventOccured(LanguageToolEvent event) {
               statusPane.setCursor(Cursor.getDefaultCursor());
             }
           }
-        } else if (event.getType() == LanguageToolEvent.RULE_DISABLED || event.getType() == LanguageToolEvent.RULE_ENABLED) {
+        } else if (event.getType() == LanguageToolEvent.Type.RULE_DISABLED || event.getType() == LanguageToolEvent.Type.RULE_ENABLED) {
           inputText = event.getSource().getTextComponent().getText();
           setRuleMatches(event.getSource().getMatches());
           displayResult();

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/XMLRuleHandler.java
Patch:
@@ -524,7 +524,7 @@ protected void finalizeTokens() {
     }
 
     if (inUnificationDef) {
-      language.getUnifier().setEquivalence(uFeature, uType, tokenElement);
+      language.getUnifierConfiguration().setEquivalence(uFeature, uType, tokenElement);
       elementList.clear();
     }
     if (tokenSpaceBeforeSet) {

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationRuleLoader.java
Patch:
@@ -356,7 +356,7 @@ public void endElement(final String namespaceURI, final String sName,
         }
       }
       if (inUnificationDef) {
-        language.getDisambiguationUnifier().setEquivalence(uFeature, uType, tokenElement);
+        language.getDisambiguationUnifierConfiguration().setEquivalence(uFeature, uType, tokenElement);
         elementList.clear();
       }
       if (tokenSpaceBeforeSet) {

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/XMLRuleHandler.java
Patch:
@@ -524,7 +524,7 @@ protected void finalizeTokens() {
     }
 
     if (inUnificationDef) {
-      language.getUnifier().setEquivalence(uFeature, uType, tokenElement);
+      language.getUnifierConfiguration().setEquivalence(uFeature, uType, tokenElement);
       elementList.clear();
     }
     if (tokenSpaceBeforeSet) {

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationRuleLoader.java
Patch:
@@ -356,7 +356,7 @@ public void endElement(final String namespaceURI, final String sName,
         }
       }
       if (inUnificationDef) {
-        language.getDisambiguationUnifier().setEquivalence(uFeature, uType, tokenElement);
+        language.getDisambiguationUnifierConfiguration().setEquivalence(uFeature, uType, tokenElement);
         elementList.clear();
       }
       if (tokenSpaceBeforeSet) {

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/XMLRuleHandler.java
Patch:
@@ -535,7 +535,7 @@ protected void finalizeTokens() {
     }
 
     if (inUnificationDef) {
-      language.getUnifier().setEquivalence(uFeature, uType, tokenElement);
+      language.getUnifierConfiguration().setEquivalence(uFeature, uType, tokenElement);
       elementList.clear();
     }
     if (tokenSpaceBeforeSet) {

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationRuleLoader.java
Patch:
@@ -356,7 +356,7 @@ public void endElement(final String namespaceURI, final String sName,
         }
       }
       if (inUnificationDef) {
-        language.getDisambiguationUnifier().setEquivalence(uFeature, uType, tokenElement);
+        language.getDisambiguationUnifierConfiguration().setEquivalence(uFeature, uType, tokenElement);
         elementList.clear();
       }
       if (tokenSpaceBeforeSet) {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -38,7 +38,7 @@ public class AgreementRuleTest extends TestCase {
   
   @Override
   public void setUp() throws IOException {
-    rule = new AgreementRule(null);
+    rule = new AgreementRule(null, new German());
     langTool = new JLanguageTool(new German());
   }
   

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -168,6 +168,7 @@ protected void init() throws IOException {
         }
 
         dictionary.addWord("LanguageTool"); // to make demo text check 4 times faster...
+        dictionary.addWord("LanguageToolFx");
       }
     }
     nonWordPattern = Pattern.compile(wordChars + NON_ALPHABETIC);

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpeller.java
Patch:
@@ -36,6 +36,7 @@
 public class MorfologikSpeller {
 
   private static final String LANGUAGETOOL = "LanguageTool";
+  private static final String LANGUAGETOOL_FX = "LanguageToolFx";
 
   private final Speller speller;
   private final Locale conversionLocale;
@@ -79,6 +80,7 @@ public boolean isMisspelled(String word) {
     return word.length() > 0 && isAlphabetic
             && !containsDigit(word)
             && !LANGUAGETOOL.equals(word)
+            && !LANGUAGETOOL_FX.equals(word)
             && !speller.isInDictionary(word)
             && !(!StringTools.isMixedCase(word) 
                 && speller.isInDictionary(word.toLowerCase(conversionLocale)));

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/TextConverter.java
Patch:
@@ -369,7 +369,7 @@ private String toText(AstNode node) throws IOException {
 
   private void addMapping(Locatable loc) {
     String contentSoFar = sb.toString() + line;
-    int textPos = contentSoFar.length() + 1 + (needSpace ? 1 : 0);
+    int textPos = contentSoFar.length() + needNewlines + 1;
     if (loc.hasLocation()) {
       mapping.put(textPos, loc.getLocation());
       //System.out.println("PUT " + textPos + " -> " + loc.getLocation());

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/RuleApplication.java
Patch:
@@ -93,7 +93,7 @@ public String getErrorMarkerEnd() {
     return errorMarkerEnd;
   }
 
-  public boolean isHasRealReplacement() {
+  public boolean hasRealReplacement() {
     return hasRealReplacement;
   }
 }

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/wikipedia/WikipediaQuickCheckTest.java
Patch:
@@ -44,7 +44,7 @@ public void noTestCheckPage() throws IOException {
     for (RuleApplication ruleApplication : ruleApplications) {
       System.out.println("Rule     : " + ruleApplication.getRuleMatch().getRule().getDescription());
       System.out.println("Original : " + ruleApplication.getOriginalErrorContext().replace("\n", " "));
-      if (ruleApplication.isHasRealReplacement()) {
+      if (ruleApplication.hasRealReplacement()) {
         System.out.println("Corrected: " + ruleApplication.getCorrectedErrorContext().replace("\n", " "));
       }
       System.out.println();

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/TextConverter.java
Patch:
@@ -372,6 +372,7 @@ private void addMapping(Locatable loc) {
     int textPos = contentSoFar.length() + 1 + (needSpace ? 1 : 0);
     if (loc.hasLocation()) {
       mapping.put(textPos, loc.getLocation());
+      //System.out.println("PUT " + textPos + " -> " + loc.getLocation());
     }
   }
 

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/hunspell/CompoundAwareHunspellRule.java
Patch:
@@ -63,10 +63,10 @@ public List<String> getSuggestions(String word) throws IOException {
     if (StringTools.startsWithUppercase(word) && !StringTools.isAllUppercase(word)) {
       // almost all words can be uppercase because they can appear at the start of a sentence:
       final List<String> noSplitLowercaseSuggestions = morfoSpeller.getSuggestions(word.toLowerCase());
-      int pos = 0;
+      int pos = candidates.size() == 0 ? 0 : 1;  // first item comes from getSuggestion() above, if any
       for (String suggestion : noSplitLowercaseSuggestions) {
         candidates.add(pos, StringTools.uppercaseFirstChar(suggestion));
-        // we don't know about the quality of the results here, so mix both lists together, taking
+        // we don't know about the quality of the results here, so mix both lists together,
         // taking elements from both lists on a rotating basis: 
         pos = Math.min(pos + 2, candidates.size());
       }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -163,7 +163,7 @@ public void testGetSuggestionOrder() throws Exception {
     assertCorrectionsByOrder(rule, "Aerger", "Ärger");
     assertCorrectionsByOrder(rule, "Walt", "Wald");
     assertCorrectionsByOrder(rule, "Rythmus", "Rhythmus");
-    assertCorrectionsByOrder(rule, "Rytmus", "Remus", "Rhythmus");
+    assertCorrectionsByOrder(rule, "Rytmus", "Rhythmus", "Remus");
   }
   
   private void assertCorrection(HunspellRule rule, String input, String... expectedTerms) throws IOException {

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanSpellerRuleTest.java
Patch:
@@ -154,7 +154,7 @@ public void testGetSuggestionOrder() throws Exception {
     final HunspellRule rule = new GermanSpellerRule(TestTools.getMessages("German"), new GermanyGerman());
     assertCorrectionsByOrder(rule, "heisst", "heißt", "heilst", "heimst");  // "heißt" should be first
     assertCorrectionsByOrder(rule, "heissen", "heißen");
-    assertCorrectionsByOrder(rule, "müßte", "müsste", "büßte");  // "müsste" should be first
+    assertCorrectionsByOrder(rule, "müßte", "müsste", "Mute");  // "müsste" should be first
     assertCorrectionsByOrder(rule, "schmohren", "schmoren");
     assertCorrectionsByOrder(rule, "Fänomen", "Phänomen");
     assertCorrectionsByOrder(rule, "homofob", "homophob");
@@ -163,7 +163,7 @@ public void testGetSuggestionOrder() throws Exception {
     assertCorrectionsByOrder(rule, "Aerger", "Ärger");
     assertCorrectionsByOrder(rule, "Walt", "Wald");
     assertCorrectionsByOrder(rule, "Rythmus", "Rhythmus");
-    assertCorrectionsByOrder(rule, "Rytmus", "Rhythmus");
+    assertCorrectionsByOrder(rule, "Rytmus", "Remus", "Rhythmus");
   }
   
   private void assertCorrection(HunspellRule rule, String input, String... expectedTerms) throws IOException {

File: languagetool-server/src/main/java/org/languagetool/server/Server.java
Patch:
@@ -81,8 +81,7 @@ public boolean isRunning() {
   }
 
   protected static boolean usageRequested(String[] args) {
-    final boolean helpRequested = args.length == 1 && (args[0].equals("-h") || args[0].equals("--help"));
-    return args.length == 0 || helpRequested;
+    return args.length == 1 && (args[0].equals("-h") || args[0].equals("--help"));
   }
 
   protected static void printCommonOptions() {

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageComboBox.java
Patch:
@@ -31,7 +31,7 @@
 /**
  * Combo box with list of available languages.
  */
-public class LanguageComboBox extends JComboBox<I18nLanguage> {
+public class LanguageComboBox extends JComboBox {
 
   private final ResourceBundle messages;
   private final List<I18nLanguage> i18nLanguages = new ArrayList<I18nLanguage>();

File: languagetool-standalone/src/main/java/org/languagetool/gui/LanguageManagerDialog.java
Patch:
@@ -60,7 +60,7 @@ public class LanguageManagerDialog implements ActionListener {
   private final ResourceBundle messages;
 
   private JDialog dialog;
-  private JList<File> list;
+  private JList list;
   private JButton addButton;
   private JButton removeButton;
   private JButton closeButton;
@@ -95,7 +95,7 @@ public void actionPerformed(ActionEvent actionEvent) {
     final Container contentPane = dialog.getContentPane();
     contentPane.setLayout(new GridBagLayout());
     
-    list = new JList<File>(ruleFiles.toArray(new File[]{}));
+    list = new JList(ruleFiles.toArray(new File[]{}));
     GridBagConstraints cons = new GridBagConstraints();
     cons.insets = new Insets(4, 4, 4, 4);
     cons.gridx = 0;

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/DatabaseDumpHandler.java
Patch:
@@ -68,6 +68,7 @@ class DatabaseDumpHandler extends BaseWikipediaDumpHandler {
       contextTools.setContextSize(CONTEXT_SIZE);
       contextTools.setErrorMarkerStart(MARKER_START);
       contextTools.setErrorMarkerEnd(MARKER_END);
+      contextTools.setEscapeHtml(false);
     }
     
     @Override

File: languagetool-language-modules/uk/src/main/java/org/languagetool/tokenizers/uk/UkrainianWordTokenizer.java
Patch:
@@ -43,7 +43,6 @@ public class UkrainianWordTokenizer implements Tokenizer {
   // decimal comma between digits
   private static final Pattern DECIMAL_COMMA_PATTERN = Pattern.compile("([\\d]),([\\d])",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   private static final String DECIMAL_COMMA_SUBST = "#DECIMAL_COMMA#";
-  private static final Pattern DECIMAL_COMMA_SUBST_PATTERN = Pattern.compile("#DECIMAL_COMMA#");
 
   public UkrainianWordTokenizer() {
   }
@@ -69,7 +68,7 @@ private static String substitute(String text) {
 
   private static String clean(String token) {
     token = token.replace("\u0301", "").replace("\u00AD", "").replace('’', '\'').replace('ʼ', '\'');
-    token = DECIMAL_COMMA_SUBST_PATTERN.matcher(token).replaceAll(",");
+    token = token.replace(DECIMAL_COMMA_SUBST, ",");
     return token;
   }
   

File: languagetool-language-modules/uk/src/test/java/org/languagetool/tokenizers/uk/UkrainianWordTokenizerTest.java
Patch:
@@ -42,6 +42,9 @@ public void testTokenize() {
 
     testList = w.tokenize("надійшло 2,2 мільйона");
     assertEquals(Arrays.asList("надійшло", " ", "2,2", " ", "мільйона"), testList);
+
+    testList = w.tokenize("надійшло 84,46 мільйона");
+    assertEquals(Arrays.asList("надійшло", " ", "84,46", " ", "мільйона"), testList);
   }
 
 }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRule.java
Patch:
@@ -280,7 +280,7 @@ public RuleMatch[] match(final AnalyzedSentence text) {
           isException=true;}
 				//exceptions: llevat de, tret de, majúsucula inicial
 				if ( !isException && ( ((token.equals("tret") || token.equals("llevat") ) && nextToken.equals("de")) 
-						|| token.equals("primer") || token.equals("junts")  
+						|| token.equals("primer") || token.equals("junts") || token.equals("plegats")    
 						|| isUpperCase.matches() ) ) {
 					isException=true;}
 				//exceptions: atès, atesos..., donat, donats... 

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/TextConverter.java
Patch:
@@ -158,7 +158,7 @@ public void visit(Itemization e)
 
     public void visit(ItemizationItem i)
     {
-        newline(1);
+        newline(2);
         iterate(i.getContent());
     }
     
@@ -169,7 +169,7 @@ public void visit(Enumeration e)
 
     public void visit(EnumerationItem item)
     {
-        newline(1);
+        newline(2);
         iterate(item.getContent());
     }
     

File: languagetool-wikipedia/src/test/java/org/languagetool/dev/wikipedia/WikipediaTextFilterTest.java
Patch:
@@ -51,9 +51,9 @@ public void testEntity() throws Exception {
 
   public void testLists() throws Exception {
     final String input1 = "# one\n# two\n";
-    assertEquals("one\ntwo", swebleFilter.filter(input1));
+    assertEquals("one\n\ntwo", swebleFilter.filter(input1));
     final String input2 = "* one\n* two\n";
-    assertEquals("one\ntwo", swebleFilter.filter(input2));
+    assertEquals("one\n\ntwo", swebleFilter.filter(input2));
   }
     
 }

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -193,8 +193,8 @@ public RuleMatch[] match(final AnalyzedSentence text) {
       boolean ignore = couldBeRelativeClause(tokens, i);
       if (i > 0) {
         final String prevToken = tokens[i-1].getToken().toLowerCase();
-        if ((prevToken.equals("der") || prevToken.equals("die") || prevToken.equals("das") || prevToken.equals("des"))
-            && (tokens[i].getToken().equals("eine") || tokens[i].getToken().equals("einen"))) {
+        if ((tokens[i].getToken().equals("eine") || tokens[i].getToken().equals("einen"))
+            && (prevToken.equals("der") || prevToken.equals("die") || prevToken.equals("das") || prevToken.equals("des") || prevToken.equals("dieses"))) {
           // TODO: "der eine Polizist" -> nicht ignorieren, sondern "der polizist" checken; "auf der einen Seite"
           ignore = true;
         }

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -118,6 +118,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Es ist nicht bekannt, mit welchem Alter Kinder diese Fähigkeit erlernen.");
     assertGood("Dieser ist nun in den Ortungsbereich des einen Roboters gefahren.");
     assertGood("Wenn dies großen Erfolg hat, werden wir es weiter fördern.");
+    assertGood("Die Ereignisse dieses einen Jahres waren sehr schlimm.");
 
     // incorrect sentences:
     assertBad("Es sind die Tisch.");

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/CheckWikipediaDump.java
Patch:
@@ -85,7 +85,7 @@ public static void main(String[] args) throws IOException, SAXException, ParserC
   }
 
   private static void addDisabledRules(String languageCode, Set<String> disabledRuleIds, Properties disabledRules) {
-    final String disabledRulesString = (String)disabledRules.get(languageCode);
+    final String disabledRulesString = disabledRules.getProperty(languageCode);
     if (disabledRulesString != null) {
       final String[] ids = disabledRulesString.split(",");
       disabledRuleIds.addAll(Arrays.asList(ids));

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/WikipediaIndexHandler.java
Patch:
@@ -95,6 +95,7 @@ public void endElement(String namespaceURI, String sName, String qName) {
       inTitle = false;
     } else if (qName.equals("text")) {
       System.out.println(++articleCount + ": " + title);
+      final String tempTitle = title.toString();
       title = new StringBuilder();
       if (articleCount < start) {
         return;
@@ -109,11 +110,11 @@ public void endElement(String namespaceURI, String sName, String qName) {
             indexer.index(textToCheck, false, articleCount);
           }
         } catch (Exception e) {
-          System.err.println("Exception when filtering '" + title + "' - skipping file. Stacktrace follows:");
+          System.err.println("Exception when filtering/indexing '" + tempTitle + "' (" + articleCount + ") - skipping file. Stacktrace follows:");
           e.printStackTrace();
         }
       } catch (Exception e) {
-        throw new RuntimeException("Failed checking article " + articleCount, e);
+        throw new RuntimeException("Failed checking article '" + tempTitle + "' (" + articleCount + ")", e);
       }
     }
     text = new StringBuilder();

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -346,7 +346,7 @@ private void configureGUI(JLanguageTool langTool) {
    *    &nbsp;&nbsp;&lt;language name="Catalan" abbr="ca" abbrWithVariant="ca-ES"/&gt;<br/>
    *    &nbsp;&nbsp;&lt;language name="German" abbr="de" abbrWithVariant="de"/&gt;<br/>
    *    &nbsp;&nbsp;&lt;language name="German (Germany)" abbr="de" abbrWithVariant="de-DE"/&gt;<br/>
-   *  &lt;languages&gt;<br/><br/>
+   *  &lt;/languages&gt;<br/><br/>
    *  The languages are sorted alphabetically by their name.
    * @return an XML document listing all supported languages
    */

File: languagetool-language-modules/uk/src/main/java/org/languagetool/tokenizers/uk/UkrainianWordTokenizer.java
Patch:
@@ -64,7 +64,7 @@ public List<String> tokenize(String text) {
   }
 
   private static String substitute(String text) {
-    return DECIMAL_COMMA_PATTERN.matcher(text).replaceAll("$1"+DECIMAL_COMMA_SUBST+"2");
+    return DECIMAL_COMMA_PATTERN.matcher(text).replaceAll("$1"+DECIMAL_COMMA_SUBST+"$2");
   }
 
   private static String clean(String token) {

File: languagetool-commandline/src/main/java/org/languagetool/commandline/Main.java
Patch:
@@ -25,6 +25,7 @@
 import org.languagetool.language.English;
 import org.languagetool.rules.Rule;
 import org.languagetool.rules.bitext.BitextRule;
+import org.languagetool.tools.JnaTools;
 import org.languagetool.tools.StringTools;
 import org.languagetool.tools.Tools;
 import org.xml.sax.SAXException;
@@ -435,6 +436,7 @@ private void changeLanguage(Language language, Language motherTongue,
    * Command line tool to check plain text files.
    */
   public static void main(final String[] args) throws IOException, ParserConfigurationException, SAXException {
+    JnaTools.setBugWorkaroundProperty();
     final CommandLineParser commandLineParser = new CommandLineParser();
     CommandLineOptions options = null;
     try {

File: languagetool-standalone/src/main/java/org/languagetool/gui/Main.java
Patch:
@@ -27,6 +27,7 @@
 import org.languagetool.server.HTTPServer;
 import org.languagetool.server.HTTPServerConfig;
 import org.languagetool.server.PortBindingException;
+import org.languagetool.tools.JnaTools;
 import org.languagetool.tools.LanguageIdentifierTools;
 import org.languagetool.tools.StringTools;
 
@@ -603,6 +604,7 @@ private void setTrayMode(boolean trayMode) {
   }
 
   public static void main(final String[] args) {
+    JnaTools.setBugWorkaroundProperty();
     try {
       final Main prg = new Main();
       if (args.length == 1 && (args[0].equals("-t") || args[0].equals("--tray"))) {

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/Main.java
Patch:
@@ -21,6 +21,7 @@
 import org.languagetool.JLanguageTool;
 import org.languagetool.dev.index.Indexer;
 import org.languagetool.dev.index.Searcher;
+import org.languagetool.tools.JnaTools;
 
 import java.util.Arrays;
 
@@ -31,6 +32,7 @@
 public class Main {
 
   public static void main(String[] args) throws Exception {
+    JnaTools.setBugWorkaroundProperty();
     if (args.length == 0) {
       printUsageAndExit();
     } else {

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -71,6 +71,7 @@ public class CaseRule extends GermanRule {
     sentenceStartExceptions.add("“");
     sentenceStartExceptions.add("«");
     sentenceStartExceptions.add("»");
+    sentenceStartExceptions.add(".");
   }
   
   private static final Set<String> exceptions = new HashSet<String>();
@@ -488,7 +489,7 @@ private void potentiallyAddUppercaseMatch(List<RuleMatch> ruleMatches, AnalyzedT
         !analyzedToken.hasReadingOfType(POSType.PROPER_NOUN) &&
         !isNilReading(analyzedToken) &&
         !analyzedToken.isSentenceEnd() &&
-        !( (tokens[i-1].getToken().equals("]") || tokens[i-1].getToken().equals(")")) &&
+        !( (tokens[i-1].getToken().equals("]") || tokens[i-1].getToken().equals(")")) && // sentence starts with […]
            ( (i == 4 && tokens[i-2].getToken().equals("…")) || (i == 6 && tokens[i-2].getToken().equals(".")) ) ) &&
         !isExceptionPhrase(i, tokens)) {
       final String msg = "Außer am Satzanfang werden nur Nomen und Eigennamen großgeschrieben";

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -114,6 +114,9 @@ public void testDetNounRule() throws IOException {
     assertGood("Das Gütersloher Radio.");
     assertGood("Das wirklich Wichtige kommt jetzt erst.");
     assertGood("Besonders wenn wir Wermut oder Absinth trinken.");
+    assertGood("Ich wünsche dir alles Gute.");
+    assertGood("Es ist nicht bekannt, mit welchem Alter Kinder diese Fähigkeit erlernen.");
+    assertGood("Dieser ist nun in den Ortungsbereich des einen Roboters gefahren.");
 
     // incorrect sentences:
     assertBad("Es sind die Tisch.");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -79,6 +79,9 @@ public void testRule() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Die Schlinge zieht sich zu.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Die Schlingen ziehen sich zu.")).length);
     
+    // used to trigger error because of "abbriviation"
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("Sie fällt auf durch ihre hilfsbereite Art. Zudem zeigt sie soziale Kompetenz.")).length);
+    
     // TODO: nach dem Doppelpunkt wird derzeit nicht auf groß/klein getestet:
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Das ist es: kein Satz.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Das ist es: Kein Satz.")).length);

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationPatternRule.java
Patch:
@@ -286,6 +286,7 @@ private AnalyzedTokenReadings[] executeAction(final AnalyzedSentence text,
         for (int i = 0; i < matchingTokens - startPositionCorrection + endPositionCorrection; i++) {
           whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos + i)].immunize();
         }
+        break;
       case FILTER:
         if (matchElement == null) { // same as REPLACE if using <match>
           final Match tmpMatchToken = new Match(disambiguatedPOS, null, true,
@@ -298,6 +299,7 @@ private AnalyzedTokenReadings[] executeAction(final AnalyzedSentence text,
           annotateChange(whTokens[fromPos], prevValue, prevAnot);
           filtered = true;
         }
+        // FALLTHROUGH
       case REPLACE:
       default:
         if (!filtered) {

File: languagetool-language-modules/fr/src/main/java/org/languagetool/rules/fr/QuestionWhitespaceRule.java
Patch:
@@ -144,7 +144,7 @@ public RuleMatch[] match(final AnalyzedSentence text) {
         suggestionText = "« ";
         fixLen = 1;
       } else if (!StringTools.isEmpty(token) && prevToken.equals("«")
-          && !token.equals("\u00a0") & !token.equals("\u202f")) {
+          && !token.equals("\u00a0") && !token.equals("\u202f")) {
         msg = "Le guillemet ouvrant est suivi d'une espace fine insécable.";
         // non-breaking space
         suggestionText = "« ";

File: languagetool-language-modules/uk/src/test/java/org/languagetool/rules/uk/SimpleReplaceRuleTest.java
Patch:
@@ -44,8 +44,8 @@ public void testRule() throws IOException {
 		// incorrect sentences:
 		matches = rule.match(langTool.getAnalyzedSentence("Ці рядки повинні співпадати."));
 		assertEquals(1, matches.length);
-		assertEquals(1, matches[0].getSuggestedReplacements().size());
-		assertEquals(Arrays.asList("збігатися"), matches[0].getSuggestedReplacements());
+		assertEquals(2, matches[0].getSuggestedReplacements().size());
+		assertEquals(Arrays.asList("збігатися", "сходитися"), matches[0].getSuggestedReplacements());
 		
 		matches = rule.match(langTool.getAnalyzedSentence("Нападаючий"));
 		assertEquals(1, matches.length);

File: languagetool-language-modules/uk/src/test/java/org/languagetool/tagging/uk/UkrainianTaggerTest.java
Patch:
@@ -54,7 +54,8 @@ public void testTagger() throws IOException {
       "Майже/[майже]todo -- два/[два]noun:m:v_naz|два/[два]noun:m:v_zna|два/[два]noun:n:v_naz|два/[два]noun:n:v_zna -- роки/[рік]noun:p:v_naz|роки/[рік]noun:p:v_zna -- тому/[той]pron|тому/[том]noun:m:v_rod"
     + " -- Люба/[Люба]noun:f:v_naz|Люба/[любий]adj:f:v_naz -- разом/[раз]noun:m:v_oru -- із/[із]pryim:rv_rod:rv_zna:rv_oru"
     + " -- чоловіком/[чоловік]noun:m:v_oru -- Степаном/[Степан]noun:m:v_oru -- виїхали/[виїхати]verb:past:m -- туди/[туди]adv"
-    + " -- на/[на]excl|на/[на]part|на/[на]pryim:rv_zna:rv_mis -- проживання/[проживання]noun:n:v_naz|проживання/[проживання]noun:n:v_rod|проживання/[проживання]noun:n:v_zna";
+    + " -- на/[на]excl|на/[на]part|на/[на]pryim:rv_zna:rv_mis -- "
+    + "проживання/[проживання]noun:n:v_naz|проживання/[проживання]noun:n:v_rod|проживання/[проживання]noun:n:v_zna|проживання/[проживання]noun:p:v_naz|проживання/[проживання]noun:p:v_zna";
   
     TestTools.myAssert("Майже два роки тому Люба разом із чоловіком Степаном виїхали туди на проживання.",
         expected, tokenizer, tagger);

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/AccentuationCheckRule.java
Patch:
@@ -181,7 +181,7 @@ else if ( i>2 && matchPostagRegexp(tokens[i-2],VERB_CONJUGAT) &&
       	//circumstancies d'una altra classe
       	else if  ( !matchPostagRegexp(tokens[i],PARTICIPI_MS)
       			   && !token.equals("venia") && !token.equals("venies") && !token.equals("tenia") && !token.equals("tenies")
-      			   && !token.equals("faria") && !token.equals("faries")
+      			   && !token.equals("faria") && !token.equals("faries") && !token.equals("espero")
       	           && !token.equals("continua") && !token.equals("continues") && !token.equals("cantar")
       	           && !prevToken.equals("que") && !prevToken.equals("qui") && !prevToken.equals("què")
       	           && mPreposicioDE.matches() && !matchPostagRegexp(tokens[i-1],NOT_IN_PREV_TOKEN)

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -42,6 +42,7 @@ public void setUp() throws IOException {
   public void testRule() throws IOException {
 
     // correct sentences:
+    assertCorrect("Espero d'ell moltes coses");
     assertCorrect("cal que abans figuri inscrit en l'Ordre del dia");
     assertCorrect("El lloc era, però, habitat de molt abans,");
     assertCorrect("i del bel canto del rococó.");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/tokenizers/ca/CatalanSentenceTokenizerTest.java
Patch:
@@ -44,6 +44,8 @@ public final void testTokenize() {
     testSplit(new String[] { "Ja ho tinc! ", "Què vols dir?" });
     testSplit(new String[] { "Us explicaré com va anar: ",
         "»La Maria va engegar el cotxe" });
+    testSplit(new String[] { "diu que va dir. ",
+    "A mi em feia estrany." });    
 
     // Initials
     testSplit(new String[] { "A l'atenció d'A. Comes." });

File: languagetool-commandline/src/main/java/org/languagetool/commandline/CommandLineParser.java
Patch:
@@ -142,7 +142,7 @@ public void printUsage(PrintStream stream) {
             + "  -c, --encoding ENC       character set of the input text, e.g. utf-8 or latin1\n"
             + "  -b                       assume that a single line break marks the end of a paragraph\n"
             + "  -l, --language LANG      the language code of the text, e.g. en for English, en-GB for British English\n"
-            + "  --list                   Print all available languages and exit\n"
+            + "  --list                   print all available languages and exit\n"
             + "  -adl, --autoDetect       auto-detect the language of the input text\n"
             + "  -m, --mothertongue LANG  the language code of your first language, used to activate false-friend checking\n"
             + "  -d, --disable RULES      a comma-separated list of rule ids to be disabled (use no spaces between ids)\n"

File: languagetool-commandline/src/test/java/org/languagetool/commandline/MainTest.java
Patch:
@@ -370,7 +370,7 @@ public void testBitextMode() throws Exception {
     assertTrue(output.indexOf("Expected text language: Polish") == 0);
     assertTrue(output.contains("Message: Hint: \"aktualny\" (Polish) means \"current\", \"(the) latest\", \"up-to-date\" (English). Did you mean 'rzeczywisty'?"));
     assertTrue(output.contains("Line 1, column 32, Rule ID: ACTUAL"));
-    assertTrue(output.contains("Line 3, column 4, Rule ID: TRANSLATION_LENGTH"));
+    assertTrue(output.contains("Line 3, column 3, Rule ID: TRANSLATION_LENGTH"));
   }
 
   public void testBitextModeWithDisabledRule() throws Exception {

File: languagetool-core/src/main/java/org/languagetool/rules/bitext/DifferentLengthRule.java
Patch:
@@ -58,7 +58,7 @@ public RuleMatch[] match(AnalyzedSentence sourceText,
     if (isLengthDifferent(getPureText(sourceText), getPureText(targetText))) {
       final AnalyzedTokenReadings[] tokens = targetText.getTokens();
       final int len = tokens[tokens.length - 1].getStartPos() + tokens[tokens.length - 1].getToken().length();
-      return new RuleMatch[] { new RuleMatch(this, 1, len, getMessage()) };
+      return new RuleMatch[] { new RuleMatch(this, 0, len, getMessage()) };
     }
     return new RuleMatch[0];
   }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/AccentuationCheckRule.java
Patch:
@@ -210,7 +210,7 @@ else if ( !token.equals("venia") && !token.equals("venies") && !token.equals("te
       	else if ( !token.equals("pronuncia") && !token.equals("pronuncies") && !token.equals("venia") && !token.equals("venies")
       	          && !token.equals("tenia") && !token.equals("tenies") && !token.equals("continua") && !token.equals("continues")
       	          && !token.equals("faria") && !token.equals("faries")
-      	          && !token.equals("genera")
+      	          && !token.equals("genera") && !token.equals("figuri")
       	          && (i<tokens.length-1) &&
       	          (
       	            (matchPostagRegexp(relevantWords.get(token),NOM_MS) && matchPostagRegexp(tokens[i+1],ADJECTIU_MS))

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tokenizers/ca/CatalanWordTokenizer.java
Patch:
@@ -51,7 +51,7 @@ public class CatalanWordTokenizer implements Tokenizer {
     // apostrophe 
     private static final Pattern APOSTROPHE = Pattern.compile("([\\p{L}])['’]([\\p{L}\"‘“«])",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
     // apostrophe before number 1. Ex.: d'1 km, és l'1 de gener, és d'1.4 kg
-    private static final Pattern APOSTROPHE_1 = Pattern.compile("([dlDL])['’](1[\\s\\.,])",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
+    private static final Pattern APOSTROPHE_1 = Pattern.compile("([dlDL])['’](\\d[\\d\\s\\.,]?)",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
     // nearby hyphens. Ex.: vint-i-quatre 
     private static final Pattern NEARBY_HYPHENS= Pattern.compile("([\\p{L}])-([\\p{L}])-([\\p{L}])",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
     // hyphens. Ex.: vint-i-quatre 

File: languagetool-language-modules/ca/src/test/java/org/languagetool/tokenizers/ca/CatalanWordTokenizerTest.java
Patch:
@@ -53,6 +53,9 @@ public void testTokenize() {
 		tokens = wordTokenizer.tokenize("És d'1,5 km.");
 		assertEquals(tokens.size(), 7);
 		assertEquals("[És,  , d', 1,5,  , km, .]", tokens.toString());
+		tokens = wordTokenizer.tokenize("És d'5 km.");
+		assertEquals(tokens.size(), 7);
+		assertEquals("[És,  , d', 5,  , km, .]", tokens.toString());
 		tokens = wordTokenizer.tokenize("la direcció E-SE");
 		assertEquals(tokens.size(), 7);
 		assertEquals("[la,  , direcció,  , E, -, SE]", tokens.toString());

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GermanWrongWordInContextRuleTest.java
Patch:
@@ -54,6 +54,7 @@ public void testRule() throws IOException {
     assertGood("Ich male ein Bild einer Mühle.");
     assertGood("Das Bild zeigt eine mahlende Mühle.");
     assertGood("Eine mahlende Mühle zeigt das Bild.");
+    assertGood("Wenn du mal etwas Mehl brauchst, kannst du zu mir kommen.");
     assertBad("Weizen ausmalen.");
     assertBad("Ich mahle das Bild aus.");
     assertBad("Eine Mühle wird zum Malen verwendet.");

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -46,6 +46,7 @@ public void testRule() throws IOException {
 		//assertCorrect("la festa de Rams es commemora anant a l'església a beneir el palmó");
 		//assertCorrect("les circumstàncies m'obliguen a gloriar-me"); Cal buscar la concordança amb (m')
 		//assertCorrect("es van agenollar i prosternar");
+	  assertCorrect("el cor m'anava a cent per hora.");
 	  assertCorrect("No li ho ensenyis, que el faràs delir.");
 		assertCorrect("m'aniria bé probablement posar els quilos");
 		assertCorrect("per a portar-te aigua");

File: languagetool-language-modules/ca/src/main/java/org/languagetool/tokenizers/ca/CatalanWordTokenizer.java
Patch:
@@ -143,7 +143,7 @@ public List<String> tokenize(final String text) {
 		return l;
 	}
 	
-	/* Splits a word containing hyphen(-) it it doesn't exist in the dictionary*/
+	/* Splits a word containing hyphen(-) if it doesn't exist in the dictionary*/
 	private List<String> wordsToAdd(String s) {
 		final List<String> l = new ArrayList<String>();
 		if (!s.contains("-"))

File: languagetool-language-modules/nl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -29,7 +29,7 @@ public void testDutch() throws IOException {
     final JLanguageTool tool = new JLanguageTool(new Dutch());
     tool.activateDefaultPatternRules();
     assertEquals(0, tool.check("Een test, die geen fouten mag geven.").size());
-    assertEquals(2, tool.check("Een test test, die een fout moet geven.").size());
+    assertEquals(1, tool.check("Een test test, die een fout moet geven.").size());
     assertEquals(1, tool.check("Dit is fout.!").size());
     //test uppercasing rule:
     /*  

File: languagetool-language-modules/de/src/main/java/org/languagetool/rules/de/GermanSpellerRule.java
Patch:
@@ -100,7 +100,7 @@ private static MorfologikSpeller getSpeller(Language language) {
     }
   }
 
-  // Use hunspell-style replacements to get got suggestions for "heisse", namely "heiße"
+  // Use hunspell-style replacements to get good suggestions for "heisse", namely "heiße" etc
   // TODO: remove this when the Morfologik speller can do this directly during tree iteration:
   @Override
   protected List<String> sortSuggestionByQuality(String misspelling, List<String> suggestions) {

File: languagetool-language-modules/ca/src/test/java/org/languagetool/tagging/ca/CatalanTaggerTest.java
Patch:
@@ -46,6 +46,8 @@ public void testTagger() throws IOException {
 // Need to fix the separator character: al - a+el+SP+DA
 //    TestTools.myAssert("Frase recitada al matí.",
 //        "Frase/[frase]NCFS000 -- recitada/[recitar]VMP00SF -- al/[a]el+SP+DA -- matí/[matar]VMIS1S0|[matí]NCMS000", tokenizer, tagger);
-    TestTools.myAssert("blablabla","blablabla/[null]null", tokenizer, tagger);        
+    TestTools.myAssert("blablabla","blablabla/[null]null", tokenizer, tagger);       
+    TestTools.myAssert("inajornablement", "inajornablement/[inajornablement]RG", tokenizer, tagger);
+    TestTools.myAssert("acomplexadament", "acomplexadament/[acomplexadament]RG", tokenizer, tagger);
   }
 }

File: languagetool-core/src/main/java/org/languagetool/rules/spelling/morfologik/MorfologikSpeller.java
Patch:
@@ -80,7 +80,8 @@ public boolean isMisspelled(String word) {
             && !containsDigit(word)
             && !LANGUAGETOOL.equals(word)
             && !speller.isInDictionary(word)
-            && !speller.isInDictionary(word.toLowerCase(conversionLocale));
+            && !(!StringTools.isMixedCase(word) 
+                && speller.isInDictionary(word.toLowerCase(conversionLocale)));
   }
 
   public List<String> getSuggestions(String word) {

File: languagetool-commandline/src/test/java/org/languagetool/commandline/MainTest.java
Patch:
@@ -191,7 +191,7 @@ public void testEnglishStdIn4() throws Exception {
     assertTrue("Got: " + output, output.contains("<error fromy=\"4\" fromx=\"5\" toy=\"4\" tox=\"10\" " +
             "ruleId=\"ENGLISH_WORD_REPEAT_RULE\" msg=\"Possible typo: you repeated a word\" replacements=\"is\" " +
             "context=\"This is is a test of language tool. \" contextoffset=\"5\" offset=\"5\" errorlength=\"5\" " +
-            "category=\"Miscellaneous\" locqualityissuetype=\"addition\"/>"));
+            "category=\"Miscellaneous\" locqualityissuetype=\"duplication\"/>"));
     // note: the offset is relative to the sentence... this seems wrong - it happens because of the way
     // the command line client feeds the data into the check() methods.
   }

File: languagetool-core/src/main/java/org/languagetool/rules/WordRepeatRule.java
Patch:
@@ -36,7 +36,7 @@ public class WordRepeatRule extends Rule {
   public WordRepeatRule(final ResourceBundle messages, final Language language) {
     super(messages);
     super.setCategory(new Category(messages.getString("category_misc")));
-    setLocQualityIssueType("addition");
+    setLocQualityIssueType("duplication");
   }
 
   /**

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/DatabaseDumpHandler.java
Patch:
@@ -113,7 +113,7 @@ protected void handleResult(String title, List<RuleMatch> ruleMatches,
           prepSt.setString(9, URL_PREFIX.replaceAll(LANG_MARKER, langCode) + title);
           prepSt.executeUpdate();
           errorCount++;
-          if (maxErrors > 0 && errorCount > maxErrors) {
+          if (maxErrors > 0 && errorCount >= maxErrors) {
             throw new ErrorLimitReachedException(maxErrors);
           }
         }

File: languagetool-wikipedia/src/main/java/org/languagetool/dev/wikipedia/OutputDumpHandler.java
Patch:
@@ -68,7 +68,7 @@ protected void handleResult(String title, List<RuleMatch> ruleMatches,
           System.out.println(StringTools.getContext(match.getFromPos(), match.getToPos(), text, CONTEXT_SIZE));
           i++;
           errorCount++;
-          if (maxErrors > 0 && errorCount > maxErrors) {
+          if (maxErrors > 0 && errorCount >= maxErrors) {
             throw new ErrorLimitReachedException(maxErrors);
           }
         }

File: languagetool-server/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -278,7 +278,7 @@ private JLanguageTool getLanguageToolInstance(Language lang, Language motherTong
       configureGUI(newLanguageTool);
     }
     if (useQuerySettings) {
-      Tools.selectRules(newLanguageTool, disabledRules, enabledRules);
+      Tools.selectRules(newLanguageTool, disabledRules, enabledRules, true);
     }
     return newLanguageTool;
   }

File: languagetool-server/src/test/java/org/languagetool/server/HTTPServerTest.java
Patch:
@@ -128,8 +128,8 @@ void runTests() throws IOException, SAXException, ParserConfigurationException {
     //enabling
     assertTrue(checkWithOptions(
             english, german, "This is an test", disableAvsAn, nothing).contains("an test"));
-    //should also mean disabling all other rules...
-    assertTrue(!checkWithOptions(
+    //should also mean _NOT_ disabling all other rules...
+    assertTrue(checkWithOptions(
             english, german, "We will berate you", disableAvsAn, nothing).contains("BERATE"));
     
     //test if two rules get enabled as well

File: languagetool-standalone/src/main/dev/tools/ltdiff/VersionDiffGenerator.java
Patch:
@@ -133,7 +133,7 @@ private void makeDiff(String lang) throws IOException {
 
             for (int k = 0; k < r.correct.size(); k++) { // remove examples which already exist in old rule
 
-              for (int l = 0; l < oldRules.get(j).correct.size(); l++) {
+              for (int l = 0; l < oldRules.get(j).correct.size() && r.correct.size()>0; l++) {
 
                 if (r.correct.get(k).equals(oldRules.get(j).correct.get(l))) {
 
@@ -148,7 +148,7 @@ private void makeDiff(String lang) throws IOException {
 
             for (int k = 0; k < r.incorrect.size(); k++) { // remove examples which already exist in old rule
 
-              for (int l = 0; l < oldRules.get(j).incorrect.size(); l++) {
+              for (int l = 0; l < oldRules.get(j).incorrect.size() && r.incorrect.size()>0; l++) {
 
                 if (r.incorrect.get(k).equals(oldRules.get(j).incorrect.get(l))) {
 

File: languagetool-language-modules/en/src/main/java/org/languagetool/tagging/en/EnglishTagger.java
Patch:
@@ -25,7 +25,7 @@
 /**
  * English Part-of-speech tagger.
  * The POS tagset is described in
- * <a href="https://languagetool.svn.sourceforge.net/svnroot/languagetool/trunk/JLanguageTool/src/main/resources/org/languagetool/resource/en/tagset.txt">tagset.txt</a>
+ * <a href="https://languagetool.svn.sourceforge.net/svnroot/languagetool/trunk/languagetool/languagetool-language-modules/en/src/main/resources/org/languagetool/resource/en/tagset.txt">tagset.txt</a>
  * 
  * @author Marcin Milkowski
  */

File: languagetool-core/src/main/java/org/languagetool/tagging/disambiguation/rules/DisambiguationPatternRule.java
Patch:
@@ -126,7 +126,7 @@ public final void setNewInterpretations(final AnalyzedToken[] newReadings) {
    */
   public final AnalyzedSentence replace(final AnalyzedSentence text)
       throws IOException {
-    final AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();
+    final AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace(); 
     AnalyzedTokenReadings[] whTokens = text.getTokens();
     final int[] tokenPositions = new int[tokens.length + 1];
     final int patternSize = patternElements.size();

File: languagetool-core/src/test/java/org/languagetool/VersionNumberTest.java
Patch:
@@ -31,7 +31,7 @@ public class VersionNumberTest extends TestCase {
 
   public void testVersionNumber() throws IOException {
     final String buildFile = StringTools.readFile(new FileInputStream("pom.xml"));
-    final Pattern p1 = Pattern.compile("<version>([0-9\\.]+(-SNAPSHOT)?)</version>");
+    final Pattern p1 = Pattern.compile("<version>([0-9\\.]+(-SNAPSHOT|-beta[0-9])?)</version>");
     final Matcher m1 = p1.matcher(buildFile);
     m1.find();
     final String javaFile = StringTools.readFile(new FileInputStream("src/main/java/org/languagetool/JLanguageTool.java"));

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternTestTools.java
Patch:
@@ -73,9 +73,9 @@ public static void warnIfRegexpSyntaxNotKosher(final List<Element> elements,
             element.getPOStag() == null ? "" : element.getPOStag(),
             element.isPOStagRegularExpression(),
             element.getCaseSensitive(),
-            element.getPOSNegation(),
-            true,   // a POS.
+            element.getPOSNegation(),            
             false,
+            true,   // a POS.
             lang, ruleId + ":" + ruleSubId + " (POS tag)",
             i);
 

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -41,8 +41,8 @@ public class ReflexiveVerbsRule extends CatalanRule {
    * Patterns
    */
   
-//List of only pronominal verbs from GDLC (eliminats: assolar, enfundar, burlar, traslluir, intersecar) (afegits: delir, desomplir)
-  private static final Pattern VERBS_PRONOMINALS = Pattern.compile("auto.+|desomplir|delir|fugar|abacallanar|abalançar|ablenar|aborrallonar|abotifarrar|abrinar|abromar|abstenir|acagallonar|acanyar|acarcanyar|acarnissar|acatarrar|aciutadanar|aclocar|acopar|acorriolar|adir|adonar|adormissar|afal·lerar|afarrossar|afeccionar|aferrallar|aferrissar|aferrussar|agallinar|agarbir|agarrofar|agemolir|agenollar|agotzonar|aiguabarrejar|allocar|alçurar|amatinar|amelar|amigar|amoixir|amoltonar|amotar|amullerar|amunionar|antullar|aparroquianar|aparroquiar|aperduar|apergaminar|apiadar|aponentar|apropinquar|apugonar|arguellar|arrapinyar|arrasir|arravatar|arraïmar|arrepapar|arrepenjar|arrepetellar|arrigolar|arrodir|arrogar|arrossar|arruar|assemblar|assocarrar|atendar|atenir|atorrentar|atrafegar|atrevir|avencar|avidolar|avinençar|balbar|balcar|balir|balmar|bescomptar|boirar|boixar|botinflar|bromar|cagaferrar|candir|capbaixar|capmassar|captenir|cariar|carnificar|carpir|coalitzar|colltrencar|collvinclar|compenetrar|condoldre|condolir|congraciar|contorçar|contrapuntar|contòrcer|corcorcar|coresforçar|cornuar|corruixar|crisalidar|desafeccionar|desalenar|desamorar|desaparroquiar|desapassionar|desaplegar|desavenir|desbocar|descantar|descarar|descontrolar|descovar|desdubtar|desempallegar|desenrojolar|desentossudir|desfeinar|desmemoriar|desnodrir|despondre|despreocupar|dessolidaritzar|desteixinar|desvagar|desvergonyir|desviure|dignar|embarbussar|embascar|embessonar|embordeir|embordir|emborrascar|emborrossar|embotifarrar|embotzegar|embromallar|embromar|embroquerar|emmainadar|emmalurar|emmalurir|emmarar|emmarranar|emmatar|emmigranyar|emmorronar|emmurriar|empassar|empassolar|empegueir|empenyalar|empescar|empillocar|empinyar|empiocar|empitarrar|emplomissar|emplujar|emportar|encabotar|encabritar|encalmar|encalostrar|encelar|encinglar|encirar|encistar|enclaperar|encolerir|encordar|encruar|endoblir|endur|enfarfollar|enfaristolar|enfavar|enfereir|enferotgir|enferritjar|enfugir|enfurrunyar|enfutimar|enfutismar|engelabrir|engolfar|engorgar|engripar|enguerxinar|enllagrimar|enlleganyar|enlleir|ennavegar|enneguitar|enquistar|enrinxar|enseriosir|ensobecar|entonyinar|entossudir|entotsolar|entreabaltir|entrebadar|entrebatre|entrebesar|entrecavalcar|entredevorar|entreferir|entreforcar|entrematar|entremetre|entremirar|entrenyorar|entresaludar|entreseguir|entresoldar|entretocar|entretzenar|entrigar|envidreir|envidriar|envolar|enxautar|esbafar|esbafegar|esbatussar|esblamar|esbojarrar|esborneiar|esbromar|escabridar|escamotar|escanyellar|escanyolir|escanyussar|escapolar|escapolir|escarcanyar|escarramicar|escarrassar|escarxofar|escatifenyar|esconillar|escorporar|escullar|escunçar|esfarinar|esfetgegar|esforçar|esgargamellar|esgatinyar|esgolar|esguimbar|esllanguir|esllavissar|esperitar|espitellar|espitxar|espollinar|espoltrar|esporcellar|espotonar|esprimatxar|esquifir|esquitllar|estilar|estritllar|esvedellar|esventegar|esvomegar|etiolar|extralimitar|extravasar|extravenar|gamar|gaspar|gatinyar|gaubar|gloriar|grifar|immiscir|indigestar|industriar|innivar|insolentar|insurgir|inveterar|irèixer|jactar|juramentar|lateritzar|llufar|malfiar|malfixar|migrolar|mofar|mullerar|neulir|obstinar|octubrar|olivar|pellobrir|pellpartir|pelltrencar|penedir|penjolar|pollar|prosternar|queixar|querar|querellar|quillar|ramificar|rancurar|realegrar|rebel·lar|rebordeir|refiar|repanxolar|repapar|repetellar|reressagar|resclosir|ressagar|ressentir|revenjar|salinar|suïcidar|tinyar|tolir|transvestir|traspostar|trufar|vanagloriar|vanagloriejar|vanar|vantar|vergonyar|xautar");
+//List of only pronominal verbs from GDLC (eliminats: assolar, enfundar, burlar, traslluir, intersecar) (afegits: delir, desomplir, encaramallar)
+  private static final Pattern VERBS_PRONOMINALS = Pattern.compile("auto.+|encaramallar|desomplir|delir|fugar|abacallanar|abalançar|ablenar|aborrallonar|abotifarrar|abrinar|abromar|abstenir|acagallonar|acanyar|acarcanyar|acarnissar|acatarrar|aciutadanar|aclocar|acopar|acorriolar|adir|adonar|adormissar|afal·lerar|afarrossar|afeccionar|aferrallar|aferrissar|aferrussar|agallinar|agarbir|agarrofar|agemolir|agenollar|agotzonar|aiguabarrejar|allocar|alçurar|amatinar|amelar|amigar|amoixir|amoltonar|amotar|amullerar|amunionar|antullar|aparroquianar|aparroquiar|aperduar|apergaminar|apiadar|aponentar|apropinquar|apugonar|arguellar|arrapinyar|arrasir|arravatar|arraïmar|arrepapar|arrepenjar|arrepetellar|arrigolar|arrodir|arrogar|arrossar|arruar|assemblar|assocarrar|atendar|atenir|atorrentar|atrafegar|atrevir|avencar|avidolar|avinençar|balbar|balcar|balir|balmar|bescomptar|boirar|boixar|botinflar|bromar|cagaferrar|candir|capbaixar|capmassar|captenir|cariar|carnificar|carpir|coalitzar|colltrencar|collvinclar|compenetrar|condoldre|condolir|congraciar|contorçar|contrapuntar|contòrcer|corcorcar|coresforçar|cornuar|corruixar|crisalidar|desafeccionar|desalenar|desamorar|desaparroquiar|desapassionar|desaplegar|desavenir|desbocar|descantar|descarar|descontrolar|descovar|desdubtar|desempallegar|desenrojolar|desentossudir|desfeinar|desmemoriar|desnodrir|despondre|despreocupar|dessolidaritzar|desteixinar|desvagar|desvergonyir|desviure|dignar|embarbussar|embascar|embessonar|embordeir|embordir|emborrascar|emborrossar|embotifarrar|embotzegar|embromallar|embromar|embroquerar|emmainadar|emmalurar|emmalurir|emmarar|emmarranar|emmatar|emmigranyar|emmorronar|emmurriar|empassar|empassolar|empegueir|empenyalar|empescar|empillocar|empinyar|empiocar|empitarrar|emplomissar|emplujar|emportar|encabotar|encabritar|encalmar|encalostrar|encelar|encinglar|encirar|encistar|enclaperar|encolerir|encordar|encruar|endoblir|endur|enfarfollar|enfaristolar|enfavar|enfereir|enferotgir|enferritjar|enfugir|enfurrunyar|enfutimar|enfutismar|engelabrir|engolfar|engorgar|engripar|enguerxinar|enllagrimar|enlleganyar|enlleir|ennavegar|enneguitar|enquistar|enrinxar|enseriosir|ensobecar|entonyinar|entossudir|entotsolar|entreabaltir|entrebadar|entrebatre|entrebesar|entrecavalcar|entredevorar|entreferir|entreforcar|entrematar|entremetre|entremirar|entrenyorar|entresaludar|entreseguir|entresoldar|entretocar|entretzenar|entrigar|envidreir|envidriar|envolar|enxautar|esbafar|esbafegar|esbatussar|esblamar|esbojarrar|esborneiar|esbromar|escabridar|escamotar|escanyellar|escanyolir|escanyussar|escapolar|escapolir|escarcanyar|escarramicar|escarrassar|escarxofar|escatifenyar|esconillar|escorporar|escullar|escunçar|esfarinar|esfetgegar|esforçar|esgargamellar|esgatinyar|esgolar|esguimbar|esllanguir|esllavissar|esperitar|espitellar|espitxar|espollinar|espoltrar|esporcellar|espotonar|esprimatxar|esquifir|esquitllar|estilar|estritllar|esvedellar|esventegar|esvomegar|etiolar|extralimitar|extravasar|extravenar|gamar|gaspar|gatinyar|gaubar|gloriar|grifar|immiscir|indigestar|industriar|innivar|insolentar|insurgir|inveterar|irèixer|jactar|juramentar|lateritzar|llufar|malfiar|malfixar|migrolar|mofar|mullerar|neulir|obstinar|octubrar|olivar|pellobrir|pellpartir|pelltrencar|penedir|penjolar|pollar|prosternar|queixar|querar|querellar|quillar|ramificar|rancurar|realegrar|rebel·lar|rebordeir|refiar|repanxolar|repapar|repetellar|reressagar|resclosir|ressagar|ressentir|revenjar|salinar|suïcidar|tinyar|tolir|transvestir|traspostar|trufar|vanagloriar|vanagloriejar|vanar|vantar|vergonyar|xautar");
   private static final Pattern NO_VERBS_PRONOMINALS = Pattern.compile("atendre|escollir|assolir|autofinançar|autografiar|automatitzar|autoritzar");
   //Eliminats: témer
   private static final Pattern VERBS_NO_PRONOMINALS = Pattern.compile("baixar|caure|callar|marxar|albergar|olorar|seure");

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -41,8 +41,8 @@ public class ReflexiveVerbsRule extends CatalanRule {
    * Patterns
    */
   
-//List of only pronominal verbs from GDLC (eliminats: assolar, enfundar, burlar, traslluir) (afegits: delir)
-  private static final Pattern VERBS_PRONOMINALS = Pattern.compile("auto.+|delir|fugar|abacallanar|abalançar|ablenar|aborrallonar|abotifarrar|abrinar|abromar|abstenir|acagallonar|acanyar|acarcanyar|acarnissar|acatarrar|aciutadanar|aclocar|acopar|acorriolar|adir|adonar|adormissar|afal·lerar|afarrossar|afeccionar|aferrallar|aferrissar|aferrussar|agallinar|agarbir|agarrofar|agemolir|agenollar|agotzonar|aiguabarrejar|allocar|alçurar|amatinar|amelar|amigar|amoixir|amoltonar|amotar|amullerar|amunionar|antullar|aparroquianar|aparroquiar|aperduar|apergaminar|apiadar|aponentar|apropinquar|apugonar|arguellar|arrapinyar|arrasir|arravatar|arraïmar|arrepapar|arrepenjar|arrepetellar|arrigolar|arrodir|arrogar|arrossar|arruar|assemblar|assocarrar|atendar|atenir|atorrentar|atrafegar|atrevir|avencar|avidolar|avinençar|balbar|balcar|balir|balmar|bescomptar|boirar|boixar|botinflar|bromar|cagaferrar|candir|capbaixar|capmassar|captenir|cariar|carnificar|carpir|coalitzar|colltrencar|collvinclar|compenetrar|condoldre|condolir|congraciar|contorçar|contrapuntar|contòrcer|corcorcar|coresforçar|cornuar|corruixar|crisalidar|desafeccionar|desalenar|desamorar|desaparroquiar|desapassionar|desaplegar|desavenir|desbocar|descantar|descarar|descontrolar|descovar|desdubtar|desempallegar|desenrojolar|desentossudir|desfeinar|desmemoriar|desnodrir|despondre|despreocupar|dessolidaritzar|desteixinar|desvagar|desvergonyir|desviure|dignar|embarbussar|embascar|embessonar|embordeir|embordir|emborrascar|emborrossar|embotifarrar|embotzegar|embromallar|embromar|embroquerar|emmainadar|emmalurar|emmalurir|emmarar|emmarranar|emmatar|emmigranyar|emmorronar|emmurriar|empassar|empassolar|empegueir|empenyalar|empescar|empillocar|empinyar|empiocar|empitarrar|emplomissar|emplujar|emportar|encabotar|encabritar|encalmar|encalostrar|encelar|encinglar|encirar|encistar|enclaperar|encolerir|encordar|encruar|endoblir|endur|enfarfollar|enfaristolar|enfavar|enfereir|enferotgir|enferritjar|enfugir|enfurrunyar|enfutimar|enfutismar|engelabrir|engolfar|engorgar|engripar|enguerxinar|enllagrimar|enlleganyar|enlleir|ennavegar|enneguitar|enquistar|enrinxar|enseriosir|ensobecar|entonyinar|entossudir|entotsolar|entreabaltir|entrebadar|entrebatre|entrebesar|entrecavalcar|entredevorar|entreferir|entreforcar|entrematar|entremetre|entremirar|entrenyorar|entresaludar|entreseguir|entresoldar|entretocar|entretzenar|entrigar|envidreir|envidriar|envolar|enxautar|esbafar|esbafegar|esbatussar|esblamar|esbojarrar|esborneiar|esbromar|escabridar|escamotar|escanyellar|escanyolir|escanyussar|escapolar|escapolir|escarcanyar|escarramicar|escarrassar|escarxofar|escatifenyar|esconillar|escorporar|escullar|escunçar|esfarinar|esfetgegar|esforçar|esgargamellar|esgatinyar|esgolar|esguimbar|esllanguir|esllavissar|esperitar|espitellar|espitxar|espollinar|espoltrar|esporcellar|espotonar|esprimatxar|esquifir|esquitllar|estilar|estritllar|esvedellar|esventegar|esvomegar|etiolar|extralimitar|extravasar|extravenar|gamar|gaspar|gatinyar|gaubar|gloriar|grifar|immiscir|indigestar|industriar|innivar|insolentar|insurgir|intersecar|inveterar|irèixer|jactar|juramentar|lateritzar|llufar|malfiar|malfixar|migrolar|mofar|mullerar|neulir|obstinar|octubrar|olivar|pellobrir|pellpartir|pelltrencar|penedir|penjolar|pollar|prosternar|queixar|querar|querellar|quillar|ramificar|rancurar|realegrar|rebel·lar|rebordeir|refiar|repanxolar|repapar|repetellar|reressagar|resclosir|ressagar|ressentir|revenjar|salinar|suïcidar|tinyar|tolir|transvestir|traspostar|trufar|vanagloriar|vanagloriejar|vanar|vantar|vergonyar|xautar");
+//List of only pronominal verbs from GDLC (eliminats: assolar, enfundar, burlar, traslluir, intersecar) (afegits: delir, desomplir)
+  private static final Pattern VERBS_PRONOMINALS = Pattern.compile("auto.+|desomplir|delir|fugar|abacallanar|abalançar|ablenar|aborrallonar|abotifarrar|abrinar|abromar|abstenir|acagallonar|acanyar|acarcanyar|acarnissar|acatarrar|aciutadanar|aclocar|acopar|acorriolar|adir|adonar|adormissar|afal·lerar|afarrossar|afeccionar|aferrallar|aferrissar|aferrussar|agallinar|agarbir|agarrofar|agemolir|agenollar|agotzonar|aiguabarrejar|allocar|alçurar|amatinar|amelar|amigar|amoixir|amoltonar|amotar|amullerar|amunionar|antullar|aparroquianar|aparroquiar|aperduar|apergaminar|apiadar|aponentar|apropinquar|apugonar|arguellar|arrapinyar|arrasir|arravatar|arraïmar|arrepapar|arrepenjar|arrepetellar|arrigolar|arrodir|arrogar|arrossar|arruar|assemblar|assocarrar|atendar|atenir|atorrentar|atrafegar|atrevir|avencar|avidolar|avinençar|balbar|balcar|balir|balmar|bescomptar|boirar|boixar|botinflar|bromar|cagaferrar|candir|capbaixar|capmassar|captenir|cariar|carnificar|carpir|coalitzar|colltrencar|collvinclar|compenetrar|condoldre|condolir|congraciar|contorçar|contrapuntar|contòrcer|corcorcar|coresforçar|cornuar|corruixar|crisalidar|desafeccionar|desalenar|desamorar|desaparroquiar|desapassionar|desaplegar|desavenir|desbocar|descantar|descarar|descontrolar|descovar|desdubtar|desempallegar|desenrojolar|desentossudir|desfeinar|desmemoriar|desnodrir|despondre|despreocupar|dessolidaritzar|desteixinar|desvagar|desvergonyir|desviure|dignar|embarbussar|embascar|embessonar|embordeir|embordir|emborrascar|emborrossar|embotifarrar|embotzegar|embromallar|embromar|embroquerar|emmainadar|emmalurar|emmalurir|emmarar|emmarranar|emmatar|emmigranyar|emmorronar|emmurriar|empassar|empassolar|empegueir|empenyalar|empescar|empillocar|empinyar|empiocar|empitarrar|emplomissar|emplujar|emportar|encabotar|encabritar|encalmar|encalostrar|encelar|encinglar|encirar|encistar|enclaperar|encolerir|encordar|encruar|endoblir|endur|enfarfollar|enfaristolar|enfavar|enfereir|enferotgir|enferritjar|enfugir|enfurrunyar|enfutimar|enfutismar|engelabrir|engolfar|engorgar|engripar|enguerxinar|enllagrimar|enlleganyar|enlleir|ennavegar|enneguitar|enquistar|enrinxar|enseriosir|ensobecar|entonyinar|entossudir|entotsolar|entreabaltir|entrebadar|entrebatre|entrebesar|entrecavalcar|entredevorar|entreferir|entreforcar|entrematar|entremetre|entremirar|entrenyorar|entresaludar|entreseguir|entresoldar|entretocar|entretzenar|entrigar|envidreir|envidriar|envolar|enxautar|esbafar|esbafegar|esbatussar|esblamar|esbojarrar|esborneiar|esbromar|escabridar|escamotar|escanyellar|escanyolir|escanyussar|escapolar|escapolir|escarcanyar|escarramicar|escarrassar|escarxofar|escatifenyar|esconillar|escorporar|escullar|escunçar|esfarinar|esfetgegar|esforçar|esgargamellar|esgatinyar|esgolar|esguimbar|esllanguir|esllavissar|esperitar|espitellar|espitxar|espollinar|espoltrar|esporcellar|espotonar|esprimatxar|esquifir|esquitllar|estilar|estritllar|esvedellar|esventegar|esvomegar|etiolar|extralimitar|extravasar|extravenar|gamar|gaspar|gatinyar|gaubar|gloriar|grifar|immiscir|indigestar|industriar|innivar|insolentar|insurgir|inveterar|irèixer|jactar|juramentar|lateritzar|llufar|malfiar|malfixar|migrolar|mofar|mullerar|neulir|obstinar|octubrar|olivar|pellobrir|pellpartir|pelltrencar|penedir|penjolar|pollar|prosternar|queixar|querar|querellar|quillar|ramificar|rancurar|realegrar|rebel·lar|rebordeir|refiar|repanxolar|repapar|repetellar|reressagar|resclosir|ressagar|ressentir|revenjar|salinar|suïcidar|tinyar|tolir|transvestir|traspostar|trufar|vanagloriar|vanagloriejar|vanar|vantar|vergonyar|xautar");
   private static final Pattern NO_VERBS_PRONOMINALS = Pattern.compile("atendre|escollir|assolir|autofinançar|autografiar|automatitzar|autoritzar");
   //Eliminats: témer
   private static final Pattern VERBS_NO_PRONOMINALS = Pattern.compile("baixar|caure|callar|marxar|albergar|olorar|seure");

File: languagetool-language-modules/de/src/test/java/org/languagetool/rules/de/GenericUnpairedBracketsRuleTest.java
Patch:
@@ -40,6 +40,8 @@ public void testGermanRule() throws IOException {
     assertMatches("(Das sind die «Sätze», die sie testen sollen).", 0);
     assertMatches("(Das sind die »Sätze«, die sie testen sollen).", 0);
     assertMatches("(Das sind die Sätze (noch mehr Klammern [schon wieder!]), die sie testen sollen).", 0);
+    assertMatches("Das ist ein Satz mit Smiley :-)", 0);
+    assertMatches("Das ist auch ein Satz mit Smiley ;-)", 0);
     // incorrect sentences:
     assertMatches("Die „Sätze zum Testen.", 1);
     assertMatches("Die «Sätze zum Testen.", 1);

File: languagetool-language-modules/pl/src/test/java/org/languagetool/JLanguageToolTest.java
Patch:
@@ -80,9 +80,9 @@ public void testPolish() throws IOException {
             sent.getAnnotations());
     sent = tool.getAnalyzedSentence("Nie mamy żadnej ryby.");
     assertEquals("Disambiguator log: "
-            + "\n\nNIE_ADAMP: Nie[nie/qub*,on/ppron3:pl:acc:f.m2.m3.n.p2.p3:ter:praep*,on/ppron3:sg:acc:n:ter:praep*] -> Nie[nie/qub*]"
-            + "\n\nunify_adj_subst: żadnej[żaden/adj:sg:dat:f:pos,żaden/adj:sg:gen:f:pos,żaden/adj:sg:loc:f:pos] -> żadnej[żaden/adj:sg:gen:f:pos]" +
-            "\n\nunify_adj_subst: ryby[ryba/subst:pl:acc:f,ryba/subst:pl:nom:f,ryba/subst:pl:voc:f,ryba/subst:sg:gen:f] -> ryby[ryba/subst:sg:gen:f]\n",
+            + "\n\nNIE_ADAMP:1 Nie[nie/qub*,on/ppron3:pl:acc:f.m2.m3.n.p2.p3:ter:praep*,on/ppron3:sg:acc:n:ter:praep*] -> Nie[nie/qub*]"
+            + "\n\nunify_adj_subst:1 żadnej[żaden/adj:sg:dat:f:pos,żaden/adj:sg:gen:f:pos,żaden/adj:sg:loc:f:pos] -> żadnej[żaden/adj:sg:gen:f:pos]" +
+            "\n\nunify_adj_subst:1 ryby[ryba/subst:pl:acc:f,ryba/subst:pl:nom:f,ryba/subst:pl:voc:f,ryba/subst:sg:gen:f] -> ryby[ryba/subst:sg:gen:f]\n",
             sent.getAnnotations());
     
   }

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -235,7 +235,7 @@ && isThereBefore(tokens, i, LEMMA_PRONOM_CD, POSTAG_PRONOM_CD) )
 				if (isThereReflexivePronoun(tokens, i)) 
 					continue loop;
 				// the rule matches
-				final String msg = "Aquest verb és pronominal. Falta un pronom.";
+				final String msg = "Aquest verb és pronominal. Probablement falta un pronom.";
 				final RuleMatch ruleMatch = new RuleMatch(this,
 						tokens[i].getStartPos(), tokens[i].getStartPos()
 								+ token.length(), msg,
@@ -270,11 +270,11 @@ && isPhraseImpersonalVerbSP(tokens, i) )
 					continue loop;
 				
 				// the rule matches
-				final String msg = "Aquest verb no és pronominal. Sobra un pronom.";
+				final String msg = "Aquest verb no és pronominal. Probablement sobra un pronom.";
 				final RuleMatch ruleMatch = new RuleMatch(this,
 						tokens[i].getStartPos(), tokens[i].getStartPos()
 								+ token.length(), msg,
-						"Verb no pronominal: sobra un pronom");
+						"Verb no pronominal");
 				ruleMatches.add(ruleMatch);
 			}
 			

File: languagetool-language-modules/fr/src/test/java/org/languagetool/tagging/disambiguation/rules/fr/FrenchRuleDisambiguatorTest.java
Patch:
@@ -89,9 +89,9 @@ public void testChunker() throws IOException {
   public void testAnnotations() throws IOException {
      final AnalyzedSentence sent = lt.getAnalyzedSentence("Les avions");
      assertEquals(sent.getAnnotations(), "Disambiguator log: \n\n" +
-        "RP-D_N_AMBIG: Les[le/D e p*,les/R pers obj 3 p*] -> Les[le/D e p*]"+
-             "\nRB-LE_LA_LES: Les[le/D e p*] -> Les[le/D e p*]" +
-        "\n\nRP-D_N_AMBIG: avions[avoir/V avoir ind impa 1 p,avion/N m p,avoir/SENT_END] -> avions[avion/N m p,avoir/SENT_END]\n");
+        "RP-D_N_AMBIG:1 Les[le/D e p*,les/R pers obj 3 p*] -> Les[le/D e p*]"+
+             "\nRB-LE_LA_LES:1 Les[le/D e p*] -> Les[le/D e p*]" +
+        "\n\nRP-D_N_AMBIG:1 avions[avoir/V avoir ind impa 1 p,avion/N m p,avoir/SENT_END] -> avions[avion/N m p,avoir/SENT_END]\n");
   }
   
 }

File: languagetool-core/src/main/java/org/languagetool/databroker/DefaultResourceDataBroker.java
Patch:
@@ -390,12 +390,10 @@ private static URL getFixedJarURL(URL url) {
 
     try {
       final String newURLStr = "jar:" + file.toURI().toURL().toExternalForm() + "!/" + originalURLPath;
-      url = new URL(newURLStr);
+      return new URL(newURLStr);
     } catch (MalformedURLException e) {
       return url;
     }
-
-    return url;
   }
 
 }

File: languagetool-language-modules/ca/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -40,7 +40,7 @@ public void setUp() throws IOException {
 	}
 
 	public void testRule() throws IOException { 
-
+	  
 		// correct sentences:
 		//es van posar en camí proveïts de presents 
 		assertCorrect("Bernabé i Saule, un cop acomplerta la seva missió a Jerusalem");
@@ -111,6 +111,7 @@ public void testRule() throws IOException {
 		assertCorrect("Era un home força misteriós");
 		
 		// errors:
+		assertIncorrect("Son molt boniques");
 		assertIncorrect("La casa destrossat");
 		assertIncorrect("pantalons curt o llargs");
 		assertIncorrect("sota les grans persianes de color verd recalcada");

File: languagetool-language-modules/ca/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -214,7 +214,7 @@ && isThereVerbBefore(tokens,i,VERBS_DEIXAR_FER)
 					&& isThereBefore(tokens, i, LEMMA_PRONOM_CD, POSTAG_PRONOM_CD)  
 					&& matchRegexp(tokens[i + 1].getToken(), REFLEXIU_POSPOSAT) ) {
 					// the rule matches
-					final String msg = "En aquesta perífrasi verbal el pronom reflexiu posterior és redundant.<suggestion></suggestion>";
+					final String msg = "En aquesta perífrasi verbal el pronom reflexiu posterior és redundant.";
 					final RuleMatch ruleMatch = new RuleMatch(this,
 							tokens[i+1].getStartPos(), tokens[i+1].getStartPos()
 									+ tokens[i+1].getToken().length(), msg, "Pronom redundant");

File: languagetool-core/src/test/java/org/languagetool/rules/CommaWhitespaceRuleTest.java
Patch:
@@ -48,6 +48,7 @@ public void testRule() throws IOException {
     assertMatches("This is $1,000,000.", 0);
     assertMatches("This is 1,5.", 0);
     assertMatches("This is a ,,test''.", 0);
+    assertMatches("This is,\u00A0really,\u00A0non-breaking whitespace.", 0);
     //test OpenOffice field codes:
     assertMatches("In his book,\u0002 Einstein proved this to be true.", 0);
 

File: languagetool-standalone/src/main/dev/org/languagetool/dev/tools/RomanianDiacriticsModifier.java
Patch:
@@ -80,7 +80,7 @@ private static char diac(char c) {
    * <b>ţ</b> with <b>ț</b> (including upper-case variants).<br/>
    * Thread-safe method.
    */
-  public static synchronized String correctDiacritrics(String s) {
+  public static synchronized String correctDiacritics(String s) {
     if (null == s) {
       return null;
     }

File: languagetool-standalone/src/main/dev/org/languagetool/dev/wikipedia/TextFilterTools.java
Patch:
@@ -37,7 +37,7 @@ static BlikiWikipediaTextFilter getTextFilter(Language lang) {
         public String filter(String arg0) {
           final String tmp = super.filter(arg0);
           // diacritics correction (comma-bellow instead of sedilla for ș and ț)
-          return RomanianDiacriticsModifier.correctDiacritrics(tmp);
+          return RomanianDiacriticsModifier.correctDiacritics(tmp);
         }
       };
     } else {

File: languagetool-standalone/src/main/dev/org/languagetool/dev/index/AnyCharTokenizer.java
Patch:
@@ -50,7 +50,7 @@ public AnyCharTokenizer(Version matchVersion, Reader in) {
    * @param matchVersion
    *          Lucene version to match See {@link <a href="#version">above</a>}
    * @param source
-   *          the attribute source to use for this {@link Tokenizer}
+   *          the attribute source to use for this {@link org.apache.lucene.analysis.Tokenizer}
    * @param in
    *          the input to split up into tokens
    */
@@ -65,7 +65,7 @@ public AnyCharTokenizer(Version matchVersion, AttributeSource source, Reader in)
    * @param matchVersion
    *          Lucene version to match See {@link <a href="#version">above</a>}
    * @param factory
-   *          the attribute factory to use for this {@link Tokenizer}
+   *          the attribute factory to use for this {@link org.apache.lucene.analysis.Tokenizer}
    * @param in
    *          the input to split up into tokens
    */

File: languagetool-standalone/src/main/dev/org/languagetool/dev/wikipedia/TextFilterTools.java
Patch:
@@ -31,7 +31,7 @@ private TextFilterTools() {
 
   static BlikiWikipediaTextFilter getTextFilter(Language lang) {
     final BlikiWikipediaTextFilter textFilter;
-    if (Language.ROMANIAN == lang) {
+    if (lang.getShortName().equals("ro")) {
       textFilter = new BlikiWikipediaTextFilter() {
         @Override
         public String filter(String arg0) {

File: languagetool-standalone/src/main/dev/org/languagetool/dev/wikipedia/WikipediaQuickCheck.java
Patch:
@@ -33,6 +33,7 @@
 import org.languagetool.JLanguageTool;
 import org.languagetool.Language;
 import org.languagetool.TextFilter;
+import org.languagetool.language.German;
 import org.languagetool.rules.Rule;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.tools.StringTools;
@@ -170,7 +171,7 @@ public static void main(String[] args) throws IOException {
     final URL url = new URL(urlString);
     final String mediaWikiContent = check.getMediaWikiContent(url);
     final String plainText = check.getPlainText(mediaWikiContent);
-    final WikipediaQuickCheckResult checkResult = check.checkPage(plainText, Language.GERMAN);
+    final WikipediaQuickCheckResult checkResult = check.checkPage(plainText, new German());
     for (RuleMatch ruleMatch : checkResult.getRuleMatches()) {
       System.out.println(ruleMatch.getMessage());
       final String context = StringTools.getContext(ruleMatch.getFromPos(), ruleMatch.getToPos(), checkResult.getText());

File: languagetool-core/src/main/java/org/languagetool/rules/patterns/bitext/BitextPatternRuleLoader.java
Patch:
@@ -185,7 +185,7 @@ private PatternRule finalizeRule() {
       for (final ArrayList<Element> phraseElement : phraseElementList) {
         processElement(phraseElement);
         rule = new PatternRule(id, language, phraseElement,
-            name, message.toString(), shortMessage.toString(),
+            name, message.toString(), shortMessage.toString(), "",
             phraseElementList.size() > 1);
         prepareRule(rule);       
       }

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -477,7 +477,7 @@ private void testBadSentences(JLanguageTool languageTool, JLanguageTool allRules
           // make sure suggestion is what we expect it to be
           if (suggestedCorrections != null && suggestedCorrections.size() > 0) {
             assertTrue("You specified a correction but your message has no suggestions in rule " + rule,
-              rule.getMessage().contains("<suggestion>")
+              rule.getMessage().contains("<suggestion>") || rule.getSuggestionsOutMsg().contains("<suggestion>")
             );
             assertTrue(lang + ": Incorrect suggestions: "
                 + suggestedCorrections.toString() + " != "

File: languagetool-core/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -74,7 +74,7 @@ public void testDemoLanguageGrammarRules() throws IOException {
   /** To be called from language modules. */
   protected void runGrammarRulesFromXmlTest() throws IOException {
     for (final Language lang : Language.REAL_LANGUAGES) {
-      if (skipCountryVariant(lang)) {
+      if (skipCountryVariant(lang) && Language.REAL_LANGUAGES.length>1) {
         System.out.println("Skipping " + lang + " because there are no specific rules for that variant");
         continue;
       }
@@ -91,7 +91,7 @@ private boolean skipCountryVariant(Language lang) {
   private String getGrammarFileName(Language lang) {
     final String shortNameWithVariant = lang.getShortNameWithVariant();
     final String fileName;
-    if (shortNameWithVariant.contains("-") && !shortNameWithVariant.endsWith("-ANY")) {
+    if (shortNameWithVariant.contains("-") && !shortNameWithVariant.endsWith("-ANY")  && Language.REAL_LANGUAGES.length>1) {
       fileName = lang.getShortName() + "/" + shortNameWithVariant + "/" + JLanguageTool.PATTERN_FILE;
     } else {
       fileName = lang.getShortName() + "/" + JLanguageTool.PATTERN_FILE;

File: languagetool-language-modules/ca/src/main/java/org/languagetool/language/Catalan.java
Patch:
@@ -66,7 +66,7 @@ public String getName() {
 
   @Override
   public String[] getCountryVariants() {
-    return new String[]{"ANY"};
+    return new String[]{"ES"};
   }
   
   @Override

File: languagetool-standalone/src/main/dev/org/languagetool/dev/CheckBNC.java
Patch:
@@ -25,8 +25,8 @@
 import java.util.List;
 
 import org.languagetool.JLanguageTool;
-import org.languagetool.Language;
 import org.languagetool.TextFilter;
+import org.languagetool.language.English;
 import org.languagetool.tokenizers.Tokenizer;
 import org.languagetool.tools.StringTools;
 import org.languagetool.tools.Tools;
@@ -53,7 +53,7 @@ public static void main(String[] args) throws Exception {
   }
   
   private CheckBNC() throws IOException {
-    langTool = new JLanguageTool(Language.ENGLISH);
+    langTool = new JLanguageTool(new English());
     langTool.activateDefaultPatternRules();
     final String[] disRules = new String[] {"UPPERCASE_SENTENCE_START", "COMMA_PARENTHESIS_WHITESPACE",
         "WORD_REPEAT_RULE", "DOUBLE_PUNCTUATION"};

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -42,7 +42,7 @@ public class ReflexiveVerbsRule extends CatalanRule {
    */
   
 //List of only pronominal verbs from GDLC (eliminats: assolar, enfundar, burlar, traslluir)
-  private static final Pattern VERBS_PRONOMINALS = Pattern.compile("auto.+|abacallanar|abalançar|ablenar|aborrallonar|abotifarrar|abrinar|abromar|abstenir|acagallonar|acanyar|acarcanyar|acarnissar|acatarrar|aciutadanar|aclocar|acopar|acorriolar|adir|adonar|adormissar|afal·lerar|afarrossar|afeccionar|aferrallar|aferrissar|aferrussar|agallinar|agarbir|agarrofar|agemolir|agenollar|agotzonar|aiguabarrejar|allocar|alçurar|amatinar|amelar|amigar|amoixir|amoltonar|amotar|amullerar|amunionar|antullar|aparroquianar|aparroquiar|aperduar|apergaminar|apiadar|aponentar|apropinquar|apugonar|arguellar|arrapinyar|arrasir|arravatar|arraïmar|arrepapar|arrepenjar|arrepetellar|arrigolar|arrodir|arrogar|arrossar|arruar|assemblar|assocarrar|atendar|atenir|atorrentar|atrafegar|atrevir|avencar|avidolar|avinençar|balbar|balcar|balir|balmar|bescomptar|boirar|boixar|botinflar|bromar|cagaferrar|candir|capbaixar|capmassar|captenir|cariar|carnificar|carpir|coalitzar|colltrencar|collvinclar|compenetrar|condoldre|condolir|congraciar|contorçar|contrapuntar|contòrcer|corcorcar|coresforçar|cornuar|corruixar|crisalidar|desafeccionar|desalenar|desamorar|desaparroquiar|desapassionar|desaplegar|desavenir|desbocar|descantar|descarar|descontrolar|descovar|desdubtar|desempallegar|desenrojolar|desentossudir|desfeinar|desmemoriar|desnodrir|despondre|despreocupar|dessolidaritzar|desteixinar|desvagar|desvergonyir|desviure|dignar|embarbussar|embascar|embessonar|embordeir|embordir|emborrascar|emborrossar|embotifarrar|embotzegar|embromallar|embromar|embroquerar|emmainadar|emmalurar|emmalurir|emmarar|emmarranar|emmatar|emmigranyar|emmorronar|emmurriar|empassar|empassolar|empegueir|empenyalar|empescar|empillocar|empinyar|empiocar|empitarrar|emplomissar|emplujar|emportar|encabotar|encabritar|encalmar|encalostrar|encelar|encinglar|encirar|encistar|enclaperar|encolerir|encordar|encruar|endoblir|endur|enfarfollar|enfaristolar|enfavar|enfereir|enferotgir|enferritjar|enfugir|enfurrunyar|enfutimar|enfutismar|engelabrir|engolfar|engorgar|engripar|enguerxinar|enllagrimar|enlleganyar|enlleir|ennavegar|enneguitar|enquistar|enrinxar|enseriosir|ensobecar|entonyinar|entossudir|entotsolar|entreabaltir|entrebadar|entrebatre|entrebesar|entrecavalcar|entredevorar|entreferir|entreforcar|entrematar|entremetre|entremirar|entrenyorar|entresaludar|entreseguir|entresoldar|entretocar|entretzenar|entrigar|envidreir|envidriar|envolar|enxautar|esbafar|esbafegar|esbatussar|esblamar|esbojarrar|esborneiar|esbromar|escabridar|escamotar|escanyellar|escanyolir|escanyussar|escapolar|escapolir|escarcanyar|escarramicar|escarrassar|escarxofar|escatifenyar|esconillar|escorporar|escullar|escunçar|esfarinar|esfetgegar|esforçar|esgargamellar|esgatinyar|esgolar|esguimbar|esllanguir|esllavissar|esperitar|espitellar|espitxar|espollinar|espoltrar|esporcellar|espotonar|esprimatxar|esquifir|esquitllar|estilar|estritllar|esvedellar|esventegar|esvomegar|etiolar|extralimitar|extravasar|extravenar|gamar|gaspar|gatinyar|gaubar|gloriar|grifar|immiscir|indigestar|industriar|innivar|insolentar|insurgir|intersecar|inveterar|irèixer|jactar|juramentar|lateritzar|llufar|malfiar|malfixar|migrolar|mofar|mullerar|neulir|obstinar|octubrar|olivar|pellobrir|pellpartir|pelltrencar|penedir|penjolar|pollar|prosternar|queixar|querar|querellar|quillar|ramificar|rancurar|realegrar|rebel·lar|rebordeir|refiar|repanxolar|repapar|repetellar|reressagar|resclosir|ressagar|ressentir|revenjar|salinar|suïcidar|tinyar|tolir|transvestir|traspostar|trufar|vanagloriar|vanagloriejar|vanar|vantar|vergonyar|xautar");
+  private static final Pattern VERBS_PRONOMINALS = Pattern.compile("auto.+|fugar|abacallanar|abalançar|ablenar|aborrallonar|abotifarrar|abrinar|abromar|abstenir|acagallonar|acanyar|acarcanyar|acarnissar|acatarrar|aciutadanar|aclocar|acopar|acorriolar|adir|adonar|adormissar|afal·lerar|afarrossar|afeccionar|aferrallar|aferrissar|aferrussar|agallinar|agarbir|agarrofar|agemolir|agenollar|agotzonar|aiguabarrejar|allocar|alçurar|amatinar|amelar|amigar|amoixir|amoltonar|amotar|amullerar|amunionar|antullar|aparroquianar|aparroquiar|aperduar|apergaminar|apiadar|aponentar|apropinquar|apugonar|arguellar|arrapinyar|arrasir|arravatar|arraïmar|arrepapar|arrepenjar|arrepetellar|arrigolar|arrodir|arrogar|arrossar|arruar|assemblar|assocarrar|atendar|atenir|atorrentar|atrafegar|atrevir|avencar|avidolar|avinençar|balbar|balcar|balir|balmar|bescomptar|boirar|boixar|botinflar|bromar|cagaferrar|candir|capbaixar|capmassar|captenir|cariar|carnificar|carpir|coalitzar|colltrencar|collvinclar|compenetrar|condoldre|condolir|congraciar|contorçar|contrapuntar|contòrcer|corcorcar|coresforçar|cornuar|corruixar|crisalidar|desafeccionar|desalenar|desamorar|desaparroquiar|desapassionar|desaplegar|desavenir|desbocar|descantar|descarar|descontrolar|descovar|desdubtar|desempallegar|desenrojolar|desentossudir|desfeinar|desmemoriar|desnodrir|despondre|despreocupar|dessolidaritzar|desteixinar|desvagar|desvergonyir|desviure|dignar|embarbussar|embascar|embessonar|embordeir|embordir|emborrascar|emborrossar|embotifarrar|embotzegar|embromallar|embromar|embroquerar|emmainadar|emmalurar|emmalurir|emmarar|emmarranar|emmatar|emmigranyar|emmorronar|emmurriar|empassar|empassolar|empegueir|empenyalar|empescar|empillocar|empinyar|empiocar|empitarrar|emplomissar|emplujar|emportar|encabotar|encabritar|encalmar|encalostrar|encelar|encinglar|encirar|encistar|enclaperar|encolerir|encordar|encruar|endoblir|endur|enfarfollar|enfaristolar|enfavar|enfereir|enferotgir|enferritjar|enfugir|enfurrunyar|enfutimar|enfutismar|engelabrir|engolfar|engorgar|engripar|enguerxinar|enllagrimar|enlleganyar|enlleir|ennavegar|enneguitar|enquistar|enrinxar|enseriosir|ensobecar|entonyinar|entossudir|entotsolar|entreabaltir|entrebadar|entrebatre|entrebesar|entrecavalcar|entredevorar|entreferir|entreforcar|entrematar|entremetre|entremirar|entrenyorar|entresaludar|entreseguir|entresoldar|entretocar|entretzenar|entrigar|envidreir|envidriar|envolar|enxautar|esbafar|esbafegar|esbatussar|esblamar|esbojarrar|esborneiar|esbromar|escabridar|escamotar|escanyellar|escanyolir|escanyussar|escapolar|escapolir|escarcanyar|escarramicar|escarrassar|escarxofar|escatifenyar|esconillar|escorporar|escullar|escunçar|esfarinar|esfetgegar|esforçar|esgargamellar|esgatinyar|esgolar|esguimbar|esllanguir|esllavissar|esperitar|espitellar|espitxar|espollinar|espoltrar|esporcellar|espotonar|esprimatxar|esquifir|esquitllar|estilar|estritllar|esvedellar|esventegar|esvomegar|etiolar|extralimitar|extravasar|extravenar|gamar|gaspar|gatinyar|gaubar|gloriar|grifar|immiscir|indigestar|industriar|innivar|insolentar|insurgir|intersecar|inveterar|irèixer|jactar|juramentar|lateritzar|llufar|malfiar|malfixar|migrolar|mofar|mullerar|neulir|obstinar|octubrar|olivar|pellobrir|pellpartir|pelltrencar|penedir|penjolar|pollar|prosternar|queixar|querar|querellar|quillar|ramificar|rancurar|realegrar|rebel·lar|rebordeir|refiar|repanxolar|repapar|repetellar|reressagar|resclosir|ressagar|ressentir|revenjar|salinar|suïcidar|tinyar|tolir|transvestir|traspostar|trufar|vanagloriar|vanagloriejar|vanar|vantar|vergonyar|xautar");
   private static final Pattern NO_VERBS_PRONOMINALS = Pattern.compile("atendre|escollir|assolir|autofinançar|autografiar|automatitzar|autoritzar");
   //Eliminats: témer
   private static final Pattern VERBS_NO_PRONOMINALS = Pattern.compile("baixar|caure|callar|marxar|albergar|olorar|seure");

File: trunk/JLanguageTool/src/test/java/org/languagetool/server/HTTPServerTest.java
Patch:
@@ -63,7 +63,7 @@ void runTests() throws IOException, SAXException, ParserConfigurationException {
     final String result2 = check(Language.GERMAN, "Ein kleiner test");
     assertTrue("Got " + result2 + ", expected " + emptyResultPattern, result2.matches(emptyResultPattern));
     // one error:
-    assertTrue(check(Language.GERMAN, "ein kleiner test").contains("UPPERCASE_SENTENCE_START"));
+    assertTrue(check(Language.GERMAN, "ein kleiner test.").contains("UPPERCASE_SENTENCE_START"));
     // two errors:
     final String result = check(Language.GERMAN, "ein kleiner test. Und wieder Erwarten noch was: \u00f6\u00e4\u00fc\u00df.");
     assertTrue(result.contains("UPPERCASE_SENTENCE_START"));

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -440,7 +440,7 @@ private void testBadSentences(JLanguageTool languageTool, JLanguageTool allRules
             assertTrue(lang + ": Incorrect suggestions: "
                 + suggestedCorrections.toString() + " != "
                 + matches.get(0).getSuggestedReplacements() + " for rule " + rule + " on input: " + badSentence,
-                suggestedCorrections.toString().equals(matches.get(0).getSuggestedReplacements().toString()));
+                suggestedCorrections.equals(matches.get(0).getSuggestedReplacements()));
           }
           // make sure the suggested correction doesn't produce an error:
           if (matches.get(0).getSuggestedReplacements().size() > 0) {

File: trunk/JLanguageTool/src/test/java/org/languagetool/tokenizers/ca/CatalanSentenceTokenizerTest.java
Patch:
@@ -41,6 +41,8 @@ public final void testTokenize() {
 		testSplit(new String[] { "Desenganyeu-vos… ",
 				"L’únic problema seriós de l'home en aquest món és el de subsistir." });
 		testSplit(new String[] { "és clar… traduir és una feina endimoniada" });
+		testSplit(new String[] { "«El cordó del frare…» surt d'una manera desguitarrada" });
+		testSplit(new String[] { "convidar el seu heroi –del ram que sigui–… a prendre cafè." });	
 		
 		// Abbreviations
 		testSplit(new String[] { "Viu al núm. 24 del carrer de l'Hort." });

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -440,7 +440,7 @@ private void testBadSentences(JLanguageTool languageTool, JLanguageTool allRules
             assertTrue(lang + ": Incorrect suggestions: "
                 + suggestedCorrections.toString() + " != "
                 + matches.get(0).getSuggestedReplacements() + " for rule " + rule + " on input: " + badSentence,
-                suggestedCorrections.equals(matches.get(0).getSuggestedReplacements()));
+                suggestedCorrections.toString().equals(matches.get(0).getSuggestedReplacements().toString()));
           }
           // make sure the suggested correction doesn't produce an error:
           if (matches.get(0).getSuggestedReplacements().size() > 0) {

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/patterns/Match.java
Patch:
@@ -170,8 +170,8 @@ public final void setToken(final AnalyzedTokenReadings[] tokens, final int index
         formattedToken = null;
       }
       for (int k = index + 1; k < index + next; k++) {
-        if (k > index + 1 && 
-            tokens[k].isWhitespaceBefore()) {
+        if (tokens[k].isWhitespaceBefore()
+        		&& !(k==index+1 && includeSkipped == IncludeRange.FOLLOWING)) {
           sb.append(' ');
         }
         sb.append(tokens[k].getToken());

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/ca/AccentuationCheckRule.java
Patch:
@@ -220,9 +220,8 @@ else if ( !token.equals("pronuncia") && !token.equals("pronuncies") && !token.eq
       	}
       	//les seves contraries
       	else if (
-      	            (matchPostagRegexp(relevantWords.get(token),NOM_MS) && matchPostagRegexp(tokens[i-1],ADJECTIU_MS))
-      	            || (matchPostagRegexp(relevantWords.get(token),NOM_FS) && matchPostagRegexp(tokens[i-1],ADJECTIU_FS) 
-      	            		&& !token.equals("venia") && !token.equals("tenia") && !token.equals("continua") && !token.equals("genera") && !token.equals("faria"))
+      	            (matchPostagRegexp(relevantWords.get(token),NOM_MS) && matchPostagRegexp(tokens[i-1],ADJECTIU_MS) && !matchPostagRegexp(tokens[i],VERB_3S))
+      	            || (matchPostagRegexp(relevantWords.get(token),NOM_FS) && matchPostagRegexp(tokens[i-1],ADJECTIU_FS) && !matchPostagRegexp(tokens[i],VERB_3S))
       	            || (matchPostagRegexp(relevantWords.get(token),NOM_MP) && matchPostagRegexp(tokens[i-1],ADJECTIU_MP))
       	            || (matchPostagRegexp(relevantWords.get(token),NOM_FP) && matchPostagRegexp(tokens[i-1],ADJECTIU_FP))
       	          )

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -43,6 +43,7 @@ public void setUp() throws IOException {
   public void testRule() throws IOException {
 
     // correct sentences:
+	assertCorrect("López-Picó publica el seu llibre de poesies");
 	assertCorrect("Vaig perdut, tremolo de por.");
 	assertCorrect("l'home marra el camí");
 	assertCorrect("veié que darrere venia el deixeble");

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -507,7 +507,7 @@ && matchRegexp(tokens[i + 1].getToken(), REFLEXIU_POSPOSAT))
 								&& matchRegexp(tokens[i - j].getToken(), REFLEXIU_ANTEPOSAT))
 							return true;
 						keepCounting = matchPostagRegexp(tokens[i - j], PREP_VERB_PRONOM)
-								&& !matchPostagRegexp(tokens[i - j], VERB_PARTICIPI)
+								&& !(j>k-1 && matchPostagRegexp(tokens[i - j], VERB_PARTICIPI))
 								&& !matchPostagRegexp(tokens[i - j], TRENCA_COMPTE2);
 						if (tokens[i-j].getToken().equalsIgnoreCase("per")
 								&& tokens[i-j+1].getToken().equalsIgnoreCase("a"))

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -44,7 +44,6 @@ public void testRule() throws IOException {
 
 		// correct sentences:
 		//es van posar en camí proveïts de presents 
-		assertCorrect("a. Home indignat bonic corre");
 		assertCorrect("Bernabé i Saule, un cop acomplerta la seva missió a Jerusalem");
 		assertCorrect("he passat una nit i un dia sencers a la deriva");
 		assertCorrect("L'olor dels teus perfums, més agradable que tots els bàlsams.");

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -48,6 +48,7 @@ public void testRule() throws IOException {
 		//assertCorrect("les circumstàncies m'obliguen a gloriar-me"); Cal buscar la concordança amb (m')
 		//assertCorrect("es van agenollar i prosternar");
 		//assertCorrect("per a portar-te aigua");
+		assertCorrect("no m'he pogut endur l'espasa");
 		assertCorrect("i de venir-vos a trobar");
 		assertCorrect("el sol s'havia post, li anaven portant tots els malalts");
 		assertCorrect("que no em caigui la casa");

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/patterns/Match.java
Patch:
@@ -533,8 +533,7 @@ public final AnalyzedTokenReadings filterReadings() {
                 targetPosTag = pPosRegexMatch.matcher(targetPosTag).replaceAll(
                     posTagReplace);
               }
-              l
-                  .add(new AnalyzedToken(token, targetPosTag, formattedToken
+              l.add(new AnalyzedToken(token, targetPosTag, formattedToken
                       .getAnalyzedToken(i).getLemma()));
               l.get(l.size() - 1).setWhitespaceBefore(formattedToken.isWhitespaceBefore());
             }

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -44,6 +44,7 @@ public void testRule() throws IOException {
 
 		// correct sentences:
 		//es van posar en camí proveïts de presents 
+		assertCorrect("a. Home indignat bonic corre");
 		assertCorrect("Bernabé i Saule, un cop acomplerta la seva missió a Jerusalem");
 		assertCorrect("he passat una nit i un dia sencers a la deriva");
 		assertCorrect("L'olor dels teus perfums, més agradable que tots els bàlsams.");

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -45,6 +45,7 @@ public void testRule() throws IOException {
 		//TODO: se'n vola / s'envola
 		// correct sentences:
 		//assertCorrect("la festa de Rams es commemora anant a l'església a beneir el palmó");
+		assertCorrect("ens hem esforçat molt per venir-vos a veure");
 		assertCorrect("Un altre dia s'anava a l'Ermita i un tercer dia se solia anar a altres indrets de caràcter comarcal.");
 		assertCorrect("La Nit de sant Joan es baixaven falles de la muntanya."); //solucions: marcar "la nit..." com a CC o comprovar la concordança subj/verb
 		assertCorrect("que no pertanyen a ells mateixos es cau en una contradicció.");

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -43,6 +43,7 @@ public void setUp() throws IOException {
 	public void testRule() throws IOException { 
 
 		// correct sentences:
+		assertCorrect("La part superior esquerra");
 		assertCorrect("I sí, la crisi serà llarga, molt llarga, potser eterna.");
 		assertCorrect("El rei ha trobat l'excusa i l'explicació adequada.");
 		assertCorrect("té una manera de jugar aquestes gires tan femenina");

File: trunk/JLanguageTool/src/test/java/org/languagetool/tagging/disambiguation/rules/fr/FrenchRuleDisambiguatorTest.java
Patch:
@@ -91,7 +91,7 @@ public void testAnnotations() throws IOException {
      assertEquals(sent.getAnnotations(), "Disambiguator log: \n\n" +
      		"RP-D_N_AMBIG: Les[le/D e p,les/R pers obj 3 p] -> Les[le/D e p]"+
              "\nRB-LE_LA_LES: Les[le/D e p] -> Les[le/D e p]" +
-     		"\n\nRP-D_N_AMBIG: avions[avoir/V avoir ind impa 1 p,avion/N m p,avoir/SENT_END] -> avions[avion/N m p,avion/SENT_END]\n");
+     		"\n\nRP-D_N_AMBIG: avions[avoir/V avoir ind impa 1 p,avion/N m p,avoir/SENT_END] -> avions[avion/N m p,avoir/SENT_END]\n");
   }
   
 }

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/GenericUnpairedBracketsRule.java
Patch:
@@ -106,7 +106,6 @@ public void uniqueMapInit() {
    * @param i Current token index
    * @param precSpace is preceded with space
    * @param follSpace is followed with space
-   * @return
    */
   protected boolean isNoException(final String token,
       final AnalyzedTokenReadings[] tokens, final int i, final int j,

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/pt/PortugueseRule.java
Patch:
@@ -22,8 +22,6 @@
 
 /**
  * Abstract base class for rules for the Portuguese language.
- * 
- * @author 
  */
 public abstract class PortugueseRule extends Rule {
 

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -492,6 +492,8 @@ private void potentiallyAddUppercaseMatch(List<RuleMatch> ruleMatches, AnalyzedT
         !analyzedToken.hasReadingOfType(POSType.PROPER_NOUN) &&
         !isNilReading(analyzedToken) &&
         !analyzedToken.isSentenceEnd() &&
+        !( (tokens[i-1].getToken().equals("]") || tokens[i-1].getToken().equals(")")) &&
+           ( (i == 4 && tokens[i-2].getToken().equals("…")) || (i == 6 && tokens[i-2].getToken().equals(".")) ) ) &&
         !isExceptionPhrase(i, tokens)) {
       final String msg = "Außer am Satzanfang werden nur Nomen und Eigennamen großgeschrieben";
       final RuleMatch ruleMatch = new RuleMatch(this, tokens[i].getStartPos(),

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -43,13 +43,13 @@ public void setUp() throws IOException {
 	public void testRule() throws IOException { 
 
 		// correct sentences:
-		//assertCorrect("I sí, la crisi serà llarga, molt llarga, potser eterna.");
+		assertCorrect("I sí, la crisi serà llarga, molt llarga, potser eterna.");
+		assertCorrect("El rei ha trobat l'excusa i l'explicació adequada.");
 		assertCorrect("té una manera de jugar aquestes gires tan femenina");
 		assertCorrect("des de la tradicional divisió en dos regnes establida per Linnaeus");
 		assertCorrect("aquestes activitats avui residuals donada ja la manca de territori");
 		assertCorrect("instruments de càlcul basats en boles anomenats yupana.");
 		assertCorrect("El rei ha trobat l'excusa i l'explicació adequades.");
-		assertCorrect("El rei ha trobat l'excusa i l'explicació adequada.");
 		assertCorrect("Copa del món femenina.");   
 		assertCorrect("Batalla entre asteques i espanyols coneguda com la Nit Trista.");
 		assertCorrect("És un informe sobre la cultura japonesa realitzat per encàrrec de l'exèrcit d'Estats Units.");

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/ro/CompoundRule.java
Patch:
@@ -38,8 +38,6 @@ public CompoundRule(final ResourceBundle messages) throws IOException {
             "Cuvântul se scrie legat.",
             "Cuvântul se scrie legat sau cu cratimă.");
     super.setShort("Problemă de scriere (cratimă, spațiu, etc.)");
-    // default value (2) is not ok for Romanian
-    setMaxUnHyphenatedWordCount(Integer.MAX_VALUE);
     // there are words that should not be written with hyphen but as one word
     setHyphenIgnored(false);
   }

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/de/CompoundRuleTest.java
Patch:
@@ -67,7 +67,7 @@ public void testRule() throws IOException {
     check(2, "Der dumme System Administrator legt die CD ROM ein blah");
     check(2, "System Administrator CD ROM");
     check(2, "Hals Wirbel Säule");
-    // TODO: check(1, "Und herum zu knobeln können.", new String[]{"herumzuknobeln"});
+    check(1, "Und herum zu knobeln können.", new String[]{"herumzuknobeln"});
     //FIXME: suggestions / longest match
     //check(1, "Roll on roll off Schiff", new String[]{"Roll-on-roll-off-Schiff"});
     check(1, "Spin off");

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -372,6 +372,8 @@ public class CaseRule extends GermanRule {
     substVerbenExceptions.add("so");
     substVerbenExceptions.add("ist");
     substVerbenExceptions.add("können");
+    substVerbenExceptions.add("mein"); // "etwas, das mein Interesse geweckt hat"
+    substVerbenExceptions.add("sein");
     substVerbenExceptions.add("muss");
     substVerbenExceptions.add("muß");
     substVerbenExceptions.add("wollen");
@@ -470,7 +472,7 @@ private void potentiallyAddLowercaseMatch(List<RuleMatch> ruleMatches, AnalyzedT
     if (prevTokenIsDas && !nextTokenIsPersonalPronoun) {
       // e.g. essen -> Essen
       if (Character.isLowerCase(token.charAt(0)) && !substVerbenExceptions.contains(token)) {
-        final String msg = "Substantivierte Verben werden groß geschrieben.";
+        final String msg = "Substantivierte Verben werden großgeschrieben.";
         final RuleMatch ruleMatch = new RuleMatch(this, tokenReadings.getStartPos(),
             tokenReadings.getStartPos() + token.length(), msg);
         final String word = tokenReadings.getToken();

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -84,6 +84,7 @@ public void testRule() throws IOException {
 		assertCorrect("una organització paramilitar de protecció civil típicament catalana");
 		assertCorrect("un Do dues octaves més alt que l'anterior");
 		assertCorrect("són pràcticament dos graus més baixes");
+		assertCorrect("és unes vint vegades més gran que l'espermatozou.");
 		assertCorrect("és unes 20 vegades més gran que l'espermatozou.");
 		assertCorrect("eren quatre vegades més alts");
 		assertCorrect("eren uns fets cada volta més inexplicables");

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/ca/MorfologikCatalanSpellerRuleTest.java
Patch:
@@ -52,7 +52,9 @@ public void testMorfologikSpeller() throws IOException {
         assertEquals(0, rule.match(langTool.getAnalyzedSentence(",")).length);
         // Spellcheck dictionary contains Valencian and general accentuation
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("Francès i francés.")).length);
-        
+        // checks abbreviations 
+        assertEquals(0, rule.match(langTool.getAnalyzedSentence("Viu al núm. 23 del carrer Nou.")).length);
+        assertEquals(0, rule.match(langTool.getAnalyzedSentence("N'hi ha de color vermell, blau, verd, etc.")).length);
         
         //test for "LanguageTool":
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("LanguageTool!")).length);

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/patterns/PatternRuleMatcher.java
Patch:
@@ -155,8 +155,9 @@ private RuleMatch createRuleMatch(final int[] tokenPositions,
 
         //now do some spell-checking:
         if (!(errMessage.contains("<pleasespellme/>") && errMessage.contains("<mistake/>"))) {
+          final String clearMsg = errMessage.replaceAll("<pleasespellme/>", "").replaceAll("<mistake/>", "");
           return new RuleMatch(rule, fromPos, toPos,
-                  errMessage, rule.getShortMessage(), startsWithUppercase);
+                  clearMsg, rule.getShortMessage(), startsWithUppercase);
         }
       } // failed to create any rule match...
       return null;

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/de/GermanWrongWordInContextRuleTest.java
Patch:
@@ -86,7 +86,10 @@ public void testRule() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Eine Gitarre hat Saiten, aber keine Seiten.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Die Saiten des Violoncellos sind kurz.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Dieses Buch über die Gitarre hat nur sechs Seiten.")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("Eine Seite und eine scharfe Suppe.")).length);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Die Saiten des Buches sind beschrieben.")).length);
+    assertEquals(1, rule.match(langTool.getAnalyzedSentence("Die Seiten des Klaviers werden angeschlagen.")).length);
+    assertEquals(1, rule.match(langTool.getAnalyzedSentence("Die Seiten der Kurzhalsgeige sind gerissen.")).length);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Die Seiten des Kontrabasses sind gerissen.")).length);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Bei der UNO müssen andere Seiten aufgezogen werden.")).length);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Die Seiten des Violoncellos sind kurz.")).length);

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -139,6 +139,9 @@ public void testDetNounRule() throws IOException {
     assertBad("Das Dach meinem großen Autos.");
     assertBad("Das Dach mein großen Autos.");
 
+    assertBad("Das Klientel der Partei.");  // gender used to be wrong in Morphy data
+    assertGood("Die Klientel der Partei.");
+
     // TODO: not yet detected:
     //assertBad("Erst recht wir fleißiges Arbeiter.");
     //assertBad("Erst recht ich fleißiges Arbeiter.");

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRule.java
Patch:
@@ -76,8 +76,8 @@ public class ComplexAdjectiveConcordanceRule extends CatalanRule {
 	private static final Pattern ADJECTIU_FP = Pattern.compile("A..[FC][PN].*|V.P..PF|PX.FP.*");
 	private static final Pattern ADJECTIU_CP = Pattern.compile("A..C[PN].*");
 	private static final Pattern ADJECTIU_CS = Pattern.compile("A..C[SN].*");
-	private static final Pattern ADJECTIU_M = Pattern.compile("A..[MC].*|V.P...M|PX.M.*");
-	private static final Pattern ADJECTIU_F = Pattern.compile("A..[FC].*|V.P...F|PX.F.*");
+	//private static final Pattern ADJECTIU_M = Pattern.compile("A..[MC].*|V.P...M|PX.M.*");
+	//private static final Pattern ADJECTIU_F = Pattern.compile("A..[FC].*|V.P...F|PX.F.*");
 	private static final Pattern ADJECTIU_S = Pattern.compile("A...[SN].*|V.P..S.|PX..S.*");
 	private static final Pattern ADJECTIU_P = Pattern.compile("A...[PN].*|V.P..P.|PX..P.*");
 	private static final Pattern ADVERBI = Pattern.compile("R.|.*LOC_ADV.*");
@@ -87,7 +87,7 @@ public class ComplexAdjectiveConcordanceRule extends CatalanRule {
 	private static final Pattern UPPERCASE = Pattern.compile("\\p{Lu}[\\p{Ll}\u00B7]*");
 	private static final Pattern COORDINACIO = Pattern.compile(",|i|o");
 	private static final Pattern COORDINACIO_IONI = Pattern.compile("i|o|ni");
-	private static final Pattern KEEP_COUNT = Pattern.compile("A.*|N.*|D[NAID].*|SPS.*|.*LOC_ADV.*|V.P.*|_PUNCT.*|.*LOC_ADJ.*");
+	private static final Pattern KEEP_COUNT = Pattern.compile("A.*|N.*|D[NAID].*|SPS.*|.*LOC_ADV.*|V.P.*|_PUNCT.*|.*LOC_ADJ.*|complement");
 	private static final Pattern KEEP_COUNT2 = Pattern.compile(",|i|o|ni|\\d+%?|%");
 	private static final Pattern STOP_COUNT = Pattern.compile(";");
 	private static final Pattern PREPOSICIONS = Pattern.compile("SPS.*");

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -43,6 +43,7 @@ public void setUp() throws IOException {
 	public void testRule() throws IOException { 
 
 		// correct sentences:
+		assertCorrect("té una manera de jugar aquestes gires tan femenina");
 		assertCorrect("des de la tradicional divisió en dos regnes establida per Linnaeus");
 		assertCorrect("aquestes activitats avui residuals donada ja la manca de territori");
 		assertCorrect("instruments de càlcul basats en boles anomenats yupana.");

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/UppercaseSentenceStartRule.java
Patch:
@@ -108,7 +108,7 @@ public final RuleMatch[] match(final AnalyzedSentence text) {
 
     //fix for words in table (not sentences); note - this will not always work for the last point in OOo,
     //as OOo might serve paragraphs in any order.
-    if ((language == Language.RUSSIAN )
+    if ((language == Language.RUSSIAN || language == Language.ENGLISH )
         && !(lastToken.matches("[.?!…;,]"))) {
       noException = true;
     }

File: trunk/JLanguageTool/src/test/java/org/languagetool/MainTest.java
Patch:
@@ -203,7 +203,7 @@ public void testEnglishLineMode() throws Exception {
 
     Main.main(args);
     String output = new String(this.out.toByteArray());
-    assertEquals("This is what I mean\nAnd you know it.\n", output);
+    assertEquals("This is what I mean\nand you know it.\n", output);
   }
 
   //first line mode

File: trunk/JLanguageTool/src/test/java/org/languagetool/server/HTTPSServerTest.java
Patch:
@@ -63,7 +63,7 @@ private void runTests() throws IOException {
 
     final String httpsPrefix = "https://localhost:" + HTTPServerConfig.DEFAULT_PORT + "/";
 
-    final String result = HTTPTools.checkAtUrl(new URL(httpsPrefix + "?text=a+test&language=en"));
+    final String result = HTTPTools.checkAtUrl(new URL(httpsPrefix + "?text=a+test.&language=en"));
     assertTrue("Got " + result, result.contains("UPPERCASE_SENTENCE_START"));
 
     final StringBuilder longText = new StringBuilder();

File: trunk/JLanguageTool/src/test/java/org/languagetool/tokenizers/de/GermanSRXSentenceTokenizerTest.java
Patch:
@@ -43,6 +43,7 @@ public void testTokenize() {
     testSplit("Das Schreiben ist auf den 31.1. datiert.");
     testSplit("Das Schreiben ist auf den 3.10.2000 datiert.");
     testSplit("Natürliche Vererbungsprozesse prägten sich erst im 18. und frühen 19. Jahrhundert aus.");
+    testSplit("Das ist ja 1a. ", "Und das auch.");
 
     testSplit("Friedrich I., auch bekannt als Friedrich der Große.");
     testSplit("Friedrich II., auch bekannt als Friedrich der Große.");

File: trunk/JLanguageTool/src/main/java/org/languagetool/tagging/eo/EsperantoTagger.java
Patch:
@@ -251,7 +251,7 @@ public List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens) throws
           } else if (lWord.endsWith("ojn")) {
             l.add(new AnalyzedToken(word, "O akz pl", lWord.substring(0, lWord.length() - 2)));
 
-          // Words ending in .*aj?n? are nouns.
+          // Words ending in .*aj?n? are adjectives.
           } else if (lWord.endsWith("a")) {
             l.add(new AnalyzedToken(word, "A nak np", lWord));
           } else if (lWord.endsWith("aj")) {

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/AbstractCompoundRule.java
Patch:
@@ -76,6 +76,7 @@ public AbstractCompoundRule(final ResourceBundle messages, final String fileName
     this.withHyphenMessage = withHyphenMessage;
     this.withoutHyphenMessage = withoutHyphenMessage;
     this.withOrWithoutHyphenMessage = withOrWithoutHyphenMessage;
+    setLocQualityIssueType("misspelling");
   }
 
   @Override

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/CommaWhitespaceRule.java
Patch:
@@ -37,6 +37,7 @@ public class CommaWhitespaceRule extends Rule {
   public CommaWhitespaceRule(final ResourceBundle messages) {
     super(messages);
     super.setCategory(new Category(messages.getString("category_misc")));
+    setLocQualityIssueType("typographical");
   }
 
   @Override

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/DoublePunctuationRule.java
Patch:
@@ -35,6 +35,7 @@ public class DoublePunctuationRule extends Rule {
   public DoublePunctuationRule(final ResourceBundle messages) {
     super(messages);
     super.setCategory(new Category(messages.getString("category_misc")));
+    setLocQualityIssueType("typographical");
   }
 
   @Override

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/GenericUnpairedBracketsRule.java
Patch:
@@ -71,6 +71,7 @@ public GenericUnpairedBracketsRule(final ResourceBundle messages,
     endSymbols = language.getUnpairedRuleEndSymbols();
     numerals = NUMERALS_EN;
     uniqueMapInit();
+    setLocQualityIssueType("typographical");
   }
 
   

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/UppercaseSentenceStartRule.java
Patch:
@@ -42,6 +42,7 @@ public UppercaseSentenceStartRule(final ResourceBundle messages,
     super(messages);
     super.setCategory(new Category(messages.getString("category_case")));
     this.language = language;
+    setLocQualityIssueType("typographical");
   }
 
   @Override

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/WhitespaceRule.java
Patch:
@@ -39,6 +39,7 @@ public class WhitespaceRule extends Rule {
   public WhitespaceRule(final ResourceBundle messages, final Language language) {
     super(messages);
     super.setCategory(new Category(messages.getString("category_misc")));
+    setLocQualityIssueType("typographical");
   }
 
   @Override

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/WordRepeatBeginningRule.java
Patch:
@@ -40,6 +40,7 @@ public class WordRepeatBeginningRule extends Rule {
   public WordRepeatBeginningRule(final ResourceBundle messages, final Language language) {
     super(messages);
     super.setCategory(new Category(messages.getString("category_misc")));
+    setLocQualityIssueType("style");
   }
 
   @Override

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/WordRepeatRule.java
Patch:
@@ -36,6 +36,7 @@ public class WordRepeatRule extends Rule {
   public WordRepeatRule(final ResourceBundle messages, final Language language) {
     super(messages);
     super.setCategory(new Category(messages.getString("category_misc")));
+    setLocQualityIssueType("addition");
   }
 
   /**

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/WrongWordInContextRule.java
Patch:
@@ -48,6 +48,7 @@ public WrongWordInContextRule(final ResourceBundle messages) throws IOException
     }
     final String filename = getFilename();
     contextWordsSet = loadContextWords(JLanguageTool.getDataBroker().getFromRulesDirAsStream(filename));
+    setLocQualityIssueType("terminology");
   }
 
   protected abstract String getFilename();

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/en/AvsAnRule.java
Patch:
@@ -58,6 +58,7 @@ public AvsAnRule(final ResourceBundle messages) throws IOException {
     }
     requiresA = loadWords(JLanguageTool.getDataBroker().getFromRulesDirAsStream(FILENAME_A));
     requiresAn = loadWords(JLanguageTool.getDataBroker().getFromRulesDirAsStream(FILENAME_AN));
+    setLocQualityIssueType("terminology");
   }
   
   @Override

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/en/BritishReplaceRule.java
Patch:
@@ -45,6 +45,7 @@ public final String getFileName() {
 
   public BritishReplaceRule(final ResourceBundle messages) throws IOException {
     super(messages);
+    setLocQualityIssueType("terminology");
   }
 
   @Override

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -45,6 +45,7 @@ public abstract class SpellingCheckRule extends Rule {
   public SpellingCheckRule(final ResourceBundle messages, final Language language) {
     super(messages);
     this.language = language;
+    setLocQualityIssueType("misspelling");
   }
 
   @Override

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/de/GermanWordRepeatRule.java
Patch:
@@ -50,7 +50,7 @@ public boolean ignore(final AnalyzedTokenReadings[] tokens, final int position)
       if (position >= 2 && ",".equals(tokens[position - 2].getToken())) {
         return true;
       }
-      if (position >= 3 && ",".equals(tokens[position - 3].getToken()) &&  tokens[position - 2].getToken().matches("ab|an|auf|bei|für|in|mit|nach|über|zu")) {
+      if (position >= 3 && ",".equals(tokens[position - 3].getToken()) &&  tokens[position - 2].getToken().matches("ab|an|auf|bei|für|in|mit|nach|ohne|über|zu")) {
         return true;
       }
       return false;

File: trunk/JLanguageTool/src/main/java/org/languagetool/gui/Main.java
Patch:
@@ -371,11 +371,12 @@ void quit() {
 
   private void maybeStartServer() {
     if (config.getRunServer()) {
-      httpServer = new HTTPServer(new HTTPServerConfig(config.getServerPort(), false), true);
       try {
+        final HTTPServerConfig serverConfig = new HTTPServerConfig(config.getServerPort(), false);
+        httpServer = new HTTPServer(serverConfig, true);
     	  httpServer.run();
       } catch (PortBindingException e) {
-        final String message = e.getMessage() + "\n\n" + org.languagetool.tools.Tools.getFullStackTrace(e);
+        final String message = e.getMessage();
         JOptionPane.showMessageDialog(null, message, "Error", JOptionPane.ERROR_MESSAGE);
       }
     }

File: trunk/JLanguageTool/src/main/java/org/languagetool/gui/Tools.java
Patch:
@@ -43,7 +43,7 @@ private Tools() {
   }
 
   public static String makeTexti18n(final ResourceBundle messages, final String key,
-      final Object[] messageArguments) {
+                                    final Object... messageArguments) {
     final MessageFormat formatter = new MessageFormat("");
     formatter.applyPattern(messages.getString(key).replaceAll("'", "''"));
     return formatter.format(messageArguments);

File: trunk/JLanguageTool/src/main/java/org/languagetool/gui/Configuration.java
Patch:
@@ -33,7 +33,7 @@
 import java.util.Set;
 
 import org.languagetool.Language;
-import org.languagetool.server.HTTPServer;
+import org.languagetool.server.HTTPServerConfig;
 import org.languagetool.tools.StringTools;
 
 /**
@@ -65,7 +65,7 @@ public class Configuration {
   private boolean runServer;
   private boolean autoDetect;
   private boolean guiConfig;
-  private int serverPort = HTTPServer.DEFAULT_PORT;
+  private int serverPort = HTTPServerConfig.DEFAULT_PORT;
 
   /**
    * Uses the configuration file from the default location.

File: trunk/JLanguageTool/src/main/java/org/languagetool/gui/ConfigurationDialog.java
Patch:
@@ -52,7 +52,7 @@
 import org.languagetool.JLanguageTool;
 import org.languagetool.Language;
 import org.languagetool.rules.Rule;
-import org.languagetool.server.HTTPServer;
+import org.languagetool.server.HTTPServerConfig;
 import org.languagetool.tools.StringTools;
 
 /**
@@ -504,7 +504,7 @@ public void setServerPort(int serverPort) {
 
   public int getServerPort() {
     if (serverPortField == null) {
-      return HTTPServer.DEFAULT_PORT;
+      return HTTPServerConfig.DEFAULT_PORT;
     }
     return Integer.parseInt(serverPortField.getText());
   }

File: trunk/JLanguageTool/src/main/java/org/languagetool/gui/Main.java
Patch:
@@ -25,6 +25,7 @@
 import org.languagetool.rules.Rule;
 import org.languagetool.rules.RuleMatch;
 import org.languagetool.server.HTTPServer;
+import org.languagetool.server.HTTPServerConfig;
 import org.languagetool.server.PortBindingException;
 import org.languagetool.tools.LanguageIdentifierTools;
 import org.languagetool.tools.StringTools;
@@ -370,7 +371,7 @@ void quit() {
 
   private void maybeStartServer() {
     if (config.getRunServer()) {
-      httpServer = new HTTPServer(config.getServerPort(), false, true);
+      httpServer = new HTTPServer(new HTTPServerConfig(config.getServerPort(), false), true);
       try {
     	  httpServer.run();
       } catch (PortBindingException e) {

File: trunk/JLanguageTool/src/main/java/org/languagetool/language/Khmer.java
Patch:
@@ -61,7 +61,7 @@ public String getShortName() {
 
   @Override
   public String[] getCountryVariants() {
-    return new String[]{"KM"};
+    return new String[]{"KH"};
   }
   
   @Override

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/de/VerbAgreementRule.java
Patch:
@@ -270,7 +270,7 @@ private RuleMatch ruleMatchWrongVerb(final AnalyzedTokenReadings token) {
   private RuleMatch ruleMatchWrongVerbSubject(final AnalyzedTokenReadings subject, final AnalyzedTokenReadings verb) {
     final String msg = "Möglicherweise fehlende grammatische Übereinstimmung zwischen Subjekt (" + subject.getToken() +
       ") und Prädikat (" + verb.getToken() + ") bezüglich Person oder Numerus (Einzahl, Mehrzahl - Beispiel: " +
-      "'ich sind' statt 'ich bist').";
+      "'ich sind' statt 'ich bin').";
     if (subject.getStartPos() < verb.getStartPos()) {
       return new RuleMatch(this, subject.getStartPos(), verb.getStartPos() + verb.getToken().length(), msg);
     } else {

File: trunk/JLanguageTool/src/main/java/org/languagetool/gui/Main.java
Patch:
@@ -57,6 +57,7 @@ public final class Main implements ActionListener {
   static final String HTML_GREY_FONT_START = "<font face='Arial,Helvetica' color='#666666'>";
 
   private static final String SYSTEM_TRAY_ICON_NAME = "/TrayIcon.png";
+  private static final String SYSTEM_TRAY_SMALL_ICON_NAME = "/TrayIconSmall.png";
   private static final String SYSTEM_TRAY_TOOLTIP = "LanguageTool";
   private static final String CONFIG_FILE = ".languagetool.cfg";
   private static final int WINDOW_WIDTH = 600;
@@ -227,7 +228,7 @@ void hideToTray() {
     if (!isInTray) {
       final SystemTray tray = SystemTray.getSystemTray();
       final Image img = Toolkit.getDefaultToolkit().getImage(
-              JLanguageTool.getDataBroker().getFromResourceDirAsUrl(SYSTEM_TRAY_ICON_NAME));
+              JLanguageTool.getDataBroker().getFromResourceDirAsUrl((tray.getTrayIconSize().height > 16 ) ?  SYSTEM_TRAY_ICON_NAME : SYSTEM_TRAY_SMALL_ICON_NAME));
       final PopupMenu popup = makePopupMenu();
       try {
         final TrayIcon trayIcon = new TrayIcon(img, SYSTEM_TRAY_TOOLTIP, popup);

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -63,7 +63,7 @@ public void testRule() throws IOException {
 		assertCorrect("Es fa segons regles de lectura constants i regulars.");
 		assertCorrect("Les meitats dreta i esquerra de la mandíbula.");
 		assertCorrect("Els períodes clàssic i medieval.");
-		assertCorrect("Els costats superior i laterals.");
+		//assertCorrect("Els costats superior i laterals.");
 		assertCorrect("En una molècula de glucosa i una de fructosa unides.");
 		// Should be Incorrect, but it is impossible to detect
 		assertCorrect("Índex de desenvolupament humà i qualitat de vida elevat"); 
@@ -102,6 +102,7 @@ public void testRule() throws IOException {
 		assertCorrect("sota les grans persianes de color verd recalcades");
 		
 		// errors:
+		assertIncorrect("pantalons curt o llargs");
 		assertIncorrect("sota les grans persianes de color verd recalcada");
 		assertIncorrect("sota les grans persianes de color verd recalcat");
 		assertIncorrect("sota les grans persianes de color verd recalcats");

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -125,7 +125,7 @@ public String getId() {
 
   @Override
   public String getDescription() {
-    return "Verbs reflexisu: comprova que porten el pronom adequat.";
+    return "Verbs reflexius: comproveu que porten el pronom adequat.";
   }
 
 	@Override

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -43,6 +43,7 @@ public void setUp() throws IOException {
   public void testRule() throws IOException {
 
     // correct sentences:
+	assertCorrect("els següents territoris externs habitats:");
 	assertCorrect("Cap faria una cosa així.");
 	assertCorrect("El cos genera suficient pressió interna.");
 	assertCorrect("Les seues contràries.");
@@ -82,7 +83,7 @@ public void testRule() throws IOException {
     assertIncorrect("De manera obvia.");
     assertIncorrect("Ell fa tasques especifiques.");
     assertIncorrect("Un home adulter.");
-    assertIncorrect("Va deixar els nens atonits.");
+   // assertIncorrect("Va deixar els nens atonits."); del v. "atonir" (=esbalair)
     assertIncorrect("La sureda ocupa amplies extensions en la muntanya.");
     assertIncorrect("Féu una magnifica digitació.");
     assertIncorrect("Els habitats de la comarca.");

File: trunk/JLanguageTool/src/main/dev/org/languagetool/dev/wikipedia/BaseWikipediaDumpHandler.java
Patch:
@@ -108,9 +108,7 @@ public void endElement(String namespaceURI, String sName, String qName) {
         try {
           articleCount++;
           if (maxArticles > 0 && articleCount > maxArticles) {
-            System.out.printf("Maximum number of articles reached. Found %d matches in %d articles\n",
-                ruleMatchCount, articleCount);
-            System.exit(0);
+            throw new ArticleLimitReachedException(maxArticles);
           }
           final List<RuleMatch> ruleMatches = languageTool.check(textToCheck);
           System.out.println("Checking article " + articleCount + " (" +

File: trunk/JLanguageTool/src/main/dev/org/languagetool/dev/wikipedia/CheckWikipediaDump.java
Patch:
@@ -132,6 +132,8 @@ private void run(File propFile, Set<String> disabledRules, String langCode, Stri
       saxParser.parse(file, xmlHandler);
     } catch (ErrorLimitReachedException e) {
       System.out.println(e);
+    } catch (ArticleLimitReachedException e) {
+      System.out.println(e);
     } finally {
       if (xmlHandler != null) { xmlHandler.close(); }
       final float matchesPerDoc = (float)xmlHandler.getRuleMatchCount() / xmlHandler.getArticleCount();

File: trunk/JLanguageTool/src/main/dev/org/languagetool/dev/wikipedia/CheckWikipediaDump.java
Patch:
@@ -134,9 +134,9 @@ private void run(File propFile, Set<String> disabledRules, String langCode, Stri
       System.out.println(e);
     } finally {
       if (xmlHandler != null) { xmlHandler.close(); }
+      final float matchesPerDoc = (float)xmlHandler.getRuleMatchCount() / xmlHandler.getArticleCount();
+      System.out.printf(lang + ": ø%.2f rule matches per document\n", matchesPerDoc);
     }
-    final float matchesPerDoc = (float)xmlHandler.getRuleMatchCount() / xmlHandler.getArticleCount();
-    System.out.printf(lang + ": ø%.2f rule matches per document", matchesPerDoc);
   }
 
   private void enableSpecifiedRules(String[] ruleIds, JLanguageTool languageTool) {

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -103,7 +103,7 @@ public class ReflexiveVerbsRule extends CatalanRule {
   //private static final Pattern REFLEXIU_ANTEPOSAT = Pattern.compile("e[mts]|[mts]e|ens|us|-[mts]|-[mts]e|'[mts]|[mts]'|-nos|'ns|-vos|-us",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   
   private static final Pattern SUBJECTE_PERSONAL_POSTAG = Pattern.compile("NC.*|NP.*|_GN_.*|PI.*");
-  private static final Pattern SUBJECTE_PERSONAL_NO_POSTAG = Pattern.compile("complement.*|D.*|A.*");
+  private static final Pattern SUBJECTE_PERSONAL_NO_POSTAG = Pattern.compile("complement.*|D.*|A.*|PX.*");
   private static final Pattern SUBJECTE_PERSONAL_TOKEN = Pattern.compile("jo|mi|tu|ella?|nosaltres|vosaltres|elle?s|vost[èé]s?|vós",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   private static final Pattern TRENCA_COMPTE = Pattern.compile("PR.*|CS|CC|PUNCT.*|.*LOC_CONJ.*");
   private static final Pattern TRENCA_COMPTE2 = Pattern.compile("SENT_START|CC|PUNCT.*|.*LOC_CONJ.*");

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -138,8 +138,8 @@ public void testRule() throws IOException {
 		assertCorrect("A escola no s'hi va a plorar.");
 		assertCorrect("A escola no es va a jugar.");
 		assertCorrect("A escola no es va a plorar.");
+		assertCorrect("Al nostre pis de la Torre es pujava per aquella llarga escala");
 		assertCorrect("Joan no es va a jugar la feina.");	
-		
 		 	
 		// errors:
 		assertIncorrect("un dels pocs moviments que poden fer és intentar pujar-se al carro de la indignació.");

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRule.java
Patch:
@@ -69,7 +69,7 @@ public class ComplexAdjectiveConcordanceRule extends CatalanRule {
 	private static final Pattern GN_CP = Pattern.compile("N.[FMC][PN].*|D[NDA0I]0[FM]P0");
 	private static final Pattern GN_CS = Pattern.compile("N.[FMC][SN].*|D[NDA0I]0[FM]S0");
 
-	private static final Pattern ADJECTIU = Pattern.compile("AQ.*|V.P.*|PX.*");
+	private static final Pattern ADJECTIU = Pattern.compile("AQ.*|V.P.*|PX.*|.*LOC_ADJ.*");
 	private static final Pattern ADJECTIU_MS = Pattern.compile("A..[MC][SN].*|V.P..SM|PX.MS.*");
 	private static final Pattern ADJECTIU_FS = Pattern.compile("A..[FC][SN].*|V.P..SF|PX.FS.*");
 	private static final Pattern ADJECTIU_MP = Pattern.compile("A..[MC][PN].*|V.P..PM|PX.MP.*");
@@ -87,7 +87,7 @@ public class ComplexAdjectiveConcordanceRule extends CatalanRule {
 	private static final Pattern UPPERCASE = Pattern.compile("\\p{Lu}[\\p{Ll}\u00B7]*");
 	private static final Pattern COORDINACIO = Pattern.compile(",|i|o");
 	private static final Pattern COORDINACIO_IONI = Pattern.compile("i|o|ni");
-	private static final Pattern KEEP_COUNT = Pattern.compile("A.*|N.*|D[NAID].*|SPS.*|.*LOC_ADV.*|V.P.*|PUNCT.*");
+	private static final Pattern KEEP_COUNT = Pattern.compile("A.*|N.*|D[NAID].*|SPS.*|.*LOC_ADV.*|V.P.*|PUNCT.*|.*LOC_ADJ.*");
 	private static final Pattern KEEP_COUNT2 = Pattern.compile(",|i|o|ni|\\d+%?|%");
 	private static final Pattern STOP_COUNT = Pattern.compile(";");
 	private static final Pattern PREPOSICIONS = Pattern.compile("SPS.*");

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/ca/AccentuationCheckRuleTest.java
Patch:
@@ -70,6 +70,7 @@ public void testRule() throws IOException {
     assertCorrect("La magnífica conservació del palau.");
 
     // errors:
+    assertIncorrect("Vaig arribar a fer una radio que no va funcionar mai.");
     assertIncorrect("No em fumaré cap faria com feia abans.");
     assertIncorrect("M'he fumat una faria.");
     assertIncorrect("Les seues contraries.");

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRule.java
Patch:
@@ -335,7 +335,7 @@ else if (!matchPostagRegexp(tokens[i-j], _GN_) && matchPostagRegexp(tokens[i-j],
 				}
 				if (theRuleMaches) {
 					final String msg = "Reviseu la concordança de l'adjectiu \u00AB"+token+"\u00BB.";
-					final RuleMatch ruleMatch = new RuleMatch(this, tokens[i].getStartPos(), tokens[i].getStartPos()+token.length(), msg, "Falta de concordança.");
+					final RuleMatch ruleMatch = new RuleMatch(this, tokens[i].getStartPos(), tokens[i].getStartPos()+token.length(), msg, "Reviseu la concordança.");
 					ruleMatches.add(ruleMatch);
 				}
 			}

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -45,6 +45,7 @@ public class ReflexiveVerbsRule extends CatalanRule {
   private static final Pattern VERBS_PRONOMINALS = Pattern.compile("abacallanar|abalançar|ablenar|aborrallonar|abotifarrar|abrinar|abromar|abstenir|acagallonar|acanyar|acarcanyar|acarnissar|acatarrar|aciutadanar|aclocar|acopar|acorriolar|adir|adonar|adormissar|afal·lerar|afarrossar|afeccionar|aferrallar|aferrissar|aferrussar|agallinar|agarbir|agarrofar|agemolir|agenollar|agotzonar|aiguabarrejar|allocar|alçurar|amatinar|amelar|amigar|amoixir|amoltonar|amotar|amullerar|amunionar|antullar|aparroquianar|aparroquiar|aperduar|apergaminar|apiadar|aponentar|apropinquar|apugonar|arguellar|arrapinyar|arrasir|arravatar|arraïmar|arrepapar|arrepetellar|arrigolar|arrodir|arrogar|arrossar|arruar|assemblar|assocarrar|atendar|atenir|atorrentar|atrafegar|atrevir|avencar|avidolar|avinençar|balbar|balcar|balir|balmar|bescomptar|boirar|boixar|botinflar|bromar|cagaferrar|candir|capbaixar|capmassar|captenir|cariar|carnificar|carpir|coalitzar|colltrencar|collvinclar|compenetrar|condoldre|condolir|congraciar|contorçar|contrapuntar|contòrcer|corcorcar|coresforçar|cornuar|corruixar|crisalidar|desafeccionar|desalenar|desamorar|desaparroquiar|desapassionar|desaplegar|desavenir|desbocar|descantar|descarar|descontrolar|descovar|desdubtar|desempallegar|desenrojolar|desentossudir|desfeinar|desmemoriar|desnodrir|despondre|despreocupar|dessolidaritzar|desteixinar|desvagar|desvergonyir|desviure|dignar|embarbussar|embascar|embessonar|embordeir|embordir|emborrascar|emborrossar|embotifarrar|embotzegar|embromallar|embromar|embroquerar|emmainadar|emmalurar|emmalurir|emmarar|emmarranar|emmatar|emmigranyar|emmorronar|emmurriar|empassar|empassolar|empegueir|empenyalar|empescar|empillocar|empinyar|empiocar|empitarrar|emplomissar|emplujar|emportar|encabotar|encabritar|encalmar|encalostrar|encelar|encinglar|encirar|encistar|enclaperar|encolerir|encordar|encruar|endoblir|endur|enfarfollar|enfaristolar|enfavar|enfereir|enferotgir|enferritjar|enfugir|enfurrunyar|enfutimar|enfutismar|engelabrir|engolfar|engorgar|engripar|enguerxinar|enllagrimar|enlleganyar|enlleir|enllustrar|ennavegar|enneguitar|enquistar|enrinxar|enseriosir|ensobecar|entonyinar|entossudir|entotsolar|entreabaltir|entrebadar|entrebatre|entrebesar|entrecavalcar|entredevorar|entreferir|entreforcar|entrematar|entremetre|entremirar|entrenyorar|entresaludar|entreseguir|entresoldar|entretocar|entretzenar|entrigar|envidreir|envidriar|envolar|enxautar|esbafar|esbafegar|esbatussar|esblamar|esbojarrar|esborneiar|esbromar|escabridar|escamotar|escanyellar|escanyolir|escanyussar|escapolar|escapolir|escarcanyar|escarramicar|escarrassar|escarxofar|escatifenyar|esconillar|escorporar|escullar|escunçar|esfarinar|esfetgegar|esforçar|esgargamellar|esgatinyar|esgolar|esguimbar|esllanguir|esllavissar|esperitar|espitellar|espitxar|espollinar|espoltrar|esporcellar|espotonar|esprimatxar|esquifir|esquitllar|estilar|estritllar|esvedellar|esventegar|esvomegar|etiolar|extralimitar|extravasar|extravenar|gamar|gaspar|gatinyar|gaubar|gloriar|grifar|immiscir|indigestar|industriar|innivar|insolentar|insurgir|intersecar|inveterar|irèixer|jactar|juramentar|lateritzar|llufar|malfiar|malfixar|migrolar|mofar|mullerar|neulir|obstinar|octubrar|olivar|pellobrir|pellpartir|pelltrencar|penedir|penjolar|pollar|prosternar|queixar|querar|querellar|quillar|ramificar|rancurar|realegrar|rebel·lar|rebordeir|refiar|repanxolar|repapar|repetellar|reressagar|resclosir|ressagar|ressentir|revenjar|salinar|suïcidar|tinyar|tolir|transvestir|traslluir|traspostar|trufar|vanagloriar|vanagloriejar|vanar|vantar|vergonyar|xautar");
   private static final Pattern NO_VERBS_PRONOMINALS = Pattern.compile("atendre|escollir|assolir");
   private static final Pattern VERBS_NO_PRONOMINALS = Pattern.compile("caure|callar|témer|marxar|albergar|olorar|seure");
+  private static final Pattern VERBS_NO_PRONOMINALS_IMPERSONALS = Pattern.compile("caure|callar|témer|marxar");
   private static final Pattern NO_VERBS_NO_PRONOMINALS = Pattern.compile("segar");
   private static final Pattern VERBS_MOVIMENT = Pattern.compile("anar|pujar|baixar");
   private static final Pattern VERBS_SOVINT_PRONOMINALS = Pattern.compile("deixar|fer|veure");
@@ -186,7 +187,8 @@ public RuleMatch[] match(final AnalyzedSentence text) {
 					continue loop;
 				//FRASE IMPERSONAL
 				// És frase impersonal si hi ha el pronom 'es', llevat que es pugui identificar un subjecte "personal"
-				if (isTherePronounBefore(tokens, i, LEMMA_ES, POSTAG_ES)
+				if (matchLemmaRegexp(tokens[i],VERBS_NO_PRONOMINALS_IMPERSONALS)
+						&& isTherePronounBefore(tokens, i, LEMMA_ES, POSTAG_ES)
 						&& !isTherePronounBefore(tokens, i, LEMMA_PRONOM_CI, POSTAG_PRONOM_CI)
 						&& !isTherePersonalSubjectBefore(tokens,i,TRENCA_COMPTE2)
 						&& isVerbNumberPerson(tokens,i,VERB_3S))  

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -169,6 +169,7 @@ public void testRule() throws IOException {
 		assertIncorrect("se'ns va anar la mà");
 		assertIncorrect("Es van caure en la trampa.");
 		assertIncorrect("Aleshores es van anar a la ciutat a presentar una queixa.");
+		assertIncorrect("Va entrar l'avi que pujava del taller i es va seure.");
 		//assertIncorrect("Aleshores es va anar a la ciutat a presentar una queixa.");
 		//assertIncorrect("quan es pugen, permeten canviar de feina.");
 		assertIncorrect("havent queixat");

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -185,6 +185,7 @@ public class CaseRule extends GermanRule {
     exceptions.add("Nähte");
     exceptions.add("Nähten");
     exceptions.add("Neuem");
+    exceptions.add("Neues");   // nichts Neues
     exceptions.add("Nr");
     exceptions.add("Nutze");   // zu Nutze
     exceptions.add("Obdachloser");

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/ca/ReflexiveVerbsRule.java
Patch:
@@ -103,7 +103,7 @@ public class ReflexiveVerbsRule extends CatalanRule {
   
   private static final Pattern SUBJECTE_PERSONAL_POSTAG = Pattern.compile("NC.*|NP.*|_GN_.*|PI.*");
   private static final Pattern SUBJECTE_PERSONAL_NO_POSTAG = Pattern.compile("complement.*|D.*|A.*");
-  private static final Pattern SUBJECTE_PERSONAL_TOKEN = Pattern.compile("jo|mi|tu|ella?|nosaltres|vosaltres|elle?s|vost[èé]s?|vós");
+  private static final Pattern SUBJECTE_PERSONAL_TOKEN = Pattern.compile("jo|mi|tu|ella?|nosaltres|vosaltres|elle?s|vost[èé]s?|vós",Pattern.CASE_INSENSITIVE|Pattern.UNICODE_CASE);
   private static final Pattern TRENCA_COMPTE = Pattern.compile("PR.*|CS|CC|PUNCT.*|.*LOC_CONJ.*");
   private static final Pattern TRENCA_COMPTE2 = Pattern.compile("SENT_START|CC|PUNCT.*|.*LOC_CONJ.*");
   
@@ -228,7 +228,7 @@ && isVerbNumberPerson(tokens,i,VERB_3S))
 				}
 				if (isThereReflexivePronoun(tokens, i) && (!isTherePronoun(tokens, i, LEMMA_EN, POSTAG_EN))) {
 					// the rule matches
-					final String msg = "Per a usar aquest verb com a pronominal, cal afegir-hi el pronom 'en'.";
+					final String msg = "Per a usar aquest verb com a pronominal, cal afegir-hi el pronom 'en'."; //Cal canviar el missatge
 					final RuleMatch ruleMatch = new RuleMatch(this,
 							tokens[i].getStartPos(), tokens[i].getStartPos()
 									+ token.length(), msg,

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/ca/ReflexiveVerbsRuleTest.java
Patch:
@@ -160,6 +160,7 @@ public void testRule() throws IOException {
 		//assertIncorrect("el dia que es va anar a la ciutat");
 		assertIncorrect("tot l'auditori es callà");
 		assertIncorrect("les gotes que es van caure fora"); 
+		assertIncorrect("Ells s'han baixat del tren.");
 		assertIncorrect("Se'ns va callar.");
 		assertIncorrect("Tothom es va callar.");
 		assertIncorrect("Els nens van poder-se caure");	

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRule.java
Patch:
@@ -87,7 +87,7 @@ public class ComplexAdjectiveConcordanceRule extends CatalanRule {
 	private static final Pattern UPPERCASE = Pattern.compile("\\p{Lu}[\\p{Ll}\u00B7]*");
 	private static final Pattern COORDINACIO = Pattern.compile(",|i|o");
 	private static final Pattern COORDINACIO_IONI = Pattern.compile("i|o|ni");
-	private static final Pattern KEEP_COUNT = Pattern.compile("A.*|N.*|D[NAID].*|SPS.*|.*LOC_ADV.*|V.P.*|PUNCT");
+	private static final Pattern KEEP_COUNT = Pattern.compile("A.*|N.*|D[NAID].*|SPS.*|.*LOC_ADV.*|V.P.*|PUNCT.*");
 	private static final Pattern KEEP_COUNT2 = Pattern.compile(",|i|o|ni|\\d+%?|%");
 	private static final Pattern STOP_COUNT = Pattern.compile(";");
 	private static final Pattern PREPOSICIONS = Pattern.compile("SPS.*");

File: trunk/JLanguageTool/src/test/java/org/languagetool/rules/ca/CatalanWrongWordInContextRuleTest.java
Patch:
@@ -40,7 +40,7 @@ public void testRule() throws IOException {
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Uns cultius rentables.")).length);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Es venen bé i són rentables.")).length);
     assertEquals("rendibles", rule.match(langTool.getAnalyzedSentence("Uns projectes molt rentables."))[0].getSuggestedReplacements().get(0));
-    assertEquals("rentable", rule.match(langTool.getAnalyzedSentence("Un teixit rendible."))[0].getSuggestedReplacements().get(0));
+    //assertEquals("rentable", rule.match(langTool.getAnalyzedSentence("Un teixit rendible."))[0].getSuggestedReplacements().get(0));
     
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Van escoltar el detingut fins al calabós.")).length);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Li va infringir un mal terrible.")).length);

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/DoublePunctuationRule.java
Patch:
@@ -77,7 +77,7 @@ public final RuleMatch[] match(final AnalyzedSentence text) {
         ruleMatches.add(ruleMatch);
         dotCount = 0;
       } else if (commaCount == 2 && !",".equals(nextToken)) {
-        final int fromPos = Math.max(0, startPos);
+        final int fromPos = Math.max(0, startPos - 1);
         final RuleMatch ruleMatch = new RuleMatch(this, fromPos, startPos + 1,
             getCommaMessage(), messages.getString("double_commas_short"));
         ruleMatch.setSuggestedReplacement(",");

File: trunk/JLanguageTool/src/test/java/org/languagetool/dev/index/IndexerSearcherTest.java
Patch:
@@ -259,7 +259,6 @@ public void testWithRegexRule() throws Exception {
             new Element("forth|back", false, true, false)
     );
     final PatternRule rule1 = new PatternRule("RULE1", Language.ENGLISH, elements, "desc", "msg", "shortMsg");
-    System.out.println(directory);
     final DirectoryReader reader = DirectoryReader.open(directory);
     try {
       final IndexSearcher indexSearcher = new IndexSearcher(reader);

File: trunk/JLanguageTool/src/main/java/org/languagetool/commandline/CommandLineParser.java
Patch:
@@ -20,6 +20,7 @@
 
 import java.io.PrintStream;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 
 import org.languagetool.Language;
@@ -166,8 +167,9 @@ private Language getLanguage(String userSuppliedLangCode) {
     } catch (IllegalArgumentException e){
       final List<String> supportedLanguages = new ArrayList<String>();
       for (final Language lang : Language.LANGUAGES) {
-        supportedLanguages.add(lang.getShortName());
+        supportedLanguages.add(lang.getShortNameWithVariant());
       }
+      Collections.sort(supportedLanguages);
       throw new IllegalArgumentException("Unknown language '" + userSuppliedLangCode
                   + "'. Supported languages are: " + supportedLanguages);
     }

File: trunk/JLanguageTool/src/main/dev/org/languagetool/dev/index/Indexer.java
Patch:
@@ -95,9 +95,6 @@ private static void run(String textFile, String indexDir, String languageCode) t
     final FSDirectory directory = FSDirectory.open(new File(indexDir));
     try {
       final Language language = Language.getLanguageForShortName(languageCode);
-      if (language == null) {
-        throw new RuntimeException("Unknown language code '" + languageCode + "'");
-      }
       final Indexer indexer = new Indexer(directory, language);
       try {
         run(reader, indexer, false);

File: trunk/JLanguageTool/src/main/dev/org/languagetool/dev/index/Searcher.java
Patch:
@@ -298,9 +298,6 @@ public static void main(String[] args) throws Exception {
     final File ruleFile = new File(args[1]);
     final String languageCode = args[2];
     final Language language = Language.getLanguageForShortName(languageCode);
-    if (language == null) {
-      throw new RuntimeException("Unknown language code '" + languageCode + "'");
-    }
     final File indexDir = new File(args[3]);
     final PatternRule rule = searcher.getRuleById(ruleId, ruleFile);
     final SearcherResult searcherResult = searcher.findRuleMatchesOnIndex(rule, language, indexDir);

File: trunk/JLanguageTool/src/main/dev/org/languagetool/dev/wikipedia/WikipediaIndexHandler.java
Patch:
@@ -151,9 +151,6 @@ public static void main(String... args) throws Exception {
     final int maxDocs = Integer.parseInt(args[3]);
 
     final Language language = Language.getLanguageForShortName(languageCode);
-    if (language == null) {
-      throw new RuntimeException("Could not find language '" + languageCode + "'");
-    }
     if (maxDocs == 0) {
       System.out.println("Going to index all documents from " + dumpFile);
     } else {

File: trunk/JLanguageTool/src/main/java/org/languagetool/Language.java
Patch:
@@ -393,7 +393,8 @@ public static Language getLanguageForName(final String languageName) {
    * Get the Language object for the given short language name.
    *
    * @param shortLanguageCode e.g. <code>en</code> or <code>de</code>
-   * @return a Language object or <code>null</code>
+   * @return a Language object
+   * @throws IllegalArgumentException if the language is not supported
    */
   public static Language getLanguageForShortName(final String shortLanguageCode) {
     StringTools.assureSet(shortLanguageCode, "shortLanguageCode");
@@ -421,7 +422,7 @@ public static Language getLanguageForShortName(final String shortLanguageCode) {
         return element;
       }
     }
-    return null;
+    throw new IllegalArgumentException("'" + shortLanguageCode + "' is not a language code known to LanguageTool");
   }
 
   /**

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/patterns/PatternRuleHandler.java
Patch:
@@ -65,9 +65,6 @@ public void startElement(final String namespaceURI, final String lName,
     } else if ("rules".equals(qName)) {
       final String languageStr = attrs.getValue("lang");
       language = Language.getLanguageForShortName(languageStr);
-      if (language == null) {
-        throw new SAXException("Unknown language '" + languageStr + "'");
-      }
     } else if (RULE.equals(qName)) {
       shortMessage = new StringBuilder();
       url = new StringBuilder();

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/patterns/bitext/BitextPatternRuleLoader.java
Patch:
@@ -91,9 +91,6 @@ public void startElement(final String namespaceURI, final String lName,
     if (qName.equals("rules")) {
       final String languageStr = attrs.getValue("targetLang");
       language = Language.getLanguageForShortName(languageStr);
-      if (language == null) {
-        throw new SAXException("Unknown language '" + languageStr + "'");
-      }
     } else if (qName.equals("rule")) {
       super.startElement(namespaceURI, lName, qName, attrs);
       correctExamples = new ArrayList<StringPair>();

File: trunk/JLanguageTool/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -133,9 +133,6 @@ private void checkText(String text, HttpExchange httpExchange, Map<String, Strin
       throw new IllegalArgumentException("Missing 'language' parameter");
     }
     final Language lang = Language.getLanguageForShortName(langParam);
-    if (lang == null) {
-      throw new IllegalArgumentException("Unknown language '" + langParam + "'");
-    }
     final String motherTongueParam = parameters.get("motherTongue");
     Language motherTongue = null;
     if (null != motherTongueParam) {

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -80,6 +80,8 @@ public class CaseRule extends GermanRule {
   private static final Set<String> exceptions = new HashSet<String>();
   static {
     exceptions.add("Hr");   // Hr. = Abkürzung für Herr
+    exceptions.add("Schwarz");
+    exceptions.add("Rosa");
     exceptions.add("Auftrieb");
     exceptions.add("Zuschnitt");
     exceptions.add("Geschossen");

File: trunk/JLanguageTool/src/main/java/org/languagetool/tools/StringTools.java
Patch:
@@ -367,6 +367,7 @@ public static String ruleMatchesToXML(final List<RuleMatch> ruleMatches,
       context = context.replaceAll("[\n\r]", " ");
       xml.append(" context=\"" + StringTools.escapeXML(context) + "\"");
       xml.append(" contextoffset=\"" + contextOffset + "\"");
+      xml.append(" offset=\"" + match.getFromPos() + "\"");
       xml.append(" errorlength=\"" + (match.getToPos() - match.getFromPos()) + "\"");
       if (match.getRule().getUrl() != null) {
           xml.append(" url=\""

File: trunk/JLanguageTool/src/main/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -89,8 +89,8 @@ public void handle(HttpExchange httpExchange) throws IOException {
   }
 
   private void sendError(HttpExchange httpExchange, int returnCode, String response) throws IOException {
-    httpExchange.sendResponseHeaders(returnCode, response.getBytes().length);
-    httpExchange.getResponseBody().write(response.getBytes());
+    httpExchange.sendResponseHeaders(returnCode, response.getBytes(ENCODING).length);
+    httpExchange.getResponseBody().write(response.getBytes(ENCODING));
   }
 
   private Map<String, String> getRequestQuery(HttpExchange httpExchange, URI requestedUri) throws IOException {

File: trunk/JLanguageTool/src/main/dev/org/languagetool/dev/RuleOverview.java
Patch:
@@ -111,7 +111,7 @@ private void run(File webRoot) throws IOException {
         xmlRules = xmlRules.replaceAll("(?s)<rules.*?>", "");
         final int count = countXmlRules(xmlRules);
         final int countInRuleGroup = countXmlRuleGroupRules(xmlRules);
-        final String ruleBase = "http://languagetool.svn.sourceforge.net/viewvc/languagetool/trunk/JLanguageTool/src/rules/";
+        final String ruleBase = "http://languagetool.svn.sourceforge.net/viewvc/languagetool/trunk/JLanguageTool/src/main/resources/org/languagetool/rules/";
         System.out.print("<td valign=\"top\" align=\"right\">" + (count + countInRuleGroup) + "</td>");
         System.out.print("<td valign=\"top\" align=\"right\">" +
             "<a href=\"" + ruleBase + lang.getShortName() + "/grammar.xml" + "\">Show</a> / " +
@@ -121,7 +121,7 @@ private void run(File webRoot) throws IOException {
       }
 
       // count Java rules:
-      final File dir = new File("src/java/org/languagetool" + 
+      final File dir = new File("src/main/java" +
               JLanguageTool.getDataBroker().getRulesDir() + "/" + lang.getShortName());
       if (!dir.exists()) {
         System.out.print("<td valign=\"top\" align=\"right\">0</td>");
@@ -151,7 +151,7 @@ private void run(File webRoot) throws IOException {
       
     if (overallJavaCount == 0) {
       throw new RuntimeException("No Java rules found - start this script from the LanguageTool directory so " +
-              "that the sources are at 'src/java/org/languagetool'");
+              "that the sources are at 'src/main/java/org/languagetool/rules'");
     }
     if (langSpecificWebsiteCount == 0) {
       throw new RuntimeException("No language specific websites found - please let the web root parameter " +

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/pl/PolishWordRepeatRule.java
Patch:
@@ -97,6 +97,7 @@ public final RuleMatch[] match(final AnalyzedSentence text) {
     boolean repetition = false;
     final TreeSet<String> inflectedWords = new TreeSet<String>();
     String prevLemma, curLemma;
+    int curToken = 0;
     // start from real token, 0 = SENT_START
     for (int i = 1; i < tokens.length; i++) {
       final String token = tokens[i].getToken();
@@ -155,10 +156,11 @@ public final RuleMatch[] match(final AnalyzedSentence text) {
           if (hasLemma) {
             curLemma = tokens[i].getAnalyzedToken(j).getLemma();
             if (!prevLemma.equals(curLemma) && !notSentEnd) {
-              if (inflectedWords.contains(curLemma)) {
+              if (inflectedWords.contains(curLemma) && curToken != i) {
                 repetition = true;
               } else {
                 inflectedWords.add(tokens[i].getAnalyzedToken(j).getLemma());
+                curToken = i;
               }
             }
             prevLemma = curLemma;

File: trunk/JLanguageTool/src/main/java/org/languagetool/commandline/CommandLineParser.java
Patch:
@@ -142,7 +142,7 @@ public void printUsage() {
             + "  -p, --profile            print performance measurements\n"
             + "  -v, --verbose            print text analysis (sentences, part-of-speech tags) to STDERR\n"
             + "  --version                print LanguageTool version number and exit\n"
-            + "  -a, --apply              automatically apply suggestions if available, printing result to STDOUT"
+            + "  -a, --apply              automatically apply suggestions if available, printing result to STDOUT\n"
             + "  --xmlfilter              remove XML/HTML elements from input before checking (this is deprecated)");
   }
 

File: trunk/JLanguageTool/src/main/java/org/languagetool/rules/spelling/SpellingCheckRule.java
Patch:
@@ -115,7 +115,7 @@ private void loadFileIfExists(String filename) throws IOException {
   private void loadWordsToBeIgnored(String ignoreFile) throws IOException {
     final InputStream inputStream = JLanguageTool.getDataBroker().getFromResourceDirAsStream(ignoreFile);
     try {
-      final Scanner scanner = new Scanner(inputStream);
+      final Scanner scanner = new Scanner(inputStream, "utf-8");
       try {
         while (scanner.hasNextLine()) {
           final String line = scanner.nextLine();

File: trunk/JLanguageTool/src/java/org/languagetool/commandline/CommandLineParser.java
Patch:
@@ -143,7 +143,7 @@ public void printUsage() {
             + "  -v, --verbose            print text analysis (sentences, part-of-speech tags) to STDERR\n"
             + "  --version                print LanguageTool version number and exit\n"
             + "  -a, --apply              automatically apply suggestions if available, printing result to STDOUT"
-            + "  --xmlfilter              remove XML/HTML elements from input before checking");
+            + "  --xmlfilter              remove XML/HTML elements from input before checking (this is deprecated)");
   }
 
   private void checkArguments(String option, int argParsingPos, String[] args) {

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/PatternRuleQueryBuilder.java
Patch:
@@ -154,7 +154,7 @@ private SpanQuery makeQuery(Element element, int position, boolean throwExceptio
         // this to avoid the exception that all fields need to have the same field
         // when constructing the SpanNearQuery:
         //final RegexpQuery regexpQuery = getCaseSensitiveRegexQuery(POS_PREFIX + pos);
-        posQuery = getWrappedRegexQuery(element, POS_PREFIX + pos);
+        posQuery = getWrappedRegexQuery(element, POS_PREFIX + "(" + pos + ")");
         //posQuery = new SpanMultiTermQueryWrapper<RegexpQuery>(regexpQuery);
       } else {
         if (element.getCaseSensitive()) {

File: trunk/JLanguageTool/src/test/org/languagetool/dev/index/PatternRuleQueryBuilderTest.java
Patch:
@@ -222,6 +222,8 @@ public void testSeveralElements() throws Exception {
     assertMatches(makeRule("<token postag=\"FOO\"></token>"), 0);
 
     assertMatches(makeRule("<token postag=\"[XW]RB\" postag_regexp=\"yes\"></token>"), 1);
+    assertMatches(makeRule("<token postag=\"FOO|WRB\" postag_regexp=\"yes\"></token>"), 1);
+    assertMatches(makeRule("<token postag=\"WRB|FOO\" postag_regexp=\"yes\"></token>"), 1);
     assertMatches(makeRule("<token postag=\"[XY]OO\" postag_regexp=\"yes\"></token>"), 0);
 
     // combine term and POS tag:

File: trunk/JLanguageTool/src/java/org/languagetool/Language.java
Patch:
@@ -175,13 +175,14 @@ public abstract class Language {
 
   /**
    * Get this language's two character code, e.g. <code>en</code> for English.
-   * The variant ("US"), if any, is not returned.
+   * The variant (e.g. "US"), if any, is not returned.
    * @return language code
    */
   public abstract String getShortName();
 
   /**
-   * Get this language's name in English, e.g. <code>English</code> or <code>German</code>.
+   * Get this language's name in English, e.g. <code>English</code> or
+   * <code>German (Germany)</code>.
    * @return language name
    */
   public abstract String getName();

File: trunk/JLanguageTool/src/java/org/languagetool/tools/StringTools.java
Patch:
@@ -457,7 +457,7 @@ public static String trimWhitespace(final String str) {
     final StringBuilder filter = new StringBuilder();
     for (int i = 0; i < str.length(); i++) {
       final char c = str.charAt(i);
-      if (c != '\n' && c != ' ' && c != '\t') {
+      if (c != '\n' && c != ' ' && c != '\t' && c != '\r') {
         filter.append(c);
       }
     }

File: trunk/JLanguageTool/src/test/org/languagetool/tools/StringToolsTest.java
Patch:
@@ -265,7 +265,7 @@ public void testTrimWhitespace() {
     assertEquals("", StringTools.trimWhitespace(""));
     assertEquals("", StringTools.trimWhitespace(" "));
     assertEquals("XXY", StringTools.trimWhitespace(" \nXX\t Y"));
-    // TODO: make this work assertEquals("XXY", StringTools.trimWhitespace(" \r\nXX\t Y"));
+    assertEquals("XXY", StringTools.trimWhitespace(" \r\nXX\t Y"));
     assertEquals("word", StringTools.trimWhitespace("word"));
   }
 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/Searcher.java
Patch:
@@ -72,7 +72,7 @@ private int getDocCount(IndexSearcher indexSearcher) throws IOException {
     final Term searchTerm = new Term(MAX_DOC_COUNT_FIELD, MAX_DOC_COUNT_FIELD_VAL);
     final TopDocs search = indexSearcher.search(new TermQuery(searchTerm), 1);
     if (search.totalHits != 1) {
-      throw new RuntimeException("Got " + search.totalHits + " hits for the docCount query in " + indexSearcher.getIndexReader() + ", expected 1");
+      return -1;
     }
     final ScoreDoc scoreDoc = search.scoreDocs[0];
     final Document doc = indexSearcher.doc(scoreDoc.doc);

File: trunk/JLanguageTool/src/test/org/languagetool/dev/index/PatternRuleQueryBuilderTest.java
Patch:
@@ -257,6 +257,9 @@ public void testSeveralElements() throws Exception {
     assertMatches(makeRule("<token>X</token> <token>.</token> <token>G</token> <token>.</token>"), 0);
     assertMatches(makeRule("<token>E</token> <token>,</token> <token>G</token> <token>.</token>"), 0);
 
+    assertMatches(makeRule("<token>E</token> <token>.</token> <token>G</token> <token>.</token> <token>LanguageTool</token>"), 1);
+    assertMatches(makeRule("<token>E</token> <token>.</token> <token>G</token> <token>.</token> <token>foo</token>"), 0);
+
     assertRelaxedMatches(makeCaseSensitiveRule("<token>The</token> <token inflected=\"yes\">is</token>"), 1);
 
     // negation:

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/AnyCharTokenizer.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.io.Reader;
 
-import org.apache.lucene.analysis.CharTokenizer;
+import org.apache.lucene.analysis.util.CharTokenizer;
 import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.Version;
 

File: trunk/JLanguageTool/src/test/org/languagetool/dev/index/AnyCharTokenizerTest.java
Patch:
@@ -30,7 +30,7 @@ public class AnyCharTokenizerTest extends TestCase {
   public void testAnyCharTokenizer() throws Exception {
     StringReader sr = new StringReader("It's a good day, I liked it!");
 
-    AnyCharTokenizer tokenizer = new AnyCharTokenizer(Version.LUCENE_31, sr);
+    AnyCharTokenizer tokenizer = new AnyCharTokenizer(Version.LUCENE_40, sr);
     CharTermAttribute termAtt = tokenizer.addAttribute(CharTermAttribute.class);
 
     assertTrue(tokenizer.incrementToken());

File: trunk/JLanguageTool/src/test/org/languagetool/dev/index/LanguageToolFilterTest.java
Patch:
@@ -36,11 +36,11 @@ public void testFilter() throws Exception {
     String input = "How do you thin?";
 
     TokenStream stream = new AnyCharTokenizer(TEST_VERSION_CURRENT, new StringReader(input));
-    LanguageToolFilter filter = new LanguageToolFilter(stream, new JLanguageTool(Language.ENGLISH));
+    LanguageToolFilter filter;
     //displayTokensWithFullDetails(filter);
 
     stream = new AnyCharTokenizer(TEST_VERSION_CURRENT, new StringReader(input));
-    filter = new LanguageToolFilter(stream, new JLanguageTool(Language.ENGLISH));
+    filter = new LanguageToolFilter(stream, new JLanguageTool(Language.ENGLISH), false);
 
     assertTokenStreamContents(filter, new String[] { "_POS_SENT_START", "How", "_POS_WRB", "do",
         "_POS_VBP", "_POS_VB", "you", "_POS_PRP", "thin", "_POS_VBP", "_POS_VB", "_POS_JJ", "?",

File: trunk/JLanguageTool/src/test/org/languagetool/rules/spelling/SuggestionExtractorTest.java
Patch:
@@ -26,7 +26,7 @@
 public class SuggestionExtractorTest extends TestCase {
 
   public void testGetSuggestions() throws IOException {
-    final SuggestionExtractor extractor = new SuggestionExtractor(Language.ENGLISH);
+    final SuggestionExtractor extractor = new SuggestionExtractor();
     assertEquals("[]", extractor.getSimpleSuggestions("Did you mean foo?").toString());
     assertEquals("[foo bla]", extractor.getSimpleSuggestions("Did you mean <suggestion>foo bla</suggestion>?").toString());
     assertEquals("[foo bla, xxx]", extractor.getSimpleSuggestions("Did you mean <suggestion>foo bla</suggestion> or <suggestion>xxx</suggestion>?").toString());

File: trunk/JLanguageTool/src/java/org/languagetool/gui/ResultArea.java
Patch:
@@ -63,6 +63,7 @@ class ResultArea extends JTextPane {
     setText(Main.HTML_GREY_FONT_START + messages.getString("resultAreaText") + Main.HTML_FONT_END);
     setEditable(false);
     addHyperlinkListener(new MyHyperlinkListener());
+    setTransferHandler(new RetainLineBreakTransferHandler());
   }
 
   String getRuleMatchHtml(List<RuleMatch> ruleMatches, String text, String startCheckText) {

File: trunk/JLanguageTool/src/java/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRule.java
Patch:
@@ -76,7 +76,7 @@ public class ComplexAdjectiveConcordanceRule extends CatalanRule {
 	private static final Pattern COORDINACIO = Pattern.compile(",|i|o");
 	private static final Pattern COORDINACIO_IONI = Pattern.compile("i|o|ni");
 	private static final Pattern KEEP_COUNT = Pattern.compile("A.*|N.*|D[NAID].*|SPS.*|R.*|V.P.*");
-	private static final Pattern KEEP_COUNT2 = Pattern.compile(",|i|o|ni");
+	private static final Pattern KEEP_COUNT2 = Pattern.compile(",|i|o|ni|\\d+");
 	private static final Pattern PREPOSICIONS = Pattern.compile("SPS.*");
 	private static final Pattern VERB_AUXILIAR = Pattern.compile("V[AS].*");
 	private static final Pattern EXCEPCIONS_PARTICIPI = Pattern.compile("atès|atés|atesa|atesos|ateses|donat|donats|donada|donades");

File: trunk/JLanguageTool/src/test/org/languagetool/rules/de/VerbAgreementRuleTest.java
Patch:
@@ -1,5 +1,5 @@
 /* LanguageTool, a natural language style checker 
- * Copyright (C) 2005 Daniel Naber (http://www.danielnaber.de)
+ * Copyright (C) 2012 Markus Brenneis
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -19,13 +19,11 @@
 package org.languagetool.rules.de;
 
 import java.io.IOException;
-import java.util.List;
 
 import junit.framework.TestCase;
 
 import org.languagetool.JLanguageTool;
 import org.languagetool.Language;
-import org.languagetool.rules.RuleMatch;
 
 /**
  * @author Markus Brenneis

File: trunk/JLanguageTool/src/java/org/languagetool/rules/zh/ChineseWordRepeatBeginningRule.java
Patch:
@@ -11,9 +11,9 @@
 import org.languagetool.rules.Rule;
 import org.languagetool.rules.RuleMatch;
 
-public class ChineseWordRepeatBeginningRule extends Rule{
+public class ChineseWordRepeatBeginningRule extends Rule {
 
-	  private String lastEndToken ="" ;
+	  private String lastEndToken = "" ;
 	  private String lastToken = "";
 	  private String beforeLastToken = "";
 	  
@@ -57,7 +57,7 @@ public RuleMatch[] match(final AnalyzedSentence text) {
 	    
 	   
 	    
-	    if (tokens.length>3) {
+	    if (tokens.length > 3) {
 	      final AnalyzedTokenReadings analyzedToken = tokens[1];
 	      final String token = analyzedToken.getToken();
 	      // avoid "..." etc. to be matched:

File: trunk/JLanguageTool/src/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -198,7 +198,6 @@ private Map<String, String> parseQuery(String query) throws UnsupportedEncodingE
         } else {
           value = URLDecoder.decode(pair.substring(pair.indexOf("=") + 1), "UTF-8");
         }
-        value = value.replaceAll("\\+", " ");
         parameters.put(key, value);
       }
     }

File: trunk/JLanguageTool/src/test/org/languagetool/server/HTTPServerTest.java
Patch:
@@ -70,8 +70,8 @@ void runTests() throws IOException, SAXException, ParserConfigurationException {
     assertTrue(!check(Language.GERMAN, "bla <script>").contains("<script>"));
 
     // other tests for special characters
-    final String germanSpecialChars = check(Language.GERMAN, "ein kleiner test. Und wieder Erwarten noch was: öäüß öäüß.");
-    assertTrue("Expected special chars, got: '" + germanSpecialChars + "'", germanSpecialChars.contains("öäüß"));
+    final String germanSpecialChars = check(Language.GERMAN, "ein kleiner test. Und wieder Erwarten noch was: öäüß+ öäüß.");
+    assertTrue("Expected special chars, got: '" + germanSpecialChars + "'", germanSpecialChars.contains("öäüß+"));
     final String romanianSpecialChars = check(Language.ROMANIAN, "bla bla șțîâă șțîâă și câteva caractere speciale");
     assertTrue("Expected special chars, got: '" + romanianSpecialChars + "'", romanianSpecialChars.contains("șțîâă"));
     final String polishSpecialChars = check(Language.POLISH, "Mówiła długo, żeby tylko mówić mówić długo.");

File: trunk/JLanguageTool/src/java/org/languagetool/language/German.java
Patch:
@@ -36,6 +36,7 @@
 import org.languagetool.rules.de.GermanWordRepeatBeginningRule;
 import org.languagetool.rules.de.GermanWordRepeatRule;
 import org.languagetool.rules.de.GermanWrongWordInContextRule;
+import org.languagetool.rules.de.VerbAgreementRule;
 import org.languagetool.rules.de.WiederVsWiderRule;
 import org.languagetool.rules.de.WordCoherencyRule;
 import org.languagetool.rules.spelling.hunspell.HunspellNoSuggestionRule;
@@ -126,6 +127,7 @@ public List<Class<? extends Rule>> getRelevantRules() {
             CaseRule.class,
             CompoundRule.class,
             DashRule.class,
+            VerbAgreementRule.class,
             WordCoherencyRule.class,
             WiederVsWiderRule.class
     );

File: trunk/JLanguageTool/src/java/org/languagetool/rules/zh/ChineseWordRepeatBeginningRule.java
Patch:
@@ -24,7 +24,7 @@ public ChineseWordRepeatBeginningRule(final ResourceBundle messages, final Langu
 
 	  @Override
 	  public String getId() {
-	    return "WORD_REPEAT_BEGINNING_RULE";
+	    return "CHINESE_WORD_REPEAT_BEGINNING_RULE";
 	  }
 
 	  @Override

File: trunk/JLanguageTool/src/java/org/languagetool/rules/spelling/morfologik/MorfologikSpellerRule.java
Patch:
@@ -97,9 +97,9 @@ public RuleMatch[] match(AnalyzedSentence text) throws IOException {
                     int index = 0;
                     final Matcher m = tokenizingPattern().matcher(word);
                     while(m.find()) {
-                        final String match = word.subSequence(index, m.start()).toString();
-                        index = m.end();
+                        final String match = word.subSequence(index, m.start()).toString();                        
                         ruleMatches.addAll(getRuleMatch(match, token.getStartPos() + index));
+                        index = m.end();
                     }
                     if (index == 0) { // tokenizing char not found
                         ruleMatches.addAll(getRuleMatch(word, token.getStartPos()));

File: trunk/JLanguageTool/src/test/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -63,7 +63,8 @@ public void testDetNounRule() throws IOException {
     assertGood("Das Auto von einem Mann.");
     assertGood("Das Auto eines Mannes.");
     assertGood("Des großen Mannes.");
-    
+    assertGood("Und nach der Nummerierung kommt die Überschrift.");
+
     assertGood("Das Dach von meinem Auto.");
     assertGood("Das Dach von meinen Autos.");
 

File: trunk/JLanguageTool/src/test/org/languagetool/JLanguageToolTest.java
Patch:
@@ -168,8 +168,8 @@ public void testPolish() throws IOException {
     //and let's test other feats
     AnalyzedSentence sent = tool.getAnalyzedSentence("Z powodu pogody dobre buty są wskazane.");
     assertEquals("Disambiguator log: "
-            + "\nMULTIWORD_CHUNKER: Z[z/prep:gen.inst] -> Z[z/prep:gen.inst,Z powodu/<PREP:GEN>]"
-            + "\n\nMULTIWORD_CHUNKER: powodu[powód/subst:sg:gen:m3] -> Z[z/prep:gen.inst,Z powodu/<PREP:GEN>]\n",
+            + "\n\nMULTIWORD_CHUNKER: Z[z/prep:gen.inst] -> Z[z/prep:gen.inst,Z powodu/<PREP:GEN>]"
+            + "\n\nMULTIWORD_CHUNKER: powodu[powód/subst:sg:gen:m3] -> powodu[powód/subst:sg:gen:m3,Z powodu/</PREP:GEN>]\n",
             sent.getAnnotations());
     sent = tool.getAnalyzedSentence("Nie mamy żadnej ryby.");
     assertEquals("Disambiguator log: "

File: trunk/JLanguageTool/src/test/org/languagetool/JLanguageToolTest.java
Patch:
@@ -142,7 +142,7 @@ public void testPolish() throws IOException {
     assertEquals(6, matches.size());
     tool.setListUnknownWords(true);
     matches = tool.check("This is not a Polish text.");
-    assertEquals(4, matches.size());
+    assertEquals(3, matches.size());
     assertEquals("[Polish, This, is, text]", tool.getUnknownWords().toString());
     //check positions relative to sentence ends    
     matches = tool.check("To jest tekst.\nTest 1. To jest linia w której nie ma przecinka.");

File: trunk/JLanguageTool/src/test/org/languagetool/rules/pl/MorfologikPolishSpellerRuleTest.java
Patch:
@@ -36,7 +36,7 @@ public void testMorfologikSpeller() throws IOException {
         assertEquals(1, matches.length);
         assertEquals(0, matches[0].getFromPos());
         assertEquals(4, matches[0].getToPos());
-        assertEquals("Zolą", matches[0].getSuggestedReplacements().get(0));
+        assertEquals("Zola", matches[0].getSuggestedReplacements().get(0));
 
         assertEquals(1, rule.match(langTool.getAnalyzedSentence("aõh")).length);
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("a")).length);

File: trunk/JLanguageTool/src/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -148,7 +148,8 @@ private GrammarCategory(String displayName) {
     "etwas",
     "was",
     "wer",
-    "jenen"      // "...und mit jenen anderer Arbeitsgruppen verwoben"
+    "jenen",      // "...und mit jenen anderer Arbeitsgruppen verwoben"
+    "diejenigen"
   ));
     
   public AgreementRule(final ResourceBundle messages) {

File: trunk/JLanguageTool/src/test/org/languagetool/rules/ca/MorfologikCatalanSpellerRuleTest.java
Patch:
@@ -50,6 +50,8 @@ public void testMorfologikSpeller() throws IOException {
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("Porta'n quatre al col·legi.")).length);
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("Has de portar-me'n moltes.")).length);
         assertEquals(0, rule.match(langTool.getAnalyzedSentence(",")).length);
+        // Spellcheck dictionary contains Valencian and general accentuation
+        assertEquals(0, rule.match(langTool.getAnalyzedSentence("Francès i francés.")).length);
         
         
         //test for "LanguageTool":

File: trunk/JLanguageTool/src/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -186,8 +186,8 @@ public RuleMatch[] match(final AnalyzedSentence text) {
       if (i > 0) {
         final String prevToken = tokens[i-1].getToken().toLowerCase();
         if ((prevToken.equals("der") || prevToken.equals("die") || prevToken.equals("das"))
-            && tokens[i].getToken().equals("eine")) {
-          // TODO: "der eine Polizist" -> nicht ignorieren, sondern "der polizist" checken
+            && (tokens[i].getToken().equals("eine") || tokens[i].getToken().equals("einen"))) {
+          // TODO: "der eine Polizist" -> nicht ignorieren, sondern "der polizist" checken; "auf der einen Seite"
           ignore = true;
         }
       }

File: trunk/JLanguageTool/src/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -79,6 +79,7 @@ public class CaseRule extends GermanRule {
   
   private static final Set<String> exceptions = new HashSet<String>();
   static {
+    exceptions.add("Hr");   // Hr. = Abkürzung für Herr
     exceptions.add("Gesandter");
     exceptions.add("Durchfahrt");
     exceptions.add("Durchgriff");

File: trunk/JLanguageTool/src/java/org/languagetool/gui/Main.java
Patch:
@@ -459,9 +459,9 @@ private ConfigurationDialog getCurrentConfigDialog(Language language) {
   private JLanguageTool getCurrentLanguageTool(Language currentLanguage) {
     final JLanguageTool langTool;
     try {
+      config = new Configuration(new File(System.getProperty("user.home")), CONFIG_FILE, currentLanguage);
       final ConfigurationDialog configDialog = getCurrentConfigDialog(currentLanguage);
       langTool = new JLanguageTool(currentLanguage, configDialog.getMotherTongue());
-      config = new Configuration(new File(System.getProperty("user.home")), CONFIG_FILE, currentLanguage);
       langTool.activateDefaultPatternRules();
       langTool.activateDefaultFalseFriendRules();
       final Set<String> disabledRules = configDialog.getDisabledRuleIds();

File: trunk/JLanguageTool/src/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -137,7 +137,8 @@ private GrammarCategory(String displayName) {
     "alle",
     "etwas",
     "was",
-    "wer"
+    "wer",
+    "jenen"      // "...und mit jenen anderer Arbeitsgruppen verwoben"
   ));
     
   public AgreementRule(final ResourceBundle messages) {

File: trunk/JLanguageTool/src/test/org/languagetool/rules/en/MorfologikAmericanSpellerRuleTest.java
Patch:
@@ -24,6 +24,8 @@ public void testMorfologikSpeller() throws IOException {
         // correct sentences:
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("This is an example: we get behavior as a dictionary word.")).length);
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("Why don't we speak today.")).length);
+        //with doesn't
+        assertEquals(0, rule.match(langTool.getAnalyzedSentence("He doesn't know what to do.")).length);
         assertEquals(0, rule.match(langTool.getAnalyzedSentence(",")).length);
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("123454")).length);
 

File: trunk/JLanguageTool/src/test/org/languagetool/rules/en/MorfologikBritishSpellerRuleTest.java
Patch:
@@ -24,6 +24,8 @@ public void testMorfologikSpeller() throws IOException {
         // correct sentences:
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("This is an example: we get behaviour as a dictionary word.")).length);
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("Why don't we speak today.")).length);
+        //with doesn't
+        assertEquals(0, rule.match(langTool.getAnalyzedSentence("He doesn't know what to do.")).length);
         assertEquals(0, rule.match(langTool.getAnalyzedSentence(",")).length);
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("123454")).length);
 

File: trunk/JLanguageTool/src/test/org/languagetool/rules/en/MorfologikCanadianSpellerRuleTest.java
Patch:
@@ -24,6 +24,8 @@ public void testMorfologikSpeller() throws IOException {
         // correct sentences:
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("This is an example: we get behaviour as a dictionary word.")).length);
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("Why don't we speak today.")).length);
+        //with doesn't
+        assertEquals(0, rule.match(langTool.getAnalyzedSentence("He doesn't know what to do.")).length);
         assertEquals(0, rule.match(langTool.getAnalyzedSentence(",")).length);
         assertEquals(0, rule.match(langTool.getAnalyzedSentence("123454")).length);
 

File: trunk/JLanguageTool/src/test/org/languagetool/rules/ca/ComplexAdjectiveConcordanceRuleTest.java
Patch:
@@ -42,6 +42,8 @@ public void setUp() throws IOException {
 	public void testRule() throws IOException { 
 
 		// correct sentences:
+		assertCorrect("des de la tradicional divisió en dos regnes establida per Linnaeus");
+		assertCorrect("aquestes activitats avui residuals donada ja la manca de territori");
 		assertCorrect("instruments de càlcul basats en boles anomenats yupana.");
 		assertCorrect("El rei ha trobat l'excusa i l'explicació adequades.");
 		assertCorrect("El rei ha trobat l'excusa i l'explicació adequada.");

File: trunk/JLanguageTool/src/java/org/languagetool/language/Greek.java
Patch:
@@ -24,7 +24,7 @@
 import org.languagetool.Language;
 import org.languagetool.rules.*;
 import org.languagetool.rules.el.GreekUnpairedBracketsRule;
-import org.languagetool.rules.spelling.hunspell.HunspellRule;
+import org.languagetool.rules.el.MorfologikGreekSpellerRule;
 import org.languagetool.synthesis.Synthesizer;
 import org.languagetool.synthesis.el.GreekSynthesizer;
 import org.languagetool.tagging.Tagger;
@@ -82,7 +82,7 @@ public List<Class<? extends Rule>> getRelevantRules() {
                 DoublePunctuationRule.class,
                 GreekUnpairedBracketsRule.class,
                 LongSentenceRule.class,
-                HunspellRule.class,
+                MorfologikGreekSpellerRule.class,
                 UppercaseSentenceStartRule.class,
                 WhitespaceRule.class,
                 WordRepeatBeginningRule.class,

File: trunk/JLanguageTool/src/java/org/languagetool/gui/ContextTools.java
Patch:
@@ -72,9 +72,11 @@ public String getContext(final int fromPos, final int toPos, String text) {
     final int endMark = markerStr.lastIndexOf('^');
     String result = sb.toString();
     if (escapeHtml) {
+      final String escapedErrorPart = StringTools.escapeHTML(result.substring(startMark, endMark + 1))
+              .replace(" ", "&nbsp;");   // make sure whitespace errors are visible
       result = StringTools.escapeHTML(result.substring(0, startMark))
           + errorMarkerStart
-          + StringTools.escapeHTML(result.substring(startMark, endMark + 1))
+          + escapedErrorPart
           + errorMarkerEnd + StringTools.escapeHTML(result.substring(endMark + 1));
     } else {
       result = result.substring(0, startMark) + errorMarkerStart

File: trunk/JLanguageTool/src/test/org/languagetool/gui/ContextToolsTest.java
Patch:
@@ -26,6 +26,8 @@ public void testGetContext() throws Exception {
     final ContextTools contextTools = new ContextTools();
     final String context = contextTools.getContext(4, 8, "Hi, this is some nice text waiting for its error markers.");
     assertEquals("Hi, <b><font bgcolor=\"#ff8b8b\">this</font></b> is some nice text waiting for its error...", context);
+    final String context2 = contextTools.getContext(3, 5, "xxx\n \nyyy");
+    assertEquals("xxx<b><font bgcolor=\"#ff8b8b\">&nbsp;&nbsp;</font></b> yyy", context2);
   }
 
   public void testLargerContext() throws Exception {

File: trunk/JLanguageTool/src/test/org/languagetool/JLanguageToolTest.java
Patch:
@@ -88,7 +88,7 @@ public void testGermanyGerman() throws IOException {
     tool.activateDefaultPatternRules();
     tool.setListUnknownWords(true);
     // German rule has no effect with English error, but they are spelling mistakes:
-    assertEquals(6, tool.check("I can give you more a detailed description").size());
+    assertEquals(8, tool.check("I can give you more a detailed description").size());
     //test unknown words listing
     assertEquals("[I, can, detailed, give, more, you]", tool.getUnknownWords().toString());
   }

File: trunk/JLanguageTool/src/java/org/languagetool/rules/en/MorfologikBritishSpellerRule.java
Patch:
@@ -26,7 +26,7 @@
 
 public final class MorfologikBritishSpellerRule extends MorfologikSpellerRule {
 
-    private static final String RESOURCE_FILENAME = "/en/hunspell/en_US.dict";
+    private static final String RESOURCE_FILENAME = "/en/hunspell/en_CA.dict";
     
     public MorfologikBritishSpellerRule(ResourceBundle messages,
             Language language) {
@@ -39,7 +39,7 @@ public String getFileName() {
     }
     
     public final String getId() {
-        return "MORFOLOGIK_RULE_EN_GB";
+        return "MORFOLOGIK_RULE_EN_CA";
     }
 
 }

File: trunk/JLanguageTool/src/test/org/languagetool/rules/de/GermanWrongWordInContextRuleTest.java
Patch:
@@ -63,6 +63,8 @@ public void testRule() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Die Explosion der Mine.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Die Mine ist explodiert.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Er versucht, keine Miene zu verziehen.")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("Sie sollen weiter Minen eingesetzt haben.")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("Er verzieht sich nach Bekanntgabe der Mineralölsteuerverordnung.")).length);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Er verzieht keine Mine.")).length);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Mit unbewegter Mine.")).length);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Er setzt eine kalte Mine auf.")).length);

File: trunk/JLanguageTool/src/java/org/languagetool/rules/ca/CatalanUnpairedQuestionMarksRule.java
Patch:
@@ -32,6 +32,7 @@ public class CatalanUnpairedQuestionMarksRule extends GenericUnpairedBracketsRul
   public CatalanUnpairedQuestionMarksRule(final ResourceBundle messages,
       final Language language) {
     super(messages, language);
+    setDefaultOff();
     startSymbols = CA_START_SYMBOLS;
     endSymbols = CA_END_SYMBOLS;
     uniqueMapInit();

File: trunk/JLanguageTool/src/java/org/languagetool/language/LanguageBuilder.java
Patch:
@@ -55,9 +55,9 @@ private static Language makeLanguage(final File file, final boolean isAdditional
     }
     final String[] parts = file.getName().split("-");    
     final boolean startsWithRules = parts[0].equals("rules");
-    final boolean secondPartHasCorrectLength = 
-            (parts[1].length() == 2 || parts[1].length() == 5) || parts[1].length() == 3;
-    if (parts.length != 3 || !startsWithRules || !secondPartHasCorrectLength) {
+    final boolean secondPartHasCorrectLength = parts.length == 3 &&
+            (parts[1].length() == "en".length() || parts[1].length() == "ast".length() || parts[1].length() == "en_US".length());
+    if (!startsWithRules || !secondPartHasCorrectLength) {
       throw new RuleFilenameException(file);
     }
     //TODO: when the Language already exists, and the XML file is mergeable with

File: trunk/JLanguageTool/src/java/org/languagetool/JLanguageTool.java
Patch:
@@ -635,7 +635,7 @@ public RuleMatch adjustRuleMatchPos(final RuleMatch rm, int sentLen,
     final int lastLineBreakPosInError = sentencePartToEndOfError
         .lastIndexOf('\n');
     if (lastLineBreakPosInError == -1) {
-      endColumn = sentencePartToEndOfError.length() + columnCount + 1;
+      endColumn = sentencePartToEndOfError.length() + columnCount;
     } else {
       endColumn = sentencePartToEndOfError.length() - lastLineBreakPosInError;
     }

File: trunk/JLanguageTool/src/java/org/languagetool/Main.java
Patch:
@@ -284,6 +284,9 @@ private void runOnFileLineByLine(String filename, String encoding, boolean listU
           if (profileRules) {
             sentences += lt.sentenceTokenize(sb.toString()).size();
           }
+          if (apiFormat && !taggerOnly && !applySuggestions) {
+              System.out.println("</matches>");
+          }
           if (listUnknownWords && !taggerOnly) {
             for (String word : lt.getUnknownWords()) {
               if (!unknownWords.contains(word)) {

File: trunk/JLanguageTool/src/java/org/languagetool/rules/patterns/XMLRuleHandler.java
Patch:
@@ -457,9 +457,9 @@ protected List<Match> addLegacyMatches() {
     int matchCounter = 0;
     while (pos != -1) {
       pos = messageStr.indexOf('\\', ind + 1);
-      if (pos != -1 && messageStr.length() > pos) {
+      if (pos != -1 && messageStr.length() > pos)              {
         if (Character.isDigit(messageStr.charAt(pos + 1))) {
-          if (pos == 1 || messageStr.charAt(pos - 1) != '\u0001') {
+          if (pos == 0 || messageStr.charAt(pos - 1) != '\u0001') {
             final Match mWorker = new Match(null, null, false, null, 
                 null, Match.CaseConversion.NONE, false, false, Match.IncludeRange.NONE);
             mWorker.setInMessageOnly(true);
@@ -473,6 +473,7 @@ protected List<Match> addLegacyMatches() {
       }
       ind = pos;
     }
+            
     if (sugMatch.isEmpty()) {
       return suggestionMatches;
     }

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/PatternRuleQueryBuilder.java
Patch:
@@ -83,7 +83,7 @@ private SpanQuery next(Iterator<Element> it, boolean throwExceptionOnUnsupported
       } else {
         // create an empty token for the unsupported token, so that it can match any term with any
         // POS tag.
-        if (patternElement.hasExceptionList() && !patternElement.getString().isEmpty()) {
+        if (patternElement.hasExceptionList() && !patternElement.isInflected() && !patternElement.getString().isEmpty()) {
           // having an exception causes the rule not to be supported but we can ignore it
           // and search for the token to get a super set of matches:
           tokenQuery = createTokenQuery(patternElement.getString(), patternElement.getNegation(),
@@ -155,6 +155,7 @@ private void checkUnsupportedRule(Element patternElement)
       throw new UnsupportedPatternRuleException(
           "Pattern rules with inflected tokens are not supported.");
     }
+    // TODO: exception for <match no="0"/> etc. (patternElement.getMatch()?)
   }
 
   private SpanQuery createTokenQuery(String token, boolean isNegation,

File: trunk/JLanguageTool/src/java/org/languagetool/Main.java
Patch:
@@ -483,12 +483,12 @@ public static void main(final String[] args) throws IOException, ParserConfigura
 
   // for language auto detect
   // TODO: alter tika's language profiles so they are in line with LT's supported languages
-  private static Language detectLanguageOfFile(String filename, String encoding) throws IOException {
+  private static Language detectLanguageOfFile(final String filename, final String encoding) throws IOException {
     final String text = StringTools.readFile(new FileInputStream(filename), encoding);
     return detectLanguageOfString(text);
   }
 
-  private static Language detectLanguageOfString(String text) {
+  private static Language detectLanguageOfString(final String text) {
     final LanguageIdentifier identifier = new LanguageIdentifier(text);
     final Language lang = Language.getLanguageForShortName(identifier.getLanguage());
     return lang;

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/PatternRuleQueryBuilder.java
Patch:
@@ -83,13 +83,13 @@ private SpanQuery next(Iterator<Element> it, boolean throwExceptionOnUnsupported
       } else {
         // create an empty token for the unsupported token, so that it can match any term with any
         // POS tag.
-        if (patternElement.hasExceptionList()) {
+        if (patternElement.hasExceptionList() && !patternElement.getString().isEmpty()) {
           // having an exception causes the rule not to be supported but we can ignore it
           // and search for the token to get a super set of matches:
           tokenQuery = createTokenQuery(patternElement.getString(), patternElement.getNegation(),
                   patternElement.isRegularExpression(), patternElement.getCaseSensitive());
         } else {
-          tokenQuery = createTokenQuery("", false, false, false);
+          tokenQuery = new POSAwaredSpanRegexQuery(new Term(FIELD_NAME, ".*"), false);
         }
       }
 

File: trunk/JLanguageTool/src/java/org/languagetool/JLanguageTool.java
Patch:
@@ -637,7 +637,7 @@ public RuleMatch adjustRuleMatchPos(final RuleMatch rm, int sentLen,
     if (lastLineBreakPosInError == -1) {
       endColumn = sentencePartToEndOfError.length() + columnCount + 1;
     } else {
-      endColumn = sentencePartToEndOfError.length() - lastLineBreakPos;
+      endColumn = sentencePartToEndOfError.length() - lastLineBreakPosInError;
     }
     final int lineBreaksToError = countLineBreaks(sentencePartToError);
     final int lineBreaksToEndOfError = countLineBreaks(sentencePartToEndOfError);

File: trunk/JLanguageTool/src/java/org/languagetool/language/Belarusian.java
Patch:
@@ -71,7 +71,7 @@ public Tagger getTagger() {
       @Override
     public SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-       sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+       sentenceTokenizer = new SRXSentenceTokenizer(this);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/language/Catalan.java
Patch:
@@ -126,7 +126,7 @@ public final Synthesizer getSynthesizer() {
   @Override
   public final SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-      sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+      sentenceTokenizer = new SRXSentenceTokenizer(this);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/language/Danish.java
Patch:
@@ -74,7 +74,7 @@ public final Tagger getTagger() {
   @Override
   public SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-      sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+      sentenceTokenizer = new SRXSentenceTokenizer(this);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/language/Dutch.java
Patch:
@@ -91,7 +91,7 @@ public final Synthesizer getSynthesizer() {
   @Override
   public final SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-      sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+      sentenceTokenizer = new SRXSentenceTokenizer(this);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/language/English.java
Patch:
@@ -55,7 +55,7 @@ public Language getDefaultVariant() {
   @Override
   public final SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-      sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+      sentenceTokenizer = new SRXSentenceTokenizer(this);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/language/Esperanto.java
Patch:
@@ -47,7 +47,7 @@ public Locale getLocale() {
   @Override
   public final SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-      sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+      sentenceTokenizer = new SRXSentenceTokenizer(this);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/language/Galician.java
Patch:
@@ -55,7 +55,7 @@ public final Locale getLocale() {
   @Override
   public final SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-      sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+      sentenceTokenizer = new SRXSentenceTokenizer(this);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/language/German.java
Patch:
@@ -80,7 +80,7 @@ public Tagger getTagger() {
   @Override
   public SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-      sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+      sentenceTokenizer = new SRXSentenceTokenizer(this);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/language/Greek.java
Patch:
@@ -100,7 +100,7 @@ public final Tagger getTagger() {
     @Override
     public final SentenceTokenizer getSentenceTokenizer() {
         if (sentenceTokenizer == null) {
-            sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+            sentenceTokenizer = new SRXSentenceTokenizer(this);
         }
         return sentenceTokenizer;
     }

File: trunk/JLanguageTool/src/java/org/languagetool/language/Icelandic.java
Patch:
@@ -73,7 +73,7 @@ public Tagger getTagger() {
   @Override
   public SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-      sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+      sentenceTokenizer = new SRXSentenceTokenizer(this);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/language/Khmer.java
Patch:
@@ -73,7 +73,7 @@ public Tagger getTagger() {
   @Override
   public SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-      sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+      sentenceTokenizer = new SRXSentenceTokenizer(this);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/language/Malayalam.java
Patch:
@@ -44,7 +44,7 @@ public final Locale getLocale() {
   @Override
   public final SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-      sentenceTokenizer = new SRXSentenceTokenizer("en");
+      sentenceTokenizer = new SRXSentenceTokenizer(Language.ENGLISH);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/language/Polish.java
Patch:
@@ -79,7 +79,7 @@ public Tagger getTagger() {
   @Override
   public SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-      sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+      sentenceTokenizer = new SRXSentenceTokenizer(this);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/language/Portuguese.java
Patch:
@@ -81,7 +81,7 @@ public Tagger getTagger() {
 	  @Override
 	  public SentenceTokenizer getSentenceTokenizer() {
 	    if (sentenceTokenizer == null) {
-	      sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+	      sentenceTokenizer = new SRXSentenceTokenizer(this);
 	    }
 	    return sentenceTokenizer;
 	  }

File: trunk/JLanguageTool/src/java/org/languagetool/language/Romanian.java
Patch:
@@ -142,7 +142,7 @@ public final Tokenizer getWordTokenizer() {
   @Override
   public SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-      sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+      sentenceTokenizer = new SRXSentenceTokenizer(this);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/language/Russian.java
Patch:
@@ -93,7 +93,7 @@ public Synthesizer getSynthesizer() {
   @Override
   public SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-       sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+       sentenceTokenizer = new SRXSentenceTokenizer(this);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/language/Slovak.java
Patch:
@@ -87,7 +87,7 @@ public Synthesizer getSynthesizer() {
   @Override
   public SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-      sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+      sentenceTokenizer = new SRXSentenceTokenizer(this);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/language/Slovenian.java
Patch:
@@ -63,7 +63,7 @@ public String[] getUnpairedRuleEndSymbols() {
   @Override
   public SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-      sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+      sentenceTokenizer = new SRXSentenceTokenizer(this);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/language/Spanish.java
Patch:
@@ -130,7 +130,7 @@ public final Synthesizer getSynthesizer() {
   @Override
   public final SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-      sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+      sentenceTokenizer = new SRXSentenceTokenizer(this);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/language/Ukrainian.java
Patch:
@@ -76,7 +76,7 @@ public Tagger getTagger() {
   @Override
   public SentenceTokenizer getSentenceTokenizer() {
     if (sentenceTokenizer == null) {
-       sentenceTokenizer = new SRXSentenceTokenizer(getShortName());
+       sentenceTokenizer = new SRXSentenceTokenizer(this);
     }
     return sentenceTokenizer;
   }

File: trunk/JLanguageTool/src/test/org/languagetool/tagging/disambiguation/PolishChunkerTest.java
Patch:
@@ -22,6 +22,7 @@
 import java.io.IOException;
 
 import junit.framework.TestCase;
+import org.languagetool.Language;
 import org.languagetool.TestTools;
 import org.languagetool.tagging.pl.PolishTagger;
 import org.languagetool.tokenizers.SentenceTokenizer;
@@ -38,7 +39,7 @@ public class PolishChunkerTest extends TestCase {
     public void setUp() {
       tagger = new PolishTagger();
       tokenizer = new WordTokenizer();
-      sentenceTokenizer = new SRXSentenceTokenizer("pl"); 
+      sentenceTokenizer = new SRXSentenceTokenizer(Language.POLISH);
       disambiguator = new MultiWordChunker("/pl/multiwords.txt");      
     }
 

File: trunk/JLanguageTool/src/test/org/languagetool/tokenizers/RussianSRXSentenceTokenizerTest.java
Patch:
@@ -20,6 +20,7 @@
 package org.languagetool.tokenizers;
 
 import junit.framework.TestCase;
+import org.languagetool.Language;
 import org.languagetool.TestTools;
 
 /*
@@ -31,9 +32,9 @@
 public class RussianSRXSentenceTokenizerTest extends TestCase {
 
   // accept \n as paragraph:
-  private SentenceTokenizer stokenizer = new SRXSentenceTokenizer("ru");
+  private final SentenceTokenizer stokenizer = new SRXSentenceTokenizer(Language.RUSSIAN);
   // accept only \n\n as paragraph:
-  private SentenceTokenizer stokenizer2 = new SRXSentenceTokenizer("ru");
+  private final SentenceTokenizer stokenizer2 = new SRXSentenceTokenizer(Language.RUSSIAN);
   
   
   public final void setUp() {

File: trunk/JLanguageTool/src/test/org/languagetool/tokenizers/SRXSentenceTokenizerTest.java
Patch:
@@ -28,9 +28,9 @@
 public class SRXSentenceTokenizerTest extends TestCase {
 
   // accept \n as paragraph:
-  private SentenceTokenizer stokenizer = new SRXSentenceTokenizer("en");
+  private final SentenceTokenizer stokenizer = new SRXSentenceTokenizer(Language.ENGLISH);
   // accept only \n\n as paragraph:
-  private SentenceTokenizer stokenizer2 = new SRXSentenceTokenizer("en");
+  private final SentenceTokenizer stokenizer2 = new SRXSentenceTokenizer(Language.ENGLISH);
 
   public void setUp() {
     stokenizer.setSingleLineBreaksMarksParagraph(true);  
@@ -114,7 +114,7 @@ public void testOfficeFootnoteTokenize() {
         continue;
       }
       final String input = "A sentence.\u0002 And another one.";
-      final SentenceTokenizer tokenizer = new SRXSentenceTokenizer(language.getShortName());
+      final SentenceTokenizer tokenizer = new SRXSentenceTokenizer(language);
       assertEquals("Sentence not split correctly for " + language + ": '" + input + "'",
               "[A sentence.\u0002 , And another one.]", tokenizer.tokenize(input).toString());
     }

File: trunk/JLanguageTool/src/test/org/languagetool/tokenizers/da/DanishSRXSentenceTokenizerTest.java
Patch:
@@ -19,6 +19,7 @@
 package org.languagetool.tokenizers.da;
 
 import junit.framework.TestCase;
+import org.languagetool.Language;
 import org.languagetool.TestTools;
 import org.languagetool.tokenizers.SRXSentenceTokenizer;
 
@@ -28,7 +29,7 @@
 public class DanishSRXSentenceTokenizerTest extends TestCase {
 
   // accept \n as paragraph:
-  private final SRXSentenceTokenizer stokenizer = new SRXSentenceTokenizer("da");
+  private final SRXSentenceTokenizer stokenizer = new SRXSentenceTokenizer(Language.DANISH);
 
   public void setUp() {
     stokenizer.setSingleLineBreaksMarksParagraph(true);

File: trunk/JLanguageTool/src/test/org/languagetool/tokenizers/de/GermanSRXSentenceTokenizerTest.java
Patch:
@@ -19,6 +19,7 @@
 package org.languagetool.tokenizers.de;
 
 import junit.framework.TestCase;
+import org.languagetool.Language;
 import org.languagetool.TestTools;
 import org.languagetool.tokenizers.SRXSentenceTokenizer;
 
@@ -28,9 +29,9 @@
 public class GermanSRXSentenceTokenizerTest extends TestCase {
 
   // accept \n as paragraph:
-  private SRXSentenceTokenizer stokenizer = new SRXSentenceTokenizer("de");
+  private final SRXSentenceTokenizer stokenizer = new SRXSentenceTokenizer(Language.GERMAN);
   // accept only \n\n as paragraph:
-  private SRXSentenceTokenizer stokenizer2 = new SRXSentenceTokenizer("de");
+  private final SRXSentenceTokenizer stokenizer2 = new SRXSentenceTokenizer(Language.GERMAN);
   
   public void setUp() {
     stokenizer.setSingleLineBreaksMarksParagraph(true);  

File: trunk/JLanguageTool/src/test/org/languagetool/tokenizers/nl/DutchSRXSentenceTokenizerTest.java
Patch:
@@ -19,6 +19,7 @@
 package org.languagetool.tokenizers.nl;
 
 import junit.framework.TestCase;
+import org.languagetool.Language;
 import org.languagetool.TestTools;
 import org.languagetool.tokenizers.SRXSentenceTokenizer;
 
@@ -28,7 +29,7 @@
  */
 public class DutchSRXSentenceTokenizerTest extends TestCase {
 
-  private SRXSentenceTokenizer stokenizer = new SRXSentenceTokenizer("nl");
+  private final SRXSentenceTokenizer stokenizer = new SRXSentenceTokenizer(Language.DUTCH);
 
   public void setUp() {
     stokenizer.setSingleLineBreaksMarksParagraph(true);  

File: trunk/JLanguageTool/src/test/org/languagetool/tokenizers/ro/RomanianSentenceTokenizerTest.java
Patch:
@@ -19,6 +19,7 @@
 package org.languagetool.tokenizers.ro;
 
 import junit.framework.TestCase;
+import org.languagetool.Language;
 import org.languagetool.TestTools;
 import org.languagetool.tokenizers.SRXSentenceTokenizer;
 import org.languagetool.tokenizers.SentenceTokenizer;
@@ -32,9 +33,9 @@
 public class RomanianSentenceTokenizerTest extends TestCase {
 
 	  // accept \n as paragraph:
-	  private SentenceTokenizer stokenizer = new SRXSentenceTokenizer("ro");
+	  private final SentenceTokenizer stokenizer = new SRXSentenceTokenizer(Language.ROMANIAN);
 	  // accept only \n\n as paragraph:
-	  private SentenceTokenizer stokenizer2 = new SRXSentenceTokenizer("ro");
+	  private final SentenceTokenizer stokenizer2 = new SRXSentenceTokenizer(Language.ROMANIAN);
 
 	  public final void setUp() {
 	    stokenizer.setSingleLineBreaksMarksParagraph(true);

File: trunk/JLanguageTool/src/java/org/languagetool/rules/de/CaseRule.java
Patch:
@@ -391,7 +391,7 @@ public RuleMatch[] match(final AnalyzedSentence text) throws IOException {
     
     boolean prevTokenIsDas = false;
     for (int i = 0; i < tokens.length; i++) {
-      //FIXME: defaulting to the first analysis don't know if it's safe
+      //Note: defaulting to the first analysis is only save if we only query for sentence start
       final String posToken = tokens[i].getAnalyzedToken(0).getPOSTag();
       if (posToken != null && posToken.equals(JLanguageTool.SENTENCE_START_TAGNAME)) {
         continue;
@@ -411,7 +411,7 @@ public RuleMatch[] match(final AnalyzedSentence text) throws IOException {
       AnalyzedGermanTokenReadings analyzedGermanToken2;
       
       boolean isBaseform = false;
-      if (analyzedToken.getReadingsLength() >= 1 && token.equals(analyzedToken.getAnalyzedToken(0).getLemma())) {
+      if (analyzedToken.getReadingsLength() >= 1 && analyzedToken.hasLemma(token)) {
         isBaseform = true;
       }
       if ((readings == null || analyzedToken.getAnalyzedToken(0).getPOSTag() == null || analyzedToken.hasReadingOfType(GermanToken.POSType.VERB))

File: trunk/JLanguageTool/src/java/org/languagetool/Main.java
Patch:
@@ -218,7 +218,7 @@ private void runOnFileLineByLine(String filename, String encoding, boolean listU
     int tmpLineOffset = 0;
     final List<String> unknownWords = new ArrayList<String>();
     StringBuilder sb = new StringBuilder();
-    for (int ruleIndex = 0; ruleIndex < runCount; ruleIndex++) {
+    for (int ruleIndex = 0; !rules.isEmpty() && ruleIndex < runCount; ruleIndex++) {
       currentRule = rules.get(ruleIndex);
       int matches = 0;
       long sentences = 0;

File: trunk/JLanguageTool/src/java/org/languagetool/language/PortuguesePortugal.java
Patch:
@@ -1,5 +1,5 @@
 /* LanguageTool, a natural language style checker 
- * Copyright (C) 2007 Daniel Naber (http://www.danielnaber.de)
+ * Copyright (C) 2012 Daniel Naber (http://www.danielnaber.de)
  * 
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -22,7 +22,7 @@ public class PortuguesePortugal extends Portuguese {
 
 	  @Override
 	  public String getName() {
-	    return "Portuguese (Brazil)";
+	    return "Portuguese (Portugal)";
 	  }
 
 	  @Override

File: trunk/JLanguageTool/src/java/org/languagetool/language/Polish.java
Patch:
@@ -22,7 +22,6 @@
 
 import org.languagetool.Language;
 import org.languagetool.rules.*;
-import org.languagetool.rules.spelling.hunspell.HunspellRule;
 import org.languagetool.rules.patterns.Unifier;
 import org.languagetool.rules.pl.CompoundRule;
 import org.languagetool.rules.pl.PolishUnpairedBracketsRule;

File: trunk/JLanguageTool/src/java/org/languagetool/openoffice/Main.java
Patch:
@@ -67,6 +67,7 @@
 import org.languagetool.Language;
 import org.languagetool.gui.Configuration;
 import org.languagetool.rules.RuleMatch;
+import org.languagetool.rules.spelling.hunspell.HunspellRule;
 import org.languagetool.tools.StringTools;
 import org.languagetool.tools.Tools;
 
@@ -284,6 +285,7 @@ private synchronized ProofreadingResult doGrammarCheckingInternal(
             langTool = new JLanguageTool(docLanguage, config.getMotherTongue());
             langTool.activateDefaultPatternRules();
             langTool.activateDefaultFalseFriendRules();
+            langTool.disableRule(HunspellRule.RULE_ID);
             recheck = false;
           } catch (final Throwable t) {
             showError(t);

File: trunk/JLanguageTool/src/java/org/languagetool/Language.java
Patch:
@@ -381,6 +381,7 @@ private static Language getLanguageForLanguageNameAndCountry(Locale locale) {
     return null;
   }
 
+  //FIXME: if the list of languages ever gets sorted, we might get unexpected results! 
   private static Language getLanguageForLanguageNameOnly(Locale locale) {
     for (Language language : Language.REAL_LANGUAGES) {
       if (language.getShortName().equals(locale.getLanguage()) && !language.hasVariant()) {

File: trunk/JLanguageTool/src/java/org/languagetool/server/LanguageToolHttpHandler.java
Patch:
@@ -267,7 +267,8 @@ private void configureGUI(JLanguageTool langTool) {
    * @return an xml string containing all supported languages.
    */
   public static String getSupportedLanguagesAsXML() {
-    final List<Language> languages = Arrays.asList(Language.REAL_LANGUAGES);
+    Language[] languageCopy = Language.REAL_LANGUAGES.clone();
+    final List<Language> languages = Arrays.asList(languageCopy);
     Collections.sort(languages, new Comparator<Language>() {
       @Override
       public int compare(Language o1, Language o2) {

File: trunk/JLanguageTool/src/java/org/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -401,7 +401,7 @@ public String getHistoricalAnnotations() {
  * @param historicalAnnotations the historicalAnnotations to set
  */
 public void setHistoricalAnnotations(String historicalAnnotations) {
-    this.historicalAnnotations = this.historicalAnnotations + "\n" + historicalAnnotations;
+    this.historicalAnnotations = historicalAnnotations;
 }
   
 }

File: trunk/JLanguageTool/src/test/org/languagetool/rules/patterns/UnifierTest.java
Patch:
@@ -200,7 +200,7 @@ public void testUnificationNumberGender() {
     satisfied &= uni.isSatisfied(sing2, equiv);
     uni.startNextToken();
     assertEquals(true, satisfied);
-    assertEquals("[mały/adj:sg:blahblah:m, człowiek/subst:sg:blahblah:m]", Arrays.toString(uni.getUnifiedTokens()));
+    assertEquals("[mały[mały/adj:sg:blahblah:m], człowiek[człowiek/subst:sg:blahblah:m]]", Arrays.toString(uni.getUnifiedTokens()));
     uni.reset();
   }
 
@@ -259,7 +259,7 @@ public void testMultipleFeats() {
     uni.isUnified(sing1a, equiv, false);
     uni.isUnified(sing1b, equiv, true);    
     assertEquals(true, uni.isUnified(sing2, equiv, true));
-    assertEquals("[osobisty/adj:sg:nom.acc.voc:n:pos:aff, godło/subst:sg:nom.acc.voc:n]", Arrays.toString(uni.getFinalUnified()));
+    assertEquals("[osobiste[osobisty/adj:sg:nom.acc.voc:n:pos:aff], godło[godło/subst:sg:nom.acc.voc:n]]", Arrays.toString(uni.getFinalUnified()));
     uni.reset();
 
     //now test a case when the last reading doesn't match at all
@@ -273,7 +273,7 @@ public void testMultipleFeats() {
     uni.isUnified(sing1b, equiv, true);
     uni.isUnified(sing2a, equiv, false);
     assertEquals(true, uni.isUnified(sing2b, equiv, true));
-    assertEquals("[osobisty/adj:sg:nom.acc.voc:n:pos:aff, godło/subst:sg:nom.acc.voc:n]", Arrays.toString(uni.getFinalUnified()));
+    assertEquals("[osobiste[osobisty/adj:sg:nom.acc.voc:n:pos:aff], godło[godło/subst:sg:nom.acc.voc:n]]", Arrays.toString(uni.getFinalUnified()));
     uni.reset();
   }
 

File: trunk/JLanguageTool/src/java/org/languagetool/rules/spelling/hunspell/HunspellRule.java
Patch:
@@ -49,6 +49,8 @@
  */
 public class HunspellRule extends SpellingCheckRule {
 
+  public static final String RULE_ID = "HUNSPELL_RULE";
+
   private final static String NON_ALPHABETIC = "[^\\p{L}]";
 
   /** The dictionary file */
@@ -64,7 +66,7 @@ public HunspellRule(final ResourceBundle messages, final Language language)
 
 	@Override
 	public String getId() {
-		return "HUNSPELL_RULE";
+		return RULE_ID;
 	}
 
 	@Override

File: trunk/JLanguageTool/src/test/org/languagetool/rules/patterns/FalseFriendRuleTest.java
Patch:
@@ -52,7 +52,7 @@ public void testHintsForEnglishSpeakers() throws IOException, ParserConfiguratio
     langTool.activateDefaultFalseFriendRules();
     assertErrors(1, "Man sollte ihn nicht so beraten.", langTool);
     assertErrors(0, "Man sollte ihn nicht so beschimpfen.", langTool);
-    assertErrors(2, "Ich gehe in Blubbstadt zur Hochschule.", langTool);
+    assertErrors(1, "Ich gehe in Blubbstadt zur Hochschule.", langTool);
   }
 
   public void testHintsForPolishSpeakers() throws IOException, ParserConfigurationException, SAXException {

File: trunk/JLanguageTool/src/test/org/languagetool/rules/HunspellRuleTest.java
Patch:
@@ -56,6 +56,8 @@ public void testRule() throws UnsatisfiedLinkError, UnsupportedOperationExceptio
 	    assertEquals(4, matches[0].getToPos());	    
 	    assertEquals("Żółw", matches[0].getSuggestedReplacements().get(0));
 	    	    
+	    assertEquals(1, rule.match(langTool.getAnalyzedSentence("aõh")).length);
+	    assertEquals(0, rule.match(langTool.getAnalyzedSentence("a")).length);
 	}
 
 }

File: trunk/JLanguageTool/src/java/org/languagetool/gui/LanguageComboBox.java
Patch:
@@ -44,7 +44,8 @@ void populateLanguageBox() {
   private List<I18nLanguage> getAllLanguages() {
     final List<I18nLanguage> i18nLanguages = new ArrayList<I18nLanguage>();
     for (Language language : Language.LANGUAGES) {
-      if (language != Language.DEMO) {
+      final boolean skip = (language == Language.DEMO) || language.hasVariant();
+      if (!skip) {
         i18nLanguages.add(new I18nLanguage(language, messages));
       }
     }

File: trunk/JLanguageTool/src/java/org/languagetool/gui/Main.java
Patch:
@@ -560,6 +560,7 @@ private int checkText(final JLanguageTool langTool, final String text,
     
     final List<RuleMatch> ruleMatches = langTool.check(text);
     final long startTimeMatching = System.currentTimeMillis();
+    final ContextTools contextTools = new ContextTools();
     int i = 0;
     for (final RuleMatch match : ruleMatches) {
       final String output = Tools.makeTexti18n(messages, "result1",
@@ -579,8 +580,7 @@ private int checkText(final JLanguageTool langTool, final String text,
         sb.append("<b>" + messages.getString("correctionMessage") + "</b> "
             + repl + "<br>\n");
       }
-      final String context = Tools.getContext(match.getFromPos(), match
-          .getToPos(), text);
+      final String context = contextTools.getContext(match.getFromPos(), match.getToPos(), text);
       sb.append("<b>" + messages.getString("errorContext") + "</b> " + context);
       sb.append("<br>\n");
       if (match.getRule().getUrl() != null && Desktop.isDesktopSupported()) {

File: trunk/JLanguageTool/src/java/org/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -176,7 +176,7 @@ public final void removeReading(final AnalyzedToken token) {
       }
     }
     if (l.isEmpty()) {
-        l.add(new AnalyzedToken(anTokReadings[0].getToken(), null, null));
+        l.add(new AnalyzedToken(this.token, null, null));
     }
     anTokReadings = l.toArray(new AnalyzedToken[l.size()]);
     setNoRealPOStag();
@@ -198,7 +198,7 @@ public final void leaveReading(final AnalyzedToken token) {
       }
     }
     if (l.isEmpty()) {
-        l.add(new AnalyzedToken(anTokReadings[0].getToken(), null, null));
+        l.add(new AnalyzedToken(this.token, null, null));
     }
     anTokReadings = l.toArray(new AnalyzedToken[l.size()]);
     setNoRealPOStag();

File: trunk/JLanguageTool/src/java/org/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -176,7 +176,7 @@ public final void removeReading(final AnalyzedToken token) {
       }
     }
     if (l.isEmpty()) {
-        l.add(new AnalyzedToken(token.getToken(), null, null));
+        l.add(new AnalyzedToken(anTokReadings[0].getToken(), null, null));
     }
     anTokReadings = l.toArray(new AnalyzedToken[l.size()]);
     setNoRealPOStag();
@@ -198,7 +198,7 @@ public final void leaveReading(final AnalyzedToken token) {
       }
     }
     if (l.isEmpty()) {
-        l.add(new AnalyzedToken(token.getToken(), null, null));
+        l.add(new AnalyzedToken(anTokReadings[0].getToken(), null, null));
     }
     anTokReadings = l.toArray(new AnalyzedToken[l.size()]);
     setNoRealPOStag();

File: trunk/JLanguageTool/src/java/org/languagetool/language/AustralianEnglish.java
Patch:
@@ -41,7 +41,7 @@ public List<Class<? extends Rule>> getRelevantRules() {
     final List<Class<? extends Rule>> rules = new ArrayList<Class<? extends Rule>>();
     rules.addAll(super.getRelevantRules());
     rules.add(HunspellRule.class);
-    // nothing specific to Canadian English yet...
+    // nothing specific to Australian English yet...
     return rules;
   }
 

File: trunk/JLanguageTool/src/java/org/languagetool/rules/patterns/XMLRuleHandler.java
Patch:
@@ -513,9 +513,6 @@ protected void finalizeTokens() {
 
     if (inUnification) {
       tokenElement.setUnification(equivalenceFeatures);
-      if (uniNegation) {
-        tokenElement.setUniNegation();
-      }
     }
 
     if (inUnificationDef) {

File: trunk/JLanguageTool/src/java/org/languagetool/language/Esperanto.java
Patch:
@@ -103,7 +103,7 @@ public List<Class<? extends Rule>> getRelevantRules() {
             CommaWhitespaceRule.class,
             DoublePunctuationRule.class,
             GenericUnpairedBracketsRule.class,
-            HunspellRule.class,
+            //HunspellRule.class,
             UppercaseSentenceStartRule.class,
             WordRepeatRule.class,
             WhitespaceRule.class

File: trunk/JLanguageTool/src/java/org/languagetool/rules/spelling/hunspell/HunspellLibrary.java
Patch:
@@ -56,5 +56,5 @@ public interface HunspellLibrary extends Library {
      * @param word The word to offer suggestions for.
      */
     public int Hunspell_suggest(Pointer pHunspell, PointerByReference slst, byte[] word);
-
+            
 }

File: trunk/JLanguageTool/src/test/org/languagetool/rules/UppercaseSentenceStartRuleTest.java
Patch:
@@ -40,7 +40,7 @@ public void testRule() throws IOException {
     matches = langTool.check("Dies ist ein Satz. Ätsch, noch einer mit Umlaut.");
     assertEquals(0, matches.size());
     matches = langTool.check("Dieser Satz ist bspw. okay so.");
-    assertEquals(1, matches.size());
+    assertEquals(0, matches.size());
     matches = langTool.check("Dieser Satz ist z.B. okay so.");
     assertEquals(0, matches.size());
     matches = langTool.check("Dies ist ein Satz. \"Aber der hier auch!\".");

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/disambiguation/rules/DisambiguationRuleLoader.java
Patch:
@@ -173,7 +173,7 @@ public void startElement(final String namespaceURI, final String lName,
           .equals(attrs.getValue(POSTAG_REGEXP)), attrs
           .getValue("regexp_match"), attrs.getValue("regexp_replace"),
           caseConversion, YES.equals(attrs.getValue("setpos")),
-          YES.equals(attrs.getValue("supress_mispelled")),
+          YES.equals(attrs.getValue("suppress_mispelled")),
           includeRange);
       if (inDisambiguation) {
         if (attrs.getValue(NO) != null) {

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/RuleOverview.java
Patch:
@@ -90,6 +90,7 @@ private void run(File webRoot) throws IOException {
       } else {
         System.out.print("<td valign=\"top\">" + lang.getName() + "</td>");
       }
+      //FIXME: this does not work for en-GB and en-US
       final String xmlFile = JLanguageTool.getDataBroker().getRulesDir() + File.separator + lang.getShortName() + File.separator + "grammar.xml";
       final URL url = this.getClass().getResource(xmlFile);    
       if (url == null) {

File: trunk/JLanguageTool/src/java/org/languagetool/rules/patterns/Element.java
Patch:
@@ -791,7 +791,7 @@ public final void setWhitespaceBefore(final boolean isWhite) {
 
   public final void setExceptionSpaceBefore(final boolean isWhite) {
     if (exceptionList != null) {
-      exceptionList.get(exceptionList.size()).setWhitespaceBefore(isWhite);
+      exceptionList.get(exceptionList.size() - 1).setWhitespaceBefore(isWhite);
     }
   }
 

File: trunk/JLanguageTool/src/java/org/languagetool/AnalyzedToken.java
Patch:
@@ -97,13 +97,13 @@ public final boolean matches(final AnalyzedToken an) {
     }
     boolean found = true;
     if (!"".equals(an.getToken())) { //token cannot be null
-      found &= this.token.equals(an.getToken());      
+      found &= an.getToken().equals(this.token);      
     }
     if (an.getLemma() != null) {
-      found &= this.lemma.equals(an.getLemma());             
+      found &= an.getLemma().equals(this.lemma);             
     }
     if (an.getPOSTag() != null) {
-      found &= this.posTag.equals(an.getPOSTag());      
+      found &= an.getPOSTag().equals(this.posTag);      
     }
     return found;
   }

File: trunk/JLanguageTool/src/java/org/languagetool/rules/en/AvsAnRule.java
Patch:
@@ -82,7 +82,7 @@ public RuleMatch[] match(final AnalyzedSentence text) {
       if (parts.length >= 1 && !parts[0].equalsIgnoreCase("a")) {  // avoid false alarm on "A-levels are..."
         token = parts[0];
       }
-      token = token.replaceAll("[^αa-zA-Z0-9\\.']", "");         // e.g. >>an "industry party"<<
+      token = token.replaceAll("[^αa-zA-Z0-9\\.;,:']", "");         // e.g. >>an "industry party"<<
       if (StringTools.isEmpty(token)) {
         continue;
       }

File: trunk/JLanguageTool/src/test/org/languagetool/rules/en/AvsAnRuleTest.java
Patch:
@@ -58,6 +58,8 @@ public void testRule() throws IOException {
     //fixed false alarms:
     assertCorrect("Here, a and b are supplementary angles.");
     assertCorrect("The Qur'an was translated into Polish.");
+    assertCorrect("See an:Grammatica");
+    assertCorrect("See http://www.an.com");
 
     // errors:
     assertIncorrect("It was a hour ago.");

File: trunk/JLanguageTool/src/java/org/languagetool/rules/patterns/Unifier.java
Patch:
@@ -230,7 +230,9 @@ private boolean checkNext(final AnalyzedToken aToken,
         if (tokSequence.size() == readingsCounter) {
           tokSequence.add(new AnalyzedTokenReadings(aToken, 0));
         } else {
-          tokSequence.get(readingsCounter).addReading(aToken);
+        	 if (readingsCounter<tokSequence.size()) {
+                 tokSequence.get(readingsCounter).addReading(aToken);
+               }   /* else? */        	
         }
         tmpFeaturesFound = tokenFeaturesFound;
       }

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/en/EnglishWordTokenizer.java
Patch:
@@ -44,7 +44,7 @@ public List<String> tokenize(final String text) {
         + "\u2028\u2029\u202a\u202b\u202c\u202d\u202e\u202f"
         + "\u205F\u2060\u2061\u2062\u2063\u206A\u206b\u206c\u206d"
         + "\u206E\u206F\u3000\u3164\ufeff\uffa0\ufff9\ufffa\ufffb"  
-        + ",.;()[]{}!?:\"'’‘„“”…\\/\t\n", true);
+        + "—,.;()[]{}!?:\"'’‘„“”…\\/\t\n", true);
     while (st.hasMoreElements()) {
       tokens.add(st.nextToken());
     }

File: trunk/JLanguageTool/src/test/org/languagetool/rules/HunspellRuleTest.java
Patch:
@@ -54,7 +54,7 @@ public void testRule() throws UnsatisfiedLinkError, UnsupportedOperationExceptio
 	    assertEquals(1, matches.length);
 	    assertEquals(0, matches[0].getFromPos());
 	    assertEquals(4, matches[0].getToPos());	    
-	    assertEquals("Żółw", matches[0].getSuggestedReplacements().get(9));
+	    assertEquals("Żółw", matches[0].getSuggestedReplacements().get(0));
 	    	    
 	}
 

File: trunk/JLanguageTool/src/test/org/languagetool/tools/ToolsTest.java
Patch:
@@ -46,7 +46,7 @@ public void testCheck() throws IOException, ParserConfigurationException, SAXExc
     assertEquals(0, output.indexOf("Time:"));
     assertEquals(0, matches);
 
-    matches = Tools.checkText("To jest jest problem.", tool);
+    matches = Tools.checkText("To jest problem problem.", tool);
     output = new String(this.out.toByteArray());
     assertTrue(output.contains("Rule ID: WORD_REPEAT_RULE"));
     assertEquals(1, matches);

File: trunk/JLanguageTool/src/java/org/languagetool/rules/de/DashRule.java
Patch:
@@ -66,8 +66,8 @@ public RuleMatch[] match(final AnalyzedSentence text) {
           && prevToken.endsWith("-")) {
         final char firstChar = token.charAt(0);
         if (Character.isUpperCase(firstChar)) {
-          final String msg = "Möglicherweise fehlt ein 'und' oder es wurde nach dem Wort " +
-          "ein überflüssiges Leerzeichen eingefügt.";
+          final String msg = "Möglicherweise fehlt ein 'und' oder ein Komma, oder es wurde nach dem Wort " +
+          "ein überflüssiges Leerzeichen eingefügt. Eventuell haben Sie auch versehentlich einen Bindestrich statt eines Punktes eingefügt.";
           final RuleMatch ruleMatch = new RuleMatch(this, tokens[i-1].getStartPos(),
               tokens[i-1].getStartPos()+prevToken.length()+1, msg);
           ruleMatch.setSuggestedReplacement(tokens[i-1].getToken());

File: trunk/JLanguageTool/src/test/org/languagetool/JLanguageToolTest.java
Patch:
@@ -124,12 +124,12 @@ public void testPolish() throws IOException {
     tool.activateDefaultPatternRules();
     matches = tool.check("Premier drapie się w ucho co i rusz.");
     assertEquals(1, matches.size());
-    // Polish rule has no effect with English error:
+    // Polish rule has no effect with English error but will get spelling activated:
     matches = tool.check("I can give you more a detailed description");
-    assertEquals(0, matches.size());
+    assertEquals(5, matches.size());
     tool.setListUnknownWords(true);
     matches = tool.check("This is not a Polish text.");
-    assertEquals(0, matches.size());
+    assertEquals(3, matches.size());
     assertEquals("[Polish, This, is]", tool.getUnknownWords().toString());
     //check positions relative to sentence ends    
     matches = tool.check("To jest tekst.\nTest 1. To jest linia w której nie ma przecinka.");

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/MarkerConverter.java
Patch:
@@ -45,7 +45,7 @@
  */
 public class MarkerConverter {
 
-  private static final Language LANGUAGE = Language.CATALAN;
+  private static final Language LANGUAGE = Language.GERMAN;
 
   public static void main(String[] args) throws SAXException, ParserConfigurationException, IOException {
     final ConverterHandler handler = new ConverterHandler();
@@ -122,7 +122,7 @@ public void startElement(final String namespaceURI, final String lName,
           if (qName1.equals("mark_from") || qName1.equals("mark_to")) {
             continue;
           }
-          System.out.print(" " + qName1 + "=\"" + attrs.getValue(qName1) + "\"");
+          System.out.print(" " + qName1 + "=\"" + StringTools.escapeXML(attrs.getValue(qName1)) + "\"");
         }
         System.out.print(">");
       } else {

File: trunk/JLanguageTool/src/java/org/languagetool/rules/patterns/XMLRuleHandler.java
Patch:
@@ -281,6 +281,7 @@ protected void finalizePhrase() {
   }
   
   protected void startPattern(final Attributes attrs) throws SAXException {
+    tokenCounter = 0;
     inPattern = true;
     if (attrs.getValue(MARK_FROM) != null) {
       startPositionCorrection = Integer.parseInt(attrs.getValue(MARK_FROM));
@@ -458,7 +459,7 @@ protected void checkPositions(final int add) throws SAXException {
           + pLocator.getLineNumber() + ", column: "
           + pLocator.getColumnNumber() + ".");
     }
-    if (tokenCounter +add - endPositionCorrection < 0) {
+    if (tokenCounter + add - endPositionCorrection < 0) {
       throw new SAXException(
           "Attempt to mark a token no. ("+ endPositionCorrection +") that is outside the pattern ("
           + tokenCounter + " elements). End positions should be negative but not larger than the token count!"

File: trunk/JLanguageTool/src/test/org/languagetool/MainTest.java
Patch:
@@ -76,7 +76,7 @@ public void testUsageMessage() throws IOException, ParserConfigurationException,
       fail("LT should have exited with status 0!");
     } catch (ExitException e) {
       String output = new String(this.out.toByteArray());
-      assertTrue(output.indexOf("Usage: java org.languagetool.Main [-r|--recursive] [-v|--verbose") != -1);
+      assertTrue(output.indexOf("Usage: java -jar LanguageTool.jar") != -1);
       assertEquals("Exit status", 1, e.status);
     }
   }

File: trunk/JLanguageTool/src/java/org/languagetool/rules/de/AgreementRule.java
Patch:
@@ -115,7 +115,7 @@ private GrammarCategory(String displayName) {
     "ich",
     "du",
     "er", "sie", "es",
-    //"wir",
+    "wir",
     "mir",
     "uns",
     "ihnen",

File: trunk/JLanguageTool/src/test/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -109,6 +109,7 @@ public void testDetNounRule() throws IOException {
     assertGood("Das Bielefelder Radio.");
     assertGood("Das Gütersloher Radio.");
     assertGood("Das wirklich Wichtige kommt jetzt erst.");
+    assertGood("Besonders wenn wir Wermut oder Absinth trinken.");
 
     // incorrect sentences:
     assertBad("Es sind die Tisch.");
@@ -135,9 +136,8 @@ public void testDetNounRule() throws IOException {
     assertBad("Das Dach meinem großen Autos.");
     assertBad("Das Dach mein großen Autos.");
 
-    assertBad("Erst recht wir fleißiges Arbeiter.");
-
     // TODO: not yet detected:
+    //assertBad("Erst recht wir fleißiges Arbeiter.");
     //assertBad("Erst recht ich fleißiges Arbeiter.");
     //assertBad("Das Dach meine großen Autos.");
     //assertBad("Das Dach meinen großen Autos.");

File: trunk/JLanguageTool/src/java/org/languagetool/rules/de/GermanWordRepeatRule.java
Patch:
@@ -50,7 +50,7 @@ public boolean ignore(final AnalyzedTokenReadings[] tokens, final int position)
       if (position >= 2 && ",".equals(tokens[position - 2].getToken())) {
         return true;
       }
-      if (position >= 3 && ",".equals(tokens[position - 3].getToken()) &&  tokens[position - 2].getToken().matches("auf|bei|für|in|nach|über")) {
+      if (position >= 3 && ",".equals(tokens[position - 3].getToken()) &&  tokens[position - 2].getToken().matches("ab|an|auf|bei|für|in|nach|über|zu")) {
         return true;
       }
       return false;

File: trunk/JLanguageTool/src/java/org/languagetool/language/Galician.java
Patch:
@@ -76,12 +76,12 @@ public final String[] getCountryVariants() {
   
   @Override
   public String[] getUnpairedRuleStartSymbols() {
-    return new String[]{ "[", "(", "{", "“", "«", "‘", "\"", "'" };
+    return new String[]{ "[", "(", "{", "“", "«", "»", "‘", "\"", "'" };
   }
 
   @Override
   public String[] getUnpairedRuleEndSymbols() {
-    return new String[]{ "]", ")", "}", "”", "»", "’", "\"", "'" };
+    return new String[]{ "]", ")", "}", "”", "»", "«", "’", "\"", "'" };
   }
   
   @Override

File: trunk/JLanguageTool/src/java/org/languagetool/language/German.java
Patch:
@@ -55,12 +55,12 @@ public String[] getCountryVariants() {
 
   @Override
   public String[] getUnpairedRuleStartSymbols() {
-    return new String[]{ "[", "(", "{", "„", "»", "‘" };
+    return new String[]{ "[", "(", "{", "„", "»", "«", "‘" };
   }
 
   @Override
   public String[] getUnpairedRuleEndSymbols() {
-    return new String[]{ "]", ")", "}", "“", "«", "’" };
+    return new String[]{ "]", ")", "}", "“", "«", "»", "’" };
   }
 
   @Override

File: trunk/JLanguageTool/src/java/org/languagetool/language/Italian.java
Patch:
@@ -51,12 +51,12 @@ public String[] getCountryVariants() {
 
   @Override
   public String[] getUnpairedRuleStartSymbols() {
-    return new String[]{ "[", "(", "{", "»", /*"‘"*/ };
+    return new String[]{ "[", "(", "{", "»", "«" /*"‘"*/ };
   }
 
   @Override
   public String[] getUnpairedRuleEndSymbols() {
-    return new String[]{ "]", ")", "}", "«", /*"’"*/ };
+    return new String[]{ "]", ")", "}", "«", "»" /*"’"*/ };
   }
   
   @Override

File: trunk/JLanguageTool/src/java/org/languagetool/language/Romanian.java
Patch:
@@ -74,12 +74,12 @@ public String[] getCountryVariants() {
 
   @Override
   public String[] getUnpairedRuleStartSymbols() {
-    return new String[]{ "[", "(", "{", "„", "«" };
+    return new String[]{ "[", "(", "{", "„", "«", "»" };
   }
 
   @Override
   public String[] getUnpairedRuleEndSymbols() {
-    return new String[]{ "]", ")", "}", "”", "»" };
+    return new String[]{ "]", ")", "}", "”", "»", "«" };
   }
   
   @Override

File: trunk/JLanguageTool/src/java/org/languagetool/language/Slovak.java
Patch:
@@ -59,12 +59,12 @@ public String[] getCountryVariants() {
 
   @Override
   public String[] getUnpairedRuleStartSymbols() {
-    return new String[]{ "[", "(", "{", "„", "»", "\"" };
+    return new String[]{ "[", "(", "{", "„", "»", "«", "\"" };
   }
 
   @Override
   public String[] getUnpairedRuleEndSymbols() {
-    return new String[]{ "]", ")", "}", "“", "«", "\"" };
+    return new String[]{ "]", ")", "}", "“", "«", "»", "\"" };
   }
   
   @Override

File: trunk/JLanguageTool/src/java/org/languagetool/language/Slovenian.java
Patch:
@@ -51,12 +51,12 @@ public String[] getCountryVariants() {
 
   @Override
   public String[] getUnpairedRuleStartSymbols() {
-    return new String[]{ "[", "(", "{", "„", "»", "\"" };
+    return new String[]{ "[", "(", "{", "„", "»", "«", "\"" };
   }
 
   @Override
   public String[] getUnpairedRuleEndSymbols() {
-    return new String[]{ "]", ")", "}", "”", "«", "\"" };
+    return new String[]{ "]", ")", "}", "”", "«", "»", "\"" };
   }
   
   @Override

File: trunk/JLanguageTool/src/java/org/languagetool/language/Spanish.java
Patch:
@@ -70,12 +70,12 @@ public String[] getCountryVariants() {
   
   @Override
   public String[] getUnpairedRuleStartSymbols() {
-    return new String[]{ "[", "(", "{", "“", "«", "¿", "¡" };
+    return new String[]{ "[", "(", "{", "“", "«", "»", "¿", "¡" };
   }
 
   @Override
   public String[] getUnpairedRuleEndSymbols() {
-    return new String[]{ "]", ")", "}", "”", "»", "?", "!" };
+    return new String[]{ "]", ")", "}", "”", "»", "«", "?", "!" };
   }
   
   @Override

File: trunk/JLanguageTool/src/java/org/languagetool/language/Ukrainian.java
Patch:
@@ -56,12 +56,12 @@ public String[] getCountryVariants() {
   
   @Override
   public String[] getUnpairedRuleStartSymbols() {
-    return new String[]{ "[", "(", "{", "„", "«" };
+    return new String[]{ "[", "(", "{", "„", "«", "»" };
   }
 
   @Override
   public String[] getUnpairedRuleEndSymbols() {
-    return new String[]{ "]", ")", "}", "“", "»" };
+    return new String[]{ "]", ")", "}", "“", "»", "«" };
   }
   
   @Override

File: trunk/JLanguageTool/src/java/org/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -110,6 +110,7 @@ public void startElement(final String namespaceURI, final String lName,
         throw new SAXException("Unknown language '" + languageStr + "'");
       }
     } else if ("rule".equals(qName)) {
+      shortMessage = new StringBuilder();
       id = attrs.getValue("id");
       if (inRuleGroup) {
         subId++;

File: trunk/JLanguageTool/src/java/org/languagetool/rules/patterns/bitext/BitextPatternRuleLoader.java
Patch:
@@ -115,6 +115,7 @@ public void startElement(final String namespaceURI, final String lName,
         throw new SAXException("Unknown language '" + languageStr + "'");
       }
     } else if (qName.equals("rule")) {
+      shortMessage = new StringBuilder();
       id = attrs.getValue("id");
       if (inRuleGroup)
         subId++;

File: trunk/JLanguageTool/src/test/org/languagetool/rules/WhitespaceRuleTest.java
Patch:
@@ -43,7 +43,9 @@ public void testRule() throws IOException {
       assertEquals(0, matches.length);
       matches = rule.match(langTool.getAnalyzedSentence("\n\tThis is a test sentence..."));
       assertEquals(0, matches.length);
-      
+      matches = rule.match(langTool.getAnalyzedSentence("Multiple tabs\t\tare okay"));
+      assertEquals(0, matches.length);
+
       // incorrect sentences:
       matches = rule.match(langTool.getAnalyzedSentence("This  is a test sentence."));
       assertEquals(1, matches.length);

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/uk/UkrainianMyspellTagger.java
Patch:
@@ -124,9 +124,9 @@ public final List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens)
         if (!word.equals(lowerWord)) {
           lowerPosTags = wordsToPos.get(lowerWord);
           if (lowerPosTags != null) {
-            for (String lowerPosTag : lowerPosTags)
-              analyzedTokens.add(new AnalyzedToken(lowerWord, lowerPosTag,
-                      lowerWord));
+            for (String lowerPosTag : lowerPosTags) {
+              analyzedTokens.add(new AnalyzedToken(word, lowerPosTag, lowerWord));
+            }
           }
         }
         // else {

File: trunk/JLanguageTool/src/test/org/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -108,7 +108,8 @@ public void testDetNounRule() throws IOException {
     assertGood("Das Stuttgarter Auto.");
     assertGood("Das Bielefelder Radio.");
     assertGood("Das Gütersloher Radio.");
-    
+    assertGood("Das wirklich Wichtige kommt jetzt erst.");
+
     // incorrect sentences:
     assertBad("Es sind die Tisch.");
     assertBad("Es sind das Tisch.");

File: trunk/JLanguageTool/src/java/org/languagetool/JLanguageTool.java
Patch:
@@ -517,7 +517,7 @@ public List<RuleMatch> check(final String text, boolean tokenizeText, final Para
       // calculate matching column:      
       final int lineBreakPos = sentence.indexOf('\n');
       if (lineBreakPos == -1) {
-        columnCount += sentence.length() -1;        
+        columnCount += sentence.length();
       } else {
         if (lineBreakPos == 0) {
           columnCount = sentence.length();

File: trunk/JLanguageTool/src/test/org/languagetool/tokenizers/ManualTaggerAdapter.java
Patch:
@@ -31,7 +31,7 @@ public List<AnalyzedTokenReadings> tag(List<String> sentenceTokens)
 			final List<AnalyzedToken> l = new ArrayList<AnalyzedToken>();
 			final String[] manualTags = manualTagger.lookup(word.toLowerCase());
 			if (manualTags != null) {
-				for (int i = 0; i < manualTags.length / 2; i = i + 2) {
+				for (int i = 0; i < manualTags.length; i = i + 2) {
 					l.add(new AnalyzedToken(word, manualTags[i + 1],
 							manualTags[i]));
 				}

File: trunk/JLanguageTool/src/java/org/languagetool/gui/Tools.java
Patch:
@@ -37,7 +37,7 @@
 public class Tools {
 
   private static final int DEFAULT_CONTEXT_SIZE = 40; // characters
-  private static final String MARKER_START = "<b><font color=\"red\">";
+  private static final String MARKER_START = "<b><font bgcolor=\"#ff8b8b\">";
   private static final String MARKER_END = "</font></b>";
 
   private Tools() {

File: trunk/JLanguageTool/src/java/org/languagetool/rules/de/GermanWordRepeatRule.java
Patch:
@@ -31,7 +31,7 @@ public boolean ignore(final AnalyzedTokenReadings[] tokens, final int position)
     // Don't mark error for cases like:
     // "wie Honda und Samsung, die die Bezahlung ihrer Firmenchefs..."
     // "Das Haus, in das das Kind läuft."
-    if (tokens[position - 1].getToken().length() == 3) {
+    if (tokens[position - 1].getToken().length() == 3 && tokens[position - 1].getToken().charAt(0) == 'd' ) {
       if (position >= 2 && ",".equals(tokens[position - 2].getToken())) {
         return true;
       }

File: trunk/JLanguageTool/src/test/org/languagetool/rules/WordRepeatRuleTest.java
Patch:
@@ -70,6 +70,8 @@ public void testRuleGerman() throws IOException {
     assertEquals(1, matches.length);
     matches = rule.match(langTool.getAnalyzedSentence("Das Buch, in in dem es steht."));
     assertEquals(1, matches.length);
+    matches = rule.match(langTool.getAnalyzedSentence("Das Haus, auf auf das Mädchen zurennen."));
+    assertEquals(1, matches.length);
   }
   
   public void testRulePolish() throws IOException {

File: trunk/JLanguageTool/src/java/org/languagetool/rules/en/AvsAnRule.java
Patch:
@@ -87,7 +87,7 @@ public RuleMatch[] match(final AnalyzedSentence text) {
       if (parts.length >= 1 && !parts[0].equalsIgnoreCase("a")) {  // avoid false alarm on "A-levels are..."
         token = parts[0];
       }
-      token = token.replaceAll("[^a-zA-Z0-9\\.']", "");         // e.g. >>an "industry party"<<
+      token = token.replaceAll("[^αa-zA-Z0-9\\.']", "");         // e.g. >>an "industry party"<<
       if (StringTools.isEmpty(token)) {
         continue;
       }

File: trunk/JLanguageTool/src/test/org/languagetool/rules/de/WiederVsWiderRuleTest.java
Patch:
@@ -38,8 +38,7 @@ public void testRule() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Das spiegelt die Situation.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Immer wieder spiegelt das die Situation.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Immer wieder spiegelt das die Situation wider.")).length);
-    // known to match although sentence is okay:
-    //assertEquals(0, rule.match(langTool.getAnalyzedText("Das spiegelt wieder wider, wie es läuft.")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("Das spiegelt wieder wider, wie es läuft.")).length);
     // errors:
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Das spiegelt wieder, wie es wieder läuft.")).length);
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Das spiegelt die Situation gut wieder.")).length);

File: trunk/JLanguageTool/src/java/org/languagetool/rules/de/CompoundRule.java
Patch:
@@ -37,7 +37,7 @@ public CompoundRule(final ResourceBundle messages) throws IOException {
             "Dieses Kompositum wird mit Bindestrich geschrieben.",
             "Dieses Kompositum wird zusammengeschrieben.",
             "Dieses Kompositum wird zusammen oder mit Bindestrich geschrieben.");
-    super.setShort("Hyphenation problem");
+    super.setShort("Zusammenschreibung von Komposita");
   }
 
 

File: trunk/JLanguageTool/src/java/org/languagetool/rules/WordRepeatBeginningRule.java
Patch:
@@ -111,7 +111,8 @@ public RuleMatch[] match(final AnalyzedSentence text) {
 
   @Override
   public void reset() {
-    // nothing
+    lastToken = "";
+    beforeLastToken = "";
   }
 
 }

File: trunk/JLanguageTool/src/test/org/languagetool/JLanguageToolTest.java
Patch:
@@ -53,7 +53,7 @@ public void testEnglish() throws IOException {
     assertEquals(0, tool.check("A test that should not give errors.").size());
     assertEquals(1, tool.check("A test test that should give errors.").size());
     assertEquals(0, tool.check("I can give you more a detailed description.").size());
-    assertEquals(9, tool.getAllRules().size());
+    assertEquals(10, tool.getAllRules().size());
     tool.activateDefaultPatternRules();
     assertTrue(tool.getAllRules().size() > 3);
     assertEquals(1, tool.check("I can give you more a detailed description.").size());

File: trunk/JLanguageTool/src/test/org/languagetool/rules/de/GermanWordRepeatBeginningRuleTest.java
Patch:
@@ -38,8 +38,8 @@ public void testRule() throws IOException {
     // errors:
     assertEquals(1, langTool.check("Er ist nett. Er heißt Max. Er ist 11.").size());
     assertEquals(1, langTool.check("Außerdem kommt er. Außerdem kommt sie.").size());
-    // TODO:
-    //assertEquals(0, langTool.check("Außerdem ist das ein neuer Text.").size());
+    // this used to cause false alarms because reset() was not implemented
+    assertEquals(0, langTool.check("Außerdem ist das ein neuer Text.").size());
   }
 
 }

File: trunk/JLanguageTool/src/java/org/languagetool/gui/Main.java
Patch:
@@ -725,7 +725,8 @@ static class PlainTextFileFilter extends FileFilter {
 
     @Override
     public boolean accept(final File f) {
-      return f.getName().toLowerCase().endsWith(".txt");
+        final boolean isTextFile = f.getName().toLowerCase().endsWith(".txt");
+        return isTextFile || f.isDirectory();
     }
 
     @Override

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/RuleOverview.java
Patch:
@@ -124,7 +124,7 @@ private void run() throws IOException {
       System.out.print("<td></td>");
 
       // count Java rules:
-      final File dir = new File("src/java/de/danielnaber/languagetool" + 
+      final File dir = new File("src/java/org/languagetool" + 
     		  JLanguageTool.getDataBroker().getRulesDir() + "/" + lang.getShortName());
       if (!dir.exists()) {
         System.out.print("<td valign=\"top\" align=\"right\">0</td>");

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/ExportGermanNouns.java
Patch:
@@ -20,14 +20,14 @@
 /*
  * Created on 06.05.2007
  */
-package de.danielnaber.languagetool.dev;
+package org.languagetool.dev;
 
 import java.io.*;
 import java.nio.ByteBuffer;
 import java.util.HashSet;
 import java.util.Set;
 
-import de.danielnaber.languagetool.JLanguageTool;
+import org.languagetool.JLanguageTool;
 
 import morfologik.fsa.FSA;
 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/PrintLocales.java
Patch:
@@ -16,15 +16,15 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev;
+package org.languagetool.dev;
 
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.util.Properties;
 
-import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.tools.StringTools;
+import org.languagetool.Language;
+import org.languagetool.tools.StringTools;
 
 /**
  * Used for creating ooolocales.properties file that defines a property that is

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/conversion/AtdRuleConverter.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package de.danielnaber.languagetool.dev.conversion;
+package org.languagetool.dev.conversion;
 
 import java.io.File;
 import java.io.FileInputStream;
@@ -34,7 +34,7 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import de.danielnaber.languagetool.JLanguageTool;
+import org.languagetool.JLanguageTool;
 
 import morfologik.stemming.Dictionary;
 import morfologik.stemming.DictionaryLookup;

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/conversion/RuleConverter.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package de.danielnaber.languagetool.dev.conversion;
+package org.languagetool.dev.conversion;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -27,7 +27,7 @@
 import java.util.Scanner;
 import java.util.regex.*;
 
-import de.danielnaber.languagetool.JLanguageTool;
+import org.languagetool.JLanguageTool;
 
 public abstract class RuleConverter {
 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/conversion/RuleConverterMain.java
Patch:
@@ -17,12 +17,12 @@
  * USA
  */
 
-package de.danielnaber.languagetool.dev.conversion;
+package org.languagetool.dev.conversion;
 
 import java.io.*;
 import java.util.*;
 
-import de.danielnaber.languagetool.Language;
+import org.languagetool.Language;
 
 public class RuleConverterMain {
     
@@ -37,7 +37,7 @@ public class RuleConverterMain {
     
     private static void exitWithUsageMessage() {
         System.out
-        .println("Usage: java de.danielnaber.languagetool.tools.RuleConverterMain "
+        .println("Usage: java org.languagetool.tools.RuleConverterMain "
             + "[-h|--help] [-g|--generalFiletype] [-s|--specificFiletype] [-i|--inputFile] [-a|--disambigFile] " +
             "[-d|--discardFile] [-o|--outputFile]");
         System.exit(1);

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/conversion/cg/CgAnchor.java
Patch:
@@ -1,4 +1,4 @@
-package de.danielnaber.languagetool.dev.conversion.cg;
+package org.languagetool.dev.conversion.cg;
 
 public class CgAnchor {
 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/conversion/cg/CgCompositeTag.java
Patch:
@@ -1,9 +1,9 @@
-package de.danielnaber.languagetool.dev.conversion.cg;
+package org.languagetool.dev.conversion.cg;
 
 import java.util.ArrayList;
 import java.util.HashSet;
 
-import de.danielnaber.languagetool.dev.conversion.CgRuleConverter;
+import org.languagetool.dev.conversion.CgRuleConverter;
 
 public class CgCompositeTag {
 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/conversion/cg/CgContextualTest.java
Patch:
@@ -1,4 +1,4 @@
-package de.danielnaber.languagetool.dev.conversion.cg;
+package org.languagetool.dev.conversion.cg;
 
 import java.util.ArrayList;
 import java.util.HashSet;

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/conversion/cg/CgRule.java
Patch:
@@ -1,9 +1,9 @@
-package de.danielnaber.languagetool.dev.conversion.cg;
+package org.languagetool.dev.conversion.cg;
 
 import java.util.HashMap;
 import java.util.HashSet;
 
-import de.danielnaber.languagetool.dev.conversion.cg.CgStrings.KEYWORDS;
+import org.languagetool.dev.conversion.cg.CgStrings.KEYWORDS;
 
 public class CgRule {
 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/conversion/cg/CgSet.java
Patch:
@@ -1,11 +1,11 @@
-package de.danielnaber.languagetool.dev.conversion.cg;
+package org.languagetool.dev.conversion.cg;
 
 import java.util.HashSet;
 import java.util.ArrayList;
 import java.util.Random;
 
-import de.danielnaber.languagetool.dev.conversion.cg.CgTag.TAGS;
-import de.danielnaber.languagetool.dev.conversion.CgRuleConverter;
+import org.languagetool.dev.conversion.cg.CgTag.TAGS;
+import org.languagetool.dev.conversion.CgRuleConverter;
 
 public class CgSet {
 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/conversion/cg/CgStrings.java
Patch:
@@ -1,4 +1,4 @@
-package de.danielnaber.languagetool.dev.conversion.cg;
+package org.languagetool.dev.conversion.cg;
 
 public class CgStrings {
 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/conversion/cg/CgTag.java
Patch:
@@ -1,9 +1,9 @@
-package de.danielnaber.languagetool.dev.conversion.cg;
+package org.languagetool.dev.conversion.cg;
 
 import java.util.HashSet;
 import java.util.regex.Pattern;
 
-import de.danielnaber.languagetool.dev.conversion.cg.CgStrings.STRINGS;
+import org.languagetool.dev.conversion.cg.CgStrings.STRINGS;
 
 public class CgTag {
 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/conversion/gui/MainMenuBar.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev.conversion.gui;
+package org.languagetool.dev.conversion.gui;
 
 import java.awt.Event;
 import java.awt.event.ActionEvent;

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/AnyCharTokenizer.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev.index;
+package org.languagetool.dev.index;
 
 import java.io.Reader;
 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/LanguageToolAnalyzer.java
Patch:
@@ -16,15 +16,15 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev.index;
+package org.languagetool.dev.index;
 
 import java.io.Reader;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.util.Version;
 
-import de.danielnaber.languagetool.JLanguageTool;
+import org.languagetool.JLanguageTool;
 
 /**
  * LanguageToolAnalyzer emits the entire input (i.e. a sentence) as a single token by

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/POSAwaredRegexNotQuery.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev.index;
+package org.languagetool.dev.index;
 
 import java.io.IOException;
 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/POSAwaredRegexNotTermEnum.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev.index;
+package org.languagetool.dev.index;
 
 import java.io.IOException;
 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/POSAwaredRegexQuery.java
Patch:
@@ -1,4 +1,4 @@
-package de.danielnaber.languagetool.dev.index;
+package org.languagetool.dev.index;
 
 import java.io.IOException;
 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/POSAwaredRegexTermEnum.java
Patch:
@@ -1,4 +1,4 @@
-package de.danielnaber.languagetool.dev.index;
+package org.languagetool.dev.index;
 
 import java.io.IOException;
 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/POSAwaredSpanRegexNotQuery.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev.index;
+package org.languagetool.dev.index;
 
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.regex.RegexCapabilities;

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/POSAwaredSpanRegexQuery.java
Patch:
@@ -1,4 +1,4 @@
-package de.danielnaber.languagetool.dev.index;
+package org.languagetool.dev.index;
 
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.regex.RegexCapabilities;

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/PatternRuleNotFoundException.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev.index;
+package org.languagetool.dev.index;
 
 import java.io.IOException;
 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/PatternRuleQueryBuilder.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev.index;
+package org.languagetool.dev.index;
 
 import java.util.ArrayList;
 import java.util.Iterator;
@@ -27,8 +27,8 @@
 import org.apache.lucene.search.regex.JavaUtilRegexCapabilities;
 import org.apache.lucene.search.spans.SpanQuery;
 
-import de.danielnaber.languagetool.rules.patterns.Element;
-import de.danielnaber.languagetool.rules.patterns.PatternRule;
+import org.languagetool.rules.patterns.Element;
+import org.languagetool.rules.patterns.PatternRule;
 
 /**
  * A factory class for building a Query from a PatternRule.

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/RigidNearSpansOrdered.java
Patch:
@@ -1,4 +1,4 @@
-package de.danielnaber.languagetool.dev.index;
+package org.languagetool.dev.index;
 
 /**
 * Licensed to the Apache Software Foundation (ASF) under one or more

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/RigidSpanNearQuery.java
Patch:
@@ -1,4 +1,4 @@
-package de.danielnaber.languagetool.dev.index;
+package org.languagetool.dev.index;
 
 import java.io.IOException;
 import java.util.Iterator;

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/index/UnsupportedPatternRuleException.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev.index;
+package org.languagetool.dev.index;
 
 import java.io.IOException;
 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/tools/RomanianDiacriticsModifier.java
Patch:
@@ -1,4 +1,4 @@
-package de.danielnaber.languagetool.dev.tools;
+package org.languagetool.dev.tools;
 
 /**
  * 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/wikipedia/TextFilterTools.java
Patch:
@@ -16,10 +16,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev.wikipedia;
+package org.languagetool.dev.wikipedia;
 
-import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.dev.tools.RomanianDiacriticsModifier;
+import org.languagetool.Language;
+import org.languagetool.dev.tools.RomanianDiacriticsModifier;
 
 /**
  * Helper class.

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/wikipedia/WikipediaQuickCheckResult.java
Patch:
@@ -16,9 +16,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev.wikipedia;
+package org.languagetool.dev.wikipedia;
 
-import de.danielnaber.languagetool.rules.RuleMatch;
+import org.languagetool.rules.RuleMatch;
 
 import java.util.List;
 

File: trunk/JLanguageTool/src/dev/org/languagetool/dev/wikipedia/WikipediaTextFilter.java
Patch:
@@ -16,13 +16,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev.wikipedia;
+package org.languagetool.dev.wikipedia;
 
 import info.bliki.wiki.model.WikiModel;
 
 import org.apache.commons.lang.StringEscapeUtils;
 
-import de.danielnaber.languagetool.TextFilter;
+import org.languagetool.TextFilter;
 
 /**
  * Convert Wikipedia syntax to HTML using Bliki and then try to clean it up (this is

File: trunk/JLanguageTool/src/java/org/languagetool/AnalyzedSentence.java
Patch:
@@ -16,13 +16,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool;
+package org.languagetool;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
-import de.danielnaber.languagetool.tagging.de.AnalyzedGermanTokenReadings;
+import org.languagetool.tagging.de.AnalyzedGermanTokenReadings;
 
 /**
  * A sentence that has been tokenized and analyzed.

File: trunk/JLanguageTool/src/java/org/languagetool/AnalyzedToken.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool;
+package org.languagetool;
 
 /**
  * A word (or punctuation, or whitespace) and its part-of-speech tag.

File: trunk/JLanguageTool/src/java/org/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -17,13 +17,13 @@
  * USA
  */
 
-package de.danielnaber.languagetool;
+package org.languagetool;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
-import de.danielnaber.languagetool.tools.StringTools;
+import org.languagetool.tools.StringTools;
 
 /**
  * An array of {@link AnalyzedToken}s used to store multiple POS tags and lemmas

File: trunk/JLanguageTool/src/java/org/languagetool/TextFilter.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool;
+package org.languagetool;
 
 /**
  * Filter, i.e. clean up, text before it is checked.

File: trunk/JLanguageTool/src/java/org/languagetool/bitext/BitextReader.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package de.danielnaber.languagetool.bitext;
+package org.languagetool.bitext;
 
 /**
  * Interface for classes that implement reading from bitext files,

File: trunk/JLanguageTool/src/java/org/languagetool/bitext/StringPair.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package de.danielnaber.languagetool.bitext;
+package org.languagetool.bitext;
 
 /**
  * A convenience class to work with bitext strings.

File: trunk/JLanguageTool/src/java/org/languagetool/bitext/TabBitextReader.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package de.danielnaber.languagetool.bitext;
+package org.languagetool.bitext;
 
 import java.io.BufferedReader;
 import java.io.FileInputStream;

File: trunk/JLanguageTool/src/java/org/languagetool/bitext/WordFastTMReader.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package de.danielnaber.languagetool.bitext;
+package org.languagetool.bitext;
 
 import java.io.IOException;
 import java.util.Iterator;

File: trunk/JLanguageTool/src/java/org/languagetool/databroker/DefaultResourceDataBroker.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.databroker;
+package org.languagetool.databroker;
 
 import java.io.File;
 import java.io.IOException;
@@ -26,7 +26,7 @@
 import java.net.URLConnection;
 import java.security.Permission;
 
-import de.danielnaber.languagetool.JLanguageTool;
+import org.languagetool.JLanguageTool;
 
 /**
  * Responsible for getting any items from the grammar checker's resource

File: trunk/JLanguageTool/src/java/org/languagetool/databroker/ResourceDataBroker.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.databroker;
+package org.languagetool.databroker;
 
 import java.io.InputStream;
 import java.net.URL;
 
-import de.danielnaber.languagetool.JLanguageTool;
+import org.languagetool.JLanguageTool;
 
 /**
  * Is responsible for getting the necessary resources for the grammar checker

File: trunk/JLanguageTool/src/java/org/languagetool/gui/LanguageManagerDialog.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.gui;
+package org.languagetool.gui;
 
 import java.awt.Container;
 import java.awt.Dimension;
@@ -42,8 +42,8 @@
 import javax.swing.KeyStroke;
 import javax.swing.filechooser.FileFilter;
 
-import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.language.LanguageBuilder;
+import org.languagetool.Language;
+import org.languagetool.language.LanguageBuilder;
 
 /**
  * Dialog for managing externally loaded rules.

File: trunk/JLanguageTool/src/java/org/languagetool/gui/MainMenuBar.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.gui;
+package org.languagetool.gui;
 
 import java.awt.Event;
 import java.awt.event.ActionEvent;
@@ -29,7 +29,7 @@
 import javax.swing.JMenuItem;
 import javax.swing.KeyStroke;
 
-import de.danielnaber.languagetool.tools.StringTools;
+import org.languagetool.tools.StringTools;
 
 /**
  * The menu bar of the main dialog.

File: trunk/JLanguageTool/src/java/org/languagetool/gui/Messages.java
Patch:
@@ -1,10 +1,10 @@
-package de.danielnaber.languagetool.gui;
+package org.languagetool.gui;
 
 import java.util.MissingResourceException;
 import java.util.ResourceBundle;
 
 public class Messages {
-	private static final String BUNDLE_NAME = "de.danielnaber.languagetool.MessagesBundle"; //$NON-NLS-1$
+	private static final String BUNDLE_NAME = "org.languagetool.MessagesBundle"; //$NON-NLS-1$
 
 	private static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle
 			.getBundle(BUNDLE_NAME);

File: trunk/JLanguageTool/src/java/org/languagetool/gui/ResourceBundleWithFallback.java
Patch:
@@ -1,4 +1,4 @@
-package de.danielnaber.languagetool.gui;
+package org.languagetool.gui;
 
 import java.util.Enumeration;
 import java.util.ResourceBundle;

File: trunk/JLanguageTool/src/java/org/languagetool/gui/Tools.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.gui;
+package org.languagetool.gui;
 
 import java.awt.Frame;
 import java.io.File;
@@ -27,7 +27,7 @@
 import javax.swing.JOptionPane;
 import javax.swing.filechooser.FileFilter;
 
-import de.danielnaber.languagetool.tools.StringTools;
+import org.languagetool.tools.StringTools;
 
 /**
  * GUI-related tools.
@@ -171,7 +171,7 @@ static File openFileDialog(final Frame frame, final FileFilter fileFilter) {
    * Show the exception (with stacktrace) in a dialog and print it to STDERR.
    */
   static void showError(final Exception e) {
-    final String msg = de.danielnaber.languagetool.tools.Tools
+    final String msg = org.languagetool.tools.Tools
         .getFullStackTrace(e);
     JOptionPane
         .showMessageDialog(null, msg, "Error", JOptionPane.ERROR_MESSAGE);

File: trunk/JLanguageTool/src/java/org/languagetool/language/Contributor.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.language;
+package org.languagetool.language;
 
 /**
  * A person that contributed rules or code to LanguageTool.

File: trunk/JLanguageTool/src/java/org/languagetool/language/Contributors.java
Patch:
@@ -1,4 +1,4 @@
-package de.danielnaber.languagetool.language;
+package org.languagetool.language;
 
 /**
  * Constants for contributors who contribute to more than one language (use to avoid duplication).

File: trunk/JLanguageTool/src/java/org/languagetool/language/LanguageBuilder.java
Patch:
@@ -16,15 +16,15 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.language;
+package org.languagetool.language;
 
 import java.io.File;
 import java.util.Collections;
 import java.util.List;
 import java.util.Locale;
 
-import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.rules.Rule;
+import org.languagetool.Language;
+import org.languagetool.rules.Rule;
 
 /**
  * Create a language by specifying the language's XML rule file.

File: trunk/JLanguageTool/src/java/org/languagetool/language/RuleFilenameException.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.language;
+package org.languagetool.language;
 
 import java.io.File;
 

File: trunk/JLanguageTool/src/java/org/languagetool/openoffice/KhmerDetector.java
Patch:
@@ -1,4 +1,4 @@
-package de.danielnaber.languagetool.openoffice;
+package org.languagetool.openoffice;
 
 /**
  * Helps detecting Khmer strings by their Unicode range.

File: trunk/JLanguageTool/src/java/org/languagetool/openoffice/OOoAboutDialog.java
Patch:
@@ -16,15 +16,15 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.openoffice;
+package org.languagetool.openoffice;
 
 import com.sun.star.awt.Rectangle;
 import com.sun.star.awt.XMessageBox;
 import com.sun.star.awt.XMessageBoxFactory;
 import com.sun.star.awt.XWindowPeer;
 import com.sun.star.uno.UnoRuntime;
-import de.danielnaber.languagetool.gui.AboutDialog;
-import de.danielnaber.languagetool.tools.StringTools;
+import org.languagetool.gui.AboutDialog;
+import org.languagetool.tools.StringTools;
 
 import java.util.ResourceBundle;
 

File: trunk/JLanguageTool/src/java/org/languagetool/openoffice/SingletonFactory.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.openoffice;
+package org.languagetool.openoffice;
 
 import com.sun.star.lang.XSingleComponentFactory;
 import com.sun.star.uno.XComponentContext;
@@ -30,7 +30,7 @@
  */
 public class SingletonFactory implements XSingleComponentFactory {
 
-  private transient de.danielnaber.languagetool.openoffice.Main instance;
+  private transient org.languagetool.openoffice.Main instance;
 
   @Override
   public final Object createInstanceWithArgumentsAndContext(final Object[] arguments, 
@@ -41,7 +41,7 @@ public final Object createInstanceWithArgumentsAndContext(final Object[] argumen
   @Override
   public final Object createInstanceWithContext(final XComponentContext xContext) throws com.sun.star.uno.Exception {    
     if (instance == null) {     
-      instance = new de.danielnaber.languagetool.openoffice.Main(xContext);      
+      instance = new org.languagetool.openoffice.Main(xContext);      
     } else {  
       instance.changeContext(xContext);      
     }

File: trunk/JLanguageTool/src/java/org/languagetool/rules/AbstractPunctuationCheckRule.java
Patch:
@@ -16,14 +16,14 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules;
+package org.languagetool.rules;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.ResourceBundle;
 
-import de.danielnaber.languagetool.AnalyzedSentence;
-import de.danielnaber.languagetool.AnalyzedTokenReadings;
+import org.languagetool.AnalyzedSentence;
+import org.languagetool.AnalyzedTokenReadings;
 
 /**
  * A rule that matches "..", "::", "-," but not "...", "!..", "?!!", ",-" etc.

File: trunk/JLanguageTool/src/java/org/languagetool/rules/Category.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules;
+package org.languagetool.rules;
 
 /**
  * A rule's category. Categories are used to group rules for

File: trunk/JLanguageTool/src/java/org/languagetool/rules/CommaWhitespaceRule.java
Patch:
@@ -16,14 +16,14 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules;
+package org.languagetool.rules;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.ResourceBundle;
 
-import de.danielnaber.languagetool.AnalyzedSentence;
-import de.danielnaber.languagetool.AnalyzedTokenReadings;
+import org.languagetool.AnalyzedSentence;
+import org.languagetool.AnalyzedTokenReadings;
 
 /**
  * A rule that matches commas and closing parenthesis preceded by whitespace and

File: trunk/JLanguageTool/src/java/org/languagetool/rules/DoublePunctuationRule.java
Patch:
@@ -16,14 +16,14 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules;
+package org.languagetool.rules;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.ResourceBundle;
 
-import de.danielnaber.languagetool.AnalyzedSentence;
-import de.danielnaber.languagetool.AnalyzedTokenReadings;
+import org.languagetool.AnalyzedSentence;
+import org.languagetool.AnalyzedTokenReadings;
 
 /**
  * A rule that matches ".." (but not "..." etc) and ",,".

File: trunk/JLanguageTool/src/java/org/languagetool/rules/IncorrectExample.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules;
+package org.languagetool.rules;
 
 import java.util.Arrays;
 import java.util.List;

File: trunk/JLanguageTool/src/java/org/languagetool/rules/LongSentenceRule.java
Patch:
@@ -1,12 +1,12 @@
-package de.danielnaber.languagetool.rules;
+package org.languagetool.rules;
 
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.ResourceBundle;
 
-import de.danielnaber.languagetool.AnalyzedSentence;
-import de.danielnaber.languagetool.AnalyzedTokenReadings;
+import org.languagetool.AnalyzedSentence;
+import org.languagetool.AnalyzedTokenReadings;
 
 public class LongSentenceRule extends Rule {
 

File: trunk/JLanguageTool/src/java/org/languagetool/rules/RuleMatch.java
Patch:
@@ -16,14 +16,14 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules;
+package org.languagetool.rules;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import de.danielnaber.languagetool.tools.StringTools;
+import org.languagetool.tools.StringTools;
 
 /**
  * A class that holds information about where a rule matches text.

File: trunk/JLanguageTool/src/java/org/languagetool/rules/bitext/IncorrectBitextExample.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.bitext;
+package org.languagetool.rules.bitext;
 
 import java.util.Arrays;
 import java.util.List;
 
-import de.danielnaber.languagetool.bitext.StringPair;
+import org.languagetool.bitext.StringPair;
 
 /**
  * A text, typically a pair of sentences that contains an error.

File: trunk/JLanguageTool/src/java/org/languagetool/rules/ca/AccentuacioReplaceRule.java
Patch:
@@ -16,13 +16,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.ca;
+package org.languagetool.rules.ca;
 
 import java.io.IOException;
 import java.util.Locale;
 import java.util.ResourceBundle;
 
-import de.danielnaber.languagetool.rules.AbstractSimpleReplaceRule;
+import org.languagetool.rules.AbstractSimpleReplaceRule;
 
 /**
  * A rule that matches words or phrases which should not be used and suggests

File: trunk/JLanguageTool/src/java/org/languagetool/rules/ca/CastellanismesReplaceRule.java
Patch:
@@ -16,13 +16,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.ca;
+package org.languagetool.rules.ca;
 
 import java.io.IOException;
 import java.util.Locale;
 import java.util.ResourceBundle;
 
-import de.danielnaber.languagetool.rules.AbstractSimpleReplaceRule;
+import org.languagetool.rules.AbstractSimpleReplaceRule;
 
 /**
  * A rule that matches words or phrases which should not be used and suggests

File: trunk/JLanguageTool/src/java/org/languagetool/rules/de/CompoundRule.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.de;
+package org.languagetool.rules.de;
 
 import java.io.IOException;
 import java.util.ResourceBundle;
 
-import de.danielnaber.languagetool.rules.AbstractCompoundRule;
+import org.languagetool.rules.AbstractCompoundRule;
 
 /**
  * Checks that compounds (if in the list) are not written as separate words.

File: trunk/JLanguageTool/src/java/org/languagetool/rules/de/GermanDoublePunctuationRule.java
Patch:
@@ -1,6 +1,6 @@
-package de.danielnaber.languagetool.rules.de;
+package org.languagetool.rules.de;
 
-import de.danielnaber.languagetool.rules.DoublePunctuationRule;
+import org.languagetool.rules.DoublePunctuationRule;
 
 import java.util.ResourceBundle;
 

File: trunk/JLanguageTool/src/java/org/languagetool/rules/de/GermanLemmatizer.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.de;
+package org.languagetool.rules.de;
 
 import java.io.BufferedReader;
 import java.io.IOException;
@@ -25,7 +25,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import de.danielnaber.languagetool.JLanguageTool;
+import org.languagetool.JLanguageTool;
 
 /**
  * Trivial German lemmatizer that can simply find the baseforms of

File: trunk/JLanguageTool/src/java/org/languagetool/rules/de/GermanRule.java
Patch:
@@ -16,9 +16,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.de;
+package org.languagetool.rules.de;
 
-import de.danielnaber.languagetool.rules.Rule;
+import org.languagetool.rules.Rule;
 
 /**
  * Abstract base class for rules for the German language.

File: trunk/JLanguageTool/src/java/org/languagetool/rules/en/CompoundRule.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.en;
+package org.languagetool.rules.en;
 
 import java.io.IOException;
 import java.util.ResourceBundle;
 
-import de.danielnaber.languagetool.rules.AbstractCompoundRule;
+import org.languagetool.rules.AbstractCompoundRule;
 
 /**
  * Checks that compounds (if in the list) are not written as separate words.

File: trunk/JLanguageTool/src/java/org/languagetool/rules/en/EnglishRule.java
Patch:
@@ -16,9 +16,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.en;
+package org.languagetool.rules.en;
 
-import de.danielnaber.languagetool.rules.Rule;
+import org.languagetool.rules.Rule;
 
 /**
  * Abstract base class for rules for the English language.

File: trunk/JLanguageTool/src/java/org/languagetool/rules/es/SpanishRule.java
Patch:
@@ -16,9 +16,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.es;
+package org.languagetool.rules.es;
 
-import de.danielnaber.languagetool.rules.Rule;
+import org.languagetool.rules.Rule;
 
 /**
  * Abstract base class for rules for Spanish.

File: trunk/JLanguageTool/src/java/org/languagetool/rules/fr/FrenchRule.java
Patch:
@@ -17,9 +17,9 @@
  * USA
  */
 
-package de.danielnaber.languagetool.rules.fr;
+package org.languagetool.rules.fr;
 
-import de.danielnaber.languagetool.rules.Rule;
+import org.languagetool.rules.Rule;
 
 /**
  * Abstract base class for French rules.

File: trunk/JLanguageTool/src/java/org/languagetool/rules/gl/CastWordsRule.java
Patch:
@@ -16,13 +16,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.gl;
+package org.languagetool.rules.gl;
 
 import java.io.IOException;
 import java.util.Locale;
 import java.util.ResourceBundle;
 
-import de.danielnaber.languagetool.rules.AbstractSimpleReplaceRule;
+import org.languagetool.rules.AbstractSimpleReplaceRule;
 
 /**
  * A rule that matches words or phrases which should not be used and suggests

File: trunk/JLanguageTool/src/java/org/languagetool/rules/gl/SimpleReplaceRule.java
Patch:
@@ -16,13 +16,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.gl;
+package org.languagetool.rules.gl;
 
 import java.io.IOException;
 import java.util.Locale;
 import java.util.ResourceBundle;
 
-import de.danielnaber.languagetool.rules.AbstractSimpleReplaceRule;
+import org.languagetool.rules.AbstractSimpleReplaceRule;
 
 /**
  * A rule that matches words or phrases which should not be used and suggests

File: trunk/JLanguageTool/src/java/org/languagetool/rules/km/KhmerRule.java
Patch:
@@ -16,9 +16,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.km;
+package org.languagetool.rules.km;
 
-import de.danielnaber.languagetool.rules.Rule;
+import org.languagetool.rules.Rule;
 
 /**
  * Abstract base class for rules for the Khmer language.

File: trunk/JLanguageTool/src/java/org/languagetool/rules/km/KhmerUnpairedBracketsRule.java
Patch:
@@ -1,9 +1,9 @@
 // LanguageTool, a natural language style checker 
 
-package de.danielnaber.languagetool.rules.km;
+package org.languagetool.rules.km;
 
-import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.rules.GenericUnpairedBracketsRule;
+import org.languagetool.Language;
+import org.languagetool.rules.GenericUnpairedBracketsRule;
 
 import java.util.ResourceBundle;
 

File: trunk/JLanguageTool/src/java/org/languagetool/rules/pl/CompoundRule.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.pl;
+package org.languagetool.rules.pl;
 
 import java.io.IOException;
 import java.util.ResourceBundle;
 
-import de.danielnaber.languagetool.rules.AbstractCompoundRule;
+import org.languagetool.rules.AbstractCompoundRule;
 
 /**
  * Checks that compounds (if in the list) are not written as separate words.

File: trunk/JLanguageTool/src/java/org/languagetool/rules/pl/PolishRule.java
Patch:
@@ -16,9 +16,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.pl;
+package org.languagetool.rules.pl;
 
-import de.danielnaber.languagetool.rules.Rule;
+import org.languagetool.rules.Rule;
 
 /**
  * Abstract base class for Polish rules.

File: trunk/JLanguageTool/src/java/org/languagetool/rules/pl/PolishUnpairedBracketsRule.java
Patch:
@@ -17,12 +17,12 @@
  * USA
  */
 
-package de.danielnaber.languagetool.rules.pl;
+package org.languagetool.rules.pl;
 
 import java.util.ResourceBundle;
 
-import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.rules.GenericUnpairedBracketsRule;
+import org.languagetool.Language;
+import org.languagetool.rules.GenericUnpairedBracketsRule;
 
 public class PolishUnpairedBracketsRule extends GenericUnpairedBracketsRule {
 

File: trunk/JLanguageTool/src/java/org/languagetool/rules/pl/SimpleReplaceRule.java
Patch:
@@ -16,13 +16,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.pl;
+package org.languagetool.rules.pl;
 
 import java.io.IOException;
 import java.util.Locale;
 import java.util.ResourceBundle;
 
-import de.danielnaber.languagetool.rules.AbstractSimpleReplaceRule;
+import org.languagetool.rules.AbstractSimpleReplaceRule;
 
 /**
  * A rule that matches words or phrases which should not be used and suggests

File: trunk/JLanguageTool/src/java/org/languagetool/rules/ro/CompoundRule.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.ro;
+package org.languagetool.rules.ro;
 
 import java.io.IOException;
 import java.util.ResourceBundle;
 
-import de.danielnaber.languagetool.rules.AbstractCompoundRule;
+import org.languagetool.rules.AbstractCompoundRule;
 
 /**
  * Checks that compounds (if in the list) are not written as separate words.

File: trunk/JLanguageTool/src/java/org/languagetool/rules/ru/RussianCompoundRule.java
Patch:
@@ -16,9 +16,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.ru;
+package org.languagetool.rules.ru;
 
-import de.danielnaber.languagetool.rules.AbstractCompoundRule;
+import org.languagetool.rules.AbstractCompoundRule;
 
 import java.io.IOException;
 import java.util.ResourceBundle;

File: trunk/JLanguageTool/src/java/org/languagetool/rules/ru/RussianRule.java
Patch:
@@ -16,9 +16,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.ru;
+package org.languagetool.rules.ru;
 
-import de.danielnaber.languagetool.rules.Rule;
+import org.languagetool.rules.Rule;
 
 /**
  * Abstract base class for rules for the Russian language.

File: trunk/JLanguageTool/src/java/org/languagetool/rules/ru/RussianSimpleReplaceRule.java
Patch:
@@ -16,13 +16,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.ru;
+package org.languagetool.rules.ru;
 
 import java.io.IOException;
 import java.util.Locale;
 import java.util.ResourceBundle;
 
-import de.danielnaber.languagetool.rules.AbstractSimpleReplaceRule;
+import org.languagetool.rules.AbstractSimpleReplaceRule;
 
 /**
  * A rule that matches words or phrases which should not be used and suggests

File: trunk/JLanguageTool/src/java/org/languagetool/rules/sk/CompoundRule.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.sk;
+package org.languagetool.rules.sk;
 
 import java.io.IOException;
 import java.util.ResourceBundle;
 
-import de.danielnaber.languagetool.rules.AbstractCompoundRule;
+import org.languagetool.rules.AbstractCompoundRule;
 
 /**
  * Checks that compounds (if in the list) are not written as separate words.

File: trunk/JLanguageTool/src/java/org/languagetool/rules/sk/SlovakRule.java
Patch:
@@ -16,9 +16,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.sk;
+package org.languagetool.rules.sk;
 
-import de.danielnaber.languagetool.rules.Rule;
+import org.languagetool.rules.Rule;
 
 /**
  * Abstract base class for Slovak rules.

File: trunk/JLanguageTool/src/java/org/languagetool/rules/sv/CompoundRule.java
Patch:
@@ -16,9 +16,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.sv;
+package org.languagetool.rules.sv;
 
-import de.danielnaber.languagetool.rules.AbstractCompoundRule;
+import org.languagetool.rules.AbstractCompoundRule;
 
 import java.io.IOException;
 import java.util.ResourceBundle;

File: trunk/JLanguageTool/src/java/org/languagetool/rules/sv/SwedishRule.java
Patch:
@@ -16,9 +16,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.sv;
+package org.languagetool.rules.sv;
 
-import de.danielnaber.languagetool.rules.Rule;
+import org.languagetool.rules.Rule;
 
 /**
  * Abstract base class for Swedish rules.

File: trunk/JLanguageTool/src/java/org/languagetool/rules/uk/SimpleReplaceRule.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.rules.uk;
+package org.languagetool.rules.uk;
 
 import java.io.IOException;
 import java.util.ResourceBundle;
 
-import de.danielnaber.languagetool.rules.AbstractSimpleReplaceRule;
+import org.languagetool.rules.AbstractSimpleReplaceRule;
 
 /**
  * A rule that matches words or phrases which should not be used and suggests

File: trunk/JLanguageTool/src/java/org/languagetool/server/HTTPServer.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.server;
+package org.languagetool.server;
 
 import com.sun.net.httpserver.HttpServer;
 

File: trunk/JLanguageTool/src/java/org/languagetool/server/PortBindingException.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.server;
+package org.languagetool.server;
 
 public class PortBindingException extends RuntimeException {
 

File: trunk/JLanguageTool/src/java/org/languagetool/synthesis/BaseSynthesizer.java
Patch:
@@ -1,4 +1,4 @@
-package de.danielnaber.languagetool.synthesis;
+package org.languagetool.synthesis;
 
 import java.io.IOException;
 import java.net.URL;
@@ -12,8 +12,8 @@
 import morfologik.stemming.IStemmer;
 import morfologik.stemming.WordData;
 
-import de.danielnaber.languagetool.AnalyzedToken;
-import de.danielnaber.languagetool.tools.Tools;
+import org.languagetool.AnalyzedToken;
+import org.languagetool.tools.Tools;
 
 public class BaseSynthesizer implements Synthesizer {
  

File: trunk/JLanguageTool/src/java/org/languagetool/synthesis/Synthesizer.java
Patch:
@@ -16,11 +16,11 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.synthesis;
+package org.languagetool.synthesis;
 
 import java.io.IOException;
 
-import de.danielnaber.languagetool.AnalyzedToken;
+import org.languagetool.AnalyzedToken;
 
 /**
  * Part-of-speech synthesizer interface. Implementations are 

File: trunk/JLanguageTool/src/java/org/languagetool/synthesis/SynthesizerTools.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.synthesis;
+package org.languagetool.synthesis;
 
 import java.io.BufferedReader;
 import java.io.IOException;

File: trunk/JLanguageTool/src/java/org/languagetool/synthesis/ca/CatalanSynthesizer.java
Patch:
@@ -16,10 +16,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.synthesis.ca;
+package org.languagetool.synthesis.ca;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.synthesis.BaseSynthesizer;
+import org.languagetool.JLanguageTool;
+import org.languagetool.synthesis.BaseSynthesizer;
 
 /**
  * Catalan word form synthesizer. <br/>

File: trunk/JLanguageTool/src/java/org/languagetool/synthesis/es/SpanishSynthesizer.java
Patch:
@@ -16,10 +16,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.synthesis.es;
+package org.languagetool.synthesis.es;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.synthesis.BaseSynthesizer;
+import org.languagetool.JLanguageTool;
+import org.languagetool.synthesis.BaseSynthesizer;
 
 /**
  * Spanish word form synthesizer. <br/> 

File: trunk/JLanguageTool/src/java/org/languagetool/synthesis/gl/GalicianSynthesizer.java
Patch:
@@ -16,10 +16,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.synthesis.gl;
+package org.languagetool.synthesis.gl;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.synthesis.BaseSynthesizer;
+import org.languagetool.JLanguageTool;
+import org.languagetool.synthesis.BaseSynthesizer;
 
 /**
  * Galician word form synthesizer. <br/>

File: trunk/JLanguageTool/src/java/org/languagetool/synthesis/nl/DutchSynthesizer.java
Patch:
@@ -16,10 +16,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.synthesis.nl;
+package org.languagetool.synthesis.nl;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.synthesis.BaseSynthesizer;
+import org.languagetool.JLanguageTool;
+import org.languagetool.synthesis.BaseSynthesizer;
 
 /**
  * Dutch word form synthesizer. <br/>

File: trunk/JLanguageTool/src/java/org/languagetool/synthesis/ro/RomanianSynthesizer.java
Patch:
@@ -16,10 +16,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.synthesis.ro;
+package org.languagetool.synthesis.ro;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.synthesis.BaseSynthesizer;
+import org.languagetool.JLanguageTool;
+import org.languagetool.synthesis.BaseSynthesizer;
 
 /**
  * Romanian word form synthesizer. <br/>

File: trunk/JLanguageTool/src/java/org/languagetool/synthesis/ru/RussianSynthesizer.java
Patch:
@@ -16,10 +16,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.synthesis.ru;
+package org.languagetool.synthesis.ru;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.synthesis.BaseSynthesizer;
+import org.languagetool.JLanguageTool;
+import org.languagetool.synthesis.BaseSynthesizer;
 
 /**
  * Russian word form synthesizer. <br/>

File: trunk/JLanguageTool/src/java/org/languagetool/synthesis/sk/SlovakSynthesizer.java
Patch:
@@ -16,10 +16,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.synthesis.sk;
+package org.languagetool.synthesis.sk;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.synthesis.BaseSynthesizer;
+import org.languagetool.JLanguageTool;
+import org.languagetool.synthesis.BaseSynthesizer;
 
 /**
  * Slovak word form synthesizer. <br/>

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/ManualTagger.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging;
+package org.languagetool.tagging;
 
 import java.io.BufferedReader;
 import java.io.IOException;
@@ -27,7 +27,7 @@
 import java.util.List;
 import java.util.Map;
 
-import de.danielnaber.languagetool.tools.StringTools;
+import org.languagetool.tools.StringTools;
 
 
 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/Tagger.java
Patch:
@@ -16,13 +16,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging;
+package org.languagetool.tagging;
 
 import java.io.IOException;
 import java.util.List;
 
-import de.danielnaber.languagetool.AnalyzedToken;
-import de.danielnaber.languagetool.AnalyzedTokenReadings;
+import org.languagetool.AnalyzedToken;
+import org.languagetool.AnalyzedTokenReadings;
 
 /**
  * The part-of-speech tagger interface, whose implementations are usually language-dependent.

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/ast/AsturianTagger.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.ast;
+package org.languagetool.tagging.ast;
 
 import java.util.Locale;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.tagging.BaseTagger;
+import org.languagetool.JLanguageTool;
+import org.languagetool.tagging.BaseTagger;
 
 /** Asturian Part-of-speech tagger.
  * Based on FreeLing tagger dictionary

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/ca/CatalanTagger.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.ca;
+package org.languagetool.tagging.ca;
 
 import java.util.Locale;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.tagging.BaseTagger;
+import org.languagetool.JLanguageTool;
+import org.languagetool.tagging.BaseTagger;
 
 /** Catalan Tagger
  * 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/da/DanishTagger.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.da;
+package org.languagetool.tagging.da;
 
 import java.util.Locale;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.tagging.BaseTagger;
+import org.languagetool.JLanguageTool;
+import org.languagetool.tagging.BaseTagger;
 
 /**
  * Danish Part-of-speech tagger.

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/de/GermanToken.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.de;
+package org.languagetool.tagging.de;
 
 /**
  * Constants used to describe the properties of German tokens.

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/disambiguation/Disambiguator.java
Patch:
@@ -16,11 +16,11 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.disambiguation;
+package org.languagetool.tagging.disambiguation;
 
 import java.io.IOException;
 
-import de.danielnaber.languagetool.AnalyzedSentence;
+import org.languagetool.AnalyzedSentence;
 
 /**
  * Disambiguator interface. Particular implementations are language-dependent.

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/disambiguation/rules/DisambXMLRuleHandler.java
Patch:
@@ -16,14 +16,14 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.disambiguation.rules;
+package org.languagetool.tagging.disambiguation.rules;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.xml.sax.SAXException;
 import org.xml.sax.SAXParseException;
-import de.danielnaber.languagetool.rules.patterns.XMLRuleHandler;
+import org.languagetool.rules.patterns.XMLRuleHandler;
 
 /**
  * XML rule handler that loads disambiguation rules from XML and throws

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/disambiguation/rules/DisambiguatedExample.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tagging.disambiguation.rules;
+package org.languagetool.tagging.disambiguation.rules;
 
 /**
  * Disambiguated example. Used for testing

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/disambiguation/rules/br/BretonRuleDisambiguator.java
Patch:
@@ -16,10 +16,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.disambiguation.rules.br;
+package org.languagetool.tagging.disambiguation.rules.br;
 
-import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
+import org.languagetool.Language;
+import org.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
 
 public class BretonRuleDisambiguator extends AbstractRuleDisambiguator {
 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/disambiguation/rules/en/EnglishRuleDisambiguator.java
Patch:
@@ -17,10 +17,10 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tagging.disambiguation.rules.en;
+package org.languagetool.tagging.disambiguation.rules.en;
 
-import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
+import org.languagetool.Language;
+import org.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
 
 public class EnglishRuleDisambiguator extends AbstractRuleDisambiguator {
 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/disambiguation/rules/eo/EsperantoRuleDisambiguator.java
Patch:
@@ -16,10 +16,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.disambiguation.rules.eo;
+package org.languagetool.tagging.disambiguation.rules.eo;
 
-import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
+import org.languagetool.Language;
+import org.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
 
 public class EsperantoRuleDisambiguator extends AbstractRuleDisambiguator {
 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/disambiguation/rules/es/SpanishRuleDisambiguator.java
Patch:
@@ -17,10 +17,10 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tagging.disambiguation.rules.es;
+package org.languagetool.tagging.disambiguation.rules.es;
 
-import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
+import org.languagetool.Language;
+import org.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
 
 public class SpanishRuleDisambiguator extends AbstractRuleDisambiguator {
 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/disambiguation/rules/fr/FrenchRuleDisambiguator.java
Patch:
@@ -17,10 +17,10 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tagging.disambiguation.rules.fr;
+package org.languagetool.tagging.disambiguation.rules.fr;
 
-import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
+import org.languagetool.Language;
+import org.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
 
 public class FrenchRuleDisambiguator extends AbstractRuleDisambiguator {
     

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/disambiguation/rules/gl/GalicianRuleDisambiguator.java
Patch:
@@ -17,10 +17,10 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tagging.disambiguation.rules.gl;
+package org.languagetool.tagging.disambiguation.rules.gl;
 
-import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
+import org.languagetool.Language;
+import org.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
 
 public class GalicianRuleDisambiguator extends AbstractRuleDisambiguator {
 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/disambiguation/rules/km/KhmerRuleDisambiguator.java
Patch:
@@ -17,10 +17,10 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tagging.disambiguation.rules.km;
+package org.languagetool.tagging.disambiguation.rules.km;
 
-import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
+import org.languagetool.Language;
+import org.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
 
 public class KhmerRuleDisambiguator extends AbstractRuleDisambiguator {
 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/disambiguation/rules/nl/DutchRuleDisambiguator.java
Patch:
@@ -17,10 +17,10 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tagging.disambiguation.rules.nl;
+package org.languagetool.tagging.disambiguation.rules.nl;
 
-import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
+import org.languagetool.Language;
+import org.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
 
 public class DutchRuleDisambiguator extends AbstractRuleDisambiguator {
 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/disambiguation/rules/pl/PolishRuleDisambiguator.java
Patch:
@@ -16,10 +16,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.disambiguation.rules.pl;
+package org.languagetool.tagging.disambiguation.rules.pl;
 
-import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
+import org.languagetool.Language;
+import org.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
 
 public class PolishRuleDisambiguator extends AbstractRuleDisambiguator {
 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/disambiguation/rules/ro/RomanianRuleDisambiguator.java
Patch:
@@ -17,10 +17,10 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tagging.disambiguation.rules.ro;
+package org.languagetool.tagging.disambiguation.rules.ro;
 
-import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
+import org.languagetool.Language;
+import org.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
 
 public class RomanianRuleDisambiguator extends AbstractRuleDisambiguator {
 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/disambiguation/rules/ru/RussianRuleDisambiguator.java
Patch:
@@ -17,10 +17,10 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tagging.disambiguation.rules.ru;
+package org.languagetool.tagging.disambiguation.rules.ru;
 
-import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
+import org.languagetool.Language;
+import org.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;
 
 /**
  * Disambiguator for Russian 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/disambiguation/xx/DemoDisambiguator.java
Patch:
@@ -17,10 +17,10 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tagging.disambiguation.xx;
+package org.languagetool.tagging.disambiguation.xx;
 
-import de.danielnaber.languagetool.AnalyzedSentence;
-import de.danielnaber.languagetool.tagging.disambiguation.Disambiguator;
+import org.languagetool.AnalyzedSentence;
+import org.languagetool.tagging.disambiguation.Disambiguator;
 
 /**
  * Trivial disambiguator.

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/en/EnglishTagger.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.en;
+package org.languagetool.tagging.en;
 
 import java.util.Locale;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.tagging.BaseTagger;
+import org.languagetool.JLanguageTool;
+import org.languagetool.tagging.BaseTagger;
 
 /** English Part-of-speech tagger.
  * Based on part-of-speech lists in Public Domain.

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/es/SpanishTagger.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.es;
+package org.languagetool.tagging.es;
 
 import java.util.Locale;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.tagging.BaseTagger;
+import org.languagetool.JLanguageTool;
+import org.languagetool.tagging.BaseTagger;
 
 /** Spanish Tagger
  * 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/fr/FrenchTagger.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.fr;
+package org.languagetool.tagging.fr;
 
 import java.util.Locale;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.tagging.BaseTagger;
+import org.languagetool.JLanguageTool;
+import org.languagetool.tagging.BaseTagger;
 
 /** French Tagger
  * 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/gl/GalicianTagger.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.gl;
+package org.languagetool.tagging.gl;
 
 import java.util.Locale;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.tagging.BaseTagger;
+import org.languagetool.JLanguageTool;
+import org.languagetool.tagging.BaseTagger;
 
 /** Galician Part-of-speech tagger.
  * Based on English tagger.

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/it/ItalianTagger.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.it;
+package org.languagetool.tagging.it;
 
 import java.util.Locale;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.tagging.BaseTagger;
+import org.languagetool.JLanguageTool;
+import org.languagetool.tagging.BaseTagger;
 
 /**
  * Italian tagger

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/km/KhmerTagger.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.km;
+package org.languagetool.tagging.km;
 
 import java.util.Locale;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.tagging.BaseTagger;
+import org.languagetool.JLanguageTool;
+import org.languagetool.tagging.BaseTagger;
 
 /** Khmer Part-of-speech tagger.
  * Based on part-of-speech lists in Public Domain.

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/ml/MalayalamTagger.java
Patch:
@@ -17,12 +17,12 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tagging.ml;
+package org.languagetool.tagging.ml;
 
 import java.util.Locale;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.tagging.BaseTagger;
+import org.languagetool.JLanguageTool;
+import org.languagetool.tagging.BaseTagger;
 
 /** Malayalam Part-of-speech tagger.
  * 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/nl/DutchTagger.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.nl;
+package org.languagetool.tagging.nl;
 
 import java.util.Locale;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.tagging.BaseTagger;
+import org.languagetool.JLanguageTool;
+import org.languagetool.tagging.BaseTagger;
 
 /**
  * Dutch tagger.

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/ru/RussianTagger.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.ru;
+package org.languagetool.tagging.ru;
 
 import java.util.Locale;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.tagging.BaseTagger;
+import org.languagetool.JLanguageTool;
+import org.languagetool.tagging.BaseTagger;
 
 /**  Part-of-speech tagger.
  * Russian dictionary originally developed by www.aot.ru and licensed under LGPL.

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/sk/SlovakTagger.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.sk;
+package org.languagetool.tagging.sk;
 
 import java.util.Locale;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.tagging.BaseTagger;
+import org.languagetool.JLanguageTool;
+import org.languagetool.tagging.BaseTagger;
 
 /** Slovak Part-of-speech tagger based on Russian Part-of-speech tagger.
  * @author Zdenko Podobný 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/sv/SwedishTagger.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.sv;
+package org.languagetool.tagging.sv;
 
 import java.util.Locale;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.tagging.BaseTagger;
+import org.languagetool.JLanguageTool;
+import org.languagetool.tagging.BaseTagger;
 
 /** Swedish Part-of-speech tagger.
  * Based on DSSO. Will be expanded upon.

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/tl/TagalogTagger.java
Patch:
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.tl;
+package org.languagetool.tagging.tl;
 
 import java.util.Locale;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.tagging.BaseTagger;
+import org.languagetool.JLanguageTool;
+import org.languagetool.tagging.BaseTagger;
 
 /** 
  * Filipino Part-of-speech tagger.

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/uk/IPOSTag.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tagging.uk;
+package org.languagetool.tagging.uk;
 
 public interface IPOSTag {
 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/uk/UkrainianMorfoTagger.java
Patch:
@@ -16,10 +16,10 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tagging.uk;
+package org.languagetool.tagging.uk;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.tagging.BaseTagger;
+import org.languagetool.JLanguageTool;
+import org.languagetool.tagging.BaseTagger;
 
 /** Ukrainian Part-of-speech tagger.
  * 

File: trunk/JLanguageTool/src/java/org/languagetool/tagging/uk/UkrainianTagger.java
Patch:
@@ -17,9 +17,9 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tagging.uk;
+package org.languagetool.tagging.uk;
 
-import de.danielnaber.languagetool.tagging.Tagger;
+import org.languagetool.tagging.Tagger;
 
 public class UkrainianTagger extends UkrainianMyspellTagger implements Tagger {
 

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/SRXSentenceTokenizer.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tokenizers;
+package org.languagetool.tokenizers;
 
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
@@ -28,7 +28,7 @@
 import net.sourceforge.segment.srx.SrxParser;
 import net.sourceforge.segment.srx.SrxTextIterator;
 import net.sourceforge.segment.srx.io.Srx2Parser;
-import de.danielnaber.languagetool.JLanguageTool;
+import org.languagetool.JLanguageTool;
 
 /**
  * Class to tokenize sentences using an SRX file.

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/SentenceTokenizer.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tokenizers;
+package org.languagetool.tokenizers;
 
 import java.util.ArrayList;
 import java.util.Arrays;

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/Tokenizer.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tokenizers;
+package org.languagetool.tokenizers;
 
 import java.util.List;
 

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/WordTokenizer.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tokenizers;
+package org.languagetool.tokenizers;
 
 import java.util.ArrayList;
 import java.util.List;

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/br/BretonWordTokenizer.java
Patch:
@@ -17,13 +17,13 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tokenizers.br;
+package org.languagetool.tokenizers.br;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Iterator;
 
-import de.danielnaber.languagetool.tokenizers.WordTokenizer;
+import org.languagetool.tokenizers.WordTokenizer;
 
 /** 
  * @author Dominique Pelle

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/cs/CzechSentenceTokenizer.java
Patch:
@@ -23,14 +23,14 @@
  * Created on 25.1.2007, 11:45
  */
 
-package de.danielnaber.languagetool.tokenizers.cs;
+package org.languagetool.tokenizers.cs;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.StringTokenizer;
 import java.util.regex.Pattern;
 
-import de.danielnaber.languagetool.tokenizers.SentenceTokenizer;
+import org.languagetool.tokenizers.SentenceTokenizer;
 
 /**
  *

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/da/DanishSentenceTokenizer.java
Patch:
@@ -16,9 +16,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tokenizers.da;
+package org.languagetool.tokenizers.da;
 
-import de.danielnaber.languagetool.tokenizers.SentenceTokenizer;
+import org.languagetool.tokenizers.SentenceTokenizer;
 
 /**
  * @deprecated use {@code new SRXSentenceTokenizer("da")} instead

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -16,13 +16,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tokenizers.de;
+package org.languagetool.tokenizers.de;
 
 import java.io.IOException;
 import java.util.List;
 
 import de.abelssoft.wordtools.jwordsplitter.impl.GermanWordSplitter;
-import de.danielnaber.languagetool.tokenizers.Tokenizer;
+import org.languagetool.tokenizers.Tokenizer;
 
 /**
  * Split German nouns using the jWordSplitter library.

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/en/EnglishWordTokenizer.java
Patch:
@@ -16,13 +16,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tokenizers.en;
+package org.languagetool.tokenizers.en;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.StringTokenizer;
 
-import de.danielnaber.languagetool.tokenizers.Tokenizer;
+import org.languagetool.tokenizers.Tokenizer;
 
 /**
  * Tokenizes a sentence into words. Punctuation and whitespace gets its own token.

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/eo/EsperantoWordTokenizer.java
Patch:
@@ -17,13 +17,13 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tokenizers.eo;
+package org.languagetool.tokenizers.eo;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Iterator;
 
-import de.danielnaber.languagetool.tokenizers.WordTokenizer;
+import org.languagetool.tokenizers.WordTokenizer;
 
 /** 
  * @author Dominique Pelle

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/es/SpanishWordTokenizer.java
Patch:
@@ -16,13 +16,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tokenizers.es;
+package org.languagetool.tokenizers.es;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.StringTokenizer;
 
-import de.danielnaber.languagetool.tokenizers.Tokenizer;
+import org.languagetool.tokenizers.Tokenizer;
 
 /**
  * Tokenizes a sentence into words. Punctuation and whitespace gets its own token.

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/gl/GalicianWordTokenizer.java
Patch:
@@ -16,13 +16,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tokenizers.gl;
+package org.languagetool.tokenizers.gl;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.StringTokenizer;
 
-import de.danielnaber.languagetool.tokenizers.Tokenizer;
+import org.languagetool.tokenizers.Tokenizer;
 
 /**
  * Tokenizes a sentence into words. Punctuation and whitespace gets its own token.

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/km/KhmerWordTokenizer.java
Patch:
@@ -16,13 +16,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tokenizers.km;
+package org.languagetool.tokenizers.km;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.StringTokenizer;
 
-import de.danielnaber.languagetool.tokenizers.Tokenizer;
+import org.languagetool.tokenizers.Tokenizer;
 
 /**
  * Tokenizes a sentence into words. Punctuation and whitespace gets its own token.

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/ml/MalayalamWordTokenizer.java
Patch:
@@ -16,13 +16,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tokenizers.ml;
+package org.languagetool.tokenizers.ml;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.StringTokenizer;
 
-import de.danielnaber.languagetool.tokenizers.Tokenizer;
+import org.languagetool.tokenizers.Tokenizer;
 
 /**
  * Tokenizes a sentence into words. Punctuation and whitespace gets its own token.

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/nl/DutchWordTokenizer.java
Patch:
@@ -17,12 +17,12 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tokenizers.nl;
+package org.languagetool.tokenizers.nl;
 
 import java.util.Arrays;
 import java.util.List;
 
-import de.danielnaber.languagetool.tokenizers.WordTokenizer;
+import org.languagetool.tokenizers.WordTokenizer;
 
 public class DutchWordTokenizer extends WordTokenizer {
 

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/ro/RomanianWordTokenizer.java
Patch:
@@ -16,13 +16,13 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tokenizers.ro;
+package org.languagetool.tokenizers.ro;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.StringTokenizer;
 
-import de.danielnaber.languagetool.tokenizers.Tokenizer;
+import org.languagetool.tokenizers.Tokenizer;
 
 /**
  * Tokenizes a sentence into words. Punctuation and whitespace gets its own

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/zh/ChineseSentenceTokenizer.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tokenizers.zh;
+package org.languagetool.tokenizers.zh;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -25,7 +25,7 @@
 import org.ictclas4j.segment.SentenceSeg;
 import org.ictclas4j.utility.Utility;
 
-import de.danielnaber.languagetool.tokenizers.SentenceTokenizer;
+import org.languagetool.tokenizers.SentenceTokenizer;
 
 public class ChineseSentenceTokenizer extends SentenceTokenizer {
 

File: trunk/JLanguageTool/src/java/org/languagetool/tokenizers/zh/ChineseWordTokenizer.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.tokenizers.zh;
+package org.languagetool.tokenizers.zh;
 
 import java.io.InputStream;
 import java.util.ArrayList;
@@ -26,8 +26,8 @@
 
 import cn.com.cjf.CJFBeanFactory;
 import cn.com.cjf.ChineseJF;
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.tokenizers.Tokenizer;
+import org.languagetool.JLanguageTool;
+import org.languagetool.tokenizers.Tokenizer;
 
 public class ChineseWordTokenizer implements Tokenizer {
 

File: trunk/JLanguageTool/src/java/org/languagetool/tools/LanguageIdentifierTools.java
Patch:
@@ -1,12 +1,12 @@
-package de.danielnaber.languagetool.tools;
+package org.languagetool.tools;
 
 import java.io.BufferedReader;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 
 import org.apache.tika.language.*;
 
-import de.danielnaber.languagetool.JLanguageTool;
+import org.languagetool.JLanguageTool;
 
 public class LanguageIdentifierTools {
 

File: trunk/JLanguageTool/src/java/org/languagetool/tools/SymbolLocator.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tools;
+package org.languagetool.tools;
 
 /**
  * Helper class for GenericUnpairedBracketsRule to identify

File: trunk/JLanguageTool/src/java/org/languagetool/tools/UnsyncStack.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package de.danielnaber.languagetool.tools;
+package org.languagetool.tools;
 
 import java.util.ArrayList;
 import java.util.EmptyStackException;

File: trunk/JLanguageTool/src/test/org/languagetool/AbstractSecurityTestCase.java
Patch:
@@ -18,7 +18,7 @@
  */
 
 
-package de.danielnaber.languagetool;
+package org.languagetool;
 
 import junit.framework.TestCase;
 import java.security.Permission;

File: trunk/JLanguageTool/src/test/org/languagetool/AnalyzedTokenReadingsTest.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package de.danielnaber.languagetool;
+package org.languagetool;
 
 import junit.framework.TestCase;
 

File: trunk/JLanguageTool/src/test/org/languagetool/AnalyzedTokenTest.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package de.danielnaber.languagetool;
+package org.languagetool;
 
 import junit.framework.TestCase;
 

File: trunk/JLanguageTool/src/test/org/languagetool/JLanguageToolTest.java
Patch:
@@ -16,15 +16,15 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool;
+package org.languagetool;
 
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.List;
 
 import junit.framework.TestCase;
-import de.danielnaber.languagetool.JLanguageTool.ParagraphHandling;
-import de.danielnaber.languagetool.rules.RuleMatch;
+import org.languagetool.JLanguageTool.ParagraphHandling;
+import org.languagetool.rules.RuleMatch;
 
 /**
  * @author Daniel Naber

File: trunk/JLanguageTool/src/test/org/languagetool/MainTest.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package de.danielnaber.languagetool;
+package org.languagetool;
 
 import java.io.ByteArrayOutputStream;
 import java.io.ByteArrayInputStream;
@@ -76,7 +76,7 @@ public void testUsageMessage() throws IOException, ParserConfigurationException,
       fail("LT should have exited with status 0!");
     } catch (ExitException e) {
       String output = new String(this.out.toByteArray());
-      assertTrue(output.indexOf("Usage: java de.danielnaber.languagetool.Main [-r|--recursive] [-v|--verbose") != -1);
+      assertTrue(output.indexOf("Usage: java org.languagetool.Main [-r|--recursive] [-v|--verbose") != -1);
       assertEquals("Exit status", 1, e.status);
     }
   }

File: trunk/JLanguageTool/src/test/org/languagetool/TranslationTest.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool;
+package org.languagetool;
 
 import java.io.BufferedReader;
 import java.io.File;
@@ -28,7 +28,7 @@
 import java.util.Properties;
 import java.util.Set;
 
-import de.danielnaber.languagetool.tools.StringTools;
+import org.languagetool.tools.StringTools;
 
 import junit.framework.TestCase;
 
@@ -110,7 +110,7 @@ private List<String> loadFile(File file) throws IOException {
 
   private File getTranslationFile(Language lang) {
     return new File("src" + File.separator + "java" + File.separator
-        + "de" + File.separator + "danielnaber" + File.separator + "languagetool" 
+        + "org" + File.separator + "languagetool" 
         + File.separator + "MessagesBundle_" + lang.getShortName() + ".properties");
   }
 

File: trunk/JLanguageTool/src/test/org/languagetool/ValidateXMLTest.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool;
+package org.languagetool;
 
 import java.io.IOException;
 import java.io.InputStream;

File: trunk/JLanguageTool/src/test/org/languagetool/VersionNumberTest.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool;
+package org.languagetool;
 
 import java.io.BufferedReader;
 import java.io.FileReader;
@@ -33,7 +33,7 @@ public void testVersionNumber() throws IOException {
     Pattern p1 = Pattern.compile("version = ([0-9\\.]+(-dev)?)");
     Matcher m1 = p1.matcher(buildFile);
     m1.find();
-    String javaFile = load("src/java/de/danielnaber/languagetool/JLanguageTool.java");
+    String javaFile = load("src/java/org/languagetool/JLanguageTool.java");
     Pattern p2 = Pattern.compile("VERSION = \"(.*?)\"");
     Matcher m2 = p2.matcher(javaFile);
     m2.find();

File: trunk/JLanguageTool/src/test/org/languagetool/XMLValidator.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool;
+package org.languagetool;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -39,7 +39,7 @@
 import org.xml.sax.SAXParseException;
 import org.xml.sax.helpers.DefaultHandler;
 
-import de.danielnaber.languagetool.tools.StringTools;
+import org.languagetool.tools.StringTools;
 
 /**
  * Validate XML files with a given DTD.

File: trunk/JLanguageTool/src/test/org/languagetool/bitext/TabBitextReaderTest.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package de.danielnaber.languagetool.bitext;
+package org.languagetool.bitext;
 
 import java.io.File;
 import java.io.FileOutputStream;

File: trunk/JLanguageTool/src/test/org/languagetool/bitext/WordFastTMReaderTest.java
Patch:
@@ -17,7 +17,7 @@
  * USA
  */
 
-package de.danielnaber.languagetool.bitext;
+package org.languagetool.bitext;
 
 import java.io.File;
 import java.io.FileOutputStream;

File: trunk/JLanguageTool/src/test/org/languagetool/dev/conversion/AtdRuleConverterTest.java
Patch:
@@ -1,4 +1,4 @@
-package de.danielnaber.languagetool.dev.conversion;
+package org.languagetool.dev.conversion;
 
 import junit.framework.TestCase;
 

File: trunk/JLanguageTool/src/test/org/languagetool/dev/index/AnyCharTokenizerTest.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev.index;
+package org.languagetool.dev.index;
 
 import java.io.StringReader;
 

File: trunk/JLanguageTool/src/test/org/languagetool/dev/index/IndexerSearcherTest.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev.index;
+package org.languagetool.dev.index;
 
 import java.io.File;
 import java.io.IOException;
@@ -27,7 +27,7 @@
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 
-import de.danielnaber.languagetool.Language;
+import org.languagetool.Language;
 
 public class IndexerSearcherTest extends LuceneTestCase {
   private IndexSearcher searcher;

File: trunk/JLanguageTool/src/test/org/languagetool/dev/index/LanguageToolFilterTest.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev.index;
+package org.languagetool.dev.index;
 
 import java.io.IOException;
 import java.io.StringReader;
@@ -28,8 +28,8 @@
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
 import org.apache.lucene.analysis.tokenattributes.TypeAttribute;
 
-import de.danielnaber.languagetool.JLanguageTool;
-import de.danielnaber.languagetool.Language;
+import org.languagetool.JLanguageTool;
+import org.languagetool.Language;
 
 public class LanguageToolFilterTest extends BaseTokenStreamTestCase {
   

File: trunk/JLanguageTool/src/test/org/languagetool/dev/index/RegexNotQueryTest.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev.index;
+package org.languagetool.dev.index;
 
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;

File: trunk/JLanguageTool/src/test/org/languagetool/dev/wikipedia/WikipediaTextFilterTest.java
Patch:
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
  * USA
  */
-package de.danielnaber.languagetool.dev.wikipedia;
+package org.languagetool.dev.wikipedia;
 
 import junit.framework.TestCase;
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/km/KhmerUnpairedBracketsRule.java
Patch:
@@ -9,8 +9,8 @@
 
 public class KhmerUnpairedBracketsRule extends GenericUnpairedBracketsRule {
   
-  private static final String[] KM_START_SYMBOLS = { "[", "(", "{", "â€œ", "\"", "'", "«" };
-  private static final String[] KM_END_SYMBOLS   = { "]", ")", "}", "â€�", "\"", "'", "»" };
+  private static final String[] KM_START_SYMBOLS = { "[", "(", "{", "“", "\"", "'", "«" };
+  private static final String[] KM_END_SYMBOLS   = { "]", ")", "}", "”", "\"", "'", "»" };
   
   public KhmerUnpairedBracketsRule(final ResourceBundle messages, final Language language) {
     super(messages, language);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/FalseFriendRuleLoader.java
Patch:
@@ -32,6 +32,7 @@
 import javax.xml.parsers.SAXParser;
 import javax.xml.parsers.SAXParserFactory;
 
+import org.apache.commons.lang.StringUtils;
 import org.xml.sax.Attributes;
 import org.xml.sax.SAXException;
 import org.xml.sax.helpers.DefaultHandler;
@@ -244,14 +245,14 @@ public void endElement(final String namespaceURI, final String sName,
           && !translations.isEmpty()) {
         formatter.applyPattern(messages.getString("false_friend_hint"));
         final Object[] messageArguments = {
-            elements.toString().replace('|', '/'),
+            StringUtils.join(elementList, " ").replace('|', '/'),
             messages.getString(textLanguage.getShortName()),
             formatTranslations(translations),
             messages.getString(motherTongue.getShortName()) };
         final String description = formatter.format(messageArguments);
         final PatternRule rule = new PatternRule(id, language, elementList,
             messages.getString("false_friend_desc") + " "
-                + elements.toString().replace('|', '/'), description, messages
+                + StringUtils.join(elementList, " ").replace('|', '/'), description, messages
                 .getString("false_friend"));
         rule.setCorrectExamples(correctExamples);
         rule.setIncorrectExamples(incorrectExamples);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/German.java
Patch:
@@ -91,7 +91,7 @@ public Contributor[] getMaintainers() {
   public List<Class<? extends Rule>> getRelevantRules() {
     return Arrays.asList(
             CommaWhitespaceRule.class,
-            DoublePunctuationRule.class,
+            GermanDoublePunctuationRule.class,
             GenericUnpairedBracketsRule.class,
             UppercaseSentenceStartRule.class,
             WhitespaceRule.class,

File: trunk/JLanguageTool/src/dev/de/danielnaber/languagetool/dev/wikipedia/CheckWikipediaDump.java
Patch:
@@ -78,7 +78,7 @@ public static void main(String[] args) throws IOException, SAXException, ParserC
     }
     int maxArticles = 0;
     if (args.length == 6) {
-      maxArticles = Integer.parseInt(args[4]);
+      maxArticles = Integer.parseInt(args[5]);
     }
     String[] ruleIds = null;
     if (!"-".equals(args[4])) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/RuleMatch.java
Patch:
@@ -62,8 +62,8 @@ public RuleMatch(Rule rule, int fromPos, int toPos, String message, String short
   /**
    * Creates a RuleMatch object, taking the rule that triggered
    * this match, position of the match and an explanation message.
-   * This message is scanned for &lt;suggestion>...&lt;/suggestion> to get suggested
-   * fixes for the problem detected by this rule. 
+   * This message is scanned for &lt;suggestion&gt;...&lt;/suggestion&gt;
+   * to get suggested fixes for the problem detected by this rule. 
    * 
    * @param startWithUppercase whether the original text at the position
    *    of the match start with an uppercase character
@@ -214,7 +214,7 @@ public void setSuggestedReplacements(final List<String> replacement) {
   /**
    * The text fragments which might be an appropriate fix for the problem. One
    * of these fragments can be used to replace the old text between getFromPos()
-   * to getToPos(). Text between &lt;suggestion> and &lt;/suggestion> is
+   * to getToPos(). Text between &lt;suggestion&gt; and &lt;/suggestion&gt; is
    * taken as the suggested replacement. 
    * @return List of String objects or an empty List
    */

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/CompoundRuleTestAbs.java
Patch:
@@ -48,7 +48,7 @@ public void check(int expectedErrors, String text) throws IOException {
   
   /**
    * Check the text against the compound rule.    
-   * @param expectedErrors teh number of extected errors.
+   * @param expectedErrors the number of expected errors.
    * @param text the text to check.
    * @param expSuggestions the expected suggestions.
    * @throws IOException thrown by JLanguageTool.

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/ro/RomanianPatternRuleTest.java
Patch:
@@ -10,7 +10,7 @@
  * 
  * This testcase is not for actual rules but for PatternRuleTest to ensure proper 
  * xml cleaning: there is a romanian rule where "<<" is used; we want 
- * "X<marker><<</marker>Y" to be tranformed into "X<<Y", not into "XY" 
+ * "X<marker><<</marker>Y" to be transformed into "X<<Y", not into "XY" 
  * (see rule id GHILIMELE_DUBLE_INTERIOR_INCEPUT in ro/grammar.xml).  
  *  
  */

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tokenizers/SRXSentenceTokenizerTest.java
Patch:
@@ -91,7 +91,7 @@ public void testTokenize() {
     // Missing space after sentence end:
     testSplit(new String[] { "James is from the Ireland!", "He lives in Spain now." });
     // From the abbreviation list:
-    testSplit(new String[] { "Jones Bros. have built a succesful company." });
+    testSplit(new String[] { "Jones Bros. have built a successful company." });
     // parentheses:
     testSplit(new String[] { "It (really!) works." });
     testSplit(new String[] { "It [really!] works." });

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tokenizers/SentenceTokenizerTest.java
Patch:
@@ -90,7 +90,7 @@ public void testTokenize() {
     // Missing space after sentence end:
     testSplit(new String[] { "James is from the Ireland!", "He lives in Spain now." });
     // From the abbreviation list:
-    testSplit(new String[] { "Jones Bros. have built a succesful company." });
+    testSplit(new String[] { "Jones Bros. have built a successful company." });
     // parentheses:
     testSplit(new String[] { "It (really!) works." });
     testSplit(new String[] { "It [really!] works." });

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tagging/disambiguation/rules/fr/FrenchRuleDisambiguatorTest.java
Patch:
@@ -54,13 +54,13 @@ public void testChunker() throws IOException {
         "/[null]SENT_START Il/[il]R pers suj 3 m s  /[null]null a/[avoir]V avoir ind pres 3 s  /[null]null enfin/[enfin]A  /[null]null publié/[publier]V ppa m s  /[null]null son/[son]D e s  /[null]null livre/[livre]N e s ./[null]null", 
         tokenizer, sentenceTokenizer, tagger, disambiguator);
     TestTools.myAssert("Il a enfin publié son livre.",
-        "/[null]SENT_START Il/[il]R pers suj 3 m s  /[null]null a/[a]N m sp|a/[avoir]V avoir ind pres 3 s  /[null]null enfin/[enfin]A  /[null]null publié/[publier]V ppa m s|publié/[publié]J m s  /[null]null son/[son]D m s|son/[son]N m s  /[null]null livre/[livre]N e s|livre/[livrer]V imp pres 2 s|livre/[livrer]V ind pres 1 s|livre/[livrer]V ind pres 3 s|livre/[livrer]V sub pres 1 s|livre/[livrer]V sub pres 3 s ./[null]null", 
+        "/[null]SENT_START Il/[il]R pers suj 3 m s  /[null]null a/[a]N m sp|a/[avoir]V avoir ind pres 3 s  /[null]null enfin/[enfin]A  /[null]null publié/[publier]V ppa m s|publié/[publié]J m s  /[null]null son/[son]D m s|son/[son]N m s  /[null]null livre/[livre]N e s|livre/[livrer]V imp pres 2 s|livre/[livrer]V ind pres 1 s|livre/[livrer]V ind pres 3 s|livre/[livrer]V sub pres 1 s|livre/[livrer]V sub pres 3 s ./[null]null",
         tokenizer, sentenceTokenizer, tagger, disamb2);
     TestTools.myAssert("Je danse toutes les semaines au club.",
-        "/[null]SENT_START Je/[je]R pers suj 1 s  /[null]null danse/[danser]V ind pres 1 s|danse/[danser]V sub pres 1 s  /[null]null toutes/[tous]R f p|toutes/[tout]D f p|toutes/[touter]V ind pres 2 s|toutes/[touter]V sub pres 2 s  /[null]null les/[le]D e p  /[null]null semaines/[semaine]N f p  /[null]null au/[au]D m s  /[null]null club/[club]N m s ./[null]null", 
+        "/[null]SENT_START Je/[je]R pers suj 1 s  /[null]null danse/[danser]V ind pres 1 s|danse/[danser]V sub pres 1 s  /[null]null toutes/[tous]R f p|toutes/[tout]D f p  /[null]null les/[le]D e p  /[null]null semaines/[semaine]N f p  /[null]null au/[au]D m s  /[null]null club/[club]N m s ./[null]null",
         tokenizer, sentenceTokenizer, tagger, disambiguator);
     TestTools.myAssert("Je danse toutes les semaines au club.",
-        "/[null]SENT_START Je/[je]R pers suj 1 s  /[null]null danse/[danse]N f s|danse/[danser]V imp pres 2 s|danse/[danser]V ind pres 1 s|danse/[danser]V ind pres 3 s|danse/[danser]V sub pres 1 s|danse/[danser]V sub pres 3 s  /[null]null toutes/[tous]R f p|toutes/[tout]D f p|toutes/[touter]V ind pres 2 s|toutes/[touter]V sub pres 2 s  /[null]null les/[le]D e p|les/[les]R pers obj 3 p  /[null]null semaines/[semaine]N f p  /[null]null au/[au]D m s  /[null]null club/[club]N m s ./[null]null", 
+        "/[null]SENT_START Je/[je]R pers suj 1 s  /[null]null danse/[danse]N f s|danse/[danser]V imp pres 2 s|danse/[danser]V ind pres 1 s|danse/[danser]V ind pres 3 s|danse/[danser]V sub pres 1 s|danse/[danser]V sub pres 3 s  /[null]null toutes/[tous]R f p|toutes/[tout]D f p  /[null]null les/[le]D e p|les/[les]R pers obj 3 p  /[null]null semaines/[semaine]N f p  /[null]null au/[au]D m s  /[null]null club/[club]N m s ./[null]null", 
         tokenizer, sentenceTokenizer, tagger, disamb2);
     TestTools.myAssert("Quand j'étais petit, je jouais au football.",
         "/[null]SENT_START Quand/[quand]C sub  /[null]null j/[je]R pers suj 1 s '/[null]null étais/[être]V etre ind impa 1 s  /[null]null petit/[petit]J m s ,/[null]null  /[null]null je/[je]R pers suj 1 s  /[null]null jouais/[jouer]V ind impa 1 s  /[null]null au/[au]D m s  /[null]null football/[football]N m s ./[null]null", 

File: trunk/JLanguageTool/src/dev/de/danielnaber/languagetool/dev/ExportGermanNouns.java
Patch:
@@ -45,7 +45,7 @@ private ExportGermanNouns() {
   }
   
   private Set<String> getWords() throws IOException {
-    final FSA fsa = FSA.getInstance(JLanguageTool.getDataBroker().getFromResourceDirAsStream(DICT_FILENAME));
+    final FSA fsa = FSA.read(JLanguageTool.getDataBroker().getFromResourceDirAsStream(DICT_FILENAME));
     String lastTerm = null;
     final Set<String> set = new HashSet<String>();
     for (ByteBuffer bb : fsa) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/br/BretonWordTokenizer.java
Patch:
@@ -62,7 +62,7 @@ public List<String> tokenize(final String text) {
     while (itr.hasNext()) {
       String word = itr.next().replace("##BR_APOS##", "’");
       tokens.add(word);
-      if (word.endsWith("’")) {
+      if (!word.equals("’") && word.endsWith("’")) {
         word = itr.next(); // Skip the next spurious white space.
       }
     }

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -522,7 +522,7 @@ private static String callFormatMultipleSynthesis(final String[] suggestions,
    * Test XML patterns, as a help for people developing rules that are not
    * programmers.
    */
-  public static void main2(final String[] args) throws IOException {
+  public static void main(final String[] args) throws IOException {
     final PatternRuleTest test = new PatternRuleTest();
     System.out.println("Running XML pattern tests...");
     test.setUp();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Language.java
Patch:
@@ -46,6 +46,7 @@
 public abstract class Language {
 
   // NOTE: keep in sync with array below!
+  public static final Language BRETON = new Breton();
   //public final static Language CZECH = new Czech();
   public static final Language CHINESE = new Chinese();
   public static final Language DANISH = new Danish();
@@ -83,7 +84,7 @@ public abstract class Language {
   public static Language[] LANGUAGES = {
     ENGLISH, GERMAN, POLISH, FRENCH, SPANISH, ITALIAN, KHMER, DUTCH, LITHUANIAN, UKRAINIAN, RUSSIAN,
     SLOVAK, SLOVENIAN, SWEDISH, ROMANIAN, ICELANDIC, GALICIAN, CATALAN, DANISH,
-    MALAYALAM, BELARUSIAN, ESPERANTO, CHINESE, ASTURIAN, TAGALOG, 
+    MALAYALAM, BELARUSIAN, ESPERANTO, CHINESE, ASTURIAN, TAGALOG, BRETON,
     DEMO
   };
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/Main.java
Patch:
@@ -549,8 +549,7 @@ private void tagTextAndDisplayResults(final JLanguageTool langTool) {
         sb.append("An error occurred while tagging the text: " + e.getMessage());
       }
       final String s = sb.toString().replaceAll("<S>", "SENT_START").replaceAll("</S>", "");
-
-      resultArea.setText(HTML_FONT_START + s + HTML_FONT_END);
+      resultArea.setText(HTML_FONT_START + StringTools.escapeHTML(s) + HTML_FONT_END);
     }
   }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/Main.java
Patch:
@@ -781,7 +781,7 @@ public boolean equals(Object o) {
       if (this == o) return true;
       if (o == null || getClass() != o.getClass()) return false;
       final I18nLanguage other = (I18nLanguage) o;
-      return language.toString().equals(other.toString());
+      return language.toString().equals(other.toString()) && language.isExternal() == other.language.isExternal();
     }
 
     @Override

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/JLanguageTool.java
Patch:
@@ -501,7 +501,7 @@ public List<RuleMatch> check(final String text, boolean tokenizeText, final Para
       }      
     }
 
-    if (!paraMode.equals(ParagraphHandling.ONLYNONPARA)) {
+    if (!ruleMatches.isEmpty() && !paraMode.equals(ParagraphHandling.ONLYNONPARA)) {
       // removing false positives in paragraph-level rules
       for (final Rule rule : allRules) {
         if (rule.isParagraphBackTrack() && (rule.getMatches() != null)) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/eo/EsperantoTagger.java
Patch:
@@ -58,7 +58,7 @@ public class EsperantoTagger implements Tagger {
   // Following preposition are never followed by accusative.
   private static final String prepositionsNoAccusative[] = {
     "al", "cis", "da", "de", "depost", "disde", "dum", "ekde",
-    "el", "far", "ĝis", "je", "kun", "laŭ", "malgraŭ", "na",
+    "el", "far", "ĝis", "graŭ", "je", "kun", "laŭ", "malgraŭ", "na",
     "per", "po", "post", "por", "pri", "pro", "sen"
   };
 
@@ -112,7 +112,7 @@ public class EsperantoTagger implements Tagger {
 
   // Verbs always end with this pattern.
   private static final Pattern patternVerb = Pattern.compile("(.*)(as|os|is|us|u|i)$");
-  private static final Pattern patternVerbIg = Pattern.compile("(ig|iĝ)i$");
+  private static final Pattern patternVerbIg = Pattern.compile("i(g|ĝ)i$");
   private static final Pattern patternPrefix = Pattern.compile("^(mal|mis|ek|re|fi|ne)(.*)");
   private static final Pattern patternSuffix = Pattern.compile("(.*)(ad|aĉ|eg|et)i$");
 
@@ -192,7 +192,7 @@ private String findTransitivity(String verb) {
     final Matcher matcher = patternVerbIg.matcher(verb);
 
     if (matcher.find()) {
-      return matcher.group(1).equals("ig") ? "tr" : "nt";
+      return matcher.group(1).equals("g") ? "tr" : "nt";
     }
 
     // This loop executes only once for most verbs (or very few times).

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/eo/EsperantoTagger.java
Patch:
@@ -50,7 +50,7 @@ public class EsperantoTagger implements Tagger {
   // These words don't need to be tagged.
   private static final String wordsNotTagged[] = {
     "ajn", "ĉi", "ĉu", "des", "ja", "ju", "ke", "malpli", 
-    "ne", "ol", "pli"
+    "ne", "ol", "pli", "pli-malpli"
   };
 
   private static final Set<String> setWordsNotTagged = new HashSet<String>(Arrays.asList(wordsNotTagged));

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/dev/index/LanguageToolFilterTest.java
Patch:
@@ -32,12 +32,13 @@
 import de.danielnaber.languagetool.Language;
 
 public class LanguageToolFilterTest extends BaseTokenStreamTestCase {
+  
   public void testFilter() throws Exception {
     String input = "How do you thin?";
 
     TokenStream stream = new AnyCharTokenizer(TEST_VERSION_CURRENT, new StringReader(input));
     LanguageToolFilter filter = new LanguageToolFilter(stream, new JLanguageTool(Language.ENGLISH));
-    displayTokensWithFullDetails(filter);
+    //displayTokensWithFullDetails(filter);
 
     stream = new AnyCharTokenizer(TEST_VERSION_CURRENT, new StringReader(input));
     filter = new LanguageToolFilter(stream, new JLanguageTool(Language.ENGLISH));

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/CommaWhitespaceRuleTest.java
Patch:
@@ -67,8 +67,6 @@ public void testRule() throws IOException {
     assertEquals(1, matches.length);
     matches = rule.match(langTool.getAnalyzedSentence("This (foo bar ) is a test!."));      
     assertEquals(1, matches.length);
-    matches = rule.match(langTool.getAnalyzedSentence("This(foo bar) is a test!."));      
-    assertEquals(1, matches.length);
     
     //other brackets, first [
     matches = rule.match(langTool.getAnalyzedSentence("This [ foo bar) is a test!."));

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/zh/ChineseWordTokenizer.java
Patch:
@@ -43,7 +43,7 @@ private void init() {
       InputStream coreDictIn = JLanguageTool.getDataBroker().getFromResourceDirAsStream(
           "/zh/coreDict.dct");
       InputStream bigramDictIn = JLanguageTool.getDataBroker().getFromResourceDirAsStream(
-          "/zh/bigramDict.dct");
+          "/zh/BigramDict.dct");
       InputStream personTaggerDctIn = JLanguageTool.getDataBroker().getFromResourceDirAsStream(
           "/zh/nr.dct");
       InputStream personTaggerCtxIn = JLanguageTool.getDataBroker().getFromResourceDirAsStream(

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/en/EnglishUnpairedBracketsRuleTest.java
Patch:
@@ -132,11 +132,11 @@ public void testMultipleSentences() throws IOException {
 
     List<RuleMatch> matches;
     matches = tool
-        .check("This is multiple sentence text that contains a bracket:"
+        .check("This is multiple sentence text that contains a bracket: "
             + "[This is bracket. With some text.] and this continues.\n");
     assertEquals(0, matches.size());
     matches = tool
-        .check("This is multiple sentence text that contains a bracket:"
+        .check("This is multiple sentence text that contains a bracket: "
             + "[This is bracket. With some text. And this continues.\n\n");
     assertEquals(1, matches.size());
     // now with a paragraph end inside - we get two alarms because of paragraph

File: trunk/JLanguageTool/src/dev/de/danielnaber/languagetool/dev/index/PatternRuleQueryBuilder.java
Patch:
@@ -149,7 +149,7 @@ private static void checkUnsupportedRule(Element patternElement)
 
     if (patternElement.isInflected()) {
       throw new UnsupportedPatternRuleException(
-          "Pattern rules with inflated tokens are not supported.");
+          "Pattern rules with inflected tokens are not supported.");
     }
 
   }

File: trunk/JLanguageTool/src/dev/de/danielnaber/languagetool/dev/wikipedia/WikipediaIndexHandler.java
Patch:
@@ -163,7 +163,8 @@ public static void main(String... strings) throws Exception {
     final SAXParserFactory factory = SAXParserFactory.newInstance();
     final SAXParser saxParser = factory.newSAXParser();
     WikipediaIndexHandler handler = new WikipediaIndexHandler(FSDirectory.open(new File(
-        "E:\\project\\data\\index_zh")), Language.CHINESE, 4001, 10000);
+        //"E:\\project\\data\\index_zh")), Language.CHINESE, 4001, 10000);
+        "E:\\project\\data\\index_zh")), Language.ENGLISH, 4001, 10000);
     try {
       saxParser.parse(new FileInputStream(new File(
           "E:\\project\\data\\zhwiki-latest-pages-meta-current.xml")), handler);

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/dev/index/PatternRuleQueryBuilderTest.java
Patch:
@@ -185,7 +185,7 @@ public void testUnsupportedPatternRule() throws Exception {
 
   }
 
-  public void testAllPatternRules() throws IOException {
+  /*public void testAllPatternRules() throws IOException {
     System.out.println("\nStatistics information for supported rule ratio of each language:");
     int successAll = 0;
     int failAll = 0;
@@ -231,5 +231,5 @@ public void testAllPatternRules() throws IOException {
       System.out.println("\t" + entry.getKey() + ": " + entry.getValue());
     }
 
-  }
+  }*/
 }

File: trunk/JLanguageTool/src/dev/de/danielnaber/languagetool/dev/index/RigidNearSpansOrdered.java
Patch:
@@ -318,9 +318,9 @@ private boolean shrinkToAfterShortestMatch() throws IOException {
 
       if (matchStart >= prevEnd) { // Only non overlapping spans add to slop.
         matchSlop += (matchStart - prevEnd);
-        if (allowedSlop > 0) {
-          matchSlop++;
-        }
+        // if (allowedSlop > 0) {
+        matchSlop++;
+        // }
       }
 
       /*

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/dev/index/PatternRuleQueryBuilderTest.java
Patch:
@@ -37,7 +37,7 @@
 import de.danielnaber.languagetool.rules.patterns.PatternRule;
 import de.danielnaber.languagetool.rules.patterns.PatternRuleLoader;
 
-public class PatternRuleQueryBuilderText extends LuceneTestCase {
+public class PatternRuleQueryBuilderTest extends LuceneTestCase {
   private IndexSearcher searcher;
 
   private IndexReader reader;

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/dev/index/PatternRuleQueryBuilderText.java
Patch:
@@ -37,7 +37,7 @@
 import de.danielnaber.languagetool.rules.patterns.PatternRule;
 import de.danielnaber.languagetool.rules.patterns.PatternRuleLoader;
 
-public class PatternRuleQueryBulderText extends LuceneTestCase {
+public class PatternRuleQueryBuilderText extends LuceneTestCase {
   private IndexSearcher searcher;
 
   private IndexReader reader;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/Esperanto.java
Patch:
@@ -22,7 +22,6 @@
 
 import de.danielnaber.languagetool.Language;
 import de.danielnaber.languagetool.rules.*;
-import de.danielnaber.languagetool.rules.fr.QuestionWhitespaceRule;
 import de.danielnaber.languagetool.tagging.Tagger;
 import de.danielnaber.languagetool.tagging.eo.EsperantoTagger;
 import de.danielnaber.languagetool.tokenizers.SentenceTokenizer;
@@ -79,8 +78,7 @@ public List<Class<? extends Rule>> getRelevantRules() {
             GenericUnpairedBracketsRule.class,
             UppercaseSentenceStartRule.class,
             WordRepeatRule.class,
-            WhitespaceRule.class,
-            QuestionWhitespaceRule.class
+            WhitespaceRule.class
     );
   }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/AgreementRule.java
Patch:
@@ -332,7 +332,7 @@ private RuleMatch checkDetAdjNounAgreement(final AnalyzedGermanTokenReadings tok
     RuleMatch ruleMatch = null;
     if (set.size() == 0) {
       // TODO: more detailed error message:
-      final String msg = "Möglicherweise fehlende Übereinstimmung (Kongruenz) zwischen Artikel, Adjektiv und " +
+      final String msg = "Möglicherweise fehlende grammatische Übereinstimmung zwischen Artikel, Adjektiv und " +
             "Nomen bezüglich Kasus, Numerus oder Genus. Beispiel: 'mein kleiner Haus' " +
             "statt 'mein kleines Haus'";
       ruleMatch = new RuleMatch(this, token1.getStartPos(), 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/Slovak.java
Patch:
@@ -99,8 +99,8 @@ public List<Class<? extends Rule>> getRelevantRules() {
             WordRepeatRule.class,
             WhitespaceRule.class,
             // specific to Slovak:
-            CompoundRule.class,
-            SlovakVesRule.class
+            CompoundRule.class
+            //SlovakVesRule.class
     );
   }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/Tagger.java
Patch:
@@ -39,7 +39,7 @@ public interface Tagger {
    * may implement special cases for the first word of a sentence, which is 
    * usually written with an uppercase letter.
    * 
-   * @param sentenceTokens the text as returned by a WordTokenizer but without whitespace tokens. 
+   * @param sentenceTokens the text as returned by a WordTokenizer 
    */
   public List<AnalyzedTokenReadings> tag(List<String> sentenceTokens) throws IOException;
   

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/FalseFriendRuleLoader.java
Patch:
@@ -293,7 +293,7 @@ public void endElement(final String namespaceURI, final String sName,
       if (currentTranslationLanguage == motherTongue) {
         translations.add(translation);
       }
-      if (currentTranslationLanguage == textLanguage) {
+      if (currentTranslationLanguage == textLanguage && language == motherTongue) {
         suggestions.add(translation.toString());
       }
       translation = new StringBuilder();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/Rule.java
Patch:
@@ -28,7 +28,7 @@
 
 /**
  * Abstract rule class. A Rule describes a language error and can test whether a
- * given pre-analyzed text contains that error using the {@link Rule#match}
+ * given pre-analyzed text contains that error using the {@link Rule#match(de.danielnaber.languagetool.AnalyzedSentence)}
  * method.
  * 
  * @author Daniel Naber
@@ -213,7 +213,7 @@ public final boolean isDefaultOff() {
   }
 
   /**
-   * Turns the rule by default off.
+   * Turns the rule off by default.
    **/
   public final void setDefaultOff() {
     defaultOff = true;

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/server/HTTPServerTest.java
Patch:
@@ -69,8 +69,9 @@ public void testHTTPServer() throws Exception {
       // test supported language listing
       final URL url = new URL("http://localhost:" + HTTPServer.DEFAULT_PORT + "/Languages");
       final String languagesXML = StringTools.streamToString((InputStream)url.getContent());
-      if (!languagesXML.contains("Romanian") || !languagesXML.contains("English"))
+      if (!languagesXML.contains("Romanian") || !languagesXML.contains("English")) {
         fail("Error getting supported languages: " + languagesXML);
+      }
       // tests for "&" character
       assertTrue(check(Language.ENGLISH, "Me & you you").contains("&"));
       // tests for mother tongue (copy from link {@link FalseFriendRuleTest})   

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/Belarusian.java
Patch:
@@ -32,8 +32,6 @@
  */
 public class Belarusian extends Language {
 
-    private static final String[] COUNTRIES = { "BY" };
-
     private final Tagger tagger = new BelarusianTagger();
 
     public Locale getLocale() {
@@ -49,7 +47,7 @@ public String getShortName() {
     }
 
     public String[] getCountryVariants() {
-        return COUNTRIES;
+        return new String[]{"BY"};
     }
 
     public Tagger getTagger() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/Czech.java
Patch:
@@ -34,8 +34,6 @@ public class Czech extends Language {
   private final Tagger tagger = new CzechTagger();
   private final SentenceTokenizer sentenceTokenizer = new CzechSentenceTokenizer();
 
-  private static final String[] COUNTRIES = {"CZ"};
-  
   public Locale getLocale() {
     return new Locale(getShortName());
   }
@@ -49,7 +47,7 @@ public String getShortName() {
   }
   
   public String[] getCountryVariants() {
-    return COUNTRIES;
+    return new String[]{"CZ"};
   }
 
   public Tagger getTagger() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/Danish.java
Patch:
@@ -32,8 +32,6 @@ public class Danish extends Language {
   private final Tagger tagger = new DanishTagger();
   private final SentenceTokenizer sentenceTokenizer = new SRXSentenceTokenizer("da");
   
-  private static final String[] COUNTRIES = {"DK"};
-  
   public final Locale getLocale() {
     return new Locale(getShortName());
   }
@@ -47,7 +45,7 @@ public final String getShortName() {
   }
 
   public final String[] getCountryVariants() {
-    return COUNTRIES;
+    return new String[]{"DK"};
   }
   
   public final Tagger getTagger() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/Dutch.java
Patch:
@@ -41,8 +41,6 @@ public class Dutch extends Language {
   private final Disambiguator disambiguator = new DutchRuleDisambiguator();
   private final Tokenizer wdTokenizer = new DutchWordTokenizer();
 
-  private static final String[] COUNTRIES = { "NL", "BE" };
-
   public final Locale getLocale() {
     return new Locale(getShortName());
   }
@@ -56,7 +54,7 @@ public final String getShortName() {
   }
 
   public final String[] getCountryVariants() {
-    return COUNTRIES;
+    return new String[]{"NL", "BE"};
   }
 
   public final Tagger getTagger() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/English.java
Patch:
@@ -44,8 +44,6 @@ public class English extends Language {
   private final Synthesizer synthesizer = new EnglishSynthesizer();
   private final Disambiguator disambiguator = new EnglishRuleDisambiguator();
 
-  private static final String[] COUNTRIES = {"GB", "US", "AU", "CA", "NZ", "ZA" };
-  
   public final Locale getLocale() {
     return new Locale(getShortName());
   }
@@ -63,7 +61,7 @@ public final String getShortName() {
   }
 
   public final String[] getCountryVariants() {
-    return COUNTRIES;
+    return new String[]{"GB", "US", "AU", "CA", "NZ", "ZA"};
   }
   
   public final Tagger getTagger() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/Galician.java
Patch:
@@ -35,8 +35,6 @@ public class Galician extends Language {
   private final Tokenizer wordTokenizer = new GalicianWordTokenizer();
   private final SentenceTokenizer sentenceTokenizer = new SRXSentenceTokenizer("gl");
 
-  private static final String[] COUNTRIES = {"ES"};
-  
   public final Locale getLocale() {
     return new Locale(getShortName());
   }
@@ -54,7 +52,7 @@ public final String getShortName() {
   }
 
   public final String[] getCountryVariants() {
-    return COUNTRIES;
+    return new String[]{"ES"};
   }
   
   public final Tagger getTagger() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/Malayalam.java
Patch:
@@ -35,8 +35,6 @@ public class Malayalam extends Language {
   private final SentenceTokenizer sentenceTokenizer = new SRXSentenceTokenizer("en");
   private final Tokenizer wordTokenizer = new MalayalamWordTokenizer();
 
-  private static final String[] COUNTRIES = {"IN"};
-  
   public final Locale getLocale() {
     return new Locale(getShortName());
   }
@@ -58,7 +56,7 @@ public final Tokenizer getWordTokenizer() {
   }
   
   public final String[] getCountryVariants() {
-    return COUNTRIES;
+    return new String[]{"IN"};
   }
   
   public final Tagger getTagger() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/Polish.java
Patch:
@@ -45,8 +45,6 @@ public class Polish extends Language {
   private static final Unifier POLISH_UNIFIER = new Unifier();
   private static final Unifier POLISH_DISAMB_UNIFIER = new Unifier();
   
-  private static final String[] COUNTRIES = {"PL"}; 
-    
   @Override
   public Locale getLocale() {
     return new Locale(getShortName());
@@ -64,7 +62,7 @@ public String getShortName() {
   
   @Override
   public String[] getCountryVariants() {
-    return COUNTRIES;
+    return new String[]{"PL"};
   }
   
   @Override

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/RuleFilenameException.java
Patch:
@@ -27,9 +27,6 @@
  */
 public class RuleFilenameException extends RuntimeException {
 
-  /**
-   * 
-   */
   private static final long serialVersionUID = 6642163394764392897L;
 
   public RuleFilenameException(File file) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tools/Tools.java
Patch:
@@ -317,7 +317,7 @@ public static List<RuleMatch> checkBitext(final String src, final String trg,
    final AnalyzedSentence srcText = srcLt.getAnalyzedSentence(src);
    final AnalyzedSentence trgText = trgLt.getAnalyzedSentence(trg);
    final List<RuleMatch> ruleMatches = trgLt.checkAnalyzedSentence
-     (JLanguageTool.paragraphHandling.NORMAL, 
+     (JLanguageTool.ParagraphHandling.NORMAL,
       trgLt.getAllRules(), 0, 0, 1, trg, trgText);     
     for (BitextRule bRule : bRules) {     
       final RuleMatch[] curMatch = bRule.match(srcText, trgText);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/sk/SlovakRule.java
Patch:
@@ -21,10 +21,9 @@
 import de.danielnaber.languagetool.rules.Rule;
 
 /**
- * Abstract base class for Polish rules.
+ * Abstract base class for Slovak rules.
  * 
  * @author Zdenko Podobný based on Polish rules
- *
  */
 public abstract class SlovakRule extends Rule {
 

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -246,7 +246,7 @@ private void testBadSentences(JLanguageTool languageTool, Language lang,
         RuleMatch[] matches = getMatches(rule, badSentence, languageTool);
         if (!rule.isWithComplexPhrase()) {
           assertTrue(lang + ": Did expect one error in: \"" + badSentence
-              + "\" (Rule: " + rule + "), got " + matches.length
+              + "\" (Rule: " + rule + "), but found " + matches.length
               + ". Additional info:" + rule.getMessage(), matches.length == 1);
           assertEquals(lang
               + ": Incorrect match position markup (start) for rule " + rule,

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/fr/FrenchTagger.java
Patch:
@@ -25,7 +25,7 @@
 
 /** French Tagger
  * 
- * Based on inDICO, implemented in FSA.
+ * Based on Dicollete (http://www.dicollecte.org/) implemented in FSA.
  * 
  * @author Marcin Milkowski
  */

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/Khmer.java
Patch:
@@ -54,7 +54,7 @@ public String getShortName() {
   }
 
   public String[] getCountryVariants() {
-    return new String[] {"KM"};
+    return COUNTRIES;
   }
   
   

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/Main.java
Patch:
@@ -589,6 +589,7 @@ public void run() {
             .println("Usage: java de.danielnaber.languagetool.gui.Main [-t|--tray]");
         System.out
             .println("  -t, --tray: dock LanguageTool to system tray on startup");
+        prg.stopServer();
       } else {
         javax.swing.SwingUtilities.invokeLater(new Runnable() {
           public void run() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tools/ReflectionUtils.java
Patch:
@@ -46,7 +46,7 @@ private ReflectionUtils() {
    *          skipping loading extra classes
    * @param subdirLevel
    *          If more than 0 all subdirectories/subpackages up to
-   *          <code>dirLevel</code> will be traversed This parameter is checked
+   *          <code>dirLevel</code> will be traversed. This parameter is checked
    *          before class is loaded - use it to improve performance by skipping
    *          loading extra classes
    * @param classExtends
@@ -101,7 +101,7 @@ private static void findClassesInDirectory(final ClassLoader classLoader,
     final File directory = new File(resource.toURI());
 
     if (!directory.exists() && !directory.isDirectory()) {
-      throw new Exception("directory does not exist: "
+      throw new Exception("Directory does not exist: "
           + directory.getAbsolutePath());
     }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/GenericUnpairedBracketsRule.java
Patch:
@@ -164,9 +164,9 @@ public String getDescription() {
 
   public void uniqueMapInit() {
     uniqueMap = new HashMap<String, Boolean>();
-    for (int j = 1; j < endSymbols.length; j++) {
+    for (int j = 0; j < endSymbols.length; j++) {
       int found = 0;
-      for (int i = 1; i < endSymbols.length; i++) {
+      for (int i = 0; i < endSymbols.length; i++) {
         if (endSymbols[i].equals(endSymbols[j])) {
           found++;
         }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/en/EnglishUnpairedBracketsRule.java
Patch:
@@ -38,6 +38,7 @@ public EnglishUnpairedBracketsRule(final ResourceBundle messages,
     super(messages, language);
     startSymbols = EN_START_SYMBOLS;
     endSymbols = EN_END_SYMBOLS;
+    uniqueMapInit();
   }
 
   public String getId() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/pl/PolishUnpairedBracketsRule.java
Patch:
@@ -34,6 +34,7 @@ public PolishUnpairedBracketsRule(final ResourceBundle messages,
     super(messages, language);
     startSymbols = PL_START_SYMBOLS;
     endSymbols = PL_END_SYMBOLS;
+    uniqueMapInit();
   }
 
   public String getId() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/ru/RussianUnpairedBracketsRule.java
Patch:
@@ -53,6 +53,7 @@ public RussianUnpairedBracketsRule(final ResourceBundle messages,
     super(messages, language);
     startSymbols = RU_START_SYMBOLS;
     endSymbols = RU_END_SYMBOLS;
+    uniqueMapInit();
   }
 
   public String getId() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Match.java
Patch:
@@ -463,7 +463,8 @@ public final AnalyzedTokenReadings filterReadings() {
         formattedToken.setWhitespaceBefore(matchedToken.isWhitespaceBefore());
       }
       String token = formattedToken.getToken();
-      if (pRegexMatch != null) {
+      if (pRegexMatch != null && regexReplace != null) {
+    	/* only replace if it is something to replace*/
         token = pRegexMatch.matcher(token).replaceAll(regexReplace);
       }
       token = convertCase(token);

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/synthesis/pl/PolishSynthesizerTest.java
Patch:
@@ -37,7 +37,7 @@ public final void testSynthesizeString() throws IOException {
     assertEquals("[Aaru]", Arrays.toString(synth.synthesize(dummyToken("Aar"), "subst:sg:gen:m3")));
     assertEquals("[Abchazem]", Arrays.toString(synth.synthesize(dummyToken("Abchaz"), "subst:sg:inst:m1")));
     assertEquals("[nieduży]", Arrays.toString(synth.synthesize(dummyToken("duży"), "adj:sg:nom:m:pos:neg")));        
-    assertEquals("[miała]", Arrays.toString(synth.synthesize(dummyToken("mieć"), "verb:praet:sg:ter:f:perf")));
+    assertEquals("[miała]", Arrays.toString(synth.synthesize(dummyToken("mieć"), "verb:praet:sg:ter:f:imperf")));
         assertEquals("[brzydziej]", Arrays.toString(synth.synthesize(dummyToken("brzydko"), "adv:comp")));
     //with regular expressions
     assertEquals("[tonera]", Arrays.toString(synth.synthesize(dummyToken("toner"), ".*sg.*[\\.:]gen.*", true)));

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/bitext/BitextPatternRuleTest.java
Patch:
@@ -39,7 +39,7 @@
 public class BitextPatternRuleTest extends TestCase {
 
   public void testBitextRulesFromXML() throws IOException {
-    testBitextRulesFromXML(null, true);
+    testBitextRulesFromXML(null, false);
   }
   
   private void testBitextRulesFromXML(final Set<Language> ignoredLanguages,

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/eo/EsperantoTagger.java
Patch:
@@ -49,7 +49,8 @@ public class EsperantoTagger implements Tagger {
 
   // These words don't need to be tagged.
   private final static String wordsNotTagged[] = {
-    "ajn", "ĉi", "des", "do", "ja", "ju", "ke", "malpli", "ne", "nek", "ol", "pli"
+    "ajn", "ĉi", "ĉu", "des", "do", "ja", "ju", "ke", "malpli", 
+    "ne", "nek", "ol", "pli"
   };
 
   private final static Set setWordsNotTagged = new HashSet<String>(Arrays.asList(wordsNotTagged));

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/eo/EsperantoTagger.java
Patch:
@@ -49,7 +49,7 @@ public class EsperantoTagger implements Tagger {
 
   // These words don't need to be tagged.
   private final static String wordsNotTagged[] = {
-    "ajn", "ĉi", "des", "ja", "ju", "ke", "malpli", "ne", "nek", "ol", "pli"
+    "ajn", "ĉi", "des", "do", "ja", "ju", "ke", "malpli", "ne", "nek", "ol", "pli"
   };
 
   private final static Set setWordsNotTagged = new HashSet<String>(Arrays.asList(wordsNotTagged));

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/eo/EsperantoTagger.java
Patch:
@@ -49,7 +49,7 @@ public class EsperantoTagger implements Tagger {
 
   // These words don't need to be tagged.
   private final static String wordsNotTagged[] = {
-    "ajn", "ĉi", "des", "ja", "ju", "malpli", "ne", "nek", "ol", "pli"
+    "ajn", "ĉi", "des", "ja", "ju", "ke", "malpli", "ne", "nek", "ol", "pli"
   };
 
   private final static Set setWordsNotTagged = new HashSet<String>(Arrays.asList(wordsNotTagged));

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tagging/eo/EsperantoTaggerTest.java
Patch:
@@ -40,6 +40,6 @@ public void setUp() {
 
   public void testTagger() throws IOException {
     TestTools.myAssert("Tio estas simpla testo",
-        "Tio/[null]T nak np t o -- estas/[est]V nt as -- simpla/[simpl]A nak np -- testo/[test]O nak np", tokenizer, tagger);
+        "Tio/[null]T nak np t o -- estas/[esti]V nt as -- simpla/[simpla]A nak np -- testo/[testo]O nak np", tokenizer, tagger);
   }
 }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Main.java
Patch:
@@ -163,7 +163,7 @@ private void runOnFile(final String filename, final String encoding,
         //TODO: add parameter to set different readers        
         TabBitextReader reader = new TabBitextReader(filename, encoding);        
         Tools.checkBitext(reader, srcLt, lt, bRules,
-            apiFormat, StringTools.XmlPrintMode.NORMAL_XML);        
+            apiFormat);        
       } else {
         final String text = getFilteredText(filename, encoding);
         if (applySuggestions) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -148,7 +148,7 @@ public void startElement(final String namespaceURI, final String lName,
         uTypeList.add(uType);
     } else if (qName.equals(TOKEN)) {
       setToken(attrs);
-    } else if (qName.equals(EXCEPTION)) {
+    } else if (EXCEPTION.equals(qName)) {
       setExceptions(attrs);
     } else if (qName.equals(EXAMPLE)
         && attrs.getValue(TYPE).equals("correct")) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Main.java
Patch:
@@ -156,10 +156,10 @@ private void runOnFile(final String filename, final String encoding,
         lt.setOutput(System.err);
       }
       if (!apiFormat && !applySuggestions) {
-        if (!"-".equals(filename)) {
-          System.out.println("Working on " + filename + "...");
+        if ("-".equals(filename)) {
+          System.out.println("Working on STDIN...");          
         } else {
-          System.out.println("Working on STDIN...");
+          System.out.println("Working on " + filename + "...");
         }
       }
       int runCount = 1; 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/bitext/TabBitextReader.java
Patch:
@@ -83,8 +83,9 @@ public StringPair next() {
           nextLine = in.readLine();
           nextPair = tab2StringPair(nextLine);
           lineCount++;
-          if (nextLine == null)
+          if (nextLine == null) {
             in.close();
+          }
         }
         return result;
       } catch(IOException e) { 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/bitext/WordFastTMReader.java
Patch:
@@ -39,7 +39,7 @@ public WordFastTMReader(final String filename, final String encoding) throws IOE
     }
   }
   
-  protected StringPair tab2StringPair(final String line) {
+  public final StringPair tab2StringPair(final String line) {
     if (line == null) {
       return null;
     }
@@ -66,8 +66,9 @@ public StringPair next() {
         if (nextLine != null) {
           nextLine = in.readLine();
           nextPair = tab2StringPair(nextLine);
-          if (nextLine == null)
+          if (nextLine == null) {
             in.close();
+          }
         }
         return result;
       } catch(IOException e) { 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/French.java
Patch:
@@ -33,7 +33,7 @@ public class French extends Language {
 
   private final Tagger tagger = new FrenchTagger();
   private final Disambiguator disambiguator = new FrenchRuleDisambiguator();
-  private static final Unifier frenchUnifier = new Unifier();
+  private static final Unifier FRENCH_UNIFIER = new Unifier();
   
   private static final String[] COUNTRIES = {"FR", "", "BE", "CH", "CA", 
     "LU", "MC", "CM", "CI", "HI", "ML", "SN", "CD", "MA", "RE"
@@ -64,7 +64,7 @@ public Disambiguator getDisambiguator() {
   }
   
   public Unifier getUnifier() {
-    return frenchUnifier;
+    return FRENCH_UNIFIER;
   }
 
   public Contributor[] getMaintainers() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/Russian.java
Patch:
@@ -45,7 +45,7 @@ public class Russian extends Language {
   
   private final Tagger tagger = new RussianTagger();
   private final Disambiguator disambiguator = new RussianRuleDisambiguator();
-  private static final Unifier russianUnifier = new Unifier();  
+  private static final Unifier RUSSIAN_UNIFIER = new Unifier();  
 //  private Tokenizer wordTokenizer = new RussianWordTokenizer();
   private final Synthesizer synthesizer = new RussianSynthesizer();
 //  private SentenceTokenizer sentenceTokenizer = new RussianSentenceTokenizer();   // old Tokenizer
@@ -89,7 +89,7 @@ public SentenceTokenizer getSentenceTokenizer() {
 
    
      public Unifier getUnifier() {
-    return russianUnifier;
+    return RUSSIAN_UNIFIER;
   }
 
   public Contributor[] getMaintainers() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/XMLRuleHandler.java
Patch:
@@ -182,6 +182,8 @@ public XMLRuleHandler() {
   protected static final String NO = "no";
   protected static final String MARK_TO = "mark_to";
   protected static final String MARK_FROM = "mark_from";
+  protected static final String PHRASES = "phrases";
+  protected static final String MESSAGE = "message";
 
 
   public List<PatternRule> getRules() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/pl/SimpleReplaceRule.java
Patch:
@@ -39,7 +39,7 @@ public class SimpleReplaceRule extends AbstractSimpleReplaceRule {
 	
 	private static final String FILE_NAME = "/pl/replace.txt";
 	// locale used on case-conversion
-	private static final Locale plLocale = new Locale("pl");
+	private static final Locale PL_LOCALE = new Locale("pl");
 
 	public final String getFileName() {
 		return FILE_NAME;
@@ -76,7 +76,7 @@ public boolean isCaseSensitive() {
 	 * locale used on case-conversion
 	 */
 	public Locale getLocale() {
-		return plLocale;
+		return PL_LOCALE;
 	}
 
 }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/ru/RuSimpleReplaceRule.java
Patch:
@@ -38,7 +38,7 @@ public class RuSimpleReplaceRule extends AbstractSimpleReplaceRule {
   private static final String FILE_NAME = "/ru/replace.txt";
 
   // locale used on case-conversion
-	private static final Locale ruLocale = new Locale("ru");
+	private static final Locale RU_LOCALE = new Locale("ru");
 
   
   public final String getFileName() {
@@ -75,6 +75,6 @@ public boolean isCaseSensitive() {
 	 * locale used on case-conversion
 	 */
 	public Locale getLocale() {
-		return ruLocale;
+		return RU_LOCALE;
 	}
 }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tools/Tools.java
Patch:
@@ -270,10 +270,10 @@ public static int checkBitext(final BitextReader reader,
 	  final int contextSize = DEFAULT_CONTEXT_SIZE;
 	  final List<RuleMatch> ruleMatches = new ArrayList<RuleMatch>();
 	  for (StringPair srcAndTrg : reader) {
-		  List<RuleMatch> curMatches = checkBitext(
+		  final List<RuleMatch> curMatches = checkBitext(
 				  srcAndTrg.getSource(), srcAndTrg.getTarget(), 
 				  srcLt, trgLt, bRules);
-		  List<RuleMatch> fixedMatches = new ArrayList<RuleMatch>();
+		  final List<RuleMatch> fixedMatches = new ArrayList<RuleMatch>();
 		  for (RuleMatch thisMatch : curMatches) {
 			  fixedMatches.add(  
 					  trgLt.adjustRuleMatchPos(thisMatch, 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Unifier.java
Patch:
@@ -153,7 +153,6 @@ protected final boolean isSatisfied(final AnalyzedToken aToken,
       return false; // throw exception??
     }
     boolean unified = true;
-    //final String[] features = uFeatures.
     List<String> types;
 
     if (allFeatsIn) {
@@ -227,7 +226,7 @@ private boolean checkNext(final AnalyzedToken aToken,
           allFeatsUnified &= featUnified;
         }
         tokenFeaturesFound.set(i, allFeatsUnified);
-        anyFeatUnified |= allFeatsUnified;
+        anyFeatUnified = anyFeatUnified || allFeatsUnified;
       }
       unifiedNext &= anyFeatUnified;
       if (unifiedNext) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/GenericUnpairedBracketsRule.java
Patch:
@@ -71,8 +71,8 @@ public class GenericUnpairedBracketsRule extends Rule {
   private static final String[] UK_START_SYMBOLS = { "[", "(", "{", "„", "«" };
   private static final String[] UK_END_SYMBOLS   = { "]", ")", "}", "“", "»" };
 
-  private static final String[] NL_START_SYMBOLS = { "[", "(", "{", "„", "“", "‘" };
-  private static final String[] NL_END_SYMBOLS   = { "]", ")", "}", "”", "”", "’" };
+  private static final String[] NL_START_SYMBOLS = { "[", "(", "{", "“", "\u2039", "\u201c", "\u201e" };
+  private static final String[] NL_END_SYMBOLS   = { "]", ")", "}", "”", "\u203a", "\u201d", "\u201d" };
 
   private static final String[] IT_START_SYMBOLS = { "[", "(", "{", "»", /*"‘"*/ };
   private static final String[] IT_END_SYMBOLS   = { "]", ")", "}", "«", /*"’"*/ };

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/GenericUnpairedBracketsRuleTest.java
Patch:
@@ -86,7 +86,7 @@ public void testRuleDutch() throws IOException {
     // incorrect sentences:
     matches = rule
         .match(langTool
-            .getAnalyzedSentence("Het centrale probleem van het werk is de ‘dichterlijke kuischheid."));
+            .getAnalyzedSentence("Het centrale probleem van het werk is de „dichterlijke kuischheid."));
     assertEquals(1, matches.length);
   }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Match.java
Patch:
@@ -419,6 +419,9 @@ public final int getTokenRef() {
    * @return Converted string.
    */
   private String convertCase(final String s) {
+    if (StringTools.isEmpty(s)) {
+      return s;
+    }
     String token = s;
     switch (caseConversionType) {
     case NONE:

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/bitext/pattern/BitextPatternRuleLoader.java
Patch:
@@ -348,6 +348,7 @@ public void startElement(final String namespaceURI, final String lName,
       subId = 0;
     } else if (qName.equals("suggestion") && inMessage) {
       message.append("<suggestion>");
+      inSuggestion = true;
     } else if (qName.equals("match")) {
       inMatch = true;
       match = new StringBuilder();
@@ -367,6 +368,7 @@ public void startElement(final String namespaceURI, final String lName,
           .getValue("regexp_match"), attrs.getValue("regexp_replace"),
           caseConv, YES.equals(attrs.getValue("setpos")),
           includeRange);
+      mWorker.setInMessageOnly(!inSuggestion);
       if (inMessage) {
         if (suggestionMatches == null) {
           suggestionMatches = new ArrayList<Match>();
@@ -609,6 +611,7 @@ public void endElement(final String namespaceURI, final String sName,
       inRuleGroup = false;
     } else if (qName.equals("suggestion") && inMessage) {
       message.append("</suggestion>");
+      inSuggestion = false;
     } else if (qName.equals(MARKER) && inCorrectExample) {
       correctExample.append("</marker>");
     } else if (qName.equals(MARKER) && inIncorrectExample) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/bitext/pattern/XMLRuleHandler.java
Patch:
@@ -26,7 +26,6 @@
 import org.xml.sax.helpers.DefaultHandler;
 
 import de.danielnaber.languagetool.bitext.StringPair;
-import de.danielnaber.languagetool.rules.IncorrectExample;
 import de.danielnaber.languagetool.rules.bitext.IncorrectBitextExample;
 
 /**
@@ -54,6 +53,7 @@ class XMLRuleHandler extends DefaultHandler {
   boolean inCorrectExample;
   boolean inIncorrectExample;
   boolean inMessage;
+  boolean inSuggestion;
   boolean inMatch;
   boolean inRuleGroup;
   boolean inToken;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRule.java
Patch:
@@ -383,8 +383,8 @@ private boolean matchConvertsCase() {
     if (suggestionMatches != null && !suggestionMatches.isEmpty()) {
       final int sugStart = message.indexOf(SUGG_TAG) + SUGG_TAG.length();
       int i = 0;
-      while (i <= suggestionMatches.size()
-          && suggestionMatches.get(i).isInMessageOnly()) {
+      while (i < suggestionMatches.size() - 1
+    		  && suggestionMatches.get(i).isInMessageOnly()) {
         i++;
       }
       convertsCase = suggestionMatches.get(i).convertsCase()

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/XMLRuleHandler.java
Patch:
@@ -52,6 +52,7 @@ class XMLRuleHandler extends DefaultHandler {
   boolean inCorrectExample;
   boolean inIncorrectExample;
   boolean inMessage;
+  boolean inSuggestion;
   boolean inMatch;
   boolean inRuleGroup;
   boolean inToken;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Main.java
Patch:
@@ -18,8 +18,8 @@
  */
 package de.danielnaber.languagetool;
 
-import java.io.BufferedReader;
 import java.io.BufferedInputStream;
+import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
@@ -36,7 +36,6 @@
 
 import org.xml.sax.SAXException;
 
-import de.danielnaber.languagetool.bitext.StringPair;
 import de.danielnaber.languagetool.bitext.TabBitextReader;
 import de.danielnaber.languagetool.rules.Rule;
 import de.danielnaber.languagetool.rules.bitext.BitextRule;

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/MainTest.java
Patch:
@@ -322,6 +322,8 @@ public void testBitextMode()  throws URISyntaxException, IOException, ParserConf
       assertTrue(output.indexOf("Expected text language: Polish") == 0);
       assertTrue(output.indexOf(
           "Message: Hint: \"aktualny\" (Polish) means \"current\", \"(the) latest\", \"up-to-date\" (English). Did you mean 'rzeczywisty'?") != -1);
+      assertTrue(output.indexOf("Line 1, column 32, Rule ID: ACTUAL") != -1);
+      assertTrue(output.indexOf("Line 3, column 4, Rule ID: TRANSLATION_LENGTH") != -1);
     }
     catch (ExitException e) {             
       assertEquals("Exit status", 1, e.status);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/bitext/pattern/BitextPatternRuleLoader.java
Patch:
@@ -672,7 +672,7 @@ private PatternRule finalizeRule() {
     phraseElementInit();
     if (phraseElementList.isEmpty()) {
       rule = new PatternRule(id, language, elementList,
-          description, message.toString(), shortMessage.toString());
+          description, "", shortMessage.toString());
       prepareRule(rule);              
     } else {
       if (!elementList.isEmpty()) {

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/bitext/BitextPatternRuleTest.java
Patch:
@@ -167,7 +167,7 @@ private void testBitextRule(final BitextPatternRule rule, final Language lang,
       assertFalse(lang + ": Did not expect error in: " + goodSentence
           + " (Rule: " + rule + ")", 
           match(rule, goodSentence.getSource(), goodSentence.getTarget(), 
-              languageTool, srcTool));
+              srcTool, languageTool));
     }
     final List<IncorrectBitextExample> badSentences = rule.getIncorrectBitextExamples();
     for (IncorrectBitextExample origBadExample : badSentences) {
@@ -191,7 +191,7 @@ private void testBitextRule(final BitextPatternRule rule, final Language lang,
           suggestedCorrection, expectedSrcMatchStart,
           expectedSrcMatchEnd, rule.getSrcRule(), 
           lang,
-          languageTool);
+          srcTool);
       
       testBadSentence(origBadTrgSentence, 
           suggestedCorrection, expectedTrgMatchStart,

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/de/WordCoherencyRuleTest.java
Patch:
@@ -24,6 +24,7 @@
 import junit.framework.TestCase;
 import de.danielnaber.languagetool.JLanguageTool;
 import de.danielnaber.languagetool.Language;
+import de.danielnaber.languagetool.rules.RuleMatch;
 
 /**
  * @author Daniel Naber
@@ -49,7 +50,7 @@ public void testRule() throws IOException {
   public void testRuleCompleteTexts() throws IOException {
     JLanguageTool langTool;
     // complete texts:
-    List matches = null;
+    List<RuleMatch> matches = null;
     //matches = langTool.check("Das ist aufwendig. Aber hallo. Es ist wirklich aufwendig.");
     //assertEquals(0, matches.size());
     langTool = new JLanguageTool(Language.GERMAN);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/ca/AccentuacioReplaceRule.java
Patch:
@@ -47,7 +47,7 @@ public class AccentuacioReplaceRule extends AbstractSimpleReplaceRule {
 	
 	private static final String FILE_NAME = "/ca/accentuacio.txt";
 	// locale used on case-conversion
-	private static final Locale caLocale = new Locale("ca");
+	private static final Locale CA_LOCALE = new Locale("ca");
 
 	public final String getFileName() {
 		return FILE_NAME;
@@ -84,7 +84,7 @@ public boolean isCaseSensitive() {
 	 * locale used on case-conversion
 	 */
 	public Locale getLocale() {
-		return caLocale;
+		return CA_LOCALE;
 	}
 
 }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Main.java
Patch:
@@ -109,7 +109,7 @@ private void setProfilingMode() {
     profileRules = true;
   }
   
-  private final void setBitextMOde(final Language sourceLang) throws IOException, ParserConfigurationException, SAXException {
+  private final void setBitextMode(final Language sourceLang) throws IOException, ParserConfigurationException, SAXException {
     bitextMode = true;
     Language target = lt.getLanguage();
     lt = new JLanguageTool(target, null);    
@@ -506,7 +506,7 @@ public static void main(final String[] args) throws IOException,
         throw new IllegalArgumentException(
         "You have to set the source language (as mother tongue).");
       }
-      prg.setBitextMOde(motherTongue);
+      prg.setBitextMode(motherTongue);
     }
     if (recursive) {
       prg.runRecursive(filename, encoding, listUnknown);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/bitext/WordFastTMReader.java
Patch:
@@ -32,8 +32,8 @@
  */
 public class WordFastTMReader extends TabBitextReader {
 
-  public WordFastTMReader(final String filename) throws IOException {
-    super(filename);
+  public WordFastTMReader(final String filename, final String encoding) throws IOException {
+    super(filename, encoding);
     //skip the header (first line)
     if (nextline != null) {
       nextline = Tab2StringPair(in.readLine());

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/bitext/TabBitextReaderTest.java
Patch:
@@ -40,7 +40,7 @@ public void testReader() throws Exception {
     w.println("ab\tVery strange data indeed, much longer than input");
     w.close();  
 
-    TabBitextReader reader = new TabBitextReader(input.getAbsolutePath());
+    TabBitextReader reader = new TabBitextReader(input.getAbsolutePath(), "UTF-8");
     int i = 1;
     for (StringPair srcAndTrg : reader) {
       assertTrue(srcAndTrg.getSource() != null);

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/bitext/WordFastTMReaderTest.java
Patch:
@@ -40,7 +40,7 @@ public void testReader() throws Exception {
     w.println("20100727~051350\tAHLJat\t2\tEN-US\tWhy not?&tA;\tPL-PL\tDlaczego nie?&tA; ");
     w.close();  
 
-    WordFastTMReader reader = new WordFastTMReader(input.getAbsolutePath());
+    WordFastTMReader reader = new WordFastTMReader(input.getAbsolutePath(), "UTF-8");
     int i = 1;
     for (StringPair srcAndTrg : reader) {
       assertTrue(srcAndTrg.getSource() != null);

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -112,7 +112,7 @@ private void warnIfElementNotKosher(final Element element,
     }
     if (element.isRegularExpression() && "".equals(element.getString())) {
       System.err.println("The " + lang.toString() + " rule: "
-          + ruleId + " contains en empty string element " + "\"" + element
+          + ruleId + " contains an empty string element " + "\"" + element
           + "\" that is marked as regular expression (don't look at the POS tag, it might be OK).");
     } else if (element.isRegularExpression()
         && !PROBABLE_REGEX.matcher(element.getString())

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/de/GermanSentenceTokenizer.java
Patch:
@@ -65,7 +65,7 @@ public class GermanSentenceTokenizer extends SentenceTokenizer {
   private static final Pattern REPAIR_NAME_PATTERN = Pattern.compile("( [IVX]+\\.) " + EOS + "([^A-ZÖÄÜ]+)");
 
   /** don't split at cases like "im 13. oder 14. Jahrhundert" */
-  private static final Pattern REPAIR_CENTURY_PATTERN = Pattern.compile("(\\d+\\.)(\\s+)" + EOS + "(und|oder|bis|bis zum|bis zur)(\\s+\\d+\\.) ");
+  private static final Pattern REPAIR_NUMBER_PATTERN = Pattern.compile("(\\d+\\.)(\\s+)" + EOS + "(und|oder|bis) ");
 
   public GermanSentenceTokenizer() {
     super(ABBREV_LIST);
@@ -75,7 +75,7 @@ public GermanSentenceTokenizer() {
   protected String removeFalseEndOfSentence(String s) {
       s = super.removeFalseEndOfSentence(s);
       s = REPAIR_NAME_PATTERN.matcher(s).replaceAll("$1 $2");
-      s = REPAIR_CENTURY_PATTERN.matcher(s).replaceAll("$1$2$3$4 ");
+      s = REPAIR_NUMBER_PATTERN.matcher(s).replaceAll("$1$2$3 ");
       return s;
   }
   

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tokenizers/de/GermanSentenceTokenizerTest.java
Patch:
@@ -47,6 +47,7 @@ public void testTokenize() {
     testSplit(new String[] { "Das Schreiben ist auf den 3.10. datiert." });
     testSplit(new String[] { "Das Schreiben ist auf den 31.1. datiert." });
     testSplit(new String[] { "Das Schreiben ist auf den 3.10.2000 datiert." });
+    testSplit(new String[] { "Natürliche Vererbungsprozesse prägten sich erst im 18. und frühen 19. Jahrhundert aus." });
 
     testSplit(new String[] { "Friedrich I., auch bekannt als Friedrich der Große." });
     testSplit(new String[] { "Friedrich II., auch bekannt als Friedrich der Große." });

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/GenericUnpairedBracketsRule.java
Patch:
@@ -176,7 +176,7 @@ public String getDescription() {
    * @return
    */
   protected boolean isNoException(final String token,
-      final AnalyzedTokenReadings[] tokens, final int i, 
+      final AnalyzedTokenReadings[] tokens, final int i, final int j,
       final boolean precSpace,
       final boolean follSpace) {
     return true;
@@ -211,7 +211,7 @@ public final RuleMatch[] match(final AnalyzedSentence text) {
                 || PUNCTUATION.matcher(tokens[i + 1].getToken()).matches();
           }         
 
-          boolean noException = isNoException(token, tokens, i,
+          boolean noException = isNoException(token, tokens, i, j,
                 precededByWhitespace, followedByWhitespace);          
 
           if (noException && precededByWhitespace

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/en/EnglishUnpairedBracketsRule.java
Patch:
@@ -45,7 +45,7 @@ public String getId() {
   }
   
   protected boolean isNoException(final String token,
-      final AnalyzedTokenReadings[] tokens, final int i, final boolean precSpace,
+      final AnalyzedTokenReadings[] tokens, final int i, final int j, final boolean precSpace,
       final boolean follSpace) {
        
     

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/ru/RussianUnpairedBracketsRule.java
Patch:
@@ -36,11 +36,11 @@ public class RussianUnpairedBracketsRule extends GenericUnpairedBracketsRule {
 
   
   protected boolean isNoException(final String token,
-      final AnalyzedTokenReadings[] tokens, final int i, 
+      final AnalyzedTokenReadings[] tokens, final int i, final int j,
       final boolean precSpace,
       final boolean follSpace) {
  // exception for Russian bullets: а), б), Д)..., ДД), аа) and 1а).  
-    if (i > 1 &&
+    if (i > 1 && endSymbols[j].equals(")") &&
         NUMERALS_RU.matcher(tokens[i - 1].getToken()).matches() && 
         !(!symbolStack.empty() && "(".equals(symbolStack.peek().symbol))) {
        return false;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/GenericUnpairedBracketsRule.java
Patch:
@@ -41,7 +41,7 @@ public class GenericUnpairedBracketsRule extends Rule {
    * Note that there must be equal length of both arrays, and the sequence of
    * starting symbols must match exactly the sequence of ending symbols.
    */
-  protected static final String[] START_SYMBOLS = { "[", "(", "{", "\"", "'" };
+  private static final String[] START_SYMBOLS = { "[", "(", "{", "\"", "'" };
   private static final String[] END_SYMBOLS   = { "]", ")", "}", "\"", "'" };
 
   protected String[] startSymbols;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/French.java
Patch:
@@ -83,6 +83,7 @@ public Set<String> getRelevantRuleIDs() {
     ids.add("UNPAIRED_BRACKETS");
     ids.add("UPPERCASE_SENTENCE_START");    
     ids.add("WHITESPACE_RULE");
+    ids.add("FRENCH_WHITESPACE");
     return ids;
   }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Main.java
Patch:
@@ -150,7 +150,7 @@ private void runOnFile(final String filename, final String encoding,
       int lineOffset = 0;           
       List<String> unknownWords = new ArrayList<String>();
       StringBuilder sb = new StringBuilder();      
-      for (int ruleIndex = 0; ruleIndex <=runCount; ruleIndex++) {
+      for (int ruleIndex = 0; ruleIndex <runCount; ruleIndex++) {
       int matches = 0;
       long sentences = 0;        
       final long startTime = System.currentTimeMillis();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/AbstractPatternRule.java
Patch:
@@ -173,7 +173,8 @@ protected boolean testAllReadings(final AnalyzedTokenReadings[] tokens,
         return false;
       }
       thisMatched = thisMatched || elem.isMatched(matchToken);
-      if (!thisMatched && !elem.isInflected() && elem.getPOStag() == null) {
+      if (!thisMatched && !elem.isInflected() && elem.getPOStag() == null 
+          && (prevElement != null && prevElement.getExceptionList() == null)) {
         return false; // the token is the same, we will not get a match
       }
       if (groupsOrUnification) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/CommaWhitespaceRule.java
Patch:
@@ -104,7 +104,7 @@ public final RuleMatch[] match(final AnalyzedSentence text) {
         ruleMatches.add(ruleMatch);
       }
       prevToken = token;
-      prevWhite = isWhite;
+      prevWhite = isWhite && !tokens[i].isFieldCode(); //OOo code before comma/dot
       prevLen = tokens[i].getToken().length();
     }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -200,8 +200,6 @@ public final boolean isWhitespace() {
   
   /**
    * Returns true if the token equals \n, \r\n \n\r or \r\n.
-   * 
-   * @return
    */
   public final boolean isLinebreak() {
     return isLinebreak;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tools/StringTools.java
Patch:
@@ -293,7 +293,7 @@ public static String escapeHTML(final String s) {
    *          matches
    * @param contextSize
    *          the desired context size in characters
-   * @deprecated Use {@link #ruleMatchesToXML(List<RuleMatch>,String,int,XmlPrintMode)} instead
+   * @deprecated Use {@link #ruleMatchesToXML(List,String,int,XmlPrintMode)} instead
    */
   public static String ruleMatchesToXML(final List<RuleMatch> ruleMatches,
       final String text, final int contextSize) {
@@ -307,7 +307,7 @@ public static String ruleMatchesToXML(final List<RuleMatch> ruleMatches,
    *          matches
    * @param contextSize
    *          the desired context size in characters
-   * @param xmlMode TODO
+   * @param xmlMode how to print the XML
    */
   public static String ruleMatchesToXML(final List<RuleMatch> ruleMatches,
       final String text, final int contextSize, XmlPrintMode xmlMode) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/de/AnalyzedGermanTokenReadings.java
Patch:
@@ -81,7 +81,6 @@ public boolean hasReadingOfType(POSType type) {
 
   /**
    * Return true if the analyzed word is a sentence or paragraph end.
-   * @return
    */
   public boolean isSentenceEnd() {
     if (anTokReadings == null) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/UppercaseSentenceStartRule.java
Patch:
@@ -95,7 +95,8 @@ public final RuleMatch[] match(final AnalyzedSentence text) {
     }
     //fix for comma in last paragraph; note - this will not always work for the last point in OOo,
     //as OOo might serve paragraphs in any order.
-    if ((language == Language.RUSSIAN || language == Language.ITALIAN)
+    if ((language == Language.RUSSIAN || language == Language.ITALIAN 
+        || language == Language.POLISH || language == Language.GERMAN)
         && (",".equals(lastPragraphString))) {
       noException = true;
     }

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/UppercaseSentenceStartRuleTest.java
Patch:
@@ -48,6 +48,9 @@ public void testRule() throws IOException {
     assertEquals(0, matches.size());
     matches = langTool.check("'Dies ist ein Satz!'");
     assertEquals(0, matches.size());
+    
+    matches = langTool.check("Sehr geehrte Frau Merkel,\nwie wir Ihnen schon früher mitgeteilt haben...");
+    assertEquals(0, matches.size());
 
     matches = langTool.check("Dies ist ein Satz. und hier kommt noch einer");
     assertEquals(1, matches.size());

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/SentenceTokenizer.java
Patch:
@@ -47,8 +47,8 @@ public class SentenceTokenizer implements Tokenizer {
   // regular expressions:
 
   private Pattern paragraph;
-  private static final Pattern paragraphByTwoLineBreaks = Pattern.compile("(\\n\\s*\\n)");
-  private static final Pattern paragraphByLineBreak = Pattern.compile("(\\n)");
+  private static final Pattern paragraphByTwoLineBreaks = Pattern.compile("([\\n\\r]\\s*[\\n\\r])");
+  private static final Pattern paragraphByLineBreak = Pattern.compile("([\\n\\r])");
 
   // add unbreakable field, for example footnote, if it's at the end of the sentence
   private static final Pattern punctWhitespace = Pattern.compile("(" + PAP + "(\u0002)?\\s)");

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/AbstractSimpleReplaceRule.java
Patch:
@@ -40,7 +40,7 @@
 /**
  * A rule that matches words or phrases which should not be used and suggests
  * correct ones instead. Loads the relevant words  from 
- * <code>rules/<XX>/replace.txt</code>, where <XX> is a code of the language.
+ * <code>rules/XX/replace.txt</code>, where XX is a code of the language.
  * 
  * @author Andriy Rysin
  */

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/IncorrectExample.java
Patch:
@@ -43,15 +43,13 @@ public IncorrectExample(final String example, final String[] corrections) {
   
   /**
    * Return the example that contains the error.
-   * @return
    */
   public String getExample() {
     return example;
   }
 
   /**
    * Return the possible corrections. May be null.
-   * @return
    */
   public List<String> getCorrections() {
     return corrections;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/UnpairedQuotesBracketsRule.java
Patch:
@@ -229,7 +229,7 @@ public final RuleMatch[] match(final AnalyzedSentence text) {
               }
             }
 
-            if (noException)
+            if (noException) {
               if (symbolStack.isEmpty()) {
                 symbolStack.push(new SymbolLocator(endSymbols[j], i));
               } else {
@@ -239,6 +239,7 @@ public final RuleMatch[] match(final AnalyzedSentence text) {
                   symbolStack.push(new SymbolLocator(endSymbols[j], i));
                 }                
               }
+            }
           }
         }
       }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Unifier.java
Patch:
@@ -34,7 +34,6 @@
  * Implements unification of features over tokens.
  * 
  * @author Marcin Milkowski
- * 
  */
 public class Unifier {
 
@@ -390,6 +389,7 @@ public final AnalyzedTokenReadings[] getFinalUnified() {
 }
 
 class EquivalenceTypeLocator {
+  
   @Override
   public int hashCode() {
     final int prime = 31;
@@ -435,4 +435,5 @@ public boolean equals(final Object obj) {
     this.feature = feature;
     this.type = type;
   }
+  
 }
\ No newline at end of file

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/es/ElwithFemRule.java
Patch:
@@ -72,7 +72,7 @@ public String getId() {
 
   @Override
   public String getDescription() {
-    return "Use of 'el' with some feminine nouns";
+    return "Uso de 'el' con sustantivos femeninos que comienzan por a- o ha- t\u00f3nicas";
   }
 
   @Override

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/CaseRule.java
Patch:
@@ -78,6 +78,7 @@ public class CaseRule extends GermanRule {
   
   private static final Set<String> exceptions = new HashSet<String>();
   static {
+    exceptions.add("Nachts");   // "des Nachts", "eines Nachts"
     exceptions.add("Genüge");
     exceptions.add("Zusage");
     exceptions.add("Nachfrage");

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/Main.java
Patch:
@@ -218,8 +218,8 @@ private Language getLanguage() {
    *          paraText - paragraph text
    * @param locale
    *          Locale - the text Locale
-   * @param int startOfSentencePos start of sentence position
-   * @param int nSuggestedBehindEndOfSentencePosition end of sentence position
+   * @param startOfSentencePos start of sentence position
+   * @param nSuggestedBehindEndOfSentencePosition end of sentence position
    * @param PropertyValue
    *          [] props - properties
    * @return ProofreadingResult containing the results of the check. *

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/SingletonFactory.java
Patch:
@@ -22,12 +22,11 @@
 import com.sun.star.uno.XComponentContext;
 
 /**
- * @author Marcin Miłkowski
- *
  * This class is a factory that creates only a single instance,
  * or a singleton, of the Main class. Used for performance 
  * reasons and to allow various parts of code to interact.
  *
+ * @author Marcin Miłkowski
  */
 public class SingletonFactory implements XSingleComponentFactory {
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/de/GermanSentenceTokenizer.java
Patch:
@@ -36,7 +36,7 @@ public class GermanSentenceTokenizer extends SentenceTokenizer {
     "Gen", "germ", "gesch", "ges", "get", "ggf", "Ggs", "ggT",
     "griech", "hebr", "hg", "Hrsg", "Hg", "hist", "hochd", "hochspr",
     "Hptst", "Hr", "Allg", "ill", "inkl", "incl", "Ind", "Inf", "Ing",
-    "ital", "Tr", "Jb", "Jg", "Jh", "jmd", "jmdm", "jmdn", "jmds",
+    "ital", "Tr", "Jb", "Jg", "Jh", "Jhd", "jmd", "jmdm", "jmdn", "jmds",
     "jur", "Kap", "kart", "kath", "kfm", "kaufm", "Kfm", "kgl",
     "Kl", "Konj", "Krs", "Kr", "Kto", "lat", "lfd", "Lit", "lt",
     "Lz", "Mask", "mask", "Mrd", "mdal", "med", "met", "mhd", "Mi",
@@ -57,7 +57,7 @@ public class GermanSentenceTokenizer extends SentenceTokenizer {
   private static final String[] MONTH_NAMES = { "Januar", "Februar", "März", "April", "Mai",
       "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember",
       // ähnliche Fälle außerhalb der Monatsnamen:
-      "Jh.", "Jhd.", "Jahrhundert", "Jahrhunderts", "Geburtstag", "Geburtstags", "Platz", "Platzes"};
+      "Jh", "Jhd", "Jahrhundert", "Jahrhunderts", "Geburtstag", "Geburtstags", "Platz", "Platzes"};
 
   public GermanSentenceTokenizer() {
     super(ABBREV_LIST);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/SentenceTokenizer.java
Patch:
@@ -87,7 +87,9 @@ public class SentenceTokenizer implements Tokenizer {
 
   /**
    * Month names like "Dezember" that should not be considered a sentence
-   * boundary in string like "13. Dezember".
+   * boundary in string like "13. Dezember". May also contain other
+   * words that indicate there's no sentence boundary when preceded
+   * by a number and a dot.
    */
   protected String[] monthNames;
   

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/de/GermanSentenceTokenizer.java
Patch:
@@ -55,7 +55,9 @@ public class GermanSentenceTokenizer extends SentenceTokenizer {
   // einige deutsche Monate, vor denen eine Zahl erscheinen kann,
   // ohne dass eine Satzgrenze erkannt wird (z.B. "am 13. Dezember" -> keine Satzgrenze)
   private static final String[] MONTH_NAMES = { "Januar", "Februar", "März", "April", "Mai",
-      "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember" };
+      "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember",
+      // ähnliche Fälle außerhalb der Monatsnamen:
+      "Jh.", "Jhd.", "Jahrhundert", "Jahrhunderts", "Geburtstag", "Geburtstags", "Platz", "Platzes"};
 
   public GermanSentenceTokenizer() {
     super(ABBREV_LIST);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/UnpairedQuotesBracketsRule.java
Patch:
@@ -79,8 +79,8 @@ public class UnpairedQuotesBracketsRule extends Rule {
   private static final String[] NL_START_SYMBOLS = { "[", "(", "{", "„", "“", "‘" };
   private static final String[] NL_END_SYMBOLS   = { "]", ")", "}", "”", "”", "’" };
 
-  private static final String[] IT_START_SYMBOLS = { "[", "(", "{", "»", "‘" };
-  private static final String[] IT_END_SYMBOLS   = { "]", ")", "}", "«", "’" };
+  private static final String[] IT_START_SYMBOLS = { "[", "(", "{", "»", /*"‘"*/ };
+  private static final String[] IT_END_SYMBOLS   = { "]", ")", "}", "«", /*"’"*/ };
 
   private static final String[] DK_START_SYMBOLS = { "[", "(", "{", "\"", "”" };
   private static final String[] DK_END_SYMBOLS   = { "]", ")", "}", "\"", "”" };

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tools/StringTools.java
Patch:
@@ -323,8 +323,8 @@ public static String ruleMatchesToXML(final List<RuleMatch> ruleMatches,
 
     for (final RuleMatch match : ruleMatches) {
       xml.append("<error" + " fromy=\"" + match.getLine() + "\"" + " fromx=\""
-          + match.getColumn() + "\"" + " toy=\"" + match.getEndLine() + "\""
-          + " tox=\"" + match.getEndColumn() + "\"" + " ruleId=\""
+          + (match.getColumn() - 1) + "\"" + " toy=\"" + match.getEndLine() + "\""
+          + " tox=\"" + (match.getEndColumn() - 1) + "\"" + " ruleId=\""
           + match.getRule().getId() + "\"");
       final String msg = match.getMessage().replaceAll("</?suggestion>", "'");
       xml.append(" msg=\"" + escapeXMLForAPIOutput(msg) + "\"");

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Main.java
Patch:
@@ -361,8 +361,6 @@ public static void main(final String[] args) throws IOException,
         }
       } else if (args[i].equals("-b")) {
         singleLineBreakMarksParagraph = true;
-      } else if (i == args.length - 1) {
-        filename = args[i];
       } else if (args[i].equals("--api")) {
         apiFormat = true;
         if (applySuggestions) {
@@ -379,6 +377,8 @@ public static void main(final String[] args) throws IOException,
           throw new IllegalArgumentException(
               "API format makes no sense for automatic application of suggestions.");
         }
+      } else if (i == args.length - 1) {
+        filename = args[i];
       } else {
         System.err.println("Unknown option: " + args[i]);
         exitWithUsageMessage();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/server/HTTPServer.java
Patch:
@@ -127,6 +127,8 @@ public String demultiplex(Request connRequest, Response connResponse) {
 
 	    // request type: list known languages
 	    if (connRequest.getLocation().endsWith("/Languages")) {
+	      connResponse.setHeaderLine(ProtocolResponseHeader.Content_Type, "text/xml");
+	      connResponse.setHeaderLine(ProtocolResponseHeader.Content_Encoding, "UTF-8");
           return getSupportedLanguagesAsXML();
 	    }
 	    

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/French.java
Patch:
@@ -76,8 +76,7 @@ public Set<String> getRelevantRuleIDs() {
     ids.add("COMMA_PARENTHESIS_WHITESPACE");
     ids.add("DOUBLE_PUNCTUATION");
     ids.add("UNPAIRED_BRACKETS");
-    ids.add("UPPERCASE_SENTENCE_START");
-    ids.add("WORD_REPEAT_RULE");
+    ids.add("UPPERCASE_SENTENCE_START");    
     ids.add("WHITESPACE_RULE");
     return ids;
   }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/UnpairedQuotesBracketsRule.java
Patch:
@@ -58,8 +58,8 @@ public class UnpairedQuotesBracketsRule extends Rule {
   private static final String[] RO_START_SYMBOLS = { "[", "(", "{", "„", "«" };
   private static final String[] RO_END_SYMBOLS   = { "]", ")", "}", "”", "»" };
 
-  private static final String[] FR_START_SYMBOLS = { "[", "(", "{", "»", "‘" };
-  private static final String[] FR_END_SYMBOLS   = { "]", ")", "}", "«", "’" };
+  private static final String[] FR_START_SYMBOLS = { "[", "(", "{", "«", /*"‘"*/ };
+  private static final String[] FR_END_SYMBOLS   = { "]", ")", "}", "»", /*"’" used in "d’arm" and many other words */ };
 
   private static final String[] DE_START_SYMBOLS = { "[", "(", "{", "„", "»", "‘" };
   private static final String[] DE_END_SYMBOLS   = { "]", ")", "}", "“", "«", "’" };

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/Catalan.java
Patch:
@@ -57,7 +57,6 @@ public Set<String> getRelevantRuleIDs() {
     ids.add("DOUBLE_PUNCTUATION");
     ids.add("UNPAIRED_BRACKETS");
     ids.add("UPPERCASE_SENTENCE_START");
-    ids.add("WORD_REPEAT_RULE");
     ids.add("WHITESPACE_RULE");
     return ids;
   }

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tagging/nl/DutchTaggerTest.java
Patch:
@@ -50,7 +50,7 @@ public void testDictionary() throws IOException {
   }
   
   public void testTagger() throws IOException {
-    TestTools.myAssert("Dit is een Nederlandse zin om het programma'tje te testen.", "Dit/[dit]DTh is/[zijn]VB3 een/[een]NM|een/[een]NN1d|een/[DTe]null|een/[NM1]null Nederlandse/[Nederlandse]NN1 zin/[zin]NN1d|zin/[zinnen]VB1 om/[om]PRom het/[het]DTh programma/[programma]NN1d|programma/[programma]NN1h tje/[null]null te/[te]PRte testen/[testen]VBi|testen/[test]NN2", tokenizer, tagger);        
+    TestTools.myAssert("Dit is een Nederlandse zin om het programma'tje te testen.", "Dit/[dit]DTh is/[zijn]VB3 een/[een]DTe|een/[een]NM|een/[een]NM1|een/[een]NN1d Nederlandse/[Nederlandse]NN1 zin/[zin]NN1d|zin/[zinnen]VB1 om/[om]PRom het/[het]DTh programma/[programma]NN1d|programma/[programma]NN1h tje/[null]null te/[te]PRte testen/[testen]VBi|testen/[test]NN2", tokenizer, tagger);        
     TestTools.myAssert("zwijnden","zwijnden/[zwijnen]VBh", tokenizer, tagger);        
   }
 

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tagging/sv/SwedishTaggerTest.java
Patch:
@@ -50,7 +50,7 @@ public void testDictionary() throws IOException {
   }
 
   public void testTagger() throws IOException {
-    TestTools.myAssert("Det är nog bäst att du får en klubba till", "Det/[det]PN är/[vara]VB:PRS nog/[nog]AB bäst/[bäst]AB|bäst/[bra]JJ:S|bäst/[god]JJ:S att/[att]null|att/[att]KN du/[du]PN får/[får]NN:OF:PLU:NOM:NEU|får/[får]NN:OF:SIN:NOM:NEU|får/[få]VB:PRS en/[en]null|en/[en]NN:OF:SIN:NOM:UTR|en/[en]PN|en/[passant]en passant NN:OF:SIN:NOM:UTR|en/[passants]en passant NN:OF:SIN:GEN:UTR|en/[passanten]en passant NN:BF:SIN:NOM:UTR|en/[passantens]en passant NN:BF:SIN:GEN:UTR|en/[passanter]en passant NN:OF:PLU:NOM:UTR|en/[passanters]en passant NN:OF:PLU:GEN:UTR|en/[passanterna]en passant NN:BF:PLU:NOM:UTR|en/[passanternas]en passant NN:BF:PLU:GEN:UTR klubba/[klubba]NN:OF:SIN:NOM:UTR|klubba/[klubba]VB:IMP|klubba/[klubba]VB:INF till/[till]AB|till/[till]PP", tokenizer, tagger);        
+    TestTools.myAssert("Det är nog bäst att du får en klubba till", "Det/[det]PN är/[vara]VB:PRS nog/[nog]AB bäst/[bäst]AB|bäst/[bra]JJ:S|bäst/[god]JJ:S att/[att]KN du/[du]PN får/[får]NN:OF:PLU:NOM:NEU|får/[får]NN:OF:SIN:NOM:NEU|får/[få]VB:PRS en/[en]NN:OF:SIN:NOM:UTR|en/[en]PN|en/[passant]en passant NN:OF:SIN:NOM:UTR|en/[passants]en passant NN:OF:SIN:GEN:UTR|en/[passanten]en passant NN:BF:SIN:NOM:UTR|en/[passantens]en passant NN:BF:SIN:GEN:UTR|en/[passanter]en passant NN:OF:PLU:NOM:UTR|en/[passanters]en passant NN:OF:PLU:GEN:UTR|en/[passanterna]en passant NN:BF:PLU:NOM:UTR|en/[passanternas]en passant NN:BF:PLU:GEN:UTR klubba/[klubba]NN:OF:SIN:NOM:UTR|klubba/[klubba]VB:IMP|klubba/[klubba]VB:INF till/[till]AB|till/[till]PP", tokenizer, tagger);        
     TestTools.myAssert("Du menar sannolikt \"massera\" om du inte skriver om masarnas era förstås.","Du/[du]PN menar/[mena]VB:PRS sannolikt/[sannolikt]AB|sannolikt/[sannolik]JJ:PN massera/[massera]VB:IMP|massera/[massera]VB:INF om/[om]AB|om/[om]KN|om/[om]PP du/[du]PN inte/[inte]AB skriver/[skriva]VB:PRS om/[om]AB|om/[om]KN|om/[om]PP masarnas/[mas]NN:BF:PLU:GEN:UTR era/[era]NN:OF:SIN:NOM:UTR|era/[era]PN förstås/[förstås]AB|förstås/[förstå]VB:INF:PF|förstås/[förstå]VB:PRS:PF", tokenizer, tagger);        
 
   }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/disambiguation/xx/TrimDisambiguator.java
Patch:
@@ -42,8 +42,7 @@ public final AnalyzedSentence disambiguate(final AnalyzedSentence input) {
       if (anTokens[i].getReadingsLength() > 1) {
         final AnalyzedToken[] firstToken = new AnalyzedToken[1];
         firstToken[0] = anTokens[i].getAnalyzedToken(0);
-
-        output[i] = new AnalyzedTokenReadings(firstToken, 0);
+        output[i] = new AnalyzedTokenReadings(firstToken, anTokens[i].getStartPos());
       } else {
         output[i] = anTokens[i];
       }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -154,7 +154,8 @@ public final void addReading(final AnalyzedToken tok) {
     }
     if (anTokReadings[anTokReadings.length - 1].getPOSTag() != null) {
       l.add(anTokReadings[anTokReadings.length - 1]);
-    }    
+    }
+    tok.setWhitespaceBefore(isWhitespaceBefore);
     l.add(tok);    
     anTokReadings = l.toArray(new AnalyzedToken[l.size()]);
     if (tok.getToken().length() > token.length()) { //in case a longer token is added
@@ -163,7 +164,7 @@ public final void addReading(final AnalyzedToken tok) {
     anTokReadings[anTokReadings.length - 1].
       setWhitespaceBefore(isWhitespaceBefore);
     isParaEnd = hasPosTag(JLanguageTool.PARAGRAPH_END_TAGNAME);
-    isSentEnd = hasPosTag(JLanguageTool.SENTENCE_END_TAGNAME);
+    isSentEnd = hasPosTag(JLanguageTool.SENTENCE_END_TAGNAME);     
   }
 
   public final void removeReading(final AnalyzedToken tok) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -104,6 +104,7 @@ public AnalyzedTokenReadings(final AnalyzedToken at) {
     anTokReadings = new AnalyzedToken[1];
     anTokReadings[0] = at;
     startPos = at.getStartPos();
+    isWhitespaceBefore = at.isWhitespaceBefore();
     init();
   }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Element.java
Patch:
@@ -163,8 +163,7 @@ public final boolean isMatched(final AnalyzedToken token) {
     boolean matched = false;
     if (testString) {
       matched = (isStringTokenMatched(token) ^ negation)
-          && (isPosTokenMatched(token) ^ posNegation)
-          && (!testWhitespace || isWhitespaceBefore(token));
+          && (isPosTokenMatched(token) ^ posNegation);
     } else {
       matched = (!negation) && (isPosTokenMatched(token) ^ posNegation);
     }
@@ -173,7 +172,7 @@ public final boolean isMatched(final AnalyzedToken token) {
       andGroupCheck[0] |= matched;
     }
 
-    return matched;
+    return matched && (!testWhitespace || isWhitespaceBefore(token));
   }
 
   /**

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/ru/RussianCompoundRuleTest.java
Patch:
@@ -56,8 +56,8 @@ public void testRule() throws IOException {
     // also detect an error if only some of the hyphens are missing:
     check(1, "Ростов-на Дону", new String[]{"Ростов-на-Дону"});
     // first part is a single character:
-    check(0, "в-третьих");
-    check(1, "в третьих", new String[]{"в-третьих"});
+    check(0, "во-первых");
+    check(1, "во первых", new String[]{"во-первых"});
   }
 
   private void check(int expectedErrors, String text) throws IOException {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/UnpairedQuotesBracketsRule.java
Patch:
@@ -291,7 +291,7 @@ private boolean isEnglishException(final String token,
     }
     if (precSpace && !follSpace) {
       // hold 'em!
-      if ("'".equals(token) && i < tokens.length
+      if ("'".equals(token) && i + 1 < tokens.length
           && "em".equals(tokens[i + 1].getToken())) {
         return false;
       }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRule.java
Patch:
@@ -332,7 +332,6 @@ public final RuleMatch[] match(final AnalyzedSentence text)
         final Element prevElement = elem;
         elem = patternElements.get(k);
         setupRef(firstMatchToken, elem, tokens);
-        final int skipNext = translateElementNo(elem.getSkipNext());
         final int nextPos = i + k + skipShiftTotal;
         prevMatched = false;
         if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) { // SENT_END?
@@ -345,7 +344,7 @@ public final RuleMatch[] match(final AnalyzedSentence text)
             lastMatchToken = m;
             final int skipShift = lastMatchToken - nextPos;
             tokenPositions[matchingTokens] = skipShift + 1;
-            prevSkipNext = skipNext;
+            prevSkipNext = translateElementNo(elem.getSkipNext());
             matchingTokens++;
             skipShiftTotal += skipShift;
             if (firstMatchToken == -1) {
@@ -359,7 +358,7 @@ public final RuleMatch[] match(final AnalyzedSentence text)
         }
       }
 
-      if (allElementsMatch) {
+      if (allElementsMatch && matchingTokens == patternSize) {
         final RuleMatch rM = createRuleMatch(tokenPositions, tokens,
             firstMatchToken, lastMatchToken, matchingTokens);
         if (rM != null) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/ro/RomanianWordTokenizer.java
Patch:
@@ -46,7 +46,7 @@ public List<String> tokenize(final String text) {
 						+ "\u2028\u2029\u202a\u202b\u202c\u202d\u202e\u202f"
 						+ "\u205F\u2060\u2061\u2062\u2063\u206A\u206b\u206c\u206d"
 						+ "\u206E\u206F\u3000\u3164\ufeff\uffa0\ufff9\ufffa\ufffb"
-						+ ",.;()[]{}!?:\"'’‘„“”…\\/\t\n«»<>%" + "-", true);
+						+ ",.;()[]{}!?:\"'’‘„“”…\\/\t\n«»<>%°" + "-", true);
 		while (st.hasMoreElements()) {
 			l.add(st.nextToken());
 		}

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/ro/RomanianWordTokenizer.java
Patch:
@@ -46,7 +46,7 @@ public List<String> tokenize(final String text) {
 						+ "\u2028\u2029\u202a\u202b\u202c\u202d\u202e\u202f"
 						+ "\u205F\u2060\u2061\u2062\u2063\u206A\u206b\u206c\u206d"
 						+ "\u206E\u206F\u3000\u3164\ufeff\uffa0\ufff9\ufffa\ufffb"
-						+ ",.;()[]{}!?:\"'’‘„“”…\\/\t\n«»<>" + "-", true);
+						+ ",.;()[]{}!?:\"'’‘„“”…\\/\t\n«»<>%" + "-", true);
 		while (st.hasMoreElements()) {
 			l.add(st.nextToken());
 		}

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/Rule.java
Patch:
@@ -188,7 +188,7 @@ public final boolean isInMatches(final int i) {
     if (previousMatches == null) {
       return false;
     }
-    if (previousMatches.size() >= i) {
+    if (previousMatches.size() > i) {
       return previousMatches.get(i) != null;
     }
     return false;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/UnpairedQuotesBracketsRule.java
Patch:
@@ -191,7 +191,7 @@ public final RuleMatch[] match(final AnalyzedSentence text) {
 
         boolean followedByWhitespace = true;
         if (i < tokens.length - 1 && startSymbols[j].equals(endSymbols[j])) {
-          followedByWhitespace = tokens[i + 1].isWhitespace()
+          followedByWhitespace = tokens[i + 1].isWhitespaceBefore()
           || PUNCTUATION.matcher(tokens[i + 1].getToken()).matches();
         }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/WordTokenizer.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.StringTokenizer;
 
 /**
- * Tokenizes a sentence into words. 
+ * Tokenizes a sentence into words.
  * Punctuation and whitespace gets its own token.
  * 
  * @author Daniel Naber

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/ro/RomanianWordTokenizer.java
Patch:
@@ -46,7 +46,7 @@ public List<String> tokenize(final String text) {
 						+ "\u2028\u2029\u202a\u202b\u202c\u202d\u202e\u202f"
 						+ "\u205F\u2060\u2061\u2062\u2063\u206A\u206b\u206c\u206d"
 						+ "\u206E\u206F\u3000\u3164\ufeff\uffa0\ufff9\ufffa\ufffb"
-						+ ",.;()[]{}!?:\"'’‘„“”…\\/\t\n" + "-", true);
+						+ ",.;()[]{}!?:\"'’‘„“”…\\/\t\n«»" + "-", true);
 		while (st.hasMoreElements()) {
 			l.add(st.nextToken());
 		}

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/UnpairedQuotesBracketsRule.java
Patch:
@@ -98,7 +98,7 @@ public class UnpairedQuotesBracketsRule extends Rule {
 
   private static final Pattern PUNCTUATION = Pattern.compile("\\p{Punct}");
   private static final Pattern PUNCTUATION_NO_DOT = Pattern
-  .compile("\\p{Punct}(?<!\\.)");
+  .compile("[\\p{Punct}&&[^\\.]]");
   private static final Pattern NUMBER = Pattern.compile("\\d+");
   private static final Pattern NUMERALS = Pattern
   .compile("(?i)\\d{1,2}?[a-z']*|M*(D?C{0,3}|C[DM])(L?X{0,3}|X[LC])(V?I{0,3}|I[VX])$");
@@ -178,7 +178,8 @@ public final RuleMatch[] match(final AnalyzedSentence text) {
         final String token = tokens[i].getToken().trim();
         boolean precededByWhitespace = true;
         if (startSymbols[j].equals(endSymbols[j])) {
-          precededByWhitespace = tokens[i].isWhitespaceBefore()
+          precededByWhitespace = tokens[i - 1].isSentStart()
+          || tokens[i].isWhitespaceBefore()
           || PUNCTUATION_NO_DOT.matcher(tokens[i - 1].getToken()).matches();
         }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Element.java
Patch:
@@ -693,9 +693,9 @@ public final Match getMatch() {
    * Element is supposed to refer to some other token).
    * 
    * @param token
-   * @AnalyzedTokenReadings - the token
+   *  the token specified as {@link #AnalyzedTokenReadings} 
    * @param synth
-   * @Syntesizer - the language synthesizer
+   *  the language synthesizer ({@link #Syntesizer}) 
    * 
    */
   public final void compile(final AnalyzedTokenReadings token,

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/Polish.java
Patch:
@@ -30,13 +30,13 @@
 import de.danielnaber.languagetool.tagging.disambiguation.pl.PolishHybridDisambiguator;
 import de.danielnaber.languagetool.tagging.pl.PolishTagger;
 import de.danielnaber.languagetool.tokenizers.SentenceTokenizer;
-import de.danielnaber.languagetool.tokenizers.pl.PolishSentenceTokenizer;
-// import de.danielnaber.languagetool.tokenizers.SRXSentenceTokenizer;
+//import de.danielnaber.languagetool.tokenizers.pl.PolishSentenceTokenizer;
+import de.danielnaber.languagetool.tokenizers.SRXSentenceTokenizer;
 
 public class Polish extends Language {
 
   private Tagger tagger = new PolishTagger();
-  private SentenceTokenizer sentenceTokenizer = new PolishSentenceTokenizer(); // new SRXSentenceTokenizer("pl"); //
+  private SentenceTokenizer sentenceTokenizer = new SRXSentenceTokenizer("pl"); // new PolishSentenceTokenizer(); //  
   private Disambiguator disambiguator = new PolishHybridDisambiguator();
   private Synthesizer synthesizer = new PolishSynthesizer();
   

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/SRXSentenceTokenizer.java
Patch:
@@ -51,11 +51,12 @@ public class SRXSentenceTokenizer extends SentenceTokenizer {
   public SRXSentenceTokenizer(final String language) {
     this.language = language;
 
-    try {
+    try {      
       srxReader = new BufferedReader(new InputStreamReader(Tools
-          .getStream(RULES), "utf-8"));
+          .getStream(RULES), "utf-8"));      
       SrxParser srxParser = new Srx2Parser();
       document = srxParser.parse(srxReader);
+      
     } catch (UnsupportedEncodingException e) {
       // TODO Auto-generated catch block
       e.printStackTrace();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRule.java
Patch:
@@ -397,6 +397,7 @@ public final RuleMatch[] match(final AnalyzedSentence text)
         }
       }
       tokenPos++;
+      //FIXME: this might be probably removed
       if (firstMatchToken + matchingTokens >= tokens.length) {
         matchingTokens = tokens.length - firstMatchToken;
       }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/JLanguageTool.java
Patch:
@@ -68,7 +68,7 @@
 public final class JLanguageTool {
 
   public static final String VERSION = "0.9.9-dev"; // keep in sync with
-                                                    // build.xml!
+                                                    // build.properties!
 
   public static final String RULES_DIR = "/rules";
   public static final String PATTERN_FILE = "grammar.xml";

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/OOoAboutDialog.java
Patch:
@@ -75,7 +75,7 @@ public void show() {
                 + "\n"
                 + "Copyright (C) 2005-2009 Daniel Naber\n"
                 + "This software is licensed under the GNU Lesser General Public License.\n"
-                + "LanguageTool Homepage: http://www.danielnaber.de/languagetool\n\n"
+                + "LanguageTool Homepage: http://www.languagetool.org/\n\n"
                 + "Maintainers of the language modules:\n"
                 + maintainersInfo.toString());
     box.execute();

File: trunk/JLanguageTool/src/dev/de/danielnaber/languagetool/dev/tools/RomanianDiacriticsModifier.java
Patch:
@@ -75,7 +75,6 @@ private static char diac(char c) {
 	 * @author Ionuț Păduraru
 	 * @since 14.04.2009 12:33:39
 	 * @param s
-	 * @return
 	 */
 	public static synchronized String correctDiacritrics(String s) {
 		if (null == s)

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/UnpairedQuotesBracketsRule.java
Patch:
@@ -156,7 +156,7 @@ public final String getDescription() {
 
   public final RuleMatch[] match(final AnalyzedSentence text) {
     final List<RuleMatch> ruleMatches = new ArrayList<RuleMatch>();
-    final AnalyzedTokenReadings[] tokens = text.getTokens();
+    final AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();
 
     if (reachedEndOfParagraph) {
       reset();

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tagging/disambiguation/rules/en/EnglishRuleDisambiguatorTest.java
Patch:
@@ -60,7 +60,7 @@ public void testChunker() throws IOException {
         "/[null]SENT_START He/[he]PRP  /[null]null is/[be]VBZ  /[null]null well/[well]RB  /[null]null known/[known]JJ ./[null]null", 
         tokenizer, sentenceTokenizer, tagger, disambiguator);
     TestTools.myAssert("He is well known.",
-        "/[null]SENT_START He/[he]PRP  /[null]null is/[be]VBZ  /[null]null well/[well]UH|well/[well]NN|well/[well]RB|well/[well]VB|well/[well]VBP  /[null]null known/[known]NN|known/[know]VBN ./[null]null", 
+        "/[null]SENT_START He/[he]PRP  /[null]null is/[be]VBZ  /[null]null well/[well]NN|well/[well]RB|well/[well]VB|well/[well]VBP|well/[well]UH  /[null]null known/[known]NN|known/[know]VBN ./[null]null", 
         tokenizer, sentenceTokenizer, tagger, disamb2);
     
   }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tools/Tools.java
Patch:
@@ -46,7 +46,7 @@ private Tools() {
   }
 
   /**
-   * Tags text using the LangugageTool tagger.
+   * Tags text using the LanguageTool tagger.
    * 
    * @param contents
    *          Text to tag.

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Main.java
Patch:
@@ -115,10 +115,12 @@ private void runOnFile(final String filename, final String encoding,
       if (listUnknownWords) {
         System.out.println("Unknown words: " + lt.getUnknownWords());
       }
-    } else {
+    } else {      
       if (verbose) {
         lt.setOutput(System.err);
       }
+      //TODO: check how easy it would be to implement paragraph detection 
+      //and send whole paragraphs - right now we get as if -b switch was used...
       if (!apiFormat && !applySuggestions) {
         if (!"-".equals(filename)) {
           System.out.println("Working on " + filename + "... in a line mode");

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/JLanguageToolTest.java
Patch:
@@ -130,7 +130,7 @@ public void testPolish() throws IOException {
     assertEquals(0, matches.size());
     tool.setListUnknownWords(true);
     matches = tool.check("This is not a Polish text.");
-    assertEquals("[Polish, This, is, text]", tool.getUnknownWords().toString());    
+    assertEquals("[Polish, This, is]", tool.getUnknownWords().toString());    
   }
 	  
   public void testCountLines() {

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tagging/it/ItalianTaggerTest.java
Patch:
@@ -35,7 +35,7 @@ public void setUp() {
   }
 
   public void testTagger() throws IOException {
-    TestTools.myAssert("Non c'è linguaggio senza inganno.", "Non/[non]ADV c/[null]null è/[essere]AUX:ind+pres+3+s|è/[essere]VER:ind+pres+3+s linguaggio/[linguaggio]NOUN-M:s senza/[senza]CON|senza/[senza]PRE inganno/[inganno]NOUN-M:s|inganno/[ingannare]VER:ind+pres+1+s", tokenizer, tagger);
+    TestTools.myAssert("Non c'è linguaggio senza inganno.", "Non/[non]ADV c/[C]NPR è/[essere]AUX:ind+pres+3+s|è/[essere]VER:ind+pres+3+s linguaggio/[linguaggio]NOUN-M:s senza/[senza]CON|senza/[senza]PRE inganno/[inganno]NOUN-M:s|inganno/[ingannare]VER:ind+pres+1+s", tokenizer, tagger);
     TestTools.myAssert("Amo quelli che desiderano l'impossibile.", "Amo/[amare]VER:ind+pres+1+s quelli/[quelli]PRO-DEMO-M-P|quelli/[quello]DET-DEMO:m+p che/[che]CON|che/[che]DET-WH:f+p|che/[che]DET-WH:f+s|che/[che]DET-WH:m+p|che/[che]DET-WH:m+s|che/[che]WH-CHE desiderano/[desiderare]VER:ind+pres+3+p l/[null]null impossibile/[impossibile]ADJ:pos+f+s|impossibile/[impossibile]ADJ:pos+m+s", tokenizer, tagger);
     TestTools.myAssert("blablabla","blablabla/[null]null", tokenizer, tagger);        
   }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tools/Tools.java
Patch:
@@ -38,7 +38,7 @@
 
 public final class Tools {
 
-  private static final int DEFAULT_CONTEXT_SIZE = 25;
+  private static final int DEFAULT_CONTEXT_SIZE = 45;
 
   private Tools() {
     // cannot construct, static methods only

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/JLanguageTool.java
Patch:
@@ -387,8 +387,9 @@ public Set<String> getDisabledCategories() {
    *          the id of the rule to enable
    */
   public void enableRule(final String ruleId) {
-    // TODO: check if such a rule exists
-    disabledRules.remove(ruleId);
+    if (disabledRules.contains(ruleId)) {
+      disabledRules.remove(ruleId);
+    }
   }
 
   /**

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/JLanguageToolTest.java
Patch:
@@ -130,8 +130,7 @@ public void testPolish() throws IOException {
     assertEquals(0, matches.size());
     tool.setListUnknownWords(true);
     matches = tool.check("This is not a Polish text.");
-    assertEquals("[Polish, This, is, text]", tool.getUnknownWords().toString());
-    
+    assertEquals("[Polish, This, is, text]", tool.getUnknownWords().toString());    
   }
 	  
   public void testCountLines() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/server/HTTPServer.java
Patch:
@@ -136,7 +136,7 @@ public String demultiplex(Request connRequest, Response connResponse) {
         connResponse.setHeaderLine(ProtocolResponseHeader.Content_Encoding,
             "UTF-8");
         String response = StringTools.ruleMatchesToXML(matches, text,
-            CONTEXT_SIZE);
+            CONTEXT_SIZE, StringTools.XmlPrintMode.NORMAL_XML);
         print("Check done in " + (System.currentTimeMillis() - timeStart)
             + "ms");
         return response;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/Main.java
Patch:
@@ -319,7 +319,7 @@ private SingleProofreadingError createOOoError(final Locale locale,
         .replaceAll("([\r]*\n)", " "); // convert line ends to spaces
     aError.aFullComment = comment;
     // not all rules have short comments
-    if (myMatch.getShortMessage() != null) {
+    if (!StringTools.isEmpty(myMatch.getShortMessage())) {
       aError.aShortComment = myMatch.getShortMessage();
     } else {
       aError.aShortComment = aError.aFullComment;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/BaseTagger.java
Patch:
@@ -100,7 +100,7 @@ public List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens) throws
    * @see de.danielnaber.languagetool.tagging.Tagger#createNullToken(java.lang.String, int)
    */
   @Override
-  public final Object createNullToken(final String token, final int startPos) {
+  public final AnalyzedTokenReadings createNullToken(final String token, final int startPos) {
     return new AnalyzedTokenReadings(new AnalyzedToken(token, null, startPos));
   }
   

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/Tagger.java
Patch:
@@ -47,7 +47,7 @@ public interface Tagger {
    * Create the AnalyzedToken used for whitespace and other non-words. Use <code>null</code>
    * as the POS tag for this token.
    */
-  public Object createNullToken(String token, int startPos);
+  public AnalyzedTokenReadings createNullToken(String token, int startPos);
 
   /**
    * Create a token specific to the laguage of the implementing class.

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/de/GermanTagger.java
Patch:
@@ -150,7 +150,7 @@ private String[] lexiconLookup(final String word) {
   }
   
   @Override
-  public final Object createNullToken(final String token, final int startPos) {
+  public final AnalyzedGermanTokenReadings createNullToken(final String token, final int startPos) {
     return new AnalyzedGermanTokenReadings(new AnalyzedGermanToken(token, null, startPos));
   }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/uk/UkrainianMyspellTagger.java
Patch:
@@ -143,7 +143,7 @@ public final List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens)
   }
 
   @Override
-  public final Object createNullToken(final String token, final int startPos) {
+  public final AnalyzedTokenReadings createNullToken(final String token, final int startPos) {
     return new AnalyzedTokenReadings(new AnalyzedToken(token, null, startPos));
   }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/xx/DemoTagger.java
Patch:
@@ -56,7 +56,7 @@ public List<AnalyzedTokenReadings> tag(List<String> sentenceTokens) {
   }
 
   @Override
-  public Object createNullToken(String token, int startPos) {
+  public AnalyzedTokenReadings createNullToken(String token, int startPos) {
 	  return new AnalyzedTokenReadings(new AnalyzedToken(token, null, startPos));
   }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/JLanguageTool.java
Patch:
@@ -580,7 +580,7 @@ public AnalyzedSentence getAnalyzedSentence(final String sentence)
       aTokens.get(i).setStartPos(aTokens.get(i).getStartPos() + posFix);
       if (!softHyphenTokens.isEmpty()) {
         if (softHyphenTokens.get(i) != null) {
-          aTokens.get(i).addReading(new AnalyzedToken(softHyphenTokens.get(i), null, aTokens.get(i).getStartPos()));
+          aTokens.get(i).addReading(tagger.createToken(softHyphenTokens.get(i), null, aTokens.get(i).getStartPos()));
           posFix += softHyphenTokens.get(i).length() - aTokens.get(i).getToken().length();
         }
       }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/Main.java
Patch:
@@ -235,7 +235,7 @@ public final ProofreadingResult doProofreading(final String docID,
     }
   }
 
-  private final ProofreadingResult doGrammarCheckingInternal(
+  synchronized private final ProofreadingResult doGrammarCheckingInternal(
       final String paraText, final Locale locale, final ProofreadingResult paRes) {
 
     if (paraText == null) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Unifier.java
Patch:
@@ -163,7 +163,7 @@ public final boolean isSatisfied(final AnalyzedToken aToken,
 
     if (!allFeatsIn) {
       tokCnt++;
-      if (equivalencesMatched.size() <= tokCnt) {
+      while (equivalencesMatched.size() <= tokCnt) {
         final Map<String, Set<String>> mapTemp = new HashMap<String, Set<String>>();
         equivalencesMatched.add(mapTemp);
       }
@@ -312,8 +312,8 @@ public final AnalyzedTokenReadings[] getUnifiedTokens() {
       while (!tmpFeaturesFound.get(first)) {
         first++;
       }
-      if (first == tmpFeaturesFound.size()) {
-        tmpFeaturesFound.remove(first);
+      tmpFeaturesFound.remove(tmpFeaturesFound.size() - 1);
+      if (first >= tmpFeaturesFound.size()) {        
         return null;
       }
       // FIXME: why this happens??

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Element.java
Patch:
@@ -349,7 +349,7 @@ public final boolean isMatchedByScopeNextException(final AnalyzedToken token) {
    * exception had scope == "previous").
    * 
    * @param token
-   * @AnalyzedToken to check matching against.
+   *    {@link AnalyzedToken} to check matching against.
    * @return True if any of the exceptions matches.
    */
   public final boolean isMatchedByPreviousException(

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tagging/disambiguation/pl/PolishChunkerTest.java
Patch:
@@ -48,6 +48,8 @@ public void testChunker() throws IOException {
       TestTools.myAssert("To test... dezambiguacji","/[null]SENT_START To/[to]conj|To/[ten]adj:sg:nom.acc.voc:n:pos  /[null]null test/[test]subst:sg:nom.acc:m3|test/[testo]subst:pl:gen:n ./[...]<ELLIPSIS> ./[null]null ./[...]</ELLIPSIS>  /[null]null dezambiguacji/[null]null", tokenizer, sentenceTokenizer, tagger, disambiguator);
       TestTools.myAssert("On, to znaczy premier, jest niezbyt mądry","/[null]SENT_START On/[on]ppron3:sg:nom:m1.m2.m3:ter ,/[null]null  /[null]null to/[to]conj|to/[ten]adj:sg:nom.acc.voc:n:pos|to/[to znaczy]<TO_ZNACZY>  /[null]null znaczy/[znaczyć]verb:fin:sg:ter:imperf|znaczy/[to znaczy]</TO_ZNACZY>  /[null]null premier/[premier]subst:sg:nom:m1|premier/[premiera]subst:pl:gen:f ,/[null]null  /[null]null jest/[być]verb:fin:sg:ter:imperf  /[null]null niezbyt/[zbyt]adv:pos:neg  /[null]null mądry/[mądry]adj:sg:nom.acc:m3:pos|mądry/[mądry]adj:sg:nom.voc:m1.m2:pos|mądry/[mądry]adj:sg:nom.acc:m3:pos:aff|mądry/[mądry]adj:sg:nom.voc:m1.m2:pos:aff", tokenizer, sentenceTokenizer, tagger, disambiguator);
       TestTools.myAssert("Lubię go z uwagi na krótkie włosy.","/[null]SENT_START Lubię/[lubić]verb:fin:sg:pri:imperf  /[null]null go/[on]ppron3:sg:acc:m1.m2.m3:ter:nakc:npraep|go/[on]ppron3:sg:gen:m1.m2.m3.n1.n2:ter:nakc:npraep|go/[on]ppron3:sg:gen:m1.m2.m3.n:ter:nakc:npraep|go/[on]ppron3:sg:acc:m1.m2.m3:ter:nakc:npraep  /[null]null z/[z]prep:gen.inst|z/[z uwagi na]<PREP:ACC>  /[null]null uwagi/[uwaga]subst:pl:gen:f|uwagi/[uwaga]subst:pl:nom.acc.voc:f|uwagi/[uwaga]subst:sg:gen.dat.loc:f  /[null]null na/[na]prep:acc.loc|na/[z uwagi na]</PREP:ACC>  /[null]null krótkie/[krótki]adj:pl:nom.acc.voc:f.n.m2.m3:pos:aff|krótkie/[krótki]adj:sg:nom.acc.voc:n:pos:aff  /[null]null włosy/[włosy]subst:pltant:nom.acc.voc:n|włosy/[włos]subst:pl:nom.acc.voc:m3 ./[null]null", tokenizer, sentenceTokenizer, tagger, disambiguator);
+      TestTools.myAssert("Test...","/[null]SENT_START Test/[test]subst:sg:nom.acc:m3|Test/[testo]subst:pl:gen:n ./[...]<ELLIPSIS> ./[null]null ./[...]</ELLIPSIS>", tokenizer, sentenceTokenizer, tagger, disambiguator);
+      TestTools.myAssert("Test... ","/[null]SENT_START Test/[test]subst:sg:nom.acc:m3|Test/[testo]subst:pl:gen:n ./[...]<ELLIPSIS> ./[null]null ./[...]</ELLIPSIS>  /[null]null", tokenizer, sentenceTokenizer, tagger, disambiguator);
     }
 
   }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/JLanguageTool.java
Patch:
@@ -613,8 +613,7 @@ public AnalyzedSentence getAnalyzedSentence(final String sentence)
 
     tokenArray[lastToken].setSentEnd();
 
-    if (tokenArray.length == 2 && (tokenArray[0].isSentStart())
-        && tokenArray[1].isLinebreak()) {
+    if (tokenArray.length == lastToken + 1 && tokenArray[lastToken].isLinebreak()) {
       tokenArray[lastToken].setParaEnd();
     }
 

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/JLanguageToolTest.java
Patch:
@@ -147,6 +147,6 @@ public void testAnalyzedSentence() throws IOException {
     assertEquals("<S> This[this/DT,this/PDT]  is[be/VBZ]  a[a/DT]  test­ed[tested/JJ,test/VBD,test/VBN,test­ed]  sentence[sentence/NN,sentence/VB,sentence/VBP].[./.,</S>]", tool.getAnalyzedSentence("This is a test\u00aded sentence.").toString());
     //test paragraph ends adding
     assertEquals("<S> </S><P/> ", tool.getAnalyzedSentence("\n").toString());
-  }
+  }    
     
 }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/Configuration.java
Patch:
@@ -47,13 +47,13 @@ public class Configuration {
   private static final String SERVER_RUN_CONFIG_KEY = "serverMode";
   private static final String SERVER_PORT_CONFIG_KEY = "serverPort";
 
-  private File configFile = null;
+  private File configFile;
 
   private Set<String> disabledRuleIds = new HashSet<String>();
   private Set<String> enabledRuleIds = new HashSet<String>();
   private Set<String> disabledCategoryNames = new HashSet<String>();
   private Language motherTongue;
-  private boolean runServer = false;
+  private boolean runServer;
   private int serverPort = HTTPServer.DEFAULT_PORT;
 
   public Configuration(final File baseDir, final String filename)

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/Lithuanian.java
Patch:
@@ -28,7 +28,7 @@
 
 public class Lithuanian extends Language {
   
-  public static final String[] COUNTRIES = {
+  private static final String[] COUNTRIES = {
     "LT"
   };
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/ConfigThread.java
Patch:
@@ -29,7 +29,7 @@ class ConfigThread extends Thread {
 
   private Language docLanguage;
   private Configuration config;
-  private de.danielnaber.languagetool.openoffice.Main mainThread = null;
+  private de.danielnaber.languagetool.openoffice.Main mainThread;
   
   private ConfigurationDialog cfgDialog;
   

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/Category.java
Patch:
@@ -24,7 +24,7 @@ public class Category {
   
   private int priority;
   private String name;
-  private boolean defaultOff = false;
+  private boolean defaultOff;
 
   /**
    * Create a new category with the given name and priority.

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/WordCoherencyRule.java
Patch:
@@ -100,15 +100,15 @@ public RuleMatch[] match(AnalyzedSentence text) {
           }
         }
         if (shouldNotAppearWord.containsKey(token)) {
-          RuleMatch otherMatch = (RuleMatch)shouldNotAppearWord.get(token);
+          RuleMatch otherMatch = shouldNotAppearWord.get(token);
           String otherSpelling = otherMatch.getMessage();
           String msg = "'" +token+ "' und '" +otherSpelling+
             "' sollten nicht gleichzeitig benutzt werden";
           RuleMatch ruleMatch = new RuleMatch(this, pos, pos+origToken.length(), msg);
           ruleMatch.setSuggestedReplacement(otherSpelling);
           ruleMatches.add(ruleMatch);
         } else if (relevantWords.containsKey(token)) {
-          String shouldNotAppear = (String)relevantWords.get(token);
+          String shouldNotAppear = relevantWords.get(token);
           // only used to display this spelling variation if the other one really occurs:
           String msg = token;
           RuleMatch potentialRuleMatch = new RuleMatch(this, pos, pos+origToken.length(), msg);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/fr/FrenchRule.java
Patch:
@@ -1,4 +1,4 @@
-/* LanguageTool, a natural language style checker 
+/* LanguageTool, a natural language style checker
  * Copyright (C) 2005 Daniel Naber (http://www.danielnaber.de)
  * 
  * This library is free software; you can redistribute it and/or

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/FalseFriendRuleLoader.java
Patch:
@@ -78,7 +78,7 @@ public final List<PatternRule> getRules(final InputStream file, final Language t
   private String formatSuggestions(final List<String> l) {
     final StringBuilder sb = new StringBuilder();
     for (final Iterator<String> iter = l.iterator(); iter.hasNext();) {
-      final String s = (String) iter.next();
+      final String s = iter.next();
       sb.append("<suggestion>");
       sb.append(s);
       sb.append("</suggestion>");
@@ -172,7 +172,6 @@ public Map<String,List<String>> getSuggestionMap() {
   //===========================================================
 
   @Override
-  @SuppressWarnings("unused")
   public void startElement(final String namespaceURI, final String lName, final String qName, final Attributes attrs) throws SAXException {
 	  if (qName.equals("rule")) {
 		  translations = new ArrayList<StringBuilder>();
@@ -279,7 +278,6 @@ public void startElement(final String namespaceURI, final String lName, final St
   }
 
   @Override
-  @SuppressWarnings("unused")
   public void endElement(final String namespaceURI, final String sName, final String qName) {
 	  if (qName.equals("rule")) {
 		  if (language == textLanguage && translationLanguage != null && translationLanguage == motherTongue

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/pl/CompoundRule.java
Patch:
@@ -30,7 +30,7 @@
  * @author Marcin Miłkowski, based on code by Daniel Naber
  */
 
-public class CompoundRule extends AbstractCompoundRule {
+public final class CompoundRule extends AbstractCompoundRule {
 
   private static final String FILE_NAME = "/resource/pl/compounds.txt";
     
@@ -43,11 +43,11 @@ public CompoundRule(final ResourceBundle messages) throws IOException {
         "Ten wyraz pisze się z łącznikiem lub bez niego.");
   }
   
-  public String getId() {
+  public final String getId() {
     return "PL_COMPOUNDS";
   }
 
-  public String getDescription() {
+  public final String getDescription() {
     return "Sprawdza wyrazy z łącznikiem, np. „łapu capu” zamiast „łapu-capu”";
   }    
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/BaseTagger.java
Patch:
@@ -87,7 +87,7 @@ public List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens) throws
       }
       pos += word.length();
       tokenReadings
-          .add(new AnalyzedTokenReadings((AnalyzedToken[]) l.toArray(new AnalyzedToken[l.size()])));
+          .add(new AnalyzedTokenReadings(l.toArray(new AnalyzedToken[l.size()])));
     }
 
     return tokenReadings;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/disambiguation/rules/DisambiguationPatternRule.java
Patch:
@@ -63,8 +63,8 @@ public static DisambiguatorAction toAction(final String str) {
   private final Language language;
   private final String description;
 
-  private int startPositionCorrection = 0;
-  private int endPositionCorrection = 0;
+  private int startPositionCorrection;
+  private int endPositionCorrection;
 
   private final List<Element> patternElements;
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/disambiguation/rules/en/EnglishRuleDisambiguator.java
Patch:
@@ -36,7 +36,7 @@
 public class EnglishRuleDisambiguator extends AbstractRuleDisambiguator {
 
   private static final String DISAMB_FILE = "disambiguation.xml";
-  private List<DisambiguationPatternRule> disambiguationRules = null;
+  private List<DisambiguationPatternRule> disambiguationRules;
 
   /**
    * Load disambiguation rules from an XML file. Use {@link #addRule} to add

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/disambiguation/rules/nl/DutchRuleDisambiguator.java
Patch:
@@ -36,7 +36,7 @@
 public class DutchRuleDisambiguator extends AbstractRuleDisambiguator {
 
   static final String DISAMB_FILE = "disambiguation.xml";
-  private List<DisambiguationPatternRule> disambiguationRules = null;
+  private List<DisambiguationPatternRule> disambiguationRules;
   
   /**
    * Load disambiguation rules from an XML file. Use {@link #addRule} to add

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/disambiguation/rules/pl/PolishRuleDisambiguator.java
Patch:
@@ -35,7 +35,7 @@
 public class PolishRuleDisambiguator extends AbstractRuleDisambiguator {
 
   private static final String DISAMB_FILE = "disambiguation.xml";
-  private List<DisambiguationPatternRule> disambiguationRules = null;
+  private List<DisambiguationPatternRule> disambiguationRules;
 
   /**
    * Load disambiguation rules from an XML file. Use {@link #addRule} to add

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/xx/DemoTagger.java
Patch:
@@ -49,7 +49,7 @@ public List<AnalyzedTokenReadings> tag(List<String> sentenceTokens) {
       // in the next line instead of null:
       l.add(new AnalyzedToken(word, null, pos));
       pos += word.length();
-      tokenReadings.add(new AnalyzedTokenReadings((AnalyzedToken[])l.toArray(new AnalyzedToken[0])));
+      tokenReadings.add(new AnalyzedTokenReadings(l.toArray(new AnalyzedToken[0])));
     }
     return tokenReadings;
   }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/SentenceTokenizer.java
Patch:
@@ -46,7 +46,7 @@ public class SentenceTokenizer implements Tokenizer {
   // Check out the private methods for comments and examples about these
   // regular expressions:
 
-  private Pattern paragraph = null;
+  private Pattern paragraph;
   private static final Pattern paragraphByTwoLineBreaks = Pattern.compile("(\\n\\s*\\n)");
   private static final Pattern paragraphByLineBreak = Pattern.compile("(\\n)");
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/WordTokenizer.java
Patch:
@@ -32,11 +32,11 @@ public class WordTokenizer implements Tokenizer {
 
   public WordTokenizer() {
   }
-  
+
   public List<String> tokenize(final String text) {
     final List<String> l = new ArrayList<String>();
     final StringTokenizer st = new StringTokenizer(text, 
-        "\u0020\u00A0\u00ad\u115f\u1160\u1680" 
+        "\u0020\u00A0\u115f\u1160\u1680" 
         + "\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007" 
         + "\u2008\u2009\u200A\u200B\u200c\u200d\u200e\u200f"
         + "\u2028\u2029\u202a\u202b\u202c\u202d\u202e\u202f"

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/cs/CzechSentenceTokenizer.java
Patch:
@@ -54,7 +54,7 @@ public class CzechSentenceTokenizer extends SentenceTokenizer {
   // Check out the private methods for comments and examples about these
   // regular expressions:
 
-  private Pattern paragraph = null;
+  private Pattern paragraph;
 
   private static final Pattern paragraphByTwoLineBreaks = Pattern.compile("(\\n\\s*\\n)");
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -31,7 +31,7 @@
  */
 public class GermanCompoundTokenizer implements Tokenizer {
 
-  private GermanWordSplitter wordSplitter = null;
+  private GermanWordSplitter wordSplitter;
   
   public GermanCompoundTokenizer() throws IOException {
     wordSplitter = new GermanWordSplitter(false);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/en/EnglishWordTokenizer.java
Patch:
@@ -37,7 +37,7 @@ public EnglishWordTokenizer() {
   public List<String> tokenize(final String text) {
     List<String> l = new ArrayList<String>();
     StringTokenizer st = new StringTokenizer(text, 
-        "\u0020\u00A0\u00ad\u115f\u1160\u1680" 
+        "\u0020\u00A0\u115f\u1160\u1680" 
         + "\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007" 
         + "\u2008\u2009\u200A\u200B\u200c\u200d\u200e\u200f"
         + "\u2028\u2029\u202a\u202b\u202c\u202d\u202e\u202f"

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/TestTools.java
Patch:
@@ -69,7 +69,7 @@ public static void myAssert(String input, String expected, Tokenizer tokenizer,
     List<AnalyzedTokenReadings> output = tagger.tag(noWhitespaceTokens);
     StringBuffer outputStr = new StringBuffer();
     for (Iterator<AnalyzedTokenReadings> iter = output.iterator(); iter.hasNext();) {
-      AnalyzedTokenReadings token = (AnalyzedTokenReadings) iter.next();
+      AnalyzedTokenReadings token = iter.next();
       int readingsNumber = token.getReadingsLength();
       for (int j = 0; j < readingsNumber; j++) {
         outputStr.append(token.getAnalyzedToken(j).getToken());
@@ -113,7 +113,7 @@ public static void myAssert(String input, String expected, Tokenizer tokenizer,
       for (String tokenStr : tokens) {
         AnalyzedTokenReadings posTag = null;
         if (isWord(tokenStr)) {
-          posTag = (AnalyzedTokenReadings) aTokens.get(noWhitespaceCount);
+          posTag = aTokens.get(noWhitespaceCount);
           posTag.setStartPos(startPos);
           noWhitespaceCount++;
         } else {
@@ -130,7 +130,7 @@ public static void myAssert(String input, String expected, Tokenizer tokenizer,
       AnalyzedTokenReadings[] output = finalSentence.getTokens();
 
       for (int i = 0; i < output.length; i++) {
-        AnalyzedTokenReadings token = (AnalyzedTokenReadings) output[i];
+        AnalyzedTokenReadings token = output[i];
         int readingsNumber = token.getReadingsLength();
         for (int j = 0; j < readingsNumber; j++) {
           outputStr.append(token.getAnalyzedToken(j).getToken());

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -115,7 +115,7 @@ private void testGrammarRulesFromXML(final List<PatternRule> rules,
       for (IncorrectExample origBadExample : badSentences) {
         // enable indentation use
         String origBadSentence = origBadExample.getExample().replaceAll("[\\n\\t]+", "");
-        List<String> suggestedCorrection = origBadExample.getCorrections();
+        final List<String> suggestedCorrection = origBadExample.getCorrections();
         final int expectedMatchStart = origBadSentence.indexOf("<marker>");
         final int expectedMatchEnd = origBadSentence.indexOf("</marker>") - "<marker>".length();
         if (expectedMatchStart == -1 || expectedMatchEnd == -1) {

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/ru/RussianCompoundRuleTest.java
Patch:
@@ -76,8 +76,8 @@ private void check(int expectedErrors, String text, String[] expSuggestions) thr
           ", expected " + expSuggestions.length,
           expSuggestions.length, ruleMatch.getSuggestedReplacements().size());
       int i = 0;
-      for (Iterator iter = ruleMatch.getSuggestedReplacements().iterator(); iter.hasNext();) {
-        String suggestion = (String) iter.next();
+      for (Iterator<String> iter = ruleMatch.getSuggestedReplacements().iterator(); iter.hasNext();) {
+        String suggestion = iter.next();
         //System.err.println(">>"+suggestion);
         assertEquals(expSuggestions[i], suggestion);
         i++;

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tokenizers/nl/DutchWordTokenizerTest.java
Patch:
@@ -27,11 +27,12 @@ public class DutchWordTokenizerTest extends TestCase {
 
   public void testTokenize() {
     DutchWordTokenizer w = new DutchWordTokenizer();
-    List <String> testList = w.tokenize("This is\u00A0a test");
+    List<String> testList = w.tokenize("This is\u00A0a test");
     assertEquals(testList.size(), 7);
     assertEquals("[This,  , is, \u00A0, a,  , test]", testList.toString());
     testList = w.tokenize("Bla bla oma's bla bla 'test");
     assertEquals(testList.size(), 12);
-    assertEquals("[Bla,  , bla,  , oma's,  , bla,  , bla,  , ', test]", testList.toString());
+    assertEquals("[Bla,  , bla,  , oma's,  , bla,  , bla,  , ', test]",
+        testList.toString());
   }
 }

File: trunk/JLanguageTool/src/dev/de/danielnaber/languagetool/dev/PrintLocales.java
Patch:
@@ -24,6 +24,7 @@
 import java.io.File;
 
 import de.danielnaber.languagetool.Language;
+import de.danielnaber.languagetool.tools.StringTools;
 
 /** Used for creating ooolocales.properties file that
  *  defines a property that is needed to build
@@ -45,7 +46,7 @@ private void run() throws IOException {
     for (final Language element : Language.LANGUAGES) {
       if (!element.equals(Language.DEMO)) {
         for (final String variant : element.getCountryVariants()) {
-          if (!("").equals(locales)) {
+          if (!StringTools.isEmpty(locales)) {
             locales = locales + " "  + element.getShortName() + "-" + variant;
           } else {
             locales = element.getShortName() + "-" + variant;

File: trunk/JLanguageTool/src/dev/de/danielnaber/languagetool/dev/RuleOverview.java
Patch:
@@ -147,7 +147,7 @@ private void run() throws IOException {
           }          
           count++;
         }
-        System.out.print("<td align=\"right\">" + (count) +
+        System.out.print("<td align=\"right\">" + count +
           "</td>");
 
         // maintainer information:

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/AnalyzedToken.java
Patch:
@@ -26,7 +26,7 @@
 public class AnalyzedToken {
 
   private String token;
-  protected String posTag;
+  private String posTag;
   private int startPos;
   private String lemma;
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/JLanguageTool.java
Patch:
@@ -535,7 +535,7 @@ public AnalyzedSentence getAnalyzedSentence(final String sentence) throws IOExce
     tokenArray[toArrayCount++] = new AnalyzedTokenReadings(startTokenArray);
     int startPos = 0;
     for (final AnalyzedTokenReadings posTag : aTokens) {
-      posTag.startPos = startPos;
+      posTag.setStartPos(startPos);
       tokenArray[toArrayCount++] = posTag;
       startPos += posTag.getToken().length();
     }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/Main.java
Patch:
@@ -517,7 +517,7 @@ private File getHomeDir() {
     return new File(homeDir);
   }
 
-  class AboutDialogThread extends Thread {
+  private class AboutDialogThread extends Thread {
 
     private ResourceBundle messages;
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/Rule.java
Patch:
@@ -111,7 +111,7 @@ public Rule(final ResourceBundle messages) {
    */
   public boolean supportsLanguage(final Language language) {
     Set<String> relevantIDs = language.getRelevantRuleIDs();
-    return (relevantIDs != null && relevantIDs.contains(getId()));    
+    return relevantIDs != null && relevantIDs.contains(getId());    
   }
 
   /**

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/AgreementRule.java
Patch:
@@ -77,7 +77,7 @@ public class AgreementRule extends GermanRule {
   };
 
   
-  private final static Set<String> REL_PRONOUN = new HashSet<String>();
+  private static final Set<String> REL_PRONOUN = new HashSet<String>();
   static {
     REL_PRONOUN.add("der");
     REL_PRONOUN.add("die");
@@ -93,7 +93,7 @@ public class AgreementRule extends GermanRule {
     REL_PRONOUN.add("welches");
   }
 
-  private final static Set<String> PREPOSITIONS = new HashSet<String>();
+  private static final Set<String> PREPOSITIONS = new HashSet<String>();
   static {
     PREPOSITIONS.add("in");
     PREPOSITIONS.add("auf");

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/WordCoherencyRule.java
Patch:
@@ -81,7 +81,7 @@ public RuleMatch[] match(AnalyzedSentence text) {
     	//defaulting to the first element because the
     	//general German lemmatizer is not (yet) there
       String token = tokens[i].getToken();
-      if (token.trim().equals("")) {
+      if (tokens[i].isWhitespace()) {
         // ignore
       } else {
         String origToken = token;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Match.java
Patch:
@@ -343,7 +343,7 @@ public final String toTokenString() {
         }
       }
     } catch (final IOException e) {
-      throw new RuntimeException(e.getMessage(), e.getCause());
+      throw new RuntimeException(e.getCause());
     }
     return output.toString();
   }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/Tagger.java
Patch:
@@ -21,7 +21,6 @@
 import java.io.IOException;
 import java.util.List;
 
-import de.danielnaber.languagetool.AnalyzedToken;
 import de.danielnaber.languagetool.AnalyzedTokenReadings;
 
 /**

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/disambiguation/pl/PolishHybridDisambiguator.java
Patch:
@@ -42,7 +42,7 @@ public class PolishHybridDisambiguator implements Disambiguator {
    * (2) a rule-based disambiguator.
    */
   @Override
-  public AnalyzedSentence disambiguate(AnalyzedSentence input)
+  public final AnalyzedSentence disambiguate(AnalyzedSentence input)
   throws IOException {
     return disambiguator.disambiguate
     ((chunker.disambiguate(input)));

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/disambiguation/rules/fr/FrenchRuleDisambiguator.java
Patch:
@@ -28,7 +28,6 @@
 
 import de.danielnaber.languagetool.AnalyzedSentence;
 import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.rules.patterns.PatternRule;
 import de.danielnaber.languagetool.tagging.disambiguation.rules.DisambiguationPatternRule;
 import de.danielnaber.languagetool.tagging.disambiguation.rules.DisambiguationRuleLoader;
 import de.danielnaber.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/disambiguation/rules/nl/DutchRuleDisambiguator.java
Patch:
@@ -28,7 +28,6 @@
 
 import de.danielnaber.languagetool.AnalyzedSentence;
 import de.danielnaber.languagetool.Language;
-import de.danielnaber.languagetool.rules.patterns.PatternRule;
 import de.danielnaber.languagetool.tagging.disambiguation.rules.DisambiguationPatternRule;
 import de.danielnaber.languagetool.tagging.disambiguation.rules.DisambiguationRuleLoader;
 import de.danielnaber.languagetool.tagging.disambiguation.rules.AbstractRuleDisambiguator;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/pl/PolishTagger.java
Patch:
@@ -42,7 +42,7 @@ public class PolishTagger extends BaseTagger {
 	private Locale plLocale = new Locale("pl");
 
   @Override
-  public void setFileName() {
+  public final void setFileName() {
     System.setProperty(Lametyzator.PROPERTY_NAME_LAMETYZATOR_DICTIONARY, 
         RESOURCE_FILENAME);    
   }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tools/ReflectionUtils.java
Patch:
@@ -34,7 +34,7 @@
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 
-public class ReflectionUtils {
+public final class ReflectionUtils {
 
   private ReflectionUtils() {
     // a static singleton class

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tools/Tools.java
Patch:
@@ -27,7 +27,6 @@
 import java.io.StringWriter;
 import java.net.MalformedURLException;
 import java.net.URL;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/TestTools.java
Patch:
@@ -114,7 +114,7 @@ public static void myAssert(String input, String expected, Tokenizer tokenizer,
         AnalyzedTokenReadings posTag = null;
         if (isWord(tokenStr)) {
           posTag = (AnalyzedTokenReadings) aTokens.get(noWhitespaceCount);
-          posTag.startPos = startPos;
+          posTag.setStartPos(startPos);
           noWhitespaceCount++;
         } else {
           posTag = (AnalyzedTokenReadings) tagger.createNullToken(tokenStr, startPos);

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/synthesis/pl/PolishSynthesizerTest.java
Patch:
@@ -7,7 +7,7 @@
 import de.danielnaber.languagetool.AnalyzedToken;
 
 public class PolishSynthesizerTest extends TestCase {
-  private final AnalyzedToken dummyToken(String tokenStr) {
+  private AnalyzedToken dummyToken(String tokenStr) {
     return new AnalyzedToken(tokenStr, tokenStr, tokenStr);
   }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Match.java
Patch:
@@ -429,7 +429,7 @@ public final AnalyzedTokenReadings filterReadings(
             if (tst != null) {
               if (pPosRegexMatch.matcher(tst).matches()) {
                 targetPosTag = formattedToken.getAnalyzedToken(i).getPOSTag();
-                if (pPosRegexMatch != null && posTagReplace != null) {
+                if (posTagReplace != null) {
                   targetPosTag = pPosRegexMatch.matcher(targetPosTag)
                       .replaceAll(posTagReplace);
                 }

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/patterns/TestUnifier.java
Patch:
@@ -5,7 +5,7 @@
 import junit.framework.TestCase;
 import de.danielnaber.languagetool.AnalyzedToken;
 
-public class testUnifier extends TestCase {
+public class TestUnifier extends TestCase {
 
   // trivial unification = test if the character case is the same
   public void testUnificationCase() {

File: trunk/JLanguageTool/src/dev/de/danielnaber/languagetool/dev/CheckWikipediaDump.java
Patch:
@@ -255,17 +255,17 @@ public String filter(String s) {
     WikiModel wikiModel = new WikiModel("${image}", "${title}");
     s = wikiModel.render(s);
     //System.out.println("0####"+s);
-    s = s.replaceAll("\n", " ");
     s = s.replaceAll("\\{\\{.*?\\}\\}", "");
     s = s.replaceAll("</p>", "\n\n");
     s = s.replaceAll("</dt>", "\n\n");
     s = s.replaceAll("</dl>", "\n\n");
     s = s.replaceAll("</h\\d>", "\n\n");
     s = s.replaceAll("<a href=\"http://[a-zA-Z-]+\\.wikipedia\\.org/wiki/.*?\">.*?</a>", "");
     s = s.replaceAll("<.*?>", "");
-    s = s.replaceAll("\n\n+", "\n\n");
+    s = s.replaceAll("\n\n*", "\n\n");    // single line break isn't detected as paragraph in LT by default
     s = StringEscapeUtils.unescapeHtml(s);
-    //System.out.println("1####"+s);
+    //System.out.println("1############################################\n"+s);
+    //System.out.println("/############################################"+s);
     return s;
   }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/WhitespaceRule.java
Patch:
@@ -61,7 +61,7 @@ public RuleMatch[] match(final AnalyzedSentence text) {
     //token no. 0 is guaranteed to be SENT_START
     int i = 1;
     while (i < tokens.length) {
-      if (tokens[i].isWhitespace() && prevWhite) {
+      if (tokens[i].isWhitespace() && prevWhite && !tokens[i -1].isLinebreak()) {
         final int pos = tokens[i -1].getStartPos();
         while (i < tokens.length && tokens[i].isWhitespace()) {
           prevLen += tokens[i].getToken().length();

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/WhitespaceRuleTest.java
Patch:
@@ -41,6 +41,8 @@ public void testRule() throws IOException {
       assertEquals(0, matches.length);
       matches = rule.match(langTool.getAnalyzedSentence("This is a test sentence..."));
       assertEquals(0, matches.length);
+      matches = rule.match(langTool.getAnalyzedSentence("\n\tThis is a test sentence..."));
+      assertEquals(0, matches.length);
       
       // incorrect sentences:
       matches = rule.match(langTool.getAnalyzedSentence("This  is a test sentence."));

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/BaseTagger.java
Patch:
@@ -68,7 +68,7 @@ public List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens) throws
         while (i < taggerTokens.length) {
           //Lametyzator returns data as String[]
           //first lemma, then annotations
-          l.add(new AnalyzedToken(word, taggerTokens[i + 1], taggerTokens[i]));
+          l.add(new AnalyzedToken(word, taggerTokens[i + 1], taggerTokens[i], pos));
           i = i + 2;
         }
       }
@@ -77,7 +77,7 @@ public List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens) throws
         while (i < lowerTaggerTokens.length) {
           //Lametyzator returns data as String[]
           //first lemma, then annotations
-          l.add(new AnalyzedToken(word, lowerTaggerTokens[i + 1], lowerTaggerTokens[i]));
+          l.add(new AnalyzedToken(word, lowerTaggerTokens[i + 1], lowerTaggerTokens[i], pos));
           i = i + 2;
         }
       }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/cs/CzechTagger.java
Patch:
@@ -88,7 +88,7 @@ public final List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens)
           final String[] tagsArr = taggerTokens[i + 1].split("\\+");
 
           for (final String currTag : tagsArr) {
-            l.add(new AnalyzedToken(word, currTag, lemma));
+            l.add(new AnalyzedToken(word, currTag, lemma, pos));
           }
 
           i += 2;
@@ -104,7 +104,7 @@ public final List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens)
           final String[] tagsArr = lowerTaggerTokens[i + 1].split("\\+");
 
           for (final String currTag : tagsArr) {
-            l.add(new AnalyzedToken(word, currTag, lemma));
+            l.add(new AnalyzedToken(word, currTag, lemma, pos));
           }
 
           i += 2;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/pl/PolishTagger.java
Patch:
@@ -77,7 +77,7 @@ public final List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens)
             final String[] tagsArr = taggerTokens[i + 1].split("\\+");
 
             for (final String currTag : tagsArr) {
-              l.add(new AnalyzedToken(word, currTag, lemma));
+              l.add(new AnalyzedToken(word, currTag, lemma, pos));
             }
             i = i + 2;
         } 
@@ -92,7 +92,7 @@ public final List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens)
            final String[] tagsArr = lowerTaggerTokens[i + 1].split("\\+");
 
            for (final String currTag : tagsArr) {
-             l.add(new AnalyzedToken(word, currTag, lemma));
+             l.add(new AnalyzedToken(word, currTag, lemma, pos));
            }
            i = i + 2;
        } 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/SentenceTokenizer.java
Patch:
@@ -77,10 +77,10 @@ public class SentenceTokenizer implements Tokenizer {
   private static final String[] ABBREV_LIST = {
       // English -- but these work globally for all languages:
       "Mr", "Mrs", "No", "pp", "St", "no", 
-      "Sr", "Bros", "etc", "vs", "esp", "Fig", "fig", "Jan", "Feb", "Mar", "Apr", "Jun", "Jul",
+      "Sr", "Jr", "Bros", "etc", "vs", "esp", "Fig", "fig", "Jan", "Feb", "Mar", "Apr", "Jun", "Jul",
       "Aug", "Sep", "Sept", "Oct", "Okt", "Nov", "Dec", "Ph.D", "PhD",
       "al",  // in "et al."
-      "cf", "Inc", "Ms", "Gen", "Sen", "Prof"
+      "cf", "Inc", "Ms", "Gen", "Sen", "Prof", "Corp", "Co"
   };
 
   private static Set<String> abbreviations = new HashSet<String>();  

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/pl/PolishSentenceTokenizer.java
Patch:
@@ -175,8 +175,8 @@ private String removeFalseEndOfSentence(String s) {
     
     s = s.replaceAll("(\\d+\\.) " + EOS + "([\\p{L}&&[^\\p{Lu}]]+)", "$1 $2");
 
-    // z.B. "Das hier ist ein(!) Satz."
-      s = s.replaceAll("\\(([!?]+)\\) " + EOS, "($1) ");
+    // np. "Uczeń napisał: "Szfecja (sic!) jest wielkim krajem".
+      s = s.replaceAll("\\(((sic)?[!?]+)\\) " + EOS, "($1) ");
     return s;
   } 
 

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tokenizers/pl/PolishSentenceTokenizerTest.java
Patch:
@@ -103,6 +103,8 @@ public final void testTokenize() {
     testSplit(new String[] {"Mam już 20 mln. buraków."});
     //ellipsis
     testSplit(new String[] { "Rytmem tej wiecznie przemijającej światowej egzystencji […] rytmem mesjańskiej natury jest szczęście." });
+    //sic!
+    testSplit(new String[] { "W gazecie napisali, że pasy (sic!) pogryzły człowieka." });
   }
 
   public final void testSplit(final String[] sentences) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Element.java
Patch:
@@ -426,7 +426,7 @@ public final void setPosException(final String posToken, final boolean regExp,
         new Element("", this.caseSensitive, regExp, false);
     posException.setPosElement(posToken, regExp, negation);
     posException.exceptionValidNext = scopeNext;
-    exceptionValidPrevious = scopePrevious;
+    exceptionValidPrevious |= scopePrevious;
     if (exceptionList == null && !scopePrevious) {
       exceptionList = new ArrayList<Element>();
     }
@@ -462,7 +462,7 @@ public final void setStringException(final String token, final boolean regExp,
           token, this.caseSensitive, regExp, inflected);
     stringException.setNegation(negation);
     stringException.exceptionValidNext = scopeNext;
-    exceptionValidPrevious = scopePrevious;
+    exceptionValidPrevious |= scopePrevious;
     if (exceptionList == null && !scopePrevious) {
       exceptionList = new ArrayList<Element>();
     }

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tagging/disambiguation/pl/PolishChunkerTest.java
Patch:
@@ -47,7 +47,7 @@ public void testChunker() throws IOException {
       //TestTools.myAssert("Krowa pasie się na pastwisku.", "/[null]SENT_START Krowa/[krowa]subst:sg:nom:f  /[null]null pasie/[pas]subst:sg:loc.voc:m3|pasie/[paść]verb:irreg  /[null]null się/[siebie]qub  /[null]null na/[na]prep:acc.loc  /[null]null pastwisku/[pastwisko]subst:sg:dat:n+subst:sg:loc:n ./[null]SENT_END", tokenizer, sentenceTokenizer, tagger, disambiguator);
       //TestTools.myAssert("blablabla","/[null]SENT_START blablabla/[null]SENT_END", tokenizer, sentenceTokenizer, tagger, disambiguator);
       TestTools.myAssert("To test... dezambiguacji","/[null]SENT_START To/[to]conj|To/[ten]adj:sg:nom.acc.voc:n:pos  /[null]null test/[test]subst:sg:nom.acc:m3|test/[testo]subst:pl:gen:n ./[...]<ELLIPSIS> ./[null]null ./[...]</ELLIPSIS>  /[null]null dezambiguacji/[null]null", tokenizer, sentenceTokenizer, tagger, disambiguator);
-      TestTools.myAssert("On, to znaczy premier, jest niezbyt mądry","/[null]SENT_START On/[on]ppron3:sg:nom:m1.m2.m3:ter ,/[null]null  /[null]null to/[to]conj|to/[ten]adj:sg:nom.acc.voc:n:pos|to/[to znaczy]<TO_ZNACZY>  /[null]null znaczy/[znaczyć]verb:fin:sg:ter:imperf|znaczy/[to znaczy]</TO_ZNACZY>  /[null]null premier/[premier]subst:sg:nom.acc:m3|premier/[premiera]subst:pl:gen:f ,/[null]null  /[null]null jest/[być]verb:fin:sg:ter:imperf  /[null]null niezbyt/[zbyt]adv:pos:neg  /[null]null mądry/[mądry]adj:sg:nom.acc:m3:pos|mądry/[mądry]adj:sg:nom.voc:m1.m2:pos|mądry/[mądry]adj:sg:nom.acc:m3:pos:aff|mądry/[mądry]adj:sg:nom.voc:m1.m2:pos:aff", tokenizer, sentenceTokenizer, tagger, disambiguator);
+      TestTools.myAssert("On, to znaczy premier, jest niezbyt mądry","/[null]SENT_START On/[on]ppron3:sg:nom:m1.m2.m3:ter ,/[null]null  /[null]null to/[to]conj|to/[ten]adj:sg:nom.acc.voc:n:pos|to/[to znaczy]<TO_ZNACZY>  /[null]null znaczy/[znaczyć]verb:fin:sg:ter:imperf|znaczy/[to znaczy]</TO_ZNACZY>  /[null]null premier/[premier]subst:sg:nom:m1|premier/[premiera]subst:pl:gen:f ,/[null]null  /[null]null jest/[być]verb:fin:sg:ter:imperf  /[null]null niezbyt/[zbyt]adv:pos:neg  /[null]null mądry/[mądry]adj:sg:nom.acc:m3:pos|mądry/[mądry]adj:sg:nom.voc:m1.m2:pos|mądry/[mądry]adj:sg:nom.acc:m3:pos:aff|mądry/[mądry]adj:sg:nom.voc:m1.m2:pos:aff", tokenizer, sentenceTokenizer, tagger, disambiguator);
       TestTools.myAssert("Lubię go z uwagi na krótkie włosy.","/[null]SENT_START Lubię/[lubić]verb:fin:sg:pri:imperf  /[null]null go/[on]ppron3:sg:gen:m1.m2.m3.n1.n2:ter:nakc:npraep|go/[on]ppron3:sg:acc:m1.m2.m3:ter:nakc:npraep|go/[on]ppron3:sg:gen:m1.m2.m3.n:ter:nakc:npraep|go/[on]ppron3:sg:acc:m1.m2.m3:ter:nakc:npraep  /[null]null z/[z]prep:gen.inst|z/[z uwagi na]<PREP:ACC>  /[null]null uwagi/[uwaga]subst:sg:gen.dat.loc:f  /[null]null na/[na]prep:acc.loc|na/[z uwagi na]</PREP:ACC>  /[null]null krótkie/[krótki]adj:sg:nom.acc.voc:n:pos:aff|krótkie/[krótki]adj:pl:nom.acc.voc:f.n.m2.m3:pos:aff  /[null]null włosy/[włosy]subst:pltant:nom:m|włosy/[włos]subst:pl:nom.voc:m ./[null]null", tokenizer, sentenceTokenizer, tagger, disambiguator);
     }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/disambiguation/pl/PolishChunker.java
Patch:
@@ -26,6 +26,7 @@ public class PolishChunker implements Disambiguator {
 
       private static final String TOKEN_DEFINITIONS = 
         "...|ELLIPSIS\n" 
+        + "bez mała|ADV\n"
         + "to znaczy|TO_ZNACZY\nTo znaczy|TO_ZNACZY\n" 
         + "to jest|TO_JEST\nTo jest|TO_JEST\n" 
         + "z uwagi na|PREP:ACC\n" 

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/synthesis/en/EnglishSynthesizerTest.java
Patch:
@@ -16,7 +16,7 @@ public final void testSynthesizeStringString() throws IOException {
     assertNull(synth.synthesize(dummyToken("blablabla"), 
         "blablabla"));
     
-    assertEquals("[were, wast, was]", Arrays.toString(synth.synthesize(dummyToken("be"), "VBD")));
+    assertEquals("[was, were]", Arrays.toString(synth.synthesize(dummyToken("be"), "VBD")));
     assertEquals("[presidents]", Arrays.toString(synth.synthesize(dummyToken("president"), "NNS")));
     assertEquals("[tested]", Arrays.toString(synth.synthesize(dummyToken("test"), "VBD")));
     assertEquals("[tested]", Arrays.toString(synth.synthesize(dummyToken("test"), "VBD", false)));

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -318,6 +318,7 @@ public void startElement(final String namespaceURI, final String lName, final St
       defaultOff = "off".equals(attrs.getValue("default"));
       defaultOn = "on".equals(attrs.getValue("default"));
       inRuleGroup = true;
+      subId = 0;
     } else if (qName.equals("suggestion") && inMessage) {
       message.append("<suggestion>");
     } else if (qName.equals("match")) {
@@ -528,8 +529,7 @@ public void endElement(final String namespaceURI, final String sName, final Stri
       }
       inMatch = false;
     } else if (qName.equals("rulegroup")) {
-      inRuleGroup = false;
-      subId = 0;
+      inRuleGroup = false;      
     } else if (qName.equals("suggestion") && inMessage) {
       message.append("</suggestion>");
     } else if (qName.equals(MARKER) && inCorrectExample) {
@@ -624,7 +624,7 @@ private void prepareRule(final PatternRule rule) {
     endPositionCorrection = 0;
     rule.setCorrectExamples(correctExamples);
     rule.setIncorrectExamples(incorrectExamples);      
-    rule.setCategory(category);
+    rule.setCategory(category);    
     rule.setSubId(subId + "");
     caseSensitive = false;
     if (suggestionMatches != null) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Match.java
Patch:
@@ -365,9 +365,9 @@ private String convertCase(final String s) {
     switch (caseConversionType) {
       case NONE : break;
       case STARTLOWER : token = token.substring(0, 1).toLowerCase() 
-        + formattedToken.getToken().substring(1); break;
+        + token.substring(1); break;
       case STARTUPPER : token = token.substring(0, 1).toUpperCase() 
-        + formattedToken.getToken().substring(1); break;
+        + token.substring(1); break;
       case ALLUPPER : token = token.toUpperCase(); break;
       case ALLLOWER : token = token.toLowerCase(); break;
       default : break;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/disambiguation/rules/DisambiguationPatternRule.java
Patch:
@@ -170,9 +170,6 @@ public final AnalyzedSentence replace(final AnalyzedSentence text) throws IOExce
 
           for (int l = 0; l < numberOfReadings; l++) {
             final AnalyzedToken matchToken = tokens[m].getAnalyzedToken(l);
-            if (id.equals("UPPER_NNP") && matchToken.getToken().equals("Maxwell")) {
-              System.out.println("gotcha!");
-            }
             if (prevSkipNext > 0 && prevElement != null
                 && prevElement.isMatchedByScopeNextException(matchToken)) {
               exceptionMatched = true;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRule.java
Patch:
@@ -468,11 +468,10 @@ public final RuleMatch[] match(final AnalyzedSentence text) throws IOException {
               shortMessage, startsWithUppercase);        
           ruleMatches.add(ruleMatch);        
         }
-      } else {
+      } 
         firstMatchToken = -1;
         lastMatchToken = -1;
         skipShiftTotal = 0;
-      }
     }
 
     return ruleMatches.toArray(new RuleMatch[ruleMatches.size()]);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/en/AvsAnRule.java
Patch:
@@ -199,11 +199,11 @@ public final String suggestAorAn(final String noun) {
       }
     }
     if (doesRequireA) {
-      return "a " + word;
+      return "a " + noun;
     } else if (doesRequireAn) {
-      return "an " + word;
+      return "an " + noun;
     } else {
-      return word;
+      return noun;
     }
   }
   

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/disambiguation/rules/DisambiguationRuleLoader.java
Patch:
@@ -242,9 +242,9 @@ public void endElement(final String namespaceURI, final String sName, final Stri
     if (qName.equals("rule")) {        
       final DisambiguationPatternRule rule = new DisambiguationPatternRule(id, name, 
           language, elementList, disambiguatedPOS, posSelector);
-      rule.setStartPositionCorrection(positionCorrection);      
+      rule.setStartPositionCorrection(positionCorrection);
+      caseSensitive = false;
       rules.add(rule);      
-
       if (elementList != null) {
         elementList.clear();
       }

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/en/AvsAnRuleTest.java
Patch:
@@ -115,6 +115,8 @@ public void testSuggestions() throws IOException {
     assertEquals("a string", rule.suggestAorAn("string"));
     assertEquals("a university", rule.suggestAorAn("university"));
     assertEquals("an hour", rule.suggestAorAn("hour"));
+    assertEquals("an all-terrain", rule.suggestAorAn("all-terrain"));    
     assertEquals("UNESCO", rule.suggestAorAn("UNESCO"));
+    
   }
 }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Main.java
Patch:
@@ -75,7 +75,7 @@ class Main {
     for (int i = 0; i < disabledRules.length; i++) {
       lt.disableRule(disabledRules[i]);
     }
-    // disable all rules except those enabled explictly, if any:
+    // disable all rules except those enabled explicitly, if any:
     if (enabledRules.length > 0) {
       Set<String> enabledRuleIDs = new HashSet<String>(Arrays.asList(enabledRules));
       for (Rule rule : lt.getAllRules()) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/AgreementRule.java
Patch:
@@ -331,7 +331,7 @@ private RuleMatch checkDetAdjNounAgreement(final AnalyzedGermanTokenReadings tok
       if (set.size() > 0) {
         System.err.println("GENUS!");
       }*/
-      String msg = "Fehlende Übereinstimmung (Kongruenz) zwischen Artikel, Adjektiv und " +
+      String msg = "Möglicherweise fehlende Übereinstimmung (Kongruenz) zwischen Artikel, Adjektiv und " +
             "Nomen bezüglich Kasus, Numerus oder Genus. Beispiel: 'mein kleiner Haus' " +
             "statt 'mein kleines Haus'";
       ruleMatch = new RuleMatch(this, token1.getStartPos(), 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/SentenceTokenizer.java
Patch:
@@ -49,8 +49,9 @@ public class SentenceTokenizer implements Tokenizer {
   private Pattern paragraph = null;
   private static final Pattern paragraphByTwoLineBreaks = Pattern.compile("(\\n\\s*\\n)");
   private static final Pattern paragraphByLineBreak = Pattern.compile("(\\n)");
-  
-  private static final Pattern punctWhitespace = Pattern.compile("(" + PAP + "\\s)");
+
+  // add unbreakable field, for example footnote, if it's at the end of the sentence
+  private static final Pattern punctWhitespace = Pattern.compile("(" + PAP + "(\u0002)?\\s)");
   // \p{Lu} = uppercase, with obeying Unicode (\p{Upper} is just US-ASCII!):
   private static final Pattern punctUpperLower = Pattern.compile("(" + PAP
       + ")([\\p{Lu}][^\\p{Lu}.])");

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/cs/CzechSentenceTokenizer.java
Patch:
@@ -41,7 +41,8 @@ public class CzechSentenceTokenizer extends SentenceTokenizer {
 
   private static final Pattern paragraphByLineBreak = Pattern.compile("(\\n)");
 
-  private static final Pattern punctWhitespace = Pattern.compile("(" + PAP + "\\s)");
+  // add unbreakable field, for example footnote, if it's at the end of the sentence
+  private static final Pattern punctWhitespace = Pattern.compile("(" + PAP + "(\u0002)?\\s)");
 
   // \p{Lu} = uppercase, with obeying Unicode (\p{Upper} is just US-ASCII!):
   private static final Pattern punctUpperLower = Pattern.compile("(" + PAP

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/pl/PolishSentenceTokenizer.java
Patch:
@@ -40,7 +40,8 @@ public class PolishSentenceTokenizer extends SentenceTokenizer {
   private static final Pattern paragraphByTwoLineBreaks = Pattern.compile("(\\n\\s*\\n[\\t]*)");
   private static final Pattern paragraphByLineBreak = Pattern.compile("(\\n[\\t]*)");
   
-  private static final Pattern punctWhitespace = Pattern.compile("(" + PAP + "\\s)");
+  // add unbreakable field, for example footnote, if it's at the end of the sentence
+  private static final Pattern punctWhitespace = Pattern.compile("(" + PAP + "(\u0002)?\\s)");
   // \p{Lu} = uppercase, with obeying Unicode (\p{Upper} is just US-ASCII!):
   private static final Pattern punctUpperLower = Pattern.compile("(" + PAP
       + ")([\\p{Lu}][^\\p{Lu}.])");

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/pl/PolishSentenceTokenizer.java
Patch:
@@ -45,8 +45,8 @@ public class PolishSentenceTokenizer extends SentenceTokenizer {
   private static final Pattern punctUpperLower = Pattern.compile("(" + PAP
       + ")([\\p{Lu}][^\\p{Lu}.])");
   private static final Pattern letterPunct = Pattern.compile("(\\s[\\p{L}]" + P + ")");
-  private static final Pattern abbrev1 = Pattern.compile("([^-\\p{L}”][\\p{L}]" + PAP + "\\s)" + EOS);
-  private static final Pattern abbrev2 = Pattern.compile("([^-\\p{L}][\\p{L}]" + P + ")" + EOS);
+  private static final Pattern abbrev1 = Pattern.compile("([^-\\p{L}\\p{S}”][\\p{L}]" + PAP + "\\s)" + EOS);
+  private static final Pattern abbrev2 = Pattern.compile("([^-\\p{L}\\p{S}][\\p{L}]" + P + ")" + EOS);
   //** Lookahead regexp excludes some possible abbrevs here
   private static final Pattern abbrev3 = Pattern.compile("(\\s(?![rwn])[\\p{L}]\\.\\s+)" + EOS +"(\\p{Ll}\\p{Ll}|\\p{Lu}[\\p{Punct}\\p{Lu}])");
   private static final Pattern abbrev4 = Pattern.compile("(\\.\\.\\. )" + EOS + "([\\p{Ll}])");

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/WhitespaceRule.java
Patch:
@@ -62,12 +62,12 @@ public RuleMatch[] match(final AnalyzedSentence text) {
     int i = 1;
     while (i < tokens.length) {
       if (tokens[i].isWhitespace() && prevWhite) {
-        final int pos = tokens[i].getStartPos();
+        final int pos = tokens[i -1].getStartPos();
         while (i < tokens.length && tokens[i].isWhitespace()) {
           prevLen += tokens[i].getToken().length();
           i++;
         }
-        final RuleMatch ruleMatch = new RuleMatch(this, prevPos, pos + prevLen - 1, messages
+        final RuleMatch ruleMatch = new RuleMatch(this, prevPos, pos + prevLen, messages
             .getString("whitespace_repetition"));
         ruleMatch.setSuggestedReplacement(" ");
         ruleMatches.add(ruleMatch);

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/WhitespaceRuleTest.java
Patch:
@@ -59,7 +59,8 @@ public void testRule() throws IOException {
       assertEquals(13, matches[1].getToPos());
       assertEquals(17, matches[2].getFromPos());
       assertEquals(20, matches[2].getToPos());
-      
+      matches = rule.match(langTool.getAnalyzedSentence("\t\t\t    \t\t\t\t  "));
+      assertEquals(1, matches.length);
       langTool = new JLanguageTool(Language.POLISH);
       // correct sentences:
       matches = rule.match(langTool.getAnalyzedSentence("To jest test."));

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/server/HTTPServer.java
Patch:
@@ -125,7 +125,7 @@ public String demultiplex(Request connRequest, Response connResponse) {
         List<RuleMatch> matches = lt.check(text);
         connResponse.setHeaderLine(ProtocolResponseHeader.Content_Type, "text/xml");
         // TODO: how to set the encoding to utf-8 if we can just return a String?
-        connResponse.setHeaderLine(ProtocolResponseHeader.Content_Encoding, System.getProperty("file.encoding"));
+        connResponse.setHeaderLine(ProtocolResponseHeader.Content_Encoding, "UTF-8");
         String response = StringTools.ruleMatchesToXML(matches, text, CONTEXT_SIZE);
         print("Check done in " + (System.currentTimeMillis()-timeStart) + "ms");
         return response;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tools/StringTools.java
Patch:
@@ -199,7 +199,7 @@ public static String ruleMatchesToXML(final List<RuleMatch> ruleMatches, final S
     // IMPORTANT: people rely on this format, don't change it!
     //
     final StringBuilder xml = new StringBuilder();
-    xml.append("<?xml version=\"1.0\" encoding=\"" +System.getProperty("file.encoding")+ "\"?>\n");
+    xml.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
     xml.append("<matches>\n");
     int i = 1;
     for (final RuleMatch match : ruleMatches) {

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/server/HTTPServerTest.java
Patch:
@@ -35,7 +35,7 @@ public void testHTTPServer() {
     try {
       server.run();
       // no error:
-      String enc = System.getProperty("file.encoding");
+      String enc = "UTF-8";
       assertEquals("<?xml version=\"1.0\" encoding=\""+enc+"\"?>\n<matches>\n</matches>\n", check(Language.GERMAN, ""));
       assertEquals("<?xml version=\"1.0\" encoding=\""+enc+"\"?>\n<matches>\n</matches>\n", check(Language.GERMAN, "Ein kleiner test"));
       // one error:

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/server/HTTPServerTest.java
Patch:
@@ -44,7 +44,8 @@ public void testHTTPServer() {
       String result = check(Language.GERMAN, "ein kleiner test. Und wieder Erwarten noch was: \u00f6\u00e4\u00fc\u00df.");
       assertTrue(result.indexOf("UPPERCASE_SENTENCE_START") != -1);
       assertTrue(result.indexOf("WIEDER_WILLEN") != -1);
-      assertTrue(result.indexOf("\u00f6\u00e4\u00fc\u00df") != -1);   // special chars are intact
+      assertTrue("Expected special chars, got: '" + result+ "'",
+          result.indexOf("\u00f6\u00e4\u00fc\u00df") != -1);   // special chars are intact
       XMLValidator validator = new XMLValidator();
       validator.validateXMLString(result, "/resource/api-output.dtd", "matches");
       validator.checkSimpleXMLString(result);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -35,6 +35,8 @@ public class GermanCompoundTokenizer implements Tokenizer {
   
   public GermanCompoundTokenizer() throws IOException {
     wordSplitter = new GermanWordSplitter(false);
+    wordSplitter.setStrictMode(true); // required for now to make minimum length work
+    wordSplitter.setMinimumWordLength(3);
   }
   
   public List<String> tokenize(String word) {

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/de/CaseRuleTest.java
Patch:
@@ -54,6 +54,8 @@ public void testRule() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Schon Le Monde schrieb das.")).length);
     // unknown word:
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("In Blubberdorf macht man das so.")).length);
+    // used to trigger an erro because of incorrect compound tokenization:
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("Das sind Euroscheine.")).length);
     
     // TODO: nach dem Doppelpunkt wird derzeit nicht auf groß/klein getestet:
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Das ist es: kein Satz.")).length);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/disambiguation/pl/PolishChunker.java
Patch:
@@ -57,7 +57,8 @@ public class PolishChunker implements Disambiguator {
         + "do niedawna|ADV\nDo niedawna|ADV\n"
         + "do równa|ADV\n"
         + "do syta|ADV\n"
-        + "do żywa|ADV\n";
+        + "do żywa|ADV\n" 
+        + "od nowa|ADV\nOd nowa|ADV\n";
       
     /* Lazy init, thanks to Artur Trzewik
      */

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/RuleFilenameException.java
Patch:
@@ -29,7 +29,9 @@ public class RuleFilenameException extends RuntimeException {
 
   public RuleFilenameException(File file) {
     super("Rule file must be named rules-<xx>-<lang>.xml (<xx> = language code, " +
-        "<lang> = language name), current name: " + file.getName());
+        "<lang> = language name),\n" +
+        "for example: rules-en-English.xml\n" +
+        "Current name: " + file.getName());
   }
   
 }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/Rule.java
Patch:
@@ -45,7 +45,7 @@ public abstract class Rule {
    * by default.
    */
   private boolean defaultOff = false;
-
+  
   protected ResourceBundle messages;
 
   /**
@@ -242,5 +242,5 @@ public final boolean isDefaultOff() {
   public final void setDefaultOff() {
     defaultOff = true;
   }
-  
+
 }

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -319,7 +319,7 @@ public static void main(final String[] args) throws IOException {
     System.out.println("Running XML pattern tests...");
     prt.setUp();
     final Set<Language> ignoredLanguages = new HashSet<Language>();
-    ignoredLanguages.add(Language.CZECH);   // has no XML rules yet
+    //ignoredLanguages.add(Language.CZECH);   // has no XML rules yet
     prt.testGrammarRulesFromXML(ignoredLanguages, true);
     System.out.println("Tests successful.");
   }

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/CommaWhitespaceRuleTest.java
Patch:
@@ -64,6 +64,8 @@ public void testRule() throws IOException {
     assertEquals(6, matches[0].getToPos());
     assertEquals(11, matches[1].getFromPos());
     assertEquals(13, matches[1].getToPos());
+    matches = rule.match(langTool.getAnalyzedSentence("This is a test with a OOo footnote\u0002, which is denoted by 0x2 in the text."));
+    assertEquals(0, matches.length);
   }
   
 }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/WiederVsWiderRule.java
Patch:
@@ -69,8 +69,8 @@ public RuleMatch[] match(AnalyzedSentence text) {
           foundWider = true;
         }
         if (foundSpiegelt && foundWieder && !foundWider) {
-          String msg = "<i>wider</i> in <i>widerspiegeln</i> wird mit <i>i</i> statt mit <i>ie</i> "+
-            "geschrieben, z.B. <i>Das spiegelt die Situation gut wider.</i>";
+          String msg = "'wider' in 'widerspiegeln' wird mit 'i' statt mit 'ie' "+
+            "geschrieben, z.B. 'Das spiegelt die Situation gut wider.'";
           RuleMatch ruleMatch = new RuleMatch(this, pos, pos+token.length(), msg);
           ruleMatch.setSuggestedReplacement("wider");
           ruleMatches.add(ruleMatch);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tools/StringTools.java
Patch:
@@ -390,6 +390,9 @@ public static char getMnemonic(final String label) {
    * @return true if the string is whitespace-only.
    */
   public static boolean isWhitespace(final String str) {
+    if ("\u0002".equals(str)) { //footnote number in OOo
+      return false;
+    }
     final String trimStr = str.trim();
     if (("").equals(trimStr)) {
       return true;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/OOoDialog.java
Patch:
@@ -261,6 +261,8 @@ void show() {
     // Try to fix the problem that the window appears in the
     // background for some people:
     dialog.toFront();
+    //stay on top
+    dialog.setAlwaysOnTop(true);
     // FIXME: close via "X" in the window must behave like close via "close" button
   }
   

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/ReplaceTextDialog.java
Patch:
@@ -84,6 +84,7 @@ class ReplaceTextDialog implements ActionListener {
     OOoDialog.centerDialog(dialog);
     dialog.setModal(true);
     dialog.setVisible(true);
+    dialog.setAlwaysOnTop(true);
   }
 
   public void actionPerformed(ActionEvent event) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/Czech.java
Patch:
@@ -33,7 +33,7 @@ public class Czech extends Language {
   private Tagger tagger = new CzechTagger();
   private SentenceTokenizer sentenceTokenizer = new CzechSentenceTokenizer();
 
-  private static String[] COUNTRIES = {"PL"};
+  private static final String[] COUNTRIES = {"CZ"};
   
   public Locale getLocale() {
     return new Locale(getShortName());

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/Dutch.java
Patch:
@@ -36,7 +36,7 @@ public class Dutch extends Language {
   private SentenceTokenizer sentenceTokenizer = new DutchSentenceTokenizer();
   private Synthesizer synthesizer = new DutchSynthesizer();
   
-  private static String[] COUNTRIES = {"NL"}; 
+  private static final String[] COUNTRIES = {"NL"}; 
   
   public Locale getLocale() {
     return new Locale(getShortName());

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/French.java
Patch:
@@ -33,7 +33,7 @@ public class French extends Language {
   private Tagger tagger = new FrenchTagger();
   private Disambiguator disambiguator = new FrenchRuleDisambiguator();
 
-  private static String[] countries = {"FR", "", "BE", "CH", "CA", 
+  private static final String[] COUNTRIES = {"FR", "", "BE", "CH", "CA", 
     "LU", "MC", "CM", "CI", "HI", "ML", "SN", "CD", "MA", "RE"
   };
   
@@ -50,7 +50,7 @@ public String getShortName() {
   }
   
   public String[] getCountryVariants() {
-    return countries;
+    return COUNTRIES;
   }
 
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tools/Tools.java
Patch:
@@ -51,7 +51,7 @@ public static int checkText(final String contents, JLanguageTool lt, boolean api
   }
 
   /**
-   * Check the gicen text and print results to System.out.
+   * Check the given text and print results to System.out.
    * @param contents a text to check (may be more than one sentence)
    * @param lt
    * @param apiFormat whether to print the result in a simple XML format
@@ -84,7 +84,7 @@ public static int checkText(final String contents, JLanguageTool lt, boolean api
         msg = msg.replaceAll("</suggestion>", "'");
         System.out.println("Message: " + msg);
         List<String> repl = match.getSuggestedReplacements();
-        if (repl.size() > 0)
+        if (!repl.isEmpty())
           System.out.println("Suggestion: " + StringTools.listToString(repl, "; "));
         System.out.println(StringTools.getContext(match.getFromPos(), match.getToPos(), 
             contents, contextSize));

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Main.java
Patch:
@@ -51,7 +51,7 @@ class Main {
   private boolean apiFormat = false;
   
   /* maximum file size to read in a single read */
-  private static int MAXFILESIZE = 64000;
+  private final static int MAXFILESIZE = 64000;
 
   Main(boolean verbose, Language language, Language motherTongue) throws IOException, 
       ParserConfigurationException, SAXException {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/Main.java
Patch:
@@ -278,7 +278,7 @@ public void endDocument(final int oldDocID) throws IllegalArgumentException {
   }
 
   /**
-   * Called to clear the paragraph state. No used yet in our implementation.
+   * Called to clear the paragraph state. Not used yet in our implementation.
    * 
    * @param docID - the ID of the document already checked
    *  valid myDocID.
@@ -423,7 +423,7 @@ public final void startDocument(final int docID)
 
   /**
    * Called to setup the paragraph state in a doc with some ID.
-   * Note yet implemented (probably will be implemented in the future).
+   * Not yet implemented (probably will be implemented in the future).
    * @param docID - the doc ID
    * @throws IllegalArgumentException in case docID is not a 
    *  valid myDocID.

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/OldChecker.java
Patch:
@@ -59,6 +59,8 @@
 import de.danielnaber.languagetool.gui.Tools;
 import de.danielnaber.languagetool.rules.Rule;
 
+//FIXME: remove as soon OOo 3 has spell-grammar dialog working
+
 /**
  * OpenOffice.org integration.
  * 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/German.java
Patch:
@@ -34,7 +34,7 @@ public class German extends Language {
   private SentenceTokenizer sentenceTokenizer = new GermanSentenceTokenizer();
 
   private static final String[] COUNTRIES = {
-    "FOO", "CH", "AT", "LU", "LI", "BE"
+    "DE", "CH", "AT", "LU", "LI", "BE"
   };
   
   public Locale getLocale() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/en/AvsAnRule.java
Patch:
@@ -88,7 +88,7 @@ public RuleMatch[] match(final AnalyzedSentence text) {
           token = parts[0];
         }
         //html entities!
-        token = token.replaceAll("&quot|&amp|&lt|&gt|[^a-zA-Z0-9]", "");         // e.g. >>an "industry party"<<
+        token = token.replaceAll("&quot|&amp|&lt|&gt|[^a-zA-Z0-9\\.]", "");         // e.g. >>an "industry party"<<
         if (token.length() == 0) {
           continue;
         }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/de/GermanTagger.java
Patch:
@@ -102,7 +102,9 @@ public List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens, final
           } else {
             // last part governs a word's POS:
             String lastPart = compoundParts.get(compoundParts.size()-1);
-            lastPart = StringTools.uppercaseFirstChar(lastPart);
+            if (StringTools.startsWithUppercase(word)) {
+              lastPart = StringTools.uppercaseFirstChar(lastPart);
+            }
             taggerTokens = lexiconLookup(lastPart);
             if (taggerTokens != null) {
               tagWord(taggerTokens, word, l);

File: trunk/JLanguageTool/src/dev/de/danielnaber/languagetool/dev/RuleOverview.java
Patch:
@@ -31,6 +31,7 @@
 import de.danielnaber.languagetool.Language;
 import de.danielnaber.languagetool.language.Contributor;
 import de.danielnaber.languagetool.tools.StringTools;
+import de.danielnaber.languagetool.tools.Tools;
 
 /**
  * Command line tool to list supported languages and their number of rules.
@@ -76,7 +77,7 @@ private void run() throws IOException {
     //setup false friends counting
     final String ffFile = "/rules" + File.separator + "false-friends.xml";
     final java.net.URL ffurl = this.getClass().getResource(ffFile);    
-    String ffRules = StringTools.readFile(this.getClass().getResourceAsStream(ffFile));
+    String ffRules = StringTools.readFile(Tools.getStream(ffFile));
     ffRules = ffRules.replaceAll("(?s)<!--.*?-->", "");
     ffRules = ffRules.replaceAll("(?s)<rules.*?>", "");
 
@@ -91,7 +92,7 @@ private void run() throws IOException {
         System.out.println("<td align=\"right\">0</td>");
       } else {
         // count XML rules:
-        String xmlRules = StringTools.readFile(this.getClass().getResourceAsStream(xmlFile));
+        String xmlRules = StringTools.readFile(Tools.getStream(xmlFile));
         xmlRules = xmlRules.replaceAll("(?s)<!--.*?-->", "");
         xmlRules = xmlRules.replaceAll("(?s)<rules.*?>", "");
         int pos = 0;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/WordCoherencyRule.java
Patch:
@@ -33,6 +33,7 @@
 import de.danielnaber.languagetool.AnalyzedTokenReadings;
 import de.danielnaber.languagetool.rules.Category;
 import de.danielnaber.languagetool.rules.RuleMatch;
+import de.danielnaber.languagetool.tools.Tools;
 
 /**
  * A rule that matches words for which two different spellings are used
@@ -58,7 +59,7 @@ public class WordCoherencyRule extends GermanRule {
   public WordCoherencyRule(ResourceBundle messages) throws IOException {
     if (messages != null)
       super.setCategory(new Category(messages.getString("category_misc")));
-    relevantWords = loadWords(this.getClass().getResourceAsStream(FILE_NAME)); 
+    relevantWords = loadWords(Tools.getStream(FILE_NAME)); 
     germanLemmatizer = new GermanLemmatizer();
   }
   

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/FalseFriendRuleLoader.java
Patch:
@@ -39,6 +39,7 @@
 import de.danielnaber.languagetool.Language;
 import de.danielnaber.languagetool.rules.Category;
 import de.danielnaber.languagetool.rules.IncorrectExample;
+import de.danielnaber.languagetool.tools.Tools;
 
 /**
  * Loads {@link PatternRule}s from a false friends XML file.
@@ -91,14 +92,14 @@ private String formatSuggestions(final List<String> l) {
   /** Testing only. */
   public void main(final String[] args) throws ParserConfigurationException, SAXException, IOException {
     final FalseFriendRuleLoader prg = new FalseFriendRuleLoader();
-    List<PatternRule> l = prg.getRules(this.getClass().getResourceAsStream("/rules/false-friends.xml"), Language.ENGLISH, Language.GERMAN);
+    List<PatternRule> l = prg.getRules(Tools.getStream("/rules/false-friends.xml"), Language.ENGLISH, Language.GERMAN);
     System.out.println("Hints for German native speakers:");
     for (final PatternRule rule : l) {
       System.out.println(rule);
     }
     System.out.println("=======================================");
     System.out.println("Hints for English native speakers:");
-    l = prg.getRules(this.getClass().getResourceAsStream("/rules/false-friends.xml"), Language.GERMAN, Language.ENGLISH);
+    l = prg.getRules(Tools.getStream("/rules/false-friends.xml"), Language.GERMAN, Language.ENGLISH);
     for (final PatternRule rule : l) {
       System.out.println(rule);
     }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -35,6 +35,7 @@
 import de.danielnaber.languagetool.rules.Category;
 import de.danielnaber.languagetool.rules.IncorrectExample;
 import de.danielnaber.languagetool.tools.StringTools;
+import de.danielnaber.languagetool.tools.Tools;
 
 /**
  * Loads {@link PatternRule}s from an XML file.
@@ -69,7 +70,7 @@ public final List<PatternRule> getRules(final InputStream is, final String filen
   public final void main(final String[] args) throws IOException {
     final PatternRuleLoader prg = new PatternRuleLoader();
     final String name = "/rules/de/grammar.xml";
-    final List<PatternRule> l = prg.getRules(this.getClass().getResourceAsStream(name), name);
+    final List<PatternRule> l = prg.getRules(Tools.getStream(name), name);
     System.out.println(l);
   }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/uk/SimpleReplaceRule.java
Patch:
@@ -33,6 +33,7 @@
 import de.danielnaber.languagetool.rules.Category;
 import de.danielnaber.languagetool.rules.Rule;
 import de.danielnaber.languagetool.rules.RuleMatch;
+import de.danielnaber.languagetool.tools.Tools;
 
 /**
  * A rule that matches words or phrases which should not be used 
@@ -51,7 +52,7 @@ public class SimpleReplaceRule extends Rule {
 	public SimpleReplaceRule(ResourceBundle messages) throws IOException {
 		if (messages != null)
 			super.setCategory(new Category(messages.getString("category_misc")));
-		wrongWords = loadWords(this.getClass().getResourceAsStream(FILE_NAME)); 
+		wrongWords = loadWords(Tools.getStream(FILE_NAME)); 
 	}
 
 	public String getId() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/synthesis/en/EnglishSynthesizer.java
Patch:
@@ -31,6 +31,7 @@
 import de.danielnaber.languagetool.AnalyzedToken;
 import de.danielnaber.languagetool.rules.en.AvsAnRule;
 import de.danielnaber.languagetool.synthesis.Synthesizer;
+import de.danielnaber.languagetool.tools.Tools;
 
 /** English word form synthesizer. <br/>
  * Based on part-of-speech lists in Public Domain.
@@ -99,7 +100,7 @@ public String[] synthesize(final AnalyzedToken token, final String posTag, final
     
     if (posTagRegExp) {
     if (possibleTags == null) {
-      possibleTags = loadWords(this.getClass().getResourceAsStream(TAGS_FILE_NAME));
+      possibleTags = loadWords(Tools.getStream(TAGS_FILE_NAME));
     }
     if (synthesizer == null) {
       setFileName();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/synthesis/nl/DutchSynthesizer.java
Patch:
@@ -29,8 +29,8 @@
 
 import morfologik.stemmers.Lametyzator;
 import de.danielnaber.languagetool.AnalyzedToken;
-import de.danielnaber.languagetool.rules.en.AvsAnRule;
 import de.danielnaber.languagetool.synthesis.Synthesizer;
+import de.danielnaber.languagetool.tools.Tools;
 
 /** Dutch word form synthesizer. <br/>
  * 
@@ -76,7 +76,7 @@ public String[] synthesize(final AnalyzedToken token, final String posTag, final
     
     if (posTagRegExp) {
     if (possibleTags == null) {
-      possibleTags = loadWords(this.getClass().getResourceAsStream(TAGS_FILE_NAME));
+      possibleTags = loadWords(Tools.getStream(TAGS_FILE_NAME));
     }
     if (synthesizer == null) {
       setFileName();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/synthesis/pl/PolishSynthesizer.java
Patch:
@@ -30,6 +30,7 @@
 import morfologik.stemmers.Lametyzator;
 import de.danielnaber.languagetool.AnalyzedToken;
 import de.danielnaber.languagetool.synthesis.Synthesizer;
+import de.danielnaber.languagetool.tools.Tools;
 
 /** Polish word form synthesizer.
  * Based on project Morfologik.
@@ -101,7 +102,7 @@ public String[] synthesize(final AnalyzedToken token, String posTag, final boole
     }
     if (posTagRegExp) {
     if (possibleTags == null) {
-      possibleTags = loadWords(this.getClass().getResourceAsStream(TAGS_FILE_NAME));
+      possibleTags = loadWords(Tools.getStream(TAGS_FILE_NAME));
     }
     if (synthesizer == null) {
       setFileName();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/de/GermanTagger.java
Patch:
@@ -28,6 +28,7 @@
 import de.danielnaber.languagetool.tagging.Tagger;
 import de.danielnaber.languagetool.tokenizers.de.GermanCompoundTokenizer;
 import de.danielnaber.languagetool.tools.StringTools;
+import de.danielnaber.languagetool.tools.Tools;
 
 /**
  * German tagger, requires data file in <code>resource/de/german.dict</code>.
@@ -77,7 +78,7 @@ public List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens, final
       morfologik = new Lametyzator();
     }
     if (manualTagger == null) {
-      manualTagger = new ManualTagger(this.getClass().getResourceAsStream(USER_DICT_FILENAME));
+      manualTagger = new ManualTagger(Tools.getStream(USER_DICT_FILENAME));
     }
     if (compoundTokenizer == null) {
       compoundTokenizer = new GermanCompoundTokenizer();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/disambiguation/rules/fr/FrenchRuleDisambiguator.java
Patch:
@@ -13,6 +13,7 @@
 import de.danielnaber.languagetool.tagging.disambiguation.rules.DisambiguationPatternRule;
 import de.danielnaber.languagetool.tagging.disambiguation.rules.DisambiguationRuleLoader;
 import de.danielnaber.languagetool.tagging.disambiguation.rules.RuleDisambiguator;
+import de.danielnaber.languagetool.tools.Tools;
 
 public class FrenchRuleDisambiguator extends RuleDisambiguator {
 
@@ -31,7 +32,7 @@ public class FrenchRuleDisambiguator extends RuleDisambiguator {
    */
   private List<DisambiguationPatternRule> loadPatternRules(final String filename) throws ParserConfigurationException, SAXException, IOException {
     DisambiguationRuleLoader ruleLoader = new DisambiguationRuleLoader();    
-    return ruleLoader.getRules(this.getClass().getResourceAsStream(filename));
+    return ruleLoader.getRules(Tools.getStream(filename));
   }
   
   public final AnalyzedSentence disambiguate(final AnalyzedSentence input) throws IOException {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/uk/UkrainianMyspellTagger.java
Patch:
@@ -31,6 +31,7 @@
 import de.danielnaber.languagetool.AnalyzedToken;
 import de.danielnaber.languagetool.AnalyzedTokenReadings;
 import de.danielnaber.languagetool.tagging.Tagger;
+import de.danielnaber.languagetool.tools.Tools;
 
 /**
  * Ukrainian Part-of-speech tagger.
@@ -59,7 +60,7 @@ public final List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens)
 //    }
     if( wordsToPos == null ) {
     	wordsToPos = new HashMap<String, String[]>();
-    	InputStream resourceFile = this.getClass().getResourceAsStream(RESOURCE_FILENAME);
+    	InputStream resourceFile = Tools.getStream(RESOURCE_FILENAME);
        	//System.err.println("reading dict: " + resourceFile);
         
     	BufferedReader input = new BufferedReader( new InputStreamReader( resourceFile, Charset.forName("UTF-8")) );

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/disambiguation/rules/en/EnglishRuleDisambiguator.java
Patch:
@@ -13,6 +13,7 @@
 import de.danielnaber.languagetool.tagging.disambiguation.rules.DisambiguationPatternRule;
 import de.danielnaber.languagetool.tagging.disambiguation.rules.DisambiguationRuleLoader;
 import de.danielnaber.languagetool.tagging.disambiguation.rules.RuleDisambiguator;
+import de.danielnaber.languagetool.tools.Tools;
 
 public class EnglishRuleDisambiguator extends RuleDisambiguator {
 
@@ -31,7 +32,7 @@ public class EnglishRuleDisambiguator extends RuleDisambiguator {
    */
   private List<DisambiguationPatternRule> loadPatternRules(final String filename) throws ParserConfigurationException, SAXException, IOException {
     DisambiguationRuleLoader ruleLoader = new DisambiguationRuleLoader();    
-    return ruleLoader.getRules(this.getClass().getResourceAsStream(filename));
+    return ruleLoader.getRules(Tools.getStream(filename));
   }
   
   public final AnalyzedSentence disambiguate(final AnalyzedSentence input) throws IOException {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tools/StringTools.java
Patch:
@@ -215,7 +215,7 @@ public static String ruleMatchesToXML(final List<RuleMatch> ruleMatches, final S
           );
       final String msg = match.getMessage().replaceAll("</?suggestion>", "'");
       xml.append(" msg=\"" + escapeXMLForAPIOutput(msg)+ "\"");
-      final String START_MARKER = "__languagetoo_start_marker";
+      final String START_MARKER = "__languagetool_start_marker";
       String context = Tools.getContext(match.getFromPos(), match.getToPos(),
           text, contextSize, START_MARKER, "", true);
       xml.append(" replacements=\"" + 

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tagging/disambiguation/rules/en/EnglishRuleDisambiguatorTest.java
Patch:
@@ -41,7 +41,7 @@ public void testChunker() throws IOException {
         "/[null]SENT_START He/[he]PRP  /[null]null is/[be]VBZ  /[null]null well/[well]RB  /[null]null known/[known]JJ ./[null]null", 
         tokenizer, sentenceTokenizer, tagger, disambiguator);
     TestTools.myAssert("He is well known.",
-        "/[null]SENT_START He/[he]PRP  /[null]null is/[be]VBZ  /[null]null well/[well]NN|well/[well]RB|well/[well]VB|well/[well]VBP  /[null]null known/[known]NN|known/[know]VBN ./[null]null", 
+        "/[null]SENT_START He/[he]PRP  /[null]null is/[be]VBZ  /[null]null well/[well]NN|well/[well]RB|well/[well]UH|well/[well]VB|well/[well]VBP  /[null]null known/[known]NN|known/[know]VBN ./[null]null", 
         tokenizer, sentenceTokenizer, tagger, disamb2);
     
   }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/SentenceTokenizer.java
Patch:
@@ -36,9 +36,8 @@
 public class SentenceTokenizer implements Tokenizer {
 
   // end of sentence marker:
-  //private static final String EOS = "\0";
-  // 
-  private final static String EOS = "#"; // for testing only
+  private static final String EOS = "\0";
+  //private final static String EOS = "#"; // for testing only
   private static final String P = "[\\.!?…]"; // PUNCTUATION
   private static final String AP = "(?:'|«|\"||\\)|\\]|\\})?"; // AFTER PUNCTUATION
   private static final String PAP = P + AP;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRule.java
Patch:
@@ -632,7 +632,7 @@ private String formatMatches(final AnalyzedTokenReadings[] toks,
 
           if (!newWay) {
             //in case <match> elements weren't used (yet)
-            errorMessage = errorMessage.replaceAll("\\\\" + (j + 1), 
+            errorMessage = errorMessage.replace("\\" + (j + 1), 
                 toks[firstMatchTok + repTokenPos - 1].getToken());          
             errMarker = errorMessage.indexOf('\\');
             numberFollows = false;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Element.java
Patch:
@@ -592,7 +592,7 @@ public final void compile() {
     }
     final boolean setsPos = tokenReference.setsPos(); 
     if (!setsPos) {
-    stringToken = referenceString.replaceAll("\\\\"  
+    stringToken = referenceString.replace("\\"  
         + tokenReference.getTokenRef(), 
         tokenReference.toTokenString());
     }
@@ -611,7 +611,7 @@ public final void compile() {
         }
       setPosElement(posReference, tokenReference.posRegExp(), negation);
       }
-      stringToken = referenceString.replaceAll("\\\\"  
+      stringToken = referenceString.replace("\\"  
           + tokenReference.getTokenRef(), "");
       inflected = true;      
     }

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -102,7 +102,7 @@ private void testGrammarRulesFromXML(final List<PatternRule> rules,
         RuleMatch[] matches = getMatches(rule, badSentence, languageTool);
         if (!rule.isWithComplexPhrase()) {
           assertTrue(lang + ": Did expect one error in: \"" + badSentence + "\" (Rule: " + rule
-              + "), got " + matches.length, matches.length == 1);
+              + "), got " + matches.length + ". Additional info:" + rule.getMessage(), matches.length == 1);
           assertEquals(lang + ": Incorrect match position markup (start) for rule " + rule,
               expectedMatchStart, matches[0].getFromPos());
           assertEquals(lang + ": Incorrect match position markup (end) for rule " + rule,
@@ -175,6 +175,7 @@ private void testGrammarRulesFromXML(final List<PatternRule> rules,
         final PatternRule badRule = complexRules.get(iter.next());
         if (badRule != null) {
           badRule.notComplexPhrase();
+          badRule.setMessage("The rule contains a phrase that never matched any incorrect example.");
           badRules.add(badRule);
         }
       }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/en/AvsAnRule.java
Patch:
@@ -32,6 +32,7 @@
 import de.danielnaber.languagetool.rules.Category;
 import de.danielnaber.languagetool.rules.RuleMatch;
 import de.danielnaber.languagetool.tools.StringTools;
+import de.danielnaber.languagetool.tools.Tools;
 
 /**
  * Check if the determiner (if any) preceding a word is:
@@ -55,8 +56,8 @@ public AvsAnRule(final ResourceBundle messages) throws IOException {
     if (messages != null) {
       super.setCategory(new Category(messages.getString("category_misc")));
     }
-    requiresA = loadWords(this.getClass().getResourceAsStream(FILENAME_A));
-    requiresAn = loadWords(this.getClass().getResourceAsStream(FILENAME_AN));
+    requiresA = loadWords(Tools.getStream(FILENAME_A));
+    requiresAn = loadWords(Tools.getStream(FILENAME_AN));
   }
   
   @Override

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/CaseRule.java
Patch:
@@ -21,7 +21,6 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.ResourceBundle;
 import java.util.Set;
@@ -304,8 +303,8 @@ public RuleMatch[] match(final AnalyzedSentence text) {
 
   private boolean isExceptionPhrase(int i, AnalyzedTokenReadings[] tokens) {
     // TODO: speed up?
-    for (Iterator iter = myExceptionPhrases.iterator(); iter.hasNext();) {
-      String exc = (String) iter.next();
+    for (String string : myExceptionPhrases) {
+      String exc = (String) string;
       String[] parts = exc.split(" ");
       for (int j = 0; j < parts.length; j++) {
         if (parts[j].equals(tokens[i].getToken())) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/CompoundRule.java
Patch:
@@ -39,6 +39,7 @@
 import de.danielnaber.languagetool.rules.Category;
 import de.danielnaber.languagetool.rules.RuleMatch;
 import de.danielnaber.languagetool.tools.StringTools;
+import de.danielnaber.languagetool.tools.Tools;
 
 /**
  * Checks that compounds (if in the list) are not written as separate words.
@@ -58,7 +59,7 @@ public class CompoundRule extends GermanRule {
   public CompoundRule(final ResourceBundle messages) throws IOException {
     if (messages != null)
       super.setCategory(new Category(messages.getString("category_misc")));
-    loadCompoundFile(this.getClass().getResourceAsStream(FILE_NAME), "UTF-8");
+    loadCompoundFile(Tools.getStream(FILE_NAME), "UTF-8");
   }
   
   public String getId() {
@@ -202,6 +203,7 @@ private void loadCompoundFile(final InputStream file, final String encoding) thr
     InputStreamReader isr = null;
     BufferedReader br = null;   
     try {
+      System.err.println(">>"+file);
       isr = new InputStreamReader(file, encoding);
       br = new BufferedReader(isr);
       String line;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/GermanLemmatizer.java
Patch:
@@ -25,6 +25,8 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import de.danielnaber.languagetool.tools.Tools;
+
 /**
  * Trivial German lemmatizer that can simply find the baseforms of
  * those fullforms listed in <code>rules/de/fullform2baseform.txt</code>.
@@ -39,7 +41,7 @@ class GermanLemmatizer {
   private Map<String, String> fullform2baseform;
   
   GermanLemmatizer() throws IOException {
-    fullform2baseform = loadWords(this.getClass().getResourceAsStream(FILE_NAME));
+    fullform2baseform = loadWords(Tools.getStream(FILE_NAME));
   }
   
   String getBaseform(final String fullform) {

File: trunk/JLanguageTool/src/dev/de/danielnaber/languagetool/dev/Overview.java
Patch:
@@ -142,7 +142,7 @@ private void run() throws IOException {
           count++;
         }
         System.out.print("<td align=\"left\">" + (count) +
-            "</td></tr>");
+            "</td>");
       }
       
       System.out.println("</tr>");    

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/FalseFriendRuleLoader.java
Patch:
@@ -76,7 +76,7 @@ public final List<PatternRule> getRules(final InputStream file, final Language t
   
   private String formatSuggestions(final List<String> l) {
     final StringBuilder sb = new StringBuilder();
-    for (final Iterator iter = l.iterator(); iter.hasNext();) {
+    for (final Iterator<String> iter = l.iterator(); iter.hasNext();) {
       final String s = (String) iter.next();
       sb.append("<suggestion>");
       sb.append(s);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -21,7 +21,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tokenizers/pl/PolishSentenceTokenizerTest.java
Patch:
@@ -93,6 +93,9 @@ public final void testTokenize() {
     testSplit(new String[] { "Prezydent jest popierany przez 20 proc. społeczeństwa." });
     testSplit(new String[] { "Moje wystąpienie ma na celu zmobilizowanie zarządu partii do działań, które umożliwią uzyskanie 40 proc.", "Nie widzę dziś na scenie politycznej formacji, która lepiej by łączyła różne poglądy" });
     testSplit(new String[] {"To jest zmienna A.", "Zaś to jest zmienna B."});
+    //SKROTY_BEZ_KROPKI in ENDABREVLIST
+    testSplit(new String[] {"Mam już 20 mln.", "To powinno mi wystarczyć"});
+    testSplit(new String[] {"Mam już 20 mln. buraków."});
     //ellipsis
     testSplit(new String[] { "Rytmem tej wiecznie przemijającej światowej egzystencji […] rytmem mesjańskiej natury jest szczęście." });
   }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/FalseFriendRuleLoader.java
Patch:
@@ -279,7 +279,8 @@ public void startElement(final String namespaceURI, final String lName, final St
   public void endElement(final String namespaceURI, final String sName, final String qName) {
 	  if (qName.equals("rule")) {
 		  if (language == textLanguage && translationLanguage != null && translationLanguage == motherTongue
-          && language != motherTongue) {
+          && language != motherTongue
+          && translations.size() > 0) {
 			  formatter.applyPattern(messages.getString("false_friend_hint"));
 			  final Object[] messageArguments = {
 					  elements.toString().replace('|', '/'),

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -172,7 +172,7 @@ public void startElement(final String namespaceURI, final String lName, final St
       }
     } else if (qName.equals("rule")) {
       id = attrs.getValue("id");
-      if (!inRuleGroup) {
+      if (!(inRuleGroup && defaultOff)) {
         defaultOff = "off".equals(attrs.getValue("default"));
       }
       if (inRuleGroup && id == null) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/Main.java
Patch:
@@ -303,6 +303,7 @@ void showOptions() {
     ConfigurationDialog configDialog = getCurrentConfigDialog();
     configDialog.show(rules);   // this blocks until OK/Cancel is clicked in the dialog
     config.setDisabledRuleIds(configDialog.getDisabledRuleIds());
+    config.setEnabledRuleIds(configDialog.getEnabledRuleIds());
     config.setDisabledCategoryNames(configDialog.getDisabledCategoryNames());
     config.setMotherTongue(configDialog.getMotherTongue());
     config.setRunServer(configDialog.getRunServer());
@@ -420,6 +421,7 @@ private ConfigurationDialog getCurrentConfigDialog() {
       configDialog = new ConfigurationDialog(frame, false);
       configDialog.setMotherTongue(config.getMotherTongue());
       configDialog.setDisabledRules(config.getDisabledRuleIds());
+      configDialog.setEnabledRules(config.getEnabledRuleIds());
       configDialog.setDisabledCategories(config.getDisabledCategoryNames());
       configDialog.setRunServer(config.getRunServer());
       configDialog.setServerPort(config.getServerPort());

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/ConfigThread.java
Patch:
@@ -38,6 +38,7 @@ class ConfigThread extends Thread {
     this.config = config;      
     cfgDialog = new ConfigurationDialog(null, true);
     cfgDialog.setDisabledRules(config.getDisabledRuleIds());
+    cfgDialog.setEnabledRules(config.getEnabledRuleIds());
     cfgDialog.setDisabledCategories(config.getDisabledCategoryNames());
     cfgDialog.setMotherTongue(config.getMotherTongue());        
   }
@@ -57,6 +58,7 @@ public void run() {
       langTool.activateDefaultFalseFriendRules();
       cfgDialog.show(langTool.getAllRules());
       config.setDisabledRuleIds(cfgDialog.getDisabledRuleIds());
+      config.setEnabledRuleIds(cfgDialog.getEnabledRuleIds());
       config.setDisabledCategoryNames(cfgDialog.getDisabledCategoryNames());
       config.setMotherTongue(cfgDialog.getMotherTongue());
       config.saveConfiguration();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/pl/PolishWordRepeatRule.java
Patch:
@@ -38,7 +38,7 @@
  *
  */
 public class PolishWordRepeatRule extends PolishRule {
-
+  
   /**
    * Excluded dictionary words.
    */
@@ -67,6 +67,7 @@ public PolishWordRepeatRule(final ResourceBundle messages) {
     if (messages != null) {
       super.setCategory(new Category(messages.getString("category_misc")));
     }
+    setDefaultOff();
   }
 
   /* (non-Javadoc)

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/pl/PolishWordRepeatRuleTest.java
Patch:
@@ -13,7 +13,7 @@ public class PolishWordRepeatRuleTest extends TestCase {
 	 * Test method for 'de.danielnaber.languagetool.rules.pl.PolishWordRepeatRule.match(AnalyzedSentence)'
 	 */
 	public void testRule() throws IOException {
-	    PolishWordRepeatRule rule = new PolishWordRepeatRule(null);
+	    final PolishWordRepeatRule rule = new PolishWordRepeatRule(null);
 	    RuleMatch[] matches;
 	    JLanguageTool langTool = new JLanguageTool(Language.POLISH);
 	    //correct

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/OOoDialog.java
Patch:
@@ -295,7 +295,7 @@ private void showError(int i) throws NoSuchElementException, WrappedTargetExcept
     msg = msg.replaceAll("<suggestion>", "<b>");
     msg = msg.replaceAll("</suggestion>", "</b>");
     StringBuilder sb = new StringBuilder();
-    int totalMatches = getTotalRuleMatches();
+    final int totalMatches = getTotalRuleMatches();
     sb.append(messages.getString("guiMatchCount") + " " +  totalMatches);
     sb.append("<br>\n<br>\n<b>" +(i+1)+ ".</b> ");
     sb.append(msg);
@@ -470,8 +470,10 @@ public void actionPerformed(ActionEvent event) {
       ConfigurationDialog cfgDialog = new ConfigurationDialog(null, true);
       cfgDialog.setMotherTongue(configuration.getMotherTongue());
       cfgDialog.setDisabledRules(configuration.getDisabledRuleIds());
+      cfgDialog.setDisabledCategories(configuration.getDisabledCategoryNames());
       cfgDialog.show(rules);
       configuration.setDisabledRuleIds(cfgDialog.getDisabledRuleIds());
+      configuration.setDisabledCategoryNames(cfgDialog.getDisabledCategoryNames());
       configuration.setMotherTongue(cfgDialog.getMotherTongue());
     } else if (event.getSource() == closeButton) {
       close();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/Main.java
Patch:
@@ -134,6 +134,7 @@ private void createGUI() {
     resultArea.setEditable(false);
     JLabel label = new JLabel(messages.getString("enterText"));
     JButton button = new JButton(messages.getString("checkText"));
+//FIXME: mnemonics should be localized and set by the "ampersand convention"
     button.setMnemonic('c'); 
     button.addActionListener(this);
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/language/LanguageBuilder.java
Patch:
@@ -40,13 +40,12 @@ private LanguageBuilder() {
    * a Language object for that language.
    */
   public static Language makeLanguage(final File file) {
-    String errMsg = "File must be named rules-<xx>-<language>.xml";
     if (file!=null) {
     if (!file.getName().endsWith(".xml"))
-      throw new IllegalArgumentException(errMsg);
+      throw new RuleFilenameException(file);
     final String[] parts = file.getName().split("-");
     if (parts.length != 3 || !parts[0].equals("rules") || parts[1].length() != 2)
-      throw new IllegalArgumentException(errMsg);
+      throw new RuleFilenameException(file);
     
     Language newLanguage = new Language() {
       public Locale getLocale() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/pl/PolishSentenceTokenizer.java
Patch:
@@ -66,7 +66,7 @@ public class PolishSentenceTokenizer extends SentenceTokenizer {
         "elektr|em|etc|ew|fab|farm|fot|fr|gat|gastr|geogr|geol|gimn|głęb|gm|godz|górn|gosp|gr|gram|" +
         "hist|hiszp|hr|hot|id|in|im|iron|jn|kard|kat|katol|k.k|kk|klas|kol|k.p.a|kpc|k.p.c|kpt|kr|k.r|" +
         "krak|k.r.o|kryt|kult|laic|łac|niem|woj|np|pol|m.in|itd|itp|pt|cdn|jw|" +
-        "nb|rys|tj|tzw|tzn|zob|ang|ul|pl|al|k|n|ok|tys|ww|ur|zm|żyd|żarg|żart|żyw|wył|" +
+        "nb|rys|tj|tzw|tzn|zob|ang|ul|pl|al|k|n|ok|tys|ww|ur|zm|żyd|żarg|żyw|wył|" +
         "up|tow|o|zn|zew|zewn|zdr|zazw|zast|zaw|zał|zal|zam|zak|zakł|zagr|zach|"+
         "adw|lek|mec|doc|dyr|inż|mgr|dr|red|prof|hab|ks|gen|por|przyp"+
         // needed for SKROTY_BEZ_KROPKI rule

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -502,6 +502,7 @@ private void resetToken() {
     inToken = false;
     stringRegExp = false;
     
+    resetException();
     exceptionSet = false; 
     tokenReference = null;
   }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -179,6 +179,9 @@ public void startElement(final String namespaceURI, final String lName, final St
       }
       correctExamples = new ArrayList<String>();
       incorrectExamples = new ArrayList<String>();
+      if (suggestionMatches != null) {
+        suggestionMatches.clear();
+      }
     } else if (qName.equals("pattern")) {
       inPattern = true;
       if (attrs.getValue("mark_from") != null) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/LanguageManagerDialog.java
Patch:
@@ -159,7 +159,9 @@ List<Language> getLanguages() {
     List<Language> langs = new ArrayList<Language>();
     for (File ruleFile : ruleFiles) {
       Language newLanguage = LanguageBuilder.makeLanguage(ruleFile);
-      langs.add(newLanguage);
+      if (newLanguage!=null) {
+        langs.add(newLanguage);
+      }
     }
     return langs;
   }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/server/HTTPServer.java
Patch:
@@ -94,8 +94,8 @@ public void run() {
     if (daemon.isRunning()) 
       System.out.println("Server started");
     else
-      throw new RuntimeException("Server could not be started on port " + port
-          + ", maybe something else is running on that port already?");
+      throw new PortBindingException("LanguageTool server could not be started " +
+          "on port " + port + ", maybe something else is running on that port already?");
   }
 
   public String demultiplex(Request connRequest, Response connResponse) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/nl/DutchTagger.java
Patch:
@@ -46,7 +46,7 @@ public List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens) throws
     //caching Lametyzator instance - lazy init
     if (morfologik == null) {
       morfologik = new Lametyzator(this.getClass().getResourceAsStream(RESOURCE_FILENAME),
-          "iso8859-9", '+');
+          "iso8859-1", '+');
     }
 
     for (String word : sentenceTokens) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/OOoDialog.java
Patch:
@@ -242,6 +242,9 @@ void show() {
     dialog.setSize(500, 380);
     centerDialog(dialog);
     dialog.setVisible(true);
+    // Try to fix the problem that the window appears in the
+    // background for some people:
+    dialog.toFront();
     // FIXME: close via "X" in the window must behave like close via "close" button
   }
   

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tools/StringTools.java
Patch:
@@ -216,13 +216,14 @@ public static String ruleMatchesToXML(final List<RuleMatch> ruleMatches, final S
       xml.append(" msg=\"" + escapeXMLForAPIOutput(msg)+ "\"");
       final String START_MARKER = "__languagetoo_start_marker";
       String context = Tools.getContext(match.getFromPos(), match.getToPos(),
-          escapeXML(text), contextSize, START_MARKER, "");
+          text, contextSize, START_MARKER, "", true);
       xml.append(" replacements=\"" + 
           escapeXMLForAPIOutput(listToString(match.getSuggestedReplacements(), "#")) + "\"");
       // get position of error in context and remove artificial marker again:
       final int contextOffset = context.indexOf(START_MARKER);
       context = context.replaceFirst(START_MARKER, "");
-      xml.append(" context=\"" +escapeXMLForAPIOutput(context)+ "\"");
+      context = context.replaceAll("[\n\r]", " ");
+      xml.append(" context=\"" +context+ "\"");
       xml.append(" contextoffset=\"" +contextOffset+ "\"");
       xml.append(" errorlength=\"" +(match.getToPos()-match.getFromPos())+ "\"");
       xml.append("/>\n");

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tagging/it/ItalianTaggerTest.java
Patch:
@@ -35,8 +35,8 @@ public void setUp() {
   }
 
   public void testTagger() throws IOException {
-    TestTools.myAssert("Non c'è linguaggio senza inganno.", "Non/[non]ADV c/[null]null è/[essere]VER:ind+pres+3+s|è/[essere]AUX:ind+pres+3+s linguaggio/[linguaggio]NOUN-M:s senza/[senza]CON|senza/[senza]PRE inganno/[inganno]NOUN-M:s|inganno/[ingannare]VER:ind+pres+1+s", tokenizer, tagger);
-    TestTools.myAssert("Amo quelli che desiderano l'impossibile.", "Amo/[amare]VER:ind+pres+1+s quelli/[quello]DET-DEMO:m+p|quelli/[quelli]PRO-DEMO-M-P che/[che]CON|che/[che]DET-WH:m+p|che/[che]DET-WH:m+s|che/[che]DET-WH:f+p|che/[che]DET-WH:f+s|che/[che]WH-CHE desiderano/[desiderare]VER:ind+pres+3+p l/[null]null impossibile/[impossibile]ADJ:pos+f+s|impossibile/[impossibile]ADJ:pos+m+s", tokenizer, tagger);
+    TestTools.myAssert("Non c'è linguaggio senza inganno.", "Non/[non]ADV c/[null]null è/[essere]AUX:ind+pres+3+s|è/[essere]VER:ind+pres+3+s linguaggio/[linguaggio]NOUN-M:s senza/[senza]CON|senza/[senza]PRE inganno/[inganno]NOUN-M:s|inganno/[ingannare]VER:ind+pres+1+s", tokenizer, tagger);
+    TestTools.myAssert("Amo quelli che desiderano l'impossibile.", "Amo/[amare]VER:ind+pres+1+s quelli/[quelli]PRO-DEMO-M-P|quelli/[quello]DET-DEMO:m+p che/[che]CON|che/[che]DET-WH:f+p|che/[che]DET-WH:f+s|che/[che]DET-WH:m+p|che/[che]DET-WH:m+s|che/[che]WH-CHE desiderano/[desiderare]VER:ind+pres+3+p l/[null]null impossibile/[impossibile]ADJ:pos+f+s|impossibile/[impossibile]ADJ:pos+m+s", tokenizer, tagger);
     TestTools.myAssert("blablabla","blablabla/[null]null", tokenizer, tagger);        
   }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/ConfigurationDialog.java
Patch:
@@ -98,7 +98,6 @@ public ConfigurationDialog(Frame owner, boolean insideOOo) {
   
   public void show(List<Rule> rules) {
     dialog = new JDialog(owner, true);
-    // TODO: i18n:
     dialog.setTitle(messages.getString("guiConfigWindowTitle"));
     checkBoxes.clear();
     checkBoxesRuleIds.clear();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Language.java
Patch:
@@ -76,7 +76,7 @@ public abstract class Language {
   private final static Disambiguator DEMO_DISAMBIGUATOR = new DemoDisambiguator();
   private final static Tagger DEMO_TAGGER = new DemoTagger();
   private final static SentenceTokenizer SENTENCE_TOKENIZER = new SentenceTokenizer();
-  private final static WordTokenizer WORD_TOKENIZERr = new WordTokenizer();
+  private final static WordTokenizer WORD_TOKENIZER = new WordTokenizer();
 
   /**
    * Get this language's two character code, e.g. <code>en</code> for English.
@@ -124,7 +124,7 @@ public SentenceTokenizer getSentenceTokenizer() {
    * Get this language's word tokenizer implementation.
    */
   public Tokenizer getWordTokenizer() {
-    return WORD_TOKENIZERr;
+    return WORD_TOKENIZER;
   }
 
   /**

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/JLanguageTool.java
Patch:
@@ -528,7 +528,7 @@ public List<Rule> getAllRules() {
     rules.addAll(builtinRules);
     rules.addAll(userRules);
     // Some rules have an internal state so they can do checks over sentence
-    // boundaries. These need to be reset so the checks don't suddendly
+    // boundaries. These need to be reset so the checks don't suddenly
     // work on different texts with the same data:
     for (Rule rule : rules) {
       rule.reset();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Match.java
Patch:
@@ -114,7 +114,7 @@ public void setLemmaString(final String lemmaString) {
     }
   }
 
-  public void setSynthesizer(final Synthesizer synth) throws IOException {
+  public void setSynthesizer(final Synthesizer synth) {
     synthesizer = synth;
   }    
 
@@ -123,7 +123,6 @@ public void setSynthesizer(final Synthesizer synth) throws IOException {
    * element.
    * @return String[] array of strings
    * @throws IOException 
-   * .
    */
   public final String[] toFinalString() throws IOException {
     String[] formattedString = new String[1];

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/Main.java
Patch:
@@ -83,7 +83,7 @@ public final class Main implements ActionListener {
   private static final String HTML_FONT_START = "<font face='Arial,Helvetica'>";
   private static final String HTML_FONT_END = "</font>";
   
-  private final Icon SYSTEM_TRAY_ICON = new ImageIcon( this.getClass().getResource("/resource/TrayIcon.png"));
+  private final Icon SYSTEM_TRAY_ICON = new ImageIcon(this.getClass().getResource("/resource/TrayIcon.png"));
   private static final String SYSTEM_TRAY_TOOLTIP = "LanguageTool";
   private static final String CONFIG_FILE = ".languagetool.cfg";
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -51,8 +51,9 @@ public final List<PatternRule> getRules(final InputStream is, final String filen
     try {
       final PatternRuleHandler handler = new PatternRuleHandler();
       final SAXParserFactory factory = SAXParserFactory.newInstance();
-      final SAXParser saxParser = factory.newSAXParser();
-      saxParser.getXMLReader().setFeature("http://xml.org/sax/features/validation", false);      
+      final SAXParser saxParser = factory.newSAXParser();      
+      saxParser.getXMLReader().setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd",
+          false);      
       saxParser.parse(is, handler);
       rules = handler.getRules();
       return rules;

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/XMLValidator.java
Patch:
@@ -87,6 +87,8 @@ private void validateInternal(String xml, String dtdFile, String doctype) throws
     SAXParserFactory factory = SAXParserFactory.newInstance();
     factory.setValidating(true);
     SAXParser saxParser = factory.newSAXParser();
+    //used for removing existing DOCTYPE from grammar.xml files
+    xml = xml.replaceAll("<!DOCTYPE.+>", "");
     final String decl = "<?xml version=\"1.0\"";
     final String endDecl = "?>";
     final String dtd = "<!DOCTYPE "+doctype+" PUBLIC \"-//W3C//DTD Rules 0.1//EN\" \"" +this.getClass().getResource(dtdFile)+ "\">";

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Match.java
Patch:
@@ -301,7 +301,7 @@ public final AnalyzedTokenReadings filterReadings(final AnalyzedTokenReadings to
                 }
                 l.add(new AnalyzedToken(token, targetPosTag,
                     formattedToken.getAnalyzedToken(i).getLemma(),
-                    formattedToken.getAnalyzedToken(i).getStartPos()));                  
+                    formattedToken.getStartPos()));                  
               }
             }
           }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/synthesis/Synthesizer.java
Patch:
@@ -32,14 +32,14 @@
 public interface Synthesizer {
 
   /** Generates a form of the word with a given POS tag for a given lemma. 
-   * @param lemma Word's base form
+   * @param token the token to be used for synthesis
    * @param posTag POS tag of the form to be generated.
    **/
   public String[] synthesize(final AnalyzedToken token, final String posTag) throws IOException;
 
   /** Generates a form of the word with a given POS tag for a given lemma.
    * POS tag can be specified using regular expressions. 
-   * @param lemma Word's base form
+   * @param token the token to be used for synthesis
    * @param posTag POS tag of the form to be generated.
    * @param posTagRegExp Specifies whether the posTag string is a 
    *  regular expression. 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/RuleMatch.java
Patch:
@@ -66,7 +66,7 @@ public RuleMatch(Rule rule, int fromPos, int toPos, String message, boolean star
     this.toPos = toPos;
     this.message = message;
     // extract suggestion from <suggestion>...</suggestion> in message:
-    Matcher matcher = SUGGESTION_PATTERN.matcher(message);
+    final Matcher matcher = SUGGESTION_PATTERN.matcher(message);
     int pos = 0;
     while (matcher.find(pos)) {
       pos = matcher.end();
@@ -195,7 +195,7 @@ public void setSuggestedReplacements(List<String> repl) {
   /**
    * The text fragments which might be an appropriate fix for the problem. One
    * of these fragments can be used to replace the old text between getFromPos()
-   * to getToPos(). Note that by default, text between &lt;em> and &lt;/em> is
+   * to getToPos(). Text between &lt;suggestion> and &lt;/suggestion> is
    * taken as the suggested replacement. 
    * @return List of String objects or an empty List
    */
@@ -210,7 +210,7 @@ public String toString() {
   public int compareTo(RuleMatch other) {
     if (other == null)
       throw new ClassCastException();
-    RuleMatch otherRule = (RuleMatch) other;
+    final RuleMatch otherRule = (RuleMatch) other;
     if (getFromPos() < otherRule.getFromPos())
       return -1;
     if (getFromPos() > otherRule.getFromPos())

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/de/GermanCompoundTokenizer.java
Patch:
@@ -34,7 +34,7 @@ public class GermanCompoundTokenizer implements Tokenizer {
   private GermanWordSplitter wordSplitter = null;
   
   public GermanCompoundTokenizer() throws IOException {
-    wordSplitter = new GermanWordSplitter();
+    wordSplitter = new GermanWordSplitter(false);
   }
   
   public List<String> tokenize(String word) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRule.java
Patch:
@@ -436,7 +436,7 @@ private final String formatMatches(final AnalyzedTokenReadings[] toks,
                     errorMessage += suggestionLeft
                     + formatMatch 
                     + suggestionRight;
-                    if (lastLeftSugEnd == -1 && lastLeftSugStart > 0) {
+                    if (lastLeftSugEnd < lastLeftSugStart && lastLeftSugStart > 0) {
                       errorMessage += "</suggestion>, <suggestion>";
                     }
                   }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/pl/PolishWordRepeatRule.java
Patch:
@@ -43,7 +43,7 @@ public class PolishWordRepeatRule extends PolishRule {
    * Excluded dictionary words.
    */
   private static final Pattern EXC_WORDS 
-  = Pattern.compile("nie|aż|to|siebie|być|ani|ni|albo|" +
+  = Pattern.compile("nie|tuż|aż|to|siebie|być|ani|ni|albo|" +
       "lub|czy|bądź|jako|zł|np|coraz" +
       "|bardzo|bardziej|proc|ten|jak|mln|tys|swój|mój|" +
        "twój|nasz|wasz|i|zbyt");

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/pl/PolishWordRepeatRule.java
Patch:
@@ -43,10 +43,10 @@ public class PolishWordRepeatRule extends PolishRule {
    * Excluded dictionary words.
    */
   private static final Pattern EXC_WORDS 
-  = Pattern.compile("nie|to|siebie|być|ani|ni|albo|" +
+  = Pattern.compile("nie|aż|to|siebie|być|ani|ni|albo|" +
       "lub|czy|bądź|jako|zł|np|coraz" +
       "|bardzo|bardziej|proc|ten|jak|mln|tys|swój|mój|" +
-  "twój|nasz|wasz|i|zbyt");
+       "twój|nasz|wasz|i|zbyt");
 
   /**
    * Excluded part of speech classes.

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tagging/disambiguation/rules/fr/FrenchRuleDisambiguatorTest.java
Patch:
@@ -26,7 +26,7 @@ public void setUp() {
 
   public void testChunker() throws IOException {
     TestTools.myAssert("Je ne suis pas la seule.",
-        "/[null]SENT_START Je/[je]R pers suj 1 s  /[null]null ne/[ne]A  /[null]null suis/[suivre]V etre ind pres 1 s  /[null]null pas/[pas]A|pas/[pas]N m sp  /[null]null la/[le]D f s  /[null]null seule/[seul]D f s|seule/[seul]J f s ./[null]null", 
+        "/[null]SENT_START Je/[je]R pers suj 1 s  /[null]null ne/[ne]A  /[null]null suis/[suivre]V etre ind pres 1 s  /[null]null pas/[pas]A  /[null]null la/[le]D f s  /[null]null seule/[seul]D f s|seule/[seul]J f s ./[null]null", 
         tokenizer, sentenceTokenizer, tagger, disambiguator);
     TestTools.myAssert("Je ne suis pas la seule.",
         "/[null]SENT_START Je/[je]R pers suj 1 s  /[null]null ne/[ne]A  /[null]null suis/[suivre]V etre ind pres 1 s|suis/[suivre]V imp pres 2 s|suis/[suivre]V ind pres 1 s|suis/[suivre]V ind pres 2 s  /[null]null pas/[pas]A|pas/[pas]N m sp  /[null]null la/[le]D f s|la/[la]N m sp|la/[la]R pers obj 3 f s  /[null]null seule/[seul]D f s|seule/[seul]J f s ./[null]null", 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -101,7 +101,7 @@ class PatternRuleHandler extends XMLRuleHandler {
   private boolean exceptionStringInflected = false;
   private boolean exceptionPosNegation = false;
   private boolean exceptionPosRegExp = false;
-  private boolean exceptionValidNext = true;
+  private boolean exceptionValidNext = false;
   private boolean exceptionSet = false;
   
   /** true when phraseref is the last element in the rule. **/ 
@@ -450,7 +450,7 @@ private void resetToken() {
     exceptionPosNegation = false;
     exceptionPosRegExp = false;
     exceptionStringRegExp = false;
-    exceptionValidNext = true;
+    exceptionValidNext = false;
     exceptionSet = false; 
   }
   

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/disambiguation/rules/XMLRuleHandler.java
Patch:
@@ -31,7 +31,6 @@ class XMLRuleHandler extends DefaultHandler {
 
   StringBuffer correctExample = new StringBuffer();
   StringBuffer incorrectExample = new StringBuffer();
-  StringBuffer message = new StringBuffer();
   StringBuffer match = new StringBuffer();
   StringBuffer elements = null;
   StringBuffer exceptions = null;    

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/FalseFriendRuleLoader.java
Patch:
@@ -179,8 +179,7 @@ public void startElement(String namespaceURI, String lName, String qName, Attrib
 			  throw new SAXException("Unknown language '" + languageStr + "'");
 		  }
 	  } else if (qName.equals("exception")) {
-	    	inException = true;
-	    	exceptionSet = true;
+	    	inException = true;	    	
 	    	exceptions = new StringBuffer();
 	    	
 	    	if (attrs.getValue("negate") != null) {
@@ -342,6 +341,8 @@ public void endElement(String namespaceURI, String sName, String qName) {
 		  exceptionPosNegation = false;
 		  exceptionPosRegExp = false;
 		  exceptionStringRegExp = false;
+      exceptionValidNext = true;
+      exceptionSet = false;
 		  
 	  } else if (qName.equals("pattern")) {
 		  inPattern = false;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/disambiguation/rules/XMLRuleHandler.java
Patch:
@@ -44,7 +44,7 @@ class XMLRuleHandler extends DefaultHandler {
   boolean inRuleGroup = false;
   boolean inToken= false;
   boolean inException = false;
-  boolean inPhrases = false;
+  boolean inAndGroup = false;
   
   List<DisambiguationPatternRule> getRules() {
     return rules;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/JLanguageTool.java
Patch:
@@ -222,9 +222,9 @@ public File getAbsoluteFile(final String relFilename) {
    * @throws IOException
    * @return a List of {@link PatternRule} objects
    */
-  public List<PatternRule> loadPatternRules(final String filename) throws ParserConfigurationException, SAXException, IOException {
+  public List<PatternRule> loadPatternRules(final String filename) throws IOException {
     PatternRuleLoader ruleLoader = new PatternRuleLoader();
-    return ruleLoader.getRules(this.getClass().getResourceAsStream(filename));
+    return ruleLoader.getRules(this.getClass().getResourceAsStream(filename), filename);
   }
 
   /**
@@ -252,7 +252,7 @@ public List<PatternRule> loadFalseFriendRules(final String filename) throws Pars
    * @throws SAXException
    * @throws IOException
    */
-  public void activateDefaultPatternRules() throws ParserConfigurationException, SAXException, IOException {
+  public void activateDefaultPatternRules() throws IOException {
     String defaultPatternFilename = 
       RULES_DIR + "/" + language.getShortName() + "/" + PATTERN_FILE;
     List<PatternRule> patternRules = loadPatternRules(defaultPatternFilename);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Element.java
Patch:
@@ -250,6 +250,8 @@ public final void setSkipNext(final int i) {
 
   /**
    * Negates the meaning of match().
+   * @param negation - true if the meaning of match()
+   * is to be negated.
    */
   final void setNegation(final boolean negation) {
     this.negation = negation;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/pl/PolishWordRepeatRule.java
Patch:
@@ -29,7 +29,7 @@ public class PolishWordRepeatRule extends PolishRule {
    */
   private static final Pattern EXC_WORDS 
     = Pattern.compile("nie|to|siebie|być|ani|albo|" +
-        "lub|czy|bądź|jako|zł|coraz" +
+        "lub|czy|bądź|jako|zł|np|coraz" +
         "|bardzo|ten|jak|mln|tys|swój|mój|" +
         "twój|nasz|wasz|i|zbyt");
   

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/UnpairedQuotesBracketsRuleTest.java
Patch:
@@ -63,6 +63,9 @@ public void testRulePolish() throws IOException {
     // correct sentences:
     matches = rule.match(langTool.getAnalyzedSentence("(To jest zdanie do testowania)."));
     assertEquals(0, matches.length);
+//  correct sentences:
+    matches = rule.match(langTool.getAnalyzedSentence("Piosenka ta trafiła na wiele list \"Best of...\", włączając w to te, które zostały utworzone przez magazyn Rolling Stone."));
+    assertEquals(0, matches.length);
     // incorrect sentences:
     matches = rule.match(langTool.getAnalyzedSentence("W tym zdaniu jest niesparowany „cudzysłów."));
     assertEquals(1, matches.length);

File: trunk/JLanguageTool/src/dev/de/danielnaber/languagetool/dev/Overview.java
Patch:
@@ -34,7 +34,7 @@
  * 
  * @author Daniel Naber
  */
-public class Overview {
+public final class Overview {
 
   public static void main(String[] args) throws IOException {
     Overview prg = new Overview();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/JLanguageTool.java
Patch:
@@ -60,7 +60,7 @@
  * 
  * @author Daniel Naber
  */
-public class JLanguageTool {
+public final class JLanguageTool {
 
   public static final String VERSION = "0.9-dev";      // keep in sync with build.xml!
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/UnpairedQuotesBracketsRule.java
Patch:
@@ -152,6 +152,7 @@ public final RuleMatch[] match(final AnalyzedSentence text) {
           }
         
         // Exception for English plural saxon genetive
+        //TODO: add POS checking
         if ((precededByWhitespace || followedByWhitespace) 
             && ruleLang.equals(Language.ENGLISH) 
             && token.trim().equals("'")

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/server/HTTPServer.java
Patch:
@@ -48,7 +48,7 @@ public class HTTPServer extends ContentOracle {
   
   private static final int CONTEXT_SIZE = 40;   // characters
 
-  private static Daemon daemon;
+  private Daemon daemon;
   private int port = DEFAULT_PORT;
   
   private static final Set<String> allowedIPs = new HashSet<String>();

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/XMLValidator.java
Patch:
@@ -39,7 +39,7 @@
  * 
  * @author Daniel Naber
  */
-public class XMLValidator {
+public final class XMLValidator {
 
   public XMLValidator() {
   }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tools/StringTools.java
Patch:
@@ -62,7 +62,7 @@ public static String readFile(final InputStream file) throws IOException {
   /**
    * Read the text file using the given encoding.
    * 
-   * @param filename name of the file
+   * @param file InputStream to a file to be read
    * @param encoding the file's character encoding (e.g. <code>iso-8859-1</code>)
    * @return a string with the file's content, lines separated by <code>\n</code>
    * @throws IOException

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tools/ReflectionUtils.java
Patch:
@@ -68,8 +68,8 @@ public static Class[] findClasses(ClassLoader classLoader, String packageName,
         // jars and directories are treated differently
         if (resource.getProtocol().startsWith("jar")) {        
           // The LanguageTool ZIP contains two JARs with the core classes,
-          // so ignore one of them to avoid rule duplication:
-          if (resource.getPath().endsWith("LanguageTool.uno.jar")) {
+          // so ignore one of them to avoid rule duplication:          
+          if (resource.getPath().contains("LanguageTool.uno.jar")) {
             continue;
           }
           findClassesInJar(packageName, classNameRegEx, subdirLevel, classExtends,

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/Main.java
Patch:
@@ -31,6 +31,7 @@
 import java.awt.event.WindowEvent;
 import java.awt.event.WindowListener;
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.Reader;
 import java.util.Enumeration;
@@ -208,7 +209,7 @@ void loadFile() {
       File file = jfc.getSelectedFile();
       if (file == null)   // user cancelled
         return;
-      String fileContents = StringTools.readFile(this.getClass().getResourceAsStream((file.getAbsolutePath())));
+      String fileContents = StringTools.readFile(new FileInputStream(file.getAbsolutePath()));
       textArea.setText(fileContents);
       JLanguageTool langTool = getCurrentLanguageTool();
       checkTextAndDisplayResults(langTool, getCurrentLanguage());

File: trunk/JLanguageTool/src/dev/de/danielnaber/languagetool/dev/CheckBNC.java
Patch:
@@ -20,6 +20,7 @@
 package de.danielnaber.languagetool.dev;
 
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.IOException;
 import java.util.List;
 
@@ -75,7 +76,7 @@ private void run(final File file) throws IOException {
       }
     } else {
       System.out.println("Checking " + file.getAbsolutePath());
-      String text = StringTools.readFile(file.getAbsolutePath());
+      String text = StringTools.readFile(new FileInputStream(file.getAbsolutePath()));
       text = textFilter.filter(text);
       if (CHECK_BY_SENTENCE) {
         SentenceTokenizer st = new SentenceTokenizer();

File: trunk/JLanguageTool/src/dev/de/danielnaber/languagetool/dev/Indexer.java
Patch:
@@ -19,6 +19,7 @@
 package de.danielnaber.languagetool.dev;
 
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.IOException;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -73,7 +74,7 @@ private void index(IndexWriter iw, File file, int count) throws IOException {
       Document doc = new Document();
       if (count % 50 == 0)
         System.out.println("Indexing file #" + count);
-      String s = StringTools.readFile(file.getAbsolutePath(), "iso-8859-1");
+      String s = StringTools.readFile(new FileInputStream(file.getAbsolutePath()), "iso-8859-1");
       // XML data:
       s = getParagraphs(s);
       //s = s.replaceAll("(\\w)([.,?!])", "$1 $2");

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Main.java
Patch:
@@ -19,6 +19,7 @@
 package de.danielnaber.languagetool;
 
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -62,7 +63,7 @@ class Main {
       SAXException, ParserConfigurationException {
     this.verbose = verbose;
     this.apiFormat = apiFormat;
-    lt = new JLanguageTool(language, motherTongue, Tools.getBaseDir());
+    lt = new JLanguageTool(language, motherTongue);
     lt.activateDefaultPatternRules();
     lt.activateDefaultFalseFriendRules();
     // disable rules that are disabled explicitly:
@@ -113,7 +114,7 @@ private String getFilteredText(final String filename, final String encoding) thr
       lt.setOutput(System.err);
     if (!apiFormat)
       System.out.println("Working on " + filename + "...");
-    String fileContents = StringTools.readFile(filename, encoding);
+    String fileContents = StringTools.readFile(new FileInputStream(filename), encoding);
     return filterXML(fileContents);
   }
     

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/Main.java
Patch:
@@ -82,7 +82,7 @@ public final class Main implements ActionListener {
   private static final String HTML_FONT_START = "<font face='Arial,Helvetica'>";
   private static final String HTML_FONT_END = "</font>";
   
-  private static final Icon SYSTEM_TRAY_ICON = new ImageIcon("resource"+File.separator+"TrayIcon.png");
+  private final Icon SYSTEM_TRAY_ICON = new ImageIcon( this.getClass().getResource("/resource/TrayIcon.png"));
   private static final String SYSTEM_TRAY_TOOLTIP = "LanguageTool";
   private static final String CONFIG_FILE = ".languagetool.cfg";
 
@@ -111,7 +111,7 @@ private void createGUI() {
     frame = new JFrame("LanguageTool " + JLanguageTool.VERSION);
     frame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
     frame.addWindowListener(new CloseListener());
-    frame.setIconImage(Tools.WINDOW_ICON);
+    frame.setIconImage(new ImageIcon(this.getClass().getResource("/resource/TrayIcon.png")).getImage());
     frame.setJMenuBar(new MainMenuBar(this, messages));
 
     textArea = new JTextArea(messages.getString("guiDemoText"));
@@ -208,7 +208,7 @@ void loadFile() {
       File file = jfc.getSelectedFile();
       if (file == null)   // user cancelled
         return;
-      String fileContents = StringTools.readFile(file.getAbsolutePath());
+      String fileContents = StringTools.readFile(this.getClass().getResourceAsStream((file.getAbsolutePath())));
       textArea.setText(fileContents);
       JLanguageTool langTool = getCurrentLanguageTool();
       checkTextAndDisplayResults(langTool, getCurrentLanguage());

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/Main.java
Patch:
@@ -302,7 +302,7 @@ private void checkText(final TextToCheck textToCheck) {
         return;
       ProgressDialog progressDialog = new ProgressDialog(messages);
       CheckerThread checkerThread = new CheckerThread(textToCheck.paragraphs, docLanguage, config, 
-          baseDir, progressDialog);
+          progressDialog);
       checkerThread.start();
       while (true) {
         if (checkerThread.done()) {
@@ -346,8 +346,8 @@ private void checkText(final TextToCheck textToCheck) {
 
     private File getBaseDir() throws IOException {
       java.net.URL url = Main.class.getResource("/de/danielnaber/languagetool/openoffice/Main.class");
-      String urlString = url.getFile();
-      urlString = URLDecoder.decode(urlString);
+      String urlString = url.getFile();            
+      urlString = URLDecoder.decode(urlString, "UTF-8");
       File file = new File(urlString.substring("file:".length(), urlString.indexOf("!")));
       if (!file.exists()) {
         throw new IOException("File not found: " + file.getAbsolutePath());

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Element.java
Patch:
@@ -45,7 +45,7 @@ public class Element {
   private boolean inflected = false;
 
   private ArrayList<Element> exceptionList;
-  public boolean exceptionValidNext = true;
+  private boolean exceptionValidNext = true;
   private boolean exceptionSet = false;
 
   private int skip = 0;

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/JLanguageToolTest.java
Patch:
@@ -44,7 +44,7 @@ public void testEnglish() throws IOException, ParserConfigurationException, SAXE
     matches = tool.check("I can give you more a detailed description.");
     assertEquals(0, matches.size());
     assertEquals(6, tool.getAllRules().size());
-    List rules = tool.loadPatternRules("rules/en/grammar.xml");
+    List rules = tool.loadPatternRules("/rules/en/grammar.xml");
     for (Iterator iter = rules.iterator(); iter.hasNext();) {
       Rule rule = (Rule) iter.next();
       tool.addRule(rule);
@@ -63,7 +63,7 @@ public void testGerman() throws IOException, ParserConfigurationException, SAXEx
     assertEquals(0, matches.size());
     matches = tool.check("Ein Test Test, der Fehler geben sollte.");
     assertEquals(1, matches.size());
-    List rules = tool.loadPatternRules("rules/de/grammar.xml");
+    List rules = tool.loadPatternRules("/rules/de/grammar.xml");
     for (Iterator iter = rules.iterator(); iter.hasNext();) {
       Rule rule = (Rule) iter.next();
       tool.addRule(rule);
@@ -79,7 +79,7 @@ public void testDutch() throws IOException, ParserConfigurationException, SAXExc
     assertEquals(0, matches.size());
     matches = tool.check("Een test test, die een fout moet geven.");
     assertEquals(1, matches.size());
-    List rules = tool.loadPatternRules("rules/nl/grammar.xml");
+    List rules = tool.loadPatternRules("/rules/nl/grammar.xml");
     for (Iterator iter = rules.iterator(); iter.hasNext();) {
       Rule rule = (Rule) iter.next();
       tool.addRule(rule);

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/XMLValidator.java
Patch:
@@ -72,8 +72,8 @@ public void validateXMLString(String xml, String dtdFile, String docType) throws
   /**
    * Validate XML file with the given DTD. Throws exception on error. 
    */
-  public void validate(String filename, String dtdFile, String docType) throws SAXException, IOException, ParserConfigurationException {
-    String xml = StringTools.readFile(filename);
+  public final void validate(String filename, String dtdFile, String docType) throws SAXException, IOException, ParserConfigurationException {
+    String xml = StringTools.readFile(this.getClass().getResourceAsStream(filename));
     validateInternal(xml, dtdFile, docType);
   }
 
@@ -83,7 +83,7 @@ private void validateInternal(String xml, String dtdFile, String doctype) throws
     SAXParser saxParser = factory.newSAXParser();
     final String decl = "<?xml version=\"1.0\"";
     final String endDecl = "?>";
-    final String dtd = "<!DOCTYPE "+doctype+" PUBLIC \"-//W3C//DTD Rules 0.1//EN\" \"file:" +dtdFile+ "\">";
+    final String dtd = "<!DOCTYPE "+doctype+" PUBLIC \"-//W3C//DTD Rules 0.1//EN\" \"" +this.getClass().getResource(dtdFile)+ "\">";
     int pos = xml.indexOf(decl);
     int endPos = xml.indexOf(endDecl);
     if (pos == -1)

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -55,7 +55,7 @@ public void testGrammarRulesFromXML() throws IOException, ParserConfigurationExc
       Language lang = Language.LANGUAGES[i];
       PatternRuleLoader ruleLoader = new PatternRuleLoader();
       JLanguageTool languageTool = new JLanguageTool(lang);
-      List rules = ruleLoader.getRules("rules" + File.separator
+      List rules = ruleLoader.getRules("/rules" + File.separator
           + lang.getShortName() + File.separator + "grammar.xml");
       testGrammarRulesFromXML(rules, languageTool, lang);
     }

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/server/HTTPServerTest.java
Patch:
@@ -46,7 +46,7 @@ public void testHTTPServer() {
       assertTrue(result.indexOf("WIEDER_WILLEN") != -1);
       assertTrue(result.indexOf("öäüß") != -1);   // special chars are intact
       XMLValidator validator = new XMLValidator();
-      validator.validateXMLString(result, "resource/api-output.dtd", "matches");
+      validator.validateXMLString(result, "/resource/api-output.dtd", "matches");
       validator.checkSimpleXMLString(result);
       //System.err.println(result);
       // make sure XML chars are escaped in the result to avoid invalid XML

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tagging/cs/CzechTaggerTest.java
Patch:
@@ -40,7 +40,7 @@ public void testTagger() throws IOException {
     
 	  TestTools.myAssert("Nejkratší věta.", "Nejkratší/[krátký]k2eAgFnPc1d3|Nejkratší/[krátký]k2eAgFnPc4d3|Nejkratší/[krátký]k2eAgFnPc5d3|Nejkratší/[krátký]k2eAgFnSc1d3|Nejkratší/[krátký]k2eAgFnSc2d3|Nejkratší/[krátký]k2eAgFnSc3d3|Nejkratší/[krátký]k2eAgFnSc4d3|Nejkratší/[krátký]k2eAgFnSc5d3|Nejkratší/[krátký]k2eAgFnSc6d3|Nejkratší/[krátký]k2eAgFnSc7d3|Nejkratší/[krátký]k2eAgInPc1d3|Nejkratší/[krátký]k2eAgInPc4d3|Nejkratší/[krátký]k2eAgInPc5d3|Nejkratší/[krátký]k2eAgInSc1d3|Nejkratší/[krátký]k2eAgInSc4d3|Nejkratší/[krátký]k2eAgInSc5d3|Nejkratší/[krátký]k2eAgMnPc1d3|Nejkratší/[krátký]k2eAgMnPc4d3|Nejkratší/[krátký]k2eAgMnPc5d3|Nejkratší/[krátký]k2eAgMnSc1d3|Nejkratší/[krátký]k2eAgMnSc5d3|Nejkratší/[krátký]k2eAgNnPc1d3|Nejkratší/[krátký]k2eAgNnPc4d3|Nejkratší/[krátký]k2eAgNnPc5d3|Nejkratší/[krátký]k2eAgNnSc1d3|Nejkratší/[krátký]k2eAgNnSc4d3|Nejkratší/[krátký]k2eAgNnSc5d3 věta/[věta]k1gFnSc1", tokenizer, tagger);
     TestTools.myAssert("zvolací.", "zvolací/[zvolací]k2eAgFnPc1d1|zvolací/[zvolací]k2eAgFnPc4d1|zvolací/[zvolací]k2eAgFnPc5d1|zvolací/[zvolací]k2eAgFnSc1d1|zvolací/[zvolací]k2eAgFnSc2d1|zvolací/[zvolací]k2eAgFnSc3d1|zvolací/[zvolací]k2eAgFnSc4d1|zvolací/[zvolací]k2eAgFnSc5d1|zvolací/[zvolací]k2eAgFnSc6d1|zvolací/[zvolací]k2eAgFnSc7d1|zvolací/[zvolací]k2eAgInPc1d1|zvolací/[zvolací]k2eAgInPc4d1|zvolací/[zvolací]k2eAgInPc5d1|zvolací/[zvolací]k2eAgInSc1d1|zvolací/[zvolací]k2eAgInSc4d1|zvolací/[zvolací]k2eAgInSc5d1|zvolací/[zvolací]k2eAgMnPc1d1|zvolací/[zvolací]k2eAgMnPc4d1|zvolací/[zvolací]k2eAgMnPc5d1|zvolací/[zvolací]k2eAgMnSc1d1|zvolací/[zvolací]k2eAgMnSc5d1|zvolací/[zvolací]k2eAgNnPc1d1|zvolací/[zvolací]k2eAgNnPc4d1|zvolací/[zvolací]k2eAgNnPc5d1|zvolací/[zvolací]k2eAgNnSc1d1|zvolací/[zvolací]k2eAgNnSc4d1|zvolací/[zvolací]k2eAgNnSc5d1", tokenizer, tagger);
-	  TestTools.myAssert("blablabla","blablabla/[null]null", tokenizer, tagger);
+	  TestTools.myAssert("blablabla", "blablabla/[null]null", tokenizer, tagger);
 	}
 
 }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/AbstractPunctuationCheckRule.java
Patch:
@@ -75,7 +75,7 @@ public RuleMatch[] match(final AnalyzedSentence text) {
 
 			if (tkns.length() >= 2) {
 				if (!isPunctsJoinOk(tkns)) {
-					String msg = "bad duplication or combination of puctuation signs";
+					String msg = "bad duplication or combination of punctuation signs";
 					RuleMatch ruleMatch = new RuleMatch(this, tokens[startTokenIdx].getStartPos(), 
                         tokens[startTokenIdx].getStartPos() + tkns.length(), msg);
 					ruleMatch.setSuggestedReplacement(tkns.substring(0, 1));

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Element.java
Patch:
@@ -65,6 +65,8 @@ public class Element {
     if (!stringToken.equals("") && stringRegExp) {
       regToken = stringToken;
       if (!caseSensitive) {
+//FIXME: it should be (?i) but this breaks Dutch rules
+        //wait for a new release and then change
         regToken = "(?u)".concat(stringToken);
       }
       p = Pattern.compile(regToken);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/en/AvsAnRule.java
Patch:
@@ -171,6 +171,9 @@ private Set<String> loadWords(final File file) throws IOException {
       String line;
       while ((line = br.readLine()) != null) {
         line = line.trim();
+        if (line.length() < 1) {
+          continue;
+        }
         if (line.charAt(0) == '#')       // ignore comments
           continue;
         if (line.charAt(0) == '*')       // case sensitive

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.Arrays;
 import java.util.List;
 import java.util.ArrayList;
-import de.danielnaber.languagetool.tools.StringTools;
 
 /**
  * An array of {@link AnalyzedToken}s used to store multiple POS tags and lemmas
@@ -57,7 +56,7 @@ public final AnalyzedToken getAnalyzedToken(final int i) {
 		return anTokReadings[i];
 	}
 
-  public final void addReading (final AnalyzedToken tok) {
+  public final void addReading(final AnalyzedToken tok) {
     ArrayList <AnalyzedToken> l = new ArrayList <AnalyzedToken>(); 
         
     for (int i = 0; i < anTokReadings.length - 1; i++) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/Configuration.java
Patch:
@@ -134,8 +134,7 @@ public void saveConfiguration() throws IOException {
         
     if (disabledRuleIds == null) {
       props.setProperty(DISABLED_RULES_CONFIG_KEY, "");
-    }
-    else {
+    } else {
       StringBuilder sb = new StringBuilder();
       for (Iterator<String> iter = disabledRuleIds.iterator(); iter.hasNext();) {
         String id = iter.next();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -434,7 +434,7 @@ public void endElement(String namespaceURI, String sName, String qName) {
     } 
   }
 
-  public void characters(final char buf [], int offset, int len) {
+  public void characters(final char[] buf, int offset, int len) {
     String s = new String(buf, offset, len);
     if (inException) {
       exceptions.append(s);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/en/EnglishTagger.java
Patch:
@@ -64,7 +64,7 @@ public final List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens)
       List<AnalyzedToken> l = new ArrayList<AnalyzedToken>();
       String[] lowerTaggerTokens = null;
       taggerTokens = morfologik.stemAndForm(word);
-      if (word != word.toLowerCase()) {
+      if (!word.equals(word.toLowerCase())) {
         lowerTaggerTokens = morfologik.stemAndForm(word.toLowerCase());
       }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/es/SpanishTagger.java
Patch:
@@ -63,7 +63,7 @@ public List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens) throws
       List<AnalyzedToken> l = new ArrayList<AnalyzedToken>();
       String[] lowerTaggerTokens = null;
       taggerTokens = morfologik_spanish.stemAndForm(word);
-      if (word != word.toLowerCase()) {
+      if (!word.equals(word.toLowerCase())) {
         lowerTaggerTokens = morfologik_spanish.stemAndForm(word.toLowerCase());
       }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/fr/FrenchTagger.java
Patch:
@@ -62,7 +62,7 @@ public List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens) throws
       List<AnalyzedToken> l = new ArrayList<AnalyzedToken>();
       String[] lowerTaggerTokens = null;
       taggerTokens = morfologik.stemAndForm(word);
-      if (word != word.toLowerCase()) {
+      if (!word.equals(word.toLowerCase())) {
         lowerTaggerTokens = morfologik.stemAndForm(word.toLowerCase());
       }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/it/ItalianTagger.java
Patch:
@@ -66,7 +66,7 @@ public List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens) throws
       List<AnalyzedToken> l = new ArrayList<AnalyzedToken>();
       String[] lowerTaggerTokens = null;
       taggerTokens = morfologik.stemAndForm(word);
-      if (word != word.toLowerCase()) {
+      if (!word.equals(word.toLowerCase())) {
         lowerTaggerTokens = morfologik.stemAndForm(word.toLowerCase());
       }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/nl/DutchTagger.java
Patch:
@@ -62,7 +62,7 @@ public List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens) throws
       List<AnalyzedToken> l = new ArrayList<AnalyzedToken>();
       String[] lowerTaggerTokens = null;
       taggerTokens = morfologik.stemAndForm(word);
-      if (word != word.toLowerCase()) {
+      if (!word.equals(word.toLowerCase())) {
         lowerTaggerTokens = morfologik.stemAndForm(word.toLowerCase());
       }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/pl/PolishTagger.java
Patch:
@@ -61,8 +61,8 @@ public final List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens)
       List<AnalyzedToken> l = new ArrayList<AnalyzedToken>();      
       String[] lowerTaggerTokens = null;
         taggerTokens = morfologik.stemAndForm(word);
-        if (word != word.toLowerCase()) {
-        lowerTaggerTokens = morfologik.stemAndForm(word.toLowerCase());
+        if (!word.equals(word.toLowerCase())) {
+          lowerTaggerTokens = morfologik.stemAndForm(word.toLowerCase());
         }
                 
     if (taggerTokens != null) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/uk/UkrainianMorfoTagger.java
Patch:
@@ -61,7 +61,7 @@ public final List<AnalyzedTokenReadings> tag(final List<String> sentenceTokens)
       List<AnalyzedToken> l = new ArrayList<AnalyzedToken>();
       String[] lowerTaggerTokens = null;
       taggerTokens = morfologik.stemAndForm(word);
-      if (word != word.toLowerCase()) {
+      if (!word.equals(word.toLowerCase())) {
         lowerTaggerTokens = morfologik.stemAndForm(word.toLowerCase());
       }
 

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -36,7 +36,6 @@
 import de.danielnaber.languagetool.JLanguageTool;
 import de.danielnaber.languagetool.Language;
 import de.danielnaber.languagetool.rules.Rule;
-import de.danielnaber.languagetool.rules.patterns.PatternRule;
 import de.danielnaber.languagetool.rules.RuleMatch;
 
 /**

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tagging/disambiguation/pl/PolishChunkerTest.java
Patch:
@@ -5,7 +5,6 @@
 import de.danielnaber.languagetool.TestTools;
 import de.danielnaber.languagetool.tokenizers.WordTokenizer;
 import de.danielnaber.languagetool.tokenizers.pl.PolishSentenceTokenizer;
-import de.danielnaber.languagetool.tagging.disambiguation.pl.PolishChunker;
 import de.danielnaber.languagetool.tagging.pl.*;
 
 /* LanguageTool, a natural language style checker 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/pl/PolishSentenceTokenizer.java
Patch:
@@ -48,7 +48,7 @@ public class PolishSentenceTokenizer extends SentenceTokenizer {
   private static final Pattern abbrev1 = Pattern.compile("([^-\\p{L}”][\\p{L}]" + PAP + "\\s)" + EOS);
   private static final Pattern abbrev2 = Pattern.compile("([^-\\p{L}][\\p{L}]" + P + ")" + EOS);
   //** Lookahead regexp excludes some possible abbrevs here
-  private static final Pattern abbrev3 = Pattern.compile("(\\s(?![rwn])[\\p{L}]\\.\\s+)" + EOS +"(\\p{Ll}\\p{Ll}|\\p{Lu}[\\p{Punct}\\s\\p{Lu}])");
+  private static final Pattern abbrev3 = Pattern.compile("(\\s(?![rwn])[\\p{L}]\\.\\s+)" + EOS +"(\\p{Ll}\\p{Ll}|\\p{Lu}[\\p{Punct}\\p{Lu}])");
   private static final Pattern abbrev4 = Pattern.compile("(\\.\\.\\. )" + EOS + "([\\p{Ll}])");
   private static final Pattern abbrev5 = Pattern.compile("(['\"]" + P + "['\"]\\s+)" + EOS);
   private static final Pattern abbrev6 = Pattern.compile("([\"”']\\s*)" + EOS + "(\\s*[\\p{Ll}])");

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tokenizers/pl/PolishSentenceTokenizerTest.java
Patch:
@@ -91,6 +91,8 @@ public final void testTokenize() {
     testSplit(new String[] { "Ks. Jankowski jest prof. teologii." });    
     testSplit(new String[] { "To wydarzyło się w 1939 r.", "To był burzliwy rok." });
     testSplit(new String[] { "Prezydent jest popierany przez 20 proc. społeczeństwa." });
+    testSplit(new String[] { "Moje wystąpienie ma na celu zmobilizowanie zarządu partii do działań, które umożliwią uzyskanie 40 proc.", "Nie widzę dziś na scenie politycznej formacji, która lepiej by łączyła różne poglądy" });
+    testSplit(new String[] {"To jest zmienna A.", "Zaś to jest zmienna B."}); 
   }
 
   public final void testSplit(final String[] sentences) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -105,7 +105,7 @@ public final boolean isParaEnd() {
   
   /**
    * @author Marcin Miłkowski
-   * @return true when the token is a last token in a paragraph. 
+   * @return true when the token is a last token in a sentence. 
    * */   
   public final boolean isSentEnd() {
    boolean isSE = false;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/de/AnalyzedGermanToken.java
Patch:
@@ -107,7 +107,7 @@ else if (parts[i].equals("PER"))
         ; // not yet used
       
       //else
-      //  System.err.println("unknown: " + posTagString + " for fullform " + fullform);
+        //System.err.println("unknown: " + posTagString + " for fullform " + fullform);
       // TODO: add else here that throws execption?!
     }
     

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/server/HTTPServerTest.java
Patch:
@@ -49,7 +49,7 @@ public void testHTTPServer() {
       validator.validateXMLString(result, "resource/api-output.dtd", "matches");
       validator.checkSimpleXMLString(result);
       //System.err.println(result);
-      // make sure XMl chars are escaped in the result to avoid invalid XML
+      // make sure XML chars are escaped in the result to avoid invalid XML
       // and XSS attacks:
       assertTrue(check(Language.GERMAN, "bla <script>").indexOf("<script>") == -1);
     } catch (Exception e) {

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tokenizers/cs/CzechSentenceTokenizerTest.java
Patch:
@@ -87,7 +87,7 @@ public final void testTokenize() {
     testSplit(new String[] { "James is from the Ireland!", "He lives in Spain now." });
     // From the abbreviation list:
     testSplit(new String[] { "V češtině jsou zkr. i pro jazyky, např. angl., maď. a jiné." });
-    testSplit(new String[] { "Titul jako doc. RNDr. Adam �?ezník, Ph.D. se může vyskytnout." });
+    testSplit(new String[] { "Titul jako doc. RNDr. Adam Řezník, Ph.D. se může vyskytnout." });
     testSplit(new String[] { "Starověký Egypt vznikl okolo r. 3150 př.n.l. (anebo 3150 př.kr.). ",
         "A zanikl v r. 31 př.kr." });
   }

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/patterns/PatternRuleTest.java
Patch:
@@ -116,7 +116,7 @@ private void testGrammarRulesFromXML(List rules, JLanguageTool languageTool, Lan
           
         alreadyMatched = alreadyMatched || matches.length != 0;
           
-          if (matches.length != 0) {
+          if ((matches.length != 0) && !simpleRule) {
                 assertTrue(lang + ": Did expect one error in: \"" + badSentence + "\" (Rule: "+rule+"), got " + 
                     matches.length, matches.length == 1);
                 assertEquals(lang + ": Incorrect match position markup (start) for rule " + rule,

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/pl/PolishSentenceTokenizer.java
Patch:
@@ -45,7 +45,7 @@ public class PolishSentenceTokenizer extends SentenceTokenizer {
   private static final Pattern punctUpperLower = Pattern.compile("(" + PAP
       + ")([\\p{Lu}][^\\p{Lu}.])");
   private static final Pattern letterPunct = Pattern.compile("(\\s[\\wąćęłńóśźżĄĆĘŁŃÓŚŹŻ]" + P + ")");
-  private static final Pattern abbrev1 = Pattern.compile("([^-\\wąćęłńóśźżĄĆĘŁŃÓŚŹŻ][\\wąćęłńóśźżĄĆĘŁŃÓŚŹŻ]" + PAP + "\\s)" + EOS);
+  private static final Pattern abbrev1 = Pattern.compile("([^-\\wąćęłńóśźżĄĆĘŁŃÓŚŹŻ”][\\wąćęłńóśźżĄĆĘŁŃÓŚŹŻ]" + PAP + "\\s)" + EOS);
   private static final Pattern abbrev2 = Pattern.compile("([^-\\wąćęłńóśźżĄĆĘŁŃÓŚŹŻ][\\wąćęłńóśźżĄĆĘŁŃÓŚŹŻ]" + P + ")" + EOS);
   private static final Pattern abbrev3 = Pattern.compile("(\\s[\\wąćęłńóśźżĄĆĘŁŃÓŚŹŻ]\\.\\s+)" + EOS);
   private static final Pattern abbrev4 = Pattern.compile("(\\.\\.\\. )" + EOS + "([\\p{Ll}])");

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/uk/SimpleReplaceRule.java
Patch:
@@ -49,7 +49,7 @@ public class SimpleReplaceRule extends Rule {
 	private static final String FILE_NAME = "rules" +File.separator+ "uk" +File.separator+ "replace.txt";
 	private static final String FILE_ENCODING = "utf-8";
 
-	private Map<String, String> wrongWords;        // e.g. "Đ˛Ń€ĐµŃ�Ń‚Ń– Ń€ĐµŃ�Ń‚" -> "Đ·Ń€ĐµŃ�Ń‚ĐľŃŽ"
+	private Map<String, String> wrongWords;        // e.g. "вреѿті реѿт" -> "зреѿтою"
 
 	public SimpleReplaceRule(ResourceBundle messages) throws IOException {
 		if (messages != null)

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -418,6 +418,8 @@ public void endElement(String namespaceURI, String sName, String qName) {
       elementList.clear();
     } else if (qName.equals("phrases") && inPhrases) {
       inPhrases = false;
+    } else if (qName.equals("phraseref")) {
+      elementList.clear();
     }
   }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Main.java
Patch:
@@ -218,7 +218,7 @@ private static Language getLanguageOrExit(String lang) {
         break;
       }          
     }
-    if (! foundLanguage) {
+    if (!foundLanguage) {
       System.out.println("Unknown language '" + lang + "'. Supported languages are: " + supportedLanguages);
       exitWithUsageMessage();
     }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/server/HTTPServer.java
Patch:
@@ -117,8 +117,9 @@ public String demultiplex(Request connRequest, Response connResponse) {
       }
     } catch (Exception e) {
       e.printStackTrace();
-      connResponse.setStatus(500);      
-      return "Error: " + e.toString();
+      connResponse.setStatus(500);
+      // escape input to avoid XSS attacks:
+      return "Error: " + StringTools.escapeXML(e.toString());
     }
   }
   

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/server/HTTPServerTest.java
Patch:
@@ -49,6 +49,9 @@ public void testHTTPServer() {
       validator.validateXMLString(result, "resource/api-output.dtd", "matches");
       validator.checkSimpleXMLString(result);
       //System.err.println(result);
+      // make sure XMl chars are escaped in the result to avoid invalid XML
+      // and XSS attacks:
+      assertTrue(check(Language.GERMAN, "bla <script>").indexOf("<script>") == -1);
     } catch (Exception e) {
       throw new RuntimeException(e);
     } finally {

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/de/AgreementRuleTest.java
Patch:
@@ -114,9 +114,9 @@ public void testDetNounRule() throws IOException {
     assertBad("Das Dach mein großen Autos.");
 
     assertBad("Erst recht wir fleißiges Arbeiter.");
-    assertBad("Erst recht ich fleißiges Arbeiter.");
 
     // TODO: not yet detected:
+    //assertBad("Erst recht ich fleißiges Arbeiter.");
     //assertBad("Das Dach meine großen Autos.");
     //assertBad("Das Dach meinen großen Autos.");
     //assertBad("Das Dach meine Autos.");

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/WiederVsWiderRule.java
Patch:
@@ -61,11 +61,11 @@ public RuleMatch[] match(AnalyzedSentence text) {
         // ignore
       } else {
         if (token.equalsIgnoreCase("spiegelt") || token.equalsIgnoreCase("spiegeln") || token.equalsIgnoreCase("spiegelte")
-            || token.equalsIgnoreCase("spiegelten")) {
+            || token.equalsIgnoreCase("spiegelten") || token.equalsIgnoreCase("spiegelst")) {
           foundSpiegelt = true;
-        } else if (token.equalsIgnoreCase("wieder")) {
+        } else if (token.equalsIgnoreCase("wieder") && foundSpiegelt) {
           foundWieder = true;
-        } else if (token.equalsIgnoreCase("wider")) {
+        } else if (token.equalsIgnoreCase("wider")  && foundSpiegelt) {
           foundWider = true;
         }
         if (foundSpiegelt && foundWieder && !foundWider) {

File: trunk/JLanguageTool/dev/de/danielnaber/languagetool/dev/CheckWikipediaDump.java
Patch:
@@ -112,7 +112,7 @@ public void characters(char buf[], int offset, int len) {
   private String cleanup(String s) {
     //[[Bild:Alkalimetalle.jpg|thumb|left|alle 5 stabilen Alkalimetalle]]
     s = s.replaceAll("(?s)\\[\\[Bild:.*?\\]\\]", "");
-    s = s.replaceAll("(?s)\\[\\[.*?\\|(.*?)\\]\\]", "$1");
+    s = s.replaceAll("(?s)\\[\\[[^\\[]*?\\|(.*?)\\]\\]", "$1");
     // e.g. [[el:Άτομο]]:
     s = s.replaceAll("(?s)\\[\\[...?:.*?\\]", "");
     // e.g. [[Chromosom]]en:

File: trunk/JLanguageTool/dev/de/danielnaber/languagetool/dev/Overview.java
Patch:
@@ -59,6 +59,7 @@ private void run() throws IOException {
           // count XML rules:
           String xmlRules = StringTools.readFile(xmlFile);
           xmlRules = xmlRules.replaceAll("(?s)<!--.*?-->", "");
+          xmlRules = xmlRules.replaceAll("(?s)<rules.*?>", "");
           int pos = 0;
           int count = 0;
           while (pos != -1) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/Main.java
Patch:
@@ -359,7 +359,8 @@ static void showError(final Throwable e) {
     for (int i = 0; i < elem.length; i++) {
       msg += elem[i].toString() + "\n";
     }
-    JOptionPane.showMessageDialog(null, msg, "Error", JOptionPane.ERROR_MESSAGE);
+    DialogThread dt = new DialogThread(msg);
+    dt.start();
     e.printStackTrace();
     throw new RuntimeException(e);
   }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/Main.java
Patch:
@@ -196,8 +196,9 @@ private Language getLanguage() {
         }
         if (!langIsSupported) {
           // FIXME: i18n
-          JOptionPane.showMessageDialog(null, "Error: Sorry, the document language '" +charLocale.Language+ 
+          DialogThread dt = new DialogThread("Error: Sorry, the document language '" +charLocale.Language+ 
               "' is not supported by LanguageTool.");
+          dt.start();
           return null;
         }
         //checkTables();

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tagging/nl/DutchTaggerTest.java
Patch:
@@ -35,9 +35,8 @@ public void setUp() {
   }
 
   public void testTagger() throws IOException {
-	//FIXME:
-    //TestTools.myAssert("De boot is zelfgemaakt.", "De/[De]1/2-adjective(both(adv))|De/[De]1/2-determiner(pron)|De/[De]1/2-noun(both,both,[])|De/[De]1/2-noun(both,pl,[])|De/[De]1/2-noun(de,sg,[])|De/[De]1/2-noun(het,sg,[])|De/[De]1/2-pronoun(nwh,thi,sg,both,both,def)|De/[De]1/2-pronoun(nwh,thi,sg,de,both,def)|De/[De]1/2-propername|De/[De]1/2-skip|De/[De]1/2-tmpnp|De/[De]1/3-determiner(plnum,nwh,nmod,pro,yparg)|De/[De]1/3-determiner(pron)|De/[De]1/3-noun(both,both,[])|De/[De]1/3-noun(de,sg,[])|De/[De]1/3-propername|De/[De]1/4-determiner(de)|De/[De]1/4-propername|De/[De]1/5-propername|De/[De]1/6-propername|De/[De]1/7-propername|De/[De]1/8-propername|De/[De]2/2-noun(both,both,[])|De/[De]2/3-determiner(pron)|De/[De]2/3-noun(both,both,[])|De/[De]2/3-propername|De/[De]2/4-propername|De/[De]2/5-propername|De/[De]2/6-propername|De/[De]2/7-propername|De/[De]2/8-propername|De/[De]3/3-noun(both,both,[])|De/[De]3/4-propername|De/[De]3/5-propername|De/[De]3/6-propername|De/[De]3/7-propername|De/[De]3/8-propername|De/[De]4/5-propername|De/[De]4/6-propername|De/[De]4/7-propername|De/[De]4/8-propername|De/[De]5/6-propername|De/[De]5/7-propername|De/[De]6/7-propername|De/[De]6/8-propername|De/[De]7/8-propername|De/[De]8/9-propername|De/[De]9/10-propername|De/[De]determiner(de)|De/[de]1/2-adjective(both(adv))|De/[de]1/2-adjective(meer)|De/[de]1/2-determiner(de,nwh,mod,pro,yparg)|De/[de]1/2-determiner(het,nwh,nmod,pro,nparg,wkpro)|De/[de]1/2-fixedpart([de,baas])|De/[de]1/2-fixedpart([de,beest])|De/[de]1/2-fixedpart([de,benen])|De/[de]1/2-fixedpart([de,beurt])|De/[de]1/2-fixedpart([de,blits])|De/[de]1/2-fixedpart([de,deur])|De/[de]1/2-fixedpart([de,draak])|De/[de]1/2-fixedpart([de,hand])|De/[de]1/2-fixedpart([de,huid])|De/[de]1/2-fixedpart([de,kaas])|De/[de]1/2-fixedpart([de,keel])|De/[de]1/2-fixedpart([de,kneep])|De/[de]1/2-fixedpart([de,loef])|De/[de]1/2-fixedpart([de,loftrompet])|De/[de]1/2-fixedpart([de,longen])|De/[de]1/2-fixedpart([de,man])|De/[de]1/2-fixedpart([de,mantel])|De/[de]1/2-fixedpart([de,mond])|De/[de]1/2-fixedpart([de,neus])|De/[de]1/2-fixedpart([de,ogen])|De/[de]1/2-fixedpart([de,pest])|De/[de]1/2-fixedpart([de,ronde])|De/[de]1/2-fixedpart([de,schoen])|De/[de]1/2-fixedpart([de,show])|De/[de]1/2-fixedpart([de,smoor])|De/[de]1/2-fixedpart([de,strot])|De/[de]1/2-fixedpart([de,tijd])|De/[de]1/2-fixedpart([de,voet])|De/[de]1/2-noun(both,pl,[])|De/[de]1/2-noun(de,sg,[])|De/[de]1/2-noun(het,sg,[])|De/[de]1/2-np|De/[de]1/2-pronoun(nwh,inv,both,de,nom,def)|De/[de]1/2-pronoun(nwh,inv,sg,both,both,def)|De/[de]1/2-pronoun(nwh,thi,pl,de,both,def)|De/[de]1/2-pronoun(nwh,thi,sg,both,both,def)|De/[de]1/2-pronoun(nwh,thi,sg,de,both,def)|De/[de]1/2-propername|De/[de]1/2-tmpnp|De/[de]1/2-whadjective(odetadv)|De/[de]1/3-determiner(plnum,nwh,nmod,pro,yparg)|De/[de]1/3-propername|De/[de]1/3-sentenceadverb|De/[de]1/4-determiner(de)|De/[de]1/4-propername|De/[de]1/5-fixedpart([de,stuipen,op,het,lijf])|De/[de]1/5-propername|De/[de]1/6-propername|De/[de]1/7-propername|De/[de]2/10-propername|De/[de]2/2-prenumadv(plindef)|De/[de]2/2-propername|De/[de]2/2-skip|De/[de]2/3-adjective(e)|De/[de]2/3-adjective(pred(nonadv))|De/[de]2/3-adjective(pred(padv))|De/[de]2/3-adverb|De/[de]2/3-determiner(pron)|De/[de]2/3-fixedpart([aan,de,dag])|De/[de]2/3-fixedpart([aan,de,hand])|De/[de]2/3-fixedpart([aan,de,kaak])|De/[de]2/3-fixedpart([aan,de,leiding])|De/[de]2/3-fixedpart([aan,de,lippen])|De/[de]2/3-fixedpart([aan,de,man])|De/[de]2/3-fixedpart([aan,de,orde])|De/[de]2/3-fixedpart([aan,de,tand])|De/[de]2/3-fixedpart([aan,de,weet])|De/[de]2/3-fixedpart([aan,de,weg])|De/[de]2/3-fixedpart([achter,de,rug])|De/[de]2/3-fixedpart([als,de,dood])|De/[de]2/3-fixedpart([bij,de,keel])|De/[de]2/3-fixedpart([door,de,beugel])|De/[de]2/3-fixedpart([door,de,mand])|De/[de]2/3-fixedpart([in,de,aarde])|De/[de]2/3-fixedpart([in,de,arm])|De/[de]2/3-fixedpart([in,de,bedoeling])|De/[de]2/3-fixedpart([in,de,gaten])|De/[de]2/3-fixedpart([in,de,gelegenheid])|De/[de]2/3-fixedpart([in,de,haren])|De/[de]2/3-fixedpart([in,de,kaart])|De/[de]2/3-fixedpart([in,de,knoop])|De/[de]2/3-fixedpart([in,de,lijn])|De/[de]2/3-fixedpart([in,de,lucht])|De/[de]2/3-fixedpart([in,de,ogen])|De/[de]2/3-fixedpart([in,de,papieren])|De/[de]2/3-fixedpart([in,de,pas])|De/[de]2/3-fixedpart([in,de,rede])|De/[de]2/3-fixedpart([in,de,schoenen])|De/[de]2/3-fixedpart([in,de,smiezen])|De/[de]2/3-fixedpart([in,de,steek])|De/[de]2/3-fixedpart([in,de,wacht])|De/[de]2/3-fixedpart([in,de,war])|De/[de]2/3-fixedpart([in,de,weg])|De/[de]2/3-fixedpart([in,de,wind])|De/[de]2/3-fixedpart([naar,de,keel])|De/[de]2/3-fixedpart([naar,de,klote])|De/[de]2/3-fixedpart([naar,de,knoppen])|De/[de]2/3-fixedpart([onder,de,knie])|De/[de]2/3-fixedpart([onder,de,nagels])|De/[de]2/3-fixedpart([onder,de,neus])|De/[de]2/3-fixedpart([onder,de,riem])|De/[de]2/3-fixedpart([onder,de,voet])|De/[de]2/3-fixedpart([onderuit,de,zak])|De/[de]2/3-fixedpart([op,de,been])|De/[de]2/3-fixedpart([op,de,borst])|De/[de]2/3-fixedpart([op,de,kast])|De/[de]2/3-fixedpart([op,de,keel])|De/[de]2/3-fixedpart([op,de,knieën])|De/[de]2/3-fixedpart([op,de,koop])|De/[de]2/3-fixedpart([op,de,kop])|De/[de]2/3-fixedpart([op,de,korrel])|De/[de]2/3-fixedpart([op,de,loer])|De/[de]2/3-fixedpart([op,de,markt])|De/[de]2/3-fixedpart([op,de,nominatie])|De/[de]2/3-fixedpart([op,de,vingers])|De/[de]2/3-fixedpart([op,de,vlucht])|De/[de]2/3-fixedpart([over,de,brug])|De/[de]2/3-fixedpart([over,de,schreef])|De/[de]2/3-fixedpart([over,de,toonbank])|De/[de]2/3-fixedpart([tegen,de,borst])|De/[de]2/3-fixedpart([tot,de,lippen])|De/[de]2/3-fixedpart([uit,de,bus])|De/[de]2/3-fixedpart([uit,de,grond])|De/[de]2/3-fixedpart([uit,de,hand])|De/[de]2/3-fixedpart([uit,de,mond])|De/[de]2/3-fixedpart([uit,de,sloffen])|De/[de]2/3-fixedpart([uit,de,verf])|De/[de]2/3-fixedpart([uit,de,voeten])|De/[de]2/3-fixedpart([uit,de,weg])|De/[de]2/3-fixedpart([van,de,domme])|De/[de]2/3-fixedpart([van,de,hand])|De/[de]2/3-fixedpart([voor,de,dag])|De/[de]2/3-fixedpart([voor,de,deur])|De/[de]2/3-fixedpart([voor,de,geest])|De/[de]2/3-fixedpart([voor,de,ogen])|De/[de]2/3-fixedpart([voor,de,voeten])|De/[de]2/3-fixedpart([voor,de,wind])|De/[de]2/3-noun(both,pl,[])|De/[de]2/3-noun(both,sg,[])|De/[de]2/3-noun(de,sg,[])|De/[de]2/3-noun(het,sg,[])|De/[de]2/3-np|De/[de]2/3-number(hoofd(plnum))|De/[de]2/3-particle([in,de,plaats])|De/[de]2/3-pp|De/[de]2/3-propername|De/[de]2/3-sentenceadverb|De/[de]2/4-determiner(pron)|De/[de]2/4-eradverb([aan,de,hand,van])|De/[de]2/4-eradverb([aan,de,vooravond,van])|De/[de]2/4-fixedpart([in,de,koude,kleren])|De/[de]2/4-fixedpart([in,de,kouwe,kleren])|De/[de]2/4-fixedpart([op,de,koop,toe])|De/[de]2/4-fixedpart([op,de,lange,baan])|De/[de]2/4-noun(both,sg,[])|De/[de]2/4-noun(de,sg,[])|De/[de]2/4-noun(het,sg,[])|De/[de]2/4-preposition([aan,de,hand,van],[])|De/[de]2/4-preposition([aan,de,vooravond,van],[])|De/[de]2/4-preposition([bij,de,gratie,van],[])|De/[de]2/4-preposition([in,de,aanloop,naar],[])|De/[de]2/4-preposition([in,de,geest,van],[])|De/[de]2/4-preposition([in,de,hitte,van],[])|De/[de]2/4-preposition([in,de,loop,van],[])|De/[de]2/4-preposition([in,de,loop,van],[],tmpadv)|De/[de]2/4-preposition([in,de,persoon,van],[])|De/[de]2/4-propername|De/[de]2/4-sentenceadverb|De/[de]2/4-waaradverb([aan,de,hand,van])|De/[de]2/5-fixedpart([in,de,lijn,der,verwachting])|De/[de]2/5-fixedpart([in,de,lijn,der,verwachtingen])|De/[de]2/5-number(hoofd(plnum))|De/[de]2/5-propername|De/[de]2/6-number(hoofd(plnum))|De/[de]2/6-propername|De/[de]2/7-number(hoofd(plnum))|De/[de]2/7-propername|De/[de]2/8-propername|De/[de]2/9-propername|De/[de]3/10-propername|De/[de]3/3-propername|De/[de]3/4-determiner(de)|De/[de]3/4-determiner(pron)|De/[de]3/4-eradverb(voor)|De/[de]3/4-fixedpart([na,aan,de,schenen])|De/[de]3/4-noun(both,pl,[])|De/[de]3/4-noun(de,sg,[])|De/[de]3/4-noun(het,sg,[])|De/[de]3/4-np|De/[de]3/4-preposition(voor,[],extractednp)|De/[de]3/4-propername|De/[de]3/5-determiner(pron)|De/[de]3/5-modaladverb|De/[de]3/5-noun(de,sg,[])|De/[de]3/5-propername|De/[de]3/6-propername|De/[de]3/7-propername|De/[de]3/8-propername|De/[de]3/9-propername|De/[de]4/4-propername|De/[de]4/5-determiner(pron)|De/[de]4/5-fixedpart([drie,slagen,in,de,rondte])|De/[de]4/5-fixedpart([een,slag,in,de,rondte])|De/[de]4/5-noun(de,sg,[])|De/[de]4/5-propername|De/[de]4/6-noun(de,sg,[])|De/[de]4/6-propername|De/[de]4/7-propername|De/[de]4/8-propername|De/[de]4/9-propername|De/[de]5/10-propername|De/[de]5/6-noun(de,sg,[])|De/[de]5/6-number(hoofd(plnum))|De/[de]5/6-propername|De/[de]5/7-propername|De/[de]5/8-propername|De/[de]5/9-propername|De/[de]6/10-propername|De/[de]6/7-propername|De/[de]6/8-propername|De/[de]6/9-propername|De/[de]7/8-propername|De/[de]7/9-propername|De/[de]8/9-propername|De/[de]9/10-propername|De/[de]determiner(de)|De/[de]propername|De/[de]skip boot/[boot]noun(de,sg,[]) is/[is]1/4-propername|is/[is]1/7-propername|is/[is]2/2-determiner(pron)|is/[is]2/2-propername|is/[is]2/3-max|is/[is]2/3-propername|is/[is]2/3-sentenceadverb|is/[is]2/4-propername|is/[is]2/5-propername|is/[is]2/6-propername|is/[is]2/7-propername|is/[is]2/8-propername|is/[is]3/3-determiner(pron)|is/[is]3/3-propername|is/[is]3/4-propername|is/[is]3/5-max|is/[is]3/5-propername|is/[is]3/6-propername|is/[is]3/7-propername|is/[is]3/8-propername|is/[is]3/9-propername|is/[is]4/4-determiner(pron)|is/[is]4/4-propername|is/[is]4/5-propername|is/[is]4/6-propername|is/[is]4/7-propername|is/[is]5/5-propername|is/[is]5/6-propername|is/[is]5/7-propername|is/[is]6/6-propername|is/[is]6/6-sentenceadverb|is/[is]6/7-propername|is/[is]7/7-propername|is/[is]skip|is/[is]verb(sgheeft) zelfgemaakt/[zelfgemaakt]adjective(noe(nonadv))", tokenizer, tagger);        
-    //TestTools.myAssert("blablabla","blablabla/[blablabla]noun(both,both,[])", tokenizer, tagger);        
+    TestTools.myAssert("Dit is een Nederlandse zin om het programma'tje te testen.", "Dit/[dit]determiner(het,nwh,nmod,pro,nparg) is/[i]noun(both,pl,[])|is/[v_root(ben,zijn)]verb(sg_heeft) een/[een]determiner(een)|een/[een]fixed_part([een])|een/[een]pre_num_adv(pl_indef)|een/[één]pronoun(nwh,thi,sg,both,both,indef) Nederlandse/[Nederlands]adjective(e) zin/[zin]noun(de,sg,[])|zin/[zin]noun(de,sg,sbar)|zin/[zin]noun(de,sg,start_app_measure)|zin/[zin]noun(de,sg,van_sbar)|zin/[zin]noun(de,sg,vp)|zin/[v_root(zin,zinnen)]verb(sg1) om/[om]adjective(pred(nonadv))|om/[om]complementizer(om)|om/[om]particle(om)|om/[om]preposition(om,[heen]) het/[het]determiner(het,nwh,nmod,pro,nparg,wkpro) programma/[programma]noun(het,sg,[])|programma/[programma]noun(het,sg,app_measure) tje/[null]null te/[te]complementizer(te)|te/[te]intensifier|te/[te]me_intensifier|te/[te]preposition(te,[],nodet)|te/[te]vp_om_intensifier|te/[te]vp_om_me_intensifier testen/[test]noun(both,pl,[])|testen/[v_root(test,testen)]verb(inf)", tokenizer, tagger);        
+    TestTools.myAssert("zwijnden","zwijnden/[v_root(zwijn,zwijnen)]verb(past(pl))", tokenizer, tagger);        
   }
 
 }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Main.java
Patch:
@@ -125,6 +125,9 @@ void checkText(final String contents) throws IOException {
       msg = msg.replaceAll("<suggestion>", "'");
       msg = msg.replaceAll("</suggestion>", "'");
       System.out.println("Message: " + msg);
+      List repl = match.getSuggestedReplacements();
+      if (repl.size() > 0)
+        System.out.println("Suggestion: " + StringTools.listToString(repl, "; "));
       System.out.println(getContext(match.getFromPos(), match.getToPos(), contents));
       if (iter.hasNext())
         System.out.println();

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/de/CompoundRuleTest.java
Patch:
@@ -76,8 +76,9 @@ public void testRule() throws IOException {
     // also accept incorrect upper/lowercase spelling:
     check(1, "Spin Off", new String[]{"Spin-Off"});
     check(1, "CW Wert", new String[]{"CW-Wert"});
-    // TODO: detect an error if only some of the hyphens are missing:
-    //check(1, "Roll-on-roll-off Schiff");
+    // also detect an error if only some of the hyphens are missing:
+    check(1, "Roll-on-roll-off Schiff", new String[]{"Roll-on-roll-off-Schiff"});
+    check(1, "E-Mail Adressen", new String[]{"E-Mail-Adressen"});
   }
 
   private void check(int expectedErrors, String text) throws IOException {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/CompoundRule.java
Patch:
@@ -99,7 +99,7 @@ public RuleMatch[] match(final AnalyzedSentence text) {
         sb.append(" ");
         sb.append(atr.getToken());
         if (j >= 1) {
-          String stringtoCheck = sb.toString().trim();
+          String stringtoCheck = sb.toString().trim().toLowerCase();
           stringsToCheck.add(stringtoCheck);
           if (!stringToToken.containsKey(stringtoCheck))
             stringToToken.put(stringtoCheck, atr);
@@ -109,7 +109,7 @@ public RuleMatch[] match(final AnalyzedSentence text) {
       // iterate backwards over all potentially incorrect strings to make
       // sure we match longer strings first:
       for (int k = stringsToCheck.size()-1; k >= 0; k--) {
-        String stringToCheck = stringsToCheck.get(k).trim();
+        String stringToCheck = stringsToCheck.get(k).trim().toLowerCase();
         //System.err.println("##"+stringtoCheck+"#");
         if (incorrectCompounds.contains(stringToCheck)) {
           AnalyzedTokenReadings atr = stringToToken.get(stringToCheck);
@@ -178,7 +178,7 @@ private Set loadCompoundFile(final String filename, final String encoding) throw
           throw new IOException("Too many compound parts: " + line + ", maximum allowed: " + MAX_TERMS);
         if (parts.length == 1)
           throw new IOException("Not a compound: " + line);
-        words.add(line);
+        words.add(line.toLowerCase());
       }
     } finally {
       if (br != null) br.close();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/Main.java
Patch:
@@ -363,7 +363,7 @@ static String getParagraphContent(Object para) throws NoSuchElementException, Wr
       Object textPortion = portionEnum.nextElement();
       XPropertySet textProps = (XPropertySet) UnoRuntime.queryInterface(XPropertySet.class, textPortion);
       String type = (String)textProps.getPropertyValue("TextPortionType");
-      if ("Footnote".equals(type)) {
+      if ("Footnote".equals(type) || "DocumentIndexMark".equals(type)) {
         // a footnote reference appears as one character in the text. we don't use a whitespace
         // because we don't want to trigger the "no whitespace before comma" rule in this case:
         // my footnote¹, foo bar

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/JLanguageTool.java
Patch:
@@ -150,7 +150,7 @@ public JLanguageTool(Language language, Language motherTongue, File basedirArg)
         new DoublePunctuationRule(messages),
         new UppercaseSentenceStartRule(messages),
         // English:
-        new AvsAnRule(messages),
+        new AvsAnRule(messages),        
         // German:
         new WordCoherencyRule(messages),
         new CaseRule(messages),

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tagging/en/EnglishTaggerTest.java
Patch:
@@ -42,8 +42,8 @@ public void setUp() {
 
   public void testTagger() throws IOException {
     myAssert("This is a big house.", "This/[this]DT|This/[this]PDT is/[be]VBZ a/[a]DT big/[big]JJ|big/[big]VB|big/[big]VBP house/[house]NN|house/[house]VB|house/[house]VBP");
-    myAssert("Marketing do a lot of trouble.", "Marketing/[marketing]NN:U|Marketing/[market]VBG do/[do]VB|do/[do]VBP a/[a]DT lot/[lot]JJ|lot/[lot]NN|lot/[lot]VB|lot/[lot]VBP of/[of]IN trouble/[trouble]NN:UN|trouble/[trouble]VB|trouble/[trouble]VBP");
-    myAssert("Manager use his laptop every day.", "Manager/[manager]NN use/[use]NN:UN|use/[use]VB|use/[use]VBP his/[his]PRP$|his/[hi]NNS laptop/[laptop]NN every/[every]DT day/[day]NN");
+    myAssert("Marketing do a lot of trouble.", "Marketing/[marketing]NN:U|Marketing/[market]VBG do/[do]VB|do/[do]VBP a/[a]DT lot/[lot]JJ|lot/[lot]NN:UN|lot/[lot]VB|lot/[lot]VBP of/[of]IN trouble/[trouble]NN:UN|trouble/[trouble]VB|trouble/[trouble]VBP");
+    myAssert("Manager use his laptop every day.", "Manager/[manager]NN use/[use]NN:UN|use/[use]VB|use/[use]VBP his/[his]PRP$|his/[hi]NNS laptop/[laptop]NN every/[every]DT day/[day]NN:UN");
     myAssert("This is a bigger house.", "This/[this]DT|This/[this]PDT is/[be]VBZ a/[a]DT bigger/[big]JJR house/[house]NN|house/[house]VB|house/[house]VBP");
     myAssert("He doesn't believe me.", "He/[he]PRP doesn/[do]VBZ t/[t]JJ|t/[t]NN|t/[t]RB believe/[believe]VB|believe/[believe]VBP me/[I]PRP");
     myAssert("It has become difficult.", "It/[it]PRP has/[have]VBZ become/[become]VB|become/[become]VBN|become/[become]VBP difficult/[difficult]JJ"); 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/UppercaseSentenceStartRule.java
Patch:
@@ -63,8 +63,8 @@ public RuleMatch[] match(final AnalyzedSentence text) {
     char firstChar = firstToken.charAt(0);
     if (Character.isLowerCase(firstChar)) {
       String msg = messages.getString("incorrect_case");
-      RuleMatch ruleMatch = new RuleMatch(this, token.getStartPos(), 
-          token.getStartPos()+token.getToken().length(), msg);
+      RuleMatch ruleMatch = new RuleMatch(this, tokens[1].getStartPos(), 
+          tokens[1].getStartPos()+tokens[1].getToken().length(), msg);
       ruleMatch.setSuggestedReplacement(Character.toUpperCase(firstChar) +  firstToken.substring(1));
       ruleMatches.add(ruleMatch);
     }
@@ -74,4 +74,4 @@ public RuleMatch[] match(final AnalyzedSentence text) {
   public void reset() {
   }
 
-}
+}
\ No newline at end of file

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Language.java
Patch:
@@ -81,7 +81,7 @@ public class Language {
    * @param shortLanguageCode e.g. <code>en</code> or <code>de</code>
    * @return a Language object or <code>null</code>
    */
-  public static Language getLanguageforShortName(String shortLanguageCode) {
+  public static Language getLanguageForShortName(String shortLanguageCode) {
     if (shortLanguageCode == null)
       throw new NullPointerException("Language code cannot be null");
     for (int i = 0; i < Language.LANGUAGES.length; i++) {
@@ -98,7 +98,7 @@ public static Language getLanguageforShortName(String shortLanguageCode) {
    * @param languageName e.g. <code>English</code> or <code>German</code>
    * @return a Language object or <code>null</code>
    */
-  public static Language getLanguageforName(String languageName) {
+  public static Language getLanguageForName(String languageName) {
     for (int i = 0; i < Language.LANGUAGES.length; i++) {
       if (languageName.equals(Language.LANGUAGES[i].getName())) {
         return Language.LANGUAGES[i];

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/Configuration.java
Patch:
@@ -88,7 +88,7 @@ private void loadConfiguration() throws IOException {
       }
       String motherTongueStr = (String)props.get(MOTHER_TONGUE_CONFIG_KEY);
       if (motherTongueStr != null) {
-        motherTongue = Language.getLanguageforShortName(motherTongueStr);
+        motherTongue = Language.getLanguageForShortName(motherTongueStr);
       }
     } catch (FileNotFoundException e) {
       // file not found: okay, leave disabledRuleIds empty

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/Main.java
Patch:
@@ -256,7 +256,7 @@ void quit() {
 
   private Language getCurrentLanguage() {
     String langName = langBox.getSelectedItem().toString();
-    return Language.getLanguageforName(langName);
+    return Language.getLanguageForName(langName);
   }
   
   private ConfigurationDialog getCurrentConfigDialog() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/Main.java
Patch:
@@ -187,7 +187,7 @@ private Language getLanguage() {
       } catch (WrappedTargetException e) {
         throw new RuntimeException(e);
       }
-      return Language.getLanguageforShortName(charLocale.Language);
+      return Language.getLanguageForShortName(charLocale.Language);
     }
     
     private TextToCheck getText() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/FalseFriendRuleLoader.java
Patch:
@@ -174,7 +174,7 @@ public void startElement(String namespaceURI, String lName, String qName, Attrib
 	  } else if (qName.equals("pattern")) {
 		  inPattern = true;
 		  String languageStr = attrs.getValue("lang");
-		  language = Language.getLanguageforShortName(languageStr);
+		  language = Language.getLanguageForShortName(languageStr);
 		  if (language == null) {
 			  throw new SAXException("Unknown language '" + languageStr + "'");
 		  }
@@ -242,7 +242,7 @@ public void startElement(String namespaceURI, String lName, String qName, Attrib
 	  } else if (qName.equals("translation")) {
 		  inTranslation = true;
 		  String languageStr = attrs.getValue("lang");
-      Language tmpLang = Language.getLanguageforShortName(languageStr);
+      Language tmpLang = Language.getLanguageForShortName(languageStr);
       currentTranslationLanguage = tmpLang;
       if (tmpLang == motherTongue) {
         translationLanguage = tmpLang;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -118,7 +118,7 @@ public void startElement(String namespaceURI, String lName, String qName, Attrib
         category = new Category(catName);
     } else if (qName.equals("rules")) {
       String languageStr = attrs.getValue("lang");
-      language = Language.getLanguageforShortName(languageStr);
+      language = Language.getLanguageForShortName(languageStr);
       if (language == null) {
         throw new SAXException("Unknown language '" + languageStr + "'");
       }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/pl/PolishWordRepeatRule.java
Patch:
@@ -94,8 +94,8 @@ public RuleMatch[] match(AnalyzedSentence text) {
                 }
                                        		    
 	        }
-	        
-	        if (Pattern.matches("nie|&quot|&gt|&lt|&amp|[0-9]+", tokens[i].getToken())) {
+	        // Roman numbers regexp added
+	        if (Pattern.matches("nie|&quot|&gt|&lt|&amp|[0-9].*|M*(D?C{0,3}|C[DM])(L?X{0,3}|X[LC])(V?I{0,3}|I[VX])$", tokens[i].getToken())) {
 	        	isWord = false;
 	        }
 	        

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Language.java
Patch:
@@ -60,7 +60,7 @@ public class Language {
   private String name;
   private String shortForm;
   private Tagger tagger;
-  private Tokenizer sentenceTokenizer;
+  private SentenceTokenizer sentenceTokenizer;
   private Tokenizer wordTokenizer;
   private Locale locale;
 
@@ -102,7 +102,7 @@ public static Language getLanguageforName(String languageName) {
     return null;
   }
 
-  private Language(String name, String shortForm, Locale locale, Tagger tagger, Tokenizer sentenceTokenizer,
+  private Language(String name, String shortForm, Locale locale, Tagger tagger, SentenceTokenizer sentenceTokenizer,
       Tokenizer wordTokenizer) {
     this.name = name;
     this.shortForm = shortForm;
@@ -137,7 +137,7 @@ public Tagger getTagger() {
     return tagger;
   }
 
-  public Tokenizer getSentenceTokenizer() {
+  public SentenceTokenizer getSentenceTokenizer() {
     return sentenceTokenizer;
   }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/pl/PolishWordRepeatRule.java
Patch:
@@ -80,7 +80,7 @@ public RuleMatch[] match(AnalyzedSentence text) {
 	        	}
            //too many false alarms here:     
                 String lemma = tokens[i].getAnalyzedToken(k).getLemma();
-                if (Pattern.matches("to|siebie|być|ani|albo|czy|bądź", lemma)) {
+                if (Pattern.matches("to|siebie|być|ani|albo|czy|bądź|zł|coraz|bardzo|ten|jak|mln|tys|swój|mój|twój|nasz|wasz|i", lemma)) {
                     isWord = false;
                     break;
                  }
@@ -95,7 +95,7 @@ public RuleMatch[] match(AnalyzedSentence text) {
                                        		    
 	        }
 	        
-	        if (tokens[i].getToken().equals("nie")) {
+	        if (Pattern.matches("nie|&quot|&gt|&lt|&amp|[0-9]+", tokens[i].getToken())) {
 	        	isWord = false;
 	        }
 	        

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/pl/PolishWordRepeatRule.java
Patch:
@@ -80,7 +80,7 @@ public RuleMatch[] match(AnalyzedSentence text) {
 	        	}
            //too many false alarms here:     
                 String lemma = tokens[i].getAnalyzedToken(k).getLemma();
-                if (Pattern.matches("to|siebie|być", lemma)) {
+                if (Pattern.matches("to|siebie|być|ani|albo|czy|bądź", lemma)) {
                     isWord = false;
                     break;
                  }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/SentenceTokenizer.java
Patch:
@@ -104,7 +104,7 @@ public class SentenceTokenizer implements Tokenizer {
       //Polish:
       "np", "p.n.e", "m.in", "itd", "itp", "pt","cdn", "czyt", "dyr","hab",
       "inż","jw", "lek","n.e","nb","rys", "tj", "tzw", "tzn", "zob" , "ds", "ang",
-      "ul", "pl", "al", "prof", "gen", "k", "n", "ks", "ok", "tys", "r"
+      "ul", "pl", "al", "prof", "gen", "k", "n", "ks", "ok", "tys", "r", "proc"
   };
 
   // einige deutsche Monate, vor denen eine Zahl erscheinen kann,

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tagging/en/EnglishTaggerTest.java
Patch:
@@ -41,6 +41,8 @@ public void setUp() {
 
   public void testTagger() {
     myAssert("This is a big house.", "This/DT is/VBZ a/DT big/JJ house/NN");
+    //clearly a bug in the tagger: "use" is not "preposition/subordinate conjunction"
+    myAssert("Manager use his laptop every day.", "Manager/NN use/IN his/PRP$ laptop/NN every/DT day/NN");
     myAssert("This is a bigger house.", "This/DT is/VBZ a/DT bigger/JJR house/NN");
     myAssert("He doesn't believe me.", "He/PRP doesn/VBZ t/RB believe/VBP me/PRP");
   }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Element.java
Patch:
@@ -52,8 +52,7 @@ public class Element {
   int skip = 0;
 
   boolean match(AnalyzedToken token) {
-    return (matchStringToken(token) != negation) && (matchPosToken(token) != posNegation)
-        && !exceptionMatch(token);
+    return (matchStringToken(token) != negation) && (matchPosToken(token) != posNegation);
   }
 
   boolean exceptionMatch(AnalyzedToken token) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/Main.java
Patch:
@@ -324,7 +324,7 @@ private void checkTextAndDisplayResults(JLanguageTool langTool, String langName)
 
   private int checkText(JLanguageTool langTool, String text, StringBuilder sb) throws IOException {
     long startTime = System.currentTimeMillis();
-    List<RuleMatch> ruleMatches = langTool.check(text);
+    List<RuleMatch> ruleMatches = langTool.check(StringTools.escapeHTML(text));
     long startTimeMatching = System.currentTimeMillis();
     int i = 0;
     for (RuleMatch match : ruleMatches) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/Tools.java
Patch:
@@ -59,8 +59,6 @@ public static String getContext(int fromPos, int toPos, String fileContents, int
       endContent = fileContents.length();
     }
     // make "^" marker. inefficient but robust implementation:
-    //FIXME: this is buggy, does not include lengths of HTML entities
-    //see what happens with a string: This is an "example" of of.
     StringBuilder marker = new StringBuilder();
     for (int i = 0; i < fileContents.length() + prefix.length(); i++) {
       if (i >= fromPos && i < toPos)

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/Tools.java
Patch:
@@ -59,6 +59,8 @@ public static String getContext(int fromPos, int toPos, String fileContents, int
       endContent = fileContents.length();
     }
     // make "^" marker. inefficient but robust implementation:
+    //FIXME: this is buggy, does not include lengths of HTML entities
+    //see what happens with a string: This is an "example" of of.
     StringBuilder marker = new StringBuilder();
     for (int i = 0; i < fileContents.length() + prefix.length(); i++) {
       if (i >= fromPos && i < toPos)
@@ -70,8 +72,8 @@ public static String getContext(int fromPos, int toPos, String fileContents, int
     StringBuilder sb = new StringBuilder();
     sb.append(prefix);
     sb.append(fileContents.substring(startContent, endContent));
-    sb.append(postfix);
     String markerStr = markerPrefix + marker.substring(startContent, endContent);
+    sb.append(postfix);
     int startMark = markerStr.indexOf("^");
     int endMark = markerStr.lastIndexOf("^");
     String result = sb.toString();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/Main.java
Patch:
@@ -202,6 +202,8 @@ private TextToCheck getText() {
         (XTextViewCursorSupplier)UnoRuntime.queryInterface(XTextViewCursorSupplier.class, xController); 
       //XTextViewCursor xViewCursor = xViewCursorSupplier.getViewCursor();
       xViewCursor = xViewCursorSupplier.getViewCursor();
+      //FIXME: getString gets only 64K of text
+      //should switch to text enumeration
       String textToCheck = xViewCursor.getString();     // user's current selection
       boolean selection = true;
       if (textToCheck.equals("")) {     // no selection = check complete text

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/pl/PolishWordRepeatRule.java
Patch:
@@ -24,7 +24,7 @@ public class PolishWordRepeatRule extends PolishRule {
 
   public PolishWordRepeatRule(ResourceBundle messages) {
     if (messages != null)
-      super.setCategory(new Category(messages.getString("category_case")));
+      super.setCategory(new Category(messages.getString("category_misc")));
   }
   
 	/* (non-Javadoc)

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/FalseFriendRuleLoader.java
Patch:
@@ -170,7 +170,6 @@ public void startElement(String namespaceURI, String lName, String qName, Attrib
 		  correctExamples = new ArrayList<String>();
 		  incorrectExamples = new ArrayList<String>();
 	  } else if (qName.equals("pattern")) {
-		  pattern = new StringBuffer();
 		  inPattern = true;
 		  String languageStr = attrs.getValue("lang");
 		  language = Language.getLanguageforShortName(languageStr);
@@ -274,7 +273,7 @@ public void endElement(String namespaceURI, String sName, String qName) {
 			  };
 			  String description = formatter.format(messageArguments);
 			  PatternRule rule = new PatternRule(id, language, elementList, 
-					  messages.getString("false_friend_desc") + " " + pattern.toString(),
+					  messages.getString("false_friend_desc") + " " + elements.toString().replace('|', '/'),
 					  description);
 			  rule.setCorrectExamples(correctExamples);
 			  rule.setIncorrectExamples(incorrectExamples);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -128,7 +128,6 @@ public void startElement(String namespaceURI, String lName, String qName, Attrib
       correctExamples = new ArrayList<String>();
       incorrectExamples = new ArrayList<String>();
     } else if (qName.equals("pattern")) {
-      pattern = new StringBuffer();
       inPattern = true;
       if (attrs.getValue("mark_from") != null)
         startPositionCorrection = Integer.parseInt(attrs.getValue("mark_from"));

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/XMLRuleHandler.java
Patch:
@@ -29,7 +29,6 @@ class XMLRuleHandler extends DefaultHandler {
 
   List<PatternRule> rules = new ArrayList<PatternRule>();
 
-  StringBuffer pattern = null;
   StringBuffer correctExample = new StringBuffer();
   StringBuffer incorrectExample = new StringBuffer();
   StringBuffer message = new StringBuffer();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/Main.java
Patch:
@@ -261,7 +261,7 @@ private void checkTextAndDisplayResults(JLanguageTool langTool, String langName)
       textArea.setText("Please insert text to check here");
     } else {
       StringBuilder sb = new StringBuilder();
-      resultArea.setText("Starting check...<br>\n");
+      resultArea.setText(HTML_FONT_START + "Starting check in "+langName+"...<br>\n" + HTML_FONT_END);
       resultArea.repaint(); // FIXME: why doesn't this work?
       //TODO: resultArea.setCursor(new Cursor(Cursor.WAIT_CURSOR)); 
       sb.append("Starting check in " +langName+ "...<br>\n");

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/CommaWhitespaceRule.java
Patch:
@@ -72,7 +72,7 @@ public RuleMatch[] match(AnalyzedSentence text) {
           suggestionText = ")";
           fixLen = 1;
     		} else if (prevToken.trim().equals(",") && !token.trim().equals("") &&
-    				!token.equals("'") && !token.equals("\"") && !token.matches(".*\\d.*")) {
+    				!token.equals("'") && !token.equals("\"") && !token.matches(".*\\d.*") && !token.equals("-")) {
     			msg = messages.getString("missing_space_after_comma");
           suggestionText = ", ";
     		} else if (token.trim().equals(",") && prevToken.trim().equals("")) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/WordRepeatRule.java
Patch:
@@ -23,7 +23,6 @@
 import java.util.ResourceBundle;
 
 import de.danielnaber.languagetool.AnalyzedSentence;
-//import de.danielnaber.languagetool.AnalyzedToken;
 import de.danielnaber.languagetool.AnalyzedTokenReadings;
 import de.danielnaber.languagetool.Language;
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/WordCoherencyRule.java
Patch:
@@ -37,7 +37,7 @@
 /**
  * A rule that matches words for which two different spellings are used
  * throughout the document. Currently only implemented for German. Loads
- * the relavant word from <code>rules/de/coherency.txt</code>.
+ * the relevant word from <code>rules/de/coherency.txt</code>.
  * 
  * <p>Note that this should not be used for language variations like
  * American English vs. British English or German "alte Rechtschreibung"

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/de/AnalyzedGermanToken.java
Patch:
@@ -130,10 +130,11 @@ public Genus getGenus() {
   }
 
   public String toString() {
+    String typeStr = makeReadableString(type);
     String casusStr = makeReadableString(casus);
     String numerusStr = makeReadableString(numerus);
     String genusStr = makeReadableString(genus);
-    return type + "/" + casusStr + "/" + numerusStr + "/" + genusStr;
+    return typeStr + "/" + casusStr + "/" + numerusStr + "/" + genusStr;
   }
   
   private String makeReadableString(Object obj) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRule.java
Patch:
@@ -30,7 +30,7 @@
 import de.danielnaber.languagetool.tools.StringTools;
 
 /**
- * A Rule that drescribes a language error as a simple pattern of words or their part-of-speech
+ * A Rule that describes a language error as a simple pattern of words or of part-of-speech
  * tags.
  * 
  * @author Daniel Naber

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/DashRule.java
Patch:
@@ -26,7 +26,7 @@
 import de.danielnaber.languagetool.rules.RuleMatch;
 
 /**
- * Prüft, dass in Bindestrich-Komposita kein Leerzeichen eingefügt wird (wie z.B. in 'Diäten- Erhöhung').
+ * Pr&uuml;ft, dass in Bindestrich-Komposita kein Leerzeichen eingef&uuml;gt wird (wie z.B. in 'Di&auml;ten- Erh&ouml;hung').
  *   
  * @author Daniel Naber
  */
@@ -60,7 +60,8 @@ public RuleMatch[] match(AnalyzedSentence text) {
             String msg = "Möglicherweise fehlt ein 'und' oder es wurde nach dem Wort " +
                     "ein überflüssiges Leerzeichen eingefügt.";
             RuleMatch ruleMatch = new RuleMatch(this, tokens[i-1].getStartPos(),
-                tokens[i-1].getStartPos()+prevToken.length(), msg);
+                tokens[i-1].getStartPos()+prevToken.length()+1, msg);
+            ruleMatch.setSuggestedReplacement(tokens[i-1].getToken());
             ruleMatches.add(ruleMatch);
           }
         }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/de/GermanToken.java
Patch:
@@ -36,6 +36,7 @@ public static class POSType {
     public static final POSType DETERMINER = new POSType("Determiner");
     public static final POSType PRONOMEN = new POSType("Pronomen");
     public static final POSType PARTIZIP = new POSType("Partizip");
+    public static final POSType PROPER_NOUN = new POSType("Eigenname");
     public static final POSType OTHER = new POSType("Other");      // e.g. sentence start
 
     private String name;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/AnalyzedSentence.java
Patch:
@@ -62,7 +62,7 @@ public AnalyzedTokenReadings[] getTokensWithoutWhitespace() {
   public String toString() {
     StringBuffer sb = new StringBuffer();
     for (int i = 0; i < tokens.length; i++) {
-      for (int j = 0; j < tokens[i].getReadingslength(); j++) {
+      for (int j = 0; j < tokens[i].getReadingsLength(); j++) {
       if (JLanguageTool.SENTENCE_START_TAGNAME.equals(tokens[i].getAnalyzedToken(j).getPOSTag())) {
         sb.append("<S>");
       } else if (tokens[i].getAnalyzedToken(j) != null && tokens[i].getAnalyzedToken(j).getPOSTag() == null && !(tokens[i] instanceof AnalyzedGermanTokenReadings)) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -56,7 +56,7 @@ public String getToken(){
 		return token;
 	}
 	
-	public int getReadingslength() {
+	public int getReadingsLength() {
 		return ATreadings.length;
 	}
 	

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRule.java
Patch:
@@ -167,7 +167,7 @@ public RuleMatch[] match(AnalyzedSentence text) {
     		}
     		for (int m = nextPos; m <= nextPos+prevSkipNext; m++) {    			
     			boolean Match = false;    			
-    			for (int l = 0; l < tokens[m].getReadingslength(); l++) {
+    			for (int l = 0; l < tokens[m].getReadingsLength(); l++) {
     				
     				AnalyzedToken matchToken = tokens[m].getAnalyzedToken(l);
     				// Logical OR (cannot be AND):

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRule.java
Patch:
@@ -202,6 +202,7 @@ public RuleMatch[] match(AnalyzedSentence text) {
     	}
     	if (allElementsMatch) {
     		String errMessage = message;
+    		//TODO: implement skipping tokens while marking error tokens
     		// replace back references like \1 in message:
     		for (int j = 0; j < matchingTokens; j++) {
     			errMessage = errMessage.replaceAll("\\\\" + (j + 1), tokens[firstMatchToken + j]

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/SentenceTokenizer.java
Patch:
@@ -100,7 +100,7 @@ public class SentenceTokenizer implements Tokenizer {
       "vs", "wg", "Hd", "Ztr", "zus", "Zus", "zzt", "zz", "Zz", "Zt",
       //Polish:
       "np", "p.n.e", "m.in", "itd", "itp", "pt","cdn", "czyt", "dyr","hab",
-      "inż","jw", "lek","n.e","nb","rys" 
+      "inż","jw", "lek","n.e","nb","rys", "tj", "tzw", "zob" 
   };
 
   // einige deutsche Monate, vor denen eine Zahl erscheinen kann,

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRule.java
Patch:
@@ -158,17 +158,18 @@ public RuleMatch[] match(AnalyzedSentence text) {
     		 }
     		 //FIXME: this could give bad results with one Polish rule
     		 //need to implement lemma matching
+    		 
     		 for (int l = 0; l < tokens[nextPos].getReadingslength(); l++) {
-    			 //boolean Match = false;
     			 AnalyzedToken matchToken = tokens[nextPos].getAnalyzedToken(l);
+    			 //Logical OR (cannot be AND):
     			 if (!elem.match(matchToken) && allElementsMatch) {
     				 allElementsMatch = false;
     			 }
     			 else {
     				 allElementsMatch = true;
     			 }
     		 }
-        if (!allElementsMatch) {
+    		 if (!allElementsMatch) {
           break;
         } else {
           matchingTokens++;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/AnalyzedTokenReadings.java
Patch:
@@ -20,7 +20,7 @@
 package de.danielnaber.languagetool;
 
 /**
- * An array of (@link AnalyzedToken) used to store multiple POS tags and lemmas
+ * An array of {@link AnalyzedToken}s used to store multiple POS tags and lemmas
  * for a given single token.
  * 
  * @author Marcin Milkowski

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/DashRule.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.List;
 
 import de.danielnaber.languagetool.AnalyzedSentence;
-import de.danielnaber.languagetool.AnalyzedToken;
+import de.danielnaber.languagetool.AnalyzedTokenReadings;
 import de.danielnaber.languagetool.rules.RuleMatch;
 
 /**
@@ -45,7 +45,7 @@ public String getDescription() {
 
   public RuleMatch[] match(AnalyzedSentence text) {
     List ruleMatches = new ArrayList();
-    AnalyzedToken[] tokens = text.getTokensWithoutWhitespace();
+    AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();
     int pos = 0;
     String prevToken = null;
     for (int i = 0; i < tokens.length; i++) {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/WiederVsWiderRule.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.List;
 
 import de.danielnaber.languagetool.AnalyzedSentence;
-import de.danielnaber.languagetool.AnalyzedToken;
+import de.danielnaber.languagetool.AnalyzedTokenReadings;
 import de.danielnaber.languagetool.rules.RuleMatch;
 
 /**
@@ -46,7 +46,7 @@ public String getDescription() {
 
   public RuleMatch[] match(AnalyzedSentence text) {
     List ruleMatches = new ArrayList();
-    AnalyzedToken[] tokens = text.getTokens();
+    AnalyzedTokenReadings[] tokens = text.getTokens();
     int pos = 0;
     boolean foundSpiegelt = false;
     boolean foundWieder = false;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/XMLRuleHandler.java
Patch:
@@ -33,6 +33,7 @@ class XMLRuleHandler extends DefaultHandler {
   StringBuffer correctExample = new StringBuffer();
   StringBuffer incorrectExample = new StringBuffer();
   StringBuffer message = new StringBuffer();
+  StringBuffer elements = null;
 
   List correctExamples = new ArrayList();
   List incorrectExamples = new ArrayList();
@@ -41,7 +42,8 @@ class XMLRuleHandler extends DefaultHandler {
   boolean inCorrectExample = false;
   boolean inIncorrectExample = false;
   boolean inMessage = false;
-  boolean inRuleGroup = false;  
+  boolean inRuleGroup = false;
+  boolean inToken= false;
 
   List getRules() {
     return rules;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/Tagger.java
Patch:
@@ -33,7 +33,7 @@ public interface Tagger {
    * Returns a list of {@link AnalyzedToken}s that assigns each term in the 
    * sentence some kind of part-of-speech information (not necessarily just one tag).
    * 
-   * <p>Note that this mehtod takes exactly one sentence. Its implementation
+   * <p>Note that this method takes exactly one sentence. Its implementation
    * may implement special cases for the first word of a sentence, which is 
    * usually written with an uppercase letter.
    * 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/de/GermanTagger.java
Patch:
@@ -56,6 +56,7 @@ public AnalyzedGermanToken lookup(String word, int startPos) throws IOException
   }
   
   private AnalyzedGermanToken lookup(String word, int startPos, boolean makeLowercase) throws IOException {
+	
     initSearcher();
     Term term = null;
     if (makeLowercase)
@@ -122,7 +123,7 @@ public List tag(List tokens) throws IOException {
   }
 
   public Object createNullToken(String token, int startPos) {
-    return new AnalyzedGermanToken(token, null, startPos);
+  	return new AnalyzedGermanToken(token, null, startPos);
   }
   
   private void initSearcher() throws IOException {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/Main.java
Patch:
@@ -200,6 +200,8 @@ private String getText() {
         textToCheck = text.getString();
         xViewCursor = null;
       }
+      // without this replacement selecting the error on Windows will not work correctly:
+      textToCheck = textToCheck.replaceAll("\r\n", "\n");
       return textToCheck;
     }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/FalseFriendRuleLoader.java
Patch:
@@ -154,9 +154,9 @@ public void endElement(String namespaceURI, String sName, String qName) {
         formatter.applyPattern(messages.getString("false_friend_hint"));
         Object[] messageArguments = {
           pattern,
-          textLanguage.getName(),
+          textLanguage.getShortName(),
           translation,
-          motherTongue.getName()
+          motherTongue.getShortName()
         };
         String description = formatter.format(messageArguments);
         String rulePattern = makeRulePattern(pattern.toString());

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/en/EnglishTagger.java
Patch:
@@ -66,6 +66,9 @@ public List tag(List tokens) {
       if (nextAnalyzedToken != null) {
         analyzedTokens.add(nextAnalyzedToken);
         nextAnalyzedToken = null;
+      } else if (token.equals("doesn") && "t".equals(nextToken)) {
+        analyzedTokens.add(new AnalyzedToken(token, "VBZ", 0));
+        nextAnalyzedToken = new AnalyzedToken(nextToken, "RB", 0);
       } else if (token.equals("don") && "t".equals(nextToken)) {
         analyzedTokens.add(new AnalyzedToken(token, "VBP", 0));
         nextAnalyzedToken = new AnalyzedToken(nextToken, "RB", 0);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/UppercaseSentenceStartRule.java
Patch:
@@ -42,7 +42,7 @@ public String getId() {
   }
 
   public String getDescription() {
-    return messages.getString("desc_double_punct");
+    return messages.getString("desc_uppercase_sentence");
   }
 
   public Language[] getLanguages() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/CommaWhitespaceRule.java
Patch:
@@ -43,7 +43,7 @@ public String getId() {
   }
 
   public String getDescription() {
-    return messages.getString("desc_comman_whitespace");
+    return messages.getString("desc_comma_whitespace");
   }
 
   public Language[] getLanguages() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tools/Morphy2Lucene.java
Patch:
@@ -19,6 +19,7 @@
 package de.danielnaber.languagetool.tools;
 
 import java.io.BufferedReader;
+import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStreamReader;
@@ -48,7 +49,8 @@ public class Morphy2Lucene {
   
   // if no category is known for a word's reading, use this one: 
   private static final String DEFAULT_CATEGORY = "0";
-  private static final String INDEX_DIR = "rules/de/categories";
+  private static final String INDEX_DIR = "resource" +File.separator+ "de"
+    +File.separator+ "categories";
   //private static final String IS_BASEFORM = "is_baseform";
 
   private final static Map manualMapping = new HashMap();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/openoffice/OOoDialog.java
Patch:
@@ -65,7 +65,7 @@
 
 public class OOoDialog implements ActionListener {
 
-  private final static String CHANGE_BUTTON = "Change";
+  private static final String CHANGE_BUTTON = "Change";
   private static final String IGNORE_BUTTON = "Ignore";
   private static final String IGNORE_ALL_BUTTON = "Ignore All";
   private static final String OPTIONS_BUTTON = "Options...";

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/JLanguageTool.java
Patch:
@@ -196,13 +196,13 @@ public void enableRule(String ruleId) {
    * The main check method. Tokenizes the text into sentences and matches these
    * sentences against all currently active rules.
    * 
-   * @param test the text to check
+   * @param text the text to check
    * @return a List of {@link RuleMatch} objects
    * @throws IOException 
    */
-  public List check(String test) throws IOException {
+  public List check(String text) throws IOException {
     SentenceTokenizer sTokenizer = new SentenceTokenizer();
-    List sentences = sTokenizer.tokenize(test);
+    List sentences = sTokenizer.tokenize(text);
     List ruleMatches = new ArrayList();
     List allRules = getAllRules();
     printIfVerbose(allRules.size() + " rules activated for language " + language);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tagging/de/GermanTagger.java
Patch:
@@ -36,7 +36,7 @@
 import de.danielnaber.languagetool.tagging.Tagger;
 
 /**
- * Experimental German tagger, requires data files in <code>rules/de/categories</code>.
+ * Experimental German tagger, requires data files in <code>resource/de/categories</code>.
  * 
  * @author Daniel Naber
  */
@@ -102,7 +102,6 @@ private AnalyzedGermanToken lookup(String word, int startPos, boolean makeLowerc
   
   public List tag(List tokens) throws IOException {
     initSearcher();
-
     List posTags = new ArrayList();
     int pos = 0;
     boolean firstWord = true;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Main.java
Patch:
@@ -176,7 +176,7 @@ private String getContext(int fromPos, int toPos, String fileContents) {
 
   private static void exitWithUsageMessagee() {
     System.out.println("Usage: java de.danielnaber.languagetool.Main " +
-            "[-h|--help] [-r|--recursive] [-v|--verbose] [-l|--language=LANG] [-d|--disable=RULES] <file>");
+            "[-r|--recursive] [-v|--verbose] [-l|--language LANG] [-d|--disable RULES] <file>");
     System.exit(1);
   }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/WiederVsWiderRule.java
Patch:
@@ -41,7 +41,7 @@ public String getId() {
   }
 
   public String getDescription() {
-    return "'wider' vs. 'wieder' in 'spiegeln .. wider'";
+    return "'wider' vs. 'wieder' in 'spiegeln ... wider'";
   }
 
   public RuleMatch[] match(AnalyzedSentence text) {
@@ -67,6 +67,7 @@ public RuleMatch[] match(AnalyzedSentence text) {
           String msg = "<i>wider</i> in <i>widerspiegeln</i> wird mit <i>i</i> statt mit <i>ie</i> "+
             "geschrieben, z.B. <i>Das spiegelt die Situation gut wider.</i>";
           RuleMatch ruleMatch = new RuleMatch(this, pos, pos+token.length(), msg);
+          ruleMatch.setSuggestedReplacement("wider");
           ruleMatches.add(ruleMatch);
           foundSpiegelt = false;
           foundWieder = false;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/WordCoherencyRule.java
Patch:
@@ -85,6 +85,7 @@ public RuleMatch[] match(AnalyzedSentence text) {
           String msg = "You should probably not use <i>" +token+ "</i> and <i>" +otherSpelling+
             "</i> in the same document, stick to one spelling";
           RuleMatch ruleMatch = new RuleMatch(this, pos, pos+origToken.length(), msg);
+          ruleMatch.setSuggestedReplacement(otherSpelling);
           ruleMatches.add(ruleMatch);
         } else if (relevantWords.containsKey(token)) {
           String shouldNotAppear = (String)relevantWords.get(token);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/JLanguageTool.java
Patch:
@@ -209,6 +209,7 @@ public List check(String test) throws IOException {
               thisMatches[i].getFromPos() + tokenCount,
               thisMatches[i].getToPos() + tokenCount,
               thisMatches[i].getMessage());
+          thisMatch.setSuggestedReplacements(thisMatches[i].getSuggestedReplacements());
           String sentencePartToError = sentence.substring(0, thisMatches[i].getFromPos());
           int lastLineBreakPos = sentencePartToError.lastIndexOf("\n");
           int column = -1;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/UppercaseSentenceStartRule.java
Patch:
@@ -56,6 +56,7 @@ public RuleMatch[] match(AnalyzedSentence text) {
       String msg = "This sentence does not start with an uppercase letter";
       RuleMatch ruleMatch = new RuleMatch(this, token.getStartPos(), 
           token.getStartPos()+token.getToken().length(), msg);
+      ruleMatch.setSuggestedReplacement(Character.toUpperCase(firstChar) +  firstToken.substring(1));
       ruleMatches.add(ruleMatch);
     }
     return toRuleMatchArray(ruleMatches);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/WordRepeatRule.java
Patch:
@@ -80,6 +80,7 @@ public RuleMatch[] match(AnalyzedSentence text) {
         if (isWord && prevToken.toLowerCase().equals(token.toLowerCase()) && !germanException) {
           String msg = "Possible typo: you repeated a word";
           RuleMatch ruleMatch = new RuleMatch(this, prevPos, pos+prevToken.length(), msg);
+          ruleMatch.setSuggestedReplacement(prevToken);
           ruleMatches.add(ruleMatch);
         }
         prevPrevToken = prevToken;

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/BNCCheck.java
Patch:
@@ -64,6 +64,8 @@ private void run(File file) throws IOException {
       text = text.replaceAll("<.*?>", "");
       text = text.replaceAll(" +", " ");
       text = text.replaceAll("&bquo|&equo", "\"");
+      text = text.replaceAll("&mdash;?", "--");
+      text = text.replaceAll("&amp;?", "&");
       //System.out.println(text);
       prg.checkText(text);
     }

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/en/AvsAnRule.java
Patch:
@@ -79,7 +79,7 @@ public RuleMatch[] match(AnalyzedSentence text) {
         if (parts.length >= 1) {
           token = parts[0];
         }
-        token = token.replaceAll("[^a-zA-Z]", "");         // e.g. >>an "industry party"<<
+        token = token.replaceAll("[^a-zA-Z0-9]", "");         // e.g. >>an "industry party"<<
         if (token.length() == 0)
           continue;
         char tokenFirstChar = token.charAt(0);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/DashRule.java
Patch:
@@ -54,7 +54,7 @@ public RuleMatch[] match(AnalyzedSentence text) {
         // ignore
         continue;
       } else {
-        if (prevToken != null && !prevToken.equals("-") && !prevToken.equals("--") && prevToken.endsWith("-")) {
+        if (prevToken != null && !prevToken.equals("-") && prevToken.indexOf("--") == -1 && prevToken.endsWith("-")) {
           char firstChar = token.charAt(0);
           if (Character.isUpperCase(firstChar)) {
             String msg = "Möglicherweise fehlt ein 'und' oder es wurde nach dem Wort " +

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/CommaWhitespaceRuleTest.java
Patch:
@@ -47,6 +47,8 @@ public void testRule() throws IOException {
     assertEquals(1, matches.length);
     matches = rule.match(langTool.getAnalyzedSentence("This ,is a test sentence."));
     assertEquals(1, matches.length);
+    matches = rule.match(langTool.getAnalyzedSentence(",is a test sentence."));
+    assertEquals(1, matches.length);
     matches = rule.match(langTool.getAnalyzedSentence("This ( foo bar) is a test(!)."));
     assertEquals(1, matches.length);
     matches = rule.match(langTool.getAnalyzedSentence("This (foo bar ) is a test(!)."));

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/CommaWhitespaceRule.java
Patch:
@@ -34,11 +34,11 @@
 public class CommaWhitespaceRule extends Rule {
 
   public String getId() {
-    return "COMMA_WHITESPACE";
+    return "COMMA__PARENTHESIS_WHITESPACE";
   }
 
   public String getDescription() {
-    return "Use of whitespace after a comma";
+    return "Use of whitespace before comma and before/after parentheses";
   }
 
   public Language[] getLanguages() {

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/DashRule.java
Patch:
@@ -54,7 +54,7 @@ public RuleMatch[] match(AnalyzedSentence text) {
         // ignore
         continue;
       } else {
-        if (prevToken != null && prevToken.endsWith("-")) {
+        if (prevToken != null && !prevToken.equals("-") && !prevToken.equals("--") && prevToken.endsWith("-")) {
           char firstChar = token.charAt(0);
           if (Character.isUpperCase(firstChar)) {
             String msg = "Möglicherweise fehlt ein 'und' oder es wurde nach dem Wort " +

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/de/DashRuleTest.java
Patch:
@@ -38,6 +38,8 @@ public void testRule() throws IOException {
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Die große Diätenerhöhung kam dann doch.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Die große Diäten-Erhöhungs-Manie kam dann doch.")).length);
     assertEquals(0, rule.match(langTool.getAnalyzedSentence("Die große Diäten- und Gehaltserhöhung kam dann doch.")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("Erst so - Karl-Heinz dann blah.")).length);
+    assertEquals(0, rule.match(langTool.getAnalyzedSentence("Erst so -- Karl-Heinz aber...")).length);
     
     // incorrect sentences:
     assertEquals(1, rule.match(langTool.getAnalyzedSentence("Die große Diäten- Erhöhung kam dann doch.")).length);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/tokenizers/SentenceTokenizer.java
Patch:
@@ -37,7 +37,7 @@ public class SentenceTokenizer implements Tokenizer {
   private final static String EOS = "\0";
   // private final static String EOS = "#"; // for testing only
   private final static String P = "[\\.!?]"; // PUNCTUATION
-  private final static String AP = "(?:'|\"||\\)|\\]|\\})?"; // AFTER PUNCTUATION
+  private final static String AP = "(?:'|«|\"||\\)|\\]|\\})?"; // AFTER PUNCTUATION
   private final static String PAP = P + AP;
 
   // Check out the private methods for comments and examples about these

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/tokenizers/SentenceTokenizerTest.java
Patch:
@@ -57,8 +57,10 @@ public void testTokenize() {
     testSplit(new String[] { "Das hier ist ein(!!) Satz." });
     testSplit(new String[] { "Das hier ist ein(?) Satz." });
     testSplit(new String[] { "Das hier ist ein(???) Satz." });
+    testSplit(new String[] { "Das hier ist ein(???) Satz." });
 
-    testSplit(new String[] { "Der Papagei ist grün. ",  "Das kam so." });
+    testSplit(new String[] { "»Der Papagei ist grün.« ",  "Das kam so." });
+    testSplit(new String[] { "»Der Papagei ist grün«, sagte er" });
 
     // TODO: derzeit unterscheiden wir nicht, ob nach dem Doppelpunkt ein
     // ganzer Satz kommt oder nicht:

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -144,6 +144,7 @@ public void endElement(String namespaceURI, String sName, String qName) throws S
       rule.setCorrectExample(correctExample.toString());
       rule.setIncorrectExample(incorrectExample.toString());
       rule.setCaseSensitive(caseSensitive);
+      caseSensitive = false;
       rules.add(rule);
     } else if (qName.equals("pattern")) {
       inPattern = false;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -139,6 +139,8 @@ public void endElement(String namespaceURI, String sName, String qName) throws S
           message.toString());
       rule.setStartPositionCorrection(startPositionCorrection);
       rule.setEndPositionCorrection(endPositionCorrection);
+      startPositionCorrection = 0;
+      endPositionCorrection = 0;
       rule.setCorrectExample(correctExample.toString());
       rule.setIncorrectExample(incorrectExample.toString());
       rule.setCaseSensitive(caseSensitive);

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/en/AvsAnRuleTest.java
Patch:
@@ -43,6 +43,8 @@ public void testRule() throws IOException {
     assertEquals(0, matches.length);
     matches = rule.match(langTool.getAnalyzedSentence("A one-way street ..."));
     assertEquals(0, matches.length);
+    matches = rule.match(langTool.getAnalyzedSentence("An hour's work ..."));
+    assertEquals(0, matches.length);
     // errors:
     matches = rule.match(langTool.getAnalyzedSentence("It was a hour ago."));
     assertEquals(1, matches.length);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/en/AvsAnRule.java
Patch:
@@ -77,7 +77,9 @@ public RuleMatch[] match(AnalyzedSentence text) {
         // check for exceptions:
         boolean isException = false;
         if (token.indexOf("-") != -1) {     // for example, in "one-way" only "one" is relevant
-          token = token.split("-")[0];
+          String[] parts = token.split("-");
+          if (parts.length >= 1)
+            token = parts[0];
         }
         if (requiresA.contains(token.toLowerCase())) {
           isException = true;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/en/AvsAnRule.java
Patch:
@@ -76,6 +76,9 @@ public RuleMatch[] match(AnalyzedSentence text) {
         boolean doesRequireAn = false;
         // check for exceptions:
         boolean isException = false;
+        if (token.indexOf("-") != -1) {     // for example, in "one-way" only "one" is relevant
+          token = token.split("-")[0];
+        }
         if (requiresA.contains(token.toLowerCase())) {
           isException = true;
           doesRequireA = true;

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/rules/en/AvsAnRuleTest.java
Patch:
@@ -41,6 +41,8 @@ public void testRule() throws IOException {
     assertEquals(0, matches.length);
     matches = rule.match(langTool.getAnalyzedSentence("A university is ..."));
     assertEquals(0, matches.length);
+    matches = rule.match(langTool.getAnalyzedSentence("A one-way street ..."));
+    assertEquals(0, matches.length);
     // errors:
     matches = rule.match(langTool.getAnalyzedSentence("It was a hour ago."));
     assertEquals(1, matches.length);

File: trunk/JLanguageTool/src/test/de/danielnaber/languagetool/JLanguageToolTest.java
Patch:
@@ -43,7 +43,7 @@ public void testEnglish() throws IOException, ParserConfigurationException, SAXE
     assertEquals(1, matches.size());
     matches = tool.check("I can give you more a detailed description.");
     assertEquals(0, matches.size());
-    assertEquals(4, tool.getAllRules().size());
+    assertEquals(5, tool.getAllRules().size());
     List rules = tool.loadPatternRules("rules/en/grammar.xml");
     for (Iterator iter = rules.iterator(); iter.hasNext();) {
       Rule rule = (Rule) iter.next();

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/JLanguageTool.java
Patch:
@@ -267,6 +267,7 @@ public AnalyzedSentence getAnalyzedSentence(String sentence) throws IOException
       AnalyzedToken posTag = null;
       if (!tokenStr.trim().equals("")) {
         posTag = (AnalyzedToken)aTokens.get(noWhitespaceCount);
+        posTag.startPos = startPos;
         noWhitespaceCount++;
       } else {
         posTag = new AnalyzedToken(tokenStr, null, startPos);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRuleLoader.java
Patch:
@@ -116,6 +116,7 @@ public void startElement(String namespaceURI, String lName, String qName, Attrib
       incorrectExample = new StringBuffer();
     } else if (qName.equals("message")) {
       inMessage = true;
+      message = new StringBuffer();
     } else if (qName.equals("rulegroup")) {
       ruleGroupId = attrs.getValue("id");
       ruleGroupDescription = attrs.getValue("name");

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/de/WiederVsWiderRule.java
Patch:
@@ -64,8 +64,8 @@ public RuleMatch[] match(AnalyzedSentence text) {
           foundWider = true;
         }
         if (foundSpiegelt && foundWieder && !foundWider) {
-          String msg = "<i>wieder</i> in <i>widerspiegeln</i> wird mit <i>i</i> statt mit <i>ie</i> "+
-            "geschrieben, z.B. <i>Das spiegelt die Situation wider.</i>";
+          String msg = "<i>wider</i> in <i>widerspiegeln</i> wird mit <i>i</i> statt mit <i>ie</i> "+
+            "geschrieben, z.B. <i>Das spiegelt die Situation gut wider.</i>";
           RuleMatch ruleMatch = new RuleMatch(this, pos, pos+token.length(), msg);
           ruleMatches.add(ruleMatch);
           foundSpiegelt = false;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/en/AvsAnRule.java
Patch:
@@ -82,7 +82,7 @@ public RuleMatch[] match(AnalyzedSentence text) {
         }
         if (requiresAn.contains(token.toLowerCase())) {
           if (isException) {
-            throw new IllegalStateException("");
+            throw new IllegalStateException(token + " is listed in both det_a.txt and det_an.txt");
           }
           isException = true;
           doesRequireAn = true;

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/Main.java
Patch:
@@ -179,7 +179,7 @@ private String getContext(int fromPos, int toPos, String fileContents) {
 
   private static void exitWithUsageMessagee() {
     System.out.println("Usage: java de.danielnaber.languagetool.Main " +
-            "[-r|--recursive] [-v|--verbove] [-l|--language] <file>");
+            "[-r|--recursive] [-v|--verbose] [-l|--language] <file>");
     System.exit(1);
   }
 

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/PatternRule.java
Patch:
@@ -116,6 +116,9 @@ public RuleMatch[] match(AnalyzedSentence text) {
         RuleMatch ruleMatch = new RuleMatch(this, firstMatchToken.getStartPos(), 
             lastMatchToken.getStartPos()+lastMatchToken.getToken().length(), description);
         ruleMatches.add(ruleMatch);
+      } else {
+        firstMatchToken = null;
+        lastMatchToken = null;
       }
       tokenPos++;
     }      

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/en/AvsAnRule.java
Patch:
@@ -94,7 +94,7 @@ public RuleMatch[] match(AnalyzedSentence text) {
             doesRequireA = true;
           }
         }
-        System.err.println(prevToken + " " +token + ", a="+doesRequireA + ", an="+doesRequireAn);
+        //System.err.println(prevToken + " " +token + ", a="+doesRequireA + ", an="+doesRequireAn);
         String msg = null;
         if (prevToken.toLowerCase().equals("a") && doesRequireAn) {
           msg = "Use <suggestion>an</suggestion> instead of <old>a</old> if the following "+

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/gui/Main.java
Patch:
@@ -206,7 +206,6 @@ private static String getContext(int fromPos, int toPos, String fileContents) {
     String markerStr = markerPrefix + marker.substring(startContent, endContent);
     int startMark = markerStr.indexOf("^");
     int endMark = markerStr.lastIndexOf("^");
-    System.err.println(startMark + " " + endMark);
     String result = sb.toString();
     result = result.substring(0, startMark) + "<b><font color=\"red\">" + 
       result.substring(startMark, endMark+1) + "</font></b>" + result.substring(endMark+1);

File: trunk/JLanguageTool/src/java/de/danielnaber/languagetool/rules/patterns/Element.java
Patch:
@@ -18,6 +18,8 @@
  */
 package de.danielnaber.languagetool.rules.patterns;
 
+import de.danielnaber.languagetool.AnalyzedToken;
+
 /**
  * A part of a pattern.
  * 
@@ -27,7 +29,7 @@ public abstract class Element {
 
   String[] tokens;
 
-  abstract boolean match(String token);
+  abstract boolean match(AnalyzedToken token);
   
   public String toString() {
     StringBuffer sb = new StringBuffer();

