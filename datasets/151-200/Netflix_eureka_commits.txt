File: eureka-client/src/test/java/com/netflix/discovery/InstanceInfoReplicatorTest.java
Patch:
@@ -76,7 +76,7 @@ public void testOnDemandUpdateRateLimiting() throws Throwable {
         assertTrue(replicator.onDemandUpdate());
         Thread.sleep(10);  // give some time for execution
         assertFalse(replicator.onDemandUpdate());
-        Thread.sleep(10);
+        Thread.sleep(1000);
 
         verify(discoveryClient, times(2)).refreshInstanceInfo();
         verify(discoveryClient, times(1)).register();

File: eureka-core/src/test/java/com/netflix/eureka/GzipEncodingEnforcingFilterTest.java
Patch:
@@ -89,7 +89,6 @@ public void testForceGzip() throws Exception {
     @Test
     public void testForceGzipOtherHeader() throws Exception {
         noneGzipRequest();
-        when(request.getHeader("Test")).thenReturn("ok");
         when(request.getHeaders("Test")).thenReturn(new Enumeration() {
             private int c = 0;
 

File: eureka-test-utils/src/main/java/com/netflix/discovery/shared/transport/ClusterSampleData.java
Patch:
@@ -99,8 +99,8 @@ public static ReplicationInstance newReplicationInstanceOf(Action action, Instan
                         instance.getAppName(),
                         instance.getId(),
                         System.currentTimeMillis(),
-                        InstanceStatus.OUT_OF_SERVICE.name(),
                         null,
+                        InstanceStatus.OUT_OF_SERVICE.name(),
                         null,
                         action
                 );
@@ -110,7 +110,7 @@ public static ReplicationInstance newReplicationInstanceOf(Action action, Instan
                         instance.getId(),
                         System.currentTimeMillis(),
                         InstanceStatus.OUT_OF_SERVICE.name(),
-                        null,
+                        InstanceStatus.UP.name(),
                         null,
                         action
                 );

File: eureka-core/src/main/java/com/netflix/eureka/GzipEncodingEnforcingFilter.java
Patch:
@@ -60,7 +60,7 @@ public Enumeration<String> getHeaders(String name) {
                 if (HttpHeaders.ACCEPT_ENCODING.equals(name)) {
                     return new EnumWrapper<String>("gzip");
                 }
-                return new EnumWrapper<String>(super.getHeaders(name), HttpHeaders.ACCEPT_ENCODING);
+                return super.getHeaders(name);
             }
 
             @Override

File: eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java
Patch:
@@ -415,7 +415,7 @@ public boolean shouldFilterOnlyUpInstances() {
     @Override
     public int getEurekaConnectionIdleTimeoutSeconds() {
         return configInstance.getIntProperty(
-                namespace + EUREKA_SERVER_CONNECTION_IDLE_TIMEOUT_KEY, 30)
+                namespace + EUREKA_SERVER_CONNECTION_IDLE_TIMEOUT_KEY, 45)
                 .get();
     }
 

File: eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java
Patch:
@@ -415,7 +415,7 @@ public boolean shouldFilterOnlyUpInstances() {
     @Override
     public int getEurekaConnectionIdleTimeoutSeconds() {
         return configInstance.getIntProperty(
-                namespace + EUREKA_SERVER_CONNECTION_IDLE_TIMEOUT_KEY, 30)
+                namespace + EUREKA_SERVER_CONNECTION_IDLE_TIMEOUT_KEY, 45)
                 .get();
     }
 

File: eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java
Patch:
@@ -521,7 +521,7 @@ public Map<String, String> getRemoteRegionUrlsWithName() {
                 logger.error("Error reading eureka remote region urls from property {}. "
                                 + "Invalid entry {} for remote region url. The entry must contain region name and url "
                                 + "separated by a {}. Ignoring this entry.",
-                        new String[]{propName, remoteRegionUrlWithNamePair, pairSplitChar});
+                        propName, remoteRegionUrlWithNamePair, pairSplitChar);
             } else {
                 String regionName = pairSplit[0];
                 String regionUrl = pairSplit[1];

File: eureka-core/src/main/java/com/netflix/eureka/registry/AbstractInstanceRegistry.java
Patch:
@@ -375,7 +375,7 @@ public boolean renew(String appName, String id, boolean isReplication) {
                     logger.info(
                             "The instance status {} is different from overridden instance status {} for instance {}. "
                                     + "Hence setting the status to overridden status", instanceInfo.getStatus().name(),
-                                    instanceInfo.getOverriddenStatus().name(),
+                                    overriddenInstanceStatus.name(),
                                     instanceInfo.getId());
                     instanceInfo.setStatusWithoutDirty(overriddenInstanceStatus);
 

File: eureka-client/src/main/java/com/netflix/discovery/endpoint/EndpointUtils.java
Patch:
@@ -280,7 +280,6 @@ public static Set<String> getEC2DiscoveryUrlsFromZone(String dnsName, DiscoveryU
             Set<String> ec2UrlsForZone = DnsResolver.getCNamesFromTxtRecord(dnsName);
             for (String ec2Url : ec2UrlsForZone) {
                 logger.debug("The eureka url for the dns name {} is {}", dnsName, ec2Url);
-                ec2UrlsForZone.add(ec2Url);
             }
             if (DiscoveryUrlType.CNAME.equals(type)) {
                 return ec2UrlsForZone;

File: eureka-client/src/main/java/com/netflix/discovery/util/StringCache.java
Patch:
@@ -32,8 +32,8 @@ public StringCache(int lengthLimit) {
     public String cachedValueOf(final String str) {
         if (str != null && (lengthLimit < 0 || str.length() <= lengthLimit)) {
             // Return value from cache if available
+            lock.readLock().lock();
             try {
-                lock.readLock().lock();
                 WeakReference<String> ref = cache.get(str);
                 if (ref != null) {
                     return ref.get();
@@ -43,8 +43,8 @@ public String cachedValueOf(final String str) {
             }
 
             // Update cache with new content
+            lock.writeLock().lock();
             try {
-                lock.writeLock().lock();
                 WeakReference<String> ref = cache.get(str);
                 if (ref != null) {
                     return ref.get();
@@ -59,8 +59,8 @@ public String cachedValueOf(final String str) {
     }
 
     public int size() {
+        lock.readLock().lock();
         try {
-            lock.readLock().lock();
             return cache.size();
         } finally {
             lock.readLock().unlock();

File: eureka-core/src/main/java/com/netflix/eureka/aws/Route53Binder.java
Patch:
@@ -147,7 +147,9 @@ private boolean createResourceRecordSet(ResourceRecordSetWithHostedZone rrs) thr
             Thread.sleep(1000);
             // check change not overwritten
             ResourceRecordSet resourceRecordSet = getResourceRecordSet(rrs.getResourceRecordSet().getName(), rrs.getHostedZone());
-            return resourceRecordSet.getResourceRecords().equals(rrs.getResourceRecordSet().getResourceRecords());
+            if (resourceRecordSet != null) {
+                return resourceRecordSet.getResourceRecords().equals(rrs.getResourceRecordSet().getResourceRecords());
+            }
         }
         return false;
     }

File: eureka-core/src/main/java/com/netflix/eureka/registry/RemoteRegionRegistry.java
Patch:
@@ -20,6 +20,7 @@
 import java.net.InetAddress;
 import java.net.URL;
 import java.net.UnknownHostException;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.Executors;
@@ -477,7 +478,7 @@ public Application getApplication(String appName) {
 
     @Override
     public List<InstanceInfo> getInstancesById(String id) {
-        List<InstanceInfo> list = Collections.emptyList();
+        List<InstanceInfo> list = new ArrayList<>(1);
 
         for (Application app : applications.get().getRegisteredApplications()) {
             InstanceInfo info = app.getByInstanceId(id);
@@ -486,7 +487,7 @@ public List<InstanceInfo> getInstancesById(String id) {
                 return list;
             }
         }
-        return list;
+        return Collections.emptyList();
     }
 
     public Applications getApplicationDeltas() {

File: eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java
Patch:
@@ -615,7 +615,7 @@ public Object unmarshal(HierarchicalStreamReader reader,
 
                 long longValue = 0;
                 try {
-                    longValue = Long.valueOf(nodeValue).longValue();
+                    longValue = Long.parseLong(nodeValue);
                 } catch (NumberFormatException ne) {
                     continue;
                 }

File: eureka-core/src/main/java/com/netflix/eureka/registry/AbstractInstanceRegistry.java
Patch:
@@ -493,7 +493,7 @@ public boolean statusUpdate(String appName, String id,
                     long replicaDirtyTimestamp = 0;
                     info.setStatusWithoutDirty(newStatus);
                     if (lastDirtyTimestamp != null) {
-                        replicaDirtyTimestamp = Long.valueOf(lastDirtyTimestamp);
+                        replicaDirtyTimestamp = Long.parseLong(lastDirtyTimestamp);
                     }
                     // If the replication's dirty timestamp is more than the existing one, just update
                     // it to the replica's.
@@ -554,7 +554,7 @@ public boolean deleteStatusOverride(String appName, String id,
                     info.setStatusWithoutDirty(newStatus);
                     long replicaDirtyTimestamp = 0;
                     if (lastDirtyTimestamp != null) {
-                        replicaDirtyTimestamp = Long.valueOf(lastDirtyTimestamp);
+                        replicaDirtyTimestamp = Long.parseLong(lastDirtyTimestamp);
                     }
                     // If the replication's dirty timestamp is more than the existing one, just update
                     // it to the replica's.

File: eureka-core/src/main/java/com/netflix/eureka/registry/AbstractInstanceRegistry.java
Patch:
@@ -485,7 +485,7 @@ public boolean statusUpdate(String appName, String id,
                     if (InstanceStatus.UP.equals(newStatus)) {
                         lease.serviceUp();
                     }
-                    // This is NAC overriden status
+                    // This is NAC overridden status
                     overriddenInstanceStatusMap.put(id, newStatus);
                     // Set it for transfer of overridden status to replica on
                     // replica start up

File: eureka-core/src/main/java/com/netflix/eureka/util/EurekaMonitors.java
Patch:
@@ -42,9 +42,9 @@
 public enum EurekaMonitors {
     RENEW("renewCounter", "Number of total renews seen since startup"),
     CANCEL("cancelCounter", "Number of total cancels seen since startup"),
-    GET_ALL_CACHE_MISS("getAllCacheMissCounter", "Number of total registery queries seen since startup"),
+    GET_ALL_CACHE_MISS("getAllCacheMissCounter", "Number of total registry queries seen since startup"),
     GET_ALL_CACHE_MISS_DELTA("getAllCacheMissDeltaCounter",
-            "Number of total registery queries for delta seen since startup"),
+            "Number of total registry queries for delta seen since startup"),
     GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS("getAllWithRemoteRegionCacheMissCounter",
             "Number of total registry with remote region queries seen since startup"),
     GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS_DELTA("getAllWithRemoteRegionCacheMissDeltaCounter",

File: eureka-core/src/main/java/com/netflix/eureka/StatusFilter.java
Patch:
@@ -60,8 +60,8 @@ public void doFilter(ServletRequest request, ServletResponse response,
         InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo();
         InstanceStatus status = myInfo.getStatus();
         if (status != InstanceStatus.UP && response instanceof HttpServletResponse) {
-            HttpServletResponse httpRespone = (HttpServletResponse) response;
-            httpRespone.sendError(SC_TEMPORARY_REDIRECT,
+            HttpServletResponse httpResponse = (HttpServletResponse) response;
+            httpResponse.sendError(SC_TEMPORARY_REDIRECT,
                     "Current node is currently not ready to serve requests -- current status: "
                             + status + " - try another DS node: ");
         }

File: eureka-client/src/main/java/com/netflix/discovery/endpoint/DnsResolver.java
Patch:
@@ -75,7 +75,7 @@ public String resolve(String originalHost) {
 
             } while (targetHost == null);
             return targetHost;
-        } catch (NamingException e) {
+        } catch (Exception e) {
             logger.warn("Cannot resolve eureka server address {}; returning original value {}", currentHost, originalHost, e);
             return originalHost;
         }

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/aws/DnsTxtRecordClusterResolver.java
Patch:
@@ -133,7 +133,7 @@ private List<AwsEndpoint> resolve(String region, String rootClusterDNS, boolean
                 }
             }
             return endpoints;
-        } catch (NamingException e) {
+        } catch (Exception e) {
             throw new ClusterResolverException("Cannot resolve Eureka cluster addresses for root: " + rootClusterDNS, e);
         }
     }

File: eureka-core/src/main/java/com/netflix/eureka/aws/EIPManager.java
Patch:
@@ -350,7 +350,7 @@ private Collection<String> getEIPsFromServiceUrls(List<String> ec2Urls) {
             regionPhrase = "." + region;
         }
         for (String cname : ec2Urls) {
-            int beginIndex = cname.indexOf("ec2-") + 4;
+            int beginIndex = cname.indexOf("ec2-");
 
             if (-1 < beginIndex) {
                 // CNAME contains "ec2-"

File: eureka-core/src/main/java/com/netflix/eureka/aws/EIPManager.java
Patch:
@@ -355,7 +355,8 @@ private Collection<String> getEIPsFromServiceUrls(List<String> ec2Urls) {
             // Handle case where there are no cnames containing "ec2-"
             // Reasons include:
             //  Systems without public addresses - purely attached to corp lan via AWS Direct Connect
-            if (-1 < beginIndex) {
+            //  Use of EC2 network adapters that are attached to an instance after startup
+            if (3 < beginIndex) {
                 int endIndex = cname.indexOf(regionPhrase + ".compute");
                 String eipStr = cname.substring(beginIndex, endIndex);
                 String eip = eipStr.replaceAll("\\-", ".");

File: eureka-client/src/test/java/com/netflix/appinfo/ApplicationInfoManagerTest.java
Patch:
@@ -54,9 +54,8 @@ public void testRefreshDataCenterInfoWithAmazonInfo() {
     @Test
     public void testSpotInstanceTermination() {
         AmazonInfo initialAmazonInfo = AmazonInfo.Builder.newBuilder().build();
-        config = spy(new CloudInstanceConfig(initialAmazonInfo));
         RefreshableAmazonInfoProvider refreshableAmazonInfoProvider = spy(new RefreshableAmazonInfoProvider(initialAmazonInfo, new Archaius1AmazonInfoConfig(CommonConstants.DEFAULT_CONFIG_NAMESPACE)));
-        config.amazonInfoHolder = refreshableAmazonInfoProvider;
+        config = spy(new CloudInstanceConfig(CommonConstants.DEFAULT_CONFIG_NAMESPACE, refreshableAmazonInfoProvider));
         this.applicationInfoManager = new ApplicationInfoManager(config, instanceInfo, null);
 
         String terminationTime = "2015-01-05T18:02:00Z";

File: eureka-client-jersey2/src/main/java/com/netflix/discovery/shared/transport/jersey2/Jersey2ApplicationClientFactory.java
Patch:
@@ -141,7 +141,7 @@ public Jersey2ApplicationClientFactory build() {
             ClientConfig clientConfig = new ClientConfig();
             
             for (ClientRequestFilter filter : additionalFilters) {
-                clientBuilder.register(filter);
+                clientConfig.register(filter);
             }
 
             for (Feature feature : features) {

File: eureka-client-jersey2/src/main/java/com/netflix/discovery/shared/transport/jersey2/Jersey2ApplicationClientFactory.java
Patch:
@@ -141,7 +141,7 @@ public Jersey2ApplicationClientFactory build() {
             ClientConfig clientConfig = new ClientConfig();
             
             for (ClientRequestFilter filter : additionalFilters) {
-                clientBuilder.register(filter);
+                clientConfig.register(filter);
             }
 
             for (Feature feature : features) {

File: eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java
Patch:
@@ -66,6 +66,7 @@ public class DefaultEurekaClientConfig implements EurekaClientConfig {
     @Deprecated
     public static final String DEFAULT_NAMESPACE = CommonConstants.DEFAULT_CONFIG_NAMESPACE + ".";
     public static final String DEFAULT_ZONE = "defaultZone";
+    public static final String URL_SEPARATOR = "\\s*,\\s*";
 
     private final String namespace;
     private final DynamicPropertyFactory configInstance;
@@ -368,7 +369,7 @@ public String[] getAvailabilityZones(String region) {
         return configInstance
                 .getStringProperty(
                         namespace + region + "." + CONFIG_AVAILABILITY_ZONE_PREFIX,
-                        DEFAULT_ZONE).get().split(",");
+                        DEFAULT_ZONE).get().split(URL_SEPARATOR);
     }
 
     /*
@@ -387,7 +388,7 @@ public List<String> getEurekaServerServiceUrls(String myZone) {
 
         }
         if (serviceUrls != null) {
-            return Arrays.asList(serviceUrls.split(","));
+            return Arrays.asList(serviceUrls.split(URL_SEPARATOR));
         }
 
         return new ArrayList<String>();

File: eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java
Patch:
@@ -66,6 +66,7 @@ public class DefaultEurekaClientConfig implements EurekaClientConfig {
     @Deprecated
     public static final String DEFAULT_NAMESPACE = CommonConstants.DEFAULT_CONFIG_NAMESPACE + ".";
     public static final String DEFAULT_ZONE = "defaultZone";
+    public static final String URL_SEPARATOR = "\\s*,\\s*";
 
     private final String namespace;
     private final DynamicPropertyFactory configInstance;
@@ -368,7 +369,7 @@ public String[] getAvailabilityZones(String region) {
         return configInstance
                 .getStringProperty(
                         namespace + region + "." + CONFIG_AVAILABILITY_ZONE_PREFIX,
-                        DEFAULT_ZONE).get().split(",");
+                        DEFAULT_ZONE).get().split(URL_SEPARATOR);
     }
 
     /*
@@ -387,7 +388,7 @@ public List<String> getEurekaServerServiceUrls(String myZone) {
 
         }
         if (serviceUrls != null) {
-            return Arrays.asList(serviceUrls.split(","));
+            return Arrays.asList(serviceUrls.split(URL_SEPARATOR));
         }
 
         return new ArrayList<String>();

File: eureka-core/src/main/java/com/netflix/eureka/registry/PeerAwareInstanceRegistryImpl.java
Patch:
@@ -531,8 +531,8 @@ private void updateRenewalThreshold() {
             }
             synchronized (lock) {
                 // Update threshold only if the threshold is greater than the
-                // current expected threshold of if the self preservation is disabled.
-                if ((count * 2) > (serverConfig.getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold)
+                // current expected threshold or if self preservation is disabled.
+                if ((count * 2) > (serverConfig.getRenewalPercentThreshold() * expectedNumberOfRenewsPerMin)
                         || (!this.isSelfPreservationModeEnabled())) {
                     this.expectedNumberOfRenewsPerMin = count * 2;
                     this.numberOfRenewsPerMinThreshold = (int) ((count * 2) * serverConfig.getRenewalPercentThreshold());

File: eureka-core/src/main/java/com/netflix/eureka/registry/PeerAwareInstanceRegistryImpl.java
Patch:
@@ -531,8 +531,8 @@ private void updateRenewalThreshold() {
             }
             synchronized (lock) {
                 // Update threshold only if the threshold is greater than the
-                // current expected threshold of if the self preservation is disabled.
-                if ((count * 2) > (serverConfig.getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold)
+                // current expected threshold or if self preservation is disabled.
+                if ((count * 2) > (serverConfig.getRenewalPercentThreshold() * expectedNumberOfRenewsPerMin)
                         || (!this.isSelfPreservationModeEnabled())) {
                     this.expectedNumberOfRenewsPerMin = count * 2;
                     this.numberOfRenewsPerMinThreshold = (int) ((count * 2) * serverConfig.getRenewalPercentThreshold());

File: eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java
Patch:
@@ -552,7 +552,8 @@ default boolean shouldEnforceRegistrationAtInit() {
 
     /**
      * To avoid configuration API pollution when trying new/experimental or features or for the migration process,
-     * the corresponding configuration can be put into experimental configuration section.
+     * the corresponding configuration can be put into experimental configuration section. Config format is:
+     * eureka.experimental.freeFormConfigString
      *
      * @return a property of experimental feature
      */

File: eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java
Patch:
@@ -552,7 +552,8 @@ default boolean shouldEnforceRegistrationAtInit() {
 
     /**
      * To avoid configuration API pollution when trying new/experimental or features or for the migration process,
-     * the corresponding configuration can be put into experimental configuration section.
+     * the corresponding configuration can be put into experimental configuration section. Config format is:
+     * eureka.experimental.freeFormConfigString
      *
      * @return a property of experimental feature
      */

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/JerseyEurekaHttpClientFactory.java
Patch:
@@ -204,7 +204,8 @@ private JerseyEurekaHttpClientFactory buildLegacy(Map<String, String> additional
                     .withMaxTotalConnections(maxTotalConnections)
                     .withConnectionIdleTimeout((int) connectionIdleTimeout)
                     .withEncoderWrapper(encoderWrapper)
-                    .withDecoderWrapper(decoderWrapper);
+                    .withDecoderWrapper(decoderWrapper)
+                    .withProxy(proxyHost,String.valueOf(proxyPort),proxyUserName,proxyPassword);
 
             if (systemSSL) {
                 clientBuilder.withSystemSSLConfiguration();

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/JerseyEurekaHttpClientFactory.java
Patch:
@@ -204,7 +204,8 @@ private JerseyEurekaHttpClientFactory buildLegacy(Map<String, String> additional
                     .withMaxTotalConnections(maxTotalConnections)
                     .withConnectionIdleTimeout((int) connectionIdleTimeout)
                     .withEncoderWrapper(encoderWrapper)
-                    .withDecoderWrapper(decoderWrapper);
+                    .withDecoderWrapper(decoderWrapper)
+                    .withProxy(proxyHost,String.valueOf(proxyPort),proxyUserName,proxyPassword);
 
             if (systemSSL) {
                 clientBuilder.withSystemSSLConfiguration();

File: eureka-client/src/main/java/com/netflix/discovery/util/EurekaEntityComparators.java
Patch:
@@ -175,6 +175,9 @@ public static boolean equal(InstanceInfo first, InstanceInfo second, EqualFunc<I
         if (first.getStatus() != null ? !first.getStatus().equals(second.getStatus()) : second.getStatus() != null) {
             return false;
         }
+        if (first.getOverriddenStatus() != null ? !first.getOverriddenStatus().equals(second.getOverriddenStatus()) : second.getOverriddenStatus() != null) {
+            return false;
+        }
         if (first.getStatusPageUrl() != null ? !first.getStatusPageUrl().equals(second.getStatusPageUrl()) : second.getStatusPageUrl() != null) {
             return false;
         }

File: eureka-client/src/main/java/com/netflix/discovery/util/EurekaEntityComparators.java
Patch:
@@ -175,6 +175,9 @@ public static boolean equal(InstanceInfo first, InstanceInfo second, EqualFunc<I
         if (first.getStatus() != null ? !first.getStatus().equals(second.getStatus()) : second.getStatus() != null) {
             return false;
         }
+        if (first.getOverriddenStatus() != null ? !first.getOverriddenStatus().equals(second.getOverriddenStatus()) : second.getOverriddenStatus() != null) {
+            return false;
+        }
         if (first.getStatusPageUrl() != null ? !first.getStatusPageUrl().equals(second.getStatusPageUrl()) : second.getStatusPageUrl() != null) {
             return false;
         }

File: eureka-core/src/main/java/com/netflix/eureka/util/batcher/TaskExecutors.java
Patch:
@@ -211,7 +211,7 @@ private List<TaskHolder<ID, T>> getWork() throws InterruptedException {
             do {
                 result = workQueue.poll(1, TimeUnit.SECONDS);
             } while (!isShutdown.get() && result == null);
-            return result;
+            return (result == null) ? new ArrayList<>() : result;
         }
 
         private List<T> getTasksOf(List<TaskHolder<ID, T>> holders) {

File: eureka-core/src/main/java/com/netflix/eureka/util/batcher/TaskExecutors.java
Patch:
@@ -211,7 +211,7 @@ private List<TaskHolder<ID, T>> getWork() throws InterruptedException {
             do {
                 result = workQueue.poll(1, TimeUnit.SECONDS);
             } while (!isShutdown.get() && result == null);
-            return result;
+            return (result == null) ? new ArrayList<>() : result;
         }
 
         private List<T> getTasksOf(List<TaskHolder<ID, T>> holders) {

File: eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java
Patch:
@@ -108,7 +108,7 @@ public int getNonSecurePort() {
      */
     @Override
     public int getSecurePort() {
-        return configInstance.getIntProperty(namespace + SECURE_PORT_KEY, super.getSecurePort()) .get();
+        return configInstance.getIntProperty(namespace + SECURE_PORT_KEY, super.getSecurePort()).get();
     }
 
     /*

File: eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java
Patch:
@@ -59,8 +59,8 @@ public synchronized InstanceInfo get() {
 
             // set the appropriate id for the InstanceInfo, falling back to datacenter Id if applicable, else hostname
             String instanceId = config.getInstanceId();
-            DataCenterInfo dataCenterInfo = config.getDataCenterInfo();
             if (instanceId == null || instanceId.isEmpty()) {
+                DataCenterInfo dataCenterInfo = config.getDataCenterInfo();
                 if (dataCenterInfo instanceof UniqueIdentifier) {
                     instanceId = ((UniqueIdentifier) dataCenterInfo).getId();
                 } else {

File: eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java
Patch:
@@ -108,7 +108,7 @@ public int getNonSecurePort() {
      */
     @Override
     public int getSecurePort() {
-        return configInstance.getIntProperty(namespace + SECURE_PORT_KEY, super.getSecurePort()) .get();
+        return configInstance.getIntProperty(namespace + SECURE_PORT_KEY, super.getSecurePort()).get();
     }
 
     /*

File: eureka-client-archaius2/src/main/java/com/netflix/appinfo/providers/Archaius2VipAddressResolver.java
Patch:
@@ -36,9 +36,9 @@ public String resolveDeploymentContextBasedVipAddresses(String vipAddressMacro)
             String key = matcher.group(1);
             String value = config.getString(key, "");
 
-            logger.debug("att:" + matcher.group());
-            logger.debug(", att key:" + key);
-            logger.debug(", att value:" + value);
+            logger.debug("att:{}", matcher.group());
+            logger.debug(", att key:{}", key);
+            logger.debug(", att value:{}", value);
             logger.debug("");
             result = result.replaceAll("\\$\\{" + key + "\\}", value);
             matcher = VIP_ATTRIBUTES_PATTERN.matcher(result);

File: eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java
Patch:
@@ -210,7 +210,7 @@ public AmazonInfo autoBuild(String namespace) {
                         break;
                     } catch (Throwable e) {
                         if (config.shouldLogAmazonMetadataErrors()) {
-                            logger.warn("Cannot get the value for the metadata key :" + key + " Reason :", e);
+                            logger.warn("Cannot get the value for the metadata key: {} Reason :", key, e);
                         }
                         if (numOfRetries >= 0) {
                             try {

File: eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java
Patch:
@@ -319,7 +319,7 @@ public static InstanceStatus toEnum(String s) {
                     return InstanceStatus.valueOf(s.toUpperCase());
                 } catch (IllegalArgumentException e) {
                     // ignore and fall through to unknown
-                    if (logger.isDebugEnabled()) logger.debug("illegal argument supplied to InstanceStatus.valueOf: {}, defaulting to {}", s, UNKNOWN);
+                    logger.debug("illegal argument supplied to InstanceStatus.valueOf: {}, defaulting to {}", s, UNKNOWN);
                 }
             }
             return UNKNOWN;

File: eureka-client/src/main/java/com/netflix/appinfo/RefreshableAmazonInfoProvider.java
Patch:
@@ -45,7 +45,7 @@ private static AmazonInfo init(AmazonInfoConfig amazonInfoConfig, FallbackAddres
                     .newBuilder()
                     .withAmazonInfoConfig(amazonInfoConfig)
                     .autoBuild(amazonInfoConfig.getNamespace());
-            logger.info("Datacenter is: " + DataCenterInfo.Name.Amazon);
+            logger.info("Datacenter is: {}", DataCenterInfo.Name.Amazon);
         } catch (Throwable e) {
             logger.error("Cannot initialize amazon info :", e);
             throw new RuntimeException(e);

File: eureka-client/src/main/java/com/netflix/appinfo/providers/Archaius1VipAddressResolver.java
Patch:
@@ -26,9 +26,9 @@ public String resolveDeploymentContextBasedVipAddresses(String vipAddressMacro)
             String key = matcher.group(1);
             String value = DynamicPropertyFactory.getInstance().getStringProperty(key, "").get();
 
-            logger.debug("att:" + matcher.group());
-            logger.debug(", att key:" + key);
-            logger.debug(", att value:" + value);
+            logger.debug("att:{}", matcher.group());
+            logger.debug(", att key:{}", key);
+            logger.debug(", att value:{}", value);
             logger.debug("");
             result = result.replaceAll("\\$\\{" + key + "\\}", value);
             matcher = VIP_ATTRIBUTES_PATTERN.matcher(result);

File: eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java
Patch:
@@ -104,7 +104,7 @@ public synchronized InstanceInfo get() {
             // Start off with the STARTING state to avoid traffic
             if (!config.isInstanceEnabledOnit()) {
                 InstanceStatus initialStatus = InstanceStatus.STARTING;
-                LOG.info("Setting initial instance status as: " + initialStatus);
+                LOG.info("Setting initial instance status as: {}", initialStatus);
                 builder.setStatus(initialStatus);
             } else {
                 LOG.info("Setting initial instance status as: {}. This may be too early for the instance to advertise "

File: eureka-client/src/main/java/com/netflix/discovery/EurekaUpStatusResolver.java
Patch:
@@ -41,7 +41,7 @@ public EurekaUpStatusResolver(EurekaClient client, EventBus eventBus) {
 
     @Subscribe
     public void onStatusChange(StatusChangeEvent event) {
-        LOG.info("Eureka status changed from " + event.getPreviousStatus() + " to " + event.getStatus());
+        LOG.info("Eureka status changed from {} to {}", event.getPreviousStatus(), event.getStatus());
         currentStatus = event.getStatus();
         counter.incrementAndGet();
     }
@@ -52,7 +52,7 @@ public void init() {
             // Must set the initial status
             currentStatus = client.getInstanceRemoteStatus();
 
-            LOG.info("Initial status set to " + currentStatus);
+            LOG.info("Initial status set to {}", currentStatus);
             eventBus.registerSubscriber(this);
         } catch (InvalidSubscriberException e) {
             LOG.error("Error registring for discovery status change events.", e);

File: eureka-client/src/main/java/com/netflix/discovery/endpoint/DnsResolver.java
Patch:
@@ -81,7 +81,7 @@ public static String resolve(String originalHost) {
             } while (targetHost == null);
             return targetHost;
         } catch (NamingException e) {
-            logger.warn("Cannot resolve eureka server address " + currentHost + "; returning original value " + originalHost, e);
+            logger.warn("Cannot resolve eureka server address {}; returning original value {}", currentHost, originalHost, e);
             return originalHost;
         }
     }
@@ -109,7 +109,7 @@ public static List<String> resolveARecord(String rootDomainName) {
                 return result;
             }
         } catch (Exception e) {
-            logger.warn("Cannot load A-record for eureka server address " + rootDomainName, e);
+            logger.warn("Cannot load A-record for eureka server address {}", rootDomainName, e);
             return null;
         }
         return null;

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/DnsClusterResolver.java
Patch:
@@ -51,9 +51,7 @@ public DnsClusterResolver(DnsService dnsService, String region, String rootClust
         } else {
             this.eurekaEndpoints = DefaultEndpoint.createForServerList(addresses, port, isSecure, relativeUri);
         }
-        if (logger.isDebugEnabled()) {
-            logger.debug("Resolved {} to {}", rootClusterDNS, eurekaEndpoints);
-        }
+        logger.debug("Resolved {} to {}", rootClusterDNS, eurekaEndpoints);
     }
 
     @Override

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/ReloadingClusterResolver.java
Patch:
@@ -109,7 +109,7 @@ public List<T> getClusterEndpoints() {
             } catch (Exception e) {
                 this.currentReloadIntervalMs = Math.min(maxReloadIntervalMs, currentReloadIntervalMs * 2);
                 logger.warn("Cluster resolve error; keeping the current Eureka endpoints; next reload in "
-                        + currentReloadIntervalMs / 1000 + "[sec]", e);
+                        + "{}[sec]", currentReloadIntervalMs / 1000, e);
             }
         }
         return delegateRef.get().getClusterEndpoints();

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/StaticClusterResolver.java
Patch:
@@ -43,9 +43,7 @@ public StaticClusterResolver(String region, T... eurekaEndpoints) {
     public StaticClusterResolver(String region, List<T> eurekaEndpoints) {
         this.eurekaEndpoints = eurekaEndpoints;
         this.region = region;
-        if (logger.isDebugEnabled()) {
-            logger.debug("Fixed resolver configuration: {}", eurekaEndpoints);
-        }
+        logger.debug("Fixed resolver configuration: {}", eurekaEndpoints);
     }
 
     @Override

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/aws/ConfigClusterResolver.java
Patch:
@@ -86,9 +86,7 @@ private List<AwsEndpoint> getClusterEndpointsFromConfig() {
             }
         }
 
-        if (logger.isDebugEnabled()) {
-            logger.debug("Config resolved to {}", endpoints);
-        }
+        logger.debug("Config resolved to {}", endpoints);
 
         if (endpoints.isEmpty()) {
             logger.error("Cannot resolve to any endpoints from provided configuration: {}", serviceUrls);

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/aws/DnsTxtRecordClusterResolver.java
Patch:
@@ -110,9 +110,7 @@ public String getRegion() {
     @Override
     public List<AwsEndpoint> getClusterEndpoints() {
         List<AwsEndpoint> eurekaEndpoints = resolve(region, rootClusterDNS, extractZoneFromDNS, port, isSecure, relativeUri);
-        if (logger.isDebugEnabled()) {
-            logger.debug("Resolved {} to {}", rootClusterDNS, eurekaEndpoints);
-        }
+        logger.debug("Resolved {} to {}", rootClusterDNS, eurekaEndpoints);
 
         return eurekaEndpoints;
     }

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/aws/ZoneAffinityClusterResolver.java
Patch:
@@ -63,9 +63,7 @@ public List<AwsEndpoint> getClusterEndpoints() {
             Collections.reverse(randomizedList);
         }
 
-        if (logger.isDebugEnabled()) {
-            logger.debug("Local zone={}; resolved to: {}", myZone, randomizedList);
-        }
+        logger.debug("Local zone={}; resolved to: {}", myZone, randomizedList);
 
         return randomizedList;
     }

File: eureka-client/src/main/java/com/netflix/discovery/util/ThresholdLevelsMetric.java
Patch:
@@ -52,7 +52,7 @@ public ThresholdLevelsMetric(Object owner, String prefix, long[] levels) {
             try {
                 DefaultMonitorRegistry.getInstance().register(gauges[i]);
             } catch (Throwable e) {
-                logger.warn("Cannot register metric " + name, e);
+                logger.warn("Cannot register metric {}", name, e);
             }
         }
     }

File: eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java
Patch:
@@ -239,7 +239,7 @@ protected PeerEurekaNodes getPeerEurekaNodes(PeerAwareInstanceRegistry registry,
     @Override
     public void contextDestroyed(ServletContextEvent event) {
         try {
-            logger.info("{} Shutting down Eureka Server..", new Date().toString());
+            logger.info("{} Shutting down Eureka Server..", new Date());
             ServletContext sc = event.getServletContext();
             sc.removeAttribute(EurekaServerContext.class.getName());
 
@@ -249,7 +249,7 @@ public void contextDestroyed(ServletContextEvent event) {
         } catch (Throwable e) {
             logger.error("Error shutting down eureka", e);
         }
-        logger.info("{} Eureka Service is now shutdown...", new Date().toString());
+        logger.info("{} Eureka Service is now shutdown...", new Date());
     }
 
     /**

File: eureka-core/src/main/java/com/netflix/eureka/aws/EIPManager.java
Patch:
@@ -62,7 +62,7 @@
  *
  * <p>
  * This binding mechanism gravitates towards one eureka server per zone for
- * resilience.Atleast one elastic ip should be slotted for each eureka server in
+ * resilience. At least one elastic ip should be slotted for each eureka server in
  * a zone. If more than eureka server is launched per zone and there are not
  * enough elastic ips slotted, the server tries to pick a free EIP slotted for other
  * zones and if it still cannot find a free EIP, waits and keeps trying.

File: eureka-core/src/main/java/com/netflix/eureka/aws/ElasticNetworkInterfaceBinder.java
Patch:
@@ -168,7 +168,7 @@ public Integer apply(NetworkInterface networkInterface) {
                 );
 
         if (result.getNetworkInterfaces().isEmpty()) {
-            logger.info("No ip is free to be associated with this instance. Candidate ips are: {} for zone: ", ips, myZone);
+            logger.info("No ip is free to be associated with this instance. Candidate ips are: {} for zone: {}", ips, myZone);
         } else {
             NetworkInterface selected = ipsOrder.min(result.getNetworkInterfaces());
             ec2Service.attachNetworkInterface(

File: eureka-core/src/main/java/com/netflix/eureka/aws/Route53Binder.java
Patch:
@@ -154,7 +154,7 @@ private List<String> toDomains(List<String> ec2Urls) {
             try {
                 domains.add(extractDomain(url));
             } catch(MalformedURLException e) {
-                logger.error("Invalid url " + url, e);
+                logger.error("Invalid url {}", url, e);
             }
         }
         return domains;
@@ -191,7 +191,7 @@ private boolean executeChangeWithRetry(Change change, HostedZone hostedZone) thr
         }
 
         if (firstError != null) {
-            logger.error("Cannot execute change " + change + " " + firstError, firstError);
+            logger.error("Cannot execute change {} {}", change, firstError, firstError);
         }
 
         return false;

File: eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNodes.java
Patch:
@@ -107,7 +107,7 @@ public void run() {
             throw new IllegalStateException(e);
         }
         for (PeerEurekaNode node : peerEurekaNodes) {
-            logger.info("Replica node URL:  " + node.getServiceUrl());
+            logger.info("Replica node URL:  {}", node.getServiceUrl());
         }
     }
 
@@ -257,7 +257,7 @@ public static String hostFromUrl(String url) {
         try {
             uri = new URI(url);
         } catch (URISyntaxException e) {
-            logger.warn("Cannot parse service URI " + url, e);
+            logger.warn("Cannot parse service URI {}", url, e);
             return null;
         }
         return uri.getHost();

File: eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java
Patch:
@@ -57,7 +57,8 @@ public ProcessingResult process(ReplicationTask task) {
                 logNetworkErrorSample(task, e);
                 return ProcessingResult.TransientError;
             } else {
-                logger.error(peerId + ": " + task.getTaskName() + "Not re-trying this exception because it does not seem to be a network exception", e);
+                logger.error("{}: {} Not re-trying this exception because it does not seem to be a network exception",
+                        peerId, task.getTaskName(), e);
                 return ProcessingResult.PermanentError;
             }
         }
@@ -135,7 +136,7 @@ private void handleBatchResponse(ReplicationTask task, ReplicationInstanceRespon
         try {
             task.handleFailure(response.getStatusCode(), response.getResponseEntity());
         } catch (Throwable e) {
-            logger.error("Replication task " + task.getTaskName() + " error handler failure", e);
+            logger.error("Replication task {} error handler failure", task.getTaskName(), e);
         }
     }
 

File: eureka-core/src/main/java/com/netflix/eureka/registry/PeerAwareInstanceRegistryImpl.java
Patch:
@@ -239,8 +239,8 @@ public void openForTraffic(ApplicationInfoManager applicationInfoManager, int co
         this.expectedNumberOfRenewsPerMin = count * 2;
         this.numberOfRenewsPerMinThreshold =
                 (int) (this.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());
-        logger.info("Got " + count + " instances from neighboring DS node");
-        logger.info("Renew threshold is: " + numberOfRenewsPerMinThreshold);
+        logger.info("Got {} instances from neighboring DS node", count);
+        logger.info("Renew threshold is: {}", numberOfRenewsPerMinThreshold);
         this.startupTime = System.currentTimeMillis();
         if (count > 0) {
             this.peerInstancesTransferEmptyOnStartup = false;
@@ -311,7 +311,7 @@ private void primeAwsReplicas(ApplicationInfoManager applicationInfoManager) {
                 }
                 areAllPeerNodesPrimed = true;
             } catch (Throwable e) {
-                logger.error("Could not contact " + peerHostName, e);
+                logger.error("Could not contact {}", peerHostName, e);
                 try {
                     Thread.sleep(PRIME_PEER_NODES_RETRY_MS);
                 } catch (InterruptedException e1) {

File: eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java
Patch:
@@ -65,7 +65,7 @@ public Response getById(@PathParam("version") String version,
         if (list != null && list.size() > 0) {
             return Response.ok(list.get(0)).build();
         } else {
-            logger.info("Not Found: " + id);
+            logger.info("Not Found: {}", id);
             return Response.status(Status.NOT_FOUND).build();
         }
     }

File: eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java
Patch:
@@ -85,8 +85,8 @@ public Response batchReplication(ReplicationList replicationList) {
                     batchResponse.addResponse(dispatch(instanceInfo));
                 } catch (Exception e) {
                     batchResponse.addResponse(new ReplicationInstanceResponse(Status.INTERNAL_SERVER_ERROR.getStatusCode(), null));
-                    logger.error(instanceInfo.getAction() + " request processing failed for batch item "
-                            + instanceInfo.getAppName() + '/' + instanceInfo.getId(), e);
+                    logger.error("{} request processing failed for batch item {}/{}",
+                            instanceInfo.getAction(), instanceInfo.getAppName(), instanceInfo.getId(), e);
                 }
             }
             return Response.ok(batchResponse).build();

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -845,7 +845,7 @@ boolean renew() {
             logger.debug(PREFIX + "{} - Heartbeat status: {}", appPathIdentifier, httpResponse.getStatusCode());
             if (httpResponse.getStatusCode() == 404) {
                 REREGISTER_COUNTER.increment();
-                logger.info("{} - Re-registering apps/{}", PREFIX + appPathIdentifier, instanceInfo.getAppName());
+                logger.info(PREFIX + "{} - Re-registering apps/{}", appPathIdentifier, instanceInfo.getAppName());
                 long timestamp = instanceInfo.setIsDirtyWithTime();
                 boolean success = register();
                 if (success) {

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -426,7 +426,7 @@ public synchronized BackupRegistry get() {
                     throw new IllegalStateException("Registration error at startup. Invalid server response.");
                 }
             } catch (Throwable th) {
-                logger.error("Registration error at startup.", th.getMessage());
+                logger.error("Registration error at startup: {}", th.getMessage());
                 throw new IllegalStateException(th);
             }
         }

File: eureka-client/src/main/java/com/netflix/discovery/util/DeserializerStringCache.java
Patch:
@@ -149,7 +149,7 @@ public static void clear(DeserializationContext context, CacheScope scope) {
         withCache(context, cache -> {
             if (scope == CacheScope.GLOBAL_SCOPE) {
                 if (logEnabled)
-                    logger.debug("clearing global-level serialization cache", cache.globalCache.size());
+                    logger.debug("clearing global-level serialization cache with size {}", cache.globalCache.size());
                 cache.globalCache.clear();
             }
             if (logEnabled)

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/aws/DnsTxtRecordClusterResolver.java
Patch:
@@ -110,9 +110,7 @@ public String getRegion() {
     @Override
     public List<AwsEndpoint> getClusterEndpoints() {
         List<AwsEndpoint> eurekaEndpoints = resolve(region, rootClusterDNS, extractZoneFromDNS, port, isSecure, relativeUri);
-        if (logger.isDebugEnabled()) {
-            logger.debug("Resolved {} to {}", rootClusterDNS, eurekaEndpoints);
-        }
+        logger.debug("Resolved {} to {}", rootClusterDNS, eurekaEndpoints);
 
         return eurekaEndpoints;
     }

File: eureka-core/src/main/java/com/netflix/eureka/transport/JerseyReplicationClient.java
Patch:
@@ -78,9 +78,7 @@ public EurekaHttpResponse<InstanceInfo> sendHeartBeat(String appName, String id,
             }
             return anEurekaHttpResponse(response.getStatus(), infoFromPeer).type(MediaType.APPLICATION_JSON_TYPE).build();
         } finally {
-            if (logger.isDebugEnabled()) {
-                logger.debug("[heartbeat] Jersey HTTP PUT {}; statusCode={}", urlPath, response == null ? "N/A" : response.getStatus());
-            }
+            logger.debug("[heartbeat] Jersey HTTP PUT {}; statusCode={}", urlPath, response == null ? "N/A" : response.getStatus());
             if (response != null) {
                 response.close();
             }

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/StaticClusterResolver.java
Patch:
@@ -43,9 +43,7 @@ public StaticClusterResolver(String region, T... eurekaEndpoints) {
     public StaticClusterResolver(String region, List<T> eurekaEndpoints) {
         this.eurekaEndpoints = eurekaEndpoints;
         this.region = region;
-        if (logger.isDebugEnabled()) {
-            logger.debug("Fixed resolver configuration: {}", eurekaEndpoints);
-        }
+        logger.debug("Fixed resolver configuration: {}", eurekaEndpoints);
     }
 
     @Override

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/aws/ConfigClusterResolver.java
Patch:
@@ -86,9 +86,7 @@ private List<AwsEndpoint> getClusterEndpointsFromConfig() {
             }
         }
 
-        if (logger.isDebugEnabled()) {
-            logger.debug("Config resolved to {}", endpoints);
-        }
+        logger.debug("Config resolved to {}", endpoints);
 
         if (endpoints.isEmpty()) {
             logger.error("Cannot resolve to any endpoints from provided configuration: {}", serviceUrls);

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/aws/ZoneAffinityClusterResolver.java
Patch:
@@ -63,9 +63,7 @@ public List<AwsEndpoint> getClusterEndpoints() {
             Collections.reverse(randomizedList);
         }
 
-        if (logger.isDebugEnabled()) {
-            logger.debug("Local zone={}; resolved to: {}", myZone, randomizedList);
-        }
+        logger.debug("Local zone={}; resolved to: {}", myZone, randomizedList);
 
         return randomizedList;
     }

File: eureka-core/src/main/java/com/netflix/eureka/aws/EIPManager.java
Patch:
@@ -62,7 +62,7 @@
  *
  * <p>
  * This binding mechanism gravitates towards one eureka server per zone for
- * resilience.Atleast one elastic ip should be slotted for each eureka server in
+ * resilience. At least one elastic ip should be slotted for each eureka server in
  * a zone. If more than eureka server is launched per zone and there are not
  * enough elastic ips slotted, the server tries to pick a free EIP slotted for other
  * zones and if it still cannot find a free EIP, waits and keeps trying.

File: eureka-core/src/main/java/com/netflix/eureka/registry/RemoteRegionRegistry.java
Patch:
@@ -420,7 +420,7 @@ private Applications fetchRemoteRegistry(boolean delta) {
     /**
      * Reconciles the delta information fetched to see if the hashcodes match.
      *
-     * @param delta - the delta information fetched previously for reconcililation.
+     * @param delta - the delta information fetched previously for reconciliation.
      * @param reconcileHashCode - the hashcode for comparison.
      * @return - response
      * @throws Throwable

File: eureka-core/src/main/java/com/netflix/eureka/registry/ResponseCacheImpl.java
Patch:
@@ -184,7 +184,7 @@ public void run() {
                             readOnlyCacheMap.put(key, cacheValue);
                         }
                     } catch (Throwable th) {
-                        logger.error("Error while updating the client cache from response cache", th);
+                        logger.error("Error while updating the client cache from response cache for key {}", key.toStringCompact(), th);
                     }
                 }
             }

File: eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java
Patch:
@@ -251,7 +251,7 @@ public int getWaitTimeInMsWhenSyncEmpty() {
     @Override
     public int getPeerNodeConnectTimeoutMs() {
         return configInstance.getIntProperty(
-                namespace + "peerNodeConnectTimeoutMs", 2000).get();
+                namespace + "peerNodeConnectTimeoutMs", 1000).get();
     }
 
     @Override
@@ -431,13 +431,13 @@ public boolean shouldDisableDeltaForRemoteRegions() {
     @Override
     public int getRemoteRegionConnectTimeoutMs() {
         return configInstance.getIntProperty(
-                namespace + "remoteRegionConnectTimeoutMs", 5000).get();
+                namespace + "remoteRegionConnectTimeoutMs", 2000).get();
     }
 
     @Override
     public int getRemoteRegionReadTimeoutMs() {
         return configInstance.getIntProperty(
-                namespace + "remoteRegionReadTimeoutMs", 10000).get();
+                namespace + "remoteRegionReadTimeoutMs", 5000).get();
     }
 
     @Override

File: eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java
Patch:
@@ -251,13 +251,13 @@ public int getWaitTimeInMsWhenSyncEmpty() {
     @Override
     public int getPeerNodeConnectTimeoutMs() {
         return configInstance.getIntProperty(
-                namespace + "peerNodeConnectTimeoutMs", 200).get();
+                namespace + "peerNodeConnectTimeoutMs", 2000).get();
     }
 
     @Override
     public int getPeerNodeReadTimeoutMs() {
         return configInstance.getIntProperty(
-                namespace + "peerNodeReadTimeoutMs", 200).get();
+                namespace + "peerNodeReadTimeoutMs", 5000).get();
     }
 
     @Override

File: eureka-core/src/main/java/com/netflix/eureka/registry/ResponseCacheImpl.java
Patch:
@@ -184,7 +184,7 @@ public void run() {
                             readOnlyCacheMap.put(key, cacheValue);
                         }
                     } catch (Throwable th) {
-                        logger.error("Error while updating the client cache from response cache", th);
+                        logger.error("Error while updating the client cache from response cache for key {}", key.toStringCompact(), th);
                     }
                 }
             }

File: eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java
Patch:
@@ -149,6 +149,8 @@ public Response addInstance(InstanceInfo info,
             return Response.status(400).entity("Missing instanceId").build();
         } else if (isBlank(info.getHostName())) {
             return Response.status(400).entity("Missing hostname").build();
+        } else if (isBlank(info.getIPAddr())) {
+            return Response.status(400).entity("Missing ip address").build();
         } else if (isBlank(info.getAppName())) {
             return Response.status(400).entity("Missing appName").build();
         } else if (!appName.equals(info.getAppName())) {

File: eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java
Patch:
@@ -176,6 +176,7 @@ protected static InstanceInfo createLocalOutOfServiceInstance(String hostname) {
 
     private static InstanceInfo createLocalInstanceWithStatus(String hostname, InstanceInfo.InstanceStatus status) {
         InstanceInfo.Builder instanceBuilder = InstanceInfo.Builder.newBuilder();
+        instanceBuilder.setInstanceId("foo");
         instanceBuilder.setAppName(LOCAL_REGION_APP_NAME);
         instanceBuilder.setHostName(hostname);
         instanceBuilder.setIPAddr("10.10.101.1");

File: eureka-client-archaius2/src/test/java/com/netflix/discovery/guice/NonEc2EurekaClientModuleTest.java
Patch:
@@ -41,6 +41,7 @@ protected void configureArchaius() {
                                                 .put("eureka.registration.enabled", "false")
                                                 .put("eureka.serviceUrl.default", "http://localhost:8080/eureka/v2")
                                                 .put("eureka.shouldInitAsEc2", "false")
+                                                .put("eureka.instanceDeploymentEnvironment", "non-ec2")
                                                 .build()
                                 );
                             }

File: eureka-client/src/main/java/com/netflix/discovery/shared/Application.java
Patch:
@@ -147,7 +147,9 @@ public List<InstanceInfo> getInstances() {
      */
     @JsonIgnore
     public List<InstanceInfo> getInstancesAsIsFromEureka() {
-        return new ArrayList<InstanceInfo>(this.instances);
+        synchronized (instances) {
+           return new ArrayList<InstanceInfo>(this.instances);
+        }
     }
 
 

File: eureka-client/src/main/java/com/netflix/discovery/shared/Application.java
Patch:
@@ -147,7 +147,9 @@ public List<InstanceInfo> getInstances() {
      */
     @JsonIgnore
     public List<InstanceInfo> getInstancesAsIsFromEureka() {
-        return new ArrayList<InstanceInfo>(this.instances);
+        synchronized (instances) {
+           return new ArrayList<InstanceInfo>(this.instances);
+        }
     }
 
 

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/LegacyClusterResolver.java
Patch:
@@ -115,7 +115,7 @@ private List<AwsEndpoint> createEurekaEndpointsFromConfig() {
                             myZone
                     ));
                 } catch (URISyntaxException ignore) {
-                    logger.warn("Invalid eureka server URI: ; removing from the server pool", serviceUrl);
+                    logger.warn("Invalid eureka server URI: {}; removing from the server pool", serviceUrl);
                 }
             }
             return endpoints;

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/LegacyClusterResolver.java
Patch:
@@ -115,7 +115,7 @@ private List<AwsEndpoint> createEurekaEndpointsFromConfig() {
                             myZone
                     ));
                 } catch (URISyntaxException ignore) {
-                    logger.warn("Invalid eureka server URI: ; removing from the server pool", serviceUrl);
+                    logger.warn("Invalid eureka server URI: {}; removing from the server pool", serviceUrl);
                 }
             }
             return endpoints;

File: eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java
Patch:
@@ -46,7 +46,7 @@ public int getInstanceInfoReplicationIntervalSeconds() {
     }
 
     public int getInitialInstanceInfoReplicationIntervalSeconds() {
-        return prefixedConfig.getInteger(INITIAL_REGISTRATION_REPLCIATION_DELAY_KEY, 40);
+        return prefixedConfig.getInteger(INITIAL_REGISTRATION_REPLICATION_DELAY_KEY, 40);
     }
 
     public int getEurekaServiceUrlPollIntervalSeconds() {

File: eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java
Patch:
@@ -112,7 +112,7 @@ public int getInstanceInfoReplicationIntervalSeconds() {
     @Override
     public int getInitialInstanceInfoReplicationIntervalSeconds() {
         return configInstance.getIntProperty(
-                namespace + INITIAL_REGISTRATION_REPLCIATION_DELAY_KEY, 40).get();
+                namespace + INITIAL_REGISTRATION_REPLICATION_DELAY_KEY, 40).get();
     }
 
     /*

File: eureka-client/src/main/java/com/netflix/discovery/PropertyBasedClientConfigConstants.java
Patch:
@@ -16,7 +16,7 @@ final class PropertyBasedClientConfigConstants {
 
     static final String REGISTRY_REFRESH_INTERVAL_KEY = "client.refresh.interval";
     static final String REGISTRATION_REPLICATION_INTERVAL_KEY = "appinfo.replicate.interval";
-    static final String INITIAL_REGISTRATION_REPLCIATION_DELAY_KEY = "appinfo.initial.replicate.time";
+    static final String INITIAL_REGISTRATION_REPLICATION_DELAY_KEY = "appinfo.initial.replicate.time";
     static final String HEARTBEAT_THREADPOOL_SIZE_KEY = "client.heartbeat.threadPoolSize";
     static final String HEARTBEAT_BACKOFF_BOUND_KEY = "client.heartbeat.exponentialBackOffBound";
     static final String CACHEREFRESH_THREADPOOL_SIZE_KEY = "client.cacheRefresh.threadPoolSize";

File: eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java
Patch:
@@ -46,7 +46,7 @@ public int getInstanceInfoReplicationIntervalSeconds() {
     }
 
     public int getInitialInstanceInfoReplicationIntervalSeconds() {
-        return prefixedConfig.getInteger(INITIAL_REGISTRATION_REPLCIATION_DELAY_KEY, 40);
+        return prefixedConfig.getInteger(INITIAL_REGISTRATION_REPLICATION_DELAY_KEY, 40);
     }
 
     public int getEurekaServiceUrlPollIntervalSeconds() {

File: eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java
Patch:
@@ -112,7 +112,7 @@ public int getInstanceInfoReplicationIntervalSeconds() {
     @Override
     public int getInitialInstanceInfoReplicationIntervalSeconds() {
         return configInstance.getIntProperty(
-                namespace + INITIAL_REGISTRATION_REPLCIATION_DELAY_KEY, 40).get();
+                namespace + INITIAL_REGISTRATION_REPLICATION_DELAY_KEY, 40).get();
     }
 
     /*

File: eureka-client/src/main/java/com/netflix/discovery/PropertyBasedClientConfigConstants.java
Patch:
@@ -16,7 +16,7 @@ final class PropertyBasedClientConfigConstants {
 
     static final String REGISTRY_REFRESH_INTERVAL_KEY = "client.refresh.interval";
     static final String REGISTRATION_REPLICATION_INTERVAL_KEY = "appinfo.replicate.interval";
-    static final String INITIAL_REGISTRATION_REPLCIATION_DELAY_KEY = "appinfo.initial.replicate.time";
+    static final String INITIAL_REGISTRATION_REPLICATION_DELAY_KEY = "appinfo.initial.replicate.time";
     static final String HEARTBEAT_THREADPOOL_SIZE_KEY = "client.heartbeat.threadPoolSize";
     static final String HEARTBEAT_BACKOFF_BOUND_KEY = "client.heartbeat.exponentialBackOffBound";
     static final String CACHEREFRESH_THREADPOOL_SIZE_KEY = "client.cacheRefresh.threadPoolSize";

File: eureka-client/src/main/java/com/netflix/appinfo/Archaius1AmazonInfoConfig.java
Patch:
@@ -19,7 +19,7 @@ public Archaius1AmazonInfoConfig(String namespace) {
                 ? namespace
                 : namespace + ".";
 
-        this.configInstance = Archaius1Utils.initConfig(CommonConstants.DEFAULT_CONFIG_NAMESPACE);
+        this.configInstance = Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME);
     }
 
 

File: eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java
Patch:
@@ -77,7 +77,7 @@ public PropertiesInstanceConfig(String namespace, DataCenterInfo info) {
         appGrpNameFromEnv = ConfigurationManager.getConfigInstance()
                 .getString(FALLBACK_APP_GROUP_KEY, Values.UNKNOWN_APPLICATION);
 
-        this.configInstance = Archaius1Utils.initConfig(CommonConstants.DEFAULT_CONFIG_NAMESPACE);
+        this.configInstance = Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME);
     }
 
     /*

File: eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java
Patch:
@@ -80,7 +80,7 @@ public DefaultEurekaClientConfig(String namespace) {
                 ? namespace
                 : namespace + ".";
 
-        this.configInstance = Archaius1Utils.initConfig(CommonConstants.DEFAULT_CONFIG_NAMESPACE);
+        this.configInstance = Archaius1Utils.initConfig(CommonConstants.CONFIG_FILE_NAME);
         this.transportConfig = new DefaultEurekaTransportConfig(namespace, configInstance);
     }
 

File: eureka-client-archaius2/src/main/java/com/netflix/appinfo/Archaius2AmazonInfoConfig.java
Patch:
@@ -2,6 +2,7 @@
 
 import com.netflix.archaius.api.Config;
 import com.netflix.archaius.api.annotations.ConfigurationSource;
+import com.netflix.discovery.CommonConstants;
 
 import javax.inject.Inject;
 import javax.inject.Singleton;
@@ -12,15 +13,15 @@
  * @author David Liu
  */
 @Singleton
-@ConfigurationSource(Values.DEFAULT_CONFIG_FILE_NAME)
+@ConfigurationSource(CommonConstants.CONFIG_FILE_NAME)
 public class Archaius2AmazonInfoConfig implements AmazonInfoConfig {
 
     private final Config config;
     private final String namespace;
 
     @Inject
     public Archaius2AmazonInfoConfig(Config config) {
-        this(config, Values.DEFAULT_NAMESPACE);
+        this(config, CommonConstants.DEFAULT_CONFIG_NAMESPACE);
     }
 
 

File: eureka-client-archaius2/src/main/java/com/netflix/appinfo/Ec2EurekaArchaius2InstanceConfig.java
Patch:
@@ -6,6 +6,7 @@
 import javax.inject.Inject;
 import javax.inject.Singleton;
 
+import com.netflix.discovery.CommonConstants;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -36,7 +37,7 @@ public class Ec2EurekaArchaius2InstanceConfig extends EurekaArchaius2InstanceCon
 
     @Inject
     public Ec2EurekaArchaius2InstanceConfig(Config config, AmazonInfoConfig amazonInfoConfig) {
-        this(config, amazonInfoConfig, PropertyBasedInstanceConfigConstants.Values.DEFAULT_NAMESPACE);
+        this(config, amazonInfoConfig, CommonConstants.DEFAULT_CONFIG_NAMESPACE);
     }
 
     public Ec2EurekaArchaius2InstanceConfig(Config config, AmazonInfoConfig amazonInfoConfig, String namespace) {

File: eureka-client-archaius2/src/main/java/com/netflix/appinfo/EurekaArchaius2InstanceConfig.java
Patch:
@@ -9,11 +9,12 @@
 import com.google.common.collect.Sets;
 import com.netflix.archaius.api.Config;
 import com.netflix.archaius.api.annotations.ConfigurationSource;
+import com.netflix.discovery.CommonConstants;
 
 import static com.netflix.appinfo.PropertyBasedInstanceConfigConstants.*;
 
 @Singleton
-@ConfigurationSource(Values.DEFAULT_CONFIG_FILE_NAME)
+@ConfigurationSource(CommonConstants.CONFIG_FILE_NAME)
 public class EurekaArchaius2InstanceConfig extends AbstractInstanceConfig {
 
     protected String namespace;
@@ -25,7 +26,7 @@ public class EurekaArchaius2InstanceConfig extends AbstractInstanceConfig {
     
     @Inject
     public EurekaArchaius2InstanceConfig(Config config) {
-        this(config, Values.DEFAULT_NAMESPACE);
+        this(config, CommonConstants.DEFAULT_CONFIG_NAMESPACE);
     }
     
     public EurekaArchaius2InstanceConfig(Config config, String namespace) {
@@ -39,7 +40,6 @@ public Name getName() {
     
     public EurekaArchaius2InstanceConfig(Config config, String namespace, DataCenterInfo dcInfo) {
         this.defaultAppGroup = config.getString(FALLBACK_APP_GROUP_KEY, Values.UNKNOWN_APPLICATION);
-        
         this.namespace = namespace;
         this.config = config.getPrefixedView(namespace);
         this.dcInfo = dcInfo;

File: eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java
Patch:
@@ -15,7 +15,7 @@
 import static com.netflix.discovery.PropertyBasedClientConfigConstants.*;
 
 @Singleton
-@ConfigurationSource(Values.DEFAULT_CONFIG_FILE_NAME)
+@ConfigurationSource(CommonConstants.CONFIG_FILE_NAME)
 public class EurekaArchaius2ClientConfig implements EurekaClientConfig {
     public static final String DEFAULT_ZONE = "defaultZone";
 

File: eureka-client/src/main/java/com/netflix/appinfo/AbstractInstanceConfig.java
Patch:
@@ -19,6 +19,7 @@
 import java.net.UnknownHostException;
 import java.util.Map;
 
+import com.netflix.discovery.CommonConstants;
 import com.netflix.discovery.shared.Pair;
 
 import org.slf4j.Logger;
@@ -36,10 +37,10 @@ public abstract class AbstractInstanceConfig implements EurekaInstanceConfig {
     private static final Logger logger = LoggerFactory.getLogger(AbstractInstanceConfig.class);
 
     /**
-     * @deprecated 2016-08-29 use {@link com.netflix.appinfo.PropertyBasedInstanceConfigConstants.Values#DEFAULT_NAMESPACE}
+     * @deprecated 2016-08-29 use {@link CommonConstants#DEFAULT_CONFIG_NAMESPACE}
      */
     @Deprecated
-    public static final String DEFAULT_NAMESPACE = PropertyBasedInstanceConfigConstants.Values.DEFAULT_NAMESPACE;
+    public static final String DEFAULT_NAMESPACE = CommonConstants.DEFAULT_CONFIG_NAMESPACE;
     
     private static final int LEASE_EXPIRATION_DURATION_SECONDS = 90;
     private static final int LEASE_RENEWAL_INTERVAL_SECONDS = 30;

File: eureka-client/src/main/java/com/netflix/appinfo/Archaius1AmazonInfoConfig.java
Patch:
@@ -1,6 +1,7 @@
 package com.netflix.appinfo;
 
 import com.netflix.config.DynamicPropertyFactory;
+import com.netflix.discovery.CommonConstants;
 import com.netflix.discovery.internal.util.Archaius1Utils;
 
 import static com.netflix.appinfo.PropertyBasedAmazonInfoConfigConstants.*;
@@ -18,7 +19,7 @@ public Archaius1AmazonInfoConfig(String namespace) {
                 ? namespace
                 : namespace + ".";
 
-        this.configInstance = Archaius1Utils.initConfig(Values.DEFAULT_CONFIG_FILE_NAME);
+        this.configInstance = Archaius1Utils.initConfig(CommonConstants.DEFAULT_CONFIG_NAMESPACE);
     }
 
 

File: eureka-client/src/main/java/com/netflix/appinfo/PropertyBasedAmazonInfoConfigConstants.java
Patch:
@@ -13,9 +13,6 @@ final class PropertyBasedAmazonInfoConfigConstants {
 
 
     static class Values {
-        static final String DEFAULT_CONFIG_FILE_NAME = "eureka-client";
-        static final String DEFAULT_NAMESPACE = "eureka";
-
         static final int DEFAULT_READ_TIMEOUT = 5000;
         static final int DEFAULT_CONNECT_TIMEOUT = 2000;
         static final int DEFAULT_NUM_RETRIES = 3;

File: eureka-client/src/main/java/com/netflix/appinfo/PropertyBasedInstanceConfigConstants.java
Patch:
@@ -40,9 +40,6 @@ final class PropertyBasedInstanceConfigConstants {
 
 
     static class Values {
-        static final String DEFAULT_CONFIG_FILE_NAME = "eureka-client";
-        static final String DEFAULT_NAMESPACE = "eureka";
-
         static final String UNKNOWN_APPLICATION = "unknown";
 
         static final String DEFAULT_STATUSPAGE_URLPATH = "/Status";

File: eureka-client/src/main/java/com/netflix/discovery/PropertyBasedClientConfigConstants.java
Patch:
@@ -71,9 +71,6 @@ final class PropertyBasedClientConfigConstants {
 
 
     static class Values {
-        static final String DEFAULT_CONFIG_FILE_NAME = "eureka-client";
-        static final String DEFAULT_NAMESPACE = "eureka";
-
         static final String CONFIG_DOLLAR_REPLACEMENT = "_-";
         static final String CONFIG_ESCAPE_CHAR_REPLACEMENT = "__";
 

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/PropertyBasedTransportConfigConstants.java
Patch:
@@ -20,12 +20,10 @@ final class PropertyBasedTransportConfigConstants {
     static final String BOOTSTRAP_RESOLVER_STRATEGY_KEY = "bootstrapResolverStrategy";
     static final String USE_BOOTSTRAP_RESOLVER_FOR_QUERY = "useBootstrapResolverForQuery";
 
-    static final String TRANSPORT_CONFIG_PREFIX = "transport";
+    static final String TRANSPORT_CONFIG_SUB_NAMESPACE = "transport";
 
 
     static class Values {
-        static final String DEFAULT_CONFIG_FILE_NAME = "eureka-client";
-
         static final int SESSION_RECONNECT_INTERVAL = 20*60;
         static final double QUARANTINE_REFRESH_PERCENTAGE = 0.66;
         static final int DATA_STALENESS_TRHESHOLD = 5*60;

File: eureka-client/src/test/java/com/netflix/discovery/guice/EurekaModuleTest.java
Patch:
@@ -1,7 +1,6 @@
 package com.netflix.discovery.guice;
 
 import com.google.inject.AbstractModule;
-import com.google.inject.Injector;
 import com.google.inject.Scopes;
 import com.netflix.appinfo.ApplicationInfoManager;
 import com.netflix.appinfo.EurekaInstanceConfig;

File: eureka-client-jersey2/src/main/java/com/netflix/discovery/shared/transport/jersey2/Jersey2ApplicationClientFactory.java
Patch:
@@ -28,7 +28,6 @@
 import java.io.FileInputStream;
 import java.security.KeyStore;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
@@ -165,10 +164,10 @@ public void filter(ClientRequestContext requestContext) {
 
             MultivaluedMap<String, Object> additionalHeaders = new MultivaluedHashMap<>();
             if (allowRedirect) {
-                additionalHeaders.put(HTTP_X_DISCOVERY_ALLOW_REDIRECT, Arrays.<Object>asList("true"));
+                additionalHeaders.add(HTTP_X_DISCOVERY_ALLOW_REDIRECT, "true");
             }
             if (EurekaAccept.compact == eurekaAccept) {
-                additionalHeaders.put(EurekaAccept.HTTP_X_EUREKA_ACCEPT, Arrays.<Object>asList(eurekaAccept.name()));
+                additionalHeaders.add(EurekaAccept.HTTP_X_EUREKA_ACCEPT, eurekaAccept.name());
             }
 
             return new Jersey2ApplicationClientFactory(jersey2Client, additionalHeaders);

File: eureka-client/src/main/java/com/netflix/appinfo/EurekaInstanceConfig.java
Patch:
@@ -84,7 +84,7 @@ public interface EurekaInstanceConfig {
      * Get the <code>Secure port</code> on which the instance should receive
      * traffic.
      *
-     * @return the non-secure port on which the instance should receive traffic.
+     * @return the secure port on which the instance should receive traffic.
      */
     int getSecurePort();
 

File: eureka-client/src/main/java/com/netflix/appinfo/EurekaInstanceConfig.java
Patch:
@@ -84,7 +84,7 @@ public interface EurekaInstanceConfig {
      * Get the <code>Secure port</code> on which the instance should receive
      * traffic.
      *
-     * @return the non-secure port on which the instance should receive traffic.
+     * @return the secure port on which the instance should receive traffic.
      */
     int getSecurePort();
 

File: eureka-core/src/test/java/com/netflix/eureka/cluster/JerseyReplicationClientTest.java
Patch:
@@ -9,6 +9,7 @@
 import com.netflix.appinfo.InstanceInfo;
 import com.netflix.appinfo.InstanceInfo.InstanceStatus;
 import com.netflix.discovery.converters.EurekaJacksonCodec;
+import com.netflix.discovery.shared.transport.ClusterSampleData;
 import com.netflix.discovery.shared.transport.EurekaHttpResponse;
 import com.netflix.eureka.DefaultEurekaServerConfig;
 import com.netflix.eureka.EurekaServerConfig;

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -511,7 +511,7 @@ public Applications getApplications(int stalenessThreshold, TimeUnit timeUnit) {
                 );
                 newRegistrationClient = newRegistrationClientFactory.newClient();
             } catch (Exception e) {
-                logger.warn("Experimental transport initialization failure", e);
+                logger.warn("Transport initialization failure", e);
             }
             eurekaTransport.registrationClientFactory = newRegistrationClientFactory;
             eurekaTransport.registrationClient = newRegistrationClient;
@@ -533,7 +533,7 @@ public Applications getApplications(int stalenessThreshold, TimeUnit timeUnit) {
                 );
                 newQueryClient = newQueryClientFactory.newClient();
             } catch (Exception e) {
-                logger.warn("Experimental transport initialization failure", e);
+                logger.warn("Transport initialization failure", e);
             }
             eurekaTransport.queryClientFactory = newQueryClientFactory;
             eurekaTransport.queryClient = newQueryClient;

File: eureka-core/src/main/java/com/netflix/eureka/registry/PeerAwareInstanceRegistryImpl.java
Patch:
@@ -614,7 +614,7 @@ private void replicateToPeers(Action action, String appName, String id,
 
             for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
                 // If the url represents this host, do not replicate to yourself.
-                if (peerEurekaNodes.isThisMe(node.getServiceUrl())) {
+                if (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) {
                     continue;
                 }
                 replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);

File: eureka-core/src/main/java/com/netflix/eureka/registry/RemoteRegionRegistry.java
Patch:
@@ -143,7 +143,7 @@ public RemoteRegionRegistry(EurekaServerConfig serverConfig,
             newEurekaHttpClient = EurekaServerHttpClients.createRemoteRegionClient(
                     serverConfig, clientConfig.getTransportConfig(), serverCodecs, clusterResolver);
         } catch (Exception e) {
-            logger.warn("Experimental transport initialization failure", e);
+            logger.warn("Transport initialization failure", e);
         }
         this.eurekaHttpClient = newEurekaHttpClient;
 

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/EurekaClientFactoryBuilder.java
Patch:
@@ -18,7 +18,7 @@ public abstract class EurekaClientFactoryBuilder<F, B extends EurekaClientFactor
 
     private static final int DEFAULT_MAX_CONNECTIONS_PER_HOST = 50;
     private static final int DEFAULT_MAX_TOTAL_CONNECTIONS = 200;
-    private static final long DEFAULT_CONNECTION_IDLE_TIMEOUT = 30 * 1000;
+    private static final long DEFAULT_CONNECTION_IDLE_TIMEOUT = 30;
 
     protected InstanceInfo myInstanceInfo;
     protected boolean allowRedirect;

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/JerseyEurekaHttpClientFactory.java
Patch:
@@ -123,7 +123,7 @@ public static JerseyEurekaHttpClientFactory create(EurekaClientConfig clientConf
                 .withReadTimeout(clientConfig.getEurekaServerReadTimeoutSeconds() * 1000)
                 .withMaxConnectionsPerHost(clientConfig.getEurekaServerTotalConnectionsPerHost())
                 .withMaxTotalConnections(clientConfig.getEurekaServerTotalConnections())
-                .withConnectionIdleTimeout(clientConfig.getEurekaConnectionIdleTimeoutSeconds())
+                .withConnectionIdleTimeout(clientConfig.getEurekaConnectionIdleTimeoutSeconds() * 1000)
                 .withEncoder(clientConfig.getEncoderName())
                 .withDecoder(clientConfig.getDecoderName(), clientConfig.getClientDataAccept())
                 .withClientIdentity(clientIdentity);

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/EurekaClientFactoryBuilder.java
Patch:
@@ -18,7 +18,7 @@ public abstract class EurekaClientFactoryBuilder<F, B extends EurekaClientFactor
 
     private static final int DEFAULT_MAX_CONNECTIONS_PER_HOST = 50;
     private static final int DEFAULT_MAX_TOTAL_CONNECTIONS = 200;
-    private static final long DEFAULT_CONNECTION_IDLE_TIMEOUT = 30 * 1000;
+    private static final long DEFAULT_CONNECTION_IDLE_TIMEOUT = 30;
 
     protected InstanceInfo myInstanceInfo;
     protected boolean allowRedirect;

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/JerseyEurekaHttpClientFactory.java
Patch:
@@ -123,7 +123,7 @@ public static JerseyEurekaHttpClientFactory create(EurekaClientConfig clientConf
                 .withReadTimeout(clientConfig.getEurekaServerReadTimeoutSeconds() * 1000)
                 .withMaxConnectionsPerHost(clientConfig.getEurekaServerTotalConnectionsPerHost())
                 .withMaxTotalConnections(clientConfig.getEurekaServerTotalConnections())
-                .withConnectionIdleTimeout(clientConfig.getEurekaConnectionIdleTimeoutSeconds())
+                .withConnectionIdleTimeout(clientConfig.getEurekaConnectionIdleTimeoutSeconds() * 1000)
                 .withEncoder(clientConfig.getEncoderName())
                 .withDecoder(clientConfig.getDecoderName(), clientConfig.getClientDataAccept())
                 .withClientIdentity(clientIdentity);

File: eureka-examples/src/main/java/com/netflix/eureka/ExampleEurekaClient.java
Patch:
@@ -28,6 +28,7 @@
 import com.netflix.appinfo.EurekaInstanceConfig;
 import com.netflix.appinfo.InstanceInfo;
 import com.netflix.appinfo.MyDataCenterInstanceConfig;
+import com.netflix.appinfo.providers.EurekaConfigBasedInstanceInfoProvider;
 import com.netflix.discovery.DefaultEurekaClientConfig;
 import com.netflix.discovery.DiscoveryClient;
 import com.netflix.discovery.EurekaClient;
@@ -47,7 +48,8 @@ public class ExampleEurekaClient {
 
     private static synchronized ApplicationInfoManager initializeApplicationInfoManager(EurekaInstanceConfig instanceConfig) {
         if (applicationInfoManager == null) {
-            applicationInfoManager = new ApplicationInfoManager(instanceConfig);
+            InstanceInfo instanceInfo = new EurekaConfigBasedInstanceInfoProvider(instanceConfig).get();
+            applicationInfoManager = new ApplicationInfoManager(instanceConfig, instanceInfo);
         }
 
         return applicationInfoManager;

File: eureka-client/src/main/java/com/netflix/appinfo/CloudInstanceConfig.java
Patch:
@@ -81,7 +81,7 @@ private void initCloudInstanceConfig(String namespace) {
     private AmazonInfo initDataCenterInfo() {
         AmazonInfo info;
         try {
-            info = AmazonInfo.Builder.newBuilder().autoBuild(namespace, true /* fail fast */);
+            info = AmazonInfo.Builder.newBuilder().autoBuild(namespace);
             logger.info("Datacenter is: " + Name.Amazon);
         } catch (Throwable e) {
             logger.error("Cannot initialize amazon info :", e);

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -1211,9 +1211,7 @@ private void updateDelta(Applications delta) {
                 }
             }
         }
-        logger.debug(
-                "The total number of instances fetched by the delta processor : {}",
-                deltaCount);
+        logger.debug("The total number of instances fetched by the delta processor : {}", deltaCount);
 
         getApplications().setVersion(delta.getVersion());
         getApplications().shuffleInstances(clientConfig.shouldFilterOnlyUpInstances());

File: eureka-core/src/test/java/com/netflix/eureka/cluster/PeerEurekaNodeTest.java
Patch:
@@ -151,7 +151,7 @@ private PeerEurekaNode createPeerEurekaNode() {
     }
 
     private Object expectRequestType(RequestType requestType) throws InterruptedException {
-        HandledRequest handledRequest = httpReplicationClient.nextHandledRequest(30, TimeUnit.SECONDS);
+        HandledRequest handledRequest = httpReplicationClient.nextHandledRequest(60, TimeUnit.SECONDS);
         assertThat(handledRequest, is(notNullValue()));
         assertThat(handledRequest.getRequestType(), is(equalTo(requestType)));
         return handledRequest.getData();

File: eureka-core/src/test/java/com/netflix/eureka/cluster/PeerEurekaNodesTest.java
Patch:
@@ -58,7 +58,7 @@ public void testReloadWithNoPeerChange() throws Exception {
         peerEurekaNodes.start();
 
         PeerEurekaNode peerNode = getPeerNode(PEER_EUREKA_URL_A);
-        assertThat(peerEurekaNodes.awaitNextReload(10, TimeUnit.SECONDS), is(true));
+        assertThat(peerEurekaNodes.awaitNextReload(60, TimeUnit.SECONDS), is(true));
         assertThat(getPeerNode(PEER_EUREKA_URL_A), is(equalTo(peerNode)));
     }
 
@@ -72,13 +72,13 @@ public void testReloadWithPeerUpdates() throws Exception {
         // Add one more peer
         peerEurekaNodes.withPeerUrls(PEER_EUREKA_URL_A, PEER_EUREKA_URL_B);
 
-        assertThat(peerEurekaNodes.awaitNextReload(10, TimeUnit.SECONDS), is(true));
+        assertThat(peerEurekaNodes.awaitNextReload(60, TimeUnit.SECONDS), is(true));
         assertThat(getPeerNode(PEER_EUREKA_URL_A), is(notNullValue()));
         assertThat(getPeerNode(PEER_EUREKA_URL_B), is(notNullValue()));
 
         // Remove first peer, and add yet another one
         peerEurekaNodes.withPeerUrls(PEER_EUREKA_URL_B, PEER_EUREKA_URL_C);
-        assertThat(peerEurekaNodes.awaitNextReload(10, TimeUnit.SECONDS), is(true));
+        assertThat(peerEurekaNodes.awaitNextReload(60, TimeUnit.SECONDS), is(true));
         assertThat(getPeerNode(PEER_EUREKA_URL_A), is(nullValue()));
         assertThat(getPeerNode(PEER_EUREKA_URL_B), is(notNullValue()));
         assertThat(getPeerNode(PEER_EUREKA_URL_C), is(notNullValue()));

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -1211,7 +1211,7 @@ private void updateDelta(Applications delta) {
                         applications.getRegisteredApplications(instance.getAppName()).removeInstance(instance);
                     }
                 } catch (Exception e) {
-                    logger.warn("Error applying delta of instanceInfo: {}", instance);
+                    logger.warn("Error applying delta of instanceInfo with id:{}, appName:{}", instance.getId(), instance.getAppName(), e);
                 }
             }
         }

File: eureka-server-governator/src/main/java/com/netflix/eureka/EurekaContextListener.java
Patch:
@@ -45,7 +45,7 @@ protected LifecycleInjector createInjector() {
         JsonXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);
         XmlXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);
 
-        LifecycleInjector injector = EurekaInjectorCreator.createInjector(false);
+        LifecycleInjector injector = EurekaInjectorCreator.createInjector();
         serverContext = injector.getInstance(EurekaServerContext.class);
         return injector;
     }

File: eureka-server-governator/src/main/java/com/netflix/eureka/guice/Ec2EurekaServerModule.java
Patch:
@@ -14,12 +14,10 @@
 import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
 import com.netflix.eureka.resources.DefaultServerCodecs;
 import com.netflix.eureka.resources.ServerCodecs;
-import com.netflix.karyon.conditional.ConditionalOnEc2;
 
 /**
  * @author David Liu
  */
-@ConditionalOnEc2
 public class Ec2EurekaServerModule extends AbstractModule {
     @Override
     protected void configure() {

File: eureka-server-governator/src/main/java/com/netflix/eureka/guice/LocalDevEurekaServerModule.java
Patch:
@@ -13,12 +13,10 @@
 import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl;
 import com.netflix.eureka.resources.DefaultServerCodecs;
 import com.netflix.eureka.resources.ServerCodecs;
-import com.netflix.karyon.conditional.ConditionalOnLocalDev;
 
 /**
  * @author David Liu
  */
-@ConditionalOnLocalDev
 public class LocalDevEurekaServerModule extends AbstractModule {
     @Override
     protected void configure() {

File: eureka-server-governator/src/main/java/com/netflix/eureka/EurekaContextListener.java
Patch:
@@ -45,7 +45,7 @@ protected LifecycleInjector createInjector() {
         JsonXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);
         XmlXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);
 
-        LifecycleInjector injector = EurekaInjectorCreator.createInjector(false);
+        LifecycleInjector injector = EurekaInjectorCreator.createInjector();
         serverContext = injector.getInstance(EurekaServerContext.class);
         return injector;
     }

File: eureka-server-governator/src/main/java/com/netflix/eureka/guice/Ec2EurekaServerModule.java
Patch:
@@ -14,12 +14,10 @@
 import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
 import com.netflix.eureka.resources.DefaultServerCodecs;
 import com.netflix.eureka.resources.ServerCodecs;
-import com.netflix.karyon.conditional.ConditionalOnEc2;
 
 /**
  * @author David Liu
  */
-@ConditionalOnEc2
 public class Ec2EurekaServerModule extends AbstractModule {
     @Override
     protected void configure() {

File: eureka-server-governator/src/main/java/com/netflix/eureka/guice/LocalDevEurekaServerModule.java
Patch:
@@ -13,12 +13,10 @@
 import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl;
 import com.netflix.eureka.resources.DefaultServerCodecs;
 import com.netflix.eureka.resources.ServerCodecs;
-import com.netflix.karyon.conditional.ConditionalOnLocalDev;
 
 /**
  * @author David Liu
  */
-@ConditionalOnLocalDev
 public class LocalDevEurekaServerModule extends AbstractModule {
     @Override
     protected void configure() {

File: eureka-client/src/test/java/com/netflix/discovery/shared/resolver/aws/ConfigClusterResolverTest.java
Patch:
@@ -32,7 +32,7 @@ public class ConfigClusterResolverTest {
             "http://1.1.2.2:8000/eureka/v2/"
     );
     private final List<String> endpointsE = Arrays.asList(
-            "https://1.1.3.1:8000/eureka/v2/"
+            "https://1.1.3.1/eureka/v2/"
     );
     private ConfigClusterResolver resolver;
 
@@ -59,7 +59,8 @@ public void testReadFromConfig() {
 
 		for (AwsEndpoint endpoint : endpoints) {
 			if (endpoint.getZone().equals("us-east-1e")) {
-				assertThat(endpoint.isSecure(), equalTo(true));
+				assertThat("secure was wrong", endpoint.isSecure(), equalTo(true));
+				assertThat("serviceUrl contains -1", endpoint.getServiceUrl().contains("-1"), equalTo(false));
 			}
 		}
     }

File: eureka-client/src/test/java/com/netflix/discovery/shared/resolver/aws/ConfigClusterResolverTest.java
Patch:
@@ -32,7 +32,7 @@ public class ConfigClusterResolverTest {
             "http://1.1.2.2:8000/eureka/v2/"
     );
     private final List<String> endpointsE = Arrays.asList(
-            "https://1.1.3.1:8000/eureka/v2/"
+            "https://1.1.3.1/eureka/v2/"
     );
     private ConfigClusterResolver resolver;
 
@@ -59,7 +59,8 @@ public void testReadFromConfig() {
 
 		for (AwsEndpoint endpoint : endpoints) {
 			if (endpoint.getZone().equals("us-east-1e")) {
-				assertThat(endpoint.isSecure(), equalTo(true));
+				assertThat("secure was wrong", endpoint.isSecure(), equalTo(true));
+				assertThat("serviceUrl contains -1", endpoint.getServiceUrl().contains("-1"), equalTo(false));
 			}
 		}
     }

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/aws/ConfigClusterResolver.java
Patch:
@@ -76,7 +76,7 @@ private List<AwsEndpoint> getClusterEndpointsFromConfig() {
                     endpoints.add(new AwsEndpoint(
                             serviceURI.getHost(),
                             serviceURI.getPort(),
-                            "https".equalsIgnoreCase(serviceURI.getSchemeSpecificPart()),
+                            "https".equalsIgnoreCase(serviceURI.getScheme()),
                             serviceURI.getPath(),
                             getRegion(),
                             zone

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -444,7 +444,7 @@ private void scheduleServerEndpointTask(EurekaTransport eurekaTransport,
                 .newBootstrapResolver(clientConfig, applicationInfoManager.getInfo());
 
         Collection<ClientFilter> additionalFilters = args == null
-                ? Collections.emptyList()
+                ? Collections.<ClientFilter>emptyList()
                 : args.additionalFilters;
 
         EurekaJerseyClient providedJerseyClient = args == null

File: eureka-client/src/test/java/com/netflix/discovery/shared/transport/EurekaHttpClientsTest.java
Patch:
@@ -192,7 +192,7 @@ public void testCanonicalResolver() throws Exception {
     @Test
     public void testAddingAdditionalFilters() throws Exception {
         TestFilter testFilter = new TestFilter();
-        Collection<ClientFilter> additionalFilters = Arrays.asList(testFilter);
+        Collection<ClientFilter> additionalFilters = Arrays.<ClientFilter>asList(testFilter);
 
         TransportClientFactory transportClientFactory = TransportClientFactories.newTransportClientFactory(
                 clientConfig,

File: eureka-core/src/main/java/com/netflix/eureka/transport/JerseyRemoteRegionClientFactory.java
Patch:
@@ -61,7 +61,7 @@ public JerseyRemoteRegionClientFactory(EurekaServerConfig serverConfig,
 
     @Override
     public EurekaHttpClient newClient(EurekaEndpoint endpoint) {
-        return new JerseyApplicationClient(getOrCreateJerseyClient(region, endpoint).getClient(), endpoint.getServiceUrl(), Collections.emptyMap());
+        return new JerseyApplicationClient(getOrCreateJerseyClient(region, endpoint).getClient(), endpoint.getServiceUrl(), Collections.<String, String>emptyMap());
     }
 
     @Override

File: eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java
Patch:
@@ -299,7 +299,7 @@ public Map<String, List<String>> getReconcileMapDiff(Applications apps) {
         for (Application otherApp : apps.getRegisteredApplications()) {
             Application thisApp = this.getRegisteredApplications(otherApp.getName());
             if (thisApp == null) {
-                logger.warn("The application %s is not found in local cache :", otherApp.getName());
+                logger.warn("Application not found in local cache : {}", otherApp.getName());
                 continue;
             }
             for (InstanceInfo instanceInfo : thisApp.getInstancesAsIsFromEureka()) {

File: eureka-client/src/test/java/com/netflix/discovery/shared/transport/EurekaHttpClientsTest.java
Patch:
@@ -159,7 +159,7 @@ public void testCompositeBootstrapResolver() throws Exception {
         when(clientConfig.getRegion()).thenReturn("us-east-1");
 
         when(transportConfig.getWriteClusterVip()).thenReturn(vipAddress);
-        when(transportConfig.getAsyncExecutorThreadPoolSize()).thenReturn(3);
+        when(transportConfig.getAsyncExecutorThreadPoolSize()).thenReturn(4);
         when(transportConfig.getAsyncResolverRefreshIntervalMs()).thenReturn(300);
         when(transportConfig.getAsyncResolverWarmUpTimeoutMs()).thenReturn(200);
 
@@ -195,10 +195,10 @@ public void testCompositeBootstrapResolver() throws Exception {
             endpoints = resolver.getClusterEndpoints();
             assertThat(endpoints.size(), equalTo(applications.getInstancesByVirtualHostName(vipAddress).size()));
 
-            // wait for the third cycle that hits the app source
+            // wait for the third cycle that triggers the mock http client (which is the third resolver cycle)
             // for the third cycle we have mocked the application resolver to return null data so should fall back
             // to calling the remote resolver again (which should return applications2)
-            verify(applicationsSource, timeout(1000).times(3)).getApplications(anyInt(), eq(TimeUnit.SECONDS));
+            verify(mockHttpClient, timeout(1000).times(3)).getVip(anyString());
             endpoints = resolver.getClusterEndpoints();
             assertThat(endpoints.size(), equalTo(applications2.getInstancesByVirtualHostName(vipAddress).size()));
         } finally {

File: eureka-client/src/main/java/com/netflix/discovery/shared/NamedConnectionPool.java
Patch:
@@ -167,6 +167,8 @@ public int getConnectionCount() {
     @Override
     public void shutdown() {
         super.shutdown();
-        Monitors.unregisterObject(name, this);
+        if(Monitors.isObjectRegistered(name, this)) {
+            Monitors.unregisterObject(name, this);
+        }
     }
 }

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/AsyncResolver.java
Patch:
@@ -133,7 +133,9 @@ public AsyncResolver(String name,
 
     @Override
     public void shutdown() {
-        Monitors.unregisterObject(name, this);
+        if(Monitors.isObjectRegistered(name, this)) {
+            Monitors.unregisterObject(name, this);
+        }
         executorService.shutdown();
         threadPoolExecutor.shutdown();
         backgroundTask.cancel();

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/decorator/RetryableEurekaHttpClient.java
Patch:
@@ -88,7 +88,9 @@ public RetryableEurekaHttpClient(String name,
     @Override
     public void shutdown() {
         TransportUtils.shutdown(delegate.get());
-        Monitors.unregisterObject(name, this);
+        if(Monitors.isObjectRegistered(name, this)) {
+            Monitors.unregisterObject(name, this);
+        }
     }
 
     @Override

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/decorator/SessionedEurekaHttpClient.java
Patch:
@@ -79,7 +79,9 @@ protected <R> EurekaHttpResponse<R> execute(RequestExecutor<R> requestExecutor)
 
     @Override
     public void shutdown() {
-        Monitors.unregisterObject(name, this);
+        if(Monitors.isObjectRegistered(name, this)) {
+            Monitors.unregisterObject(name, this);
+        }
         TransportUtils.shutdown(eurekaHttpClientRef.getAndSet(null));
     }
 

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/AbstractJerseyEurekaHttpClient.java
Patch:
@@ -258,7 +258,6 @@ private EurekaHttpResponse<InstanceInfo> getInstanceInternal(String urlPath) {
             Builder requestBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();
             addExtraHeaders(requestBuilder);
             response = requestBuilder.accept(MediaType.APPLICATION_JSON_TYPE).get(ClientResponse.class);
-            // FIXME add clientAccept
 
             InstanceInfo infoFromPeer = null;
             if (response.getStatus() == Status.OK.getStatusCode() && response.hasEntity()) {

File: eureka-client/src/main/java/com/netflix/discovery/shared/NamedConnectionPool.java
Patch:
@@ -167,6 +167,8 @@ public int getConnectionCount() {
     @Override
     public void shutdown() {
         super.shutdown();
-        Monitors.unregisterObject(name, this);
+        if(Monitors.isObjectRegistered(name, this)) {
+            Monitors.unregisterObject(name, this);
+        }
     }
 }

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/AsyncResolver.java
Patch:
@@ -133,7 +133,9 @@ public AsyncResolver(String name,
 
     @Override
     public void shutdown() {
-        Monitors.unregisterObject(name, this);
+        if(Monitors.isObjectRegistered(name, this)) {
+            Monitors.unregisterObject(name, this);
+        }
         executorService.shutdown();
         threadPoolExecutor.shutdown();
         backgroundTask.cancel();

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/decorator/RetryableEurekaHttpClient.java
Patch:
@@ -88,7 +88,9 @@ public RetryableEurekaHttpClient(String name,
     @Override
     public void shutdown() {
         TransportUtils.shutdown(delegate.get());
-        Monitors.unregisterObject(name, this);
+        if(Monitors.isObjectRegistered(name, this)) {
+            Monitors.unregisterObject(name, this);
+        }
     }
 
     @Override

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/decorator/SessionedEurekaHttpClient.java
Patch:
@@ -79,7 +79,9 @@ protected <R> EurekaHttpResponse<R> execute(RequestExecutor<R> requestExecutor)
 
     @Override
     public void shutdown() {
-        Monitors.unregisterObject(name, this);
+        if(Monitors.isObjectRegistered(name, this)) {
+            Monitors.unregisterObject(name, this);
+        }
         TransportUtils.shutdown(eurekaHttpClientRef.getAndSet(null));
     }
 

File: eureka-client/src/main/java/com/netflix/discovery/util/ExceptionsMetric.java
Patch:
@@ -33,7 +33,7 @@ public class ExceptionsMetric {
 
     private final String name;
 
-    private final Map<String, Counter> exceptionCounters = new ConcurrentHashMap<>();
+    private final ConcurrentHashMap<String, Counter> exceptionCounters = new ConcurrentHashMap<>();
 
     public ExceptionsMetric(String name) {
         this.name = name;

File: eureka-client/src/main/java/com/netflix/discovery/util/ExceptionsMetric.java
Patch:
@@ -33,7 +33,7 @@ public class ExceptionsMetric {
 
     private final String name;
 
-    private final Map<String, Counter> exceptionCounters = new ConcurrentHashMap<>();
+    private final ConcurrentHashMap<String, Counter> exceptionCounters = new ConcurrentHashMap<>();
 
     public ExceptionsMetric(String name) {
         this.name = name;

File: eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java
Patch:
@@ -34,7 +34,7 @@
 import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
 import com.netflix.config.DynamicBooleanProperty;
 import com.netflix.config.DynamicIntProperty;
-import com.netflix.discovery.converters.jackson.StringInterningAmazonInfoBuilder;
+import com.netflix.discovery.converters.jackson.builder.StringInterningAmazonInfoBuilder;
 import com.thoughtworks.xstream.annotations.XStreamOmitField;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: eureka-client/src/main/java/com/netflix/discovery/converters/jackson/EurekaXmlJacksonCodec.java
Patch:
@@ -22,10 +22,12 @@
 import com.fasterxml.jackson.databind.module.SimpleModule;
 import com.fasterxml.jackson.dataformat.xml.XmlMapper;
 import com.netflix.appinfo.DataCenterInfo;
+import com.netflix.appinfo.InstanceInfo;
 import com.netflix.discovery.converters.KeyFormatter;
 import com.netflix.discovery.converters.jackson.mixin.ApplicationXmlMixIn;
 import com.netflix.discovery.converters.jackson.mixin.ApplicationsXmlMixIn;
 import com.netflix.discovery.converters.jackson.mixin.DataCenterInfoXmlMixIn;
+import com.netflix.discovery.converters.jackson.mixin.PortWrapperXmlMixIn;
 import com.netflix.discovery.shared.Application;
 import com.netflix.discovery.shared.Applications;
 
@@ -51,10 +53,10 @@ public ObjectMapper registerModule(Module module) {
         };
         xmlMapper.setSerializationInclusion(Include.NON_NULL);
         xmlMapper.addMixIn(DataCenterInfo.class, DataCenterInfoXmlMixIn.class);
+        xmlMapper.addMixIn(InstanceInfo.PortWrapper.class, PortWrapperXmlMixIn.class);
         xmlMapper.addMixIn(Application.class, ApplicationXmlMixIn.class);
         xmlMapper.addMixIn(Applications.class, ApplicationsXmlMixIn.class);
         SimpleModule xmlModule = new SimpleModule();
-        xmlModule.setDeserializerModifier(EurekaJacksonXmlModifiers.createXmlDeserializerModifier(keyFormatter, compact));
         xmlMapper.registerModule(xmlModule);
 
         if (compact) {

File: eureka-client/src/main/java/com/netflix/discovery/converters/jackson/mixin/InstanceInfoJsonMixIn.java
Patch:
@@ -19,9 +19,10 @@
 import java.util.Map;
 
 import com.fasterxml.jackson.annotation.JsonIgnore;
+import com.netflix.discovery.converters.jackson.serializer.InstanceInfoJsonBeanSerializer;
 
 /**
- * @author Tomasz Bak
+ * Meta data are handled directly by {@link InstanceInfoJsonBeanSerializer}, for backwards compatibility reasons.
  */
 public interface InstanceInfoJsonMixIn {
 

File: eureka-client/src/main/java/com/netflix/discovery/util/DiscoveryBuildInfo.java
Patch:
@@ -63,7 +63,7 @@ private static Manifest loadManifest(String jarUrl) throws Exception {
     private static String resolveJarUrl(Class<?> clazz) {
         URL location = clazz.getResource('/' + clazz.getName().replace('.', '/') + ".class");
         if (location != null) {
-            Matcher matcher = Pattern.compile("(jar:file.*-[\\d.]+(-SNAPSHOT)?.jar)!.*$").matcher(location.toString());
+            Matcher matcher = Pattern.compile("(jar:file.*-[\\d.]+(-rc[\\d]+|-SNAPSHOT)?.jar)!.*$").matcher(location.toString());
             if (matcher.matches()) {
                 return matcher.group(1);
             }

File: eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java
Patch:
@@ -70,8 +70,8 @@ public DiscoveryJerseyProvider() {
     }
 
     public DiscoveryJerseyProvider(EncoderWrapper encoder, DecoderWrapper decoder) {
-        this.encoder = encoder == null ? CodecWrappers.getEncoder(CodecWrappers.JacksonJson.class) : encoder;
-        this.decoder = decoder == null ? CodecWrappers.getDecoder(CodecWrappers.JacksonJson.class) : decoder;
+        this.encoder = encoder == null ? CodecWrappers.getEncoder(LegacyJacksonJson.class) : encoder;
+        this.decoder = decoder == null ? CodecWrappers.getDecoder(LegacyJacksonJson.class) : decoder;
 
         if (encoder instanceof CodecWrappers.JacksonJsonMini) {
             throw new UnsupportedOperationException("Encoder: " + encoder.codecName() + "is not supported for the client");

File: eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java
Patch:
@@ -70,8 +70,8 @@ public DiscoveryJerseyProvider() {
     }
 
     public DiscoveryJerseyProvider(EncoderWrapper encoder, DecoderWrapper decoder) {
-        this.encoder = encoder == null ? CodecWrappers.getEncoder(CodecWrappers.JacksonJson.class) : encoder;
-        this.decoder = decoder == null ? CodecWrappers.getDecoder(CodecWrappers.JacksonJson.class) : decoder;
+        this.encoder = encoder == null ? CodecWrappers.getEncoder(LegacyJacksonJson.class) : encoder;
+        this.decoder = decoder == null ? CodecWrappers.getDecoder(LegacyJacksonJson.class) : decoder;
 
         if (encoder instanceof CodecWrappers.JacksonJsonMini) {
             throw new UnsupportedOperationException("Encoder: " + encoder.codecName() + "is not supported for the client");

File: eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java
Patch:
@@ -70,8 +70,8 @@ public DiscoveryJerseyProvider() {
     }
 
     public DiscoveryJerseyProvider(EncoderWrapper encoder, DecoderWrapper decoder) {
-        this.encoder = encoder == null ? CodecWrappers.getEncoder(LegacyJacksonJson.class) : encoder;
-        this.decoder = decoder == null ? CodecWrappers.getDecoder(LegacyJacksonJson.class) : decoder;
+        this.encoder = encoder == null ? CodecWrappers.getEncoder(CodecWrappers.JacksonJson.class) : encoder;
+        this.decoder = decoder == null ? CodecWrappers.getDecoder(CodecWrappers.JacksonJson.class) : decoder;
 
         if (encoder instanceof CodecWrappers.JacksonJsonMini) {
             throw new UnsupportedOperationException("Encoder: " + encoder.codecName() + "is not supported for the client");

File: eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java
Patch:
@@ -70,8 +70,8 @@ public DiscoveryJerseyProvider() {
     }
 
     public DiscoveryJerseyProvider(EncoderWrapper encoder, DecoderWrapper decoder) {
-        this.encoder = encoder == null ? CodecWrappers.getEncoder(LegacyJacksonJson.class) : encoder;
-        this.decoder = decoder == null ? CodecWrappers.getDecoder(LegacyJacksonJson.class) : decoder;
+        this.encoder = encoder == null ? CodecWrappers.getEncoder(CodecWrappers.JacksonJson.class) : encoder;
+        this.decoder = decoder == null ? CodecWrappers.getDecoder(CodecWrappers.JacksonJson.class) : decoder;
 
         if (encoder instanceof CodecWrappers.JacksonJsonMini) {
             throw new UnsupportedOperationException("Encoder: " + encoder.codecName() + "is not supported for the client");

File: eureka-client/src/main/java/com/netflix/appinfo/ApplicationInfoManager.java
Patch:
@@ -151,11 +151,11 @@ public void unregisterStatusChangeListener(String listenerId) {
      */
     public void refreshDataCenterInfoIfRequired() {
         String existingAddress = instanceInfo.getHostName();
-        DataCenterInfo dataCenterInfo = instanceInfo.getDataCenterInfo();
 
         String newAddress;
         if (config instanceof CloudInstanceConfig) {
-            newAddress = ((CloudInstanceConfig) config).resolveDefaultAddress(dataCenterInfo);
+            // Refresh data center info, and return up to date address
+            newAddress = ((CloudInstanceConfig) config).resolveDefaultAddress();
         } else {
             newAddress = config.getHostName(true);
         }

File: eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java
Patch:
@@ -63,7 +63,8 @@ public synchronized InstanceInfo get() {
 
             String defaultAddress;
             if (config instanceof CloudInstanceConfig) {
-                defaultAddress = ((CloudInstanceConfig) config).resolveDefaultAddress(dataCenterInfo);
+                // Refresh AWS data center info, and return up to date address
+                defaultAddress = ((CloudInstanceConfig) config).resolveDefaultAddress();
             } else {
                 defaultAddress = config.getHostName(false);
             }

File: eureka-client/src/main/java/com/netflix/appinfo/ApplicationInfoManager.java
Patch:
@@ -151,11 +151,11 @@ public void unregisterStatusChangeListener(String listenerId) {
      */
     public void refreshDataCenterInfoIfRequired() {
         String existingAddress = instanceInfo.getHostName();
-        DataCenterInfo dataCenterInfo = instanceInfo.getDataCenterInfo();
 
         String newAddress;
         if (config instanceof CloudInstanceConfig) {
-            newAddress = ((CloudInstanceConfig) config).resolveDefaultAddress(dataCenterInfo);
+            // Refresh data center info, and return up to date address
+            newAddress = ((CloudInstanceConfig) config).resolveDefaultAddress();
         } else {
             newAddress = config.getHostName(true);
         }

File: eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java
Patch:
@@ -63,7 +63,8 @@ public synchronized InstanceInfo get() {
 
             String defaultAddress;
             if (config instanceof CloudInstanceConfig) {
-                defaultAddress = ((CloudInstanceConfig) config).resolveDefaultAddress(dataCenterInfo);
+                // Refresh AWS data center info, and return up to date address
+                defaultAddress = ((CloudInstanceConfig) config).resolveDefaultAddress();
             } else {
                 defaultAddress = config.getHostName(false);
             }

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/EurekaTransportConfig.java
Patch:
@@ -1,6 +1,8 @@
 package com.netflix.discovery.shared.transport;
 
 /**
+ * Config class that governs configurations relevant to the transport layer
+ *
  * @author David Liu
  */
 public interface EurekaTransportConfig {

File: eureka-client/src/main/java/com/netflix/appinfo/ApplicationInfoManager.java
Patch:
@@ -147,10 +147,10 @@ public void unregisterStatusChangeListener(String listenerId) {
      * <code>DataCenterInfo</code> is refetched and passed on to the eureka
      * server on next heartbeat.
      *
-     * see {@link InstanceInfo#getDefaultAddress()} for explanation on why the hostname is used as the default address
+     * see {@link InstanceInfo#getHostName()} for explanation on why the hostname is used as the default address
      */
     public void refreshDataCenterInfoIfRequired() {
-        String existingAddress = instanceInfo.getDefaultAddress();
+        String existingAddress = instanceInfo.getHostName();
         DataCenterInfo dataCenterInfo = instanceInfo.getDataCenterInfo();
 
         String newAddress;

File: eureka-client/src/test/java/com/netflix/appinfo/ApplicationInfoManagerTest.java
Patch:
@@ -50,12 +50,12 @@ public void setUp() {
     public void testRefreshDataCenterInfoWithAmazonInfo() {
         AmazonInfo info = (AmazonInfo) instanceInfo.getDataCenterInfo();
         String newPublicHostname = "newValue";
-        assertThat(instanceInfo.getDefaultAddress(), is(not(newPublicHostname)));
+        assertThat(instanceInfo.getHostName(), is(not(newPublicHostname)));
 
         info.getMetadata().put(publicHostname.getName(), newPublicHostname);
         applicationInfoManager.refreshDataCenterInfoIfRequired();
 
-        assertThat(instanceInfo.getDefaultAddress(), is(newPublicHostname));
+        assertThat(instanceInfo.getHostName(), is(newPublicHostname));
     }
 
     @Test
@@ -68,6 +68,6 @@ public void testRefreshDataCenterInfoWithMyDataCenterInfo() {
         assertThat(info, instanceOf(MyDataCenterInfo.class));
 
         applicationInfoManager.refreshDataCenterInfoIfRequired();
-        assertThat(instanceInfo.getDefaultAddress(), is(dummyDefault));
+        assertThat(instanceInfo.getHostName(), is(dummyDefault));
     }
 }

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/EurekaTransportConfig.java
Patch:
@@ -1,6 +1,8 @@
 package com.netflix.discovery.shared.transport;
 
 /**
+ * Config class that governs configurations relevant to the transport layer
+ *
  * @author David Liu
  */
 public interface EurekaTransportConfig {

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/EurekaClientFactoryBuilder.java
Patch:
@@ -15,6 +15,7 @@ public abstract class EurekaClientFactoryBuilder<F, B extends EurekaClientFactor
 
     private static final int DEFAULT_MAX_CONNECTIONS_PER_HOST = 50;
     private static final int DEFAULT_MAX_TOTAL_CONNECTIONS = 200;
+    private static final long DEFAULT_CONNECTION_IDLE_TIMEOUT = 30 * 1000;
 
     protected InstanceInfo myInstanceInfo;
     protected boolean allowRedirect;
@@ -32,7 +33,7 @@ public abstract class EurekaClientFactoryBuilder<F, B extends EurekaClientFactor
     protected int proxyPort;
     protected int connectionTimeout;
     protected int readTimeout;
-    protected int connectionIdleTimeout;
+    protected long connectionIdleTimeout = DEFAULT_CONNECTION_IDLE_TIMEOUT;
     protected EncoderWrapper encoderWrapper;
     protected DecoderWrapper decoderWrapper;
     protected AbstractEurekaIdentity clientIdentity;
@@ -67,7 +68,7 @@ public B withReadTimeout(int readTimeout) {
         return self();
     }
 
-    public B withConnectionIdleTimeout(int connectionIdleTimeout) {
+    public B withConnectionIdleTimeout(long connectionIdleTimeout) {
         this.connectionIdleTimeout = connectionIdleTimeout;
         return self();
     }

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/EurekaClientFactoryBuilder.java
Patch:
@@ -15,6 +15,7 @@ public abstract class EurekaClientFactoryBuilder<F, B extends EurekaClientFactor
 
     private static final int DEFAULT_MAX_CONNECTIONS_PER_HOST = 50;
     private static final int DEFAULT_MAX_TOTAL_CONNECTIONS = 200;
+    private static final long DEFAULT_CONNECTION_IDLE_TIMEOUT = 30 * 1000;
 
     protected InstanceInfo myInstanceInfo;
     protected boolean allowRedirect;
@@ -32,7 +33,7 @@ public abstract class EurekaClientFactoryBuilder<F, B extends EurekaClientFactor
     protected int proxyPort;
     protected int connectionTimeout;
     protected int readTimeout;
-    protected int connectionIdleTimeout;
+    protected long connectionIdleTimeout = DEFAULT_CONNECTION_IDLE_TIMEOUT;
     protected EncoderWrapper encoderWrapper;
     protected DecoderWrapper decoderWrapper;
     protected AbstractEurekaIdentity clientIdentity;
@@ -67,7 +68,7 @@ public B withReadTimeout(int readTimeout) {
         return self();
     }
 
-    public B withConnectionIdleTimeout(int connectionIdleTimeout) {
+    public B withConnectionIdleTimeout(long connectionIdleTimeout) {
         this.connectionIdleTimeout = connectionIdleTimeout;
         return self();
     }

File: eureka-core/src/test/java/com/netflix/eureka/resources/ApplicationResourceTest.java
Patch:
@@ -81,7 +81,7 @@ public void testMiniAppGet() throws Exception {
     public void testGoodRegistration() throws Exception {
         InstanceInfo noIdInfo = InstanceInfoGenerator.takeOne();
         Response response = applicationResource.addInstance(noIdInfo, false+"");
-        assertThat(response.getStatus(), is(200));
+        assertThat(response.getStatus(), is(204));
     }
 
     @Test

File: eureka-client-archaius2/src/main/java/com/netflix/discovery/shared/transport/EurekaArchaius2TransportConfig.java
Patch:
@@ -61,6 +61,6 @@ public String getReadClusterVip() {
 
     @Override
     public boolean useBootstrapResolverForQuery() {
-        return config.getBoolean("useBootstrapResolverForQuery", false);
+        return config.getBoolean("useBootstrapResolverForQuery", true);
     }
 }

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/DefaultEurekaTransportConfig.java
Patch:
@@ -55,6 +55,6 @@ public String getReadClusterVip() {
 
     @Override
     public boolean useBootstrapResolverForQuery() {
-        return configInstance.getBooleanProperty(namespace + "useBootstrapResolverForQuery", false).get();
+        return configInstance.getBooleanProperty(namespace + "useBootstrapResolverForQuery", true).get();
     }
 }

File: eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2Module.java
Patch:
@@ -6,6 +6,8 @@
 import com.netflix.appinfo.InstanceInfo;
 import com.netflix.appinfo.providers.EurekaConfigBasedInstanceInfoProvider;
 import com.netflix.archaius.Config;
+import com.netflix.discovery.shared.transport.EurekaArchaius2TransportConfig;
+import com.netflix.discovery.shared.transport.EurekaTransportConfig;
 
 /**
  * Add this module to your project to enable Eureka client and registration
@@ -20,6 +22,7 @@ protected void configure() {
 
         // Bindings for eureka
         bind(EurekaInstanceConfig.class).to(CloudInstanceConfig.class);
+        bind(EurekaTransportConfig.class).to(EurekaArchaius2TransportConfig.class);
         bind(EurekaArchaius2ClientConfig.class).to(EurekaArchaius2ClientConfig.class);
         bind(InstanceInfo.class).toProvider(EurekaConfigBasedInstanceInfoProvider.class);
         bind(EurekaClient.class).to(DiscoveryClient.class);

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/aws/ApplicationsResolver.java
Patch:
@@ -40,7 +40,9 @@ public String getRegion() {
     public List<AwsEndpoint> getClusterEndpoints() {
         List<AwsEndpoint> result = new ArrayList<>();
 
-        Applications applications = applicationsSource.getApplications(5, TimeUnit.MINUTES);
+        Applications applications = applicationsSource.getApplications(
+                transportConfig.getApplicationsResolverDataStalenessThresholdSeconds(), TimeUnit.SECONDS);
+
         String vipAddress = transportConfig.getReadClusterVip();
         if (applications != null && vipAddress != null) {
             List<InstanceInfo> validInstanceInfos = applications.getInstancesByVirtualHostName(vipAddress);

File: eureka-test-utils/src/main/java/com/netflix/discovery/util/InstanceInfoGenerator.java
Patch:
@@ -119,6 +119,7 @@ public Applications toApplications() {
             applications.addApplication(app);
         }
 
+        applications.shuffleInstances(false);
         applications.setAppsHashCode(applications.getReconcileHashCode());
         applications.setVersion(1L);
 

File: eureka-client/src/main/java/com/netflix/discovery/converters/jackson/EurekaXmlJacksonCodec.java
Patch:
@@ -63,7 +63,7 @@ public ObjectMapper registerModule(Module module) {
     }
 
     @Override
-    public ObjectMapper getObjectMapper() {
+    public <T> ObjectMapper getObjectMapper(Class<T> type) {
         return xmlMapper;
     }
 }

File: eureka-client/src/test/java/com/netflix/discovery/converters/CodecLoadTester.java
Patch:
@@ -240,7 +240,7 @@ public int call(Object object) {
                     codec.writeTo(object, captureStream);
                     byte[] bytes = captureStream.toByteArray();
                     InputStream source = new ByteArrayInputStream(bytes);
-                    Applications readValue = (Applications) codec.getObjectMapper().readValue(source, object.getClass());
+                    Applications readValue = codec.getObjectMapper(object.getClass()).readValue(source, Applications.class);
                     secondHolder.value = readValue;
 
                     return bytes.length;

File: eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationList.java
Patch:
@@ -6,13 +6,11 @@
 
 import com.fasterxml.jackson.annotation.JsonCreator;
 import com.fasterxml.jackson.annotation.JsonProperty;
-import com.fasterxml.jackson.annotation.JsonRootName;
 import com.netflix.discovery.provider.Serializer;
 
 /**
  * @author Tomasz Bak
  */
-@JsonRootName("replicationList")
 @Serializer("jackson") // For backwards compatibility with DiscoveryJerseyProvider
 public class ReplicationList {
     private final List<ReplicationInstance> replicationList;

File: eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationListResponse.java
Patch:
@@ -5,13 +5,11 @@
 
 import com.fasterxml.jackson.annotation.JsonCreator;
 import com.fasterxml.jackson.annotation.JsonProperty;
-import com.fasterxml.jackson.annotation.JsonRootName;
 import com.netflix.discovery.provider.Serializer;
 
 /**
  * The jersey resource class that generates the replication batch response.
  */
-@JsonRootName("replicationListResponse")
 @Serializer("jackson") // For backwards compatibility with DiscoveryJerseyProvider
 public class ReplicationListResponse {
     private List<ReplicationInstanceResponse> responseList;

File: eureka-client/src/test/java/com/netflix/discovery/converters/EurekaCodecCompatibilityTest.java
Patch:
@@ -275,7 +275,7 @@ public void call(EncoderWrapper encodingCodec, DecoderWrapper decodingCodec) thr
                 new CodecWrappers.LegacyJacksonJson()
         );
 
-        verifyAllPairs(codingAction, Applications.class, jsonCodes);
+        verifyAllPairs(codingAction, ReplicationList.class, jsonCodes);
     }
 
     @Test
@@ -300,7 +300,7 @@ public void call(EncoderWrapper encodingCodec, DecoderWrapper decodingCodec) thr
                 new CodecWrappers.LegacyJacksonJson()
         );
 
-        verifyAllPairs(codingAction, Applications.class, jsonCodes);
+        verifyAllPairs(codingAction, ReplicationListResponse.class, jsonCodes);
     }
 
     public void verifyAllPairs(Action2 codingAction, Class<?> typeToEncode, List<CodecWrapper> codecHolders) throws Exception {

File: eureka-client/src/main/java/com/netflix/discovery/converters/jackson/EurekaXmlJacksonCodec.java
Patch:
@@ -63,7 +63,7 @@ public ObjectMapper registerModule(Module module) {
     }
 
     @Override
-    public ObjectMapper getObjectMapper() {
+    public <T> ObjectMapper getObjectMapper(Class<T> type) {
         return xmlMapper;
     }
 }

File: eureka-client/src/test/java/com/netflix/discovery/converters/CodecLoadTester.java
Patch:
@@ -240,7 +240,7 @@ public int call(Object object) {
                     codec.writeTo(object, captureStream);
                     byte[] bytes = captureStream.toByteArray();
                     InputStream source = new ByteArrayInputStream(bytes);
-                    Applications readValue = (Applications) codec.getObjectMapper().readValue(source, object.getClass());
+                    Applications readValue = codec.getObjectMapper(object.getClass()).readValue(source, Applications.class);
                     secondHolder.value = readValue;
 
                     return bytes.length;

File: eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationList.java
Patch:
@@ -6,13 +6,11 @@
 
 import com.fasterxml.jackson.annotation.JsonCreator;
 import com.fasterxml.jackson.annotation.JsonProperty;
-import com.fasterxml.jackson.annotation.JsonRootName;
 import com.netflix.discovery.provider.Serializer;
 
 /**
  * @author Tomasz Bak
  */
-@JsonRootName("replicationList")
 @Serializer("jackson") // For backwards compatibility with DiscoveryJerseyProvider
 public class ReplicationList {
     private final List<ReplicationInstance> replicationList;

File: eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationListResponse.java
Patch:
@@ -5,13 +5,11 @@
 
 import com.fasterxml.jackson.annotation.JsonCreator;
 import com.fasterxml.jackson.annotation.JsonProperty;
-import com.fasterxml.jackson.annotation.JsonRootName;
 import com.netflix.discovery.provider.Serializer;
 
 /**
  * The jersey resource class that generates the replication batch response.
  */
-@JsonRootName("replicationListResponse")
 @Serializer("jackson") // For backwards compatibility with DiscoveryJerseyProvider
 public class ReplicationListResponse {
     private List<ReplicationInstanceResponse> responseList;

File: eureka-core/src/main/java/com/netflix/eureka/util/StatusUtil.java
Patch:
@@ -59,6 +59,9 @@ private boolean isReplicaAvailable(String myAppName, String url) {
         try {
             String givenHostName = new URI(url).getHost();
             Application app = registry.getApplication(myAppName, false);
+            if (app == null) {
+                return false;
+            }
             for (InstanceInfo info : app.getInstances()) {
                 if (info.getHostName().equals(givenHostName)) {
                     return true;

File: eureka-core/src/main/java/com/netflix/eureka/util/StatusUtil.java
Patch:
@@ -59,6 +59,9 @@ private boolean isReplicaAvailable(String myAppName, String url) {
         try {
             String givenHostName = new URI(url).getHost();
             Application app = registry.getApplication(myAppName, false);
+            if (app == null) {
+                return false;
+            }
             for (InstanceInfo info : app.getInstances()) {
                 if (info.getHostName().equals(givenHostName)) {
                     return true;

File: eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java
Patch:
@@ -84,6 +84,9 @@ private boolean isReplicaAvailable(String myAppName, String url) {
             String givenHostName = new URI(url).getHost();
             Application app = PeerAwareInstanceRegistryImpl.getInstance()
                     .getApplication(myAppName, false);
+            if (app == null) {
+                return false;
+            }
             for (InstanceInfo info : app.getInstances()) {
                 if (info.getHostName().equals(givenHostName)) {
                     return true;

File: eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java
Patch:
@@ -84,6 +84,9 @@ private boolean isReplicaAvailable(String myAppName, String url) {
             String givenHostName = new URI(url).getHost();
             Application app = PeerAwareInstanceRegistryImpl.getInstance()
                     .getApplication(myAppName, false);
+            if (app == null) {
+                return false;
+            }
             for (InstanceInfo info : app.getInstances()) {
                 if (info.getHostName().equals(givenHostName)) {
                     return true;

File: eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2InstanceConfig.java
Patch:
@@ -48,8 +48,8 @@ public EurekaArchaius2InstanceConfig(Config config, String namespace, DataCenter
     }
 
     @Override
-    public String getSID() {
-        return config.getString("sid", null);
+    public String getInstanceId() {
+        return config.getString("instanceId", null);
     }
 
     @Override

File: eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java
Patch:
@@ -68,6 +68,7 @@ public enum MetaDataKey {
         instanceId("instance-id"),
         instanceType("instance-type"),
         localIpv4("local-ipv4"),
+        localHostname("local-hostname"),
         availabilityZone("availability-zone", "placement/"),
         publicHostname("public-hostname"),
         publicIpv4("public-ipv4"),

File: eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java
Patch:
@@ -241,7 +241,7 @@ public Map<String, String> getMetadataMap() {
     }
 
     @Override
-    public String getSID() {
+    public String getInstanceId() {
         String result = INSTANCE.getStringProperty(idPropName, null).get();
         return result == null ? null : result.trim();
     }
@@ -316,7 +316,7 @@ private void init(String namespace) {
         propSecurePortEnabled = propSecurePort + ".enabled";
         propNonSecurePort = namespace + "port";
 
-        idPropName = namespace + "sid";
+        idPropName = namespace + "instanceId";
         propName = namespace + "name";
         propPortEnabled = propNonSecurePort + ".enabled";
         propLeaseRenewalIntervalInSeconds = namespace + "lease.renewalInterval";

File: eureka-client/src/test/java/com/netflix/discovery/converters/EurekaCodecCompatibilityTest.java
Patch:
@@ -61,6 +61,7 @@ public void call(EncoderWrapper encodingCodec, DecoderWrapper decodingCodec) thr
                 // convert the field from the json string to what the legacy json would encode as
                 encodedString = encodedString.replaceFirst("lastRenewalTimestamp", "renewalTimestamp");
                 InstanceInfo decodedValue = decodingCodec.decode(encodedString, InstanceInfo.class);
+                assertThat(EurekaEntityComparators.equal(instanceInfo, decodedValue, new EurekaEntityComparators.RawIdEqualFunc()), is(true));
                 assertThat(EurekaEntityComparators.equal(instanceInfo, decodedValue), is(true));
             }
         };
@@ -166,6 +167,7 @@ public void call(EncoderWrapper encodingCodec, DecoderWrapper decodingCodec) thr
                 String encodedString = encodingCodec.encode(instanceInfo);
                 InstanceInfo decodedValue = decodingCodec.decode(encodedString, InstanceInfo.class);
                 assertThat(EurekaEntityComparators.equal(instanceInfo, decodedValue), is(true));
+                assertThat(EurekaEntityComparators.equal(instanceInfo, decodedValue, new EurekaEntityComparators.RawIdEqualFunc()), is(true));
             }
         };
 

File: eureka-core/src/main/java/com/netflix/eureka/aws/EIPManager.java
Patch:
@@ -72,7 +72,7 @@
  *
  */
 @Singleton
-public class EIPManager {
+public class EIPManager implements AwsBinder {
     private static final Logger logger = LoggerFactory.getLogger(EIPManager.class);
 
     private static final String US_EAST_1 = "us-east-1";

File: eureka-core/src/test/java/com/netflix/eureka/cluster/PeerEurekaNodesTest.java
Patch:
@@ -34,8 +34,7 @@ public class PeerEurekaNodesTest {
 
     private final PeerAwareInstanceRegistry registry = mock(PeerAwareInstanceRegistry.class);
 
-    private final TestablePeerEurekaNodes peerEurekaNodes = new TestablePeerEurekaNodes(
-            registry, ClusterSampleData.newEurekaServerConfig(false));
+    private final TestablePeerEurekaNodes peerEurekaNodes = new TestablePeerEurekaNodes(registry, ClusterSampleData.newEurekaServerConfig());
 
     @Test
     public void testInitialStartupShutdown() throws Exception {

File: eureka-server-karyon3/src/main/java/com/netflix/eureka/EurekaInjectorCreator.java
Patch:
@@ -1,6 +1,8 @@
 package com.netflix.eureka;
 
+import com.netflix.archaius.bridge.StaticArchaiusBridgeModule;
 import com.netflix.archaius.guice.ArchaiusModule;
+import com.netflix.eureka.guice.EurekaServerModule;
 import com.netflix.eureka.guice.LocalEurekaServerModule;
 import com.netflix.governator.GovernatorFeatures;
 import com.netflix.governator.LifecycleInjector;
@@ -46,6 +48,7 @@ private static DefaultKaryonConfiguration.Builder<?> createInjectorBuilder(boole
                 .addModules(
                         new LocalEurekaServerModule(),  // server
                         new ArchaiusModule(),
+                        new StaticArchaiusBridgeModule(),
                         new ProvisionDebugModule(),
                         new JerseyServletModule() {
                             @Override

File: eureka-server-karyon3/src/main/java/com/netflix/eureka/guice/EurekaServerModule.java
Patch:
@@ -7,6 +7,7 @@
 import com.netflix.eureka.DefaultEurekaServerContext;
 import com.netflix.eureka.EurekaServerConfig;
 import com.netflix.eureka.EurekaServerContext;
+import com.netflix.eureka.aws.AwsBinderDelegate;
 import com.netflix.eureka.aws.EIPManager;
 import com.netflix.eureka.cluster.PeerEurekaNodes;
 import com.netflix.eureka.registry.AbstractInstanceRegistry;
@@ -27,7 +28,7 @@ protected void configure() {
         bind(EurekaServerConfig.class).to(DefaultEurekaServerConfig.class).in(Scopes.SINGLETON);
         bind(PeerEurekaNodes.class).in(Scopes.SINGLETON);
 
-        bind(EIPManager.class).asEagerSingleton();
+        bind(AwsBinderDelegate.class).asEagerSingleton();
 
         // registry and interfaces
         bind(AwsInstanceRegistry.class).asEagerSingleton();

File: eureka-server-karyon3/src/main/java/com/netflix/eureka/guice/EurekaServerModule.java
Patch:
@@ -7,6 +7,7 @@
 import com.netflix.eureka.DefaultEurekaServerContext;
 import com.netflix.eureka.EurekaServerConfig;
 import com.netflix.eureka.EurekaServerContext;
+import com.netflix.eureka.aws.AwsBinderDelegate;
 import com.netflix.eureka.aws.EIPManager;
 import com.netflix.eureka.cluster.PeerEurekaNodes;
 import com.netflix.eureka.registry.AbstractInstanceRegistry;
@@ -27,7 +28,7 @@ protected void configure() {
         bind(EurekaServerConfig.class).to(DefaultEurekaServerConfig.class).in(Scopes.SINGLETON);
         bind(PeerEurekaNodes.class).in(Scopes.SINGLETON);
 
-        bind(EIPManager.class).asEagerSingleton();
+        bind(AwsBinderDelegate.class).in(Scopes.SINGLETON);
 
         // registry and interfaces
         bind(AwsInstanceRegistry.class).asEagerSingleton();

File: eureka-test-utils/src/main/java/com/netflix/discovery/util/InstanceInfoGenerator.java
Patch:
@@ -150,6 +150,7 @@ public static InstanceInfoGeneratorBuilder newBuilder(int instanceCount, String.
     private InstanceInfo generateInstanceInfo(int appIndex, int appInstanceId, boolean useInstanceId) {
         String appName = appNames[appIndex];
         String hostName = "instance" + appInstanceId + '.' + appName + ".com";
+        String privateHostname = "ip-10.0" + appIndex + "." + appInstanceId + ".compute.internal";
         String publicIp = "20.0." + appIndex + '.' + appInstanceId;
         String privateIp = "192.168." + appIndex + '.' + appInstanceId;
 
@@ -164,6 +165,7 @@ private InstanceInfo generateInstanceInfo(int appIndex, int appInstanceId, boole
                 .addMetadata(MetaDataKey.availabilityZone, zone)
                 .addMetadata(MetaDataKey.instanceId, instanceId)
                 .addMetadata(MetaDataKey.instanceType, "m2.xlarge")
+                .addMetadata(MetaDataKey.localHostname, privateHostname)
                 .addMetadata(MetaDataKey.localIpv4, privateIp)
                 .addMetadata(MetaDataKey.publicHostname, hostName)
                 .addMetadata(MetaDataKey.publicIpv4, publicIp)

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/LegacyClusterResolver.java
Patch:
@@ -75,9 +75,10 @@ static class LegacyClusterResolverFactory implements ClusterResolverFactory {
         public ClusterResolver createClusterResolver() {
             ClusterResolver newResolver;
             if (clientConfig.shouldUseDnsForFetchingServiceUrls()) {
+                String discoveryDnsName = "txt." + myRegion + '.' + clientConfig.getEurekaServerDNSName();
                 newResolver = new DnsTxtRecordClusterResolver(
                         myRegion,
-                        clientConfig.getEurekaServerDNSName(),
+                        discoveryDnsName,
                         true,
                         Integer.parseInt(clientConfig.getEurekaServerPort()),
                         false,

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/decorator/EurekaHttpClientDecorator.java
Patch:
@@ -135,7 +135,7 @@ public EurekaHttpResponse<Applications> getDelta() {
         return execute(new RequestExecutor<Applications>() {
             @Override
             public EurekaHttpResponse<Applications> execute(EurekaHttpClient delegate) {
-                return delegate.getApplications();
+                return delegate.getDelta();
             }
 
             @Override

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/ClusterResolver.java
Patch:
@@ -23,5 +23,7 @@
  */
 public interface ClusterResolver {
 
+    String getRegion();
+
     List<EurekaEndpoint> getClusterEndpoints();
 }

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/decorator/ServerStatusEvaluator.java
Patch:
@@ -16,6 +16,8 @@
 
 package com.netflix.discovery.shared.transport.decorator;
 
+import com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.RequestType;
+
 /**
  * HTTP status code evaluator, that can be used to make a decision whether it makes sense to
  * immediately retry a request on another server or stick to the current one.
@@ -26,5 +28,5 @@
  * @author Tomasz Bak
  */
 public interface ServerStatusEvaluator {
-    boolean abandon(int statusCode);
+    boolean accept(int statusCode, RequestType requestType);
 }

File: eureka-client/src/test/java/com/netflix/discovery/shared/resolver/ReloadingClusterResolverTest.java
Patch:
@@ -92,7 +92,7 @@ static class InjectableFactory implements ClusterResolverFactory {
 
         @Override
         public ClusterResolver createClusterResolver() {
-            return new StaticClusterResolver(currentEndpointsRef.get());
+            return new StaticClusterResolver("regionA", currentEndpointsRef.get());
         }
 
         void setEndpoints(List<EurekaEndpoint> endpoints) {

File: eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNodes.java
Patch:
@@ -21,6 +21,7 @@
 import com.netflix.eureka.EurekaServerConfig;
 import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
 import com.netflix.eureka.resources.ServerCodecs;
+import com.netflix.eureka.transport.JerseyReplicationClient;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: eureka-core/src/test/java/com/netflix/eureka/cluster/JerseyReplicationClientTest.java
Patch:
@@ -15,6 +15,7 @@
 import com.netflix.eureka.resources.ASGResource.ASGStatus;
 import com.netflix.eureka.resources.DefaultServerCodecs;
 import com.netflix.eureka.resources.ServerCodecs;
+import com.netflix.eureka.transport.JerseyReplicationClient;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;

File: eureka-server/src/test/java/com/netflix/eureka/resources/EurekaClientServerRestIntegrationTest.java
Patch:
@@ -18,7 +18,7 @@
 import com.netflix.discovery.shared.transport.jersey.JerseyApplicationClient;
 import com.netflix.discovery.util.InstanceInfoGenerator;
 import com.netflix.eureka.EurekaServerConfig;
-import com.netflix.eureka.cluster.JerseyReplicationClient;
+import com.netflix.eureka.transport.JerseyReplicationClient;
 import com.netflix.eureka.cluster.protocol.ReplicationInstance;
 import com.netflix.eureka.cluster.protocol.ReplicationInstanceResponse;
 import com.netflix.eureka.cluster.protocol.ReplicationList;

File: eureka-test-utils/src/main/java/com/netflix/discovery/util/DiagnosticClient.java
Patch:
@@ -3,7 +3,7 @@
 import com.netflix.discovery.shared.Applications;
 import com.netflix.eureka.DefaultEurekaServerConfig;
 import com.netflix.eureka.EurekaServerConfig;
-import com.netflix.eureka.cluster.JerseyReplicationClient;
+import com.netflix.eureka.transport.JerseyReplicationClient;
 import com.netflix.eureka.resources.DefaultServerCodecs;
 
 import static com.netflix.discovery.util.EurekaEntityFunctions.countInstances;

File: eureka-client/src/test/java/com/netflix/appinfo/InstanceInfoTest.java
Patch:
@@ -124,7 +124,7 @@ public void testGetIdWithSIDUsed() {
     // test case for compatiblity
     @Test
     public void testGetIdWithSIDNotUsed() {
-        String sidDefaultVal = "unknown";
+        String sidDefaultVal = "na";
         InstanceInfo baseline = InstanceInfoGenerator.takeOne();
         InstanceInfo instanceInfo1 = new InstanceInfo.Builder(baseline).setSID(sidDefaultVal).build();
         String dataCenterInfoId = ((UniqueIdentifier) baseline.getDataCenterInfo()).getId();

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/ClusterResolver.java
Patch:
@@ -23,7 +23,7 @@
  */
 public interface ClusterResolver {
 
-    List<EurekaEndpoint> getClusterServers();
+    List<EurekaEndpoint> getClusterEndpoints();
 
     void shutdown();
 }

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/DnsClusterResolver.java
Patch:
@@ -48,7 +48,7 @@ public DnsClusterResolver(String rootClusterDNS, int port, boolean isSecure, Str
     }
 
     @Override
-    public List<EurekaEndpoint> getClusterServers() {
+    public List<EurekaEndpoint> getClusterEndpoints() {
         return eurekaEndpoints;
     }
 

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/DnsTxtRecordClusterResolver.java
Patch:
@@ -86,7 +86,7 @@ public DnsTxtRecordClusterResolver(String rootClusterDNS, boolean extractZoneFro
     }
 
     @Override
-    public List<EurekaEndpoint> getClusterServers() {
+    public List<EurekaEndpoint> getClusterEndpoints() {
         return eurekaEndpoints;
     }
 

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/RandomizingClusterResolver.java
Patch:
@@ -30,11 +30,11 @@ public class RandomizingClusterResolver implements ClusterResolver {
     private final List<EurekaEndpoint> eurekaEndpoints;
 
     public RandomizingClusterResolver(ClusterResolver delegate) {
-        this.eurekaEndpoints = ResolverUtils.randomize(new ArrayList<EurekaEndpoint>(delegate.getClusterServers()));
+        this.eurekaEndpoints = ResolverUtils.randomize(new ArrayList<EurekaEndpoint>(delegate.getClusterEndpoints()));
     }
 
     @Override
-    public List<EurekaEndpoint> getClusterServers() {
+    public List<EurekaEndpoint> getClusterEndpoints() {
         return eurekaEndpoints;
     }
 

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/StaticClusterResolver.java
Patch:
@@ -32,7 +32,7 @@ public StaticClusterResolver(List<EurekaEndpoint> eurekaEndpoints) {
     }
 
     @Override
-    public List<EurekaEndpoint> getClusterServers() {
+    public List<EurekaEndpoint> getClusterEndpoints() {
         return eurekaEndpoints;
     }
 

File: eureka-client/src/main/java/com/netflix/discovery/shared/resolver/ZoneAffinityClusterResolver.java
Patch:
@@ -30,14 +30,14 @@ public class ZoneAffinityClusterResolver implements ClusterResolver {
     private final List<EurekaEndpoint> eurekaEndpoints;
 
     public ZoneAffinityClusterResolver(ClusterResolver delegate, String myZone) {
-        List<EurekaEndpoint>[] parts = ResolverUtils.splitByZone(delegate.getClusterServers(), myZone);
+        List<EurekaEndpoint>[] parts = ResolverUtils.splitByZone(delegate.getClusterEndpoints(), myZone);
         List<EurekaEndpoint> myZoneEndpoints = parts[0];
         List<EurekaEndpoint> remainingEndpoints = parts[1];
         this.eurekaEndpoints = randomizeAndMerge(myZoneEndpoints, remainingEndpoints);
     }
 
     @Override
-    public List<EurekaEndpoint> getClusterServers() {
+    public List<EurekaEndpoint> getClusterEndpoints() {
         return eurekaEndpoints;
     }
 

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/EurekaHttpClients.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.netflix.discovery.EurekaClientConfig;
 import com.netflix.discovery.shared.resolver.ClusterResolver;
+import com.netflix.discovery.shared.resolver.DnsServiceImpl;
 import com.netflix.discovery.shared.transport.decorator.RebalancingEurekaHttpClient;
 import com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient;
 import com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient;
@@ -54,10 +55,11 @@ public static EurekaHttpClient createStandardClient(EurekaClientConfig clientCon
     }
 
     private static EurekaHttpClientFactory createRedirectingClientFactory(final EurekaHttpClientFactory delegateFactory) {
+        final DnsServiceImpl dnsService = new DnsServiceImpl();
         return new EurekaHttpClientFactory() {
             @Override
             public EurekaHttpClient create(String... serviceUrls) {
-                return new RedirectingEurekaHttpClient(serviceUrls[0], delegateFactory);
+                return new RedirectingEurekaHttpClient(serviceUrls[0], delegateFactory, dnsService);
             }
 
             @Override

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/decorator/RetryableEurekaHttpClient.java
Patch:
@@ -106,7 +106,7 @@ protected <R> EurekaHttpResponse<R> execute(RequestExecutor<R> requestExecutor)
     }
 
     private List<EurekaEndpoint> getHostCandidates() {
-        List<EurekaEndpoint> candidateHosts = clusterResolver.getClusterServers();
+        List<EurekaEndpoint> candidateHosts = clusterResolver.getClusterEndpoints();
         quarantineSet.retainAll(candidateHosts);
 
         // If all hosts are bad, we have no choice but start over again

File: eureka-client/src/main/java/com/netflix/discovery/shared/transport/jersey/JerseyEurekaHttpClientFactory.java
Patch:
@@ -62,7 +62,7 @@ private EurekaJerseyClient getOrCreateJerseyClient() {
 
         synchronized (lock) {
             if (jerseyClient == null) {
-                if (clusterResolver.getClusterServers().isEmpty()) {
+                if (clusterResolver.getClusterEndpoints().isEmpty()) {
                     throw new IllegalStateException("Eureka server list is empty; cannot setup connection to any server");
                 }
 
@@ -76,7 +76,7 @@ private EurekaJerseyClient getOrCreateJerseyClient() {
                         .withEncoder(clientConfig.getEncoderName())
                         .withDecoder(clientConfig.getDecoderName(), clientConfig.getClientDataAccept());
 
-                if (clusterResolver.getClusterServers().get(0).getServiceUrl().startsWith("https://") &&
+                if (clusterResolver.getClusterEndpoints().get(0).getServiceUrl().startsWith("https://") &&
                         "true".equals(System.getProperty("com.netflix.eureka.shouldSSLConnectionsUseSystemSocketFactory"))) {
                     clientBuilder.withClientName("DiscoveryClient-HTTPClient-System")
                             .withSystemSSLConfiguration();

File: eureka-core/src/main/java/com/netflix/eureka/registry/AbstractInstanceRegistry.java
Patch:
@@ -685,8 +685,8 @@ public Applications getApplicationsFromMultipleRegions(String[] remoteRegions) {
 
         boolean includeRemoteRegion = null != remoteRegions && remoteRegions.length != 0;
 
-        logger.info("Fetching applications registry with remote regions: {}, Regions argument {}", includeRemoteRegion,
-                Arrays.toString(remoteRegions));
+        logger.debug("Fetching applications registry with remote regions: {}, Regions argument {}",
+                includeRemoteRegion, Arrays.toString(remoteRegions));
 
         if (includeRemoteRegion) {
             GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS.increment();

File: eureka-core/src/main/java/com/netflix/eureka/registry/PeerAwareInstanceRegistryImpl.java
Patch:
@@ -265,6 +265,8 @@ private void primeAwsReplicas(ApplicationInfoManager applicationInfoManager) {
                 Application eurekaApps = this.getApplication(applicationInfoManager.getInfo().getAppName(), false);
                 if (eurekaApps == null) {
                     areAllPeerNodesPrimed = true;
+                    logger.info("No peers needed to prime.");
+                    return;
                 }
                 for (PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
                     for (InstanceInfo peerInstanceInfo : eurekaApps.getInstances()) {

File: eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerContext.java
Patch:
@@ -45,7 +45,7 @@ public class DefaultEurekaServerContext implements EurekaServerContext {
     private final ApplicationInfoManager applicationInfoManager;
 
     @Inject
-    DefaultEurekaServerContext(EurekaServerConfig serverConfig,
+    public DefaultEurekaServerContext(EurekaServerConfig serverConfig,
                                ServerCodecs serverCodecs,
                                PeerAwareInstanceRegistry registry,
                                PeerEurekaNodes peerEurekaNodes,

File: eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClientImpl.java
Patch:
@@ -73,7 +73,6 @@ public EurekaJerseyClientImpl(int connectionTimeout, int readTimeout, final int
                               ClientConfig clientConfig) {
         try {
             jerseyClientConfig = clientConfig;
-            jerseyClientConfig.getClasses().add(DiscoveryJerseyProvider.class);
             apacheHttpClient = ApacheHttpClient4.create(jerseyClientConfig);
             HttpParams params = apacheHttpClient.getClientHandler().getHttpClient().getParams();
 

File: eureka-client/src/main/java/com/netflix/discovery/converters/jackson/AbstractEurekaJacksonCodec.java
Patch:
@@ -15,6 +15,7 @@
 import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;
 import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;
 import com.netflix.appinfo.InstanceInfo;
+import com.netflix.discovery.converters.jackson.mixin.MiniInstanceInfoMixIn;
 
 /**
  * @author Tomasz Bak

File: eureka-client/src/main/java/com/netflix/discovery/converters/jackson/EurekaJsonJacksonCodec.java
Patch:
@@ -37,8 +37,8 @@ public EurekaJsonJacksonCodec() {
     public EurekaJsonJacksonCodec(final KeyFormatter keyFormatter, boolean compact) {
         // JSON
         SimpleModule jsonModule = new SimpleModule();
-        jsonModule.setSerializerModifier(EurekaJacksonModifiers.createJsonSerializerModifier(keyFormatter));
-        jsonModule.setDeserializerModifier(EurekaJacksonModifiers.createJsonDeserializerModifier(keyFormatter, compact));
+        jsonModule.setSerializerModifier(EurekaJacksonJsonModifiers.createJsonSerializerModifier(keyFormatter));
+        jsonModule.setDeserializerModifier(EurekaJacksonJsonModifiers.createJsonDeserializerModifier(keyFormatter, compact));
         jsonMapper.registerModule(jsonModule);
         jsonMapper.setSerializationInclusion(Include.NON_NULL);
         jsonMapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true);

File: eureka-client/src/main/java/com/netflix/discovery/converters/jackson/InstanceInfoBeanDeserializers.java
Patch:
@@ -11,6 +11,7 @@
 import com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator;
 import com.fasterxml.jackson.databind.deser.impl.PropertyValueBuffer;
 import com.netflix.appinfo.InstanceInfo;
+import com.netflix.discovery.converters.jackson.mixin.MiniInstanceInfoMixIn;
 
 /**
  * Custom {@link InstanceInfo} deserializers that handles port/secure port according to the legacy rules.

File: eureka-client/src/main/java/com/netflix/discovery/converters/jackson/mixin/DataCenterInfoXmlMixIn.java
Patch:
@@ -1,4 +1,4 @@
-package com.netflix.discovery.converters.jackson;
+package com.netflix.discovery.converters.jackson.mixin;
 
 import com.fasterxml.jackson.annotation.JsonTypeInfo;
 import com.fasterxml.jackson.annotation.JsonTypeInfo.As;

File: eureka-client/src/main/java/com/netflix/discovery/converters/jackson/mixin/MiniInstanceInfoMixIn.java
Patch:
@@ -1,4 +1,4 @@
-package com.netflix.discovery.converters.jackson;
+package com.netflix.discovery.converters.jackson.mixin;
 
 import java.util.HashSet;
 import java.util.Map;

File: eureka-client/src/main/java/com/netflix/discovery/shared/Application.java
Patch:
@@ -31,7 +31,6 @@
 import com.fasterxml.jackson.annotation.JsonIgnore;
 import com.fasterxml.jackson.annotation.JsonProperty;
 import com.fasterxml.jackson.annotation.JsonRootName;
-import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;
 import com.netflix.appinfo.InstanceInfo;
 import com.netflix.appinfo.InstanceInfo.InstanceStatus;
 import com.netflix.discovery.EurekaClientConfig;
@@ -67,7 +66,6 @@ public String toString() {
     private volatile boolean isDirty = false;
 
     @XStreamImplicit
-    @JacksonXmlElementWrapper(useWrapping=false)
     private final Set<InstanceInfo> instances;
 
     private AtomicReference<List<InstanceInfo>> shuffledInstances = new AtomicReference<List<InstanceInfo>>();

File: eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java
Patch:
@@ -37,7 +37,6 @@
 import com.fasterxml.jackson.annotation.JsonIgnore;
 import com.fasterxml.jackson.annotation.JsonProperty;
 import com.fasterxml.jackson.annotation.JsonRootName;
-import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;
 import com.netflix.appinfo.InstanceInfo;
 import com.netflix.appinfo.InstanceInfo.ActionType;
 import com.netflix.appinfo.InstanceInfo.InstanceStatus;
@@ -103,7 +102,7 @@ public Applications(
             @JsonProperty("versionDelta") Long versionDelta,
             @JsonProperty("application") List<Application> registeredApplications) {
         this.applications = new ConcurrentLinkedQueue<Application>();
-        for(Application app: registeredApplications) {
+        for (Application app : registeredApplications) {
             this.addApplication(app);
         }
         this.appsHashCode = appsHashCode;
@@ -140,7 +139,6 @@ public void addApplication(Application app) {
      * @return list containing all applications registered with eureka.
      */
     @JsonProperty("application")
-    @JacksonXmlElementWrapper(useWrapping=false)
     public List<Application> getRegisteredApplications() {
         List<Application> list = new ArrayList<Application>();
         list.addAll(this.applications);

File: eureka-client/src/main/java/com/netflix/discovery/converters/jackson/EurekaJsonJacksonCodec.java
Patch:
@@ -42,7 +42,7 @@ public EurekaJsonJacksonCodec(final KeyFormatter keyFormatter, boolean compact)
         jsonMapper.registerModule(jsonModule);
         jsonMapper.setSerializationInclusion(Include.NON_NULL);
         jsonMapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true);
-        jsonMapper.configure(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED, true);
+        jsonMapper.configure(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED, false);
         jsonMapper.configure(DeserializationFeature.UNWRAP_ROOT_VALUE, true);
         jsonMapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);
 

File: eureka-client/src/main/java/com/netflix/discovery/converters/jackson/EurekaJsonJacksonCodec.java
Patch:
@@ -42,7 +42,7 @@ public EurekaJsonJacksonCodec(final KeyFormatter keyFormatter, boolean compact)
         jsonMapper.registerModule(jsonModule);
         jsonMapper.setSerializationInclusion(Include.NON_NULL);
         jsonMapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true);
-        jsonMapper.configure(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED, true);
+        jsonMapper.configure(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED, false);
         jsonMapper.configure(DeserializationFeature.UNWRAP_ROOT_VALUE, true);
         jsonMapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);
 

File: eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRedirectTest.java
Patch:
@@ -12,7 +12,7 @@
 import com.netflix.discovery.converters.EntityBodyConverter;
 import com.netflix.discovery.shared.Application;
 import com.netflix.discovery.shared.Applications;
-import com.netflix.discovery.util.ApplicationFunctions;
+import com.netflix.discovery.util.EurekaEntityFunctions;
 import com.netflix.discovery.util.InstanceInfoGenerator;
 import org.junit.Before;
 import org.junit.Ignore;
@@ -144,7 +144,7 @@ public void testClientRegistrationFollowsRedirectsAndPinsToTargetServer() throws
     public void testClientFallsBackToOriginalServerOnError() throws Exception {
         Applications fullFetchApps1 = dataGenerator.takeDelta(1);
         String fullFetchJson1 = toJson(fullFetchApps1);
-        Applications fullFetchApps2 = ApplicationFunctions.merge(fullFetchApps1, dataGenerator.takeDelta(1));
+        Applications fullFetchApps2 = EurekaEntityFunctions.mergeApplications(fullFetchApps1, dataGenerator.takeDelta(1));
         String fullFetchJson2 = toJson(fullFetchApps2);
 
         redirectServerMockClient.when(

File: eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java
Patch:
@@ -18,6 +18,7 @@
 import com.netflix.eureka.cluster.protocol.ReplicationList;
 import com.netflix.eureka.cluster.protocol.ReplicationListResponse;
 import com.netflix.eureka.resources.ASGResource.ASGStatus;
+import com.sun.jersey.api.client.Client;
 import com.sun.jersey.api.client.ClientResponse;
 import com.sun.jersey.api.client.WebResource;
 import com.sun.jersey.api.client.WebResource.Builder;
@@ -79,7 +80,7 @@ public JerseyReplicationClient(EurekaServerConfig config, String serviceUrl) {
     }
 
     @Override
-    protected ApacheHttpClient4 getJerseyApacheClient() {
+    protected Client getJerseyClient() {
         return jerseyApacheClient;
     }
 
@@ -97,7 +98,7 @@ public HttpResponse<InstanceInfo> sendHeartBeat(String appName, String id, Insta
         String urlPath = "apps/" + appName + '/' + id;
         ClientResponse response = null;
         try {
-            WebResource webResource = getJerseyApacheClient().resource(serviceUrl)
+            WebResource webResource = getJerseyClient().resource(serviceUrl)
                     .path(urlPath)
                     .queryParam("status", info.getStatus().toString())
                     .queryParam("lastDirtyTimestamp", info.getLastDirtyTimestamp().toString());

File: eureka-server/src/test/java/com/netflix/eureka/resources/EurekaClientServerRestIntegrationTest.java
Patch:
@@ -77,7 +77,7 @@ public static void setUp() throws Exception {
             public EurekaJerseyClient jerseyClient;
 
             @Override
-            protected ApacheHttpClient4 getJerseyApacheClient() {
+            protected ApacheHttpClient4 getJerseyClient() {
                 jerseyClient = new EurekaJerseyClientBuilder()
                         .withClientName("testEurekaClient")
                         .withConnectionTimeout(1000)

File: eureka-test-utils/src/main/java/com/netflix/discovery/util/ApplicationFunctions.java
Patch:
@@ -15,6 +15,7 @@
  * structures.
  *
  * @author Tomasz Bak
+ * @deprecated Use instead {@link EurekaEntityFunctions}
  */
 public final class ApplicationFunctions {
 

File: eureka-test-utils/src/main/java/com/netflix/discovery/util/DiagnosticClient.java
Patch:
@@ -4,7 +4,7 @@
 import com.netflix.eureka.DefaultEurekaServerConfig;
 import com.netflix.eureka.cluster.JerseyReplicationClient;
 
-import static com.netflix.discovery.util.ApplicationFunctions.countInstances;
+import static com.netflix.discovery.util.EurekaEntityFunctions.countInstances;
 
 /**
  * A tool for running diagnostic tasks against a discovery server. Currently limited to observing
@@ -32,7 +32,7 @@ public static void main(String[] args) throws InterruptedException {
             }
             startTime = System.currentTimeMillis();
             Applications delta = client.getDelta().getEntity();
-            Applications merged = ApplicationFunctions.merge(applications, delta);
+            Applications merged = EurekaEntityFunctions.mergeApplications(applications, delta);
             if (merged.getAppsHashCode().equals(delta.getAppsHashCode())) {
                 System.out.println("Hash codes match: " + delta.getAppsHashCode() + "(delta count=" + countInstances(delta) + ')');
                 applications = merged;

File: eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRedirectTest.java
Patch:
@@ -12,7 +12,7 @@
 import com.netflix.discovery.converters.EntityBodyConverter;
 import com.netflix.discovery.shared.Application;
 import com.netflix.discovery.shared.Applications;
-import com.netflix.discovery.util.ApplicationFunctions;
+import com.netflix.discovery.util.EurekaEntityFunctions;
 import com.netflix.discovery.util.InstanceInfoGenerator;
 import org.junit.Before;
 import org.junit.Ignore;
@@ -144,7 +144,7 @@ public void testClientRegistrationFollowsRedirectsAndPinsToTargetServer() throws
     public void testClientFallsBackToOriginalServerOnError() throws Exception {
         Applications fullFetchApps1 = dataGenerator.takeDelta(1);
         String fullFetchJson1 = toJson(fullFetchApps1);
-        Applications fullFetchApps2 = ApplicationFunctions.merge(fullFetchApps1, dataGenerator.takeDelta(1));
+        Applications fullFetchApps2 = EurekaEntityFunctions.mergeApplications(fullFetchApps1, dataGenerator.takeDelta(1));
         String fullFetchJson2 = toJson(fullFetchApps2);
 
         redirectServerMockClient.when(

File: eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java
Patch:
@@ -18,6 +18,7 @@
 import com.netflix.eureka.cluster.protocol.ReplicationList;
 import com.netflix.eureka.cluster.protocol.ReplicationListResponse;
 import com.netflix.eureka.resources.ASGResource.ASGStatus;
+import com.sun.jersey.api.client.Client;
 import com.sun.jersey.api.client.ClientResponse;
 import com.sun.jersey.api.client.WebResource;
 import com.sun.jersey.api.client.WebResource.Builder;
@@ -79,7 +80,7 @@ public JerseyReplicationClient(EurekaServerConfig config, String serviceUrl) {
     }
 
     @Override
-    protected ApacheHttpClient4 getJerseyApacheClient() {
+    protected Client getJerseyClient() {
         return jerseyApacheClient;
     }
 
@@ -97,7 +98,7 @@ public HttpResponse<InstanceInfo> sendHeartBeat(String appName, String id, Insta
         String urlPath = "apps/" + appName + '/' + id;
         ClientResponse response = null;
         try {
-            WebResource webResource = getJerseyApacheClient().resource(serviceUrl)
+            WebResource webResource = getJerseyClient().resource(serviceUrl)
                     .path(urlPath)
                     .queryParam("status", info.getStatus().toString())
                     .queryParam("lastDirtyTimestamp", info.getLastDirtyTimestamp().toString());

File: eureka-server/src/test/java/com/netflix/eureka/resources/EurekaClientServerRestIntegrationTest.java
Patch:
@@ -77,7 +77,7 @@ public static void setUp() throws Exception {
             public EurekaJerseyClient jerseyClient;
 
             @Override
-            protected ApacheHttpClient4 getJerseyApacheClient() {
+            protected ApacheHttpClient4 getJerseyClient() {
                 jerseyClient = new EurekaJerseyClientBuilder()
                         .withClientName("testEurekaClient")
                         .withConnectionTimeout(1000)

File: eureka-test-utils/src/main/java/com/netflix/discovery/util/ApplicationFunctions.java
Patch:
@@ -15,6 +15,7 @@
  * structures.
  *
  * @author Tomasz Bak
+ * @deprecated Use instead {@link EurekaEntityFunctions}
  */
 public final class ApplicationFunctions {
 

File: eureka-test-utils/src/main/java/com/netflix/discovery/util/DiagnosticClient.java
Patch:
@@ -4,7 +4,7 @@
 import com.netflix.eureka.DefaultEurekaServerConfig;
 import com.netflix.eureka.cluster.JerseyReplicationClient;
 
-import static com.netflix.discovery.util.ApplicationFunctions.countInstances;
+import static com.netflix.discovery.util.EurekaEntityFunctions.countInstances;
 
 /**
  * A tool for running diagnostic tasks against a discovery server. Currently limited to observing
@@ -32,7 +32,7 @@ public static void main(String[] args) throws InterruptedException {
             }
             startTime = System.currentTimeMillis();
             Applications delta = client.getDelta().getEntity();
-            Applications merged = ApplicationFunctions.merge(applications, delta);
+            Applications merged = EurekaEntityFunctions.mergeApplications(applications, delta);
             if (merged.getAppsHashCode().equals(delta.getAppsHashCode())) {
                 System.out.println("Hash codes match: " + delta.getAppsHashCode() + "(delta count=" + countInstances(delta) + ')');
                 applications = merged;

File: eureka-core/src/main/java/com/netflix/eureka/util/EurekaMonitors.java
Patch:
@@ -181,7 +181,7 @@ public static void registerAllStats() {
     public static void shutdown() {
         for (EurekaMonitors c : EurekaMonitors.values()) {
             DefaultMonitorRegistry.getInstance().unregister(
-                    Monitors.newObjectMonitor(c.name(), c));
+                    Monitors.newObjectMonitor(c.getName(), c));
         }
     }
 }

File: eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java
Patch:
@@ -293,6 +293,7 @@ public void shutDown() {
         cancelProcessor.shutdown();
         statusProcessor.shutdown();
         asgStatusProcessor.shutdown();
+        replicationClient.shutdown();
     }
 
     /**

File: eureka-core/src/test/java/com/netflix/eureka/cluster/PeerEurekaNodeTest.java
Patch:
@@ -27,6 +27,7 @@
 import static org.hamcrest.CoreMatchers.nullValue;
 import static org.junit.Assert.assertThat;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.timeout;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
@@ -142,7 +143,7 @@ public void testHeartbeatWithInstanceInfoFromPeer() throws Throwable {
         expectRequestType(RequestType.Heartbeat);
 
         // Check that registry has instanceInfo from peer
-        verify(registry, times(1)).register(instanceInfoFromPeer, true);
+        verify(registry, timeout(1000).times(1)).register(instanceInfoFromPeer, true);
     }
 
     @Test

File: eureka-core/src/test/java/com/netflix/eureka/cluster/PeerEurekaNodeTest.java
Patch:
@@ -27,6 +27,7 @@
 import static org.hamcrest.CoreMatchers.nullValue;
 import static org.junit.Assert.assertThat;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.timeout;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
@@ -142,7 +143,7 @@ public void testHeartbeatWithInstanceInfoFromPeer() throws Throwable {
         expectRequestType(RequestType.Heartbeat);
 
         // Check that registry has instanceInfo from peer
-        verify(registry, times(1)).register(instanceInfoFromPeer, true);
+        verify(registry, timeout(1000).times(1)).register(instanceInfoFromPeer, true);
     }
 
     @Test

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -338,7 +338,7 @@ public synchronized BackupRegistry get() {
             }
 
             EurekaJerseyClientBuilder clientBuilder = new EurekaJerseyClientBuilder()
-                    .withUserAgent("Java EurekaClient")
+                    .withUserAgent("Java-EurekaClient")
                     .withConnectionTimeout(clientConfig.getEurekaServerConnectTimeoutSeconds() * 1000)
                     .withReadTimeout(clientConfig.getEurekaServerReadTimeoutSeconds() * 1000)
                     .withMaxConnectionsPerHost(clientConfig.getEurekaServerTotalConnectionsPerHost())

File: eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java
Patch:
@@ -83,7 +83,7 @@ public RemoteRegionRegistry(String regionName, URL remoteRegionURL) {
         this.fetchRegistryTimer = Monitors.newTimer(this.remoteRegionURL.toString() + "_FetchRegistry");
 
         EurekaJerseyClientBuilder clientBuilder = new EurekaJerseyClientBuilder()
-                .withUserAgent("Java EurekaClient (remote region)")
+                .withUserAgent("Java-EurekaClient-RemoteRegion")
                 .withConnectionTimeout(EUREKA_SERVER_CONFIG.getRemoteRegionConnectTimeoutMs())
                 .withReadTimeout(EUREKA_SERVER_CONFIG.getRemoteRegionReadTimeoutMs())
                 .withMaxConnectionsPerHost(EUREKA_SERVER_CONFIG.getRemoteRegionTotalConnectionsPerHost())

File: eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java
Patch:
@@ -50,7 +50,7 @@ public JerseyReplicationClient(EurekaServerConfig config, String serviceUrl) {
             String jerseyClientName = "Discovery-PeerNodeClient-" + hostname;
             EurekaJerseyClientBuilder clientBuilder = new EurekaJerseyClientBuilder()
                     .withClientName(jerseyClientName)
-                    .withUserAgent("Java EurekaClient (replication)")
+                    .withUserAgent("Java-EurekaClient-Replication")
                     .withConnectionTimeout(config.getPeerNodeConnectTimeoutMs())
                     .withReadTimeout(config.getPeerNodeReadTimeoutMs())
                     .withMaxConnectionsPerHost(config.getPeerNodeTotalConnectionsPerHost())

File: eureka-core/src/main/java/com/netflix/eureka/util/batcher/AcceptorExecutor.java
Patch:
@@ -251,6 +251,8 @@ private void appendTaskHolder(TaskHolder<ID, T> taskHolder) {
             TaskHolder<ID, T> previousTask = pendingTasks.put(taskHolder.getId(), taskHolder);
             if (previousTask == null) {
                 processingOrder.add(taskHolder.getId());
+            } else {
+                overriddenTasks++;
             }
         }
 

File: eureka-core/src/main/java/com/netflix/eureka/util/batcher/TrafficShaper.java
Patch:
@@ -52,13 +52,13 @@ long grantTransmissionPermit() {
         }
         long now = System.currentTimeMillis();
         if (now - lastCongestionError < congestionRetryDelayMs) {
-            return now - congestionRetryDelayMs;
+            return congestionRetryDelayMs - (now - lastCongestionError);
         } else {
             lastCongestionError = -1;
         }
 
         if (now - lastNetworkFailure < networkFailureRetryMs) {
-            return now - networkFailureRetryMs;
+            return networkFailureRetryMs - (now - lastNetworkFailure);
         }
         lastNetworkFailure = -1;
         return 0;

File: eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java
Patch:
@@ -68,6 +68,7 @@ public class DefaultEurekaClientConfig implements EurekaClientConfig {
             .getInstance().getStringProperty("eureka.client.props",
                     "eureka-client");
     public static final String DEFAULT_ZONE = "defaultZone";
+    private static final int DEFAULT_EXECUTOR_THREAD_POOL_SIZE = 5;
     private String namespace = "eureka.";
 
     public DefaultEurekaClientConfig() {
@@ -448,7 +449,7 @@ public String getRegistryRefreshSingleVipAddress() {
     @Override
     public int getHeartbeatExecutorThreadPoolSize() {
         return configInstance.getIntProperty(
-                namespace + "client.heartbeat.threadPoolSize", 2).get();
+                namespace + "client.heartbeat.threadPoolSize", DEFAULT_EXECUTOR_THREAD_POOL_SIZE).get();
     }
 
     @Override
@@ -465,7 +466,7 @@ public int getHeartbeatExecutorExponentialBackOffBound() {
     @Override
     public int getCacheRefreshExecutorThreadPoolSize() {
         return configInstance.getIntProperty(
-                namespace + "client.cacheRefresh.threadPoolSize", 2).get();
+                namespace + "client.cacheRefresh.threadPoolSize", DEFAULT_EXECUTOR_THREAD_POOL_SIZE).get();
     }
 
     @Override

File: eureka-client-archaius2/src/main/java/com/netflix/discovery/Ec2EurekaArchaius2InstanceConfig.java
Patch:
@@ -28,8 +28,6 @@
 public class Ec2EurekaArchaius2InstanceConfig extends EurekaArchaius2InstanceConfig {
     private static final Logger LOG = LoggerFactory.getLogger(Ec2EurekaArchaius2InstanceConfig.class);
     
-    private static final String DEFAULT_NAMESPACE = "eureka";
-    
     private volatile DataCenterInfo info;
 
     @Inject

File: eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java
Patch:
@@ -26,7 +26,7 @@ public EurekaArchaius2ClientConfig(Config config) {
 
     public EurekaArchaius2ClientConfig(Config config, String namespace) {
         this.defaultRegion = config.getString("@region", null);
-        this.config = config.getPrefixedView(DEFAULT_NAMESPACE);
+        this.config = config.getPrefixedView(namespace);
     }
 
     public int getRegistryFetchIntervalSeconds() {

File: eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2InstanceConfig.java
Patch:
@@ -16,7 +16,7 @@
 @ConfigurationSource("eureka-client")
 public class EurekaArchaius2InstanceConfig extends AbstractInstanceConfig {
     private static final String UNKNOWN_APPLICATION = "unknown";
-    
+
     private Config config;
     private String namespace;
     private final DataCenterInfo dcInfo;
@@ -25,11 +25,11 @@ public class EurekaArchaius2InstanceConfig extends AbstractInstanceConfig {
     
     @Inject
     public EurekaArchaius2InstanceConfig(Config config) {
-        this(config, "eureka");
+        this(config, DEFAULT_NAMESPACE);
     }
     
     public EurekaArchaius2InstanceConfig(Config config, String namespace) {
-        this(config, "eureka", new DataCenterInfo() {
+        this(config, namespace, new DataCenterInfo() {
             @Override
             public Name getName() {
                 return Name.MyOwn;

File: eureka-client/src/main/java/com/netflix/appinfo/AbstractInstanceConfig.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.Map;
 
 import com.netflix.discovery.shared.Pair;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -35,6 +36,8 @@ public abstract class AbstractInstanceConfig implements EurekaInstanceConfig {
     private static final Logger logger = LoggerFactory
             .getLogger(AbstractInstanceConfig.class);
 
+    public static final String DEFAULT_NAMESPACE = "eureka";
+    
     private static final int LEASE_EXPIRATION_DURATION_SECONDS = 90;
     private static final int LEASE_RENEWAL_INTERVAL_SECONDS = 30;
     private static final boolean SECURE_PORT_ENABLED = false;

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -326,9 +326,10 @@ public synchronized BackupRegistry get() {
 
             DiscoveryJerseyProvider discoveryJerseyProvider = new DiscoveryJerseyProvider(
                     CodecWrappers.getEncoder(clientConfig.getEncoderName()),
-                    CodecWrappers.getDecoder(clientConfig.getDecoderName())
+                    CodecWrappers.resolveDecoder(clientConfig.getDecoderName(), clientConfig.getClientDataAccept())
             );
-            clientAccept = EurekaAccept.getClientAccept(discoveryJerseyProvider.getDecoder());
+
+            clientAccept = EurekaAccept.fromString(clientConfig.getClientDataAccept());
 
             if (eurekaServiceUrls.get().get(0).startsWith("https://") &&
                     "true".equals(System.getProperty("com.netflix.eureka.shouldSSLConnectionsUseSystemSocketFactory"))) {

File: eureka-client/src/main/java/com/netflix/discovery/converters/EurekaJacksonCodec.java
Patch:
@@ -473,6 +473,9 @@ public InstanceInfo deserialize(JsonParser jp, DeserializationContext context) t
                                 meta.put(key, value);
                             }
                         }
+                        if (meta == null) {
+                            meta = Collections.emptyMap();
+                        }
                         builder.setMetadata(meta);
                     } else if (ELEM_HEALTHCHECKURL.equals(fieldName)) {
                         healthChecUrl = fieldNode.asText();

File: eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java
Patch:
@@ -12,4 +12,6 @@ public interface InstanceRegistry extends LeaseManager<InstanceInfo>, LookupServ
 
     void storeOverriddenStatusIfRequired(String id, InstanceStatus overriddenStatus);
 
+    void storeOverriddenStatusIfRequired(String appName, String id, InstanceStatus overriddenStatus);
+
 }

File: eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java
Patch:
@@ -174,7 +174,7 @@ public void handleFailure(int statusCode, Object responseEntity) throws Throwabl
                 } else if (config.shouldSyncWhenTimestampDiffers()) {
                     InstanceInfo peerInstanceInfo = (InstanceInfo) responseEntity;
                     if (peerInstanceInfo != null) {
-                        syncInstancesIfTimestampDiffers(id, info, peerInstanceInfo);
+                        syncInstancesIfTimestampDiffers(appName, id, info, peerInstanceInfo);
                     }
                 }
             }
@@ -299,15 +299,15 @@ public void shutDown() {
      * Synchronize {@link InstanceInfo} information if the timestamp between
      * this node and the peer eureka nodes vary.
      */
-    private void syncInstancesIfTimestampDiffers(String id, InstanceInfo info, InstanceInfo infoFromPeer) {
+    private void syncInstancesIfTimestampDiffers(String appName, String id, InstanceInfo info, InstanceInfo infoFromPeer) {
         try {
             if (infoFromPeer != null) {
                 logger.warn("Peer wants us to take the instance information from it, since the timestamp differs,"
                         + "Id : {} My Timestamp : {}, Peer's timestamp: {}", id, info.getLastDirtyTimestamp(), infoFromPeer.getLastDirtyTimestamp());
 
                 if (infoFromPeer.getOverriddenStatus() != null && !InstanceStatus.UNKNOWN.equals(infoFromPeer.getOverriddenStatus())) {
                     logger.warn("Overridden Status info -id {}, mine {}, peer's {}", id, info.getOverriddenStatus(), infoFromPeer.getOverriddenStatus());
-                    registry.storeOverriddenStatusIfRequired(id, infoFromPeer.getOverriddenStatus());
+                    registry.storeOverriddenStatusIfRequired(appName, id, infoFromPeer.getOverriddenStatus());
                 }
                 registry.register(infoFromPeer, true);
             }

File: eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java
Patch:
@@ -12,4 +12,6 @@ public interface InstanceRegistry extends LeaseManager<InstanceInfo>, LookupServ
 
     void storeOverriddenStatusIfRequired(String id, InstanceStatus overriddenStatus);
 
+    void storeOverriddenStatusIfRequired(String appName, String id, InstanceStatus overriddenStatus);
+
 }

File: eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java
Patch:
@@ -174,7 +174,7 @@ public void handleFailure(int statusCode, Object responseEntity) throws Throwabl
                 } else if (config.shouldSyncWhenTimestampDiffers()) {
                     InstanceInfo peerInstanceInfo = (InstanceInfo) responseEntity;
                     if (peerInstanceInfo != null) {
-                        syncInstancesIfTimestampDiffers(id, info, peerInstanceInfo);
+                        syncInstancesIfTimestampDiffers(appName, id, info, peerInstanceInfo);
                     }
                 }
             }
@@ -299,15 +299,15 @@ public void shutDown() {
      * Synchronize {@link InstanceInfo} information if the timestamp between
      * this node and the peer eureka nodes vary.
      */
-    private void syncInstancesIfTimestampDiffers(String id, InstanceInfo info, InstanceInfo infoFromPeer) {
+    private void syncInstancesIfTimestampDiffers(String appName, String id, InstanceInfo info, InstanceInfo infoFromPeer) {
         try {
             if (infoFromPeer != null) {
                 logger.warn("Peer wants us to take the instance information from it, since the timestamp differs,"
                         + "Id : {} My Timestamp : {}, Peer's timestamp: {}", id, info.getLastDirtyTimestamp(), infoFromPeer.getLastDirtyTimestamp());
 
                 if (infoFromPeer.getOverriddenStatus() != null && !InstanceStatus.UNKNOWN.equals(infoFromPeer.getOverriddenStatus())) {
                     logger.warn("Overridden Status info -id {}, mine {}, peer's {}", id, info.getOverriddenStatus(), infoFromPeer.getOverriddenStatus());
-                    registry.storeOverriddenStatusIfRequired(id, infoFromPeer.getOverriddenStatus());
+                    registry.storeOverriddenStatusIfRequired(appName, id, infoFromPeer.getOverriddenStatus());
                 }
                 registry.register(infoFromPeer, true);
             }

File: eureka-client/src/main/java/com/netflix/appinfo/LeaseInfo.java
Patch:
@@ -172,7 +172,7 @@ public LeaseInfo(@JsonProperty("renewalIntervalInSecs") int renewalIntervalInSec
                      @JsonProperty("durationInSecs") int durationInSecs,
                      @JsonProperty("registrationTimestamp") long registrationTimestamp,
                      @JsonProperty("lastRenewalTimestamp") Long lastRenewalTimestamp,
-                     @JsonProperty("renewalTimestamp") Long lastRenewalTimestampLegacy,  // for legacy
+                     @JsonProperty("renewalTimestamp") long lastRenewalTimestampLegacy,  // for legacy
                      @JsonProperty("evictionTimestamp") long evictionTimestamp,
                      @JsonProperty("serviceUpTimestamp") long serviceUpTimestamp) {
         this.renewalIntervalInSecs = renewalIntervalInSecs;

File: eureka-client/src/main/java/com/netflix/appinfo/LeaseInfo.java
Patch:
@@ -172,7 +172,7 @@ public LeaseInfo(@JsonProperty("renewalIntervalInSecs") int renewalIntervalInSec
                      @JsonProperty("durationInSecs") int durationInSecs,
                      @JsonProperty("registrationTimestamp") long registrationTimestamp,
                      @JsonProperty("lastRenewalTimestamp") Long lastRenewalTimestamp,
-                     @JsonProperty("renewalTimestamp") Long lastRenewalTimestampLegacy,  // for legacy
+                     @JsonProperty("renewalTimestamp") long lastRenewalTimestampLegacy,  // for legacy
                      @JsonProperty("evictionTimestamp") long evictionTimestamp,
                      @JsonProperty("serviceUpTimestamp") long serviceUpTimestamp) {
         this.renewalIntervalInSecs = renewalIntervalInSecs;

File: eureka-core/src/main/java/com/netflix/eureka/util/StatusInfo.java
Patch:
@@ -19,7 +19,7 @@
  *
  * @author Greg Kim
  */
-@Serializer("com.netflix.eureka.converters.EntityBodyConverter")
+@Serializer("com.netflix.discovery.converters.EntityBodyConverter")
 @XStreamAlias("status")
 public class StatusInfo {
     private static final String DATE_FORMAT = "yyyy-MM-dd'T'HH:mm:ss Z";

File: eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegisterUpdateTest.java
Patch:
@@ -49,10 +49,11 @@ public void tearDown() throws Exception {
 
     @Test
     public void registerUpdateLifecycleTest() throws Exception {
+        Thread.sleep(1200);  // give some execution time (the allowed on-demand interval is 60/min)
         applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP);
-        Thread.sleep(400);  // give some execution time
+        Thread.sleep(1200);  // give some execution time
         applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UNKNOWN);
-        Thread.sleep(400);  // give some execution time
+        Thread.sleep(1200);  // give some execution time
         applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.DOWN);
 
         Thread.sleep(2400);

File: eureka-core/src/main/java/com/netflix/eureka/util/StatusInfo.java
Patch:
@@ -19,7 +19,7 @@
  *
  * @author Greg Kim
  */
-@Serializer("com.netflix.eureka.converters.EntityBodyConverter")
+@Serializer("com.netflix.discovery.converters.EntityBodyConverter")
 @XStreamAlias("status")
 public class StatusInfo {
     private static final String DATE_FORMAT = "yyyy-MM-dd'T'HH:mm:ss Z";

File: eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegisterUpdateTest.java
Patch:
@@ -49,10 +49,11 @@ public void tearDown() throws Exception {
 
     @Test
     public void registerUpdateLifecycleTest() throws Exception {
+        Thread.sleep(1200);  // give some execution time (the allowed on-demand interval is 60/min)
         applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP);
-        Thread.sleep(400);  // give some execution time
+        Thread.sleep(1200);  // give some execution time
         applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UNKNOWN);
-        Thread.sleep(400);  // give some execution time
+        Thread.sleep(1200);  // give some execution time
         applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.DOWN);
 
         Thread.sleep(2400);

File: eureka-core/src/main/java/com/netflix/eureka/AbstractInstanceRegistry.java
Patch:
@@ -150,9 +150,9 @@ public void register(InstanceInfo r, int leaseDuration, boolean isReplication) {
             // Retain the last dirty timestamp without overwriting it, if there
             // is already a lease
             if (existingLease != null && (existingLease.getHolder() != null)) {
-                Long existingLastDirtyTimestamp = existingLease.getHolder()
-                        .getLastDirtyTimestamp();
+                Long existingLastDirtyTimestamp = existingLease.getHolder().getLastDirtyTimestamp();
                 Long registrationLastDirtyTimestamp = r.getLastDirtyTimestamp();
+                logger.debug("Existing lease found (existing={}, provided={}", existingLastDirtyTimestamp, registrationLastDirtyTimestamp);
                 if (existingLastDirtyTimestamp > registrationLastDirtyTimestamp) {
                     logger.warn(
                             "There is an existing lease and the existing lease's dirty timestamp {} is greater than "
@@ -173,6 +173,7 @@ public void register(InstanceInfo r, int leaseDuration, boolean isReplication) {
                                         * EUREKA_SERVER_CONFIG.getRenewalPercentThreshold());
                     }
                 }
+                logger.debug("No previous lease information found; it is new registration");
             }
             Lease<InstanceInfo> lease = new Lease<InstanceInfo>(r,
                     leaseDuration);

File: eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java
Patch:
@@ -109,7 +109,7 @@ public HttpResponse<InstanceInfo> sendHeartBeat(String appName, String id, Insta
             addExtraHeaders(requestBuilder);
             response = requestBuilder.accept(MediaType.APPLICATION_JSON_TYPE).put(ClientResponse.class);
             InstanceInfo infoFromPeer = null;
-            if (response.getStatus() == Status.OK.getStatusCode() && response.hasEntity()) {
+            if (response.getStatus() == Status.CONFLICT.getStatusCode() && response.hasEntity()) {
                 infoFromPeer = response.getEntity(InstanceInfo.class);
             }
             return HttpResponse.responseWith(response.getStatus(), infoFromPeer);

File: eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java
Patch:
@@ -123,6 +123,7 @@ public InstanceResource getInstanceInfo(@PathParam("id") String id) {
     @Consumes({"application/json", "application/xml"})
     public void addInstance(InstanceInfo info,
                             @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) {
+        logger.debug("Registering instance {} (replication={})", info.getId(), isReplication);
         registry.register(info, "true".equals(isReplication));
     }
 

File: eureka-core/src/test/java/com/netflix/eureka/cluster/JerseyReplicationClientTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.netflix.eureka.cluster;
 
 import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response.Status;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.util.zip.GZIPOutputStream;
@@ -110,14 +111,14 @@ public void testHeartbeatReplicationWithResponseBody() throws Exception {
                         .withPath("/eureka/v2/apps/" + this.instanceInfo.getAppName() + '/' + this.instanceInfo.getId())
         ).respond(
                 response()
-                        .withStatusCode(200)
+                        .withStatusCode(Status.CONFLICT.getStatusCode())
                         .withHeader(header("Content-Type", MediaType.APPLICATION_JSON))
                         .withHeader(header("Content-Encoding", "gzip"))
                         .withBody(responseBody)
         );
 
         HttpResponse<InstanceInfo> response = replicationClient.sendHeartBeat(this.instanceInfo.getAppName(), this.instanceInfo.getId(), this.instanceInfo, null);
-        assertThat(response.getStatusCode(), is(equalTo(200)));
+        assertThat(response.getStatusCode(), is(equalTo(Status.CONFLICT.getStatusCode())));
         assertThat(response.getEntity(), is(notNullValue()));
     }
 

File: eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java
Patch:
@@ -1213,8 +1213,7 @@ private InstanceStatus getOverriddenInstanceStatus(InstanceInfo r,
         // If the ASGName is present- check for its status
         boolean isASGDisabled = false;
         if (r.getASGName() != null) {
-            isASGDisabled = !AwsAsgUtil.getInstance().isASGEnabled(
-                    r.getASGName());
+            isASGDisabled = !AwsAsgUtil.getInstance().isASGEnabled(r);
             logger.debug("The ASG name is specified {} and the value is {}",
                     r.getASGName(), isASGDisabled);
             if (isASGDisabled) {

File: eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java
Patch:
@@ -46,7 +46,7 @@
  * get refilled by an ASG - which is normal in AWS environments,the instances
  * automatically go in the {@link com.netflix.appinfo.InstanceInfo.InstanceStatus#OUT_OF_SERVICE} state when they
  * are refilled by the ASG and if the ASG is disabled by as indicated by a flag
- * in the ASG as described in {@link AwsAsgUtil#isASGEnabled(String)}
+ * in the ASG as described in {@link AwsAsgUtil#isASGEnabled}
  * </p>
  *
  * @author Karthik Ranganathan

File: eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java
Patch:
@@ -1213,8 +1213,7 @@ private InstanceStatus getOverriddenInstanceStatus(InstanceInfo r,
         // If the ASGName is present- check for its status
         boolean isASGDisabled = false;
         if (r.getASGName() != null) {
-            isASGDisabled = !AwsAsgUtil.getInstance().isASGEnabled(
-                    r.getASGName());
+            isASGDisabled = !AwsAsgUtil.getInstance().isASGEnabled(r);
             logger.debug("The ASG name is specified {} and the value is {}",
                     r.getASGName(), isASGDisabled);
             if (isASGDisabled) {

File: eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java
Patch:
@@ -46,7 +46,7 @@
  * get refilled by an ASG - which is normal in AWS environments,the instances
  * automatically go in the {@link com.netflix.appinfo.InstanceInfo.InstanceStatus#OUT_OF_SERVICE} state when they
  * are refilled by the ASG and if the ASG is disabled by as indicated by a flag
- * in the ASG as described in {@link AwsAsgUtil#isASGEnabled(String)}
+ * in the ASG as described in {@link AwsAsgUtil#isASGEnabled}
  * </p>
  *
  * @author Karthik Ranganathan

File: eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java
Patch:
@@ -674,14 +674,14 @@ public long getNumOfReplicationsInLastMin() {
     }
 
     /**
-     * Checks if the number of renewals is lesser than threshold.
+     * Checks if the number of renewals is lesser than threshold. This method is for servo metrics only.
      *
      * @return 0 if the renewals are greater than threshold, 1 otherwise.
      */
     @com.netflix.servo.annotations.Monitor(name = "isBelowRenewThreshold", description = "0 = false, 1 = true",
             type = com.netflix.servo.annotations.DataSourceType.GAUGE)
     public int isBelowRenewThresold() {
-        if ((getNumOfRenewsInLastMin() < numberOfRenewsPerMinThreshold)
+        if ((getNumOfRenewsInLastMin() <= numberOfRenewsPerMinThreshold)
                 && ((this.startupTime > 0) && (System.currentTimeMillis() > this.startupTime
                 + (EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())))) {
             return 1;

File: eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.TimeUnit;
 
-import com.amazonaws.auth.AWSCredentials;
 import com.amazonaws.services.securitytoken.AWSSecurityTokenService;
 import com.amazonaws.services.securitytoken.AWSSecurityTokenServiceClient;
 import com.amazonaws.services.securitytoken.model.AssumeRoleResult;
@@ -154,7 +153,7 @@ public void setStatus(String asgName, boolean enabled) {
     private boolean isAddToLoadBalancerSuspended(String asgName) {
         String asgAccount = getASGAccount(asgName);
         AutoScalingGroup asg;
-        if(asgAccount.equals(accountId)) {
+        if(asgAccount == null || asgAccount.equals(accountId)) {
             asg = retrieveAutoScalingGroup(asgName);
         } else {
             asg = retrieveAutoScalingGroupCrossAccount(asgAccount, asgName);
@@ -410,7 +409,7 @@ private String getASGAccount(String asgName) {
             }
         }
 
-        logger.error("Couldn't get the ASG account for " + asgName);
+        logger.warn("Couldn't get the ASG account for {}, using the default accountId instead", asgName);
         return accountId;
     }
 

File: eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java
Patch:
@@ -674,14 +674,14 @@ public long getNumOfReplicationsInLastMin() {
     }
 
     /**
-     * Checks if the number of renewals is lesser than threshold.
+     * Checks if the number of renewals is lesser than threshold. This method is for servo metrics only.
      *
      * @return 0 if the renewals are greater than threshold, 1 otherwise.
      */
     @com.netflix.servo.annotations.Monitor(name = "isBelowRenewThreshold", description = "0 = false, 1 = true",
             type = com.netflix.servo.annotations.DataSourceType.GAUGE)
     public int isBelowRenewThresold() {
-        if ((getNumOfRenewsInLastMin() < numberOfRenewsPerMinThreshold)
+        if ((getNumOfRenewsInLastMin() <= numberOfRenewsPerMinThreshold)
                 && ((this.startupTime > 0) && (System.currentTimeMillis() > this.startupTime
                 + (EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())))) {
             return 1;

File: eureka-server/src/test/java/com/netflix/eureka/resources/EurekaClientServerRestIntegrationTest.java
Patch:
@@ -124,7 +124,7 @@ public void testHeartbeat() throws Exception {
         jerseyEurekaClient.register(instanceInfo);
 
         // Now send heartbeat
-        HttpResponse<InstanceInfo> heartBeatResponse = jerseyEurekaClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null);
+        HttpResponse<InstanceInfo> heartBeatResponse = jerseyReplicationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null);
 
         assertThat(heartBeatResponse.getStatusCode(), is(equalTo(200)));
         assertThat(heartBeatResponse.getEntity(), is(nullValue()));
@@ -135,7 +135,7 @@ public void testMissedHeartbeat() throws Exception {
         InstanceInfo instanceInfo = instanceInfoIt.next();
 
         // Now send heartbeat
-        HttpResponse<InstanceInfo> heartBeatResponse = jerseyEurekaClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null);
+        HttpResponse<InstanceInfo> heartBeatResponse = jerseyReplicationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null);
 
         assertThat(heartBeatResponse.getStatusCode(), is(equalTo(404)));
     }

File: eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java
Patch:
@@ -38,6 +38,7 @@ public class AbstractTester {
     public static final String REMOTE_REGION_NAME = "us-east-1";
     public static final String REMOTE_REGION_APP_NAME = "MYAPP";
     public static final String REMOTE_REGION_INSTANCE_1_HOSTNAME = "blah";
+    public static final String REMOTE_REGION_INSTANCE_2_HOSTNAME = "blah2";
     public static final String LOCAL_REGION_APP_NAME = "MYLOCAPP";
     public static final String LOCAL_REGION_INSTANCE_1_HOSTNAME = "blahloc";
     public static final String LOCAL_REGION_INSTANCE_2_HOSTNAME = "blahloc2";

File: eureka-core/src/test/java/com/netflix/eureka/InstanceRegistryTest.java
Patch:
@@ -97,7 +97,7 @@ public void testGetAppsFromLocalRegionOnly() throws Exception {
 
     @Test
     public void testGetAppsFromBothRegions() throws Exception {
-        registerInstanceLocally(createRemoteInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME));
+        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_2_HOSTNAME));
         registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME));
 
         Applications apps = registry.getApplicationsFromAllRemoteRegions();
@@ -114,10 +114,10 @@ public void testGetAppsFromBothRegions() throws Exception {
             }
         }
         Assert.assertNotNull("Did not find local registry app", locaApplication);
-        Assert.assertEquals("Local registry app instance count not as expected.", 1,
+        Assert.assertEquals("Local registry app instance count not as expected.", 2,
                 locaApplication.getInstances().size());
         Assert.assertNotNull("Did not find remote registry app", remApplication);
-        Assert.assertEquals("Remote registry app instance count not as expected.", 2,
+        Assert.assertEquals("Remote registry app instance count not as expected.", 1,
                 remApplication.getInstances().size());
 
     }

File: eureka-server/src/test/java/com/netflix/eureka/resources/EurekaClientServerRestIntegrationTest.java
Patch:
@@ -11,7 +11,6 @@
 
 import com.netflix.appinfo.InstanceInfo;
 import com.netflix.appinfo.InstanceInfo.InstanceStatus;
-import com.netflix.discovery.EurekaClientConfig;
 import com.netflix.discovery.shared.EurekaHttpClient.HttpResponse;
 import com.netflix.discovery.shared.EurekaJerseyClient;
 import com.netflix.discovery.shared.EurekaJerseyClient.JerseyClient;
@@ -53,7 +52,6 @@ public class EurekaClientServerRestIntegrationTest {
 
     private static final Pattern WAR_PATTERN = Pattern.compile("eureka-server.*.war");
 
-    private static EurekaClientConfig eurekaClientConfig;
     private static EurekaServerConfig eurekaServerConfig;
 
     private static Server server;

File: eureka-client/src/test/java/com/netflix/discovery/converters/CodecLoadTester.java
Patch:
@@ -26,7 +26,7 @@ public class CodecLoadTester {
     private final EurekaJacksonCodec jacksonCodec = new EurekaJacksonCodec();
 
     public CodecLoadTester(int instanceCount, int appCount) {
-        Iterator<InstanceInfo> instanceIt = new InstanceInfoGenerator(instanceCount, appCount).serviceIterator();
+        Iterator<InstanceInfo> instanceIt = new InstanceInfoGenerator(instanceCount, appCount, true).serviceIterator();
         int appIdx = 0;
         while (instanceIt.hasNext()) {
             InstanceInfo next = instanceIt.next();

File: eureka-client/src/main/java/com/netflix/appinfo/providers/CloudInstanceConfigProvider.java
Patch:
@@ -1,7 +1,5 @@
 package com.netflix.appinfo.providers;
 
-import javax.inject.Singleton;
-
 import com.google.inject.Inject;
 import com.google.inject.Provider;
 import com.netflix.appinfo.CloudInstanceConfig;
@@ -12,7 +10,6 @@
  * This provider is necessary because the namespace is optional.
  * @author elandau
  */
-@Singleton
 public class CloudInstanceConfigProvider implements Provider<CloudInstanceConfig> {
     @Inject(optional = true)
     @EurekaNamespace

File: eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java
Patch:
@@ -3,7 +3,6 @@
 import java.util.Map;
 
 import javax.inject.Inject;
-import javax.inject.Singleton;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -14,7 +13,6 @@
 import com.netflix.appinfo.LeaseInfo;
 import com.netflix.appinfo.InstanceInfo.InstanceStatus;
 import com.netflix.appinfo.InstanceInfo.PortType;
-import com.netflix.governator.guice.lazy.LazySingleton;
 
 /**
  * InstanceInfo provider that constructs the InstanceInfo this this instance using
@@ -23,7 +21,6 @@
  * @author elandau
  *
  */
-@LazySingleton
 public class EurekaConfigBasedInstanceInfoProvider implements Provider<InstanceInfo> {
     private static final Logger LOG = LoggerFactory.getLogger(EurekaConfigBasedInstanceInfoProvider.class);
 

File: eureka-client/src/main/java/com/netflix/appinfo/providers/MyDataCenterInstanceConfigProvider.java
Patch:
@@ -6,6 +6,9 @@
 import com.netflix.discovery.DiscoveryManager;
 import com.netflix.discovery.EurekaNamespace;
 
+import javax.inject.Singleton;
+
+@Singleton
 public class MyDataCenterInstanceConfigProvider implements Provider<MyDataCenterInstanceConfig> {
     @Inject(optional = true)
     @EurekaNamespace

File: eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.Arrays;
 import java.util.List;
 
+import com.netflix.governator.guice.lazy.FineGrainedLazySingleton;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -55,6 +56,7 @@
  * @author Karthik Ranganathan
  *
  */
+@FineGrainedLazySingleton
 @ProvidedBy(DefaultEurekaClientConfigProvider.class)
 public class DefaultEurekaClientConfig implements EurekaClientConfig {
     private static final String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = "archaius.deployment.environment";

File: eureka-client/src/main/java/com/netflix/discovery/providers/DefaultEurekaClientConfigProvider.java
Patch:
@@ -6,10 +6,13 @@
 import com.netflix.discovery.EurekaClientConfig;
 import com.netflix.discovery.EurekaNamespace;
 
+import javax.inject.Singleton;
+
 /**
  * This provider is necessary because the namespace is optional.
  * @author elandau
  */
+@Singleton
 public class DefaultEurekaClientConfigProvider implements Provider<EurekaClientConfig> {
 
     @Inject(optional = true)

File: eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java
Patch:
@@ -956,7 +956,9 @@ public InstanceInfo getInstanceByAppAndId(String appName, String id,
         } else if (includeRemoteRegions) {
             for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                 Application application = remoteRegistry.getApplication(appName);
-                return application.getByInstanceId(id);
+                if(application != null) {
+                    return application.getByInstanceId(id);
+                }
             }
         }
         return null;

File: eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java
Patch:
@@ -956,7 +956,9 @@ public InstanceInfo getInstanceByAppAndId(String appName, String id,
         } else if (includeRemoteRegions) {
             for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                 Application application = remoteRegistry.getApplication(appName);
-                return application.getByInstanceId(id);
+                if(application != null) {
+                    return application.getByInstanceId(id);
+                }
             }
         }
         return null;

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -591,7 +591,7 @@ private boolean shouldRegister(InstanceInfo myInfo) {
         if (!clientConfig.shouldRegisterWithEureka()) {
             return false;
         } else if ((myInfo != null)
-                && (myInfo.getDataCenterInfo()
+                && (myInfo.getDataCenterInfo().getName()
                         .equals(DataCenterInfo.Name.Amazon))) {
             return true;
         }
@@ -1630,7 +1630,7 @@ public void run() {
                 // Pass in the appinfo again since
                 if ((discoveryServer != null)
                         && (Name.Amazon.equals(discoveryServer
-                                .getDataCenterInfo()))) {
+                                .getDataCenterInfo().getName()))) {
                     String amiId = ((AmazonInfo) discoveryServer
                             .getDataCenterInfo()).get(MetaDataKey.amiId);
                     if (discoveryServerAMIId == null) {

File: eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java
Patch:
@@ -864,10 +864,10 @@ public String getStatusPageUrl() {
      */
     public Set<String> getHealthCheckUrls() {
         Set<String> healthCheckUrlSet = new LinkedHashSet<String>();
-        if (this.isUnsecurePortEnabled) {
+        if (this.isUnsecurePortEnabled && healthCheckUrl != null && !healthCheckUrl.isEmpty()) {
             healthCheckUrlSet.add(healthCheckUrl);
         }
-        if (this.isSecurePortEnabled) {
+        if (this.isSecurePortEnabled && secureHealthCheckUrl != null && !secureHealthCheckUrl.isEmpty()) {
             healthCheckUrlSet.add(secureHealthCheckUrl);
         }
         return healthCheckUrlSet;

File: eureka-core/src/main/java/com/netflix/eureka/util/EurekaMonitors.java
Patch:
@@ -59,6 +59,7 @@ public enum EurekaMonitors {
     REGISTER("registerCounter", "Number of total registers seen since startup"),
     EXPIRED("expiredCounter", "Number of total expired leases since startup"),
     STATUS_UPDATE("statusUpdateCounter", "Number of total admin status updates since startup"),
+    STATUS_OVERRIDE_DELETE("statusOverrideDeleteCounter", "Number of status override removals"),
     CANCEL_NOT_FOUND("cancelNotFoundCounter", "Number of total cancel requests on non-existing instance since startup"),
     RENEW_NOT_FOUND("renewNotFoundexpiredCounter", "Number of total renew on non-existing instance since startup"),
     REJECTED_REPLICATIONS("numOfRejectedReplications", "Number of replications rejected because of full queue"),

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -1722,7 +1722,7 @@ public void run() {
 
                 fetchRegistry(remoteRegionsModified);
 
-                if (logger.isInfoEnabled()) {
+                if (logger.isDebugEnabled()) {
                     StringBuilder allAppsHashCodes = new StringBuilder();
                     allAppsHashCodes.append("Local region apps hashcode: ");
                     allAppsHashCodes.append(localRegionApps.get().getAppsHashCode());

File: eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java
Patch:
@@ -568,8 +568,9 @@ public Builder setDataCenterInfo(DataCenterInfo datacenter) {
          * @param info
          *            the lease information for this instance.
          */
-        public void setLeaseInfo(LeaseInfo info) {
+        public Builder setLeaseInfo(LeaseInfo info) {
             result.leaseInfo = info;
+            return this;
         }
 
         /**

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -1722,7 +1722,7 @@ public void run() {
 
                 fetchRegistry(remoteRegionsModified);
 
-                if (logger.isInfoEnabled()) {
+                if (logger.isDebugEnabled()) {
                     StringBuilder allAppsHashCodes = new StringBuilder();
                     allAppsHashCodes.append("Local region apps hashcode: ");
                     allAppsHashCodes.append(localRegionApps.get().getAppsHashCode());

File: eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java
Patch:
@@ -16,6 +16,7 @@
 package com.netflix.appinfo;
 
 import java.util.LinkedHashSet;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
@@ -266,7 +267,7 @@ public static Builder newBuilder() {
          */
         public Builder setAppName(String appName) {
             if (appName != null) {
-                result.appName = appName.toUpperCase();
+                result.appName = appName.toUpperCase(Locale.ROOT);
             } else {
                 result.appName = null;
             }
@@ -275,7 +276,7 @@ public Builder setAppName(String appName) {
 
         public Builder setAppGroupName(String appGroupName) {
             if (appGroupName != null) {
-                result.appGroupName = appGroupName.toUpperCase();
+                result.appGroupName = appGroupName.toUpperCase(Locale.ROOT);
             } else {
                 result.appGroupName = null;
             }

File: eureka-client/src/main/java/com/netflix/appinfo/InstanceInfo.java
Patch:
@@ -568,8 +568,9 @@ public Builder setDataCenterInfo(DataCenterInfo datacenter) {
          * @param info
          *            the lease information for this instance.
          */
-        public void setLeaseInfo(LeaseInfo info) {
+        public Builder setLeaseInfo(LeaseInfo info) {
             result.leaseInfo = info;
+            return this;
         }
 
         /**

File: eureka-core/src/main/java/com/netflix/eureka/util/EurekaMonitors.java
Patch:
@@ -55,6 +55,7 @@ public enum EurekaMonitors {
     GET_ALL("getAllCounter", "Number of total registry queries seen since startup"),
     GET_ALL_WITH_REMOTE_REGIONS("getAllWithRemoteRegionCounter",
             "Number of total registry queries with remote regions, seen since startup"),
+    GET_APPLICATION("getApplicationCounter", "Number of total application queries seen since startup"),
     REGISTER("registerCounter", "Number of total registers seen since startup"),
     EXPIRED("expiredCounter", "Number of total expired leases since startup"),
     STATUS_UPDATE("statusUpdateCounter", "Number of total admin status updates since startup"),

File: eureka-core/src/test/java/com/netflix/eureka/RateLimitingFilterTest.java
Patch:
@@ -150,7 +150,7 @@ public void testCustomClientThrottlingCandidatesCounter() throws Exception {
 
     private void whenRequest(String path, String client) {
         when(request.getMethod()).thenReturn("GET");
-        when(request.getPathInfo()).thenReturn(path);
+        when(request.getRequestURI()).thenReturn(path);
         when(request.getHeader(AbstractEurekaIdentity.AUTH_NAME_HEADER_KEY)).thenReturn(client);
     }
 }
\ No newline at end of file

File: eureka-core/src/main/java/com/netflix/eureka/util/EurekaMonitors.java
Patch:
@@ -55,6 +55,7 @@ public enum EurekaMonitors {
     GET_ALL("getAllCounter", "Number of total registry queries seen since startup"),
     GET_ALL_WITH_REMOTE_REGIONS("getAllWithRemoteRegionCounter",
             "Number of total registry queries with remote regions, seen since startup"),
+    GET_APPLICATION("getApplicationCounter", "Number of total application queries seen since startup"),
     REGISTER("registerCounter", "Number of total registers seen since startup"),
     EXPIRED("expiredCounter", "Number of total expired leases since startup"),
     STATUS_UPDATE("statusUpdateCounter", "Number of total admin status updates since startup"),

File: eureka-core/src/test/java/com/netflix/eureka/RateLimitingFilterTest.java
Patch:
@@ -150,7 +150,7 @@ public void testCustomClientThrottlingCandidatesCounter() throws Exception {
 
     private void whenRequest(String path, String client) {
         when(request.getMethod()).thenReturn("GET");
-        when(request.getPathInfo()).thenReturn(path);
+        when(request.getRequestURI()).thenReturn(path);
         when(request.getHeader(AbstractEurekaIdentity.AUTH_NAME_HEADER_KEY)).thenReturn(client);
     }
 }
\ No newline at end of file

File: eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java
Patch:
@@ -396,6 +396,8 @@ private void shuffleInstances(boolean filterUpInstances, boolean indexByRemoteRe
                                   @Nullable InstanceRegionChecker instanceRegionChecker) {
         this.virtualHostNameAppMap.clear();
         this.secureVirtualHostNameAppMap.clear();
+        this.shuffleVirtualHostNameMap.clear();
+        this.shuffledSecureVirtualHostNameMap.clear();
         for (Application application : appNameApplicationMap.values()) {
             if (indexByRemoteRegions) {
                 application.shuffleAndStoreInstances(remoteRegionsRegistry, clientConfig, instanceRegionChecker);

File: eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java
Patch:
@@ -396,6 +396,8 @@ private void shuffleInstances(boolean filterUpInstances, boolean indexByRemoteRe
                                   @Nullable InstanceRegionChecker instanceRegionChecker) {
         this.virtualHostNameAppMap.clear();
         this.secureVirtualHostNameAppMap.clear();
+        this.shuffleVirtualHostNameMap.clear();
+        this.shuffledSecureVirtualHostNameMap.clear();
         for (Application application : appNameApplicationMap.values()) {
             if (indexByRemoteRegions) {
                 application.shuffleAndStoreInstances(remoteRegionsRegistry, clientConfig, instanceRegionChecker);

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -266,7 +266,7 @@ public BackupRegistry get() {
                                     + instanceInfo.getId();
             }
 
-            if (eurekaServiceUrls.get().get(0).startsWith("https://") && 
+            if (eurekaServiceUrls.get().get(0).startsWith("https://") &&
                     "true".equals(System.getProperty("com.netflix.eureka.shouldSSLConnectionsUseSystemSocketFactory"))) {
                 discoveryJerseyClient = EurekaJerseyClient.createSystemSSLJerseyClient("DiscoveryClient-HTTPClient-System",
                         clientConfig.getEurekaServerConnectTimeoutSeconds() * 1000,
@@ -281,13 +281,13 @@ public BackupRegistry get() {
                         clientConfig.getEurekaServerTotalConnectionsPerHost(), 
                         clientConfig.getEurekaServerTotalConnections(),
                         clientConfig.getEurekaConnectionIdleTimeoutSeconds(),
-                        clientConfig.getProxyHost(), clientConfig.getProxyPort(), 
+                        clientConfig.getProxyHost(), clientConfig.getProxyPort(),
                         clientConfig.getProxyUserName(), clientConfig.getProxyPassword());
             } else {
                 discoveryJerseyClient = EurekaJerseyClient.createJerseyClient("DiscoveryClient-HTTPClient",
                         clientConfig.getEurekaServerConnectTimeoutSeconds() * 1000,
                         clientConfig.getEurekaServerReadTimeoutSeconds() * 1000,
-                        clientConfig.getEurekaServerTotalConnectionsPerHost(), 
+                        clientConfig.getEurekaServerTotalConnectionsPerHost(),
                         clientConfig.getEurekaServerTotalConnections(),
                         clientConfig.getEurekaConnectionIdleTimeoutSeconds());
             }

File: eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java
Patch:
@@ -283,7 +283,7 @@ public SSLCustomApacheHttpClientConfig(String clientName, int maxConnectionsPerH
             }
 
         }
-    
+
         private static TrustManager[] createTrustManagers(KeyStore trustStore) {
             TrustManagerFactory factory;
             try {

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -38,7 +38,6 @@
 import com.netflix.discovery.shared.Applications;
 import com.netflix.discovery.shared.EurekaJerseyClient;
 import com.netflix.discovery.shared.EurekaJerseyClient.JerseyClient;
-import com.netflix.discovery.shared.EurekaJerseyClient.SystemSSLCustomApacheHttpClientConfig;
 import com.netflix.discovery.shared.LookupService;
 import com.netflix.eventbus.spi.EventBus;
 import com.netflix.governator.guice.lazy.FineGrainedLazySingleton;
@@ -53,7 +52,6 @@
 import com.sun.jersey.client.apache4.ApacheHttpClient4;
 import com.sun.jersey.client.apache4.config.ApacheHttpClient4Config;
 import com.sun.jersey.client.apache4.config.DefaultApacheHttpClient4Config;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -62,7 +60,6 @@
 import javax.naming.directory.DirContext;
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.core.Response.Status;
-
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;

File: eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java
Patch:
@@ -29,7 +29,6 @@
 import com.sun.jersey.client.apache4.ApacheHttpClient4;
 import com.sun.jersey.client.apache4.config.ApacheHttpClient4Config;
 import com.sun.jersey.client.apache4.config.DefaultApacheHttpClient4Config;
-import org.apache.http.conn.ClientConnectionManager;
 import org.apache.http.conn.scheme.Scheme;
 import org.apache.http.conn.scheme.SchemeRegistry;
 import org.apache.http.conn.ssl.SSLSocketFactory;
@@ -186,7 +185,7 @@ public static JerseyClient createSSLJerseyClient(String clientName, int connecti
             throw new RuntimeException("Cannot create SSL Jersey client ", e);
         }
     }
-    
+
     /**
      * Creates the SSL based Jersey client with the given configuration
      * parameters and using a SystemSocketFactory to support standard keystore/truststore 
@@ -302,7 +301,7 @@ private static TrustManager[] createTrustManagers(KeyStore trustStore) {
         }
     }
     
-    public static class SystemSSLCustomApacheHttpClientConfig extends DefaultApacheHttpClient4Config {
+    private static class SystemSSLCustomApacheHttpClientConfig extends DefaultApacheHttpClient4Config {
     	private static final int HTTPS_PORT = 443;
     	private static final String PROTOCOL = "https";
     	

File: eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java
Patch:
@@ -29,7 +29,6 @@
 import javax.ws.rs.core.Response.Status;
 
 import com.netflix.discovery.EurekaIdentityHeaderFilter;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java
Patch:
@@ -30,7 +30,6 @@
 
 import com.netflix.discovery.EurekaIdentityHeaderFilter;
 import com.netflix.eureka.EurekaServerIdentity;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: eureka-client/src/main/java/com/netflix/discovery/BackupRegistry.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.netflix.discovery;
 
+import com.google.inject.ImplementedBy;
 import com.netflix.discovery.shared.Applications;
 
 /**
@@ -31,6 +32,7 @@
  * @author Karthik Ranganathan
  *
  */
+@ImplementedBy(NotImplementedRegistryImpl.class)
 public interface BackupRegistry {
 
     Applications fetchRegistry();

File: eureka-client/src/test/java/com/netflix/discovery/MockBackupRegistry.java
Patch:
@@ -1,5 +1,6 @@
 package com.netflix.discovery;
 
+import com.google.inject.Singleton;
 import com.netflix.discovery.shared.Application;
 import com.netflix.discovery.shared.Applications;
 
@@ -9,6 +10,7 @@
 /**
  * @author Nitesh Kant
  */
+@Singleton
 public class MockBackupRegistry implements BackupRegistry {
 
     private Map<String, Applications> remoteRegionVsApps = new HashMap<String, Applications>();

File: eureka-client/src/main/java/com/netflix/discovery/BackupRegistry.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.netflix.discovery;
 
+import com.google.inject.ImplementedBy;
 import com.netflix.discovery.shared.Applications;
 
 /**
@@ -31,6 +32,7 @@
  * @author Karthik Ranganathan
  *
  */
+@ImplementedBy(NotImplementedRegistryImpl.class)
 public interface BackupRegistry {
 
     Applications fetchRegistry();

File: eureka-client/src/test/java/com/netflix/discovery/MockBackupRegistry.java
Patch:
@@ -1,5 +1,6 @@
 package com.netflix.discovery;
 
+import com.google.inject.Singleton;
 import com.netflix.discovery.shared.Application;
 import com.netflix.discovery.shared.Applications;
 
@@ -9,6 +10,7 @@
 /**
  * @author Nitesh Kant
  */
+@Singleton
 public class MockBackupRegistry implements BackupRegistry {
 
     private Map<String, Applications> remoteRegionVsApps = new HashMap<String, Applications>();

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -605,7 +605,7 @@ public static List<String> getEurekaServiceUrlsFromConfig(
             availZones = new String[1];
             availZones[0] = "default";
         }
-        logger.debug("The availability zone for the given region {} are %s",
+        logger.debug("The availability zone for the given region {} are {}",
                 region, Arrays.toString(availZones));
         int myZoneOffset = getZoneOffset(instanceZone, preferSameZone,
                 availZones);

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -605,7 +605,7 @@ public static List<String> getEurekaServiceUrlsFromConfig(
             availZones = new String[1];
             availZones[0] = "default";
         }
-        logger.debug("The availability zone for the given region {} are %s",
+        logger.debug("The availability zone for the given region {} are {}",
                 region, Arrays.toString(availZones));
         int myZoneOffset = getZoneOffset(instanceZone, preferSameZone,
                 availZones);

File: eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java
Patch:
@@ -35,7 +35,7 @@ abstract class AbstractVIPResource {
 
     protected Response getVipResponse(String version, String entityName, String acceptHeader,
                                       ResponseCache.Key.EntityType entityType) {
-        if (!PeerAwareInstanceRegistry.getInstance().shouldAllowAccess()) {
+        if (!PeerAwareInstanceRegistry.getInstance().shouldAllowAccess(false)) {
             return Response.status(Response.Status.FORBIDDEN).build();
         }
         CurrentRequestVersion.set(Version.toEnum(version));

File: eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java
Patch:
@@ -72,7 +72,7 @@ public ApplicationResource(String appName) {
     @GET
     public Response getApplication(@PathParam("version") String version,
             @HeaderParam("Accept") final String acceptHeader) {
-        if (!PeerAwareInstanceRegistry.getInstance().shouldAllowAccess()) {
+        if (!PeerAwareInstanceRegistry.getInstance().shouldAllowAccess(false)) {
             return Response.status(Status.FORBIDDEN).build();
         }
         CurrentRequestVersion.set(Version.toEnum(version));

File: eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java
Patch:
@@ -35,7 +35,7 @@ abstract class AbstractVIPResource {
 
     protected Response getVipResponse(String version, String entityName, String acceptHeader,
                                       ResponseCache.Key.EntityType entityType) {
-        if (!PeerAwareInstanceRegistry.getInstance().shouldAllowAccess()) {
+        if (!PeerAwareInstanceRegistry.getInstance().shouldAllowAccess(false)) {
             return Response.status(Response.Status.FORBIDDEN).build();
         }
         CurrentRequestVersion.set(Version.toEnum(version));

File: eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java
Patch:
@@ -72,7 +72,7 @@ public ApplicationResource(String appName) {
     @GET
     public Response getApplication(@PathParam("version") String version,
             @HeaderParam("Accept") final String acceptHeader) {
-        if (!PeerAwareInstanceRegistry.getInstance().shouldAllowAccess()) {
+        if (!PeerAwareInstanceRegistry.getInstance().shouldAllowAccess(false)) {
             return Response.status(Status.FORBIDDEN).build();
         }
         CurrentRequestVersion.set(Version.toEnum(version));

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -1109,8 +1109,8 @@ private ClientResponse makeRemoteCall(Action action, int serviceUrlIndex)
                 break;
             }
 
-            if (logger.isInfoEnabled()) {
-                logger.info("Finished a call to service url {} and url path {} with status code {}.",
+            if (logger.isDebugEnabled()) {
+                logger.debug("Finished a call to service url {} and url path {} with status code {}.",
                             new String[] {serviceUrl, urlPath, String.valueOf(response.getStatus())});
             }
             if (isOk(action, response.getStatus())) {
@@ -1687,7 +1687,7 @@ public void run() {
                         allAppsHashCodes.append(" , apps hashcode: ");
                         allAppsHashCodes.append(entry.getValue().getAppsHashCode());
                     }
-                    logger.info("Completed cache refresh task for discovery. All Apps hash code is {} ",
+                    logger.debug("Completed cache refresh task for discovery. All Apps hash code is {} ",
                                 allAppsHashCodes.toString());
                 }
             } catch (Throwable th) {

File: eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java
Patch:
@@ -21,7 +21,6 @@ public class ServerRequestAuthFilter implements Filter {
     public static final String UNKNOWN = "unknown";
 
     private static final String NAME_PREFIX = "DiscoveryServerRequestAuth_Name_";
-    private static final String ID_PREFIX = "DiscoveryServerRequestAuth_Id_";
 
     @Override
     public void init(FilterConfig filterConfig) throws ServletException {
@@ -47,10 +46,8 @@ protected void logAuth(ServletRequest request) {
 
                 String clientName = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_NAME_HEADER_KEY);
                 String clientVersion = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_VERSION_HEADER_KEY);
-                String clientId = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_ID_HEADER_KEY);
 
                 DynamicCounter.increment(MonitorConfig.builder(NAME_PREFIX + clientName + "-" + clientVersion).build());
-                DynamicCounter.increment(MonitorConfig.builder(ID_PREFIX + clientId).build());
             }
         }
     }

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -1109,8 +1109,8 @@ private ClientResponse makeRemoteCall(Action action, int serviceUrlIndex)
                 break;
             }
 
-            if (logger.isInfoEnabled()) {
-                logger.info("Finished a call to service url {} and url path {} with status code {}.",
+            if (logger.isDebugEnabled()) {
+                logger.debug("Finished a call to service url {} and url path {} with status code {}.",
                             new String[] {serviceUrl, urlPath, String.valueOf(response.getStatus())});
             }
             if (isOk(action, response.getStatus())) {
@@ -1687,7 +1687,7 @@ public void run() {
                         allAppsHashCodes.append(" , apps hashcode: ");
                         allAppsHashCodes.append(entry.getValue().getAppsHashCode());
                     }
-                    logger.info("Completed cache refresh task for discovery. All Apps hash code is {} ",
+                    logger.debug("Completed cache refresh task for discovery. All Apps hash code is {} ",
                                 allAppsHashCodes.toString());
                 }
             } catch (Throwable th) {

File: eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java
Patch:
@@ -21,7 +21,6 @@ public class ServerRequestAuthFilter implements Filter {
     public static final String UNKNOWN = "unknown";
 
     private static final String NAME_PREFIX = "DiscoveryServerRequestAuth_Name_";
-    private static final String ID_PREFIX = "DiscoveryServerRequestAuth_Id_";
 
     @Override
     public void init(FilterConfig filterConfig) throws ServletException {
@@ -47,10 +46,8 @@ protected void logAuth(ServletRequest request) {
 
                 String clientName = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_NAME_HEADER_KEY);
                 String clientVersion = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_VERSION_HEADER_KEY);
-                String clientId = getHeader(httpRequest, AbstractEurekaIdentity.AUTH_ID_HEADER_KEY);
 
                 DynamicCounter.increment(MonitorConfig.builder(NAME_PREFIX + clientName + "-" + clientVersion).build());
-                DynamicCounter.increment(MonitorConfig.builder(ID_PREFIX + clientId).build());
             }
         }
     }

File: eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java
Patch:
@@ -41,7 +41,7 @@ public void destroy() {
     }
 
     protected void logAuth(ServletRequest request) {
-        if ( EurekaServerConfigurationManager.getInstance().getConfiguration().shouldLogAuthHeaders() ) {
+        if ( EurekaServerConfigurationManager.getInstance().getConfiguration().shouldLogIdentityHeaders() ) {
             if (request instanceof HttpServletRequest) {
                 HttpServletRequest httpRequest = (HttpServletRequest) request;
 

File: eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java
Patch:
@@ -262,10 +262,7 @@ public interface EurekaServerConfig {
      * be updated.
      *
      * @return time in milliseconds.
-     * @deprecated This is not used anymore. The cache entry is removed whenever there is a change in the registry or
-     * it is expired as specified by {@link #getResponseCacheAutoExpirationInSeconds()}
      */
-    @Deprecated
     long getResponseCacheUpdateIntervalMs();
 
     /**

File: eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java
Patch:
@@ -262,10 +262,7 @@ public interface EurekaServerConfig {
      * be updated.
      *
      * @return time in milliseconds.
-     * @deprecated This is not used anymore. The cache entry is removed whenever there is a change in the registry or
-     * it is expired as specified by {@link #getResponseCacheAutoExpirationInSeconds()}
      */
-    @Deprecated
     long getResponseCacheUpdateIntervalMs();
 
     /**

File: eureka-client/src/main/java/com/netflix/appinfo/HealthCheckCallback.java
Patch:
@@ -36,8 +36,10 @@
  * {@link HealthCheckResource}.
  * </p>
  *
+ * @deprecated Use {@link com.netflix.appinfo.HealthCheckHandler} instead.
  * @author Karthik Ranganathan, Greg Kim
  */
+@Deprecated
 public interface HealthCheckCallback {
     /**
      * If false, the instance will be marked

File: eureka-client/src/main/java/com/netflix/appinfo/HealthCheckCallback.java
Patch:
@@ -36,8 +36,10 @@
  * {@link HealthCheckResource}.
  * </p>
  *
+ * @deprecated Use {@link com.netflix.appinfo.HealthCheckHandler} instead.
  * @author Karthik Ranganathan, Greg Kim
  */
+@Deprecated
 public interface HealthCheckCallback {
     /**
      * If false, the instance will be marked

File: eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java
Patch:
@@ -197,9 +197,10 @@ private boolean fetchRegistry() {
 
                         }
                     }
-                    logTotalInstances();
                 }
             }
+            logTotalInstances();
+
             logger.debug("Remote Registry Fetch Status : {}", null == response ? null : response.getStatus());
         } catch (Throwable e) {
             logger.error(

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -40,7 +40,6 @@
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.core.Response.Status;
 
-import org.mortbay.log.Log;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java
Patch:
@@ -78,7 +78,7 @@ public Name getName() {
                                                              "http://localhost:" + mockRemoteEurekaServer.getPort() +
                                                              MockRemoteEurekaServer.EUREKA_API_BASE_PATH);
 
-        client = new DiscoveryClient(builder.build(), new DefaultEurekaClientConfig(), new EventBusImpl());
+        client = new DiscoveryClient(builder.build(), new DefaultEurekaClientConfig());
         ApplicationInfoManager.getInstance().initComponent(new MyDataCenterInstanceConfig());
         registry = new InstanceRegistry() {
 

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -40,7 +40,6 @@
 import javax.ws.rs.core.MediaType;
 import javax.ws.rs.core.Response.Status;
 
-import org.mortbay.log.Log;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java
Patch:
@@ -78,7 +78,7 @@ public Name getName() {
                                                              "http://localhost:" + mockRemoteEurekaServer.getPort() +
                                                              MockRemoteEurekaServer.EUREKA_API_BASE_PATH);
 
-        client = new DiscoveryClient(builder.build(), new DefaultEurekaClientConfig(), new EventBusImpl());
+        client = new DiscoveryClient(builder.build(), new DefaultEurekaClientConfig());
         ApplicationInfoManager.getInstance().initComponent(new MyDataCenterInstanceConfig());
         registry = new InstanceRegistry() {
 

File: eureka-client/src/main/java/com/netflix/discovery/InternalEurekaStatusModule.java
Patch:
@@ -28,8 +28,7 @@
  *
  */
 @Singleton
-class InternalEurekaStatusModule extends AbstractModule {
-
+public class InternalEurekaStatusModule extends AbstractModule {
     @LazySingleton
     public static class UpStatusProvider implements Provider<Supplier<Boolean>> {
         @Inject

File: eureka-client/src/main/java/com/netflix/discovery/InternalEurekaStatusModule.java
Patch:
@@ -28,8 +28,7 @@
  *
  */
 @Singleton
-class InternalEurekaStatusModule extends AbstractModule {
-
+public class InternalEurekaStatusModule extends AbstractModule {
     @LazySingleton
     public static class UpStatusProvider implements Provider<Supplier<Boolean>> {
         @Inject

File: eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java
Patch:
@@ -217,7 +217,9 @@ public static class JerseyClient {
 
             @Override
             public Thread newThread(Runnable r) {
-                return new Thread(r, "Eureka-JerseyClient-Conn-Cleaner" + threadNumber.incrementAndGet());
+                Thread thread = new Thread(r, "Eureka-JerseyClient-Conn-Cleaner" + threadNumber.incrementAndGet());
+                thread.setDaemon(true);
+                return thread;
             }
         });
 

File: eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java
Patch:
@@ -262,7 +262,10 @@ public interface EurekaServerConfig {
      * be updated.
      *
      * @return time in milliseconds.
+     * @deprecated This is not used anymore. The cache entry is removed whenever there is a change in the registry or
+     * it is expired as specified by {@link #getResponseCacheAutoExpirationInSeconds()}
      */
+    @Deprecated
     long getResponseCacheUpdateIntervalMs();
 
     /**

File: eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java
Patch:
@@ -262,7 +262,10 @@ public interface EurekaServerConfig {
      * be updated.
      *
      * @return time in milliseconds.
+     * @deprecated This is not used anymore. The cache entry is removed whenever there is a change in the registry or
+     * it is expired as specified by {@link #getResponseCacheAutoExpirationInSeconds()}
      */
+    @Deprecated
     long getResponseCacheUpdateIntervalMs();
 
     /**

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -1148,7 +1148,7 @@ public List<String> getServiceUrlsFromDNS(String instanceZone,
         arrangeListBasedonHostname(serviceUrls);
         serviceUrls.add(0, primaryServiceUrl);
 
-        logger.info(
+        logger.debug(
                 "This client will talk to the following serviceUrls in order : {} ",
                 Arrays.toString(serviceUrls.toArray()));
         t.stop();
@@ -1639,7 +1639,7 @@ public void run() {
                         return;
                     }
                     if (!serviceUrlList.equals(eurekaServiceUrls.get())) {
-                        logger.debug(
+                        logger.info(
                                 "Updating the serviceUrls as they seem to have changed from {} to {} ",
                                 Arrays.toString(eurekaServiceUrls.get()
                                         .toArray()), Arrays

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -1148,7 +1148,7 @@ public List<String> getServiceUrlsFromDNS(String instanceZone,
         arrangeListBasedonHostname(serviceUrls);
         serviceUrls.add(0, primaryServiceUrl);
 
-        logger.info(
+        logger.debug(
                 "This client will talk to the following serviceUrls in order : {} ",
                 Arrays.toString(serviceUrls.toArray()));
         t.stop();
@@ -1639,7 +1639,7 @@ public void run() {
                         return;
                     }
                     if (!serviceUrlList.equals(eurekaServiceUrls.get())) {
-                        logger.debug(
+                        logger.info(
                                 "Updating the serviceUrls as they seem to have changed from {} to {} ",
                                 Arrays.toString(eurekaServiceUrls.get()
                                         .toArray()), Arrays

File: eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java
Patch:
@@ -217,7 +217,9 @@ public static class JerseyClient {
 
             @Override
             public Thread newThread(Runnable r) {
-                return new Thread(r, "Eureka-JerseyClient-Conn-Cleaner" + threadNumber.incrementAndGet());
+                Thread thread = new Thread(r, "Eureka-JerseyClient-Conn-Cleaner" + threadNumber.incrementAndGet());
+                thread.setDaemon(true);
+                return thread;
             }
         });
 

File: eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java
Patch:
@@ -736,7 +736,7 @@ public Applications getApplications(boolean includeRemoteRegion) {
      * @return all application deltas.
      * @deprecated use {@link #getApplicationDeltasFromMultipleRegions(String[])} instead. This method has a
      * flawed behavior of transparently falling back to a remote region if no instances for an app is available locally.
-     * The new behavior is to explictly specify if you need a remote region.
+     * The new behavior is to explicitly specify if you need a remote region.
      */
     @Deprecated
     public Applications getApplicationDeltas() {

File: eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java
Patch:
@@ -679,7 +679,7 @@ private boolean shouldFetchFromRemoteRegistry(String appName, String remoteRegio
      * @return applications
      * @deprecated Use {@link #getApplicationsFromMultipleRegions(String[])} instead. This method has a flawed behavior
      * of transparently falling back to a remote region if no instances for an app is available locally. The new
-     * behavior is to explictly specify if you need a remote region.
+     * behavior is to explicitly specify if you need a remote region.
      */
     @Deprecated
     public Applications getApplications(boolean includeRemoteRegion) {

File: eureka-client/src/main/java/com/netflix/appinfo/DataCenterInfo.java
Patch:
@@ -20,12 +20,12 @@
 
 /**
  * A simple interface for indicating which <em>datacenter</em> a particular instance belongs.
- * 
+ *
  * @author Karthik Ranganathan
  *
  */
 @XStreamAlias("datacenter")
 public interface DataCenterInfo {
-   enum Name {Netflix, Amazon, MyOwn};
+   enum Name { Netflix, Amazon, MyOwn };
    Name getName();
 }

File: eureka-client/src/main/java/com/netflix/appinfo/HealthCheckResource.java
Patch:
@@ -26,7 +26,7 @@
 
 /**
  * A basic <em>healthcheck</em> jersey resource.
- * 
+ *
  * This can be used a {@link HealthCheckCallback} resource if required.
  * @author Karthik Ranganathan, Greg Kim
  *
@@ -62,4 +62,4 @@ public Response doHealthCheck() {
             return Response.status(Status.INTERNAL_SERVER_ERROR).build();
         }
     }
-}
\ No newline at end of file
+}

File: eureka-client/src/main/java/com/netflix/appinfo/MyDataCenterInstanceConfig.java
Patch:
@@ -22,15 +22,15 @@
 
 /**
  * An {@link InstanceInfo} configuration for the non-AWS datacenter.
- * 
+ *
  * @author Karthik Ranganathan
- * 
+ *
  */
 @Singleton
 @ProvidedBy(MyDataCenterInstanceConfigProvider.class)
 public class MyDataCenterInstanceConfig extends PropertiesInstanceConfig
 implements EurekaInstanceConfig {
-    
+
     public MyDataCenterInstanceConfig() {
     }
 

File: eureka-client/src/main/java/com/netflix/discovery/BackupRegistry.java
Patch:
@@ -22,14 +22,14 @@
  * A simple contract for <em>eureka</em> clients to fallback for getting
  * registry information in case eureka clients are unable to retrieve this
  * information from any of the <em>eureka</em> servers.
- * 
+ *
  * <p>
  * This is normally not required, but for applications that cannot exist without
  * the registry information it can provide some additional reslience.
  * </p>
- * 
+ *
  * @author Karthik Ranganathan
- * 
+ *
  */
 public interface BackupRegistry {
 

File: eureka-client/src/main/java/com/netflix/discovery/EurekaNamespace.java
Patch:
@@ -8,7 +8,7 @@
 import com.google.inject.BindingAnnotation;
 
 @BindingAnnotation
-@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD})
+@Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })
 @Retention(RetentionPolicy.RUNTIME)
 public @interface EurekaNamespace {
 

File: eureka-client/src/main/java/com/netflix/discovery/shared/Pair.java
Patch:
@@ -18,7 +18,7 @@
 
 /**
  * An utility class for stores any information that needs to exist as a pair.
- * 
+ *
  * @author Karthik Ranganathan
  *
  * @param <E1> Generics indicating the type information for the first one in the pair.
@@ -48,4 +48,4 @@ public Pair(E1 first, E2 second) {
         this.first = first;
         this.second = second;
     }
-}
\ No newline at end of file
+}

File: eureka-core/src/main/java/com/netflix/eureka/CurrentRequestVersion.java
Patch:
@@ -26,7 +26,7 @@
  * Rather it is here to support those cases where someplace deep in
  * a library we need to know about the context of the request that
  * initially triggered the current request.</p>
- * 
+ *
  * @author Karthik Ranganathan, Greg Kim
  */
 public final class CurrentRequestVersion {
@@ -45,10 +45,10 @@ public static Version get() {
     }
 
     /**
-     * Sets the current {@link Version}
+     * Sets the current {@link Version}.
      */
     public static void set(Version version) {
         CURRENT_REQ_VERSION.set(version);
     }
 
-}
\ No newline at end of file
+}

File: eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfigurationManager.java
Patch:
@@ -18,12 +18,12 @@
 
 
 /**
- * 
+ *
  * The class that caches the configuration of the instance of
  * {@link EurekaServerConfig} that the server started with.
- * 
+ *
  * @author Karthik Ranganathan.
- * 
+ *
  */
 public class EurekaServerConfigurationManager {
     private EurekaServerConfig config;

File: eureka-core/src/main/java/com/netflix/eureka/StatusFilter.java
Patch:
@@ -40,7 +40,7 @@ public class StatusFilter implements Filter {
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see javax.servlet.Filter#destroy()
      */
     public void destroy() {
@@ -50,7 +50,7 @@ public void destroy() {
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest,
      * javax.servlet.ServletResponse, javax.servlet.FilterChain)
      */
@@ -70,7 +70,7 @@ public void doFilter(ServletRequest request, ServletResponse response,
 
     /*
      * (non-Javadoc)
-     * 
+     *
      * @see javax.servlet.Filter#init(javax.servlet.FilterConfig)
      */
     public void init(FilterConfig arg0) throws ServletException {

File: eureka-core/src/main/java/com/netflix/eureka/V1AwareInstanceInfoConverter.java
Patch:
@@ -23,9 +23,9 @@
 /**
  * Support for {@link Version#V1}. {@link Version#V2} introduces a new status
  * {@link InstanceStatus#OUT_OF_SERVICE}.
- * 
+ *
  * @author Karthik Ranganathan, Greg Kim
- * 
+ *
  */
 public class V1AwareInstanceInfoConverter extends InstanceInfoConverter {
 

File: eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java
Patch:
@@ -44,7 +44,8 @@ protected Response getVipResponse(String version, String entityName, String acce
             keyType = ResponseCache.KeyType.XML;
         }
 
-        ResponseCache.Key cacheKey = new ResponseCache.Key(entityType, entityName, keyType, CurrentRequestVersion.get());
+        ResponseCache.Key cacheKey = new ResponseCache.Key(entityType, entityName, keyType,
+                CurrentRequestVersion.get());
 
         String payLoad = ResponseCache.getInstance().get(cacheKey);
 

File: eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java
Patch:
@@ -36,7 +36,7 @@
 
 /**
  * A <em>jersey</em> resource that gets information about a particular instance.
- * 
+ *
  * @author Karthik Ranganathan, Greg Kim
  *
  */

File: eureka-core/src/main/java/com/netflix/eureka/util/MeasuredRate.java
Patch:
@@ -23,8 +23,8 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * Utility class for getting a count in last X milliseconds
- * 
+ * Utility class for getting a count in last X milliseconds.
+ *
  * @author Karthik Ranganathan,Greg Kim
  */
 public class MeasuredRate {
@@ -63,7 +63,7 @@ public long getCount() {
     }
 
     /**
-     * Increments the count in the current sample interval. 
+     * Increments the count in the current sample interval.
      */
     public void increment() {
         currentBucket.incrementAndGet();

File: eureka-server/test/java/com/netflix/eureka/SampleEurekaClient.java
Patch:
@@ -35,9 +35,9 @@
 /**
  * Sample Eureka client that discovers the service using Eureka and sends
  * requests.
- * 
+ *
  * @author Karthik Ranganathan
- * 
+ *
  */
 public class SampleEurekaClient {
     private static final DynamicPropertyFactory configInstance = com.netflix.config.DynamicPropertyFactory
@@ -91,7 +91,7 @@ public void unRegisterWithEureka() {
         DiscoveryManager.getInstance().shutdownComponent();
     }
 
-    public static void main(String args[]) {
+    public static void main(String[] args) {
         SampleEurekaClient sampleEurekaService = new SampleEurekaClient();
         sampleEurekaService.sendRequestToServiceUsingEureka();
 

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -529,7 +529,7 @@ public static List<String> getEurekaServiceUrlsFromConfig(
             String instanceZone, boolean preferSameZone) {
         List<String> orderedUrls = new ArrayList<String>();
         String region = getRegion();
-        String availZones[] = clientConfig.getAvailabilityZones(clientConfig.getRegion());
+        String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());
         if (availZones == null || availZones.length == 0) {
             availZones = new String[1];
             availZones[0] = "default";
@@ -1180,7 +1180,7 @@ public enum DiscoveryUrlType {
      * @return - The zone in which the particular instance belongs to.
      */
     public static String getZone(InstanceInfo myInfo) {
-        String availZones[] = clientConfig.getAvailabilityZones(clientConfig
+        String[] availZones = clientConfig.getAvailabilityZones(clientConfig
                 .getRegion());
         String instanceZone = ((availZones == null || availZones.length == 0) ? "default"
                 : availZones[0]);

File: eureka-server/test/java/com/netflix/eureka/SampleEurekaClient.java
Patch:
@@ -91,7 +91,7 @@ public void unRegisterWithEureka() {
         DiscoveryManager.getInstance().shutdownComponent();
     }
 
-    public static void main(String args[]) {
+    public static void main(String[] args) {
         SampleEurekaClient sampleEurekaService = new SampleEurekaClient();
         sampleEurekaService.sendRequestToServiceUsingEureka();
 

File: eureka-server/test/java/com/netflix/eureka/SampleEurekaService.java
Patch:
@@ -163,7 +163,7 @@ private void processRequest(final Socket s) {
 
     }
 
-    public static void main(String args[]) {
+    public static void main(String[] args) {
         SampleEurekaService sampleEurekaService = new SampleEurekaService();
         sampleEurekaService.registerWithEureka();
     }

File: eureka-client/src/main/java/com/netflix/appinfo/HealthCheckCallback.java
Patch:
@@ -16,11 +16,9 @@
 
 package com.netflix.appinfo;
 
-import com.netflix.discovery.DiscoveryClient;
-
 /**
  * Applications can implement this interface and register a callback with the
- * {@link DiscoveryClient#registerHealthCheckCallback(HealthCheckCallback)}.
+ * {@link com.netflix.discovery.DiscoveryClient#registerHealthCheckCallback(HealthCheckCallback)}.
  *
  * <p>
  * Your callback will be invoked every

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.netflix.discovery;
 
-import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -86,9 +85,9 @@
  *
  * <p>
  * <tt>Eureka Client</tt> needs a configured list of <tt>Eureka Server</tt>
- * {@link URL}s to talk to.These {@link URL}s are typically amazon elastic eips
+ * {@link java.net.URL}s to talk to.These {@link java.net.URL}s are typically amazon elastic eips
  * which do not change. All of the functions defined above fail-over to other
- * {@link URL}s specified in the list in the case of failure.
+ * {@link java.net.URL}s specified in the list in the case of failure.
  * </p>
  *
  * @author Karthik Ranganathan, Greg Kim

File: eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java
Patch:
@@ -35,7 +35,6 @@
 import com.netflix.appinfo.InstanceInfo.InstanceStatus;
 import com.netflix.appinfo.InstanceInfo.PortType;
 import com.netflix.appinfo.LeaseInfo;
-import com.netflix.discovery.provider.Serializer;
 import com.netflix.discovery.shared.Application;
 import com.netflix.discovery.shared.Applications;
 import com.netflix.servo.monitor.Counter;
@@ -47,11 +46,11 @@
 import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
 
 /**
- * The custom {@link Serializer} for serializing and deserializing the registry
+ * The custom {@link com.netflix.discovery.provider.Serializer} for serializing and deserializing the registry
  * information from and to the eureka server.
  *
  * <p>
- * The {@link Serializer} used here is an <tt>Xstream</tt> serializer which uses
+ * The {@link com.netflix.discovery.provider.Serializer} used here is an <tt>Xstream</tt> serializer which uses
  * the <tt>JSON</tt> format and custom fields.The XStream deserialization does
  * not handle removal of fields and hence this custom mechanism. Since then
  * {@link Auto} annotation introduced handles any fields that does not exist

File: eureka-client/src/main/java/com/netflix/discovery/converters/EntityBodyConverter.java
Patch:
@@ -23,7 +23,6 @@
 import javax.ws.rs.core.MediaType;
 
 import com.netflix.discovery.provider.ISerializer;
-import com.netflix.discovery.provider.Serializer;
 import com.thoughtworks.xstream.XStream;
 
 /**
@@ -34,7 +33,7 @@
  * serialization/deserialization capabilities. If the users to wish to provide
  * their own implementation they can do so by plugging in their own provider
  * here and annotating their classes with that provider by specifying the
- * {@link Serializer} annotation.
+ * {@link com.netflix.discovery.provider.Serializer} annotation.
  * <p>
  *
  * @author Karthik Ranganathan, Greg Kim.

File: eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java
Patch:
@@ -19,7 +19,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.io.Serializable;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.concurrent.ConcurrentHashMap;
@@ -161,7 +160,7 @@ public void writeTo(Object serializableObject, Class serializableClass,
     }
 
     /**
-     * Checks for the {@link Serializable} annotation for the given class.
+     * Checks for the {@link java.io.Serializable} annotation for the given class.
      *
      * @param serializableClass
      *            The class to be serialized/deserialized.

File: eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java
Patch:
@@ -17,7 +17,6 @@
 package com.netflix.eureka;
 
 import javax.annotation.Nullable;
-import java.net.URL;
 import java.util.Map;
 import java.util.Set;
 
@@ -26,7 +25,7 @@
  *
  * <p>
  * Most of the required information is provided by the default configuration
- * {@link DefaultServerConfig}.
+ * {@link com.netflix.eureka.DefaultEurekaServerConfig}.
  *
  * Note that all configurations are not effective at runtime unless and
  * otherwise specified.
@@ -455,7 +454,7 @@ public interface EurekaServerConfig {
 
     /**
      * Get the list of remote region urls.
-     * @return - array of string representing {@link URL}s.
+     * @return - array of string representing {@link java.net.URL}s.
      * @deprecated Use {@link #getRemoteRegionUrlsWithName()}
      */
     String[] getRemoteRegionUrls();

File: eureka-core/src/main/java/com/netflix/eureka/lease/LeaseManager.java
Patch:
@@ -16,16 +16,14 @@
 
 package com.netflix.eureka.lease;
 
-import com.netflix.eureka.InstanceRegistry;
-
 /**
  * This class is responsible for creating/renewing and evicting a <em>lease</em>
  * for a particular instance.
  *
  * <p>
  * Leases determine what instances receive traffic. When there is no renewal
  * request from the client, the lease gets expired and the instances are evicted
- * out of {@link InstanceRegistry}. This is key to instances receiving traffic
+ * out of {@link com.netflix.eureka.InstanceRegistry}. This is key to instances receiving traffic
  * or not.
  * <p>
  *

File: eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java
Patch:
@@ -27,7 +27,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.netflix.appinfo.InstanceInfo.InstanceStatus;
 import com.netflix.eureka.PeerAwareInstanceRegistry;
 import com.netflix.eureka.cluster.PeerEurekaNode;
 import com.netflix.eureka.util.AwsAsgUtil;
@@ -46,7 +45,7 @@
  * <p>
  * During such a scenario, when an ASG is disabled and the instances go away and
  * get refilled by an ASG - which is normal in AWS environments,the instances
- * automatically go in the {@link InstanceStatus#OUT_OF_SERVICE} state when they
+ * automatically go in the {@link com.netflix.appinfo.InstanceInfo.InstanceStatus#OUT_OF_SERVICE} state when they
  * are refilled by the ASG and if the ASG is disabled by as indicated by a flag
  * in the ASG as described in {@link AwsAsgUtil#isASGEnabled(String)}
  * </p>

File: eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java
Patch:
@@ -46,7 +46,6 @@
 import com.netflix.discovery.shared.Applications;
 import com.netflix.eureka.EurekaServerConfig;
 import com.netflix.eureka.EurekaServerConfigurationManager;
-import com.netflix.eureka.InstanceRegistry;
 import com.netflix.eureka.PeerAwareInstanceRegistry;
 import com.netflix.servo.annotations.DataSourceType;
 import com.netflix.servo.monitor.Monitors;
@@ -288,7 +287,7 @@ public void run() {
      * Get the names of all the ASG to which query AWS for.
      *
      * <p>
-     * The names are obtained from the {@link InstanceRegistry} which is then
+     * The names are obtained from the {@link com.netflix.eureka.InstanceRegistry} which is then
      * used for querying the AWS.
      * </p>
      *

File: eureka-client/src/main/java/com/netflix/appinfo/DataCenterInfo.java
Patch:
@@ -26,6 +26,6 @@
  */
 @XStreamAlias("datacenter")
 public interface DataCenterInfo {
-   enum Name {Netflix, Amazon, MyOwn};
+   enum Name { Netflix, Amazon, MyOwn };
    Name getName();
 }

File: eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java
Patch:
@@ -76,9 +76,9 @@ public InstanceInfo get() {
             LOG.info("Setting initial instance status as: " + initialStatus);
             builder.setStatus(initialStatus);
         } else {
-            LOG.info("Setting initial instance status as: " + InstanceStatus.UP +
-                        ". This may be too early for the instance to advertise itself as available. " +
-                        "You would instead want to control this via a healthcheck handler.");
+            LOG.info("Setting initial instance status as: " + InstanceStatus.UP
+                    + ". This may be too early for the instance to advertise itself as available. "
+                    + "You would instead want to control this via a healthcheck handler.");
         }
 
         // Add any user-specific metadata information

File: eureka-client/src/main/java/com/netflix/appinfo/providers/MyDataCenterInstanceConfigProvider.java
Patch:
@@ -7,7 +7,7 @@
 import com.netflix.discovery.EurekaNamespace;
 
 public class MyDataCenterInstanceConfigProvider implements Provider<MyDataCenterInstanceConfig> {
-    @Inject(optional=true)
+    @Inject(optional = true)
     @EurekaNamespace
     private String namespace;
 

File: eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java
Patch:
@@ -93,7 +93,8 @@ private void init() {
                     .loadCascadedPropertiesFromResources(eurekaPropsFile);
         } catch (IOException e) {
             logger.warn(
-                    "Cannot find the properties specified : {}. This may be okay if there are other environment specific properties or the configuration is installed with a different mechanism.",
+                    "Cannot find the properties specified : {}. This may be okay if there are other environment "
+                    + "specific properties or the configuration is installed with a different mechanism.",
                     eurekaPropsFile);
 
         }

File: eureka-client/src/main/java/com/netflix/discovery/EurekaNamespace.java
Patch:
@@ -8,7 +8,7 @@
 import com.google.inject.BindingAnnotation;
 
 @BindingAnnotation
-@Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD})
+@Target({ ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD })
 @Retention(RetentionPolicy.RUNTIME)
 public @interface EurekaNamespace {
 

File: eureka-client/src/main/java/com/netflix/discovery/InternalEurekaStatusModule.java
Patch:
@@ -66,11 +66,11 @@ public Boolean get() {
 
     @Override
     protected void configure() {
-        bind(new TypeLiteral<Supplier<Boolean>>() {})
+        bind(new TypeLiteral<Supplier<Boolean>>() { })
             .annotatedWith(UpStatus.class)
             .toProvider(UpStatusProvider.class);
 
-        bind(new TypeLiteral<Supplier<Boolean>>() {})
+        bind(new TypeLiteral<Supplier<Boolean>>() { })
             .annotatedWith(DownStatus.class)
             .toProvider(DownStatusProvider.class);
     }

File: eureka-client/src/main/java/com/netflix/discovery/converters/JsonXStream.java
Patch:
@@ -54,8 +54,7 @@ protected NameCoder getNameCoder() {
         registerConverter(new Converters.LeaseInfoConverter());
         registerConverter(new Converters.MetadataConverter());
         setMode(XStream.NO_REFERENCES);
-        processAnnotations(new Class[] { InstanceInfo.class, Application.class,
-                Applications.class });
+        processAnnotations(new Class[] {InstanceInfo.class, Application.class, Applications.class});
     }
 
     public static JsonXStream getInstance() {

File: eureka-client/src/main/java/com/netflix/discovery/converters/XmlXStream.java
Patch:
@@ -48,8 +48,8 @@ public XmlXStream() {
         registerConverter(new Converters.LeaseInfoConverter());
         registerConverter(new Converters.MetadataConverter());
         setMode(XStream.NO_REFERENCES);
-        processAnnotations(new Class[] { InstanceInfo.class, Application.class,
-                Applications.class });
+        processAnnotations(new Class[] {InstanceInfo.class, Application.class,
+                Applications.class});
     }
 
     public static XmlXStream getInstance() {

File: eureka-client/src/main/java/com/netflix/discovery/providers/DefaultEurekaClientConfigProvider.java
Patch:
@@ -12,7 +12,7 @@
  */
 public class DefaultEurekaClientConfigProvider implements Provider<EurekaClientConfig> {
 
-    @Inject(optional=true)
+    @Inject(optional = true)
     @EurekaNamespace
     private String namespace;
 

File: eureka-client/src/main/java/com/netflix/discovery/shared/Application.java
Patch:
@@ -117,8 +117,7 @@ public void removeInstance(InstanceInfo i) {
     public List<InstanceInfo> getInstances() {
         if (this.shuffledInstances.get() == null) {
             return this.getInstancesAsIsFromEureka();
-        }
-        else {
+        } else {
             return this.shuffledInstances.get();
         }
     }
@@ -207,7 +206,8 @@ private void _shuffleAndStoreInstances(boolean filterUpInstances, boolean indexB
                             remoteRegionsRegistry.put(instanceRegion, appsForRemoteRegion);
                         }
 
-                        Application remoteApp = appsForRemoteRegion.getRegisteredApplications(instanceInfo.getAppName());
+                        Application remoteApp =
+                                appsForRemoteRegion.getRegisteredApplications(instanceInfo.getAppName());
                         if (null == remoteApp) {
                             remoteApp = new Application(instanceInfo.getAppName());
                             appsForRemoteRegion.addApplication(remoteApp);

File: eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java
Patch:
@@ -366,8 +366,8 @@ public void shuffleInstances(boolean filterUpInstances) {
         _shuffleInstances(filterUpInstances, false, null, null, null);
     }
 
-    public void shuffleAndIndexInstances(Map<String, Applications> remoteRegionsRegistry, EurekaClientConfig clientConfig,
-                                         InstanceRegionChecker instanceRegionChecker) {
+    public void shuffleAndIndexInstances(Map<String, Applications> remoteRegionsRegistry,
+                                         EurekaClientConfig clientConfig, InstanceRegionChecker instanceRegionChecker) {
         _shuffleInstances(clientConfig.shouldFilterOnlyUpInstances(), true, remoteRegionsRegistry, clientConfig,
                           instanceRegionChecker);
     }

File: eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java
Patch:
@@ -448,8 +448,8 @@ public interface EurekaServerConfig {
     /**
      * Get a map of region name against remote region discovery url.
      *
-     * @return - An unmodifiable map of remote region name against remote region discovery url. Empty map if no remote region url
-     * is defined.
+     * @return - An unmodifiable map of remote region name against remote region discovery url. Empty map if no remote
+     * region url is defined.
      */
     Map<String, String> getRemoteRegionUrlsWithName();
 

File: eureka-core/src/main/java/com/netflix/eureka/Version.java
Patch:
@@ -28,9 +28,9 @@
 public enum Version {
     V1, V2;
 
-    public static Version toEnum(String v){
-        for(Version version : Version.values()){
-            if(version.name().equalsIgnoreCase(v)){
+    public static Version toEnum(String v) {
+        for (Version version : Version.values()) {
+            if (version.name().equalsIgnoreCase(v)) {
                 return version;
             }
         }

File: eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java
Patch:
@@ -44,7 +44,8 @@ protected Response getVipResponse(String version, String entityName, String acce
             keyType = ResponseCache.KeyType.XML;
         }
 
-        ResponseCache.Key cacheKey = new ResponseCache.Key(entityType, entityName, keyType, CurrentRequestVersion.get());
+        ResponseCache.Key cacheKey = new ResponseCache.Key(entityType, entityName, keyType,
+                CurrentRequestVersion.get());
 
         String payLoad = ResponseCache.getInstance().get(cacheKey);
 

File: eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationsResource.java
Patch:
@@ -112,7 +112,7 @@ public Response getContainers(@PathParam("version") String version,
             EurekaMonitors.GET_ALL.increment();
         } else {
             regions = regionsStr.toLowerCase().split(",");
-            Arrays.sort(regions); // So, that we don't have different caches for same regions queried in different order.
+            Arrays.sort(regions); // So we don't have different caches for same regions queried in different order.
             EurekaMonitors.GET_ALL_WITH_REMOTE_REGIONS.increment();
         }
         // Check if the server allows the access to the registry. The server can
@@ -195,7 +195,7 @@ public Response getContainerDifferential(
             EurekaMonitors.GET_ALL_DELTA.increment();
         } else {
             regions = regionsStr.toLowerCase().split(",");
-            Arrays.sort(regions); // So, that we don't have different caches for same regions queried in different order.
+            Arrays.sort(regions); // So we don't have different caches for same regions queried in different order.
             EurekaMonitors.GET_ALL_DELTA_WITH_REMOTE_REGIONS.increment();
         }
 

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -160,7 +160,7 @@ private enum Action {
     @Inject(optional=true)
     private EventBus eventBus;
     
-    DiscoveryClient(InstanceInfo myInfo, EurekaClientConfig config, EventBus eventBus) {
+    public DiscoveryClient(InstanceInfo myInfo, EurekaClientConfig config, EventBus eventBus) {
         this(myInfo, config);
         this.eventBus = eventBus;
     }

File: eureka-client/src/main/java/com/netflix/discovery/providers/DefaultEurekaClientConfigProvider.java
Patch:
@@ -3,20 +3,21 @@
 import com.google.inject.Inject;
 import com.google.inject.Provider;
 import com.netflix.discovery.DefaultEurekaClientConfig;
+import com.netflix.discovery.EurekaClientConfig;
 import com.netflix.discovery.EurekaNamespace;
 
 /**
  * This provider is necessary because the namespace is optional
  * @author elandau
  */
-public class DefaultEurekaClientConfigProvider implements Provider<DefaultEurekaClientConfig> {
+public class DefaultEurekaClientConfigProvider implements Provider<EurekaClientConfig> {
 
     @Inject(optional=true)
     @EurekaNamespace 
     private String namespace;
     
     @Override
-    public DefaultEurekaClientConfig get() {
+    public EurekaClientConfig get() {
         if (namespace == null)
             return new DefaultEurekaClientConfig();
         else

File: eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java
Patch:
@@ -132,7 +132,7 @@ public int getInstanceInfoReplicationIntervalSeconds() {
     @Override
     public int getEurekaServiceUrlPollIntervalSeconds() {
         return configInstance.getIntProperty(
-                namespace + "serviceUrlPollIntervalMs", 5 * 60 * 1000).get();
+                namespace + "serviceUrlPollIntervalMs", 5 * 60 * 1000).get() / 1000;
     }
 
     /*
@@ -176,7 +176,7 @@ public boolean shouldGZipContent() {
     @Override
     public int getEurekaServerReadTimeoutSeconds() {
         return configInstance.getIntProperty(
-                namespace + "eurekaServer.readTimeout", 8000).get();
+                namespace + "eurekaServer.readTimeout", 8).get();
     }
 
     /*
@@ -187,7 +187,7 @@ public int getEurekaServerReadTimeoutSeconds() {
     @Override
     public int getEurekaServerConnectTimeoutSeconds() {
         return configInstance.getIntProperty(
-                namespace + "eurekaServer.connectTimeout", 5000).get();
+                namespace + "eurekaServer.connectTimeout", 5).get();
     }
 
     /*

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -186,9 +186,9 @@ private enum Action {
             String proxyPort = clientConfig.getProxyPort();
             discoveryJerseyClient = EurekaJerseyClient.createJerseyClient("DiscoveryClient-HTTPClient",
                                                                           clientConfig
-                                                                                  .getEurekaServerConnectTimeoutSeconds(),
+                                                                                  .getEurekaServerConnectTimeoutSeconds() * 1000,
                                                                           clientConfig
-                                                                                  .getEurekaServerReadTimeoutSeconds(),
+                                                                                  .getEurekaServerReadTimeoutSeconds() * 1000,
                                                                           clientConfig
                                                                                   .getEurekaServerTotalConnectionsPerHost(),
                                                                           clientConfig

File: eureka-client/src/main/java/com/netflix/discovery/providers/DefaultEurekaClientConfigProvider.java
Patch:
@@ -3,20 +3,21 @@
 import com.google.inject.Inject;
 import com.google.inject.Provider;
 import com.netflix.discovery.DefaultEurekaClientConfig;
+import com.netflix.discovery.EurekaClientConfig;
 import com.netflix.discovery.EurekaNamespace;
 
 /**
  * This provider is necessary because the namespace is optional
  * @author elandau
  */
-public class DefaultEurekaClientConfigProvider implements Provider<DefaultEurekaClientConfig> {
+public class DefaultEurekaClientConfigProvider implements Provider<EurekaClientConfig> {
 
     @Inject(optional=true)
     @EurekaNamespace 
     private String namespace;
     
     @Override
-    public DefaultEurekaClientConfig get() {
+    public EurekaClientConfig get() {
         if (namespace == null)
             return new DefaultEurekaClientConfig();
         else

File: eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java
Patch:
@@ -132,7 +132,7 @@ public int getInstanceInfoReplicationIntervalSeconds() {
     @Override
     public int getEurekaServiceUrlPollIntervalSeconds() {
         return configInstance.getIntProperty(
-                namespace + "serviceUrlPollIntervalMs", 5 * 60 * 1000).get();
+                namespace + "serviceUrlPollIntervalMs", 5 * 60 * 1000).get() / 1000;
     }
 
     /*
@@ -176,7 +176,7 @@ public boolean shouldGZipContent() {
     @Override
     public int getEurekaServerReadTimeoutSeconds() {
         return configInstance.getIntProperty(
-                namespace + "eurekaServer.readTimeout", 8000).get();
+                namespace + "eurekaServer.readTimeout", 8).get();
     }
 
     /*
@@ -187,7 +187,7 @@ public int getEurekaServerReadTimeoutSeconds() {
     @Override
     public int getEurekaServerConnectTimeoutSeconds() {
         return configInstance.getIntProperty(
-                namespace + "eurekaServer.connectTimeout", 5000).get();
+                namespace + "eurekaServer.connectTimeout", 5).get();
     }
 
     /*

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -186,9 +186,9 @@ private enum Action {
             String proxyPort = clientConfig.getProxyPort();
             discoveryJerseyClient = EurekaJerseyClient.createJerseyClient("DiscoveryClient-HTTPClient",
                                                                           clientConfig
-                                                                                  .getEurekaServerConnectTimeoutSeconds(),
+                                                                                  .getEurekaServerConnectTimeoutSeconds() * 1000,
                                                                           clientConfig
-                                                                                  .getEurekaServerReadTimeoutSeconds(),
+                                                                                  .getEurekaServerReadTimeoutSeconds() * 1000,
                                                                           clientConfig
                                                                                   .getEurekaServerTotalConnectionsPerHost(),
                                                                           clientConfig

File: eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java
Patch:
@@ -123,7 +123,7 @@ public interface EurekaServerConfig {
     /**
      * The interval with which the information about the changes in peer eureka
      * nodes is updated. The user can use the DNS mechanism or dynamic
-     * configuration provided by {@link https://github.com/Netflix/archaius} to
+     * configuration provided by <a href="https://github.com/Netflix/archaius">Archaius</a> to
      * change the information dynamically.
      * <p>
      * <em>The changes are effective at runtime.</em>

File: eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java
Patch:
@@ -236,7 +236,6 @@ public void handleFailure(int statusCode) throws Throwable {
      *            the instance info {@link InstanceInfo} of the instance.
      * @param overriddenStatus
      *            the overridden status information if any of the instance.
-     * @return true, if the instance exists in the peer node, false otherwise.
      * @throws Throwable
      */
     public void heartbeat(final String appName, final String id,
@@ -341,7 +340,6 @@ public boolean isBatchingSupported() {
      *            the new status of the instance.
      * @param info
      *            the instance information of the instance.
-     * @return true if the update succeeded, false otherwise.
      */
     public void statusUpdate(final String appName, final String id,
             final InstanceStatus newStatus, final InstanceInfo info) {

File: eureka-core/src/main/java/com/netflix/eureka/util/EurekaMonitors.java
Patch:
@@ -31,7 +31,7 @@
  * The enum that encapsulates all statistics monitored by Eureka.
  * 
  * <p>
- * Eureka Monitoring is done using {@link https://github.com/Netflix/servo}. The
+ * Eureka Monitoring is done using <a href="https://github.com/Netflix/servo">Servo</a>. The
  * users who wants to take advantage of the monitoring should read up on
  * <tt>Servo</tt>
  * <p>

File: eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java
Patch:
@@ -199,7 +199,7 @@ public void addLocalRegionAppsDelta(String appName, Application app) {
 
     public void waitForDeltaToBeRetrieved(int refreshRate) throws InterruptedException {
         int count = 0;
-        while (count < 3 && !isSentDelta()) {
+        while (count++ < 3 && !isSentDelta()) {
             System.out.println("Sleeping for " + refreshRate + " seconds to let the remote registry fetch delta. Attempt: " + count);
             Thread.sleep( 3 * refreshRate * 1000);
             System.out.println("Done sleeping for 10 seconds to let the remote registry fetch delta. Delta fetched: " + isSentDelta());

File: eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java
Patch:
@@ -123,7 +123,7 @@ public interface EurekaServerConfig {
     /**
      * The interval with which the information about the changes in peer eureka
      * nodes is updated. The user can use the DNS mechanism or dynamic
-     * configuration provided by {@link https://github.com/Netflix/archaius} to
+     * configuration provided by <a href="https://github.com/Netflix/archaius">Archaius</a> to
      * change the information dynamically.
      * <p>
      * <em>The changes are effective at runtime.</em>

File: eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java
Patch:
@@ -236,7 +236,6 @@ public void handleFailure(int statusCode) throws Throwable {
      *            the instance info {@link InstanceInfo} of the instance.
      * @param overriddenStatus
      *            the overridden status information if any of the instance.
-     * @return true, if the instance exists in the peer node, false otherwise.
      * @throws Throwable
      */
     public void heartbeat(final String appName, final String id,
@@ -341,7 +340,6 @@ public boolean isBatchingSupported() {
      *            the new status of the instance.
      * @param info
      *            the instance information of the instance.
-     * @return true if the update succeeded, false otherwise.
      */
     public void statusUpdate(final String appName, final String id,
             final InstanceStatus newStatus, final InstanceInfo info) {

File: eureka-core/src/main/java/com/netflix/eureka/util/EurekaMonitors.java
Patch:
@@ -31,7 +31,7 @@
  * The enum that encapsulates all statistics monitored by Eureka.
  * 
  * <p>
- * Eureka Monitoring is done using {@link https://github.com/Netflix/servo}. The
+ * Eureka Monitoring is done using <a href="https://github.com/Netflix/servo">Servo</a>. The
  * users who wants to take advantage of the monitoring should read up on
  * <tt>Servo</tt>
  * <p>

File: eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java
Patch:
@@ -199,7 +199,7 @@ public void addLocalRegionAppsDelta(String appName, Application app) {
 
     public void waitForDeltaToBeRetrieved(int refreshRate) throws InterruptedException {
         int count = 0;
-        while (count < 3 && !isSentDelta()) {
+        while (count++ < 3 && !isSentDelta()) {
             System.out.println("Sleeping for " + refreshRate + " seconds to let the remote registry fetch delta. Attempt: " + count);
             Thread.sleep( 3 * refreshRate * 1000);
             System.out.println("Done sleeping for 10 seconds to let the remote registry fetch delta. Delta fetched: " + isSentDelta());

File: eureka-client/src/main/java/com/netflix/appinfo/EurekaInstanceConfig.java
Patch:
@@ -18,6 +18,7 @@
 import java.net.URL;
 import java.util.Map;
 
+import com.google.inject.ImplementedBy;
 import com.netflix.discovery.DiscoveryClient;
 
 /**
@@ -36,6 +37,7 @@
  * @author Karthik Ranganathan
  * 
  */
+@ImplementedBy(CloudInstanceConfig.class)
 public interface EurekaInstanceConfig {
     /**
      * Get the name of the application to be registered with eureka.

File: eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java
Patch:
@@ -24,6 +24,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import com.google.inject.ProvidedBy;
 import com.netflix.config.ConfigurationManager;
 import com.netflix.config.DynamicPropertyFactory;
 import com.netflix.config.DynamicStringProperty;
@@ -53,6 +54,7 @@
  * @author Karthik Ranganathan
  * 
  */
+@ProvidedBy(DefaultEurekaClientConfigProvider.class)
 public class DefaultEurekaClientConfig implements EurekaClientConfig {
     private static final String ARCHAIUS_DEPLOYMENT_ENVIRONMENT = "archaius.deployment.environment";
     private static final String TEST = "test";

File: eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java
Patch:
@@ -22,6 +22,8 @@
 
 import org.apache.http.client.HttpClient;
 
+import com.google.inject.ImplementedBy;
+import com.netflix.appinfo.CloudInstanceConfig;
 import com.netflix.appinfo.InstanceInfo.InstanceStatus;
 
 import javax.annotation.Nullable;
@@ -55,6 +57,7 @@
  * @author Karthik Ranganathan
  * 
  */
+@ImplementedBy(DefaultEurekaClientConfig.class)
 public interface EurekaClientConfig {
 
     /**

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -998,7 +998,7 @@ private void initScheduledTasks() {
 
             // InstanceInfo replication timer
             scheduler.scheduleWithFixedDelay(new InstanceInfoReplicator(),
-                                             10 * 1000 + clientConfig.getInstanceInfoReplicationIntervalSeconds(),
+                                             10 + clientConfig.getInstanceInfoReplicationIntervalSeconds(),
                                              clientConfig.getInstanceInfoReplicationIntervalSeconds(), TimeUnit.SECONDS);
 
         }

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -998,7 +998,7 @@ private void initScheduledTasks() {
 
             // InstanceInfo replication timer
             scheduler.scheduleWithFixedDelay(new InstanceInfoReplicator(),
-                                             10 * 1000 + clientConfig.getInstanceInfoReplicationIntervalSeconds(),
+                                             10 + clientConfig.getInstanceInfoReplicationIntervalSeconds(),
                                              clientConfig.getInstanceInfoReplicationIntervalSeconds(), TimeUnit.SECONDS);
 
         }

File: eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java
Patch:
@@ -134,6 +134,7 @@ public AmazonInfo autoBuild(String namespace) {
                         if (value != null) {
                             result.metadata.put(key.getName(), value);
                         }
+                        break;
                     } catch (Throwable e) {
                         if (shouldLogAWSMetadataError.get()) {
                             logger.warn(

File: eureka-client/src/main/java/com/netflix/appinfo/ApplicationInfoManager.java
Patch:
@@ -73,6 +73,7 @@ public void initComponent(EurekaInstanceConfig config) {
 
             builder.setNamespace(config.getNamespace())
             .setAppName(config.getAppname())
+            .setAppGroupName(config.getAppGroupName())
             .setDataCenterInfo(config.getDataCenterInfo())
             .setIPAddr(config.getIpAddress())
             .setHostName(config.getHostName(false))

File: eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java
Patch:
@@ -134,6 +134,7 @@ public AmazonInfo autoBuild(String namespace) {
                         if (value != null) {
                             result.metadata.put(key.getName(), value);
                         }
+                        break;
                     } catch (Throwable e) {
                         if (shouldLogAWSMetadataError.get()) {
                             logger.warn(

File: eureka-client/src/main/java/com/netflix/appinfo/ApplicationInfoManager.java
Patch:
@@ -73,6 +73,7 @@ public void initComponent(EurekaInstanceConfig config) {
 
             builder.setNamespace(config.getNamespace())
             .setAppName(config.getAppname())
+            .setAppGroupName(config.getAppGroupName())
             .setDataCenterInfo(config.getDataCenterInfo())
             .setIPAddr(config.getIpAddress())
             .setHostName(config.getHostName(false))

File: eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientDisableRegistryTest.java
Patch:
@@ -26,6 +26,7 @@ public void setUp() throws Exception {
         final int eurekaPort = localRandomEurekaPort + (int)(Math.random() * 10);
         Properties props = new Properties();
         props.setProperty("eureka.registration.enabled", "false");
+        props.setProperty("eureka.shouldFetchRegistry", "false");
         props.setProperty("eureka.serviceUrl.default",
                 "http://localhost:" + eurekaPort +
                 MockRemoteEurekaServer.EUREKA_API_BASE_PATH);

File: eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java
Patch:
@@ -142,6 +142,8 @@ private String getDeltaAppsHashCode(boolean includeRemote) {
 
         private boolean isRemoteRequest(HttpServletRequest request) {
             String queryString = request.getQueryString();
+            if (queryString == null)
+                return false;
             return queryString.contains("regions=");
         }
 

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -444,7 +444,7 @@ public Applications getApplications(String serviceUrl) {
         } catch (Exception e) {
             logger.error(
                     PREFIX + appPathIdentifier
-                            + " - was unable to refresh it's cache! status = "
+                            + " - was unable to refresh its cache! status = "
                             + e.getMessage(), e);
 
         } finally {
@@ -650,7 +650,7 @@ private boolean fetchRegistry(boolean forceFullRegistryFetch) {
         } catch (Throwable e) {
             logger.error(
                     PREFIX + appPathIdentifier
-                            + " - was unable to refresh it's cache! status = "
+                            + " - was unable to refresh its cache! status = "
                             + e.getMessage(), e);
             return false;
 

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -444,7 +444,7 @@ public Applications getApplications(String serviceUrl) {
         } catch (Exception e) {
             logger.error(
                     PREFIX + appPathIdentifier
-                            + " - was unable to refresh it's cache! status = "
+                            + " - was unable to refresh its cache! status = "
                             + e.getMessage(), e);
 
         } finally {
@@ -650,7 +650,7 @@ private boolean fetchRegistry(boolean forceFullRegistryFetch) {
         } catch (Throwable e) {
             logger.error(
                     PREFIX + appPathIdentifier
-                            + " - was unable to refresh it's cache! status = "
+                            + " - was unable to refresh its cache! status = "
                             + e.getMessage(), e);
             return false;
 

File: eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java
Patch:
@@ -231,7 +231,8 @@ public Map<String, String> getMetadataMap() {
         Map<String, String> metadataMap = new LinkedHashMap<String, String>();
         Configuration config = (Configuration) INSTANCE
         .getBackingConfigurationSource();
-        for (Iterator<String> iter = config.subset(propMetadataNamespace)
+        String subsetPrefix = propMetadataNamespace.substring(0, propMetadataNamespace.length() - 1);
+        for (Iterator<String> iter = config.subset(subsetPrefix)
                 .getKeys();
 
         iter.hasNext();) {

File: eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java
Patch:
@@ -184,6 +184,9 @@ public void register(InstanceInfo r, int leaseDuration,
             }
             Lease<InstanceInfo> lease = new Lease<InstanceInfo>(r,
                     leaseDuration);
+            if (existingLease != null) {
+                lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());
+            }
             gMap.put(r.getId(), lease);
             synchronized (recentRegisteredQueue) {
                 recentRegisteredQueue.add(new Pair<Long, String>(Long

File: eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java
Patch:
@@ -184,6 +184,9 @@ public void register(InstanceInfo r, int leaseDuration,
             }
             Lease<InstanceInfo> lease = new Lease<InstanceInfo>(r,
                     leaseDuration);
+            if (existingLease != null) {
+                lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());
+            }
             gMap.put(r.getId(), lease);
             synchronized (recentRegisteredQueue) {
                 recentRegisteredQueue.add(new Pair<Long, String>(Long

File: eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java
Patch:
@@ -524,6 +524,6 @@ public boolean disableTransparentFallbackToOtherRegion() {
 
     @Override
     public boolean shouldBatchReplication() {
-        return configInstance.getBooleanProperty(namespace + "shouldBatchReplication", true).get();
+        return configInstance.getBooleanProperty(namespace + "shouldBatchReplication", false).get();
     }
 }

File: eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java
Patch:
@@ -524,6 +524,6 @@ public boolean disableTransparentFallbackToOtherRegion() {
 
     @Override
     public boolean shouldBatchReplication() {
-        return configInstance.getBooleanProperty(namespace + "shouldBatchReplication", true).get();
+        return configInstance.getBooleanProperty(namespace + "shouldBatchReplication", false).get();
     }
 }

File: eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * @author Nitesh Kant
  */
-public class DiscoveryClientTest {
+public class DiscoveryClientRegistryTest {
 
     public static final String ALL_REGIONS_VIP_ADDR = "myvip";
     public static final String REMOTE_REGION_INSTANCE_1_HOSTNAME = "blah";
@@ -43,7 +43,7 @@ public class DiscoveryClientTest {
     private final Map<String, Application> remoteRegionAppsDelta = new HashMap<String, Application>();
 
     private DiscoveryClient client;
-    private int localRandomEurekaPort = 7799;
+    private final int localRandomEurekaPort = 7799;
 
     @Before
     public void setUp() throws Exception {

File: eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * @author Nitesh Kant
  */
-public class DiscoveryClientTest {
+public class DiscoveryClientRegistryTest {
 
     public static final String ALL_REGIONS_VIP_ADDR = "myvip";
     public static final String REMOTE_REGION_INSTANCE_1_HOSTNAME = "blah";
@@ -43,7 +43,7 @@ public class DiscoveryClientTest {
     private final Map<String, Application> remoteRegionAppsDelta = new HashMap<String, Application>();
 
     private DiscoveryClient client;
-    private int localRandomEurekaPort = 7799;
+    private final int localRandomEurekaPort = 7799;
 
     @Before
     public void setUp() throws Exception {

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -174,7 +174,7 @@ private enum Action {
             }
             String proxyHost = clientConfig.getProxyHost();
             String proxyPort = clientConfig.getProxyPort();
-            discoveryJerseyClient = EurekaJerseyClient.createJerseyClient(
+            discoveryJerseyClient = EurekaJerseyClient.createJerseyClient("DiscoveryClient-HTTPClient",
                     clientConfig.getEurekaServerConnectTimeoutSeconds(),
                     clientConfig.getEurekaServerReadTimeoutSeconds(),
                     clientConfig.getEurekaServerTotalConnectionsPerHost(),

File: eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java
Patch:
@@ -1206,7 +1206,8 @@ protected void initRemoteRegionRegistry() throws MalformedURLException {
             allKnownRemoteRegions = new String[remoteRegionUrlsWithName.size()];
             int remoteRegionArrayIndex = 0;
             for (Entry<String, String> remoteRegionUrlWithName : remoteRegionUrlsWithName.entrySet()) {
-                RemoteRegionRegistry remoteRegionRegistry = new RemoteRegionRegistry(new URL(remoteRegionUrlWithName.getValue()));
+                RemoteRegionRegistry remoteRegionRegistry = new RemoteRegionRegistry(remoteRegionUrlWithName.getKey(),
+                                                                                     new URL(remoteRegionUrlWithName.getValue()));
                 regionNameVSRemoteRegistry.put(remoteRegionUrlWithName.getKey(), remoteRegionRegistry);
                 allKnownRemoteRegions[remoteRegionArrayIndex++] = remoteRegionUrlWithName.getKey();
             }

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -174,7 +174,7 @@ private enum Action {
             }
             String proxyHost = clientConfig.getProxyHost();
             String proxyPort = clientConfig.getProxyPort();
-            discoveryJerseyClient = EurekaJerseyClient.createJerseyClient(
+            discoveryJerseyClient = EurekaJerseyClient.createJerseyClient("DiscoveryClient-HTTPClient",
                     clientConfig.getEurekaServerConnectTimeoutSeconds(),
                     clientConfig.getEurekaServerReadTimeoutSeconds(),
                     clientConfig.getEurekaServerTotalConnectionsPerHost(),

File: eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java
Patch:
@@ -1206,7 +1206,8 @@ protected void initRemoteRegionRegistry() throws MalformedURLException {
             allKnownRemoteRegions = new String[remoteRegionUrlsWithName.size()];
             int remoteRegionArrayIndex = 0;
             for (Entry<String, String> remoteRegionUrlWithName : remoteRegionUrlsWithName.entrySet()) {
-                RemoteRegionRegistry remoteRegionRegistry = new RemoteRegionRegistry(new URL(remoteRegionUrlWithName.getValue()));
+                RemoteRegionRegistry remoteRegionRegistry = new RemoteRegionRegistry(remoteRegionUrlWithName.getKey(),
+                                                                                     new URL(remoteRegionUrlWithName.getValue()));
                 regionNameVSRemoteRegistry.put(remoteRegionUrlWithName.getKey(), remoteRegionRegistry);
                 allKnownRemoteRegions[remoteRegionArrayIndex++] = remoteRegionUrlWithName.getKey();
             }

File: eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java
Patch:
@@ -201,7 +201,7 @@ public Response statusUpdate(
     public Response updateMetadata(@Context UriInfo uriInfo) {
         try {
             InstanceInfo instanceInfo = registry.getInstanceByAppAndId(app.getName(), id);
-            // Instance information is not found, generate an error
+            // ReplicationInstance information is not found, generate an error
             if (instanceInfo == null) {
                 logger.error("Cannot find instance while updating metadata for instance {}", id);
                 return Response.serverError().build();
@@ -295,7 +295,7 @@ private Response validateDirtyTimestamp(Long lastDirtyTimestamp,
                 if (lastDirtyTimestamp > appInfo.getLastDirtyTimestamp()) {
                     logger.warn(
                             "Time to sync, since the last dirty timestamp differs -"
-                                    + " Instance id : {},Registry : {} Incoming: {} Replication: {}",
+                                    + " ReplicationInstance id : {},Registry : {} Incoming: {} Replication: {}",
                             args);
                     return Response.status(Status.NOT_FOUND).build();
                 } else if (appInfo.getLastDirtyTimestamp() > lastDirtyTimestamp) {
@@ -305,7 +305,7 @@ private Response validateDirtyTimestamp(Long lastDirtyTimestamp,
                     if (isReplication) {
                         logger.warn(
                                 "Time to sync, since the last dirty timestamp differs -"
-                                        + " Instance id : {},Registry : {} Incoming: {} Replication: {}",
+                                        + " ReplicationInstance id : {},Registry : {} Incoming: {} Replication: {}",
                                 args);
                         return Response.ok(appInfo).build();
                     } else {

File: eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java
Patch:
@@ -150,6 +150,7 @@ public void bindToEIP() {
                     // If it is the same, stop searching for an EIP as this instance is already associated with an EIP
                     else if (isMyinstanceAssociatedWithEIP = (associatedInstanceId
                             .equals(myInstanceId))) {
+                        selectedEIP = eipEntry;
                         break;
                     } 
                     // The EIP is used by some other instance, hence skip it

File: eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationsResource.java
Patch:
@@ -187,9 +187,8 @@ public Response getContainerDifferential(
         // If the delta flag is disabled in discovery or if the lease expiration
         // has been disabled, redirect clients to get all instances
         if ((eurekaConfig.shouldDisableDelta())
-                || (!PeerAwareInstanceRegistry.getInstance()
-                        .isLeaseExpirationEnabled() || (!PeerAwareInstanceRegistry
-                                .getInstance().shouldAllowAccess()))) {
+                ||  (!PeerAwareInstanceRegistry
+                                .getInstance().shouldAllowAccess())) {
             return Response.status(Status.FORBIDDEN).build();
         }
 

File: eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationsResource.java
Patch:
@@ -187,9 +187,8 @@ public Response getContainerDifferential(
         // If the delta flag is disabled in discovery or if the lease expiration
         // has been disabled, redirect clients to get all instances
         if ((eurekaConfig.shouldDisableDelta())
-                || (!PeerAwareInstanceRegistry.getInstance()
-                        .isLeaseExpirationEnabled() || (!PeerAwareInstanceRegistry
-                                .getInstance().shouldAllowAccess()))) {
+                ||  (!PeerAwareInstanceRegistry
+                                .getInstance().shouldAllowAccess())) {
             return Response.status(Status.FORBIDDEN).build();
         }
 

File: eureka-client/src/main/java/com/netflix/discovery/BackupRegistry.java
Patch:
@@ -32,5 +32,8 @@
  * 
  */
 public interface BackupRegistry {
+
     Applications fetchRegistry();
+
+    Applications fetchRegistry(String[] includeRemoteRegions);
 }

File: eureka-client/src/main/java/com/netflix/discovery/BackupRegistry.java
Patch:
@@ -32,5 +32,8 @@
  * 
  */
 public interface BackupRegistry {
+
     Applications fetchRegistry();
+
+    Applications fetchRegistry(String[] includeRemoteRegions);
 }

File: eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java
Patch:
@@ -189,8 +189,7 @@ private boolean fetchRegistry() {
                 }
                 logTotalInstances();
             }
-            logger.debug("Remote Registry Fetch Status : {}",
-                    response.getStatus());
+            logger.debug("Remote Registry Fetch Status : {}", null == response ? null : response.getStatus());
         } catch (Throwable e) {
             logger.error(
                     "Unable to fetch registry information from the remote registry "

File: eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java
Patch:
@@ -189,8 +189,7 @@ private boolean fetchRegistry() {
                 }
                 logTotalInstances();
             }
-            logger.debug("Remote Registry Fetch Status : {}",
-                    response.getStatus());
+            logger.debug("Remote Registry Fetch Status : {}", null == response ? null : response.getStatus());
         } catch (Throwable e) {
             logger.error(
                     "Unable to fetch registry information from the remote registry "

File: eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java
Patch:
@@ -819,7 +819,7 @@ public Applications getApplicationDeltasFromMultipleRegions(String[] remoteRegio
         }
 
         Applications apps = new Applications();
-        apps.setVersion(ResponseCache.getVersionDelta().get());
+        apps.setVersion(ResponseCache.getVersionDeltaWithRegions().get());
         Map<String, Application> applicationInstancesMap = new HashMap<String, Application>();
         try {
             write.lock();

File: eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java
Patch:
@@ -82,7 +82,7 @@ public Response getApplication(@PathParam("version") String version,
             keyType = KeyType.XML;
         }
 
-        Key cacheKey = new Key(appName, keyType, CurrentRequestVersion.get());
+        Key cacheKey = new Key(Key.EntityType.Application, appName, keyType, CurrentRequestVersion.get());
 
         String payLoad = ResponseCache.getInstance().get(cacheKey);
 

File: eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java
Patch:
@@ -395,7 +395,7 @@ public boolean shouldAllowAccess() {
                 return false;
             }
         }
-        for (RemoteRegionRegistry remoteRegionRegistry : this.remoteRegionRegistryList) {
+        for (RemoteRegionRegistry remoteRegionRegistry : this.regionNameVSRemoteRegistry.values()) {
             if (!remoteRegionRegistry.isReadyForServingData()) {
                 return false;
             }

File: eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java
Patch:
@@ -395,7 +395,7 @@ public boolean shouldAllowAccess() {
                 return false;
             }
         }
-        for (RemoteRegionRegistry remoteRegionRegistry : this.remoteRegionRegistryList) {
+        for (RemoteRegionRegistry remoteRegionRegistry : this.regionNameVSRemoteRegistry.values()) {
             if (!remoteRegionRegistry.isReadyForServingData()) {
                 return false;
             }

File: eureka-core/src/main/java/com/netflix/eureka/resources/ResponseCache.java
Patch:
@@ -375,7 +375,7 @@ private Applications getApplicationsForVip(Key key, InstanceRegistry registry) {
                 if (null != vipAddress) {
                     String[] vipAddresses = vipAddress.split(",");
                     Arrays.sort(vipAddresses);
-                    if (Arrays.binarySearch(vipAddresses, key.getName()) > 0) {
+                    if (Arrays.binarySearch(vipAddresses, key.getName()) >= 0) {
                         if (null == appToAdd) {
                             appToAdd = new Application(application.getName());
                             toReturn.addApplication(appToAdd);

File: eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java
Patch:
@@ -522,9 +522,10 @@ public void statusUpdate(final String asgName, final ASGStatus newStatus,
      */
     @Override
     public boolean isLeaseExpirationEnabled() {
-        boolean leaseExpirationEnabled = (getNumOfRenewsInLastMin() > numberOfRenewsPerMinThreshold);
+        boolean leaseExpirationEnabled = (numberOfRenewsPerMinThreshold > 0)
+                && (getNumOfRenewsInLastMin() > numberOfRenewsPerMinThreshold);
         boolean isSelfPreservationModeEnabled = isSelfPreservationModeEnabled();
-        if ((!leaseExpirationEnabled)) {
+      if ((!leaseExpirationEnabled)) {
             if (isSelfPreservationModeEnabled) {
                 logger.error("The lease expiration has been disabled since the number of renewals per minute  "
                         + " is lower than the minimum threshold. Number of Renewals Last Minute : "

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -1143,8 +1143,9 @@ private static int getZoneOffset(String myZone, boolean preferSameZone,
                 return i;
             }
         }
-        logger.error("DISCOVERY: invalid zone - " + myZone + " defaulting to "
-                + availZones[0]);
+        logger.warn(
+                "DISCOVERY: Could not pick a zone based on preferred zone settings. My zone - {}, preferSameZone- {}. Defaulting to "
+                        + availZones[0], myZone, preferSameZone);
         return 0;
     }
 

File: eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java
Patch:
@@ -92,9 +92,8 @@ public Object readFrom(Class serializableClass, Type type,
             return getSerializer(serializableClass).read(inputStream,
                     serializableClass, mediaType);
         } catch (Throwable th) {
-            new IOException("Cannot read the object for :" + serializableClass, th);
+           throw new RuntimeException("Cannot read the object for :" + serializableClass, th);
         }
-        return null;
     }
 
     /*

File: eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java
Patch:
@@ -588,12 +588,14 @@ public Applications getApplicationDeltas() {
                 }
                 app.addInstance(decorateInstanceInfo(lease));
             }
+            Applications allAppsInLocalRegion = getApplications(false);
+            
             for (RemoteRegionRegistry remoteRegistry : this.remoteRegionRegistryList) {
                 Applications applications = remoteRegistry
                         .getApplicationDeltas();
                 for (Application application : applications
                         .getRegisteredApplications()) {
-                    Application appInLocalRegistry = apps
+                    Application appInLocalRegistry = allAppsInLocalRegion
                             .getRegisteredApplications(application.getName());
                     if (appInLocalRegistry == null) {
                         apps.addApplication(application);

File: eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java
Patch:
@@ -86,7 +86,7 @@ public abstract class InstanceRegistry implements LeaseManager<InstanceInfo>,
     private volatile MeasuredRate renewsLastMin;
     protected ConcurrentMap<String, InstanceStatus> overriddenInstanceStatusMap = CacheBuilder
             .newBuilder().initialCapacity(500)
-            .expireAfterAccess(5, TimeUnit.MINUTES)
+            .expireAfterAccess(1, TimeUnit.HOURS)
             .<String, InstanceStatus> build().asMap();
 
     // CircularQueues here for debugging/statistics purposes only
@@ -287,7 +287,7 @@ public boolean renew(String appName, String id, boolean isReplication) {
                             instanceInfo.getOverriddenStatus().name(),
                             instanceInfo.getId() };
                     logger.info(
-                            "The instance status {} is different from overridden instance status {] for instance {}. Hence setting the status to overridden status",
+                            "The instance status {} is different from overridden instance status {} for instance {}. Hence setting the status to overridden status",
                             args);
                     instanceInfo.setStatus(overriddenInstanceStatus);
                 }

File: eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java
Patch:
@@ -749,7 +749,7 @@ private void replicateToPeers(Action action, String appName, String id,
                 // If the url represents this host, do not replicate
                 // to yourself.
                 if (isThisMe(node.getServiceUrl())) {
-                    return;
+                    continue;
                 }
                 replicateInstanceActionsToPeers(action, appName, id, info,
                         newStatus, node);

File: eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java
Patch:
@@ -305,7 +305,7 @@ private Set<String> getASGNames() {
                 if (AmazonInfo.class.isInstance(instanceInfo
                         .getDataCenterInfo())) {
                     if (AmazonInfo.class
-                            .cast(instanceInfo)
+                            .cast(instanceInfo.getDataCenterInfo())
                             .get(MetaDataKey.availabilityZone)
                             .contains(
                                     ConfigurationManager.getDeploymentContext()

File: eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java
Patch:
@@ -189,7 +189,7 @@ public void contextDestroyed(ServletContextEvent event) {
                 }
             }
             PeerAwareInstanceRegistry.getInstance().shutdown();
-            destoryEurekaEnvironment();
+            destroyEurekaEnvironment();
 
         } catch (Throwable e) {
             logger.error("Error shutting down eureka", e);
@@ -201,7 +201,7 @@ public void contextDestroyed(ServletContextEvent event) {
     /**
      * Users can override to clean up the environment themselves.
      */
-    protected void destoryEurekaEnvironment() {
+    protected void destroyEurekaEnvironment() {
         
     }
 

File: eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java
Patch:
@@ -226,7 +226,7 @@ public int getEurekaServerTotalConnectionsPerHost() {
      */
     @Override
     public String getEurekaServerURLContext() {
-        return configInstance.getStringProperty(namespace + "eurekaServer.context", null)
+        return configInstance.getStringProperty(namespace + "context", null)
                 .get();
     }
 
@@ -237,7 +237,7 @@ public String getEurekaServerURLContext() {
      */
     @Override
     public String getEurekaServerPort() {
-        return configInstance.getStringProperty(namespace + "eurekaServer.port", null).get();
+        return configInstance.getStringProperty(namespace + "port", null).get();
     }
 
     /*
@@ -247,7 +247,7 @@ public String getEurekaServerPort() {
      */
     @Override
     public String getEurekaServerDNSName() {
-        return configInstance.getStringProperty(namespace + "eurekaServer.domainName", null)
+        return configInstance.getStringProperty(namespace + "domainName", null)
                 .get();
     }
 

File: eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java
Patch:
@@ -32,6 +32,7 @@
 import com.netflix.appinfo.EurekaInstanceConfig;
 import com.netflix.appinfo.InstanceInfo;
 import com.netflix.appinfo.MyDataCenterInstanceConfig;
+import com.netflix.blitz4j.LoggingConfiguration;
 import com.netflix.config.ConfigurationManager;
 import com.netflix.discovery.DefaultEurekaClientConfig;
 import com.netflix.discovery.DiscoveryManager;
@@ -126,6 +127,7 @@ public void contextInitialized(ServletContextEvent event) {
      */
     protected void initEurekaEnvironment() {
         logger.info("Setting the eureka configuration..");
+        LoggingConfiguration.getInstance().configure();
         EurekaServerConfig eurekaServerConfig = new DefaultEurekaServerConfig();
         EurekaServerConfigurationManager.getInstance().setConfiguration(
                 eurekaServerConfig);

File: eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java
Patch:
@@ -570,7 +570,8 @@ public void process(List<ReplicationTask> tasks) {
                 for (ReplicationTask task : tasks) {
                     boolean done = true;
                     do {
-                        try {
+                       done = true;
+                       try {
                             Object[] args = {
                                     task.getAppName(),
                                     task.getId(),
@@ -583,6 +584,7 @@ public void process(List<ReplicationTask> tasks) {
                                 logger.warn(
                                         "Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}",
                                         args);
+                                
                                 continue;
                             }
                             task.execute();

File: eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java
Patch:
@@ -316,7 +316,7 @@ public int syncUp() {
             for (Application app : apps.getRegisteredApplications()) {
                 for (InstanceInfo instance : app.getInstances()) {
                     try {
-                        register(instance, -1, true);
+                        register(instance, instance.getLeaseInfo().getDurationInSecs(), true);
                         count++;
                     } catch (Throwable t) {
                         logger.error("During DS init copy", t);

File: eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java
Patch:
@@ -104,7 +104,7 @@ public Response renewLease(
 
         // Not found in the registry, immediately ask for a register
         if (!isSuccess) {
-            logger.debug("Not Found (Renew): {} - {}", app.getName(), id);
+            logger.warn("Not Found (Renew): {} - {}", app.getName(), id);
             return Response.status(Status.NOT_FOUND).build();
         }
         // Check if we need to sync based on dirty time stamp, the client
@@ -123,7 +123,7 @@ public Response renewLease(
                     && (overriddenStatus != null)
                     && !(InstanceStatus.UNKNOWN.equals(overriddenStatus))
                     && isFromReplicaNode) {
-                registry.storeOverriddenStatusIfRequired(overriddenStatus,
+                registry.storeOverriddenStatusIfRequired(id,
                         InstanceStatus.valueOf(overriddenStatus));
             }
             return response;

File: eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java
Patch:
@@ -231,7 +231,7 @@ public String getCandidateEIP(String myInstanceId, String myZone,
         if (availableEIPList == null || availableEIPList.isEmpty()) {
             throw new RuntimeException("Cannot find a free EIP to bind");
         }
-        return eipCandidates.iterator().next();
+        return availableEIPList.iterator().next();
     }
 
     /**

File: eureka-client/src/main/java/com/netflix/discovery/shared/LookupService.java
Patch:
@@ -26,9 +26,10 @@
  * Lookup service for finding active instances.
  * 
  * @author Karthik Ranganathan, Greg Kim.
+ * @param <T> for backward compatibility
 
  */
-public interface LookupService {
+public interface LookupService<T> {
 
     /**
      * Returns the corresponding {@link Application} object which is basically a

File: eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java
Patch:
@@ -101,7 +101,9 @@ public Builder addMetadata(MetaDataKey key, String value) {
         }
 
         /**
-         * Build the {@link InstanceInfo}
+         * Build the {@link InstanceInfo} information.
+         * 
+         * @return AWS specific instance information.
          */
         public AmazonInfo build() {
             return result;

File: eureka-client/src/main/java/com/netflix/appinfo/HealthCheckCallback.java
Patch:
@@ -46,7 +46,9 @@ public interface HealthCheckCallback {
      * {@link InstanceInfo.InstanceStatus#DOWN} with eureka. If the instance was
      * already marked {@link InstanceInfo.InstanceStatus#DOWN} , returning true
      * here will mark the instance back to
-     * {@link InstanceInfo.InstanceStatus#UP}
+     * {@link InstanceInfo.InstanceStatus#UP}.
+     * 
+     * @return true if the call back returns healthy, false otherwise.
      */
     boolean isHealthy();
 }

File: eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java
Patch:
@@ -19,9 +19,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.LinkedHashMap;
 import java.util.List;
-import java.util.Map;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java
Patch:
@@ -207,10 +207,9 @@ private enum Action {
         }
     }
 
-    /**
+    /*
      * (non-Javadoc)
-     * 
-     * @see com.netflix.discovery.shared.LookupService#getApplication(T)
+     * @see com.netflix.discovery.shared.LookupService#getApplication(java.lang.String)
      */
     public Application getApplication(String appName) {
         return getApplications().getRegisteredApplications(appName);

File: eureka-client/src/main/java/com/netflix/discovery/DiscoveryManager.java
Patch:
@@ -59,6 +59,7 @@ public static DiscoveryManager getInstance() {
      * @param config
      *            the instance info configuration that will be used for
      *            registration with Eureka.
+     * @param eurekaConfig the eureka client configuration of the instance.
      */
     public void initComponent(EurekaInstanceConfig config,
             EurekaClientConfig eurekaConfig) {
@@ -91,6 +92,7 @@ public LookupService getLookupService() {
 
     /**
      * Get the {@link DiscoveryClient}
+     * @return the client that is used to talk to eureka.
      */
     public DiscoveryClient getDiscoveryClient() {
         return discoveryClient;

File: eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java
Patch:
@@ -26,7 +26,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.netflix.discovery.DiscoveryClient;
 import com.netflix.discovery.provider.DiscoveryJerseyProvider;
 import com.sun.jersey.api.client.config.ClientConfig;
 import com.sun.jersey.client.apache4.ApacheHttpClient4;

File: eureka-client/src/main/java/com/netflix/discovery/shared/LookupService.java
Patch:
@@ -26,8 +26,9 @@
  * Lookup service for finding active instances.
  * 
  * @author Karthik Ranganathan, Greg Kim.
+
  */
-public interface LookupService<T> {
+public interface LookupService {
 
     /**
      * Returns the corresponding {@link Application} object which is basically a
@@ -43,7 +44,6 @@ public interface LookupService<T> {
      * Returns the {@link Applications} object which is basically a container of
      * all currently registered {@link Application}s.
      * 
-     * @param appName
      * @return {@link Applications}
      */
     Applications getApplications();

