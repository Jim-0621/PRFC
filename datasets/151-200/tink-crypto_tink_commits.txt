File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtMacKey.java
Patch:
@@ -36,7 +36,7 @@ public abstract class JwtMacKey extends Key {
    * needs to match the return value of this function.
    *
    * <p>Note that {@code getParameters.allowKidAbsent()} specifies if omitting the {@code kid}
-   * header is allowed. Of course, if {@code getParameters.allowKidAbsent()} is true, then {@code
+   * header is allowed. Of course, if {@code getParameters.allowKidAbsent()} is false, then {@code
    * getKid} must not return an empty {@link Optional}.
    */
   public abstract Optional<String> getKid();

File: java_src/src/main/java/com/google/crypto/tink/KeysetHandle.java
Patch:
@@ -1085,7 +1085,7 @@ private <B, P> P getPrimitiveWithKnownInputPrimitive(
                   + inputPrimitiveClassObject
                   + " for key of type "
                   + protoKey.getKeyData().getTypeUrl()
-                  + ", see https://developers.google.com/tink/registration_errors");
+                  + ", see https://developers.google.com/tink/faq/registration_errors");
         }
         if (protoKey.getKeyId() == keyset.getPrimaryKeyId()) {
           builder.addPrimaryFullPrimitive(fullPrimitive, key, protoKey);

File: java_src/src/test/java/com/google/crypto/tink/KeysetHandleTest.java
Patch:
@@ -1980,7 +1980,7 @@ public void getPrimitive_wrongType_linksToDevsite() throws Exception {
         assertThrows(GeneralSecurityException.class, () -> handle.getPrimitive(Mac.class));
     assertThat(ex)
         .hasMessageThat()
-        .contains("https://developers.google.com/tink/registration_errors");
+        .contains("https://developers.google.com/tink/faq/registration_errors");
   }
 
   // This keyset contains a JwtEcdsaPrivateKey with an OutputPrefixType LEGACY. This

File: java_src/src/main/java/com/google/crypto/tink/internal/MonitoringUtil.java
Patch:
@@ -67,7 +67,7 @@ public static <P> MonitoringKeysetInfo getMonitoringKeysetInfo(PrimitiveSet<P> p
         builder.addEntry(
             parseStatus(entry.getStatus()),
             entry.getKeyId(),
-            parseKeyTypeUrl(entry.getKeyType()),
+            parseKeyTypeUrl(entry.getKeyTypeUrl()),
             entry.getOutputPrefixType().name());
       }
     }

File: java_src/src/main/java/com/google/crypto/tink/mac/internal/LegacyHmacTestKeyManager.java
Patch:
@@ -41,7 +41,7 @@
  */
 class LegacyHmacTestKeyManager implements KeyManager<Mac> {
   /** Type url that this manager does support. */
-  public static final String TYPE_URL = "type.googleapis.com/google.crypto.tink.HmacKey";
+  public static final String TYPE_URL = "type.googleapis.com/custom.HmacKey";
   /** Current version of this key manager. Keys with version equal or smaller are supported. */
   private static final int VERSION = 0;
 

File: java_src/src/test/java/com/google/crypto/tink/RegistryTest.java
Patch:
@@ -1399,8 +1399,8 @@ private static PrimitiveSet<Aead> createAeadPrimitiveSet() throws Exception {
         TestUtil.createKey(
             TestUtil.createAesGcmKeyData(KEY2), 43, KeyStatusType.ENABLED, OutputPrefixType.RAW);
     return PrimitiveSet.newBuilder(Aead.class)
-        .addPrimaryFullPrimitiveAndOptionalPrimitive(fullPrimitive1, null, protoKey1)
-        .addFullPrimitiveAndOptionalPrimitive(fullPrimitive2, null, protoKey2)
+        .addPrimaryFullPrimitive(fullPrimitive1, protoKey1)
+        .addFullPrimitive(fullPrimitive2, protoKey2)
         .build();
   }
 

File: java_src/src/test/java/com/google/crypto/tink/internal/RegistryConfigurationTest.java
Patch:
@@ -159,8 +159,7 @@ public void wrap_matchesRegistry() throws Exception {
         RegistryConfiguration.get()
             .wrap(
                 PrimitiveSet.newBuilder(Mac.class)
-                    .addPrimaryFullPrimitiveAndOptionalPrimitive(
-                        LegacyFullMac.create(legacyProtoRawKey), null, rawKeysetKey)
+                    .addPrimaryFullPrimitive(LegacyFullMac.create(legacyProtoRawKey), rawKeysetKey)
                     .build(),
                 Mac.class);
 

File: java_src/src/main/java/com/google/crypto/tink/KeysetHandle.java
Patch:
@@ -21,6 +21,7 @@
 import com.google.crypto.tink.internal.LegacyProtoParameters;
 import com.google.crypto.tink.internal.MutableParametersRegistry;
 import com.google.crypto.tink.internal.MutableSerializationRegistry;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.internal.ProtoKeySerialization;
 import com.google.crypto.tink.internal.ProtoParametersSerialization;
 import com.google.crypto.tink.internal.RegistryConfiguration;

File: java_src/src/main/java/com/google/crypto/tink/PrimitiveWrapper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2017 Google Inc.
+// Copyright 2017 Google LLC
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -16,6 +16,7 @@
 
 package com.google.crypto.tink;
 
+import com.google.crypto.tink.internal.PrimitiveSet;
 import java.security.GeneralSecurityException;
 
 /**

File: java_src/src/main/java/com/google/crypto/tink/Registry.java
Patch:
@@ -21,6 +21,7 @@
 import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.internal.MutableParametersRegistry;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.internal.PrivateKeyTypeManager;
 import com.google.crypto.tink.prf.Prf;
 import com.google.crypto.tink.proto.KeyData;

File: java_src/src/main/java/com/google/crypto/tink/aead/AeadWrapper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2017 Google Inc.
+// Copyright 2017 Google LLC
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -18,14 +18,14 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.CryptoFormat;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.aead.internal.LegacyFullAead;
 import com.google.crypto.tink.internal.LegacyProtoKey;
 import com.google.crypto.tink.internal.MonitoringUtil;
 import com.google.crypto.tink.internal.MutableMonitoringRegistry;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
 import com.google.crypto.tink.internal.PrimitiveConstructor;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.monitoring.MonitoringClient;
 import com.google.crypto.tink.monitoring.MonitoringKeysetInfo;
 import java.security.GeneralSecurityException;

File: java_src/src/main/java/com/google/crypto/tink/daead/DeterministicAeadWrapper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2017 Google Inc.
+// Copyright 2017 Google LLC
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -18,14 +18,14 @@
 
 import com.google.crypto.tink.CryptoFormat;
 import com.google.crypto.tink.DeterministicAead;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.daead.internal.LegacyFullDeterministicAead;
 import com.google.crypto.tink.internal.LegacyProtoKey;
 import com.google.crypto.tink.internal.MonitoringUtil;
 import com.google.crypto.tink.internal.MutableMonitoringRegistry;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
 import com.google.crypto.tink.internal.PrimitiveConstructor;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.monitoring.MonitoringClient;
 import com.google.crypto.tink.monitoring.MonitoringKeysetInfo;
 import java.security.GeneralSecurityException;

File: java_src/src/main/java/com/google/crypto/tink/hybrid/HybridDecryptWrapper.java
Patch:
@@ -17,14 +17,14 @@
 
 import com.google.crypto.tink.CryptoFormat;
 import com.google.crypto.tink.HybridDecrypt;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.hybrid.internal.LegacyFullHybridDecrypt;
 import com.google.crypto.tink.internal.LegacyProtoKey;
 import com.google.crypto.tink.internal.MonitoringUtil;
 import com.google.crypto.tink.internal.MutableMonitoringRegistry;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
 import com.google.crypto.tink.internal.PrimitiveConstructor;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.monitoring.MonitoringClient;
 import com.google.crypto.tink.monitoring.MonitoringKeysetInfo;
 import java.security.GeneralSecurityException;

File: java_src/src/main/java/com/google/crypto/tink/hybrid/HybridEncryptWrapper.java
Patch:
@@ -16,14 +16,14 @@
 package com.google.crypto.tink.hybrid;
 
 import com.google.crypto.tink.HybridEncrypt;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.hybrid.internal.LegacyFullHybridEncrypt;
 import com.google.crypto.tink.internal.LegacyProtoKey;
 import com.google.crypto.tink.internal.MonitoringUtil;
 import com.google.crypto.tink.internal.MutableMonitoringRegistry;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
 import com.google.crypto.tink.internal.PrimitiveConstructor;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.monitoring.MonitoringClient;
 import com.google.crypto.tink.monitoring.MonitoringKeysetInfo;
 import java.security.GeneralSecurityException;

File: java_src/src/main/java/com/google/crypto/tink/internal/InternalConfiguration.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.google.crypto.tink.Configuration;
 import com.google.crypto.tink.Key;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.proto.KeyData;
 import java.security.GeneralSecurityException;
 

File: java_src/src/main/java/com/google/crypto/tink/internal/MonitoringUtil.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.crypto.tink.internal;
 
 import com.google.crypto.tink.KeyStatus;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.monitoring.MonitoringClient;
 import com.google.crypto.tink.monitoring.MonitoringKeysetInfo;
 import com.google.crypto.tink.proto.KeyStatusType;

File: java_src/src/main/java/com/google/crypto/tink/internal/MutablePrimitiveRegistry.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.crypto.tink.internal;
 
 import com.google.crypto.tink.Key;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import java.security.GeneralSecurityException;
 import java.util.concurrent.atomic.AtomicReference;

File: java_src/src/main/java/com/google/crypto/tink/internal/PrimitiveRegistry.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.crypto.tink.internal;
 
 import com.google.crypto.tink.Key;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.security.GeneralSecurityException;

File: java_src/src/main/java/com/google/crypto/tink/internal/RegistryConfiguration.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.crypto.tink.internal;
 
 import com.google.crypto.tink.Key;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.proto.KeyData;
 import com.google.errorprone.annotations.DoNotCall;

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtMacWrapper.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.crypto.tink.jwt;
 
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.errorprone.annotations.Immutable;
 import java.security.GeneralSecurityException;
 import java.util.List;

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtPublicKeySignWrapper.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.crypto.tink.jwt;
 
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import java.security.GeneralSecurityException;
 
 /**

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtPublicKeyVerifyWrapper.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.crypto.tink.jwt;
 
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.errorprone.annotations.Immutable;
 import java.security.GeneralSecurityException;
 import java.util.List;

File: java_src/src/main/java/com/google/crypto/tink/keyderivation/internal/KeysetDeriverWrapper.java
Patch:
@@ -18,9 +18,9 @@
 
 import com.google.crypto.tink.Key;
 import com.google.crypto.tink.KeysetHandle;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.keyderivation.KeysetDeriver;
 import com.google.errorprone.annotations.Immutable;
 import java.security.GeneralSecurityException;

File: java_src/src/main/java/com/google/crypto/tink/mac/ChunkedMacWrapper.java
Patch:
@@ -17,10 +17,10 @@
 package com.google.crypto.tink.mac;
 
 import com.google.crypto.tink.CryptoFormat;
-import com.google.crypto.tink.PrimitiveSet;
-import com.google.crypto.tink.PrimitiveSet.Entry;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
+import com.google.crypto.tink.internal.PrimitiveSet;
+import com.google.crypto.tink.internal.PrimitiveSet.Entry;
 import com.google.errorprone.annotations.Immutable;
 import java.nio.ByteBuffer;
 import java.security.GeneralSecurityException;

File: java_src/src/main/java/com/google/crypto/tink/mac/MacWrapper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2017 Google Inc.
+// Copyright 2017 Google LLC
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -18,13 +18,13 @@
 
 import com.google.crypto.tink.CryptoFormat;
 import com.google.crypto.tink.Mac;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.internal.LegacyProtoKey;
 import com.google.crypto.tink.internal.MonitoringUtil;
 import com.google.crypto.tink.internal.MutableMonitoringRegistry;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
 import com.google.crypto.tink.internal.PrimitiveConstructor;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.mac.internal.LegacyFullMac;
 import com.google.crypto.tink.monitoring.MonitoringClient;
 import com.google.crypto.tink.monitoring.MonitoringKeysetInfo;

File: java_src/src/main/java/com/google/crypto/tink/prf/PrfSetWrapper.java
Patch:
@@ -15,13 +15,13 @@
 ////////////////////////////////////////////////////////////////////////////////
 package com.google.crypto.tink.prf;
 
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.internal.LegacyProtoKey;
 import com.google.crypto.tink.internal.MonitoringUtil;
 import com.google.crypto.tink.internal.MutableMonitoringRegistry;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
 import com.google.crypto.tink.internal.PrimitiveConstructor;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.monitoring.MonitoringClient;
 import com.google.crypto.tink.monitoring.MonitoringKeysetInfo;
 import com.google.crypto.tink.prf.internal.LegacyFullPrf;

File: java_src/src/main/java/com/google/crypto/tink/signature/PublicKeySignWrapper.java
Patch:
@@ -16,14 +16,14 @@
 
 package com.google.crypto.tink.signature;
 
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.internal.LegacyProtoKey;
 import com.google.crypto.tink.internal.MonitoringUtil;
 import com.google.crypto.tink.internal.MutableMonitoringRegistry;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
 import com.google.crypto.tink.internal.PrimitiveConstructor;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.monitoring.MonitoringClient;
 import com.google.crypto.tink.monitoring.MonitoringKeysetInfo;
 import com.google.crypto.tink.signature.internal.LegacyFullSign;

File: java_src/src/main/java/com/google/crypto/tink/signature/PublicKeyVerifyWrapper.java
Patch:
@@ -17,14 +17,14 @@
 package com.google.crypto.tink.signature;
 
 import com.google.crypto.tink.CryptoFormat;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.internal.LegacyProtoKey;
 import com.google.crypto.tink.internal.MonitoringUtil;
 import com.google.crypto.tink.internal.MutableMonitoringRegistry;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
 import com.google.crypto.tink.internal.PrimitiveConstructor;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.monitoring.MonitoringClient;
 import com.google.crypto.tink.monitoring.MonitoringKeysetInfo;
 import com.google.crypto.tink.signature.internal.LegacyFullVerify;

File: java_src/src/main/java/com/google/crypto/tink/streamingaead/StreamingAeadWrapper.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2017 Google Inc.
+// Copyright 2017 Google LLC
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -16,12 +16,12 @@
 
 package com.google.crypto.tink.streamingaead;
 
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.StreamingAead;
 import com.google.crypto.tink.internal.LegacyProtoKey;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
 import com.google.crypto.tink.internal.PrimitiveConstructor;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.streamingaead.internal.LegacyFullStreamingAead;
 import java.security.GeneralSecurityException;
 import java.util.ArrayList;

File: java_src/src/main/java/com/google/crypto/tink/testing/TestUtil.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2017 Google Inc.
+// Copyright 2017 Google LLC
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -24,12 +24,12 @@
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.InsecureSecretKeyAccess;
 import com.google.crypto.tink.KeysetHandle;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.TinkProtoKeysetFormat;
 import com.google.crypto.tink.aead.AeadConfig;
 import com.google.crypto.tink.daead.DeterministicAeadConfig;
 import com.google.crypto.tink.internal.KeyTemplateProtoConverter;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.mac.MacConfig;
 import com.google.crypto.tink.monitoring.MonitoringAnnotations;
 import com.google.crypto.tink.prf.PrfConfig;

File: java_src/src/test/java/com/google/crypto/tink/KeysetHandleFullPrimitiveTest.java
Patch:
@@ -20,12 +20,13 @@
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertThrows;
 
-import com.google.crypto.tink.PrimitiveSet.Entry;
 import com.google.crypto.tink.internal.KeyParser;
 import com.google.crypto.tink.internal.KeySerializer;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
 import com.google.crypto.tink.internal.MutableSerializationRegistry;
 import com.google.crypto.tink.internal.PrimitiveConstructor;
+import com.google.crypto.tink.internal.PrimitiveSet;
+import com.google.crypto.tink.internal.PrimitiveSet.Entry;
 import com.google.crypto.tink.internal.ProtoKeySerialization;
 import com.google.crypto.tink.mac.AesCmacKey;
 import com.google.crypto.tink.mac.AesCmacParameters;

File: java_src/src/test/java/com/google/crypto/tink/KeysetHandleTest.java
Patch:
@@ -39,6 +39,7 @@
 import com.google.crypto.tink.internal.MutableSerializationRegistry;
 import com.google.crypto.tink.internal.PrimitiveConstructor;
 import com.google.crypto.tink.internal.PrimitiveRegistry;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.internal.ProtoKeySerialization;
 import com.google.crypto.tink.internal.testing.FakeMonitoringClient;
 import com.google.crypto.tink.mac.AesCmacKey;

File: java_src/src/test/java/com/google/crypto/tink/MonitoringUtilTest.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.crypto.tink.internal.MonitoringUtil;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.monitoring.MonitoringAnnotations;
 import com.google.crypto.tink.monitoring.MonitoringKeysetInfo;
 import com.google.crypto.tink.proto.KeyStatusType;

File: java_src/src/test/java/com/google/crypto/tink/RegistryTest.java
Patch:
@@ -33,6 +33,7 @@
 import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
 import com.google.crypto.tink.internal.PrimitiveFactory;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.internal.PrivateKeyTypeManager;
 import com.google.crypto.tink.jwt.JwtMac;
 import com.google.crypto.tink.mac.MacConfig;

File: java_src/src/test/java/com/google/crypto/tink/internal/InternalConfigurationTest.java
Patch:
@@ -22,7 +22,6 @@
 import com.google.crypto.tink.InsecureSecretKeyAccess;
 import com.google.crypto.tink.Key;
 import com.google.crypto.tink.Parameters;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.proto.KeyData;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/test/java/com/google/crypto/tink/internal/MutablePrimitiveRegistryTest.java
Patch:
@@ -21,7 +21,6 @@
 
 import com.google.crypto.tink.Key;
 import com.google.crypto.tink.Parameters;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.errorprone.annotations.Immutable;
 import java.security.GeneralSecurityException;

File: java_src/src/test/java/com/google/crypto/tink/internal/PrimitiveRegistryTest.java
Patch:
@@ -21,7 +21,6 @@
 
 import com.google.crypto.tink.Key;
 import com.google.crypto.tink.Parameters;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.errorprone.annotations.Immutable;
 import java.security.GeneralSecurityException;

File: java_src/src/test/java/com/google/crypto/tink/internal/RegistryConfigurationTest.java
Patch:
@@ -24,7 +24,6 @@
 import com.google.crypto.tink.InsecureSecretKeyAccess;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.Mac;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.aead.AesEaxKey;
 import com.google.crypto.tink.aead.AesEaxParameters;

File: java_src/src/test/java/com/google/crypto/tink/mac/internal/LegacyFullMacIntegrationTest.java
Patch:
@@ -22,13 +22,13 @@
 import com.google.crypto.tink.InsecureSecretKeyAccess;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.Mac;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.TinkProtoKeysetFormat;
 import com.google.crypto.tink.internal.EnumTypeProtoConverter;
 import com.google.crypto.tink.internal.LegacyProtoKey;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
 import com.google.crypto.tink.internal.PrimitiveConstructor;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.mac.HmacKey;
 import com.google.crypto.tink.mac.HmacParameters;
 import com.google.crypto.tink.mac.internal.HmacTestUtil.HmacTestVector;

File: java_src/src/test/java/com/google/crypto/tink/mac/internal/LegacyFullMacTest.java
Patch:
@@ -21,12 +21,12 @@
 
 import com.google.crypto.tink.InsecureSecretKeyAccess;
 import com.google.crypto.tink.Mac;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.internal.LegacyProtoKey;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
 import com.google.crypto.tink.internal.MutableSerializationRegistry;
 import com.google.crypto.tink.internal.PrimitiveConstructor;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.internal.ProtoKeySerialization;
 import com.google.crypto.tink.mac.HmacKey;
 import com.google.crypto.tink.mac.internal.HmacTestUtil.HmacTestVector;

File: java_src/src/test/java/com/google/crypto/tink/prf/internal/LegacyFullPrfIntegrationTest.java
Patch:
@@ -21,13 +21,13 @@
 
 import com.google.crypto.tink.InsecureSecretKeyAccess;
 import com.google.crypto.tink.KeysetHandle;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.TinkProtoKeysetFormat;
 import com.google.crypto.tink.internal.EnumTypeProtoConverter;
 import com.google.crypto.tink.internal.LegacyProtoKey;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
 import com.google.crypto.tink.internal.PrimitiveConstructor;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.prf.HmacPrfKey;
 import com.google.crypto.tink.prf.HmacPrfParameters;
 import com.google.crypto.tink.prf.Prf;

File: java_src/src/test/java/com/google/crypto/tink/streamingaead/internal/LegacyFullStreamingAeadIntegrationTest.java
Patch:
@@ -22,13 +22,13 @@
 
 import com.google.crypto.tink.InsecureSecretKeyAccess;
 import com.google.crypto.tink.KeysetHandle;
-import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.StreamingAead;
 import com.google.crypto.tink.TinkProtoKeysetFormat;
 import com.google.crypto.tink.internal.LegacyProtoKey;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
 import com.google.crypto.tink.internal.PrimitiveConstructor;
+import com.google.crypto.tink.internal.PrimitiveSet;
 import com.google.crypto.tink.proto.AesGcmHkdfStreamingKey;
 import com.google.crypto.tink.proto.AesGcmHkdfStreamingParams;
 import com.google.crypto.tink.proto.HashType;

File: java_src/src/main/java/com/google/crypto/tink/KeysetHandle.java
Patch:
@@ -1109,7 +1109,8 @@ private <B, P> P getPrimitiveWithKnownInputPrimitive(
               "Unable to get primitive "
                   + inputPrimitiveClassObject
                   + " for key of type "
-                  + protoKey.getKeyData().getTypeUrl());
+                  + protoKey.getKeyData().getTypeUrl()
+                  + ", see https://developers.google.com/tink/registration_errors");
         }
         if (protoKey.getKeyId() == keyset.getPrimaryKeyId()) {
           builder.addPrimaryFullPrimitiveAndOptionalPrimitive(fullPrimitive, primitive, protoKey);

File: java_src/src/main/java/com/google/crypto/tink/integration/hcvault/HcVaultAead.java
Patch:
@@ -76,14 +76,14 @@ public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData)
     }
   }
 
-  public static String getOperationEndpoint(String keyPath, String operation)
+  static String getOperationEndpoint(String keyPath, String operation)
       throws GeneralSecurityException {
     String[] parts = keyPath.split("/");
     if (parts.length < 3 || !parts[parts.length - 2].equals("keys")) {
       throw new GeneralSecurityException(String.format("malformed URL"));
     }
     parts[parts.length - 2] = operation;
-    return Arrays.asList(parts).stream().collect(Collectors.joining("/")).replaceFirst("/", "");
+    return Arrays.asList(parts).stream().collect(Collectors.joining("/"));
   }
 
   /* This shouldn't be necessary, but in older versions of the client library failing requests

File: java_src/src/main/java/com/google/crypto/tink/integration/hcvault/HcVaultAead.java
Patch:
@@ -35,7 +35,7 @@
  *
  * @since 1.0.0
  */
-public final class HcVaultAead implements Aead {
+final class HcVaultAead implements Aead {
 
   /** This client knows how to talk to Hashicorp Vault. */
   private final Logical kmsClient;
@@ -53,7 +53,6 @@ public byte[] encrypt(final byte[] plaintext, final byte[] associatedData)
       throws GeneralSecurityException {
     try {
       String encPath = getOperationEndpoint(this.keyUri, "encrypt");
-      System.out.println("Running encryption against: " + encPath);
       Map<String, Object> content = new HashMap<>();
       content.put("plaintext", Base64.getEncoder().encodeToString(plaintext));
       content.put("context", Base64.getEncoder().encodeToString(associatedData));
@@ -70,7 +69,6 @@ public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData)
       throws GeneralSecurityException {
     try {
       String encPath = getOperationEndpoint(this.keyUri, "decrypt");
-      System.out.println("Running decryption against: " + encPath);
       Map<String, Object> content = new HashMap<>();
       content.put("ciphertext", new String(ciphertext));
       content.put("context", Base64.getEncoder().encodeToString(associatedData));

File: java_src/src/main/java/com/google/crypto/tink/signature/RsaSsaPkcs1SignKeyManager.java
Patch:
@@ -100,6 +100,7 @@ private static RsaSsaPkcs1PrivateKey createKey(
         RsaSsaPkcs1PublicKey.builder()
             .setParameters(parameters)
             .setModulus(pubKey.getModulus())
+            .setIdRequirement(idRequirement)
             .build();
 
     // Creates RsaSsaPkcs1PrivateKey.

File: java_src/src/main/java/com/google/crypto/tink/signature/RsaSsaPssSignKeyManager.java
Patch:
@@ -100,6 +100,7 @@ private static RsaSsaPssPrivateKey createKey(
         RsaSsaPssPublicKey.builder()
             .setParameters(parameters)
             .setModulus(pubKey.getModulus())
+            .setIdRequirement(idRequirement)
             .build();
 
     // Creates RsaSsaPssPrivateKey.

File: java_src/src/main/java/com/google/crypto/tink/aead/internal/LegacyFullAead.java
Patch:
@@ -42,7 +42,7 @@ public class LegacyFullAead implements Aead {
   private final OutputPrefixType outputPrefixType;
   private final byte[] identifier;
 
-  /** This method covers the cases where users created their own mac/key classes. */
+  /** This method covers the cases where users created their own aead/key classes. */
   public static Aead create(LegacyProtoKey key) throws GeneralSecurityException {
     ProtoKeySerialization protoKeySerialization =
         key.getSerialization(InsecureSecretKeyAccess.get());

File: java_src/src/main/java/com/google/crypto/tink/subtle/Kwp.java
Patch:
@@ -45,7 +45,6 @@
  *     providers that did not implement KWP. It implements the same functionality as {@code
  *     Cipher.getInstance("AESWRAPPAD");}. Some provider use a different algorithm name: {@code
  *     Cipher.getInstance("AES/KWP/NoPadding");}.
- * @since 1.?.?
  */
 @Deprecated
 public class Kwp implements KeyWrap {

File: java_src/src/main/java/com/google/crypto/tink/mac/MacKeyTemplates.java
Patch:
@@ -129,8 +129,9 @@ public final class MacKeyTemplates {
               AesCmacKeyFormat.newBuilder()
                   .setKeySize(32)
                   .setParams(AesCmacParams.newBuilder().setTagSize(16).build())
-                  .build().toByteString())
-          .setTypeUrl(new AesCmacKeyManager().getKeyType())
+                  .build()
+                  .toByteString())
+          .setTypeUrl("type.googleapis.com/google.crypto.tink.AesCmacKey")
           .setOutputPrefixType(OutputPrefixType.TINK)
           .build();
 

File: java_src/src/main/java/com/google/crypto/tink/KeysetHandle.java
Patch:
@@ -1,4 +1,4 @@
-// Copyright 2017 Google Inc.
+// Copyright 2017 Google LLC
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.

File: java_src/src/main/java/com/google/crypto/tink/TinkProtoParametersFormat.java
Patch:
@@ -27,7 +27,7 @@
 /** Functions to parse and serialize Parameters in Tink's binary format based on Protobufs. */
 public final class TinkProtoParametersFormat {
   /**
-   * Serializes a parameters object into a byte[] according to Tink's binary format.
+   * Serializes a Parameters object into a byte[] according to Tink's binary format.
    */
   public static byte[] serialize(Parameters parameters) throws GeneralSecurityException {
     if (parameters instanceof LegacyProtoParameters) {
@@ -40,7 +40,7 @@ public static byte[] serialize(Parameters parameters) throws GeneralSecurityExce
   }
 
   /**
-   * Parses a byte[] into a parameters object into a byte[] according to Tink's binary format.
+   * Parses a byte[] into a Parameters object according to Tink's binary format.
    */
   public static Parameters parse(byte[] serializedParameters) throws GeneralSecurityException {
     KeyTemplate t;

File: java_src/src/main/java/com/google/crypto/tink/internal/KeyTypeManager.java
Patch:
@@ -105,9 +105,7 @@ public final Class<KeyProtoT> getKeyClass() {
   public abstract KeyMaterialType keyMaterialType();
 
   /** Returns the FIPS compatibility of this KeyTypeManager. */
-  public TinkFipsUtil.AlgorithmFipsCompatibility fipsStatus() {
-    return TinkFipsUtil.AlgorithmFipsCompatibility.ALGORITHM_NOT_FIPS;
-  };
+  public abstract TinkFipsUtil.AlgorithmFipsCompatibility fipsStatus();
 
   /**
    * Parses a serialized key proto.

File: java_src/src/test/java/com/google/crypto/tink/subtle/AesCtrHmacStreamingTest.java
Patch:
@@ -20,6 +20,7 @@
 import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.StreamingAead;
 import com.google.crypto.tink.config.TinkFips;
 import com.google.crypto.tink.testing.StreamingTestUtil;
 import com.google.crypto.tink.testing.StreamingTestUtil.SeekableByteBufferChannel;
@@ -305,14 +306,13 @@ public void testEncryptLimitedCiphertextChannel() throws Exception {
     int ciphertextLength = (int) ags.expectedCiphertextSize(plaintextSize);
     ByteBuffer ciphertext = ByteBuffer.allocate(ciphertextLength);
     WritableByteChannel ctChannel = new SeekableByteBufferChannel(ciphertext, maxChunkSize);
-    WritableByteChannel encChannel = ags.newEncryptingChannel(ctChannel, aad);
+    WritableByteChannel encChannel = ((StreamingAead) ags).newEncryptingChannel(ctChannel, aad);
     ByteBuffer plaintextBuffer = ByteBuffer.wrap(plaintext);
     int loops = 0;
     while (plaintextBuffer.remaining() > 0) {
       encChannel.write(plaintextBuffer);
       loops += 1;
       if (loops > 100000) {
-        System.out.println(encChannel.toString());
         fail("Too many loops");
       }
     }

File: java_src/src/test/java/com/google/crypto/tink/mac/MacWrapperTest.java
Patch:
@@ -179,6 +179,9 @@ private static HmacParameters createDefaultHmacParameters(HmacParameters.Variant
 
   @Test
   public void testComputeVerifyMac_works() throws Exception {
+    MutablePrimitiveRegistry.resetGlobalInstanceTestOnly();
+    MacConfig.register();
+
     byte[] plaintext = "plaintext".getBytes(UTF_8);
     KeysetHandle smallKeysetHandle =
         KeysetHandle.newBuilder()

File: java_src/src/test/java/com/google/crypto/tink/hybrid/EciesProtoSerializationTest.java
Patch:
@@ -348,7 +348,7 @@ public void test_demOutputPrefixTypeIsIgnored_whenParsed() throws Exception {
                         EcPointFormat.UNCOMPRESSED,
                         ByteString.copyFrom(SALT.toByteArray()),
                         KeyTemplate.newBuilder()
-                            .setTypeUrl("Non Existent Type Url")
+                            .setTypeUrl("NonExistentTypeUrl")
                             .setValue(
                                 XChaCha20Poly1305KeyFormat.newBuilder()
                                     .setVersion(0)

File: java_src/src/test/java/com/google/crypto/tink/keyderivation/internal/PrfBasedDeriverKeyManagerTest.java
Patch:
@@ -210,7 +210,7 @@ public void createKey_invalidDerivedKeyTemplate_throws() throws Exception {
             .setParams(
                 PrfBasedDeriverParams.newBuilder()
                     .setDerivedKeyTemplate(
-                        KeyTemplate.newBuilder().setTypeUrl("non existent type url").build()))
+                        KeyTemplate.newBuilder().setTypeUrl("nonexistenttypeurl").build()))
             .build();
     assertThrows(GeneralSecurityException.class, () -> factory.createKey(keyFormat));
   }

File: java_src/src/test/java/com/google/crypto/tink/keyderivation/internal/PrfBasedDeriverTest.java
Patch:
@@ -95,7 +95,7 @@ public void createDeriver_invalidDerivedKeyTemplate_throws() throws Exception {
             .setParams(HkdfPrfParams.newBuilder().setHash(HashType.SHA256))
             .setKeyValue(ByteString.copyFrom(Random.randBytes(32)))
             .build();
-    KeyTemplate keyTemplate = KeyTemplate.newBuilder().setTypeUrl("non existent type url").build();
+    KeyTemplate keyTemplate = KeyTemplate.newBuilder().setTypeUrl("nonexistenttypeurl").build();
     assertThrows(
         GeneralSecurityException.class,
         () ->

File: java_src/src/test/java/com/google/crypto/tink/keyderivation/internal/PrfBasedKeyDerivationKeyProtoSerializationTest.java
Patch:
@@ -225,7 +225,7 @@ public void parseParameters_invalidSerializations_badTypeUrl1_throws() throws Ex
             PrfBasedDeriverKeyFormat.newBuilder()
                 .setPrfKeyTemplate(
                     KeyTemplate.newBuilder()
-                        .setTypeUrl("Non Existent Type Url")
+                        .setTypeUrl("NonExistentTypeUrl")
                         .setValue(PRF_KEY_FORMAT_PROTO.toByteString())
                         .setOutputPrefixType(OutputPrefixType.RAW))
                 .setParams(

File: java_src/src/main/java/com/google/crypto/tink/testing/StreamingTestUtil.java
Patch:
@@ -472,8 +472,7 @@ public static void testEncryptionAndDecryption(
       byte[] decrypted = new byte[plaintext.length];
       for (int i = 0; i < plaintext.length; i++) {
         int b = decStream.read();
-        // TODO(b/298951892): A valid output of read() should not be negative.
-        // assertThat(b).isAtLeast(0);
+        assertThat(b).isAtLeast(0);
         assertThat(b).isAtMost(255);
         decrypted[i] = (byte) b;
       }

File: java_src/src/main/java/com/google/crypto/tink/streamingaead/InputStreamDecrypter.java
Patch:
@@ -121,7 +121,7 @@ public synchronized int available() throws IOException {
   public synchronized int read() throws IOException {
     byte[] oneByte = new byte[1];
     if (read(oneByte) == 1) {
-      return oneByte[0];
+      return oneByte[0] & 0xff;
     }
     return -1;
   }

File: java_src/src/main/java/com/google/crypto/tink/Registry.java
Patch:
@@ -111,7 +111,7 @@ private <KeyFormatProtoT extends MessageLite> MessageLite deriveKeyWithFactory(
           throw new GeneralSecurityException("parsing key format failed in deriveKey", e);
         }
         keyFactory.validateKeyFormat(keyFormat);
-        return keyFactory.deriveKey(keyFormat, stream);
+        return keyFactory.deriveKey(keyManager, keyFormat, stream);
       }
 
       @Override

File: java_src/src/main/java/com/google/crypto/tink/aead/AesGcmKeyManager.java
Patch:
@@ -106,7 +106,8 @@ public AesGcmKey createKey(AesGcmKeyFormat format) throws GeneralSecurityExcepti
       }
 
       @Override
-      public AesGcmKey deriveKey(AesGcmKeyFormat format, InputStream inputStream)
+      public AesGcmKey deriveKey(
+          KeyTypeManager<AesGcmKey> keyManager, AesGcmKeyFormat format, InputStream inputStream)
           throws GeneralSecurityException {
         Validators.validateVersion(format.getVersion(), getVersion());
 

File: java_src/src/main/java/com/google/crypto/tink/aead/XChaCha20Poly1305KeyManager.java
Patch:
@@ -113,7 +113,9 @@ public XChaCha20Poly1305Key createKey(XChaCha20Poly1305KeyFormat format)
 
       @Override
       public XChaCha20Poly1305Key deriveKey(
-          XChaCha20Poly1305KeyFormat format, InputStream inputStream)
+          KeyTypeManager<XChaCha20Poly1305Key> keyManager,
+          XChaCha20Poly1305KeyFormat format,
+          InputStream inputStream)
           throws GeneralSecurityException {
         Validators.validateVersion(format.getVersion(), getVersion());
 

File: java_src/src/main/java/com/google/crypto/tink/daead/AesSivKeyManager.java
Patch:
@@ -123,7 +123,8 @@ public AesSivKey createKey(AesSivKeyFormat format) throws GeneralSecurityExcepti
       }
 
       @Override
-      public AesSivKey deriveKey(AesSivKeyFormat format, InputStream inputStream)
+      public AesSivKey deriveKey(
+          KeyTypeManager<AesSivKey> keyTypeManager, AesSivKeyFormat format, InputStream inputStream)
           throws GeneralSecurityException {
         Validators.validateVersion(format.getVersion(), getVersion());
 

File: java_src/src/main/java/com/google/crypto/tink/mac/HmacKeyManager.java
Patch:
@@ -188,7 +188,8 @@ public HmacKey createKey(HmacKeyFormat format) throws GeneralSecurityException {
       }
 
       @Override
-      public HmacKey deriveKey(HmacKeyFormat format, InputStream inputStream)
+      public HmacKey deriveKey(
+          KeyTypeManager<HmacKey> keyManager, HmacKeyFormat format, InputStream inputStream)
           throws GeneralSecurityException {
         Validators.validateVersion(format.getVersion(), getVersion());
         byte[] pseudorandomness = new byte[format.getKeySize()];

File: java_src/src/main/java/com/google/crypto/tink/prf/HmacPrfKeyManager.java
Patch:
@@ -152,7 +152,8 @@ public HmacPrfKey createKey(HmacPrfKeyFormat format) {
       }
 
       @Override
-      public HmacPrfKey deriveKey(HmacPrfKeyFormat format, InputStream inputStream)
+      public HmacPrfKey deriveKey(
+          KeyTypeManager<HmacPrfKey> keyManager, HmacPrfKeyFormat format, InputStream inputStream)
           throws GeneralSecurityException {
         Validators.validateVersion(format.getVersion(), getVersion());
         byte[] pseudorandomness = new byte[format.getKeySize()];

File: java_src/src/main/java/com/google/crypto/tink/streamingaead/AesGcmHkdfStreamingKeyManager.java
Patch:
@@ -126,7 +126,9 @@ public AesGcmHkdfStreamingKey createKey(AesGcmHkdfStreamingKeyFormat format)
 
       @Override
       public AesGcmHkdfStreamingKey deriveKey(
-          AesGcmHkdfStreamingKeyFormat format, InputStream inputStream)
+          KeyTypeManager<AesGcmHkdfStreamingKey> keyManager,
+          AesGcmHkdfStreamingKeyFormat format,
+          InputStream inputStream)
           throws GeneralSecurityException {
         Validators.validateVersion(format.getVersion(), getVersion());
         byte[] pseudorandomness = new byte[format.getKeySize()];

File: java_src/src/test/java/com/google/crypto/tink/subtle/PrfMacTest.java
Patch:
@@ -153,8 +153,8 @@ public void verifyHmac_throwsOnWrongTag(
       @FromDataPoints("failingHmacTestVectors") HmacTestVector t) throws Exception {
     assumeTrue(!TinkFips.useOnlyFips() || TinkFipsUtil.fipsModuleAvailable());
 
-    Mac hmmac = PrfMac.create(t.key);
+    Mac hmac = PrfMac.create(t.key);
 
-    assertThrows(GeneralSecurityException.class, () -> hmmac.verifyMac(t.tag, t.message));
+    assertThrows(GeneralSecurityException.class, () -> hmac.verifyMac(t.tag, t.message));
   }
 }

File: java_src/examples/walkthrough/src/main/java/walkthrough/CreateKeysetExample.java
Patch:
@@ -19,7 +19,7 @@
 import java.security.GeneralSecurityException;
 
 // [START_EXCLUDE]
-/** Example to showcase creating a keyset and getting a {@link KeysetHandle}. */
+/** Example that creates a keyset and returns a {@link KeysetHandle}. */
 final class CreateKeysetExample {
   private CreateKeysetExample() {}
   // [END_EXCLUDE]

File: java_src/examples/walkthrough/src/main/java/walkthrough/ObtainAndUseAeadPrimitiveExample.java
Patch:
@@ -19,7 +19,7 @@
 import java.security.GeneralSecurityException;
 
 // [START_EXCLUDE]
-/** AEAD encryption/decryption example. */
+/** Example for AEAD encryption/decryption. */
 final class ObtainAndUseAeadPrimitiveExample {
   private ObtainAndUseAeadPrimitiveExample() {}
   // [END_EXCLUDE]

File: java_src/examples/walkthrough/src/main/java/walkthrough/ReadKeysetExample.java
Patch:
@@ -20,7 +20,7 @@
 import java.security.GeneralSecurityException;
 
 // [START_EXCLUDE]
-/** Examples to read a keyset from an input stream that was encrypted with a KMS key. */
+/** Example that reads a keyset that was encrypted with a KMS key. */
 final class ReadKeysetExample {
   private ReadKeysetExample() {}
 

File: java_src/examples/walkthrough/src/main/java/walkthrough/WriteKeysetExample.java
Patch:
@@ -20,7 +20,7 @@
 import java.security.GeneralSecurityException;
 
 // [START_EXCLUDE]
-/** Examples to write a keyset to an output stream encrypted with a KMS key. */
+/** Example that encrypts a keyset with a Key Encryption Key and JSON serializes it. */
 final class WriteKeysetExample {
   private WriteKeysetExample() {}
 

File: java_src/examples/walkthrough/src/test/java/walkthrough/WriteKeysetExampleTest.java
Patch:
@@ -28,7 +28,7 @@
 import org.junit.runners.JUnit4;
 
 @RunWith(JUnit4.class)
-public final class WriteKeyserExampleTest {
+public final class WriteKeysetExampleTest {
   private static final String KEYSET_TO_SERIALIZE =
       "{"
           + "  \"key\": ["

File: java_src/src/main/java/com/google/crypto/tink/internal/KeyTypeManager.java
Patch:
@@ -220,8 +220,8 @@ public KeyProtoT deriveKey(KeyFormatProtoT keyFormat, InputStream pseudoRandomne
     }
 
     /**
-     * Returns supported parameters and their names. Subclasses should override this if it should
-     * not return the empty map.
+     * Returns supported parameters and their names. This should not be used. Instead, subclasses
+     * should manually call MutablePrimitiveRegistry.globalInstance().put().
      *
      * @throws GeneralSecurityException Key type managers can throw GeneralSecurityException when
      *     their key formats depend on other key formats that were not registered.

File: java_src/src/main/java/com/google/crypto/tink/internal/MutableParametersRegistry.java
Patch:
@@ -69,7 +69,7 @@ public synchronized void putAll(Map<String, Parameters> values) throws GeneralSe
     }
   }
 
-  public synchronized List<String> getNames() throws GeneralSecurityException {
+  public synchronized List<String> getNames() {
     List<String> results = new ArrayList<>();
     results.addAll(parametersMap.keySet());
 

File: java_src/src/main/java/com/google/crypto/tink/prf/HmacPrfKeyManager.java
Patch:
@@ -23,6 +23,7 @@
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.MutableParametersRegistry;
 import com.google.crypto.tink.internal.MutablePrimitiveRegistry;
 import com.google.crypto.tink.internal.PrimitiveConstructor;
 import com.google.crypto.tink.internal.PrimitiveFactory;
@@ -183,6 +184,8 @@ public static void register(boolean newKeyAllowed) throws GeneralSecurityExcepti
     HmacPrfProtoSerialization.register();
     MutablePrimitiveRegistry.globalInstance()
         .registerPrimitiveConstructor(PRF_PRIMITIVE_CONSTRUCTOR);
+    MutableParametersRegistry.globalInstance()
+        .putAll(new HmacPrfKeyManager().keyFactory().namedParameters());
   }
 
   @Override

File: java_src/src/test/java/com/google/crypto/tink/KeyTemplatesAsParametersTest.java
Patch:
@@ -1015,6 +1015,6 @@ private static Set<String> getAllTestedNames() {
   public void testCompletenessOfThisTest() throws Exception {
     Set<String> testedNames = getAllTestedNames();
 
-    assertThat(Registry.parametersMap().keySet()).containsExactlyElementsIn(testedNames);
+    assertThat(Registry.keyTemplates()).containsExactlyElementsIn(testedNames);
   }
 }

File: java_src/src/main/java/com/google/crypto/tink/hybrid/PredefinedHybridParameters.java
Patch:
@@ -42,7 +42,7 @@ public final class PredefinedHybridParameters {
    * generated by this key template has no limitation on Android KitKat (API level 19). They might
    * not work in older versions though.
    */
-  public static final HybridParameters ECIES_P256_HKDF_HMAC_SHA256_AES128_GCM =
+  public static final EciesParameters ECIES_P256_HKDF_HMAC_SHA256_AES128_GCM =
       exceptionIsBug(
           () ->
               EciesParameters.builder()
@@ -75,7 +75,7 @@ public final class PredefinedHybridParameters {
    * generated by this key template has no limitation on Android KitKat (API level 19). They might
    * not work in older versions though.
    */
-  public static final HybridParameters
+  public static final EciesParameters
       ECIES_P256_HKDF_HMAC_SHA256_AES128_GCM_COMPRESSED_WITHOUT_PREFIX =
           exceptionIsBug(
               () ->
@@ -109,7 +109,7 @@ public final class PredefinedHybridParameters {
    *   <li>KDF: HKDF-HMAC-SHA256 with an empty salt
    * </ul>
    */
-  public static final HybridParameters ECIES_P256_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256 =
+  public static final EciesParameters ECIES_P256_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256 =
       exceptionIsBug(
           () ->
               EciesParameters.builder()

File: java_src/src/main/java/com/google/crypto/tink/aead/AesEaxProtoSerialization.java
Patch:
@@ -147,7 +147,7 @@ private static AesEaxParameters parseParameters(ProtoParametersSerialization ser
       throws GeneralSecurityException {
     if (!serialization.getKeyTemplate().getTypeUrl().equals(TYPE_URL)) {
       throw new IllegalArgumentException(
-          "Wrong type URL in call to AesEaxParameters.parseParameters: "
+          "Wrong type URL in call to AesEaxProtoSerialization.parseParameters: "
               + serialization.getKeyTemplate().getTypeUrl());
     }
     com.google.crypto.tink.proto.AesEaxKeyFormat format;
@@ -173,7 +173,7 @@ private static AesEaxKey parseKey(
       throws GeneralSecurityException {
     if (!serialization.getTypeUrl().equals(TYPE_URL)) {
       throw new IllegalArgumentException(
-          "Wrong type URL in call to AesEaxParameters.parseParameters");
+          "Wrong type URL in call to AesEaxProtoSerialization.parseKey");
     }
     try {
       com.google.crypto.tink.proto.AesEaxKey protoKey =

File: java_src/src/main/java/com/google/crypto/tink/aead/AesGcmProtoSerialization.java
Patch:
@@ -152,7 +152,7 @@ private static AesGcmParameters parseParameters(ProtoParametersSerialization ser
       throws GeneralSecurityException {
     if (!serialization.getKeyTemplate().getTypeUrl().equals(TYPE_URL)) {
       throw new IllegalArgumentException(
-          "Wrong type URL in call to AesGcmParameters.parseParameters: "
+          "Wrong type URL in call to AesGcmProtoSerialization.parseParameters: "
               + serialization.getKeyTemplate().getTypeUrl());
     }
     com.google.crypto.tink.proto.AesGcmKeyFormat format;
@@ -185,7 +185,7 @@ private static AesGcmKey parseKey(
       throws GeneralSecurityException {
     if (!serialization.getTypeUrl().equals(TYPE_URL)) {
       throw new IllegalArgumentException(
-          "Wrong type URL in call to AesGcmParameters.parseParameters");
+          "Wrong type URL in call to AesGcmProtoSerialization.parseKey");
     }
     try {
       com.google.crypto.tink.proto.AesGcmKey protoKey =

File: java_src/src/main/java/com/google/crypto/tink/aead/AesGcmSivProtoSerialization.java
Patch:
@@ -135,7 +135,7 @@ private static AesGcmSivParameters parseParameters(ProtoParametersSerialization
       throws GeneralSecurityException {
     if (!serialization.getKeyTemplate().getTypeUrl().equals(TYPE_URL)) {
       throw new IllegalArgumentException(
-          "Wrong type URL in call to AesGcmSivParameters.parseParameters: "
+          "Wrong type URL in call to AesGcmSivProtoSerialization.parseParameters: "
               + serialization.getKeyTemplate().getTypeUrl());
     }
     com.google.crypto.tink.proto.AesGcmSivKeyFormat format;
@@ -161,7 +161,7 @@ private static AesGcmSivKey parseKey(
       throws GeneralSecurityException {
     if (!serialization.getTypeUrl().equals(TYPE_URL)) {
       throw new IllegalArgumentException(
-          "Wrong type URL in call to AesGcmSivParameters.parseParameters");
+          "Wrong type URL in call to AesGcmSivProtoSerialization.parseKey");
     }
     try {
       com.google.crypto.tink.proto.AesGcmSivKey protoKey =

File: java_src/src/main/java/com/google/crypto/tink/aead/ChaCha20Poly1305ProtoSerialization.java
Patch:
@@ -137,7 +137,7 @@ private static ChaCha20Poly1305Parameters parseParameters(
       ProtoParametersSerialization serialization) throws GeneralSecurityException {
     if (!serialization.getKeyTemplate().getTypeUrl().equals(TYPE_URL)) {
       throw new IllegalArgumentException(
-          "Wrong type URL in call to ChaCha20Poly1305Parameters.parseParameters: "
+          "Wrong type URL in call to ChaCha20Poly1305ProtoSerialization.parseParameters: "
               + serialization.getKeyTemplate().getTypeUrl());
     }
     // ChaCha20Poly1305KeyFormat is currently an empty proto -- so it's not quite clear if we want
@@ -160,7 +160,7 @@ private static ChaCha20Poly1305Key parseKey(
       throws GeneralSecurityException {
     if (!serialization.getTypeUrl().equals(TYPE_URL)) {
       throw new IllegalArgumentException(
-          "Wrong type URL in call to ChaCha20Poly1305Parameters.parseParameters");
+          "Wrong type URL in call to ChaCha20Poly1305ProtoSerialization.parseKey");
     }
     try {
       com.google.crypto.tink.proto.ChaCha20Poly1305Key protoKey =

File: java_src/src/main/java/com/google/crypto/tink/aead/XChaCha20Poly1305ProtoSerialization.java
Patch:
@@ -137,7 +137,7 @@ private static XChaCha20Poly1305Parameters parseParameters(
       ProtoParametersSerialization serialization) throws GeneralSecurityException {
     if (!serialization.getKeyTemplate().getTypeUrl().equals(TYPE_URL)) {
       throw new IllegalArgumentException(
-          "Wrong type URL in call to XChaCha20Poly1305Parameters.parseParameters: "
+          "Wrong type URL in call to XChaCha20Poly1305ProtoSerialization.parseParameters: "
               + serialization.getKeyTemplate().getTypeUrl());
     }
     com.google.crypto.tink.proto.XChaCha20Poly1305KeyFormat format;
@@ -161,7 +161,7 @@ private static XChaCha20Poly1305Key parseKey(
       throws GeneralSecurityException {
     if (!serialization.getTypeUrl().equals(TYPE_URL)) {
       throw new IllegalArgumentException(
-          "Wrong type URL in call to XChaCha20Poly1305Parameters.parseParameters");
+          "Wrong type URL in call to XChaCha20Poly1305ProtoSerialization.parseKey");
     }
     try {
       com.google.crypto.tink.proto.XChaCha20Poly1305Key protoKey =

File: java_src/src/main/java/com/google/crypto/tink/mac/AesCmacProtoSerialization.java
Patch:
@@ -144,7 +144,7 @@ private static AesCmacParameters parseParameters(ProtoParametersSerialization se
       throws GeneralSecurityException {
     if (!serialization.getKeyTemplate().getTypeUrl().equals(TYPE_URL)) {
       throw new IllegalArgumentException(
-          "Wrong type URL in call to AesCmacParameters.parseParameters: "
+          "Wrong type URL in call to AesCmacProtoSerialization.parseParameters: "
               + serialization.getKeyTemplate().getTypeUrl());
     }
     com.google.crypto.tink.proto.AesCmacKeyFormat format;
@@ -167,7 +167,7 @@ private static AesCmacKey parseKey(
       throws GeneralSecurityException {
     if (!serialization.getTypeUrl().equals(TYPE_URL)) {
       throw new IllegalArgumentException(
-          "Wrong type URL in call to AesCmacParameters.parseParameters");
+          "Wrong type URL in call to AesCmacProtoSerialization.parseKey");
     }
     try {
       com.google.crypto.tink.proto.AesCmacKey protoKey =

File: java_src/src/test/java/com/google/crypto/tink/mac/internal/LegacyFullMacIntegrationTest.java
Patch:
@@ -167,7 +167,7 @@ private static final class TestLegacyMacWrapper implements PrimitiveWrapper<Lega
     static final TestLegacyMacWrapper WRAPPER = new TestLegacyMacWrapper();
 
     @Override
-    public LegacyFullMac wrap(PrimitiveSet<LegacyFullMac> primitiveSet)
+    public Mac wrap(PrimitiveSet<LegacyFullMac> primitiveSet)
         throws GeneralSecurityException {
       // This is a dummy test wrapper that act as a proxy to a single primitive object under test.
       return primitiveSet.getPrimary().getFullPrimitive();

File: java_src/src/main/java/com/google/crypto/tink/internal/KeyTypeManager.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.crypto.tink.internal;
 
 import com.google.crypto.tink.KeyTemplate;
+import com.google.crypto.tink.Parameters;
 import com.google.crypto.tink.annotations.Alpha;
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
@@ -234,14 +235,13 @@ public KeyProtoT deriveKey(KeyFormatProtoT keyFormat, InputStream pseudoRandomne
     }
 
     /**
-     * Returns supported key templates and their names. Subclasses should override this if it should
+     * Returns supported parameters and their names. Subclasses should override this if it should
      * not return the empty map.
      *
      * @throws GeneralSecurityException Key type managers can throw GeneralSecurityException when
      *     their key formats depend on other key formats that were not registered.
      */
-    public Map<String, KeyTemplate> namedKeyTemplates(String typeUrl)
-        throws GeneralSecurityException {
+    public Map<String, Parameters> namedParameters() throws GeneralSecurityException {
       return Collections.emptyMap();
     }
 

File: java_src/src/main/java/com/google/crypto/tink/hybrid/EciesPublicKey.java
Patch:
@@ -158,9 +158,9 @@ public static EciesPublicKey createForNistCurve(
   }
 
   /**
-   * Returns the underlying public point as byte array in case the curve is X25519.
+   * Returns the underlying public point if the curve is a NIST curve.
    *
-   * <p>Returns null For NIST curves.
+   * <p>Returns null if the curve used for this key is not a NIST curve.
    */
   @RestrictedApi(
       explanation = "Accessing parts of keys can produce unexpected incompatibilities, annotate the function with @AccessesPartialKey",

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwkSetConverter.java
Patch:
@@ -192,17 +192,17 @@ private static JsonObject convertJwtEcdsaKey(ProtoKeySerialization protoKeySeria
       case ES256:
         alg = "ES256";
         crv = "P-256";
-        encLength = 33;
+        encLength = 32;
         break;
       case ES384:
         alg = "ES384";
         crv = "P-384";
-        encLength = 49;
+        encLength = 48;
         break;
       case ES512:
         alg = "ES512";
         crv = "P-521";
-        encLength = 67;
+        encLength = 66;
         break;
       default:
         throw new GeneralSecurityException("unknown algorithm");

File: java_src/src/test/java/com/google/crypto/tink/aead/KmsAeadKeyManagerTest.java
Patch:
@@ -44,10 +44,10 @@ public void setUp() throws Exception {
   }
 
   @Test
-  public void testKmsAeadWithBoundedClient_success() throws Exception {
+  public void testKmsAead_success() throws Exception {
     String keyUri = FakeKmsClient.createFakeKeyUri();
     KeysetHandle keysetHandle =
-        KeysetHandle.generateNew(AeadKeyTemplates.createKmsAeadKeyTemplate(keyUri));
+        KeysetHandle.generateNew(KmsAeadKeyManager.createKeyTemplate(keyUri));
     TestUtil.runBasicAeadTests(keysetHandle.getPrimitive(Aead.class));
   }
 

File: java_src/src/test/java/com/google/crypto/tink/hybrid/EciesPrivateKeyTest.java
Patch:
@@ -128,7 +128,8 @@ public void createNistCurvePrivateKey_hasCorrectParameters(
             .setCurveType(nistCurveMapping.curveType)
             .setNistCurvePointFormat(pointFormat)
             .setVariant(EciesParameters.Variant.NO_PREFIX)
-            .setDemParameters(XChaCha20Poly1305Parameters.create())
+            .setDemParameters(
+                XChaCha20Poly1305Parameters.create(XChaCha20Poly1305Parameters.Variant.NO_PREFIX))
             .build();
 
     KeyPair keyPair = EllipticCurves.generateKeyPair(nistCurveMapping.ecNistCurve);

File: java_src/src/main/java/com/google/crypto/tink/mac/internal/LegacyFullMac.java
Patch:
@@ -45,7 +45,7 @@ public final class LegacyFullMac implements Mac {
   private final byte[] identifier;
 
   /** This method covers the cases where users created their own mac/key classes. */
-  public static LegacyFullMac create(LegacyProtoKey key) throws GeneralSecurityException {
+  public static Mac create(LegacyProtoKey key) throws GeneralSecurityException {
     ProtoKeySerialization protoKeySerialization =
         key.getSerialization(InsecureSecretKeyAccess.get());
     KeyData keyData =

File: java_src/src/main/java/com/google/crypto/tink/mac/internal/LegacyFullMac.java
Patch:
@@ -19,9 +19,9 @@
 import com.google.crypto.tink.CryptoFormat;
 import com.google.crypto.tink.InsecureSecretKeyAccess;
 import com.google.crypto.tink.Mac;
-import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.internal.LegacyProtoKey;
 import com.google.crypto.tink.internal.ProtoKeySerialization;
+import com.google.crypto.tink.internal.RegistryConfiguration;
 import com.google.crypto.tink.proto.KeyData;
 import com.google.crypto.tink.proto.OutputPrefixType;
 import com.google.crypto.tink.subtle.Bytes;
@@ -45,7 +45,7 @@ public final class LegacyFullMac implements Mac {
   private final byte[] identifier;
 
   /** This method covers the cases where users created their own mac/key classes. */
-  public static Mac create(LegacyProtoKey key) throws GeneralSecurityException {
+  public static LegacyFullMac create(LegacyProtoKey key) throws GeneralSecurityException {
     ProtoKeySerialization protoKeySerialization =
         key.getSerialization(InsecureSecretKeyAccess.get());
     KeyData keyData =
@@ -54,7 +54,7 @@ public static Mac create(LegacyProtoKey key) throws GeneralSecurityException {
             .setValue(protoKeySerialization.getValue())
             .setKeyMaterialType(protoKeySerialization.getKeyMaterialType())
             .build();
-    Mac rawPrimitive = Registry.getPrimitive(keyData, Mac.class);
+    Mac rawPrimitive = RegistryConfiguration.get().getLegacyPrimitive(keyData, Mac.class);
 
     OutputPrefixType outputPrefixType = protoKeySerialization.getOutputPrefixType();
     byte[] outputPrefix;

File: java_src/src/main/java/com/google/crypto/tink/mac/internal/LegacyHmacTestKeyManager.java
Patch:
@@ -41,7 +41,6 @@
  */
 class LegacyHmacTestKeyManager implements KeyManager<Mac> {
   /** Type url that this manager does support. */
-  // public static final String TYPE_URL = "type.googleapis.com/google.crypto.tink.HmacKey";
   public static final String TYPE_URL = "type.googleapis.com/google.crypto.tink.HmacKey";
   /** Current version of this key manager. Keys with version equal or smaller are supported. */
   private static final int VERSION = 0;
@@ -210,7 +209,6 @@ private void validate(HmacParams params) throws GeneralSecurityException {
 
   static void register() throws GeneralSecurityException {
     Registry.registerKeyManager(new LegacyHmacTestKeyManager(), true);
-    HmacProtoSerialization.register();
   }
 
   private static final class LegacyMacTestImpl implements Mac {

File: java_src/src/main/java/com/google/crypto/tink/KeysetManager.java
Patch:
@@ -99,7 +99,7 @@ public synchronized KeysetManager add(com.google.crypto.tink.proto.KeyTemplate k
    */
   @CanIgnoreReturnValue
   public synchronized KeysetManager add(KeyTemplate keyTemplate) throws GeneralSecurityException {
-    addNewKey(keyTemplate.getProto(), false);
+    addNewKey(keyTemplate.getProtoMaybeThrow(), false);
     return this;
   }
 

File: java_src/src/main/java/com/google/crypto/tink/tinkkey/KeyHandle.java
Patch:
@@ -15,6 +15,8 @@
 ////////////////////////////////////////////////////////////////////////////////
 package com.google.crypto.tink.tinkkey;
 
+import static com.google.crypto.tink.internal.KeyTemplateProtoConverter.getOutputPrefixType;
+
 import com.google.crypto.tink.KeyTemplate;
 import com.google.crypto.tink.KeyTemplate.OutputPrefixType;
 import com.google.crypto.tink.Registry;
@@ -105,7 +107,7 @@ protected KeyHandle(TinkKey key, KeyStatusType status, int keyId) {
    */
   public static KeyHandle generateNew(KeyTemplate keyTemplate) throws GeneralSecurityException {
     ProtoKey protoKey =
-        new ProtoKey(Registry.newKeyData(keyTemplate), keyTemplate.getOutputPrefixType());
+        new ProtoKey(Registry.newKeyData(keyTemplate), getOutputPrefixType(keyTemplate));
     return new KeyHandle(protoKey);
   }
 

File: java_src/src/main/java/com/google/crypto/tink/testing/TestUtil.java
Patch:
@@ -730,9 +730,11 @@ public static void assertHmacKey(
   public static void assertKeyInfo(
       com.google.crypto.tink.KeyTemplate keyTemplate, KeysetInfo.KeyInfo keyInfo) throws Exception {
     assertThat(keyInfo.getKeyId()).isGreaterThan(0);
+    com.google.crypto.tink.proto.KeyTemplate protoTemplate =
+        KeyTemplateProtoConverter.toProto(keyTemplate);
+    assertThat(keyInfo.getTypeUrl()).isEqualTo(protoTemplate.getTypeUrl());
     assertThat(keyInfo.getStatus()).isEqualTo(KeyStatusType.ENABLED);
     assertThat(keyInfo.getOutputPrefixType()).isEqualTo(OutputPrefixType.TINK);
-    assertThat(keyInfo.getTypeUrl()).isEqualTo(keyTemplate.getTypeUrl());
   }
 
   /**

File: java_src/src/test/java/com/google/crypto/tink/aead/KmsEnvelopeAeadKeyManagerTest.java
Patch:
@@ -221,7 +221,7 @@ public void createKeyTemplate() throws Exception {
 
     com.google.crypto.tink.proto.KeyTemplate protoTemplate =
         KeyTemplateProtoConverter.toProto(template);
-    assertThat(new KmsEnvelopeAeadKeyManager().getKeyType()).isEqualTo(template.getTypeUrl());
+    assertThat(new KmsEnvelopeAeadKeyManager().getKeyType()).isEqualTo(protoTemplate.getTypeUrl());
     assertThat(com.google.crypto.tink.proto.OutputPrefixType.RAW)
         .isEqualTo(protoTemplate.getOutputPrefixType());
 

File: java_src/src/test/java/com/google/crypto/tink/tinkkey/KeyHandleTest.java
Patch:
@@ -128,7 +128,8 @@ public void createFromKey_keyDataUnknown_shouldHaveSecret() throws Exception {
   @Test
   public void createFromKey_keyDataAsymmetricPublic_shouldNotHaveSecret() throws Exception {
     KeyTemplate kt = KeyTemplates.get("ED25519");
-    KeyData kd = Registry.getPublicKeyData(kt.getTypeUrl(), Registry.newKeyData(kt).getValue());
+    KeyData privateKeyData = Registry.newKeyData(kt);
+    KeyData kd = Registry.getPublicKeyData(privateKeyData.getTypeUrl(), privateKeyData.getValue());
 
     KeyHandle kh = KeyHandle.createFromKey(kd, kt.getOutputPrefixType());
 

File: java_src/src/test/java/com/google/crypto/tink/tinkkey/internal/ProtoKeyTest.java
Patch:
@@ -85,7 +85,8 @@ public void testProtoKey_keyDataUNKNOWN_shouldHaveSecret() throws GeneralSecurit
   public void testProtoKey_keyDataASYMMETRICPUBLIC_shouldNotHaveSecret()
       throws GeneralSecurityException {
     KeyTemplate kt = KeyTemplates.get("ED25519");
-    KeyData kd = Registry.getPublicKeyData(kt.getTypeUrl(), Registry.newKeyData(kt).getValue());
+    KeyData privateKeyData = Registry.newKeyData(kt);
+    KeyData kd = Registry.getPublicKeyData(privateKeyData.getTypeUrl(), privateKeyData.getValue());
 
     ProtoKey pk = new ProtoKey(kd, kt.getOutputPrefixType());
 

File: java_src/src/main/java/com/google/crypto/tink/TinkProtoParametersFormat.java
Patch:
@@ -50,7 +50,7 @@ public static Parameters parse(byte[] serializedParameters) throws GeneralSecuri
       throw new GeneralSecurityException("Failed to parse proto", e);
     }
     return MutableSerializationRegistry.globalInstance()
-        .parseParametersWithLegacyFallback(ProtoParametersSerialization.create(t));
+        .parseParametersWithLegacyFallback(ProtoParametersSerialization.checkedCreate(t));
   }
 
   private TinkProtoParametersFormat() {}

File: java_src/src/main/java/com/google/crypto/tink/internal/Ed25519.java
Patch:
@@ -1529,7 +1529,7 @@ public static byte[] getHashedScalar(final byte[] privateKey) throws GeneralSecu
    * Returns the EdDSA signature for the {@code message} based on the {@code hashedPrivateKey}.
    *
    * @param message to sign
-   * @param publicKey {@link Ed25519#scalarMultToBytes(byte[])} of {@code hashedPrivateKey}
+   * @param publicKey {@link Ed25519#scalarMultWithBaseToBytes(byte[])} of {@code hashedPrivateKey}
    * @param hashedPrivateKey {@link Ed25519#getHashedScalar(byte[])} of the private key
    * @return signature for the {@code message}.
    * @throws GeneralSecurityException if there is no SHA-512 algorithm defined in {@link

File: testing/java_src/javatests/com/google/crypto/tink/testing/TestingServicesTest.java
Patch:
@@ -165,7 +165,7 @@ public void template_success() throws Exception {
     assertThat(response.getErr()).isEmpty();
     KeyTemplate template =
         KeyTemplateProtoConverter.fromByteArray(response.getKeyTemplate().toByteArray());
-    assertThat(template.getTypeUrl()).isEqualTo("type.googleapis.com/google.crypto.tink.AesGcmKey");
+    assertThat(template.toParameters()).isEqualTo(KeyTemplates.get("AES256_GCM").toParameters());
   }
 
   @Test

File: java_src/src/main/java/com/google/crypto/tink/Registry.java
Patch:
@@ -573,7 +573,9 @@ public static synchronized MessageLite newKey(
    * {@link KeyManager#newKey} with {@code format} as the parameter.
    *
    * @return a new key
+   * @deprecated Use {@code newKeyData} instead.
    */
+  @Deprecated
   public static synchronized MessageLite newKey(String typeUrl, MessageLite format)
       throws GeneralSecurityException {
     KeyManager<?> manager = getKeyManager(typeUrl);

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtEcdsaPublicKey.java
Patch:
@@ -178,7 +178,7 @@ public Integer getIdRequirementOrNull() {
   }
 
   @Override
-  public JwtSignatureParameters getParameters() {
+  public JwtEcdsaParameters getParameters() {
     return parameters;
   }
 

File: java_src/src/main/java/com/google/crypto/tink/JsonKeysetReader.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.crypto.tink;
 
-import androidx.annotation.RequiresApi;
 import com.google.crypto.tink.internal.JsonParser;
 import com.google.crypto.tink.proto.EncryptedKeyset;
 import com.google.crypto.tink.proto.KeyData;
@@ -146,7 +145,6 @@ public static JsonKeysetReader withPath(String path) throws IOException {
   @InlineMe(
       replacement = "JsonKeysetReader.withInputStream(new FileInputStream(path.toFile()))",
       imports = {"com.google.crypto.tink.JsonKeysetReader", "java.io.FileInputStream"})
-  @RequiresApi(26) // https://developer.android.com/reference/java/nio/file/Path
   @Deprecated
   public static JsonKeysetReader withPath(Path path) throws IOException {
     return JsonKeysetReader.withInputStream(new FileInputStream(path.toFile()));

File: java_src/src/main/java/com/google/crypto/tink/JsonKeysetWriter.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.crypto.tink;
 
-import androidx.annotation.RequiresApi;
 import com.google.crypto.tink.proto.EncryptedKeyset;
 import com.google.crypto.tink.proto.KeyData;
 import com.google.crypto.tink.proto.Keyset;
@@ -95,7 +94,6 @@ public static KeysetWriter withPath(String path) throws IOException {
    *
    * @deprecated Method should be inlined.
    */
-  @RequiresApi(26) // https://developer.android.com/reference/java/nio/file/Path
   @InlineMe(
       replacement = "JsonKeysetWriter.withOutputStream(new FileOutputStream(path.toFile()))",
       imports = {"com.google.crypto.tink.JsonKeysetWriter", "java.io.FileOutputStream"})

File: java_src/src/main/java/com/google/crypto/tink/StreamingAead.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.crypto.tink;
 
-import androidx.annotation.RequiresApi;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -162,7 +161,6 @@ WritableByteChannel newEncryptingChannel(
    *     associatedData is not correct.
    * @throws IOException if an IOException occurred while reading from ciphertextDestination.
    */
-  @RequiresApi(24) // https://developer.android.com/reference/java/nio/channels/SeekableByteChannel
   SeekableByteChannel newSeekableDecryptingChannel(
       SeekableByteChannel ciphertextSource, byte[] associatedData)
       throws GeneralSecurityException, IOException;

File: java_src/src/main/java/com/google/crypto/tink/streamingaead/SeekableByteChannelDecrypter.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.crypto.tink.streamingaead;
 
-import androidx.annotation.RequiresApi;
 import com.google.crypto.tink.StreamingAead;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
@@ -30,7 +29,6 @@
 import javax.annotation.concurrent.GuardedBy;
 
 /** A decrypter for ciphertext given in a {@link SeekableByteChannel}. */
-@RequiresApi(24) // https://developer.android.com/reference/java/nio/channels/SeekableByteChannel
 final class SeekableByteChannelDecrypter implements SeekableByteChannel {
   @GuardedBy("this")
   SeekableByteChannel attemptingChannel;

File: java_src/src/main/java/com/google/crypto/tink/streamingaead/StreamingAeadHelper.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.crypto.tink.streamingaead;
 
-import androidx.annotation.RequiresApi;
 import com.google.crypto.tink.StreamingAead;
 import java.io.IOException;
 import java.io.InputStream;
@@ -61,7 +60,6 @@ public ReadableByteChannel newDecryptingChannel(
   }
 
   @Override
-  @RequiresApi(24) // https://developer.android.com/reference/java/nio/channels/SeekableByteChannel
   public SeekableByteChannel newSeekableDecryptingChannel(
       SeekableByteChannel ciphertextChannel, byte[] associatedData)
       throws GeneralSecurityException, IOException {

File: java_src/src/main/java/com/google/crypto/tink/subtle/StreamingAeadSeekableDecryptingChannel.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.crypto.tink.subtle;
 
-import androidx.annotation.RequiresApi;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
 import java.nio.ByteBuffer;
@@ -30,7 +29,6 @@
  * An instance of {@link SeekableByteChannel} that allows random access to the plaintext of some
  * ciphertext.
  */
-@RequiresApi(24) // https://developer.android.com/reference/java/nio/channels/SeekableByteChannel
 class StreamingAeadSeekableDecryptingChannel implements SeekableByteChannel {
   // Each plaintext segment has 16 bytes more of memory than the actual plaintext that it contains.
   // This is a workaround for an incompatibility between Conscrypt and OpenJDK in their

File: java_src/src/test/java/com/google/crypto/tink/signature/EcdsaProtoSerializationTest.java
Patch:
@@ -417,7 +417,6 @@ public void serializeParsePrivateKey_p256_tink_equal() throws Exception {
             /* idRequirement= */ 123);
 
     Key parsed = registry.parseKey(serialization, InsecureSecretKeyAccess.get());
-    System.out.println(parsed);
     assertThat(parsed.equalsKey(privateKey)).isTrue();
 
     ProtoKeySerialization serialized =

File: java_src/src/main/java/com/google/crypto/tink/KeysetHandle.java
Patch:
@@ -938,7 +938,7 @@ private static Keyset decrypt(
   /**
    * If the managed keyset contains private keys, returns a {@link KeysetHandle} of the public keys.
    *
-   * @throws GenernalSecurityException if the managed keyset is null or if it contains any
+   * @throws GeneralSecurityException if the managed keyset is null or if it contains any
    *     non-private keys.
    */
   public KeysetHandle getPublicKeysetHandle() throws GeneralSecurityException {

File: java_src/src/main/java/com/google/crypto/tink/subtle/PemKeyType.java
Patch:
@@ -34,7 +34,7 @@
  *
  * @deprecated Use com.google.crypto.tink.PemKeyType instead.
  */
-@Deprecated /* Deprecation under consideration */
+@Deprecated
 public enum PemKeyType {
   // RSASSA-PSS 2048 bit key with a SHA256 digest.
   RSA_PSS_2048_SHA256("RSA", "RSASSA-PSS", 2048, HashType.SHA256),

File: java_src/src/main/java/com/google/crypto/tink/prf/HkdfPrfParameters.java
Patch:
@@ -141,7 +141,7 @@ public boolean equals(Object o) {
     HkdfPrfParameters that = (HkdfPrfParameters) o;
     return that.getKeySizeBytes() == getKeySizeBytes()
         && that.getHashType() == getHashType()
-        && that.getSalt().equals(getSalt());
+        && Objects.equals(that.getSalt(), getSalt());
   }
 
   @Override

File: java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeysetManager.java
Patch:
@@ -369,7 +369,7 @@ private KeysetManager readMasterkeyDecryptAndParseKeyset(byte[] serializedKeyset
           KeysetManager manager = readKeysetInCleartext(serializedKeyset);
           Log.w(TAG, "cannot use Android Keystore, it'll be disabled", keystoreException);
           return manager;
-        } catch (InvalidProtocolBufferException unused) {
+        } catch (IOException unused) {
           // Keyset is encrypted, throw error about master key encryption
           throw keystoreException;
         }
@@ -379,7 +379,7 @@ private KeysetManager readMasterkeyDecryptAndParseKeyset(byte[] serializedKeyset
         // Decrypt and parse the keyset using masterKey.
         return KeysetManager.withKeysetHandle(
             KeysetHandle.read(BinaryKeysetReader.withBytes(serializedKeyset), masterKey));
-      } catch (InvalidProtocolBufferException | GeneralSecurityException ex) {
+      } catch (IOException | GeneralSecurityException ex) {
         // Attempt to read the keyset in cleartext.
         // This edge case may happen when either
         //   - the keyset was generated on a pre M phone which was upgraded to M or newer, or
@@ -392,7 +392,7 @@ private KeysetManager readMasterkeyDecryptAndParseKeyset(byte[] serializedKeyset
         // write the encrypted keyset in the first place.
         try {
           return readKeysetInCleartext(serializedKeyset);
-        } catch (InvalidProtocolBufferException unused) {
+        } catch (IOException unused) {
           // Parsing failed because the keyset is encrypted but we were not able to decrypt it.
           throw ex;
         }

File: testing/java_src/javatests/com/google/crypto/tink/testing/TestingServicesTest.java
Patch:
@@ -187,7 +187,7 @@ public void fromJson_success() throws Exception {
             + "      \"keyData\": {"
             + "        \"typeUrl\": \"type.googleapis.com/google.crypto.tink.AesGcmKey\","
             + "        \"keyMaterialType\": \"SYMMETRIC\","
-            + "        \"value\": \"AFakeTestKeyValue1234567\""
+            + "        \"value\": \"GhCC74uJ+2f4qlpaHwR4ylNQ\""
             + "      },"
             + "      \"outputPrefixType\": \"TINK\","
             + "      \"keyId\": 42,"

File: java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeysetManager.java
Patch:
@@ -131,7 +131,7 @@ public final class AndroidKeysetManager {
   @GuardedBy("this")
   private KeysetManager keysetManager;
 
-  private AndroidKeysetManager(Builder builder) throws GeneralSecurityException, IOException {
+  private AndroidKeysetManager(Builder builder) {
     writer = builder.writer;
     masterKey = builder.masterKey;
     keysetManager = builder.keysetManager;
@@ -274,7 +274,8 @@ private Aead readOrGenerateNewMasterKey() throws GeneralSecurityException {
       boolean existed = client.hasKey(masterKeyUri);
       if (!existed) {
         try {
-          AndroidKeystoreKmsClient.generateNewAeadKey(masterKeyUri);
+          // Note that this function does not use the keyStore instance set with withKeyStore.
+          AndroidKeystoreKmsClient.generateNewAesGcmKeyWithoutExistenceCheck(masterKeyUri);
         } catch (GeneralSecurityException | ProviderException ex) {
           Log.w(TAG, "cannot use Android Keystore, it'll be disabled", ex);
           return null;

File: java_src/src/test/java/com/google/crypto/tink/aead/AesEaxParametersTest.java
Patch:
@@ -102,6 +102,7 @@ public void buildWithVariantSetToNull_fails() throws Exception {
             AesEaxParameters.builder()
                 .setKeySizeBytes(16)
                 .setIvSizeBytes(16)
+                .setTagSizeBytes(16)
                 .setVariant(null)
                 .build());
   }

File: java_src/src/test/java/com/google/crypto/tink/RegistryTest.java
Patch:
@@ -137,6 +137,8 @@ private static interface EncryptOnly {
   }
 
   private static class AeadToEncryptOnlyWrapper implements PrimitiveWrapper<Aead, EncryptOnly> {
+    public static final AeadToEncryptOnlyWrapper WRAPPER = new AeadToEncryptOnlyWrapper();
+
     @Override
     public EncryptOnly wrap(PrimitiveSet<Aead> set) throws GeneralSecurityException {
       return new EncryptOnly() {
@@ -169,7 +171,7 @@ public void setUp() throws GeneralSecurityException {
     TinkFipsUtil.unsetFipsRestricted();
     Registry.reset();
     TinkConfig.register();
-    Registry.registerPrimitiveWrapper(new AeadToEncryptOnlyWrapper());
+    Registry.registerPrimitiveWrapper(AeadToEncryptOnlyWrapper.WRAPPER);
   }
 
   private void testGetKeyManagerShouldWork(String typeUrl, String className) throws Exception {

File: java_src/src/test/java/com/google/crypto/tink/RegistryTest.java
Patch:
@@ -137,8 +137,6 @@ private static interface EncryptOnly {
   }
 
   private static class AeadToEncryptOnlyWrapper implements PrimitiveWrapper<Aead, EncryptOnly> {
-    public static final AeadToEncryptOnlyWrapper WRAPPER = new AeadToEncryptOnlyWrapper();
-
     @Override
     public EncryptOnly wrap(PrimitiveSet<Aead> set) throws GeneralSecurityException {
       return new EncryptOnly() {
@@ -171,7 +169,7 @@ public void setUp() throws GeneralSecurityException {
     TinkFipsUtil.unsetFipsRestricted();
     Registry.reset();
     TinkConfig.register();
-    Registry.registerPrimitiveWrapper(AeadToEncryptOnlyWrapper.WRAPPER);
+    Registry.registerPrimitiveWrapper(new AeadToEncryptOnlyWrapper());
   }
 
   private void testGetKeyManagerShouldWork(String typeUrl, String className) throws Exception {

File: java_src/src/test/java/com/google/crypto/tink/RegistryTest.java
Patch:
@@ -137,6 +137,8 @@ private static interface EncryptOnly {
   }
 
   private static class AeadToEncryptOnlyWrapper implements PrimitiveWrapper<Aead, EncryptOnly> {
+    public static final AeadToEncryptOnlyWrapper WRAPPER = new AeadToEncryptOnlyWrapper();
+
     @Override
     public EncryptOnly wrap(PrimitiveSet<Aead> set) throws GeneralSecurityException {
       return new EncryptOnly() {
@@ -169,7 +171,7 @@ public void setUp() throws GeneralSecurityException {
     TinkFipsUtil.unsetFipsRestricted();
     Registry.reset();
     TinkConfig.register();
-    Registry.registerPrimitiveWrapper(new AeadToEncryptOnlyWrapper());
+    Registry.registerPrimitiveWrapper(AeadToEncryptOnlyWrapper.WRAPPER);
   }
 
   private void testGetKeyManagerShouldWork(String typeUrl, String className) throws Exception {

File: java_src/src/main/java/com/google/crypto/tink/mac/HmacProtoSerialization.java
Patch:
@@ -183,7 +183,7 @@ private static HmacParameters parseParameters(ProtoParametersSerialization seria
       throws GeneralSecurityException {
     if (!serialization.getKeyTemplate().getTypeUrl().equals(TYPE_URL)) {
       throw new IllegalArgumentException(
-          "Wrong type URL in call to HmacParameters.parseParameters: "
+          "Wrong type URL in call to HmacProtoSerialization.parseParameters: "
               + serialization.getKeyTemplate().getTypeUrl());
     }
     com.google.crypto.tink.proto.HmacKeyFormat format;
@@ -212,7 +212,7 @@ private static HmacKey parseKey(
       throws GeneralSecurityException {
     if (!serialization.getTypeUrl().equals(TYPE_URL)) {
       throw new IllegalArgumentException(
-          "Wrong type URL in call to HmacParameters.parseParameters");
+          "Wrong type URL in call to HmacProtoSerialization.parseKey");
     }
     try {
       com.google.crypto.tink.proto.HmacKey protoKey =

File: java_src/src/main/java/com/google/crypto/tink/signature/EcdsaPrivateKey.java
Patch:
@@ -130,7 +130,7 @@ public boolean equalsKey(Key o) {
       return false;
     }
     EcdsaPrivateKey that = (EcdsaPrivateKey) o;
-    return that.publicKey.equals(publicKey)
+    return that.publicKey.equalsKey(publicKey)
         && privateValue.equalsSecretBigInteger(that.privateValue);
   }
 }

File: java_src/src/main/java/com/google/crypto/tink/internal/PrimitiveRegistry.java
Patch:
@@ -143,7 +143,7 @@ public <InputPrimitiveT, WrapperPrimitiveT> WrapperPrimitiveT wrap(
       throws GeneralSecurityException {
     if (!primitiveWrapperMap.containsKey(wrapperClassObject)) {
       throw new GeneralSecurityException(
-          "No PrimitiveWrapper for " + wrapperClassObject + " available");
+          "No wrapper found for " + wrapperClassObject);
     }
     @SuppressWarnings("unchecked") // We know this is how this map is organized.
     PrimitiveWrapper<?, WrapperPrimitiveT> wrapper =

File: java_src/src/main/java/com/google/crypto/tink/PrimitiveSet.java
Patch:
@@ -314,6 +314,7 @@ public void setPrimary(final Entry<P> primary) {
    * @deprecated use {@link Builder.addPrimitive} or {@link Builder.addPrimaryPrimitive} instead.
    */
   @Deprecated
+  @CanIgnoreReturnValue
   public Entry<P> addPrimitive(final P primitive, Keyset.Key key) throws GeneralSecurityException {
     if (!isMutable) {
       throw new IllegalStateException(

File: java_src/src/main/java/com/google/crypto/tink/testing/KeyTypeManagerTestUtil.java
Patch:
@@ -20,6 +20,7 @@
 
 import com.google.crypto.tink.KeyTemplate;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.protobuf.ByteString;
 import com.google.protobuf.MessageLite;
 
@@ -39,6 +40,7 @@ KeyProtoT parseValidateCreateKey(
    * Checks that the given keyTemplate will be handed to the given KeyTypeManager (if registered),
    * that it validates, and returns a key if needed.
    */
+  @CanIgnoreReturnValue
   public static <KeyProtoT extends MessageLite> KeyProtoT testKeyTemplateCompatible(
       KeyTypeManager<KeyProtoT> manager, KeyTemplate template) throws Exception {
     assertThat(template.getTypeUrl()).isEqualTo(manager.getKeyType());

File: java_src/src/main/java/com/google/crypto/tink/util/KeysDownloader.java
Patch:
@@ -161,6 +161,7 @@ long getCurrentTimeInMillis() {
   }
 
   @GuardedBy("fetchDataLock")
+  @CanIgnoreReturnValue
   private String fetchAndCacheData() throws IOException {
     long currentTimeInMillis = getCurrentTimeInMillis();
     HttpRequest httpRequest =

File: java_src/src/main/java/com/google/crypto/tink/aead/AeadFactory.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeysetHandle;
-import com.google.crypto.tink.Registry;
 import java.security.GeneralSecurityException;
 
 /**
@@ -46,7 +45,7 @@ public final class AeadFactory {
    */
   @Deprecated
   public static Aead getPrimitive(KeysetHandle keysetHandle) throws GeneralSecurityException {
-    Registry.registerPrimitiveWrapper(new AeadWrapper());
+    AeadWrapper.register();
     return keysetHandle.getPrimitive(Aead.class);
   }
 

File: java_src/src/main/java/com/google/crypto/tink/daead/DeterministicAeadFactory.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.google.crypto.tink.DeterministicAead;
 import com.google.crypto.tink.KeysetHandle;
-import com.google.crypto.tink.Registry;
 import java.security.GeneralSecurityException;
 
 /**
@@ -46,7 +45,7 @@ public final class DeterministicAeadFactory {
   @Deprecated
   public static DeterministicAead getPrimitive(KeysetHandle keysetHandle)
       throws GeneralSecurityException {
-    Registry.registerPrimitiveWrapper(new DeterministicAeadWrapper());
+    DeterministicAeadWrapper.register();
     return keysetHandle.getPrimitive(DeterministicAead.class);
   }
 

File: java_src/src/main/java/com/google/crypto/tink/hybrid/HybridDecryptFactory.java
Patch:
@@ -17,7 +17,6 @@
 
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.KeysetHandle;
-import com.google.crypto.tink.Registry;
 import java.security.GeneralSecurityException;
 
 /**
@@ -45,7 +44,7 @@ public final class HybridDecryptFactory {
   @Deprecated
   public static HybridDecrypt getPrimitive(KeysetHandle keysetHandle)
       throws GeneralSecurityException {
-    Registry.registerPrimitiveWrapper(new HybridDecryptWrapper());
+    HybridDecryptWrapper.register();
     return keysetHandle.getPrimitive(HybridDecrypt.class);
   }
 

File: java_src/src/main/java/com/google/crypto/tink/hybrid/HybridEncryptFactory.java
Patch:
@@ -17,7 +17,6 @@
 
 import com.google.crypto.tink.HybridEncrypt;
 import com.google.crypto.tink.KeysetHandle;
-import com.google.crypto.tink.Registry;
 import java.security.GeneralSecurityException;
 
 /**
@@ -46,7 +45,7 @@ public final class HybridEncryptFactory {
   @Deprecated
   public static HybridEncrypt getPrimitive(KeysetHandle keysetHandle)
       throws GeneralSecurityException {
-    Registry.registerPrimitiveWrapper(new HybridEncryptWrapper());
+    HybridEncryptWrapper.register();
     return keysetHandle.getPrimitive(HybridEncrypt.class);
   }
 

File: java_src/src/main/java/com/google/crypto/tink/mac/MacFactory.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.Mac;
-import com.google.crypto.tink.Registry;
 import java.security.GeneralSecurityException;
 
 /**
@@ -47,7 +46,7 @@ public final class MacFactory {
    */
   @Deprecated
   public static Mac getPrimitive(KeysetHandle keysetHandle) throws GeneralSecurityException {
-    Registry.registerPrimitiveWrapper(new MacWrapper());
+    MacWrapper.register();
     return keysetHandle.getPrimitive(Mac.class);
   }
 

File: java_src/src/main/java/com/google/crypto/tink/signature/PublicKeySignFactory.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.PublicKeySign;
-import com.google.crypto.tink.Registry;
 import java.security.GeneralSecurityException;
 
 /**
@@ -46,7 +45,7 @@ public final class PublicKeySignFactory {
   @Deprecated
   public static PublicKeySign getPrimitive(KeysetHandle keysetHandle)
       throws GeneralSecurityException {
-    Registry.registerPrimitiveWrapper(new PublicKeySignWrapper());
+    PublicKeySignWrapper.register();
     return keysetHandle.getPrimitive(PublicKeySign.class);
   }
 

File: java_src/src/main/java/com/google/crypto/tink/signature/PublicKeyVerifyFactory.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.PublicKeyVerify;
-import com.google.crypto.tink.Registry;
 import java.security.GeneralSecurityException;
 
 /**
@@ -46,7 +45,7 @@ public final class PublicKeyVerifyFactory {
   @Deprecated
   public static PublicKeyVerify getPrimitive(KeysetHandle keysetHandle)
       throws GeneralSecurityException {
-    Registry.registerPrimitiveWrapper(new PublicKeyVerifyWrapper());
+    PublicKeyVerifyWrapper.register();
     return keysetHandle.getPrimitive(PublicKeyVerify.class);
   }
 

File: java_src/src/main/java/com/google/crypto/tink/streamingaead/StreamingAeadFactory.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.crypto.tink.streamingaead;
 
 import com.google.crypto.tink.KeysetHandle;
-import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.StreamingAead;
 import java.security.GeneralSecurityException;
 
@@ -43,7 +42,7 @@ public final class StreamingAeadFactory {
    */
   public static StreamingAead getPrimitive(KeysetHandle keysetHandle)
       throws GeneralSecurityException {
-    Registry.registerPrimitiveWrapper(new StreamingAeadWrapper());
+    StreamingAeadWrapper.register();
     return keysetHandle.getPrimitive(StreamingAead.class);
   }
 

File: java_src/src/test/java/com/google/crypto/tink/MonitoringUtilTest.java
Patch:
@@ -55,9 +55,8 @@ public void monitoringKeysetInfoFromPrimitiveSet() throws Exception {
     assertThat(entries).hasSize(1);
     assertThat(entries.get(0).getStatus()).isEqualTo(KeyStatus.ENABLED);
     assertThat(entries.get(0).getKeyId()).isEqualTo(42);
-    assertThat(entries.get(0).getParameters().toString())
-        .isEqualTo(
-            "(typeUrl=type.googleapis.com/google.crypto.tink.AesGcmKey, outputPrefixType=TINK)");
+    assertThat(entries.get(0).getKeyType()).isEqualTo("tink.AesGcmKey");
+    assertThat(entries.get(0).getKeyPrefix()).isEqualTo("TINK");
   }
 
   @Test

File: testing/java_src/java/com/google/crypto/tink/testing/TestingServer.java
Patch:
@@ -74,8 +74,8 @@ public void run() throws InterruptedException, GeneralSecurityException, IOExcep
     PrfConfig.register();
     SignatureConfig.register();
     StreamingAeadConfig.register();
-    GcpKmsClient.register(Optional.of(gcpKeyUri), Optional.of(gcpCredentialsPath));
-    AwsKmsClient.register(Optional.of(awsKeyUri), Optional.of(awsCredentialsPath));
+    GcpKmsClient.register(Optional.ofNullable(gcpKeyUri), Optional.of(gcpCredentialsPath));
+    AwsKmsClient.register(Optional.ofNullable(awsKeyUri), Optional.of(awsCredentialsPath));
 
     System.out.println("Start server on port " + port);
     KmsClients.add(new FakeKmsClient());

File: java_src/src/test/java/com/google/crypto/tink/internal/MutableSerializationRegistryTest.java
Patch:
@@ -37,7 +37,7 @@
 import org.junit.runners.JUnit4;
 
 /**
- * Thread safety tests for {@link MutableSerializationRegistry}.
+ * Tests for {@link MutableSerializationRegistry}.
  *
  * <p>We repeat the main tests in SerializationRegistryTest. There really shouldn't be both classes,
  * but currently this is what we need, and the other is what we should have.

File: java_src/src/test/java/com/google/crypto/tink/internal/PrimitiveRegistryTest.java
Patch:
@@ -223,7 +223,7 @@ public void test_registerAll_checkDispatch() throws Exception {
   }
 
   @Test
-  public void test_serializer_copyWorks() throws Exception {
+  public void test_copyWorks() throws Exception {
     PrimitiveRegistry registry =
         new PrimitiveRegistry.Builder()
             .registerPrimitiveConstructor(

File: java_src/src/main/java/com/google/crypto/tink/subtle/EngineFactory.java
Patch:
@@ -41,7 +41,7 @@
  *
  * @since 1.0.0
  */
-public final class EngineFactory<T_WRAPPER extends EngineWrapper<T_ENGINE>, T_ENGINE> {
+public final class EngineFactory<T_WRAPPER extends EngineWrapper<JcePrimitiveT>, JcePrimitiveT> {
   private static final Logger logger = Logger.getLogger(EngineFactory.class.getName());
   private static final List<Provider> policy;
   private static final boolean LET_FALLBACK;
@@ -106,7 +106,7 @@ public EngineFactory(T_WRAPPER instanceBuilder) {
     this.instanceBuilder = instanceBuilder;
   }
 
-  public T_ENGINE getInstance(String algorithm) throws GeneralSecurityException {
+  public JcePrimitiveT getInstance(String algorithm) throws GeneralSecurityException {
     Exception cause = null;
     for (Provider provider : policy) {
       try {

File: testing/java_src/javatests/com/google/crypto/tink/testing/JwtServiceImplTest.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertThrows;
 
 import com.google.crypto.tink.KeyTemplates;
 import com.google.crypto.tink.internal.KeyTemplateProtoConverter;
@@ -363,8 +364,8 @@ public void signFailsOnBadKeyset() throws Exception {
                     .build())
             .setRawJwt(token)
             .build();
-    JwtSignResponse signResponse = jwtStub.computeMacAndEncode(signRequest);
-    assertThat(signResponse.getErr()).isNotEmpty();
+    assertThrows(
+        io.grpc.StatusRuntimeException.class, () -> jwtStub.computeMacAndEncode(signRequest));
   }
 
   @Test

File: java_src/src/main/java/com/google/crypto/tink/mac/internal/ChunkedAesCmacImpl.java
Patch:
@@ -21,9 +21,9 @@
 import com.google.crypto.tink.mac.ChunkedMac;
 import com.google.crypto.tink.mac.ChunkedMacComputation;
 import com.google.crypto.tink.mac.ChunkedMacVerification;
+import com.google.crypto.tink.util.Bytes;
 import com.google.errorprone.annotations.Immutable;
 import java.security.GeneralSecurityException;
-import java.util.Arrays;
 
 /** AES-CMAC implementation of the ChunkedMac interface. */
 @Immutable
@@ -52,8 +52,7 @@ public ChunkedMacVerification createVerification(final byte[] tag)
     if (tag.length < key.getOutputPrefix().size()) {
       throw new GeneralSecurityException("Tag too short");
     }
-    if (!Arrays.equals(
-        Arrays.copyOf(tag, key.getOutputPrefix().size()), key.getOutputPrefix().toByteArray())) {
+    if (!key.getOutputPrefix().equals(Bytes.copyFrom(tag, 0, key.getOutputPrefix().size()))) {
       throw new GeneralSecurityException("Wrong tag prefix");
     }
     return new ChunkedAesCmacVerification(key, tag);

File: java_src/src/main/java/com/google/crypto/tink/Parameters.java
Patch:
@@ -34,8 +34,8 @@ public abstract class Parameters {
    *
    * <p>In Tink, certain keys change their behavior depending on the key id (for example, an {@link
    * Aead} object can prefix the ciphertext with the big endian encoding of the key id). If this is
-   * the case, such a key should require a unique id in {@link Key#getIdRequirement} and return true
-   * here.
+   * the case, such a key should require a unique id in {@link Key#getIdRequirementOrNull} and
+   * return true here.
    */
   public abstract boolean hasIdRequirement();
 }

File: java_src/src/main/java/com/google/crypto/tink/PrimitiveSet.java
Patch:
@@ -362,12 +362,14 @@ private Builder<P> addPrimitive(final P primitive, Keyset.Key key, boolean asPri
     }
 
     /* Adds a non-primary primitive.*/
+    @CanIgnoreReturnValue
     public Builder<P> addPrimitive(final P primitive, Keyset.Key key)
         throws GeneralSecurityException {
       return addPrimitive(primitive, key, false);
     }
 
     /* Adds the primary primitive. Should be called exactly once per PrimitiveSet.*/
+    @CanIgnoreReturnValue
     public Builder<P> addPrimaryPrimitive(final P primitive, Keyset.Key key)
         throws GeneralSecurityException {
       return addPrimitive(primitive, key, true);

File: java_src/src/main/java/com/google/crypto/tink/streamingaead/SeekableByteChannelDecrypter.java
Patch:
@@ -19,6 +19,7 @@
 import androidx.annotation.RequiresApi;
 import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.StreamingAead;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.channels.NonWritableChannelException;
@@ -132,6 +133,7 @@ public synchronized int read(ByteBuffer dst) throws IOException {
     }
   }
 
+  @CanIgnoreReturnValue
   @Override
   @GuardedBy("this")
   public synchronized SeekableByteChannel position(long newPosition) throws IOException {

File: java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeystoreKmsClient.java
Patch:
@@ -26,6 +26,7 @@
 import com.google.crypto.tink.KmsClient;
 import com.google.crypto.tink.subtle.Random;
 import com.google.crypto.tink.subtle.Validators;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
 import java.security.GeneralSecurityException;
 import java.security.KeyStore;
@@ -96,6 +97,7 @@ public Builder() {
       }
     }
 
+    @CanIgnoreReturnValue
     @RequiresApi(23)
     public Builder setKeyUri(String val) {
       if (val == null || !val.toLowerCase(Locale.US).startsWith(PREFIX)) {
@@ -106,6 +108,7 @@ public Builder setKeyUri(String val) {
     }
 
     /** This is for testing only */
+    @CanIgnoreReturnValue
     @RequiresApi(23)
     public Builder setKeyStore(KeyStore val) {
       if (val == null) {

File: java_src/src/main/java/com/google/crypto/tink/integration/gcpkms/GcpKmsClient.java
Patch:
@@ -30,6 +30,7 @@
 import com.google.crypto.tink.KmsClients;
 import com.google.crypto.tink.Version;
 import com.google.crypto.tink.subtle.Validators;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
@@ -110,6 +111,7 @@ public KmsClient withCredentials(String credentialPath) throws GeneralSecurityEx
   }
 
   /** Loads the provided credential with {@code GoogleCredential}. */
+  @CanIgnoreReturnValue
   public KmsClient withCredentials(GoogleCredential credential) {
     if (credential.createScopedRequired()) {
       credential = credential.createScoped(CloudKMSScopes.all());
@@ -122,6 +124,7 @@ public KmsClient withCredentials(GoogleCredential credential) {
   }
 
   /** Loads the provided credentials with {@code GoogleCredentials}. */
+  @CanIgnoreReturnValue
   public KmsClient withCredentials(GoogleCredentials credentials) throws GeneralSecurityException {
     if (credentials.createScopedRequired()) {
       credentials = credentials.createScoped(CloudKMSScopes.all());

File: java_src/src/main/java/com/google/crypto/tink/internal/KeyTester.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertWithMessage;
 
 import com.google.crypto.tink.Key;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
@@ -48,6 +49,7 @@
 public final class KeyTester {
   private final Map<String, List<Key>> equivalenceGroups = new HashMap<>();
 
+  @CanIgnoreReturnValue
   public KeyTester addEqualityGroup(String name, Key... keys) {
     if (equivalenceGroups.containsKey(name)) {
       throw new AssertionError("Group with name " + name + " already present");

File: java_src/src/main/java/com/google/crypto/tink/monitoring/MonitoringAnnotations.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.crypto.tink.monitoring;
 
 import com.google.crypto.tink.annotations.Alpha;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.Immutable;
 import java.util.Collections;
 import java.util.HashMap;
@@ -37,6 +38,7 @@ public final class MonitoringAnnotations {
   public static final class Builder {
     private HashMap<String, String> builderEntries = new HashMap<>();
 
+    @CanIgnoreReturnValue
     public Builder addAll(Map<String, String> newEntries) {
       if (builderEntries == null) {
         throw new IllegalStateException("addAll cannot be called after build()");
@@ -45,6 +47,7 @@ public Builder addAll(Map<String, String> newEntries) {
       return this;
     }
 
+    @CanIgnoreReturnValue
     public Builder add(String name, String value) {
       if (builderEntries == null) {
         throw new IllegalStateException("add cannot be called after build()");

File: apps/paymentmethodtoken/src/main/java/com/google/crypto/tink/apps/paymentmethodtoken/GooglePaymentsPublicKeysManager.java
Patch:
@@ -19,6 +19,7 @@
 import com.google.api.client.http.HttpTransport;
 import com.google.api.client.http.javanet.NetHttpTransport;
 import com.google.crypto.tink.util.KeysDownloader;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.concurrent.Executor;
@@ -111,6 +112,7 @@ public static class Builder {
     private HttpTransport httpTransport = DEFAULT_HTTP_TRANSPORT;
     private String keysUrl = KEYS_URL_PRODUCTION;
 
+    @CanIgnoreReturnValue
     public Builder setKeysUrl(String keysUrl) {
       this.keysUrl = keysUrl;
       return this;
@@ -122,6 +124,7 @@ public Builder setKeysUrl(String keysUrl) {
      * <p>You generally should not need to set a custom transport as the default transport {@link
      * GooglePaymentsPublicKeysManager#DEFAULT_HTTP_TRANSPORT} should be suited for most use cases.
      */
+    @CanIgnoreReturnValue
     public Builder setHttpTransport(HttpTransport httpTransport) {
       this.httpTransport = httpTransport;
       return this;

File: java_src/src/main/java/com/google/crypto/tink/mac/AesCmacKeyManager.java
Patch:
@@ -160,6 +160,7 @@ public Map<String, KeyFactory.KeyFormat<AesCmacKeyFormat>> keyFormats()
 
   public static void register(boolean newKeyAllowed) throws GeneralSecurityException {
     Registry.registerKeyManager(new AesCmacKeyManager(), newKeyAllowed);
+    AesCmacProtoSerialization.register();
   }
 
   /**

File: java_src/src/main/java/com/google/crypto/tink/mac/AesCmacKeyManager.java
Patch:
@@ -160,6 +160,7 @@ public Map<String, KeyFactory.KeyFormat<AesCmacKeyFormat>> keyFormats()
 
   public static void register(boolean newKeyAllowed) throws GeneralSecurityException {
     Registry.registerKeyManager(new AesCmacKeyManager(), newKeyAllowed);
+    AesCmacProtoSerialization.register();
   }
 
   /**

File: java_src/src/main/java/com/google/crypto/tink/KeysetHandle.java
Patch:
@@ -470,7 +470,7 @@ public KeysetHandle getPublicKeysetHandle() throws GeneralSecurityException {
     Keyset.Builder keysetBuilder = Keyset.newBuilder();
     for (Keyset.Key key : keyset.getKeyList()) {
       KeyData keyData = createPublicKeyData(key.getKeyData());
-      keysetBuilder.addKey(Keyset.Key.newBuilder().mergeFrom(key).setKeyData(keyData).build());
+      keysetBuilder.addKey(key.toBuilder().setKeyData(keyData).build());
     }
     keysetBuilder.setPrimaryKeyId(keyset.getPrimaryKeyId());
     return new KeysetHandle(keysetBuilder.build());

File: java_src/src/test/java/com/google/crypto/tink/signature/PublicKeyVerifyIntegrationTest.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.crypto.tink.signature;
 
 import static org.junit.Assert.assertThrows;
-import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.PublicKeySign;
@@ -132,7 +131,7 @@ public void testMultipleKeys() throws Exception {
         try {
           verifier.verify(sig, plaintext);
         } catch (GeneralSecurityException ex) {
-          fail("Valid signature, should not throw exception: " + k);
+          throw new AssertionError("Valid signature, should not throw exception: " + k, ex);
         }
       }
 

File: java_src/src/main/java/com/google/crypto/tink/aead/AeadFactory.java
Patch:
@@ -41,7 +41,6 @@
 public final class AeadFactory {
   /**
    * @return a Aead primitive from a {@code keysetHandle}.
-   * @throws GeneralSecurityException
    * @deprecated Use {@code keysetHandle.GetPrimitive(Aead.class)} after registering the {@code
    *     AeadWrapper} instead.
    */

File: java_src/src/main/java/com/google/crypto/tink/daead/DeterministicAeadFactory.java
Patch:
@@ -40,7 +40,6 @@
 public final class DeterministicAeadFactory {
   /**
    * @return a DeterministicAead primitive from a {@code keysetHandle}.
-   * @throws GeneralSecurityException
    * @deprecated Use {@code keysetHandle.GetPrimitive(DeterministicAead.class)} after registering
    *     the {@code DeterministicAeadWrapper} instead.
    */

File: java_src/src/main/java/com/google/crypto/tink/hybrid/HybridDecryptFactory.java
Patch:
@@ -39,7 +39,6 @@
 public final class HybridDecryptFactory {
   /**
    * @return a HybridDecrypt primitive from a {@code keysetHandle}.
-   * @throws GeneralSecurityException
    * @deprecated Use {@code keysetHandle.GetPrimitive(HybridDecrypt.class)} after registering the
    *     {@code HybridDecryptWrapper} instead.
    */

File: java_src/src/main/java/com/google/crypto/tink/mac/MacFactory.java
Patch:
@@ -42,7 +42,6 @@
 public final class MacFactory {
   /**
    * @return a Mac primitive from a {@code keysetHandle}.
-   * @throws GeneralSecurityException
    * @deprecated Use {@code keysetHandle.GetPrimitive(Mac.class)} after registering the {@code
    *     MacWrapper} instead.
    */

File: java_src/src/main/java/com/google/crypto/tink/signature/PublicKeySignFactory.java
Patch:
@@ -40,7 +40,6 @@
 public final class PublicKeySignFactory {
   /**
    * @return a PublicKeySign primitive from a {@code keysetHandle}.
-   * @throws GeneralSecurityException
    * @deprecated Use {@code keysetHandle.GetPrimitive(PublicKeySign.class)} after registering the
    *     {@code PublicKeySignWrapper} instead.
    */

File: java_src/src/main/java/com/google/crypto/tink/signature/PublicKeyVerifyFactory.java
Patch:
@@ -40,7 +40,6 @@
 public final class PublicKeyVerifyFactory {
   /**
    * @return a PublicKeyVerify primitive from a {@code keysetHandle}.
-   * @throws GeneralSecurityException
    * @deprecated Use {@code keysetHandle.GetPrimitive(PublicKeyVerify.class)} after registering the
    *     {@code PublicKeyVerifyWrapper} instead.
    */

File: java_src/src/main/java/com/google/crypto/tink/streamingaead/StreamingAeadFactory.java
Patch:
@@ -40,7 +40,6 @@
 public final class StreamingAeadFactory {
   /**
    * @return a StreamingAead primitive from a {@code keysetHandle}.
-   * @throws GeneralSecurityException
    */
   public static StreamingAead getPrimitive(KeysetHandle keysetHandle)
       throws GeneralSecurityException {

File: java_src/src/main/java/com/google/crypto/tink/Registry.java
Patch:
@@ -34,6 +34,7 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.logging.Logger;
+import javax.annotation.Nullable;
 
 /**
  * A global container of key managers and catalogues.
@@ -816,6 +817,7 @@ static synchronized Map<String, KeyTemplate> keyTemplateMap() {
    * primitive of type {@code wrappedPrimitive}. Returns {@code null} if no wrapper for this
    * primitive has been registered.
    */
+  @Nullable
   public static Class<?> getInputPrimitive(Class<?> wrappedPrimitive) {
     PrimitiveWrapper<?, ?> wrapper = primitiveWrapperMap.get(wrappedPrimitive);
     if (wrapper == null) {

File: java_src/src/main/java/com/google/crypto/tink/PemKeyType.java
Patch:
@@ -30,6 +30,7 @@
 import java.security.spec.ECParameterSpec;
 import java.security.spec.PKCS8EncodedKeySpec;
 import java.security.spec.X509EncodedKeySpec;
+import javax.annotation.Nullable;
 
 /** PEM key types that Tink supports */
 public enum PemKeyType {
@@ -81,6 +82,7 @@ public enum PemKeyType {
    *
    * @return a {@link Key} or null if the reader doesn't contain a valid PEM.
    */
+  @Nullable
   public Key readKey(BufferedReader reader) throws IOException {
     String line = reader.readLine();
     while (line != null && !line.startsWith(BEGIN)) {

File: java_src/src/main/java/com/google/crypto/tink/subtle/PemKeyType.java
Patch:
@@ -27,6 +27,7 @@
 import java.security.spec.ECParameterSpec;
 import java.security.spec.PKCS8EncodedKeySpec;
 import java.security.spec.X509EncodedKeySpec;
+import javax.annotation.Nullable;
 
 /**
  * PEM key types that Tink supports
@@ -83,6 +84,7 @@ public enum PemKeyType {
    *
    * @return a {@link Key} or null if the reader doesn't contain a valid PEM.
    */
+  @Nullable
   public Key readKey(BufferedReader reader) throws IOException {
     String line = reader.readLine();
     while (line != null && !line.startsWith(BEGIN)) {

File: testing/java_src/java/com/google/crypto/tink/testing/JwtServiceImpl.java
Patch:
@@ -43,10 +43,10 @@
 import com.google.crypto.tink.testing.proto.JwtVerifyRequest;
 import com.google.crypto.tink.testing.proto.JwtVerifyResponse;
 import com.google.crypto.tink.testing.proto.NullValue;
-import com.google.crypto.tink.testing.proto.StringValue;
-import com.google.crypto.tink.testing.proto.Timestamp;
 import com.google.protobuf.ByteString;
 import com.google.protobuf.InvalidProtocolBufferException;
+import com.google.protobuf.StringValue;
+import com.google.protobuf.Timestamp;
 import io.grpc.Status;
 import io.grpc.stub.StreamObserver;
 import java.io.ByteArrayOutputStream;

File: testing/java_src/javatests/com/google/crypto/tink/testing/JwtServiceImplTest.java
Patch:
@@ -43,9 +43,9 @@
 import com.google.crypto.tink.testing.proto.KeysetPublicRequest;
 import com.google.crypto.tink.testing.proto.KeysetPublicResponse;
 import com.google.crypto.tink.testing.proto.NullValue;
-import com.google.crypto.tink.testing.proto.StringValue;
-import com.google.crypto.tink.testing.proto.Timestamp;
 import com.google.protobuf.ByteString;
+import com.google.protobuf.StringValue;
+import com.google.protobuf.Timestamp;
 import io.grpc.ManagedChannel;
 import io.grpc.Server;
 import io.grpc.inprocess.InProcessChannelBuilder;

File: java_src/src/test/java/com/google/crypto/tink/mac/HmacKeyManagerTest.java
Patch:
@@ -142,7 +142,7 @@ public void createKey_checkValues() throws Exception {
   public void createKey_multipleTimes() throws Exception {
     HmacKeyFormat keyFormat = makeHmacKeyFormat(16, 10, HashType.SHA256);
     int numKeys = 100;
-    Set<String> keys = new TreeSet<String>();
+    Set<String> keys = new TreeSet<>();
     for (int i = 0; i < numKeys; ++i) {
       keys.add(TestUtil.hexEncode(factory.createKey(keyFormat).getKeyValue().toByteArray()));
     }

File: java_src/src/main/java/com/google/crypto/tink/internal/KeyTester.java
Patch:
@@ -66,8 +66,8 @@ private static void testSingleKey(String keyIdentifier, Key key) {
     } else {
       assertWithMessage(
               keyIdentifier
-                  + " has a format without IdRequirement, but getIdRequirementOrNull returns an"
-                  + " optional with value")
+                  + " has a format without IdRequirement, but getIdRequirementOrNull returns a"
+                  + " non-null value")
           .that(key.getIdRequirementOrNull())
           .isNull();
     }

File: java_src/src/main/java/com/google/crypto/tink/internal/SerializationRegistry.java
Patch:
@@ -63,7 +63,8 @@ public <KeyT extends Key, SerializationT extends Serialization> Builder register
         KeySerializer<?, ?> existingSerializer = keySerializerMap.get(index);
         if (!existingSerializer.equals(serializer) || !serializer.equals(existingSerializer)) {
           throw new GeneralSecurityException(
-              "Attempt to register non-equal parser for already existing object of type: " + index);
+              "Attempt to register non-equal serializer for already existing object of type: "
+                  + index);
         }
       } else {
         keySerializerMap.put(index, serializer);

File: java_src/src/main/java/com/google/crypto/tink/internal/KeyParser.java
Patch:
@@ -94,6 +94,9 @@ public final Class<SerializationT> getSerializationClass() {
    *       KeyParser.create(MyClass::parse, objectIdentifier, MySerialization.class);
    * }</pre>
    *
+   * Note that calling this function twice will result in objects which are not equal according to
+   * {@code Object.equals}, and hence cannot be used to re-register a previously registered object.
+   *
    * @param function The function used to parse a Key
    * @param objectIdentifier The identifier to be returned by {@link #getObjectIdentifier}
    * @param serializationClass The class object corresponding to {@code SerializationT}

File: java_src/src/main/java/com/google/crypto/tink/KeyFormat.java
Patch:
@@ -33,7 +33,7 @@ public abstract class KeyFormat {
    *
    * <p>In Tink, certain keys change their behavior depending on the key id (for example, an {@link
    * Aead} object can prefix the ciphertext with the big endian encoding of the key id). If this is
-   * the case, such a key should require a unique id in {@link Key#getKeyRequirement} and return
+   * the case, such a key should require a unique id in {@link Key#getIdRequirement} and return
    * true here.
    */
   public abstract boolean hasIdRequirement();

File: java_src/src/main/java/com/google/crypto/tink/aead/AesCtrHmacAeadKeyManager.java
Patch:
@@ -22,6 +22,7 @@
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.mac.HmacKeyManager;
 import com.google.crypto.tink.proto.AesCtrHmacAeadKey;
 import com.google.crypto.tink.proto.AesCtrHmacAeadKeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/aead/AesCtrKeyManager.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.AesCtrKey;
 import com.google.crypto.tink.proto.AesCtrKeyFormat;
 import com.google.crypto.tink.proto.AesCtrParams;

File: java_src/src/main/java/com/google/crypto/tink/aead/AesEaxKeyManager.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.crypto.tink.KeyTemplate;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.AesEaxKey;
 import com.google.crypto.tink.proto.AesEaxKeyFormat;
 import com.google.crypto.tink.proto.AesEaxParams;

File: java_src/src/main/java/com/google/crypto/tink/aead/AesGcmKeyManager.java
Patch:
@@ -21,6 +21,7 @@
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.AesGcmKey;
 import com.google.crypto.tink.proto.AesGcmKeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
@@ -45,7 +46,7 @@ public final class AesGcmKeyManager extends KeyTypeManager<AesGcmKey> {
   AesGcmKeyManager() {
     super(
         AesGcmKey.class,
-        new KeyTypeManager.PrimitiveFactory<Aead, AesGcmKey>(Aead.class) {
+        new PrimitiveFactory<Aead, AesGcmKey>(Aead.class) {
           @Override
           public Aead getPrimitive(AesGcmKey key) throws GeneralSecurityException {
             return new AesGcmJce(key.getKeyValue().toByteArray());

File: java_src/src/main/java/com/google/crypto/tink/aead/AesGcmSivKeyManager.java
Patch:
@@ -21,6 +21,7 @@
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.aead.subtle.AesGcmSiv;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.AesGcmSivKey;
 import com.google.crypto.tink.proto.AesGcmSivKeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/main/java/com/google/crypto/tink/aead/ChaCha20Poly1305KeyManager.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.crypto.tink.KeyTemplate;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.ChaCha20Poly1305Key;
 import com.google.crypto.tink.proto.ChaCha20Poly1305KeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/main/java/com/google/crypto/tink/aead/KmsAeadKeyManager.java
Patch:
@@ -22,6 +22,7 @@
 import com.google.crypto.tink.KmsClients;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.KmsAeadKey;
 import com.google.crypto.tink.proto.KmsAeadKeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/aead/KmsEnvelopeAeadKeyManager.java
Patch:
@@ -22,6 +22,7 @@
 import com.google.crypto.tink.KmsClients;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.KmsEnvelopeAeadKey;
 import com.google.crypto.tink.proto.KmsEnvelopeAeadKeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/aead/XChaCha20Poly1305KeyManager.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.crypto.tink.KeyTemplate;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.XChaCha20Poly1305Key;
 import com.google.crypto.tink.proto.XChaCha20Poly1305KeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/daead/AesSivKeyManager.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.crypto.tink.KeyTemplate;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.AesSivKey;
 import com.google.crypto.tink.proto.AesSivKeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/main/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPublicKeyManager.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.crypto.tink.HybridEncrypt;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.EciesAeadHkdfParams;
 import com.google.crypto.tink.proto.EciesAeadHkdfPublicKey;
 import com.google.crypto.tink.proto.EciesHkdfKemParams;
@@ -40,8 +41,7 @@ class EciesAeadHkdfPublicKeyManager extends KeyTypeManager<EciesAeadHkdfPublicKe
   public EciesAeadHkdfPublicKeyManager() {
     super(
         EciesAeadHkdfPublicKey.class,
-        new KeyTypeManager.PrimitiveFactory<HybridEncrypt, EciesAeadHkdfPublicKey>(
-            HybridEncrypt.class) {
+        new PrimitiveFactory<HybridEncrypt, EciesAeadHkdfPublicKey>(HybridEncrypt.class) {
           @Override
           public HybridEncrypt getPrimitive(EciesAeadHkdfPublicKey recipientKeyProto)
               throws GeneralSecurityException {

File: java_src/src/main/java/com/google/crypto/tink/hybrid/internal/HpkePublicKeyManager.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.crypto.tink.HybridEncrypt;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.HpkePublicKey;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.subtle.Validators;
@@ -31,7 +32,7 @@ public final class HpkePublicKeyManager extends KeyTypeManager<HpkePublicKey> {
   public HpkePublicKeyManager() {
     super(
         HpkePublicKey.class,
-        new KeyTypeManager.PrimitiveFactory<HybridEncrypt, HpkePublicKey>(HybridEncrypt.class) {
+        new PrimitiveFactory<HybridEncrypt, HpkePublicKey>(HybridEncrypt.class) {
           @Override
           public HybridEncrypt getPrimitive(HpkePublicKey recipientPublicKey)
               throws GeneralSecurityException {

File: java_src/src/main/java/com/google/crypto/tink/internal/PrivateKeyTypeManager.java
Patch:
@@ -33,7 +33,7 @@ public abstract class PrivateKeyTypeManager<
   protected PrivateKeyTypeManager(
       Class<KeyProtoT> clazz,
       Class<PublicKeyProtoT> publicKeyClazz,
-      KeyTypeManager.PrimitiveFactory<?, KeyProtoT>... factories) {
+      PrimitiveFactory<?, KeyProtoT>... factories) {
     super(clazz, factories);
     this.publicKeyClazz = publicKeyClazz;
   }

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtEcdsaVerifyKeyManager.java
Patch:
@@ -18,6 +18,7 @@
 import static java.nio.charset.StandardCharsets.US_ASCII;
 
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.JwtEcdsaAlgorithm;
 import com.google.crypto.tink.proto.JwtEcdsaPublicKey;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
@@ -75,7 +76,7 @@ static final void validateEcdsaAlgorithm(JwtEcdsaAlgorithm algorithm)
   }
 
   private static class JwtPublicKeyVerifyFactory
-      extends KeyTypeManager.PrimitiveFactory<JwtPublicKeyVerifyInternal, JwtEcdsaPublicKey> {
+      extends PrimitiveFactory<JwtPublicKeyVerifyInternal, JwtEcdsaPublicKey> {
     public JwtPublicKeyVerifyFactory() {
       super(JwtPublicKeyVerifyInternal.class);
     }

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtHmacKeyManager.java
Patch:
@@ -21,6 +21,7 @@
 import com.google.crypto.tink.KeyTemplate;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.JwtHmacAlgorithm;
 import com.google.crypto.tink.proto.JwtHmacKey;
 import com.google.crypto.tink.proto.JwtHmacKeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtRsaSsaPkcs1VerifyKeyManager.java
Patch:
@@ -18,6 +18,7 @@
 import static java.nio.charset.StandardCharsets.US_ASCII;
 
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.JwtRsaSsaPkcs1Algorithm;
 import com.google.crypto.tink.proto.JwtRsaSsaPkcs1PublicKey;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
@@ -69,7 +70,7 @@ private static final RSAPublicKey createPublicKey(JwtRsaSsaPkcs1PublicKey keyPro
   public JwtRsaSsaPkcs1VerifyKeyManager() {
     super(
         JwtRsaSsaPkcs1PublicKey.class,
-        new KeyTypeManager.PrimitiveFactory<JwtPublicKeyVerifyInternal, JwtRsaSsaPkcs1PublicKey>(
+        new PrimitiveFactory<JwtPublicKeyVerifyInternal, JwtRsaSsaPkcs1PublicKey>(
             JwtPublicKeyVerifyInternal.class) {
           @Override
           public JwtPublicKeyVerifyInternal getPrimitive(JwtRsaSsaPkcs1PublicKey keyProto)

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtRsaSsaPssVerifyKeyManager.java
Patch:
@@ -18,6 +18,7 @@
 import static java.nio.charset.StandardCharsets.US_ASCII;
 
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.JwtRsaSsaPssAlgorithm;
 import com.google.crypto.tink.proto.JwtRsaSsaPssPublicKey;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
@@ -83,7 +84,7 @@ private static final RSAPublicKey createPublicKey(JwtRsaSsaPssPublicKey keyProto
   public JwtRsaSsaPssVerifyKeyManager() {
     super(
         JwtRsaSsaPssPublicKey.class,
-        new KeyTypeManager.PrimitiveFactory<JwtPublicKeyVerifyInternal, JwtRsaSsaPssPublicKey>(
+        new PrimitiveFactory<JwtPublicKeyVerifyInternal, JwtRsaSsaPssPublicKey>(
             JwtPublicKeyVerifyInternal.class) {
           @Override
           public JwtPublicKeyVerifyInternal getPrimitive(JwtRsaSsaPssPublicKey keyProto)

File: java_src/src/main/java/com/google/crypto/tink/mac/AesCmacKeyManager.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.crypto.tink.Mac;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.AesCmacKey;
 import com.google.crypto.tink.proto.AesCmacKeyFormat;
 import com.google.crypto.tink.proto.AesCmacParams;

File: java_src/src/main/java/com/google/crypto/tink/mac/HmacKeyManager.java
Patch:
@@ -21,6 +21,7 @@
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.proto.HmacKey;
 import com.google.crypto.tink.proto.HmacKeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/prf/AesCmacPrfKeyManager.java
Patch:
@@ -19,6 +19,7 @@
 import com.google.crypto.tink.KeyTemplate;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.AesCmacPrfKey;
 import com.google.crypto.tink.proto.AesCmacPrfKeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/main/java/com/google/crypto/tink/prf/HkdfPrfKeyManager.java
Patch:
@@ -18,6 +18,7 @@
 import com.google.crypto.tink.KeyTemplate;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.proto.HkdfPrfKey;
 import com.google.crypto.tink.proto.HkdfPrfKeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/prf/HmacPrfKeyManager.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.proto.HmacPrfKey;
 import com.google.crypto.tink.proto.HmacPrfKeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/signature/EcdsaVerifyKeyManager.java
Patch:
@@ -19,6 +19,7 @@
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.EcdsaPublicKey;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.signature.internal.SigUtil;
@@ -39,8 +40,7 @@ class EcdsaVerifyKeyManager extends KeyTypeManager<EcdsaPublicKey> {
   public EcdsaVerifyKeyManager() {
     super(
         EcdsaPublicKey.class,
-        new KeyTypeManager.PrimitiveFactory<PublicKeyVerify, EcdsaPublicKey>(
-            PublicKeyVerify.class) {
+        new PrimitiveFactory<PublicKeyVerify, EcdsaPublicKey>(PublicKeyVerify.class) {
           @Override
           public PublicKeyVerify getPrimitive(EcdsaPublicKey keyProto)
               throws GeneralSecurityException {

File: java_src/src/main/java/com/google/crypto/tink/signature/Ed25519PublicKeyManager.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.Ed25519PublicKey;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.subtle.Ed25519Verify;
@@ -35,8 +36,7 @@ class Ed25519PublicKeyManager extends KeyTypeManager<Ed25519PublicKey> {
   public Ed25519PublicKeyManager() {
     super(
         Ed25519PublicKey.class,
-        new KeyTypeManager.PrimitiveFactory<PublicKeyVerify, Ed25519PublicKey>(
-            PublicKeyVerify.class) {
+        new PrimitiveFactory<PublicKeyVerify, Ed25519PublicKey>(PublicKeyVerify.class) {
           @Override
           public PublicKeyVerify getPrimitive(Ed25519PublicKey keyProto) {
             return new Ed25519Verify(keyProto.getKeyValue().toByteArray());

File: java_src/src/main/java/com/google/crypto/tink/signature/RsaSsaPkcs1VerifyKeyManager.java
Patch:
@@ -19,6 +19,7 @@
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.RsaSsaPkcs1PublicKey;
 import com.google.crypto.tink.signature.internal.SigUtil;
@@ -41,8 +42,7 @@ class RsaSsaPkcs1VerifyKeyManager extends KeyTypeManager<RsaSsaPkcs1PublicKey> {
   public RsaSsaPkcs1VerifyKeyManager() {
     super(
         RsaSsaPkcs1PublicKey.class,
-        new KeyTypeManager.PrimitiveFactory<PublicKeyVerify, RsaSsaPkcs1PublicKey>(
-            PublicKeyVerify.class) {
+        new PrimitiveFactory<PublicKeyVerify, RsaSsaPkcs1PublicKey>(PublicKeyVerify.class) {
           @Override
           public PublicKeyVerify getPrimitive(RsaSsaPkcs1PublicKey keyProto)
               throws GeneralSecurityException {

File: java_src/src/main/java/com/google/crypto/tink/signature/RsaSsaPssVerifyKeyManager.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.RsaSsaPssParams;
 import com.google.crypto.tink.proto.RsaSsaPssPublicKey;
@@ -41,8 +42,7 @@ class RsaSsaPssVerifyKeyManager extends KeyTypeManager<RsaSsaPssPublicKey> {
   public RsaSsaPssVerifyKeyManager() {
     super(
         RsaSsaPssPublicKey.class,
-        new KeyTypeManager.PrimitiveFactory<PublicKeyVerify, RsaSsaPssPublicKey>(
-            PublicKeyVerify.class) {
+        new PrimitiveFactory<PublicKeyVerify, RsaSsaPssPublicKey>(PublicKeyVerify.class) {
           @Override
           public PublicKeyVerify getPrimitive(RsaSsaPssPublicKey keyProto)
               throws GeneralSecurityException {

File: java_src/src/main/java/com/google/crypto/tink/streamingaead/AesCtrHmacStreamingKeyManager.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.StreamingAead;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.AesCtrHmacStreamingKey;
 import com.google.crypto.tink.proto.AesCtrHmacStreamingKeyFormat;
 import com.google.crypto.tink.proto.AesCtrHmacStreamingParams;

File: java_src/src/main/java/com/google/crypto/tink/streamingaead/AesGcmHkdfStreamingKeyManager.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.StreamingAead;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.AesGcmHkdfStreamingKey;
 import com.google.crypto.tink.proto.AesGcmHkdfStreamingKeyFormat;
 import com.google.crypto.tink.proto.AesGcmHkdfStreamingParams;

File: java_src/src/test/java/com/google/crypto/tink/KeyManagerImplTest.java
Patch:
@@ -20,6 +20,7 @@
 import static org.junit.Assert.assertThrows;
 
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.proto.AesGcmKey;
 import com.google.crypto.tink.proto.AesGcmKeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/test/java/com/google/crypto/tink/RegistryTest.java
Patch:
@@ -29,6 +29,7 @@
 import com.google.crypto.tink.config.TinkConfig;
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
 import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrimitiveFactory;
 import com.google.crypto.tink.internal.PrivateKeyTypeManager;
 import com.google.crypto.tink.mac.MacConfig;
 import com.google.crypto.tink.mac.MacKeyTemplates;

File: java_src/src/main/java/com/google/crypto/tink/aead/AesGcmKeyManager.java
Patch:
@@ -45,7 +45,7 @@ public final class AesGcmKeyManager extends KeyTypeManager<AesGcmKey> {
   AesGcmKeyManager() {
     super(
         AesGcmKey.class,
-        new PrimitiveFactory<Aead, AesGcmKey>(Aead.class) {
+        new KeyTypeManager.PrimitiveFactory<Aead, AesGcmKey>(Aead.class) {
           @Override
           public Aead getPrimitive(AesGcmKey key) throws GeneralSecurityException {
             return new AesGcmJce(key.getKeyValue().toByteArray());

File: java_src/src/main/java/com/google/crypto/tink/JsonKeysetWriter.java
Patch:
@@ -148,7 +148,7 @@ private JsonObject toJson(KeysetInfo.KeyInfo keyInfo) {
     JsonObject json = new JsonObject();
     json.addProperty("typeUrl", keyInfo.getTypeUrl());
     json.addProperty("status", keyInfo.getStatus().name());
-    json.addProperty("keyId", keyInfo.getKeyId());
+    json.addProperty("keyId", toUnsignedLong(keyInfo.getKeyId()));
     json.addProperty("outputPrefixType", keyInfo.getOutputPrefixType().name());
     return json;
   }

File: java_src/src/main/java/com/google/crypto/tink/hybrid/HybridEncryptWrapper.java
Patch:
@@ -40,6 +40,9 @@ public WrappedHybridEncrypt(final PrimitiveSet<HybridEncrypt> primitives) {
     @Override
     public byte[] encrypt(final byte[] plaintext, final byte[] contextInfo)
         throws GeneralSecurityException {
+      if (primitives.getPrimary() == null) {
+        throw new GeneralSecurityException("keyset without primary key");
+      }
       return Bytes.concat(
           primitives.getPrimary().getIdentifier(),
           primitives.getPrimary().getPrimitive().encrypt(plaintext, contextInfo));

File: java_src/src/main/java/com/google/crypto/tink/KeyManagerImpl.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.crypto.tink;
 
 import com.google.crypto.tink.annotations.Alpha;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.KeyData;
 import com.google.protobuf.ByteString;
 import com.google.protobuf.InvalidProtocolBufferException;

File: java_src/src/main/java/com/google/crypto/tink/PrivateKeyManagerImpl.java
Patch:
@@ -17,6 +17,8 @@
 package com.google.crypto.tink;
 
 import com.google.crypto.tink.annotations.Alpha;
+import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrivateKeyTypeManager;
 import com.google.crypto.tink.proto.KeyData;
 import com.google.protobuf.ByteString;
 import com.google.protobuf.InvalidProtocolBufferException;

File: java_src/src/main/java/com/google/crypto/tink/Registry.java
Patch:
@@ -17,6 +17,8 @@
 package com.google.crypto.tink;
 
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
+import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrivateKeyTypeManager;
 import com.google.crypto.tink.proto.KeyData;
 import com.google.protobuf.ByteString;
 import com.google.protobuf.InvalidProtocolBufferException;

File: java_src/src/main/java/com/google/crypto/tink/aead/AesCtrHmacAeadKeyManager.java
Patch:
@@ -18,10 +18,10 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Mac;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.mac.HmacKeyManager;
 import com.google.crypto.tink.proto.AesCtrHmacAeadKey;
 import com.google.crypto.tink.proto.AesCtrHmacAeadKeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/aead/AesCtrKeyManager.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.crypto.tink.aead;
 
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesCtrKey;
 import com.google.crypto.tink.proto.AesCtrKeyFormat;
 import com.google.crypto.tink.proto.AesCtrParams;

File: java_src/src/main/java/com/google/crypto/tink/aead/AesEaxKeyManager.java
Patch:
@@ -18,8 +18,8 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesEaxKey;
 import com.google.crypto.tink.proto.AesEaxKeyFormat;
 import com.google.crypto.tink.proto.AesEaxParams;

File: java_src/src/main/java/com/google/crypto/tink/aead/AesGcmKeyManager.java
Patch:
@@ -18,9 +18,9 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesGcmKey;
 import com.google.crypto.tink.proto.AesGcmKeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/main/java/com/google/crypto/tink/aead/AesGcmSivKeyManager.java
Patch:
@@ -18,9 +18,9 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.aead.subtle.AesGcmSiv;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesGcmSivKey;
 import com.google.crypto.tink.proto.AesGcmSivKeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/main/java/com/google/crypto/tink/aead/ChaCha20Poly1305KeyManager.java
Patch:
@@ -18,8 +18,8 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.ChaCha20Poly1305Key;
 import com.google.crypto.tink.proto.ChaCha20Poly1305KeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/main/java/com/google/crypto/tink/aead/KmsAeadKeyManager.java
Patch:
@@ -18,10 +18,10 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.KmsClient;
 import com.google.crypto.tink.KmsClients;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.KmsAeadKey;
 import com.google.crypto.tink.proto.KmsAeadKeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/aead/KmsEnvelopeAeadKeyManager.java
Patch:
@@ -18,10 +18,10 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.KmsClient;
 import com.google.crypto.tink.KmsClients;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.KmsEnvelopeAeadKey;
 import com.google.crypto.tink.proto.KmsEnvelopeAeadKeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/aead/XChaCha20Poly1305KeyManager.java
Patch:
@@ -18,8 +18,8 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.XChaCha20Poly1305Key;
 import com.google.crypto.tink.proto.XChaCha20Poly1305KeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/daead/AesSivKeyManager.java
Patch:
@@ -18,8 +18,8 @@
 
 import com.google.crypto.tink.DeterministicAead;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesSivKey;
 import com.google.crypto.tink.proto.AesSivKeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/main/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPrivateKeyManager.java
Patch:
@@ -19,11 +19,11 @@
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.KeyTemplate;
 import com.google.crypto.tink.KeyTemplates;
-import com.google.crypto.tink.KeyTypeManager;
-import com.google.crypto.tink.PrivateKeyTypeManager;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.aead.AesCtrHmacAeadKeyManager;
 import com.google.crypto.tink.aead.AesGcmKeyManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrivateKeyTypeManager;
 import com.google.crypto.tink.proto.EcPointFormat;
 import com.google.crypto.tink.proto.EciesAeadDemParams;
 import com.google.crypto.tink.proto.EciesAeadHkdfKeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPublicKeyManager.java
Patch:
@@ -17,7 +17,7 @@
 package com.google.crypto.tink.hybrid;
 
 import com.google.crypto.tink.HybridEncrypt;
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.EciesAeadHkdfParams;
 import com.google.crypto.tink.proto.EciesAeadHkdfPublicKey;
 import com.google.crypto.tink.proto.EciesHkdfKemParams;

File: java_src/src/main/java/com/google/crypto/tink/hybrid/internal/HpkePrivateKeyManager.java
Patch:
@@ -18,9 +18,9 @@
 
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
-import com.google.crypto.tink.PrivateKeyTypeManager;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrivateKeyTypeManager;
 import com.google.crypto.tink.proto.HpkeAead;
 import com.google.crypto.tink.proto.HpkeKdf;
 import com.google.crypto.tink.proto.HpkeKem;

File: java_src/src/main/java/com/google/crypto/tink/hybrid/internal/HpkePublicKeyManager.java
Patch:
@@ -17,7 +17,7 @@
 package com.google.crypto.tink.hybrid.internal;
 
 import com.google.crypto.tink.HybridEncrypt;
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.HpkePublicKey;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.subtle.Validators;

File: java_src/src/main/java/com/google/crypto/tink/internal/PrivateKeyTypeManager.java
Patch:
@@ -14,7 +14,7 @@
 //
 ////////////////////////////////////////////////////////////////////////////////
 
-package com.google.crypto.tink;
+package com.google.crypto.tink.internal;
 
 import com.google.crypto.tink.annotations.Alpha;
 import com.google.protobuf.MessageLite;

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtEcdsaSignKeyManager.java
Patch:
@@ -18,9 +18,9 @@
 import static java.nio.charset.StandardCharsets.US_ASCII;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
-import com.google.crypto.tink.PrivateKeyTypeManager;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrivateKeyTypeManager;
 import com.google.crypto.tink.proto.JwtEcdsaAlgorithm;
 import com.google.crypto.tink.proto.JwtEcdsaKeyFormat;
 import com.google.crypto.tink.proto.JwtEcdsaPrivateKey;

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtEcdsaVerifyKeyManager.java
Patch:
@@ -17,7 +17,7 @@
 
 import static java.nio.charset.StandardCharsets.US_ASCII;
 
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.JwtEcdsaAlgorithm;
 import com.google.crypto.tink.proto.JwtEcdsaPublicKey;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtHmacKeyManager.java
Patch:
@@ -19,8 +19,8 @@
 import static java.nio.charset.StandardCharsets.US_ASCII;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.JwtHmacAlgorithm;
 import com.google.crypto.tink.proto.JwtHmacKey;
 import com.google.crypto.tink.proto.JwtHmacKeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtRsaSsaPkcs1SignKeyManager.java
Patch:
@@ -18,9 +18,9 @@
 import static java.nio.charset.StandardCharsets.US_ASCII;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
-import com.google.crypto.tink.PrivateKeyTypeManager;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrivateKeyTypeManager;
 import com.google.crypto.tink.proto.JwtRsaSsaPkcs1Algorithm;
 import com.google.crypto.tink.proto.JwtRsaSsaPkcs1KeyFormat;
 import com.google.crypto.tink.proto.JwtRsaSsaPkcs1PrivateKey;

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtRsaSsaPkcs1VerifyKeyManager.java
Patch:
@@ -17,7 +17,7 @@
 
 import static java.nio.charset.StandardCharsets.US_ASCII;
 
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.JwtRsaSsaPkcs1Algorithm;
 import com.google.crypto.tink.proto.JwtRsaSsaPkcs1PublicKey;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtRsaSsaPssSignKeyManager.java
Patch:
@@ -18,9 +18,9 @@
 import static java.nio.charset.StandardCharsets.US_ASCII;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
-import com.google.crypto.tink.PrivateKeyTypeManager;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrivateKeyTypeManager;
 import com.google.crypto.tink.proto.JwtRsaSsaPssAlgorithm;
 import com.google.crypto.tink.proto.JwtRsaSsaPssKeyFormat;
 import com.google.crypto.tink.proto.JwtRsaSsaPssPrivateKey;

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtRsaSsaPssVerifyKeyManager.java
Patch:
@@ -17,7 +17,7 @@
 
 import static java.nio.charset.StandardCharsets.US_ASCII;
 
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.JwtRsaSsaPssAlgorithm;
 import com.google.crypto.tink.proto.JwtRsaSsaPssPublicKey;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/main/java/com/google/crypto/tink/mac/AesCmacKeyManager.java
Patch:
@@ -17,9 +17,9 @@
 package com.google.crypto.tink.mac;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Mac;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesCmacKey;
 import com.google.crypto.tink.proto.AesCmacKeyFormat;
 import com.google.crypto.tink.proto.AesCmacParams;

File: java_src/src/main/java/com/google/crypto/tink/mac/HmacKeyManager.java
Patch:
@@ -17,10 +17,10 @@
 package com.google.crypto.tink.mac;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Mac;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.proto.HmacKey;
 import com.google.crypto.tink.proto.HmacKeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/prf/AesCmacPrfKeyManager.java
Patch:
@@ -17,8 +17,8 @@
 package com.google.crypto.tink.prf;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesCmacPrfKey;
 import com.google.crypto.tink.proto.AesCmacPrfKeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/main/java/com/google/crypto/tink/prf/HkdfPrfKeyManager.java
Patch:
@@ -16,8 +16,8 @@
 package com.google.crypto.tink.prf;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.proto.HkdfPrfKey;
 import com.google.crypto.tink.proto.HkdfPrfKeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/prf/HmacPrfKeyManager.java
Patch:
@@ -17,9 +17,9 @@
 package com.google.crypto.tink.prf;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.proto.HmacPrfKey;
 import com.google.crypto.tink.proto.HmacPrfKeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/signature/EcdsaSignKeyManager.java
Patch:
@@ -17,11 +17,11 @@
 package com.google.crypto.tink.signature;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
-import com.google.crypto.tink.PrivateKeyTypeManager;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
+import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrivateKeyTypeManager;
 import com.google.crypto.tink.proto.EcdsaKeyFormat;
 import com.google.crypto.tink.proto.EcdsaParams;
 import com.google.crypto.tink.proto.EcdsaPrivateKey;

File: java_src/src/main/java/com/google/crypto/tink/signature/EcdsaVerifyKeyManager.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.crypto.tink.signature;
 
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.EcdsaPublicKey;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.signature.internal.SigUtil;

File: java_src/src/main/java/com/google/crypto/tink/signature/Ed25519PrivateKeyManager.java
Patch:
@@ -17,10 +17,10 @@
 package com.google.crypto.tink.signature;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
-import com.google.crypto.tink.PrivateKeyTypeManager;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrivateKeyTypeManager;
 import com.google.crypto.tink.proto.Ed25519KeyFormat;
 import com.google.crypto.tink.proto.Ed25519PrivateKey;
 import com.google.crypto.tink.proto.Ed25519PublicKey;

File: java_src/src/main/java/com/google/crypto/tink/signature/Ed25519PublicKeyManager.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.crypto.tink.signature;
 
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeyVerify;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.Ed25519PublicKey;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.subtle.Ed25519Verify;

File: java_src/src/main/java/com/google/crypto/tink/signature/RsaSsaPkcs1SignKeyManager.java
Patch:
@@ -17,11 +17,11 @@
 package com.google.crypto.tink.signature;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
-import com.google.crypto.tink.PrivateKeyTypeManager;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
+import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrivateKeyTypeManager;
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.RsaSsaPkcs1KeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/signature/RsaSsaPkcs1VerifyKeyManager.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.crypto.tink.signature;
 
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.config.internal.TinkFipsUtil;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.RsaSsaPkcs1PublicKey;
 import com.google.crypto.tink.signature.internal.SigUtil;

File: java_src/src/main/java/com/google/crypto/tink/signature/RsaSsaPssSignKeyManager.java
Patch:
@@ -17,10 +17,10 @@
 package com.google.crypto.tink.signature;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
-import com.google.crypto.tink.PrivateKeyTypeManager;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrivateKeyTypeManager;
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.RsaSsaPssKeyFormat;

File: java_src/src/main/java/com/google/crypto/tink/signature/RsaSsaPssVerifyKeyManager.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.crypto.tink.signature;
 
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeyVerify;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.RsaSsaPssParams;
 import com.google.crypto.tink.proto.RsaSsaPssPublicKey;

File: java_src/src/main/java/com/google/crypto/tink/streamingaead/AesCtrHmacStreamingKeyManager.java
Patch:
@@ -17,9 +17,9 @@
 package com.google.crypto.tink.streamingaead;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.StreamingAead;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesCtrHmacStreamingKey;
 import com.google.crypto.tink.proto.AesCtrHmacStreamingKeyFormat;
 import com.google.crypto.tink.proto.AesCtrHmacStreamingParams;

File: java_src/src/main/java/com/google/crypto/tink/streamingaead/AesGcmHkdfStreamingKeyManager.java
Patch:
@@ -17,9 +17,9 @@
 package com.google.crypto.tink.streamingaead;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.StreamingAead;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesGcmHkdfStreamingKey;
 import com.google.crypto.tink.proto.AesGcmHkdfStreamingKeyFormat;
 import com.google.crypto.tink.proto.AesGcmHkdfStreamingParams;

File: java_src/src/main/java/com/google/crypto/tink/testing/KeyTypeManagerTestUtil.java
Patch:
@@ -19,7 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.protobuf.ByteString;
 import com.google.protobuf.MessageLite;
 

File: java_src/src/test/java/com/google/crypto/tink/KeyManagerImplTest.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesGcmKey;
 import com.google.crypto.tink.proto.AesGcmKeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/test/java/com/google/crypto/tink/KeyTemplatesTest.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.Empty;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.protobuf.ByteString;

File: java_src/src/test/java/com/google/crypto/tink/PrivateKeyManagerImplTest.java
Patch:
@@ -20,6 +20,8 @@
 import static com.google.crypto.tink.testing.TestUtil.assertExceptionContains;
 import static org.junit.Assert.assertThrows;
 
+import com.google.crypto.tink.internal.KeyTypeManager;
+import com.google.crypto.tink.internal.PrivateKeyTypeManager;
 import com.google.crypto.tink.proto.Ed25519PrivateKey;
 import com.google.crypto.tink.proto.Ed25519PublicKey;
 import com.google.crypto.tink.proto.KeyData;

File: java_src/src/test/java/com/google/crypto/tink/aead/AesCtrHmacAeadKeyManagerTest.java
Patch:
@@ -24,7 +24,7 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesCtrHmacAeadKey;
 import com.google.crypto.tink.proto.AesCtrHmacAeadKeyFormat;
 import com.google.crypto.tink.proto.AesCtrKeyFormat;

File: java_src/src/test/java/com/google/crypto/tink/aead/AesCtrKeyManagerTest.java
Patch:
@@ -19,7 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesCtrKey;
 import com.google.crypto.tink.proto.AesCtrKeyFormat;
 import com.google.crypto.tink.proto.AesCtrParams;

File: java_src/src/test/java/com/google/crypto/tink/aead/AesEaxKeyManagerTest.java
Patch:
@@ -27,7 +27,7 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesEaxKey;
 import com.google.crypto.tink.proto.AesEaxKeyFormat;
 import com.google.crypto.tink.proto.AesEaxParams;

File: java_src/src/test/java/com/google/crypto/tink/aead/AesGcmKeyManagerTest.java
Patch:
@@ -26,7 +26,7 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesGcmKey;
 import com.google.crypto.tink.proto.AesGcmKeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/test/java/com/google/crypto/tink/aead/AesGcmSivKeyManagerTest.java
Patch:
@@ -24,8 +24,8 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.aead.subtle.AesGcmSiv;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesGcmSivKey;
 import com.google.crypto.tink.proto.AesGcmSivKeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/test/java/com/google/crypto/tink/aead/ChaCha20Poly1305KeyManagerTest.java
Patch:
@@ -24,7 +24,7 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.ChaCha20Poly1305Key;
 import com.google.crypto.tink.proto.ChaCha20Poly1305KeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/test/java/com/google/crypto/tink/aead/KmsEnvelopeAeadKeyManagerTest.java
Patch:
@@ -22,9 +22,9 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.KmsClients;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.KmsEnvelopeAeadKey;
 import com.google.crypto.tink.proto.KmsEnvelopeAeadKeyFormat;

File: java_src/src/test/java/com/google/crypto/tink/aead/XChaCha20Poly1305KeyManagerTest.java
Patch:
@@ -22,7 +22,7 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.XChaCha20Poly1305Key;
 import com.google.crypto.tink.proto.XChaCha20Poly1305KeyFormat;

File: java_src/src/test/java/com/google/crypto/tink/daead/AesSivKeyManagerTest.java
Patch:
@@ -21,7 +21,7 @@
 
 import com.google.crypto.tink.DeterministicAead;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesSivKey;
 import com.google.crypto.tink.proto.AesSivKeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: java_src/src/test/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPrivateKeyManagerTest.java
Patch:
@@ -24,10 +24,10 @@
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.HybridEncrypt;
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.aead.AeadConfig;
 import com.google.crypto.tink.aead.AeadKeyTemplates;
 import com.google.crypto.tink.aead.AesCtrHmacAeadKeyManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.EcPointFormat;
 import com.google.crypto.tink.proto.EciesAeadHkdfKeyFormat;
 import com.google.crypto.tink.proto.EciesAeadHkdfParams;

File: java_src/src/test/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPublicKeyManagerTest.java
Patch:
@@ -20,9 +20,9 @@
 
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.HybridEncrypt;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.aead.AeadConfig;
 import com.google.crypto.tink.aead.AeadKeyTemplates;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.EcPointFormat;
 import com.google.crypto.tink.proto.EciesAeadDemParams;
 import com.google.crypto.tink.proto.EciesAeadHkdfKeyFormat;

File: java_src/src/test/java/com/google/crypto/tink/hybrid/internal/HpkePrivateKeyManagerTest.java
Patch:
@@ -21,8 +21,8 @@
 
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.HybridEncrypt;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.HpkeAead;
 import com.google.crypto.tink.proto.HpkeKdf;
 import com.google.crypto.tink.proto.HpkeKem;

File: java_src/src/test/java/com/google/crypto/tink/internal/KeyTypeManagerTest.java
Patch:
@@ -13,7 +13,7 @@
 // limitations under the License.
 //
 ////////////////////////////////////////////////////////////////////////////////
-package com.google.crypto.tink;
+package com.google.crypto.tink.internal;
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtEcdsaSignKeyManagerTest.java
Patch:
@@ -23,8 +23,8 @@
 import com.google.crypto.tink.CleartextKeysetHandle;
 import com.google.crypto.tink.KeyTemplate;
 import com.google.crypto.tink.KeyTemplates;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.KeysetHandle;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.JwtEcdsaAlgorithm;
 import com.google.crypto.tink.proto.JwtEcdsaKeyFormat;
 import com.google.crypto.tink.proto.JwtEcdsaPrivateKey;

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtEcdsaVerifyKeyManagerTest.java
Patch:
@@ -18,7 +18,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.JwtEcdsaAlgorithm;
 import com.google.crypto.tink.proto.JwtEcdsaKeyFormat;
 import com.google.crypto.tink.proto.JwtEcdsaPrivateKey;

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtHmacKeyManagerTest.java
Patch:
@@ -24,8 +24,8 @@
 import com.google.crypto.tink.CleartextKeysetHandle;
 import com.google.crypto.tink.KeyTemplate;
 import com.google.crypto.tink.KeyTemplates;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.KeysetHandle;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.JwtHmacAlgorithm;
 import com.google.crypto.tink.proto.JwtHmacKey;
 import com.google.crypto.tink.proto.JwtHmacKey.CustomKid;

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtRsaSsaPkcs1SignKeyManagerTest.java
Patch:
@@ -23,8 +23,8 @@
 import com.google.crypto.tink.CleartextKeysetHandle;
 import com.google.crypto.tink.KeyTemplate;
 import com.google.crypto.tink.KeyTemplates;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.KeysetHandle;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.JwtRsaSsaPkcs1Algorithm;
 import com.google.crypto.tink.proto.JwtRsaSsaPkcs1KeyFormat;
 import com.google.crypto.tink.proto.JwtRsaSsaPkcs1PrivateKey;

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtRsaSsaPkcs1VerifyKeyManagerTest.java
Patch:
@@ -18,7 +18,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.JwtRsaSsaPkcs1Algorithm;
 import com.google.crypto.tink.proto.JwtRsaSsaPkcs1KeyFormat;
 import com.google.crypto.tink.proto.JwtRsaSsaPkcs1PrivateKey;

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtRsaSsaPssSignKeyManagerTest.java
Patch:
@@ -24,8 +24,8 @@
 import com.google.crypto.tink.CleartextKeysetHandle;
 import com.google.crypto.tink.KeyTemplate;
 import com.google.crypto.tink.KeyTemplates;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.KeysetHandle;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.JwtRsaSsaPssAlgorithm;
 import com.google.crypto.tink.proto.JwtRsaSsaPssKeyFormat;
 import com.google.crypto.tink.proto.JwtRsaSsaPssPrivateKey;

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtRsaSsaPssVerifyKeyManagerTest.java
Patch:
@@ -18,7 +18,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.JwtRsaSsaPssAlgorithm;
 import com.google.crypto.tink.proto.JwtRsaSsaPssKeyFormat;
 import com.google.crypto.tink.proto.JwtRsaSsaPssPrivateKey;

File: java_src/src/test/java/com/google/crypto/tink/mac/AesCmacKeyManagerTest.java
Patch:
@@ -21,8 +21,8 @@
 import static org.junit.Assert.assertThrows;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Mac;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesCmacKey;
 import com.google.crypto.tink.proto.AesCmacKeyFormat;
 import com.google.crypto.tink.proto.AesCmacParams;

File: java_src/src/test/java/com/google/crypto/tink/mac/HmacKeyManagerTest.java
Patch:
@@ -21,8 +21,8 @@
 import static org.junit.Assert.assertThrows;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.Mac;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.proto.HmacKey;
 import com.google.crypto.tink.proto.HmacKeyFormat;

File: java_src/src/test/java/com/google/crypto/tink/prf/AesCmacPrfKeyManagerTest.java
Patch:
@@ -21,7 +21,7 @@
 import static org.junit.Assert.assertThrows;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesCmacPrfKey;
 import com.google.crypto.tink.proto.AesCmacPrfKeyFormat;
 import com.google.crypto.tink.subtle.PrfAesCmac;

File: java_src/src/test/java/com/google/crypto/tink/prf/HkdfPrfKeyManagerTest.java
Patch:
@@ -22,7 +22,7 @@
 import static org.junit.Assert.assertThrows;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.proto.HkdfPrfKey;
 import com.google.crypto.tink.proto.HkdfPrfKeyFormat;

File: java_src/src/test/java/com/google/crypto/tink/prf/HmacPrfKeyManagerTest.java
Patch:
@@ -21,7 +21,7 @@
 import static org.junit.Assert.assertThrows;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.proto.HmacPrfKey;
 import com.google.crypto.tink.proto.HmacPrfKeyFormat;

File: java_src/src/test/java/com/google/crypto/tink/signature/EcdsaSignKeyManagerTest.java
Patch:
@@ -21,8 +21,8 @@
 import static org.junit.Assert.assertThrows;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeySign;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.EcdsaKeyFormat;
 import com.google.crypto.tink.proto.EcdsaParams;
 import com.google.crypto.tink.proto.EcdsaPrivateKey;

File: java_src/src/test/java/com/google/crypto/tink/signature/EcdsaVerifyKeyManagerTest.java
Patch:
@@ -19,8 +19,8 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeyVerify;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.EcdsaKeyFormat;
 import com.google.crypto.tink.proto.EcdsaParams;
 import com.google.crypto.tink.proto.EcdsaPrivateKey;

File: java_src/src/test/java/com/google/crypto/tink/signature/Ed25519PrivateKeyManagerTest.java
Patch:
@@ -21,9 +21,9 @@
 import static org.junit.Assert.assertThrows;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.Ed25519KeyFormat;
 import com.google.crypto.tink.proto.Ed25519PrivateKey;
 import com.google.crypto.tink.proto.Ed25519PublicKey;

File: java_src/src/test/java/com/google/crypto/tink/signature/Ed25519PublicKeyManagerTest.java
Patch:
@@ -19,9 +19,9 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
 
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.Ed25519KeyFormat;
 import com.google.crypto.tink.proto.Ed25519PrivateKey;
 import com.google.crypto.tink.proto.Ed25519PublicKey;

File: java_src/src/test/java/com/google/crypto/tink/signature/RsaSsaPkcs1SignKeyManagerTest.java
Patch:
@@ -21,9 +21,9 @@
 import static org.junit.Assert.assertThrows;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.RsaSsaPkcs1KeyFormat;

File: java_src/src/test/java/com/google/crypto/tink/signature/RsaSsaPkcs1VerifyKeyManagerTest.java
Patch:
@@ -19,9 +19,9 @@
 import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.fail;
 
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.RsaSsaPkcs1KeyFormat;

File: java_src/src/test/java/com/google/crypto/tink/signature/RsaSsaPssSignKeyManagerTest.java
Patch:
@@ -21,9 +21,9 @@
 import static org.junit.Assert.assertThrows;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.RsaSsaPssKeyFormat;

File: java_src/src/test/java/com/google/crypto/tink/signature/RsaSsaPssVerifyKeyManagerTest.java
Patch:
@@ -19,9 +19,9 @@
 import static org.junit.Assert.assertThrows;
 import static org.junit.Assert.fail;
 
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.RsaSsaPssKeyFormat;

File: java_src/src/test/java/com/google/crypto/tink/streamingaead/AesCtrHmacStreamingKeyManagerTest.java
Patch:
@@ -20,8 +20,8 @@
 import static org.junit.Assert.assertThrows;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.StreamingAead;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesCtrHmacStreamingKey;
 import com.google.crypto.tink.proto.AesCtrHmacStreamingKeyFormat;
 import com.google.crypto.tink.proto.AesCtrHmacStreamingParams;

File: java_src/src/test/java/com/google/crypto/tink/streamingaead/AesGcmHkdfStreamingKeyManagerTest.java
Patch:
@@ -20,8 +20,8 @@
 import static org.junit.Assert.assertThrows;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.StreamingAead;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesGcmHkdfStreamingKey;
 import com.google.crypto.tink.proto.AesGcmHkdfStreamingKeyFormat;
 import com.google.crypto.tink.proto.AesGcmHkdfStreamingParams;

File: java_src/src/test/java/com/google/crypto/tink/testing/KeyTypeManagerTestUtilTest.java
Patch:
@@ -20,7 +20,7 @@
 import static org.junit.Assert.assertThrows;
 
 import com.google.crypto.tink.KeyTemplate;
-import com.google.crypto.tink.KeyTypeManager;
+import com.google.crypto.tink.internal.KeyTypeManager;
 import com.google.crypto.tink.proto.AesGcmKey;
 import com.google.crypto.tink.proto.AesGcmKeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;

File: testing/java_src/java/com/google/crypto/tink/testing/KeysetServiceImpl.java
Patch:
@@ -16,8 +16,6 @@
 
 package com.google.crypto.tink.testing;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.BinaryKeysetReader;
 import com.google.crypto.tink.BinaryKeysetWriter;
@@ -143,7 +141,7 @@ public void toJson(
       JsonKeysetWriter.withOutputStream(jsonKeysetStream).write(keyset);
       jsonKeysetStream.close();
       response =
-          KeysetToJsonResponse.newBuilder().setJsonKeyset(jsonKeysetStream.toString(UTF_8)).build();
+          KeysetToJsonResponse.newBuilder().setJsonKeyset(jsonKeysetStream.toString("UTF-8")).build();
     } catch (GeneralSecurityException | InvalidProtocolBufferException e) {
       response = KeysetToJsonResponse.newBuilder().setErr(e.toString()).build();
     } catch (IOException e) {

File: tools/testing/java/com/google/crypto/tink/testing/CompareKeysets.java
Patch:
@@ -52,8 +52,8 @@ private static boolean equalKeys(Keyset.Key key1, Keyset.Key key2) throws Except
   }
 
   /**
-   * Finds a key in {@param keyList} for which {@link areEqualKeys} returns true, removes it, and
-   * returns true. If not such key exists returns false.
+   * Finds a key in {@code keyList} for which {@link equalKeys} returns true, removes it, and
+   * returns true. If no such key exists, returns false.
    */
   private static boolean findAndRemove(Keyset.Key key, List<Keyset.Key> keyList) throws Exception {
     for (Keyset.Key key2 : keyList) {

File: java_src/src/test/java/com/google/crypto/tink/hybrid/internal/AesGcmHpkeAeadTest.java
Patch:
@@ -148,7 +148,7 @@ public void open_wrongKeyLength() throws GeneralSecurityException {
     assertThrows(
         InvalidAlgorithmParameterException.class,
         () ->
-            aead.seal(
-                setup.key, encryption.nonce, encryption.plaintext, encryption.associatedData));
+            aead.open(
+                setup.key, encryption.nonce, encryption.ciphertext, encryption.associatedData));
   }
 }

File: java_src/src/main/java/com/google/crypto/tink/hybrid/HybridConfig.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.crypto.tink.aead.AeadConfig;
 import com.google.crypto.tink.config.TinkFips;
+import com.google.crypto.tink.hybrid.internal.HpkePrivateKeyManager;
 import com.google.crypto.tink.proto.RegistryConfig;
 import java.security.GeneralSecurityException;
 
@@ -107,6 +108,7 @@ public static void register() throws GeneralSecurityException {
     }
 
     EciesAeadHkdfPrivateKeyManager.registerPair(/*newKeyAllowed=*/true);
+    HpkePrivateKeyManager.registerPair(/*newKeyAllowed=*/true);
   }
 
   private HybridConfig() {}

File: java_src/src/test/java/com/google/crypto/tink/aead/AesEaxKeyManagerTest.java
Patch:
@@ -18,6 +18,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.crypto.tink.testing.KeyTypeManagerTestUtil.testKeyTemplateCompatible;
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThrows;
@@ -286,8 +287,8 @@ public void testPublicTestVectors() throws Exception {
   public void testCiphertextSize() throws Exception {
     AesEaxKey key = factory.createKey(createKeyFormat(32, 16));
     Aead aead = manager.getPrimitive(key, Aead.class);
-    byte[] plaintext = "plaintext".getBytes("UTF-8");
-    byte[] associatedData = "associatedData".getBytes("UTF-8");
+    byte[] plaintext = "plaintext".getBytes(UTF_8);
+    byte[] associatedData = "associatedData".getBytes(UTF_8);
     byte[] ciphertext = aead.encrypt(plaintext, associatedData);
     assertEquals(16 /* IV_SIZE */ + plaintext.length + 16 /* TAG_SIZE */, ciphertext.length);
   }

File: java_src/src/test/java/com/google/crypto/tink/aead/AesGcmKeyManagerTest.java
Patch:
@@ -18,6 +18,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.crypto.tink.testing.KeyTypeManagerTestUtil.testKeyTemplateCompatible;
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThrows;
@@ -340,8 +341,8 @@ public void testNistVectors() throws Exception {
   public void testCiphertextSize() throws Exception {
     AesGcmKey key = factory.createKey(AesGcmKeyFormat.newBuilder().setKeySize(32).build());
     Aead aead = new AesGcmKeyManager().getPrimitive(key, Aead.class);
-    byte[] plaintext = "plaintext".getBytes("UTF-8");
-    byte[] associatedData = "associatedData".getBytes("UTF-8");
+    byte[] plaintext = "plaintext".getBytes(UTF_8);
+    byte[] associatedData = "associatedData".getBytes(UTF_8);
     byte[] ciphertext = aead.encrypt(plaintext, associatedData);
     assertThat(ciphertext.length)
         .isEqualTo(12 /* IV_SIZE */ + plaintext.length + 16 /* TAG_SIZE */);

File: java_src/src/test/java/com/google/crypto/tink/aead/AesGcmSivKeyManagerTest.java
Patch:
@@ -18,6 +18,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.crypto.tink.testing.KeyTypeManagerTestUtil.testKeyTemplateCompatible;
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThrows;
 
@@ -144,8 +145,8 @@ public void getPrimitive() throws Exception {
   public void testCiphertextSize() throws Exception {
     AesGcmSivKey key = factory.createKey(AesGcmSivKeyFormat.newBuilder().setKeySize(32).build());
     Aead aead = new AesGcmSivKeyManager().getPrimitive(key, Aead.class);
-    byte[] plaintext = "plaintext".getBytes("UTF-8");
-    byte[] associatedData = "associatedData".getBytes("UTF-8");
+    byte[] plaintext = "plaintext".getBytes(UTF_8);
+    byte[] associatedData = "associatedData".getBytes(UTF_8);
     byte[] ciphertext = aead.encrypt(plaintext, associatedData);
     assertThat(ciphertext.length)
         .isEqualTo(12 /* IV_SIZE */ + plaintext.length + 16 /* TAG_SIZE */);

File: java_src/src/test/java/com/google/crypto/tink/aead/ChaCha20Poly1305KeyManagerTest.java
Patch:
@@ -18,6 +18,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.crypto.tink.testing.KeyTypeManagerTestUtil.testKeyTemplateCompatible;
+import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThrows;
 
@@ -126,8 +127,8 @@ public void createKey_multipleCallsCreateDifferentKeys() throws Exception {
   public void testCiphertextSize() throws Exception {
     Aead aead =
         new ChaCha20Poly1305KeyManager().getPrimitive(createChaCha20Poly1305Key(32), Aead.class);
-    byte[] plaintext = "plaintext".getBytes("UTF-8");
-    byte[] associatedData = "associatedData".getBytes("UTF-8");
+    byte[] plaintext = "plaintext".getBytes(UTF_8);
+    byte[] associatedData = "associatedData".getBytes(UTF_8);
     byte[] ciphertext = aead.encrypt(plaintext, associatedData);
     assertEquals(12 /* IV_SIZE */ + plaintext.length + 16 /* TAG_SIZE */, ciphertext.length);
   }

File: tools/tinkey/src/main/java/com/google/crypto/tink/tinkey/CreatePublicKeysetCommand.java
Patch:
@@ -28,6 +28,7 @@
 public class CreatePublicKeysetCommand extends OutOptions implements Command {
   @Override
   public void run() throws Exception {
+    validate();
     create(outputStream, outFormat, inputStream, inFormat, masterKeyUri, credentialPath);
     outputStream.close();
     inputStream.close();

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtMacInternal.java
Patch:
@@ -29,6 +29,6 @@ String computeMacAndEncodeWithKid(RawJwt token, Optional<String> kid)
       throws GeneralSecurityException;
 
   /** Decodes and verifies a JWT in the JWS compact serialization format. */
-  VerifiedJwt verifyMacAndDecode(String compact, JwtValidator validator)
-      throws GeneralSecurityException;
+  VerifiedJwt verifyMacAndDecodeWithKid(
+      String compact, JwtValidator validator, Optional<String> kid) throws GeneralSecurityException;
 }

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtMacWrapper.java
Patch:
@@ -67,7 +67,8 @@ public VerifiedJwt verifyMacAndDecode(String compact, JwtValidator validator)
       for (List<PrimitiveSet.Entry<JwtMacInternal>> entries : primitives.getAll()) {
         for (PrimitiveSet.Entry<JwtMacInternal> entry : entries) {
           try {
-            return entry.getPrimitive().verifyMacAndDecode(compact, validator);
+            Optional<String> kid = JwtFormat.getKid(entry.getKeyId(), entry.getOutputPrefixType());
+            return entry.getPrimitive().verifyMacAndDecodeWithKid(compact, validator, kid);
           } catch (GeneralSecurityException e) {
             if (e instanceof JwtInvalidException) {
               // Keep this exception so that we are able to throw a meaningful message in the end

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtHmacKeyManager.java
Patch:
@@ -107,7 +107,8 @@ public VerifiedJwt verifyMacAndDecode(String compact, JwtValidator validator)
       JwtFormat.Parts parts = JwtFormat.splitSignedCompact(compact);
       prfMac.verifyMac(parts.signatureOrMac, parts.unsignedCompact.getBytes(US_ASCII));
       JsonObject parsedHeader = JsonUtil.parseJson(parts.header);
-      JwtFormat.validateHeader(algorithm, parsedHeader);
+      // TODO(juerg): Add kid validation.
+      JwtFormat.validateHeader(algorithm, Optional.empty(), Optional.empty(), parsedHeader);
       RawJwt token = RawJwt.fromJsonPayload(JwtFormat.getTypeHeader(parsedHeader), parts.payload);
       return validator.validate(token);
     }

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtEcdsaSignKeyManagerTest.java
Patch:
@@ -453,7 +453,7 @@ public void signAndVerifyWithCustomKid() throws Exception {
     JwtPublicKeyVerify verifier =
         handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
     JwtPublicKeyVerify verifierWithKid =
-        handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
+        handleWithKid.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
 
     // Both the verifiers accept signedCompactWithKid.
     assertThat(verifier.verifyAndDecode(signedCompactWithKid, validator).getJwtId())

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtRsaSsaPkcs1SignKeyManagerTest.java
Patch:
@@ -590,7 +590,7 @@ public void signAndVerifyWithCustomKid() throws Exception {
     JwtPublicKeyVerify verifier =
         handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
     JwtPublicKeyVerify verifierWithKid =
-        handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
+        handleWithKid.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
 
     // Both the verifiers accept signedCompactWithKid.
     assertThat(verifier.verifyAndDecode(signedCompactWithKid, validator).getJwtId())

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtRsaSsaPssSignKeyManagerTest.java
Patch:
@@ -542,7 +542,7 @@ public void signAndVerifyWithCustomKid() throws Exception {
     JwtPublicKeyVerify verifier =
         handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
     JwtPublicKeyVerify verifierWithKid =
-        handle.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
+        handleWithKid.getPublicKeysetHandle().getPrimitive(JwtPublicKeyVerify.class);
 
     // Both the verifiers accept signedCompactWithKid.
     assertThat(verifier.verifyAndDecode(signedCompactWithKid, validator).getJwtId())

File: java_src/src/test/java/com/google/crypto/tink/hybrid/HybridConfigTest.java
Patch:
@@ -22,6 +22,7 @@
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.config.TinkFips;
+import com.google.crypto.tink.config.internal.TinkFipsUtil;
 import java.security.GeneralSecurityException;
 import org.junit.Assume;
 import org.junit.FixMethodOrder;
@@ -89,6 +90,7 @@ public void testNoFipsRegister() throws Exception {
   @Test
   public void testFipsRegisterNonFipsKeys() throws Exception {
     Assume.assumeTrue(TinkFips.useOnlyFips());
+    Assume.assumeTrue(TinkFipsUtil.fipsModuleAvailable());
 
     // Register Hybrid key manager
     HybridConfig.register();

File: java_src/src/main/java/com/google/crypto/tink/KeysetHandle.java
Patch:
@@ -23,7 +23,6 @@
 import com.google.crypto.tink.proto.KeysetInfo;
 import com.google.crypto.tink.tinkkey.KeyAccess;
 import com.google.crypto.tink.tinkkey.KeyHandle;
-import com.google.crypto.tink.tinkkey.SecretKeyAccess;
 import com.google.crypto.tink.tinkkey.internal.InternalKeyHandle;
 import com.google.crypto.tink.tinkkey.internal.ProtoKey;
 import com.google.protobuf.ByteString;
@@ -380,9 +379,10 @@ public KeyHandle primaryKey() throws GeneralSecurityException {
     int primaryKeyId = keyset.getPrimaryKeyId();
     for (Keyset.Key key : keyset.getKeyList()) {
       if (key.getKeyId() == primaryKeyId) {
-        return KeyHandle.createFromKey(
+        return new InternalKeyHandle(
             new ProtoKey(key.getKeyData(), KeyTemplate.fromProto(key.getOutputPrefixType())),
-            SecretKeyAccess.insecureSecretAccess());
+            key.getStatus(),
+            key.getKeyId());
       }
     }
     throw new GeneralSecurityException("No primary key found in keyset.");

File: java_src/src/main/java/com/google/crypto/tink/tinkkey/KeyHandle.java
Patch:
@@ -56,7 +56,10 @@ public static KeyHandle createFromKey(TinkKey key, KeyAccess access)
    * Returns a {@code KeyHandle} instance where the underlying {@code TinkKey} wraps the input
    * {@code keyData}. The returned KeyHandle has a secret if keyData has key material of type
    * UNKNOWN_KEYMATERIAL, SYMMETRIC, or ASYMMETRIC_PRIVATE.
+   *
+   * @deprecated Use the KeyHandle(TinkKey, KeyAccess) constructor instead.
    */
+  @Deprecated
   public static KeyHandle createFromKey(KeyData keyData, OutputPrefixType opt) {
     return new KeyHandle(new ProtoKey(keyData, opt));
   }

File: java_src/src/test/java/com/google/crypto/tink/KeysetHandleTest.java
Patch:
@@ -157,7 +157,9 @@ public void generateNew_generatesDifferentKeys() throws Exception {
   public void createFromKey_shouldWork() throws Exception {
     KeyTemplate template = AesEaxKeyManager.aes128EaxTemplate();
     KeyHandle keyHandle =
-        KeyHandle.createFromKey(Registry.newKeyData(template), template.getOutputPrefixType());
+        KeyHandle.createFromKey(
+            new ProtoKey(Registry.newKeyData(template), template.getOutputPrefixType()),
+            SecretKeyAccess.insecureSecretAccess());
     KeyAccess token = SecretKeyAccess.insecureSecretAccess();
 
     KeysetHandle handle = KeysetHandle.createFromKey(keyHandle, token);

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwkSetConverter.java
Patch:
@@ -376,7 +376,7 @@ private Keyset.Key convertToRsaSsaPkcs1Key(JsonObject jsonKey) throws IOExceptio
       }
       if (jsonKey.has("p")
           || jsonKey.has("q")
-          || jsonKey.has("dq")
+          || jsonKey.has("dp")
           || jsonKey.has("dq")
           || jsonKey.has("d")
           || jsonKey.has("qi")) {

File: examples/java_src/gcs/GcsEnvelopeAeadExample.java
Patch:
@@ -124,7 +124,7 @@ public static void main(String[] args) throws Exception {
       String gcsBlobPath = args[5];
       // This will bind the encryption to the location of the GCS blob. That if, if you rename or
       // move the blob to a different bucket, decryption will fail.
-      // See https://developers.google.com/tink/AEAD#associated_data.
+      // See https://developers.google.com/tink/aead#associated_data.
       byte[] associatedData = gcsBlobPath.getBytes(UTF_8);
       byte[] ciphertext = aead.encrypt(input, associatedData);
 

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwkSetConverterTest.java
Patch:
@@ -520,9 +520,9 @@ public void convertTinkToJwksTokenVerification_success() throws Exception {
       JwtPublicKeySign signer = keysetHandle.getPrimitive(JwtPublicKeySign.class);
       JwtPublicKeyVerify verifier = publicKeysetHandle.getPrimitive(JwtPublicKeyVerify.class);
 
-      RawJwt rawToken = RawJwt.newBuilder().setJwtId("jwtId").build();
+      RawJwt rawToken = RawJwt.newBuilder().setJwtId("jwtId").withoutExpiration().build();
       String signedCompact = signer.signAndEncode(rawToken);
-      JwtValidator validator = JwtValidator.newBuilder().build();
+      JwtValidator validator = JwtValidator.newBuilder().allowMissingExpiration().build();
       VerifiedJwt verifiedToken = verifier.verifyAndDecode(signedCompact, validator);
       assertThat(verifiedToken.getJwtId()).isEqualTo("jwtId");
     }

File: testing/java_src/javatests/com/google/crypto/tink/testing/JwtServiceImplTest.java
Patch:
@@ -104,7 +104,8 @@ private static KeysetPublicResponse publicKeyset(
 
   private JwtToken generateToken(String audience, long expSeconds, int expNanos) {
     return JwtToken.newBuilder()
-        .setTypeHeader(StringValue.newBuilder().setValue("typeHeader"))
+        // TODO(juerg): support typ header.
+        // .setTypeHeader(StringValue.newBuilder().setValue("typeHeader"))
         .setIssuer(StringValue.newBuilder().setValue("issuer"))
         .addAudiences(audience)
         .addAudiences(audience + "2")

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtMacWrapperTest.java
Patch:
@@ -174,7 +174,7 @@ public void wrongIssuer_throwsInvalidException() throws Exception {
     JwtMac jwtMac = keysetHandle.getPrimitive(JwtMac.class);
     RawJwt rawJwt = new RawJwt.Builder().setIssuer("Justus").build();
     String compact = jwtMac.computeMacAndEncode(rawJwt);
-    JwtValidator validator = new JwtValidator.Builder().setIssuer("Peter").build();
+    JwtValidator validator = JwtValidator.newBuilder().expectIssuer("Peter").build();
     assertThrows(JwtInvalidException.class, () -> jwtMac.verifyMacAndDecode(compact, validator));
   }
 

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtPublicKeySignVerifyWrappersTest.java
Patch:
@@ -223,7 +223,7 @@ public void wrongIssuer_throwsInvalidException() throws Exception {
     JwtPublicKeyVerify jwtVerifier = publicHandle.getPrimitive(JwtPublicKeyVerify.class);
     RawJwt rawJwt = new RawJwt.Builder().setIssuer("Justus").build();
     String compact = jwtSigner.signAndEncode(rawJwt);
-    JwtValidator validator = new JwtValidator.Builder().setIssuer("Peter").build();
+    JwtValidator validator = JwtValidator.newBuilder().expectIssuer("Peter").build();
     assertThrows(JwtInvalidException.class, () -> jwtVerifier.verifyAndDecode(compact, validator));
   }
 

File: testing/java_src/javatests/com/google/crypto/tink/testing/JwtServiceImplTest.java
Patch:
@@ -142,6 +142,7 @@ public void jwtComputeVerifyMac_success() throws Exception {
 
     JwtValidator validator =
         JwtValidator.newBuilder()
+            .setIssuer(StringValue.newBuilder().setValue("issuer"))
             .setAudience(StringValue.newBuilder().setValue("audience"))
             .setNow(Timestamp.newBuilder().setSeconds(1234))
             .build();
@@ -208,6 +209,7 @@ public void publicKeySignVerify_success() throws Exception {
 
     JwtValidator validator =
         JwtValidator.newBuilder()
+            .setIssuer(StringValue.newBuilder().setValue("issuer"))
             .setAudience(StringValue.newBuilder().setValue("audience"))
             .setNow(Timestamp.newBuilder().setSeconds(1234))
             .build();

File: testing/java_src/javatests/com/google/crypto/tink/testing/JwtServiceImplTest.java
Patch:
@@ -104,6 +104,7 @@ private static KeysetPublicResponse publicKeyset(
 
   private JwtToken generateToken(String audience, long expSeconds, int expNanos) {
     return JwtToken.newBuilder()
+        .setTypeHeader(StringValue.newBuilder().setValue("typeHeader"))
         .setIssuer(StringValue.newBuilder().setValue("issuer"))
         .addAudiences(audience)
         .addAudiences(audience + "2")

File: examples/java_src/helloworld/src/main/java/com/helloworld/Commands.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017 Google Inc.
+ * Copyright 2017 Google LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
  * in compliance with the License. You may obtain a copy of the License at

File: examples/java_src/helloworld/src/main/java/com/helloworld/HelloWorld.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2017 Google Inc.
+ * Copyright 2017 Google LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
  * in compliance with the License. You may obtain a copy of the License at

File: java_src/src/main/java/com/google/crypto/tink/config/TinkFipsEnabled.java
Patch:
@@ -33,7 +33,7 @@ public static boolean fipsModuleAvailable() {
 
   static Boolean checkConscryptUsesFipsBoringSsl() {
     try {
-      Class<?> cls = Class.forName("Conscrypt");
+      Class<?> cls = Class.forName("org.conscrypt.Conscrypt");
       Method isBoringSslFIPSBuild = cls.getMethod("isBoringSslFIPSBuild");
       return (Boolean) isBoringSslFIPSBuild.invoke(null);
     } catch (ReflectiveOperationException e) {

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtEcdsaSignKeyManager.java
Patch:
@@ -86,7 +86,7 @@ public JwtPublicKeySign getPrimitive(JwtEcdsaPrivateKey keyProto)
 
       return new JwtPublicKeySign() {
         @Override
-        public String sign(RawJwt token) throws GeneralSecurityException {
+        public String signAndEncode(RawJwt token) throws GeneralSecurityException {
           String unsignedCompact =
               JwtFormat.createUnsignedCompact(algorithmName, token.getJsonPayload());
           return JwtFormat.createSignedCompact(

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtEcdsaVerifyKeyManager.java
Patch:
@@ -92,7 +92,7 @@ public JwtPublicKeyVerify getPrimitive(JwtEcdsaPublicKey keyProto)
 
       return new JwtPublicKeyVerify() {
         @Override
-        public VerifiedJwt verify(String compact, JwtValidator validator)
+        public VerifiedJwt verifyAndDecode(String compact, JwtValidator validator)
             throws GeneralSecurityException {
           JwtFormat.validateASCII(compact);
           String[] parts = compact.split("\\.", -1);

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtHmacKeyManager.java
Patch:
@@ -77,15 +77,15 @@ public JwtHmac(String algorithm, PrfMac prfMac) {
     }
 
     @Override
-    public String sign(RawJwt token) throws GeneralSecurityException {
+    public String computeMacAndEncode(RawJwt token) throws GeneralSecurityException {
       String unsignedCompact =
           JwtFormat.createUnsignedCompact(algorithm, token.getJsonPayload());
       return JwtFormat.createSignedCompact(
           unsignedCompact, prfMac.computeMac(unsignedCompact.getBytes(US_ASCII)));
     }
 
     @Override
-    public VerifiedJwt verify(String compact, JwtValidator validator)
+    public VerifiedJwt verifyMacAndDecode(String compact, JwtValidator validator)
         throws GeneralSecurityException {
       JwtFormat.validateASCII(compact);
       String[] parts = compact.split("\\.", -1);

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtMac.java
Patch:
@@ -26,7 +26,7 @@
 @Immutable
 public interface JwtMac {
   /** Computes a MAC, and encodes the JWT and the MAC in the JWS compact serialization format. */
-  String sign(RawJwt token) throws GeneralSecurityException;
+  String computeMacAndEncode(RawJwt token) throws GeneralSecurityException;
 
   /**
    * Decodes and verifies a JWT in the JWS compact serialization format.
@@ -44,5 +44,6 @@ public interface JwtMac {
    * @throws GeneralSecurityException when the signature of the token could not be verified, the
    *     token contains an invalid claim or header, the token has been expired or can't be used yet
    */
-  VerifiedJwt verify(String compact, JwtValidator validator) throws GeneralSecurityException;
+  VerifiedJwt verifyMacAndDecode(String compact, JwtValidator validator)
+      throws GeneralSecurityException;
 }

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtPublicKeySign.java
Patch:
@@ -27,6 +27,6 @@
 public interface JwtPublicKeySign {
   /** Computes a signature, and encodes the JWT and the signature in the
    * JWS compact serialization format. */
-  String sign(RawJwt token) throws GeneralSecurityException;
+  String signAndEncode(RawJwt token) throws GeneralSecurityException;
 }
 

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtPublicKeySignWrapper.java
Patch:
@@ -50,8 +50,8 @@ public WrappedJwtPublicKeySign(final PrimitiveSet<JwtPublicKeySign> primitives)
     }
 
     @Override
-    public String sign(RawJwt token) throws GeneralSecurityException {
-      return primitives.getPrimary().getPrimitive().sign(token);
+    public String signAndEncode(RawJwt token) throws GeneralSecurityException {
+      return primitives.getPrimary().getPrimitive().signAndEncode(token);
     }
   }
 

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtPublicKeyVerifyWrapper.java
Patch:
@@ -46,15 +46,15 @@ public WrappedJwtPublicKeyVerify(PrimitiveSet<JwtPublicKeyVerify> primitives) {
     }
 
     @Override
-    public VerifiedJwt verify(String compact, JwtValidator validator)
+    public VerifiedJwt verifyAndDecode(String compact, JwtValidator validator)
         throws GeneralSecurityException {
 
       // All JWT keys are raw.
       List<PrimitiveSet.Entry<JwtPublicKeyVerify>> entries = primitives.getRawPrimitives();
       GeneralSecurityException interestingException = null;
       for (PrimitiveSet.Entry<JwtPublicKeyVerify> entry : entries) {
         try {
-          return entry.getPrimitive().verify(compact, validator);
+          return entry.getPrimitive().verifyAndDecode(compact, validator);
         } catch (GeneralSecurityException e) {
           if (e instanceof JwtInvalidException) {
             // Keep this exception so that we are able to throw a meaningful message in the end

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtRsaSsaPkcs1SignKeyManager.java
Patch:
@@ -100,7 +100,7 @@ public JwtPublicKeySign getPrimitive(JwtRsaSsaPkcs1PrivateKey keyProto)
       final String algorithmName = algorithm.name();
       return new JwtPublicKeySign() {
         @Override
-        public String sign(RawJwt token) throws GeneralSecurityException {
+        public String signAndEncode(RawJwt token) throws GeneralSecurityException {
           String unsignedCompact =
               JwtFormat.createUnsignedCompact(algorithmName, token.getJsonPayload());
           return JwtFormat.createSignedCompact(

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtRsaSsaPkcs1VerifyKeyManager.java
Patch:
@@ -77,7 +77,7 @@ public JwtPublicKeyVerify getPrimitive(JwtRsaSsaPkcs1PublicKey keyProto)
 
             return new JwtPublicKeyVerify() {
               @Override
-              public VerifiedJwt verify(String compact, JwtValidator validator)
+              public VerifiedJwt verifyAndDecode(String compact, JwtValidator validator)
                   throws GeneralSecurityException {
                 JwtFormat.validateASCII(compact);
                 String[] parts = compact.split("\\.", -1);

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtRsaSsaPssSignKeyManager.java
Patch:
@@ -102,7 +102,7 @@ public JwtPublicKeySign getPrimitive(JwtRsaSsaPssPrivateKey keyProto)
 
       return new JwtPublicKeySign() {
         @Override
-        public String sign(RawJwt token) throws GeneralSecurityException {
+        public String signAndEncode(RawJwt token) throws GeneralSecurityException {
           String unsignedCompact =
               JwtFormat.createUnsignedCompact(algorithmName, token.getJsonPayload());
           return JwtFormat.createSignedCompact(

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtRsaSsaPssVerifyKeyManager.java
Patch:
@@ -92,7 +92,7 @@ public JwtPublicKeyVerify getPrimitive(JwtRsaSsaPssPublicKey keyProto)
             final String algorithmName = keyProto.getAlgorithm().name();
             return new JwtPublicKeyVerify() {
               @Override
-              public VerifiedJwt verify(String compact, JwtValidator validator)
+              public VerifiedJwt verifyAndDecode(String compact, JwtValidator validator)
                   throws GeneralSecurityException {
                 JwtFormat.validateASCII(compact);
                 String[] parts = compact.split("\\.", -1);

File: java_src/src/main/java/com/google/crypto/tink/mac/MacWrapper.java
Patch:
@@ -42,7 +42,7 @@ class MacWrapper implements PrimitiveWrapper<Mac, Mac> {
 
   private static class WrappedMac implements Mac {
     private final PrimitiveSet<Mac> primitives;
-    private final byte[] formatVersion = new byte[] {CryptoFormat.LEGACY_START_BYTE};
+    private final byte[] formatVersion = new byte[] {0};
 
     private WrappedMac(PrimitiveSet<Mac> primitives) {
       this.primitives = primitives;

File: java_src/src/main/java/com/google/crypto/tink/signature/PublicKeySignWrapper.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.crypto.tink.signature;
 
-import com.google.crypto.tink.CryptoFormat;
 import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.PublicKeySign;
@@ -43,7 +42,7 @@ public WrappedPublicKeySign(final PrimitiveSet<PublicKeySign> primitives) {
     @Override
     public byte[] sign(final byte[] data) throws GeneralSecurityException {
       if (primitives.getPrimary().getOutputPrefixType().equals(OutputPrefixType.LEGACY)) {
-        byte[] formatVersion = new byte[] {CryptoFormat.LEGACY_START_BYTE};
+        byte[] formatVersion = new byte[] {0};
         return Bytes.concat(
             primitives.getPrimary().getIdentifier(),
             primitives.getPrimary().getPrimitive().sign(Bytes.concat(data, formatVersion)));

File: java_src/src/main/java/com/google/crypto/tink/signature/PublicKeyVerifyWrapper.java
Patch:
@@ -55,14 +55,14 @@ public void verify(final byte[] signature, final byte[] data) throws GeneralSecu
         // schemes that output signatures that small.
         throw new GeneralSecurityException("signature too short");
       }
-      byte[] prefix = Arrays.copyOfRange(signature, 0, CryptoFormat.NON_RAW_PREFIX_SIZE);
+      byte[] prefix = Arrays.copyOf(signature, CryptoFormat.NON_RAW_PREFIX_SIZE);
       byte[] sigNoPrefix =
           Arrays.copyOfRange(signature, CryptoFormat.NON_RAW_PREFIX_SIZE, signature.length);
       List<PrimitiveSet.Entry<PublicKeyVerify>> entries = primitives.getPrimitive(prefix);
       for (PrimitiveSet.Entry<PublicKeyVerify> entry : entries) {
         try {
           if (entry.getOutputPrefixType().equals(OutputPrefixType.LEGACY)) {
-            final byte[] formatVersion = new byte[] {CryptoFormat.LEGACY_START_BYTE};
+            final byte[] formatVersion = new byte[] {0};
             final byte[] dataWithFormatVersion = Bytes.concat(data, formatVersion);
             entry.getPrimitive().verify(sigNoPrefix, dataWithFormatVersion);
           } else {

File: java_src/src/main/java/com/google/crypto/tink/subtle/ChaCha20Poly1305.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.crypto.tink.subtle;
 
 
+import java.security.GeneralSecurityException;
 import java.security.InvalidKeyException;
 
 /**
@@ -26,7 +27,7 @@
  * @since 1.1.0
  */
 public final class ChaCha20Poly1305 extends ChaCha20Poly1305Base {
-  public ChaCha20Poly1305(final byte[] key) throws InvalidKeyException {
+  public ChaCha20Poly1305(final byte[] key) throws GeneralSecurityException {
     super(key);
   }
 

File: java_src/src/main/java/com/google/crypto/tink/subtle/Enums.java
Patch:
@@ -21,6 +21,7 @@ public final class Enums {
   /** Hash type. */
   public enum HashType {
     SHA1, // Using SHA1 for digital signature is deprecated but HMAC-SHA1 is fine.
+    SHA224,
     SHA256,
     SHA384,
     SHA512,

File: java_src/src/main/java/com/google/crypto/tink/subtle/SubtleUtil.java
Patch:
@@ -64,6 +64,8 @@ public static String toDigestAlgo(HashType hash) throws GeneralSecurityException
     switch (hash) {
       case SHA1:
         return "SHA-1";
+      case SHA224:
+        return "SHA-224";
       case SHA256:
         return "SHA-256";
       case SHA384:

File: java_src/src/main/java/com/google/crypto/tink/subtle/XChaCha20Poly1305.java
Patch:
@@ -16,14 +16,15 @@
 
 package com.google.crypto.tink.subtle;
 
+import java.security.GeneralSecurityException;
 import java.security.InvalidKeyException;
 
 /**
  * XChaCha20Poly1305 AEAD construction, as described in
  * https://tools.ietf.org/html/draft-arciszewski-xchacha-01.
  */
 public final class XChaCha20Poly1305 extends ChaCha20Poly1305Base {
-  public XChaCha20Poly1305(final byte[] key) throws InvalidKeyException {
+  public XChaCha20Poly1305(final byte[] key) throws GeneralSecurityException {
     super(key);
   }
 

File: java_src/src/test/java/com/google/crypto/tink/aead/AeadKeyTemplatesTest.java
Patch:
@@ -212,14 +212,14 @@ public void testCreateKmsAeadKeyTemplate() throws Exception {
   }
 
   @Test
-  public void testCreateKmsEnvelopeAeadKeyFormat() throws Exception {
+  public void testCreateKmsEnvelopeAeadKeyTemplate() throws Exception {
     // Intentionally using "weird" or invalid values for parameters,
     // to test that the function correctly puts them in the resulting template.
     String kekUri = "some example KEK URI";
     KeyTemplate dekTemplate = AeadKeyTemplates.AES256_GCM;
     KeyTemplate template = AeadKeyTemplates.createKmsEnvelopeAeadKeyTemplate(kekUri, dekTemplate);
     assertEquals(new KmsEnvelopeAeadKeyManager().getKeyType(), template.getTypeUrl());
-    assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
+    assertEquals(OutputPrefixType.RAW, template.getOutputPrefixType());
 
     KmsEnvelopeAeadKeyFormat format =
         KmsEnvelopeAeadKeyFormat.parseFrom(

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtEcdsaVerifyKeyManagerTest.java
Patch:
@@ -83,7 +83,7 @@ public void createPrimitive_ok(JwtEcdsaAlgorithm algorithm) throws Exception {
     JwtPublicKeyVerify verifier = verifyManager.getPrimitive(publicKey, JwtPublicKeyVerify.class);
     RawJwt token = new RawJwt.Builder().build();
     JwtValidator validator = new JwtValidator.Builder().build();
-    verifier.verify(signer.sign(token), validator);
+    verifier.verifyAndDecode(signer.signAndEncode(token), validator);
   }
 
   @Test
@@ -103,6 +103,7 @@ public void createPrimitive_anotherKey_throw(JwtEcdsaAlgorithm algorithm) throws
     RawJwt token = new RawJwt.Builder().build();
     JwtValidator validator = new JwtValidator.Builder().build();
     assertThrows(
-        GeneralSecurityException.class, () -> verifier.verify(signer.sign(token), validator));
+        GeneralSecurityException.class,
+        () -> verifier.verifyAndDecode(signer.signAndEncode(token), validator));
   }
 }

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtRsaSsaPkcs1VerifyKeyManagerTest.java
Patch:
@@ -105,7 +105,7 @@ public void createPrimitive_ok(JwtRsaSsaPkcs1Algorithm algorithm, int keySize) t
     JwtPublicKeyVerify verifier = verifyManager.getPrimitive(publicKey, JwtPublicKeyVerify.class);
     RawJwt token = new RawJwt.Builder().build();
     JwtValidator validator = new JwtValidator.Builder().build();
-    verifier.verify(signer.sign(token), validator);
+    verifier.verifyAndDecode(signer.signAndEncode(token), validator);
   }
 
   @Test
@@ -130,6 +130,7 @@ public void createPrimitive_anotherKey_throw(JwtRsaSsaPkcs1Algorithm algorithm,
     RawJwt token = new RawJwt.Builder().build();
     JwtValidator validator = new JwtValidator.Builder().build();
     assertThrows(
-        GeneralSecurityException.class, () -> verifier.verify(signer.sign(token), validator));
+        GeneralSecurityException.class,
+        () -> verifier.verifyAndDecode(signer.signAndEncode(token), validator));
   }
 }

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtRsaSsaPssVerifyKeyManagerTest.java
Patch:
@@ -105,7 +105,7 @@ public void createPrimitive_ok(JwtRsaSsaPssAlgorithm algorithm, int keySize) thr
     JwtPublicKeyVerify verifier = verifyManager.getPrimitive(publicKey, JwtPublicKeyVerify.class);
     RawJwt token = new RawJwt.Builder().build();
     JwtValidator validator = new JwtValidator.Builder().build();
-    verifier.verify(signer.sign(token), validator);
+    verifier.verifyAndDecode(signer.signAndEncode(token), validator);
   }
 
   @Test
@@ -130,6 +130,7 @@ public void createPrimitive_anotherKey_throw(JwtRsaSsaPssAlgorithm algorithm, in
     RawJwt token = new RawJwt.Builder().build();
     JwtValidator validator = new JwtValidator.Builder().build();
     assertThrows(
-        GeneralSecurityException.class, () -> verifier.verify(signer.sign(token), validator));
+        GeneralSecurityException.class,
+        () -> verifier.verifyAndDecode(signer.signAndEncode(token), validator));
   }
 }

File: java_src/src/test/java/com/google/crypto/tink/aead/AeadKeyTemplatesTest.java
Patch:
@@ -212,14 +212,14 @@ public void testCreateKmsAeadKeyTemplate() throws Exception {
   }
 
   @Test
-  public void testCreateKmsEnvelopeAeadKeyFormat() throws Exception {
+  public void testCreateKmsEnvelopeAeadKeyTemplate() throws Exception {
     // Intentionally using "weird" or invalid values for parameters,
     // to test that the function correctly puts them in the resulting template.
     String kekUri = "some example KEK URI";
     KeyTemplate dekTemplate = AeadKeyTemplates.AES256_GCM;
     KeyTemplate template = AeadKeyTemplates.createKmsEnvelopeAeadKeyTemplate(kekUri, dekTemplate);
     assertEquals(new KmsEnvelopeAeadKeyManager().getKeyType(), template.getTypeUrl());
-    assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
+    assertEquals(OutputPrefixType.RAW, template.getOutputPrefixType());
 
     KmsEnvelopeAeadKeyFormat format =
         KmsEnvelopeAeadKeyFormat.parseFrom(

File: apps/paymentmethodtoken/src/main/java/com/google/crypto/tink/apps/paymentmethodtoken/PaymentMethodTokenRecipientKeyGen.java
Patch:
@@ -76,4 +76,6 @@ public static void main(String[] args) throws GeneralSecurityException, IOExcept
     generateKey();
     System.out.println("done.");
   }
+
+  private PaymentMethodTokenRecipientKeyGen() {}
 }

File: examples/java_src/helloworld/src/main/java/com/helloworld/HelloWorld.java
Patch:
@@ -45,4 +45,6 @@ public static void main(String[] args) throws Exception {
       System.exit(1);
     }
   }
+
+  private HelloWorld() {}
 }

File: java_src/src/main/java/com/google/crypto/tink/KeyTemplate.java
Patch:
@@ -46,7 +46,7 @@ public enum OutputPrefixType {
     CRUNCHY
   }
 
-  private static OutputPrefixType fromProto(
+  static OutputPrefixType fromProto(
       com.google.crypto.tink.proto.OutputPrefixType outputPrefixType) {
     switch (outputPrefixType) {
       case TINK:
@@ -62,8 +62,7 @@ private static OutputPrefixType fromProto(
     }
   }
 
-  private static com.google.crypto.tink.proto.OutputPrefixType toProto(
-      OutputPrefixType outputPrefixType) {
+  static com.google.crypto.tink.proto.OutputPrefixType toProto(OutputPrefixType outputPrefixType) {
     switch (outputPrefixType) {
       case TINK:
         return com.google.crypto.tink.proto.OutputPrefixType.TINK;

File: java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeysetManager.java
Patch:
@@ -287,7 +287,7 @@ private KeysetManager readOrGenerateNewKeyset() throws GeneralSecurityException,
         return read();
       } catch (FileNotFoundException ex) {
         // Not found, handle below.
-        Log.w(TAG, "keyset not found, will generate a new one", ex);
+        Log.i(TAG, "keyset not found, will generate a new one", ex);
       }
 
       // Not found.

File: java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeystoreKmsClient.java
Patch:
@@ -203,7 +203,7 @@ public static Aead getOrGenerateNewAeadKey(String keyUri)
       throws GeneralSecurityException, IOException {
     AndroidKeystoreKmsClient client = new AndroidKeystoreKmsClient();
     if (!client.hasKey(keyUri)) {
-      Log.w(TAG, String.format("key URI %s doesn't exist, generating a new one", keyUri));
+      Log.i(TAG, String.format("key URI %s doesn't exist, generating a new one", keyUri));
       generateNewAeadKey(keyUri);
     }
     return client.getAead(keyUri);

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtNames.java
Patch:
@@ -49,7 +49,7 @@ static String validate(String name) {
     return name;
   }
 
-  private static boolean isRegisteredName(String name) {
+  static boolean isRegisteredName(String name) {
     return name.equals(CLAIM_ISSUER)
         || name.equals(CLAIM_SUBJECT)
         || name.equals(CLAIM_AUDIENCE)

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtPublicKeySign.java
Patch:
@@ -27,6 +27,6 @@
 public interface JwtPublicKeySign {
   /** Computes a signature, and encodes the JWT and the signature in the
    * JWS compact serialization format. */
-  String sign(ToBeSignedJwt token) throws GeneralSecurityException;
+  String signAndEncode(RawJwt token) throws GeneralSecurityException;
 }
 

File: java_src/src/main/java/com/google/crypto/tink/config/TinkFipsEnabled.java
Patch:
@@ -33,7 +33,7 @@ public static boolean fipsModuleAvailable() {
 
   static Boolean checkConscryptUsesFipsBoringSsl() {
     try {
-      Class<?> cls = Class.forName("Conscrypt");
+      Class<?> cls = Class.forName("org.conscrypt.Conscrypt");
       Method isBoringSslFIPSBuild = cls.getMethod("isBoringSslFIPSBuild");
       return (Boolean) isBoringSslFIPSBuild.invoke(null);
     } catch (ReflectiveOperationException e) {

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtEcdsaSignKeyManager.java
Patch:
@@ -86,7 +86,7 @@ public JwtPublicKeySign getPrimitive(JwtEcdsaPrivateKey keyProto)
 
       return new JwtPublicKeySign() {
         @Override
-        public String sign(RawJwt token) throws GeneralSecurityException {
+        public String signAndEncode(RawJwt token) throws GeneralSecurityException {
           String unsignedCompact =
               JwtFormat.createUnsignedCompact(algorithmName, token.getJsonPayload());
           return JwtFormat.createSignedCompact(

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtEcdsaVerifyKeyManager.java
Patch:
@@ -92,7 +92,7 @@ public JwtPublicKeyVerify getPrimitive(JwtEcdsaPublicKey keyProto)
 
       return new JwtPublicKeyVerify() {
         @Override
-        public VerifiedJwt verify(String compact, JwtValidator validator)
+        public VerifiedJwt verifyAndDecode(String compact, JwtValidator validator)
             throws GeneralSecurityException {
           JwtFormat.validateASCII(compact);
           String[] parts = compact.split("\\.", -1);

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtHmacKeyManager.java
Patch:
@@ -77,15 +77,15 @@ public JwtHmac(String algorithm, PrfMac prfMac) {
     }
 
     @Override
-    public String sign(RawJwt token) throws GeneralSecurityException {
+    public String computeMacAndEncode(RawJwt token) throws GeneralSecurityException {
       String unsignedCompact =
           JwtFormat.createUnsignedCompact(algorithm, token.getJsonPayload());
       return JwtFormat.createSignedCompact(
           unsignedCompact, prfMac.computeMac(unsignedCompact.getBytes(US_ASCII)));
     }
 
     @Override
-    public VerifiedJwt verify(String compact, JwtValidator validator)
+    public VerifiedJwt verifyMacAndDecode(String compact, JwtValidator validator)
         throws GeneralSecurityException {
       JwtFormat.validateASCII(compact);
       String[] parts = compact.split("\\.", -1);

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtMac.java
Patch:
@@ -26,7 +26,7 @@
 @Immutable
 public interface JwtMac {
   /** Computes a MAC, and encodes the JWT and the MAC in the JWS compact serialization format. */
-  String sign(RawJwt token) throws GeneralSecurityException;
+  String computeMacAndEncode(RawJwt token) throws GeneralSecurityException;
 
   /**
    * Decodes and verifies a JWT in the JWS compact serialization format.
@@ -44,5 +44,6 @@ public interface JwtMac {
    * @throws GeneralSecurityException when the signature of the token could not be verified, the
    *     token contains an invalid claim or header, the token has been expired or can't be used yet
    */
-  VerifiedJwt verify(String compact, JwtValidator validator) throws GeneralSecurityException;
+  VerifiedJwt verifyMacAndDecode(String compact, JwtValidator validator)
+      throws GeneralSecurityException;
 }

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtPublicKeySign.java
Patch:
@@ -27,6 +27,6 @@
 public interface JwtPublicKeySign {
   /** Computes a signature, and encodes the JWT and the signature in the
    * JWS compact serialization format. */
-  String sign(RawJwt token) throws GeneralSecurityException;
+  String signAndEncode(RawJwt token) throws GeneralSecurityException;
 }
 

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtPublicKeySignWrapper.java
Patch:
@@ -50,8 +50,8 @@ public WrappedJwtPublicKeySign(final PrimitiveSet<JwtPublicKeySign> primitives)
     }
 
     @Override
-    public String sign(RawJwt token) throws GeneralSecurityException {
-      return primitives.getPrimary().getPrimitive().sign(token);
+    public String signAndEncode(RawJwt token) throws GeneralSecurityException {
+      return primitives.getPrimary().getPrimitive().signAndEncode(token);
     }
   }
 

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtPublicKeyVerifyWrapper.java
Patch:
@@ -46,15 +46,15 @@ public WrappedJwtPublicKeyVerify(PrimitiveSet<JwtPublicKeyVerify> primitives) {
     }
 
     @Override
-    public VerifiedJwt verify(String compact, JwtValidator validator)
+    public VerifiedJwt verifyAndDecode(String compact, JwtValidator validator)
         throws GeneralSecurityException {
 
       // All JWT keys are raw.
       List<PrimitiveSet.Entry<JwtPublicKeyVerify>> entries = primitives.getRawPrimitives();
       GeneralSecurityException interestingException = null;
       for (PrimitiveSet.Entry<JwtPublicKeyVerify> entry : entries) {
         try {
-          return entry.getPrimitive().verify(compact, validator);
+          return entry.getPrimitive().verifyAndDecode(compact, validator);
         } catch (GeneralSecurityException e) {
           if (e instanceof JwtInvalidException) {
             // Keep this exception so that we are able to throw a meaningful message in the end

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtRsaSsaPkcs1SignKeyManager.java
Patch:
@@ -100,7 +100,7 @@ public JwtPublicKeySign getPrimitive(JwtRsaSsaPkcs1PrivateKey keyProto)
       final String algorithmName = algorithm.name();
       return new JwtPublicKeySign() {
         @Override
-        public String sign(RawJwt token) throws GeneralSecurityException {
+        public String signAndEncode(RawJwt token) throws GeneralSecurityException {
           String unsignedCompact =
               JwtFormat.createUnsignedCompact(algorithmName, token.getJsonPayload());
           return JwtFormat.createSignedCompact(

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtRsaSsaPkcs1VerifyKeyManager.java
Patch:
@@ -77,7 +77,7 @@ public JwtPublicKeyVerify getPrimitive(JwtRsaSsaPkcs1PublicKey keyProto)
 
             return new JwtPublicKeyVerify() {
               @Override
-              public VerifiedJwt verify(String compact, JwtValidator validator)
+              public VerifiedJwt verifyAndDecode(String compact, JwtValidator validator)
                   throws GeneralSecurityException {
                 JwtFormat.validateASCII(compact);
                 String[] parts = compact.split("\\.", -1);

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtRsaSsaPssSignKeyManager.java
Patch:
@@ -102,7 +102,7 @@ public JwtPublicKeySign getPrimitive(JwtRsaSsaPssPrivateKey keyProto)
 
       return new JwtPublicKeySign() {
         @Override
-        public String sign(RawJwt token) throws GeneralSecurityException {
+        public String signAndEncode(RawJwt token) throws GeneralSecurityException {
           String unsignedCompact =
               JwtFormat.createUnsignedCompact(algorithmName, token.getJsonPayload());
           return JwtFormat.createSignedCompact(

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtRsaSsaPssVerifyKeyManager.java
Patch:
@@ -92,7 +92,7 @@ public JwtPublicKeyVerify getPrimitive(JwtRsaSsaPssPublicKey keyProto)
             final String algorithmName = keyProto.getAlgorithm().name();
             return new JwtPublicKeyVerify() {
               @Override
-              public VerifiedJwt verify(String compact, JwtValidator validator)
+              public VerifiedJwt verifyAndDecode(String compact, JwtValidator validator)
                   throws GeneralSecurityException {
                 JwtFormat.validateASCII(compact);
                 String[] parts = compact.split("\\.", -1);

File: java_src/src/main/java/com/google/crypto/tink/mac/MacWrapper.java
Patch:
@@ -42,7 +42,7 @@ class MacWrapper implements PrimitiveWrapper<Mac, Mac> {
 
   private static class WrappedMac implements Mac {
     private final PrimitiveSet<Mac> primitives;
-    private final byte[] formatVersion = new byte[] {CryptoFormat.LEGACY_START_BYTE};
+    private final byte[] formatVersion = new byte[] {0};
 
     private WrappedMac(PrimitiveSet<Mac> primitives) {
       this.primitives = primitives;

File: java_src/src/main/java/com/google/crypto/tink/signature/PublicKeySignWrapper.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.crypto.tink.signature;
 
-import com.google.crypto.tink.CryptoFormat;
 import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PrimitiveWrapper;
 import com.google.crypto.tink.PublicKeySign;
@@ -43,7 +42,7 @@ public WrappedPublicKeySign(final PrimitiveSet<PublicKeySign> primitives) {
     @Override
     public byte[] sign(final byte[] data) throws GeneralSecurityException {
       if (primitives.getPrimary().getOutputPrefixType().equals(OutputPrefixType.LEGACY)) {
-        byte[] formatVersion = new byte[] {CryptoFormat.LEGACY_START_BYTE};
+        byte[] formatVersion = new byte[] {0};
         return Bytes.concat(
             primitives.getPrimary().getIdentifier(),
             primitives.getPrimary().getPrimitive().sign(Bytes.concat(data, formatVersion)));

File: java_src/src/main/java/com/google/crypto/tink/signature/PublicKeyVerifyWrapper.java
Patch:
@@ -55,14 +55,14 @@ public void verify(final byte[] signature, final byte[] data) throws GeneralSecu
         // schemes that output signatures that small.
         throw new GeneralSecurityException("signature too short");
       }
-      byte[] prefix = Arrays.copyOfRange(signature, 0, CryptoFormat.NON_RAW_PREFIX_SIZE);
+      byte[] prefix = Arrays.copyOf(signature, CryptoFormat.NON_RAW_PREFIX_SIZE);
       byte[] sigNoPrefix =
           Arrays.copyOfRange(signature, CryptoFormat.NON_RAW_PREFIX_SIZE, signature.length);
       List<PrimitiveSet.Entry<PublicKeyVerify>> entries = primitives.getPrimitive(prefix);
       for (PrimitiveSet.Entry<PublicKeyVerify> entry : entries) {
         try {
           if (entry.getOutputPrefixType().equals(OutputPrefixType.LEGACY)) {
-            final byte[] formatVersion = new byte[] {CryptoFormat.LEGACY_START_BYTE};
+            final byte[] formatVersion = new byte[] {0};
             final byte[] dataWithFormatVersion = Bytes.concat(data, formatVersion);
             entry.getPrimitive().verify(sigNoPrefix, dataWithFormatVersion);
           } else {

File: java_src/src/main/java/com/google/crypto/tink/subtle/Enums.java
Patch:
@@ -21,6 +21,7 @@ public final class Enums {
   /** Hash type. */
   public enum HashType {
     SHA1, // Using SHA1 for digital signature is deprecated but HMAC-SHA1 is fine.
+    SHA224,
     SHA256,
     SHA384,
     SHA512,

File: java_src/src/main/java/com/google/crypto/tink/subtle/PrfHmacJce.java
Patch:
@@ -63,6 +63,9 @@ public PrfHmacJce(String algorithm, java.security.Key key) throws GeneralSecurit
       case "HMACSHA1":
         maxOutputLength = 20;
         break;
+      case "HMACSHA224":
+        maxOutputLength = 28;
+        break;
       case "HMACSHA256":
         maxOutputLength = 32;
         break;

File: java_src/src/main/java/com/google/crypto/tink/subtle/SubtleUtil.java
Patch:
@@ -64,6 +64,8 @@ public static String toDigestAlgo(HashType hash) throws GeneralSecurityException
     switch (hash) {
       case SHA1:
         return "SHA-1";
+      case SHA224:
+        return "SHA-224";
       case SHA256:
         return "SHA-256";
       case SHA384:

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtEcdsaVerifyKeyManagerTest.java
Patch:
@@ -83,7 +83,7 @@ public void createPrimitive_ok(JwtEcdsaAlgorithm algorithm) throws Exception {
     JwtPublicKeyVerify verifier = verifyManager.getPrimitive(publicKey, JwtPublicKeyVerify.class);
     RawJwt token = new RawJwt.Builder().build();
     JwtValidator validator = new JwtValidator.Builder().build();
-    verifier.verify(signer.sign(token), validator);
+    verifier.verifyAndDecode(signer.signAndEncode(token), validator);
   }
 
   @Test
@@ -103,6 +103,7 @@ public void createPrimitive_anotherKey_throw(JwtEcdsaAlgorithm algorithm) throws
     RawJwt token = new RawJwt.Builder().build();
     JwtValidator validator = new JwtValidator.Builder().build();
     assertThrows(
-        GeneralSecurityException.class, () -> verifier.verify(signer.sign(token), validator));
+        GeneralSecurityException.class,
+        () -> verifier.verifyAndDecode(signer.signAndEncode(token), validator));
   }
 }

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtRsaSsaPkcs1VerifyKeyManagerTest.java
Patch:
@@ -105,7 +105,7 @@ public void createPrimitive_ok(JwtRsaSsaPkcs1Algorithm algorithm, int keySize) t
     JwtPublicKeyVerify verifier = verifyManager.getPrimitive(publicKey, JwtPublicKeyVerify.class);
     RawJwt token = new RawJwt.Builder().build();
     JwtValidator validator = new JwtValidator.Builder().build();
-    verifier.verify(signer.sign(token), validator);
+    verifier.verifyAndDecode(signer.signAndEncode(token), validator);
   }
 
   @Test
@@ -130,6 +130,7 @@ public void createPrimitive_anotherKey_throw(JwtRsaSsaPkcs1Algorithm algorithm,
     RawJwt token = new RawJwt.Builder().build();
     JwtValidator validator = new JwtValidator.Builder().build();
     assertThrows(
-        GeneralSecurityException.class, () -> verifier.verify(signer.sign(token), validator));
+        GeneralSecurityException.class,
+        () -> verifier.verifyAndDecode(signer.signAndEncode(token), validator));
   }
 }

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtRsaSsaPssVerifyKeyManagerTest.java
Patch:
@@ -105,7 +105,7 @@ public void createPrimitive_ok(JwtRsaSsaPssAlgorithm algorithm, int keySize) thr
     JwtPublicKeyVerify verifier = verifyManager.getPrimitive(publicKey, JwtPublicKeyVerify.class);
     RawJwt token = new RawJwt.Builder().build();
     JwtValidator validator = new JwtValidator.Builder().build();
-    verifier.verify(signer.sign(token), validator);
+    verifier.verifyAndDecode(signer.signAndEncode(token), validator);
   }
 
   @Test
@@ -130,6 +130,7 @@ public void createPrimitive_anotherKey_throw(JwtRsaSsaPssAlgorithm algorithm, in
     RawJwt token = new RawJwt.Builder().build();
     JwtValidator validator = new JwtValidator.Builder().build();
     assertThrows(
-        GeneralSecurityException.class, () -> verifier.verify(signer.sign(token), validator));
+        GeneralSecurityException.class,
+        () -> verifier.verifyAndDecode(signer.signAndEncode(token), validator));
   }
 }

File: java_src/src/test/java/com/google/crypto/tink/streamingaead/StreamingAeadUtilTest.java
Patch:
@@ -32,7 +32,9 @@ public class StreamingAeadUtilTest {
   @Test
   public void testToHmacAlgo() throws Exception {
     assertEquals("HmacSha1", StreamingAeadUtil.toHmacAlgo(HashType.SHA1));
+    assertEquals("HmacSha224", StreamingAeadUtil.toHmacAlgo(HashType.SHA224));
     assertEquals("HmacSha256", StreamingAeadUtil.toHmacAlgo(HashType.SHA256));
+    assertEquals("HmacSha384", StreamingAeadUtil.toHmacAlgo(HashType.SHA384));
     assertEquals("HmacSha512", StreamingAeadUtil.toHmacAlgo(HashType.SHA512));
 
     NoSuchAlgorithmException ex =

File: java_src/src/main/java/com/google/crypto/tink/config/TinkFipsEnabled.java
Patch:
@@ -33,7 +33,7 @@ public static boolean fipsModuleAvailable() {
 
   static Boolean checkConscryptUsesFipsBoringSsl() {
     try {
-      Class<?> cls = Class.forName("Conscrypt");
+      Class<?> cls = Class.forName("org.conscrypt.Conscrypt");
       Method isBoringSslFIPSBuild = cls.getMethod("isBoringSslFIPSBuild");
       return (Boolean) isBoringSslFIPSBuild.invoke(null);
     } catch (ReflectiveOperationException e) {

File: java_src/src/main/java/com/google/crypto/tink/signature/SignaturePemKeysetReader.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.crypto.tink.signature;
 
 import com.google.crypto.tink.KeysetReader;
+import com.google.crypto.tink.PemKeyType;
 import com.google.crypto.tink.proto.EcdsaParams;
 import com.google.crypto.tink.proto.EcdsaPublicKey;
 import com.google.crypto.tink.proto.EcdsaSignatureEncoding;
@@ -31,7 +32,6 @@
 import com.google.crypto.tink.proto.RsaSsaPkcs1PublicKey;
 import com.google.crypto.tink.proto.RsaSsaPssParams;
 import com.google.crypto.tink.proto.RsaSsaPssPublicKey;
-import com.google.crypto.tink.subtle.PemKeyType;
 import com.google.crypto.tink.subtle.Random;
 import com.google.protobuf.ByteString;
 import java.io.BufferedReader;

File: java_src/src/test/java/com/google/crypto/tink/signature/SignaturePemKeysetReaderTest.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.crypto.tink.KeysetReader;
+import com.google.crypto.tink.PemKeyType;
 import com.google.crypto.tink.proto.EcdsaPublicKey;
 import com.google.crypto.tink.proto.EcdsaSignatureEncoding;
 import com.google.crypto.tink.proto.EllipticCurveType;
@@ -29,7 +30,6 @@
 import com.google.crypto.tink.proto.Keyset;
 import com.google.crypto.tink.proto.OutputPrefixType;
 import com.google.crypto.tink.proto.RsaSsaPssPublicKey;
-import com.google.crypto.tink.subtle.PemKeyType;
 import com.google.protobuf.ExtensionRegistryLite;
 import java.io.BufferedReader;
 import java.io.StringReader;

File: java_src/src/main/java/com/google/crypto/tink/signature/SignaturePemKeysetReader.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.crypto.tink.signature;
 
 import com.google.crypto.tink.KeysetReader;
-import com.google.crypto.tink.PemKeyType;
 import com.google.crypto.tink.proto.EcdsaParams;
 import com.google.crypto.tink.proto.EcdsaPublicKey;
 import com.google.crypto.tink.proto.EcdsaSignatureEncoding;
@@ -32,6 +31,7 @@
 import com.google.crypto.tink.proto.RsaSsaPkcs1PublicKey;
 import com.google.crypto.tink.proto.RsaSsaPssParams;
 import com.google.crypto.tink.proto.RsaSsaPssPublicKey;
+import com.google.crypto.tink.subtle.PemKeyType;
 import com.google.crypto.tink.subtle.Random;
 import com.google.protobuf.ByteString;
 import java.io.BufferedReader;

File: java_src/src/test/java/com/google/crypto/tink/signature/SignaturePemKeysetReaderTest.java
Patch:
@@ -19,7 +19,6 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.crypto.tink.KeysetReader;
-import com.google.crypto.tink.PemKeyType;
 import com.google.crypto.tink.proto.EcdsaPublicKey;
 import com.google.crypto.tink.proto.EcdsaSignatureEncoding;
 import com.google.crypto.tink.proto.EllipticCurveType;
@@ -30,6 +29,7 @@
 import com.google.crypto.tink.proto.Keyset;
 import com.google.crypto.tink.proto.OutputPrefixType;
 import com.google.crypto.tink.proto.RsaSsaPssPublicKey;
+import com.google.crypto.tink.subtle.PemKeyType;
 import com.google.protobuf.ExtensionRegistryLite;
 import java.io.BufferedReader;
 import java.io.StringReader;

File: java_src/src/main/java/com/google/crypto/tink/signature/SignaturePemKeysetReader.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.crypto.tink.signature;
 
 import com.google.crypto.tink.KeysetReader;
+import com.google.crypto.tink.PemKeyType;
 import com.google.crypto.tink.proto.EcdsaParams;
 import com.google.crypto.tink.proto.EcdsaPublicKey;
 import com.google.crypto.tink.proto.EcdsaSignatureEncoding;
@@ -31,7 +32,6 @@
 import com.google.crypto.tink.proto.RsaSsaPkcs1PublicKey;
 import com.google.crypto.tink.proto.RsaSsaPssParams;
 import com.google.crypto.tink.proto.RsaSsaPssPublicKey;
-import com.google.crypto.tink.subtle.PemKeyType;
 import com.google.crypto.tink.subtle.Random;
 import com.google.protobuf.ByteString;
 import java.io.BufferedReader;

File: java_src/src/test/java/com/google/crypto/tink/signature/SignaturePemKeysetReaderTest.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.crypto.tink.KeysetReader;
+import com.google.crypto.tink.PemKeyType;
 import com.google.crypto.tink.proto.EcdsaPublicKey;
 import com.google.crypto.tink.proto.EcdsaSignatureEncoding;
 import com.google.crypto.tink.proto.EllipticCurveType;
@@ -29,7 +30,6 @@
 import com.google.crypto.tink.proto.Keyset;
 import com.google.crypto.tink.proto.OutputPrefixType;
 import com.google.crypto.tink.proto.RsaSsaPssPublicKey;
-import com.google.crypto.tink.subtle.PemKeyType;
 import com.google.protobuf.ExtensionRegistryLite;
 import java.io.BufferedReader;
 import java.io.StringReader;

File: java_src/src/main/java/com/google/crypto/tink/subtle/EllipticCurves.java
Patch:
@@ -228,7 +228,7 @@ public static BigInteger getModulus(EllipticCurve curve) throws GeneralSecurityE
    * @param curve must be a prime order elliptic curve
    * @return the size of an element in bits
    */
-  static int fieldSizeInBits(EllipticCurve curve) throws GeneralSecurityException {
+  public static int fieldSizeInBits(EllipticCurve curve) throws GeneralSecurityException {
     return getModulus(curve).subtract(BigInteger.ONE).bitLength();
   }
 

File: apps/paymentmethodtoken/src/test/java/com/google/crypto/tink/apps/paymentmethodtoken/PaymentMethodTokenSenderTest.java
Patch:
@@ -73,8 +73,8 @@ public class PaymentMethodTokenSenderTest {
           + Instant.now().plus(Duration.standardDays(1)).getMillis()
           + "\",\n"
           + "      \"protocolVersion\": \"ECv2SigningOnly\"\n"
-          + "    }\n"
-          + "  ]\n"
+          + "    },\n"
+          + "  ],\n"
           + "}";
 
   /**

File: java_src/src/test/java/com/google/crypto/tink/JsonKeysetWriterTest.java
Patch:
@@ -131,8 +131,8 @@ public void testWrite_writesNegativeIdAsPositive() throws Exception {
 
     ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
     CleartextKeysetHandle.write(modifiedHandle, JsonKeysetWriter.withOutputStream(outputStream));
-    assertThat(outputStream.toString()).contains("\"primaryKeyId\": 4275736384");
-    assertThat(outputStream.toString()).contains("\"keyId\": 4275736384");
+    assertThat(outputStream.toString()).contains("\"primaryKeyId\":4275736384");
+    assertThat(outputStream.toString()).contains("\"keyId\":4275736384");
   }
 
 }

File: testing/java_src/javatests/com/google/crypto/tink/testing/TestingServicesTest.java
Patch:
@@ -159,7 +159,7 @@ public void toJson_success() throws Exception {
             + "      \"status\": \"ENABLED\""
             + "    }"
             + "  ]"
-            + "})";
+            + "}";
     KeysetFromJsonResponse fromResponse = keysetFromJson(keysetStub, jsonKeyset);
     assertThat(fromResponse.getErr()).isEmpty();
     byte[] output = fromResponse.getKeyset().toByteArray();

File: java_src/src/test/java/com/google/crypto/tink/JsonKeysetWriterTest.java
Patch:
@@ -131,8 +131,8 @@ public void testWrite_writesNegativeIdAsPositive() throws Exception {
 
     ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
     CleartextKeysetHandle.write(modifiedHandle, JsonKeysetWriter.withOutputStream(outputStream));
-    assertThat(outputStream.toString()).contains("\"primaryKeyId\":4275736384");
-    assertThat(outputStream.toString()).contains("\"keyId\":4275736384");
+    assertThat(outputStream.toString()).contains("\"primaryKeyId\": 4275736384");
+    assertThat(outputStream.toString()).contains("\"keyId\": 4275736384");
   }
 
 }

File: testing/java_src/javatests/com/google/crypto/tink/testing/TestingServicesTest.java
Patch:
@@ -159,7 +159,7 @@ public void toJson_success() throws Exception {
             + "      \"status\": \"ENABLED\""
             + "    }"
             + "  ]"
-            + "}";
+            + "})";
     KeysetFromJsonResponse fromResponse = keysetFromJson(keysetStub, jsonKeyset);
     assertThat(fromResponse.getErr()).isEmpty();
     byte[] output = fromResponse.getKeyset().toByteArray();

File: apps/paymentmethodtoken/src/test/java/com/google/crypto/tink/apps/paymentmethodtoken/PaymentMethodTokenSenderTest.java
Patch:
@@ -73,8 +73,8 @@ public class PaymentMethodTokenSenderTest {
           + Instant.now().plus(Duration.standardDays(1)).getMillis()
           + "\",\n"
           + "      \"protocolVersion\": \"ECv2SigningOnly\"\n"
-          + "    },\n"
-          + "  ],\n"
+          + "    }\n"
+          + "  ]\n"
           + "}";
 
   /**

File: java_src/src/test/java/com/google/crypto/tink/aead/AesCtrHmacAeadKeyManagerTest.java
Patch:
@@ -44,7 +44,7 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
-/** Tests for AesCtrHmaAeadKeyManager. */
+/** Tests for AesCtrHmacAeadKeyManager. */
 @RunWith(JUnit4.class)
 public class AesCtrHmacAeadKeyManagerTest {
   private final AesCtrHmacAeadKeyManager manager = new AesCtrHmacAeadKeyManager();

File: java_src/src/test/java/com/google/crypto/tink/JsonKeysetWriterTest.java
Patch:
@@ -131,8 +131,8 @@ public void testWrite_writesNegativeIdAsPositive() throws Exception {
 
     ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
     CleartextKeysetHandle.write(modifiedHandle, JsonKeysetWriter.withOutputStream(outputStream));
-    assertThat(outputStream.toString()).contains("\"primaryKeyId\": 4275736384");
-    assertThat(outputStream.toString()).contains("\"keyId\": 4275736384");
+    assertThat(outputStream.toString()).contains("\"primaryKeyId\":4275736384");
+    assertThat(outputStream.toString()).contains("\"keyId\":4275736384");
   }
 
 }

File: java_src/src/test/java/com/google/crypto/tink/jwt/RawJwtTest.java
Patch:
@@ -382,7 +382,7 @@ public void customClaimNames_success() throws Exception {
   }
 
   @Test
-  public void changingValuesInBuilderChangesAlreadBuiltToken() throws Exception {
+  public void changingValueInBuilderDoesntChangeAlreadyBuiltToken() throws Exception {
     RawJwt.Builder builder = new RawJwt.Builder();
 
     builder.setSubject("foo");
@@ -391,7 +391,7 @@ public void changingValuesInBuilderChangesAlreadBuiltToken() throws Exception {
     builder.setSubject("bar");
     RawJwt barToken = builder.build();
 
-    assertThat(fooToken.getSubject()).isEqualTo("bar");  // This is wrong, we should change that.
+    assertThat(fooToken.getSubject()).isEqualTo("foo");
     assertThat(barToken.getSubject()).isEqualTo("bar");
   }
 }

File: java_src/src/main/java/com/google/crypto/tink/jwt/JwtNames.java
Patch:
@@ -49,7 +49,7 @@ static String validate(String name) {
     return name;
   }
 
-  private static boolean isRegisteredName(String name) {
+  static boolean isRegisteredName(String name) {
     return name.equals(CLAIM_ISSUER)
         || name.equals(CLAIM_SUBJECT)
         || name.equals(CLAIM_AUDIENCE)

File: java_src/src/test/java/com/google/crypto/tink/jwt/JwtHmacKeyManagerTest.java
Patch:
@@ -326,7 +326,7 @@ public void computeVerify_canGetData() throws Exception {
             .setIssuer(issuer)
             .addAudience(audience)
             .setJwtId(jwtId)
-            .addClaim("amount", amount)
+            .addNumberClaim("amount", amount)
             .build();
     String compact = mac.createCompact(unverified);
     JwtValidator validator = new JwtValidator.Builder().setAudience(audience).build();

File: java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeysetManager.java
Patch:
@@ -287,7 +287,7 @@ private KeysetManager readOrGenerateNewKeyset() throws GeneralSecurityException,
         return read();
       } catch (FileNotFoundException ex) {
         // Not found, handle below.
-        Log.w(TAG, "keyset not found, will generate a new one", ex);
+        Log.i(TAG, "keyset not found, will generate a new one", ex);
       }
 
       // Not found.

File: java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeystoreKmsClient.java
Patch:
@@ -203,7 +203,7 @@ public static Aead getOrGenerateNewAeadKey(String keyUri)
       throws GeneralSecurityException, IOException {
     AndroidKeystoreKmsClient client = new AndroidKeystoreKmsClient();
     if (!client.hasKey(keyUri)) {
-      Log.w(TAG, String.format("key URI %s doesn't exist, generating a new one", keyUri));
+      Log.i(TAG, String.format("key URI %s doesn't exist, generating a new one", keyUri));
       generateNewAeadKey(keyUri);
     }
     return client.getAead(keyUri);

File: java_src/src/main/java/com/google/crypto/tink/CryptoFormat.java
Patch:
@@ -27,7 +27,7 @@
  */
 public final class CryptoFormat {
 
-  /** Prefix size of Tink and Legacy key types. */
+  /** Prefix size of Tink, Legacy and Crunchy output prefix types. */
   public static final int NON_RAW_PREFIX_SIZE = 5;
 
   /** Legacy or Crunchy prefix starts with \x00 and followed by a 4-byte key id. */
@@ -73,4 +73,6 @@ public static byte[] getOutputPrefix(Key key) throws GeneralSecurityException {
         throw new GeneralSecurityException("unknown output prefix type");
     }
   }
+
+  private CryptoFormat() {}
 }

File: java_src/src/main/java/com/google/crypto/tink/KeysetHandle.java
Patch:
@@ -327,7 +327,10 @@ public <P> P getPrimitive(Class<P> targetClassObject) throws GeneralSecurityExce
    * Returns a primitive from this keyset, using the given {@code customKeyManager} and the global
    * registry to get resources creating the primitive. The given keyManager will take precedence
    * when creating primitives over the globally registered keyManagers.
+   *
+   * @deprecated Register the keymanager and use the normal {@code getPrimitive}.
    */
+  @Deprecated
   public <P> P getPrimitive(KeyManager<P> customKeyManager, Class<P> targetClassObject)
       throws GeneralSecurityException {
     if (customKeyManager == null) {

File: java_src/src/main/java/com/google/crypto/tink/integration/awskms/AwsKmsAead.java
Patch:
@@ -66,7 +66,9 @@ public byte[] encrypt(final byte[] plaintext, final byte[] associatedData)
   public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData)
       throws GeneralSecurityException {
     try {
-      DecryptRequest req = new DecryptRequest().withCiphertextBlob(ByteBuffer.wrap(ciphertext));
+      DecryptRequest req =
+          new DecryptRequest().withKeyId(keyArn)
+              .withCiphertextBlob(ByteBuffer.wrap(ciphertext));
       if (associatedData != null && associatedData.length != 0) {
         req = req.addEncryptionContextEntry("associatedData", BinaryUtils.toHex(associatedData));
       }

File: java_src/src/main/java/com/google/crypto/tink/Catalogue.java
Patch:
@@ -43,5 +43,5 @@ public KeyManager<P> getKeyManager(String typeUrl, String primitiveName, int min
       throws GeneralSecurityException;
 
   /** Returns a new primitive wrapper for this primitive. */
-  public PrimitiveWrapper<P> getPrimitiveWrapper() throws GeneralSecurityException;
+  public PrimitiveWrapper<?, P> getPrimitiveWrapper() throws GeneralSecurityException;
 }

File: java_src/src/main/java/com/google/crypto/tink/mac/AesCmacKeyManager.java
Patch:
@@ -93,7 +93,7 @@ private static void validateParams(AesCmacParams params) throws GeneralSecurityE
 
   private static void validateSize(int size) throws GeneralSecurityException {
     if (size != KEY_SIZE_IN_BYTES) {
-      throw new GeneralSecurityException("AesCmacKey size wrong, must be 16 bytes");
+      throw new GeneralSecurityException("AesCmacKey size wrong, must be 32 bytes");
     }
   }
 

File: java_src/src/main/java/com/google/crypto/tink/JsonKeysetWriter.java
Patch:
@@ -79,6 +79,7 @@ public static KeysetWriter withPath(Path path) throws IOException {
   public void write(Keyset keyset) throws IOException {
     try {
       outputStream.write(toJson(keyset).toString(4).getBytes(UTF_8));
+      outputStream.write(System.lineSeparator().getBytes(UTF_8));
     } catch (JSONException e) {
       throw new IOException(e);
     } finally {
@@ -90,6 +91,7 @@ public void write(Keyset keyset) throws IOException {
   public void write(EncryptedKeyset keyset) throws IOException {
     try {
       outputStream.write(toJson(keyset).toString(4).getBytes(UTF_8));
+      outputStream.write(System.lineSeparator().getBytes(UTF_8));
     } catch (JSONException e) {
       throw new IOException(e);
     } finally {

File: java_src/src/main/java/com/google/crypto/tink/StreamingAead.java
Patch:
@@ -150,9 +150,9 @@ WritableByteChannel newEncryptingChannel(
    *       <li>{@code long size()} Returns the size of the plaintext. TODO: Decide whether the
    *           result should be authenticated)
    *       <li>{@code SeekableByteChannel truncate(long size)} throws {@link
-   *           NonWritableChannelException} because the channel is read-only.
-   *       <li>{@code int write(ByteBuffer src)} throws {@link NonWritableChannelException} because
-   *           the channel is read-only.
+   *           java.nio.channels.NonWritableChannelException } because the channel is read-only.
+   *       <li>{@code int write(ByteBuffer src)} throws {@link
+   *           java.nio.channels.NonWritableChannelException } because the channel is read-only.
    *       <li>{@code close()} closes the channel
    *       <li>{@code isOpen()}
    *     </ul>

File: java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeystoreKmsClient.java
Patch:
@@ -57,7 +57,7 @@ public AndroidKeystoreKmsClient() throws GeneralSecurityException {
    * Constructs an {@link AndroidKeystoreKmsClient} that is bound to a single key identified by
    * {@code uri}.
    *
-   * @deprecated use {@link AndroidKeystoreKmsClient#Builder}.
+   * @deprecated use {@link AndroidKeystoreKmsClient.Builder}.
    */
   @Deprecated
   public AndroidKeystoreKmsClient(String uri) {

File: java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeystoreKmsClient.java
Patch:
@@ -25,6 +25,7 @@
 import java.io.IOException;
 import java.security.GeneralSecurityException;
 import java.security.KeyStore;
+import java.util.Locale;
 import javax.crypto.KeyGenerator;
 
 /**
@@ -53,7 +54,7 @@ public AndroidKeystoreKmsClient() throws GeneralSecurityException {
    * {@code uri}.
    */
   public AndroidKeystoreKmsClient(String uri) {
-    if (!uri.toLowerCase().startsWith(PREFIX)) {
+    if (!uri.toLowerCase(Locale.US).startsWith(PREFIX)) {
       throw new IllegalArgumentException("key URI must starts with " + PREFIX);
     }
     this.keyUri = uri;
@@ -69,7 +70,7 @@ public boolean doesSupport(String uri) {
     if (this.keyUri != null && this.keyUri.equals(uri)) {
       return true;
     }
-    return this.keyUri == null && uri.toLowerCase().startsWith(PREFIX);
+    return this.keyUri == null && uri.toLowerCase(Locale.US).startsWith(PREFIX);
   }
 
   /**

File: java_src/src/main/java/com/google/crypto/tink/KeyTypeManager.java
Patch:
@@ -79,7 +79,7 @@ final Class<PrimitiveT> getPrimitiveClass() {
    * Constructs a new KeyTypeManager.
    *
    * <p>Takes an arbitrary number of {@link PrimitiveFactory} objects as input. These will be used
-   * and provided via {@link #createPrimitive} to the user.
+   * and provided via {@link #getPrimitive} to the user.
    *
    * @throws IllegalArgumentException if two of the passed in factories produce primitives of the
    *     same class.

File: java_src/src/main/java/com/google/crypto/tink/mac/MacKeyTemplates.java
Patch:
@@ -139,4 +139,6 @@ public static KeyTemplate createHmacKeyTemplate(int keySize, int tagSize, HashTy
         .setOutputPrefixType(OutputPrefixType.TINK)
         .build();
   }
+
+  private MacKeyTemplates() {}
 }

File: java_src/src/main/java/com/google/crypto/tink/mac/MacWrapper.java
Patch:
@@ -67,7 +67,7 @@ public void verifyMac(final byte[] mac, final byte[] data) throws GeneralSecurit
         // clearly insecure, thus should be discouraged.
         throw new GeneralSecurityException("tag too short");
       }
-      byte[] prefix = Arrays.copyOfRange(mac, 0, CryptoFormat.NON_RAW_PREFIX_SIZE);
+      byte[] prefix = Arrays.copyOf(mac, CryptoFormat.NON_RAW_PREFIX_SIZE);
       byte[] macNoPrefix = Arrays.copyOfRange(mac, CryptoFormat.NON_RAW_PREFIX_SIZE, mac.length);
       List<PrimitiveSet.Entry<Mac>> entries = primitives.getPrimitive(prefix);
       for (PrimitiveSet.Entry<Mac> entry : entries) {
@@ -80,7 +80,7 @@ public void verifyMac(final byte[] mac, final byte[] data) throws GeneralSecurit
           // If there is no exception, the MAC is valid and we can return.
           return;
         } catch (GeneralSecurityException e) {
-          logger.info("tag prefix matches a key, but cannot verify: " + e.toString());
+          logger.info("tag prefix matches a key, but cannot verify: " + e);
           // Ignored as we want to continue verification with the remaining keys.
         }
       }

File: java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeystoreAesGcm.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.crypto.tink.integration.android;
 
-import android.annotation.TargetApi;
 import android.os.Build.VERSION_CODES;
+import androidx.annotation.RequiresApi;
 import com.google.crypto.tink.Aead;
 import java.io.IOException;
 import java.security.GeneralSecurityException;
@@ -35,7 +35,7 @@
  *
  * @since 1.0.0
  */
-@TargetApi(VERSION_CODES.M)
+@RequiresApi(VERSION_CODES.M)
 public final class AndroidKeystoreAesGcm implements Aead {
   // All instances of this class use a 12 byte IV and a 16 byte tag.
   private static final int IV_SIZE_IN_BYTES = 12;

File: java_src/src/main/java/com/google/crypto/tink/integration/android/AndroidKeystoreKmsClient.java
Patch:
@@ -16,11 +16,11 @@
 
 package com.google.crypto.tink.integration.android;
 
-import android.annotation.TargetApi;
 import android.os.Build;
 import android.os.Build.VERSION_CODES;
 import android.security.keystore.KeyGenParameterSpec;
 import android.security.keystore.KeyProperties;
+import androidx.annotation.RequiresApi;
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KmsClient;
 import com.google.crypto.tink.subtle.Validators;
@@ -37,7 +37,7 @@
  *
  * @since 1.0.0
  */
-@TargetApi(VERSION_CODES.M)
+@RequiresApi(VERSION_CODES.M)
 public final class AndroidKeystoreKmsClient implements KmsClient {
   /** The prefix of all keys stored in Android Keystore. */
   public static final String PREFIX = "android-keystore://";

File: java_src/src/main/java/com/google/crypto/tink/prf/PrfKeyTemplates.java
Patch:
@@ -34,7 +34,7 @@ private static KeyTemplate createHkdfKeyTemplate() {
     return KeyTemplate.newBuilder()
         .setValue(format.toByteString())
         .setTypeUrl(HkdfPrfKeyManager.staticKeyType())
-        .setOutputPrefixType(OutputPrefixType.TINK)
+        .setOutputPrefixType(OutputPrefixType.RAW)
         .build();
   }
 

File: java_src/src/test/java/com/google/crypto/tink/prf/PrfKeyTemplatesTest.java
Patch:
@@ -31,7 +31,7 @@ public final class PrfKeyTemplatesTest {
   public void testHKDF_SHA256() throws Exception {
     assertThat(PrfKeyTemplates.HKDF_SHA256.getTypeUrl())
         .isEqualTo(new HkdfPrfKeyManager().getKeyType());
-    assertThat(PrfKeyTemplates.HKDF_SHA256.getOutputPrefixType()).isEqualTo(OutputPrefixType.TINK);
+    assertThat(PrfKeyTemplates.HKDF_SHA256.getOutputPrefixType()).isEqualTo(OutputPrefixType.RAW);
   }
 
   @Test

File: java/src/main/java/com/google/crypto/tink/KeysetHandle.java
Patch:
@@ -71,11 +71,8 @@ public KeysetInfo getKeysetInfo() {
    *     {@code keyTemplate}.
    * @throws GeneralSecurityException
    */
-  @SuppressWarnings("GuardedBy")
   public static final KeysetHandle generateNew(KeyTemplate keyTemplate)
       throws GeneralSecurityException {
-    // TODO(b/145386688): This access should be guarded by 'KeysetManager.withEmptyKeyset()', which
-    // is not currently held
     return KeysetManager.withEmptyKeyset().rotate(keyTemplate).getKeysetHandle();
   }
 

File: java/src/test/java/com/google/crypto/tink/aead/AesCtrHmacAeadKeyManagerTest.java
Patch:
@@ -20,6 +20,7 @@
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.Aead;
+import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.proto.AesCtrHmacAeadKey;
 import com.google.crypto.tink.proto.AesCtrHmacAeadKeyFormat;
 import com.google.crypto.tink.proto.AesCtrKeyFormat;
@@ -42,8 +43,8 @@
 @RunWith(JUnit4.class)
 public class AesCtrHmacAeadKeyManagerTest {
   private final AesCtrHmacAeadKeyManager manager = new AesCtrHmacAeadKeyManager();
-  private final AesCtrHmacAeadKeyManager.KeyFactory<AesCtrHmacAeadKeyFormat, AesCtrHmacAeadKey>
-      factory = manager.keyFactory();
+  private final KeyTypeManager.KeyFactory<AesCtrHmacAeadKeyFormat, AesCtrHmacAeadKey> factory =
+      manager.keyFactory();
 
   @Test
   public void basics() throws Exception {

File: java/src/test/java/com/google/crypto/tink/aead/AesCtrKeyManagerTest.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.proto.AesCtrKey;
 import com.google.crypto.tink.proto.AesCtrKeyFormat;
 import com.google.crypto.tink.proto.AesCtrParams;
@@ -38,7 +39,7 @@
 @RunWith(JUnit4.class)
 public class AesCtrKeyManagerTest {
   private final AesCtrKeyManager manager = new AesCtrKeyManager();
-  private final AesCtrKeyManager.KeyFactory<AesCtrKeyFormat, AesCtrKey> factory =
+  private final KeyTypeManager.KeyFactory<AesCtrKeyFormat, AesCtrKey> factory =
       manager.keyFactory();
 
   @Test

File: java/src/test/java/com/google/crypto/tink/aead/AesEaxKeyManagerTest.java
Patch:
@@ -22,6 +22,7 @@
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.Aead;
+import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.proto.AesEaxKey;
 import com.google.crypto.tink.proto.AesEaxKeyFormat;
 import com.google.crypto.tink.proto.AesEaxParams;
@@ -42,7 +43,7 @@
 @RunWith(JUnit4.class)
 public class AesEaxKeyManagerTest {
   private final AesEaxKeyManager manager = new AesEaxKeyManager();
-  private final AesEaxKeyManager.KeyFactory<AesEaxKeyFormat, AesEaxKey> factory =
+  private final KeyTypeManager.KeyFactory<AesEaxKeyFormat, AesEaxKey> factory =
       manager.keyFactory();
 
   @Test

File: java/src/test/java/com/google/crypto/tink/aead/AesGcmKeyManagerTest.java
Patch:
@@ -21,6 +21,7 @@
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.Aead;
+import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.proto.AesGcmKey;
 import com.google.crypto.tink.proto.AesGcmKeyFormat;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
@@ -41,7 +42,7 @@
 @RunWith(JUnit4.class)
 public class AesGcmKeyManagerTest {
   private final AesGcmKeyManager manager = new AesGcmKeyManager();
-  private final AesGcmKeyManager.KeyFactory<AesGcmKeyFormat, AesGcmKey> factory =
+  private final KeyTypeManager.KeyFactory<AesGcmKeyFormat, AesGcmKey> factory =
       manager.keyFactory();
 
   @Test

File: java/src/test/java/com/google/crypto/tink/aead/XChaCha20Poly1305KeyManagerTest.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.crypto.tink.Aead;
+import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
 import com.google.crypto.tink.proto.XChaCha20Poly1305Key;
 import com.google.crypto.tink.proto.XChaCha20Poly1305KeyFormat;
@@ -35,8 +36,7 @@
 @RunWith(JUnit4.class)
 public class XChaCha20Poly1305KeyManagerTest {
   private final XChaCha20Poly1305KeyManager manager = new XChaCha20Poly1305KeyManager();
-  private final XChaCha20Poly1305KeyManager.KeyFactory<
-          XChaCha20Poly1305KeyFormat, XChaCha20Poly1305Key>
+  private final KeyTypeManager.KeyFactory<XChaCha20Poly1305KeyFormat, XChaCha20Poly1305Key>
       factory = manager.keyFactory();
 
   @Test

File: java/src/test/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPrivateKeyManagerTest.java
Patch:
@@ -21,6 +21,7 @@
 
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.HybridEncrypt;
+import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.aead.AeadConfig;
 import com.google.crypto.tink.aead.AeadKeyTemplates;
 import com.google.crypto.tink.proto.EcPointFormat;
@@ -56,9 +57,8 @@ public static void setUp() throws Exception {
   }
 
   private final EciesAeadHkdfPrivateKeyManager manager = new EciesAeadHkdfPrivateKeyManager();
-  private final EciesAeadHkdfPrivateKeyManager.KeyFactory<
-          EciesAeadHkdfKeyFormat, EciesAeadHkdfPrivateKey>
-      factory = manager.keyFactory();
+  private final KeyTypeManager.KeyFactory<EciesAeadHkdfKeyFormat, EciesAeadHkdfPrivateKey> factory =
+      manager.keyFactory();
 
   @Test
   public void basics() throws Exception {

File: java/src/test/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPublicKeyManagerTest.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.HybridEncrypt;
+import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.aead.AeadConfig;
 import com.google.crypto.tink.aead.AeadKeyTemplates;
 import com.google.crypto.tink.proto.EcPointFormat;
@@ -44,9 +45,8 @@
 public final class EciesAeadHkdfPublicKeyManagerTest {
   private final EciesAeadHkdfPrivateKeyManager privateManager =
       new EciesAeadHkdfPrivateKeyManager();
-  private final EciesAeadHkdfPrivateKeyManager.KeyFactory<
-          EciesAeadHkdfKeyFormat, EciesAeadHkdfPrivateKey>
-      factory = privateManager.keyFactory();
+  private final KeyTypeManager.KeyFactory<EciesAeadHkdfKeyFormat, EciesAeadHkdfPrivateKey> factory =
+      privateManager.keyFactory();
   private final EciesAeadHkdfPublicKeyManager publicManager = new EciesAeadHkdfPublicKeyManager();
 
   @BeforeClass

File: java/src/test/java/com/google/crypto/tink/signature/EcdsaSignKeyManagerTest.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.proto.EcdsaKeyFormat;
 import com.google.crypto.tink.proto.EcdsaParams;
 import com.google.crypto.tink.proto.EcdsaPrivateKey;
@@ -39,7 +40,7 @@
 @RunWith(JUnit4.class)
 public class EcdsaSignKeyManagerTest {
   private final EcdsaSignKeyManager manager = new EcdsaSignKeyManager();
-  private final EcdsaSignKeyManager.KeyFactory<EcdsaKeyFormat, EcdsaPrivateKey> factory =
+  private final KeyTypeManager.KeyFactory<EcdsaKeyFormat, EcdsaPrivateKey> factory =
       manager.keyFactory();
 
   private static EcdsaKeyFormat createKeyFormat(

File: java/src/test/java/com/google/crypto/tink/signature/EcdsaVerifyKeyManagerTest.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.proto.EcdsaKeyFormat;
 import com.google.crypto.tink.proto.EcdsaParams;
@@ -55,7 +56,7 @@
 public class EcdsaVerifyKeyManagerTest {
   private final EcdsaSignKeyManager signManager = new EcdsaSignKeyManager();
   private final EcdsaVerifyKeyManager verifyManager = new EcdsaVerifyKeyManager();
-  private final EcdsaSignKeyManager.KeyFactory<EcdsaKeyFormat, EcdsaPrivateKey> factory =
+  private final KeyTypeManager.KeyFactory<EcdsaKeyFormat, EcdsaPrivateKey> factory =
       signManager.keyFactory();
 
   private EcdsaPrivateKey createKey(

File: java/src/test/java/com/google/crypto/tink/signature/Ed25519PrivateKeyManagerTest.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.proto.Ed25519KeyFormat;
@@ -40,7 +41,7 @@
 @RunWith(JUnit4.class)
 public class Ed25519PrivateKeyManagerTest {
   private final Ed25519PrivateKeyManager manager = new Ed25519PrivateKeyManager();
-  private final Ed25519PrivateKeyManager.KeyFactory<Ed25519KeyFormat, Ed25519PrivateKey> factory =
+  private final KeyTypeManager.KeyFactory<Ed25519KeyFormat, Ed25519PrivateKey> factory =
       manager.keyFactory();
 
   @Test

File: java/src/test/java/com/google/crypto/tink/signature/Ed25519PublicKeyManagerTest.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.proto.Ed25519KeyFormat;
@@ -36,7 +37,7 @@
 @RunWith(JUnit4.class)
 public class Ed25519PublicKeyManagerTest {
   private final Ed25519PrivateKeyManager signManager = new Ed25519PrivateKeyManager();
-  private final Ed25519PrivateKeyManager.KeyFactory<Ed25519KeyFormat, Ed25519PrivateKey> factory =
+  private final KeyTypeManager.KeyFactory<Ed25519KeyFormat, Ed25519PrivateKey> factory =
       signManager.keyFactory();
 
   private final Ed25519PublicKeyManager verifyManager = new Ed25519PublicKeyManager();

File: java/src/test/java/com/google/crypto/tink/signature/RsaSsaPkcs1SignKeyManagerTest.java
Patch:
@@ -20,6 +20,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.proto.HashType;
@@ -49,8 +50,8 @@
 @RunWith(JUnit4.class)
 public class RsaSsaPkcs1SignKeyManagerTest {
   private final RsaSsaPkcs1SignKeyManager manager = new RsaSsaPkcs1SignKeyManager();
-  private final RsaSsaPkcs1SignKeyManager.KeyFactory<RsaSsaPkcs1KeyFormat, RsaSsaPkcs1PrivateKey>
-      factory = manager.keyFactory();
+  private final KeyTypeManager.KeyFactory<RsaSsaPkcs1KeyFormat, RsaSsaPkcs1PrivateKey> factory =
+      manager.keyFactory();
 
   private static RsaSsaPkcs1KeyFormat createKeyFormat(
       HashType hashType, int modulusSizeInBits, BigInteger publicExponent) {

File: java/src/test/java/com/google/crypto/tink/signature/RsaSsaPkcs1VerifyKeyManagerTest.java
Patch:
@@ -18,6 +18,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.proto.HashType;
@@ -40,8 +41,8 @@
 @RunWith(JUnit4.class)
 public final class RsaSsaPkcs1VerifyKeyManagerTest {
   private final RsaSsaPkcs1SignKeyManager signManager = new RsaSsaPkcs1SignKeyManager();
-  private final RsaSsaPkcs1SignKeyManager.KeyFactory<RsaSsaPkcs1KeyFormat, RsaSsaPkcs1PrivateKey>
-      factory = signManager.keyFactory();
+  private final KeyTypeManager.KeyFactory<RsaSsaPkcs1KeyFormat, RsaSsaPkcs1PrivateKey> factory =
+      signManager.keyFactory();
 
   private final RsaSsaPkcs1VerifyKeyManager verifyManager = new RsaSsaPkcs1VerifyKeyManager();
 

File: java/src/test/java/com/google/crypto/tink/signature/RsaSsaPssSignKeyManagerTest.java
Patch:
@@ -20,6 +20,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.proto.HashType;
@@ -49,8 +50,8 @@
 @RunWith(JUnit4.class)
 public class RsaSsaPssSignKeyManagerTest {
   private final RsaSsaPssSignKeyManager manager = new RsaSsaPssSignKeyManager();
-  private final RsaSsaPssSignKeyManager.KeyFactory<RsaSsaPssKeyFormat, RsaSsaPssPrivateKey>
-      factory = manager.keyFactory();
+  private final KeyTypeManager.KeyFactory<RsaSsaPssKeyFormat, RsaSsaPssPrivateKey> factory =
+      manager.keyFactory();
 
   private static RsaSsaPssKeyFormat createKeyFormat(
       HashType sigHash,

File: java/src/test/java/com/google/crypto/tink/signature/RsaSsaPssVerifyKeyManagerTest.java
Patch:
@@ -18,6 +18,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.proto.HashType;
@@ -40,8 +41,8 @@
 @RunWith(JUnit4.class)
 public class RsaSsaPssVerifyKeyManagerTest {
   private final RsaSsaPssSignKeyManager signManager = new RsaSsaPssSignKeyManager();
-  private final RsaSsaPssSignKeyManager.KeyFactory<RsaSsaPssKeyFormat, RsaSsaPssPrivateKey>
-      factory = signManager.keyFactory();
+  private final KeyTypeManager.KeyFactory<RsaSsaPssKeyFormat, RsaSsaPssPrivateKey> factory =
+      signManager.keyFactory();
 
   private final RsaSsaPssVerifyKeyManager verifyManager = new RsaSsaPssVerifyKeyManager();
 

File: java/src/test/java/com/google/crypto/tink/streamingaead/AesCtrHmacStreamingKeyManagerTest.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.StreamingAead;
 import com.google.crypto.tink.proto.AesCtrHmacStreamingKey;
 import com.google.crypto.tink.proto.AesCtrHmacStreamingKeyFormat;
@@ -39,8 +40,7 @@
 @RunWith(JUnit4.class)
 public class AesCtrHmacStreamingKeyManagerTest {
   private final AesCtrHmacStreamingKeyManager manager = new AesCtrHmacStreamingKeyManager();
-  private final AesCtrHmacStreamingKeyManager.KeyFactory<
-          AesCtrHmacStreamingKeyFormat, AesCtrHmacStreamingKey>
+  private final KeyTypeManager.KeyFactory<AesCtrHmacStreamingKeyFormat, AesCtrHmacStreamingKey>
       factory = manager.keyFactory();
 
   // Returns an HmacParams.Builder with valid parameters

File: java/src/test/java/com/google/crypto/tink/streamingaead/AesGcmHkdfStreamingKeyManagerTest.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.KeyTypeManager;
 import com.google.crypto.tink.StreamingAead;
 import com.google.crypto.tink.proto.AesGcmHkdfStreamingKey;
 import com.google.crypto.tink.proto.AesGcmHkdfStreamingKeyFormat;
@@ -38,8 +39,7 @@
 @RunWith(JUnit4.class)
 public class AesGcmHkdfStreamingKeyManagerTest {
   private final AesGcmHkdfStreamingKeyManager manager = new AesGcmHkdfStreamingKeyManager();
-  private final AesGcmHkdfStreamingKeyManager.KeyFactory<
-          AesGcmHkdfStreamingKeyFormat, AesGcmHkdfStreamingKey>
+  private final KeyTypeManager.KeyFactory<AesGcmHkdfStreamingKeyFormat, AesGcmHkdfStreamingKey>
       factory = manager.keyFactory();
 
   private static AesGcmHkdfStreamingKeyFormat createKeyFormat(

File: java/src/main/java/com/google/crypto/tink/PublicKeySign.java
Patch:
@@ -37,7 +37,7 @@ public interface PublicKeySign {
   /**
    * Computes the signature for {@code data}.
    *
-   * @return the signature of {$code data}
+   * @return the signature of {@code data}
    */
   byte[] sign(final byte[] data) throws GeneralSecurityException;
 }

File: java/src/test/java/com/google/crypto/tink/subtle/AesSivTest.java
Patch:
@@ -112,7 +112,7 @@ public void testEncryptDecryptWithEmptyPlaintext() throws GeneralSecurityExcepti
         assertEquals(Hex.encode(plaintext), Hex.encode(rebuiltPlaintext));
 
         byte[] nullAadCiphertext = dead.encryptDeterministically(plaintext, null);
-        byte[] nullAadDecryptedText = dead.decryptDeterministically(nullAadDecryptedText, null);
+        byte[] nullAadDecryptedText = dead.decryptDeterministically(nullAadCiphertext, null);
         assertEquals(AesUtil.BLOCK_SIZE, nullAadCiphertext.length);
         assertEquals(Hex.encode(plaintext), Hex.encode(nullAadDecryptedText));
       }

File: java/src/test/java/com/google/crypto/tink/subtle/AesSivTest.java
Patch:
@@ -112,9 +112,9 @@ public void testEncryptDecryptWithEmptyPlaintext() throws GeneralSecurityExcepti
         assertEquals(Hex.encode(plaintext), Hex.encode(rebuiltPlaintext));
 
         byte[] nullAadCiphertext = dead.encryptDeterministically(plaintext, null);
-        byte[] nullAadDecryptedText = dead.encryptDeterministically(plaintext, null);
+        byte[] nullAadDecryptedText = dead.decryptDeterministically(nullAadDecryptedText, null);
         assertEquals(AesUtil.BLOCK_SIZE, nullAadCiphertext.length);
-        assertEquals(Hex.encode(nullAadDecryptedText), Hex.encode(nullAadCiphertext));
+        assertEquals(Hex.encode(plaintext), Hex.encode(nullAadDecryptedText));
       }
     }
   }

File: java/src/test/java/com/google/crypto/tink/subtle/AesGcmJceTest.java
Patch:
@@ -122,7 +122,9 @@ public void testModifyCiphertext() throws Exception {
             String.format(
                 "Decrypting with modified aad should fail: ciphertext = %s, aad = %s,"
                     + " description = %s",
-                ciphertext, mutation.value, mutation.description));
+                Arrays.toString(ciphertext),
+                Arrays.toString(mutation.value),
+                mutation.description));
       } catch (GeneralSecurityException ex) {
         // This is expected.
         // This could be a AeadBadTagException when the tag verification

File: java/src/test/java/com/google/crypto/tink/subtle/ChaCha20Poly1305Test.java
Patch:
@@ -127,7 +127,7 @@ public void testModifyCiphertext() throws Exception {
             String.format(
                 "Decrypting modified ciphertext should fail : ciphertext = %s, aad = %s,"
                     + " description = %s",
-                Hex.encode(mutation.value), aad, mutation.description));
+                Hex.encode(mutation.value), Arrays.toString(aad), mutation.description));
       } catch (GeneralSecurityException ex) {
         // This is expected.
         // This could be a AeadBadTagException when the tag verification

File: java/src/test/java/com/google/crypto/tink/subtle/EcdsaVerifyJceTest.java
Patch:
@@ -33,6 +33,7 @@
 import java.security.interfaces.ECPublicKey;
 import java.security.spec.ECParameterSpec;
 import java.security.spec.X509EncodedKeySpec;
+import java.util.Arrays;
 import org.json.JSONArray;
 import org.json.JSONObject;
 import org.junit.Test;
@@ -220,7 +221,7 @@ public void testModification() throws Exception {
               String.format(
                   "Invalid signature, should have thrown exception : signature = %s, message = %s, "
                       + " description = %s",
-                  Hex.encode(mutation.value), message, mutation.description));
+                  Hex.encode(mutation.value), Arrays.toString(message), mutation.description));
         } catch (GeneralSecurityException expected) {
           // Expected.
         }

File: java/src/main/java/com/google/crypto/tink/Registry.java
Patch:
@@ -648,12 +648,11 @@ private static String toCommaSeparatedString(Set<Class<?>> setOfClasses) {
     return b.toString();
   }
 
-  @SuppressWarnings("unchecked")
   private static <P> KeyManager<P> getKeyManagerInternal(String typeUrl, Class<P> primitiveClass)
       throws GeneralSecurityException {
     KeyManagerContainer container = getKeyManagerContainerOrThrow(typeUrl);
     if (primitiveClass == null) {
-      @SuppressWarnings("Unchecked")  // Only called from deprecated functions; unavoidable there.
+      @SuppressWarnings("unchecked")  // Only called from deprecated functions; unavoidable there.
       KeyManager<P> result = (KeyManager<P>) container.getUntypedKeyManager();
       return result;
     }

File: java/src/test/java/com/google/crypto/tink/RegistryTest.java
Patch:
@@ -152,7 +152,8 @@ public void testGetKeyManager_legacy_wrongType_shouldThrowException() throws Exc
       Aead unused = wrongType.getPrimitive(hmacKey);
       fail("Expected ClassCastException");
     } catch (ClassCastException e) {
-      assertExceptionContains(e, "MacJce cannot be cast to com.google.crypto.tink.Aead");
+      assertExceptionContains(e, "com.google.crypto.tink.Aead");
+      assertExceptionContains(e, "com.google.crypto.tink.subtle.MacJce");
     }
   }
 

File: java/src/main/java/com/google/crypto/tink/subtle/Ed25519.java
Patch:
@@ -145,7 +145,7 @@ boolean isOnCurve() {
       Field25519.mult(rhs, rhs, D);
       // rhs = z^4 + D * x^2 * y^2
       Field25519.sum(rhs, z4);
-      // Field25519.mult reduces its output, but Field25519.sub does not, so we have to manually
+      // Field25519.mult reduces its output, but Field25519.sum does not, so we have to manually
       // reduce it here.
       Field25519.reduce(rhs, rhs);
       // z^2 (y^2 - x^2) == z^4 + D * x^2 * y^2

File: java/src/main/java/com/google/crypto/tink/subtle/Ed25519.java
Patch:
@@ -145,6 +145,9 @@ boolean isOnCurve() {
       Field25519.mult(rhs, rhs, D);
       // rhs = z^4 + D * x^2 * y^2
       Field25519.sum(rhs, z4);
+      // Field25519.mult reduces its output, but Field25519.sub does not, so we have to manually
+      // reduce it here.
+      Field25519.reduce(rhs, rhs);
       // z^2 (y^2 - x^2) == z^4 + D * x^2 * y^2
       return Bytes.equal(Field25519.contract(lhs), Field25519.contract(rhs));
     }

File: java/src/main/java/com/google/crypto/tink/aead/AeadConfig.java
Patch:
@@ -34,7 +34,8 @@
  * @since 1.0.0
  */
 public final class AeadConfig {
-  public static final String AES_CTR_HMAC_AEAD_TYPE_URL = AesCtrHmacAeadKeyManager.TYPE_URL;
+  public static final String AES_CTR_HMAC_AEAD_TYPE_URL =
+      new AesCtrHmacAeadKeyManager().getKeyType();
   public static final String AES_GCM_TYPE_URL = new AesGcmKeyManager().getKeyType();
   public static final String AES_EAX_TYPE_URL = new AesEaxKeyManager().getKeyType();
   public static final String KMS_AEAD_TYPE_URL = new KmsAeadKeyManager().getKeyType();
@@ -96,7 +97,7 @@ public static void init() throws GeneralSecurityException {
    */
   public static void register() throws GeneralSecurityException {
     MacConfig.register();
-    Registry.registerKeyManager(new AesCtrHmacAeadKeyManager());
+    Registry.registerKeyManager(new AesCtrHmacAeadKeyManager(), /*newKeyAllowed=*/ true);
     Registry.registerKeyManager(new AesEaxKeyManager(), /*newKeyAllowed=*/ true);
     Registry.registerKeyManager(new AesGcmKeyManager(), /*newKeyAllowed=*/ true);
     Registry.registerKeyManager(new ChaCha20Poly1305KeyManager(), /*newKeyAllowed=*/ true);

File: java/src/main/java/com/google/crypto/tink/aead/AeadKeyTemplates.java
Patch:
@@ -202,7 +202,7 @@ public static KeyTemplate createAesCtrHmacAeadKeyTemplate(
         .build();
     return KeyTemplate.newBuilder()
         .setValue(format.toByteString())
-        .setTypeUrl(AesCtrHmacAeadKeyManager.TYPE_URL)
+        .setTypeUrl(new AesCtrHmacAeadKeyManager().getKeyType())
         .setOutputPrefixType(OutputPrefixType.TINK)
         .build();
   }

File: java/src/main/java/com/google/crypto/tink/hybrid/HybridKeyTemplates.java
Patch:
@@ -105,7 +105,7 @@ public static KeyTemplate createEciesAeadHkdfKeyTemplate(
             createEciesAeadHkdfParams(curve, hashType, ecPointFormat, demKeyTemplate, salt))
         .build();
     return KeyTemplate.newBuilder()
-        .setTypeUrl(EciesAeadHkdfPrivateKeyManager.TYPE_URL)
+        .setTypeUrl(new EciesAeadHkdfPrivateKeyManager().getKeyType())
         .setOutputPrefixType(OutputPrefixType.TINK)
         .setValue(format.toByteString())
         .build();

File: java/src/main/java/com/google/crypto/tink/mac/HmacKeyManager.java
Patch:
@@ -34,7 +34,7 @@
 /**
  * This key manager generates new {@code HmacKey} keys and produces new instances of {@code MacJce}.
  */
-class HmacKeyManager extends KeyTypeManager<HmacKey> {
+public class HmacKeyManager extends KeyTypeManager<HmacKey> {
   public HmacKeyManager() {
     super(
         HmacKey.class,

File: java/src/main/java/com/google/crypto/tink/signature/SignatureConfig.java
Patch:
@@ -92,8 +92,8 @@ public static void register() throws GeneralSecurityException {
     Registry.registerAsymmetricKeyManagers(
         new Ed25519PrivateKeyManager(), new Ed25519PublicKeyManager(), true);
 
-    Registry.registerKeyManager(new RsaSsaPkcs1SignKeyManager());
-    Registry.registerKeyManager(new RsaSsaPkcs1VerifyKeyManager());
+    Registry.registerAsymmetricKeyManagers(
+        new RsaSsaPkcs1SignKeyManager(), new RsaSsaPkcs1VerifyKeyManager(), true);
 
     Registry.registerAsymmetricKeyManagers(
         new RsaSsaPssSignKeyManager(), new RsaSsaPssVerifyKeyManager(), true);

File: java/src/main/java/com/google/crypto/tink/signature/SignatureKeyTemplates.java
Patch:
@@ -206,7 +206,7 @@ public static KeyTemplate createRsaSsaPkcs1KeyTemplate(
             .build();
     return KeyTemplate.newBuilder()
         .setValue(format.toByteString())
-        .setTypeUrl(RsaSsaPkcs1SignKeyManager.TYPE_URL)
+        .setTypeUrl(new RsaSsaPkcs1SignKeyManager().getKeyType())
         .setOutputPrefixType(OutputPrefixType.TINK)
         .build();
   }

File: java/src/main/java/com/google/crypto/tink/signature/SignaturePemKeysetReader.java
Patch:
@@ -158,13 +158,13 @@ private static KeyData convertRsaPublicKey(PemKeyType pemKeyType, RSAPublicKey k
           RsaSsaPkcs1Params.newBuilder().setHashType(getHashType(pemKeyType)).build();
       RsaSsaPkcs1PublicKey pkcs1PubKey =
           RsaSsaPkcs1PublicKey.newBuilder()
-              .setVersion(RsaSsaPkcs1VerifyKeyManager.VERSION)
+              .setVersion(new RsaSsaPkcs1VerifyKeyManager().getVersion())
               .setParams(params)
               .setE(ByteString.copyFrom(key.getPublicExponent().toByteArray()))
               .setN(ByteString.copyFrom(key.getModulus().toByteArray()))
               .build();
       return KeyData.newBuilder()
-          .setTypeUrl(RsaSsaPkcs1VerifyKeyManager.TYPE_URL)
+          .setTypeUrl(new RsaSsaPkcs1VerifyKeyManager().getKeyType())
           .setValue(pkcs1PubKey.toByteString())
           .setKeyMaterialType(KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC)
           .build();

File: java/src/test/java/com/google/crypto/tink/RegistryTest.java
Patch:
@@ -124,7 +124,7 @@ private void testGetKeyManager_shouldWork(String typeUrl, String className) thro
 
   @Test
   public void testGetKeyManager_legacy_shouldWork() throws Exception {
-    testGetKeyManager_shouldWork(AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL, "AesCtrHmacAeadKeyManager");
+    testGetKeyManager_shouldWork(AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL, "KeyManagerImpl");
     testGetKeyManager_shouldWork(AeadConfig.AES_EAX_TYPE_URL, "KeyManagerImpl");
     testGetKeyManager_shouldWork(MacConfig.HMAC_TYPE_URL, "KeyManagerImpl");
   }
@@ -249,7 +249,7 @@ public void testRegisterKeyManager_keyManagerFromAnotherClass_shouldThrowExcepti
     }
 
     KeyManager<Aead> manager = Registry.getKeyManager(AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL);
-    assertThat(manager.getClass().toString()).contains("AesCtrHmacAeadKeyManager");
+    assertThat(manager.getClass().toString()).contains("KeyManagerImpl");
   }
 
   @Test
@@ -317,7 +317,7 @@ public void testRegisterKeyManager_deprecated_keyManagerFromAnotherClass_shouldT
     }
 
     KeyManager<Aead> manager = Registry.getKeyManager(AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL);
-    assertThat(manager.getClass().toString()).contains("AesCtrHmacAeadKeyManager");
+    assertThat(manager.getClass().toString()).contains("KeyManagerImpl");
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/aead/AeadKeyTemplatesTest.java
Patch:
@@ -106,7 +106,7 @@ public void testCreateAesEaxKeyTemplate() throws Exception {
   @Test
   public void testAES128_CTR_HMAC_SHA256() throws Exception {
     KeyTemplate template = AeadKeyTemplates.AES128_CTR_HMAC_SHA256;
-    assertEquals(AesCtrHmacAeadKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesCtrHmacAeadKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     AesCtrHmacAeadKeyFormat format = AesCtrHmacAeadKeyFormat.parseFrom(template.getValue());
 
@@ -125,7 +125,7 @@ public void testAES128_CTR_HMAC_SHA256() throws Exception {
   @Test
   public void testAES256_CTR_HMAC_SHA256() throws Exception {
     KeyTemplate template = AeadKeyTemplates.AES256_CTR_HMAC_SHA256;
-    assertEquals(AesCtrHmacAeadKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesCtrHmacAeadKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     AesCtrHmacAeadKeyFormat format = AesCtrHmacAeadKeyFormat.parseFrom(template.getValue());
 
@@ -152,7 +152,7 @@ public void testCreateAesCtrHmacAeadKeyTemplate() throws Exception {
     HashType hashType = HashType.UNKNOWN_HASH;
     KeyTemplate template = AeadKeyTemplates.createAesCtrHmacAeadKeyTemplate(
         aesKeySize, ivSize, hmacKeySize, tagSize, hashType);
-    assertEquals(AesCtrHmacAeadKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesCtrHmacAeadKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     AesCtrHmacAeadKeyFormat format = AesCtrHmacAeadKeyFormat.parseFrom(template.getValue());
 

File: java/src/test/java/com/google/crypto/tink/hybrid/HybridKeyTemplatesTest.java
Patch:
@@ -40,7 +40,7 @@ public class HybridKeyTemplatesTest {
   @Test
   public void testECIES_P256_HKDF_HMAC_SHA256_AES128_GCM() throws Exception {
     KeyTemplate template = HybridKeyTemplates.ECIES_P256_HKDF_HMAC_SHA256_AES128_GCM;
-    assertEquals(EciesAeadHkdfPrivateKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new EciesAeadHkdfPrivateKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     EciesAeadHkdfKeyFormat format = EciesAeadHkdfKeyFormat.parseFrom(template.getValue());
 
@@ -60,7 +60,7 @@ public void testECIES_P256_HKDF_HMAC_SHA256_AES128_GCM() throws Exception {
   @Test
   public void testECIES_P256_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256() throws Exception {
     KeyTemplate template = HybridKeyTemplates.ECIES_P256_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256;
-    assertEquals(EciesAeadHkdfPrivateKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new EciesAeadHkdfPrivateKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     EciesAeadHkdfKeyFormat format = EciesAeadHkdfKeyFormat.parseFrom(template.getValue());
 
@@ -88,7 +88,7 @@ public void testCreateEciesAeadHkdfKeyTemplate() throws Exception {
     String salt = "some salt";
     KeyTemplate template = HybridKeyTemplates.createEciesAeadHkdfKeyTemplate(
         curveType, hashType, ecPointFormat, demKeyTemplate, salt.getBytes(UTF_8));
-    assertEquals(EciesAeadHkdfPrivateKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new EciesAeadHkdfPrivateKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     EciesAeadHkdfKeyFormat format = EciesAeadHkdfKeyFormat.parseFrom(template.getValue());
 

File: java/src/test/java/com/google/crypto/tink/signature/SignatureKeyTemplatesTest.java
Patch:
@@ -128,7 +128,7 @@ public void testED25519() throws Exception {
   @Test
   public void testRSA_SSA_PKCS1_3072_SHA256_F4() throws Exception {
     KeyTemplate template = SignatureKeyTemplates.RSA_SSA_PKCS1_3072_SHA256_F4;
-    assertEquals(RsaSsaPkcs1SignKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new RsaSsaPkcs1SignKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     RsaSsaPkcs1KeyFormat format = RsaSsaPkcs1KeyFormat.parseFrom(template.getValue());
 
@@ -142,7 +142,7 @@ public void testRSA_SSA_PKCS1_3072_SHA256_F4() throws Exception {
   @Test
   public void testRSA_SSA_PKCS1_4096_SHA512_F4() throws Exception {
     KeyTemplate template = SignatureKeyTemplates.RSA_SSA_PKCS1_4096_SHA512_F4;
-    assertEquals(RsaSsaPkcs1SignKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new RsaSsaPkcs1SignKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     RsaSsaPkcs1KeyFormat format = RsaSsaPkcs1KeyFormat.parseFrom(template.getValue());
 

File: java/src/main/java/com/google/crypto/tink/signature/SignatureConfig.java
Patch:
@@ -92,8 +92,8 @@ public static void register() throws GeneralSecurityException {
     Registry.registerAsymmetricKeyManagers(
         new Ed25519PrivateKeyManager(), new Ed25519PublicKeyManager(), true);
 
-    Registry.registerKeyManager(new RsaSsaPkcs1SignKeyManager());
-    Registry.registerKeyManager(new RsaSsaPkcs1VerifyKeyManager());
+    Registry.registerAsymmetricKeyManagers(
+        new RsaSsaPkcs1SignKeyManager(), new RsaSsaPkcs1VerifyKeyManager(), true);
 
     Registry.registerAsymmetricKeyManagers(
         new RsaSsaPssSignKeyManager(), new RsaSsaPssVerifyKeyManager(), true);

File: java/src/main/java/com/google/crypto/tink/signature/SignatureKeyTemplates.java
Patch:
@@ -206,7 +206,7 @@ public static KeyTemplate createRsaSsaPkcs1KeyTemplate(
             .build();
     return KeyTemplate.newBuilder()
         .setValue(format.toByteString())
-        .setTypeUrl(RsaSsaPkcs1SignKeyManager.TYPE_URL)
+        .setTypeUrl(new RsaSsaPkcs1SignKeyManager().getKeyType())
         .setOutputPrefixType(OutputPrefixType.TINK)
         .build();
   }

File: java/src/main/java/com/google/crypto/tink/signature/SignaturePemKeysetReader.java
Patch:
@@ -158,13 +158,13 @@ private static KeyData convertRsaPublicKey(PemKeyType pemKeyType, RSAPublicKey k
           RsaSsaPkcs1Params.newBuilder().setHashType(getHashType(pemKeyType)).build();
       RsaSsaPkcs1PublicKey pkcs1PubKey =
           RsaSsaPkcs1PublicKey.newBuilder()
-              .setVersion(RsaSsaPkcs1VerifyKeyManager.VERSION)
+              .setVersion(new RsaSsaPkcs1VerifyKeyManager().getVersion())
               .setParams(params)
               .setE(ByteString.copyFrom(key.getPublicExponent().toByteArray()))
               .setN(ByteString.copyFrom(key.getModulus().toByteArray()))
               .build();
       return KeyData.newBuilder()
-          .setTypeUrl(RsaSsaPkcs1VerifyKeyManager.TYPE_URL)
+          .setTypeUrl(new RsaSsaPkcs1VerifyKeyManager().getKeyType())
           .setValue(pkcs1PubKey.toByteString())
           .setKeyMaterialType(KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC)
           .build();

File: java/src/test/java/com/google/crypto/tink/signature/SignatureKeyTemplatesTest.java
Patch:
@@ -128,7 +128,7 @@ public void testED25519() throws Exception {
   @Test
   public void testRSA_SSA_PKCS1_3072_SHA256_F4() throws Exception {
     KeyTemplate template = SignatureKeyTemplates.RSA_SSA_PKCS1_3072_SHA256_F4;
-    assertEquals(RsaSsaPkcs1SignKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new RsaSsaPkcs1SignKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     RsaSsaPkcs1KeyFormat format = RsaSsaPkcs1KeyFormat.parseFrom(template.getValue());
 
@@ -142,7 +142,7 @@ public void testRSA_SSA_PKCS1_3072_SHA256_F4() throws Exception {
   @Test
   public void testRSA_SSA_PKCS1_4096_SHA512_F4() throws Exception {
     KeyTemplate template = SignatureKeyTemplates.RSA_SSA_PKCS1_4096_SHA512_F4;
-    assertEquals(RsaSsaPkcs1SignKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new RsaSsaPkcs1SignKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     RsaSsaPkcs1KeyFormat format = RsaSsaPkcs1KeyFormat.parseFrom(template.getValue());
 

File: java/src/main/java/com/google/crypto/tink/aead/AeadConfig.java
Patch:
@@ -34,7 +34,8 @@
  * @since 1.0.0
  */
 public final class AeadConfig {
-  public static final String AES_CTR_HMAC_AEAD_TYPE_URL = AesCtrHmacAeadKeyManager.TYPE_URL;
+  public static final String AES_CTR_HMAC_AEAD_TYPE_URL =
+      new AesCtrHmacAeadKeyManager().getKeyType();
   public static final String AES_GCM_TYPE_URL = new AesGcmKeyManager().getKeyType();
   public static final String AES_EAX_TYPE_URL = new AesEaxKeyManager().getKeyType();
   public static final String KMS_AEAD_TYPE_URL = new KmsAeadKeyManager().getKeyType();
@@ -96,7 +97,7 @@ public static void init() throws GeneralSecurityException {
    */
   public static void register() throws GeneralSecurityException {
     MacConfig.register();
-    Registry.registerKeyManager(new AesCtrHmacAeadKeyManager());
+    Registry.registerKeyManager(new AesCtrHmacAeadKeyManager(), /*newKeyAllowed=*/ true);
     Registry.registerKeyManager(new AesEaxKeyManager(), /*newKeyAllowed=*/ true);
     Registry.registerKeyManager(new AesGcmKeyManager(), /*newKeyAllowed=*/ true);
     Registry.registerKeyManager(new ChaCha20Poly1305KeyManager(), /*newKeyAllowed=*/ true);

File: java/src/main/java/com/google/crypto/tink/aead/AeadKeyTemplates.java
Patch:
@@ -202,7 +202,7 @@ public static KeyTemplate createAesCtrHmacAeadKeyTemplate(
         .build();
     return KeyTemplate.newBuilder()
         .setValue(format.toByteString())
-        .setTypeUrl(AesCtrHmacAeadKeyManager.TYPE_URL)
+        .setTypeUrl(new AesCtrHmacAeadKeyManager().getKeyType())
         .setOutputPrefixType(OutputPrefixType.TINK)
         .build();
   }

File: java/src/main/java/com/google/crypto/tink/mac/HmacKeyManager.java
Patch:
@@ -34,7 +34,7 @@
 /**
  * This key manager generates new {@code HmacKey} keys and produces new instances of {@code MacJce}.
  */
-class HmacKeyManager extends KeyTypeManager<HmacKey> {
+public class HmacKeyManager extends KeyTypeManager<HmacKey> {
   public HmacKeyManager() {
     super(
         HmacKey.class,

File: java/src/test/java/com/google/crypto/tink/RegistryTest.java
Patch:
@@ -124,7 +124,7 @@ private void testGetKeyManager_shouldWork(String typeUrl, String className) thro
 
   @Test
   public void testGetKeyManager_legacy_shouldWork() throws Exception {
-    testGetKeyManager_shouldWork(AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL, "AesCtrHmacAeadKeyManager");
+    testGetKeyManager_shouldWork(AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL, "KeyManagerImpl");
     testGetKeyManager_shouldWork(AeadConfig.AES_EAX_TYPE_URL, "KeyManagerImpl");
     testGetKeyManager_shouldWork(MacConfig.HMAC_TYPE_URL, "KeyManagerImpl");
   }
@@ -249,7 +249,7 @@ public void testRegisterKeyManager_keyManagerFromAnotherClass_shouldThrowExcepti
     }
 
     KeyManager<Aead> manager = Registry.getKeyManager(AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL);
-    assertThat(manager.getClass().toString()).contains("AesCtrHmacAeadKeyManager");
+    assertThat(manager.getClass().toString()).contains("KeyManagerImpl");
   }
 
   @Test
@@ -317,7 +317,7 @@ public void testRegisterKeyManager_deprecated_keyManagerFromAnotherClass_shouldT
     }
 
     KeyManager<Aead> manager = Registry.getKeyManager(AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL);
-    assertThat(manager.getClass().toString()).contains("AesCtrHmacAeadKeyManager");
+    assertThat(manager.getClass().toString()).contains("KeyManagerImpl");
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/aead/AeadKeyTemplatesTest.java
Patch:
@@ -106,7 +106,7 @@ public void testCreateAesEaxKeyTemplate() throws Exception {
   @Test
   public void testAES128_CTR_HMAC_SHA256() throws Exception {
     KeyTemplate template = AeadKeyTemplates.AES128_CTR_HMAC_SHA256;
-    assertEquals(AesCtrHmacAeadKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesCtrHmacAeadKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     AesCtrHmacAeadKeyFormat format = AesCtrHmacAeadKeyFormat.parseFrom(template.getValue());
 
@@ -125,7 +125,7 @@ public void testAES128_CTR_HMAC_SHA256() throws Exception {
   @Test
   public void testAES256_CTR_HMAC_SHA256() throws Exception {
     KeyTemplate template = AeadKeyTemplates.AES256_CTR_HMAC_SHA256;
-    assertEquals(AesCtrHmacAeadKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesCtrHmacAeadKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     AesCtrHmacAeadKeyFormat format = AesCtrHmacAeadKeyFormat.parseFrom(template.getValue());
 
@@ -152,7 +152,7 @@ public void testCreateAesCtrHmacAeadKeyTemplate() throws Exception {
     HashType hashType = HashType.UNKNOWN_HASH;
     KeyTemplate template = AeadKeyTemplates.createAesCtrHmacAeadKeyTemplate(
         aesKeySize, ivSize, hmacKeySize, tagSize, hashType);
-    assertEquals(AesCtrHmacAeadKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesCtrHmacAeadKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     AesCtrHmacAeadKeyFormat format = AesCtrHmacAeadKeyFormat.parseFrom(template.getValue());
 

File: java/src/main/java/com/google/crypto/tink/hybrid/HybridKeyTemplates.java
Patch:
@@ -105,7 +105,7 @@ public static KeyTemplate createEciesAeadHkdfKeyTemplate(
             createEciesAeadHkdfParams(curve, hashType, ecPointFormat, demKeyTemplate, salt))
         .build();
     return KeyTemplate.newBuilder()
-        .setTypeUrl(EciesAeadHkdfPrivateKeyManager.TYPE_URL)
+        .setTypeUrl(new EciesAeadHkdfPrivateKeyManager().getKeyType())
         .setOutputPrefixType(OutputPrefixType.TINK)
         .setValue(format.toByteString())
         .build();

File: java/src/test/java/com/google/crypto/tink/hybrid/HybridKeyTemplatesTest.java
Patch:
@@ -40,7 +40,7 @@ public class HybridKeyTemplatesTest {
   @Test
   public void testECIES_P256_HKDF_HMAC_SHA256_AES128_GCM() throws Exception {
     KeyTemplate template = HybridKeyTemplates.ECIES_P256_HKDF_HMAC_SHA256_AES128_GCM;
-    assertEquals(EciesAeadHkdfPrivateKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new EciesAeadHkdfPrivateKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     EciesAeadHkdfKeyFormat format = EciesAeadHkdfKeyFormat.parseFrom(template.getValue());
 
@@ -60,7 +60,7 @@ public void testECIES_P256_HKDF_HMAC_SHA256_AES128_GCM() throws Exception {
   @Test
   public void testECIES_P256_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256() throws Exception {
     KeyTemplate template = HybridKeyTemplates.ECIES_P256_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256;
-    assertEquals(EciesAeadHkdfPrivateKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new EciesAeadHkdfPrivateKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     EciesAeadHkdfKeyFormat format = EciesAeadHkdfKeyFormat.parseFrom(template.getValue());
 
@@ -88,7 +88,7 @@ public void testCreateEciesAeadHkdfKeyTemplate() throws Exception {
     String salt = "some salt";
     KeyTemplate template = HybridKeyTemplates.createEciesAeadHkdfKeyTemplate(
         curveType, hashType, ecPointFormat, demKeyTemplate, salt.getBytes(UTF_8));
-    assertEquals(EciesAeadHkdfPrivateKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new EciesAeadHkdfPrivateKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     EciesAeadHkdfKeyFormat format = EciesAeadHkdfKeyFormat.parseFrom(template.getValue());
 

File: java/src/main/java/com/google/crypto/tink/signature/SignatureConfig.java
Patch:
@@ -95,8 +95,8 @@ public static void register() throws GeneralSecurityException {
     Registry.registerKeyManager(new RsaSsaPkcs1SignKeyManager());
     Registry.registerKeyManager(new RsaSsaPkcs1VerifyKeyManager());
 
-    Registry.registerKeyManager(new RsaSsaPssSignKeyManager());
-    Registry.registerKeyManager(new RsaSsaPssVerifyKeyManager());
+    Registry.registerAsymmetricKeyManagers(
+        new RsaSsaPssSignKeyManager(), new RsaSsaPssVerifyKeyManager(), true);
 
     Registry.registerPrimitiveWrapper(new PublicKeySignWrapper());
     Registry.registerPrimitiveWrapper(new PublicKeyVerifyWrapper());

File: java/src/main/java/com/google/crypto/tink/signature/SignatureKeyTemplates.java
Patch:
@@ -267,7 +267,7 @@ public static KeyTemplate createRsaSsaPssKeyTemplate(
             .build();
     return KeyTemplate.newBuilder()
         .setValue(format.toByteString())
-        .setTypeUrl(RsaSsaPssSignKeyManager.TYPE_URL)
+        .setTypeUrl(new RsaSsaPssSignKeyManager().getKeyType())
         .setOutputPrefixType(OutputPrefixType.TINK)
         .build();
   }

File: java/src/main/java/com/google/crypto/tink/signature/SignaturePemKeysetReader.java
Patch:
@@ -177,13 +177,13 @@ private static KeyData convertRsaPublicKey(PemKeyType pemKeyType, RSAPublicKey k
               .build();
       RsaSsaPssPublicKey pssPubKey =
           RsaSsaPssPublicKey.newBuilder()
-              .setVersion(RsaSsaPssVerifyKeyManager.VERSION)
+              .setVersion(new RsaSsaPssVerifyKeyManager().getVersion())
               .setParams(params)
               .setE(ByteString.copyFrom(key.getPublicExponent().toByteArray()))
               .setN(ByteString.copyFrom(key.getModulus().toByteArray()))
               .build();
       return KeyData.newBuilder()
-          .setTypeUrl(RsaSsaPssVerifyKeyManager.TYPE_URL)
+          .setTypeUrl(new RsaSsaPssVerifyKeyManager().getKeyType())
           .setValue(pssPubKey.toByteString())
           .setKeyMaterialType(KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC)
           .build();

File: java/src/test/java/com/google/crypto/tink/signature/SignatureKeyTemplatesTest.java
Patch:
@@ -156,7 +156,7 @@ public void testRSA_SSA_PKCS1_4096_SHA512_F4() throws Exception {
   @Test
   public void testRSA_SSA_PSS_3072_SHA256_SHA256_32_F4() throws Exception {
     KeyTemplate template = SignatureKeyTemplates.RSA_SSA_PSS_3072_SHA256_SHA256_32_F4;
-    assertEquals(RsaSsaPssSignKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new RsaSsaPssSignKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     RsaSsaPssKeyFormat format = RsaSsaPssKeyFormat.parseFrom(template.getValue());
 
@@ -172,7 +172,7 @@ public void testRSA_SSA_PSS_3072_SHA256_SHA256_32_F4() throws Exception {
   @Test
   public void testRSA_SSA_PSS_4096_SHA512_SHA512_64_F4() throws Exception {
     KeyTemplate template = SignatureKeyTemplates.RSA_SSA_PSS_4096_SHA512_SHA512_64_F4;
-    assertEquals(RsaSsaPssSignKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new RsaSsaPssSignKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     RsaSsaPssKeyFormat format = RsaSsaPssKeyFormat.parseFrom(template.getValue());
 

File: java/src/main/java/com/google/crypto/tink/signature/Ed25519PrivateKeyManager.java
Patch:
@@ -74,6 +74,7 @@ public Ed25519PrivateKey parseKey(ByteString byteString) throws InvalidProtocolB
   @Override
   public void validateKey(Ed25519PrivateKey keyProto) throws GeneralSecurityException {
     Validators.validateVersion(keyProto.getVersion(), getVersion());
+    new Ed25519PublicKeyManager().validateKey(keyProto.getPublicKey());
     if (keyProto.getKeyValue().size() != Ed25519Sign.SECRET_KEY_LEN) {
       throw new GeneralSecurityException("invalid Ed25519 private key: incorrect key length");
     }

File: java/src/main/java/com/google/crypto/tink/signature/SignatureKeyTemplates.java
Patch:
@@ -141,7 +141,7 @@ public final class SignatureKeyTemplates {
    */
   public static final KeyTemplate ED25519 =
       KeyTemplate.newBuilder()
-          .setTypeUrl(Ed25519PrivateKeyManager.TYPE_URL)
+          .setTypeUrl(new Ed25519PrivateKeyManager().getKeyType())
           .setOutputPrefixType(OutputPrefixType.TINK)
           .build();
 

File: java/src/test/java/com/google/crypto/tink/signature/SignatureKeyTemplatesTest.java
Patch:
@@ -120,7 +120,7 @@ public void testCreateEcdsaKeyTemplate() throws Exception {
   @Test
   public void testED25519() throws Exception {
     KeyTemplate template = SignatureKeyTemplates.ED25519;
-    assertEquals(Ed25519PrivateKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new Ed25519PrivateKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     assertTrue(template.getValue().isEmpty()); // Empty format.
   }

File: java/src/main/java/com/google/crypto/tink/aead/AeadConfig.java
Patch:
@@ -38,7 +38,8 @@ public final class AeadConfig {
   public static final String AES_GCM_TYPE_URL = new AesGcmKeyManager().getKeyType();
   public static final String AES_EAX_TYPE_URL = new AesEaxKeyManager().getKeyType();
   public static final String KMS_AEAD_TYPE_URL = new KmsAeadKeyManager().getKeyType();
-  public static final String KMS_ENVELOPE_AEAD_TYPE_URL = KmsEnvelopeAeadKeyManager.TYPE_URL;
+  public static final String KMS_ENVELOPE_AEAD_TYPE_URL =
+      new KmsEnvelopeAeadKeyManager().getKeyType();
   public static final String CHACHA20_POLY1305_TYPE_URL =
       new ChaCha20Poly1305KeyManager().getKeyType();
   public static final String XCHACHA20_POLY1305_TYPE_URL =
@@ -100,7 +101,7 @@ public static void register() throws GeneralSecurityException {
     Registry.registerKeyManager(new AesGcmKeyManager(), /*newKeyAllowed=*/ true);
     Registry.registerKeyManager(new ChaCha20Poly1305KeyManager(), /*newKeyAllowed=*/ true);
     Registry.registerKeyManager(new KmsAeadKeyManager(), /*newKeyAllowed=*/ true);
-    Registry.registerKeyManager(new KmsEnvelopeAeadKeyManager());
+    Registry.registerKeyManager(new KmsEnvelopeAeadKeyManager(), /*newKeyAllowed=*/ true);
     Registry.registerKeyManager(new XChaCha20Poly1305KeyManager(), /*newKeyAllowed=*/ true);
     Registry.registerPrimitiveWrapper(new AeadWrapper());
   }

File: java/src/main/java/com/google/crypto/tink/aead/AeadKeyTemplates.java
Patch:
@@ -235,7 +235,7 @@ public static KeyTemplate createKmsEnvelopeAeadKeyTemplate(
         .build();
     return KeyTemplate.newBuilder()
         .setValue(format.toByteString())
-        .setTypeUrl(KmsEnvelopeAeadKeyManager.TYPE_URL)
+        .setTypeUrl(new KmsEnvelopeAeadKeyManager().getKeyType())
         .setOutputPrefixType(OutputPrefixType.TINK)
         .build();
   }

File: java/src/test/java/com/google/crypto/tink/aead/AeadKeyTemplatesTest.java
Patch:
@@ -204,7 +204,7 @@ public void testCreateKmsEnvelopeAeadKeyFormat() throws Exception {
     String kekUri = "some example KEK URI";
     KeyTemplate dekTemplate = AeadKeyTemplates.AES256_GCM;
     KeyTemplate template = AeadKeyTemplates.createKmsEnvelopeAeadKeyTemplate(kekUri, dekTemplate);
-    assertEquals(KmsEnvelopeAeadKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new KmsEnvelopeAeadKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
 
     KmsEnvelopeAeadKeyFormat format = KmsEnvelopeAeadKeyFormat.parseFrom(template.getValue());

File: java/src/main/java/com/google/crypto/tink/aead/AeadConfig.java
Patch:
@@ -37,7 +37,7 @@ public final class AeadConfig {
   public static final String AES_CTR_HMAC_AEAD_TYPE_URL = AesCtrHmacAeadKeyManager.TYPE_URL;
   public static final String AES_GCM_TYPE_URL = new AesGcmKeyManager().getKeyType();
   public static final String AES_EAX_TYPE_URL = new AesEaxKeyManager().getKeyType();
-  public static final String KMS_AEAD_TYPE_URL = KmsAeadKeyManager.TYPE_URL;
+  public static final String KMS_AEAD_TYPE_URL = new KmsAeadKeyManager().getKeyType();
   public static final String KMS_ENVELOPE_AEAD_TYPE_URL = KmsEnvelopeAeadKeyManager.TYPE_URL;
   public static final String CHACHA20_POLY1305_TYPE_URL =
       new ChaCha20Poly1305KeyManager().getKeyType();
@@ -99,7 +99,7 @@ public static void register() throws GeneralSecurityException {
     Registry.registerKeyManager(new AesEaxKeyManager(), /*newKeyAllowed=*/ true);
     Registry.registerKeyManager(new AesGcmKeyManager(), /*newKeyAllowed=*/ true);
     Registry.registerKeyManager(new ChaCha20Poly1305KeyManager(), /*newKeyAllowed=*/ true);
-    Registry.registerKeyManager(new KmsAeadKeyManager());
+    Registry.registerKeyManager(new KmsAeadKeyManager(), /*newKeyAllowed=*/ true);
     Registry.registerKeyManager(new KmsEnvelopeAeadKeyManager());
     Registry.registerKeyManager(new XChaCha20Poly1305KeyManager(), /*newKeyAllowed=*/ true);
     Registry.registerPrimitiveWrapper(new AeadWrapper());

File: java/src/main/java/com/google/crypto/tink/aead/AeadKeyTemplates.java
Patch:
@@ -217,7 +217,7 @@ public static KeyTemplate createKmsAeadKeyTemplate(String keyUri) {
         .build();
     return KeyTemplate.newBuilder()
         .setValue(format.toByteString())
-        .setTypeUrl(KmsAeadKeyManager.TYPE_URL)
+        .setTypeUrl(new KmsAeadKeyManager().getKeyType())
         .setOutputPrefixType(OutputPrefixType.TINK)
         .build();
   }

File: java/src/test/java/com/google/crypto/tink/aead/AeadKeyTemplatesTest.java
Patch:
@@ -190,7 +190,7 @@ public void testCreateKmsAeadKeyTemplate() throws Exception {
     // to test that the function correctly puts them in the resulting template.
     String keyUri = "some example URI";
     KeyTemplate template = AeadKeyTemplates.createKmsAeadKeyTemplate(keyUri);
-    assertEquals(KmsAeadKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new KmsAeadKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
 
     KmsAeadKeyFormat format = KmsAeadKeyFormat.parseFrom(template.getValue());

File: java/src/main/java/com/google/crypto/tink/aead/AeadConfig.java
Patch:
@@ -36,7 +36,7 @@
 public final class AeadConfig {
   public static final String AES_CTR_HMAC_AEAD_TYPE_URL = AesCtrHmacAeadKeyManager.TYPE_URL;
   public static final String AES_GCM_TYPE_URL = new AesGcmKeyManager().getKeyType();
-  public static final String AES_EAX_TYPE_URL = AesEaxKeyManager.TYPE_URL;
+  public static final String AES_EAX_TYPE_URL = new AesEaxKeyManager().getKeyType();
   public static final String KMS_AEAD_TYPE_URL = KmsAeadKeyManager.TYPE_URL;
   public static final String KMS_ENVELOPE_AEAD_TYPE_URL = KmsEnvelopeAeadKeyManager.TYPE_URL;
   public static final String CHACHA20_POLY1305_TYPE_URL =
@@ -96,7 +96,7 @@ public static void init() throws GeneralSecurityException {
   public static void register() throws GeneralSecurityException {
     MacConfig.register();
     Registry.registerKeyManager(new AesCtrHmacAeadKeyManager());
-    Registry.registerKeyManager(new AesEaxKeyManager());
+    Registry.registerKeyManager(new AesEaxKeyManager(), /*newKeyAllowed=*/ true);
     Registry.registerKeyManager(new AesGcmKeyManager(), /*newKeyAllowed=*/ true);
     Registry.registerKeyManager(new ChaCha20Poly1305KeyManager(), /*newKeyAllowed=*/ true);
     Registry.registerKeyManager(new KmsAeadKeyManager());

File: java/src/main/java/com/google/crypto/tink/aead/AeadKeyTemplates.java
Patch:
@@ -176,7 +176,7 @@ public static KeyTemplate createAesEaxKeyTemplate(int keySize, int ivSize) {
         .build();
     return KeyTemplate.newBuilder()
         .setValue(format.toByteString())
-        .setTypeUrl(AesEaxKeyManager.TYPE_URL)
+        .setTypeUrl(new AesEaxKeyManager().getKeyType())
         .setOutputPrefixType(OutputPrefixType.TINK)
         .build();
   }

File: java/src/test/java/com/google/crypto/tink/RegistryTest.java
Patch:
@@ -125,15 +125,15 @@ private void testGetKeyManager_shouldWork(String typeUrl, String className) thro
   @Test
   public void testGetKeyManager_legacy_shouldWork() throws Exception {
     testGetKeyManager_shouldWork(AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL, "AesCtrHmacAeadKeyManager");
-    testGetKeyManager_shouldWork(AeadConfig.AES_EAX_TYPE_URL, "AesEaxKeyManager");
+    testGetKeyManager_shouldWork(AeadConfig.AES_EAX_TYPE_URL, "KeyManagerImpl");
     testGetKeyManager_shouldWork(MacConfig.HMAC_TYPE_URL, "KeyManagerImpl");
   }
 
   @Test
   public void testGetKeyManager_shouldWorkAesEax() throws Exception {
     assertThat(
             Registry.getKeyManager(AeadConfig.AES_EAX_TYPE_URL, Aead.class).getClass().toString())
-        .contains("AesEaxKeyManager");
+        .contains("KeyManagerImpl");
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/aead/AeadKeyTemplatesTest.java
Patch:
@@ -68,7 +68,7 @@ public void testCreateAesGcmKeyTemplate() throws Exception {
   @Test
   public void testAES128_EAX() throws Exception {
     KeyTemplate template = AeadKeyTemplates.AES128_EAX;
-    assertEquals(AesEaxKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesEaxKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     AesEaxKeyFormat format = AesEaxKeyFormat.parseFrom(template.getValue());
     assertEquals(16, format.getKeySize());
@@ -79,7 +79,7 @@ public void testAES128_EAX() throws Exception {
   @Test
   public void testAES256_EAX() throws Exception {
     KeyTemplate template = AeadKeyTemplates.AES256_EAX;
-    assertEquals(AesEaxKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesEaxKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     AesEaxKeyFormat format = AesEaxKeyFormat.parseFrom(template.getValue());
     assertEquals(32, format.getKeySize());
@@ -94,7 +94,7 @@ public void testCreateAesEaxKeyTemplate() throws Exception {
     int keySize = 42;
     int ivSize = 72;
     KeyTemplate template = AeadKeyTemplates.createAesEaxKeyTemplate(keySize, ivSize);
-    assertEquals(AesEaxKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesEaxKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
 
     AesEaxKeyFormat format = AesEaxKeyFormat.parseFrom(template.getValue());

File: java/src/main/java/com/google/crypto/tink/aead/AeadKeyTemplates.java
Patch:
@@ -146,7 +146,7 @@ public final class AeadKeyTemplates {
    */
   public static final KeyTemplate XCHACHA20_POLY1305 =
       KeyTemplate.newBuilder()
-          .setTypeUrl(XChaCha20Poly1305KeyManager.TYPE_URL)
+          .setTypeUrl(new XChaCha20Poly1305KeyManager().getKeyType())
           .setOutputPrefixType(OutputPrefixType.TINK)
           .build();
 

File: java/src/test/java/com/google/crypto/tink/aead/AeadKeyTemplatesTest.java
Patch:
@@ -179,7 +179,7 @@ public void testCHACHA20_POLY1305() throws Exception {
   @Test
   public void testXCHACHA20_POLY1305() throws Exception {
     KeyTemplate template = AeadKeyTemplates.XCHACHA20_POLY1305;
-    assertEquals(XChaCha20Poly1305KeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new XChaCha20Poly1305KeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     assertTrue(template.getValue().isEmpty()); // Empty format.
   }

File: java/src/main/java/com/google/crypto/tink/streamingaead/StreamingAeadConfig.java
Patch:
@@ -37,7 +37,7 @@
  */
 public final class StreamingAeadConfig {
   public static final String AES_CTR_HMAC_STREAMINGAEAD_TYPE_URL =
-      AesCtrHmacStreamingKeyManager.TYPE_URL;
+      new AesCtrHmacStreamingKeyManager().getKeyType();
   public static final String AES_GCM_HKDF_STREAMINGAEAD_TYPE_URL =
       new AesGcmHkdfStreamingKeyManager().getKeyType();
 
@@ -74,7 +74,7 @@ public static void init() throws GeneralSecurityException {
    * @since 1.2.0
    */
   public static void register() throws GeneralSecurityException {
-    Registry.registerKeyManager(new AesCtrHmacStreamingKeyManager());
+    Registry.registerKeyManager(new AesCtrHmacStreamingKeyManager(), /* newKeyAllowed = */ true);
     Registry.registerKeyManager(new AesGcmHkdfStreamingKeyManager(), /* newKeyAllowed = */ true);
     Registry.registerPrimitiveWrapper(new StreamingAeadWrapper());
   }

File: java/src/main/java/com/google/crypto/tink/streamingaead/StreamingAeadKeyTemplates.java
Patch:
@@ -129,7 +129,7 @@ public static KeyTemplate createAesCtrHmacStreamingKeyTemplate(
         .build();
     return KeyTemplate.newBuilder()
         .setValue(format.toByteString())
-        .setTypeUrl(AesCtrHmacStreamingKeyManager.TYPE_URL)
+        .setTypeUrl(new AesCtrHmacStreamingKeyManager().getKeyType())
         .setOutputPrefixType(OutputPrefixType.RAW)
         .build();
   }

File: java/src/test/java/com/google/crypto/tink/streamingaead/StreamingAeadKeyTemplatesTest.java
Patch:
@@ -33,7 +33,7 @@ public class StreamingAeadKeyTemplatesTest {
   @Test
   public void testAES128_CTR_HMAC_SHA256_4KB() throws Exception {
     KeyTemplate template = StreamingAeadKeyTemplates.AES128_CTR_HMAC_SHA256_4KB;
-    assertEquals(AesCtrHmacStreamingKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesCtrHmacStreamingKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.RAW, template.getOutputPrefixType());
     AesCtrHmacStreamingKeyFormat format = AesCtrHmacStreamingKeyFormat.parseFrom(
         template.getValue());
@@ -49,7 +49,7 @@ public void testAES128_CTR_HMAC_SHA256_4KB() throws Exception {
   @Test
   public void testAES256_CTR_HMAC_SHA256_4KB() throws Exception {
     KeyTemplate template = StreamingAeadKeyTemplates.AES256_CTR_HMAC_SHA256_4KB;
-    assertEquals(AesCtrHmacStreamingKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesCtrHmacStreamingKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.RAW, template.getOutputPrefixType());
     AesCtrHmacStreamingKeyFormat format = AesCtrHmacStreamingKeyFormat.parseFrom(
         template.getValue());
@@ -103,7 +103,7 @@ public void testCreateAesCtrHmacStreamingKeyTemplate() throws Exception {
     KeyTemplate template = StreamingAeadKeyTemplates.createAesCtrHmacStreamingKeyTemplate(
         mainKeySize, hkdfHashType, derivedKeySize,
         macHashType, tagSize, ciphertextSegmentSize);
-    assertEquals(AesCtrHmacStreamingKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesCtrHmacStreamingKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.RAW, template.getOutputPrefixType());
     AesCtrHmacStreamingKeyFormat format = AesCtrHmacStreamingKeyFormat.parseFrom(
         template.getValue());

File: java/src/main/java/com/google/crypto/tink/streamingaead/StreamingAeadConfig.java
Patch:
@@ -39,7 +39,7 @@ public final class StreamingAeadConfig {
   public static final String AES_CTR_HMAC_STREAMINGAEAD_TYPE_URL =
       AesCtrHmacStreamingKeyManager.TYPE_URL;
   public static final String AES_GCM_HKDF_STREAMINGAEAD_TYPE_URL =
-      AesGcmHkdfStreamingKeyManager.TYPE_URL;
+      new AesGcmHkdfStreamingKeyManager().getKeyType();
 
   /** @deprecated */
   @Deprecated
@@ -75,7 +75,7 @@ public static void init() throws GeneralSecurityException {
    */
   public static void register() throws GeneralSecurityException {
     Registry.registerKeyManager(new AesCtrHmacStreamingKeyManager());
-    Registry.registerKeyManager(new AesGcmHkdfStreamingKeyManager());
+    Registry.registerKeyManager(new AesGcmHkdfStreamingKeyManager(), /* newKeyAllowed = */ true);
     Registry.registerPrimitiveWrapper(new StreamingAeadWrapper());
   }
 }

File: java/src/main/java/com/google/crypto/tink/streamingaead/StreamingAeadKeyTemplates.java
Patch:
@@ -153,7 +153,7 @@ public static KeyTemplate createAesGcmHkdfStreamingKeyTemplate(
             .build();
     return KeyTemplate.newBuilder()
         .setValue(format.toByteString())
-        .setTypeUrl(AesGcmHkdfStreamingKeyManager.TYPE_URL)
+        .setTypeUrl(new AesGcmHkdfStreamingKeyManager().getKeyType())
         .setOutputPrefixType(OutputPrefixType.RAW)
         .build();
   }

File: java/src/test/java/com/google/crypto/tink/streamingaead/StreamingAeadKeyTemplatesTest.java
Patch:
@@ -65,7 +65,7 @@ public void testAES256_CTR_HMAC_SHA256_4KB() throws Exception {
   @Test
   public void testAES128_GCM_HKDF_4KB() throws Exception {
     KeyTemplate template = StreamingAeadKeyTemplates.AES128_GCM_HKDF_4KB;
-    assertEquals(AesGcmHkdfStreamingKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesGcmHkdfStreamingKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.RAW, template.getOutputPrefixType());
     AesGcmHkdfStreamingKeyFormat format = AesGcmHkdfStreamingKeyFormat.parseFrom(
         template.getValue());
@@ -79,7 +79,7 @@ public void testAES128_GCM_HKDF_4KB() throws Exception {
   @Test
   public void testAES256_GCM_HKDF_4KB() throws Exception {
     KeyTemplate template = StreamingAeadKeyTemplates.AES256_GCM_HKDF_4KB;
-    assertEquals(AesGcmHkdfStreamingKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesGcmHkdfStreamingKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.RAW, template.getOutputPrefixType());
     AesGcmHkdfStreamingKeyFormat format = AesGcmHkdfStreamingKeyFormat.parseFrom(
         template.getValue());
@@ -126,7 +126,7 @@ public void testCreateAesGcmHkdfStreamingKeyTemplate() throws Exception {
     HashType hkdfHashType = HashType.SHA512;
     KeyTemplate template = StreamingAeadKeyTemplates.createAesGcmHkdfStreamingKeyTemplate(
         mainKeySize, hkdfHashType, derivedKeySize, ciphertextSegmentSize);
-    assertEquals(AesGcmHkdfStreamingKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesGcmHkdfStreamingKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.RAW, template.getOutputPrefixType());
     AesGcmHkdfStreamingKeyFormat format = AesGcmHkdfStreamingKeyFormat.parseFrom(
         template.getValue());

File: java/src/main/java/com/google/crypto/tink/mac/MacConfig.java
Patch:
@@ -35,7 +35,7 @@
  * @since 1.0.0
  */
 public final class MacConfig {
-  public static final String HMAC_TYPE_URL = HmacKeyManager.TYPE_URL;
+  public static final String HMAC_TYPE_URL = new HmacKeyManager().getKeyType();
 
   /** @deprecated */
   @Deprecated
@@ -83,7 +83,7 @@ public static void init() throws GeneralSecurityException {
    * @since 1.2.0
    */
   public static void register() throws GeneralSecurityException {
-    Registry.registerKeyManager(new HmacKeyManager());
+    Registry.registerKeyManager(new HmacKeyManager(), true);
     Registry.registerKeyManager(new AesCmacKeyManager(), true);
     Registry.registerPrimitiveWrapper(new MacWrapper());
   }

File: java/src/main/java/com/google/crypto/tink/mac/MacKeyTemplates.java
Patch:
@@ -132,7 +132,7 @@ public static KeyTemplate createHmacKeyTemplate(int keySize, int tagSize, HashTy
         .build();
     return KeyTemplate.newBuilder()
         .setValue(format.toByteString())
-        .setTypeUrl(HmacKeyManager.TYPE_URL)
+        .setTypeUrl(new HmacKeyManager().getKeyType())
         .setOutputPrefixType(OutputPrefixType.TINK)
         .build();
   }

File: java/src/test/java/com/google/crypto/tink/RegistryTest.java
Patch:
@@ -126,7 +126,7 @@ private void testGetKeyManager_shouldWork(String typeUrl, String className) thro
   public void testGetKeyManager_legacy_shouldWork() throws Exception {
     testGetKeyManager_shouldWork(AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL, "AesCtrHmacAeadKeyManager");
     testGetKeyManager_shouldWork(AeadConfig.AES_EAX_TYPE_URL, "AesEaxKeyManager");
-    testGetKeyManager_shouldWork(MacConfig.HMAC_TYPE_URL, "HmacKeyManager");
+    testGetKeyManager_shouldWork(MacConfig.HMAC_TYPE_URL, "KeyManagerImpl");
   }
 
   @Test
@@ -139,7 +139,7 @@ public void testGetKeyManager_shouldWorkAesEax() throws Exception {
   @Test
   public void testGetKeyManager_shouldWorkHmac() throws Exception {
     assertThat(Registry.getKeyManager(MacConfig.HMAC_TYPE_URL, Mac.class).getClass().toString())
-        .contains("HmacKeyManager");
+        .contains("KeyManagerImpl");
   }
 
   @Test
@@ -196,7 +196,7 @@ public void testGetKeyManager_badTypeUrl_shouldThrowException() throws Exception
   @Test
   public void testGetUntypedKeyManager_shouldWorkHmac() throws Exception {
     assertThat(Registry.getUntypedKeyManager(MacConfig.HMAC_TYPE_URL).getClass().toString())
-        .contains("HmacKeyManager");
+        .contains("KeyManagerImpl");
   }
 
   @Test

File: java/src/main/java/com/google/crypto/tink/KeyManagerImpl.java
Patch:
@@ -28,7 +28,8 @@
  * functions {@link #getPrimitive} will throw if invoked.
  */
 @Alpha
-class KeyManagerImpl<PrimitiveT, KeyProtoT extends MessageLite> implements KeyManager<PrimitiveT> {
+public class KeyManagerImpl<PrimitiveT, KeyProtoT extends MessageLite>
+    implements KeyManager<PrimitiveT> {
   public KeyManagerImpl(
       KeyTypeManager<KeyProtoT> keyTypeManager, Class<PrimitiveT> primitiveClass) {
     if (!keyTypeManager.supportedPrimitives().contains(primitiveClass)

File: java/src/main/java/com/google/crypto/tink/daead/DeterministicAeadConfig.java
Patch:
@@ -36,7 +36,7 @@
  * @since 1.1.0
  */
 public final class DeterministicAeadConfig {
-  public static final String AES_SIV_TYPE_URL = AesSivKeyManager.TYPE_URL;
+  public static final String AES_SIV_TYPE_URL = new AesSivKeyManager().getKeyType();
 
   /** @deprecated */
   @Deprecated
@@ -80,7 +80,7 @@ public static void init() throws GeneralSecurityException {
    * @since 1.2.0
    */
   public static void register() throws GeneralSecurityException {
-    Registry.registerKeyManager(new AesSivKeyManager());
+    Registry.registerKeyManager(new AesSivKeyManager(), /* newKeyAllowed = */ true);
     Registry.registerPrimitiveWrapper(new DeterministicAeadWrapper());
   }
 }

File: java/src/main/java/com/google/crypto/tink/daead/DeterministicAeadKeyTemplates.java
Patch:
@@ -45,7 +45,7 @@ public static KeyTemplate createAesSivKeyTemplate(int keySize) {
     AesSivKeyFormat format = AesSivKeyFormat.newBuilder().setKeySize(keySize).build();
     return KeyTemplate.newBuilder()
         .setValue(format.toByteString())
-        .setTypeUrl(AesSivKeyManager.TYPE_URL)
+        .setTypeUrl(new AesSivKeyManager().getKeyType())
         .setOutputPrefixType(OutputPrefixType.TINK)
         .build();
   }

File: java/src/test/java/com/google/crypto/tink/daead/DeterministicAeadKeyTemplatesTest.java
Patch:
@@ -31,7 +31,7 @@ public class DeterministicAeadKeyTemplatesTest {
   @Test
   public void testAES256_SIV() throws Exception {
     KeyTemplate template = DeterministicAeadKeyTemplates.AES256_SIV;
-    assertEquals(AesSivKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesSivKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     AesSivKeyFormat format = AesSivKeyFormat.parseFrom(
         template.getValue());
@@ -45,7 +45,7 @@ public void testCreateAesSivKeyTemplate() throws Exception {
     // to test that the function correctly puts them in the resulting template.
     int keySize = 42;
     KeyTemplate template = DeterministicAeadKeyTemplates.createAesSivKeyTemplate(keySize);
-    assertEquals(AesSivKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesSivKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     AesSivKeyFormat format = AesSivKeyFormat.parseFrom(template.getValue());
 

File: java/src/main/java/com/google/crypto/tink/subtle/StreamingAeadSeekableDecryptingChannel.java
Patch:
@@ -258,7 +258,7 @@ private boolean reachedEnd() {
   /**
    * Atomic read from a given position.
    *
-   * This method works in the same way as read(ByteBuffer), except that is tart at the given
+   * This method works in the same way as read(ByteBuffer), except that it starts at the given
    * position and does not modify the channel's position.
    */
   public synchronized int read(ByteBuffer dst, long start) throws IOException {

File: java/src/main/java/com/google/crypto/tink/KeyTypeManager.java
Patch:
@@ -173,7 +173,7 @@ final Class<?> firstSupportedPrimitiveClass() {
    * be able to generate keys. In particular, in this case it needs to have some KeyFormat protocol
    * buffer which can be validated, parsed, and from which a key can be generated.
    */
-  protected abstract static class KeyFactory<KeyFormatProtoT extends MessageLite, KeyT> {
+  public abstract static class KeyFactory<KeyFormatProtoT extends MessageLite, KeyT> {
     private final Class<KeyFormatProtoT> clazz;
     public KeyFactory(Class<KeyFormatProtoT> clazz) {
       this.clazz = clazz;

File: java/src/main/java/com/google/crypto/tink/aead/AeadConfig.java
Patch:
@@ -35,7 +35,7 @@
  */
 public final class AeadConfig {
   public static final String AES_CTR_HMAC_AEAD_TYPE_URL = AesCtrHmacAeadKeyManager.TYPE_URL;
-  public static final String AES_GCM_TYPE_URL = AesGcmKeyManager.TYPE_URL;
+  public static final String AES_GCM_TYPE_URL = new AesGcmKeyManager().getKeyType();
   public static final String AES_EAX_TYPE_URL = AesEaxKeyManager.TYPE_URL;
   public static final String KMS_AEAD_TYPE_URL = KmsAeadKeyManager.TYPE_URL;
   public static final String KMS_ENVELOPE_AEAD_TYPE_URL = KmsEnvelopeAeadKeyManager.TYPE_URL;
@@ -98,7 +98,7 @@ public static void register() throws GeneralSecurityException {
     MacConfig.register();
     Registry.registerKeyManager(new AesCtrHmacAeadKeyManager());
     Registry.registerKeyManager(new AesEaxKeyManager());
-    Registry.registerKeyManager(new AesGcmKeyManager());
+    Registry.registerKeyManager(new AesGcmKeyManager(), true);
     Registry.registerKeyManager(new ChaCha20Poly1305KeyManager());
     Registry.registerKeyManager(new KmsAeadKeyManager());
     Registry.registerKeyManager(new KmsEnvelopeAeadKeyManager());

File: java/src/main/java/com/google/crypto/tink/aead/AeadKeyTemplates.java
Patch:
@@ -160,7 +160,7 @@ public static KeyTemplate createAesGcmKeyTemplate(int keySize) {
         .build();
     return KeyTemplate.newBuilder()
         .setValue(format.toByteString())
-        .setTypeUrl(AesGcmKeyManager.TYPE_URL)
+        .setTypeUrl(new AesGcmKeyManager().getKeyType())
         .setOutputPrefixType(OutputPrefixType.TINK)
         .build();
   }

File: java/src/test/java/com/google/crypto/tink/aead/AeadKeyTemplatesTest.java
Patch:
@@ -37,7 +37,7 @@ public class AeadKeyTemplatesTest {
   @Test
   public void testAES128_GCM() throws Exception {
     KeyTemplate template = AeadKeyTemplates.AES128_GCM;
-    assertEquals(AesGcmKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesGcmKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     AesGcmKeyFormat format = AesGcmKeyFormat.parseFrom(template.getValue());
     assertEquals(16, format.getKeySize());
@@ -46,7 +46,7 @@ public void testAES128_GCM() throws Exception {
   @Test
   public void testAES256_GCM() throws Exception {
     KeyTemplate template = AeadKeyTemplates.AES256_GCM;
-    assertEquals(AesGcmKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesGcmKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
     AesGcmKeyFormat format = AesGcmKeyFormat.parseFrom(template.getValue());
     assertEquals(32, format.getKeySize());
@@ -58,7 +58,7 @@ public void testCreateAesGcmKeyTemplate() throws Exception {
     // to test that the function correctly puts them in the resulting template.
     int keySize = 42;
     KeyTemplate template = AeadKeyTemplates.createAesGcmKeyTemplate(keySize);
-    assertEquals(AesGcmKeyManager.TYPE_URL, template.getTypeUrl());
+    assertEquals(new AesGcmKeyManager().getKeyType(), template.getTypeUrl());
     assertEquals(OutputPrefixType.TINK, template.getOutputPrefixType());
 
     AesGcmKeyFormat format = AesGcmKeyFormat.parseFrom(template.getValue());

File: java/src/main/java/com/google/crypto/tink/subtle/AesCtrHmacStreaming.java
Patch:
@@ -32,7 +32,7 @@
  * <p>Each ciphertext uses a new AES-CTR key and HMAC key that are derived from the key derivation
  * key, a randomly chosen salt of the same size as the key and a nonce prefix using HKDF.
  *
- * <p>The the format of a ciphertext is header || segment_0 || segment_1 || ... || segment_k. The
+ * <p>The format of a ciphertext is header || segment_0 || segment_1 || ... || segment_k. The
  * header has size this.getHeaderLength(). Its format is headerLength || salt || prefix. where
  * headerLength is 1 byte determining the size of the header, salt is a salt used in the key
  * derivation and prefix is the prefix of the nonce. In principle headerLength is redundant

File: java/src/main/java/com/google/crypto/tink/subtle/AesGcmHkdfStreaming.java
Patch:
@@ -31,7 +31,7 @@
  * <p>Each ciphertext uses a new AES-GCM key that is derived from the key derivation key, a randomly
  * chosen salt of the same size as the key and a nonce prefix.
  *
- * <p>The the format of a ciphertext is header || segment_0 || segment_1 || ... || segment_k. The
+ * <p>The format of a ciphertext is header || segment_0 || segment_1 || ... || segment_k. The
  * header has size this.getHeaderLength(). Its format is headerLength || salt || prefix. where
  * headerLength is 1 byte determining the size of the header, salt is a salt used in the key
  * derivation and prefix is the prefix of the nonce. In principle headerLength is redundant

File: java/src/main/java/com/google/crypto/tink/subtle/StreamingAeadDecryptingChannel.java
Patch:
@@ -128,7 +128,7 @@ private void readSomeCiphertext(ByteBuffer buffer) throws IOException {
 
   /**
    * Tries to read the header of the ciphertext.
-   * @return true if the header has been fully read and false if not enogh bytes were available
+   * @return true if the header has been fully read and false if not enough bytes were available
    *          from the ciphertext stream.
    * @throws IOException when an exception occurs while reading the ciphertextStream or when
    *         the header is too short.

File: java/src/main/java/com/google/crypto/tink/subtle/StreamingAeadDecryptingStream.java
Patch:
@@ -106,8 +106,8 @@ public StreamingAeadDecryptingStream(
   /**
    * Tries to read the header of the ciphertext.
    *
-   * @return true if the header has been fully read and false if not enogh bytes were available from
-   *     the ciphertext stream.
+   * @return true if the header has been fully read and false if not enough bytes were available
+   *     from the ciphertext stream.
    * @throws IOException when an exception occurs while reading from @code{in} or when the header is
    *     too short.
    */

File: java/src/main/java/com/google/crypto/tink/subtle/AesCtrHmacStreaming.java
Patch:
@@ -29,7 +29,7 @@
 /**
  * Streaming encryption using AES-CTR and HMAC.
  *
- * <p>Each ciphertext uses a new AES-CTR key and HMAC key that ared derived from the key derivation
+ * <p>Each ciphertext uses a new AES-CTR key and HMAC key that are derived from the key derivation
  * key, a randomly chosen salt of the same size as the key and a nonce prefix using HKDF.
  *
  * <p>The the format of a ciphertext is header || segment_0 || segment_1 || ... || segment_k. The
@@ -193,7 +193,7 @@ public int getFirstSegmentOffset() {
   }
 
   /**
-   * Returns the expected size of the ciphertext for a given plaintext The returned value includes
+   * Returns the expected size of the ciphertext for a given plaintext. The returned value includes
    * the header and offset.
    */
   public long expectedCiphertextSize(long plaintextSize) {

File: java/src/main/java/com/google/crypto/tink/KeysetHandle.java
Patch:
@@ -258,7 +258,7 @@ private static void assertNoSecretKeyMaterial(Keyset keyset) throws GeneralSecur
   }
 
   /**
-   * Validates that an keyset handle contains enough key material to build a keyset on.
+   * Validates that a keyset handle contains enough key material to build a keyset on.
    *
    * @throws GeneralSecurityException
    */

File: java/src/main/java/com/google/crypto/tink/subtle/AesCtrHmacStreaming.java
Patch:
@@ -29,7 +29,7 @@
 /**
  * Streaming encryption using AES-CTR and HMAC.
  *
- * <p>Each ciphertext uses a new AES-CTR key and HMAC key that ared derived from the key derivation
+ * <p>Each ciphertext uses a new AES-CTR key and HMAC key that are derived from the key derivation
  * key, a randomly chosen salt of the same size as the key and a nonce prefix using HKDF.
  *
  * <p>The the format of a ciphertext is header || segment_0 || segment_1 || ... || segment_k. The

File: java/src/main/java/com/google/crypto/tink/InternalKeyManager.java
Patch:
@@ -83,6 +83,7 @@ final Class<PrimitiveT> getPrimitiveClass() {
    * @throws IllegalArgumentException if two of the passed in factories produce primitives of the
    *     same class.
    */
+  @SafeVarargs  // Safe because we do not reference the array (see Effective Java ed. 3, Item 32).
   protected InternalKeyManager(
       Class<KeyProtoT> clazz, PrimitiveFactory<?, KeyProtoT>... factories) {
     this.clazz = clazz;

File: java/src/main/java/com/google/crypto/tink/Registry.java
Patch:
@@ -79,7 +79,7 @@ public final class Registry {
   private static final ConcurrentMap<String, Boolean> newKeyAllowedMap =
       new ConcurrentHashMap<>(); // typeUrl -> newKeyAllowed mapping
 
-  private static final ConcurrentMap<String, Catalogue> catalogueMap =
+  private static final ConcurrentMap<String, Catalogue<?>> catalogueMap =
       new ConcurrentHashMap<>(); //  name -> catalogue mapping
 
   private static final ConcurrentMap<Class<?>, PrimitiveWrapper<?>> primitiveWrapperMap =
@@ -412,6 +412,7 @@ public static synchronized <P> void registerPrimitiveWrapper(final PrimitiveWrap
     }
     Class<P> classObject = wrapper.getPrimitiveClass();
     if (primitiveWrapperMap.containsKey(classObject)) {
+      @SuppressWarnings("unchecked") // We know that we only inserted objects of the correct type.
       PrimitiveWrapper<P> existingWrapper =
           (PrimitiveWrapper<P>) (primitiveWrapperMap.get(classObject));
       if (!wrapper.getClass().equals(existingWrapper.getClass())) {

File: java/src/main/java/com/google/crypto/tink/integration/awskms/AwsKmsClient.java
Patch:
@@ -117,7 +117,7 @@ public KmsClient withCredentialsProvider(AWSCredentialsProvider provider)
       this.client =
           AWSKMSClientBuilder.standard()
               .withCredentials(provider)
-              .withRegion(Regions.fromName(tokens[3]))
+              .withRegion(Regions.fromName(tokens[4]))
               .build();
       return this;
     } catch (AmazonServiceException e) {

File: apps/rewardedads/src/main/java/com/google/crypto/tink/apps/rewardedads/RewardedAdsVerifier.java
Patch:
@@ -205,12 +205,12 @@ public Map<Long, ECPublicKey> get() throws GeneralSecurityException {
      * {
      *   "keys": [
      *     {
-     *       key_id: 1916455855,
+     *       keyId: 1916455855,
      *       pem: "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEUaWMKcBHWdhUE+DncSIHhFCLLEln\nUs0LB9oanZ4K/FNICIM8ltS4nzc9yjmhgVQOlmSS6unqvN9t8sqajRTPcw==\n-----END PUBLIC KEY-----"
      *       base64: "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEUaWMKcBHWdhUE+DncSIHhFCLLElnUs0LB9oanZ4K/FNICIM8ltS4nzc9yjmhgVQOlmSS6unqvN9t8sqajRTPcw=="
      *     },
      *     {
-     *       key_id: 3901585526,
+     *       keyId: 3901585526,
      *       pem: "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEtxg2BsK/fllIeADtLspezS6YfHFWXZ8tiJncm8LDBa/NxEC84akdWbWDCUrMMGIV27/3/e7UuKSEonjGvaDUsw==\n-----END PUBLIC KEY-----"
      *       base64: "MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEtxg2BsK/fllIeADtLspezS6YfHFWXZ8tiJncm8LDBa/NxEC84akdWbWDCUrMMGIV27/3/e7UuKSEonjGvaDUsw=="
      *     },

File: apps/rewardedads/src/main/java/com/google/crypto/tink/apps/rewardedads/RewardedAdsVerifier.java
Patch:
@@ -205,12 +205,12 @@ public Map<Long, ECPublicKey> get() throws GeneralSecurityException {
      * {
      *   "keys": [
      *     {
-     *       keyId: 1916455855,
+     *       key_id: 1916455855,
      *       pem: "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEUaWMKcBHWdhUE+DncSIHhFCLLEln\nUs0LB9oanZ4K/FNICIM8ltS4nzc9yjmhgVQOlmSS6unqvN9t8sqajRTPcw==\n-----END PUBLIC KEY-----"
      *       base64: "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEUaWMKcBHWdhUE+DncSIHhFCLLElnUs0LB9oanZ4K/FNICIM8ltS4nzc9yjmhgVQOlmSS6unqvN9t8sqajRTPcw=="
      *     },
      *     {
-     *       keyId: 3901585526,
+     *       key_id: 3901585526,
      *       pem: "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEtxg2BsK/fllIeADtLspezS6YfHFWXZ8tiJncm8LDBa/NxEC84akdWbWDCUrMMGIV27/3/e7UuKSEonjGvaDUsw==\n-----END PUBLIC KEY-----"
      *       base64: "MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEtxg2BsK/fllIeADtLspezS6YfHFWXZ8tiJncm8LDBa/NxEC84akdWbWDCUrMMGIV27/3/e7UuKSEonjGvaDUsw=="
      *     },

File: java/src/main/java/com/google/crypto/tink/KeysetHandle.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.crypto.tink;
 
+import com.google.crypto.tink.annotations.Alpha;
 import com.google.crypto.tink.proto.EncryptedKeyset;
 import com.google.crypto.tink.proto.KeyData;
 import com.google.crypto.tink.proto.KeyTemplate;
@@ -291,6 +292,7 @@ public <P> P getPrimitive(Class<P> classObject) throws GeneralSecurityException
    * registry to get resources creating the primitive. The given keyManager will take precedence
    * when creating primitives over the globally registered keyManagers.
    */
+  @Alpha
   public <P> P getPrimitive(KeyManager<P> customKeyManager, Class<P> classObject)
       throws GeneralSecurityException {
     if (customKeyManager == null) {

File: java/src/main/java/com/google/crypto/tink/subtle/XChaCha20.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.crypto.tink.subtle;
 
+import com.google.crypto.tink.annotations.Alpha;
 import java.security.InvalidKeyException;
 import java.util.Arrays;
 
@@ -26,6 +27,7 @@
  *
  * <p>This cipher is meant to be used to construct an AEAD with Poly1305.
  */
+@Alpha
 class XChaCha20 extends ChaCha20Base {
   /**
    * Constructs a new XChaCha20 cipher with the supplied {@code key}.

File: java/src/main/java/com/google/crypto/tink/subtle/XChaCha20Poly1305.java
Patch:
@@ -16,12 +16,14 @@
 
 package com.google.crypto.tink.subtle;
 
+import com.google.crypto.tink.annotations.Alpha;
 import java.security.InvalidKeyException;
 
 /**
  * XChaCha20Poly1305 AEAD construction, as described in
  * https://tools.ietf.org/html/draft-arciszewski-xchacha-01.
  */
+@Alpha
 public final class XChaCha20Poly1305 extends ChaCha20Poly1305Base {
   public XChaCha20Poly1305(final byte[] key) throws InvalidKeyException {
     super(key);

File: apps/rewardedads/src/main/java/com/google/crypto/tink/apps/rewardedads/RewardedAdsVerifier.java
Patch:
@@ -205,12 +205,12 @@ public Map<Long, ECPublicKey> get() throws GeneralSecurityException {
      * {
      *   "keys": [
      *     {
-     *       key_id: 1916455855,
+     *       keyId: 1916455855,
      *       pem: "-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEUaWMKcBHWdhUE+DncSIHhFCLLEln\nUs0LB9oanZ4K/FNICIM8ltS4nzc9yjmhgVQOlmSS6unqvN9t8sqajRTPcw==\n-----END PUBLIC KEY-----"
      *       base64: "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEUaWMKcBHWdhUE+DncSIHhFCLLElnUs0LB9oanZ4K/FNICIM8ltS4nzc9yjmhgVQOlmSS6unqvN9t8sqajRTPcw=="
      *     },
      *     {
-     *       key_id: 3901585526,
+     *       keyId: 3901585526,
      *       pem: "-----BEGIN PUBLIC KEY-----\nMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEtxg2BsK/fllIeADtLspezS6YfHFWXZ8tiJncm8LDBa/NxEC84akdWbWDCUrMMGIV27/3/e7UuKSEonjGvaDUsw==\n-----END PUBLIC KEY-----"
      *       base64: "MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEtxg2BsK/fllIeADtLspezS6YfHFWXZ8tiJncm8LDBa/NxEC84akdWbWDCUrMMGIV27/3/e7UuKSEonjGvaDUsw=="
      *     },

File: java/src/test/java/com/google/crypto/tink/aead/AeadConfigTest.java
Patch:
@@ -20,6 +20,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.TestUtil;
 import com.google.crypto.tink.proto.RegistryConfig;
@@ -59,7 +60,7 @@ public void aaaTestInitialization() throws Exception {
     // Before registration, key manager should be absent.
     String typeUrl = "type.googleapis.com/google.crypto.tink.AesCtrHmacAeadKey";
     try {
-      Registry.getKeyManager(typeUrl);
+      Registry.getUntypedKeyManager(typeUrl);
       fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
       assertThat(e.toString()).contains("No key manager found");
@@ -73,7 +74,7 @@ public void aaaTestInitialization() throws Exception {
     Registry.getCatalogue("tinkaead");
 
     // After registration the key manager should be present.
-    Registry.getKeyManager(typeUrl);
+    Registry.getKeyManager(typeUrl, Aead.class);
 
     // Running init() manually again should succeed.
     AeadConfig.register();

File: java/src/test/java/com/google/crypto/tink/daead/DeterministicAeadConfigTest.java
Patch:
@@ -20,6 +20,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.DeterministicAead;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.TestUtil;
 import com.google.crypto.tink.proto.RegistryConfig;
@@ -52,7 +53,7 @@ public void aaaTestInitialization() throws Exception {
     // Before registration, the key manager should be absent.
     String typeUrl = "type.googleapis.com/google.crypto.tink.AesSivKey";
     try {
-      Registry.getKeyManager(typeUrl);
+      Registry.getUntypedKeyManager(typeUrl);
       fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
       assertThat(e.toString()).contains("No key manager found");
@@ -66,7 +67,7 @@ public void aaaTestInitialization() throws Exception {
     Registry.getCatalogue("tinkdeterministicaead");
 
     // After registration, the key manager should be present.
-    Registry.getKeyManager(typeUrl);
+    Registry.getKeyManager(typeUrl, DeterministicAead.class);
 
     // Running init() manually again should succeed.
     DeterministicAeadConfig.register();

File: java/src/test/java/com/google/crypto/tink/hybrid/HybridConfigTest.java
Patch:
@@ -20,6 +20,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.TestUtil;
 import com.google.crypto.tink.proto.RegistryConfig;
@@ -65,7 +66,7 @@ public void aaaTestInitialization() throws Exception {
 
     String typeUrl = "type.googleapis.com/google.crypto.tink.EciesAeadHkdfPrivateKey";
     try {
-      Registry.getKeyManager(typeUrl);
+      Registry.getUntypedKeyManager(typeUrl);
       fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
       assertThat(e.toString()).contains("No key manager found");
@@ -79,7 +80,7 @@ public void aaaTestInitialization() throws Exception {
     Registry.getCatalogue("tinkhybriddecrypt");
     Registry.getCatalogue("tinkhybridencrypt");
 
-    Registry.getKeyManager(typeUrl);
+    Registry.getKeyManager(typeUrl, HybridDecrypt.class);
 
     // Running init() manually again should succeed.
     HybridConfig.register();

File: java/src/test/java/com/google/crypto/tink/signature/SignatureConfigTest.java
Patch:
@@ -20,6 +20,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.TestUtil;
 import com.google.crypto.tink.proto.RegistryConfig;
@@ -57,7 +58,7 @@ public void aaaTestInitialization() throws Exception {
     }
     String typeUrl = "type.googleapis.com/google.crypto.tink.EcdsaPrivateKey";
     try {
-      Registry.getKeyManager(typeUrl);
+      Registry.getUntypedKeyManager(typeUrl);
       fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
       assertThat(e.toString()).contains("No key manager found");
@@ -71,7 +72,7 @@ public void aaaTestInitialization() throws Exception {
     Registry.getCatalogue("tinkpublickeyverify");
 
     // After registration the key manager should be present.
-    Registry.getKeyManager(typeUrl);
+    Registry.getKeyManager(typeUrl, PublicKeySign.class);
 
     // Running init() manually again should succeed.
     SignatureConfig.register();

File: java/src/test/java/com/google/crypto/tink/streamingaead/StreamingAeadConfigTest.java
Patch:
@@ -21,6 +21,7 @@
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.StreamingAead;
 import com.google.crypto.tink.TestUtil;
 import com.google.crypto.tink.proto.RegistryConfig;
 import java.security.GeneralSecurityException;
@@ -57,7 +58,7 @@ public void aaaTestInitialization() throws Exception {
     }
     String typeUrl = "type.googleapis.com/google.crypto.tink.AesCtrHmacStreamingKey";
     try {
-      Registry.getKeyManager(typeUrl);
+      Registry.getUntypedKeyManager(typeUrl);
       fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
       assertThat(e.toString()).contains("No key manager found");
@@ -70,7 +71,7 @@ public void aaaTestInitialization() throws Exception {
     Registry.getCatalogue("TinkStreamingAead");
 
     // After registration the key manager should be present.
-    Registry.getKeyManager(typeUrl);
+    Registry.getKeyManager(typeUrl, StreamingAead.class);
 
     // Running init() manually again should succeed.
     StreamingAeadConfig.register();

File: java/src/main/java/com/google/crypto/tink/subtle/Validators.java
Patch:
@@ -53,7 +53,9 @@ public static void validateTypeUrl(String typeUrl) throws GeneralSecurityExcepti
   public static void validateAesKeySize(int sizeInBytes) throws InvalidAlgorithmParameterException {
     if (sizeInBytes != 16 && sizeInBytes != 32) {
       throw new InvalidAlgorithmParameterException(
-          "invalid key size; only 128-bit and 256-bit AES keys are supported");
+          String.format(
+              "invalid key size %d; only 128-bit and 256-bit AES keys are supported",
+              sizeInBytes * 8));
     }
   }
 

File: java/src/main/java/com/google/crypto/tink/integration/awskms/AwsKmsClient.java
Patch:
@@ -109,7 +109,7 @@ public KmsClient withDefaultCredentials() throws GeneralSecurityException {
   }
 
   /** Loads AWS credentials from a provider. */
-  private KmsClient withCredentialsProvider(AWSCredentialsProvider provider)
+  public KmsClient withCredentialsProvider(AWSCredentialsProvider provider)
       throws GeneralSecurityException {
     try {
       this.client = AWSKMSClientBuilder.standard().withCredentials(provider).build();

File: java/src/main/java/com/google/crypto/tink/aead/AeadWrapper.java
Patch:
@@ -35,7 +35,7 @@
  * simply throw a GeneralSecurityException.
  */
 public class AeadWrapper implements PrimitiveWrapper<Aead> {
-  private static final Logger logger = Logger.getLogger(AeadFactory.class.getName());
+  private static final Logger logger = Logger.getLogger(AeadWrapper.class.getName());
 
   private static class WrappedAead implements Aead {
     private final PrimitiveSet<Aead> pSet;

File: java/src/main/java/com/google/crypto/tink/hybrid/HybridDecryptWrapper.java
Patch:
@@ -33,7 +33,7 @@
  * com.google.crypto.tink.proto.OutputPrefixType#RAW}.
  */
 public final class HybridDecryptWrapper implements PrimitiveWrapper<HybridDecrypt> {
-  private static final Logger logger = Logger.getLogger(HybridDecryptFactory.class.getName());
+  private static final Logger logger = Logger.getLogger(HybridDecryptWrapper.class.getName());
 
   private static class WrappedHybridDecrypt implements HybridDecrypt {
     private final PrimitiveSet<HybridDecrypt> primitives;

File: java/src/main/java/com/google/crypto/tink/mac/MacWrapper.java
Patch:
@@ -37,7 +37,7 @@
  * primitive tries all keys with {@link com.google.crypto.tink.proto.OutputPrefixType#RAW}.
  */
 public final class MacWrapper implements PrimitiveWrapper<Mac> {
-  private static final Logger logger = Logger.getLogger(MacFactory.class.getName());
+  private static final Logger logger = Logger.getLogger(MacWrapper.class.getName());
 
   private static class WrappedMac implements Mac {
     private final PrimitiveSet<Mac> primitives;

File: java/src/main/java/com/google/crypto/tink/Registry.java
Patch:
@@ -667,7 +667,7 @@ public static <P> P wrap(PrimitiveSet<P> primitiveSet)
         (PrimitiveWrapper<P>) primitiveWrapperMap.get(primitiveSet.getPrimitiveClass());
     if (wrapper == null) {
       throw new GeneralSecurityException(
-          "No key manager found for primitive class " + primitiveSet.getPrimitiveClass().getName());
+          "No wrapper found for " + primitiveSet.getPrimitiveClass().getName());
     }
     return wrapper.wrap(primitiveSet);
   }

File: java/src/main/java/com/google/crypto/tink/Config.java
Patch:
@@ -79,11 +79,10 @@ public static void register(RegistryConfig config) throws GeneralSecurityExcepti
    *     {@link com.google.crypto.tink.KeyManager} or {@link com.google.crypto.tink.Catalogue} that
    *     can handle the entry. In both cases the error message should show how to resolve it.
    */
-  @SuppressWarnings({"rawtypes", "unchecked"})
   public static void registerKeyType(KeyTypeEntry entry) throws GeneralSecurityException {
     validate(entry);
-    Catalogue catalogue = Registry.getCatalogue(entry.getCatalogueName());
-    KeyManager keyManager =
+    Catalogue<?> catalogue = Registry.getCatalogue(entry.getCatalogueName());
+    KeyManager<?> keyManager =
         catalogue.getKeyManager(
             entry.getTypeUrl(), entry.getPrimitiveName(), entry.getKeyManagerVersion());
     Registry.registerKeyManager(keyManager, entry.getNewKeyAllowed());

File: java/src/test/java/com/google/crypto/tink/subtle/X25519Test.java
Patch:
@@ -143,6 +143,7 @@ public void testComputeSharedSecretWithWycheproofVectors() throws Exception {
     for (int i = 0; i < testGroups.length(); i++) {
       JSONObject group = testGroups.getJSONObject(i);
       JSONArray tests = group.getJSONArray("tests");
+      String curve = group.getString("curve");
       for (int j = 0; j < tests.length(); j++) {
         JSONObject testcase = tests.getJSONObject(j);
         String tcId =
@@ -152,7 +153,6 @@ public void testComputeSharedSecretWithWycheproofVectors() throws Exception {
         String hexPubKey = testcase.getString("public");
         String hexPrivKey = testcase.getString("private");
         String expectedSharedSecret = testcase.getString("shared");
-        String curve = testcase.getString("curve");
         if (!curve.equals("curve25519")) {
           System.out.printf("Skipping %s, unknown curve name: %s", tcId, curve);
           cntSkippedTests++;

File: java/src/main/java/com/google/crypto/tink/KeysetHandle.java
Patch:
@@ -168,6 +168,7 @@ private static KeyData createPublicKeyData(KeyData privateKeyData)
     return publicKeyData;
   }
 
+  @SuppressWarnings("deprecation")
   private static void validate(KeyData keyData) throws GeneralSecurityException {
     // This will throw GeneralSecurityException if the keyData is invalid.
     Registry.getPrimitive(keyData);

File: java/src/main/java/com/google/crypto/tink/aead/AesCtrHmacAeadKeyManager.java
Patch:
@@ -52,8 +52,9 @@ public AesCtrHmacAeadKeyManager() throws GeneralSecurityException {
   public Aead getPrimitiveFromKey(AesCtrHmacAeadKey keyProto) throws GeneralSecurityException {
     validate(keyProto);
     return new EncryptThenAuthenticate(
-        (IndCpaCipher) Registry.getPrimitive(AesCtrKeyManager.TYPE_URL, keyProto.getAesCtrKey()),
-        (Mac) Registry.getPrimitive(MacConfig.HMAC_TYPE_URL, keyProto.getHmacKey()),
+        Registry.getPrimitive(
+            AesCtrKeyManager.TYPE_URL, keyProto.getAesCtrKey(), IndCpaCipher.class),
+        Registry.getPrimitive(MacConfig.HMAC_TYPE_URL, keyProto.getHmacKey(), Mac.class),
         keyProto.getHmacKey().getParams().getTagSize());
   }
 

File: java/src/main/java/com/google/crypto/tink/hybrid/HybridDecryptFactory.java
Patch:
@@ -65,8 +65,8 @@ public static HybridDecrypt getPrimitive(KeysetHandle keysetHandle)
   public static HybridDecrypt getPrimitive(
       KeysetHandle keysetHandle, final KeyManager<HybridDecrypt> keyManager)
       throws GeneralSecurityException {
-    final PrimitiveSet<HybridDecrypt> primitives = Registry.getPrimitives(keysetHandle, keyManager);
-    validate(primitives);
+    final PrimitiveSet<HybridDecrypt> primitives =
+        Registry.getPrimitives(keysetHandle, keyManager, HybridDecrypt.class);
     return new HybridDecrypt() {
       @Override
       public byte[] decrypt(final byte[] ciphertext, final byte[] contextInfo)

File: java/src/main/java/com/google/crypto/tink/hybrid/RegistryEciesAeadHkdfDemHelper.java
Patch:
@@ -91,7 +91,7 @@ public Aead getAead(final byte[] symmetricKeyValue) throws GeneralSecurityExcept
           .mergeFrom(aesGcmKey)
           .setKeyValue(ByteString.copyFrom(symmetricKeyValue, 0, symmetricKeySize))
           .build();
-      return Registry.getPrimitive(demKeyTypeUrl, aeadKey);
+      return Registry.getPrimitive(demKeyTypeUrl, aeadKey, Aead.class);
     } else if (demKeyTypeUrl.equals(AeadConfig.AES_CTR_HMAC_AEAD_TYPE_URL)) {
       byte[] aesCtrKeyValue = Arrays.copyOfRange(symmetricKeyValue, 0, aesCtrKeySize);
       byte[] hmacKeyValue = Arrays.copyOfRange(symmetricKeyValue, aesCtrKeySize, symmetricKeySize);
@@ -111,7 +111,7 @@ public Aead getAead(final byte[] symmetricKeyValue) throws GeneralSecurityExcept
               .setAesCtrKey(aesCtrKey)
               .setHmacKey(hmacKey)
               .build();
-      return Registry.getPrimitive(demKeyTypeUrl, aeadKey);
+      return Registry.getPrimitive(demKeyTypeUrl, aeadKey, Aead.class);
     } else {
       throw new GeneralSecurityException("unknown DEM key type");
     }

File: java/src/test/java/com/google/crypto/tink/mac/MacFactoryTest.java
Patch:
@@ -182,7 +182,7 @@ public void testInvalidKeyMaterial() throws Exception {
       MacFactory.getPrimitive(keysetHandle);
       fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
-      assertExceptionContains(e, "invalid MAC key material");
+      assertExceptionContains(e, "not match requested primitive type com.google.crypto.tink.Mac");
     }
 
     // invalid as the primary key.
@@ -191,7 +191,7 @@ public void testInvalidKeyMaterial() throws Exception {
       MacFactory.getPrimitive(keysetHandle);
       fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
-      assertExceptionContains(e, "invalid MAC key material");
+      assertExceptionContains(e, "not match requested primitive type com.google.crypto.tink.Mac");
     }
   }
 }

File: java/src/test/java/com/google/crypto/tink/aead/AeadFactoryTest.java
Patch:
@@ -221,7 +221,7 @@ public void testInvalidKeyMaterial() throws Exception {
       AeadFactory.getPrimitive(keysetHandle);
       fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
-      assertExceptionContains(e, "invalid AEAD key material");
+      assertExceptionContains(e, "Primitive type com.google.crypto.tink.DeterministicAead");
     }
 
     // invalid as the primary key.
@@ -230,7 +230,7 @@ public void testInvalidKeyMaterial() throws Exception {
       AeadFactory.getPrimitive(keysetHandle);
       fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
-      assertExceptionContains(e, "invalid AEAD key material");
+      assertExceptionContains(e, "Primitive type com.google.crypto.tink.DeterministicAead");
     }
   }
 }

File: java/src/main/java/com/google/crypto/tink/aead/AesCtrHmacAeadKeyManager.java
Patch:
@@ -40,7 +40,7 @@
 class AesCtrHmacAeadKeyManager
     extends KeyManagerBase<Aead, AesCtrHmacAeadKey, AesCtrHmacAeadKeyFormat> {
   public AesCtrHmacAeadKeyManager() throws GeneralSecurityException {
-    super(AesCtrHmacAeadKey.class, AesCtrHmacAeadKeyFormat.class, TYPE_URL);
+    super(Aead.class, AesCtrHmacAeadKey.class, AesCtrHmacAeadKeyFormat.class, TYPE_URL);
     Registry.registerKeyManager(new AesCtrKeyManager());
   }
 

File: java/src/main/java/com/google/crypto/tink/aead/AesCtrKeyManager.java
Patch:
@@ -35,7 +35,7 @@
  */
 class AesCtrKeyManager extends KeyManagerBase<IndCpaCipher, AesCtrKey, AesCtrKeyFormat> {
   public AesCtrKeyManager() {
-    super(AesCtrKey.class, AesCtrKeyFormat.class, TYPE_URL);
+    super(IndCpaCipher.class, AesCtrKey.class, AesCtrKeyFormat.class, TYPE_URL);
   }
 
   private static final int VERSION = 0;

File: java/src/main/java/com/google/crypto/tink/aead/AesEaxKeyManager.java
Patch:
@@ -34,7 +34,7 @@
  */
 class AesEaxKeyManager extends KeyManagerBase<Aead, AesEaxKey, AesEaxKeyFormat> {
   public AesEaxKeyManager() {
-    super(AesEaxKey.class, AesEaxKeyFormat.class, TYPE_URL);
+    super(Aead.class, AesEaxKey.class, AesEaxKeyFormat.class, TYPE_URL);
   }
 
   private static final int VERSION = 0;

File: java/src/main/java/com/google/crypto/tink/aead/AesGcmKeyManager.java
Patch:
@@ -34,7 +34,7 @@
  */
 class AesGcmKeyManager extends KeyManagerBase<Aead, AesGcmKey, AesGcmKeyFormat> {
   public AesGcmKeyManager() {
-    super(AesGcmKey.class, AesGcmKeyFormat.class, TYPE_URL);
+    super(Aead.class, AesGcmKey.class, AesGcmKeyFormat.class, TYPE_URL);
   }
 
   private static final int VERSION = 0;

File: java/src/main/java/com/google/crypto/tink/aead/ChaCha20Poly1305KeyManager.java
Patch:
@@ -35,7 +35,7 @@
 class ChaCha20Poly1305KeyManager
     extends KeyManagerBase<Aead, ChaCha20Poly1305Key, Empty> {
   public ChaCha20Poly1305KeyManager() {
-    super(ChaCha20Poly1305Key.class, Empty.class, TYPE_URL);
+    super(Aead.class, ChaCha20Poly1305Key.class, Empty.class, TYPE_URL);
   }
 
   /** Type url that this manager supports */

File: java/src/main/java/com/google/crypto/tink/aead/KmsAeadKeyManager.java
Patch:
@@ -34,7 +34,7 @@
  */
 class KmsAeadKeyManager extends KeyManagerBase<Aead, KmsAeadKey, KmsAeadKeyFormat> {
   public KmsAeadKeyManager() {
-    super(KmsAeadKey.class, KmsAeadKeyFormat.class, TYPE_URL);
+    super(Aead.class, KmsAeadKey.class, KmsAeadKeyFormat.class, TYPE_URL);
   }
 
   private static final int VERSION = 0;

File: java/src/main/java/com/google/crypto/tink/aead/KmsEnvelopeAeadKeyManager.java
Patch:
@@ -35,7 +35,7 @@
 class KmsEnvelopeAeadKeyManager
     extends KeyManagerBase<Aead, KmsEnvelopeAeadKey, KmsEnvelopeAeadKeyFormat> {
   public KmsEnvelopeAeadKeyManager() {
-    super(KmsEnvelopeAeadKey.class, KmsEnvelopeAeadKeyFormat.class, TYPE_URL);
+    super(Aead.class, KmsEnvelopeAeadKey.class, KmsEnvelopeAeadKeyFormat.class, TYPE_URL);
   }
 
   private static final int VERSION = 0;

File: java/src/main/java/com/google/crypto/tink/aead/XChaCha20Poly1305KeyManager.java
Patch:
@@ -34,7 +34,7 @@
  */
 class XChaCha20Poly1305KeyManager extends KeyManagerBase<Aead, XChaCha20Poly1305Key, Empty> {
   public XChaCha20Poly1305KeyManager() {
-    super(XChaCha20Poly1305Key.class, Empty.class, TYPE_URL);
+    super(Aead.class, XChaCha20Poly1305Key.class, Empty.class, TYPE_URL);
   }
 
   public static final String TYPE_URL =

File: java/src/main/java/com/google/crypto/tink/daead/AesSivKeyManager.java
Patch:
@@ -36,7 +36,7 @@
  */
 class AesSivKeyManager extends KeyManagerBase<DeterministicAead, AesSivKey, AesSivKeyFormat> {
   public AesSivKeyManager() {
-    super(AesSivKey.class, AesSivKeyFormat.class, TYPE_URL);
+    super(DeterministicAead.class, AesSivKey.class, AesSivKeyFormat.class, TYPE_URL);
   }
 
   private static final int VERSION = 0;

File: java/src/main/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPrivateKeyManager.java
Patch:
@@ -46,7 +46,8 @@ class EciesAeadHkdfPrivateKeyManager
     extends KeyManagerBase<HybridDecrypt, EciesAeadHkdfPrivateKey, EciesAeadHkdfKeyFormat>
     implements PrivateKeyManager<HybridDecrypt> {
   public EciesAeadHkdfPrivateKeyManager() {
-    super(EciesAeadHkdfPrivateKey.class, EciesAeadHkdfKeyFormat.class, TYPE_URL);
+    super(
+        HybridDecrypt.class, EciesAeadHkdfPrivateKey.class, EciesAeadHkdfKeyFormat.class, TYPE_URL);
   }
 
   private static final int VERSION = 0;

File: java/src/main/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPublicKeyManager.java
Patch:
@@ -39,7 +39,7 @@
 class EciesAeadHkdfPublicKeyManager
     extends KeyManagerBase<HybridEncrypt, EciesAeadHkdfPublicKey, Empty> {
   public EciesAeadHkdfPublicKeyManager() {
-    super(EciesAeadHkdfPublicKey.class, Empty.class, TYPE_URL);
+    super(HybridEncrypt.class, EciesAeadHkdfPublicKey.class, Empty.class, TYPE_URL);
   }
   
   private static final int VERSION = 0;

File: java/src/main/java/com/google/crypto/tink/mac/HmacKeyManager.java
Patch:
@@ -36,7 +36,7 @@
  */
 class HmacKeyManager extends KeyManagerBase<Mac, HmacKey, HmacKeyFormat> {
   public HmacKeyManager() {
-    super(HmacKey.class, HmacKeyFormat.class, TYPE_URL);
+    super(Mac.class, HmacKey.class, HmacKeyFormat.class, TYPE_URL);
   }
   /** Type url that this manager does support. */
   public static final String TYPE_URL = "type.googleapis.com/google.crypto.tink.HmacKey";

File: java/src/main/java/com/google/crypto/tink/signature/EcdsaSignKeyManager.java
Patch:
@@ -44,7 +44,7 @@ class EcdsaSignKeyManager
     extends KeyManagerBase<PublicKeySign, EcdsaPrivateKey, EcdsaKeyFormat>
     implements PrivateKeyManager<PublicKeySign> {
   public EcdsaSignKeyManager() {
-    super(EcdsaPrivateKey.class, EcdsaKeyFormat.class, TYPE_URL);
+    super(PublicKeySign.class, EcdsaPrivateKey.class, EcdsaKeyFormat.class, TYPE_URL);
   }
 
   /** Type url that this manager supports */

File: java/src/main/java/com/google/crypto/tink/signature/EcdsaVerifyKeyManager.java
Patch:
@@ -35,7 +35,7 @@
  */
 class EcdsaVerifyKeyManager extends KeyManagerBase<PublicKeyVerify, EcdsaPublicKey, Empty> {
   public EcdsaVerifyKeyManager() {
-    super(EcdsaPublicKey.class, Empty.class, TYPE_URL);
+    super(PublicKeyVerify.class, EcdsaPublicKey.class, Empty.class, TYPE_URL);
   }
 
   public static final String TYPE_URL = "type.googleapis.com/google.crypto.tink.EcdsaPublicKey";

File: java/src/main/java/com/google/crypto/tink/signature/Ed25519PrivateKeyManager.java
Patch:
@@ -38,7 +38,7 @@ class Ed25519PrivateKeyManager
     extends KeyManagerBase<PublicKeySign, Ed25519PrivateKey, Empty>
     implements PrivateKeyManager<PublicKeySign> {
   public Ed25519PrivateKeyManager() {
-    super(Ed25519PrivateKey.class, Empty.class, TYPE_URL);
+    super(PublicKeySign.class, Ed25519PrivateKey.class, Empty.class, TYPE_URL);
   }
 
   public static final String TYPE_URL = "type.googleapis.com/google.crypto.tink.Ed25519PrivateKey";

File: java/src/main/java/com/google/crypto/tink/signature/Ed25519PublicKeyManager.java
Patch:
@@ -33,7 +33,7 @@
  */
 class Ed25519PublicKeyManager extends KeyManagerBase<PublicKeyVerify, Ed25519PublicKey, Empty> {
   public Ed25519PublicKeyManager() {
-    super(Ed25519PublicKey.class, Empty.class, TYPE_URL);
+    super(PublicKeyVerify.class, Ed25519PublicKey.class, Empty.class, TYPE_URL);
   }
   public static final String TYPE_URL = "type.googleapis.com/google.crypto.tink.Ed25519PublicKey";
 

File: java/src/main/java/com/google/crypto/tink/signature/RsaSsaPkcs1SignKeyManager.java
Patch:
@@ -51,7 +51,7 @@ class RsaSsaPkcs1SignKeyManager
     extends KeyManagerBase<PublicKeySign, RsaSsaPkcs1PrivateKey, RsaSsaPkcs1KeyFormat>
     implements PrivateKeyManager<PublicKeySign> {
   public RsaSsaPkcs1SignKeyManager() {
-    super(RsaSsaPkcs1PrivateKey.class, RsaSsaPkcs1KeyFormat.class, TYPE_URL);
+    super(PublicKeySign.class, RsaSsaPkcs1PrivateKey.class, RsaSsaPkcs1KeyFormat.class, TYPE_URL);
   }
 
   public static final String TYPE_URL =

File: java/src/main/java/com/google/crypto/tink/signature/RsaSsaPkcs1VerifyKeyManager.java
Patch:
@@ -39,7 +39,7 @@
 class RsaSsaPkcs1VerifyKeyManager
     extends KeyManagerBase<PublicKeyVerify, RsaSsaPkcs1PublicKey, Empty> {
   public RsaSsaPkcs1VerifyKeyManager() {
-    super(RsaSsaPkcs1PublicKey.class, Empty.class, TYPE_URL);
+    super(PublicKeyVerify.class, RsaSsaPkcs1PublicKey.class, Empty.class, TYPE_URL);
   }
 
   private static final int VERSION = 0;

File: java/src/main/java/com/google/crypto/tink/signature/RsaSsaPssSignKeyManager.java
Patch:
@@ -51,7 +51,7 @@ class RsaSsaPssSignKeyManager
     extends KeyManagerBase<PublicKeySign, RsaSsaPssPrivateKey, RsaSsaPssKeyFormat>
     implements PrivateKeyManager<PublicKeySign> {
   public RsaSsaPssSignKeyManager() {
-    super(RsaSsaPssPrivateKey.class, RsaSsaPssKeyFormat.class, TYPE_URL);
+    super(PublicKeySign.class, RsaSsaPssPrivateKey.class, RsaSsaPssKeyFormat.class, TYPE_URL);
   }
 
   public static final String TYPE_URL =

File: java/src/main/java/com/google/crypto/tink/signature/RsaSsaPssVerifyKeyManager.java
Patch:
@@ -39,7 +39,7 @@
  */
 class RsaSsaPssVerifyKeyManager extends KeyManagerBase<PublicKeyVerify, RsaSsaPssPublicKey, Empty> {
   public RsaSsaPssVerifyKeyManager() {
-    super(RsaSsaPssPublicKey.class, Empty.class, TYPE_URL);
+    super(PublicKeyVerify.class, RsaSsaPssPublicKey.class, Empty.class, TYPE_URL);
   }
 
   public static final String TYPE_URL = "type.googleapis.com/google.crypto.tink.RsaSsaPssPublicKey";

File: java/src/main/java/com/google/crypto/tink/integration/gcpkms/GcpKmsClient.java
Patch:
@@ -24,6 +24,7 @@
 import com.google.auto.service.AutoService;
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KmsClient;
+import com.google.crypto.tink.Version;
 import com.google.crypto.tink.subtle.Validators;
 import java.io.File;
 import java.io.FileInputStream;
@@ -41,7 +42,7 @@ public final class GcpKmsClient implements KmsClient {
   /** The prefix of all keys stored in Google Cloud KMS. */
   public static final String PREFIX = "gcp-kms://";
 
-  private static final String APPLICATION_NAME = "Tink";
+  private static final String APPLICATION_NAME = "Tink/" + Version.TINK_VERSION;
   private CloudKMS client;
   private String keyUri;
 

File: examples/helloworld/java/src/main/java/com/helloworld/Commands.java
Patch:
@@ -61,7 +61,7 @@ private static KeysetHandle getKeysetHandle(File keyset)
       // Read the cleartext keyset from disk.
       // WARNING: reading cleartext keysets is a bad practice. Tink supports reading/writing
       // encrypted keysets, see
-      // https://github.com/google/tink/blob/master/doc/JAVA-HOWTO.md#loading-existing-keysets.
+      // https://github.com/google/tink/blob/master/docs/JAVA-HOWTO.md#loading-existing-keysets.
       return CleartextKeysetHandle.read(JsonKeysetReader.withFile(keyset));
     }
     KeysetHandle handle = KeysetHandle.generateNew(AeadKeyTemplates.AES128_GCM);

File: java/src/test/java/com/google/crypto/tink/subtle/AesEaxJceTest.java
Patch:
@@ -141,8 +141,7 @@ public void testEncryptDecrypt() throws Exception {
   public void testModifyCiphertext() throws Exception {
     testModifyCiphertext(16, 16);
     testModifyCiphertext(16, 12);
-    // TODO(bleichen): Skipping test with key sizes larger than 128 bits because of
-    //   https://buganizer.corp.google.com/issues/35928521
+    // TODO(bleichen): Skipping test with key sizes larger than 128 bits because of b/35928521.
     // testModifyCiphertext(24, 16);
     // testModifyCiphertext(32, 16);
   }

File: java/src/main/java/com/google/crypto/tink/hybrid/RegistryEciesAeadHkdfDemHelper.java
Patch:
@@ -69,7 +69,7 @@ class RegistryEciesAeadHkdfDemHelper implements EciesAeadHkdfDemHelper {
         this.symmetricKeySize = aesCtrKeySize + hmacKeySize;
       } catch (InvalidProtocolBufferException e) {
         throw new GeneralSecurityException(
-            "invalid KeyFormat protobuf, expected AesGcmKeyFormat", e);
+            "invalid KeyFormat protobuf, expected AesCtrHmacAeadKeyFormat", e);
       }
     } else {
       throw new GeneralSecurityException("unsupported AEAD DEM key type: " + demKeyTypeUrl);

File: java/src/main/java/com/google/crypto/tink/subtle/EciesAeadHkdfDemHelper.java
Patch:
@@ -32,7 +32,7 @@ public interface EciesAeadHkdfDemHelper {
    * Creates a new {@code Aead}-primitive that uses the key material given in 'symmetric_key', which
    * must be of length dem_key_size_in_bytes().
    *
-   * @return the newly created {@codee Aead}-primitive.
+   * @return the newly created {@code Aead}-primitive.
    */
   public Aead getAead(final byte[] symmetricKeyValue) throws GeneralSecurityException;
 }

File: apps/paymentmethodtoken/src/main/java/com/google/crypto/tink/apps/paymentmethodtoken/PaymentMethodTokenConstants.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.crypto.tink.apps.paymentmethodtoken;
 
 import com.google.crypto.tink.subtle.EllipticCurves;
+import com.google.crypto.tink.subtle.Enums.HashType;
 import java.nio.charset.StandardCharsets;
 
 /** Various constants. */
@@ -34,7 +35,7 @@ class PaymentMethodTokenConstants {
   public static final String PROTOCOL_VERSION_EC_V1 = "ECv1";
   public static final String PROTOCOL_VERSION_EC_V2 = "ECv2";
   public static final String PROTOCOL_VERSION_EC_V2_SIGNING_ONLY = "ECv2SigningOnly";
-  public static final String ECDSA_SHA256_SIGNING_ALGO = "SHA256WithECDSA";
+  public static final HashType ECDSA_HASH_SHA256 = HashType.SHA256;
 
   public static final String JSON_ENCRYPTED_MESSAGE_KEY = "encryptedMessage";
   public static final String JSON_EPHEMERAL_PUBLIC_KEY = "ephemeralPublicKey";

File: apps/paymentmethodtoken/src/main/java/com/google/crypto/tink/apps/paymentmethodtoken/PaymentMethodTokenRecipient.java
Patch:
@@ -442,9 +442,7 @@ private static void verify(
       for (ECPublicKey publicKey : verifyingKeysProvider.get(protocolVersion)) {
         EcdsaVerifyJce verifier =
             new EcdsaVerifyJce(
-                publicKey,
-                PaymentMethodTokenConstants.ECDSA_SHA256_SIGNING_ALGO,
-                EcdsaEncoding.DER);
+                publicKey, PaymentMethodTokenConstants.ECDSA_HASH_SHA256, EcdsaEncoding.DER);
         for (byte[] signature : signatures) {
           try {
             verifier.verify(signature, signedBytes);

File: apps/paymentmethodtoken/src/main/java/com/google/crypto/tink/apps/paymentmethodtoken/PaymentMethodTokenSender.java
Patch:
@@ -87,7 +87,7 @@ public final class PaymentMethodTokenSender {
             builder.senderIntermediateSigningKey != null
                 ? builder.senderIntermediateSigningKey
                 : builder.senderSigningKey,
-            PaymentMethodTokenConstants.ECDSA_SHA256_SIGNING_ALGO,
+            PaymentMethodTokenConstants.ECDSA_HASH_SHA256,
             EcdsaEncoding.DER);
     this.senderId = builder.senderId;
     if (protocolVersionConfig.isEncryptionRequired) {

File: apps/paymentmethodtoken/src/main/java/com/google/crypto/tink/apps/paymentmethodtoken/SenderIntermediateCertFactory.java
Patch:
@@ -69,9 +69,7 @@ private SenderIntermediateCertFactory(
     for (ECPrivateKey senderSigningKey : senderSigningKeys) {
       this.signers.add(
           new EcdsaSignJce(
-              senderSigningKey,
-              PaymentMethodTokenConstants.ECDSA_SHA256_SIGNING_ALGO,
-              EcdsaEncoding.DER));
+              senderSigningKey, PaymentMethodTokenConstants.ECDSA_HASH_SHA256, EcdsaEncoding.DER));
     }
     this.intermediateSigningKey = intermediateSigningKey;
     this.expiration = expiration;

File: apps/rewardedads/src/main/java/com/google/crypto/tink/apps/rewardedads/RewardedAdsVerifier.java
Patch:
@@ -21,6 +21,7 @@
 import com.google.crypto.tink.subtle.EcdsaVerifyJce;
 import com.google.crypto.tink.subtle.EllipticCurves;
 import com.google.crypto.tink.subtle.EllipticCurves.EcdsaEncoding;
+import com.google.crypto.tink.subtle.Enums.HashType;
 import com.google.crypto.tink.util.KeysDownloader;
 import java.io.IOException;
 import java.net.URI;
@@ -152,8 +153,7 @@ private void verify(final byte[] tbs, long keyId, final byte[] signature)
       if (publicKeys.containsKey(keyId)) {
         foundKeyId = true;
         ECPublicKey publicKey = publicKeys.get(keyId);
-        EcdsaVerifyJce verifier =
-            new EcdsaVerifyJce(publicKey, "SHA256WithECDSA", EcdsaEncoding.DER);
+        EcdsaVerifyJce verifier = new EcdsaVerifyJce(publicKey, HashType.SHA256, EcdsaEncoding.DER);
         verifier.verify(signature, tbs);
       }
     }

File: java/src/main/java/com/google/crypto/tink/signature/EcdsaSignKeyManager.java
Patch:
@@ -71,7 +71,7 @@ public PublicKeySign getPrimitive(MessageLite key) throws GeneralSecurityExcepti
             keyProto.getKeyValue().toByteArray());
     return new EcdsaSignJce(
         privateKey,
-        SigUtil.toEcdsaAlgo(keyProto.getPublicKey().getParams().getHashType()),
+        SigUtil.toHashType(keyProto.getPublicKey().getParams().getHashType()),
         SigUtil.toEcdsaEncoding(keyProto.getPublicKey().getParams().getEncoding()));
   }
 

File: java/src/main/java/com/google/crypto/tink/signature/EcdsaVerifyKeyManager.java
Patch:
@@ -64,7 +64,7 @@ public PublicKeyVerify getPrimitive(MessageLite key) throws GeneralSecurityExcep
             keyProto.getY().toByteArray());
     return new EcdsaVerifyJce(
         publicKey,
-        SigUtil.toEcdsaAlgo(keyProto.getParams().getHashType()),
+        SigUtil.toHashType(keyProto.getParams().getHashType()),
         SigUtil.toEcdsaEncoding(keyProto.getParams().getEncoding()));
   }
 

File: java/src/main/java/com/google/crypto/tink/subtle/EcdsaSignJce.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.subtle.EllipticCurves.EcdsaEncoding;
+import com.google.crypto.tink.subtle.Enums.HashType;
 import java.security.GeneralSecurityException;
 import java.security.Signature;
 import java.security.interfaces.ECPrivateKey;
@@ -33,11 +34,10 @@ public final class EcdsaSignJce implements PublicKeySign {
   private final String signatureAlgorithm;
   private final EcdsaEncoding encoding;
 
-  public EcdsaSignJce(final ECPrivateKey priv, String signatureAlgorithm, EcdsaEncoding encoding)
+  public EcdsaSignJce(final ECPrivateKey priv, HashType hash, EcdsaEncoding encoding)
       throws GeneralSecurityException {
-    Validators.validateSignatureHash(signatureAlgorithm);
     this.privateKey = priv;
-    this.signatureAlgorithm = signatureAlgorithm;
+    this.signatureAlgorithm = SubtleUtil.toEcdsaAlgo(hash);
     this.encoding = encoding;
   }
 

File: java/src/main/java/com/google/crypto/tink/subtle/EcdsaVerifyJce.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.subtle.EllipticCurves.EcdsaEncoding;
+import com.google.crypto.tink.subtle.Enums.HashType;
 import java.security.GeneralSecurityException;
 import java.security.Signature;
 import java.security.interfaces.ECPublicKey;
@@ -33,12 +34,11 @@ public final class EcdsaVerifyJce implements PublicKeyVerify {
   private final String signatureAlgorithm;
   private final EcdsaEncoding encoding;
 
-  public EcdsaVerifyJce(final ECPublicKey pubKey, String signatureAlgorithm, EcdsaEncoding encoding)
+  public EcdsaVerifyJce(final ECPublicKey pubKey, HashType hash, EcdsaEncoding encoding)
       throws GeneralSecurityException {
     EllipticCurves.checkPublicKey(pubKey);
-    Validators.validateSignatureHash(signatureAlgorithm);
+    this.signatureAlgorithm = SubtleUtil.toEcdsaAlgo(hash);
     this.publicKey = pubKey;
-    this.signatureAlgorithm = signatureAlgorithm;
     this.encoding = encoding;
   }
 

File: java/src/test/java/com/google/crypto/tink/signature/EcdsaVerifyKeyManagerTest.java
Patch:
@@ -26,6 +26,7 @@
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.subtle.EllipticCurves;
 import com.google.crypto.tink.subtle.Random;
+import com.google.crypto.tink.subtle.SubtleUtil;
 import java.security.GeneralSecurityException;
 import java.security.KeyPair;
 import java.security.KeyPairGenerator;
@@ -155,7 +156,8 @@ public void testGetPrimitiveWithJCE() throws Exception {
       ECPrivateKey privKey = (ECPrivateKey) keyPair.getPrivate();
 
       // Sign with JCE's Signature.
-      Signature signer = Signature.getInstance(SigUtil.toEcdsaAlgo(hashType));
+      Signature signer =
+          Signature.getInstance(SubtleUtil.toEcdsaAlgo(SigUtil.toHashType(hashType)));
       signer.initSign(privKey);
       byte[] msg = Random.randBytes(1231);
       signer.update(msg);

File: java/src/test/java/com/google/crypto/tink/subtle/SignatureThreadSafetyTest.java
Patch:
@@ -24,6 +24,7 @@
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.TestUtil;
 import com.google.crypto.tink.subtle.EllipticCurves.EcdsaEncoding;
+import com.google.crypto.tink.subtle.Enums.HashType;
 import java.security.KeyPair;
 import java.security.KeyPairGenerator;
 import java.security.interfaces.ECPrivateKey;
@@ -218,8 +219,8 @@ public void testEcdsa() throws Exception {
     KeyPair keyPair = keyGen.generateKeyPair();
     ECPublicKey pub = (ECPublicKey) keyPair.getPublic();
     ECPrivateKey priv = (ECPrivateKey) keyPair.getPrivate();
-    EcdsaSignJce signer = new EcdsaSignJce(priv, "SHA256WithECDSA", EcdsaEncoding.DER);
-    EcdsaVerifyJce verifier = new EcdsaVerifyJce(pub, "SHA256WithECDSA", EcdsaEncoding.DER);
+    EcdsaSignJce signer = new EcdsaSignJce(priv, HashType.SHA256, EcdsaEncoding.DER);
+    EcdsaVerifyJce verifier = new EcdsaVerifyJce(pub, HashType.SHA256, EcdsaEncoding.DER);
 
     byte[] msg = Random.randBytes(20);
     testSigningSameMessage(signer, verifier, false, msg, 5, 20);

File: java/src/test/java/com/google/crypto/tink/WycheproofTestUtil.java
Patch:
@@ -79,7 +79,7 @@ public static JSONObject readJson(String path) throws Exception {
   public static EllipticCurves.CurveType getCurveType(String curveName)
       throws NoSuchAlgorithmException {
     switch (curveName) {
-      case "sepcp256r1":
+      case "secp256r1":
         return EllipticCurves.CurveType.NIST_P256;
       case "secp384r1":
         return EllipticCurves.CurveType.NIST_P384;

File: java/src/main/java/com/google/crypto/tink/Config.java
Patch:
@@ -86,7 +86,7 @@ public static void registerKeyType(KeyTypeEntry entry) throws GeneralSecurityExc
     KeyManager keyManager =
         catalogue.getKeyManager(
             entry.getTypeUrl(), entry.getPrimitiveName(), entry.getKeyManagerVersion());
-    Registry.registerKeyManager(entry.getTypeUrl(), keyManager, entry.getNewKeyAllowed());
+    Registry.registerKeyManager(keyManager, entry.getNewKeyAllowed());
   }
 
   private static void validate(KeyTypeEntry entry) throws GeneralSecurityException {

File: java/src/main/java/com/google/crypto/tink/aead/AesCtrHmacAeadKeyManager.java
Patch:
@@ -41,7 +41,7 @@
  */
 class AesCtrHmacAeadKeyManager implements KeyManager<Aead> {
   AesCtrHmacAeadKeyManager() throws GeneralSecurityException {
-    Registry.registerKeyManager(AesCtrKeyManager.TYPE_URL, new AesCtrKeyManager());
+    Registry.registerKeyManager(new AesCtrKeyManager());
   }
 
   private static final Logger logger =

File: apps/paymentmethodtoken/src/main/java/com/google/crypto/tink/apps/paymentmethodtoken/PaymentMethodTokenRecipientKem.java
Patch:
@@ -35,6 +35,7 @@
  *
  * @see <a href="https://developers.google.com/pay/api/payment-data-cryptography">Google Payment
  *     Method Token standard</a>
+ * @since 1.1.0
  */
 public interface PaymentMethodTokenRecipientKem {
   /**

File: java/src/main/java/com/google/crypto/tink/BinaryKeysetReader.java
Patch:
@@ -27,6 +27,8 @@
 /**
  * A {@link KeysetReader} that can read from some source cleartext or encrypted keysets in <a
  * href="https://developers.google.com/protocol-buffers/docs/encoding">proto binary wire format</a>.
+ *
+ * @since 1.0.0
  */
 public final class BinaryKeysetReader implements KeysetReader {
   private final InputStream inputStream;

File: java/src/main/java/com/google/crypto/tink/BinaryKeysetWriter.java
Patch:
@@ -26,6 +26,8 @@
 /**
  * A {@link KeysetWriter} that can write to some source cleartext or encrypted keysets in <a
  * href="https://developers.google.com/protocol-buffers/docs/encoding">proto binary wire format</a>.
+ *
+ * @since 1.0.0
  */
 public final class BinaryKeysetWriter implements KeysetWriter {
   private final OutputStream outputStream;

File: java/src/main/java/com/google/crypto/tink/Catalogue.java
Patch:
@@ -29,6 +29,8 @@
  *
  * <p>The template parameter {@code P} denotes the primitive corresponding to the {@link KeyManager}
  * handled by this catalogue.
+ *
+ * @since 1.0.0
  */
 public interface Catalogue<P> {
   /**

File: java/src/main/java/com/google/crypto/tink/CleartextKeysetHandle.java
Patch:
@@ -24,10 +24,12 @@
 /**
  * Static methods for reading or writing cleartext keysets.
  *
- * <p><b>Warning</b>
+ * <h3>WARNING</h3>
  *
  * <p>Reading or writing cleartext keysets is a bad practice, usage of this API should be
  * restricted. Users can read encrypted keysets using {@link KeysetHandle#read}.
+ *
+ * @since 1.0.0
  */
 public final class CleartextKeysetHandle {
   /**

File: java/src/main/java/com/google/crypto/tink/JsonKeysetReader.java
Patch:
@@ -42,6 +42,8 @@
  * A {@link KeysetReader} that can read from source source cleartext or encrypted keysets in <a
  * href="https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/util/JsonFormat">proto
  * JSON format</a>.
+ *
+ * @since 1.0.0
  */
 public final class JsonKeysetReader implements KeysetReader {
   private static final Charset UTF_8 = Charset.forName("UTF-8");

File: java/src/main/java/com/google/crypto/tink/JsonKeysetWriter.java
Patch:
@@ -37,6 +37,8 @@
  * A {@link KeysetWriter} that can write to some source cleartext or encrypted keysets in <a
  * href="https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/util/JsonFormat">proto
  * JSON format</a>.
+ *
+ * @since 1.0.0
  */
 public final class JsonKeysetWriter implements KeysetWriter {
   private static final Charset UTF_8 = Charset.forName("UTF-8");

File: java/src/main/java/com/google/crypto/tink/KeyManager.java
Patch:
@@ -31,6 +31,8 @@
  *
  * <p>The template parameter {@code P} denotes the primitive corresponding to the keys handled by
  * this manager.
+ *
+ * @since 1.0.0
  */
 public interface KeyManager<P> {
   // APIs for primitive development

File: java/src/main/java/com/google/crypto/tink/KeysetHandle.java
Patch:
@@ -33,6 +33,8 @@
  * <p>This class allows reading and writing encrypted keysets. Users that want to read or write can
  * use the restricted API {@link CleartextKeysetHandle}. Users can also load keysets that don't
  * contain any secret key material with {@link NoSecretKeysetHandle}.
+ *
+ * @since 1.0.0
  */
 public final class KeysetHandle {
   private Keyset keyset;

File: java/src/main/java/com/google/crypto/tink/KeysetManager.java
Patch:
@@ -28,6 +28,8 @@
 /**
  * Manages a {@link Keyset} proto, with convenience methods that rotate, disable, enable or destroy
  * keys.
+ *
+ * @since 1.0.0
  */
 public final class KeysetManager {
   @GuardedBy("this")

File: java/src/main/java/com/google/crypto/tink/KeysetReader.java
Patch:
@@ -22,6 +22,8 @@
 
 /**
  * A KeysetReader knows how to read a {@link Keyset} or an {@link EncryptedKeyset} from some source.
+ *
+ * @since 1.0.0
  */
 public interface KeysetReader {
   /**

File: java/src/main/java/com/google/crypto/tink/KeysetWriter.java
Patch:
@@ -23,6 +23,8 @@
 /**
  * A KeysetWriter knows how to write a {@link Keyset} or an {@link EncryptedKeyset} to some storage
  * system.
+ *
+ * @since 1.0.0
  */
 public interface KeysetWriter {
   /** Tries to write a {@link Keyset} to some storage system. */

File: java/src/main/java/com/google/crypto/tink/KmsClients.java
Patch:
@@ -30,6 +30,8 @@
  *
  * <p>This class consists exclusively of static methods that register and load {@link
  * KmsClient}-objects.
+ *
+ * @since 1.0.0
  */
 public final class KmsClients {
   // The list of KmsClients loaded automatically using ServiceLoader.

File: java/src/main/java/com/google/crypto/tink/Registry.java
Patch:
@@ -64,6 +64,8 @@
  * KeysetHandle keysetHandle = ...;
  * Aead aead = AeadFactory.getPrimitive(keysetHandle);
  * }</pre>
+ *
+ * @since 1.0.0
  */
 public final class Registry {
   private static final Logger logger = Logger.getLogger(Registry.class.getName());

File: java/src/main/java/com/google/crypto/tink/aead/AeadFactory.java
Patch:
@@ -31,7 +31,7 @@
 /**
  * Static methods for obtaining {@link Aead} instances.
  *
- * <p>Usage:
+ * <h3>Usage</h3>
  *
  * <pre>{@code
  * KeysetHandle keysetHandle = ...;
@@ -46,6 +46,8 @@
  * with the primary key. To decrypt, the primitive uses the prefix of the ciphertext to efficiently
  * select the right key in the set. If the keys associated with the prefix do not work, the
  * primitive tries all keys with {@link com.google.crypto.tink.proto.OutputPrefixType#RAW}.
+ *
+ * @since 1.0.0
  */
 public final class AeadFactory {
   private static final Logger logger = Logger.getLogger(AeadFactory.class.getName());

File: java/src/main/java/com/google/crypto/tink/config/TinkConfig.java
Patch:
@@ -32,6 +32,8 @@
  * <pre>{@code
  * Config.register(TinkConfig.TINK_1_1_0);
  * }</pre>
+ *
+ * @since 1.0.0
  */
 public final class TinkConfig {
   public static final RegistryConfig TINK_1_0_0 =
@@ -42,6 +44,7 @@ public final class TinkConfig {
           .setConfigName("TINK_1_0_0")
           .build();
 
+  /** @since 1.1.0 */
   public static final RegistryConfig TINK_1_1_0 =
       RegistryConfig.newBuilder()
           .mergeFrom(

File: java/src/main/java/com/google/crypto/tink/daead/DeterministicAeadConfig.java
Patch:
@@ -33,6 +33,8 @@
  *
  * <p>For more information on how to obtain and use instances of DeterministicAead, see {@link
  * DeterministicAeadFactory}.
+ *
+ * @since 1.1.0
  */
 public final class DeterministicAeadConfig {
   public static final String AES_SIV_TYPE_URL = AesSivKeyManager.TYPE_URL;

File: java/src/main/java/com/google/crypto/tink/daead/DeterministicAeadFactory.java
Patch:
@@ -31,7 +31,7 @@
 /**
  * Static methods for obtaining {@link DeterministicAead} instances.
  *
- * <p>Usage:
+ * <h3>Usage</h3>
  *
  * <pre>{@code
  * KeysetHandle keysetHandle = ...;
@@ -46,6 +46,8 @@
  * with the primary key. To decrypt, the primitive uses the prefix of the ciphertext to efficiently
  * select the right key in the set. If the keys associated with the prefix do not work, the
  * primitive tries all keys with {@link com.google.crypto.tink.proto.OutputPrefixType#RAW}.
+ *
+ * @since 1.1.0
  */
 public final class DeterministicAeadFactory {
   private static final Logger logger = Logger.getLogger(DeterministicAeadFactory.class.getName());

File: java/src/main/java/com/google/crypto/tink/daead/DeterministicAeadKeyTemplates.java
Patch:
@@ -30,6 +30,8 @@
  *   KeysetHandle handle = KeysetHandle.generateNew(DeterministicAeadKeyTemplates.AES256_SIV);
  *   DeterministicAead daead = DeterministicAeadFactory.getPrimitive(handle);
  * </pre>
+ *
+ * @since 1.1.0
  */
 public final class DeterministicAeadKeyTemplates {
   /** A {@code KeyTemplate} that generates new instances of {@code AesSivKey} with a 64-byte key. */

File: java/src/main/java/com/google/crypto/tink/hybrid/HybridDecryptFactory.java
Patch:
@@ -29,7 +29,7 @@
 /**
  * Static methods for obtaining {@link HybridDecrypt} instances.
  *
- * <p>Usage:
+ * <h3>Usage</h3>
  *
  * <pre>{@code
  * KeysetHandle keysetHandle = ...;
@@ -43,6 +43,8 @@
  * primitive uses the prefix of the ciphertext to efficiently select the right key in the set. If
  * the keys associated with the prefix do not work, the primitive tries all keys with {@link
  * com.google.crypto.tink.proto.OutputPrefixType#RAW}.
+ *
+ * @since 1.0.0
  */
 public final class HybridDecryptFactory {
   private static final Logger logger = Logger.getLogger(HybridDecryptFactory.class.getName());

File: java/src/main/java/com/google/crypto/tink/hybrid/HybridEncryptFactory.java
Patch:
@@ -27,7 +27,7 @@
 /**
  * Static methods for obtaining {@link HybridEncrypt} instances.
  *
- * <p>Usage:
+ * <h3>Usage</h3>
  *
  * <pre>{@code
  * KeysetHandle keysetHandle = ...;
@@ -40,6 +40,8 @@
  * <p>The returned primitive works with a keyset (rather than a single key). To encrypt a plaintext,
  * it uses the primary key in the keyset, and prepends to the ciphertext a certain prefix associated
  * with the primary key.
+ *
+ * @since 1.0.0
  */
 public final class HybridEncryptFactory {
   private static final Logger logger = Logger.getLogger(HybridEncryptFactory.class.getName());

File: java/src/main/java/com/google/crypto/tink/hybrid/HybridKeyTemplates.java
Patch:
@@ -41,6 +41,8 @@
  *     HybridKeyTemplates.ECIES_P256_HKDF_HMAC_SHA256_AES128_GCM);
  * PublicKeySign signer = PublicKeySignFactory.getPrimitive(handle);
  * }</pre>
+ *
+ * @since 1.0.0
  */
 public final class HybridKeyTemplates {
   private static final byte[] EMPTY_SALT = new byte[0];

File: java/src/main/java/com/google/crypto/tink/integration/android/AndroidKeystoreAesGcm.java
Patch:
@@ -31,6 +31,8 @@
  * href="https://developer.android.com/training/articles/keystore.html">Android Keystore</a>.
  *
  * <p>This class requires Android M (API level 23) or newer.
+ *
+ * @since 1.0.0
  */
 @TargetApi(VERSION_CODES.M)
 public final class AndroidKeystoreAesGcm implements Aead {

File: java/src/main/java/com/google/crypto/tink/integration/android/AndroidKeystoreKmsClient.java
Patch:
@@ -34,6 +34,8 @@
  * href="https://developer.android.com/training/articles/keystore.html">Android Keystore</a>.
  *
  * <p>This class requires Android M (API level 23) or newer.
+ *
+ * @since 1.0.0
  */
 @TargetApi(VERSION_CODES.M)
 public final class AndroidKeystoreKmsClient implements KmsClient {

File: java/src/main/java/com/google/crypto/tink/integration/android/SharedPrefKeysetReader.java
Patch:
@@ -27,6 +27,8 @@
 
 /**
  * A {@link KeysetReader} that can read keysets from private shared preferences on Android.
+ *
+ * @since 1.0.0
  */
 public final class SharedPrefKeysetReader implements KeysetReader {
   private final SharedPreferences sharedPreferences;

File: java/src/main/java/com/google/crypto/tink/integration/awskms/AwsKmsAead.java
Patch:
@@ -29,6 +29,8 @@
 /**
  * A {@link Aead} that forwards encryption/decryption requests to a key in <a
  * href="https://aws.amazon.com/kms/">AWS KMS</a>.
+ *
+ * @since 1.0.0
  */
 public final class AwsKmsAead implements Aead {
 

File: java/src/main/java/com/google/crypto/tink/integration/gcpkms/GcpKmsAead.java
Patch:
@@ -30,6 +30,8 @@
  * href="https://cloud.google.com/kms/">Google Cloud KMS</a>.
  *
  * <p>As of August 2017, Google Cloud KMS supports only AES-256-GCM keys.
+ *
+ * @since 1.0.0
  */
 public final class GcpKmsAead implements Aead {
 

File: java/src/main/java/com/google/crypto/tink/integration/gcpkms/GcpKmsClient.java
Patch:
@@ -33,6 +33,8 @@
 /**
  * An implementation of {@code KmsClient} for <a href="https://cloud.google.com/kms/">Google Cloud
  * KMS</a>.
+ *
+ * @since 1.0.0
  */
 @AutoService(KmsClient.class)
 public final class GcpKmsClient implements KmsClient {

File: java/src/main/java/com/google/crypto/tink/mac/MacFactory.java
Patch:
@@ -32,7 +32,7 @@
 /**
  * Static methods for obtaining {@link Mac} instances.
  *
- * <p>Usage:
+ * <h3>Usage</h3>
  *
  * <pre>{@code
  * KeysetHandle keysetHandle = ...;
@@ -47,6 +47,8 @@
  * the primary key. To verify a tag, the primitive uses the prefix of the tag to efficiently select
  * the right key in the set. If the keys associated with the prefix do not validate the tag, the
  * primitive tries all keys with {@link com.google.crypto.tink.proto.OutputPrefixType#RAW}.
+ *
+ * @since 1.0.0
  */
 public final class MacFactory {
   private static final Logger logger = Logger.getLogger(MacFactory.class.getName());

File: java/src/main/java/com/google/crypto/tink/mac/MacKeyTemplates.java
Patch:
@@ -34,6 +34,8 @@
  * KeysetHandle handle = KeysetHandle.generateNew(MacKeyTemplates.HMAC_SHA256_128BITTAG);
  * Mac mac = MacFactory.getPrimitive(handle);
  * }</pre>
+ *
+ * @since 1.0.0
  */
 public final class MacKeyTemplates {
   /**

File: java/src/main/java/com/google/crypto/tink/signature/PublicKeySignFactory.java
Patch:
@@ -29,7 +29,7 @@
 /**
  * Static methods for obtaining {@link PublicKeySign} instances.
  *
- * <p>Usage:
+ * <h3>Usage</h3>
  *
  * <pre>{@code
  * KeysetHandle keysetHandle = ...;
@@ -41,6 +41,8 @@
  * <p>The returned primitive works with a keyset (rather than a single key). To sign a message, it
  * uses the primary key in the keyset, and prepends to the signature a certain prefix associated
  * with the primary key.
+ *
+ * @since 1.0.0
  */
 public final class PublicKeySignFactory {
   /**

File: java/src/main/java/com/google/crypto/tink/signature/PublicKeyVerifyFactory.java
Patch:
@@ -32,7 +32,7 @@
 /**
  * Static methods for obtaining {@link PublicKeyVerify} instances.
  *
- * <p>Usage:
+ * <h3>Usage</h3>
  *
  * <pre>{@code
  * KeysetHandle keysetHandle = ...;
@@ -44,6 +44,8 @@
  * the primitive uses the prefix of the signature to efficiently select the right key in the set. If
  * there is no key associated with the prefix or if the keys associated with the prefix do not work,
  * the primitive tries all keys with {@link com.google.crypto.tink.proto.OutputPrefixType#RAW}.
+ *
+ * @since 1.0.0
  */
 public final class PublicKeyVerifyFactory {
   private static final Logger logger = Logger.getLogger(PublicKeyVerifyFactory.class.getName());

File: java/src/main/java/com/google/crypto/tink/signature/SignatureConfig.java
Patch:
@@ -35,6 +35,8 @@
  *
  * <p>For more information on how to obtain and use instances of PublicKeySign or PublicKeyVerify,
  * see {@link PublicKeySignFactory} or {@link PublicKeyVerifyFactory}.
+ *
+ * @since 1.0.0
  */
 public final class SignatureConfig {
   public static final String ECDSA_PUBLIC_KEY_TYPE_URL = EcdsaVerifyKeyManager.TYPE_URL;
@@ -61,7 +63,7 @@ public final class SignatureConfig {
                   PUBLIC_KEY_VERIFY_CATALOGUE_NAME, "PublicKeyVerify", "Ed25519PublicKey", 0, true))
           .build();
 
-
+  /** @since 1.1.0 */
   public static final RegistryConfig TINK_1_1_0 =
       RegistryConfig.newBuilder()
           .mergeFrom(TINK_1_0_0)

File: java/src/main/java/com/google/crypto/tink/streamingaead/StreamingAeadConfig.java
Patch:
@@ -33,6 +33,8 @@
  *
  * <p>For more information on how to obtain and use instances of StreamingAead, see {@link
  * StreamingAeadFactory}.
+ *
+ * @since 1.1.0
  */
 public final class StreamingAeadConfig {
   public static final String AES_CTR_HMAC_STREAMINGAEAD_TYPE_URL =

File: java/src/main/java/com/google/crypto/tink/streamingaead/StreamingAeadFactory.java
Patch:
@@ -27,7 +27,7 @@
 /**
  * Static methods for obtaining {@link StreamingAead} instances.
  *
- * <p>Usage:
+ * <h3>Usage</h3>
  *
  * <pre>{@code
  * KeysetHandle keysetHandle = ...;
@@ -48,6 +48,8 @@
  * it uses the primary key in the keyset. To decrypt, the primitive tries the enabled keys from the
  * keyset to select the right key for decryption. All keys in a keyset of StreamingAead have type
  * {@link com.google.crypto.tink.proto.OutputPrefixType#RAW}.
+ *
+ * @since 1.1.0
  */
 public final class StreamingAeadFactory {
   private static final Logger logger = Logger.getLogger(StreamingAeadFactory.class.getName());

File: java/src/main/java/com/google/crypto/tink/streamingaead/StreamingAeadKeyTemplates.java
Patch:
@@ -37,6 +37,8 @@
  * KeysetHandle handle = KeysetHandle.generateNew(StreamingAeadKeyTemplates.AES128_GCM_HKDF_4KB);
  * StreamingAead ags = StreamingAeadFactory.getPrimitive(handle);
  * }</pre>
+ *
+ * @since 1.1.0
  */
 public final class StreamingAeadKeyTemplates {
   /**

File: java/src/main/java/com/google/crypto/tink/subtle/AesCtrHmacStreaming.java
Patch:
@@ -41,6 +41,8 @@
  * <p>segment_i is the i-th segment of the ciphertext. The size of segment_1 .. segment_{k-1} is
  * ciphertextSegmentSize. segment_0 is shorter, so that segment_0, the header and other information
  * of size firstSegmentOffset align with ciphertextSegmentSize.
+ *
+ * @since 1.1.0
  */
 public final class AesCtrHmacStreaming extends NonceBasedStreamingAead {
   // TODO(bleichen): Some things that are not yet decided:

File: java/src/main/java/com/google/crypto/tink/subtle/AesEaxJce.java
Patch:
@@ -44,6 +44,8 @@
  * <p>Plans: The current implementation is slow since it uses JCA and only assumes that the
  * encryption modes "AES/ECB/NOPADDING" and "AES/CTR/NOPADDING" are implemented. Our plan is to
  * implement a native version of EAX.
+ *
+ * @since 1.0.0
  */
 public final class AesEaxJce implements Aead {
   static final int BLOCK_SIZE_IN_BYTES = 16;

File: java/src/main/java/com/google/crypto/tink/subtle/AesGcmHkdfStreaming.java
Patch:
@@ -42,6 +42,8 @@
  * of size firstSegmentOffset align with ciphertextSegmentSize.
  *
  * <p>This class does not work on Android KitKat (API level 19) or older.
+ *
+ * @since 1.1.0
  */
 public final class AesGcmHkdfStreaming extends NonceBasedStreamingAead {
   // TODO(bleichen): Some things that are not yet decided:

File: java/src/main/java/com/google/crypto/tink/subtle/AesSiv.java
Patch:
@@ -31,6 +31,8 @@
  *
  * <p>To meet the security requirements of {@link DeterministicAead}, this cipher can only be used
  * with 256-bit keys.
+ *
+ * @since 1.1.0
  */
 public final class AesSiv implements DeterministicAead {
   // Do not support 128-bit keys because it might not provide 128-bit security level in

File: java/src/main/java/com/google/crypto/tink/subtle/Base64.java
Patch:
@@ -27,6 +27,8 @@
  *
  * <p>This is a copy of android.util.Base64, with minor modifications to to fix style and ErrorProne
  * errors.
+ *
+ * @since 1.0.0
  */
 public final class Base64 {
   private static final Charset UTF_8 = Charset.forName("UTF-8");

File: java/src/main/java/com/google/crypto/tink/subtle/ChaCha20Poly1305.java
Patch:
@@ -21,6 +21,8 @@
 /**
  * ChaCha20-Poly1305, as described in <a href="https://tools.ietf.org/html/rfc7539#section-2.8">RFC
  * 7539, section 2.8</a>.
+ *
+ * @since 1.1.0
  */
 public final class ChaCha20Poly1305 extends SnufflePoly1305 {
   public ChaCha20Poly1305(final byte[] key) throws InvalidKeyException {

File: java/src/main/java/com/google/crypto/tink/subtle/EciesAeadHkdfHybridDecrypt.java
Patch:
@@ -26,6 +26,8 @@
 /**
  * ECIES encryption with HKDF-KEM (key encapsulation mechanism) and AEAD-DEM (data encapsulation
  * mechanism).
+ *
+ * @since 1.0.0
  */
 public final class EciesAeadHkdfHybridDecrypt implements HybridDecrypt {
   private static final byte[] EMPTY_AAD = new byte[0];

File: java/src/main/java/com/google/crypto/tink/subtle/Ed25519Sign.java
Patch:
@@ -23,14 +23,16 @@
 /**
  * Ed25519 signing.
  *
- * <p>Usage:
+ * <h3>Usage</h3>
  *
  * <pre>{@code
  * Ed25519Sign.KeyPair keyPair = Ed25519Sign.KeyPair.newKeyPair();
  * // securely store keyPair and share keyPair.getPublicKey()
  * Ed25519Sign signer = new Ed25519Sign(keyPair.getPrivateKey());
  * byte[] signature = signer.sign(message);
  * }</pre>
+ *
+ * @since 1.1.0
  */
 public final class Ed25519Sign implements PublicKeySign {
 

File: java/src/main/java/com/google/crypto/tink/subtle/EncryptThenAuthenticate.java
Patch:
@@ -31,6 +31,8 @@
  * is based on <a
  * href="http://tools.ietf.org/html/draft-mcgrew-aead-aes-cbc-hmac-sha2-05">Authenticated Encryption
  * with AES-CBC and HMAC-SHA</a>.
+ *
+ * @since 1.0.0
  */
 public final class EncryptThenAuthenticate implements Aead {
   private final IndCpaCipher cipher;

File: java/src/main/java/com/google/crypto/tink/subtle/EngineWrapper.java
Patch:
@@ -31,6 +31,8 @@
  *
  * <p>There's no expected reason to directly import this for users of Tink, but it might be needed
  * to implement it (say, if someone wants a new type of engine).
+ *
+ * @since 1.0.0
  */
 public interface EngineWrapper<T> {
 

File: java/src/main/java/com/google/crypto/tink/subtle/Hkdf.java
Patch:
@@ -23,6 +23,8 @@
 /**
  * This class implements HMAC-based Extract-and-Expand Key Derivation Function (HKDF), as described
  * in <a href="https://tools.ietf.org/html/rfc5869">RFC 5869</a>.
+ *
+ * @since 1.0.0
  */
 public final class Hkdf {
 

File: java/src/main/java/com/google/crypto/tink/subtle/IndCpaCipher.java
Patch:
@@ -24,6 +24,8 @@
  *
  * <p>Said primitives do not provide authentication, thus should not be used directly, but only to
  * construct safer primitives such as {@link com.google.crypto.tink.Aead}.
+ *
+ * @since 1.0.0
  */
 public interface IndCpaCipher {
   /**

File: java/src/main/java/com/google/crypto/tink/subtle/RewindableReadableByteChannel.java
Patch:
@@ -27,6 +27,8 @@
  * again read the bytes from the beginning. Once the rewinding feature is not needed any more, it
  * can be disabled via {@link #disableRewinding}: this frees the cache memory and forwadrds the
  * subsequent {@link #read}-calls directly to the wrapped channel.
+ *
+ * @since 1.1.0
  */
 public final class RewindableReadableByteChannel implements ReadableByteChannel {
   @GuardedBy("this")

File: java/src/main/java/com/google/crypto/tink/subtle/StreamSegmentDecrypter.java
Patch:
@@ -24,6 +24,8 @@
  *
  * <p>Instances of this interfaces are passed to {@link StreamingAeadDecryptingChannel}. Each
  * instance must be initialized with the header of the ciphertext.
+ *
+ * @since 1.1.0
  */
 public interface StreamSegmentDecrypter {
   void init(ByteBuffer header, byte[] aad) throws GeneralSecurityException;

File: java/src/main/java/com/google/crypto/tink/subtle/StreamSegmentEncrypter.java
Patch:
@@ -31,6 +31,8 @@
  * <p>A StreamSegmentEncrypter has a state: it keeps the number of segments encrypted so far. This
  * state is used to encrypt each segment with different parameters, so that segments in the
  * ciphertext cannot be switched.
+ *
+ * @since 1.1.0
  */
 public interface StreamSegmentEncrypter {
 

File: java/src/main/java/com/google/crypto/tink/PrimitiveSet.java
Patch:
@@ -19,7 +19,6 @@
 import com.google.crypto.tink.proto.KeyStatusType;
 import com.google.crypto.tink.proto.Keyset;
 import com.google.crypto.tink.proto.OutputPrefixType;
-import com.google.errorprone.annotations.Immutable;
 import java.nio.charset.Charset;
 import java.security.GeneralSecurityException;
 import java.util.ArrayList;
@@ -45,20 +44,20 @@
  * set.
  *
  * <p>PrimitiveSet is a public class to allow its use in implementations of custom primitives.
+ *
+ * @since 1.0.0
  */
 public final class PrimitiveSet<P> {
   private static final Charset UTF_8 = Charset.forName("UTF-8");
   /**
    * A single entry in the set. In addition to the actual primitive it holds also some extra
    * information about the primitive.
    */
-  @Immutable(containerOf = {"P"})
   public static final class Entry<P> {
     // The actual primitive.
     private final P primitive;
     // Identifies the primitive within the set.
     // It is the ciphertext prefix of the correponding key.
-    @SuppressWarnings("Immutable")
     private final byte[] identifier;
     // The status of the key represented by the primitive.
     private final KeyStatusType status;

File: java/src/main/java/com/google/crypto/tink/subtle/Ed25519.java
Patch:
@@ -24,7 +24,6 @@
 import static com.google.crypto.tink.subtle.Field25519.FIELD_LEN;
 import static com.google.crypto.tink.subtle.Field25519.LIMB_CNT;
 
-import com.google.crypto.tink.annotations.Alpha;
 import java.security.GeneralSecurityException;
 import java.security.MessageDigest;
 import java.util.Arrays;
@@ -43,7 +42,6 @@
  * @see <a href="https://eprint.iacr.org/2008/522.pdf">Hisil H., Wong K.KH., Carter G., Dawson E.
  *     (2008) Twisted Edwards Curves Revisited</a>
  */
-@Alpha
 final class Ed25519 {
 
   public static final int SECRET_KEY_LEN = FIELD_LEN;

File: java/src/main/java/com/google/crypto/tink/subtle/Ed25519Verify.java
Patch:
@@ -17,13 +17,12 @@
 package com.google.crypto.tink.subtle;
 
 import com.google.crypto.tink.PublicKeyVerify;
-import com.google.errorprone.annotations.Immutable;
 import java.security.GeneralSecurityException;
 
 /**
  * Ed25519 verifying.
  *
- * <p>Usage:
+ * <h3>Usage</h3>
  *
  * <pre>{@code
  * // get the publicKey from the other party.
@@ -34,8 +33,9 @@
  *   // all the rest of security exceptions.
  * }
  * }</pre>
+ *
+ * @since 1.1.0
  */
-@Immutable
 public final class Ed25519Verify implements PublicKeyVerify {
 
   public static final int PUBLIC_KEY_LEN = Field25519.FIELD_LEN;

File: apps/paymentmethodtoken/src/main/java/com/google/crypto/tink/apps/paymentmethodtoken/PaymentMethodTokenRecipient.java
Patch:
@@ -496,7 +496,7 @@ private List<SenderVerifyingKeysProvider> verifyIntermediateSigningKey(JSONObjec
     JSONObject signedKey = new JSONObject(signedKeyAsString);
     validateSignedKey(signedKey);
     final String key = signedKey.getString(PaymentMethodTokenConstants.JSON_KEY_VALUE_KEY);
-    return Collections.singletonList(
+    SenderVerifyingKeysProvider provider =
         new SenderVerifyingKeysProvider() {
           @Override
           public List<ECPublicKey> get(String protocolVersion) throws GeneralSecurityException {
@@ -506,7 +506,8 @@ public List<ECPublicKey> get(String protocolVersion) throws GeneralSecurityExcep
               return Collections.emptyList();
             }
           }
-        });
+        };
+    return Collections.singletonList(provider);
   }
 
   private JSONObject validateIntermediateSigningKey(final JSONObject intermediateSigningKey)

File: apps/webpush/src/main/java/com/google/crypto/tink/apps/webpush/WebPushHybridDecrypt.java
Patch:
@@ -176,8 +176,8 @@ public Builder withRecipientPrivateKey(ECPrivateKey val) throws GeneralSecurityE
     /**
      * Sets the private key of the recipient.
      *
-     * <p>The private key is in PKCS8 encoding. In Java, this is the return value of {@link
-     * ECPrivateKey#getEncoded()}.
+     * <p>The private key is the serialized bytes of the BigInteger returned by
+     * {@link ECPrivateKey#getS()}.
      */
     public Builder withRecipientPrivateKey(final byte[] val) throws GeneralSecurityException {
       recipientPrivateKey =

File: apps/paymentmethodtoken/src/main/java/com/google/crypto/tink/apps/paymentmethodtoken/PaymentMethodTokenRecipientKem.java
Patch:
@@ -31,7 +31,7 @@
  * ephemeral public key, and from that derive the DEM key using HKDF. If the recipient keeps the
  * private key in a HSM, they cannot load the private key in Tink, but they can implement this
  * interface and configure Tink to use their custom KEM implementation with {@link
- * PaymentMethodTokenRecipient#addRecipientKem}.
+ * PaymentMethodTokenRecipient.Builder#addRecipientKem}.
  *
  * @see <a href="https://developers.google.com/pay/api/payment-data-cryptography">Google Payment
  *     Method Token standard</a>

File: apps/paymentmethodtoken/src/main/java/com/google/crypto/tink/apps/paymentmethodtoken/PaymentMethodTokenRecipientKeyGen.java
Patch:
@@ -30,7 +30,7 @@
  * href="https://developers.google.com/android-pay/integration/payment-token-cryptography">Google
  * Payment Method Token</a>.
  *
- * <p>Usage:
+ * <h3>Usage</h3>
  *
  * <pre>
  * bazel build apps/paymentmethodtoken/...
@@ -39,8 +39,8 @@
  *
  * <p>Running that command will generate a fresh key pair. The private/public key can be found in
  * private_key.bin/public_key.bin. The content of private_key.bin can be passed to {@link
- * PaymentMethodTokenRecipient#addRecipientPrivateKey} and the content of public_key.bin can be
- * passed to {@link PaymentMethodTokenSender#rawUncompressedRecipientPublicKey}.
+ * PaymentMethodTokenRecipient.Builder#addRecipientPrivateKey} and the content of public_key.bin can
+ * be passed to {@link PaymentMethodTokenSender.Builder#rawUncompressedRecipientPublicKey}.
  */
 public final class PaymentMethodTokenRecipientKeyGen {
   private static final String PRIVATE_KEY_FILE = "private_key.bin";

File: tools/tinkey/src/main/java/com/google/crypto/tink/tinkey/TinkeyUtil.java
Patch:
@@ -138,7 +138,7 @@ public static void manipulateKey(
         manager = manager.destroy(keyId);
         break;
       case DISABLE_KEY:
-        manager = manager.enable(keyId);
+        manager = manager.disable(keyId);
         break;
       case ENABLE_KEY:
         manager = manager.enable(keyId);

File: java/src/test/java/com/google/crypto/tink/hybrid/EciesAeadHkdfHybridDecryptTest.java
Patch:
@@ -53,8 +53,8 @@ private void testModifyDecrypt(CurveType curveType, KeyTemplate keyTemplate) thr
     ECPublicKey recipientPublicKey = (ECPublicKey) recipientKey.getPublic();
     ECPrivateKey recipientPrivateKey = (ECPrivateKey) recipientKey.getPrivate();
     byte[] salt = Random.randBytes(8);
-    byte[] plaintext = Random.randBytes(8);
-    byte[] context = "context info".getBytes("UTF-8");
+    byte[] plaintext = Random.randBytes(4);
+    byte[] context = Random.randBytes(4);
     String hmacAlgo = HybridUtil.toHmacAlgo(HashType.SHA256);
     HybridEncrypt hybridEncrypt =
         new EciesAeadHkdfHybridEncrypt(

File: java/src/test/java/com/google/crypto/tink/subtle/ChaCha20Poly1305Test.java
Patch:
@@ -241,7 +241,7 @@ public void testRandomNonce() throws Exception {
     byte[] message = new byte[0];
     byte[] aad = new byte[0];
     HashSet<String> ciphertexts = new HashSet<String>();
-    final int samples = 1 << 17;
+    final int samples = 1 << 10;
     for (int i = 0; i < samples; i++) {
       byte[] ct = aead.encrypt(message, aad);
       String ctHex = TestUtil.hexEncode(ct);

File: java/src/test/java/com/google/crypto/tink/subtle/Ed25519Test.java
Patch:
@@ -47,7 +47,7 @@ public void testUnmodifiedKey() throws Exception {
         Arrays.copyOfRange(hashedPrivateKey, 0, hashedPrivateKey.length);
     byte[] publicKey = Ed25519.scalarMultWithBaseToBytes(hashedPrivateKey);
     byte[] originalPublicKey = Arrays.copyOfRange(publicKey, 0, publicKey.length);
-    for (int i = 0; i < 1024; i++) {
+    for (int i = 0; i < 64; i++) {
       byte[] msg = Random.randBytes(1024);
       byte[] sig = Ed25519.sign(msg, publicKey, hashedPrivateKey);
       assertTrue(Ed25519.verify(msg, sig, publicKey));

File: java/src/main/java/com/google/crypto/tink/subtle/Hex.java
Patch:
@@ -32,7 +32,7 @@ public static String encode(final byte[] bytes) {
   }
 
   /** Decodes a hex string to a byte array. */
-  public static byte[] decode(String hex) throws IllegalArgumentException {
+  public static byte[] decode(String hex) {
     if (hex.length() % 2 != 0) {
       throw new IllegalArgumentException("Expected a string of even length");
     }

File: java/src/main/java/com/google/crypto/tink/BinaryKeysetWriter.java
Patch:
@@ -34,10 +34,12 @@ private BinaryKeysetWriter(OutputStream stream) {
     outputStream = stream;
   }
 
+  /** Static method to create a BinaryKeysetWriter that writes to an {@link OutputStream}. */
   public static KeysetWriter withOutputStream(OutputStream stream) {
     return new BinaryKeysetWriter(stream);
   }
 
+  /** Static method to create a BinaryKeysetWriter that writes to a file. */
   public static KeysetWriter withFile(File file) throws IOException {
     return new BinaryKeysetWriter(new FileOutputStream(file));
   }

File: java/src/main/java/com/google/crypto/tink/KeysetHandle.java
Patch:
@@ -27,8 +27,8 @@
 import java.security.GeneralSecurityException;
 
 /**
- * A KeysetHandle provides abstracted access to {@link com.google.crypto.tink.proto.Keyset}, to
- * limit the exposure of actual protocol buffers that hold sensitive key material.
+ * A KeysetHandle provides abstracted access to {@link Keyset}, to limit the exposure of actual
+ * protocol buffers that hold sensitive key material.
  *
  * <p>This class allows reading and writing encrypted keysets. Users that want to read or write can
  * use the restricted API {@link CleartextKeysetHandle}. Users can also load keysets that don't

File: java/src/main/java/com/google/crypto/tink/KeysetManager.java
Patch:
@@ -26,8 +26,8 @@
 import javax.annotation.concurrent.GuardedBy;
 
 /**
- * Manages a {@link com.google.crypto.tink.proto.Keyset} proto, with convenience methods that
- * rotate, disable, enable or destroy keys.
+ * Manages a {@link Keyset} proto, with convenience methods that rotate, disable, enable or destroy
+ * keys.
  */
 public final class KeysetManager {
   @GuardedBy("this")

File: java/src/main/java/com/google/crypto/tink/NoSecretKeysetHandle.java
Patch:
@@ -25,7 +25,7 @@
 /** Static methods for reading cleartext keysets that don't contain any secret key material. */
 public final class NoSecretKeysetHandle {
   /**
-   * @return a new keyset handle from {@code serialized} which is a serialized {@code Keyset}.
+   * @return a new keyset handle from {@code serialized} which is a serialized {@link Keyset}.
    * @throws GeneralSecurityException
    * @deprecated use {@link NoSecretKeysetHandle#read} instead
    */

File: java/src/main/java/com/google/crypto/tink/Registry.java
Patch:
@@ -43,7 +43,7 @@
  * for specific KeyManagers. Registry is public though, to enable configurations with custom
  * catalogues, primitives or KeyManagers.
  *
- * <p>To initialize the Registery with all key managers in Tink 1.0.0, one can do as follows:
+ * <p>To initialize the Registry with all key managers in Tink 1.0.0, one can do as follows:
  *
  * <pre>{@code
  * Config.register(TinkConfig.TINK_1_0_0);
@@ -228,7 +228,7 @@ public static <P> KeyManager<P> getKeyManager(String typeUrl) throws GeneralSecu
   }
 
   /**
-   * Convenience method for generating a new {@code KeyData} for the specified {@code template}.
+   * Convenience method for generating a new {@link KeyData} for the specified {@code template}.
    *
    * <p>It looks up a {@link KeyManager} identified by {@code keyTemplate.type_url}, and calls
    * {@link KeyManager#newKeyData}.
@@ -288,7 +288,7 @@ public static <P> MessageLite newKey(String typeUrl, MessageLite format)
    * serializedPrivateKey}.
    *
    * <p>It looks up a {@link PrivateKeyManager} identified by {@code typeUrl}, and calls {@link
-   * KeyManager#getPublicKeyData} with {@code serializedPrivateKey} as the parameter.
+   * PrivateKeyManager#getPublicKeyData} with {@code serializedPrivateKey} as the parameter.
    *
    * @return a new key
    */

File: java/src/main/java/com/google/crypto/tink/integration/android/AndroidKeystoreAesGcm.java
Patch:
@@ -27,10 +27,10 @@
 import javax.crypto.spec.GCMParameterSpec;
 
 /**
- * An {@link Aead} that does AES-GCM encryption with a key stored in
- * <a href="https://developer.android.com/training/articles/keystore.html">Android Keystore</a>.
+ * An {@link Aead} that does AES-GCM encryption with a key stored in <a
+ * href="https://developer.android.com/training/articles/keystore.html">Android Keystore</a>.
  *
- * <p>This class requires Android M or newer.
+ * <p>This class requires Android M (API level 23) or newer.
  */
 @TargetApi(VERSION_CODES.M)
 public final class AndroidKeystoreAesGcm implements Aead {

File: java/src/main/java/com/google/crypto/tink/integration/android/AndroidKeystoreKmsClient.java
Patch:
@@ -33,7 +33,7 @@
  * An implementation of {@link KmsClient} for <a
  * href="https://developer.android.com/training/articles/keystore.html">Android Keystore</a>.
  *
- * <p>This class requires Android M or newer.
+ * <p>This class requires Android M (API level 23) or newer.
  */
 @TargetApi(VERSION_CODES.M)
 public final class AndroidKeystoreKmsClient implements KmsClient {

File: java/src/main/java/com/google/crypto/tink/integration/awskms/AwsKmsClient.java
Patch:
@@ -28,7 +28,7 @@
 import com.google.crypto.tink.subtle.Validators;
 import java.security.GeneralSecurityException;
 
-/** An implementation of {@code KmsClient} for AWS KMS. */
+/** An implementation of {@link KmsClient} for <a href="https://aws.amazon.com/kms/">AWS KMS</a>. */
 @AutoService(KmsClient.class)
 public final class AwsKmsClient implements KmsClient {
   /** The prefix of all keys stored in AWS KMS. */

File: java/src/main/java/com/google/crypto/tink/integration/gcpkms/GcpKmsAead.java
Patch:
@@ -26,7 +26,8 @@
 import java.security.GeneralSecurityException;
 
 /**
- * A {@link Aead} that forwards encryption/decryption requests to a key in Google Cloud KMS.
+ * A {@link Aead} that forwards encryption/decryption requests to a key in <a
+ * href="https://cloud.google.com/kms/">Google Cloud KMS</a>.
  *
  * <p>As of August 2017, Google Cloud KMS supports only AES-256-GCM keys.
  */

File: java/src/main/java/com/google/crypto/tink/mac/MacConfig.java
Patch:
@@ -73,7 +73,7 @@ public static void init() throws GeneralSecurityException {
    * <p>Deprecated-yet-still-supported key types are registered in so-called "no new key"-mode,
    * which allows for usage of existing keys forbids generation of new key material.
    *
-   * @deprecated
+   * @deprecated use {@link Config#register}
    */
   @Deprecated
   public static void registerStandardKeyTypes() throws GeneralSecurityException {

File: java/src/main/java/com/google/crypto/tink/subtle/AesCmac.java
Patch:
@@ -27,7 +27,9 @@
 import javax.crypto.SecretKey;
 import javax.crypto.spec.SecretKeySpec;
 
-/** An implementation of CMAC following https://tools.ietf.org/html/rfc4493 */
+/**
+ * An implementation of CMAC following <a href="https://tools.ietf.org/html/rfc4493">RFC 4493</a>.
+ */
 @Alpha
 public final class AesCmac implements Mac {
   static final int MIN_TAG_SIZE_IN_BYTES = 10;

File: java/src/main/java/com/google/crypto/tink/subtle/AesSiv.java
Patch:
@@ -28,7 +28,7 @@
 import javax.crypto.spec.SecretKeySpec;
 
 /**
- * AES-SIV per https://tools.ietf.org/html/rfc5297.
+ * AES-SIV, as described in <a href="https://tools.ietf.org/html/rfc5297">RFC 5297</a>.
  *
  * <p>To meet the security requirements of {@link DeterministicAead}, this cipher can only be used
  * with 192-bit or 256-bit keys.

File: java/src/main/java/com/google/crypto/tink/subtle/Base64.java
Patch:
@@ -20,8 +20,9 @@
 import java.nio.charset.Charset;
 
 /**
- * Utilities for encoding and decoding the Base64 representation of binary data. See RFCs <a
- * href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a
+ * Utilities for encoding and decoding the Base64 representation of binary data.
+ *
+ * <p>See RFCs <a href="http://www.ietf.org/rfc/rfc2045.txt">2045</a> and <a
  * href="http://www.ietf.org/rfc/rfc3548.txt">3548</a>.
  *
  * <p>This is a copy of android.util.Base64, with minor modifications to to fix style and ErrorProne

File: java/src/main/java/com/google/crypto/tink/subtle/ChaCha20.java
Patch:
@@ -21,7 +21,7 @@
 import java.security.InvalidKeyException;
 
 /**
- * A stream cipher based on RFC7539 (i.e., uses 96-bit random nonces).
+ * A stream cipher based on RFC7539 (i.e., uses 96-bit random nonces)
  * https://tools.ietf.org/html/rfc7539
  *
  * <p>This cipher is meant to be used to construct an AEAD with Poly1305.

File: java/src/main/java/com/google/crypto/tink/subtle/ChaCha20Poly1305.java
Patch:
@@ -19,8 +19,8 @@
 import java.security.InvalidKeyException;
 
 /**
- * ChaCha20-Poly1305 AEAD construction, compatible with <a
- * href="https://tools.ietf.org/html/rfc7539#section-2.8">RFC 7539, section 2.8</a>.
+ * ChaCha20-Poly1305, as described in <a href="https://tools.ietf.org/html/rfc7539#section-2.8">RFC
+ * 7539, section 2.8</a>.
  */
 public final class ChaCha20Poly1305 extends SnufflePoly1305 {
   public ChaCha20Poly1305(final byte[] key) throws InvalidKeyException {

File: java/src/main/java/com/google/crypto/tink/subtle/EcdsaSignJce.java
Patch:
@@ -21,7 +21,7 @@
 import java.security.Signature;
 import java.security.interfaces.ECPrivateKey;
 
-/** Ecdsa signature's signing in JCE. */
+/** ECDSA signing with JCE. */
 public final class EcdsaSignJce implements PublicKeySign {
   private final ECPrivateKey privateKey;
   private final String signatureAlgorithm;

File: java/src/main/java/com/google/crypto/tink/subtle/EcdsaVerifyJce.java
Patch:
@@ -21,7 +21,7 @@
 import java.security.Signature;
 import java.security.interfaces.ECPublicKey;
 
-/** Ecdsa signature's verification in JCE. */
+/** ECDSA verifying with JCE. */
 public final class EcdsaVerifyJce implements PublicKeyVerify {
   private final ECPublicKey publicKey;
   private final String signatureAlgorithm;

File: java/src/main/java/com/google/crypto/tink/subtle/Ed25519Sign.java
Patch:
@@ -26,12 +26,12 @@
  *
  * <p>Usage:
  *
- * <pre>
+ * <pre>{@code
  * Ed25519Sign.KeyPair keyPair = Ed25519Sign.KeyPair.newKeyPair();
  * // securely store keyPair and share keyPair.getPublicKey()
  * Ed25519Sign signer = new Ed25519Sign(keyPair.getPrivateKey());
  * byte[] signature = signer.sign(message);
- * </pre>
+ * }</pre>
  */
 @Alpha
 public final class Ed25519Sign implements PublicKeySign {

File: java/src/main/java/com/google/crypto/tink/subtle/Hkdf.java
Patch:
@@ -21,8 +21,8 @@
 import javax.crypto.spec.SecretKeySpec;
 
 /**
- * This class implements HMAC-based Extract-and-Expand Key Derivation Function (HKDF)
- * https://tools.ietf.org/html/rfc5869.
+ * This class implements HMAC-based Extract-and-Expand Key Derivation Function (HKDF), as described
+ * in <a href="https://tools.ietf.org/html/rfc5869">RFC 5869</a>.
  */
 public final class Hkdf {
 

File: java/src/main/java/com/google/crypto/tink/subtle/MacJce.java
Patch:
@@ -21,7 +21,7 @@
 import java.security.InvalidAlgorithmParameterException;
 import java.security.NoSuchAlgorithmException;
 
-/** Mac implementations in JCE. */
+/** {@link Mac} implementations in JCE. */
 public final class MacJce implements Mac {
   static final int MIN_TAG_SIZE_IN_BYTES = 10;
   static final int MIN_KEY_SIZE_IN_BYTES = 16;

File: java/src/main/java/com/google/crypto/tink/subtle/NonceBasedStreamingAead.java
Patch:
@@ -26,9 +26,9 @@
 import java.security.GeneralSecurityException;
 
 /**
- * An abstract class for StreamingAead using the nonce based online encryption scheme proposed in
- * "Online Authenticated-Encryption and its Nonce-Reuse Misuse-Resistance" by Hoang, Reyhanitabar,
- * Rogaway and Vizár https://eprint.iacr.org/2015/189.pdf
+ * An abstract class for StreamingAead using the nonce based online encryption scheme proposed in <a
+ * href="https://eprint.iacr.org/2015/189.pdf">Online Authenticated-Encryption and its Nonce-Reuse
+ * Misuse-Resistance</a> by Hoang, Reyhanitabar, Rogaway and Vizár.
  */
 abstract class NonceBasedStreamingAead implements StreamingAead {
 

File: java/src/main/java/com/google/crypto/tink/subtle/Random.java
Patch:
@@ -18,7 +18,7 @@
 
 import java.security.SecureRandom;
 
-/** A simple wrapper of SecureRandom. */
+/** A simple wrapper of {@link SecureRandom}. */
 public final class Random {
   private static final ThreadLocal<SecureRandom> localRandom = new ThreadLocal<SecureRandom>() {
     @Override

File: java/src/main/java/com/google/crypto/tink/subtle/SnufflePoly1305.java
Patch:
@@ -28,8 +28,8 @@
 import javax.crypto.AEADBadTagException;
 
 /**
- * An {@link Aead} construction with a {@link com.google.crypto.tink.subtle.Snuffle} and {@link
- * com.google.crypto.tink.subtle.Poly1305}, following RFC 7539, section 2.8.
+ * An {@link Aead} construction with a {@link Snuffle} and {@link Poly1305}, following RFC 7539,
+ * section 2.8.
  *
  * <p>This implementation produces ciphertext with the following format: {@code nonce ||
  * actual_ciphertext || tag} and only decrypts the same format.

File: java/src/main/java/com/google/crypto/tink/subtle/StreamingAeadDecryptingChannel.java
Patch:
@@ -22,9 +22,7 @@
 import java.security.GeneralSecurityException;
 import java.util.Arrays;
 
-/**
- * An instance of a ReadableByteChannel that returns the plaintext for some ciphertext.
- */
+/** An instance of {@link ReadableByteChannel} that returns the plaintext for some ciphertext. */
 class StreamingAeadDecryptingChannel implements ReadableByteChannel {
   // Each plaintext segment has 16 bytes more of memory than the actual plaintext that it contains.
   // This is a workaround for an incompatibility between Conscrypt and OpenJDK in their

File: java/src/main/java/com/google/crypto/tink/subtle/StreamingAeadDecryptingStream.java
Patch:
@@ -25,7 +25,8 @@
 
 /**
  * An instance of a InputStream that returns the plaintext for some ciphertext.
- * TODO(bleichen): define what the state is after an IOException.
+ *
+ * <p>TODO(bleichen): define what the state is after an IOException.
  */
 class StreamingAeadDecryptingStream extends FilterInputStream {
   // Each plaintext segment has 16 bytes more of memory than the actual plaintext that it contains.

File: java/src/main/java/com/google/crypto/tink/subtle/StreamingAeadEncryptingChannel.java
Patch:
@@ -23,7 +23,7 @@
 import java.security.GeneralSecurityException;
 
 /**
- * An instance of {WritableByteChannel} that encrypts the input using a nonce based online
+ * An instance of {@link WritableByteChannel} that encrypts the input using a nonce based online
  * authentication scheme.
  */
 class StreamingAeadEncryptingChannel implements WritableByteChannel {

File: java/src/main/java/com/google/crypto/tink/subtle/StreamingAeadEncryptingStream.java
Patch:
@@ -23,7 +23,7 @@
 import java.security.GeneralSecurityException;
 
 /**
- * An instance of {FilterOutputStream} that encrypts the input using a nonce based online
+ * An instance of {@link FilterOutputStream} that encrypts the input using a nonce based online
  * authentication scheme.
  */
 class StreamingAeadEncryptingStream extends FilterOutputStream {

File: java/src/main/java/com/google/crypto/tink/subtle/StreamingAeadSeekableDecryptingChannel.java
Patch:
@@ -25,8 +25,8 @@
 import java.util.Arrays;
 
 /**
- * An instance of {code SeekableByteChannel} that allows random access to the plaintext of
- * some ciphertext.
+ * An instance of {@link SeekableByteChannel} that allows random access to the plaintext of some
+ * ciphertext.
  */
 class StreamingAeadSeekableDecryptingChannel implements SeekableByteChannel {
   // Each plaintext segment has 16 bytes more of memory than the actual plaintext that it contains.

File: java/src/main/java/com/google/crypto/tink/subtle/X25519.java
Patch:
@@ -25,8 +25,7 @@
  * also known as the X25519 function.
  *
  * <p>This implementation is based on <a
- * href="https://github.com/agl/curve25519-donna/blob/master/curve25519-donna.c">curve255-donna C
- * implementation</a>.
+ * href="https://github.com/agl/curve25519-donna/blob/master/curve25519-donna.c">curve255-donna</a>.
  *
  * <p>Example Usage:
  *

File: java/src/main/java/com/google/crypto/tink/subtle/AesGcmHkdfStreaming.java
Patch:
@@ -26,7 +26,7 @@
 import javax.crypto.spec.SecretKeySpec;
 
 /**
- * Streaming encryption using AES-GCM with HKDF as key derivation function.
+ * Streaming encryption using {@code AES-GCM} with {@code HKDF} as key derivation function.
  *
  * <p>Each ciphertext uses a new AES-GCM key that is derived from the key derivation key, a randomly
  * chosen salt of the same size as the key and a nonce prefix.
@@ -40,6 +40,8 @@
  * <p>segment_i is the i-th segment of the ciphertext. The size of segment_1 .. segment_{k-1} is
  * ciphertextSegmentSize. segment_0 is shorter, so that segment_0, the header and other information
  * of size firstSegmentOffset align with ciphertextSegmentSize.
+ *
+ * <p>This class does not work on Android KitKat (API level 19) or older.
  */
 public final class AesGcmHkdfStreaming extends NonceBasedStreamingAead {
   // TODO(bleichen): Some things that are not yet decided:

File: java/src/main/java/com/google/crypto/tink/hybrid/HybridKeyTemplates.java
Patch:
@@ -85,7 +85,6 @@ public static KeyTemplate createEciesAeadHkdfKeyTemplate(EllipticCurveType curve
         .setTypeUrl(EciesAeadHkdfPrivateKeyManager.TYPE_URL)
         .setOutputPrefixType(OutputPrefixType.TINK)
         .setValue(format.toByteString())
-        .setOutputPrefixType(OutputPrefixType.TINK)
         .build();
   }
 

File: java/src/test/java/com/google/crypto/tink/subtle/AesEaxJceTest.java
Patch:
@@ -67,7 +67,8 @@ public void setUp() throws Exception {
 
   @Test
   public void testWycheproofVectors() throws Exception {
-    JSONObject json = WycheproofTestUtil.readJson("testdata/wycheproof/aes_eax_test.json");
+    JSONObject json =
+        WycheproofTestUtil.readJson("testdata/wycheproof/aes_eax_test.json");
     int errors = 0;
     int cntSkippedTests = 0;
     JSONArray testGroups = json.getJSONArray("testGroups");

File: java/src/test/java/com/google/crypto/tink/subtle/AesGcmJceTest.java
Patch:
@@ -145,7 +145,8 @@ public void testModifyCiphertext() throws Exception {
 
   @Test
   public void testWycheproofVectors() throws Exception {
-    JSONObject json = WycheproofTestUtil.readJson("testdata/wycheproof/aes_gcm_test.json");
+    JSONObject json =
+        WycheproofTestUtil.readJson("testdata/wycheproof/aes_gcm_test.json");
     int errors = 0;
     int cntSkippedTests = 0;
     JSONArray testGroups = json.getJSONArray("testGroups");

File: java/src/test/java/com/google/crypto/tink/subtle/AesSivTest.java
Patch:
@@ -57,7 +57,8 @@ public void setUp() throws Exception {
 
   @Test
   public void testWycheproofVectors() throws Exception {
-    JSONObject json = WycheproofTestUtil.readJson("testdata/wycheproof/aes_siv_cmac_test.json");
+    JSONObject json =
+        WycheproofTestUtil.readJson("testdata/wycheproof/aes_siv_cmac_test.json");
     JSONArray testGroups = json.getJSONArray("testGroups");
     int cntSkippedTests = 0;
     for (int i = 0; i < testGroups.length(); i++) {

File: java/src/test/java/com/google/crypto/tink/subtle/ChaCha20Poly1305Test.java
Patch:
@@ -254,7 +254,8 @@ public void testRandomNonce() throws Exception {
   @Test
   public void testWycheproofVectors() throws Exception {
     JSONObject json =
-        WycheproofTestUtil.readJson("testdata/wycheproof/chacha20_poly1305_test.json");
+        WycheproofTestUtil.readJson(
+            "testdata/wycheproof/chacha20_poly1305_test.json");
     int errors = 0;
     JSONArray testGroups = json.getJSONArray("testGroups");
     for (int i = 0; i < testGroups.length(); i++) {

File: java/src/test/java/com/google/crypto/tink/subtle/EcdsaVerifyJceTest.java
Patch:
@@ -42,7 +42,8 @@ public class EcdsaVerifyJceTest {
 
   @Test
   public void testWycheproofVectors() throws Exception {
-    JSONObject jsonObj = WycheproofTestUtil.readJson("testdata/wycheproof/ecdsa_test.json");
+    JSONObject jsonObj =
+        WycheproofTestUtil.readJson("testdata/wycheproof/ecdsa_test.json");
 
     int errors = 0;
     int cntSkippedTests = 0;

File: java/src/test/java/com/google/crypto/tink/subtle/Ed25519SignTest.java
Patch:
@@ -131,7 +131,8 @@ private byte[] getMessage(JSONObject testcase) throws Exception {
 
   @Test
   public void testSigningWithWycheproofVectors() throws Exception {
-    JSONObject json = WycheproofTestUtil.readJson("testdata/wycheproof/eddsa_test.json");
+    JSONObject json =
+        WycheproofTestUtil.readJson("testdata/wycheproof/eddsa_test.json");
     int errors = 0;
     JSONArray testGroups = json.getJSONArray("testGroups");
     for (int i = 0; i < testGroups.length(); i++) {

File: java/src/test/java/com/google/crypto/tink/subtle/Ed25519VerifyTest.java
Patch:
@@ -57,7 +57,8 @@ private byte[] getMessage(JSONObject testcase) throws Exception {
 
   @Test
   public void testVerificationWithWycheproofVectors() throws Exception {
-    JSONObject json = WycheproofTestUtil.readJson("testdata/wycheproof/eddsa_test.json");
+    JSONObject json =
+        WycheproofTestUtil.readJson("testdata/wycheproof/eddsa_test.json");
     int errors = 0;
     JSONArray testGroups = json.getJSONArray("testGroups");
     for (int i = 0; i < testGroups.length(); i++) {

File: java/src/test/java/com/google/crypto/tink/subtle/EllipticCurvesTest.java
Patch:
@@ -457,7 +457,8 @@ public void testPointEncode() throws Exception {
 
   @Test
   public void testComputeSharedSecretWithWycheproofTestVectors() throws Exception {
-    JSONObject json = WycheproofTestUtil.readJson("testdata/wycheproof/ecdh_test.json");
+    JSONObject json =
+        WycheproofTestUtil.readJson("testdata/wycheproof/ecdh_test.json");
     int errors = 0;
     JSONArray testGroups = json.getJSONArray("testGroups");
     for (int i = 0; i < testGroups.length(); i++) {

File: java/src/test/java/com/google/crypto/tink/subtle/X25519Test.java
Patch:
@@ -135,7 +135,8 @@ public void testX25519PublicFromPrivateThrowsIllegalArgExWhenPrivateKeyIsGreater
 
   @Test
   public void testComputeSharedSecretWithWycheproofVectors() throws Exception {
-    JSONObject json = WycheproofTestUtil.readJson("testdata/wycheproof/x25519_test.json");
+    JSONObject json =
+        WycheproofTestUtil.readJson("testdata/wycheproof/x25519_test.json");
     int errors = 0;
     int cntSkippedTests = 0;
     JSONArray testGroups = json.getJSONArray("testGroups");

File: java/src/main/java/com/google/crypto/tink/Registry.java
Patch:
@@ -65,7 +65,7 @@
  * Aead aead = AeadFactory.getPrimitive(keysetHandle);
  * }</pre>
  */
-// TODO(przydatek): make the read only methods, e.g., getKeyManager, getCatalogue, etc.
+// TODO(b/74249234): make the read only methods, e.g., getKeyManager, getCatalogue, etc.
 // thread-safe.
 public final class Registry {
   private static final Logger logger = Logger.getLogger(Registry.class.getName());

File: java/src/main/java/com/google/crypto/tink/aead/KmsEnvelopeAead.java
Patch:
@@ -63,7 +63,6 @@ public byte[] encrypt(final byte[] plaintext, final byte[] associatedData)
   public byte[] decrypt(final byte[] ciphertext, final byte[] associatedData)
       throws GeneralSecurityException {
     try {
-      // TODO(thaidn): more efficient parsing?
       ByteBuffer buffer = ByteBuffer.wrap(ciphertext);
       int encryptedDekSize = buffer.getInt();
       if (encryptedDekSize <= 0 || encryptedDekSize > (ciphertext.length - LENGTH_ENCRYPTED_DEK)) {

File: java/src/main/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPrivateKeyManager.java
Patch:
@@ -254,7 +254,7 @@ private void validateKey(JSONObject json) throws JSONException {
   }
 
   private void validate(EciesAeadHkdfPrivateKey keyProto) throws GeneralSecurityException {
-    // TODO(przydatek): add more checks.
+    // TODO(b/74249437): add more checks.
     Validators.validateVersion(keyProto.getVersion(), VERSION);
     HybridUtil.validate(keyProto.getPublicKey().getParams());
   }

File: java/src/main/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPublicKeyManager.java
Patch:
@@ -283,12 +283,12 @@ private void validateKeyFormat(JSONObject json) throws JSONException {
   }
 
   private void validate(EciesAeadHkdfKeyFormat format) throws GeneralSecurityException {
-    // TODO(przydatek): add more checks.
+    // TODO(b/74251423): add more checks.
     HybridUtil.validate(format.getParams());
   }
 
   private void validate(EciesAeadHkdfPublicKey key) throws GeneralSecurityException {
-    // TODO(przydatek): add more checks.
+    // TODO(b/74251423): add more checks.
     Validators.validateVersion(key.getVersion(), VERSION);
     HybridUtil.validate(key.getParams());
   }

File: java/src/main/java/com/google/crypto/tink/signature/SigUtil.java
Patch:
@@ -56,7 +56,7 @@ public static void validateEcdsaParams(EcdsaParams params) throws GeneralSecurit
     switch (encoding) {
       case DER:
         break;
-        // TODO(quannguyen): support other signature encodings.
+        // TODO(b/74249423): support other signature encodings.
       default:
         throw new GeneralSecurityException("unsupported signature encoding");
     }

File: java/src/main/java/com/google/crypto/tink/subtle/AesCtrHmacStreaming.java
Patch:
@@ -328,7 +328,7 @@ public synchronized void encryptSegment(
     }
 
     @Override
-    // TODO(bleichen): So far this is unused.
+    // TODO(b/74250492): So far this is unused.
     public synchronized int getEncryptedSegments() {
       return encryptedSegments;
     }

File: java/src/main/java/com/google/crypto/tink/subtle/StreamingAeadDecryptingChannel.java
Patch:
@@ -148,7 +148,7 @@ private boolean tryReadHeader() throws IOException {
         decrypter.init(header, aad);
         headerRead = true;
       } catch (GeneralSecurityException ex) {
-        // TODO(bleichen): Try to define the state of this.
+        // TODO(b/74249330): Try to define the state of this.
         setUndefinedState();
         throw new IOException(ex);
       }

File: java/src/test/java/com/google/crypto/tink/UtilTest.java
Patch:
@@ -334,5 +334,5 @@ public void testJsonExportOfKeyTemplates() throws Exception {
     assertEquals(templateCount, count);
   }
 
-  // TODO(thaidn): add tests for other functions.
+  // TODO(b/74251398): add tests for other functions.
 }

File: java/src/test/java/com/google/crypto/tink/hybrid/EciesAeadHkdfHybridEncryptTest.java
Patch:
@@ -44,7 +44,7 @@
 /**
  * Unit tests for EciesAeadHkdfHybridEncrypt.
  *
- * <p>TODO(przydatek): Add more tests.
+ * <p>TODO(b/74250701): Add more tests.
  */
 @RunWith(JUnit4.class)
 public class EciesAeadHkdfHybridEncryptTest {

File: java/src/test/java/com/google/crypto/tink/subtle/AesCtrHmacStreamingTest.java
Patch:
@@ -362,7 +362,6 @@ public void testKeyStream() throws Exception {
   /** Encrypt and decrypt a long ciphertext. */
   @Test
   public void testEncryptDecryptLong() throws Exception {
-    // TODO(b/66918385): test with more than 4GB of data.
     long plaintextSize = (1L << 26) + 1234567;
     StreamingTestUtil.testEncryptDecryptLong(createAesCtrHmacStreaming(), plaintextSize);
   }

File: java/src/test/java/com/google/crypto/tink/subtle/Ed25519SignTest.java
Patch:
@@ -33,7 +33,6 @@
 /**
  * Unit tests for {@link Ed25519Sign}.
  *
- * <p>TODO(quannguyen): Use Github Wycheproof's test vectors once it's available (b/66825199).
  */
 @RunWith(JUnit4.class)
 public final class Ed25519SignTest {

File: java/src/test/java/com/google/crypto/tink/subtle/Ed25519VerifyTest.java
Patch:
@@ -30,7 +30,6 @@
 /**
  * Unit tests for {@link Ed25519Verify}.
  *
- * <p>TODO(quannguyen): Use Github Wycheproof's test vectors once it's available (b/66825199).
  */
 @RunWith(JUnit4.class)
 public final class Ed25519VerifyTest {

File: apps/rewardedads/java/src/main/java/com/google/crypto/tink/apps/rewardedads/RewardedAdsVerifier.java
Patch:
@@ -248,7 +248,7 @@ public Map<Integer, ECPublicKey> get() throws GeneralSecurityException {
      * the private keys corresponding to the public keys added. Adding multiple keys is useful for
      * handling key rotation.
      */
-    public Builder addVerifyingPublicKey(int keyId, final String val)
+    public Builder addVerifyingPublicKey(final int keyId, final String val)
         throws GeneralSecurityException {
       this.verifyingPublicKeysProviders.add(
           new VerifyingPublicKeysProvider() {
@@ -270,7 +270,7 @@ public Map<Integer, ECPublicKey> get() throws GeneralSecurityException {
      * this method if you can't use {@link #fetchVerifyingPublicKeysWith} and be aware you will need
      * to handle Google key rotations yourself.
      */
-    public Builder addVerifyingPublicKey(int keyId, final ECPublicKey val)
+    public Builder addVerifyingPublicKey(final int keyId, final ECPublicKey val)
         throws GeneralSecurityException {
       this.verifyingPublicKeysProviders.add(
           new VerifyingPublicKeysProvider() {

File: apps/webpush/src/main/java/com/google/crypto/tink/apps/webpush/WebPushHybridDecrypt.java
Patch:
@@ -38,6 +38,7 @@
  * is formatted according to RFC 8188 section 2, and looks as follows
  *
  * <pre>
+ * // NOLINTNEXTLINE
  * +-----------+----------------+------------------+---------------------------------------------------
  * | salt (16) | recordsize (4) | publickeylen (1) | publickey (publickeylen) | aes128-gcm-ciphertext |
  * +-----------+----------------+------------------+---------------------------------------------------

File: apps/webpush/src/main/java/com/google/crypto/tink/apps/webpush/WebPushHybridEncrypt.java
Patch:
@@ -39,6 +39,7 @@
  * is formatted according to RFC 8188 section 2, and looks as follows
  *
  * <pre>
+ * // NOLINTNEXTLINE
  * +-----------+----------------+------------------+---------------------------------------------------
  * | salt (16) | recordsize (4) | publickeylen (1) | publickey (publickeylen) | aes128-gcm-ciphertext |
  * +-----------+----------------+------------------+---------------------------------------------------

File: tools/testing/java/com/google/crypto/tink/testing/PublicKeyVerifyCli.java
Patch:
@@ -27,7 +27,7 @@
  *   keyset-file:  name of the file with the keyset to be used for verifying
  *   signature-file:  name of the file that contains the signature
  *   message-file:  name of the file that contains message to be verified
- *   output-file:  name of the output file for the the verification result (valid/invalid)
+ *   output-file:  name of the output file for the verification result (valid/invalid)
  */
 public class PublicKeyVerifyCli {
   public static void main(String[] args) throws Exception {

File: apps/webpush/src/test/java/com/google/crypto/tink/apps/webpush/WebPushHybridEncryptTest.java
Patch:
@@ -204,7 +204,6 @@ public void testEncryptDecryptWithVaryingRecordSizes() throws Exception {
   @Test
   public void testNonNullContextInfo() throws Exception {
     KeyPair uaKeyPair = EllipticCurves.generateKeyPair(WebPushConstants.NIST_P256_CURVE_TYPE);
-    ECPrivateKey uaPrivateKey = (ECPrivateKey) uaKeyPair.getPrivate();
     ECPublicKey uaPublicKey = (ECPublicKey) uaKeyPair.getPublic();
     byte[] authSecret = Random.randBytes(16);
 
@@ -217,7 +216,7 @@ public void testNonNullContextInfo() throws Exception {
     byte[] contextInfo = new byte[0];
 
     try {
-      byte[] ciphertext = hybridEncrypt.encrypt(plaintext, contextInfo);
+      byte[] unusedCiphertext = hybridEncrypt.encrypt(plaintext, contextInfo);
       fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException ex) {
       // expected;

File: java/src/main/java/com/google/crypto/tink/aead/AesCtrHmacAeadKeyManager.java
Patch:
@@ -152,7 +152,7 @@ public int getVersion() {
   }
 
   /**
-   * @param jsonKey JSON formated {@code AesCtrHmacAeadKey}-proto
+   * @param jsonKey JSON formatted {@code AesCtrHmacAeadKey}-proto
    * @return {@code AesCtrHmacAeadKey}-proto
    */
   @Override
@@ -175,7 +175,7 @@ public MessageLite jsonToKey(final byte[] jsonKey) throws GeneralSecurityExcepti
   }
 
   /**
-   * @param jsonKeyFormat JSON formated {@code AesCtrHmacAeadKeyFromat}-proto
+   * @param jsonKeyFormat JSON formatted {@code AesCtrHmacAeadKeyFromat}-proto
    * @return {@code AesCtrHmacAeadKeyFormat}-proto
    */
   @Override

File: java/src/main/java/com/google/crypto/tink/aead/AesCtrKeyManager.java
Patch:
@@ -137,7 +137,7 @@ public int getVersion() {
   }
 
   /**
-   * @param jsonKey JSON formated {@code AesCtrKey}-proto
+   * @param jsonKey JSON formatted {@code AesCtrKey}-proto
    * @return {@code AesCtrKey}-proto
    */
   @Override
@@ -157,7 +157,7 @@ public MessageLite jsonToKey(final byte[] jsonKey) throws GeneralSecurityExcepti
   }
 
   /**
-   * @param jsonKeyFormat JSON formated {@code AesCtrKeyFromat}-proto
+   * @param jsonKeyFormat JSON formatted {@code AesCtrKeyFromat}-proto
    * @return {@code AesCtrKeyFormat}-proto
    */
   @Override

File: java/src/main/java/com/google/crypto/tink/aead/AesEaxKeyManager.java
Patch:
@@ -127,7 +127,7 @@ public int getVersion() {
   }
 
   /**
-   * @param jsonKey JSON formated {@code AesEaxKey}-proto
+   * @param jsonKey JSON formatted {@code AesEaxKey}-proto
    * @return {@code AesEaxKey}-proto
    */
   @Override
@@ -147,7 +147,7 @@ public MessageLite jsonToKey(final byte[] jsonKey) throws GeneralSecurityExcepti
   }
 
   /**
-   * @param jsonKeyFormat JSON formated {@code AesEaxKeyFromat}-proto
+   * @param jsonKeyFormat JSON formatted {@code AesEaxKeyFromat}-proto
    * @return {@code AesEaxKeyFormat}-proto
    */
   @Override

File: java/src/main/java/com/google/crypto/tink/aead/AesGcmKeyManager.java
Patch:
@@ -125,7 +125,7 @@ public int getVersion() {
   }
 
   /**
-   * @param jsonKey JSON formated {@code AesGcmKey}-proto
+   * @param jsonKey JSON formatted {@code AesGcmKey}-proto
    * @return {@code AesGcmKey}-proto
    */
   @Override
@@ -144,7 +144,7 @@ public MessageLite jsonToKey(final byte[] jsonKey) throws GeneralSecurityExcepti
   }
 
   /**
-   * @param jsonKeyFormat JSON formated {@code AesGcmKeyFromat}-proto
+   * @param jsonKeyFormat JSON formatted {@code AesGcmKeyFromat}-proto
    * @return {@code AesGcmKeyFormat}-proto
    */
   @Override

File: java/src/main/java/com/google/crypto/tink/aead/ChaCha20Poly1305KeyManager.java
Patch:
@@ -102,7 +102,7 @@ public int getVersion() {
   }
 
   /**
-   * @param jsonKey JSON formated {@code ChaCha20Poly1305Key}-proto
+   * @param jsonKey JSON formatted {@code ChaCha20Poly1305Key}-proto
    * @return {@code ChaCha20Poly1305Key}-proto
    */
   @Override

File: java/src/main/java/com/google/crypto/tink/aead/KmsAeadKeyManager.java
Patch:
@@ -131,7 +131,7 @@ public int getVersion() {
   }
 
   /**
-   * @param jsonKey JSON formated {@code KmsAeadKey}-proto
+   * @param jsonKey JSON formatted {@code KmsAeadKey}-proto
    * @return {@code KmsAeadKey}-proto
    */
   @Override
@@ -149,7 +149,7 @@ public MessageLite jsonToKey(final byte[] jsonKey) throws GeneralSecurityExcepti
   }
 
   /**
-   * @param jsonKeyFormat JSON formated {@code KmsAeadKeyFromat}-proto
+   * @param jsonKeyFormat JSON formatted {@code KmsAeadKeyFromat}-proto
    * @return {@code KmsAeadKeyFormat}-proto
    */
   @Override

File: java/src/main/java/com/google/crypto/tink/aead/KmsEnvelopeAeadKeyManager.java
Patch:
@@ -124,7 +124,7 @@ public int getVersion() {
   }
 
   /**
-   * @param jsonKey JSON formated {@code KmsEnvelopeAeadKey}-proto
+   * @param jsonKey JSON formatted {@code KmsEnvelopeAeadKey}-proto
    * @return {@code KmsEnvelopeAeadKey}-proto
    */
   @Override
@@ -142,7 +142,7 @@ public MessageLite jsonToKey(final byte[] jsonKey) throws GeneralSecurityExcepti
   }
 
   /**
-   * @param jsonKeyFormat JSON formated {@code KmsEnvelopeAeadKeyFromat}-proto
+   * @param jsonKeyFormat JSON formatted {@code KmsEnvelopeAeadKeyFromat}-proto
    * @return {@code KmsEnvelopeAeadKeyFormat}-proto
    */
   @Override

File: java/src/main/java/com/google/crypto/tink/daead/AesSivKeyManager.java
Patch:
@@ -127,7 +127,7 @@ public int getVersion() {
   }
 
   /**
-   * @param jsonKey JSON formated {@code AesSivKey}-proto
+   * @param jsonKey JSON formatted {@code AesSivKey}-proto
    * @return {@code AesSivKey}-proto
    */
   @Override
@@ -146,7 +146,7 @@ public MessageLite jsonToKey(final byte[] jsonKey) throws GeneralSecurityExcepti
   }
 
   /**
-   * @param jsonKeyFormat JSON formated {@code AesSivKeyFromat}-proto
+   * @param jsonKeyFormat JSON formatted {@code AesSivKeyFromat}-proto
    * @return {@code AesSivKeyFormat}-proto
    */
   @Override

File: java/src/main/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPrivateKeyManager.java
Patch:
@@ -180,7 +180,7 @@ public int getVersion() {
   }
 
   /**
-   * @param jsonKey JSON formated {@code EciesAeadHkdfPrivateKey}-proto
+   * @param jsonKey JSON formatted {@code EciesAeadHkdfPrivateKey}-proto
    * @return {@code EciesAeadHkdfPrivateKey}-proto
    */
   @Override
@@ -201,7 +201,7 @@ public MessageLite jsonToKey(final byte[] jsonKey) throws GeneralSecurityExcepti
   }
 
   /**
-   * @param jsonKeyFormat JSON formated {@code EciesAeadHkdfPrivateKeyFromat}-proto
+   * @param jsonKeyFormat JSON formatted {@code EciesAeadHkdfPrivateKeyFromat}-proto
    * @return {@code EciesAeadHkdfKeyFormat}-proto
    */
   @Override

File: java/src/main/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPublicKeyManager.java
Patch:
@@ -127,7 +127,7 @@ public int getVersion() {
   }
 
   /**
-   * @param jsonKey JSON formated {@code EciesAeadHkdfPublicKey}-proto
+   * @param jsonKey JSON formatted {@code EciesAeadHkdfPublicKey}-proto
    * @return {@code EciesAeadHkdfPublicKey}-proto
    */
   @Override
@@ -147,7 +147,7 @@ public MessageLite jsonToKey(final byte[] jsonKey) throws GeneralSecurityExcepti
   }
 
   /**
-   * @param jsonKeyFormat JSON formated {@code EciesAeadHkdfPublicKeyFromat}-proto
+   * @param jsonKeyFormat JSON formatted {@code EciesAeadHkdfPublicKeyFromat}-proto
    * @return {@code EciesAeadHkdfKeyFormat}-proto
    */
   @Override

File: java/src/main/java/com/google/crypto/tink/mac/HmacKeyManager.java
Patch:
@@ -148,7 +148,7 @@ public KeyData newKeyData(ByteString serializedKeyFormat) throws GeneralSecurity
   }
 
   /**
-   * @param jsonKey JSON formated {@code HmacKey}-proto
+   * @param jsonKey JSON formatted {@code HmacKey}-proto
    * @return {@code HmacKey}-proto
    */
   @Override
@@ -168,7 +168,7 @@ public MessageLite jsonToKey(final byte[] jsonKey) throws GeneralSecurityExcepti
   }
 
   /**
-   * @param jsonKeyFormat JSON formated {@code HmacKeyFromat}-proto
+   * @param jsonKeyFormat JSON formatted {@code HmacKeyFromat}-proto
    * @return {@code HmacKeyFormat}-proto
    */
   @Override

File: java/src/main/java/com/google/crypto/tink/signature/EcdsaSignKeyManager.java
Patch:
@@ -169,7 +169,7 @@ public int getVersion() {
   }
 
   /**
-   * @param jsonKey JSON formated {@code EcdsaPrivateKey}-proto
+   * @param jsonKey JSON formatted {@code EcdsaPrivateKey}-proto
    * @return {@code EcdsaPrivateKey}-proto
    */
   @Override
@@ -190,7 +190,7 @@ public MessageLite jsonToKey(final byte[] jsonKey) throws GeneralSecurityExcepti
   }
 
   /**
-   * @param jsonKeyFormat JSON formated {@code EcdsaPrivateKeyFromat}-proto
+   * @param jsonKeyFormat JSON formatted {@code EcdsaPrivateKeyFromat}-proto
    * @return {@code EcdsaKeyFormat}-proto
    */
   @Override

File: java/src/main/java/com/google/crypto/tink/signature/EcdsaVerifyKeyManager.java
Patch:
@@ -115,7 +115,7 @@ public int getVersion() {
   }
 
   /**
-   * @param jsonKey JSON formated {@code EcdsaPublicKey}-proto
+   * @param jsonKey JSON formatted {@code EcdsaPublicKey}-proto
    * @return {@code EcdsaPublicKey}-proto
    */
   @Override
@@ -135,7 +135,7 @@ public MessageLite jsonToKey(final byte[] jsonKey) throws GeneralSecurityExcepti
   }
 
   /**
-   * @param jsonKeyFormat JSON formated {@code EcdsaKeyFromat}-proto
+   * @param jsonKeyFormat JSON formatted {@code EcdsaKeyFromat}-proto
    * @return {@code EcdsaKeyFormat}-proto
    */
   @Override

File: java/src/main/java/com/google/crypto/tink/signature/Ed25519PrivateKeyManager.java
Patch:
@@ -113,7 +113,7 @@ public int getVersion() {
   }
 
   /**
-   * @param jsonKey JSON formated {@code Ed25519PrivateKey}-proto
+   * @param jsonKey JSON formatted {@code Ed25519PrivateKey}-proto
    * @return {@code Ed25519PrivateKey}-proto
    */
   @Override

File: java/src/main/java/com/google/crypto/tink/signature/Ed25519PublicKeyManager.java
Patch:
@@ -105,7 +105,7 @@ public int getVersion() {
   }
 
   /**
-   * @param jsonKey JSON formated {@code Ed25519PublicKey}-proto
+   * @param jsonKey JSON formatted {@code Ed25519PublicKey}-proto
    * @return {@code Ed25519PublicKey}-proto
    */
   @Override

File: java/src/main/java/com/google/crypto/tink/streamingaead/AesCtrHmacStreamingKeyManager.java
Patch:
@@ -144,7 +144,7 @@ public int getVersion() {
   }
 
   /**
-   * @param jsonKey JSON formated {@code AesCtrHmacStreamingKey}-proto
+   * @param jsonKey JSON formatted {@code AesCtrHmacStreamingKey}-proto
    * @return {@code AesCtrHmacStreamingKey}-proto
    */
   @Override
@@ -164,7 +164,7 @@ public MessageLite jsonToKey(final byte[] jsonKey) throws GeneralSecurityExcepti
   }
 
   /**
-   * @param jsonKeyFormat JSON formated {@code AesCtrHmacStreamingKeyFromat}-proto
+   * @param jsonKeyFormat JSON formatted {@code AesCtrHmacStreamingKeyFromat}-proto
    * @return {@code AesCtrHmacStreamingKeyFormat}-proto
    */
   @Override

File: java/src/main/java/com/google/crypto/tink/streamingaead/AesGcmHkdfStreamingKeyManager.java
Patch:
@@ -137,7 +137,7 @@ public int getVersion() {
   }
 
   /**
-   * @param jsonKey JSON formated {@code AesGcmHkdfStreamingKey}-proto
+   * @param jsonKey JSON formatted {@code AesGcmHkdfStreamingKey}-proto
    * @return {@code AesGcmHkdfStreamingKey}-proto
    */
   @Override
@@ -157,7 +157,7 @@ public MessageLite jsonToKey(final byte[] jsonKey) throws GeneralSecurityExcepti
   }
 
   /**
-   * @param jsonKeyFormat JSON formated {@code AesGcmHkdfStreamingKeyFromat}-proto
+   * @param jsonKeyFormat JSON formatted {@code AesGcmHkdfStreamingKeyFromat}-proto
    * @return {@code AesGcmHkdfStreamingKeyFormat}-proto
    */
   @Override

File: java/src/test/java/com/google/crypto/tink/daead/AesSivKeyManagerTest.java
Patch:
@@ -49,6 +49,7 @@ public class AesSivKeyManagerTest {
 
   @BeforeClass
   public static void setUp() throws GeneralSecurityException {
+    DeterministicAeadConfig.init();
     Config.register(DeterministicAeadConfig.TINK_1_1_0);
   }
 

File: java/src/test/java/com/google/crypto/tink/daead/DeterministicAeadFactoryTest.java
Patch:
@@ -47,6 +47,7 @@ public class DeterministicAeadFactoryTest {
 
   @BeforeClass
   public static void setUp() throws Exception {
+    DeterministicAeadConfig.init();
     Config.register(DeterministicAeadConfig.TINK_1_1_0);
   }
 

File: java/src/test/java/com/google/crypto/tink/streamingaead/StreamingAeadFactoryTest.java
Patch:
@@ -42,6 +42,7 @@ public class StreamingAeadFactoryTest {
 
   @BeforeClass
   public static void setUp() throws Exception {
+    StreamingAeadConfig.init();
     Config.register(StreamingAeadConfig.TINK_1_1_0);
   }
 

File: java/src/main/java/com/google/crypto/tink/Registry.java
Patch:
@@ -141,7 +141,8 @@ public static <P> Catalogue<P> getCatalogue(String catalogueName)
       String error = String.format("no catalogue found for %s. ", catalogueName);
       if (catalogueName.toLowerCase().startsWith("tinkaead")) {
         error += "Maybe call AeadConfig.init().";
-      } if (catalogueName.toLowerCase().startsWith("tinkdeterministicaead")) {
+      }
+      if (catalogueName.toLowerCase().startsWith("tinkdeterministicaead")) {
         error += "Maybe call DeterministicAeadConfig.init().";
       } else if (catalogueName.toLowerCase().startsWith("tinkstreamingaead")) {
         error += "Maybe call StreamingAeadConfig.init().";

File: java/src/main/java/com/google/crypto/tink/hybrid/HybridEncryptCatalogue.java
Patch:
@@ -30,8 +30,8 @@ public HybridEncryptCatalogue() {}
    *     {@code minVersion} (if it exists in the catalogue).
    */
   @Override
-  public KeyManager<HybridEncrypt> getKeyManager(String typeUrl, String primitiveName, int minVersion)
-      throws GeneralSecurityException {
+  public KeyManager<HybridEncrypt> getKeyManager(
+      String typeUrl, String primitiveName, int minVersion) throws GeneralSecurityException {
     KeyManager<HybridEncrypt> keyManager;
     switch (primitiveName.toLowerCase()) {
       case "hybridencrypt":

File: java/src/test/java/com/google/crypto/tink/daead/DeterministicAeadConfigTest.java
Patch:
@@ -32,8 +32,8 @@
 import org.junit.runners.MethodSorters;
 
 /**
- * Tests for DeterministicAeadConfig. Using FixedMethodOrder to ensure that aaaTestInitialization runs first, as
- * it tests execution of a static block within DeterministicAeadConfig-class.
+ * Tests for DeterministicAeadConfig. Using FixedMethodOrder to ensure that aaaTestInitialization
+ * runs first, as it tests execution of a static block within DeterministicAeadConfig-class.
  */
 @RunWith(JUnit4.class)
 @FixMethodOrder(MethodSorters.NAME_ASCENDING)

File: java/src/test/java/com/google/crypto/tink/subtle/ChaCha20Poly1305Test.java
Patch:
@@ -195,7 +195,6 @@ public void testWycheproofVectors() throws Exception {
     JSONArray testGroups = json.getJSONArray("testGroups");
     for (int i = 0; i < testGroups.length(); i++) {
       JSONObject group = testGroups.getJSONObject(i);
-      int keySize = group.getInt("keySize");
       JSONArray tests = group.getJSONArray("tests");
       for (int j = 0; j < tests.length(); j++) {
         cntTests++;

File: java/src/test/java/com/google/crypto/tink/subtle/XChaCha20Test.java
Patch:
@@ -18,8 +18,6 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.TestUtil;
@@ -52,7 +50,8 @@ public void testEncryptDecrypt() throws Exception {
                 TestUtil.hexEncode(key),
                 TestUtil.hexEncode(output),
                 TestUtil.hexEncode(actualInput)),
-            expectedInput, actualInput);
+            expectedInput,
+            actualInput);
       }
     }
   }

File: tools/tinkey/src/main/java/com/google/crypto/tink/tinkey/Tinkey.java
Patch:
@@ -26,7 +26,7 @@
  */
 public final class Tinkey {
   public static void main(String[] args) throws Exception {
-    Config.register(TinkConfig.TINK_1_0_0);
+    Config.register(TinkConfig.TINK_1_1_0);
     TinkeyCommands commands = new TinkeyCommands();
     CmdLineParser parser = new CmdLineParser(commands);
 

File: java/src/main/java/com/google/crypto/tink/Registry.java
Patch:
@@ -141,6 +141,8 @@ public static <P> Catalogue<P> getCatalogue(String catalogueName)
       String error = String.format("no catalogue found for %s. ", catalogueName);
       if (catalogueName.toLowerCase().startsWith("tinkaead")) {
         error += "Maybe call AeadConfig.init().";
+      } if (catalogueName.toLowerCase().startsWith("tinkdeterministicaead")) {
+        error += "Maybe call DeterministicAeadConfig.init().";
       } else if (catalogueName.toLowerCase().startsWith("tinkstreamingaead")) {
         error += "Maybe call StreamingAeadConfig.init().";
       } else if (catalogueName.toLowerCase().startsWith("tinkhybriddecrypt")

File: java/src/main/java/com/google/crypto/tink/aead/AesGcmKeyManager.java
Patch:
@@ -43,7 +43,7 @@ class AesGcmKeyManager implements KeyManager<Aead> {
   public Aead getPrimitive(ByteString serializedKey) throws GeneralSecurityException {
     try {
       AesGcmKey keyProto = AesGcmKey.parseFrom(serializedKey);
-      return new AesGcmJce(keyProto.getKeyValue().toByteArray());
+      return getPrimitive(keyProto);
     } catch (InvalidProtocolBufferException e) {
       throw new GeneralSecurityException("expected AesGcmKey proto");
     }

File: java/src/main/java/com/google/crypto/tink/subtle/AesCmac.java
Patch:
@@ -44,7 +44,7 @@ private static Cipher instance() throws GeneralSecurityException {
 
   public AesCmac(final byte[] key, int tagSizeInBytes) throws GeneralSecurityException {
     if (!KEY_SIZES.contains(key.length)) {
-      throw new InvalidKeyException("invalid key size");
+      throw new InvalidKeyException("invalid key size: " + key.length);
     }
     if (tagSizeInBytes < MIN_TAG_SIZE_IN_BYTES) {
       throw new InvalidAlgorithmParameterException(

File: java/src/main/java/com/google/crypto/tink/subtle/AesSiv.java
Patch:
@@ -37,7 +37,7 @@
 public final class AesSiv implements DeterministicAead {
   // Do not support 128-bit keys because it might not provide 128-bit security level in
   // multi-user setting.
-  private static final Collection<Integer> KEY_SIZES = Arrays.asList(24, 32);
+  private static final Collection<Integer> KEY_SIZES = Arrays.asList(48, 64);
   private static final byte[] BLOCK_ZERO = new byte[AesUtil.BLOCK_SIZE];
   private static final byte[] BLOCK_ONE = {
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (byte) 0x01
@@ -51,7 +51,8 @@ public final class AesSiv implements DeterministicAead {
 
   public AesSiv(final byte[] key) throws GeneralSecurityException {
     if (!KEY_SIZES.contains(key.length)) {
-      throw new InvalidKeyException("invalid key size");
+      throw new InvalidKeyException(
+          "invalid key size: " + key.length + "; acceptable values are 48 or 64 bytes");
     }
 
     byte[] k1 = Arrays.copyOfRange(key, 0, key.length / 2);

File: java/src/main/java/com/google/crypto/tink/subtle/AesSiv.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.crypto.tink.subtle;
 
 import com.google.crypto.tink.DeterministicAead;
+import com.google.crypto.tink.annotations.Alpha;
 import java.security.GeneralSecurityException;
 import java.security.InvalidKeyException;
 import java.util.Arrays;
@@ -32,6 +33,7 @@
  * <p>To meet the security requirements of {@link DeterministicAead}, this cipher can only be used
  * with 192-bit or 256-bit keys.
  */
+@Alpha
 public final class AesSiv implements DeterministicAead {
   // Do not support 128-bit keys because it might not provide 128-bit security level in
   // multi-user setting.
@@ -54,7 +56,7 @@ public AesSiv(final byte[] key) throws GeneralSecurityException {
 
     byte[] k1 = Arrays.copyOfRange(key, 0, key.length / 2);
     this.aesCtrKey = Arrays.copyOfRange(key, key.length / 2, key.length);
-    this.cmacForS2V = new AesCmac(k1);
+    this.cmacForS2V = new AesCmac(k1, AesUtil.BLOCK_SIZE);
   }
 
   /**

File: apps/rewardedads/java/src/test/java/com/google/crypto/tink/apps/rewardedads/RewardedAdsVerifierTest.java
Patch:
@@ -184,7 +184,7 @@ public void testShouldFailIfSignedMessageWasChanged() throws Exception {
         signUrl(REWARD_URL, GOOGLE_SIGNING_PRIVATE_KEY_PKCS8_BASE64, KEY_ID).getBytes(UTF_8);
     for (int i = REWARD_HOST_AND_PATH.length(); i < REWARD_URL.length(); i++) {
       byte[] modifiedUrl = Arrays.copyOf(validSignedUrl, validSignedUrl.length);
-      modifiedUrl[i] ^= 0xff;
+      modifiedUrl[i] = (byte) (modifiedUrl[i] ^ 0xff);
       try {
         verifier.verify(new String(modifiedUrl, UTF_8));
         fail("Expected GeneralSecurityException");
@@ -208,7 +208,7 @@ public void testShouldFailIfSignatureWasChanged() throws Exception {
     byte[] validSig = signer.sign(REWARD_URL.getBytes(UTF_8));
     for (int i = 0; i < validSig.length; i++) {
       byte[] modifiedSig = Arrays.copyOf(validSig, validSig.length);
-      modifiedSig[i] ^= 0xff;
+      modifiedSig[i] = (byte) (modifiedSig[i] ^ 0xff);
       String modifiedUrl = buildUrl(REWARD_URL, modifiedSig, KEY_ID);
       try {
         verifier.verify(modifiedUrl);

File: java/src/main/java/com/google/crypto/tink/subtle/Bytes.java
Patch:
@@ -68,8 +68,9 @@ public static byte[] concat(byte[]... chunks) throws GeneralSecurityException {
    *
    * @return a new byte[] of length len.
    */
-  public static final byte[] xor(final byte[] x, int offsetX, final byte[] y, int offsetY, int len) {
-    if (len < 0 || x.length - len < offsetX  || y.length - len < offsetY) {
+  public static final byte[] xor(
+      final byte[] x, int offsetX, final byte[] y, int offsetY, int len) {
+    if (len < 0 || x.length - len < offsetX || y.length - len < offsetY) {
       throw new IllegalArgumentException(
           "That combination of buffers, offsets and length to xor result in out-of-bond accesses.");
     }

File: java/src/test/java/com/google/crypto/tink/KeysetHandleTest.java
Patch:
@@ -76,7 +76,7 @@ public void testToString() throws Exception {
   public void testWriteEncrypted() throws Exception {
     KeysetHandle handle = KeysetHandle.generateNew(MacKeyTemplates.HMAC_SHA256_128BITTAG);
     // Encrypt the keyset with an AeadKey.
-    KeyTemplate masterKeyTemplate = AeadKeyTemplates.AES128_GCM;
+    KeyTemplate masterKeyTemplate = AeadKeyTemplates.AES128_EAX;
     Aead masterKey = Registry.getPrimitive(Registry.newKeyData(masterKeyTemplate));
     ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
     KeysetWriter writer = BinaryKeysetWriter.withOutputStream(outputStream);

File: java/src/test/java/com/google/crypto/tink/hybrid/EciesAeadHkdfHybridEncryptTest.java
Patch:
@@ -97,8 +97,8 @@ public void testBasicMultipleEncrypts() throws Exception {
     testBasicMultipleEncrypts(CurveType.NIST_P384, AeadKeyTemplates.AES128_CTR_HMAC_SHA256);
     testBasicMultipleEncrypts(CurveType.NIST_P521, AeadKeyTemplates.AES128_CTR_HMAC_SHA256);
 
-    testBasicMultipleEncrypts(CurveType.NIST_P256, AeadKeyTemplates.AES128_GCM);
-    testBasicMultipleEncrypts(CurveType.NIST_P384, AeadKeyTemplates.AES128_GCM);
-    testBasicMultipleEncrypts(CurveType.NIST_P521, AeadKeyTemplates.AES128_GCM);
+    testBasicMultipleEncrypts(CurveType.NIST_P256, AeadKeyTemplates.AES128_CTR_HMAC_SHA256);
+    testBasicMultipleEncrypts(CurveType.NIST_P384, AeadKeyTemplates.AES128_CTR_HMAC_SHA256);
+    testBasicMultipleEncrypts(CurveType.NIST_P521, AeadKeyTemplates.AES128_CTR_HMAC_SHA256);
   }
 }

File: java/src/test/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPrivateKeyManagerTest.java
Patch:
@@ -100,7 +100,8 @@ public void testNewKey() throws Exception {
   @Test
   public void testGetPublicKeyData() throws Exception {
     KeysetHandle privateHandle =
-        KeysetHandle.generateNew(HybridKeyTemplates.ECIES_P256_HKDF_HMAC_SHA256_AES128_GCM);
+        KeysetHandle.generateNew(
+            HybridKeyTemplates.ECIES_P256_HKDF_HMAC_SHA256_AES128_CTR_HMAC_SHA256);
     KeyData privateKeyData = TestUtil.getKeyset(privateHandle).getKey(0).getKeyData();
     EciesAeadHkdfPrivateKeyManager privateManager = new EciesAeadHkdfPrivateKeyManager();
     KeyData publicKeyData = privateManager.getPublicKeyData(privateKeyData.getValue());

File: java/src/test/java/com/google/crypto/tink/hybrid/HybridEncryptFactoryTest.java
Patch:
@@ -55,7 +55,7 @@ public void testBasicEncryption() throws Exception {
     EcPointFormat rawPointFormat = EcPointFormat.COMPRESSED;
     KeyTemplate primaryDemKeyTemplate = AeadKeyTemplates.AES128_CTR_HMAC_SHA256;
 
-    KeyTemplate rawDemKeyTemplate = AeadKeyTemplates.AES128_GCM;
+    KeyTemplate rawDemKeyTemplate = AeadKeyTemplates.AES128_CTR_HMAC_SHA256;
     byte[] primarySalt = "some salt".getBytes("UTF-8");
     byte[] rawSalt = "other salt".getBytes("UTF-8");
 

File: java/src/test/java/com/google/crypto/tink/subtle/AeadThreadSafetyTest.java
Patch:
@@ -16,8 +16,6 @@
 
 package com.google.crypto.tink.subtle;
 
-import static org.junit.Assert.assertEquals;
-
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.Mac;
 import com.google.crypto.tink.TestUtil;

File: java/src/main/java/com/google/crypto/tink/JsonKeysetReader.java
Patch:
@@ -16,8 +16,6 @@
 
 package com.google.crypto.tink;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-
 import com.google.crypto.tink.proto.EncryptedKeyset;
 import com.google.crypto.tink.proto.KeyData;
 import com.google.crypto.tink.proto.KeyData.KeyMaterialType;
@@ -34,6 +32,7 @@
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.charset.Charset;
 import java.nio.file.Path;
 import org.json.JSONArray;
 import org.json.JSONException;
@@ -44,6 +43,8 @@
  * JSON format.
  */
 public final class JsonKeysetReader implements KeysetReader {
+  private static final Charset UTF_8 = Charset.forName("UTF-8");
+
   private final InputStream inputStream;
   private final JSONObject json;
   private boolean urlSafeBase64 = false;

File: java/src/main/java/com/google/crypto/tink/JsonKeysetWriter.java
Patch:
@@ -16,8 +16,6 @@
 
 package com.google.crypto.tink;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-
 import com.google.crypto.tink.proto.EncryptedKeyset;
 import com.google.crypto.tink.proto.KeyData;
 import com.google.crypto.tink.proto.Keyset;
@@ -29,6 +27,7 @@
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
+import java.nio.charset.Charset;
 import java.nio.file.Path;
 import org.json.JSONArray;
 import org.json.JSONException;
@@ -39,6 +38,8 @@
  * format.
  */
 public final class JsonKeysetWriter implements KeysetWriter {
+  private static final Charset UTF_8 = Charset.forName("UTF-8");
+
   private final OutputStream outputStream;
 
   private JsonKeysetWriter(OutputStream stream) {

File: java/src/main/java/com/google/crypto/tink/subtle/Base64.java
Patch:
@@ -16,9 +16,8 @@
 
 package com.google.crypto.tink.subtle;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-
 import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
 
 /**
  * Utilities for encoding and decoding the Base64 representation of binary data. See RFCs <a
@@ -29,6 +28,8 @@
  * errors.
  */
 public final class Base64 {
+  private static final Charset UTF_8 = Charset.forName("UTF-8");
+
   /** Default values for encoder/decoder flags. */
   public static final int DEFAULT = 0;
 

File: java/src/test/java/com/google/crypto/tink/JsonKeysetReaderTest.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.crypto.tink;
 
 import static com.google.common.truth.Truth.assertThat;
-import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.aead.AeadKeyTemplates;
@@ -29,6 +28,7 @@
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
+import java.nio.charset.Charset;
 import java.security.GeneralSecurityException;
 import org.json.JSONArray;
 import org.json.JSONObject;
@@ -42,6 +42,8 @@
  */
 @RunWith(JUnit4.class)
 public class JsonKeysetReaderTest {
+  private static final Charset UTF_8 = Charset.forName("UTF-8");
+
   private static final String JSON_KEYSET = "{"
       + "\"primaryKeyId\": 547623039,"
       + "\"key\": [{"

File: java/src/test/java/com/google/crypto/tink/PrimitiveSetTest.java
Patch:
@@ -17,14 +17,14 @@
 package com.google.crypto.tink;
 
 import static com.google.crypto.tink.TestUtil.assertExceptionContains;
-import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.proto.KeyStatusType;
 import com.google.crypto.tink.proto.Keyset.Key;
 import com.google.crypto.tink.proto.OutputPrefixType;
+import java.nio.charset.Charset;
 import java.security.GeneralSecurityException;
 import java.util.List;
 import org.junit.Test;
@@ -34,6 +34,8 @@
 /** Tests for PrimitiveSet. */
 @RunWith(JUnit4.class)
 public class PrimitiveSetTest {
+  private static final Charset UTF_8 = Charset.forName("UTF-8");
+
   private static class DummyMac1 implements Mac {
     public DummyMac1() {}
 

File: java/src/test/java/com/google/crypto/tink/WycheproofTestUtil.java
Patch:
@@ -16,17 +16,19 @@
 
 package com.google.crypto.tink;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.subtle.EllipticCurves;
 import java.io.File;
 import java.io.FileInputStream;
+import java.nio.charset.Charset;
 import java.security.NoSuchAlgorithmException;
 import org.json.JSONObject;
 
 /** Wycheproof Test helpers. */
 public class WycheproofTestUtil {
+  private static final Charset UTF_8 = Charset.forName("UTF-8");
+
   /**
    * Returns the algorithm name for a digital signature algorithm with a given message digest. The
    * algorithm names used in JCA are a bit inconsequential. E.g. a dash is necessary for message

File: java/src/main/java/com/google/crypto/tink/subtle/Random.java
Patch:
@@ -29,7 +29,7 @@ public static byte[] randBytes(int size) {
     return rand;
   }
 
-  public static final int rand(int max) {
+  public static final int randInt(int max) {
     return secureRandom.nextInt(max);
   }
 }

File: java/src/test/java/com/google/crypto/tink/subtle/AesCmacTest.java
Patch:
@@ -75,7 +75,7 @@ public void randomMacThenCheck() throws GeneralSecurityException {
     for (int triesKey = 0; triesKey < 100; triesKey++) {
       AesCmac c = new AesCmac(Random.randBytes(16));
       for (int triesPlaintext = 0; triesPlaintext < 100; triesPlaintext++) {
-        byte[] plaintext = Random.randBytes(Random.rand(1024) + 1);
+        byte[] plaintext = Random.randBytes(Random.randInt(1024) + 1);
         c.verifyMac(c.computeMac(plaintext), plaintext);
       }
     }
@@ -86,7 +86,7 @@ public void randomMacThenFlipShouldNotCheck() throws GeneralSecurityException {
     for (int triesKey = 0; triesKey < 100; triesKey++) {
       AesCmac c = new AesCmac(Random.randBytes(16));
       for (int triesPlaintext = 0; triesPlaintext < 100; triesPlaintext++) {
-        byte[] plaintext = Random.randBytes(Random.rand(1024) + 1);
+        byte[] plaintext = Random.randBytes(Random.randInt(1024) + 1);
         byte[] initialMac = c.computeMac(plaintext);
 
         // Modify every bit of the tag.

File: java/src/test/java/com/google/crypto/tink/subtle/SnuffleCipherPoly1305Test.java
Patch:
@@ -29,6 +29,7 @@
 import java.nio.ByteBuffer;
 import java.nio.charset.StandardCharsets;
 import java.security.GeneralSecurityException;
+import java.security.InvalidKeyException;
 import java.util.Arrays;
 import org.json.JSONArray;
 import org.json.JSONObject;
@@ -272,7 +273,8 @@ protected SnuffleCipherPoly1305 createInstance(byte[] key) {
       return SnuffleCipherPoly1305.constructXSalsa20Poly1305Nacl(key);
     }
 
-    private static byte[] sharedKey(byte[] privateKey, byte[] publicKey) {
+    private static byte[] sharedKey(byte[] privateKey, byte[] publicKey)
+        throws InvalidKeyException {
       return X25519.computeSharedSecret(privateKey, publicKey);
     }
 

File: java/src/main/java/com/google/crypto/tink/subtle/Base64.java
Patch:
@@ -94,7 +94,7 @@ public static byte[] decode(String input) {
 
   /** Decodes a url-safe base64 string to a byte array. */
   public static byte[] urlSafeDecode(String input) {
-    return decode(input, DEFAULT | NO_WRAP | URL_SAFE);
+    return decode(input, DEFAULT | NO_PADDING | NO_WRAP | URL_SAFE);
   }
 
   /**
@@ -428,7 +428,7 @@ public static String encode(final byte[] input) {
 
   /** Url-safe base64 encodes a byte array to a string. */
   public static String urlSafeEncode(final byte[] input) {
-    return encodeToString(input, DEFAULT | NO_WRAP | URL_SAFE);
+    return encodeToString(input, DEFAULT | NO_PADDING | NO_WRAP | URL_SAFE);
   }
 
   /**

File: java/src/main/java/com/google/crypto/tink/subtle/KeysDownloader.java
Patch:
@@ -51,7 +51,7 @@
  */
 public class KeysDownloader {
   /** Default HTTP transport used by this class. */
-  public static final NetHttpTransport DEFAULT_HTTP_TRANSPORT =
+  private static final NetHttpTransport DEFAULT_HTTP_TRANSPORT =
       new NetHttpTransport.Builder().build();
 
   private static final Executor DEFAULT_BACKGROUND_EXECUTOR = Executors.newCachedThreadPool();
@@ -77,7 +77,7 @@ public class KeysDownloader {
   @GuardedBy("instanceStateLock")
   private long cacheExpirationDurationInMillis;
 
-  KeysDownloader(Executor backgroundExecutor, HttpTransport httpTransport, String url) {
+  public KeysDownloader(Executor backgroundExecutor, HttpTransport httpTransport, String url) {
     validate(url);
     this.backgroundExecutor = backgroundExecutor;
     this.httpTransport = httpTransport;

File: java/src/main/java/com/google/crypto/tink/Registry.java
Patch:
@@ -136,6 +136,8 @@ public static Catalogue getCatalogue(String catalogueName) throws GeneralSecurit
       String error = String.format("no catalogue found for %s. ", catalogueName);
       if (catalogueName.toLowerCase().startsWith("tinkaead")) {
         error += "Maybe call AeadConfig.init().";
+      } else if (catalogueName.toLowerCase().startsWith("tinkstreamingaead")) {
+        error += "Maybe call StreamingAeadConfig.init().";
       } else if (catalogueName.toLowerCase().startsWith("tinkhybrid")) {
         error += "Maybe call HybridConfig.init().";
       } else if (catalogueName.toLowerCase().startsWith("tinkmac")) {

File: java/src/test/java/com/google/crypto/tink/StreamingTestUtil.java
Patch:
@@ -846,7 +846,7 @@ public static void testFileEncrytionWithStream(StreamingAead ags, File tmpFile)
       }
       if (read != (pt[decryptedSize] & 0xff)) {
         fail(
-            "Incorrect decryption at postion "
+            "Incorrect decryption at position "
                 + decryptedSize
                 + " expected: "
                 + pt[decryptedSize]

File: java/src/test/java/com/google/crypto/tink/subtle/AesGcmHkdfStreamingTest.java
Patch:
@@ -22,7 +22,6 @@
 import com.google.crypto.tink.StreamingTestUtil;
 import com.google.crypto.tink.StreamingTestUtil.ByteBufferChannel;
 import com.google.crypto.tink.TestUtil;
-import java.io.File;
 import java.nio.ByteBuffer;
 import java.nio.channels.WritableByteChannel;
 import org.junit.Rule;
@@ -296,7 +295,6 @@ public void testFileEncrytion() throws Exception {
   /** Encrypt some plaintext to a file using FileOutputStream, then decrypt from the file */
   @Test
   public void testFileEncrytionWithStream() throws Exception {
-    StreamingTestUtil.testFileEncrytionWithStream(createAesGcmStreaming(),
-        tmpFolder.newFile());
+    StreamingTestUtil.testFileEncrytionWithStream(createAesGcmStreaming(), tmpFolder.newFile());
   }
 }

File: examples/helloworld/android/app/src/main/java/com/helloworld/MainActivity.java
Patch:
@@ -26,6 +26,9 @@
 import java.io.UnsupportedEncodingException;
 import java.security.GeneralSecurityException;
 
+/**
+ * This activity allows users to encrypt and decrypt a string.
+ */
 public class MainActivity extends AppCompatActivity {
   private static final byte[] EMPTY_ASSOCIATED_DATA = new byte[0];
 

File: examples/helloworld/java/src/main/java/com/helloworld/HelloWorld.java
Patch:
@@ -16,9 +16,9 @@
 
 import com.google.crypto.tink.Config;
 import com.google.crypto.tink.aead.AeadConfig;
+import java.security.GeneralSecurityException;
 import org.kohsuke.args4j.CmdLineException;
 import org.kohsuke.args4j.CmdLineParser;
-import java.security.GeneralSecurityException;
 
 /**
  * A command-line tool that can encrypt and decrypt small files with AES128-GCM.

File: java/src/main/java/com/google/crypto/tink/subtle/Ed25519.java
Patch:
@@ -700,7 +700,7 @@ private static boolean isNonZeroVarTime(long[] in) {
     System.arraycopy(in, 0, inCopy, 0, in.length);
     Field25519.reduceCoefficients(inCopy);
     byte[] bytes = Field25519.contract(inCopy);
-    for (byte b: bytes) {
+    for (byte b : bytes) {
       if (b != 0) {
         return true;
       }

File: java/src/test/java/com/google/crypto/tink/JsonKeysetReaderTest.java
Patch:
@@ -24,7 +24,6 @@
 import com.google.crypto.tink.config.TinkConfig;
 import com.google.crypto.tink.mac.MacFactory;
 import com.google.crypto.tink.mac.MacKeyTemplates;
-import com.google.crypto.tink.proto.EncryptedKeyset;
 import com.google.crypto.tink.proto.KeyTemplate;
 import com.google.crypto.tink.subtle.Random;
 import java.io.ByteArrayInputStream;

File: java/src/test/java/com/google/crypto/tink/JsonKeysetWriterTest.java
Patch:
@@ -17,15 +17,12 @@
 package com.google.crypto.tink;
 
 import static com.google.common.truth.Truth.assertThat;
-import static java.nio.charset.StandardCharsets.UTF_8;
 
 import com.google.crypto.tink.aead.AeadKeyTemplates;
 import com.google.crypto.tink.config.TinkConfig;
 import com.google.crypto.tink.mac.MacFactory;
 import com.google.crypto.tink.mac.MacKeyTemplates;
-import com.google.crypto.tink.proto.EncryptedKeyset;
 import com.google.crypto.tink.proto.KeyTemplate;
-import com.google.crypto.tink.proto.Keyset;
 import com.google.crypto.tink.subtle.Random;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;

File: java/src/test/java/com/google/crypto/tink/subtle/AesCtrHmacStreamingTest.java
Patch:
@@ -999,7 +999,7 @@ public void testFileEncryptionWithStream() throws Exception {
       }
       if (read != (pt[decryptedSize] & 0xff)) {
         fail(
-            "Incorrect decryption at postion "
+            "Incorrect decryption at position "
                 + decryptedSize
                 + " expected: "
                 + pt[decryptedSize]

File: java/src/test/java/com/google/crypto/tink/subtle/AesGcmJceTest.java
Patch:
@@ -22,7 +22,6 @@
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.TestUtil;
-import com.google.crypto.tink.subtle.Hex;
 import java.security.GeneralSecurityException;
 import java.util.Arrays;
 import java.util.HashSet;

File: java/src/test/java/com/google/crypto/tink/subtle/Ed25519SignTest.java
Patch:
@@ -5,7 +5,6 @@
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.TestUtil;
-import com.google.crypto.tink.subtle.Hex;
 import java.security.GeneralSecurityException;
 import java.util.TreeSet;
 import org.json.JSONArray;

File: java/src/test/java/com/google/crypto/tink/subtle/Ed25519VerifyTest.java
Patch:
@@ -4,7 +4,6 @@
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.TestUtil;
-import com.google.crypto.tink.subtle.Hex;
 import java.security.GeneralSecurityException;
 import org.json.JSONArray;
 import org.json.JSONObject;
@@ -76,7 +75,7 @@ public void testVerificationWithWycheproofVectors() throws Exception {
     assertEquals(numTests, cntTests);
   }
 
-  private void checkAlgAndVersion(JSONObject jsonObj) {
+  private void checkAlgAndVersion(JSONObject jsonObj) throws Exception {
     final String expectedAlgorithm = "EDDSA";
     String algorithm = jsonObj.getString("algorithm");
     if (!expectedAlgorithm.equals(algorithm)) {

File: java/src/test/java/com/google/crypto/tink/subtle/RewindableReadableByteChannelTest.java
Patch:
@@ -94,7 +94,7 @@ public void testSingleReadsOfVariousLengths() throws Exception {
     }
     ByteBuffer buffer6 = ByteBuffer.allocate(42);
     try {
-      int readCount = rewindableChannel.read(buffer6);
+      int unused = rewindableChannel.read(buffer6);
       fail("Should have thrown exception, as cannot read after closing.");
     } catch (ClosedChannelException expected) {
     }
@@ -218,7 +218,7 @@ public void testExceptions() throws Exception {
 
     ByteBuffer buffer = ByteBuffer.allocate(42);
     try {
-      int readCount = rewindableChannel.read(buffer);
+      int unused = rewindableChannel.read(buffer);
       fail("Should have thrown exception, as cannot read after closing.");
     } catch (ClosedChannelException expected) {
     }

File: java/src/test/java/com/google/crypto/tink/signature/Ed25519PublicKeyManagerTest.java
Patch:
@@ -77,8 +77,8 @@ public void testModifiedSignature() throws Exception {
     copySig[copySig.length - 1] = (byte) (copySig[copySig.length - 1] ^ 0xff);
     try {
       verifier.verify(copySig, message);
-      fail("Expected IllegalArgumentException");
-    } catch (IllegalArgumentException e) {
+      fail("Expected GeneralSecurityException");
+    } catch (GeneralSecurityException e) {
       assertExceptionContains(e, "Given signature's 3 most significant bits must be 0.");
     }
     // Flip other bytes.

File: java/src/main/java/com/google/crypto/tink/subtle/StreamingAeadEncryptingChannel.java
Patch:
@@ -115,7 +115,7 @@ public synchronized void close() throws IOException {
   }
 
   @Override
-  public boolean isOpen() {
+  public synchronized boolean isOpen() {
     return open;
   }
 }

File: java/src/main/java/com/google/crypto/tink/subtle/StreamingAeadSeekableDecryptingChannel.java
Patch:
@@ -138,7 +138,7 @@ public String toString() {
    * The position is relative to the plaintext.
    */
   @Override
-  public long position() {
+  public synchronized long position() {
     return plaintextPosition;
   }
 
@@ -148,7 +148,7 @@ public long position() {
    * A later attempt to read byte will throw an IOException.
    */
   @Override
-  public SeekableByteChannel position(long newPosition) {
+  public synchronized SeekableByteChannel position(long newPosition) {
     plaintextPosition = newPosition;
     return this;
   }
@@ -308,7 +308,7 @@ public long size() {
     return plaintextSize;
   }
 
-  public long verifiedSize() throws IOException {
+  public synchronized long verifiedSize() throws IOException {
     if (tryLoadSegment(numberOfSegments - 1)) {
       return plaintextSize;
     } else {

File: java/src/main/java/com/google/crypto/tink/subtle/Ed25519.java
Patch:
@@ -1501,8 +1501,9 @@ static byte[] sign(final byte[] message, final byte[] publicKey, final byte[] ha
     digest.update(message);
     byte[] hram = digest.digest();
     reduce(hram);
-    mulAdd(hashedPrivateKey, hram, hashedPrivateKey, r);
-    return Bytes.concat(rB, Arrays.copyOfRange(hashedPrivateKey, 0, FIELD_LEN));
+    byte[] s = new byte[FIELD_LEN];
+    mulAdd(s, hram, hashedPrivateKey, r);
+    return Bytes.concat(rB, s);
   }
 
   /**

File: java/src/main/java/com/google/crypto/tink/annotations/Alpha.java
Patch:
@@ -43,4 +43,4 @@
   ElementType.TYPE
 })
 @Documented
-public @interface Alpha {}
\ No newline at end of file
+public @interface Alpha {}

File: java/src/main/java/com/google/crypto/tink/subtle/Hkdf.java
Patch:
@@ -82,7 +82,7 @@ public static byte[] computeHkdf(
   /**
    * Computes symmetric key for ECIES with HKDF from the provided parameters.
    *
-   * @param ephemeralPublicKeyBytes the encoded ephemeral public key, i.e. the KEM part of the the
+   * @param ephemeralPublicKeyBytes the encoded ephemeral public key, i.e. the KEM part of the
    *     hybrid encryption. In some versions of ECIES (e.g. IEEE P1363a) this argument is optional.
    *     Shoup strongly prefers the inclusion of this argument in
    *     http://eprint.iacr.org/2001/112.pdf (see discussion of the value C0 in Section 15.6, and

File: java/src/test/java/com/google/crypto/tink/subtle/AesGcmJceTest.java
Patch:
@@ -249,7 +249,6 @@ public void testWycheproofVectors() throws Exception {
     JSONArray testGroups = jsonObj.getJSONArray("testGroups");
     for (int i = 0; i < testGroups.length(); i++) {
       JSONObject group = testGroups.getJSONObject(i);
-      int tagSize = group.getInt("tagSize");
       int keySize = group.getInt("keySize");
       JSONArray tests = group.getJSONArray("tests");
       if (!Arrays.asList(keySizeInBytes).contains(keySize / 8)) {

File: apps/paymentmethodtoken/src/main/java/com/google/crypto/tink/apps/paymentmethodtoken/GooglePaymentsPublicKeysManager.java
Patch:
@@ -114,9 +114,9 @@ public class GooglePaymentsPublicKeysManager {
   /**
    * Returns a string containing a JSON with the Google public signing keys.
    *
-   * <p>You can pass this value to {@link PaymentMethodTokenRecipient.Builder#senderVerifyingKeys}.
+   * <p>Meant to be called by {@link PaymentMethodTokenRecipient}.
    */
-  public String getTrustedSigningKeysJson() throws IOException {
+  String getTrustedSigningKeysJson() throws IOException {
     synchronized (instanceStateLock) {
       // Checking and using the cache if required.
       if (hasNonExpiredKeyCached()) {

File: java/src/test/java/com/google/crypto/tink/aead/KmsAeadKeyManagerTest.java
Patch:
@@ -21,7 +21,7 @@
 import com.google.crypto.tink.KmsClient;
 import com.google.crypto.tink.KmsClients;
 import com.google.crypto.tink.TestUtil;
-import com.google.crypto.tink.integration.GcpKmsClient;
+import com.google.crypto.tink.integration.gcpkms.GcpKmsClient;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: java/src/test/java/com/google/crypto/tink/aead/KmsEnvelopeAeadKeyManagerTest.java
Patch:
@@ -26,7 +26,7 @@
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.KmsClients;
 import com.google.crypto.tink.TestUtil;
-import com.google.crypto.tink.integration.GcpKmsClient;
+import com.google.crypto.tink.integration.gcpkms.GcpKmsClient;
 import com.google.crypto.tink.proto.KeyTemplate;
 import com.google.crypto.tink.subtle.Random;
 import java.nio.ByteBuffer;

File: java/src/test/java/com/google/crypto/tink/integration/awskms/AwsKmsAeadTest.java
Patch:
@@ -14,7 +14,7 @@
 //
 ////////////////////////////////////////////////////////////////////////////////
 
-package com.google.crypto.tink.integration;
+package com.google.crypto.tink.integration.awskms;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.fail;

File: apps/paymentmethodtoken/src/main/java/com/google/crypto/tink/apps/paymentmethodtoken/PaymentMethodTokenConstants.java
Patch:
@@ -14,15 +14,15 @@
 //
 ////////////////////////////////////////////////////////////////////////////////
 
-package com.google.payments;
+package com.google.crypto.tink.apps.paymentmethodtoken;
 
 import com.google.crypto.tink.subtle.EllipticCurves;
 import java.nio.charset.StandardCharsets;
 
 /**
  * Various constants.
  */
-public final class PaymentMethodTokenConstants {
+class PaymentMethodTokenConstants {
   public static final String GOOGLE_SENDER_ID = "Google";
   public static final String HMAC_SHA256_ALGO = "HmacSha256";
   public static final byte[] HKDF_EMPTY_SALT = new byte[0];

File: apps/paymentmethodtoken/src/main/java/com/google/crypto/tink/apps/paymentmethodtoken/PaymentMethodTokenUtil.java
Patch:
@@ -14,7 +14,7 @@
 //
 ////////////////////////////////////////////////////////////////////////////////
 
-package com.google.payments;
+package com.google.crypto.tink.apps.paymentmethodtoken;
 
 import com.google.crypto.tink.subtle.Base64;
 import com.google.crypto.tink.subtle.Bytes;
@@ -37,7 +37,7 @@
 /**
  * Various helpers.
  */
-public final class PaymentMethodTokenUtil {
+class PaymentMethodTokenUtil {
 
   public static ECPublicKey rawUncompressedEcPublicKey(String rawUncompressedPublicKey)
       throws GeneralSecurityException {

File: apps/paymentmethodtoken/src/test/java/com/google/crypto/tink/apps/paymentmethodtoken/PaymentMethodTokenHybridDecryptTest.java
Patch:
@@ -14,7 +14,7 @@
 //
 ////////////////////////////////////////////////////////////////////////////////
 
-package com.google.payments;
+package com.google.crypto.tink.apps.paymentmethodtoken;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.fail;

File: apps/paymentmethodtoken/src/test/java/com/google/crypto/tink/apps/paymentmethodtoken/PaymentMethodTokenHybridEncryptTest.java
Patch:
@@ -14,7 +14,7 @@
 //
 ////////////////////////////////////////////////////////////////////////////////
 
-package com.google.payments;
+package com.google.crypto.tink.apps.paymentmethodtoken;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;

File: apps/paymentmethodtoken/src/test/java/com/google/crypto/tink/apps/paymentmethodtoken/PaymentMethodTokenRecipientTest.java
Patch:
@@ -14,7 +14,7 @@
 //
 ////////////////////////////////////////////////////////////////////////////////
 
-package com.google.payments;
+package com.google.crypto.tink.apps.paymentmethodtoken;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;

File: apps/paymentmethodtoken/src/test/java/com/google/crypto/tink/apps/paymentmethodtoken/PaymentMethodTokenSenderTest.java
Patch:
@@ -14,7 +14,7 @@
 //
 ////////////////////////////////////////////////////////////////////////////////
 
-package com.google.payments;
+package com.google.crypto.tink.apps.paymentmethodtoken;
 
 import static org.junit.Assert.assertEquals;
 

File: java/src/main/java/com/google/crypto/tink/Aead.java
Patch:
@@ -22,7 +22,7 @@
  * The interface for Authenticated Encryption with Associated Data.
  * Implementations of this interface are secure against adaptive chosen ciphertext attacks.
  * Encryption with associated data ensures authenticity and integrity of that data,
- * but not its secrecy. (see RFC 5116, https://tools.ietf.org/html/rfc5116)
+ * but not its secrecy. (see <a href="https://tools.ietf.org/html/rfc5116">RFC 5116</a>)
  */
 public interface Aead {
   /**

File: java/src/main/java/com/google/crypto/tink/BinaryKeysetReader.java
Patch:
@@ -25,8 +25,9 @@
 import java.io.InputStream;
 
 /**
- * A {@link KeysetReader} that can read cleartext or encrypted keysets in binary wire format,
- * see {@link https://developers.google.com/protocol-buffers/docs/encoding}.
+ * A {@link KeysetReader} that can read from some source cleartext or encrypted keysets in
+ * <a href="https://developers.google.com/protocol-buffers/docs/encoding">
+ * proto binary wire format</a>.
  */
 public final class BinaryKeysetReader implements KeysetReader {
   private final InputStream inputStream;

File: java/src/main/java/com/google/crypto/tink/BinaryKeysetWriter.java
Patch:
@@ -24,8 +24,9 @@
 import java.io.OutputStream;
 
 /**
- * A {@link KeysetWriter} that can write keysets in binary wire format,
- * see {@link https://developers.google.com/protocol-buffers/docs/encoding}.
+ * A {@link KeysetWriter} that can write to some source cleartext or encrypted keysets in
+ * <a href="https://developers.google.com/protocol-buffers/docs/encoding">
+ * proto binary wire format</a>.
  */
 public final class BinaryKeysetWriter implements KeysetWriter {
   private final OutputStream outputStream;

File: java/src/main/java/com/google/crypto/tink/JsonKeysetReader.java
Patch:
@@ -39,7 +39,8 @@
 import org.json.JSONObject;
 
 /**
- * A {@link KeysetReader} that can read cleartext or encrypted keysets in proto JSON format.
+ * A {@link KeysetReader} that can read from source source cleartext or encrypted keysets in proto
+ * JSON format.
  */
 public final class JsonKeysetReader implements KeysetReader {
   private final JSONObject json;

File: java/src/main/java/com/google/crypto/tink/JsonKeysetWriter.java
Patch:
@@ -34,7 +34,8 @@
 import org.json.JSONObject;
 
 /**
- * A {@link KeysetWriter} that can write keysets in proto JSON format.
+ * A {@link KeysetWriter} that can write to some source cleartext or encrypted keysets in proto
+ * JSON format.
  */
 public final class JsonKeysetWriter implements KeysetWriter {
   private final OutputStream outputStream;

File: java/src/main/java/com/google/crypto/tink/NoSecretKeysetHandle.java
Patch:
@@ -23,9 +23,7 @@
 import java.security.GeneralSecurityException;
 
 /**
- * Creates keyset handles from keysets that don't contain secret key material. This keyset handle
- * therefore is not restricted, and can be used to load keysets containing only public or remote
- * keys.
+ * Static methods for reading cleartext keysets that don't contain any secret key material.
  */
 public final class NoSecretKeysetHandle {
   /**

File: java/src/main/java/com/google/crypto/tink/aead/AeadConfig.java
Patch:
@@ -78,10 +78,10 @@ public static void init() throws GeneralSecurityException {
    * Registers with the {@code Registry} all Aead key types released with the latest version
    * of Tink.
    *
-   * Deprecated-yet-still-supported key types are registered in so-called "no new key"-mode,
+   * <p>Deprecated-yet-still-supported key types are registered in so-called "no new key"-mode,
    * which allows for usage of existing keys forbids generation of new key material.
    *
-   * @deprecated
+   * @deprecated use {@link Config#register}
    */
   @Deprecated
   public static void registerStandardKeyTypes() throws GeneralSecurityException {

File: java/src/main/java/com/google/crypto/tink/mac/MacConfig.java
Patch:
@@ -62,7 +62,7 @@ public static void init() throws GeneralSecurityException {
    * Registers with the {@code Registry} all Mac key types released with the latest
    * version of Tink.
    *
-   * Deprecated-yet-still-supported key types are registered in so-called "no new key"-mode,
+   * <p>Deprecated-yet-still-supported key types are registered in so-called "no new key"-mode,
    * which allows for usage of existing keys forbids generation of new key material.
    *
    * @deprecated

File: java/src/test/java/com/google/crypto/tink/RegistryTest.java
Patch:
@@ -446,7 +446,7 @@ public KeyManager getKeyManager(String typeUrl, String primitiveName, int minVer
 
   @Test
   public void testAddCatalogue_MultiThreads_shouldWork() throws Exception {
-    boolean[] threwException = new boolean[3];
+    final boolean[] threwException = new boolean[3];
     Thread thread1 = new Thread(
         new Runnable() {
           @Override

File: java/src/main/java/com/google/crypto/tink/aead/AeadFactory.java
Patch:
@@ -32,11 +32,11 @@
  * AeadFactory allows obtaining a primitive from a {@code KeysetHandle}.
  *
  * AeadFactory gets primitives from the {@code Registry}, which can be initialized
- * via convenience methods from {@code AeadConfig}. Here is an example how one can obtain
- * and use a Aead primitive:
+ * via convenience methods from {@code Config} and {@code AeadConfig}. Here is an example
+ * how one can obtain and use a Aead primitive:
  * <pre>   {@code
  *   KeysetHandle keysetHandle = ...;
- *   AeadConfig.registerStandardKeyTypes();
+ *   Config.register(AeadConfig.TINK_1_0_0);
  *   Aead aead = AeadFactory.getPrimitive(keysetHandle);
  *   byte[] plaintext = ...;
  *   byte[] aad = ...;

File: java/src/main/java/com/google/crypto/tink/aead/AeadKeyTemplates.java
Patch:
@@ -34,7 +34,7 @@
  * to generate new {@code Keyset} with {@code KeysetHandle}. To generate a new keyset
  * that contains a single {@code AesGcmKey}, one can do:
  * <pre>
- *   AeadConfig.registerStandardKeyTypes();
+ *   Config.register(AeadConfig.TINK_1_0_0);
  *   KeysetHandle handle = KeysetHandle.generateNew(AeadKeyTemplates.AES128_GCM);
  *   Aead aead = AeadFactory.getPrimitive(handle);
  * </pre>

File: java/src/main/java/com/google/crypto/tink/hybrid/HybridDecryptFactory.java
Patch:
@@ -30,11 +30,11 @@
  * HybridDecryptFactory allows obtaining a HybridDecrypt primitive from a {@code KeysetHandle}.
  *
  * HybridDecryptFactory gets primitives from the {@code Registry}, which can be initialized
- * via convenience methods from {@code HybridDecryptConfig}. Here is an example how one can obtain
- * and use a HybridDecrypt primitive:
+ * via convenience methods from {@code Config} and {@code HybridConfig}. Here is an example how
+ * one can obtain and use a HybridDecrypt primitive:
  * <pre>   {@code
  *   KeysetHandle keysetHandle = ...;
- *   HybridDecryptConfig.registerStandardKeyTypes();
+ *   Config.register(HybridConfig.TINK_1_0_0);
  *   HybridDecrypt hybridDecrypt = HybridDecryptFactory.getPrimitive(keysetHandle);
  *   byte[] ciphertext = ...;
  *   byte[] contextInfo = ...;

File: java/src/main/java/com/google/crypto/tink/hybrid/HybridEncryptFactory.java
Patch:
@@ -28,11 +28,11 @@
  * HybridEncryptFactory allows obtaining a HybridEncrypt primitive from a {@code KeysetHandle}.
  *
  * HybridEncryptFactory gets primitives from the {@code Registry}, which can be initialized
- * via convenience methods from {@code HybridEncryptConfig}. Here is an example how one can obtain
- * and use a HybridEncrypt primitive:
+ * via convenience methods from {@code Config} and {@code HybridConfig}. Here is an
+ * example how one can obtain and use a HybridEncrypt primitive:
  * <pre>   {@code
  *   KeysetHandle keysetHandle = ...;
- *   HybridEncryptConfig.registerStandardKeyTypes();
+ *   Config.register(HybridConfig.TINK_1_0_0);
  *   HybridEncrypt hybridEncrypt = HybridEncryptFactory.getPrimitive(keysetHandle);
  *   byte[] plaintext = ...;
  *   byte[] contextInfo = ...;

File: java/src/main/java/com/google/crypto/tink/hybrid/HybridKeyTemplates.java
Patch:
@@ -33,7 +33,7 @@
  * {@code KeysetHandle}. To generate a new keyset that contains a single
  * {@code EciesAeadHkdfPrivateKey}, one can do:
  * <pre>
- *   PublicKeySign.registerStandardKeyTypes();
+ *   Config.register(HybridConfig.TINK_1_0_0);
  *   KeysetHandle handle = KeysetHandle.generateNew(
  *       HybridKeyTemplates.ECIES_P256_HKDF_AES128_GCM);
  *   PublicKeySign signer = PublicKeySignFactory.getPrimitive(handle);

File: java/src/main/java/com/google/crypto/tink/mac/MacFactory.java
Patch:
@@ -33,11 +33,11 @@
  * MacFactory allows obtaining a Mac primitive from a {@code KeysetHandle}.
  *
  * MacFactory gets primitives from the {@code Registry}, which can be initialized
- * via convenience methods from {@code MacConfig}. Here is an example how one can obtain
- * and use a Mac primitive:
+ * via convenience methods from {@code Config} and {@code MacConfig}. Here is an example
+ * how one can obtain and use a Mac primitive:
  * <pre>   {@code
  *   KeysetHandle keysetHandle = ...;
- *   MacConfig.registerStandardKeyTypes();
+ *   Config.register(Mac.TINK_1_0_0);
  *   Mac mac = MacFactory.getPrimitive(keysetHandle);
  *   byte[] data = ...;
  *   byte[] tag = mac.computeMac(data);

File: java/src/main/java/com/google/crypto/tink/mac/MacKeyTemplates.java
Patch:
@@ -26,7 +26,7 @@
  * to generate new {@code Keyset} with {@code KeysetHandle}. To generate a new keyset
  * that contains a single {@code HmacKey}, one can do:
  * <pre>
- *   MacConfig.registerStandardKeyTypes();
+ *   Config.register(Mac.TINK_1_0_0);
  *   KeysetHandle handle = KeysetHandle.generateNew(MacKeyTemplates.HMAC_SHA256_128BITTAG);
  *   Mac mac = MacFactory.getPrimitive(handle);
  * </pre>

File: java/src/main/java/com/google/crypto/tink/signature/PublicKeySignFactory.java
Patch:
@@ -31,11 +31,11 @@
  * {@code KeysetHandle}.
  *
  * PublicKeySignFactory gets primitives from the {@code Registry}, which can be initialized
- * via convenience methods from {@code PublicKeySignConfig}. Here is an example how one can obtain
- * and use a PublicKeySign primitive:
+ * via convenience methods from {@code Config} and {@code SignatureConfig}. Here is an example
+ * how one can obtain and use a PublicKeySign primitive:
  * <pre>   {@code
  *   KeysetHandle keysetHandle = ...;
- *   PublicKeySignConfig.registerStandardKeyTypes();
+ *   Config.register(SignatureConfig.TINK_1_0_0);
  *   PublicKeySign signer = PublicKeySignFactory.getPrimitive(keysetHandle);
  *   byte[] data = ...;
  *   byte[] signature = signer.sign(data);

File: java/src/main/java/com/google/crypto/tink/signature/PublicKeyVerifyFactory.java
Patch:
@@ -34,11 +34,11 @@
  * {@code KeysetHandle}.
  *
  * PublicKeyVerifyFactory gets primitives from the {@code Registry}, which can be
- * initialized via convenience methods from {@code PublicKeyVerifyConfig}. Here is an example
- * how one can obtain and use a PublicKeyVerify primitive:
+ * initialized via convenience methods from {@code Config} and {@code PublicKeyVerifyConfig}.
+ * Here is an example how one can obtain and use a PublicKeyVerify primitive:
  * <pre>   {@code
  *   KeysetHandle keysetHandle = ...;
- *   PublicKeyVerifyConfig.registerStandardKeyTypes();
+ *   Config.register(SignatureConfig.TINK_1_0_0);
  *   PublicKeyVerify verifier = PublicKeyVerifyFactory.getPrimitive(keysetHandle);
  *   verifier.verify(signature, data);
  *  }</pre>

File: java/src/main/java/com/google/crypto/tink/signature/SignatureKeyTemplates.java
Patch:
@@ -28,7 +28,7 @@
  * One can use these templates to generate new {@code Keyset} with {@code KeysetHandle}.
  * To generate a new keyset that contains a single {@code EcdsaPrivateKey}, one can do:
  * <pre>
- *   PublicKeySign.registerStandardKeyTypes();
+ *   Config.register(SignatureConfig.TINK_1_0_0);
  *   KeysetHandle handle = KeysetHandle.generateNew(SignatureKeyTemplates.ECDSA_P256);
  *   PublicKeySign signer = PublicKeySignFactory.getPrimitive(handle);
  * </pre>

File: java/src/test/java/com/google/crypto/tink/CleartextKeysetHandleTest.java
Patch:
@@ -20,7 +20,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
-import com.google.crypto.tink.mac.MacConfig;
+import com.google.crypto.tink.config.TinkConfig;
 import com.google.crypto.tink.mac.MacFactory;
 import com.google.crypto.tink.mac.MacKeyTemplates;
 import com.google.crypto.tink.proto.KeyTemplate;
@@ -41,7 +41,7 @@
 public class CleartextKeysetHandleTest {
   @BeforeClass
   public static void setUp() throws GeneralSecurityException {
-    MacConfig.registerStandardKeyTypes();
+    Config.register(TinkConfig.TINK_1_0_0);
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/IntegrationTest.java
Patch:
@@ -19,7 +19,7 @@
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 
-import com.google.crypto.tink.config.Config;
+import com.google.crypto.tink.config.TinkConfig;
 import com.google.crypto.tink.hybrid.HybridDecryptFactory;
 import com.google.crypto.tink.hybrid.HybridEncryptFactory;
 import com.google.crypto.tink.subtle.Random;
@@ -37,7 +37,7 @@
 public class IntegrationTest {
   @BeforeClass
   public static void setUp() throws GeneralSecurityException {
-    Config.register(Config.TINK_HYBRID_1_0_0);
+    Config.register(TinkConfig.TINK_1_0_0);
   }
 
   /**

File: java/src/test/java/com/google/crypto/tink/KeysetHandleTest.java
Patch:
@@ -24,7 +24,7 @@
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.aead.AeadKeyTemplates;
-import com.google.crypto.tink.config.Config;
+import com.google.crypto.tink.config.TinkConfig;
 import com.google.crypto.tink.mac.MacKeyTemplates;
 import com.google.crypto.tink.proto.EcdsaPrivateKey;
 import com.google.crypto.tink.proto.KeyData;
@@ -52,8 +52,7 @@
 public class KeysetHandleTest {
   @BeforeClass
   public static void setUp() throws GeneralSecurityException {
-    Config.register(Config.TINK_AEAD_1_0_0);
-    Config.register(Config.TINK_SIGNATURE_1_0_0);
+    Config.register(TinkConfig.TINK_1_0_0);
   }
 
   /**

File: java/src/test/java/com/google/crypto/tink/KeysetManagerTest.java
Patch:
@@ -19,7 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
-import com.google.crypto.tink.config.Config;
+import com.google.crypto.tink.config.TinkConfig;
 import com.google.crypto.tink.mac.MacKeyTemplates;
 import com.google.crypto.tink.proto.KeyStatusType;
 import com.google.crypto.tink.proto.KeyTemplate;
@@ -38,7 +38,7 @@
 public class KeysetManagerTest {
   @BeforeClass
   public static void setUp() throws GeneralSecurityException {
-    Config.register(Config.TINK_HYBRID_1_0_0);  // includes TINK_AEAD_1_0_0
+    Config.register(TinkConfig.TINK_1_0_0);
   }
 
   private Key createDisabledKey(int keyId) {

File: java/src/test/java/com/google/crypto/tink/NoSecretKeysetHandleTest.java
Patch:
@@ -19,7 +19,7 @@
 import static com.google.crypto.tink.TestUtil.assertExceptionContains;
 import static org.junit.Assert.fail;
 
-import com.google.crypto.tink.config.Config;
+import com.google.crypto.tink.config.TinkConfig;
 import com.google.crypto.tink.mac.MacKeyTemplates;
 import com.google.crypto.tink.proto.KeyTemplate;
 import com.google.crypto.tink.proto.Keyset;
@@ -36,7 +36,7 @@
 public class NoSecretKeysetHandleTest {
   @BeforeClass
   public static void setUp() throws GeneralSecurityException {
-    Config.register(Config.TINK_AEAD_1_0_0);
+    Config.register(TinkConfig.TINK_1_0_0);
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/aead/AeadFactoryTest.java
Patch:
@@ -22,10 +22,10 @@
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.Aead;
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.CryptoFormat;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.TestUtil;
-import com.google.crypto.tink.config.Config;
 import com.google.crypto.tink.proto.KeyStatusType;
 import com.google.crypto.tink.proto.Keyset.Key;
 import com.google.crypto.tink.proto.OutputPrefixType;
@@ -47,7 +47,7 @@ public class AeadFactoryTest {
 
   @BeforeClass
   public static void setUp() throws Exception {
-    Config.register(Config.TINK_AEAD_1_0_0);
+    Config.register(AeadConfig.TINK_1_0_0);
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/aead/AesCtrHmacAeadKeyManagerTest.java
Patch:
@@ -19,7 +19,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
-import com.google.crypto.tink.config.Config;
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.proto.AesCtrHmacAeadKey;
 import com.google.crypto.tink.proto.AesCtrHmacAeadKeyFormat;
 import com.google.crypto.tink.proto.KeyData;
@@ -40,7 +40,7 @@
 public class AesCtrHmacAeadKeyManagerTest {
   @BeforeClass
   public static void setUp() throws Exception {
-    Config.register(Config.TINK_MAC_1_0_0);
+    Config.register(AeadConfig.TINK_1_0_0);
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/aead/ChaCha20Poly1305KeyManagerTest.java
Patch:
@@ -19,6 +19,7 @@
 import static org.junit.Assert.assertEquals;
 
 import com.google.crypto.tink.Aead;
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.CryptoFormat;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.TestUtil;
@@ -40,7 +41,7 @@
 public class ChaCha20Poly1305KeyManagerTest {
   @BeforeClass
   public static void setUp() throws GeneralSecurityException {
-    AeadConfig.registerStandardKeyTypes();
+    Config.register(AeadConfig.TINK_1_0_0);
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/aead/KmsAeadKeyManagerTest.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.crypto.tink.aead;
 
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.KmsClient;
 import com.google.crypto.tink.KmsClients;
@@ -36,7 +37,7 @@ public void setUp() throws Exception {
     KmsClient kmsClient = new GcpKmsClient()
         .withCredentials(TestUtil.SERVICE_ACCOUNT_FILE);
     KmsClients.add(kmsClient);
-    AeadConfig.registerStandardKeyTypes();
+    Config.register(AeadConfig.TINK_1_0_0);
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/aead/KmsEnvelopeAeadKeyManagerTest.java
Patch:
@@ -21,11 +21,11 @@
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.Aead;
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.CryptoFormat;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.KmsClients;
 import com.google.crypto.tink.TestUtil;
-import com.google.crypto.tink.config.Config;
 import com.google.crypto.tink.integration.GcpKmsClient;
 import com.google.crypto.tink.proto.KeyTemplate;
 import com.google.crypto.tink.subtle.Random;
@@ -43,9 +43,9 @@
 public class KmsEnvelopeAeadKeyManagerTest {
   @BeforeClass
   public static void setUp() throws Exception {
-    Config.register(Config.TINK_AEAD_1_0_0);
     KmsClients.add(new GcpKmsClient()
         .withCredentials(TestUtil.SERVICE_ACCOUNT_FILE));
+    Config.register(AeadConfig.TINK_1_0_0);
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/hybrid/EciesAeadHkdfHybridDecryptTest.java
Patch:
@@ -19,10 +19,10 @@
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.HybridEncrypt;
 import com.google.crypto.tink.aead.AeadKeyTemplates;
-import com.google.crypto.tink.config.Config;
 import com.google.crypto.tink.proto.EllipticCurveType;
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.proto.KeyTemplate;
@@ -47,7 +47,7 @@
 public class EciesAeadHkdfHybridDecryptTest {
   @Before
   public void setUp() throws GeneralSecurityException {
-    Config.register(Config.TINK_AEAD_1_0_0);
+    Config.register(HybridConfig.TINK_1_0_0);
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/hybrid/EciesAeadHkdfHybridEncryptTest.java
Patch:
@@ -19,10 +19,10 @@
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.HybridEncrypt;
 import com.google.crypto.tink.aead.AeadKeyTemplates;
-import com.google.crypto.tink.config.Config;
 import com.google.crypto.tink.proto.EllipticCurveType;
 import com.google.crypto.tink.proto.HashType;
 import com.google.crypto.tink.proto.KeyTemplate;
@@ -51,7 +51,7 @@
 public class EciesAeadHkdfHybridEncryptTest {
   @Before
   public void setUp() throws GeneralSecurityException {
-    Config.register(Config.TINK_AEAD_1_0_0);
+    Config.register(HybridConfig.TINK_1_0_0);
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPrivateKeyManagerTest.java
Patch:
@@ -19,12 +19,12 @@
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.HybridEncrypt;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.TestUtil;
 import com.google.crypto.tink.aead.AeadKeyTemplates;
-import com.google.crypto.tink.config.Config;
 import com.google.crypto.tink.proto.EcPointFormat;
 import com.google.crypto.tink.proto.EciesAeadHkdfKeyFormat;
 import com.google.crypto.tink.proto.EciesAeadHkdfParams;
@@ -49,7 +49,7 @@
 public class EciesAeadHkdfPrivateKeyManagerTest {
   @BeforeClass
   public static void setUp() throws Exception {
-    Config.register(Config.TINK_HYBRID_1_0_0);
+    Config.register(HybridConfig.TINK_1_0_0);
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/hybrid/HybridEncryptFactoryTest.java
Patch:
@@ -18,12 +18,12 @@
 
 import static org.junit.Assert.assertArrayEquals;
 
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.HybridEncrypt;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.TestUtil;
 import com.google.crypto.tink.aead.AeadKeyTemplates;
-import com.google.crypto.tink.config.Config;
 import com.google.crypto.tink.proto.EcPointFormat;
 import com.google.crypto.tink.proto.EciesAeadHkdfPrivateKey;
 import com.google.crypto.tink.proto.EllipticCurveType;
@@ -46,7 +46,7 @@
 public class HybridEncryptFactoryTest {
   @BeforeClass
   public static void setUp() throws Exception {
-    Config.register(Config.TINK_HYBRID_1_0_0);
+    Config.register(HybridConfig.TINK_1_0_0);
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/mac/MacFactoryTest.java
Patch:
@@ -20,6 +20,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.CryptoFormat;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.Mac;
@@ -45,7 +46,7 @@ public class MacFactoryTest {
 
   @BeforeClass
   public static void setUp() throws Exception {
-    MacConfig.registerStandardKeyTypes();
+    Config.register(MacConfig.TINK_1_0_0);
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/signature/EcdsaSignKeyManagerTest.java
Patch:
@@ -21,6 +21,7 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;
@@ -59,8 +60,7 @@
 public class EcdsaSignKeyManagerTest {
   @BeforeClass
   public static void setUp() throws Exception {
-    PublicKeySignConfig.registerStandardKeyTypes();
-    PublicKeyVerifyConfig.registerStandardKeyTypes();
+    Config.register(SignatureConfig.TINK_1_0_0);;
   }
 
   private static class HashAndCurveType {

File: java/src/test/java/com/google/crypto/tink/signature/Ed25519PrivateKeyManagerTest.java
Patch:
@@ -21,6 +21,7 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;
@@ -45,8 +46,7 @@
 public class Ed25519PrivateKeyManagerTest {
   @BeforeClass
   public static void setUp() throws GeneralSecurityException {
-    PublicKeySignConfig.registerStandardKeyTypes();
-    PublicKeyVerifyConfig.registerStandardKeyTypes();
+    Config.register(SignatureConfig.TINK_1_0_0);;
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/signature/Ed25519PublicKeyManagerTest.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.crypto.tink.TestUtil.assertExceptionContains;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.proto.Ed25519PrivateKey;
@@ -39,8 +40,7 @@
 public class Ed25519PublicKeyManagerTest {
   @Before
   public void setUp() throws GeneralSecurityException {
-    PublicKeySignConfig.registerStandardKeyTypes();
-    PublicKeyVerifyConfig.registerStandardKeyTypes();
+    Config.register(SignatureConfig.TINK_1_0_0);;
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/signature/PublicKeySignFactoryTest.java
Patch:
@@ -19,6 +19,7 @@
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.CryptoFormat;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.PublicKeySign;
@@ -47,8 +48,7 @@ public class PublicKeySignFactoryTest {
 
   @Before
   public void setUp() throws Exception {
-    PublicKeySignConfig.registerStandardKeyTypes();
-    PublicKeyVerifyConfig.registerStandardKeyTypes();
+    Config.register(SignatureConfig.TINK_1_0_0);;
   }
 
   @Test

File: java/src/test/java/com/google/crypto/tink/signature/PublicKeyVerifyFactoryTest.java
Patch:
@@ -18,6 +18,7 @@
 
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;
@@ -44,8 +45,7 @@ public class PublicKeyVerifyFactoryTest {
 
   @Before
   public void setUp() throws Exception {
-    PublicKeyVerifyConfig.registerStandardKeyTypes();
-    PublicKeySignConfig.registerStandardKeyTypes();
+    Config.register(SignatureConfig.TINK_1_0_0);;
   }
 
   @Test

File: tools/testing/java/com/google/crypto/tink/testing/HybridDecryptCli.java
Patch:
@@ -17,10 +17,11 @@
 package com.google.crypto.tink.testing;
 
 import com.google.crypto.tink.CleartextKeysetHandle;
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.KeysetReaders;
-import com.google.crypto.tink.config.Config;
+import com.google.crypto.tink.hybrid.HybridConfig;
 import com.google.crypto.tink.hybrid.HybridDecryptFactory;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -72,7 +73,7 @@ public static void main(String[] args) throws Exception {
 
     // Get the primitive.
     System.out.println("Getting the primitive...");
-    Config.register(Config.TINK_HYBRID_DECRYPT_1_0_0);
+    Config.register(HybridConfig.TINK_1_0_0);
     HybridDecrypt hybridDecrypt = HybridDecryptFactory.getPrimitive(keysetHandle);
 
     // Read the ciphertext.

File: tools/testing/java/com/google/crypto/tink/testing/HybridEncryptCli.java
Patch:
@@ -17,10 +17,11 @@
 package com.google.crypto.tink.testing;
 
 import com.google.crypto.tink.CleartextKeysetHandle;
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.HybridEncrypt;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.KeysetReaders;
-import com.google.crypto.tink.config.Config;
+import com.google.crypto.tink.hybrid.HybridConfig;
 import com.google.crypto.tink.hybrid.HybridEncryptFactory;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -72,7 +73,7 @@ public static void main(String[] args) throws Exception {
 
     // Get the primitive.
     System.out.println("Getting the primitive...");
-    Config.register(Config.TINK_HYBRID_ENCRYPT_1_0_0);
+    Config.register(HybridConfig.TINK_1_0_0);
     HybridEncrypt hybridEncrypt = HybridEncryptFactory.getPrimitive(keysetHandle);
 
     // Read the plaintext.

File: tools/tinkey/src/main/java/com/google/crypto/tink/tinkey/Tinkey.java
Patch:
@@ -16,7 +16,8 @@
 
 package com.google.crypto.tink.tinkey;
 
-import com.google.crypto.tink.config.Config;
+import com.google.crypto.tink.Config;
+import com.google.crypto.tink.config.TinkConfig;
 import org.kohsuke.args4j.CmdLineException;
 import org.kohsuke.args4j.CmdLineParser;
 
@@ -25,7 +26,7 @@
  */
 public final class Tinkey {
   public static void main(String[] args) throws Exception {
-    Config.register(Config.TINK_1_0_0);
+    Config.register(TinkConfig.TINK_1_0_0);
     TinkeyCommands commands = new TinkeyCommands();
     CmdLineParser parser = new CmdLineParser(commands);
 

File: tools/tinkey/src/test/java/com/google/crypto/tink/tinkey/AddKeyCommandTest.java
Patch:
@@ -19,9 +19,10 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.KeysetReader;
 import com.google.crypto.tink.TestUtil;
-import com.google.crypto.tink.config.Config;
+import com.google.crypto.tink.config.TinkConfig;
 import com.google.crypto.tink.mac.MacKeyTemplates;
 import com.google.crypto.tink.proto.EncryptedKeyset;
 import com.google.crypto.tink.proto.KeyTemplate;
@@ -48,7 +49,7 @@ public class AddKeyCommandTest {
 
   @BeforeClass
   public static void setUp() throws Exception {
-    Config.register(Config.TINK_1_0_0);
+    Config.register(TinkConfig.TINK_1_0_0);
   }
 
   private KeysetReader addNewKeyToKeyset(String outFormat, InputStream inputStream,

File: tools/tinkey/src/test/java/com/google/crypto/tink/tinkey/CreateKeyTemplateCommandTest.java
Patch:
@@ -19,8 +19,9 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.aead.AesGcmKeyManager;
-import com.google.crypto.tink.config.Config;
+import com.google.crypto.tink.config.TinkConfig;
 import com.google.crypto.tink.proto.AesGcmKeyFormat;
 import com.google.crypto.tink.proto.KeyTemplate;
 import com.google.protobuf.TextFormat;
@@ -37,7 +38,7 @@
 public class CreateKeyTemplateCommandTest {
   @BeforeClass
   public static void setUp() throws Exception {
-    Config.register(Config.TINK_1_0_0);
+    Config.register(TinkConfig.TINK_1_0_0);
   }
 
   @Test

File: tools/tinkey/src/test/java/com/google/crypto/tink/tinkey/CreateKeysetCommandTest.java
Patch:
@@ -18,8 +18,9 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.TestUtil;
-import com.google.crypto.tink.config.Config;
+import com.google.crypto.tink.config.TinkConfig;
 import com.google.crypto.tink.mac.MacKeyTemplates;
 import com.google.crypto.tink.proto.EncryptedKeyset;
 import com.google.crypto.tink.proto.KeyTemplate;
@@ -41,7 +42,7 @@ public class CreateKeysetCommandTest {
 
   @BeforeClass
   public static void setUp() throws Exception {
-    Config.register(Config.TINK_1_0_0);
+    Config.register(TinkConfig.TINK_1_0_0);
   }
 
   @Test

File: tools/tinkey/src/test/java/com/google/crypto/tink/tinkey/CreatePublicKeysetCommandTest.java
Patch:
@@ -19,14 +19,15 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.google.crypto.tink.CleartextKeysetHandle;
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.HybridEncrypt;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.KeysetReader;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.TestUtil;
-import com.google.crypto.tink.config.Config;
+import com.google.crypto.tink.config.TinkConfig;
 import com.google.crypto.tink.hybrid.HybridDecryptFactory;
 import com.google.crypto.tink.hybrid.HybridEncryptFactory;
 import com.google.crypto.tink.hybrid.HybridKeyTemplates;
@@ -61,7 +62,7 @@ private enum KeyType {
 
   @BeforeClass
   public static void setUp() throws Exception {
-    Config.register(Config.TINK_1_0_0);
+    Config.register(TinkConfig.TINK_1_0_0);
   }
 
   @Test

File: tools/tinkey/src/test/java/com/google/crypto/tink/tinkey/RotateKeysetCommandTest.java
Patch:
@@ -19,9 +19,10 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.KeysetReader;
 import com.google.crypto.tink.TestUtil;
-import com.google.crypto.tink.config.Config;
+import com.google.crypto.tink.config.TinkConfig;
 import com.google.crypto.tink.mac.MacKeyTemplates;
 import com.google.crypto.tink.proto.EncryptedKeyset;
 import com.google.crypto.tink.proto.KeyTemplate;
@@ -48,7 +49,7 @@ public class RotateKeysetCommandTest {
 
   @BeforeClass
   public static void setUp() throws Exception {
-    Config.register(Config.TINK_1_0_0);
+    Config.register(TinkConfig.TINK_1_0_0);
   }
 
   private KeysetReader addNewKeyToKeyset(String outFormat, InputStream inputStream,

File: tools/tinkey/src/test/java/com/google/crypto/tink/tinkey/TinkeyUtilTest.java
Patch:
@@ -20,10 +20,11 @@
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
+import com.google.crypto.tink.Config;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.aead.AesCtrHmacAeadKeyManager;
 import com.google.crypto.tink.aead.AesGcmKeyManager;
-import com.google.crypto.tink.config.Config;
+import com.google.crypto.tink.config.TinkConfig;
 import com.google.crypto.tink.proto.AesCtrHmacAeadKey;
 import com.google.crypto.tink.proto.AesGcmKey;
 import com.google.crypto.tink.proto.KeyTemplate;
@@ -39,7 +40,7 @@
 public class TinkeyUtilTest {
   @BeforeClass
   public static void setUp() throws Exception {
-    Config.register(Config.TINK_1_0_0);
+    Config.register(TinkConfig.TINK_1_0_0);
   }
 
   @Test

File: apps/googlepayments/src/main/java/com/google/payments/PaymentMethodTokenRecipient.java
Patch:
@@ -213,7 +213,7 @@ public String unseal(final String sealedMessage) throws GeneralSecurityException
       }
       throw new IllegalArgumentException("unsupported version: " + protocolVersion);
     } catch (JSONException e) {
-      throw new GeneralSecurityException("cannot unseal; invalid JSON message", e);
+      throw new GeneralSecurityException("cannot unseal; invalid JSON message");
     }
   }
 
@@ -266,7 +266,8 @@ private String decrypt(String ciphertext)
     throw new GeneralSecurityException("cannot decrypt");
   }
 
-  private void validateV1(final JSONObject jsonMsg) throws GeneralSecurityException {
+  private void validateV1(final JSONObject jsonMsg)
+      throws GeneralSecurityException, JSONException {
     if (!jsonMsg.has(PaymentMethodTokenConstants.JSON_PROTOCOL_VERSION_KEY)
         || !jsonMsg.has(PaymentMethodTokenConstants.JSON_SIGNATURE_KEY)
         || !jsonMsg.has(PaymentMethodTokenConstants.JSON_SIGNED_MESSAGE_KEY)

File: apps/googlepayments/src/test/java/com/google/payments/PaymentMethodTokenRecipientTest.java
Patch:
@@ -211,7 +211,7 @@ public void testShouldFailIfNoSigningKeysForProtocolVersion() throws Exception {
     trustedKeysJson.put("keys", new JSONArray().put(key1).put(key2));
 
     try {
-      PaymentMethodTokenRecipient recipient = new PaymentMethodTokenRecipient.Builder()
+      PaymentMethodTokenRecipient unused = new PaymentMethodTokenRecipient.Builder()
           .senderVerifyingKeys(trustedKeysJson.toString())
           .recipientId(RECIPIENT_ID)
           .addRecipientPrivateKey(MERCHANT_PRIVATE_KEY_PKCS8_BASE64)
@@ -287,7 +287,7 @@ public void testShouldFailIfProtocolSetToAnInt() throws Exception {
       recipient.unseal(payload.toString());
       fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
-      assertEquals("cannot unseal; invalid JSON message", e.getMessage());
+      // expected
     }
   }
 
@@ -305,7 +305,7 @@ public void testShouldFailIfProtocolSetToAnFloat() throws Exception {
       recipient.unseal(payload.toString());
       fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
-      assertEquals("cannot unseal; invalid JSON message", e.getMessage());
+      // expected
     }
   }
 }

File: tools/tinkey/src/test/java/com/google/crypto/tink/tinkey/AddCommandTest.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.crypto.tink.tinkey;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.KeysetReader;
 import com.google.crypto.tink.TestUtil;
@@ -92,6 +93,7 @@ public void testAddCleartext_shouldThrowExceptionIfExistingKeysetIsEmpty() throw
           outputStream, OUTPUT_FORMAT,
           emptyStream, INPUT_FORMAT,
           masterKeyUri, credentialPath, NEW_TEMPLATE);
+      fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
       TestUtil.assertExceptionContains(e, "empty keyset");
     }

File: tools/tinkey/src/test/java/com/google/crypto/tink/tinkey/RotateCommandTest.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.crypto.tink.tinkey;
 
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.KeysetReader;
 import com.google.crypto.tink.TestUtil;
@@ -92,6 +93,7 @@ public void testRotateCleartext_shouldThrowExceptionIfExistingKeysetIsEmpty() th
           outputStream, OUTPUT_FORMAT,
           emptyStream, INPUT_FORMAT,
           masterKeyUri, credentialPath, NEW_TEMPLATE);
+      fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
       TestUtil.assertExceptionContains(e, "empty keyset");
     }

File: java/src/main/java/com/google/crypto/tink/integration/AwsKmsAead.java
Patch:
@@ -18,8 +18,8 @@
 
 import static com.google.common.io.BaseEncoding.base16;
 
+import com.amazonaws.AmazonServiceException;
 import com.amazonaws.services.kms.AWSKMS;
-import com.amazonaws.services.kms.model.AWSKMSException;
 import com.amazonaws.services.kms.model.DecryptRequest;
 import com.amazonaws.services.kms.model.EncryptRequest;
 import com.google.crypto.tink.Aead;
@@ -61,7 +61,7 @@ public byte[] encrypt(final byte[] plaintext, final byte[] aad)
           .withPlaintext(ByteBuffer.wrap(plaintext))
           .addEncryptionContextEntry("aad", base16().lowerCase().encode(aad));
       return kmsClient.encrypt(req).getCiphertextBlob().array();
-    } catch (AWSKMSException e) {
+    } catch (AmazonServiceException e) {
       throw new GeneralSecurityException("encryption failed", e);
     }
   }
@@ -74,7 +74,7 @@ public byte[] decrypt(final byte[] ciphertext, final byte[] aad)
           .withCiphertextBlob(ByteBuffer.wrap(ciphertext))
           .addEncryptionContextEntry("aad", base16().lowerCase().encode(aad));
       return kmsClient.decrypt(req).getPlaintext().array();
-    } catch (AWSKMSException e) {
+    } catch (AmazonServiceException e) {
       throw new GeneralSecurityException("decryption failed", e);
     }
   }

File: java/src/main/java/com/google/crypto/tink/subtle/StreamingAeadDecryptingChannel.java
Patch:
@@ -80,7 +80,6 @@ class StreamingAeadDecryptingChannel implements ReadableByteChannel {
   private int segmentNr;
 
   private final StreamSegmentDecrypter decrypter;
-  private final int plaintextSegmentSize;
   private final int ciphertextSegmentSize;
   private final int ciphertextOffset;
 
@@ -104,7 +103,6 @@ public StreamingAeadDecryptingChannel(
     this.ciphertextSegmentSize = ciphertextSegmentSize;
     ciphertextSegment = ByteBuffer.allocate(ciphertextSegmentSize + 1);
     ciphertextSegment.limit(0);
-    this.plaintextSegmentSize = plaintextSegmentSize;
     plaintextSegment = ByteBuffer.allocate(plaintextSegmentSize);
     plaintextSegment.limit(0);
     this.ciphertextOffset = ciphertextOffset;
@@ -133,7 +131,7 @@ private void readSomeCiphertext(ByteBuffer buffer) throws IOException {
 
   /**
    * Tries to read the header of the ciphertext.
-   * @returns true if the header has been fully read and false if not enogh bytes were available
+   * @return true if the header has been fully read and false if not enogh bytes were available
    *          from the ciphertext stream.
    * @throws IOException when an exception occurs while reading the ciphertextStream or when
    *         the header is too short.

File: java/src/main/java/com/google/crypto/tink/subtle/StreamingAeadEncryptingChannel.java
Patch:
@@ -31,7 +31,6 @@ class StreamingAeadEncryptingChannel implements WritableByteChannel {
   ByteBuffer ptBuffer;  // contains plaintext that has not yet been encrypted.
   ByteBuffer ctBuffer;  // contains ciphertext that has not been written to ciphertextChannel.
   private int plaintextSegmentSize;
-  private int ciphertextSegmentSize;
   boolean open = true;
 
   public StreamingAeadEncryptingChannel(
@@ -46,7 +45,6 @@ public StreamingAeadEncryptingChannel(
     this.plaintextSegmentSize = plaintextSegmentSize;
     ptBuffer.limit(plaintextSegmentSize - ciphertextOffset);
     ctBuffer = ByteBuffer.allocate(ciphertextSegmentSize);
-    this.ciphertextSegmentSize = ciphertextSegmentSize;
     // At this point, ciphertextChannel might not yet be ready to receive bytes.
     // Buffering the header in ctBuffer ensures that the header will be written when writing to
     // ciphertextChannel is possible.

File: java/src/main/java/com/google/crypto/tink/subtle/StreamingAeadSeekableDecryptingChannel.java
Patch:
@@ -157,7 +157,7 @@ public SeekableByteChannel position(long newPosition) {
    * Tries to read the header of the ciphertext and derive the key used for the
    * ciphertext from the information in the header.
    *
-   * @returns true if the header was fully read and has a correct format.
+   * @return true if the header was fully read and has a correct format.
    *               Returns false if the header could not be read.
    * @throws IOException if the header was incorrectly formatted or if there
    *         was an exception during the key derivation.
@@ -187,7 +187,7 @@ private int getSegmentNr(long plaintextPosition) {
   /**
    * Tries to read and decrypt a ciphertext segment.
    * @param segmentNr the number of the segment
-   * @returns true if the segment was read and correctly decrypted.
+   * @return true if the segment was read and correctly decrypted.
    *          Returns false if the segment could not be fully read.
    * @throws IOException if there was an exception reading the ciphertext,
    *         if the segment number was incorrect, or

File: java/src/test/java/com/google/crypto/tink/aead/KmsEnvelopeAeadKeyManagerTest.java
Patch:
@@ -57,8 +57,6 @@ public void setUp() throws Exception {
   @Test
   public void testGcpKmsKeyRestricted() throws Exception {
     KeyTemplate dekTemplate = AeadKeyTemplates.AES128_CTR_HMAC_SHA256;
-    // This key is restricted to {@code TestUtil.SERVICE_ACCOUNT_FILE}.
-    String kekUri = TestUtil.RESTRICTED_CRYPTO_KEY_URI;
     KeysetHandle keysetHandle = CleartextKeysetHandle.generateNew(
         AeadKeyTemplates.createKmsEnvelopeAeadKeyTemplate(
             TestUtil.RESTRICTED_CRYPTO_KEY_URI, dekTemplate));
@@ -68,7 +66,6 @@ public void testGcpKmsKeyRestricted() throws Exception {
   @Test
   public void testParsingInvalidCiphertexts() throws Exception {
     KeyTemplate dekTemplate = AeadKeyTemplates.AES128_CTR_HMAC_SHA256;
-    String kekUri = TestUtil.RESTRICTED_CRYPTO_KEY_URI;
     KeysetHandle keysetHandle = CleartextKeysetHandle.generateNew(
         AeadKeyTemplates.createKmsEnvelopeAeadKeyTemplate(
             TestUtil.RESTRICTED_CRYPTO_KEY_URI, dekTemplate));

File: java/src/test/java/com/google/crypto/tink/integration/AwsKmsAeadTest.java
Patch:
@@ -22,8 +22,8 @@
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import com.amazonaws.AmazonServiceException;
 import com.amazonaws.services.kms.AWSKMS;
-import com.amazonaws.services.kms.model.AWSKMSException;
 import com.amazonaws.services.kms.model.DecryptRequest;
 import com.amazonaws.services.kms.model.DecryptResult;
 import com.amazonaws.services.kms.model.EncryptRequest;
@@ -69,7 +69,7 @@ public void testEncryptDecrypt() throws Exception {
 
   @Test
   public void testEncrypt_shouldThrowExceptionIfRequestFailed() throws Exception {
-    AWSKMSException exception = mock(AWSKMSException.class);
+    AmazonServiceException exception = mock(AmazonServiceException.class);
     when(mockKms.encrypt(isA(EncryptRequest.class)))
         .thenThrow(exception);
 
@@ -89,7 +89,7 @@ public void testDecrypt_shouldThrowExceptionIfRequestFailed() throws Exception {
     EncryptResult mockEncryptResult = mock(EncryptResult.class);
     when(mockKms.encrypt(isA(EncryptRequest.class)))
         .thenReturn(mockEncryptResult);
-    AWSKMSException exception = mock(AWSKMSException.class);
+    AmazonServiceException exception = mock(AmazonServiceException.class);
     when(mockKms.decrypt(isA(DecryptRequest.class)))
         .thenThrow(exception);
 

File: java/src/main/java/com/google/crypto/tink/aead/AeadKeyTemplates.java
Patch:
@@ -26,8 +26,8 @@
 import com.google.crypto.tink.proto.HmacKeyFormat;
 import com.google.crypto.tink.proto.HmacParams;
 import com.google.crypto.tink.proto.KeyTemplate;
-import com.google.crypto.tink.proto.KmsEnvelopeAeadKeyFormat;
 import com.google.crypto.tink.proto.KmsAeadKeyFormat;
+import com.google.crypto.tink.proto.KmsEnvelopeAeadKeyFormat;
 
 /**
  * Pre-generated {@code KeyTemplate} for {@code Aead} keys. One can use these templates

File: java/src/main/java/com/google/crypto/tink/integration/CloudKmsClient.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.google.crypto.tink.integration;
 
-import com.google.crypto.tink.subtle.KmsClient;
 import com.amazonaws.services.kms.AWSKMS;
 import com.google.api.services.cloudkms.v1.CloudKMS;
 import com.google.crypto.tink.Aead;
+import com.google.crypto.tink.subtle.KmsClient;
 import java.security.GeneralSecurityException;
 
 /**

File: java/src/main/java/com/google/crypto/tink/integration/IntegrationUtil.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.crypto.tink.integration;
 
-import java.util.regex.Pattern;
 import java.security.GeneralSecurityException;
+import java.util.regex.Pattern;
 
 /**
  * Integration helper methods.

File: java/src/main/java/com/google/crypto/tink/subtle/NaClCryptoBox.java
Patch:
@@ -31,11 +31,11 @@
  *   byte[] plaintext = hybridDecrypt.decrypt(ciphertextFromAlice, contextInfo \/* can be null *\/);
  * </code>
  */
-public class NaClCryptoBox {
+public final class NaClCryptoBox {
 
   private static final byte[] EMPTY_AAD = new byte[0];
 
-  private static abstract class Curve25519DjbCipherPoly1305Factory {
+  private abstract static class Curve25519DjbCipherPoly1305Factory {
     abstract DjbCipherPoly1305 constructFromSymmetricKey(final byte[] sharedSecret);
 
     DjbCipherPoly1305 constructWithKem(final byte[] privateKey, final byte[] peerPublicKey) {

File: java/src/test/java/com/google/crypto/tink/aead/AesCtrHmacAeadKeyManagerTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.crypto.tink.aead;
 
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.fail;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.proto.AesCtrHmacAeadKey;
 import com.google.crypto.tink.proto.AesCtrHmacAeadKeyFormat;

File: java/src/test/java/com/google/crypto/tink/aead/AesCtrKeyManagerTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.crypto.tink.aead;
 
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.fail;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.TestUtil;
 import com.google.crypto.tink.proto.AesCtrKey;

File: java/src/test/java/com/google/crypto/tink/aead/AesGcmKeyManagerTest.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.crypto.tink.aead;
 
-import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.CryptoFormat;

File: java/src/test/java/com/google/crypto/tink/hybrid/EciesAeadHkdfHybridDecryptTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.crypto.tink.hybrid;
 
-import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.HybridEncrypt;

File: java/src/test/java/com/google/crypto/tink/hybrid/EciesAeadHkdfHybridEncryptTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.crypto.tink.hybrid;
 
-import static junit.framework.Assert.assertEquals;
 import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
 
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.HybridEncrypt;

File: java/src/test/java/com/google/crypto/tink/mac/HmacKeyManagerTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.crypto.tink.mac;
 
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.fail;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.TestUtil;
 import com.google.crypto.tink.proto.HashType;

File: java/src/test/java/com/google/crypto/tink/mac/MacFactoryTest.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.crypto.tink.mac;
 
-import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.CryptoFormat;
 import com.google.crypto.tink.KeysetHandle;

File: java/src/test/java/com/google/crypto/tink/signature/EcdsaSignKeyManagerTest.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.google.crypto.tink.signature;
 
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertTrue;
-import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.CleartextKeysetHandle;
 import com.google.crypto.tink.KeysetHandle;

File: java/src/test/java/com/google/crypto/tink/signature/EcdsaVerifyKeyManagerTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.crypto.tink.signature;
 
-import static junit.framework.Assert.fail;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.TestUtil;

File: java/src/test/java/com/google/crypto/tink/signature/Ed25519PrivateKeyManagerTest.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.google.crypto.tink.signature;
 
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertTrue;
-import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.CleartextKeysetHandle;
 import com.google.crypto.tink.KeysetHandle;

File: java/src/test/java/com/google/crypto/tink/signature/Ed25519PublicKeyManagerTest.java
Patch:
@@ -17,7 +17,7 @@
 package com.google.crypto.tink.signature;
 
 import static com.google.crypto.tink.TestUtil.assertExceptionContains;
-import static junit.framework.Assert.fail;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.PublicKeyVerify;

File: java/src/test/java/com/google/crypto/tink/signature/PublicKeySignFactoryTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.crypto.tink.signature;
 
-import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.CryptoFormat;
 import com.google.crypto.tink.KeysetHandle;

File: java/src/test/java/com/google/crypto/tink/signature/PublicKeyVerifyFactoryTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.crypto.tink.signature;
 
-import static junit.framework.Assert.fail;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.PublicKeySign;

File: java/src/test/java/com/google/crypto/tink/streamingaead/AesCtrHmacStreamingKeyManagerTest.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.crypto.tink.streamingaead;
 
-import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.StreamingAead;
 import com.google.crypto.tink.TestUtil;

File: java/src/test/java/com/google/crypto/tink/streamingaead/AesGcmHkdfStreamingKeyManagerTest.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.crypto.tink.streamingaead;
 
-import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.StreamingAead;
 import com.google.crypto.tink.TestUtil;

File: java/src/test/java/com/google/crypto/tink/subtle/AesCtrJceCipherTest.java
Patch:
@@ -16,9 +16,9 @@
 
 package com.google.crypto.tink.subtle;
 
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.assertFalse;
 import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 
 import com.google.crypto.tink.TestUtil;
 import java.util.Arrays;

File: java/src/test/java/com/google/crypto/tink/subtle/EcUtilTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.crypto.tink.subtle;
 
-import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.TestUtil;
 import com.google.crypto.tink.proto.EcPointFormat;

File: java/src/test/java/com/google/crypto/tink/subtle/EcdsaSignJceTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.crypto.tink.subtle;
 
-import static junit.framework.Assert.assertFalse;
-import static junit.framework.Assert.assertTrue;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 import java.security.GeneralSecurityException;
 import java.security.KeyPair;

File: java/src/test/java/com/google/crypto/tink/subtle/EcdsaVerifyJceTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.crypto.tink.subtle;
 
-import static junit.framework.Assert.assertEquals;
-import static junit.framework.Assert.fail;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.TestUtil;
 import java.math.BigInteger;

File: java/src/test/java/com/google/crypto/tink/subtle/EncryptThenAuthenticateTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.crypto.tink.subtle;
 
-import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.Mac;

File: java/src/test/java/com/google/crypto/tink/subtle/MacJceTest.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.crypto.tink.subtle;
 
-import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.Mac;
 import com.google.crypto.tink.TestUtil;

File: java/src/main/java/com/google/crypto/tink/aead/AeadConfig.java
Patch:
@@ -42,7 +42,6 @@ public final class AeadConfig {
    */
   public static void registerStandardKeyTypes() throws GeneralSecurityException {
     registerKeyManager(new AesCtrHmacAeadKeyManager());
-    registerKeyManager(new KmsEnvelopeAeadKeyManager());
     registerKeyManager(new AesGcmKeyManager());
     registerKeyManager(new AesEaxKeyManager());
     registerKeyManager(new ChaCha20Poly1305KeyManager());

File: java/src/main/java/com/google/crypto/tink/integration/GcpScopes.java
Patch:
@@ -14,7 +14,7 @@
 //
 ////////////////////////////////////////////////////////////////////////////////
 
-package com.google.crypto.tink.subtle;
+package com.google.crypto.tink.integration;
 
 /**
  * Available OAuth 2.0 scopes for use with the Google Cloud API.

File: tools/tinkey/src/main/java/com/google/crypto/tink/tinkey/CreateCommand.java
Patch:
@@ -18,11 +18,11 @@
 
 import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeysetManager;
+import com.google.crypto.tink.integration.GcpKmsAead;
+import com.google.crypto.tink.integration.GcpKmsClient;
 import com.google.crypto.tink.proto.EncryptedKeyset;
 import com.google.crypto.tink.proto.KeyTemplate;
 import com.google.crypto.tink.proto.Keyset;
-import com.google.crypto.tink.subtle.GcpKmsAead;
-import com.google.crypto.tink.subtle.GcpKmsClient;
 import com.google.protobuf.Message;
 import java.io.File;
 import java.io.OutputStream;

File: tools/tinkey/src/main/java/com/google/crypto/tink/tinkey/CreateOptions.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.crypto.tink.tinkey;
 
+import com.google.crypto.tink.integration.IntegrationUtil;
 import com.google.crypto.tink.proto.KeyTemplate;
-import com.google.crypto.tink.subtle.GcpKmsClient;
 import com.google.crypto.tink.subtle.SubtleUtil;
 import org.kohsuke.args4j.Option;
 
@@ -55,7 +55,7 @@ void validate() {
         SubtleUtil.die("Cannot set both --gcp-kms-key-uri and --aws-kms-key-arn");
       }
       if (gcpKmsMasterKeyUriValue != null) {
-        GcpKmsClient.validateCryptoKeyUri(gcpKmsMasterKeyUriValue);
+        IntegrationUtil.validateCryptoKeyUri(gcpKmsMasterKeyUriValue);
       }
     } catch (Exception e) {
       SubtleUtil.die(e.toString());

File: java/src/test/java/com/google/crypto/tink/subtle/AesCtrHmacStreamingTest.java
Patch:
@@ -825,7 +825,7 @@ private ReadableByteChannel ciphertextChannel(
       final AesCtrHmacStreaming ags,
       final ReadableByteChannel plaintext,
       final byte[] aad,
-      int chunkSize) throws Exception {
+      final int chunkSize) throws Exception {
     PipedOutputStream output = new PipedOutputStream();
     PipedInputStream result = new PipedInputStream(output);
     final WritableByteChannel ciphertext = Channels.newChannel(output);

File: java/src/main/java/com/google/crypto/tink/subtle/StreamingAeadEncryptingChannel.java
Patch:
@@ -25,8 +25,7 @@
  * An instance of {WritableByteChannel} that encrypts the input
  * using a nonce based online authentication scheme.
  */
-// TODO(bleichen): Rename. The implementation is generic an can use any AEAD cipher
-class AesGcmHkdfEncryptingChannel implements WritableByteChannel {
+class StreamingAeadEncryptingChannel implements WritableByteChannel {
   private WritableByteChannel ciphertextChannel;
   private StreamSegmentEncrypter encrypter;
   ByteBuffer ptBuffer;  // contains plaintext that has not yet been encrypted.
@@ -35,7 +34,7 @@ class AesGcmHkdfEncryptingChannel implements WritableByteChannel {
   private int ciphertextSegmentSize;
   boolean open = true;
 
-  public AesGcmHkdfEncryptingChannel(
+  public StreamingAeadEncryptingChannel(
       StreamSegmentEncrypter encrypter,
       WritableByteChannel ciphertextChannel,
       int plaintextSegmentSize,

File: examples/java/envelopeme/src/main/java/com/example/envelopeme/EnvelopeMe.java
Patch:
@@ -35,7 +35,7 @@ public static byte[] encrypt(byte[] config, byte[] plaintext)
       throws Exception {
     KeysetHandle handle = NoSecretKeysetHandle.parseFrom(config);
     Aead aead = AeadFactory.getPrimitive(handle);
-    return aead.encrypt(plaintext, null /* aad */);
+    return aead.encrypt(plaintext, /* additionalData= */null);
   }
 
   /**
@@ -45,7 +45,7 @@ public static byte[] decrypt(byte[] config, byte[] ciphertext)
       throws Exception {
     KeysetHandle handle = NoSecretKeysetHandle.parseFrom(config);
     Aead aead = AeadFactory.getPrimitive(handle);
-    return aead.decrypt(ciphertext, null /* aad */);
+    return aead.decrypt(ciphertext, /* additionalData= */null);
   }
 
   public static void main(String[] args) throws Exception {

File: java/src/main/java/com/google/crypto/tink/EncryptedKeysetHandle.java
Patch:
@@ -70,7 +70,7 @@ public static final KeysetHandle parseFrom(EncryptedKeyset proto, Aead masterKey
     EncryptedKeysetHandle.assertEnoughKeyMaterial(proto);
     try {
       final Keyset keyset = Keyset.parseFrom(masterKey.decrypt(
-          proto.getEncryptedKeyset().toByteArray(), new byte[0] /* aad */));
+          proto.getEncryptedKeyset().toByteArray(), /* additionalData= */new byte[0]));
       // check emptiness here too, in case the encrypted keys unwrapped to nothing?
       KeysetHandle.assertEnoughKeyMaterial(keyset);
       return new KeysetHandle(keyset, proto);

File: java/src/main/java/com/google/crypto/tink/KeysetManager.java
Patch:
@@ -129,11 +129,11 @@ public KeysetHandle getKeysetHandle() throws GeneralSecurityException {
     }
     Keyset keyset = keysetBuilder.build();
     byte[] encryptedKeyset = masterKey.encrypt(keyset.toByteArray(),
-        new byte[0] /* aad */);
+        /* additionalData= */new byte[0]);
     // Check if we can decrypt, to detect errors
     try {
       final Keyset keyset2 = Keyset.parseFrom(masterKey.decrypt(
-          encryptedKeyset, new byte[0] /* aad */));
+          encryptedKeyset, /* additionalData= */new byte[0]));
       if (!keyset2.equals(keyset)) {
         throw new GeneralSecurityException("cannot encrypt keyset");
       }

File: java/src/main/java/com/google/crypto/tink/Registry.java
Patch:
@@ -192,7 +192,7 @@ public <P> P getPrimitive(KeyData keyData) throws GeneralSecurityException {
    */
   public <P> PrimitiveSet<P> getPrimitives(KeysetHandle keysetHandle)
       throws GeneralSecurityException {
-    return getPrimitives(keysetHandle, null /* customManager */);
+    return getPrimitives(keysetHandle, /* customManager= */null);
   }
   /**
    * Creates a set of primitives corresponding to the keys with status=ENABLED in the keyset

File: java/src/main/java/com/google/crypto/tink/aead/AeadFactory.java
Patch:
@@ -57,7 +57,7 @@ public final class AeadFactory {
    */
   public static Aead getPrimitive(KeysetHandle keysetHandle)
       throws GeneralSecurityException {
-    return getPrimitive(keysetHandle, null /* keyManager */);
+    return getPrimitive(keysetHandle, /* keyManager= */null);
   }
 
   /**

File: java/src/main/java/com/google/crypto/tink/hybrid/HybridDecryptFactory.java
Patch:
@@ -54,7 +54,7 @@ public final class HybridDecryptFactory {
    */
   public static HybridDecrypt getPrimitive(KeysetHandle keysetHandle)
       throws GeneralSecurityException {
-    return getPrimitive(keysetHandle, null /* keyManager */);
+    return getPrimitive(keysetHandle, /* keyManager= */null);
   }
   /**
    * @return a HybridDecrypt primitive from a {@code keysetHandle} and a custom {@code keyManager}.

File: java/src/main/java/com/google/crypto/tink/hybrid/HybridEncryptFactory.java
Patch:
@@ -77,7 +77,7 @@ public static void registerLegacyKeyTypes() throws GeneralSecurityException {
    */
   public static HybridEncrypt getPrimitive(KeysetHandle keysetHandle)
       throws GeneralSecurityException {
-    return getPrimitive(keysetHandle, null /* keyManager */);
+    return getPrimitive(keysetHandle, /* keyManager= */null);
   }
   /**
    * @return a HybridEncrypt primitive from a {@code keysetHandle} and a custom {@code keyManager}.

File: java/src/main/java/com/google/crypto/tink/mac/MacFactory.java
Patch:
@@ -57,7 +57,7 @@ public final class MacFactory {
    */
   public static Mac getPrimitive(KeysetHandle keysetHandle)
       throws GeneralSecurityException {
-    return getPrimitive(keysetHandle, null /* keyManager */);
+    return getPrimitive(keysetHandle, /* keyManager= */null);
   }
 
   /**

File: java/src/main/java/com/google/crypto/tink/signature/PublicKeySignFactory.java
Patch:
@@ -52,7 +52,7 @@ public final class PublicKeySignFactory {
    */
   public static PublicKeySign getPrimitive(KeysetHandle keysetHandle)
       throws GeneralSecurityException {
-        return getPrimitive(keysetHandle, null /* keyManager */);
+        return getPrimitive(keysetHandle, /* keyManager= */null);
       }
 
   /**

File: java/src/main/java/com/google/crypto/tink/signature/PublicKeyVerifyFactory.java
Patch:
@@ -56,7 +56,7 @@ public final class PublicKeyVerifyFactory {
    */
   public static PublicKeyVerify getPrimitive(KeysetHandle keysetHandle)
       throws GeneralSecurityException {
-        return getPrimitive(keysetHandle, null /* keyManager */);
+        return getPrimitive(keysetHandle, /* keyManager= */null);
       }
 
   /**

File: tools/tinkey/src/main/java/com/google/crypto/tink/tinkey/CreateKeyTemplateCommand.java
Patch:
@@ -51,6 +51,6 @@ public static void create(OutputStream outputStream, String typeUrlValue,
     }
 
     outputStream.write(comment.getBytes("UTF-8"));
-    TinkeyUtil.writeProto(keyTemplate, outputStream, "TEXT" /* outFormat */);
+    TinkeyUtil.writeProto(keyTemplate, outputStream, /* outFormat= */"TEXT");
   }
 }

File: java/src/main/java/com/google/crypto/tink/StreamingAead.java
Patch:
@@ -55,12 +55,12 @@
  * decryption have the same property. That is encryption always processes all the plaintext passed
  * in and waits until complete segments have been written to the ciphertext channel. Similarly,
  * decryption blocks until sufficiently many bytes have been read from the ciphertext channel until
- * all the requested plaintext has been decrypted and authenticated, an IOException occured, or the
+ * all the requested plaintext has been decrypted and authenticated, an IOException occurred, or the
  * end of the plaintext has been reached.
  *
  * If the channel provided to the streaming encryption is in non-blocking mode, then encryption and
  * decryption are also non-blocking. Since encryption and decryption is done in segments it is
- * possible that for exmaple a call attempting to read() returns no plaintext at all even if
+ * possible that for example a call attempting to read() returns no plaintext at all even if
  * partial ciphertext was read from the underlying channel.
  *
  * Sample encryption:
@@ -149,7 +149,7 @@ WritableByteChannel newEncryptingChannel(
    *    </ul>
    * @throws GeneralSecurityException if the header of the ciphertext is corrupt or if the
    *    associatedData is not correct.
-   * @throws IOException if an IOException occured while reading from ciphertextDestination.
+   * @throws IOException if an IOException occurred while reading from ciphertextDestination.
    */
   SeekableByteChannel newSeekableDecryptingChannel(
       SeekableByteChannel ciphertextSource,

File: java/src/main/java/com/google/crypto/tink/subtle/AesGcmHkdfDecryptingChannel.java
Patch:
@@ -60,7 +60,7 @@ class AesGcmHkdfDecryptingChannel implements ReadableByteChannel {
   /**
    * Indicates whether this stream is in a defined state.
    * Currently the state of this instance becomes undefined when
-   * an authentication error has occured.
+   * an authentication error has occurred.
    */
   private boolean definedState;
 
@@ -276,7 +276,7 @@ public String toString() {
        .append(" position:").append(header.position())
        .append(" limit:").append(header.position())
        .append("\nciphertextSgement")
-       .append(" postion:").append(ciphertextSegment.position())
+       .append(" position:").append(ciphertextSegment.position())
        .append(" limit:").append(ciphertextSegment.limit())
        .append("\nplaintextSegment")
        .append(" position:").append(plaintextSegment.position())

File: java/src/main/java/com/google/crypto/tink/subtle/AesGcmHkdfStreaming.java
Patch:
@@ -278,8 +278,8 @@ public synchronized void encryptSegment(
 
     /**
      * Encrypt a segment consisting of two parts.
-     * This method simplifies the case where one part of the plaintext is buffered and the other part
-     * is passed in by the caller.
+     * This method simplifies the case where one part of the plaintext is buffered and the other
+     * part is passed in by the caller.
      */
     public synchronized void encryptSegment(
         ByteBuffer part1, ByteBuffer part2, boolean isLastSegment, ByteBuffer ciphertext)

File: java/src/main/java/com/google/crypto/tink/subtle/DjbCipherPoly1305.java
Patch:
@@ -273,7 +273,8 @@ public byte[] decrypt(final byte[] ciphertext, final byte[] additionalData)
     ciphertextBuf.get(tag);
     byte[] nonce = new byte[djbCipher.nonceSizeInBytes()];
     ciphertextBuf.get(nonce);
-    byte[] expectedTag = computeTag(ciphertextBuf, additionalData, djbCipher.getAuthenticatorKey(nonce));
+    byte[] expectedTag =
+        computeTag(ciphertextBuf, additionalData, djbCipher.getAuthenticatorKey(nonce));
     if (!SubtleUtil.arrayEquals(tag, expectedTag)) {
       throw new GeneralSecurityException("Tags do not match.");
     }

File: java/src/test/java/com/google/crypto/tink/TestUtil.java
Patch:
@@ -111,7 +111,7 @@ public static class ByteBufferChannel implements SeekableByteChannel {
     private final ByteBuffer buffer;
 
     /**
-     * Defines the maximal size of a chunk that is transfered with a single write.
+     * Defines the maximal size of a chunk that is transferred with a single write.
      * This can be used to test the behavior of streaming encryption with channels
      * where not always sufficiently many bytes are available during reads and writes.
      */

File: java/src/test/java/com/google/crypto/tink/streamingaead/AesGcmHkdfStreamingKeyManagerTest.java
Patch:
@@ -252,7 +252,7 @@ public void testNewKeyWithBadFormat() throws Exception {
         .setKeySize(16)
         .build();
     serializedKeyFormat = ByteString.copyFrom(keyFormat.toByteArray());
-    AesGcmHkdfStreamingKey key = (AesGcmHkdfStreamingKey) keyManager.newKey(keyFormat);
-    key = (AesGcmHkdfStreamingKey) keyManager.newKey(serializedKeyFormat);
+    AesGcmHkdfStreamingKey unusedKey = (AesGcmHkdfStreamingKey) keyManager.newKey(keyFormat);
+    unusedKey = (AesGcmHkdfStreamingKey) keyManager.newKey(serializedKeyFormat);
   }
 }

File: java/src/test/java/com/google/crypto/tink/subtle/AesGcmHkdfStreamingTest.java
Patch:
@@ -48,7 +48,7 @@
 import org.junit.runners.JUnit4;
 
 /**
- * Test for {@code AesGcmHkdfStreaming}-implementaiton of {@code StreamingAead}-primitive.
+ * Test for {@code AesGcmHkdfStreaming}-implementation of {@code StreamingAead}-primitive.
  */
 @RunWith(JUnit4.class)
 public class AesGcmHkdfStreamingTest {

File: java/src/main/java/com/google/crypto/tink/hybrid/HybridUtil.java
Patch:
@@ -20,10 +20,10 @@
 import com.google.crypto.tink.proto.EcPointFormat;
 import com.google.crypto.tink.proto.EciesAeadHkdfParams;
 import com.google.crypto.tink.subtle.EcUtil;
-import com.google.crypto.tink.subtle.SubtleUtil;
+import com.google.crypto.tink.subtle.ProtoUtil;
 import java.security.GeneralSecurityException;
 
-final class HybridUtil {
+class HybridUtil {
   /**
    * Validates EciesAeadHkdf params.
    *
@@ -32,7 +32,7 @@ final class HybridUtil {
    */
   public static void validate(EciesAeadHkdfParams params) throws GeneralSecurityException {
     EcUtil.getCurveSpec(params.getKemParams().getCurveType());
-    SubtleUtil.hashToHmacAlgorithmName(params.getKemParams().getHkdfHashType());
+    ProtoUtil.hashToHmacAlgorithmName(params.getKemParams().getHkdfHashType());
     if (params.getEcPointFormat() == EcPointFormat.UNKNOWN_FORMAT) {
       throw new GeneralSecurityException("unknown EC point format");
     }

File: java/src/main/java/com/google/crypto/tink/subtle/EciesAeadHkdfHybridDecrypt.java
Patch:
@@ -45,7 +45,7 @@ public EciesAeadHkdfHybridDecrypt(final ECPrivateKey recipientPrivateKey,
     this.recipientPrivateKey = recipientPrivateKey;
     this.recipientKem = new EciesHkdfRecipientKem(recipientPrivateKey);
     this.hkdfSalt = hkdfSalt;
-    this.hkdfHmacAlgo = SubtleUtil.hashToHmacAlgorithmName(hkdfHashType);
+    this.hkdfHmacAlgo = ProtoUtil.hashToHmacAlgorithmName(hkdfHashType);
     this.ecPointFormat = ecPointFormat;
     this.demHelper = demHelper;
   }

File: java/src/main/java/com/google/crypto/tink/subtle/EciesAeadHkdfHybridEncrypt.java
Patch:
@@ -43,7 +43,7 @@ public EciesAeadHkdfHybridEncrypt(final ECPublicKey recipientPublicKey,
     EcUtil.checkPublicKey(recipientPublicKey);
     this.senderKem = new EciesHkdfSenderKem(recipientPublicKey);
     this.hkdfSalt = hkdfSalt;
-    this.hkdfHmacAlgo = SubtleUtil.hashToHmacAlgorithmName(hkdfHashType);
+    this.hkdfHmacAlgo = ProtoUtil.hashToHmacAlgorithmName(hkdfHashType);
     this.ecPointFormat = ecPointFormat;
     this.demHelper = demHelper;
   }

File: java/src/test/java/com/google/crypto/tink/UtilTest.java
Patch:
@@ -118,7 +118,6 @@ public void testValidateKeyset() throws Exception {
             .setStatus(KeyStatusType.ENABLED)
             .setOutputPrefixType(OutputPrefixType.TINK)
             .build())
-        .setPrimaryKeyId(1)
         .build();
     try {
       Util.validateKeyset(validKeyset);

File: java/src/main/java/com/google/crypto/tink/aead/ChaCha20Poly1305KeyManager.java
Patch:
@@ -16,14 +16,15 @@
 
 package com.google.crypto.tink.aead;
 
+import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.ChaCha20Poly1305Key;
 import com.google.crypto.tink.KeyManager;
-import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.TinkProto.KeyData;
 import com.google.crypto.tink.subtle.DjbCipher;
 import com.google.crypto.tink.subtle.DjbCipherPoly1305;
 import com.google.crypto.tink.subtle.SubtleUtil;
 import com.google.crypto.tink.subtle.Random;
+import com.google.crypto.tink.subtle.SubtleUtil;
 import com.google.protobuf.ByteString;
 import com.google.protobuf.InvalidProtocolBufferException;
 import com.google.protobuf.MessageLite;

File: java/src/main/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPrivateKeyManager.java
Patch:
@@ -24,7 +24,7 @@
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.KeyManager;
 import com.google.crypto.tink.TinkProto.KeyData;
-import com.google.crypto.tink.Util;
+import com.google.crypto.tink.subtle.EcUtil;
 import com.google.crypto.tink.subtle.EciesAeadHkdfDemHelper;
 import com.google.crypto.tink.subtle.EciesAeadHkdfHybridDecrypt;
 import com.google.crypto.tink.subtle.SubtleUtil;
@@ -75,7 +75,7 @@ public HybridDecrypt getPrimitive(MessageLite recipientKey) throws GeneralSecuri
     EciesAeadHkdfParams eciesParams = recipientKeyProto.getPublicKey().getParams();
     EciesHkdfKemParams kemParams = eciesParams.getKemParams();
 
-    ECPrivateKey recipientPrivateKey = Util.getEcPrivateKey(kemParams.getCurveType(),
+    ECPrivateKey recipientPrivateKey = EcUtil.getEcPrivateKey(kemParams.getCurveType(),
         recipientKeyProto.getKeyValue().toByteArray());
     EciesAeadHkdfDemHelper demHelper = new RegistryEciesAeadHkdfDemHelper(
         eciesParams.getDemParams().getAeadDem());
@@ -112,7 +112,7 @@ public MessageLite newKey(MessageLite keyFormat) throws GeneralSecurityException
     EciesAeadHkdfKeyFormat eciesKeyFormat = (EciesAeadHkdfKeyFormat) keyFormat;
     HybridUtil.validate(eciesKeyFormat.getParams());
     EciesHkdfKemParams kemParams = eciesKeyFormat.getParams().getKemParams();
-    KeyPair keyPair = Util.generateKeyPair(kemParams.getCurveType());
+    KeyPair keyPair = EcUtil.generateKeyPair(kemParams.getCurveType());
     ECPublicKey pubKey = (ECPublicKey) keyPair.getPublic();
     ECPrivateKey privKey = (ECPrivateKey) keyPair.getPrivate();
     ECPoint w = pubKey.getW();

File: java/src/main/java/com/google/crypto/tink/hybrid/EciesAeadHkdfPublicKeyManager.java
Patch:
@@ -22,7 +22,7 @@
 import com.google.crypto.tink.HybridEncrypt;
 import com.google.crypto.tink.KeyManager;
 import com.google.crypto.tink.TinkProto.KeyData;
-import com.google.crypto.tink.Util;
+import com.google.crypto.tink.subtle.EcUtil;
 import com.google.crypto.tink.subtle.EciesAeadHkdfDemHelper;
 import com.google.crypto.tink.subtle.EciesAeadHkdfHybridEncrypt;
 import com.google.crypto.tink.subtle.SubtleUtil;
@@ -69,7 +69,7 @@ public HybridEncrypt getPrimitive(MessageLite recipientKey) throws GeneralSecuri
     validate(recipientKeyProto);
     EciesAeadHkdfParams eciesParams = recipientKeyProto.getParams();
     EciesHkdfKemParams kemParams = eciesParams.getKemParams();
-    ECPublicKey recipientPublicKey = Util.getEcPublicKey(kemParams.getCurveType(),
+    ECPublicKey recipientPublicKey = EcUtil.getEcPublicKey(kemParams.getCurveType(),
         recipientKeyProto.getX().toByteArray(), recipientKeyProto.getY().toByteArray());
     EciesAeadHkdfDemHelper demHelper = new RegistryEciesAeadHkdfDemHelper(
         eciesParams.getDemParams().getAeadDem());

File: java/src/main/java/com/google/crypto/tink/signature/EcdsaSignKeyManager.java
Patch:
@@ -23,7 +23,7 @@
 import com.google.crypto.tink.KeyManager;
 import com.google.crypto.tink.PublicKeySign;
 import com.google.crypto.tink.TinkProto.KeyData;
-import com.google.crypto.tink.Util;
+import com.google.crypto.tink.subtle.EcUtil;
 import com.google.crypto.tink.subtle.EcdsaSignJce;
 import com.google.crypto.tink.subtle.SubtleUtil;
 import com.google.protobuf.ByteString;
@@ -77,7 +77,7 @@ public PublicKeySign getPrimitive(MessageLite key) throws GeneralSecurityExcepti
     }
     EcdsaPrivateKey keyProto = (EcdsaPrivateKey) key;
     validateKey(keyProto);
-    ECPrivateKey privateKey = Util.getEcPrivateKey(
+    ECPrivateKey privateKey = EcUtil.getEcPrivateKey(
         keyProto.getPublicKey().getParams().getCurve(),
         keyProto.getKeyValue().toByteArray());
     return new EcdsaSignJce(privateKey,
@@ -110,7 +110,7 @@ public MessageLite newKey(MessageLite keyFormat) throws GeneralSecurityException
     EcdsaKeyFormat format = (EcdsaKeyFormat) keyFormat;
     EcdsaParams ecdsaParams = format.getParams();
     SigUtil.validateEcdsaParams(ecdsaParams);
-    KeyPair keyPair = Util.generateKeyPair(ecdsaParams.getCurve());
+    KeyPair keyPair = EcUtil.generateKeyPair(ecdsaParams.getCurve());
     ECPublicKey pubKey = (ECPublicKey) keyPair.getPublic();
     ECPrivateKey privKey = (ECPrivateKey) keyPair.getPrivate();
     ECPoint w = pubKey.getW();

File: java/src/main/java/com/google/crypto/tink/signature/EcdsaVerifyKeyManager.java
Patch:
@@ -20,7 +20,7 @@
 import com.google.crypto.tink.KeyManager;
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.TinkProto.KeyData;
-import com.google.crypto.tink.Util;
+import com.google.crypto.tink.subtle.EcUtil;
 import com.google.crypto.tink.subtle.EcdsaVerifyJce;
 import com.google.crypto.tink.subtle.SubtleUtil;
 import com.google.protobuf.ByteString;
@@ -67,7 +67,7 @@ public PublicKeyVerify getPrimitive(MessageLite key) throws GeneralSecurityExcep
     }
     EcdsaPublicKey keyProto = (EcdsaPublicKey) key;
     validateKey(keyProto);
-    ECPublicKey publicKey = Util.getEcPublicKey(keyProto.getParams().getCurve(),
+    ECPublicKey publicKey = EcUtil.getEcPublicKey(keyProto.getParams().getCurve(),
         keyProto.getX().toByteArray(), keyProto.getY().toByteArray());
     return new EcdsaVerifyJce(publicKey,
         SigUtil.hashToEcdsaAlgorithmName(keyProto.getParams().getHashType()));

File: java/src/main/java/com/google/crypto/tink/signature/SignatureKeyTemplates.java
Patch:
@@ -18,10 +18,9 @@
 
 import com.google.crypto.tink.CommonProto.EllipticCurveType;
 import com.google.crypto.tink.CommonProto.HashType;
-import com.google.crypto.tink.EcdsaProto.EcdsaParams;
 import com.google.crypto.tink.EcdsaProto.EcdsaKeyFormat;
+import com.google.crypto.tink.EcdsaProto.EcdsaParams;
 import com.google.crypto.tink.EcdsaProto.EcdsaSignatureEncoding;
-
 import com.google.crypto.tink.TinkProto.KeyTemplate;
 
 /**

File: java/src/main/java/com/google/crypto/tink/subtle/EciesHkdfRecipientKem.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.crypto.tink.subtle;
 
+import com.google.crypto.tink.CommonProto.EcPointFormat;
 import java.security.GeneralSecurityException;
 import java.security.KeyFactory;
 import java.security.interfaces.ECPrivateKey;
@@ -36,7 +37,7 @@ public EciesHkdfRecipientKem(final ECPrivateKey recipientPrivateKey) {
   }
 
   public byte[] generateKey(byte[] kemBytes, String hmacAlgo, final byte[] hkdfSalt,
-     final byte[] hkdfInfo, int keySizeInBytes, EcUtil.PointFormat pointFormat)
+     final byte[] hkdfInfo, int keySizeInBytes, EcPointFormat pointFormat)
        throws GeneralSecurityException {
     ECParameterSpec spec = recipientPrivateKey.getParams();
     ECPoint ephemeralPublicPoint = EcUtil.ecPointDecode(spec.getCurve(), pointFormat, kemBytes);

File: java/src/main/java/com/google/crypto/tink/subtle/EciesHkdfSenderKem.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.crypto.tink.subtle;
 
+import com.google.crypto.tink.CommonProto.EcPointFormat;
 import com.google.errorprone.annotations.Immutable;
 import java.security.GeneralSecurityException;
 import java.security.KeyPair;
@@ -64,7 +65,7 @@ public EciesHkdfSenderKem(final ECPublicKey recipientPublicKey) {
   }
 
   public KemKey generateKey(String hmacAlgo, final byte[] hkdfSalt, final byte[] hkdfInfo,
-      int keySizeInBytes, EcUtil.PointFormat pointFormat) throws GeneralSecurityException {
+      int keySizeInBytes, EcPointFormat pointFormat) throws GeneralSecurityException {
     KeyPair ephemeralKeyPair = generateEphemeralKey();
     ECPublicKey ephemeralPublicKey = (ECPublicKey) ephemeralKeyPair.getPublic();
     ECPrivateKey ephemeralPrivateKey = (ECPrivateKey) ephemeralKeyPair.getPrivate();

File: java/src/test/java/com/google/crypto/tink/KeysetHandleTest.java
Patch:
@@ -27,11 +27,11 @@
 import com.google.crypto.tink.aead.AeadConfig;
 import com.google.crypto.tink.aead.AeadKeyTemplates;
 import com.google.crypto.tink.mac.MacKeyTemplates;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
 
 /**
  * Tests for KeysetHandle.

File: java/src/test/java/com/google/crypto/tink/TestUtil.java
Patch:
@@ -34,12 +34,9 @@
 import com.google.crypto.tink.EcdsaProto.EcdsaPrivateKey;
 import com.google.crypto.tink.EcdsaProto.EcdsaPublicKey;
 import com.google.crypto.tink.EcdsaProto.EcdsaSignatureEncoding;
-import com.google.crypto.tink.EciesAeadHkdfProto.EciesAeadDemParams;
-import com.google.crypto.tink.EciesAeadHkdfProto.EciesAeadHkdfKeyFormat;
 import com.google.crypto.tink.EciesAeadHkdfProto.EciesAeadHkdfParams;
 import com.google.crypto.tink.EciesAeadHkdfProto.EciesAeadHkdfPrivateKey;
 import com.google.crypto.tink.EciesAeadHkdfProto.EciesAeadHkdfPublicKey;
-import com.google.crypto.tink.EciesAeadHkdfProto.EciesHkdfKemParams;
 import com.google.crypto.tink.HmacProto.HmacKey;
 import com.google.crypto.tink.HmacProto.HmacParams;
 import com.google.crypto.tink.KmsEnvelopeProto.KmsEnvelopeAeadKey;

File: java/src/test/java/com/google/crypto/tink/hybrid/EciesAeadHkdfHybridDecryptTest.java
Patch:
@@ -25,9 +25,9 @@
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.HybridEncrypt;
 import com.google.crypto.tink.TinkProto.KeyTemplate;
-import com.google.crypto.tink.Util;
 import com.google.crypto.tink.aead.AeadConfig;
 import com.google.crypto.tink.aead.AeadKeyTemplates;
+import com.google.crypto.tink.subtle.EcUtil;
 import com.google.crypto.tink.subtle.EciesAeadHkdfHybridDecrypt;
 import com.google.crypto.tink.subtle.EciesAeadHkdfHybridEncrypt;
 import com.google.crypto.tink.subtle.Random;
@@ -53,7 +53,7 @@ public void setUp() throws GeneralSecurityException {
 
   @Test
   public void testModifyDecrypt() throws Exception {
-    ECParameterSpec spec = Util.getCurveSpec(EllipticCurveType.NIST_P256);
+    ECParameterSpec spec = EcUtil.getCurveSpec(EllipticCurveType.NIST_P256);
     KeyPairGenerator keyGen = KeyPairGenerator.getInstance("EC");
     keyGen.initialize(spec);
     KeyPair recipientKey = keyGen.generateKeyPair();

File: java/src/test/java/com/google/crypto/tink/hybrid/EciesAeadHkdfHybridEncryptTest.java
Patch:
@@ -25,9 +25,9 @@
 import com.google.crypto.tink.HybridDecrypt;
 import com.google.crypto.tink.HybridEncrypt;
 import com.google.crypto.tink.TinkProto.KeyTemplate;
-import com.google.crypto.tink.Util;
 import com.google.crypto.tink.aead.AeadConfig;
 import com.google.crypto.tink.aead.AeadKeyTemplates;
+import com.google.crypto.tink.subtle.EcUtil;
 import com.google.crypto.tink.subtle.EciesAeadHkdfHybridDecrypt;
 import com.google.crypto.tink.subtle.EciesAeadHkdfHybridEncrypt;
 import com.google.crypto.tink.subtle.Random;
@@ -57,7 +57,7 @@ public void setUp() throws GeneralSecurityException {
 
   @Test
   public void testBasicMultipleEncrypts() throws Exception {
-    ECParameterSpec spec = Util.getCurveSpec(EllipticCurveType.NIST_P256);
+    ECParameterSpec spec = EcUtil.getCurveSpec(EllipticCurveType.NIST_P256);
     KeyPairGenerator keyGen = KeyPairGenerator.getInstance("EC");
     keyGen.initialize(spec);
     KeyPair recipientKey = keyGen.generateKeyPair();

File: java/src/test/java/com/google/crypto/tink/signature/EcdsaSignKeyManagerTest.java
Patch:
@@ -31,7 +31,7 @@
 import com.google.crypto.tink.PublicKeyVerify;
 import com.google.crypto.tink.TestUtil;
 import com.google.crypto.tink.TinkProto.KeyTemplate;
-import com.google.crypto.tink.Util;
+import com.google.crypto.tink.subtle.EcUtil;
 import com.google.crypto.tink.subtle.Random;
 import com.google.protobuf.ByteString;
 import java.security.GeneralSecurityException;
@@ -220,7 +220,7 @@ public void testGetPrimitiveWithVerifier() throws Exception {
     for (int i = 0; i < hashAndCurves.length; i++) {
       HashType hashType = hashAndCurves[i].hashType;
       EllipticCurveType curveType = hashAndCurves[i].curveType;
-      ECParameterSpec ecParams = Util.getCurveSpec(curveType);
+      ECParameterSpec ecParams = EcUtil.getCurveSpec(curveType);
       KeyPairGenerator keyGen = KeyPairGenerator.getInstance("EC");
       keyGen.initialize(ecParams);
       KeyPair keyPair = keyGen.generateKeyPair();
@@ -256,7 +256,7 @@ public void testGetPrimitiveWithUnsupportedKey() throws Exception {
     for (int i = 0; i < hashAndCurves.length; i++) {
       HashType hashType = hashAndCurves[i].hashType;
       EllipticCurveType curveType = hashAndCurves[i].curveType;
-      ECParameterSpec ecParams = Util.getCurveSpec(curveType);
+      ECParameterSpec ecParams = EcUtil.getCurveSpec(curveType);
       KeyPairGenerator keyGen = KeyPairGenerator.getInstance("EC");
       keyGen.initialize(ecParams);
       KeyPair keyPair = keyGen.generateKeyPair();

File: java/src/test/java/com/google/crypto/tink/subtle/DjbCipherTest.java
Patch:
@@ -24,7 +24,6 @@
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.IntBuffer;
-import java.util.Arrays;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;

File: tools/tinkey/src/test/java/com/google/crypto/tink/tinkey/CreatePublicKeysetCommandTest.java
Patch:
@@ -29,7 +29,6 @@
 import com.google.crypto.tink.TinkProto.Keyset;
 import com.google.crypto.tink.TinkProto.OutputPrefixType;
 import com.google.crypto.tink.aead.AeadConfig;
-import com.google.crypto.tink.aead.AeadKeyTemplates;
 import com.google.crypto.tink.aead.GcpKmsAeadKeyManager;
 import com.google.crypto.tink.hybrid.EciesAeadHkdfPublicKeyManager;
 import com.google.crypto.tink.hybrid.HybridDecryptConfig;

File: tools/tinkey/src/test/java/com/google/crypto/tink/tinkey/TinkeyUtilTest.java
Patch:
@@ -29,12 +29,10 @@
 import com.google.crypto.tink.HybridEncrypt;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.Registry;
-import com.google.crypto.tink.TestUtil;
 import com.google.crypto.tink.TinkProto.KeyData;
 import com.google.crypto.tink.TinkProto.KeyTemplate;
 import com.google.crypto.tink.TinkProto.Keyset;
 import com.google.crypto.tink.aead.AeadConfig;
-import com.google.crypto.tink.aead.AeadKeyTemplates;
 import com.google.crypto.tink.aead.AesCtrHmacAeadKeyManager;
 import com.google.crypto.tink.aead.AesGcmKeyManager;
 import com.google.crypto.tink.hybrid.EciesAeadHkdfPublicKeyManager;

File: java/src/test/java/com/google/crypto/tink/subtle/ChaCha20Test.java
Patch:
@@ -28,7 +28,7 @@
  * Unit tests for ChaCha20.
  */
 @RunWith(JUnit4.class)
-public class ChaCha20Test extends DJBCipherTestBase<ChaCha20> {
+public class ChaCha20Test extends DjbCipherTestBase<ChaCha20> {
 
   private static ChaCha20 dummyCipher = new ChaCha20(new byte[32]);
 

File: java/src/test/java/com/google/crypto/tink/subtle/XSalsa20Test.java
Patch:
@@ -30,7 +30,7 @@
  * Unit tests for {@link XSalsa20}.
  */
 @RunWith(JUnit4.class)
-public class XSalsa20Test extends DJBCipherTestBase<XSalsa20> {
+public class XSalsa20Test extends DjbCipherTestBase<XSalsa20> {
 
   private static final XSalsa20 dummy = new XSalsa20(new byte[32]);
 
@@ -40,7 +40,7 @@ protected XSalsa20 createInstance(byte[] key) {
   }
 
   private static int[] matrix(int[] bytes) {
-    return DJBCipher.toIntArray(
+    return DjbCipher.toIntArray(
         ByteBuffer.wrap(twosCompByte(bytes)).order(ByteOrder.LITTLE_ENDIAN));
   }
 
@@ -74,7 +74,7 @@ private static void testSalsa20(int[] in, int[] output, int count) {
     ByteBuffer buf = ByteBuffer.allocate(64).order(ByteOrder.LITTLE_ENDIAN);
     for (int i = 0; i < count; i++) {
       buf.asIntBuffer().put(dummy.shuffleAdd(x));
-      x = DJBCipher.toIntArray(buf);
+      x = DjbCipher.toIntArray(buf);
     }
     Truth.assertThat(buf.array()).isEqualTo(twosCompByte(output));
   }

File: java/src/main/java/com/google/crypto/tink/aead/AeadKeyTemplates.java
Patch:
@@ -119,7 +119,7 @@ public final class AeadKeyTemplates {
    *   - HMAC hash function: SHA256
    */
   public static final KeyTemplate AES_128_CTR_128BITIV_HMAC_SHA256 =
-      createAesCtrHmacAeadKeyTemplate(32, 16, 32, 32, HashType.SHA256);
+      createAesCtrHmacAeadKeyTemplate(16, 16, 32, 32, HashType.SHA256);
 
   /**
    * A {@code KeyTemplate} that generates new instances of {@code AesCtrHmacAeadKey} with the

File: java/src/main/java/com/google/crypto/tink/mac/MacFactory.java
Patch:
@@ -21,8 +21,8 @@
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.Mac;
 import com.google.crypto.tink.PrimitiveSet;
-import com.google.crypto.tink.TinkProto.OutputPrefixType;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.TinkProto.OutputPrefixType;
 import com.google.crypto.tink.subtle.SubtleUtil;
 import java.security.GeneralSecurityException;
 import java.util.Arrays;

File: java/src/main/java/com/google/crypto/tink/signature/PublicKeySignFactory.java
Patch:
@@ -21,8 +21,8 @@
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PublicKeySign;
-import com.google.crypto.tink.TinkProto.OutputPrefixType;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.TinkProto.OutputPrefixType;
 import com.google.crypto.tink.subtle.SubtleUtil;
 import java.security.GeneralSecurityException;
 

File: java/src/main/java/com/google/crypto/tink/signature/PublicKeyVerifyFactory.java
Patch:
@@ -21,8 +21,8 @@
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.PrimitiveSet;
 import com.google.crypto.tink.PublicKeyVerify;
-import com.google.crypto.tink.TinkProto.OutputPrefixType;
 import com.google.crypto.tink.Registry;
+import com.google.crypto.tink.TinkProto.OutputPrefixType;
 import com.google.crypto.tink.subtle.SubtleUtil;
 import java.security.GeneralSecurityException;
 import java.util.Arrays;

File: java/src/test/java/com/google/crypto/tink/CleartextKeysetHandleTest.java
Patch:
@@ -19,7 +19,6 @@
 import static com.google.crypto.tink.TestUtil.assertExceptionContains;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.TinkProto.KeyTemplate;

File: java/src/test/java/com/google/crypto/tink/EncryptedKeysetHandleTest.java
Patch:
@@ -20,7 +20,6 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.TinkProto.EncryptedKeyset;

File: java/src/test/java/com/google/crypto/tink/NoSecretKeysetHandleTest.java
Patch:
@@ -18,7 +18,6 @@
 
 import static com.google.crypto.tink.TestUtil.assertExceptionContains;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.TinkProto.KeyData;

File: java/src/test/java/com/google/crypto/tink/PrimitiveSetTest.java
Patch:
@@ -20,7 +20,6 @@
 import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.TinkProto.KeyStatusType;

File: java/src/test/java/com/google/crypto/tink/UtilTest.java
Patch:
@@ -30,7 +30,6 @@
 import com.google.crypto.tink.TinkProto.OutputPrefixType;
 import com.google.crypto.tink.subtle.EcUtil;
 import java.math.BigInteger;
-import java.lang.AssertionError;
 import java.security.GeneralSecurityException;
 import java.security.spec.ECPoint;
 import java.security.spec.EllipticCurve;

File: java/src/test/java/com/google/crypto/tink/aead/AeadFactoryTest.java
Patch:
@@ -19,7 +19,6 @@
 import static com.google.crypto.tink.TestUtil.assertExceptionContains;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.Aead;

File: java/src/test/java/com/google/crypto/tink/aead/GcpKmsAeadKeyManagerTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.crypto.tink.aead;
 
-import com.google.crypto.tink.Aead;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.Registry;
 import com.google.crypto.tink.TestUtil;

File: java/src/test/java/com/google/crypto/tink/aead/KmsEnvelopeAeadKeyManagerTest.java
Patch:
@@ -18,7 +18,6 @@
 
 import static com.google.crypto.tink.TestUtil.assertExceptionContains;
 import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.Aead;

File: java/src/test/java/com/google/crypto/tink/signature/Ed25519PublicKeyManagerTest.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.crypto.tink.signature;
 
 import static com.google.crypto.tink.TestUtil.assertExceptionContains;
-import static junit.framework.Assert.assertTrue;
 import static junit.framework.Assert.fail;
 
 import com.google.crypto.tink.Ed25519Proto.Ed25519PrivateKey;

File: java/src/test/java/com/google/crypto/tink/signature/PublicKeyVerifyFactoryTest.java
Patch:
@@ -21,7 +21,6 @@
 import com.google.crypto.tink.CommonProto.EllipticCurveType;
 import com.google.crypto.tink.CommonProto.HashType;
 import com.google.crypto.tink.EcdsaProto.EcdsaPrivateKey;
-import com.google.crypto.tink.EcdsaProto.EcdsaPublicKey;
 import com.google.crypto.tink.EcdsaProto.EcdsaSignatureEncoding;
 import com.google.crypto.tink.KeysetHandle;
 import com.google.crypto.tink.PublicKeySign;

File: java/src/test/java/com/google/crypto/tink/subtle/SubtleUtilTest.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.crypto.tink.subtle;
 
 import static com.google.crypto.tink.TestUtil.assertExceptionContains;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import com.google.crypto.tink.TestUtil;

File: java/src/main/java/com/google/crypto/tink/CryptoFormat.java
Patch:
@@ -31,7 +31,7 @@ public final class CryptoFormat {
   public static final int NON_RAW_PREFIX_SIZE = 5;
 
   /**
-   * Legacy prefix starts with \x00 and followed by a 4-byte key id.
+   * Legacy or Crunchy prefix starts with \x00 and followed by a 4-byte key id.
    */
   public static final int LEGACY_PREFIX_SIZE = NON_RAW_PREFIX_SIZE;
   public static final byte LEGACY_START_BYTE = (byte) 0;
@@ -60,7 +60,8 @@ public final class CryptoFormat {
    */
   public static byte[] getOutputPrefix(Key key) throws GeneralSecurityException {
     switch (key.getOutputPrefixType()) {
-      case LEGACY:
+      case LEGACY: // fall through
+      case CRUNCHY:
         return ByteBuffer.allocate(LEGACY_PREFIX_SIZE)  // BIG_ENDIAN by default
             .put(LEGACY_START_BYTE)
             .putInt(key.getKeyId())

File: java/src/test/java/com/google/crypto/tink/CryptoFormatTest.java
Patch:
@@ -57,5 +57,6 @@ public void testPrefixWithWeirdKeyIds() throws Exception {
     testPrefix(OutputPrefixType.RAW, 0, -1, 2147483647 /* INT_MAX */, -2147483648 /* INT_MIN */);
     testPrefix(OutputPrefixType.TINK, 0, -1, 2147483647, -2147483648);
     testPrefix(OutputPrefixType.LEGACY, 0, -1, 2147483647, -2147483648);
+    testPrefix(OutputPrefixType.CRUNCHY, 0, -1, 2147483647, -2147483648);
   }
 }

File: java/src/main/java/com/google/crypto/tink/hybrid/EciesAeadHkdfHybridEncrypt.java
Patch:
@@ -33,7 +33,6 @@
  */
 class EciesAeadHkdfHybridEncrypt implements HybridEncrypt {
   private static final byte[] EMPTY_AAD = new byte[0];
-  private final ECPublicKey recipientPublicKey;
   private final EciesHkdfSenderKem senderKem;
   private final String hkdfHmacAlgo;
   private final byte[] hkdfSalt;
@@ -45,7 +44,6 @@ class EciesAeadHkdfHybridEncrypt implements HybridEncrypt {
       KeyTemplate aeadDemTemplate, EcPointFormat ecPointFormat)
       throws GeneralSecurityException {
     EcUtil.checkPublicKey(recipientPublicKey);
-    this.recipientPublicKey = recipientPublicKey;
     this.senderKem = new EciesHkdfSenderKem(recipientPublicKey);
     this.hkdfSalt = hkdfSalt;
     this.hkdfHmacAlgo = hkdfHmacAlgo;

File: tools/tinkey/src/main/java/com/google/crypto/tink/tinkey/Command.java
Patch:
@@ -21,4 +21,4 @@
  */
 public interface Command {
   public void run() throws Exception;
-}
\ No newline at end of file
+}

File: java/src/main/java/com/google/cloud/crypto/tink/PrimitiveSet.java
Patch:
@@ -50,7 +50,7 @@ public final class PrimitiveSet<P> {
    * A single entry in the set. In addition to the actual primitive it holds also
    * some extra information about the primitive.
    */
-  @Immutable(containerOf={"P"})
+  @Immutable(containerOf = {"P"})
   public final static class Entry<P> {
     // The actual primitive.
     private final P primitive;

File: java/src/test/java/com/google/cloud/crypto/tink/CleartextKeysetHandleTest.java
Patch:
@@ -62,7 +62,7 @@ public void testBasic() throws Exception {
     Keyset.Key key2 = keyset2.getKey(0);
     assertEquals(keyset2.getPrimaryKeyId(), key2.getKeyId());
     assertEquals(template.getTypeUrl(), key2.getKeyData().getTypeUrl());
-    Mac mac = MacFactory.getPrimitive(handle2);  // instantiation should succeed
+    Mac unused = MacFactory.getPrimitive(handle2);  // instantiation should succeed
   }
 
   @Test

File: java/src/test/java/com/google/cloud/crypto/tink/IntegrationTest.java
Patch:
@@ -33,9 +33,6 @@
  */
 @RunWith(JUnit4.class)
 public class IntegrationTest {
-  private static final int AES_KEY_SIZE = 16;
-  private static final int HMAC_KEY_SIZE = 20;
-
   @Before
   public void setUp() throws GeneralSecurityException {
     HybridEncryptFactory.registerStandardKeyTypes();

File: java/src/test/java/com/google/cloud/crypto/tink/KeysetManagerTest.java
Patch:
@@ -46,9 +46,6 @@
  */
 @RunWith(JUnit4.class)
 public class KeysetManagerTest {
-  private static final int AES_KEY_SIZE = 16;
-  private static final int HMAC_KEY_SIZE = 20;
-
   private String hmacKeyTypeUrl =
       HmacKeyManager.TYPE_URL;
 

File: java/src/main/java/com/google/cloud/crypto/tink/PrimitiveSet.java
Patch:
@@ -51,7 +51,7 @@ public final class PrimitiveSet<P> {
    * some extra information about the primitive.
    */
   @Immutable(containerOf={"P"})
-  public class Entry<P> {
+  public final static class Entry<P> {
     // The actual primitive.
     private final P primitive;
     // Identifies the primitive within the set.

File: java/src/main/java/com/google/cloud/crypto/tink/mac/MacFactory.java
Patch:
@@ -113,8 +113,8 @@ public void verifyMac(final byte[] mac, final byte[] data) throws GeneralSecurit
         byte[] prefix = Arrays.copyOfRange(mac, 0, CryptoFormat.NON_RAW_PREFIX_SIZE);
         byte[] macNoPrefix = Arrays.copyOfRange(mac, CryptoFormat.NON_RAW_PREFIX_SIZE,
               mac.length);
-        List<PrimitiveSet<Mac>.Entry<Mac>> entries = primitives.getPrimitive(prefix);
-        for (PrimitiveSet<Mac>.Entry<Mac> entry : entries) {
+        List<PrimitiveSet.Entry<Mac>> entries = primitives.getPrimitive(prefix);
+        for (PrimitiveSet.Entry<Mac> entry : entries) {
             try {
               entry.getPrimitive().verifyMac(macNoPrefix, data);
               // If there is no exception, the MAC is valid and we can return.
@@ -127,7 +127,7 @@ public void verifyMac(final byte[] mac, final byte[] data) throws GeneralSecurit
 
         // None "non-raw" key matched, so let's try the raw keys (if any exist).
         entries = primitives.getRawPrimitives();
-        for (PrimitiveSet<Mac>.Entry<Mac> entry : entries) {
+        for (PrimitiveSet.Entry<Mac> entry : entries) {
           try {
             entry.getPrimitive().verifyMac(mac, data);
             // If there is no exception, the MAC is valid and we can return.

File: java/src/main/java/com/google/cloud/crypto/tink/signature/PublicKeyVerifyFactory.java
Patch:
@@ -105,9 +105,9 @@ public void verify(final byte[] signature, final byte[] data)
         byte[] prefix = Arrays.copyOfRange(signature, 0, CryptoFormat.NON_RAW_PREFIX_SIZE);
         byte[] sigNoPrefix = Arrays.copyOfRange(signature, CryptoFormat.NON_RAW_PREFIX_SIZE,
             signature.length);
-        List<PrimitiveSet<PublicKeyVerify>.Entry<PublicKeyVerify>> entries =
+        List<PrimitiveSet.Entry<PublicKeyVerify>> entries =
             primitives.getPrimitive(prefix);
-        for (PrimitiveSet<PublicKeyVerify>.Entry<PublicKeyVerify> entry : entries) {
+        for (PrimitiveSet.Entry<PublicKeyVerify> entry : entries) {
           try {
             entry.getPrimitive().verify(sigNoPrefix, data);
             // If there is no exception, the signature is valid and we can return.
@@ -120,7 +120,7 @@ public void verify(final byte[] signature, final byte[] data)
 
         // None "non-raw" key matched, so let's try the raw keys (if any exist).
         entries = primitives.getRawPrimitives();
-        for (PrimitiveSet<PublicKeyVerify>.Entry<PublicKeyVerify> entry : entries) {
+        for (PrimitiveSet.Entry<PublicKeyVerify> entry : entries) {
           try {
             entry.getPrimitive().verify(signature, data);
             // If there is no exception, the signature is valid and we can return.

File: java/src/test/java/com/google/cloud/crypto/tink/RegistryTest.java
Patch:
@@ -309,9 +309,9 @@ public void testCustomKeyManagerHandling() throws Exception {
         .build());
     // Get a PrimitiveSet using registered key managers.
     PrimitiveSet<Aead> aeadSet = Registry.INSTANCE.getPrimitives(keysetHandle);
-    List<PrimitiveSet<Aead>.Entry<Aead>> aead1List =
+    List<PrimitiveSet.Entry<Aead>> aead1List =
         aeadSet.getPrimitive(keysetHandle.getKeyset().getKey(0));
-    List<PrimitiveSet<Aead>.Entry<Aead>> aead2List =
+    List<PrimitiveSet.Entry<Aead>> aead2List =
         aeadSet.getPrimitive(keysetHandle.getKeyset().getKey(1));
     assertEquals(1, aead1List.size());
     assertEquals(AesGcmJce.class, aead1List.get(0).getPrimitive().getClass());

File: java/src/main/java/com/google/cloud/crypto/tink/PrimitiveSet.java
Patch:
@@ -35,7 +35,7 @@
  * PrimitiveSet is an auxiliary class used for supporting key rotation: primitives in a set
  * correspond to keys in a keyset.  Users will usually work with primitive instances,
  * which essentially wrap primitive sets.  For example an instance of an Aead-primitive
- * for a given keyset holds a set of Aead-primitives corresponding to the keys in the keyset,
+ * for a given keyset holds a set of Aead-primitivies corresponding to the keys in the keyset,
  * and uses the set members to do the actual crypto operations: to encrypt data the primary
  * Aead-primitive from the set is used, and upon decryption the ciphertext's prefix
  * determines the id of the primitive from the set. <p>

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/Ed25519.java
Patch:
@@ -538,6 +538,7 @@ private static void select(CachedXYT t, int pos, byte b) {
    * Preconditions:
    * a[31] <= 127
    */
+  @SuppressWarnings("NarrowingCompoundAssignment")
   private static XYZ scalarMult(byte[] a) {
     byte[] e = new byte[2 * FIELD_LEN];
     for (int i = 0; i < FIELD_LEN; i++) {
@@ -601,8 +602,8 @@ static byte[] scalarMultToBytes(byte[] a) {
     return scalarMult(a).toBytes();
   }
 
+  @SuppressWarnings("NarrowingCompoundAssignment")
   private static byte[] slide(byte[] a) {
-
     byte[] r = new byte[256];
     // Writes each bit in a[0..31] into r[0..255]:
     // a = a[0]+256*a[1]+...+256^31*a[31] is equal to

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/Ed25519Constants.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.cloud.crypto.tink.subtle;
 
-import static com.google.cloud.crypto.tink.subtle.Ed25519.CachedXYT;
+import com.google.cloud.crypto.tink.subtle.Ed25519.CachedXYT;
 
 /**
  * Constants used in {@link Ed25519}.

File: java/src/main/java/com/google/cloud/crypto/tink/PrimitiveSet.java
Patch:
@@ -35,7 +35,7 @@
  * PrimitiveSet is an auxiliary class used for supporting key rotation: primitives in a set
  * correspond to keys in a keyset.  Users will usually work with primitive instances,
  * which essentially wrap primitive sets.  For example an instance of an Aead-primitive
- * for a given keyset holds a set of Aead-primitivies corresponding to the keys in the keyset,
+ * for a given keyset holds a set of Aead-primitives corresponding to the keys in the keyset,
  * and uses the set members to do the actual crypto operations: to encrypt data the primary
  * Aead-primitive from the set is used, and upon decryption the ciphertext's prefix
  * determines the id of the primitive from the set. <p>

File: examples/java/envelopeme/src/main/java/com/example/envelopeme/EnvelopeMeCommands.java
Patch:
@@ -53,7 +53,7 @@ static class Args {
 
     void validate() {
       try {
-        SubtleUtil.validateNotExist(outFile);
+        SubtleUtil.validateNotExists(outFile);
         SubtleUtil.validateExists(configFile);
         SubtleUtil.validateExists(credentialFile);
         SubtleUtil.validateExists(inFile);

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/SubtleUtil.java
Patch:
@@ -108,7 +108,7 @@ public static boolean isAndroid() {
   /*
    * @throws IOException if {@code f} exists.
    */
-  public static void validateNotExist(File f) throws IOException {
+  public static void validateNotExists(File f) throws IOException {
     if (f.exists()) {
       throw new IOException(
           String.format("%s exists, please choose another file\n", f.toString()));

File: tools/tinkey/src/main/java/com/google/cloud/crypto/tink/tinkey/InputStreamHandler.java
Patch:
@@ -45,7 +45,7 @@ public final int parseArguments(final Parameters params) throws CmdLineException
     final String token = params.getParameter(0);
     try {
       File inFile = Paths.get(token).toFile();
-      SubtleUtil.validateNotExist(inFile);
+      SubtleUtil.validateExists(inFile);
       setter.addValue(new FileInputStream(inFile));
     } catch (IOException e) {
       throw new CmdLineException(owner, e.getMessage(), e);

File: tools/tinkey/src/main/java/com/google/cloud/crypto/tink/tinkey/OutputStreamHandler.java
Patch:
@@ -45,7 +45,7 @@ public final int parseArguments(final Parameters params) throws CmdLineException
     final String token = params.getParameter(0);
     try {
       File outFile = Paths.get(token).toFile();
-      SubtleUtil.validateNotExist(outFile);
+      SubtleUtil.validateNotExists(outFile);
       setter.addValue(new FileOutputStream(outFile));
     } catch (IOException e) {
       throw new CmdLineException(owner, e.getMessage(), e);

File: java/src/main/java/com/google/cloud/crypto/tink/aead/GcpKmsAeadKeyManager.java
Patch:
@@ -36,7 +36,7 @@
 import java.security.GeneralSecurityException;
 
 /**
- * This key manager produces new instances of GcpKmsAead.
+ * This key manager produces new instances of {@code GcpKmsAead}.
  * Currently it doesn't support key generation. To use it one must
  * provide an implementation of {@code GcpCredentialFactory}.
  */

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/Ed25519.java
Patch:
@@ -24,7 +24,6 @@
 import static com.google.cloud.crypto.tink.subtle.Ed25519Constants.D2;
 import static com.google.cloud.crypto.tink.subtle.Ed25519Constants.SQRTM1;
 
-
 import com.google.common.base.Preconditions;
 import java.security.GeneralSecurityException;
 import java.security.MessageDigest;

File: java/src/test/java/com/google/cloud/crypto/tink/RegistryTest.java
Patch:
@@ -37,8 +37,8 @@
 import com.google.cloud.crypto.tink.TinkProto.OutputPrefixType;
 import com.google.cloud.crypto.tink.aead.AeadFactory;
 import com.google.cloud.crypto.tink.aead.AesGcmKeyManager;
-import com.google.cloud.crypto.tink.mac.MacFactory;
 import com.google.cloud.crypto.tink.mac.HmacKeyManager;
+import com.google.cloud.crypto.tink.mac.MacFactory;
 import com.google.cloud.crypto.tink.subtle.AesGcmJce;
 import com.google.cloud.crypto.tink.subtle.EncryptThenAuthenticate;
 import com.google.cloud.crypto.tink.subtle.MacJce;

File: java/src/test/java/com/google/cloud/crypto/tink/TestUtil.java
Patch:
@@ -56,7 +56,6 @@
 import com.google.cloud.crypto.tink.TinkProto.Keyset;
 import com.google.cloud.crypto.tink.TinkProto.Keyset.Key;
 import com.google.cloud.crypto.tink.TinkProto.OutputPrefixType;
-import com.google.cloud.crypto.tink.aead.AesCtrHmacAeadKeyManager;
 import com.google.cloud.crypto.tink.aead.AesEaxKeyManager;
 import com.google.cloud.crypto.tink.aead.AesGcmKeyManager;
 import com.google.cloud.crypto.tink.aead.GcpKmsAeadKeyManager;

File: tools/tinkey/src/main/java/com/google/cloud/crypto/tink/tinkey/AddRotateOptions.java
Patch:
@@ -15,6 +15,7 @@
 ////////////////////////////////////////////////////////////////////////////////
 
 package com.google.cloud.crypto.tink.tinkey;
+
 import com.google.cloud.crypto.tink.TinkProto.KeyTemplate;
 import org.kohsuke.args4j.Option;
 

File: tools/tinkey/src/main/java/com/google/cloud/crypto/tink/tinkey/ListCommand.java
Patch:
@@ -20,7 +20,6 @@
 import java.io.InputStream;
 import java.io.OutputStream;
 
-
 /**
  * List keys in a keyset.
  */

File: java/src/main/java/com/google/cloud/crypto/tink/aead/AesCtrKeyManager.java
Patch:
@@ -32,7 +32,7 @@
 class AesCtrKeyManager implements KeyManager<IndCpaCipher, AesCtrKey, AesCtrKeyFormat> {
   private static final int VERSION = 0;
 
-  private static final String AES_CTR_KEY_TYPE =
+  static final String TYPE_URL =
       "type.googleapis.com/google.cloud.crypto.tink.AesCtrKey";
 
   // In counter mode each message is encrypted with an initialization vector (IV) that must be
@@ -85,15 +85,15 @@ public AesCtrKey newKey(AesCtrKeyFormat format) throws GeneralSecurityException
   public KeyData newKeyData(ByteString serialized) throws GeneralSecurityException {
     AesCtrKey key = newKey(serialized);
     return KeyData.newBuilder()
-        .setTypeUrl(AES_CTR_KEY_TYPE)
+        .setTypeUrl(TYPE_URL)
         .setValue(key.toByteString())
         .setKeyMaterialType(KeyData.KeyMaterialType.SYMMETRIC)
         .build();
   }
 
   @Override
   public boolean doesSupport(String typeUrl) {
-    return typeUrl.equals(AES_CTR_KEY_TYPE);
+    return typeUrl.equals(TYPE_URL);
   }
 
   private void validate(AesCtrKey key) throws GeneralSecurityException {

File: java/src/main/java/com/google/cloud/crypto/tink/aead/GcpKmsAeadKeyManager.java
Patch:
@@ -40,11 +40,11 @@
  * Currently it doesn't support key generation. To use it one must
  * provide an implementation of {@code GcpCredentialFactory}.
  */
-public class GcpKmsAeadKeyManager
+public final class GcpKmsAeadKeyManager
     implements KeyManager<Aead, GcpKmsAeadKey, GcpKmsAeadKeyFormat> {
   private static final int VERSION = 0;
 
-  private static final String KEY_TYPE =
+  public static final String TYPE_URL =
       "type.googleapis.com/google.cloud.crypto.tink.GcpKmsAeadKey";
 
   private final GcpCredentialFactory credFactory;
@@ -91,7 +91,7 @@ public KeyData newKeyData(ByteString serialized) throws GeneralSecurityException
 
   @Override
   public boolean doesSupport(String typeUrl) {
-    return typeUrl.equals(KEY_TYPE);
+    return typeUrl.equals(TYPE_URL);
   }
 
   private CloudKMS createCloudKmsClient(GcpKmsAeadKey key) throws IOException {

File: java/src/main/java/com/google/cloud/crypto/tink/aead/KmsEnvelopeAead.java
Patch:
@@ -34,7 +34,7 @@
  *   - Encrypted DEK: variable length that is equal to the value specified in the last 4 bytes.
  *   - AEAD payload: variable length.
  */
-class KmsEnvelopeAead implements Aead {
+public final class KmsEnvelopeAead implements Aead {
   private static final byte[] EMPTY_AAD = new byte[0];
   private final KeyTemplate dekTemplate;
   private final Aead remote;

File: java/src/main/java/com/google/cloud/crypto/tink/hybrid/EciesAeadHkdfHybridDecrypt.java
Patch:
@@ -14,7 +14,7 @@
 //
 ////////////////////////////////////////////////////////////////////////////////
 
-package com.google.cloud.crypto.tink.hybrid; // instead of subtle, because it depends on KeyTemplate.
+package com.google.cloud.crypto.tink.hybrid; // not subtle, because it depends on KeyTemplate.
 
 import com.google.cloud.crypto.tink.Aead;
 import com.google.cloud.crypto.tink.CommonProto.EcPointFormat;
@@ -32,7 +32,7 @@
  * ECIES encryption with HKDF-KEM (key encapsulation mechanism) and
  * AEAD-DEM (data encapsulation mechanism).
  */
-public final class EciesAeadHkdfHybridDecrypt implements HybridDecrypt {
+class EciesAeadHkdfHybridDecrypt implements HybridDecrypt {
   private static final byte[] EMPTY_AAD = new byte[0];
   private final ECPrivateKey recipientPrivateKey;
   private final EciesHkdfRecipientKem recipientKem;
@@ -41,7 +41,7 @@ public final class EciesAeadHkdfHybridDecrypt implements HybridDecrypt {
   private final EcUtil.PointFormat ecPointFormat;
   private final EciesAeadHkdfAeadFactory aeadFactory;
 
-  public EciesAeadHkdfHybridDecrypt(final ECPrivateKey recipientPrivateKey,
+  EciesAeadHkdfHybridDecrypt(final ECPrivateKey recipientPrivateKey,
       final byte[] hkdfSalt, String hkdfHmacAlgo,
       KeyTemplate aeadDemTemplate, EcPointFormat ecPointFormat)
       throws GeneralSecurityException {

File: java/src/main/java/com/google/cloud/crypto/tink/hybrid/EciesAeadHkdfHybridEncrypt.java
Patch:
@@ -31,7 +31,7 @@
  * ECIES encryption with HKDF-KEM (key encapsulation mechanism) and
  * AEAD-DEM (data encapsulation mechanism).
  */
-public final class EciesAeadHkdfHybridEncrypt implements HybridEncrypt {
+class EciesAeadHkdfHybridEncrypt implements HybridEncrypt {
   private static final byte[] EMPTY_AAD = new byte[0];
   private final ECPublicKey recipientPublicKey;
   private final EciesHkdfSenderKem senderKem;
@@ -40,7 +40,7 @@ public final class EciesAeadHkdfHybridEncrypt implements HybridEncrypt {
   private final EcUtil.PointFormat ecPointFormat;
   private final EciesAeadHkdfAeadFactory aeadFactory;
 
-  public EciesAeadHkdfHybridEncrypt(final ECPublicKey recipientPublicKey,
+  EciesAeadHkdfHybridEncrypt(final ECPublicKey recipientPublicKey,
       final byte[] hkdfSalt, String hkdfHmacAlgo,
       KeyTemplate aeadDemTemplate, EcPointFormat ecPointFormat)
       throws GeneralSecurityException {

File: java/src/main/java/com/google/cloud/crypto/tink/hybrid/HybridDecryptFactory.java
Patch:
@@ -73,7 +73,7 @@ public final class HybridDecryptFactory {
    */
   public static void registerStandardKeyTypes() throws GeneralSecurityException {
     Registry.INSTANCE.registerKeyManager(
-        "type.googleapis.com/google.cloud.crypto.tink.EciesAeadHkdfPrivateKey",
+        EciesAeadHkdfPrivateKeyManager.TYPE_URL,
         new EciesAeadHkdfPrivateKeyManager());
   }
   /**

File: java/src/main/java/com/google/cloud/crypto/tink/hybrid/HybridEncryptFactory.java
Patch:
@@ -70,7 +70,7 @@ public final class HybridEncryptFactory {
    */
   public static void registerStandardKeyTypes() throws GeneralSecurityException {
     Registry.INSTANCE.registerKeyManager(
-        "type.googleapis.com/google.cloud.crypto.tink.EciesAeadHkdfPublicKey",
+        EciesAeadHkdfPublicKeyManager.TYPE_URL,
         new EciesAeadHkdfPublicKeyManager());
   }
   /**

File: java/src/main/java/com/google/cloud/crypto/tink/mac/HmacKeyManager.java
Patch:
@@ -31,11 +31,12 @@
 import java.security.GeneralSecurityException;
 import javax.crypto.spec.SecretKeySpec;
 
-final class HmacKeyManager implements KeyManager<Mac, HmacKey, HmacKeyFormat> {
+public final class HmacKeyManager implements KeyManager<Mac, HmacKey, HmacKeyFormat> {
+  HmacKeyManager() {}
   /**
    * Type url that this manager does support.
    */
-  static final String TYPE_URL = "type.googleapis.com/google.cloud.crypto.tink.HmacKey";
+  public static final String TYPE_URL = "type.googleapis.com/google.cloud.crypto.tink.HmacKey";
   /**
    * Current version of this key manager.
    * Keys with version equal or smaller are supported.

File: java/src/main/java/com/google/cloud/crypto/tink/mac/MacFactory.java
Patch:
@@ -64,7 +64,8 @@ public final class MacFactory {
    * @throws GeneralSecurityException
    */
   public static void registerStandardKeyTypes() throws GeneralSecurityException {
-      Registry.INSTANCE.registerKeyManager("type.googleapis.com/google.cloud.crypto.tink.HmacKey",
+      Registry.INSTANCE.registerKeyManager(
+          HmacKeyManager.TYPE_URL,
           new HmacKeyManager());
   }
 

File: java/src/main/java/com/google/cloud/crypto/tink/signature/PublicKeySignFactory.java
Patch:
@@ -58,7 +58,7 @@ public final class PublicKeySignFactory {
    */
   public static void registerStandardKeyTypes() throws GeneralSecurityException {
     Registry.INSTANCE.registerKeyManager(
-        "type.googleapis.com/google.cloud.crypto.tink.EcdsaPrivateKey",
+        EcdsaSignKeyManager.TYPE_URL,
         new EcdsaSignKeyManager());
   }
 

File: java/src/main/java/com/google/cloud/crypto/tink/signature/PublicKeyVerifyFactory.java
Patch:
@@ -63,7 +63,7 @@ public final class PublicKeyVerifyFactory {
    */
   public static void registerStandardKeyTypes() throws GeneralSecurityException {
     Registry.INSTANCE.registerKeyManager(
-        "type.googleapis.com/google.cloud.crypto.tink.EcdsaPublicKey",
+        EcdsaVerifyKeyManager.TYPE_URL,
         new EcdsaVerifyKeyManager());
   }
 

File: java/src/test/java/com/google/cloud/crypto/tink/IntegrationTest.java
Patch:
@@ -26,6 +26,7 @@
 import com.google.cloud.crypto.tink.EciesAeadHkdfProto.EciesAeadHkdfPrivateKey;
 import com.google.cloud.crypto.tink.TinkProto.KeyData;
 import com.google.cloud.crypto.tink.TinkProto.KeyTemplate;
+import com.google.cloud.crypto.tink.hybrid.EciesAeadHkdfPublicKeyManager;
 import com.google.cloud.crypto.tink.hybrid.HybridDecryptFactory;
 import com.google.cloud.crypto.tink.hybrid.HybridEncryptFactory;
 import com.google.cloud.crypto.tink.subtle.Random;
@@ -78,7 +79,7 @@ public void testExtractPublicKey() throws Exception {
     KeysetManager managerPublic = managerPrivate.transformToPublicKeyset();
     assertEquals(1, managerPublic.getKeysetHandle().getKeyset().getKeyCount());
     KeyData publicKeyData = managerPublic.getKeysetHandle().getKeyset().getKey(0).getKeyData();
-    assertEquals("type.googleapis.com/google.cloud.crypto.tink.EciesAeadHkdfPublicKey",
+    assertEquals(EciesAeadHkdfPublicKeyManager.TYPE_URL,
         publicKeyData.getTypeUrl());
     assertEquals(KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC, publicKeyData.getKeyMaterialType());
     assertArrayEquals(privateKey.getPublicKey().toByteArray(),

File: java/src/test/java/com/google/cloud/crypto/tink/aead/AesCtrHmacAeadKeyManagerTest.java
Patch:
@@ -74,7 +74,7 @@ public void testNewKeyMultipleTimes() throws Exception {
   public void testNewKeyWithCorruptedFormat() throws Exception {
     ByteString serialized = ByteString.copyFrom(new byte[128]);
     KeyTemplate keyTemplate = KeyTemplate.newBuilder()
-        .setTypeUrl("type.googleapis.com/google.cloud.crypto.tink.AesCtrHmacAeadKey")
+        .setTypeUrl(AesCtrHmacAeadKeyManager.TYPE_URL)
         .setValue(serialized)
         .build();
     AesCtrHmacAeadKeyManager keyManager = new AesCtrHmacAeadKeyManager();

File: java/src/test/java/com/google/cloud/crypto/tink/aead/AesCtrKeyManagerTest.java
Patch:
@@ -43,7 +43,7 @@ public void testNewKeyMultipleTimes() throws Exception {
         .build();
     ByteString serialized = ByteString.copyFrom(ctrKeyFormat.toByteArray());
     KeyTemplate keyTemplate = KeyTemplate.newBuilder()
-        .setTypeUrl("type.googleapis.com/google.cloud.crypto.tink.AesCtrKey")
+        .setTypeUrl(AesCtrKeyManager.TYPE_URL)
         .setValue(serialized)
         .build();
     AesCtrKeyManager keyManager = new AesCtrKeyManager();
@@ -71,7 +71,7 @@ public void testNewKeyMultipleTimes() throws Exception {
   public void testNewKeyWithCorruptedFormat() throws Exception {
     ByteString serialized = ByteString.copyFrom(new byte[128]);
     KeyTemplate keyTemplate = KeyTemplate.newBuilder()
-        .setTypeUrl("type.googleapis.com/google.cloud.crypto.tink.AesCtrKey")
+        .setTypeUrl(AesCtrKeyManager.TYPE_URL)
         .setValue(serialized)
         .build();
     AesCtrKeyManager keyManager = new AesCtrKeyManager();

File: java/src/test/java/com/google/cloud/crypto/tink/aead/AesEaxKeyManagerTest.java
Patch:
@@ -55,7 +55,7 @@ public void testNewKeyMultipleTimes() throws Exception {
         .build();
     ByteString serialized = ByteString.copyFrom(eaxKeyFormat.toByteArray());
     KeyTemplate keyTemplate = KeyTemplate.newBuilder()
-        .setTypeUrl("type.googleapis.com/google.cloud.crypto.tink.AesEaxKey")
+        .setTypeUrl(AesEaxKeyManager.TYPE_URL)
         .setValue(serialized)
         .build();
     AesEaxKeyManager keyManager = new AesEaxKeyManager();
@@ -83,7 +83,7 @@ public void testNewKeyMultipleTimes() throws Exception {
   public void testNewKeyWithCorruptedFormat() throws Exception {
     ByteString serialized = ByteString.copyFrom(new byte[128]);
     KeyTemplate keyTemplate = KeyTemplate.newBuilder()
-        .setTypeUrl("type.googleapis.com/google.cloud.crypto.tink.AesEaxKey")
+        .setTypeUrl(AesEaxKeyManager.TYPE_URL)
         .setValue(serialized)
         .build();
     AesEaxKeyManager keyManager = new AesEaxKeyManager();

File: java/src/test/java/com/google/cloud/crypto/tink/aead/AesGcmKeyManagerTest.java
Patch:
@@ -56,7 +56,7 @@ public void testNewKeyMultipleTimes() throws Exception {
         .build();
     ByteString serialized = ByteString.copyFrom(gcmKeyFormat.toByteArray());
     KeyTemplate keyTemplate = KeyTemplate.newBuilder()
-        .setTypeUrl("type.googleapis.com/google.cloud.crypto.tink.AesGcmKey")
+        .setTypeUrl(AesGcmKeyManager.TYPE_URL)
         .setValue(serialized)
         .build();
     AesGcmKeyManager keyManager = new AesGcmKeyManager();
@@ -84,7 +84,7 @@ public void testNewKeyMultipleTimes() throws Exception {
   public void testNewKeyWithCorruptedFormat() throws Exception {
     ByteString serialized = ByteString.copyFrom(new byte[128]);
     KeyTemplate keyTemplate = KeyTemplate.newBuilder()
-        .setTypeUrl("type.googleapis.com/google.cloud.crypto.tink.AesGcmKey")
+        .setTypeUrl(AesGcmKeyManager.TYPE_URL)
         .setValue(serialized)
         .build();
     AesGcmKeyManager keyManager = new AesGcmKeyManager();

File: java/src/test/java/com/google/cloud/crypto/tink/aead/GcpKmsAeadKeyManagerTest.java
Patch:
@@ -38,7 +38,7 @@ public class GcpKmsAeadKeyManagerTest {
   @Before
   public void setUp() throws GeneralSecurityException {
     Registry.INSTANCE.registerKeyManager(
-        "type.googleapis.com/google.cloud.crypto.tink.GcpKmsAeadKey",
+        GcpKmsAeadKeyManager.TYPE_URL,
         new GcpKmsAeadKeyManager(new ServiceAccountGcpCredentialFactory(
             TestUtil.SERVICE_ACCOUNT_FILE)));
   }

File: java/src/test/java/com/google/cloud/crypto/tink/aead/KmsEnvelopeAeadKeyManagerTest.java
Patch:
@@ -47,7 +47,7 @@ public class KmsEnvelopeAeadKeyManagerTest {
   public void setUp() throws GeneralSecurityException {
     AeadFactory.registerStandardKeyTypes();
     Registry.INSTANCE.registerKeyManager(
-        "type.googleapis.com/google.cloud.crypto.tink.GcpKmsAeadKey",
+        GcpKmsAeadKeyManager.TYPE_URL,
         new GcpKmsAeadKeyManager(new ServiceAccountGcpCredentialFactory(
             TestUtil.SERVICE_ACCOUNT_FILE)));
   }

File: java/src/test/java/com/google/cloud/crypto/tink/hybrid/EciesAeadHkdfPrivateKeyManagerTest.java
Patch:
@@ -75,15 +75,15 @@ public void testNewKey() throws Exception {
     Key primaryPriv = TestUtil.createKey(
         TestUtil.createKeyData(
             keyProto,
-            "type.googleapis.com/google.cloud.crypto.tink.EciesAeadHkdfPrivateKey",
+            EciesAeadHkdfPrivateKeyManager.TYPE_URL,
             KeyData.KeyMaterialType.ASYMMETRIC_PRIVATE),
         8,
         KeyStatusType.ENABLED,
         OutputPrefixType.RAW);
     Key primaryPub = TestUtil.createKey(
         TestUtil.createKeyData(
             keyProto.getPublicKey(),
-            "type.googleapis.com/google.cloud.crypto.tink.EciesAeadHkdfPublicKey",
+            EciesAeadHkdfPublicKeyManager.TYPE_URL,
             KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC),
         42,
         KeyStatusType.ENABLED,

File: java/src/test/java/com/google/cloud/crypto/tink/mac/HmacKeyManagerTest.java
Patch:
@@ -44,7 +44,7 @@ public void testNewKeyMultipleTimes() throws Exception {
         .build();
     ByteString serialized = ByteString.copyFrom(hmacKeyFormat.toByteArray());
     KeyTemplate keyTemplate = KeyTemplate.newBuilder()
-        .setTypeUrl("type.googleapis.com/google.cloud.crypto.tink.HmacKey")
+        .setTypeUrl(HmacKeyManager.TYPE_URL)
         .setValue(serialized)
         .build();
     // Calls newKey multiple times and make sure that we get different HmacKey each time.
@@ -71,7 +71,7 @@ public void testNewKeyCorruptedFormat() throws Exception {
     HmacKeyManager keyManager = new HmacKeyManager();
     ByteString serialized = ByteString.copyFrom(new byte[128]);
     KeyTemplate keyTemplate = KeyTemplate.newBuilder()
-        .setTypeUrl("type.googleapis.com/google.cloud.crypto.tink.HmacKey")
+        .setTypeUrl(HmacKeyManager.TYPE_URL)
         .setValue(serialized)
         .build();
     try {

File: java/src/test/java/com/google/cloud/crypto/tink/signature/EcdsaSignKeyManagerTest.java
Patch:
@@ -84,7 +84,7 @@ public void testNewKeyWithVerifier() throws Exception {
           .build();
       ByteString serializedFormat = ByteString.copyFrom(ecdsaFormat.toByteArray());
       KeyTemplate keyTemplate = KeyTemplate.newBuilder()
-          .setTypeUrl("type.googleapis.com/google.cloud.crypto.tink.EcdsaPrivateKey")
+          .setTypeUrl(EcdsaSignKeyManager.TYPE_URL)
           .setValue(serializedFormat)
           .build();
       // Call newKey multiple times and make sure that it generates different keys.
@@ -154,7 +154,7 @@ public void testNewKeyWithVerifier() throws Exception {
   public void testNewKeyWithCorruptedFormat() {
     ByteString serialized = ByteString.copyFrom(new byte[128]);
     KeyTemplate keyTemplate = KeyTemplate.newBuilder()
-        .setTypeUrl("type.googleapis.com/google.cloud.crypto.tink.EcdsaPrivateKey")
+        .setTypeUrl(EcdsaSignKeyManager.TYPE_URL)
         .setValue(serialized)
         .build();
     EcdsaSignKeyManager keyManager = new EcdsaSignKeyManager();

File: tools/tinkey/src/test/java/com/google/cloud/crypto/tink/tinkey/CreateKeyTemplateCommandTest.java
Patch:
@@ -23,6 +23,7 @@
 import com.google.cloud.crypto.tink.AesGcmProto.AesGcmKeyFormat;
 import com.google.cloud.crypto.tink.TinkProto.KeyTemplate;
 import com.google.cloud.crypto.tink.aead.AeadFactory;
+import com.google.cloud.crypto.tink.aead.AesGcmKeyManager;
 import com.google.cloud.crypto.tink.hybrid.HybridDecryptFactory;
 import com.google.cloud.crypto.tink.hybrid.HybridEncryptFactory;
 import com.google.cloud.crypto.tink.mac.MacFactory;
@@ -53,7 +54,7 @@ public void setUp() throws Exception {
   @Test
   public void testCreate() throws Exception {
     ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-    String typeUrl = "type.googleapis.com/google.cloud.crypto.tink.AesGcmKey";
+    String typeUrl = AesGcmKeyManager.TYPE_URL;
     String keyFormat = "key_size: 16";
     CreateKeyTemplateCommand.create(outputStream, typeUrl, keyFormat);
 
@@ -68,7 +69,7 @@ public void testCreate() throws Exception {
   @Test
   public void testCreateInvalid() throws Exception {
     ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-    String typeUrl = "type.googleapis.com/google.cloud.crypto.tink.AesGcmKey";
+    String typeUrl = AesGcmKeyManager.TYPE_URL;
     String keyFormat = "key_size: 17";
     try {
       CreateKeyTemplateCommand.create(outputStream, typeUrl, keyFormat);

File: tools/tinkey/src/test/java/com/google/cloud/crypto/tink/tinkey/CreatePublicKeysetCommandTest.java
Patch:
@@ -33,6 +33,7 @@
 import com.google.cloud.crypto.tink.TinkProto.OutputPrefixType;
 import com.google.cloud.crypto.tink.aead.AeadFactory;
 import com.google.cloud.crypto.tink.aead.GcpKmsAeadKeyManager;
+import com.google.cloud.crypto.tink.hybrid.EciesAeadHkdfPublicKeyManager;
 import com.google.cloud.crypto.tink.hybrid.HybridDecryptFactory;
 import com.google.cloud.crypto.tink.hybrid.HybridEncryptFactory;
 import com.google.cloud.crypto.tink.mac.MacFactory;
@@ -66,7 +67,7 @@ public void setUp() throws Exception {
     PublicKeyVerifyFactory.registerStandardKeyTypes();
 
     Registry.INSTANCE.registerKeyManager(
-        "type.googleapis.com/google.cloud.crypto.tink.GcpKmsAeadKey",
+        GcpKmsAeadKeyManager.TYPE_URL,
         new GcpKmsAeadKeyManager(
             new ServiceAccountGcpCredentialFactory(TestUtil.SERVICE_ACCOUNT_FILE)));
   }
@@ -117,7 +118,7 @@ public void testCreate() throws Exception {
     assertEquals(OutputPrefixType.TINK, publicKeyset.getKey(0).getOutputPrefixType());
 
     KeyData publicKeyData = publicKeyset.getKey(0).getKeyData();
-    assertEquals("type.googleapis.com/google.cloud.crypto.tink.EciesAeadHkdfPublicKey",
+    assertEquals(EciesAeadHkdfPublicKeyManager.TYPE_URL,
         publicKeyData.getTypeUrl());
     assertEquals(KeyData.KeyMaterialType.ASYMMETRIC_PUBLIC, publicKeyData.getKeyMaterialType());
     assertArrayEquals(privateKey.getPublicKey().toByteArray(),

File: java/src/main/java/com/google/cloud/crypto/tink/hybrid/EciesAeadHkdfHybridDecrypt.java
Patch:
@@ -17,8 +17,8 @@
 package com.google.cloud.crypto.tink.hybrid; // instead of subtle, because it depends on KeyTemplate.
 
 import com.google.cloud.crypto.tink.Aead;
-import com.google.cloud.crypto.tink.HybridDecrypt;
 import com.google.cloud.crypto.tink.CommonProto.EcPointFormat;
+import com.google.cloud.crypto.tink.HybridDecrypt;
 import com.google.cloud.crypto.tink.TinkProto.KeyTemplate;
 import com.google.cloud.crypto.tink.Util;
 import com.google.cloud.crypto.tink.subtle.EcUtil;

File: java/src/main/java/com/google/cloud/crypto/tink/hybrid/EciesAeadHkdfHybridEncrypt.java
Patch:
@@ -17,8 +17,8 @@
 package com.google.cloud.crypto.tink.hybrid; // instead of subtle, because it depends on KeyTemplate.
 
 import com.google.cloud.crypto.tink.Aead;
-import com.google.cloud.crypto.tink.HybridEncrypt;
 import com.google.cloud.crypto.tink.CommonProto.EcPointFormat;
+import com.google.cloud.crypto.tink.HybridEncrypt;
 import com.google.cloud.crypto.tink.TinkProto.KeyTemplate;
 import com.google.cloud.crypto.tink.Util;
 import com.google.cloud.crypto.tink.subtle.EcUtil;

File: java/src/test/java/com/google/cloud/crypto/tink/TestUtil.java
Patch:
@@ -59,7 +59,6 @@
 import com.google.cloud.crypto.tink.subtle.EcUtil;
 import com.google.cloud.crypto.tink.subtle.Random;
 import com.google.common.base.Optional;
-import com.google.common.util.concurrent.ListenableFuture;
 import com.google.protobuf.ByteString;
 import com.google.protobuf.MessageLite;
 import java.io.File;
@@ -72,8 +71,6 @@
 import java.security.interfaces.ECPublicKey;
 import java.security.spec.ECParameterSpec;
 import java.security.spec.ECPoint;
-import java.util.Arrays;
-import java.util.concurrent.ExecutionException;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 

File: java/src/test/java/com/google/cloud/crypto/tink/aead/AeadFactoryTest.java
Patch:
@@ -31,7 +31,6 @@
 import com.google.cloud.crypto.tink.subtle.Random;
 import java.security.GeneralSecurityException;
 import java.util.Arrays;
-import java.util.concurrent.ExecutionException;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: java/src/test/java/com/google/cloud/crypto/tink/subtle/AesEaxJceTest.java
Patch:
@@ -17,13 +17,11 @@
 package com.google.cloud.crypto.tink.subtle;
 
 import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import com.google.cloud.crypto.tink.TestUtil;
 import java.security.GeneralSecurityException;
 import java.util.Arrays;
-import java.util.concurrent.ExecutionException;
 import javax.crypto.AEADBadTagException;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: java/src/test/java/com/google/cloud/crypto/tink/subtle/AesGcmJceTest.java
Patch:
@@ -18,14 +18,12 @@
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import com.google.cloud.crypto.tink.TestUtil;
 import java.security.GeneralSecurityException;
 import java.util.Arrays;
 import java.util.HashSet;
-import java.util.concurrent.ExecutionException;
 import javax.crypto.AEADBadTagException;
 import org.junit.Test;
 import org.junit.runner.RunWith;

File: java/src/main/java/com/google/cloud/crypto/tink/KeysetManager.java
Patch:
@@ -25,9 +25,9 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.reflect.ClassPath;
 import com.google.common.reflect.ClassPath.ClassInfo;
+import com.google.protobuf.ByteString;
 import com.google.protobuf.InvalidProtocolBufferException;
 import com.google.protobuf.MessageLite;
-import com.google.protobuf.ByteString;
 import java.security.GeneralSecurityException;
 
 /**

File: java/src/test/java/com/google/cloud/crypto/tink/KeysetManagerTest.java
Patch:
@@ -35,9 +35,9 @@
 import com.google.cloud.crypto.tink.TinkProto.KeysetInfo;
 import com.google.cloud.crypto.tink.TinkProto.OutputPrefixType;
 import com.google.cloud.crypto.tink.aead.AeadFactory;
-import com.google.cloud.crypto.tink.mac.MacFactory;
 import com.google.cloud.crypto.tink.hybrid.HybridDecryptFactory;
 import com.google.cloud.crypto.tink.hybrid.HybridEncryptFactory;
+import com.google.cloud.crypto.tink.mac.MacFactory;
 import com.google.cloud.crypto.tink.subtle.Random;
 import java.security.GeneralSecurityException;
 import org.junit.Before;

File: tools/tinkey/src/main/java/com/google/cloud/crypto/tink/tinkey/TinkeyUtil.java
Patch:
@@ -23,10 +23,9 @@
 import com.google.api.client.json.jackson2.JacksonFactory;
 import com.google.api.services.cloudkms.v1.CloudKMS;
 import com.google.api.services.cloudkms.v1.CloudKMSScopes;
-import com.google.cloud.crypto.tink.GcpKmsProto.GcpKmsAeadKey;
 import com.google.cloud.crypto.tink.CleartextKeysetHandle;
+import com.google.cloud.crypto.tink.GcpKmsProto.GcpKmsAeadKey;
 import com.google.cloud.crypto.tink.KeysetHandle;
-import com.google.cloud.crypto.tink.KmsEncryptedKeysetHandle;
 import com.google.cloud.crypto.tink.Registry;
 import com.google.cloud.crypto.tink.TinkProto.KeyData;
 import com.google.cloud.crypto.tink.TinkProto.KeyTemplate;
@@ -43,7 +42,6 @@
 import com.google.protobuf.TextFormat;
 import java.io.ByteArrayInputStream;
 import java.io.File;
-import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;

File: java/src/main/java/com/google/cloud/crypto/tink/aead/GcpKmsAeadKeyManager.java
Patch:
@@ -103,7 +103,7 @@ private CloudKMS createCloudKmsClient(GcpKmsAeadKey key) throws IOException {
         .build();
   }
 
-  private void validate(GcpKmsAeadKey key) throws GeneralSecurityException {
+  private static void validate(GcpKmsAeadKey key) throws GeneralSecurityException {
     SubtleUtil.validateVersion(key.getVersion(), VERSION);
   }
 }

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/GcpScopes.java
Patch:
@@ -38,4 +38,4 @@ public static java.util.Set<String> all() {
 
   private GcpScopes() {
   }
-}
\ No newline at end of file
+}

File: java/src/test/java/com/google/cloud/crypto/tink/KmsEncryptedKeysetHandleTest.java
Patch:
@@ -83,7 +83,6 @@ public void testInvalidKeyset() throws Exception {
         .setKeyTemplate(template)
         .build()
         .rotate();
-    Keyset keyset = manager.getKeysetHandle().getKeyset();
 
     // Encrypt the keyset with an AeadKey.
     template = TestUtil.createAesGcmKeyTemplate(16 /* key size */);

File: java/src/test/java/com/google/cloud/crypto/tink/RegistryTest.java
Patch:
@@ -122,7 +122,8 @@ public void testKeyManagerRegistration() throws Exception {
         16 /* key size */, 16 /* tag size */, HashType.SHA256);
     HmacKey hmacKey = Registry.INSTANCE.newKey(template);
     try {
-      Aead aead = wrongType.getPrimitive(hmacKey);
+      Aead unused = wrongType.getPrimitive(hmacKey);
+      fail("Expected ClassCastException");
     } catch (ClassCastException e) {
       assertTrue(e.toString().contains(
           "MacJce cannot be cast to com.google.cloud.crypto.tink.Aead"));

File: java/src/test/java/com/google/cloud/crypto/tink/aead/GcpKmsAeadKeyManagerTest.java
Patch:
@@ -61,7 +61,7 @@ public void testGcpKmsKeyRestricted() throws Exception {
     GcpKmsAeadKeyManager customKeyManager =
         new GcpKmsAeadKeyManager(new ServiceAccountGcpCredentialFactory(
             TestUtil.SERVICE_ACCOUNT_FILE));
-    aead = AeadFactory.getPrimitive(keysetHandle);
+    aead = AeadFactory.getPrimitive(keysetHandle, customKeyManager);
     TestUtil.runBasicTests(aead);
   }
 }

File: java/src/test/java/com/google/cloud/crypto/tink/hybrid/HybridEncryptFactoryTest.java
Patch:
@@ -64,7 +64,6 @@ public void testBasicEncryption() throws Exception {
     KeyTemplate rawDemKeyTemplate = TestUtil.createAesGcmKeyTemplate(AES_KEY_SIZE);
     byte[] primarySalt = "some salt".getBytes("UTF-8");
     byte[] rawSalt = "other salt".getBytes("UTF-8");
-    byte[] legacySalt = "yet another salt".getBytes("UTF-8");
 
     EciesAeadHkdfPrivateKey primaryPrivProto = TestUtil.generateEciesAeadHkdfPrivKey(curve,
         hashType, primaryPointFormat, primaryDemKeyTemplate, primarySalt);

File: java/src/test/java/com/google/cloud/crypto/tink/subtle/Curve25519Test.java
Patch:
@@ -18,6 +18,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
 import com.google.cloud.crypto.tink.TestUtil;
 import org.junit.Test;
@@ -119,6 +120,7 @@ private static void x25519Helper(int privateKeyLen, int peersPublicValueLen, Str
     byte[] base = new byte[peersPublicValueLen]; base[0] = 9;
     try {
       Curve25519.x25519(privateKey, base);
+      fail("Expected IllegalArgumentException");
     } catch (IllegalArgumentException expected) {
       assertThat(expected).hasMessageThat().containsMatch(errorMsg);
     }
@@ -148,6 +150,7 @@ private static void x25519PublicFromPrivateHelper(int privateKeyLen, String erro
     byte[] privateKey = new byte[privateKeyLen];
     try {
       Curve25519.x25519PublicFromPrivate(privateKey);
+      fail("Expected IllegalArgumentException");
     } catch (IllegalArgumentException expected) {
       assertThat(expected).hasMessageThat().containsMatch(errorMsg);
     }

File: tools/tinkey/src/main/java/com/google/cloud/crypto/tink/tinkey/ChangeMasterKeyCommand.java
Patch:
@@ -40,4 +40,4 @@ public static void changeMasterKey(OutputStream outputStream, InputStream inputS
       throws Exception {
     throw new Exception("Not Implemented Yet");
   }
-}
\ No newline at end of file
+}

File: tools/tinkey/src/main/java/com/google/cloud/crypto/tink/tinkey/CreateCommand.java
Patch:
@@ -104,4 +104,4 @@ public static final KmsEncryptedKeyset createEncryptedKeysetWithAws(
       String awsKmsMasterKeyUriValue) throws Exception {
     throw new Exception("Not Implemented Yet");
   }
-}
\ No newline at end of file
+}

File: tools/tinkey/src/main/java/com/google/cloud/crypto/tink/tinkey/CreateKeyTemplateCommand.java
Patch:
@@ -44,4 +44,4 @@ public static void create(OutputStream outputStream, String typeUrlValue,
     outputStream.write(comment.getBytes("UTF-8"));
     TinkeyUtil.writeProto(keyTemplate, "TEXT" /* outFormat */, outputStream);
   }
-}
\ No newline at end of file
+}

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/GoogleCloudKmsAead.java
Patch:
@@ -58,7 +58,6 @@ public byte[] encrypt(final byte[] plaintext, final byte[] aad) throws GeneralSe
     } catch (IOException e) {
       throw new GeneralSecurityException("encryption failed", e);
     }
-
   }
 
   @Override

File: tools/tinkey/src/main/java/com/google/cloud/crypto/tink/tinkey/KeyIdOptions.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * Options for commands that take a key id option, e.g., enable, disable or destroy.
  */
-class KeyIdOptions extends ListOptions {
-   @Option(name = "--key-id", required = true, usage = "The target key id")
+class KeyIdOptions extends InOptions {
+  @Option(name = "--key-id", required = true, usage = "The target key id")
   int keyIdValue;
 }

File: tools/tinkey/src/main/java/com/google/cloud/crypto/tink/tinkey/TinkeyCommands.java
Patch:
@@ -32,9 +32,9 @@ class TinkeyCommands {
       @SubCommand(name = "change-master-key", impl = ChangeMasterKeyCommand.class),
       @SubCommand(name = "create", impl = CreateCommand.class),
       @SubCommand(name = "create-public-keyset", impl = CreatePublicKeysetCommand.class),
+      @SubCommand(name = "create-key-template", impl = CreateKeyTemplateCommand.class),
       @SubCommand(name = "destroy", impl = DestroyCommand.class),
       @SubCommand(name = "disable", impl = DisableCommand.class),
-      @SubCommand(name = "envelope", impl = EnvelopeCommand.class),
       @SubCommand(name = "enable", impl = EnableCommand.class),
       @SubCommand(name = "list", impl = ListCommand.class),
       @SubCommand(name = "rotate", impl = RotateCommand.class),

File: java/src/main/java/com/google/cloud/crypto/tink/Util.java
Patch:
@@ -36,8 +36,6 @@
 import java.security.spec.ECPoint;
 import java.security.spec.ECPrivateKeySpec;
 import java.security.spec.ECPublicKeySpec;
-import java.security.spec.EllipticCurve;
-import java.util.Arrays;
 
 /**
  * Various helpers.

File: java/src/main/java/com/google/cloud/crypto/tink/hybrid/EciesAeadHkdfHybridDecrypt.java
Patch:
@@ -25,7 +25,6 @@
 import com.google.cloud.crypto.tink.subtle.HybridDecryptBase;
 import java.security.GeneralSecurityException;
 import java.security.interfaces.ECPrivateKey;
-import java.security.spec.ECPoint;
 import java.security.spec.EllipticCurve;
 import java.util.Arrays;
 

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/Hkdf.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.cloud.crypto.tink.subtle;
 
 import java.security.GeneralSecurityException;
-import java.security.interfaces.ECPublicKey;
 import javax.crypto.Mac;
 import javax.crypto.spec.SecretKeySpec;
 

File: java/src/test/java/com/google/cloud/crypto/tink/KeysetManagerTest.java
Patch:
@@ -30,7 +30,6 @@
 import com.google.cloud.crypto.tink.TinkProto.Keyset;
 import com.google.cloud.crypto.tink.TinkProto.KeysetInfo;
 import com.google.cloud.crypto.tink.TinkProto.OutputPrefixType;
-import com.google.cloud.crypto.tink.TinkProto.KmsEncryptedKeyset;
 import com.google.cloud.crypto.tink.aead.AeadFactory;
 import com.google.cloud.crypto.tink.mac.MacFactory;
 import java.security.GeneralSecurityException;

File: java/src/test/java/com/google/cloud/crypto/tink/KmsEncryptedKeysetHandleTest.java
Patch:
@@ -28,7 +28,6 @@
 import com.google.cloud.crypto.tink.TinkProto.KmsEncryptedKeyset;
 import com.google.cloud.crypto.tink.aead.AeadFactory;
 import com.google.cloud.crypto.tink.mac.MacFactory;
-import com.google.cloud.crypto.tink.subtle.Random;
 import com.google.protobuf.ByteString;
 import java.security.GeneralSecurityException;
 import org.junit.Before;

File: java/src/test/java/com/google/cloud/crypto/tink/NoSecretKeysetHandleTest.java
Patch:
@@ -26,8 +26,6 @@
 import com.google.cloud.crypto.tink.TinkProto.Keyset;
 import com.google.cloud.crypto.tink.aead.AeadFactory;
 import com.google.cloud.crypto.tink.mac.MacFactory;
-import com.google.protobuf.ByteString;
-import com.google.protobuf.Message;
 import java.security.GeneralSecurityException;
 import org.junit.Before;
 import org.junit.Test;

File: java/src/test/java/com/google/cloud/crypto/tink/RegistryTest.java
Patch:
@@ -130,7 +130,8 @@ public void testKeyManagerRegistration() throws Exception {
 
     String badTypeUrl = "bad type URL";
     try {
-      KeyManager<Mac, MessageLite, MessageLite> unused = Registry.INSTANCE.getKeyManager(badTypeUrl);
+      KeyManager<Mac, MessageLite, MessageLite> unused =
+          Registry.INSTANCE.getKeyManager(badTypeUrl);
       fail("Expected GeneralSecurityException.");
     } catch (GeneralSecurityException e) {
       assertTrue(e.toString().contains("unsupported"));

File: java/src/test/java/com/google/cloud/crypto/tink/TestUtil.java
Patch:
@@ -57,12 +57,9 @@
 import com.google.cloud.crypto.tink.TinkProto.OutputPrefixType;
 import com.google.cloud.crypto.tink.subtle.EcUtil;
 import com.google.cloud.crypto.tink.subtle.Random;
-import com.google.cloud.crypto.tink.subtle.SubtleUtil;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.protobuf.ByteString;
 import com.google.protobuf.Message;
-import com.google.protobuf.TextFormat;
-import java.io.UnsupportedEncodingException;
 import java.security.GeneralSecurityException;
 import java.security.KeyPair;
 import java.security.KeyPairGenerator;

File: java/src/test/java/com/google/cloud/crypto/tink/UtilTest.java
Patch:
@@ -23,7 +23,6 @@
 
 import com.google.cloud.crypto.tink.CommonProto.EcPointFormat;
 import com.google.cloud.crypto.tink.CommonProto.EllipticCurveType;
-import com.google.cloud.crypto.tink.TinkProto.KeyData;
 import com.google.cloud.crypto.tink.TinkProto.KeyStatusType;
 import com.google.cloud.crypto.tink.TinkProto.Keyset;
 import com.google.cloud.crypto.tink.TinkProto.KeysetInfo;

File: java/src/test/java/com/google/cloud/crypto/tink/aead/AeadFactoryTest.java
Patch:
@@ -22,7 +22,6 @@
 import static org.junit.Assert.fail;
 
 import com.google.cloud.crypto.tink.Aead;
-import com.google.cloud.crypto.tink.AesCtrHmacAeadProto.AesCtrHmacAeadKey;
 import com.google.cloud.crypto.tink.CryptoFormat;
 import com.google.cloud.crypto.tink.KeysetHandle;
 import com.google.cloud.crypto.tink.TestUtil;

File: java/src/test/java/com/google/cloud/crypto/tink/aead/KmsEnvelopeAeadKeyManagerTest.java
Patch:
@@ -22,7 +22,6 @@
 
 import com.google.cloud.crypto.tink.Aead;
 import com.google.cloud.crypto.tink.KeysetHandle;
-import com.google.cloud.crypto.tink.KmsEnvelopeProto.KmsEnvelopeAeadKey;
 import com.google.cloud.crypto.tink.Registry;
 import com.google.cloud.crypto.tink.TestGoogleCredentialFactory;
 import com.google.cloud.crypto.tink.TestUtil;

File: java/src/test/java/com/google/cloud/crypto/tink/mac/MacFactoryTest.java
Patch:
@@ -21,7 +21,6 @@
 import static org.junit.Assert.assertEquals;
 
 import com.google.cloud.crypto.tink.CryptoFormat;
-import com.google.cloud.crypto.tink.HmacProto.HmacKey;
 import com.google.cloud.crypto.tink.KeysetHandle;
 import com.google.cloud.crypto.tink.Mac;
 import com.google.cloud.crypto.tink.TestUtil;

File: java/src/test/java/com/google/cloud/crypto/tink/subtle/Curve25519Test.java
Patch:
@@ -16,8 +16,8 @@
 
 package com.google.cloud.crypto.tink.subtle;
 
-import static org.junit.Assert.assertEquals;
 import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
 
 import com.google.cloud.crypto.tink.TestUtil;
 import org.junit.Test;

File: java/src/main/java/com/google/cloud/crypto/tink/KeysetManager.java
Patch:
@@ -125,10 +125,10 @@ public KeysetHandle getKeysetHandle() {
    */
   public KeysetHandle getKeysetHandle(Aead aead) throws GeneralSecurityException {
     Keyset keyset = keysetBuilder.build();
-    byte[] encryptedKeyset = aead.encrypt(keyset.toByteArray(), null /* aad */);
+    byte[] encryptedKeyset = aead.encrypt(keyset.toByteArray(), new byte[0] /* aad */);
     // Check if we can decrypt encryptedKeyset, to detect errors
     try {
-      byte[] cleartext = aead.decrypt(encryptedKeyset, null /* aad */);
+      byte[] cleartext = aead.decrypt(encryptedKeyset, new byte[0] /* aad */);
       Keyset keyset2 = Keyset.parseFrom(cleartext);
       if (!keyset2.equals(keyset)) {
         throw new GeneralSecurityException("encryption with KMS failed");

File: java/src/main/java/com/google/cloud/crypto/tink/KmsEncryptedKeysetHandle.java
Patch:
@@ -52,7 +52,7 @@ public static final KeysetHandle parseFrom(KmsEncryptedKeyset kmsEncryptedKeyset
     }
     Aead aead = Registry.INSTANCE.getPrimitive(kmsEncryptedKeyset.getKmsKey());
     try {
-      final Keyset keyset = Keyset.parseFrom(aead.decrypt(encryptedKeyset, null /* aad */));
+      final Keyset keyset = Keyset.parseFrom(aead.decrypt(encryptedKeyset, new byte[0] /* aad */));
       return new KeysetHandle(keyset, encryptedKeyset);
     } catch (InvalidProtocolBufferException e) {
       throw new GeneralSecurityException("invalid keyset, corrupted key material");

File: java/src/main/java/com/google/cloud/crypto/tink/aead/KmsEnvelopeAead.java
Patch:
@@ -49,8 +49,7 @@ class KmsEnvelopeAead extends AeadBase {
   @Override
   public byte[] encrypt(final byte[] plaintext, final byte[] aad) throws GeneralSecurityException {
     // Generate a new DEK.
-    byte[] dek = Registry.INSTANCE.newKey(
-        dekTemplate.getTypeUrl(), dekTemplate.getValue()).toByteArray();
+    byte[] dek = Registry.INSTANCE.newKey(dekTemplate).toByteArray();
     // Wrap it with remote.
     byte[] encryptedDek = remote.encrypt(dek, EMPTY_AAD);
     // Use DEK to encrypt plaintext.

File: java/src/test/java/com/google/cloud/crypto/tink/aead/AesCtrHmacAeadKeyManagerTest.java
Patch:
@@ -39,7 +39,7 @@
 public class AesCtrHmacAeadKeyManagerTest {
   @Test
   public void testNewKeyMultipleTimes() throws Exception {
-    KeyTemplate keyTemplate = TestUtil.createAesCtrHmacAeadKeyDataTemplate(16, 16, 32, 16);
+    KeyTemplate keyTemplate = TestUtil.createAesCtrHmacAeadKeyTemplate(16, 16, 32, 16);
     AesCtrHmacAeadKeyFormat aeadKeyFormat = AesCtrHmacAeadKeyFormat.parseFrom(
         keyTemplate.getValue().toByteArray());
     ByteString serialized = ByteString.copyFrom(aeadKeyFormat.toByteArray());

File: java/src/test/java/com/google/cloud/crypto/tink/aead/KmsEnvelopeAeadKeyManagerTest.java
Patch:
@@ -60,7 +60,7 @@ public void testGoogleCloudKmsKeyRestricted() throws Exception {
     int ivSize = 16;
     int hmacKeySize = 16;
     int tagSize = 16;
-    KeyTemplate dekTemplate = TestUtil.createAesCtrHmacAeadKeyDataTemplate(
+    KeyTemplate dekTemplate = TestUtil.createAesCtrHmacAeadKeyTemplate(
         aesKeySize, ivSize, hmacKeySize, tagSize);
     KeyData kmsKey = TestUtil.createGoogleCloudKmsAeadKeyData(TestGoogleCredentialFactory.RESTRICTED);
     KeysetHandle keysetHandle = TestUtil.createKeysetHandle(
@@ -81,7 +81,7 @@ public void testParsingInvalidCiphertexts() throws Exception {
     int ivSize = 16;
     int hmacKeySize = 16;
     int tagSize = 16;
-    KeyTemplate dekTemplate = TestUtil.createAesCtrHmacAeadKeyDataTemplate(
+    KeyTemplate dekTemplate = TestUtil.createAesCtrHmacAeadKeyTemplate(
         aesKeySize, ivSize, hmacKeySize, tagSize);
     KeyData kmsKey = TestUtil.createGoogleCloudKmsAeadKeyData(TestGoogleCredentialFactory.RESTRICTED);
     KeysetHandle keysetHandle = TestUtil.createKeysetHandle(

File: java/src/test/java/com/google/cloud/crypto/tink/hybrid/EciesAeadHkdfHybridDecryptTest.java
Patch:
@@ -62,8 +62,8 @@ public void testModifyDecrypt() throws Exception {
     String hmacAlgo = "HmacSha256";
 
     KeyTemplate[] keyTemplates = new KeyTemplate[] {
-      TestUtil.createAesCtrHmacAeadKeyDataTemplate(16, 16, 16, 16),
-      TestUtil.createAesGcmKeyDataTemplate(16)
+      TestUtil.createAesCtrHmacAeadKeyTemplate(16, 16, 16, 16),
+      TestUtil.createAesGcmKeyTemplate(16)
     };
     for (int i = 0; i < keyTemplates.length; i++) {
       HybridEncrypt hybridEncrypt = new EciesAeadHkdfHybridEncrypt(recipientPublicKey, salt,

File: java/src/test/java/com/google/cloud/crypto/tink/hybrid/EciesAeadHkdfHybridEncryptTest.java
Patch:
@@ -66,8 +66,8 @@ public void testBasicMultipleEncrypts() throws Exception {
     String hmacAlgo = "HmacSha256";
 
     KeyTemplate[] keyTemplates = new KeyTemplate[] {
-      TestUtil.createAesCtrHmacAeadKeyDataTemplate(16, 16, 16, 16),
-      TestUtil.createAesGcmKeyDataTemplate(16)
+      TestUtil.createAesCtrHmacAeadKeyTemplate(16, 16, 16, 16),
+      TestUtil.createAesGcmKeyTemplate(16)
     };
     for (int i = 0; i < keyTemplates.length; i++) {
       HybridEncrypt hybridEncrypt = new EciesAeadHkdfHybridEncrypt(recipientPublicKey, salt,

File: java/src/test/java/com/google/cloud/crypto/tink/hybrid/EciesAeadHkdfPrivateKeyManagerTest.java
Patch:
@@ -61,7 +61,7 @@ public void testNewKey() throws Exception {
     EllipticCurveType curve = EllipticCurveType.NIST_P384;
     HashType hashType = HashType.SHA256;
     EcPointFormat pointFormat = EcPointFormat.UNCOMPRESSED;
-    KeyTemplate demKeyTemplate = TestUtil.createAesCtrHmacAeadKeyDataTemplate(AES_KEY_SIZE, ivSize,
+    KeyTemplate demKeyTemplate = TestUtil.createAesCtrHmacAeadKeyTemplate(AES_KEY_SIZE, ivSize,
         HMAC_KEY_SIZE, tagSize);
     byte[] salt = "some salt".getBytes("UTF-8");
     EciesAeadHkdfParams params = TestUtil.createEciesAeadHkdfParams(curve, hashType, pointFormat,

File: java/src/test/java/com/google/cloud/crypto/tink/hybrid/HybridEncryptFactoryTest.java
Patch:
@@ -59,9 +59,9 @@ public void testBasicEncryption() throws Exception {
     HashType hashType = HashType.SHA256;
     EcPointFormat primaryPointFormat = EcPointFormat.UNCOMPRESSED;
     EcPointFormat rawPointFormat = EcPointFormat.COMPRESSED;
-    KeyTemplate primaryDemKeyTemplate = TestUtil.createAesCtrHmacAeadKeyDataTemplate(
+    KeyTemplate primaryDemKeyTemplate = TestUtil.createAesCtrHmacAeadKeyTemplate(
         AES_KEY_SIZE, ivSize, HMAC_KEY_SIZE, tagSize);
-    KeyTemplate rawDemKeyTemplate = TestUtil.createAesGcmKeyDataTemplate(AES_KEY_SIZE);
+    KeyTemplate rawDemKeyTemplate = TestUtil.createAesGcmKeyTemplate(AES_KEY_SIZE);
     byte[] primarySalt = "some salt".getBytes("UTF-8");
     byte[] rawSalt = "other salt".getBytes("UTF-8");
     byte[] legacySalt = "yet another salt".getBytes("UTF-8");

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/AesGcmJce.java
Patch:
@@ -36,7 +36,7 @@ public AesGcmJce(final byte[] key) {
     keySpec = new SecretKeySpec(key, "AES");
   }
 
-  private Cipher instance() throws GeneralSecurityException {
+  private static Cipher instance() throws GeneralSecurityException {
     return EngineFactory.CIPHER.getInstance("AES/GCM/NoPadding");
   }
 

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/Curve25519.java
Patch:
@@ -378,6 +378,7 @@ private static int gte(int a, int b) {
    *
    * On entry: |input_limbs[i]| < 2^26
    */
+  @SuppressWarnings("NarrowingCompoundAssignment")
   private static byte[] contract(long[] inputLimbs) {
     long[] input = Arrays.copyOf(inputLimbs, LIMB_CNT);
     for (int j = 0; j < 2; j++) {
@@ -735,6 +736,7 @@ private static void curveRecip(long[] out, long[] z) {
    * This does not affect security because, although we're throwing away entropy, a valid
    * implementation of x25519 should throw away the exact same bits anyway.
    */
+  @SuppressWarnings("NarrowingCompoundAssignment")
   public static byte[] generatePrivateKey() {
     byte[] privateKey = Random.randBytes(32);
 
@@ -752,6 +754,7 @@ public static byte[] generatePrivateKey() {
    * @param peersPublicValue 32-byte public value
    * @return the 32-byte shared key
    */
+  @SuppressWarnings("NarrowingCompoundAssignment")
   public static byte[] x25519(byte[] privateKey, byte[] peersPublicValue) {
     long[] x = new long[LIMB_CNT];
     long[] z = new long[LIMB_CNT + 1];

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/AesCtrJceCipher.java
Patch:
@@ -20,7 +20,7 @@
 import javax.crypto.Cipher;
 import javax.crypto.spec.IvParameterSpec;
 import javax.crypto.spec.SecretKeySpec;
-import com.google.cloud.crypto.tink.EngineFactory;
+
 /**
  * The primitive implements AES counter mode with random IVs, using JCE. It is safe against
  * chosen-plaintext attacks, but does not provide ciphertext integrity, thus is unsafe

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/EcdsaSignJce.java
Patch:
@@ -35,7 +35,7 @@ public EcdsaSignJce(final ECPrivateKey priv, String signatureAlgorithm) {
 
   @Override
   public byte[] sign(final byte[] data) throws GeneralSecurityException {
-    Signature signer = Signature.getInstance(signatureAlgorithm);
+    Signature signer = EngineFactory.SIGNATURE.getInstance(signatureAlgorithm);
     signer.initSign(privateKey);
     signer.update(data);
     return signer.sign();

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/EcdsaVerifyJce.java
Patch:
@@ -38,7 +38,7 @@ public EcdsaVerifyJce(final ECPublicKey pubKey, String signatureAlgorithm)
   @Override
   public void verify(final byte[] signature, final byte[] data)
       throws GeneralSecurityException {
-    Signature verifier = Signature.getInstance(signatureAlgorithm);
+    Signature verifier = EngineFactory.SIGNATURE.getInstance(signatureAlgorithm);
     verifier.initVerify(publicKey);
     verifier.update(data);
     boolean verified = false;

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/EciesHkdfRecipientKem.java
Patch:
@@ -40,7 +40,7 @@ public byte[] generateKey(final ECPoint ephemeralPublicPoint, String hmacAlgo,
       throws GeneralSecurityException {
     ECParameterSpec spec = recipientPrivateKey.getParams();
     ECPublicKeySpec publicKeySpec = new ECPublicKeySpec(ephemeralPublicPoint, spec);
-    KeyFactory kf = KeyFactory.getInstance("EC");
+    KeyFactory kf = EngineFactory.KEY_FACTORY.getInstance("EC");
     ECPublicKey ephemeralPublicKey = (ECPublicKey) kf.generatePublic(publicKeySpec);
     byte[] sharedSecret = getSharedSecret(ephemeralPublicKey);
     return Hkdf.computeEciesHkdfSymmetricKey(ephemeralPublicKey,
@@ -51,7 +51,7 @@ private byte[] getSharedSecret(final ECPublicKey publicKey)
       throws GeneralSecurityException {
     ECParameterSpec spec = recipientPrivateKey.getParams();
     EcUtil.checkPointOnCurve(publicKey.getW(), spec.getCurve());
-    KeyAgreement ka = KeyAgreement.getInstance("ECDH");
+    KeyAgreement ka = EngineFactory.KEY_AGREEMENT.getInstance("ECDH");
     ka.init(recipientPrivateKey);
     ka.doPhase(publicKey, true);
     return ka.generateSecret();

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/EciesHkdfSenderKem.java
Patch:
@@ -68,7 +68,7 @@ public KemKey generateKey(String hmacAlgo, final byte[] hkdfSalt, final byte[] h
   private KeyPair generateEphemeralKey()
       throws GeneralSecurityException {
     ECParameterSpec spec = recipientPublicKey.getParams();
-    KeyPairGenerator keyGen = KeyPairGenerator.getInstance("EC");
+    KeyPairGenerator keyGen = EngineFactory.KEY_PAIR_GENERATOR.getInstance("EC");
     keyGen.initialize(spec);
     return keyGen.generateKeyPair();
   }
@@ -78,7 +78,7 @@ private byte[] getSharedSecret(final ECPrivateKey senderPrivateKey)
     ECPoint publicPoint = recipientPublicKey.getW();
     ECParameterSpec spec = recipientPublicKey.getParams();
     EcUtil.checkPointOnCurve(publicPoint, spec.getCurve());
-    KeyAgreement ka = KeyAgreement.getInstance("ECDH");
+    KeyAgreement ka = EngineFactory.KEY_AGREEMENT.getInstance("ECDH");
     ka.init(senderPrivateKey);
     ka.doPhase(recipientPublicKey, true);
     return ka.generateSecret();

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/Hkdf.java
Patch:
@@ -46,7 +46,7 @@ public class Hkdf {
    */
   public static byte[] computeHkdf(String macAlgorithm, byte[] ikm, byte[] salt, byte[] info,
       int size) throws GeneralSecurityException {
-    Mac mac = Mac.getInstance(macAlgorithm);
+    Mac mac = EngineFactory.MAC.getInstance(macAlgorithm);
     if (size > 255 * mac.getMacLength()) {
       throw new GeneralSecurityException("size too large");
     }

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/MacJce.java
Patch:
@@ -18,7 +18,6 @@
 
 import com.google.cloud.crypto.tink.Mac;
 import java.security.GeneralSecurityException;
-import com.google.cloud.crypto.tink.EngineFactory;
 
 /**
  * Mac implementations in JCE.

File: java/src/test/java/com/google/cloud/crypto/tink/mac/HmacKeyManagerTest.java
Patch:
@@ -24,7 +24,6 @@
 import com.google.cloud.crypto.tink.HmacProto.HmacKeyFormat;
 import com.google.cloud.crypto.tink.HmacProto.HmacParams;
 import com.google.cloud.crypto.tink.TinkProto.KeyTemplate;
-import com.google.cloud.crypto.tink.subtle.Random;
 import com.google.protobuf.ByteString;
 import java.security.GeneralSecurityException;
 import java.util.Set;

File: java/src/test/java/com/google/cloud/crypto/tink/subtle/Curve25519Test.java
Patch:
@@ -108,7 +108,7 @@ public void testDHTestVectors() {
 
   @Test
   public void testGeneratePrivateKeyReturnsIntentionallyMalformedKeys() {
-    byte[] privateKey = Curve25519.GeneratePrivateKey();
+    byte[] privateKey = Curve25519.generatePrivateKey();
     assertEquals(7, privateKey[0] & 7);
     assertEquals(128, privateKey[31] & 192);
   }

File: java/src/main/java/com/google/cloud/crypto/tink/Util.java
Patch:
@@ -291,7 +291,6 @@ public static void validateKeyset(Keyset keyset) throws GeneralSecurityException
       throw new GeneralSecurityException("empty keyset");
     }
 
-    Keyset.Key first = keyset.getKey(0);
     int primaryKeyId = keyset.getPrimaryKeyId();
     boolean hasPrimaryKey = false;
     for (Keyset.Key key : keyset.getKeyList()) {

File: java/src/main/java/com/google/cloud/crypto/tink/signature/EcdsaVerifyKeyManager.java
Patch:
@@ -49,6 +49,7 @@ public PublicKeyVerify getPrimitive(ByteString serialized) throws GeneralSecurit
     }
   }
 
+  @Override
   public PublicKeyVerify getPrimitive(EcdsaPublicKey pubKey) throws GeneralSecurityException {
     validateKey(pubKey);
     ECPublicKey publicKey = Util.getEcPublicKey(pubKey.getParams().getCurve(),

File: java/src/test/java/com/google/cloud/crypto/tink/mac/HmacKeyManagerTest.java
Patch:
@@ -48,7 +48,6 @@ public void testNewKeyMultipleTimes() throws Exception {
         .setTypeUrl("type.googleapis.com/google.cloud.crypto.tink.HmacKey")
         .setValue(serialized)
         .build();
-    byte[] plaintext = Random.randBytes(123);
     // Calls newKey multiple times and make sure that we get different HmacKey each time.
     Set<String> keys = new TreeSet<String>();
     int numTests = 27;

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/AesCtrJceCipher.java
Patch:
@@ -20,7 +20,7 @@
 import javax.crypto.Cipher;
 import javax.crypto.spec.IvParameterSpec;
 import javax.crypto.spec.SecretKeySpec;
-
+import com.google.cloud.crypto.tink.EngineFactory;
 /**
  * The primitive implements AES counter mode with random IVs, using JCE. It is safe against
  * chosen-plaintext attacks, but does not provide ciphertext integrity, thus is unsafe
@@ -45,7 +45,7 @@ public final class AesCtrJceCipher implements IndCpaCipher {
 
   public AesCtrJceCipher(final byte[] key, int ivSize) throws GeneralSecurityException {
     this.keySpec = new SecretKeySpec(key, KEY_ALGORITHM);
-    this.blockSize = Cipher.getInstance(CIPHER_ALGORITHM).getBlockSize();
+    this.blockSize = EngineFactory.CIPHER.getInstance(CIPHER_ALGORITHM).getBlockSize();
     if (ivSize < MIN_IV_SIZE_IN_BYTES || ivSize > blockSize) {
       throw new GeneralSecurityException("invalid IV size");
     }
@@ -95,7 +95,7 @@ public byte[] decrypt(final byte[] ciphertext) throws GeneralSecurityException {
 
   private void doCtr(final byte[] input, int inputOffset, int inputLen, byte[] output,
       int outputOffset, final byte[] iv, boolean encrypt) throws GeneralSecurityException {
-    Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
+    Cipher cipher = EngineFactory.CIPHER.getInstance(CIPHER_ALGORITHM);
     // The counter is big-endian. The counter is composed of iv and (blockSize - ivSize) of zeros.
     byte[] counter = new byte[blockSize];
     System.arraycopy(iv, 0, counter, 0, ivSize);

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/MacJce.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.cloud.crypto.tink.Mac;
 import java.security.GeneralSecurityException;
+import com.google.cloud.crypto.tink.EngineFactory;
 
 /**
  * Mac implementations in JCE.
@@ -33,7 +34,7 @@ public MacJce(String algorithm, java.security.Key key, int digestSize)
     this.algorithm = algorithm;
     this.digestSize = digestSize;
     this.key = key;
-    this.mac = javax.crypto.Mac.getInstance(algorithm);
+    this.mac = EngineFactory.MAC.getInstance(algorithm);
     mac.init(key);
   }
 
@@ -45,7 +46,7 @@ public byte[] computeMac(final byte[] data) throws GeneralSecurityException {
       tmp = (javax.crypto.Mac) this.mac.clone();
     } catch (java.lang.CloneNotSupportedException ex) {
       // Unfortunately, the Mac interface in certain versions of Android is not clonable.
-      tmp = javax.crypto.Mac.getInstance(this.algorithm);
+      tmp = EngineFactory.MAC.getInstance(this.algorithm);
       tmp.init(this.key);
     }
     tmp.update(data);

File: tools/tinkey/src/main/java/com/google/cloud/crypto/tink/tinkey/EnvelopeCommand.java
Patch:
@@ -59,4 +59,5 @@ public static Keyset createKeyset(String dekTypeValue, String dekFormatValue,
         .rotate();
     return manager.getKeysetHandle().getKeyset();
   }
-}
\ No newline at end of file
+}
+

File: java/src/main/java/com/google/cloud/crypto/tink/CryptoFormat.java
Patch:
@@ -70,7 +70,7 @@ public static byte[] getOutputPrefix(Key key) throws GeneralSecurityException {
       case RAW:
         return RAW_PREFIX;
       default:
-        throw new GeneralSecurityException("invalid key");
+        throw new GeneralSecurityException("unknown output prefix type");
     }
   }
 }

File: java/src/main/java/com/google/cloud/crypto/tink/KmsEncryptedKeysetHandle.java
Patch:
@@ -48,14 +48,14 @@ public static final KeysetHandle parseFrom(KmsEncryptedKeyset kmsEncryptedKeyset
       throws GeneralSecurityException {
     byte[] encryptedKeyset = kmsEncryptedKeyset.getEncryptedKeyset().toByteArray();
     if (encryptedKeyset.length == 0 || !kmsEncryptedKeyset.hasKmsKey()) {
-      throw new GeneralSecurityException("invalid keyset");
+      throw new GeneralSecurityException("invalid keyset, needs encrypted key material");
     }
     Aead aead = Registry.INSTANCE.getPrimitive(kmsEncryptedKeyset.getKmsKey());
     try {
       final Keyset keyset = Keyset.parseFrom(aead.decrypt(encryptedKeyset, null /* aad */));
       return new KeysetHandle(keyset, encryptedKeyset);
     } catch (InvalidProtocolBufferException e) {
-      throw new GeneralSecurityException("invalid keyset");
+      throw new GeneralSecurityException("invalid keyset, corrupted key material");
     }
   }
 }

File: java/src/main/java/com/google/cloud/crypto/tink/NoSecretKeysetHandle.java
Patch:
@@ -60,7 +60,7 @@ private static void validate(Keyset keyset) throws GeneralSecurityException {
       if (key.getKeyData().getKeyMaterialType() == KeyData.KeyMaterialType.UNKNOWN_KEYMATERIAL
           || key.getKeyData().getKeyMaterialType() == KeyData.KeyMaterialType.SYMMETRIC
           || key.getKeyData().getKeyMaterialType() == KeyData.KeyMaterialType.ASYMMETRIC_PRIVATE) {
-        throw new GeneralSecurityException("Keyset contains secret key material");
+        throw new GeneralSecurityException("keyset contains secret key material");
       }
     }
   }

File: java/src/main/java/com/google/cloud/crypto/tink/Registry.java
Patch:
@@ -67,7 +67,7 @@ protected Registry() {}
   public <P, K extends MessageLite, F extends MessageLite> boolean registerKeyManager(
       String typeUrl, final KeyManager<P, K, F> manager) throws GeneralSecurityException {
     if (manager == null) {
-      throw new NullPointerException("Key manager must be non-null.");
+      throw new NullPointerException("key manager must be non-null.");
     }
     KeyManager<P, K, F> existing = keyManager.putIfAbsent(typeUrl, manager);
     if (existing == null) {
@@ -86,7 +86,7 @@ public <P, K extends MessageLite, F extends MessageLite> KeyManager<P, K, F> get
       String typeUrl) throws GeneralSecurityException {
     KeyManager<P, K, F> manager = keyManager.get(typeUrl);
     if (manager == null) {
-      throw new GeneralSecurityException("Unsupported key type: " + typeUrl);
+      throw new GeneralSecurityException("unsupported key type: " + typeUrl);
     }
     return manager;
   }

File: java/src/main/java/com/google/cloud/crypto/tink/aead/AesCtrHmacAeadKeyManager.java
Patch:
@@ -55,7 +55,7 @@ class AesCtrHmacAeadKeyManager
       Registry.INSTANCE.registerKeyManager(AES_CTR_KEY_TYPE, new AesCtrKeyManager());
       MacFactory.registerStandardKeyTypes();
     } catch (GeneralSecurityException e) {
-      logger.severe("Cannot register key managers: " + e);
+      logger.severe("cannot register key managers: " + e);
     }
   }
 
@@ -84,7 +84,7 @@ public AesCtrHmacAeadKey newKey(ByteString serialized) throws GeneralSecurityExc
       AesCtrHmacAeadKeyFormat format = AesCtrHmacAeadKeyFormat.parseFrom(serialized);
       return newKey(format);
     } catch (InvalidProtocolBufferException e) {
-      throw new GeneralSecurityException("cannot generate AesCtrHmacAead key");
+      throw new GeneralSecurityException("invalid AesCtrHmacAead key format", e);
     }
   }
 

File: java/src/main/java/com/google/cloud/crypto/tink/aead/AesCtrKeyManager.java
Patch:
@@ -51,7 +51,7 @@ public AesCtrJceCipher getPrimitive(ByteString serialized) throws GeneralSecurit
       AesCtrKey keyProto = AesCtrKey.parseFrom(serialized);
       return getPrimitive(keyProto);
     } catch (InvalidProtocolBufferException e) {
-      throw new GeneralSecurityException("Invalid AesCtr Key");
+      throw new GeneralSecurityException("invalid AesCtr Key");
     }
   }
 
@@ -68,7 +68,7 @@ public AesCtrKey newKey(ByteString serialized) throws GeneralSecurityException {
       AesCtrKeyFormat format = AesCtrKeyFormat.parseFrom(serialized);
       return newKey(format);
     } catch (InvalidProtocolBufferException e) {
-      throw new GeneralSecurityException(e);
+      throw new GeneralSecurityException("invalid AesCtr key format", e);
     }
   }
 

File: java/src/main/java/com/google/cloud/crypto/tink/aead/AesEaxKeyManager.java
Patch:
@@ -57,7 +57,7 @@ public AesEaxKey newKey(ByteString serialized) throws GeneralSecurityException {
       AesEaxKeyFormat format = AesEaxKeyFormat.parseFrom(serialized);
       return newKey(format);
     } catch (InvalidProtocolBufferException e) {
-      throw new GeneralSecurityException("cannot generate AesEax key");
+      throw new GeneralSecurityException("invalid AesEax key format", e);
     }
   }
 

File: java/src/main/java/com/google/cloud/crypto/tink/aead/AesGcmKeyManager.java
Patch:
@@ -57,7 +57,7 @@ public AesGcmKey newKey(ByteString serialized) throws GeneralSecurityException {
       AesGcmKeyFormat format = AesGcmKeyFormat.parseFrom(serialized);
       return newKey(format);
     } catch (InvalidProtocolBufferException e) {
-      throw new GeneralSecurityException("cannot generate AesGcm key");
+      throw new GeneralSecurityException("invalid AesGcm key format", e);
     }
   }
 

File: java/src/main/java/com/google/cloud/crypto/tink/aead/KmsEnvelopeAead.java
Patch:
@@ -82,7 +82,7 @@ public byte[] decrypt(final byte[] ciphertext, final byte[] aad)
     } catch (IndexOutOfBoundsException
              | BufferUnderflowException
              | NegativeArraySizeException e) {
-      throw new GeneralSecurityException("invalid ciphertext");
+      throw new GeneralSecurityException("invalid ciphertext", e);
     }
   }
 

File: java/src/main/java/com/google/cloud/crypto/tink/aead/KmsEnvelopeAeadKeyManager.java
Patch:
@@ -58,7 +58,7 @@ public KmsEnvelopeAeadKey newKey(ByteString serialized) throws GeneralSecurityEx
       KmsEnvelopeAeadKeyFormat format = KmsEnvelopeAeadKeyFormat.parseFrom(serialized);
       return newKey(format);
     } catch (InvalidProtocolBufferException e) {
-      throw new GeneralSecurityException(e);
+      throw new GeneralSecurityException("invalid KmsEnvelopeAead key format", e);
     }
   }
 

File: java/src/main/java/com/google/cloud/crypto/tink/hybrid/EciesAeadHkdfHybridDecrypt.java
Patch:
@@ -59,7 +59,7 @@ public byte[] decrypt(final byte[] ciphertext, final byte[] contextInfo)
     EllipticCurve curve = recipientPrivateKey.getParams().getCurve();
     int headerSize = Util.encodingSizeInBytes(curve, ecPointFormat);
     if (ciphertext.length < headerSize) {
-      throw new GeneralSecurityException("Ciphertext too short");
+      throw new GeneralSecurityException("ciphertext too short");
     }
     ECPoint ephemeralPublicPoint = Util.ecPointDecode(curve, ecPointFormat,
         Arrays.copyOfRange(ciphertext, 0, headerSize));

File: java/src/main/java/com/google/cloud/crypto/tink/hybrid/EciesAeadHkdfPrivateKeyManager.java
Patch:
@@ -47,7 +47,7 @@ public HybridDecrypt getPrimitive(ByteString proto) throws GeneralSecurityExcept
       EciesAeadHkdfPrivateKey recipientKeyProto = EciesAeadHkdfPrivateKey.parseFrom(proto);
       return getPrimitive(recipientKeyProto);
     } catch (InvalidProtocolBufferException e) {
-      throw new GeneralSecurityException("Invalid EciesAeadHkdfPrivateKey.");
+      throw new GeneralSecurityException("invalid EciesAeadHkdfPrivateKey.");
     }
   }
 
@@ -72,7 +72,7 @@ public EciesAeadHkdfPrivateKey newKey(ByteString serialized) throws GeneralSecur
       EciesAeadHkdfKeyFormat eciesKeyFormat = EciesAeadHkdfKeyFormat.parseFrom(serialized);
       return newKey(eciesKeyFormat);
     } catch (InvalidProtocolBufferException e) {
-      throw new GeneralSecurityException("Invalid EciesAeadHkdf key format");
+      throw new GeneralSecurityException("invalid EciesAeadHkdf key format", e);
     }
   }
 

File: java/src/main/java/com/google/cloud/crypto/tink/hybrid/EciesAeadHkdfPublicKeyManager.java
Patch:
@@ -43,7 +43,7 @@ public HybridEncrypt getPrimitive(ByteString serialized) throws GeneralSecurityE
       EciesAeadHkdfPublicKey recipientKeyProto = EciesAeadHkdfPublicKey.parseFrom(serialized);
       return getPrimitive(recipientKeyProto);
     } catch (InvalidProtocolBufferException e) {
-      throw new GeneralSecurityException("Invalid EciesAeadHkdfPublicKey.");
+      throw new GeneralSecurityException("invalid EciesAeadHkdfPublicKey.");
     }
   }
 

File: java/src/main/java/com/google/cloud/crypto/tink/hybrid/HybridDecryptFactory.java
Patch:
@@ -117,6 +117,7 @@ public byte[] decrypt(final byte[] ciphertext, final byte[] contextInfo)
             try {
               return entry.getPrimitive().decrypt(ciphertextNoPrefix, contextInfo);
             } catch (GeneralSecurityException e) {
+              logger.info("ciphertext prefix matches a key, but cannot decrypt: " + e.toString());
               continue;
             }
           }

File: java/src/main/java/com/google/cloud/crypto/tink/hybrid/HybridEncryptFactory.java
Patch:
@@ -62,7 +62,7 @@ public final class HybridEncryptFactory {
       AeadFactory.registerStandardKeyTypes();
       MacFactory.registerStandardKeyTypes();
     } catch (GeneralSecurityException e) {
-      logger.severe("Cannot register key managers: " + e);
+      logger.severe("cannot register key managers: " + e);
     }
   }
   /**

File: java/src/main/java/com/google/cloud/crypto/tink/hybrid/HybridUtil.java
Patch:
@@ -33,7 +33,7 @@ public static void validate(EciesAeadHkdfParams params) throws GeneralSecurityEx
     Util.getCurveSpec(params.getKemParams().getCurveType());
     Util.hashToHmacAlgorithmName(params.getKemParams().getHkdfHashType());
     if (params.getEcPointFormat() == EcPointFormat.UNKNOWN_FORMAT) {
-      throw new GeneralSecurityException("invalid EC point format");
+      throw new GeneralSecurityException("unknown EC point format");
     }
     // Check that we can generate new keys from the DEM AEAD key format.
     Registry.INSTANCE.newKey(params.getDemParams().getAeadDem());

File: java/src/main/java/com/google/cloud/crypto/tink/mac/HmacKeyManager.java
Patch:
@@ -74,7 +74,7 @@ public Mac getPrimitive(HmacKey keyProto) throws GeneralSecurityException {
       case SHA1 : return new MacJce("HMACSHA1", keySpec, tagSize);
       case SHA256 : return new MacJce("HMACSHA256", keySpec, tagSize);
       case SHA512 : return new MacJce("HMACSHA512", keySpec, tagSize);
-      default: throw new GeneralSecurityException("Unknown hash");
+      default: throw new GeneralSecurityException("unknown hash");
     }
   }
 
@@ -84,7 +84,7 @@ public HmacKey newKey(ByteString serialized) throws GeneralSecurityException {
       HmacKeyFormat format = HmacKeyFormat.parseFrom(serialized);
       return newKey(format);
     } catch (InvalidProtocolBufferException e) {
-      throw new GeneralSecurityException("cannot generate Hmac key");
+      throw new GeneralSecurityException("invalid Hmac key format", e);
     }
   }
 

File: java/src/main/java/com/google/cloud/crypto/tink/signature/EcdsaSignKeyManager.java
Patch:
@@ -55,7 +55,7 @@ public PublicKeySign getPrimitive(ByteString serialized) throws GeneralSecurityE
       EcdsaPrivateKey privKeyProto = EcdsaPrivateKey.parseFrom(serialized);
       return getPrimitive(privKeyProto);
     } catch (InvalidProtocolBufferException e) {
-      throw new GeneralSecurityException("Invalid Ecdsa private key");
+      throw new GeneralSecurityException("invalid Ecdsa private key");
     }
   }
 
@@ -75,7 +75,7 @@ public EcdsaPrivateKey newKey(ByteString serialized) throws GeneralSecurityExcep
       EcdsaKeyFormat ecdsaKeyFormat = EcdsaKeyFormat.parseFrom(serialized);
       return newKey(ecdsaKeyFormat);
     } catch (InvalidProtocolBufferException e) {
-      throw new GeneralSecurityException("Invalid Ecdsa key format");
+      throw new GeneralSecurityException("invalid Ecdsa key format", e);
     }
   }
 

File: java/src/main/java/com/google/cloud/crypto/tink/signature/SigUtil.java
Patch:
@@ -38,7 +38,7 @@ public static String hashToEcdsaAlgorithmName(HashType hash) throws NoSuchAlgori
       case SHA512:
         return "SHA512WithECDSA";
       default:
-        throw new NoSuchAlgorithmException("Hash unsupported for signature: " + hash);
+        throw new NoSuchAlgorithmException("hash unsupported for signature: " + hash);
     }
   }
 
@@ -57,7 +57,7 @@ public static void validateEcdsaParams(EcdsaParams params) throws GeneralSecurit
         break;
       // TODO(quannguyen): support other signature encodings.
       default:
-        throw new GeneralSecurityException("Unsupported signature encoding");
+        throw new GeneralSecurityException("unsupported signature encoding");
     }
     switch(curve) {
       case NIST_P256:

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/AesEaxJce.java
Patch:
@@ -58,7 +58,7 @@ public final class AesEaxJce extends AeadBase {
   @SuppressWarnings("InsecureCryptoUsage")
   public AesEaxJce(final byte[] key, int ivSizeInBytes) throws GeneralSecurityException {
     if (ivSizeInBytes != 12 && ivSizeInBytes != 16) {
-      throw new IllegalArgumentException("Iv size should be either 12 or 16 bytes");
+      throw new IllegalArgumentException("IV size should be either 12 or 16 bytes");
     }
     this.ivSizeInBytes = ivSizeInBytes;
     keySpec = new SecretKeySpec(key, "AES");
@@ -158,7 +158,7 @@ private byte[] omac(Cipher ecb, int tag, final byte[] data, int offset, int leng
   public byte[] encrypt(final byte[] plaintext, final byte[] aad) throws GeneralSecurityException {
     // Check that ciphertext is not longer than the max. size of a Java array.
     if (plaintext.length > Integer.MAX_VALUE - ivSizeInBytes - TAG_SIZE_IN_BYTES) {
-      throw new GeneralSecurityException("Plaintext too long");
+      throw new GeneralSecurityException("plaintext too long");
     }
     byte[] ciphertext = new byte[ivSizeInBytes + plaintext.length + TAG_SIZE_IN_BYTES];
     byte[] iv = Random.randBytes(ivSizeInBytes);

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/AesGcmJce.java
Patch:
@@ -47,7 +47,7 @@ public byte[] encrypt(final byte[] plaintext, final byte[] aad)
       throws GeneralSecurityException {
     // Check that ciphertext is not longer than the max. size of a Java array.
     if (plaintext.length > Integer.MAX_VALUE - IV_SIZE_IN_BYTES - TAG_SIZE_IN_BYTES) {
-      throw new GeneralSecurityException("Plaintext too long");
+      throw new GeneralSecurityException("plaintext too long");
     }
     byte[] ciphertext = new byte[IV_SIZE_IN_BYTES + plaintext.length + TAG_SIZE_IN_BYTES];
     byte[] iv = Random.randBytes(IV_SIZE_IN_BYTES);

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/EncryptThenAuthenticate.java
Patch:
@@ -75,7 +75,7 @@ public byte[] encrypt(final byte[] plaintext, final byte[] aad) throws GeneralSe
   public byte[] decrypt(final byte[] ciphertext, final byte[] aad)
       throws GeneralSecurityException {
     if (ciphertext.length < macLength) {
-      throw new GeneralSecurityException("Ciphertext too short");
+      throw new GeneralSecurityException("ciphertext too short");
     }
     byte[] rawCiphertext = Arrays.copyOfRange(ciphertext, 0, ciphertext.length - macLength);
     byte[] macValue = Arrays.copyOfRange(ciphertext, ciphertext.length - macLength,

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/GoogleCloudKmsAead.java
Patch:
@@ -56,7 +56,7 @@ public byte[] encrypt(final byte[] plaintext, final byte[] aad) throws GeneralSe
           .execute();
       return response.decodeCiphertext();
     } catch (IOException e) {
-      throw new GeneralSecurityException("decryption failed");
+      throw new GeneralSecurityException("encryption failed", e);
     }
 
   }
@@ -73,7 +73,7 @@ public byte[] decrypt(final byte[] ciphertext, final byte[] aad)
           .execute();
       return response.decodePlaintext();
     } catch (IOException e) {
-      throw new GeneralSecurityException("decryption failed");
+      throw new GeneralSecurityException("decryption failed", e);
     }
 
   }

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/MacJce.java
Patch:
@@ -50,7 +50,7 @@ public byte[] computeMac(final byte[] data) throws GeneralSecurityException {
   @Override
   public void verifyMac(final byte[] mac, final byte[] data) throws GeneralSecurityException {
     if (!SubtleUtil.arrayEquals(computeMac(data), mac)) {
-      throw new GeneralSecurityException("Invalid MAC");
+      throw new GeneralSecurityException("invalid MAC");
     }
   }
 };

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/SubtleUtil.java
Patch:
@@ -51,7 +51,7 @@ public static byte[] concat(byte[]... chunks) throws GeneralSecurityException {
     int length = 0;
     for (byte[] chunk : chunks) {
       if (length > Integer.MAX_VALUE - chunk.length) {
-        throw new GeneralSecurityException("Exceeded size limit");
+        throw new GeneralSecurityException("exceeded size limit");
       }
       length += chunk.length;
     }
@@ -82,7 +82,7 @@ public static void validateVersion(int candidate, int maxExpected)
     if (candidate < 0 || candidate > maxExpected) {
       throw new GeneralSecurityException(
           String.format(
-              "Key has version %d. Only keys with version in range [0..%d] are supported",
+              "key has version %d; only keys with version in range [0..%d] are supported",
               candidate,
               maxExpected));
     }

File: java/src/test/java/com/google/cloud/crypto/tink/NoSecretKeysetHandleTest.java
Patch:
@@ -94,7 +94,7 @@ public void testBasic() throws Exception {
       KeysetHandle unused = NoSecretKeysetHandle.parseFrom(keyset.toByteArray());
       fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
-      assertTrue(e.toString().contains("Keyset contains secret key material"));
+      assertTrue(e.toString().contains("keyset contains secret key material"));
     }
 
     KeyFormat format2 = KeyFormat.newBuilder().setTypeUrl(AEAD_TYPE_URL).build();

File: java/src/test/java/com/google/cloud/crypto/tink/PrimitiveSetTest.java
Patch:
@@ -223,7 +223,7 @@ public void testAddInvalidKey() throws Exception {
       pset.addPrimitive(new DummyMac1(), key1);
       fail("Expected GeneralSecurityException.");
     } catch (GeneralSecurityException e) {
-      assertTrue(e.toString().contains("invalid key"));
+      assertTrue(e.toString().contains("unknown output prefix type"));
     }
   }
 }

File: java/src/test/java/com/google/cloud/crypto/tink/RegistryTest.java
Patch:
@@ -246,7 +246,7 @@ public void testKeyManagerRegistration() throws Exception {
       KeyManager<Mac, Message, Message> unused = registry.getKeyManager(badTypeUrl);
       fail("Expected GeneralSecurityException.");
     } catch (GeneralSecurityException e) {
-      assertTrue(e.toString().contains("Unsupported"));
+      assertTrue(e.toString().contains("unsupported"));
       assertTrue(e.toString().contains(badTypeUrl));
     }
   }

File: java/src/main/java/com/google/cloud/crypto/tink/KeysetManager.java
Patch:
@@ -96,9 +96,9 @@ public KeysetManager rotate() throws GeneralSecurityException {
    */
   public KeysetManager rotate(KeyFormat keyFormat) throws GeneralSecurityException {
     KeyData keyData = Registry.INSTANCE.newKey(keyFormat);
-    int keyId = Random.randNonNegativeInt();
+    int keyId = Random.randPositiveInt();
     while (hasKeyWithKeyId(keyId)) {
-      keyId = Random.randNonNegativeInt();
+      keyId = Random.randPositiveInt();
     }
     Keyset.Key key = Keyset.Key.newBuilder()
         .setKeyData(keyData)

File: java/src/test/java/com/google/cloud/crypto/tink/aead/KmsEnvelopeAeadKeyManagerTest.java
Patch:
@@ -63,7 +63,7 @@ public void testGoogleCloudKmsKeyRestricted() throws Exception {
     KeyFormat dekFormat = TestUtil.createAesCtrHmacAeadKeyFormat(
         aesKeySize, ivSize, hmacKeySize, tagSize);
     KeyData kmsKey = TestUtil.createKeyData(TestUtil.createGoogleCloudKmsAeadKey(
-        TestGoogleCredentialFactory.RESTRICTED));
+        TestGoogleCredentialFactory.RESTRICTED), KeyData.KeyMaterialType.REMOTE);
     KmsEnvelopeAeadKey kmsEnvelopeAeadKey = TestUtil.createKmsEnvelopeAeadKey(kmsKey, dekFormat);
     KeysetHandle keysetHandle = TestUtil.createKeysetHandle(
         TestUtil.createKeyset(
@@ -83,7 +83,7 @@ public void testParsingInvalidCiphertexts() throws Exception {
     KeyFormat dekFormat = TestUtil.createAesCtrHmacAeadKeyFormat(
         aesKeySize, ivSize, hmacKeySize, tagSize);
     KeyData kmsKey = TestUtil.createKeyData(TestUtil.createGoogleCloudKmsAeadKey(
-        TestGoogleCredentialFactory.RESTRICTED));
+        TestGoogleCredentialFactory.RESTRICTED), KeyData.KeyMaterialType.REMOTE);
     KmsEnvelopeAeadKey kmsEnvelopeAeadKey = TestUtil.createKmsEnvelopeAeadKey(kmsKey, dekFormat);
     KeysetHandle keysetHandle = TestUtil.createKeysetHandle(
         TestUtil.createKeyset(

File: java/src/test/java/com/google/cloud/crypto/tink/CleartextKeysetHandleTest.java
Patch:
@@ -69,7 +69,7 @@ public void testInvalidKeyset() throws Exception {
     byte[] proto = keyset.toByteArray();
     proto[0] = (byte) ~proto[0];
     try {
-      KeysetHandle handle = CleartextKeysetHandle.parseFrom(proto);
+      KeysetHandle unused = CleartextKeysetHandle.parseFrom(proto);
       fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
       assertTrue(e.toString().contains("invalid keyset"));

File: java/src/test/java/com/google/cloud/crypto/tink/CleartextKeysetHandleTest.java
Patch:
@@ -74,15 +74,15 @@ public void testInvalidKeyset() throws Exception {
     byte[] proto = keyset.toByteArray();
     proto[0] = (byte) ~proto[0];
     try {
-      KeysetHandle handle = CleartextKeysetHandle.fromBinaryFormat(proto);
+      KeysetHandle unused = CleartextKeysetHandle.fromBinaryFormat(proto);
       fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
       assertTrue(e.toString().contains("invalid keyset"));
     }
 
     String str = TextFormat.printToUnicodeString(keyset);
     try {
-      KeysetHandle handle = CleartextKeysetHandle.fromTextFormat(str + "invalid");
+      KeysetHandle unused = CleartextKeysetHandle.fromTextFormat(str + "invalid");
       fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
       assertTrue(e.toString().contains("invalid keyset"));

File: java/src/test/java/com/google/cloud/crypto/tink/KeysetManagerTest.java
Patch:
@@ -111,6 +111,8 @@ public void testExistingKeyset() throws Exception {
     Keyset keyset2 = manager2.getKeysetHandle().getKeyset();
 
     assertEquals(2, keyset2.getKeyCount());
+    // The first key in two keysets should be the same.
+    assertEquals(keyset1.getKey(0), keyset2.getKey(0));
     // The new key is the primary key.
     assertEquals(keyset2.getPrimaryKeyId(), keyset2.getKey(1).getKeyId());
   }
@@ -131,7 +133,7 @@ public void testFaultyKms() throws Exception {
     FaultyAead faultyAead = Registry.INSTANCE.getPrimitive(Registry.INSTANCE.newKey(
         KeyFormat.newBuilder().setTypeUrl(faultyAeadTypeUrl).build()));
     try {
-      KeysetHandle keysetHandle = manager.getKeysetHandle(faultyAead);
+      KeysetHandle unused = manager.getKeysetHandle(faultyAead);
       fail("Expected GeneralSecurityException");
     } catch (GeneralSecurityException e) {
       assertTrue(e.toString().contains("encryption with KMS failed"));

File: java/src/test/java/com/google/cloud/crypto/tink/hybrid/EciesAeadHkdfHybridEncryptTest.java
Patch:
@@ -77,7 +77,7 @@ public void testBasicAesGcm() throws Exception {
         CONTEXT.getBytes("UTF-8"));
     byte[] decrypted = hybridDecrypt.decrypt(ciphertext, CONTEXT.getBytes("UTF-8"));
 
-    assertFalse(PLAINTEXT.equals(new String(ciphertext)));
-    assertEquals(PLAINTEXT, new String(decrypted));
+    assertFalse(PLAINTEXT.equals(new String(ciphertext, "UTF-8")));
+    assertEquals(PLAINTEXT, new String(decrypted, "UTF-8"));
   }
 }

File: java/src/main/java/com/google/cloud/crypto/tink/hybrid/EciesAeadHkdfPublicKeyManager.java
Patch:
@@ -66,6 +66,7 @@ public boolean doesSupport(String typeUrl) {
   private void validate(EciesAeadHkdfPublicKey key) throws GeneralSecurityException {
     // TODO(przydatek): add more checks.
     SubtleUtil.validateVersion(key.getVersion(), VERSION);
+    HybridUtil.validate(key.getParams());
   }
 
 }

File: java/src/test/java/com/google/cloud/crypto/tink/hybrid/HybridEncryptFactoryTest.java
Patch:
@@ -61,9 +61,9 @@ public void testBasicEncryption() throws Exception {
     KeyFormat primaryDemKeyFormat = TestUtil.createAesCtrHmacAeadKeyFormat(AES_KEY_SIZE, ivSize,
         HMAC_KEY_SIZE, tagSize);
     KeyFormat rawDemKeyFormat = TestUtil.createAesGcmKeyFormat(AES_KEY_SIZE);
-    byte[] primarySalt = "some salt".getBytes();
-    byte[] rawSalt = "other salt".getBytes();
-    byte[] legacySalt = "yet another salt".getBytes();
+    byte[] primarySalt = "some salt".getBytes("UTF-8");
+    byte[] rawSalt = "other salt".getBytes("UTF-8");
+    byte[] legacySalt = "yet another salt".getBytes("UTF-8");
 
     EciesAeadHkdfPrivateKey primaryPrivProto = TestUtil.generateEciesAeadHkdfPrivKey(curve,
         hashType, primaryPointFormat, primaryDemKeyFormat, primarySalt);

File: java/src/main/java/com/google/cloud/crypto/tink/hybrid/EciesAeadHkdfPrivateKeyManager.java
Patch:
@@ -45,6 +45,7 @@ public HybridDecrypt getPrimitive(Any proto) throws GeneralSecurityException {
           recipientKeyProto.getKeyValue().toByteArray());
       return new EciesAeadHkdfHybridDecrypt(recipientPrivateKey,
           kemParams.getHkdfSalt().toByteArray(),
+          Util.hashToHmacAlgorithmName(kemParams.getHkdfHashType()),
           recipientKeyProto.getPublicKey().getParams().getDemParams().getAeadDem(),
           recipientKeyProto.getPublicKey().getParams().getEcPointFormat());
     } catch (InvalidProtocolBufferException e) {

File: java/src/main/java/com/google/cloud/crypto/tink/hybrid/EciesAeadHkdfPublicKeyManager.java
Patch:
@@ -44,6 +44,7 @@ public HybridEncrypt getPrimitive(Any proto) throws GeneralSecurityException {
           recipientKeyProto.getX().toByteArray(), recipientKeyProto.getY().toByteArray());
       return new EciesAeadHkdfHybridEncrypt(recipientPublicKey,
           kemParams.getHkdfSalt().toByteArray(),
+          Util.hashToHmacAlgorithmName(kemParams.getHkdfHashType()),
           recipientKeyProto.getParams().getDemParams().getAeadDem(),
           recipientKeyProto.getParams().getEcPointFormat());
     } catch (InvalidProtocolBufferException e) {

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/EciesHkdfRecipientKem.java
Patch:
@@ -36,15 +36,15 @@ public EciesHkdfRecipientKem(final ECPrivateKey recipientPrivateKey) {
   }
 
   public byte[] generateKey(final ECPoint ephemeralPublicPoint, int keySizeInBytes,
-      final byte[] hkdfSalt, final byte[] hkdfInfo)
+      String hmacAlgo, final byte[] hkdfSalt, final byte[] hkdfInfo)
       throws GeneralSecurityException {
     ECParameterSpec spec = recipientPrivateKey.getParams();
     ECPublicKeySpec publicKeySpec = new ECPublicKeySpec(ephemeralPublicPoint, spec);
     KeyFactory kf = KeyFactory.getInstance("EC");
     ECPublicKey ephemeralPublicKey = (ECPublicKey) kf.generatePublic(publicKeySpec);
     byte[] sharedSecret = getSharedSecret(ephemeralPublicKey);
     return Hkdf.computeEciesHkdfSymmetricKey(ephemeralPublicKey,
-        sharedSecret, keySizeInBytes, hkdfSalt, hkdfInfo);
+        sharedSecret, keySizeInBytes, hmacAlgo, hkdfSalt, hkdfInfo);
   }
 
   private byte[] getSharedSecret(final ECPublicKey publicKey)

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/EciesHkdfSenderKem.java
Patch:
@@ -53,15 +53,16 @@ public EciesHkdfSenderKem(final ECPublicKey recipientPublicKey) {
     this.recipientPublicKey = recipientPublicKey;
   }
 
-  public KemKey generateKey(int keySizeInBytes, final byte[] hkdfSalt, final byte[] hkdfInfo)
+  public KemKey generateKey(int keySizeInBytes,
+      String hmacAlgo, final byte[] hkdfSalt, final byte[] hkdfInfo)
       throws GeneralSecurityException {
     KeyPair ephemeralKeyPair = generateEphemeralKey();
     ECPublicKey ephemeralPublicKey = (ECPublicKey) ephemeralKeyPair.getPublic();
     ECPrivateKey ephemeralPrivateKey = (ECPrivateKey) ephemeralKeyPair.getPrivate();
 
     byte[] sharedSecret = getSharedSecret(ephemeralPrivateKey);
     byte[] symmetricKey = Hkdf.computeEciesHkdfSymmetricKey(ephemeralPublicKey, sharedSecret,
-        keySizeInBytes, hkdfSalt, hkdfInfo);
+        keySizeInBytes, hmacAlgo, hkdfSalt, hkdfInfo);
     return new KemKey(ephemeralPublicKey, symmetricKey);
   }
 

File: java/src/main/java/com/google/cloud/crypto/tink/HybridEncrypt.java
Patch:
@@ -54,8 +54,7 @@ byte[] encrypt(final byte[] plaintext, final byte[] contextInfo)
    * Asynchronous encryption:
    * encrypts {@code plaintext} binding {@code contextInfo} to the resulting ciphertext.
    *
-   * @return resulting ciphertext.
+   * @return a {@code Future} that holds the resulting ciphertext.
    */
-  Future<byte[]> asyncEncrypt(final byte[] plaintext, final byte[] contextInfo)
-      throws GeneralSecurityException;
+  Future<byte[]> asyncEncrypt(final byte[] plaintext, final byte[] contextInfo);
 }

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/HybridDecryptBase.java
Patch:
@@ -31,8 +31,7 @@ public abstract byte[] decrypt(final byte[] ciphertext, final byte[] contextInfo
       throws GeneralSecurityException;
 
   @Override
-  public Future<byte[]> asyncDecrypt(final byte[] ciphertext, final byte[] contextInfo)
-      throws GeneralSecurityException {
+  public Future<byte[]> asyncDecrypt(final byte[] ciphertext, final byte[] contextInfo) {
     return Executors.newSingleThreadExecutor().submit(() -> decrypt(ciphertext, contextInfo));
   }
 }

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/HybridEncryptBase.java
Patch:
@@ -31,8 +31,7 @@ public abstract byte[] encrypt(final byte[] plaintext, final byte[] contextInfo)
       throws GeneralSecurityException;
 
   @Override
-  public Future<byte[]> asyncEncrypt(final byte[] plaintext, final byte[] contextInfo)
-      throws GeneralSecurityException {
+  public Future<byte[]> asyncEncrypt(final byte[] plaintext, final byte[] contextInfo) {
     return Executors.newSingleThreadExecutor().submit(() -> encrypt(plaintext, contextInfo));
   }
 }

File: java/src/test/java/com/google/cloud/crypto/tink/signature/EcdsaSignKeyManagerTest.java
Patch:
@@ -110,7 +110,7 @@ public void testNewKeyUnsupportedEncoding() throws Exception {
     EcdsaParams ecdsaParams = EcdsaParams.newBuilder()
         .setHashType(HashType.SHA256)
         .setCurve(EllipticCurveType.NIST_P256)
-        .setEncoding(EcdsaSignatureEncoding.RAW)
+        .setEncoding(EcdsaSignatureEncoding.IEEE_P1363)
         .build();
     EcdsaKeyFormat ecdsaFormat = EcdsaKeyFormat.newBuilder()
         .setParams(ecdsaParams)

File: java/src/test/java/com/google/cloud/crypto/tink/signature/EcdsaVerifyKeyManagerTest.java
Patch:
@@ -214,7 +214,8 @@ public void testGetPrimitiveWithUnsupportedEncoding() throws Exception {
     ECPoint w = pubKey.getW();
     try {
       PublicKeyVerify unusedVerifier = createVerifier(HashType.SHA256, EllipticCurveType.NIST_P256,
-          EcdsaSignatureEncoding.RAW, w.getAffineX().toByteArray(), w.getAffineY().toByteArray());
+          EcdsaSignatureEncoding.IEEE_P1363, w.getAffineX().toByteArray(),
+          w.getAffineY().toByteArray());
       fail("Unsupported encoding, should have thrown exception.");
     } catch (GeneralSecurityException expected) {
       // Expected

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/AesEaxJce.java
Patch:
@@ -198,7 +198,7 @@ public byte[] decrypt(final byte[] ciphertext, final byte[] aad)
     byte res = 0;
     int offset = ciphertext.length - TAG_SIZE_IN_BYTES;
     for (int i = 0; i < TAG_SIZE_IN_BYTES; i++) {
-      res = (byte) (res | ciphertext[offset + i] ^ h[i] ^ n[i] ^ t[i]);
+      res = (byte) (res | (ciphertext[offset + i] ^ h[i] ^ n[i] ^ t[i]));
     }
     if (res != 0) {
       throw new AEADBadTagException("tag mismatch");

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/AesGcmJce.java
Patch:
@@ -59,7 +59,8 @@ public byte[] encrypt(final byte[] plaintext, final byte[] aad)
     if (aad != null) {
       cipher.updateAAD(aad);
     }
-    int unusedWritten = cipher.doFinal(plaintext, 0, plaintext.length, ciphertext, IV_SIZE_IN_BYTES);
+    int unusedWritten = cipher.doFinal(plaintext, 0, plaintext.length, ciphertext,
+        IV_SIZE_IN_BYTES);
     return ciphertext;
   }
 

File: tools/tinkey/src/main/java/com/google/cloud/crypto/tink/tinkey/ChangeMasterKeyCommand.java
Patch:
@@ -27,8 +27,8 @@ public void run() throws Exception {
   }
 
   /**
-   * Reencrypts the keyset in {@code inFilename} using {@code newMasterKeyValue}, writes the resulting
-   * keyset to {@code outFilename}.
+   * Reencrypts the keyset in {@code inFilename} using {@code newMasterKeyValue}, writes the
+   * resulting keyset to {@code outFilename}.
    */
   public static void changeMasterKey(String outFilename, String inFilename,
       String credentialFilename, String newMasterKeyValue, String newCredentialFilename)

File: tools/tinkey/src/main/java/com/google/cloud/crypto/tink/tinkey/EnvelopeCommand.java
Patch:
@@ -18,8 +18,6 @@
 
 import com.google.cloud.crypto.tink.GoogleCloudKmsProto.GoogleCloudKmsAeadKey;
 import com.google.cloud.crypto.tink.KeysetManager;
-import com.google.cloud.crypto.tink.KmsEnvelopeProto.KmsEnvelopeAeadKeyFormat;
-import com.google.cloud.crypto.tink.KmsEnvelopeProto.KmsEnvelopeAeadParams;
 import com.google.cloud.crypto.tink.TinkProto.KeyFormat;
 import com.google.cloud.crypto.tink.TinkProto.Keyset;
 import com.google.protobuf.Any;

File: java/src/main/java/com/google/cloud/crypto/tink/KeysetManager.java
Patch:
@@ -21,7 +21,6 @@
 import com.google.cloud.crypto.tink.TinkProto.Keyset;
 import com.google.cloud.crypto.tink.TinkProto.OutputPrefixType;
 import com.google.cloud.crypto.tink.subtle.Random;
-
 import com.google.protobuf.Any;
 import com.google.protobuf.InvalidProtocolBufferException;
 import java.security.GeneralSecurityException;

File: java/src/main/java/com/google/cloud/crypto/tink/Mac.java
Patch:
@@ -34,7 +34,8 @@ public interface Mac {
   /**
    * Verifies whether {@code mac} is a correct authentication code (MAC) for {@code data}.
    *
-   * @return true iff {@code mac} is a correct MAC for {@code data}.
+   * @throws GeneralSecurityException If {@code mac} is not a correct MAC for {@code data} then a
+   * GeneralSecurityException is thrown.
    */
-  boolean verifyMac(final byte[] mac, final byte[] data) throws GeneralSecurityException;
+  void verifyMac(final byte[] mac, final byte[] data) throws GeneralSecurityException;
 }

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/EncryptThenAuthenticate.java
Patch:
@@ -82,9 +82,7 @@ public byte[] decrypt(final byte[] ciphertext, final byte[] aad)
         ciphertext.length);
     byte[] aadLengthInBits = Arrays.copyOf(
         ByteBuffer.allocate(8).putLong(8L * aad.length).array(), 8);
-    if (!mac.verifyMac(macValue, Util.concat(aad, rawCiphertext, aadLengthInBits))) {
-      throw new GeneralSecurityException("Mac verification failed");
-    }
+    mac.verifyMac(macValue, Util.concat(aad, rawCiphertext, aadLengthInBits));
     return cipher.decrypt(rawCiphertext);
   }
 }

File: java/src/test/java/com/google/cloud/crypto/tink/RegistryTest.java
Patch:
@@ -49,8 +49,8 @@ public byte[] computeMac(byte[] data) throws GeneralSecurityException {
       return label.getBytes();
     }
     @Override
-    public boolean verifyMac(byte[] mac, byte[] data) throws GeneralSecurityException {
-      return true;
+    public void verifyMac(byte[] mac, byte[] data) throws GeneralSecurityException {
+      return;
     }
   }
 

File: java/src/test/java/com/google/cloud/crypto/tink/TestUtil.java
Patch:
@@ -75,8 +75,8 @@ public byte[] computeMac(byte[] data) throws GeneralSecurityException {
       return data;
     }
     @Override
-    public boolean verifyMac(byte[] mac, byte[] data) throws GeneralSecurityException {
-      return true;
+    public void verifyMac(byte[] mac, byte[] data) throws GeneralSecurityException {
+      return;
     }
   }
 

File: java/src/test/java/com/google/cloud/crypto/tink/subtle/AesCtrJceCipherTest.java
Patch:
@@ -21,7 +21,6 @@
 import static org.junit.Assert.assertArrayEquals;
 
 import com.google.cloud.crypto.tink.TestUtil;
-
 import java.util.Arrays;
 import org.junit.Before;
 import org.junit.Test;

File: java/src/test/java/com/google/cloud/crypto/tink/subtle/AesGcmJceTest.java
Patch:
@@ -17,10 +17,9 @@
 package com.google.cloud.crypto.tink.subtle;
 
 import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.fail;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
-import com.google.cloud.crypto.tink.subtle.Random;
 import java.security.GeneralSecurityException;
 import java.util.Arrays;
 import java.util.concurrent.ExecutionException;

File: java/src/main/java/com/google/cloud/crypto/tink/PrimitiveSet.java
Patch:
@@ -128,7 +128,8 @@ protected void setPrimary(final Entry<P> primary) {
     * Creates an entry in the primitive table.
     * @return the added entry
     */
-  protected Entry<P> addPrimitive(final P primitive, Keyset.Key key) throws GeneralSecurityException {
+  protected Entry<P> addPrimitive(final P primitive, Keyset.Key key)
+      throws GeneralSecurityException {
     Entry<P> entry = new Entry<P>(primitive, CryptoFormat.getOutputPrefix(key), key.getStatus());
     List<Entry<P>> list = new ArrayList<Entry<P>>();
     list.add(entry);

File: java/src/main/java/com/google/cloud/crypto/tink/signature/EcdsaVerifyKeyManager.java
Patch:
@@ -34,7 +34,7 @@
 import java.security.spec.ECPublicKeySpec;
 
 final class EcdsaVerifyKeyManager implements KeyManager<PublicKeyVerify> {
-  final static String ECDSA_PUBLIC_KEY_TYPE =
+  private static final String ECDSA_PUBLIC_KEY_TYPE =
       "type.googleapis.com/google.cloud.crypto.tink.EcdsaPublicKey";
   /**
    * Current version of this key manager.

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/AesGcmJce.java
Patch:
@@ -29,6 +29,9 @@
 import javax.crypto.NoSuchPaddingException;
 import javax.crypto.spec.SecretKeySpec;
 
+/**
+ * This primitive implements AesGcm using JCE.
+ */
 public final class AesGcmJce implements Aead {
 
   // All instances of this class use a 12 byte IV and a 16 byte tag.

File: java/src/test/java/com/google/cloud/crypto/tink/aead/AesCtrHmacAeadKeyTest.java
Patch:
@@ -27,6 +27,9 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+/**
+ * Tests for AesCtrHmacAead and its key manager.
+ */
 @RunWith(JUnit4.class)
 public class AesCtrHmacAeadKeyTest {
 

File: java/src/test/java/com/google/cloud/crypto/tink/subtle/EncryptThenAuthenticateTest.java
Patch:
@@ -85,7 +85,7 @@ public RFCTestVector(String macKey, String encKey, String ciphertext, String aad
   public void testRFCVectors() throws Exception {
     for (int i = 0; i < rfcTestVectors.length; i++) {
       RFCTestVector t = rfcTestVectors[i];
-      if(Cipher.getMaxAllowedKeyLength("AES") < 256 && t.encKey.length > 16) {
+      if (Cipher.getMaxAllowedKeyLength("AES") < 256 && t.encKey.length > 16) {
           System.out.println("Unlimited Strength Jurisdiction Policy Files are required"
               + " but not installed. Skip tests with keys larger than 128 bits.");
           continue;

File: java/src/main/java/com/google/cloud/crypto/tink/CleartextKeysetHandle.java
Patch:
@@ -28,7 +28,7 @@
  */
 public final class CleartextKeysetHandle {
   /**
-   * @returns a new keyset handle from {@code proto} which is a Keyset protobuf in binary format.
+   * @return a new keyset handle from {@code proto} which is a Keyset protobuf in binary format.
    * @throws GeneralSecurityException
    */
   public static final KeysetHandle fromBinaryFormat(final byte[] proto)
@@ -42,7 +42,7 @@ public static final KeysetHandle fromBinaryFormat(final byte[] proto)
   }
 
   /**
-   * @returns a new keyset handle from {@code proto} which is a Keyset protobuf in text format.
+   * @return a new keyset handle from {@code proto} which is a Keyset protobuf in text format.
    * @throws GeneralSecurityException
    */
   public static final KeysetHandle fromTextFormat(String proto) throws GeneralSecurityException {
@@ -56,7 +56,7 @@ public static final KeysetHandle fromTextFormat(String proto) throws GeneralSecu
   }
 
   /**
-   * @returns a new keyset handle from {@code encryptedKeySet}.
+   * @return a new keyset handle from {@code encryptedKeySet}.
    * @throws GeneralSecurityException
    */
   public static final KeysetHandle fromProto(Keyset keyset)

File: java/src/main/java/com/google/cloud/crypto/tink/KeyManager.java
Patch:
@@ -31,7 +31,7 @@ public interface KeyManager<Primitive> {
   /**
    * Constructs an instance of Primitive for the key given in {@code proto}.
    *
-   * @returns the new constructed Primitive.
+   * @return the new constructed Primitive.
    * @throws GeneralSecurityException if the key given in {@code proto} is corrupted
    *         or not supported.
    */
@@ -40,13 +40,13 @@ public interface KeyManager<Primitive> {
   /**
    * Generates a new key according to specification in {@code keyFormat}.
    *
-   * @returns the new generated key.
+   * @return the new generated key.
    * @throws GeneralSecurityException if the specified format is wrong or not supported.
    */
   Any newKey(KeyFormat keyFormat) throws GeneralSecurityException;
 
   /**
-   * @returns true iff this KeyManager supports key type identified by {@code typeUrl}.
+   * @return true iff this KeyManager supports key type identified by {@code typeUrl}.
    */
   boolean doesSupport(String typeUrl);
 }

File: java/src/main/java/com/google/cloud/crypto/tink/KeysetHandle.java
Patch:
@@ -56,21 +56,21 @@ public final class KeysetHandle {
   }
 
   /**
-   * @returns the actual keyset data.
+   * @return the actual keyset data.
    */
   public Keyset getKeyset() {
     return keyset;
   }
 
   /**
-   * @returns the actual keyset data.
+   * @return the actual keyset data.
    */
   public KeysetInfo getKeysetInfo() {
     return Util.getKeysetInfo(keyset);
   }
 
   /**
-   * @returns the actual keyset data.
+   * @return the actual keyset data.
    */
   public byte[] getEncryptedKeyset() {
     return encryptedKeyset;

File: java/src/main/java/com/google/cloud/crypto/tink/KeysetManager.java
Patch:
@@ -113,7 +113,7 @@ public void rotate(KeyFormat keyFormat) throws GeneralSecurityException {
   }
 
   /**
-   * @returns return {@code KeysetHandle} of the managed keyset.
+   * @return return {@code KeysetHandle} of the managed keyset.
    */
   public KeysetHandle getKeysetHandle() {
     return new KeysetHandle(keysetBuilder.build());
@@ -122,7 +122,7 @@ public KeysetHandle getKeysetHandle() {
   /**
    * Encrypts the managed keyset with {@code aead} and returns a {@code KeysetHandle} of
    * the encrypted result.
-   * @returns a {@code KeysetHandle} of an encrypted keyset.
+   * @return a {@code KeysetHandle} of an encrypted keyset.
    * @throws GeneralSecurityException
    */
   public KeysetHandle getKeysetHandle(Aead aead) throws GeneralSecurityException {

File: java/src/main/java/com/google/cloud/crypto/tink/KmsEncryptedKeysetHandle.java
Patch:
@@ -28,7 +28,7 @@
  */
 public final class KmsEncryptedKeysetHandle {
   /**
-   * @returns a new keyset handle from {@code proto} which is a KmsEncryptedKeyset
+   * @return a new keyset handle from {@code proto} which is a KmsEncryptedKeyset
    * protobuf in binary format.
    * @throws GeneralSecurityException
    */
@@ -43,7 +43,7 @@ public static final KeysetHandle fromBinaryFormat(final byte[] proto)
   }
 
   /**
-   * @returns a new keyset handle from {@code proto} which is a KmsEncryptedKeyset
+   * @return a new keyset handle from {@code proto} which is a KmsEncryptedKeyset
    * protobuf in text format.
    * @throws GeneralSecurityException
    */
@@ -58,7 +58,7 @@ public static final KeysetHandle fromTextFormat(String proto) throws GeneralSecu
   }
 
   /**
-   * @returns a new keyset handle from {@code encryptedKeyset}.
+   * @return a new keyset handle from {@code encryptedKeyset}.
    * @throws GeneralSecurityException
    */
   public static final KeysetHandle fromProto(KmsEncryptedKeyset kmsEncryptedKeyset)

File: java/src/main/java/com/google/cloud/crypto/tink/Mac.java
Patch:
@@ -27,14 +27,14 @@ public interface Mac {
   /**
    * Computes message authentication code (MAC) for {@code data}.
    *
-   * @returns MAC value.
+   * @return MAC value.
    */
   byte[] computeMac(final byte[] data) throws GeneralSecurityException;
 
   /**
    * Verifies whether {@code mac} is a correct authentication code (MAC) for {@code data}.
    *
-   * @returns true iff {@code mac} is a correct MAC for {@code data}.
+   * @return true iff {@code mac} is a correct MAC for {@code data}.
    */
   boolean verifyMac(final byte[] mac, final byte[] data) throws GeneralSecurityException;
 }

File: java/src/main/java/com/google/cloud/crypto/tink/PublicKeySign.java
Patch:
@@ -27,7 +27,7 @@ public interface PublicKeySign {
   /**
    * Computes the signature for {@code data}.
    *
-   * @returns the signature of {$code data}.
+   * @return the signature of {$code data}.
    */
   byte[] sign(final byte[] data) throws GeneralSecurityException;
 }

File: java/src/main/java/com/google/cloud/crypto/tink/PublicKeyVerify.java
Patch:
@@ -27,7 +27,7 @@ public interface PublicKeyVerify {
   /**
    * Verifies whether {@code signature} is a valid signature for {@code data}.
    *
-   * @returns true iff {@code signature} is a valid signature for {@code data}.
+   * @return true iff {@code signature} is a valid signature for {@code data}.
    */
   boolean verify(final byte[] signature, final byte[] data) throws GeneralSecurityException;
 }

File: java/src/main/java/com/google/cloud/crypto/tink/Util.java
Patch:
@@ -24,7 +24,7 @@
  */
 public class Util {
   /**
-   * @returns a KeysetInfo-proto from a {@code keyset} protobuf.
+   * @return a KeysetInfo-proto from a {@code keyset} protobuf.
    */
   public static KeysetInfo getKeysetInfo(Keyset keyset) {
     KeysetInfo.Builder info = KeysetInfo.newBuilder()
@@ -36,7 +36,7 @@ public static KeysetInfo getKeysetInfo(Keyset keyset) {
   }
 
   /**
-   * @returns a KeyInfo-proto from a {@code key} protobuf.
+   * @return a KeyInfo-proto from a {@code key} protobuf.
    */
   public static KeysetInfo.KeyInfo getKeyInfo(Keyset.Key key) {
     return KeysetInfo.KeyInfo.newBuilder()

File: java/src/main/java/com/google/cloud/crypto/tink/aead/AeadFactory.java
Patch:
@@ -107,7 +107,7 @@ public static void registerLegacyKeyTypes() throws GeneralSecurityException {
   }
 
   /**
-   * @returns a Aead primitive from a {@code keysetHandle}.
+   * @return a Aead primitive from a {@code keysetHandle}.
    * @throws GeneralSecurityException
    */
   public static Aead getPrimitive(final KeysetHandle keysetHandle)
@@ -116,7 +116,7 @@ public static Aead getPrimitive(final KeysetHandle keysetHandle)
   }
 
   /**
-   * @returns a Aead primitive from a {@code keysetHandle} and a custom {@code keyManager}.
+   * @return a Aead primitive from a {@code keysetHandle} and a custom {@code keyManager}.
    * @throws GeneralSecurityException
    */
   public static Aead getPrimitive(final KeysetHandle keysetHandle,

File: java/src/main/java/com/google/cloud/crypto/tink/mac/MacFactory.java
Patch:
@@ -94,7 +94,7 @@ public static void registerLegacyKeyTypes() throws GeneralSecurityException {
   }
 
   /**
-   * @returns a Mac primitive from a {@code keysetHandle}.
+   * @return a Mac primitive from a {@code keysetHandle}.
    * @throws GeneralSecurityException
    */
   public static Mac getPrimitive(final KeysetHandle keysetHandle)
@@ -103,7 +103,7 @@ public static Mac getPrimitive(final KeysetHandle keysetHandle)
   }
 
   /**
-   * @returns a Mac primitive from a {@code keysetHandle} and a custom {@code keyManager}.
+   * @return a Mac primitive from a {@code keysetHandle} and a custom {@code keyManager}.
    * @throws GeneralSecurityException
    */
   public static Mac getPrimitive(final KeysetHandle keysetHandle, final KeyManager<Mac> keyManager)

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/Random.java
Patch:
@@ -25,7 +25,7 @@ public final class Random {
   private static final SecureRandom secureRandom = new SecureRandom();
 
   /**
-   * @returns a random byte array of size {@code size}.
+   * @return a random byte array of size {@code size}.
    */
   public static byte[] randBytes(int size) {
     byte[] rand = new byte[size];
@@ -34,7 +34,7 @@ public static byte[] randBytes(int size) {
   }
 
   /**
-   * @returns non negative random int.
+   * @return non negative random int.
    */
   public static int randNonNegativeInt() {
     byte[] rand = randBytes(4);

File: java/src/main/java/com/google/cloud/crypto/tink/subtle/Util.java
Patch:
@@ -24,7 +24,7 @@
 public final class Util {
   /**
    * Best effort fix-timing array comparison.
-   * @returns true if two arrays are equal.
+   * @return true if two arrays are equal.
    */
   public static final boolean arrayEquals(final byte[] x, final byte[] y) {
     if (x == null || y == null) {

File: java/src/main/java/com/google/cloud/crypto/tink/aead/AesCtrJceCipher.java
Patch:
@@ -17,9 +17,7 @@
 package com.google.cloud.crypto.tink.aead;
 
 import com.google.cloud.crypto.tink.Random;
-import java.lang.System;
 import java.security.GeneralSecurityException;
-import java.security.SecureRandom;
 import javax.crypto.Cipher;
 import javax.crypto.spec.IvParameterSpec;
 import javax.crypto.spec.SecretKeySpec;

File: java/src/test/java/com/google/cloud/crypto/tink/RegistryTest.java
Patch:
@@ -289,7 +289,7 @@ public void testRegistryCollisions() throws Exception {
 
     // This should not overwrite the existing manager.
     assertFalse(registry.registerKeyManager(mac1TypeUrl, new Mac2KeyManager()));
-    KeyManager<Mac> manager= registry.getKeyManager(mac1TypeUrl);
+    KeyManager<Mac> manager = registry.getKeyManager(mac1TypeUrl);
     assertEquals(Mac1KeyManager.class.getSimpleName(),
         manager.getClass().getSimpleName());
   }

File: java/src/test/java/com/google/cloud/crypto/tink/signature/EcdsaVerifyKeyManagerTest.java
Patch:
@@ -20,7 +20,6 @@
 
 import com.google.cloud.crypto.tink.CommonProto.EllipticCurveType;
 import com.google.cloud.crypto.tink.CommonProto.HashType;
-import com.google.cloud.crypto.tink.EcdsaProto.EcdsaKeyFormat;
 import com.google.cloud.crypto.tink.EcdsaProto.EcdsaParams;
 import com.google.cloud.crypto.tink.EcdsaProto.EcdsaPublicKey;
 import com.google.cloud.crypto.tink.PublicKeyVerify;

File: java/src/main/java/com/google/cloud/crypto/tink/Mac.java
Patch:
@@ -29,12 +29,12 @@ public interface Mac {
    *
    * @returns MAC value.
    */
-  byte[] computeMac(byte[] data) throws GeneralSecurityException;
+  byte[] computeMac(final byte[] data) throws GeneralSecurityException;
 
   /**
    * Verifies whether {@code mac} is a correct authentication code (MAC) for {@code data}.
    *
    * @returns true iff {@code mac} is a correct MAC for {@code data}.
    */
-  boolean verifyMac(byte[] mac, byte[] data) throws GeneralSecurityException;
+  boolean verifyMac(final byte[] mac, final byte[] data) throws GeneralSecurityException;
 }

File: java/src/main/java/com/google/cloud/crypto/tink/Mac.java
Patch:
@@ -4,9 +4,8 @@
 
 /**
  * Interface for MACs (Message Authentication Codes).
- * This interface should be used for authentication only, and not for other
- * purposes (for example, it should not be used to generate pseudorandom
- * bytes).
+ * This interface should be used for authentication only, and not for other purposes
+ * (for example, it should not be used to generate pseudorandom bytes).
  */
 public interface Mac {
   /**

