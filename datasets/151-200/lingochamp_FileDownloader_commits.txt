File: library/src/main/java/com/liulishuo/filedownloader/connection/FileDownloadUrlConnection.java
Patch:
@@ -46,6 +46,9 @@ public FileDownloadUrlConnection(URL url, Configuration configuration) throws IO
         } else {
             mConnection = url.openConnection();
         }
+        if (mConnection instanceof HttpURLConnection) {
+            ((HttpURLConnection) mConnection).setInstanceFollowRedirects(false);
+        }
 
         if (configuration != null) {
             if (configuration.readTimeout != null) {

File: library/src/main/java/com/liulishuo/filedownloader/connection/FileDownloadUrlConnection.java
Patch:
@@ -46,6 +46,9 @@ public FileDownloadUrlConnection(URL url, Configuration configuration) throws IO
         } else {
             mConnection = url.openConnection();
         }
+        if (mConnection instanceof HttpURLConnection) {
+            ((HttpURLConnection) mConnection).setInstanceFollowRedirects(false);
+        }
 
         if (configuration != null) {
             if (configuration.readTimeout != null) {

File: demo/src/main/java/com/liulishuo/filedownloader/demo/SingleTaskTestActivity.java
Patch:
@@ -157,8 +157,7 @@ private BaseDownloadTask createDownloadTask(final int position) {
 
         switch (position) {
             case 1:
-//                url = Constant.LIULISHUO_APK_URL;
-                url = "http://static.open.baidu.com/media/ch1000/png/chenweiting.png";
+                url = Constant.LIULISHUO_APK_URL;
                 tag = new ViewHolder(new WeakReference<>(this), progressBar1, null, speedTv1, 1);
                 path = llsApkFilePath;
                 tag.setFilenameTv(filenameTv1);

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadThreadPool.java
Patch:
@@ -121,7 +121,7 @@ private synchronized void filterOutNoExist() {
         runnablePool = correctedRunnablePool;
     }
 
-    public boolean isInThreadPool(final int downloadId) {
+    public synchronized boolean isInThreadPool(final int downloadId) {
         final DownloadLaunchRunnable runnable = runnablePool.get(downloadId);
         return runnable != null && runnable.isAlive();
     }

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadThreadPool.java
Patch:
@@ -121,7 +121,7 @@ private synchronized void filterOutNoExist() {
         runnablePool = correctedRunnablePool;
     }
 
-    public boolean isInThreadPool(final int downloadId) {
+    public synchronized boolean isInThreadPool(final int downloadId) {
         final DownloadLaunchRunnable runnable = runnablePool.get(downloadId);
         return runnable != null && runnable.isAlive();
     }

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloader.java
Patch:
@@ -746,7 +746,7 @@ IQueuesHandler getQueuesHandler() {
     private static final Object INIT_LOST_CONNECTED_HANDLER_LOCK = new Object();
     private ILostServiceConnectedHandler mLostConnectedHandler;
 
-    public ILostServiceConnectedHandler getLostConnectedHandler() {
+    ILostServiceConnectedHandler getLostConnectedHandler() {
         if (mLostConnectedHandler == null) {
             synchronized (INIT_LOST_CONNECTED_HANDLER_LOCK) {
                 if (mLostConnectedHandler == null) {

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloader.java
Patch:
@@ -746,7 +746,7 @@ IQueuesHandler getQueuesHandler() {
     private static final Object INIT_LOST_CONNECTED_HANDLER_LOCK = new Object();
     private ILostServiceConnectedHandler mLostConnectedHandler;
 
-    public ILostServiceConnectedHandler getLostConnectedHandler() {
+    ILostServiceConnectedHandler getLostConnectedHandler() {
         if (mLostConnectedHandler == null) {
             synchronized (INIT_LOST_CONNECTED_HANDLER_LOCK) {
                 if (mLostConnectedHandler == null) {

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloader.java
Patch:
@@ -746,7 +746,7 @@ IQueuesHandler getQueuesHandler() {
     private static final Object INIT_LOST_CONNECTED_HANDLER_LOCK = new Object();
     private ILostServiceConnectedHandler mLostConnectedHandler;
 
-    ILostServiceConnectedHandler getLostConnectedHandler() {
+    public ILostServiceConnectedHandler getLostConnectedHandler() {
         if (mLostConnectedHandler == null) {
             synchronized (INIT_LOST_CONNECTED_HANDLER_LOCK) {
                 if (mLostConnectedHandler == null) {

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloader.java
Patch:
@@ -746,7 +746,7 @@ IQueuesHandler getQueuesHandler() {
     private static final Object INIT_LOST_CONNECTED_HANDLER_LOCK = new Object();
     private ILostServiceConnectedHandler mLostConnectedHandler;
 
-    ILostServiceConnectedHandler getLostConnectedHandler() {
+    public ILostServiceConnectedHandler getLostConnectedHandler() {
         if (mLostConnectedHandler == null) {
             synchronized (INIT_LOST_CONNECTED_HANDLER_LOCK) {
                 if (mLostConnectedHandler == null) {

File: demo/src/main/java/com/liulishuo/filedownloader/demo/MainActivity.java
Patch:
@@ -54,7 +54,7 @@ public void onClickPerformance(final View view) {
     }
 
     public void onClickNotification(final View view){
-        startActivity(new Intent(this, NotificationEntranceActivity.class));
+        startActivity(new Intent(this, NotificationSampleActivity.class));
     }
 
     @Override

File: demo/src/main/java/com/liulishuo/filedownloader/demo/SingleTaskTestActivity.java
Patch:
@@ -11,7 +11,6 @@
 import com.liulishuo.filedownloader.BaseDownloadTask;
 import com.liulishuo.filedownloader.FileDownloadSampleListener;
 import com.liulishuo.filedownloader.FileDownloader;
-import com.liulishuo.filedownloader.util.FileDownloadLog;
 import com.liulishuo.filedownloader.util.FileDownloadUtils;
 
 import java.io.File;
@@ -158,7 +157,8 @@ private BaseDownloadTask createDownloadTask(final int position) {
 
         switch (position) {
             case 1:
-                url = Constant.LIULISHUO_APK_URL;
+//                url = Constant.LIULISHUO_APK_URL;
+                url = "http://static.open.baidu.com/media/ch1000/png/chenweiting.png";
                 tag = new ViewHolder(new WeakReference<>(this), progressBar1, null, speedTv1, 1);
                 path = llsApkFilePath;
                 tag.setFilenameTv(filenameTv1);

File: demo/src/main/java/com/liulishuo/filedownloader/demo/SingleTaskTestActivity.java
Patch:
@@ -11,7 +11,6 @@
 import com.liulishuo.filedownloader.BaseDownloadTask;
 import com.liulishuo.filedownloader.FileDownloadSampleListener;
 import com.liulishuo.filedownloader.FileDownloader;
-import com.liulishuo.filedownloader.util.FileDownloadLog;
 import com.liulishuo.filedownloader.util.FileDownloadUtils;
 
 import java.io.File;
@@ -158,7 +157,8 @@ private BaseDownloadTask createDownloadTask(final int position) {
 
         switch (position) {
             case 1:
-                url = Constant.LIULISHUO_APK_URL;
+//                url = Constant.LIULISHUO_APK_URL;
+                url = "http://static.open.baidu.com/media/ch1000/png/chenweiting.png";
                 tag = new ViewHolder(new WeakReference<>(this), progressBar1, null, speedTv1, 1);
                 path = llsApkFilePath;
                 tag.setFilenameTv(filenameTv1);

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadThreadPool.java
Patch:
@@ -114,7 +114,7 @@ private synchronized void filterOutNoExist() {
         for (int i = 0; i < size; i++) {
             final int key = runnablePool.keyAt(i);
             final DownloadLaunchRunnable runnable = runnablePool.get(key);
-            if (runnable.isAlive()) {
+            if (runnable != null && runnable.isAlive()) {
                 correctedRunnablePool.put(key, runnable);
             }
         }

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadThreadPool.java
Patch:
@@ -114,7 +114,7 @@ private synchronized void filterOutNoExist() {
         for (int i = 0; i < size; i++) {
             final int key = runnablePool.keyAt(i);
             final DownloadLaunchRunnable runnable = runnablePool.get(key);
-            if (runnable.isAlive()) {
+            if (runnable != null && runnable.isAlive()) {
                 correctedRunnablePool.put(key, runnable);
             }
         }

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadRunnable.java
Patch:
@@ -166,8 +166,8 @@ private long getDownloadedOffset() {
             }
         } else {
             // is single connection
-            FileDownloadModel downloadModel = database.find(downloadId);
-            return downloadModel.getSoFar();
+            final FileDownloadModel downloadModel = database.find(downloadId);
+            if (downloadModel != null) return downloadModel.getSoFar();
         }
         return 0;
     }

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadRunnable.java
Patch:
@@ -166,8 +166,8 @@ private long getDownloadedOffset() {
             }
         } else {
             // is single connection
-            FileDownloadModel downloadModel = database.find(downloadId);
-            return downloadModel.getSoFar();
+            final FileDownloadModel downloadModel = database.find(downloadId);
+            if (downloadModel != null) return downloadModel.getSoFar();
         }
         return 0;
     }

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadServiceUIGuard.java
Patch:
@@ -82,6 +82,7 @@ protected static class FileDownloadServiceCallback extends IFileDownloadIPCCallb
         public void callback(MessageSnapshot snapshot) throws RemoteException {
             MessageSnapshotFlow.getImpl().inflow(snapshot);
         }
+
     }
 
     /**

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadServiceSharedTransmit.java
Patch:
@@ -26,6 +26,7 @@
 import com.liulishuo.filedownloader.services.FDServiceSharedHandler.FileDownloadServiceSharedConnection;
 import com.liulishuo.filedownloader.services.FileDownloadService.SharedMainProcessService;
 import com.liulishuo.filedownloader.util.DownloadServiceNotConnectedHelper;
+import com.liulishuo.filedownloader.util.ExtraKeys;
 import com.liulishuo.filedownloader.util.FileDownloadLog;
 import com.liulishuo.filedownloader.util.FileDownloadUtils;
 
@@ -148,6 +149,7 @@ public void bindStartByContext(Context context, Runnable connectedRunnable) {
         }
         Intent i = new Intent(context, SERVICE_CLASS);
         runServiceForeground = FileDownloadUtils.needMakeServiceForeground(context);
+        i.putExtra(ExtraKeys.IS_FOREGROUND, runServiceForeground);
         if (runServiceForeground) {
             if (FileDownloadLog.NEED_LOG) FileDownloadLog.d(this, "start foreground service");
             if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) context.startForegroundService(i);

File: library/src/main/java/com/liulishuo/filedownloader/model/ServiceStatusModel.java
Patch:
@@ -24,7 +24,8 @@ public class ServiceStatusModel implements Parcelable {
     private boolean isHandled;
     private boolean runServiceForeground;
 
-    public ServiceStatusModel() {}
+    public ServiceStatusModel() {
+    }
 
     public boolean isHandled() {
         return isHandled;

File: library/src/main/java/com/liulishuo/filedownloader/util/FileDownloadUtils.java
Patch:
@@ -848,8 +848,8 @@ private static boolean isAppOnForeground(Context context) {
         String packageName = context.getApplicationContext().getPackageName();
         for (ActivityManager.RunningAppProcessInfo appProcess : appProcesses) {
             // The name of the process that this object is associated with.
-            if (appProcess.processName.equals(packageName) && appProcess.importance ==
-                    ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {
+            if (appProcess.processName.equals(packageName) && appProcess.importance
+                    == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {
                 return true;
             }
 

File: library/src/main/java/com/liulishuo/filedownloader/util/FileDownloadUtils.java
Patch:
@@ -650,8 +650,8 @@ public static String findFilename(FileDownloadConnection connection, String url)
             filename = FileDownloadUtils.generateFileName(url);
         } else if (filename.contains("../")) {
             throw new FileDownloadSecurityException(FileDownloadUtils.formatString(
-                    "The filename [%s] from the response is not allowable, because it is " +
-                            "contains '../', which can raise the directory traversal vulnerability",
+                    "The filename [%s] from the response is not allowable, because it contains "
+                            + "'../', which can raise the directory traversal vulnerability",
                     filename));
         }
 

File: library/src/main/java/com/liulishuo/filedownloader/util/FileDownloadUtils.java
Patch:
@@ -648,10 +648,10 @@ public static String findFilename(FileDownloadConnection connection, String url)
 
         if (TextUtils.isEmpty(filename)) {
             filename = FileDownloadUtils.generateFileName(url);
-        } else if (filename.startsWith("../")) {
+        } else if (filename.contains("../")) {
             throw new FileDownloadSecurityException(FileDownloadUtils.formatString(
-                    "The filename [%s] from the response is not allowable, because it start"
-                            + " with '../', which can raise the directory traversal vulnerability",
+                    "The filename [%s] from the response is not allowable, because it is " +
+                            "contains '../', which can raise the directory traversal vulnerability",
                     filename));
         }
 

File: library/src/test/java/com/liulishuo/filedownloader/util/FileDownloadUtilsTest.java
Patch:
@@ -71,7 +71,8 @@ public void parseContentLengthFromContentRange_withUnavailableContentRange() {
     @Test(expected = FileDownloadSecurityException.class)
     public void findFilename_securityIssue() throws FileDownloadSecurityException {
         final FileDownloadConnection connection = mock(FileDownloadConnection.class);
-        when(connection.getResponseHeaderField("Content-Disposition")).thenReturn("attachment; filename=\"../abc\"");
+        when(connection.getResponseHeaderField("Content-Disposition"))
+                .thenReturn("attachment; filename=\"../abc\"");
 
         FileDownloadUtils.findFilename(connection, "url");
     }

File: library/src/main/java/com/liulishuo/filedownloader/LostServiceConnectedHandler.java
Patch:
@@ -97,8 +97,8 @@ public void disconnected() {
                 try {
                     FileDownloader.getImpl().bindService();
                 } catch (IllegalStateException ignored) {
-                    FileDownloadLog.w(this, "restart service failed, you may need to " +
-                            "restart downloading manually when the app comes back to foreground");
+                    FileDownloadLog.w(this, "restart service failed, you may need to "
+                            + "restart downloading manually when the app comes back to foreground");
                 }
             }
         } else {

File: library/src/main/java/com/liulishuo/filedownloader/stream/FileDownloadRandomAccessFile.java
Patch:
@@ -54,6 +54,7 @@ public void flushAndSync() throws IOException {
     @Override
     public void close() throws IOException {
         out.close();
+        randomAccess.close();
     }
 
     @Override

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadLaunchRunnable.java
Patch:
@@ -537,7 +537,7 @@ private void handleTrialConnectResult(Map<String, List<String>> requestHeader,
 
         redirectedUrl = connectTask.getFinalRedirectedUrl();
         if (acceptPartial || onlyFromBeginning) {
-            final long totalLength = FileDownloadUtils.findInstanceLengthForTrial(id, connection);
+            final long totalLength = FileDownloadUtils.findInstanceLengthForTrial(connection);
 
             // update model
             String fileName = null;

File: library/src/test/java/com/liulishuo/filedownloader/util/FileDownloadUtilsTest.java
Patch:
@@ -49,7 +49,8 @@ public void parseContentLengthFromContentRange_withEmptyContentRange() {
 
     @Test
     public void parseContentLengthFromContentRange_withStartToEndRange() {
-        long length = FileDownloadUtils.parseContentLengthFromContentRange("bytes 25086300-37629450/37629451");
+        long length = FileDownloadUtils
+                .parseContentLengthFromContentRange("bytes 25086300-37629450/37629451");
         assertThat(length).isEqualTo(12543151);
     }
 

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadLaunchRunnable.java
Patch:
@@ -537,7 +537,7 @@ private void handleTrialConnectResult(Map<String, List<String>> requestHeader,
 
         redirectedUrl = connectTask.getFinalRedirectedUrl();
         if (acceptPartial || onlyFromBeginning) {
-            final long totalLength = FileDownloadUtils.findInstanceLengthForTrial(id, connection);
+            final long totalLength = FileDownloadUtils.findInstanceLengthForTrial(connection);
 
             // update model
             String fileName = null;

File: library/src/main/java/com/liulishuo/filedownloader/util/FileDownloadUtils.java
Patch:
@@ -578,6 +578,7 @@ public static long findInstanceLengthFromContentRange(FileDownloadConnection con
     public static long findContentLength(final int id, FileDownloadConnection connection) {
         long contentLength = FileDownloadUtils
                 .convertContentLengthString(connection.getResponseHeaderField("Content-Length"));
+        if (contentLength < 0) contentLength = findInstanceLengthFromContentRange(connection);
         final String transferEncoding = connection.getResponseHeaderField("Transfer-Encoding");
 
         if (contentLength < 0) {

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadStatusCallback.java
Patch:
@@ -167,9 +167,8 @@ void onProgress(long increaseBytes) {
         }
     }
 
-    void onRetry(Exception exception, int remainRetryTimes, long invalidIncreaseBytes) {
+    void onRetry(Exception exception, int remainRetryTimes) {
         this.callbackIncreaseBuffer.set(0);
-        model.increaseSoFar(-invalidIncreaseBytes);
 
         if (handler == null) {
             // direct

File: library/src/main/java/com/liulishuo/filedownloader/download/FetchDataTask.java
Patch:
@@ -93,7 +93,7 @@ public void run() throws IOException, IllegalAccessException, IllegalArgumentExc
 
         if (this.contentLength > 0 && contentLength != this.contentLength) {
             final String range;
-            if (endOffset == 0) {
+            if (endOffset == ConnectionProfile.RANGE_INFINITE) {
                 range = FileDownloadUtils.formatString("range[%d-)", currentOffset);
             } else {
                 range = FileDownloadUtils.formatString("range[%d-%d)", currentOffset, endOffset);
@@ -186,7 +186,7 @@ public void run() throws IOException, IllegalAccessException, IllegalArgumentExc
         if (contentLength != TOTAL_VALUE_IN_CHUNKED_RESOURCE && contentLength != fetchedLength) {
             throw new FileDownloadGiveUpRetryException(
                     FileDownloadUtils.formatString("fetched length[%d] != content length[%d],"
-                                    + " range[%d, %d) offset[%d] fetch begin offset",
+                                    + " range[%d, %d) offset[%d] fetch begin offset[%d]",
                             fetchedLength, contentLength,
                             startOffset, endOffset, currentOffset, fetchBeginOffset));
         }
@@ -229,7 +229,7 @@ private void sync() {
         }
 
         if (bufferPersistToDevice) {
-            final boolean isBelongMultiConnection = hostRunnable != null;
+            final boolean isBelongMultiConnection = connectionIndex >= 0;
             if (isBelongMultiConnection) {
                 // only need update the connection table.
                 database.updateConnectionModel(downloadId, connectionIndex, currentOffset);

File: library/src/main/java/com/liulishuo/filedownloader/download/ProcessCallback.java
Patch:
@@ -29,7 +29,7 @@ public interface ProcessCallback {
 
     void onError(Exception exception);
 
-    void onRetry(Exception exception, long invalidIncreaseBytes);
+    void onRetry(Exception exception);
 
     void syncProgressFromCache();
 }

File: library/src/test/java/com/liulishuo/filedownloader/download/DownloadLaunchRunnableTest.java
Patch:
@@ -58,11 +58,11 @@ public void onRetry_validRetryTimesDecrease_only1() {
                         mock(IThreadPoolMonitor.class),
                         1000, 100, false,
                         true, 3);
-        launchRunnable.onRetry(mock(Exception.class), 0);
+        launchRunnable.onRetry(mock(Exception.class));
         assertThat(launchRunnable.validRetryTimes).isEqualTo(2);
-        launchRunnable.onRetry(mock(Exception.class), 0);
+        launchRunnable.onRetry(mock(Exception.class));
         assertThat(launchRunnable.validRetryTimes).isEqualTo(1);
-        launchRunnable.onRetry(mock(Exception.class), 0);
+        launchRunnable.onRetry(mock(Exception.class));
         assertThat(launchRunnable.validRetryTimes).isEqualTo(0);
     }
 

File: library/src/main/java/com/liulishuo/filedownloader/download/ConnectTask.java
Patch:
@@ -59,9 +59,7 @@ private ConnectTask(ConnectionProfile profile,
 
     void updateConnectionProfile(long downloadedOffset) {
         if (downloadedOffset == profile.currentOffset) {
-            if (FileDownloadLog.NEED_LOG) {
-                FileDownloadLog.w(this, "no data download, no need to update");
-            }
+            FileDownloadLog.w(this, "no data download, no need to update");
             return;
         }
         final long newContentLength =

File: library/src/main/java/com/liulishuo/filedownloader/download/FetchDataTask.java
Patch:
@@ -186,7 +186,7 @@ public void run() throws IOException, IllegalAccessException, IllegalArgumentExc
         if (contentLength != TOTAL_VALUE_IN_CHUNKED_RESOURCE && contentLength != fetchedLength) {
             throw new FileDownloadGiveUpRetryException(
                     FileDownloadUtils.formatString("fetched length[%d] != content length[%d],"
-                                    + " range[%d, %d) offset[%d] fetch begin offset",
+                                    + " range[%d, %d) offset[%d] fetch begin offset[%d]",
                             fetchedLength, contentLength,
                             startOffset, endOffset, currentOffset, fetchBeginOffset));
         }

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadRunnable.java
Patch:
@@ -137,7 +137,7 @@ public void run() {
                             //update currentOffset in ConnectionProfile
                             final long downloadedOffset = getDownloadedOffset();
                             if (downloadedOffset > 0) {
-                                connectTask.updateConnectionProfile(fetchDataTask.currentOffset);
+                                connectTask.updateConnectionProfile(downloadedOffset);
                             }
                         }
                         callback.onRetry(e);

File: library/src/main/java/com/liulishuo/filedownloader/download/FetchDataTask.java
Patch:
@@ -93,7 +93,7 @@ public void run() throws IOException, IllegalAccessException, IllegalArgumentExc
 
         if (this.contentLength > 0 && contentLength != this.contentLength) {
             final String range;
-            if (endOffset <= 0) {
+            if (endOffset == ConnectionProfile.RANGE_INFINITE) {
                 range = FileDownloadUtils.formatString("range[%d-)", currentOffset);
             } else {
                 range = FileDownloadUtils.formatString("range[%d-%d)", currentOffset, endOffset);

File: library/src/main/java/com/liulishuo/filedownloader/download/ConnectTask.java
Patch:
@@ -64,7 +64,8 @@ void updateConnectionProfile(long haveFinishedOffset) {
             }
             return;
         }
-        final long newContentLength = profile.contentLength - (haveFinishedOffset - profile.currentOffset);
+        final long newContentLength =
+                profile.contentLength - (haveFinishedOffset - profile.currentOffset);
         profile = ConnectionProfile.ConnectionProfileBuild.buildConnectionProfile(
                 profile.startOffset,
                 haveFinishedOffset,

File: library/src/test/java/com/liulishuo/filedownloader/download/DownloadRunnableTest.java
Patch:
@@ -28,7 +28,6 @@
 import java.net.HttpURLConnection;
 
 import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.verify;

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadLaunchRunnable.java
Patch:
@@ -308,7 +308,7 @@ public void run() {
                         | InterruptedException | IllegalArgumentException
                         | FileDownloadGiveUpRetryException e) {
                     if (isRetry(e)) {
-                        onRetry(e, 0);
+                        onRetry(e);
                         continue;
                     } else {
                         onError(e);
@@ -854,7 +854,7 @@ public void onError(Exception exception) {
     }
 
     @Override
-    public void onRetry(Exception exception, long invalidIncreaseBytes) {
+    public void onRetry(Exception exception) {
         if (paused) {
             if (FileDownloadLog.NEED_LOG) {
                 FileDownloadLog.d(this, "the task[%d] has already been paused, so pass the"
@@ -868,7 +868,7 @@ public void onRetry(Exception exception, long invalidIncreaseBytes) {
                     validRetryTimes, model.getId());
         }
 
-        statusCallback.onRetry(exception, validRetryTimes, invalidIncreaseBytes);
+        statusCallback.onRetry(exception, validRetryTimes);
     }
 
     @Override

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadStatusCallback.java
Patch:
@@ -167,9 +167,8 @@ void onProgress(long increaseBytes) {
         }
     }
 
-    void onRetry(Exception exception, int remainRetryTimes, long invalidIncreaseBytes) {
+    void onRetry(Exception exception, int remainRetryTimes) {
         this.callbackIncreaseBuffer.set(0);
-        model.increaseSoFar(-invalidIncreaseBytes);
 
         if (handler == null) {
             // direct

File: library/src/main/java/com/liulishuo/filedownloader/download/FetchDataTask.java
Patch:
@@ -93,7 +93,7 @@ public void run() throws IOException, IllegalAccessException, IllegalArgumentExc
 
         if (this.contentLength > 0 && contentLength != this.contentLength) {
             final String range;
-            if (endOffset == 0) {
+            if (endOffset <= 0) {
                 range = FileDownloadUtils.formatString("range[%d-)", currentOffset);
             } else {
                 range = FileDownloadUtils.formatString("range[%d-%d)", currentOffset, endOffset);

File: library/src/main/java/com/liulishuo/filedownloader/download/ProcessCallback.java
Patch:
@@ -29,7 +29,7 @@ public interface ProcessCallback {
 
     void onError(Exception exception);
 
-    void onRetry(Exception exception, long invalidIncreaseBytes);
+    void onRetry(Exception exception);
 
     void syncProgressFromCache();
 }

File: library/src/test/java/com/liulishuo/filedownloader/download/DownloadLaunchRunnableTest.java
Patch:
@@ -58,11 +58,11 @@ public void onRetry_validRetryTimesDecrease_only1() {
                         mock(IThreadPoolMonitor.class),
                         1000, 100, false,
                         true, 3);
-        launchRunnable.onRetry(mock(Exception.class), 0);
+        launchRunnable.onRetry(mock(Exception.class));
         assertThat(launchRunnable.validRetryTimes).isEqualTo(2);
-        launchRunnable.onRetry(mock(Exception.class), 0);
+        launchRunnable.onRetry(mock(Exception.class));
         assertThat(launchRunnable.validRetryTimes).isEqualTo(1);
-        launchRunnable.onRetry(mock(Exception.class), 0);
+        launchRunnable.onRetry(mock(Exception.class));
         assertThat(launchRunnable.validRetryTimes).isEqualTo(0);
     }
 

File: library/src/test/java/com/liulishuo/filedownloader/download/DownloadRunnableTest.java
Patch:
@@ -67,7 +67,7 @@ public void run_withConnectFailed_retry() throws IOException, IllegalAccessExcep
 
         downloadRunnable.run();
 
-        verify(mockCallback).onRetry(mockIOException, 0);
+        verify(mockCallback).onRetry(mockIOException);
     }
 
     @Test
@@ -79,7 +79,7 @@ public void run_responseCodeNotMet_error() throws IOException, IllegalAccessExce
         downloadRunnable.run();
 
         // retry first.
-        verify(mockCallback).onRetry(any(Exception.class), anyLong());
+        verify(mockCallback).onRetry(any(Exception.class));
 
         // then callback error.
         verify(mockCallback).onError(any(Exception.class));
@@ -113,7 +113,7 @@ public void onError(Exception exception) {
 
 
         @Override
-        public void onRetry(Exception exception, long invalidIncreaseBytes) {
+        public void onRetry(Exception exception) {
         }
 
         @Override

File: library/src/main/java/com/liulishuo/filedownloader/util/FileDownloadUtils.java
Patch:
@@ -555,7 +555,8 @@ public static boolean isAcceptRange(int responseCode, FileDownloadConnection con
     // because of we using one of two HEAD method to request or using range:0-0 to trial connection
     // only if connection api not support, so we test content-range first and then test
     // content-length.
-    // the response of HEAD method is not very canonical sometimes(it depends on server implementation)
+    // the response of HEAD method is not very canonical
+    // sometimes(it depends on server implementation)
     // so that it's uncertain the content-length is the same as the response of GET method if
     // content-length=0, so must filter this case in here.
     public static long findInstanceLengthForTrial(int id, FileDownloadConnection connection) {

File: library/src/main/java/com/liulishuo/filedownloader/util/FileDownloadUtils.java
Patch:
@@ -558,7 +558,7 @@ public static boolean isAcceptRange(int responseCode, FileDownloadConnection con
     public static long findInstanceLengthForTrial(int id, FileDownloadConnection connection) {
         long length = findInstanceLengthFromContentRange(connection);
         if (length < 0) length = findContentLength(id, connection);
-        if (length <= 0) length = TOTAL_VALUE_IN_CHUNKED_RESOURCE;
+        if (length < 0) length = TOTAL_VALUE_IN_CHUNKED_RESOURCE;
 
         return length;
     }

File: library/src/main/java/com/liulishuo/filedownloader/util/FileDownloadProperties.java
Patch:
@@ -133,7 +133,8 @@ public class FileDownloadProperties {
             "download.max-network-thread-count";
     private static final String KEY_FILE_NON_PRE_ALLOCATION = "file.non-pre-allocation";
     private static final String KEY_BROADCAST_COMPLETED = "broadcast.completed";
-    private static final String KEY_TRIAL_CONNECTION_HEAD_METHOD = "download.trial-connection-head-method";
+    private static final String KEY_TRIAL_CONNECTION_HEAD_METHOD
+            = "download.trial-connection-head-method";
 
     public final int downloadMinProgressStep;
     public final long downloadMinProgressTime;

File: library/src/main/java/com/liulishuo/filedownloader/download/ConnectionProfile.java
Patch:
@@ -17,6 +17,7 @@
 package com.liulishuo.filedownloader.download;
 
 import com.liulishuo.filedownloader.connection.FileDownloadConnection;
+import com.liulishuo.filedownloader.util.FileDownloadProperties;
 import com.liulishuo.filedownloader.util.FileDownloadUtils;
 
 import java.net.ProtocolException;
@@ -73,7 +74,7 @@ private ConnectionProfile(long startOffset, long currentOffset, long endOffset,
     public void processProfile(FileDownloadConnection connection) throws ProtocolException {
         if (isForceNoRange) return;
 
-        if (isTrialConnect) {
+        if (isTrialConnect && FileDownloadProperties.getImpl().trialConnectionHeadMethod) {
             connection.setRequestMethod("HEAD");
         }
 

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadLaunchRunnable.java
Patch:
@@ -659,7 +659,7 @@ private void fetchWithMultipleConnection(final List<ConnectionModel> connectionM
         final boolean withEtag = isResumeAvailableOnDB;
         for (ConnectionModel connectionModel : connectionModelList) {
             final long contentLength;
-            if (connectionModel.getEndOffset() == 0) {
+            if (connectionModel.getEndOffset() == ConnectionProfile.RANGE_INFINITE) {
                 // must be the last one
                 contentLength = totalLength - connectionModel.getCurrentOffset();
             } else {

File: library/src/main/java/com/liulishuo/filedownloader/util/FileDownloadUtils.java
Patch:
@@ -558,6 +558,7 @@ public static boolean isAcceptRange(int responseCode, FileDownloadConnection con
     public static long findInstanceLengthForTrial(int id, FileDownloadConnection connection) {
         long length = findInstanceLengthFromContentRange(connection);
         if (length < 0) length = findContentLength(id, connection);
+        if (length <= 0) length = TOTAL_VALUE_IN_CHUNKED_RESOURCE;
 
         return length;
     }

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadLaunchRunnable.java
Patch:
@@ -595,13 +595,13 @@ private void realDownloadWithSingleConnection(final long totalLength)
     }
 
     private void realDownloadWithMultiConnectionFromResume(final int connectionCount,
-                                                           final List<ConnectionModel> connectionModelList)
+                                                           List<ConnectionModel> modelList)
             throws InterruptedException {
-        if (connectionCount <= 1 || connectionModelList.size() != connectionCount) {
+        if (connectionCount <= 1 || modelList.size() != connectionCount) {
             throw new IllegalArgumentException();
         }
 
-        fetchWithMultipleConnection(connectionModelList, model.getTotal());
+        fetchWithMultipleConnection(modelList, model.getTotal());
     }
 
     private void realDownloadWithMultiConnectionFromBeginning(final long totalLength,

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadListener.java
Patch:
@@ -60,7 +60,7 @@ protected boolean isInvalid() {
      * Enqueue, and pending, waiting for {@link #started(BaseDownloadTask)}.
      *
      * @param task       The task
-     * @param soFarBytes Already downloaded bytes stored in the db
+     * @param soFarBytes Already downloaded and reusable bytes stored in the db
      * @param totalBytes Total bytes stored in the db
      * @see IFileDownloadMessenger#notifyPending
      */

File: library/src/test/java/com/liulishuo/filedownloader/util/FileDownloadUtilsTest.java
Patch:
@@ -31,7 +31,7 @@ public void parseContentDisposition() {
                 .parseContentDisposition("attachment; filename=\"hello world\"");
         assertThat(filename).isEqualTo("hello world");
         filename = FileDownloadUtils
-                .parseContentDisposition("attachment; filename=genome.jpeg");
+                .parseContentDisposition("attachment; filename=genome.jpeg\nabc");
         assertThat(filename).isEqualTo("genome.jpeg");
     }
 

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadManager.java
Patch:
@@ -213,6 +213,7 @@ public boolean pause(final int id) {
             return false;
         }
 
+        model.setStatus(FileDownloadStatus.paused);
         mThreadPool.cancel(id);
         return true;
     }

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadLaunchRunnable.java
Patch:
@@ -85,7 +85,7 @@ public class DownloadLaunchRunnable implements Runnable, ProcessCallback {
 
     private boolean isTriedFixRangeNotSatisfiable;
 
-    private int validRetryTimes;
+    int validRetryTimes;
 
     /**
      * None of the ranges in the request's Range header field overlap the current extent of the
@@ -850,7 +850,7 @@ public void onRetry(Exception exception, long invalidIncreaseBytes) {
                     validRetryTimes, model.getId());
         }
 
-        statusCallback.onRetry(exception, validRetryTimes--, invalidIncreaseBytes);
+        statusCallback.onRetry(exception, validRetryTimes, invalidIncreaseBytes);
     }
 
     @Override

File: library/src/main/java/com/liulishuo/filedownloader/notification/FileDownloadNotificationListener.java
Patch:
@@ -20,8 +20,6 @@
 import com.liulishuo.filedownloader.FileDownloadList;
 import com.liulishuo.filedownloader.FileDownloadListener;
 
-import junit.framework.Assert;
-
 /**
  * The listener of the notification with the task.
  *
@@ -33,7 +31,7 @@ public abstract class FileDownloadNotificationListener extends FileDownloadListe
     private final FileDownloadNotificationHelper helper;
 
     public FileDownloadNotificationListener(FileDownloadNotificationHelper helper) {
-        Assert.assertNotNull("FileDownloadNotificationHelper must not null", helper);
+        if (helper == null) throw new IllegalArgumentException("helper must not be null!");
         this.helper = helper;
     }
 

File: library/src/main/java/com/liulishuo/filedownloader/download/CustomComponentHolder.java
Patch:
@@ -20,7 +20,7 @@
 import com.liulishuo.filedownloader.model.FileDownloadModel;
 import com.liulishuo.filedownloader.model.FileDownloadStatus;
 import com.liulishuo.filedownloader.services.DownloadMgrInitialParams;
-import com.liulishuo.filedownloader.services.FileDownloadDatabase;
+import com.liulishuo.filedownloader.database.FileDownloadDatabase;
 import com.liulishuo.filedownloader.stream.FileDownloadOutputStream;
 import com.liulishuo.filedownloader.util.FileDownloadHelper;
 import com.liulishuo.filedownloader.util.FileDownloadLog;

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadLaunchRunnable.java
Patch:
@@ -30,7 +30,7 @@
 import com.liulishuo.filedownloader.model.FileDownloadHeader;
 import com.liulishuo.filedownloader.model.FileDownloadModel;
 import com.liulishuo.filedownloader.model.FileDownloadStatus;
-import com.liulishuo.filedownloader.services.FileDownloadDatabase;
+import com.liulishuo.filedownloader.database.FileDownloadDatabase;
 import com.liulishuo.filedownloader.stream.FileDownloadOutputStream;
 import com.liulishuo.filedownloader.util.FileDownloadExecutors;
 import com.liulishuo.filedownloader.util.FileDownloadHelper;

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadStatusCallback.java
Patch:
@@ -30,7 +30,7 @@
 import com.liulishuo.filedownloader.model.FileDownloadModel;
 import com.liulishuo.filedownloader.model.FileDownloadStatus;
 import com.liulishuo.filedownloader.services.FileDownloadBroadcastHandler;
-import com.liulishuo.filedownloader.services.FileDownloadDatabase;
+import com.liulishuo.filedownloader.database.FileDownloadDatabase;
 import com.liulishuo.filedownloader.util.FileDownloadLog;
 import com.liulishuo.filedownloader.util.FileDownloadProperties;
 import com.liulishuo.filedownloader.util.FileDownloadUtils;
@@ -110,6 +110,7 @@ void onStartThread() {
         // direct
         model.setStatus(FileDownloadStatus.started);
         onStatusChanged(FileDownloadStatus.started);
+        database.onTaskStart(model.getId());
     }
 
     void onConnected(boolean isResume, long totalLength, String etag, String fileName) throws

File: library/src/main/java/com/liulishuo/filedownloader/download/FetchDataTask.java
Patch:
@@ -21,7 +21,7 @@
 import com.liulishuo.filedownloader.connection.FileDownloadConnection;
 import com.liulishuo.filedownloader.exception.FileDownloadGiveUpRetryException;
 import com.liulishuo.filedownloader.exception.FileDownloadNetworkPolicyException;
-import com.liulishuo.filedownloader.services.FileDownloadDatabase;
+import com.liulishuo.filedownloader.database.FileDownloadDatabase;
 import com.liulishuo.filedownloader.stream.FileDownloadOutputStream;
 import com.liulishuo.filedownloader.util.FileDownloadLog;
 import com.liulishuo.filedownloader.util.FileDownloadUtils;

File: library/src/main/java/com/liulishuo/filedownloader/model/FileDownloadModel.java
Patch:
@@ -21,6 +21,7 @@
 import android.os.Parcelable;
 
 import com.liulishuo.filedownloader.BaseDownloadTask;
+import com.liulishuo.filedownloader.database.FileDownloadDatabase;
 import com.liulishuo.filedownloader.util.FileDownloadUtils;
 
 import java.io.File;
@@ -30,7 +31,7 @@
 /**
  * The model of the downloading task will be used in the filedownloader database.
  *
- * @see com.liulishuo.filedownloader.services.FileDownloadDatabase
+ * @see FileDownloadDatabase
  */
 @SuppressWarnings("WeakerAccess")
 public class FileDownloadModel implements Parcelable {

File: library/src/main/java/com/liulishuo/filedownloader/services/DownloadMgrInitialParams.java
Patch:
@@ -18,6 +18,8 @@
 
 import com.liulishuo.filedownloader.connection.DefaultConnectionCountAdapter;
 import com.liulishuo.filedownloader.connection.FileDownloadUrlConnection;
+import com.liulishuo.filedownloader.database.FileDownloadDatabase;
+import com.liulishuo.filedownloader.database.RemitDatabase;
 import com.liulishuo.filedownloader.model.FileDownloadModel;
 import com.liulishuo.filedownloader.stream.FileDownloadOutputStream;
 import com.liulishuo.filedownloader.stream.FileDownloadRandomAccessFile;
@@ -159,7 +161,7 @@ private int getDefaultMaxNetworkThreadCount() {
     }
 
     private FileDownloadDatabase createDefaultDatabase() {
-        return new DefaultDatabaseImpl();
+        return new RemitDatabase();
     }
 
     private FileDownloadHelper.OutputStreamCreator createDefaultOutputStreamCreator() {

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadManager.java
Patch:
@@ -20,6 +20,7 @@
 import android.text.TextUtils;
 
 import com.liulishuo.filedownloader.IThreadPoolMonitor;
+import com.liulishuo.filedownloader.database.FileDownloadDatabase;
 import com.liulishuo.filedownloader.download.CustomComponentHolder;
 import com.liulishuo.filedownloader.download.DownloadLaunchRunnable;
 import com.liulishuo.filedownloader.download.DownloadRunnable;

File: library/src/main/java/com/liulishuo/filedownloader/util/FileDownloadHelper.java
Patch:
@@ -21,11 +21,12 @@
 
 import com.liulishuo.filedownloader.IThreadPoolMonitor;
 import com.liulishuo.filedownloader.connection.FileDownloadConnection;
+import com.liulishuo.filedownloader.database.SqliteDatabaseImpl;
 import com.liulishuo.filedownloader.exception.PathConflictException;
 import com.liulishuo.filedownloader.message.MessageSnapshotFlow;
 import com.liulishuo.filedownloader.message.MessageSnapshotTaker;
 import com.liulishuo.filedownloader.model.FileDownloadModel;
-import com.liulishuo.filedownloader.services.FileDownloadDatabase;
+import com.liulishuo.filedownloader.database.FileDownloadDatabase;
 import com.liulishuo.filedownloader.stream.FileDownloadOutputStream;
 import com.liulishuo.filedownloader.stream.FileDownloadRandomAccessFile;
 
@@ -132,7 +133,7 @@ public interface DatabaseCustomMaker {
          *
          * @return Nullable, Customize {@link FileDownloadDatabase} which will be used for storing
          * downloading model.
-         * @see com.liulishuo.filedownloader.services.DefaultDatabaseImpl
+         * @see SqliteDatabaseImpl
          */
         FileDownloadDatabase customMake();
     }

File: library/src/test/java/com/liulishuo/filedownloader/download/DownloadLaunchRunnableTest.java
Patch:
@@ -27,7 +27,7 @@
 import com.liulishuo.filedownloader.model.FileDownloadHeader;
 import com.liulishuo.filedownloader.model.FileDownloadModel;
 import com.liulishuo.filedownloader.model.FileDownloadStatus;
-import com.liulishuo.filedownloader.services.FileDownloadDatabase;
+import com.liulishuo.filedownloader.database.FileDownloadDatabase;
 import com.liulishuo.filedownloader.util.FileDownloadHelper;
 
 import org.junit.Test;

File: library/src/main/java/com/liulishuo/filedownloader/util/FileDownloadUtils.java
Patch:
@@ -477,6 +477,7 @@ public static boolean isNetworkNotOnWifiType() {
             return true;
         }
 
+        //noinspection MissingPermission, because we check permission accessable when invoked
         final NetworkInfo info = manager.getActiveNetworkInfo();
 
         return info == null || info.getType() != ConnectivityManager.TYPE_WIFI;

File: library/src/main/java/com/liulishuo/filedownloader/services/DefaultDatabaseImpl.java
Patch:
@@ -37,7 +37,7 @@
  * For storing and updating the {@link FileDownloadModel} to the filedownloader database, and also
  * maintain the database when FileDownloader-Process is launching automatically.
  */
-class DefaultDatabaseImpl implements FileDownloadDatabase {
+public class DefaultDatabaseImpl implements FileDownloadDatabase {
 
     private final SQLiteDatabase db;
 

File: library/src/main/java/com/liulishuo/filedownloader/services/DefaultDatabaseOpenHelper.java
Patch:
@@ -28,7 +28,7 @@
 /**
  * The default opener of the filedownloader database helper.
  */
-class DefaultDatabaseOpenHelper extends SQLiteOpenHelper {
+public class DefaultDatabaseOpenHelper extends SQLiteOpenHelper {
     private static final String DATABASE_NAME = "filedownloader.db";
     private static final int DATABASE_VERSION = 3;
 

File: library/src/main/java/com/liulishuo/filedownloader/services/DefaultDatabaseImpl.java
Patch:
@@ -37,7 +37,7 @@
  * For storing and updating the {@link FileDownloadModel} to the filedownloader database, and also
  * maintain the database when FileDownloader-Process is launching automatically.
  */
-class DefaultDatabaseImpl implements FileDownloadDatabase {
+public class DefaultDatabaseImpl implements FileDownloadDatabase {
 
     private final SQLiteDatabase db;
 

File: library/src/main/java/com/liulishuo/filedownloader/services/DefaultDatabaseOpenHelper.java
Patch:
@@ -28,7 +28,7 @@
 /**
  * The default opener of the filedownloader database helper.
  */
-class DefaultDatabaseOpenHelper extends SQLiteOpenHelper {
+public class DefaultDatabaseOpenHelper extends SQLiteOpenHelper {
     private static final String DATABASE_NAME = "filedownloader.db";
     private static final int DATABASE_VERSION = 3;
 

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadStatusCallback.java
Patch:
@@ -22,7 +22,6 @@
 import android.os.HandlerThread;
 import android.os.Message;
 import android.os.SystemClock;
-import android.util.Log;
 
 import com.liulishuo.filedownloader.exception.FileDownloadGiveUpRetryException;
 import com.liulishuo.filedownloader.exception.FileDownloadOutOfSpaceException;

File: library/src/main/java/com/liulishuo/filedownloader/model/FileDownloadModel.java
Patch:
@@ -97,7 +97,7 @@ public void setSoFar(long soFar) {
         this.soFar.set(soFar);
     }
 
-    public void increaseSoFar(long increaseBytes){
+    public void increaseSoFar(long increaseBytes) {
         this.soFar.addAndGet(increaseBytes);
     }
 

File: library/src/main/java/com/liulishuo/filedownloader/services/DefaultDatabaseImpl.java
Patch:
@@ -224,9 +224,7 @@ public void updatePause(int id, long sofar) {
 
     @Override
     public void updatePending(int id) {
-        ContentValues cv = new ContentValues();
-        cv.put(FileDownloadModel.STATUS, FileDownloadStatus.pending);
-        update(id, cv);
+        // No need to persist pending status.
     }
 
     @Override

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadStatusCallback.java
Patch:
@@ -462,7 +462,7 @@ private boolean isNeedCallbackToUser(final long now) {
     private void onStatusChanged(final byte status) {
         // In current situation, it maybe invoke this method simultaneously between #onPause() and
         // others.
-        if (model.getStatus() == FileDownloadStatus.paused) {
+        if (status == FileDownloadStatus.paused) {
             if (FileDownloadLog.NEED_LOG) {
                 /**
                  * Already paused or the current status is paused.

File: library/src/test/java/com/liulishuo/filedownloader/download/DownloadRunnableTest.java
Patch:
@@ -92,7 +92,7 @@ public void onProgress(long increaseBytes) {
         }
 
         @Override
-        public void onCompleted(DownloadRunnable doneRunnable, long startOffset, long endOffset) throws IOException {
+        public void onCompleted(DownloadRunnable doneRunnable, long startOffset, long endOffset) {
         }
 
         boolean isFirstTime = true;

File: library/src/main/java/com/liulishuo/filedownloader/download/ProcessCallback.java
Patch:
@@ -16,16 +16,14 @@
 
 package com.liulishuo.filedownloader.download;
 
-import java.io.IOException;
-
 /**
  * The process event callbacks.
  */
 public interface ProcessCallback {
 
     void onProgress(long increaseBytes);
 
-    void onCompleted(DownloadRunnable doneRunnable, long startOffset, long endOffset) throws IOException;
+    void onCompleted(DownloadRunnable doneRunnable, long startOffset, long endOffset);
 
     boolean isRetry(Exception exception);
 

File: library/src/main/java/com/liulishuo/filedownloader/stream/FileDownloadOutputStream.java
Patch:
@@ -88,7 +88,7 @@ public interface FileDownloadOutputStream {
      * @see java.io.RandomAccessFile#seek(long)
      * @see java.nio.channels.FileChannel#position(long)
      */
-    void seek(long offset) throws IOException;
+    void seek(long offset) throws IOException, IllegalAccessException;
 
     /**
      * Sets the length of this file.
@@ -108,5 +108,5 @@ public interface FileDownloadOutputStream {
      * @throws IllegalAccessException If in this output stream doesn't support this function.
      * @see java.io.RandomAccessFile#setLength(long)
      */
-    void setLength(final long newLength) throws IOException;
+    void setLength(final long newLength) throws IOException, IllegalAccessException;
 }

File: library/src/main/java/com/liulishuo/filedownloader/services/DefaultDatabaseImpl.java
Patch:
@@ -70,9 +70,9 @@ public List<ConnectionModel> findConnectionModel(int id) {
                 final ConnectionModel model = new ConnectionModel();
                 model.setId(id);
                 model.setIndex(c.getInt(c.getColumnIndex(ConnectionModel.INDEX)));
-                model.setStartOffset(c.getInt(c.getColumnIndex(ConnectionModel.START_OFFSET)));
-                model.setCurrentOffset(c.getInt(c.getColumnIndex(ConnectionModel.CURRENT_OFFSET)));
-                model.setEndOffset(c.getInt(c.getColumnIndex(ConnectionModel.END_OFFSET)));
+                model.setStartOffset(c.getLong(c.getColumnIndex(ConnectionModel.START_OFFSET)));
+                model.setCurrentOffset(c.getLong(c.getColumnIndex(ConnectionModel.CURRENT_OFFSET)));
+                model.setEndOffset(c.getLong(c.getColumnIndex(ConnectionModel.END_OFFSET)));
 
                 resultList.add(model);
             }

File: library/src/main/java/com/liulishuo/filedownloader/services/DefaultDatabaseImpl.java
Patch:
@@ -154,7 +154,7 @@ public void clear() {
         downloaderModelMap.clear();
 
         db.delete(TABLE_NAME, null, null);
-        db.delete(TABLE_NAME, null, null);
+        db.delete(CONNECTION_TABLE_NAME, null, null);
     }
 
     @Override

File: library/src/main/java/com/liulishuo/filedownloader/download/CustomComponentHolder.java
Patch:
@@ -27,7 +27,6 @@
 import com.liulishuo.filedownloader.util.FileDownloadUtils;
 
 import java.io.File;
-import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.util.Iterator;
 
@@ -65,7 +64,7 @@ public FileDownloadConnection createConnection(String url) throws IOException {
         return getConnectionCreator().create(url);
     }
 
-    public FileDownloadOutputStream createOutputStream(File file) throws FileNotFoundException {
+    public FileDownloadOutputStream createOutputStream(File file) throws IOException {
         return getOutputStreamCreator().create(file);
     }
 

File: library/src/main/java/com/liulishuo/filedownloader/download/FetchDataTask.java
Patch:
@@ -210,7 +210,7 @@ private void checkAndSync() {
     private void sync() {
         final long startTimestamp = SystemClock.uptimeMillis();
         try {
-            outputStream.sync();
+            outputStream.flushAndSync();
         } catch (IOException e) {
             e.printStackTrace();
         }

File: library/src/main/java/com/liulishuo/filedownloader/util/FileDownloadHelper.java
Patch:
@@ -26,7 +26,6 @@
 import com.liulishuo.filedownloader.message.MessageSnapshotTaker;
 import com.liulishuo.filedownloader.model.FileDownloadModel;
 import com.liulishuo.filedownloader.services.FileDownloadDatabase;
-import com.liulishuo.filedownloader.stream.FileDownloadBufferedOutputStream;
 import com.liulishuo.filedownloader.stream.FileDownloadOutputStream;
 import com.liulishuo.filedownloader.stream.FileDownloadRandomAccessFile;
 
@@ -153,9 +152,8 @@ public interface OutputStreamCreator {
          *                               rather than a regular file, does not exist but cannot
          *                               be created, or cannot be opened for any other reason
          * @see FileDownloadRandomAccessFile.Creator
-         * @see FileDownloadBufferedOutputStream.Creator
          */
-        FileDownloadOutputStream create(File file) throws FileNotFoundException;
+        FileDownloadOutputStream create(File file) throws IOException;
 
         /**
          * @return {@code true} if the {@link FileDownloadOutputStream} is created through

File: library/src/main/java/com/liulishuo/filedownloader/model/FileDownloadModel.java
Patch:
@@ -260,7 +260,7 @@ public void deleteTargetFile() {
 
     @Override
     public String toString() {
-        return FileDownloadUtils.formatString("id[%d], url[%s], path[%s], status[%d], sofar[%d]," +
+        return FileDownloadUtils.formatString("id[%d], url[%s], path[%s], status[%d], sofar[%s]," +
                         " total[%d], etag[%s], %s", id, url, path, status, soFar, total, eTag,
                 super.toString());
     }

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadLaunchRunnable.java
Patch:
@@ -587,8 +587,8 @@ private void fetchWithMultipleConnection(final List<ConnectionModel> connectionM
         final String path = model.getTempFilePath();
 
         if (FileDownloadLog.NEED_LOG) {
-            FileDownloadLog.d(this, "fetch data with multiple connection(count: [%d]) for task[%d]",
-                    connectionModelList.size(), id);
+            FileDownloadLog.d(this, "fetch data with multiple connection(count: [%d]) for task[%d] totalLength[%d]",
+                    connectionModelList.size(), id, totalLength);
         }
 
         long totalOffset = 0;
@@ -607,7 +607,7 @@ private void fetchWithMultipleConnection(final List<ConnectionModel> connectionM
 
             totalOffset += (connectionModel.getCurrentOffset() - connectionModel.getStartOffset());
 
-            if (connectionModel.getEndOffset() == connectionModel.getCurrentOffset() - 1) {
+            if (contentLength == 0) {
                 // [start, end), offset contain the start one, so need - 1.
                 // it has already done, so pass.
                 if (FileDownloadLog.NEED_LOG) {

File: library/src/main/java/com/liulishuo/filedownloader/event/DownloadEventPoolImpl.java
Patch:
@@ -127,6 +127,8 @@ private void trigger(final LinkedList<IDownloadListener> listeners, final IDownl
 
         final Object[] lists = listeners.toArray();
         for (Object o : lists) {
+            if (o == null) continue; // it has been removed while before listeners.toArray().
+
             if (((IDownloadListener) o).callback(event)) {
                 break;
             }

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadMessenger.java
Patch:
@@ -392,6 +392,6 @@ public void discard() {
 
     @Override
     public String toString() {
-        return FileDownloadUtils.formatString("%d:%s", mTask.getOrigin().getId(), super.toString());
+        return FileDownloadUtils.formatString("%d:%s", mTask == null ? -1 : mTask.getOrigin().getId(), super.toString());
     }
 }

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadLaunchRunnable.java
Patch:
@@ -540,7 +540,7 @@ private void fetchWithMultipleConnectionFromResume(final int connectionCount, fi
     }
 
     private void fetchWithMultipleConnectionFromBeginning(final long totalLength, final int connectionCount) throws InterruptedException {
-        int startOffset = 0;
+        long startOffset = 0;
         final long eachRegion = totalLength / connectionCount;
         final int id = model.getId();
 

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadLaunchRunnable.java
Patch:
@@ -389,7 +389,7 @@ private ConnectionProfile buildFirstConnectProfile(List<ConnectionModel> connect
             FileDownloadUtils.deleteTaskFiles(targetFilePath, tempFilePath);
         }
 
-        return new ConnectionProfile(0, offset, 0, model.getTotal());
+        return new ConnectionProfile(0, offset, 0, model.getTotal() - offset);
     }
 
     private void handleFirstConnected(Map<String, List<String>> requestHeader,

File: library/src/main/java/com/liulishuo/filedownloader/download/FetchDataTask.java
Patch:
@@ -91,9 +91,9 @@ public void run() throws IOException, IllegalAccessException, IllegalArgumentExc
         if (this.contentLength > 0 && contentLength != this.contentLength) {
             final String range;
             if (endOffset == 0) {
-                range = FileDownloadUtils.formatString("range[%d-)", startOffset);
+                range = FileDownloadUtils.formatString("range[%d-)", currentOffset);
             } else {
-                range = FileDownloadUtils.formatString("range[%d-%d)", startOffset, endOffset);
+                range = FileDownloadUtils.formatString("range[%d-%d)", currentOffset, endOffset);
             }
             throw new FileDownloadGiveUpRetryException(FileDownloadUtils.
                     formatString("require %s with contentLength(%d), but the " +

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloader.java
Patch:
@@ -100,7 +100,7 @@ public static void init(final Context context) {
         if (context == null)
             throw new IllegalArgumentException("the provided context must not be null!");
 
-        init(context, null);
+        setup(context);
     }
 
 

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadBroadcastHandler.java
Patch:
@@ -27,7 +27,6 @@
  * The handler broadcast from filedownloader.
  */
 public class FileDownloadBroadcastHandler {
-    public final static String PERMISSION = "filedownloader.permission.RECEIVE_STATE";
     public final static String ACTION_COMPLETED = "filedownloader.intent.action.completed";
     public final static String KEY_MODEL = "model";
 
@@ -54,6 +53,6 @@ public static void sendCompletedBroadcast(FileDownloadModel model) {
         final Intent intent = new Intent(ACTION_COMPLETED);
         intent.putExtra(KEY_MODEL, model);
 
-        FileDownloadHelper.getAppContext().sendBroadcast(intent, PERMISSION);
+        FileDownloadHelper.getAppContext().sendBroadcast(intent);
     }
 }

File: library/src/main/java/com/liulishuo/filedownloader/util/FileDownloadProperties.java
Patch:
@@ -108,9 +108,8 @@
  * when a task is completed task, you will receive the broadcast, and the main process will be relaunched
  * to handle the broadcast.
  * <p>
- * If you want to receive such broadcast, you also need to declare 'filedownloader.permission.RECEIVE_STATE'
- * permission on the manifest, and register receiver with 'filedownloader.intent.action.completed' action
- * name.
+ * If you want to receive such broadcast, you also need to register receiver with
+ * 'filedownloader.intent.action.completed' action name on 'AndroidManifest.xml'.
  * <p>
  * You can use {@link FileDownloadBroadcastHandler} class to parse the received intent.
  */

File: library/src/test/java/com/liulishuo/filedownloader/download/DownloadRunnableTest.java
Patch:
@@ -62,7 +62,7 @@ public void setUp() {
     }
 
     @Test
-    public void run_withConnectFailed_retry() throws IOException {
+    public void run_withConnectFailed_retry() throws IOException, IllegalAccessException {
         when(mockConnectTask.connect()).thenThrow(mockIOException);
 
         downloadRunnable.run();
@@ -71,7 +71,7 @@ public void run_withConnectFailed_retry() throws IOException {
     }
 
     @Test
-    public void run_responseCodeNotMet_error() throws IOException {
+    public void run_responseCodeNotMet_error() throws IOException, IllegalAccessException {
         final FileDownloadConnection connection = mock(FileDownloadConnection.class);
         when(connection.getResponseCode()).thenReturn(HttpURLConnection.HTTP_PRECON_FAILED);
         when(mockConnectTask.connect()).thenReturn(connection);

File: library/src/main/java/com/liulishuo/filedownloader/connection/RedirectHandler.java
Patch:
@@ -70,12 +70,11 @@ public static FileDownloadConnection process(final Map<String, List<String>> req
                         location, code, redirectLocationList);
             }
 
+            redirectConnection.ending();
             redirectConnection =
                     buildRedirectConnection(requestHeaderFields, location);
             redirectLocationList.add(location);
 
-            if (redirectConnection != null) redirectConnection.ending();
-
             redirectConnection.execute();
             code = redirectConnection.getResponseCode();
             location = redirectConnection.getResponseHeaderField("Location");

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadLaunchRunnable.java
Patch:
@@ -495,6 +495,8 @@ private void fetchWithSingleConnection(final ConnectionProfile profile, FileDown
                 .setConnectionProfile(profile)
                 .setPath(model.getTempFilePath());
 
+        model.setConnectionCount(1);
+        database.updateConnectionCount(model.getId(), 1);
         singleFetchDataTask = builder.build();
         singleFetchDataTask.run();
     }

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadQueueSet.java
Patch:
@@ -155,7 +155,7 @@ public void start() {
             }
 
             if (this.isWifiRequired != null) {
-                task.setWifiRequired(true);
+                task.setWifiRequired(this.isWifiRequired);
             }
 
             task.asInQueueTask().enqueue();

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadQueueSet.java
Patch:
@@ -155,7 +155,7 @@ public void start() {
             }
 
             if (this.isWifiRequired != null) {
-                task.setWifiRequired(true);
+                task.setWifiRequired(this.isWifiRequired);
             }
 
             task.asInQueueTask().enqueue();

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadStatusCallback.java
Patch:
@@ -29,7 +29,7 @@
 import com.liulishuo.filedownloader.message.MessageSnapshotTaker;
 import com.liulishuo.filedownloader.model.FileDownloadModel;
 import com.liulishuo.filedownloader.model.FileDownloadStatus;
-import com.liulishuo.filedownloader.services.FileDownloadBroadCastHandler;
+import com.liulishuo.filedownloader.services.FileDownloadBroadcastHandler;
 import com.liulishuo.filedownloader.services.FileDownloadDatabase;
 import com.liulishuo.filedownloader.util.FileDownloadLog;
 import com.liulishuo.filedownloader.util.FileDownloadProperties;
@@ -389,7 +389,7 @@ private void handleCompleted() throws IOException {
         onStatusChanged(FileDownloadStatus.completed);
 
         if (FileDownloadProperties.getImpl().BROADCAST_COMPLETED) {
-            FileDownloadBroadCastHandler.sendCompletedBroadcast(model);
+            FileDownloadBroadcastHandler.sendCompletedBroadcast(model);
         }
     }
 

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadBroadcastHandler.java
Patch:
@@ -26,7 +26,7 @@
 /**
  * The handler broadcast from filedownloader.
  */
-public class FileDownloadBroadCastHandler {
+public class FileDownloadBroadcastHandler {
     public final static String PERMISSION = "filedownloader.permission.RECEIVE_STATE";
     public final static String ACTION_COMPLETED = "filedownloader.intent.action.completed";
     public final static String KEY_MODEL = "model";

File: library/src/main/java/com/liulishuo/filedownloader/util/FileDownloadProperties.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.liulishuo.filedownloader.util;
 
-import com.liulishuo.filedownloader.services.FileDownloadBroadCastHandler;
+import com.liulishuo.filedownloader.services.FileDownloadBroadcastHandler;
 
 import java.io.FileNotFoundException;
 import java.io.IOException;
@@ -112,7 +112,7 @@
  * permission on the manifest, and register receiver with 'filedownloader.intent.action.completed' action
  * name.
  *
- * You can use {@link FileDownloadBroadCastHandler} class to parse the received intent.
+ * You can use {@link FileDownloadBroadcastHandler} class to parse the received intent.
  */
 public class FileDownloadProperties {
 

File: library/src/main/java/com/liulishuo/filedownloader/download/FetchDataTask.java
Patch:
@@ -91,8 +91,8 @@ public void run() throws IOException, IllegalAccessException, IllegalArgumentExc
 
         final long contentLength = FileDownloadUtils.findContentLength(connectionIndex, connection);
         if (contentLength == 0) {
-            FileDownloadLog.w(this, "there isn't any content need to download on %d", connectionIndex);
-            return;
+            throw new FileDownloadGiveUpRetryException(FileDownloadUtils.
+                    formatString("there isn't any content need to download on %d-%d with the content-length is 0", downloadId, connectionIndex));
         }
 
         final long fetchBeginOffset = currentOffset;

File: library/src/main/java/com/liulishuo/filedownloader/services/DefaultDatabaseOpenHelper.java
Patch:
@@ -34,9 +34,6 @@ class DefaultDatabaseOpenHelper extends SQLiteOpenHelper {
 
     public DefaultDatabaseOpenHelper(final Context context) {
         super(context, DATABASE_NAME, null, DATABASE_VERSION);
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
-            setWriteAheadLoggingEnabled(true);
-        }
     }
 
     @Override

File: library/src/main/java/com/liulishuo/filedownloader/DownloadTaskHunter.java
Patch:
@@ -613,7 +613,7 @@ public void start() {
                 //noinspection StatementWithEmptyBody
                 if (!lostConnectedHandler.dispatchTaskStart(runningTask)) {
                     final MessageSnapshot snapshot = prepareErrorMessage(
-                            new RuntimeException("Occur Unknow Error, when request to start" +
+                            new RuntimeException("Occur Unknown Error, when request to start" +
                                     " maybe some problem in binder, maybe the process was killed in " +
                                     "unexpected."));
 

File: library/src/main/java/com/liulishuo/filedownloader/connection/FileDownloadConnection.java
Patch:
@@ -23,8 +23,6 @@
 import java.util.Map;
 
 /**
- * Created by Jacksgong on 06/12/2016.
- * <p>
  * The connection used for connecting to the network.
  */
 

File: library/src/main/java/com/liulishuo/filedownloader/message/MessageSnapshot.java
Patch:
@@ -182,7 +182,7 @@ public MessageSnapshot createFromParcel(Parcel source) {
             if (snapshot != null) {
                 snapshot.isLargeFile = largeFile;
             } else {
-                throw new IllegalStateException("Can't restore the snapshot because unknow " +
+                throw new IllegalStateException("Can't restore the snapshot because unknown " +
                         "status: " + status);
             }
 

File: library/src/main/java/com/liulishuo/filedownloader/services/DefaultDatabaseImpl.java
Patch:
@@ -63,9 +63,8 @@ public List<ConnectionModel> findConnectionModel(int id) {
 
         Cursor c = null;
         try {
-            c = db.rawQuery("SELECT * FROM " + CONNECTION_TABLE_NAME
-                            + " WHERE " + ConnectionModel.ID + " = ?"
-                    , new String[]{Integer.toString(id)});
+            c = db.rawQuery(FileDownloadUtils.formatString("SELECT * FROM %s WHERE %s = ?",
+                    CONNECTION_TABLE_NAME, ConnectionModel.ID), new String[]{Integer.toString(id)});
 
             while (c.moveToNext()) {
                 final ConnectionModel model = new ConnectionModel();

File: library/src/main/java/com/liulishuo/filedownloader/util/FileDownloadHelper.java
Patch:
@@ -183,7 +183,7 @@ public interface ConnectionCreator {
      *                        'completed' message if need.
      * @param path            if the file with {@code path} is exist it means the relate task would
      *                        be completed.
-     * @param forceReDownload whether the task is force to redownload ignore whether the file has
+     * @param forceReDownload whether the task is force to re-download ignore whether the file has
      *                        been exist or not.
      * @param flowDirectly    {@code true} if flow the message if need directly without throw to the
      *                        message-queue.

File: library/src/main/java/com/liulishuo/filedownloader/download/DownloadLaunchRunnable.java
Patch:
@@ -269,7 +269,7 @@ public void run() {
                         }
                     }
 
-                } catch (IOException | IllegalAccessException | InterruptedException | IllegalArgumentException e) {
+                } catch (IOException | IllegalAccessException | InterruptedException | IllegalArgumentException | FileDownloadGiveUpRetryException e) {
                     if (isRetry(e)) {
                         onRetry(e, 0);
                         continue;

File: library/src/main/java/com/liulishuo/filedownloader/download/FetchDataTask.java
Patch:
@@ -65,7 +65,7 @@ public void pause() {
             }
         }
 
-        // why paused argument is after sync? because of if pause the output-stream would be closed.
+        // why do I assign paused argument need wait for sync? because of if paused the output-stream would be closed.
         paused = true;
     }
 

File: library/src/main/java/com/liulishuo/filedownloader/DownloadSpeedMonitor.java
Patch:
@@ -51,7 +51,7 @@ public void end(long sofarBytes) {
         long downloadSize = sofarBytes - mStartSofarBytes;
         this.mLastRefreshTime = 0;
         long interval = SystemClock.uptimeMillis() - mStartTime;
-        if (interval < 0) {
+        if (interval <= 0) {
             mSpeed = (int) downloadSize;
         } else {
             mSpeed = (int) (downloadSize / interval);

File: library/src/main/java/com/liulishuo/filedownloader/download/FetchDataTask.java
Patch:
@@ -69,6 +69,7 @@ private FetchDataTask(FileDownloadConnection connection, ConnectionProfile conne
         this.hostRunnable = host;
         this.connectionIndex = connectionIndex;
         this.downloadId = id;
+        this.database = CustomComponentHolder.getImpl().getDatabaseInstance();
 
         startOffset = connectionProfile.startOffset;
         endOffset = connectionProfile.endOffset;
@@ -169,13 +170,11 @@ public FileDownloadOutputStream getOutputStream() {
         return outputStream;
     }
 
-    private FileDownloadDatabase database;
+    private final FileDownloadDatabase database;
     private volatile long lastSyncBytes = 0;
     private volatile long lastSyncTimestamp = 0;
 
     private void checkAndSync() {
-        if (database == null) database = CustomComponentHolder.getImpl().getDatabaseInstance();
-
         final long now = SystemClock.elapsedRealtime();
         final long bytesDelta = currentOffset - lastSyncBytes;
         final long timestampDelta = now - lastSyncTimestamp;

File: library/src/main/java/com/liulishuo/filedownloader/download/FetchDataTask.java
Patch:
@@ -256,7 +256,7 @@ public Builder setDownloadId(int downloadId) {
             return this;
         }
 
-        public FetchDataTask build() {
+        public FetchDataTask build() throws IllegalArgumentException {
             if (isWifiRequired == null || connection == null || connectionProfile == null
                     || callback == null || path == null || downloadId == null || connectionIndex == null)
                 throw new IllegalArgumentException();

File: library/src/main/java/com/liulishuo/filedownloader/DownloadSpeedMonitor.java
Patch:
@@ -34,7 +34,7 @@ public class DownloadSpeedMonitor implements IDownloadSpeed.Monitor, IDownloadSp
     private long mTotalBytes;
 
     // The min interval millisecond for updating the download mSpeed.
-    private int mMinIntervalUpdateSpeed = 500;
+    private int mMinIntervalUpdateSpeed = 1000;
 
     @Override
     public void start(long startBytes) {
@@ -44,7 +44,7 @@ public void start(long startBytes) {
 
     @Override
     public void end(long sofarBytes) {
-        if (mStartTime <= 0 || mStartSofarBytes <= 0) {
+        if (mStartTime <= 0) {
             return;
         }
 

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadMessenger.java
Patch:
@@ -208,7 +208,7 @@ private void process(MessageSnapshot snapshot) {
         }
 
         if (mIsDiscard || mTask.getOrigin().getListener() == null) {
-            if (FileDownloadMonitor.isValid() &&
+            if ((FileDownloadMonitor.isValid() || mTask.isContainFinishListener()) &&
                     snapshot.getStatus() == FileDownloadStatus.blockComplete) {
                 // there is a FileDownloadMonitor, so we have to ensure the 'BaseDownloadTask#over'
                 // can be invoked.

File: library/src/main/java/com/liulishuo/filedownloader/services/DownloadMgrInitialParams.java
Patch:
@@ -39,7 +39,9 @@ public DownloadMgrInitialParams() {
 
     public DownloadMgrInitialParams(InitCustomMaker maker) {
         this.mMaker = maker;
-        maker.securityCheck();
+        if (maker != null) {
+            maker.securityCheck();
+        }
     }
 
     public int getMaxNetworkThreadCount() {

File: library/src/main/java/com/liulishuo/filedownloader/download/FetchDataTask.java
Patch:
@@ -197,7 +197,7 @@ private void checkAndSync() {
 
 
             lastSyncBytes = currentOffset;
-            lastSyncTimestamp = currentOffset;
+            lastSyncTimestamp = now;
         }
     }
 

File: library/src/main/java/com/liulishuo/filedownloader/DownloadTaskHunter.java
Patch:
@@ -118,7 +118,7 @@ public IFileDownloadMessenger getMessenger() {
     public MessageSnapshot prepareErrorMessage(Throwable cause) {
         mStatus = FileDownloadStatus.error;
         mThrowable = cause;
-        return MessageSnapshotTaker.catchException(mTask.getRunningTask().getOrigin());
+        return MessageSnapshotTaker.catchException(getId(), getSofarBytes(), cause);
     }
 
     private void update(final MessageSnapshot snapshot) {

File: library/src/main/java/com/liulishuo/filedownloader/IThreadPoolMonitor.java
Patch:
@@ -24,4 +24,6 @@
 
 public interface IThreadPoolMonitor {
     boolean isDownloading(FileDownloadModel model);
+
+    int findRunningTaskIdBySameTempPath(String tempFilePath, int excludeId);
 }

File: library/src/main/java/com/liulishuo/filedownloader/exception/FileDownloadHttpException.java
Patch:
@@ -32,7 +32,8 @@ public class FileDownloadHttpException extends RuntimeException {
 
     public FileDownloadHttpException(final int code, final FileDownloadConnection connection) {
         super(FileDownloadUtils.formatString("response code error: %d, \n request headers: %s \n " +
-                "response headers: %s", code, connection));
+                        "response headers: %s", code,
+                connection.getRequestHeaderFields(), connection.getResponseHeaderFields()));
 
         this.mCode = code;
         this.mRequestHeaderMap = connection.getRequestHeaderFields();

File: library/src/main/java/com/liulishuo/filedownloader/services/FDServiceSeparateHandler.java
Patch:
@@ -56,9 +56,9 @@ private synchronized int callback(MessageSnapshot snapShot) {
         return n;
     }
 
-    FDServiceSeparateHandler(WeakReference<FileDownloadService> wService) {
+    FDServiceSeparateHandler(WeakReference<FileDownloadService> wService, FileDownloadMgr manager) {
         this.wService = wService;
-        this.downloadManager = new FileDownloadMgr();
+        this.downloadManager = manager;
 
         MessageSnapshotFlow.getImpl().setReceiver(this);
     }

File: library/src/main/java/com/liulishuo/filedownloader/services/FDServiceSharedHandler.java
Patch:
@@ -34,9 +34,9 @@ public class FDServiceSharedHandler extends IFileDownloadIPCService.Stub
     private final FileDownloadMgr downloadManager;
     private final WeakReference<FileDownloadService> wService;
 
-    FDServiceSharedHandler(WeakReference<FileDownloadService> wService) {
+    FDServiceSharedHandler(WeakReference<FileDownloadService> wService, FileDownloadMgr manager) {
         this.wService = wService;
-        this.downloadManager = new FileDownloadMgr();
+        this.downloadManager = manager;
     }
 
     @Override

File: library/src/main/java/com/liulishuo/filedownloader/MessageSnapshotGate.java
Patch:
@@ -69,8 +69,7 @@ public void receive(MessageSnapshot snapshot) {
         final String updateSyncLock = Integer.toString(snapshot.getId());
         synchronized (updateSyncLock.intern()) {
             final List<BaseDownloadTask.IRunningTask> taskList = FileDownloadList.getImpl().
-                    getDownloadingList(snapshot.getId());
-
+                    getReceiveServiceTaskList(snapshot.getId());
 
             if (taskList.size() > 0) {
                 final BaseDownloadTask topOriginTask = taskList.get(0).getOrigin();

File: library/src/main/java/com/liulishuo/filedownloader/util/FileDownloadSerialQueue.java
Patch:
@@ -83,6 +83,7 @@ public List<BaseDownloadTask> shutdown() {
 
         final List<BaseDownloadTask> unDealTaskList = new ArrayList<>();
         mTasks.drainTo(unDealTaskList);
+        mHandler.removeMessages(WHAT_NEXT);
         mHandlerThread.interrupt();
         mHandlerThread.quit();
 

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadRunnable.java
Patch:
@@ -399,7 +399,6 @@ private void loop(FileDownloadModel model) {
                     onRetry(ex, retryingTimes);
                 } else {
 
-
                     // error
                     onError(ex);
                     break;
@@ -950,7 +949,9 @@ private Throwable exFiltrate(Throwable ex) {
          * Only handle the case of Chunked resource, if it is not chunked, has already been handled
          * in {@link #getOutputStream(boolean, long)}.
          */
-        if (model.getTotal() == TOTAL_VALUE_IN_CHUNKED_RESOURCE && ex instanceof IOException &&
+        if ((model.getTotal() == TOTAL_VALUE_IN_CHUNKED_RESOURCE ||
+                FileDownloadProperties.getImpl().FILE_NON_PRE_ALLOCATION)
+                && ex instanceof IOException &&
                 new File(tempPath).exists()) {
             // chunked
             final long freeSpaceBytes = FileDownloadUtils.

File: library/src/main/java/com/liulishuo/filedownloader/DownloadTaskHunter.java
Patch:
@@ -239,8 +239,9 @@ private void update(final MessageSnapshot snapshot) {
 
                         mSpeedMonitor.start();
 
-                        ((MessageSnapshot.IWarnMessageSnapshot) snapshot).turnToPending();
-                        getMessenger().notifyPending(snapshot);
+                        getMessenger().
+                                notifyPending(((MessageSnapshot.IWarnMessageSnapshot) snapshot).
+                                        turnToPending());
                         break;
                     } else {
                         // already over and no callback

File: library/src/main/java/com/liulishuo/filedownloader/DownloadTaskHunter.java
Patch:
@@ -568,7 +568,8 @@ public void start() {
                             origin.getCallbackProgressTimes(), origin.getCallbackProgressMinInterval(),
                             origin.getAutoRetryTimes(),
                             origin.isForceReDownload(),
-                            mTask.getHeader());
+                            mTask.getHeader(),
+                            origin.isWifiRequired());
 
             if (!succeed) {
                 //noinspection StatementWithEmptyBody

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadServiceSharedTransmit.java
Patch:
@@ -45,13 +45,14 @@ class FileDownloadServiceSharedTransmit implements
     @Override
     public boolean start(String url, String path, boolean pathAsDirectory, int callbackProgressTimes,
                          int callbackProgressMinIntervalMillis,
-                         int autoRetryTimes, boolean forceReDownload, FileDownloadHeader header) {
+                         int autoRetryTimes, boolean forceReDownload, FileDownloadHeader header,
+                         boolean isWifiRequired) {
         if (!isConnected()) {
             return DownloadServiceNotConnectedHelper.start(url, path, pathAsDirectory);
         }
 
         handler.start(url, path, pathAsDirectory, callbackProgressTimes, callbackProgressMinIntervalMillis,
-                autoRetryTimes, forceReDownload, header);
+                autoRetryTimes, forceReDownload, header, isWifiRequired);
         return true;
     }
 

File: library/src/main/java/com/liulishuo/filedownloader/IFileDownloadServiceProxy.java
Patch:
@@ -28,7 +28,7 @@ boolean start(final String url, final String path, final boolean pathAsDirectory
                   final int callbackProgressTimes,
                   final int callbackProgressMinIntervalMillis,
                   final int autoRetryTimes, boolean forceReDownload,
-                  final FileDownloadHeader header);
+                  final FileDownloadHeader header, boolean isWifiRequired);
 
     boolean pause(final int id);
 

File: library/src/main/java/com/liulishuo/filedownloader/services/FDServiceSeparateHandler.java
Patch:
@@ -81,9 +81,10 @@ public boolean checkDownloading(String url, String path) throws RemoteException
     @Override
     public void start(String url, String path, boolean pathAsDirectory, int callbackProgressTimes,
                       int callbackProgressMinIntervalMillis, int autoRetryTimes, boolean forceReDownload,
-                      FileDownloadHeader header) throws RemoteException {
+                      FileDownloadHeader header, boolean isWifiRequired) throws RemoteException {
         downloadManager.start(url, path, pathAsDirectory, callbackProgressTimes,
-                callbackProgressMinIntervalMillis, autoRetryTimes, forceReDownload, header);
+                callbackProgressMinIntervalMillis, autoRetryTimes, forceReDownload, header,
+                isWifiRequired);
     }
 
     @Override

File: library/src/main/java/com/liulishuo/filedownloader/services/FDServiceSharedHandler.java
Patch:
@@ -55,9 +55,10 @@ public boolean checkDownloading(String url, String path) {
     @Override
     public void start(String url, String path, boolean pathAsDirectory, int callbackProgressTimes,
                       int callbackProgressMinIntervalMillis, int autoRetryTimes, boolean forceReDownload,
-                      FileDownloadHeader header) {
+                      FileDownloadHeader header, boolean isWifiRequired) {
         downloadManager.start(url, path, pathAsDirectory, callbackProgressTimes,
-                callbackProgressMinIntervalMillis, autoRetryTimes, forceReDownload, header);
+                callbackProgressMinIntervalMillis, autoRetryTimes, forceReDownload, header,
+                isWifiRequired);
     }
 
     @Override

File: library/src/main/java/com/liulishuo/filedownloader/services/BaseFileServiceUIGuard.java
Patch:
@@ -43,7 +43,7 @@ public abstract class BaseFileServiceUIGuard<CALLBACK extends Binder, INTERFACE
         implements IFileDownloadServiceProxy, ServiceConnection {
 
     private final CALLBACK callback;
-    private INTERFACE service;
+    private volatile INTERFACE service;
     private final Class<?> serviceClass;
 
     private final HashMap<String, Object> uiCacheMap = new HashMap<>();

File: library/src/main/java/com/liulishuo/filedownloader/DownloadTaskHunter.java
Patch:
@@ -334,7 +334,7 @@ interface ICaptureTask {
         final DownloadSpeedMonitor monitor = new DownloadSpeedMonitor();
         mSpeedMonitor = monitor;
         mSpeedLookup = monitor;
-        mMessenger = new FileDownloadMessenger(task.getRunningTask().getOrigin(), this);
+        mMessenger = new FileDownloadMessenger(task.getRunningTask(), this);
     }
 
     @Override
@@ -433,7 +433,7 @@ public void reset() {
         mSpeedMonitor.reset();
         free();
 
-        mMessenger.reAppointment(mTask.getRunningTask().getOrigin(), this);
+        mMessenger.reAppointment(mTask.getRunningTask(), this);
     }
 
     @Override

File: library/src/main/java/com/liulishuo/filedownloader/IFileDownloadMessenger.java
Patch:
@@ -152,7 +152,7 @@ interface IFileDownloadMessenger {
      * @param task Re-appointment for this task, when this messenger has already accomplished the
      *             old one.
      */
-    void reAppointment(BaseDownloadTask task, BaseDownloadTask.LifeCycleCallback callback);
+    void reAppointment(BaseDownloadTask.IRunningTask task, BaseDownloadTask.LifeCycleCallback callback);
 
     /**
      * The 'block completed'(status) message will be handover in the non-UI thread and block the

File: library/src/main/java/com/liulishuo/filedownloader/message/MessageSnapshotTaker.java
Patch:
@@ -102,7 +102,7 @@ public static MessageSnapshot takeBlockCompleted(MessageSnapshot snapshot) {
                             "already be completed. %d %d", snapshot.getId(), snapshot.getStatus()));
         }
 
-        return new MessageSnapshot(snapshot.getId(), FileDownloadStatus.blockComplete);
+        return new BlockCompleteMessage.BlockCompleteMessageImpl(snapshot);
     }
 
     public static MessageSnapshot take(byte status, FileDownloadModel model,

File: library/src/main/java/com/liulishuo/filedownloader/LostServiceConnectedHandler.java
Patch:
@@ -55,7 +55,7 @@ public void connected() {
                 }
                 //noinspection StatementWithEmptyBody
                 if (!task.getOrigin().isUsing()) {
-                    task.getOrigin().start();
+                    task.startTaskByRescue();
                 } else {
                     /** already handled
                      * by {@link FileDownloadEventPool#launchTask(DownloadTaskEvent)}

File: library/src/main/java/com/liulishuo/filedownloader/BaseDownloadTask.java
Patch:
@@ -261,6 +261,7 @@ public interface BaseDownloadTask {
      * @see IQueuesHandler#startQueueSerial(FileDownloadListener)
      * @see IQueuesHandler#startQueueParallel(FileDownloadListener)
      */
+    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
     boolean isAttached();
 
     /**

File: library/src/main/java/com/liulishuo/filedownloader/notification/FileDownloadNotificationHelper.java
Patch:
@@ -22,7 +22,7 @@
 
 /**
  * The helper for notifications with downloading tasks. You also can think this is the notifications
- * mananger.
+ * manager.
  *
  * @see BaseNotificationItem
  * @see FileDownloadNotificationListener

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadQueueSet.java
Patch:
@@ -142,7 +142,7 @@ public void start() {
                 task.setPath(this.directory, true);
             }
 
-            task.ready();
+            task.asInQueueTask().enqueue();
         }
 
         FileDownloader.getImpl().start(target, isSerial);

File: library/src/main/java/com/liulishuo/filedownloader/LostServiceConnectedHandler.java
Patch:
@@ -50,7 +50,7 @@ public void connected() {
 
             for (BaseDownloadTask.IRunningTask task : copyWaitingList) {
                 if (queueHandler.contain(task.getAttachKey())) {
-                    task.getOrigin().ready();
+                    task.getOrigin().asInQueueTask().enqueue();
                     continue;
                 }
                 //noinspection StatementWithEmptyBody

File: library/src/main/java/com/liulishuo/filedownloader/QueuesHandler.java
Patch:
@@ -53,7 +53,7 @@ public boolean startQueueParallel(FileDownloadListener listener) {
         }
 
         for (BaseDownloadTask.IRunningTask task : list) {
-            task.getOrigin().start();
+            task.startTaskByQueue();
         }
 
         return true;
@@ -201,8 +201,8 @@ public boolean handleMessage(final Message msg) {
 
 
                 stackTopTask.getOrigin()
-                        .addFinishListener(mSerialFinishListener.setNextIndex(mRunningIndex + 1))
-                        .start();
+                        .addFinishListener(mSerialFinishListener.setNextIndex(mRunningIndex + 1));
+                stackTopTask.startTaskByQueue();
 
             } else if (msg.what == WHAT_FREEZE) {
                 freeze();

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadTask.java
Patch:
@@ -118,7 +118,7 @@ protected void _startExecute() {
     @Override
     protected boolean _checkCanReuse() {
         return FileDownloadHelper.inspectAndInflowDownloaded(getId(), getTargetFilePath(),
-                isForceReDownload()) ||
+                isForceReDownload(), true) ||
                 super._checkCanReuse();
     }
 

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadMgr.java
Patch:
@@ -100,7 +100,7 @@ public synchronized void start(final String url, final String path, final boolea
             }
         }
 
-        if (FileDownloadHelper.inspectAndInflowDownloading(id, model, this)) {
+        if (FileDownloadHelper.inspectAndInflowDownloading(id, model, this, true)) {
             if (FileDownloadLog.NEED_LOG) {
                 FileDownloadLog.d(this, "has already started download %d", id);
             }
@@ -110,7 +110,8 @@ public synchronized void start(final String url, final String path, final boolea
         final String targetFilePath = model != null ? model.getTargetFilePath() :
                 FileDownloadUtils.getTargetFilePath(path, pathAsDirectory, null);
 
-        if (FileDownloadHelper.inspectAndInflowDownloaded(id, targetFilePath, forceReDownload)) {
+        if (FileDownloadHelper.inspectAndInflowDownloaded(id, targetFilePath, forceReDownload,
+                true)) {
             if (FileDownloadLog.NEED_LOG) {
                 FileDownloadLog.d(this, "has already completed downloading %d", id);
             }

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadRunnable.java
Patch:
@@ -313,8 +313,7 @@ private void loop(FileDownloadModel model) {
                                 model.getTargetFilePath());
 
                         if (FileDownloadHelper.inspectAndInflowDownloaded(getId(),
-                                model.getTargetFilePath(),
-                                isForceReDownload)) {
+                                model.getTargetFilePath(), isForceReDownload, false)) {
                             helper.remove(getId());
                             break;
                         }
@@ -323,7 +322,7 @@ private void loop(FileDownloadModel model) {
 
                         if (fileCaseModel != null) {
                             if (FileDownloadHelper.inspectAndInflowDownloading(getId(), fileCaseModel,
-                                    threadPoolMonitor)) {
+                                    threadPoolMonitor, false)) {
                                 helper.remove(getId());
                                 break;
                             }

File: demo/src/main/java/com/liulishuo/filedownloader/demo/SingleTaskTestActivity.java
Patch:
@@ -109,7 +109,7 @@ public void onClick(View v) {
         deleteBtn3.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
-                new File(llsApkDir).delete();
+                new File(normalTaskFilePath).delete();
             }
         });
     }

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloader.java
Patch:
@@ -566,6 +566,7 @@ public void stopForeground(boolean removeNotification) {
      * any longer. In new mechanism(filedownloader 0.3.3 or higher), FileDownloader doesn't store
      * completed tasks in Database anymore, because all downloading files have temp a file name.
      */
+    @SuppressWarnings("UnusedParameters")
     public boolean setTaskCompleted(String url, String path, long totalBytes) {
         FileDownloadLog.w(this, "If you invoked this method, please remove it directly feel free, " +
                 "it doesn't need any longer");
@@ -590,6 +591,7 @@ public boolean setTaskCompleted(String url, String path, long totalBytes) {
      * any longer. In new mechanism(filedownloader 0.3.3 or higher), FileDownloader doesn't store
      * completed tasks in Database anymore, because all downloading files have temp a file name.
      */
+    @SuppressWarnings("UnusedParameters")
     public boolean setTaskCompleted(@SuppressWarnings("deprecation") List<FileDownloadTaskAtom> taskAtomList) {
         FileDownloadLog.w(this, "If you invoked this method, please remove it directly feel free, " +
                 "it doesn't need any longer");

File: library/src/main/java/com/liulishuo/filedownloader/message/LargeMessageSnapshot.java
Patch:
@@ -182,8 +182,8 @@ public void writeToParcel(Parcel dest, int flags) {
     }
 
     public static class CompletedSnapshot extends LargeMessageSnapshot {
-        private boolean reusedDownloadedFile;
-        private long totalBytes;
+        private final boolean reusedDownloadedFile;
+        private final long totalBytes;
 
         CompletedSnapshot(int id, byte status, boolean reusedDownloadedFile,
                           long totalBytes) {

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadRunnable.java
Patch:
@@ -79,7 +79,7 @@ public class FileDownloadRunnable implements Runnable {
     private static final int BUFFER_SIZE = 1024 * 4;
 
     private int maxProgressCount = 0;
-    private boolean isForceReDownload;
+    private final boolean isForceReDownload;
     private boolean isResumeDownloadAvailable;
     private boolean isResuming;
     private Throwable throwable;
@@ -101,7 +101,7 @@ public class FileDownloadRunnable implements Runnable {
     private final int callbackMinIntervalMillis;
     private long callbackMinIntervalBytes;
 
-    private IThreadPoolMonitor threadPoolMonitor;
+    private final IThreadPoolMonitor threadPoolMonitor;
 
     public FileDownloadRunnable(final OkHttpClient client, final IThreadPoolMonitor threadPoolMonitor,
                                 final FileDownloadModel model,
@@ -205,6 +205,7 @@ public void run() {
 
     }
 
+    @SuppressWarnings("ConstantConditions")
     private void loop(FileDownloadModel model) {
         int retryingTimes = 0;
         boolean revisedInterval = false;

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadList.java
Patch:
@@ -74,7 +74,7 @@ int count(final int id) {
     public BaseDownloadTask get(final int id) {
         synchronized (list) {
             for (BaseDownloadTask baseDownloadTask : list) {
-                // when FileDownloadMgr#checkDownloading
+                // when FileDownloadMgr#isDownloading
                 if (baseDownloadTask.getId() == id) {
                     return baseDownloadTask;
                 }

File: library/src/main/java/com/liulishuo/filedownloader/IFileDownloadMessenger.java
Patch:
@@ -61,7 +61,7 @@ interface IFileDownloadMessenger {
      * <p/>
      * Already connected to the server, and received the Http-response.
      *
-     * @see FileDownloadRunnable#onConnected(boolean, long, String)
+     * @see FileDownloadRunnable#onConnected(boolean, long, String, String)
      */
     void notifyConnected(MessageSnapshot snapshot);
 
@@ -97,8 +97,8 @@ interface IFileDownloadMessenger {
      * There has already had some same Tasks(Same-URL & Same-SavePath) in Pending-Queue or is
      * running.
      *
-     * @see com.liulishuo.filedownloader.services.FileDownloadMgr#start(String, String, int, int, int, FileDownloadHeader)
-     * @see com.liulishuo.filedownloader.services.FileDownloadMgr#checkDownloading(String, String)
+     * @see com.liulishuo.filedownloader.services.FileDownloadMgr#start(String, String, boolean, int, int, int, boolean, FileDownloadHeader)
+     * @see com.liulishuo.filedownloader.services.FileDownloadMgr#isDownloading(String, String)
      */
     void notifyWarn(MessageSnapshot snapshot);
 

File: library/src/main/java/com/liulishuo/filedownloader/IFileDownloadServiceProxy.java
Patch:
@@ -26,10 +26,10 @@
  * The interface to access the FileDownloadService.
  */
 public interface IFileDownloadServiceProxy {
-    boolean start(final String url, final String path,
+    boolean start(final String url, final String path, final boolean pathAsDirectory,
                   final int callbackProgressTimes,
                   final int callbackProgressMinIntervalMillis,
-                  final int autoRetryTimes,
+                  final int autoRetryTimes, boolean forceReDownload,
                   final FileDownloadHeader header);
 
     boolean pause(final int id);

File: library/src/main/java/com/liulishuo/filedownloader/message/IMessageSnapshot.java
Patch:
@@ -45,4 +45,6 @@ interface IMessageSnapshot {
     boolean isReusedDownloadedFile();
 
     boolean isLargeFile();
+
+    String getFileName();
 }
\ No newline at end of file

File: library/src/main/java/com/liulishuo/filedownloader/model/FileDownloadStatus.java
Patch:
@@ -175,6 +175,5 @@ public static boolean isKeepFlow(final int status, final int nextStatus) {
 
     public static boolean isMoreLikelyCompleted(BaseDownloadTask task) {
         return task.getStatus() == INVALID_STATUS || task.getStatus() == progress;
-
     }
 }

File: library/src/main/java/com/liulishuo/filedownloader/model/FileDownloadTaskAtom.java
Patch:
@@ -30,8 +30,9 @@
  * Used for telling the FileDownloader Engine that a task was downloaded by the other ways.
  *
  * @see com.liulishuo.filedownloader.FileDownloader#setTaskCompleted(List)
+ * @deprecated No used. {@link com.liulishuo.filedownloader.FileDownloader#setTaskCompleted(String, String, long)}
  */
-@SuppressWarnings("WeakerAccess")
+@SuppressWarnings({"WeakerAccess", "deprecation"})
 public class FileDownloadTaskAtom implements Parcelable {
     private String url;
     private String path;

File: library/src/main/java/com/liulishuo/filedownloader/services/IFileDownloadDBHelper.java
Patch:
@@ -42,7 +42,8 @@ interface IFileDownloadDBHelper {
 
     void remove(final int id);
 
-    void updateConnected(final FileDownloadModel model, final long total, final String etag);
+    void updateConnected(final FileDownloadModel model, final long total, final String etag,
+                         final String fileName);
 
     void updateProgress(final FileDownloadModel model, final long soFar);
 

File: library/src/main/java/com/liulishuo/filedownloader/util/DownloadServiceNotConnectedHelper.java
Patch:
@@ -27,10 +27,10 @@
  */
 public class DownloadServiceNotConnectedHelper {
 
-    public static boolean start(final String url, final String path) {
+    public static boolean start(final String url, final String path, final boolean pathAsDirectory) {
         FileDownloadLog.w(DownloadServiceNotConnectedHelper.class,
-                "request start the task([%s],[%s]) in the download service," +
-                        " but the download service isn't connected yet.", url, path);
+                "request start the task([%s], [%s], [%B]) in the download service," +
+                        " but the download service isn't connected yet.", url, path, pathAsDirectory);
         return false;
     }
 

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadList.java
Patch:
@@ -83,11 +83,12 @@ public BaseDownloadTask get(final int id) {
         return null;
     }
 
-    List<BaseDownloadTask> getList(final int id) {
+    List<BaseDownloadTask> getDownloadingList(final int id) {
         final List<BaseDownloadTask> list = new ArrayList<>();
         synchronized (this.list) {
             for (BaseDownloadTask baseDownloadTask : this.list) {
-                if (baseDownloadTask.getId() == id) {
+                if (baseDownloadTask.getId() == id &&
+                        !FileDownloadStatus.isOver(baseDownloadTask.getStatus())) {
                     list.add(baseDownloadTask);
                 }
             }

File: library/src/main/java/com/liulishuo/filedownloader/services/IFileDownloadDBHelper.java
Patch:
@@ -48,9 +48,9 @@ interface IFileDownloadDBHelper {
 
     void updateProgress(final FileDownloadModel model, final long soFar);
 
-    void updateError(final FileDownloadModel model, final String errMsg, final long sofar);
+    void updateError(final FileDownloadModel model, final Throwable throwable, final long sofar);
 
-    void updateRetry(final FileDownloadModel model, final String errMsg);
+    void updateRetry(final FileDownloadModel model, final Throwable throwable);
 
     void updateComplete(final FileDownloadModel model, final long total);
 

File: library/src/main/java/com/liulishuo/filedownloader/event/DownloadEventPoolImpl.java
Patch:
@@ -96,7 +96,7 @@ public boolean removeListener(final String eventId, final IDownloadListener list
         synchronized (eventId.intern()) {
             boolean succeed = container.remove(listener);
             if (container.size() <= 0) {
-                listenersMap.remove(container);
+                listenersMap.remove(eventId);
             }
             return succeed;
         }

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadList.java
Patch:
@@ -195,7 +195,8 @@ boolean remove(final BaseDownloadTask willRemoveDownload, final byte removeBySta
             }
 
         } else {
-            FileDownloadLog.e(this, "remove error, not exist: %s", willRemoveDownload);
+            FileDownloadLog.e(this, "remove error, not exist: %s %d", willRemoveDownload,
+                    removeByStatus);
         }
 
         return succeed;

File: library/src/main/java/com/liulishuo/filedownloader/exception/FileDownloadHttpException.java
Patch:
@@ -35,7 +35,7 @@ public class FileDownloadHttpException extends RuntimeException {
     private final HeaderWrap responseHeaderWrap;
 
     public FileDownloadHttpException(final Request request, final Response response) {
-        super(String.format("response code error: %d, \n request headers: %s \n " +
+        super(FileDownloadUtils.formatString("response code error: %d, \n request headers: %s \n " +
                 "response headers: %s", response.code(), request.headers(), response.headers()));
 
         this.code = response.code();

File: library/src/main/java/com/liulishuo/filedownloader/util/FileDownloadLog.java
Patch:
@@ -66,7 +66,7 @@ private static void log(int priority, Object o, Throwable throwable, String mess
             return;
         }
 
-        Log.println(priority, getTag(o), String.format(message, args));
+        Log.println(priority, getTag(o), FileDownloadUtils.formatString(message, args));
         if (throwable != null) {
             throwable.printStackTrace();
         }

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadRunnable.java
Patch:
@@ -371,7 +371,7 @@ private void addHeader(Request.Builder builder) {
             if (!TextUtils.isEmpty(model.getETag())) {
                 builder.addHeader("If-Match", model.getETag());
             }
-            builder.addHeader("Range", String.format("bytes=%d-", model.getSoFar()));
+            builder.addHeader("Range", FileDownloadUtils.formatString("bytes=%d-", model.getSoFar()));
         }
     }
 

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadConnectListener.java
Patch:
@@ -19,7 +19,6 @@
 import com.liulishuo.filedownloader.event.DownloadServiceConnectChangedEvent;
 import com.liulishuo.filedownloader.event.IDownloadEvent;
 import com.liulishuo.filedownloader.event.IDownloadListener;
-import com.liulishuo.filedownloader.services.FileDownloadService;
 
 /**
  * Created by Jacksgong on 1/10/16.
@@ -38,8 +37,7 @@ public boolean callback(IDownloadEvent event) {
         if (event instanceof DownloadServiceConnectChangedEvent) {
             final DownloadServiceConnectChangedEvent connectChangedEvent
                     = (DownloadServiceConnectChangedEvent) event;
-            if (connectChangedEvent.isSuchService(FileDownloadService.class)
-                    && connectChangedEvent.getStatus()
+            if (connectChangedEvent.getStatus()
                     == DownloadServiceConnectChangedEvent.ConnectStatus.connected) {
                 connected();
             } else {

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadServiceProxy.java
Patch:
@@ -21,6 +21,7 @@
 import com.liulishuo.filedownloader.model.FileDownloadHeader;
 import com.liulishuo.filedownloader.model.FileDownloadTransferModel;
 import com.liulishuo.filedownloader.services.FDServiceSharedHandler;
+import com.liulishuo.filedownloader.util.FileDownloadProperties;
 
 /**
  * Created by Jacksgong on 4/17/16.
@@ -53,7 +54,7 @@ public static FDServiceSharedHandler.FileDownloadServiceSharedConnection getConn
     private final IFileDownloadServiceProxy handler;
 
     private FileDownloadServiceProxy() {
-        handler = BuildConfig.PROCESS_NON_SEPARATE ?
+        handler = FileDownloadProperties.getImpl().PROCESS_NON_SEPARATE ?
                 new FileDownloadServiceSharedTransmit() :
                 new FileDownloadServiceUIGuard();
     }

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadServiceUIGuard.java
Patch:
@@ -27,7 +27,7 @@
 import com.liulishuo.filedownloader.model.FileDownloadStatus;
 import com.liulishuo.filedownloader.model.FileDownloadTransferModel;
 import com.liulishuo.filedownloader.services.BaseFileServiceUIGuard;
-import com.liulishuo.filedownloader.services.FileDownloadService;
+import com.liulishuo.filedownloader.services.FileDownloadService.SeparateProcessService;
 
 
 /**
@@ -49,7 +49,7 @@ class FileDownloadServiceUIGuard extends
                 IFileDownloadIPCService> {
 
     FileDownloadServiceUIGuard() {
-        super(FileDownloadService.class);
+        super(SeparateProcessService.class);
     }
 
     @Override

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadRunnable.java
Patch:
@@ -21,7 +21,6 @@
 import android.os.SystemClock;
 import android.text.TextUtils;
 
-import com.liulishuo.filedownloader.BuildConfig;
 import com.liulishuo.filedownloader.FileDownloadEventPool;
 import com.liulishuo.filedownloader.event.DownloadTransferEvent;
 import com.liulishuo.filedownloader.exception.FileDownloadGiveUpRetryException;
@@ -32,6 +31,7 @@
 import com.liulishuo.filedownloader.model.FileDownloadStatus;
 import com.liulishuo.filedownloader.model.FileDownloadTransferModel;
 import com.liulishuo.filedownloader.util.FileDownloadLog;
+import com.liulishuo.filedownloader.util.FileDownloadProperties;
 import com.liulishuo.filedownloader.util.FileDownloadUtils;
 
 import java.io.File;
@@ -226,7 +226,7 @@ private void loop(FileDownloadModel model) {
                                 && transferEncoding.equals("chunked");
                         if (!isEncodingChunked) {
                             // not chunked transfer encoding data
-                            if (BuildConfig.HTTP_LENIENT) {
+                            if (FileDownloadProperties.getImpl().HTTP_LENIENT) {
                                 // do not response content-length either not chunk transfer encoding,
                                 // but HTTP lenient is true, so handle as the case of transfer encoding chunk
                                 total = -1;

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadMgr.java
Patch:
@@ -110,7 +110,6 @@ public synchronized void start(final String url, final String path, final int ca
         }
 
         model.setCallbackProgressTimes(callbackProgressTimes);
-        model.setIsCancel(false);
 
         // - update model to db
         if (needUpdate2DB) {
@@ -328,7 +327,8 @@ public boolean pause(final int id) {
         if (FileDownloadLog.NEED_LOG) {
             FileDownloadLog.d(this, "paused %d", id);
         }
-        model.setIsCancel(true);
+
+        mThreadPool.cancel(id);
         /**
          *  by {@link FileDownloadRunnable#run()}  {@link com.squareup.okhttp.Request.Builder#tag(Object)}
          * okHttp

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadRunnable.java
Patch:
@@ -572,7 +572,8 @@ private Throwable exFiltrate(Throwable ex) {
          * Only handle the case of Chunked resource, if it is not chunked, has already been handled
          * in {@link #getRandomAccessFile(boolean, long)}.
          */
-        if (model.getTotal() == -1 && ex instanceof IOException) {
+        if (model.getTotal() == -1 && ex instanceof IOException &&
+                new File(model.getPath()).exists()) {
             // chunked
             final long freeSpaceBytes = FileDownloadUtils.
                     getFreeSpaceBytes(model.getPath());

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadDBHelper.java
Patch:
@@ -231,18 +231,16 @@ public void updateError(int id, String errMsg) {
     }
 
     @Override
-    public void updateRetry(int id, String errMsg, int retryingTimes, final long soFar) {
+    public void updateRetry(int id, String errMsg, int retryingTimes) {
         final FileDownloadModel downloadModel = find(id);
         if (downloadModel != null) {
             downloadModel.setStatus(FileDownloadStatus.retry);
             downloadModel.setErrMsg(errMsg);
-            downloadModel.setSoFar(soFar);
 
             // db
             ContentValues cv = new ContentValues();
             cv.put(FileDownloadModel.ERR_MSG, errMsg);
             cv.put(FileDownloadModel.STATUS, FileDownloadStatus.retry);
-            cv.put(FileDownloadModel.SOFAR, soFar);
             db.update(TABLE_NAME, cv, FileDownloadModel.ID + " = ? ", new String[]{String.valueOf(id)});
         }
     }

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadRunnable.java
Patch:
@@ -432,7 +432,7 @@ private void onRetry(Throwable ex, final int retryTimes, final long soFarBytes)
         }
 
         ex = exFiltrate(ex);
-        helper.updateRetry(getId(), ex.getMessage(), retryTimes, soFarBytes);
+        helper.updateRetry(getId(), ex.getMessage(), retryTimes);
 
         transferModel.setThrowable(ex);
         transferModel.setRetryingTimes(retryTimes);

File: library/src/main/java/com/liulishuo/filedownloader/services/IFileDownloadDBHelper.java
Patch:
@@ -52,7 +52,7 @@ interface IFileDownloadDBHelper {
 
     void updateError(final int id, final String errMsg);
 
-    void updateRetry(final int id, final String errMsg, final int retryingTimes, final long soFar);
+    void updateRetry(final int id, final String errMsg, final int retryingTimes);
 
     void updateComplete(final int id, final long total);
 

File: library/src/main/java/com/liulishuo/filedownloader/model/FileDownloadStatus.java
Patch:
@@ -51,7 +51,7 @@ public static boolean isIng(final int status) {
     }
 
     public static boolean isKeepAhead(final int status, final int nextStatus) {
-        if (status != progress && status == nextStatus) {
+        if (status != progress && status != retry && status == nextStatus) {
             return false;
         }
 
@@ -112,7 +112,7 @@ public static boolean isKeepAhead(final int status, final int nextStatus) {
     }
 
     public static boolean isKeepFlow(final int status, final int nextStatus) {
-        if (status != progress && status == nextStatus) {
+        if (status != progress && status != retry && status == nextStatus) {
             return false;
         }
 
@@ -148,6 +148,7 @@ public static boolean isKeepFlow(final int status, final int nextStatus) {
             case retry:
             case started:
                 switch (nextStatus) {
+                    case retry:
                     case connected:
                         return true;
                     default:

File: library/src/main/java/com/liulishuo/filedownloader/BaseDownloadTask.java
Patch:
@@ -882,6 +882,8 @@ private void update(final FileDownloadTransferModel transfer) {
                         // keep and wait callback
 
                         setStatus(FileDownloadStatus.pending);
+                        setTotalBytes(transfer.getTotalBytes());
+                        setSoFarBytes(transfer.getSoFarBytes());
                         getDriver().notifyPending();
                         break;
                     } else {

File: library/src/main/java/com/liulishuo/filedownloader/model/FileDownloadTransferModel.java
Patch:
@@ -153,6 +153,7 @@ public void writeToParcel(Parcel dest, int flags) {
 
         // For fewer copies
         switch (this.status) {
+            case FileDownloadStatus.warn:
             case FileDownloadStatus.pending:
                 dest.writeLong(this.soFarBytes);
                 dest.writeLong(this.totalBytes);
@@ -194,6 +195,7 @@ protected FileDownloadTransferModel(Parcel in) {
 
         // For fewer copies
         switch (this.status) {
+            case FileDownloadStatus.warn:
             case FileDownloadStatus.pending:
                 this.soFarBytes = in.readLong();
                 this.totalBytes = in.readLong();

File: library/src/main/java/com/liulishuo/filedownloader/model/FileDownloadStatus.java
Patch:
@@ -43,6 +43,6 @@ public static boolean isOver(final int status) {
     }
 
     public static boolean isIng(final int status) {
-        return status >= pending && status <= retry;
+        return status >= pending && status <= started;
     }
 }

File: library/src/main/java/com/liulishuo/filedownloader/BaseDownloadTask.java
Patch:
@@ -882,8 +882,7 @@ boolean update(final FileDownloadTransferModel transfer) {
             case FileDownloadStatus.completed:
                 if (getStatus() != FileDownloadStatus.INVALID_STATUS &&
                         getStatus() != FileDownloadStatus.connected &&
-                        getStatus() != FileDownloadStatus.progress &&
-                        getStatus() != FileDownloadStatus.pending) {
+                        getStatus() != FileDownloadStatus.progress) {
                     printNotMatchReasonLog(transfer.getStatus());
                     break;
                 }

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadServiceUIGuard.java
Patch:
@@ -77,7 +77,7 @@ public static class FileDownloadServiceCallback extends IFileDownloadIPCCallback
 
         @Override
         public void callback(FileDownloadTransferModel transfer) throws RemoteException {
-            FileDownloadEventPool.getImpl().receiveByService(new DownloadTransferEvent(transfer));
+            FileDownloadEventPool.getImpl().asyncPublishInFlow(new DownloadTransferEvent(transfer));
         }
     }
 

File: library/src/main/java/com/liulishuo/filedownloader/event/IDownloadEventPool.java
Patch:
@@ -42,4 +42,6 @@ public interface IDownloadEventPool {
 
     void asyncPublishInMain(final IDownloadEvent event);
 
+    void asyncPublishInFlow(final DownloadTransferEvent event);
+
 }

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadMgr.java
Patch:
@@ -17,6 +17,7 @@
 package com.liulishuo.filedownloader.services;
 
 
+import com.liulishuo.filedownloader.FileDownloadEventPool;
 import com.liulishuo.filedownloader.event.DownloadTransferEvent;
 import com.liulishuo.filedownloader.model.FileDownloadHeader;
 import com.liulishuo.filedownloader.model.FileDownloadModel;
@@ -76,7 +77,7 @@ public synchronized void start(final String url, final String path, final int ca
             warnModel.setDownloadId(id);
             warnModel.setStatus(FileDownloadStatus.warn);
 
-            FileDownloadProcessEventPool.getImpl()
+            FileDownloadEventPool.getImpl()
                     .publish(new DownloadTransferEvent(warnModel));
             return;
         }

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadService.java
Patch:
@@ -18,6 +18,7 @@
 
 import android.os.RemoteException;
 
+import com.liulishuo.filedownloader.FileDownloadEventPool;
 import com.liulishuo.filedownloader.event.DownloadEventSampleListener;
 import com.liulishuo.filedownloader.event.DownloadTransferEvent;
 import com.liulishuo.filedownloader.event.IDownloadEvent;
@@ -48,14 +49,14 @@ public void onCreate() {
         super.onCreate();
         mListener = new DownloadEventSampleListener(this);
 
-        FileDownloadProcessEventPool.getImpl().addListener(DownloadTransferEvent.ID, mListener);
+        FileDownloadEventPool.getImpl().addListener(DownloadTransferEvent.ID, mListener);
     }
 
     @Override
     public void onDestroy() {
         super.onDestroy();
 
-        FileDownloadProcessEventPool.getImpl().removeListener(DownloadTransferEvent.ID, mListener);
+        FileDownloadEventPool.getImpl().removeListener(DownloadTransferEvent.ID, mListener);
     }
 
     @Override

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadRunnable.java
Patch:
@@ -531,7 +531,7 @@ private RandomAccessFile getRandomAccessFile(final boolean append, final long to
             if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
                 availableBytes = statFs.getAvailableBytes();
             } else {
-                availableBytes = statFs.getAvailableBlocks() * statFs.getBlockSize();
+                availableBytes = statFs.getAvailableBlocks() * (long) statFs.getBlockSize();
             }
 
             if (availableBytes < needAvailableSpace) {

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadRunnable.java
Patch:
@@ -314,7 +314,7 @@ private boolean fetch(Response response, boolean isSucceedContinue,
             } while (true);
 
 
-            // Step 7, adapter chuncked transfer encoding
+            // Step 7, adapter chunked transfer encoding
             if (total == -1) {
                 total = soFar;
             }

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadLargeFileListener.java
Patch:
@@ -53,7 +53,7 @@ public boolean callback(IDownloadEvent event) {
             case FileDownloadStatus.connected:
                 connected(downloaderEvent.getDownloader(),
                         downloaderEvent.getDownloader().getEtag(),
-                        downloaderEvent.getDownloader().isContinue(),
+                        downloaderEvent.getDownloader().isResuming(),
                         downloaderEvent.getDownloader().getLargeFileSoFarBytes(),
                         downloaderEvent.getDownloader().getLargeFileTotalBytes());
                 break;

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadListener.java
Patch:
@@ -63,7 +63,7 @@ public boolean callback(IDownloadEvent event) {
             case FileDownloadStatus.connected:
                 connected(downloaderEvent.getDownloader(),
                         downloaderEvent.getDownloader().getEtag(),
-                        downloaderEvent.getDownloader().isContinue(),
+                        downloaderEvent.getDownloader().isResuming(),
                         downloaderEvent.getDownloader().getSmallFileSoFarBytes(),
                         downloaderEvent.getDownloader().getSmallFileTotalBytes());
                 break;

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadDBHelper.java
Patch:
@@ -228,16 +228,18 @@ public void updateError(int id, String errMsg) {
     }
 
     @Override
-    public void updateRetry(int id, String errMsg, int retryingTimes) {
+    public void updateRetry(int id, String errMsg, int retryingTimes, final long soFar) {
         final FileDownloadModel downloadModel = find(id);
         if (downloadModel != null) {
             downloadModel.setStatus(FileDownloadStatus.retry);
             downloadModel.setErrMsg(errMsg);
+            downloadModel.setSoFar(soFar);
 
             // db
             ContentValues cv = new ContentValues();
             cv.put(FileDownloadModel.ERR_MSG, errMsg);
             cv.put(FileDownloadModel.STATUS, FileDownloadStatus.retry);
+            cv.put(FileDownloadModel.SOFAR, soFar);
             db.update(TABLE_NAME, cv, FileDownloadModel.ID + " = ? ", new String[]{String.valueOf(id)});
         }
     }

File: library/src/main/java/com/liulishuo/filedownloader/services/IFileDownloadDBHelper.java
Patch:
@@ -50,7 +50,7 @@ interface IFileDownloadDBHelper {
 
     void updateError(final int id, final String errMsg);
 
-    void updateRetry(final int id, final String errMsg, final int retryingTimes);
+    void updateRetry(final int id, final String errMsg, final int retryingTimes, final long soFar);
 
     void updateComplete(final int id, final long total);
 

File: demo/src/main/java/com/liulishuo/filedownloader/demo/Constant.java
Patch:
@@ -5,9 +5,8 @@
  */
 public interface Constant {
 
-    String[] CHUNKED_TRANSFER_ENCODING_DATAS = {
-            "http://www.funonsite.com/funarea/ringtones/download-ringtone-953-funonsite.com.mp3",
-            "http://www.funonsite.com/funarea/ringtones/download-ringtone-951-funonsite.com.mp3"
+    String[] CHUNKED_TRANSFER_ENCODING_DATA_URLS = {
+            "http://www.httpwatch.com/httpgallery/chunked/chunkedimage.aspx?0.04400023248109086",
     };
 
     String[] BIG_FILE_URLS = {

File: library/src/main/java/com/liulishuo/filedownloader/services/BaseFileServiceUIGuard.java
Patch:
@@ -94,7 +94,7 @@ public void onServiceDisconnected(ComponentName name) {
     }
 
     private void releaseConnect(final boolean isLost) {
-        if (this.service != null) {
+        if (!isLost && this.service != null) {
             try {
                 unregisterCallback(this.service, this.callback);
             } catch (RemoteException e) {

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadEventPool.java
Patch:
@@ -90,14 +90,14 @@ public boolean publish(IDownloadEvent event) {
         if (event instanceof FileDownloadEvent) {
             final FileDownloadEvent fileDownloadEvent = (FileDownloadEvent) event;
             if (fileDownloadEvent.getDownloader() == null) {
-                FileDownloadLog.e(FileDownloadEventPool.this, "can't invoke callback method %d," +
+                FileDownloadLog.e(FileDownloadEventPool.this, "can't invoke callback method %s," +
                         " do not find downloader in event", event.getId());
                 return false;
             }
 
             if (fileDownloadEvent.getDownloader().getListener() == null) {
                 if (FileDownloadLog.NEED_LOG) {
-                    FileDownloadLog.d(FileDownloadEventPool.this, "do not invoke  callback method %d, " +
+                    FileDownloadLog.d(FileDownloadEventPool.this, "do not invoke  callback method %s, " +
                             "no listener be found in task.", fileDownloadEvent.getId());
                 }
 

File: library/src/main/java/com/liulishuo/filedownloader/event/DownloadServiceConnectChangedEvent.java
Patch:
@@ -33,14 +33,15 @@ public DownloadServiceConnectChangedEvent(final ConnectStatus status, final Clas
     private final ConnectStatus status;
 
     public enum ConnectStatus {
-        connected, disconnected
+        connected, disconnected,
+        // the process hosting the service has crashed or been killed. (do not be unbound manually)
+        lost
     }
 
     public ConnectStatus getStatus() {
         return status;
     }
 
-
     private final Class<?> serviceClass;
 
     public boolean isSuchService(final Class<?> serviceClass) {

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadRunnable.java
Patch:
@@ -289,7 +289,7 @@ private boolean fetch(Response response, boolean isSucceedContinue,
                 // Step 4, adapter sofar
                 soFar += byteCount;
 
-                // Step 5, check whether file be changed by others
+                // Step 5, check whether file is changed by others
                 if (accessFile.length() < soFar) {
                     // 
                     throw new RuntimeException(String.format("file be changed by others when downloading %d %d", accessFile.length(), soFar));

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadListener.java
Patch:
@@ -37,6 +37,7 @@ public FileDownloadListener() {
     }
 
     /**
+     * @see #FileDownloadListener()
      * @param priority
      * @deprecated not handle priority any more
      */

File: library/src/main/java/com/liulishuo/filedownloader/BaseDownloadTask.java
Patch:
@@ -232,7 +232,7 @@ public BaseDownloadTask addHeader(final String line) {
     /**
      * @see okhttp3.Headers.Builder#removeAll(String)
      */
-    public BaseDownloadTask removeAll(final String name) {
+    public BaseDownloadTask removeAllHeaders(final String name) {
         if (header == null) {
             synchronized (headerCreateLock) {
                 // maybe invoking checkAndCreateHear and will to be available.

File: library/src/main/java/com/liulishuo/filedownloader/util/FileDownloadLog.java
Patch:
@@ -56,7 +56,8 @@ private static void log(int priority, Object o, String message, Object... args)
     }
 
     private static void log(int priority, Object o, Throwable throwable, String message, Object... args) {
-        if (!NEED_LOG) {
+        final boolean force = priority >= Log.WARN;
+        if (!force && !NEED_LOG) {
             return;
         }
 

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadDBHelper.java
Patch:
@@ -83,7 +83,8 @@ public void refreshDataFromDB() {
                 model.setErrMsg(c.getString(c.getColumnIndex(FileDownloadModel.ERR_MSG)));
                 model.setETag(c.getString(c.getColumnIndex(FileDownloadModel.ETAG)));
                 if (model.getStatus() == FileDownloadStatus.progress ||
-                        model.getStatus() == FileDownloadStatus.connected) {
+                        model.getStatus() == FileDownloadStatus.connected ||
+                        model.getStatus() == FileDownloadStatus.error) {
                     // 
                     model.setStatus(FileDownloadStatus.paused);
                 }

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadRunnable.java
Patch:
@@ -115,10 +115,11 @@ public boolean isExist() {
 
     @Override
     public void run() {
+        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
+
         isPending = false;
         isRunning = true;
         int retryingTimes = 0;
-        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
 
         FileDownloadModel model = this.downloadModel;
 

File: library/src/main/java/com/liulishuo/filedownloader/BaseDownloadTask.java
Patch:
@@ -202,7 +202,7 @@ public BaseDownloadTask setAutoRetryTimes(int autoRetryTimes) {
     }
 
     /**
-     * We have already handled etag, and will add 'If-Match' & 'Range' value if valid.
+     * We have already handled etag, and will add 'If-Match' & 'Range' value if it works.
      *
      * @see okhttp3.Headers.Builder#add(String, String)
      */
@@ -213,7 +213,7 @@ public BaseDownloadTask addHeader(final String name, final String value) {
     }
 
     /**
-     * We have already handled etag, and will add 'If-Match' & 'Range' value if valid.
+     * We have already handled etag, and will add 'If-Match' & 'Range' value if it works.
      *
      * @see okhttp3.Headers.Builder#add(String, String)
      */

File: library/src/main/java/com/liulishuo/filedownloader/model/FileDownloadHeader.java
Patch:
@@ -23,7 +23,7 @@
 import okhttp3.Request;
 
 /**
- * We have already handled etag, and will add 'If-Match' & 'Range' value if valid.
+ * We have already handled etag, and will add 'If-Match' & 'Range' value if it works.
  * <p/>
  * Created by Jacksgong on 1/17/16.
  */
@@ -35,7 +35,7 @@ public class FileDownloadHeader implements Parcelable {
     private String[] namesAndValues;
 
     /**
-     * We have already handled etag, and will add 'If-Match' & 'Range' value if valid.
+     * We have already handled etag, and will add 'If-Match' & 'Range' value if it works.
      *
      * @see com.liulishuo.filedownloader.services.FileDownloadRunnable#addHeader(Request.Builder)
      * @see okhttp3.Headers.Builder#add(String, String)
@@ -49,7 +49,7 @@ public void add(String name, String value) {
     }
 
     /**
-     * We have already handled etag, and will add 'If-Match' & 'Range' value if valid.
+     * We have already handled etag, and will add 'If-Match' & 'Range' value if it works.
      *
      * @see com.liulishuo.filedownloader.services.FileDownloadRunnable#addHeader(Request.Builder)
      * @see okhttp3.Headers.Builder#add(String, String)

File: library/src/main/java/com/liulishuo/filedownloader/BaseDownloadTask.java
Patch:
@@ -202,7 +202,7 @@ public BaseDownloadTask setAutoRetryTimes(int autoRetryTimes) {
     }
 
     /**
-     * We have already handle etag, and will add 'If-Match' & 'Range' automatically if it in effect.
+     * We have already handled etag, and will add 'If-Match' & 'Range' value if valid.
      *
      * @see okhttp3.Headers.Builder#add(String, String)
      */
@@ -213,7 +213,7 @@ public BaseDownloadTask addHeader(final String name, final String value) {
     }
 
     /**
-     * We have already handle etag, and will add 'If-Match' & 'Range' automatically if it in effect.
+     * We have already handled etag, and will add 'If-Match' & 'Range' value if valid.
      *
      * @see okhttp3.Headers.Builder#add(String, String)
      */

File: library/src/main/java/com/liulishuo/filedownloader/model/FileDownloadHeader.java
Patch:
@@ -23,7 +23,7 @@
 import okhttp3.Request;
 
 /**
- * We have already handle etag, and will add 'If-Match' & 'Range' if it in effect.
+ * We have already handled etag, and will add 'If-Match' & 'Range' value if valid.
  * <p/>
  * Created by Jacksgong on 1/17/16.
  */
@@ -35,7 +35,7 @@ public class FileDownloadHeader implements Parcelable {
     private String[] namesAndValues;
 
     /**
-     * We have already handle etag, and will add 'If-Match' & 'Range' if it in effect.
+     * We have already handled etag, and will add 'If-Match' & 'Range' value if valid.
      *
      * @see com.liulishuo.filedownloader.services.FileDownloadRunnable#addHeader(Request.Builder)
      * @see okhttp3.Headers.Builder#add(String, String)
@@ -49,7 +49,7 @@ public void add(String name, String value) {
     }
 
     /**
-     * We have already handle etag, and will add 'If-Match' & 'Range' if it in effect.
+     * We have already handled etag, and will add 'If-Match' & 'Range' value if valid.
      *
      * @see com.liulishuo.filedownloader.services.FileDownloadRunnable#addHeader(Request.Builder)
      * @see okhttp3.Headers.Builder#add(String, String)

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadTask.java
Patch:
@@ -163,7 +163,7 @@ public boolean callback(IDownloadEvent event) {
 
                     if (transfer.getStatus() == FileDownloadStatus.warn) {
                         // just update one task, another will be maintained to receive other status
-                        final BaseDownloadTask task = taskList.get(0);
+                        final BaseDownloadTask task = taskList.get(taskList.size() - 1);
                         task.update(transfer);
                     } else {
                         // guarantee: 1. BaseDownloadTask#update pass no change status.

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadRunnable.java
Patch:
@@ -141,8 +141,9 @@ public void run() {
             long soFar = 0;
             try {
 
-                if (model.isCanceled()) {
+                if (isCancelled()) {
                     FileDownloadLog.d(this, "already canceled %d %d", model.getId(), model.getStatus());
+                    onPause();
                     break;
                 }
 

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadDBHelper.java
Patch:
@@ -154,7 +154,7 @@ public void remove(int id) {
     private long lastRefreshUpdate = 0;
 
     @Override
-    public void update(int id, byte status, int soFar, int total) {
+    public void update(int id, byte status, long soFar, long total) {
         final FileDownloadModel downloadModel = find(id);
         if (downloadModel != null) {
             downloadModel.setStatus(status);
@@ -226,7 +226,7 @@ public void updateRetry(int id, String errMsg, int retryingTimes) {
     }
 
     @Override
-    public void updateComplete(int id, final int total) {
+    public void updateComplete(int id, final long total) {
         final FileDownloadModel downloadModel = find(id);
         if (downloadModel != null) {
             downloadModel.setStatus(FileDownloadStatus.completed);

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadMgr.java
Patch:
@@ -193,7 +193,7 @@ public boolean pause(final int id) {
         return true;
     }
 
-    public int getSoFar(final int id) {
+    public long getSoFar(final int id) {
         final FileDownloadModel model = mHelper.find(id);
         if (model == null) {
             return 0;
@@ -202,7 +202,7 @@ public int getSoFar(final int id) {
         return model.getSoFar();
     }
 
-    public int getTotal(final int id) {
+    public long getTotal(final int id) {
         final FileDownloadModel model = mHelper.find(id);
         if (model == null) {
             return 0;

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadService.java
Patch:
@@ -109,12 +109,12 @@ public boolean pause(int downloadId) throws RemoteException {
         }
 
         @Override
-        public int getSofar(int downloadId) throws RemoteException {
+        public long getSofar(int downloadId) throws RemoteException {
             return downloadManager.getSoFar(downloadId);
         }
 
         @Override
-        public int getTotal(int downloadId) throws RemoteException {
+        public long getTotal(int downloadId) throws RemoteException {
             return downloadManager.getTotal(downloadId);
         }
     }

File: library/src/main/java/com/liulishuo/filedownloader/services/IFileDownloadDBHelper.java
Patch:
@@ -44,15 +44,15 @@ interface IFileDownloadDBHelper {
 
     void remove(final int id);
 
-    void update(final int id, final byte status, final int soFar, final int total);
+    void update(final int id, final byte status, final long soFar, final long total);
 
     void updateHeader(final int id, final String etag);
 
     void updateError(final int id, final String errMsg);
 
     void updateRetry(final int id, final String errMsg, final int retryingTimes);
 
-    void updateComplete(final int id, final int total);
+    void updateComplete(final int id, final long total);
 
     void updatePause(final int id);
 

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadTask.java
Patch:
@@ -16,10 +16,10 @@
 
 package com.liulishuo.filedownloader;
 
-import com.liulishuo.filedownloader.event.DownloadEventPool;
 import com.liulishuo.filedownloader.event.DownloadEventSampleListener;
 import com.liulishuo.filedownloader.event.DownloadServiceConnectChangedEvent;
 import com.liulishuo.filedownloader.event.DownloadTransferEvent;
+import com.liulishuo.filedownloader.event.FileDownloadEventPool;
 import com.liulishuo.filedownloader.event.IDownloadEvent;
 import com.liulishuo.filedownloader.model.FileDownloadTransferModel;
 import com.liulishuo.filedownloader.util.FileDownloadHelper;
@@ -38,8 +38,8 @@ class FileDownloadTask extends BaseDownloadTask {
 
     static {
         DOWNLOAD_INTERNAL_LIS = new DownloadEventSampleListener(new FileDownloadInternalLis());
-        DownloadEventPool.getImpl().addListener(DownloadServiceConnectChangedEvent.ID, DOWNLOAD_INTERNAL_LIS);
-        DownloadEventPool.getImpl().addListener(DownloadTransferEvent.ID, DOWNLOAD_INTERNAL_LIS);
+        FileDownloadEventPool.getImpl().addListener(DownloadServiceConnectChangedEvent.ID, DOWNLOAD_INTERNAL_LIS);
+        FileDownloadEventPool.getImpl().addListener(DownloadTransferEvent.ID, DOWNLOAD_INTERNAL_LIS);
     }
 
     FileDownloadTask(String url) {

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadService.java
Patch:
@@ -18,7 +18,6 @@
 
 import android.os.RemoteException;
 
-import com.liulishuo.filedownloader.event.DownloadEventPool;
 import com.liulishuo.filedownloader.event.DownloadEventSampleListener;
 import com.liulishuo.filedownloader.event.DownloadTransferEvent;
 import com.liulishuo.filedownloader.event.IDownloadEvent;
@@ -38,14 +37,14 @@ public void onCreate() {
         super.onCreate();
         mListener = new DownloadEventSampleListener(this);
 
-        DownloadEventPool.getImpl().addListener(DownloadTransferEvent.ID, mListener);
+        FileDownloadProcessEventPool.getImpl().addListener(DownloadTransferEvent.ID, mListener);
     }
 
     @Override
     public void onDestroy() {
         super.onDestroy();
 
-        DownloadEventPool.getImpl().removeListener(DownloadTransferEvent.ID, mListener);
+        FileDownloadProcessEventPool.getImpl().removeListener(DownloadTransferEvent.ID, mListener);
     }
 
     @Override

File: library/src/main/java/com/liulishuo/filedownloader/BaseDownloadTask.java
Patch:
@@ -531,6 +531,7 @@ FileDownloadDriver getDriver() {
     // ------------------
     // 
     void begin() {
+        FileDownloadLog.v(this, "filedownloader:lifecycle:start %s by %d ", toString(), getStatus());
         _addEventListener();
     }
 
@@ -540,7 +541,7 @@ void ing() {
 
     // 
     void over() {
-        FileDownloadLog.v(this, "%s over by %d ", toString(), getStatus());
+        FileDownloadLog.v(this, "filedownloader:lifecycle:over %s by %d ", toString(), getStatus());
 
         if (finishListener != null) {
             finishListener.over();

File: library/src/main/java/com/liulishuo/filedownloader/model/FileDownloadModel.java
Patch:
@@ -136,7 +136,7 @@ public void setProgressCallbackTimes(int progressCallbackTimes) {
         this.progressCallbackTimes = progressCallbackTimes;
     }
 
-    public String geteTag() {
+    public String getETag() {
         return eTag;
     }
 

File: library/src/main/java/com/liulishuo/filedownloader/BaseFileDownloadInternal.java
Patch:
@@ -209,6 +209,8 @@ public int start() {
                 return 0;
             }
 
+            FileDownloadList.getImpl().add(this);
+
             // 
             if (checkDownloading(getUrl(), getSavePath())) {
                 // 
@@ -225,7 +227,6 @@ public int start() {
                 FileDownloadLog.d(this, "reuse downloaded file %s", getUrl());
                 this.isReusedOldFile = true;
 
-                FileDownloadList.getImpl().add(this);
 
                 setStatus(FileDownloadStatus.completed);
                 FileDownloadList.getImpl().removeByCompleted(this);
@@ -234,7 +235,6 @@ public int start() {
                 FileDownloadLog.d(this, "start downloaded by ui process %s", getUrl());
                 this.isReusedOldFile = false;
 
-                FileDownloadList.getImpl().add(this);
                 downloadId = startExecute();
                 if (downloadId == 0) {
                     setEx(new RuntimeException("not run download, not got download id"));

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadDriver.java
Patch:
@@ -36,7 +36,7 @@ public void notifyPending() {
 
     @Override
     public void notifyProgress() {
-        FileDownloadLog.d(this, "notify pending %s %d %d", download, download.getDownloadedSofar(), download.getTotalSizeBytes());
+        FileDownloadLog.d(this, "notify progress %s %d %d", download, download.getDownloadedSofar(), download.getTotalSizeBytes());
 
         DownloadEventPool.getImpl().asyncPublishInMain(new FileDownloadEvent(download).
                 progress());

File: library/src/main/java/com/liulishuo/filedownloader/FileDownloadServiceUIGuard.java
Patch:
@@ -17,6 +17,7 @@
  * Created by Jacksgong on 9/23/15.
  */
 class FileDownloadServiceUIGuard extends BaseFileServiceUIGuard<FileDownloadServiceUIGuard.FileDownloadServiceCallback, IFileDownloadIPCService> {
+    // TODO   
 
     private final static class HolderClass {
         private final static FileDownloadServiceUIGuard INSTANCE = new FileDownloadServiceUIGuard();

File: library/src/main/java/com/liulishuo/filedownloader/model/FileDownloadStatus.java
Patch:
@@ -2,6 +2,8 @@
 
 /**
  * Created by Jacksgong on 11/26/15.
+ *
+ * @see com.liulishuo.filedownloader.IFileDownloadMessage
  */
 public interface FileDownloadStatus {
     int pending = 1;

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadDBHelper.java
Patch:
@@ -21,7 +21,7 @@
  */
 class FileDownloadDBHelper implements IFileDownloadDBHelper {
 
-    // TODO thread safe? update ? get? 
+    // TODO thread safe? update ? get?
     private FileDownloadDBOpenHelper openHelper;
     private SQLiteDatabase db;
 

File: library/src/main/java/com/liulishuo/filedownloader/model/FileDownloadModel.java
Patch:
@@ -8,7 +8,8 @@
  * Created by Jacksgong on 9/24/15.
  */
 public class FileDownloadModel implements Parcelable {
-    //TODO 
+
+    public final static int DEFAULT_NOTIFY_NUMS = 100;
 
     // download id
     private int id;
@@ -33,7 +34,7 @@ public class FileDownloadModel implements Parcelable {
     private String desc;
     public final static String DESC = "desc";
 
-    private int progressNotifyNums;
+    private int progressNotifyNums = DEFAULT_NOTIFY_NUMS;
     public final static String PROGRESS_NOTIFY_NUMS = "progressNotifyNums";
 
     private int status;

File: library/src/main/java/com/liulishuo/filedownloader/services/FileDownloadRunnable.java
Patch:
@@ -35,7 +35,6 @@ class FileDownloadRunnable implements Runnable {
 
     private int maxNotifyBytes;
 
-    private final int DEFAULT_NOTIFY_NUMS = 100;
 
     private int maxNotifyNums = 0;
 
@@ -70,7 +69,7 @@ public FileDownloadRunnable(final FileDownloadModel model, final IFileDownloadDB
         downloadTransfer.setSofarBytes(model.getSoFar());
         downloadTransfer.setTotalBytes(model.getTotal());
 
-        maxNotifyNums = model.getProgressNotifyNums() != 0 ? model.getProgressNotifyNums() : DEFAULT_NOTIFY_NUMS;
+        maxNotifyNums = model.getProgressNotifyNums();
         maxNotifyNums = maxNotifyNums <= 0 ? 0 : maxNotifyNums;
 
         this.isContinueDownloadAvailable = false;

File: library/src/main/java/com/liulishuo/filedownloader/model/FileDownloadNotificationModel.java
Patch:
@@ -7,7 +7,6 @@
  * Created by Jacksgong on 9/23/15.
  */
 public class FileDownloadNotificationModel implements Parcelable {
-    //TODO 
 
     private boolean isNeed = false;
     private String title;

