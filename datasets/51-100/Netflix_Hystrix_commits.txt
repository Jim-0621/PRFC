File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextScheduler.java
Patch:
@@ -27,7 +27,7 @@
 import com.netflix.hystrix.strategy.HystrixPlugins;
 
 /**
- * Wrap a {@link Scheduler} so that scheduled actions are wrapped with {@link HystrixContexSchedulerAction} so that
+ * Wrap a {@link Scheduler} so that scheduled actions are wrapped with {@link HystrixContextSchedulerAction} so that
  * the {@link HystrixRequestContext} is properly copied across threads (if they are used by the {@link Scheduler}).
  */
 public class HystrixContextScheduler extends Scheduler {
@@ -93,7 +93,7 @@ public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
                     throw new RejectedExecutionException("Rejected command because thread-pool queueSize is at rejection threshold.");
                 }
             }
-            return worker.schedule(new HystrixContexSchedulerAction(concurrencyStrategy, action), delayTime, unit);
+            return worker.schedule(new HystrixContextSchedulerAction(concurrencyStrategy, action), delayTime, unit);
         }
 
         @Override
@@ -103,7 +103,7 @@ public Subscription schedule(Action0 action) {
                     throw new RejectedExecutionException("Rejected command because thread-pool queueSize is at rejection threshold.");
                 }
             }
-            return worker.schedule(new HystrixContexSchedulerAction(concurrencyStrategy, action));
+            return worker.schedule(new HystrixContextSchedulerAction(concurrencyStrategy, action));
         }
 
     }

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextSchedulerAction.java
Patch:
@@ -30,17 +30,17 @@
  * 
  * @ExcludeFromJavadoc
  */
-public class HystrixContexSchedulerAction implements Action0 {
+public class HystrixContextSchedulerAction implements Action0 {
 
     private final Action0 actual;
     private final HystrixRequestContext parentThreadState;
     private final Callable<Void> c;
 
-    public HystrixContexSchedulerAction(Action0 action) {
+    public HystrixContextSchedulerAction(Action0 action) {
         this(HystrixPlugins.getInstance().getConcurrencyStrategy(), action);
     }
 
-    public HystrixContexSchedulerAction(final HystrixConcurrencyStrategy concurrencyStrategy, Action0 action) {
+    public HystrixContextSchedulerAction(final HystrixConcurrencyStrategy concurrencyStrategy, Action0 action) {
         this.actual = action;
         this.parentThreadState = HystrixRequestContext.getContextForCurrentThread();
 

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextScheduler.java
Patch:
@@ -27,7 +27,7 @@
 import com.netflix.hystrix.strategy.HystrixPlugins;
 
 /**
- * Wrap a {@link Scheduler} so that scheduled actions are wrapped with {@link HystrixContexSchedulerAction} so that
+ * Wrap a {@link Scheduler} so that scheduled actions are wrapped with {@link HystrixContextSchedulerAction} so that
  * the {@link HystrixRequestContext} is properly copied across threads (if they are used by the {@link Scheduler}).
  */
 public class HystrixContextScheduler extends Scheduler {
@@ -93,7 +93,7 @@ public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
                     throw new RejectedExecutionException("Rejected command because thread-pool queueSize is at rejection threshold.");
                 }
             }
-            return worker.schedule(new HystrixContexSchedulerAction(concurrencyStrategy, action), delayTime, unit);
+            return worker.schedule(new HystrixContextSchedulerAction(concurrencyStrategy, action), delayTime, unit);
         }
 
         @Override
@@ -103,7 +103,7 @@ public Subscription schedule(Action0 action) {
                     throw new RejectedExecutionException("Rejected command because thread-pool queueSize is at rejection threshold.");
                 }
             }
-            return worker.schedule(new HystrixContexSchedulerAction(concurrencyStrategy, action));
+            return worker.schedule(new HystrixContextSchedulerAction(concurrencyStrategy, action));
         }
 
     }

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextSchedulerAction.java
Patch:
@@ -30,17 +30,17 @@
  * 
  * @ExcludeFromJavadoc
  */
-public class HystrixContexSchedulerAction implements Action0 {
+public class HystrixContextSchedulerAction implements Action0 {
 
     private final Action0 actual;
     private final HystrixRequestContext parentThreadState;
     private final Callable<Void> c;
 
-    public HystrixContexSchedulerAction(Action0 action) {
+    public HystrixContextSchedulerAction(Action0 action) {
         this(HystrixPlugins.getInstance().getConcurrencyStrategy(), action);
     }
 
-    public HystrixContexSchedulerAction(final HystrixConcurrencyStrategy concurrencyStrategy, Action0 action) {
+    public HystrixContextSchedulerAction(final HystrixConcurrencyStrategy concurrencyStrategy, Action0 action) {
         this.actual = action;
         this.parentThreadState = HystrixRequestContext.getContextForCurrentThread();
 

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java
Patch:
@@ -382,6 +382,7 @@ public void call() {
         final Action0 unsubscribeCommandCleanup = new Action0() {
             @Override
             public void call() {
+                circuitBreaker.markNonSuccess();
                 if (_cmd.commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.UNSUBSCRIBED)) {
                     if (!_cmd.executionResult.containsTerminalEvent()) {
                         _cmd.eventNotifier.markEvent(HystrixEventType.CANCELLED, _cmd.commandKey);

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java
Patch:
@@ -382,6 +382,7 @@ public void call() {
         final Action0 unsubscribeCommandCleanup = new Action0() {
             @Override
             public void call() {
+                circuitBreaker.markNonSuccess();
                 if (_cmd.commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.UNSUBSCRIBED)) {
                     if (!_cmd.executionResult.containsTerminalEvent()) {
                         _cmd.eventNotifier.markEvent(HystrixEventType.CANCELLED, _cmd.commandKey);

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java
Patch:
@@ -683,7 +683,7 @@ public Observable<R> call() {
                         }
                     } else {
                         //command has already been unsubscribed, so return immediately
-                        return Observable.error(new RuntimeException("unsubscribed before executing run()"));
+                        return Observable.empty();
                     }
                 }
             }).doOnTerminate(new Action0() {

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java
Patch:
@@ -683,7 +683,7 @@ public Observable<R> call() {
                         }
                     } else {
                         //command has already been unsubscribed, so return immediately
-                        return Observable.error(new RuntimeException("unsubscribed before executing run()"));
+                        return Observable.empty();
                     }
                 }
             }).doOnTerminate(new Action0() {

File: hystrix-contrib/hystrix-codahale-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/codahalemetricspublisher/HystrixCodaHaleMetricsPublisherThreadPool.java
Patch:
@@ -156,7 +156,7 @@ public Number getValue() {
         metricRegistry.register(createMetricName("propertyValue_actualMaximumSize"), new Gauge<Number>() {
             @Override
             public Number getValue() {
-                return properties.maximumSize().get();
+                return properties.actualMaximumSize();
             }
         });
 

File: hystrix-contrib/hystrix-codahale-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/codahalemetricspublisher/HystrixCodaHaleMetricsPublisherThreadPool.java
Patch:
@@ -156,7 +156,7 @@ public Number getValue() {
         metricRegistry.register(createMetricName("propertyValue_actualMaximumSize"), new Gauge<Number>() {
             @Override
             public Number getValue() {
-                return properties.maximumSize().get();
+                return properties.actualMaximumSize();
             }
         });
 

File: hystrix-core/src/test/java/com/netflix/hystrix/NotWrappedByHystrixTestRuntimeException.java
Patch:
@@ -5,4 +5,7 @@
 public class NotWrappedByHystrixTestRuntimeException extends RuntimeException implements ExceptionNotWrappedByHystrix {
     private static final long serialVersionUID = 1L;
 
+    public NotWrappedByHystrixTestRuntimeException() {
+        super("Raw exception for TestHystrixCommand");
+    }
 }

File: hystrix-core/src/main/java/com/netflix/hystrix/metric/CachedValuesHistogram.java
Patch:
@@ -108,7 +108,7 @@ public int getMean() {
      * @return value at percentile (from cache if possible)
      */
     public int getValueAtPercentile(double percentile) {
-        int permyriad = (int) percentile * 100;
+        int permyriad = (int) (percentile * 100);
         switch (permyriad) {
             case 0: return p0;
             case 500: return p5;

File: hystrix-core/src/main/java/com/netflix/hystrix/metric/CachedValuesHistogram.java
Patch:
@@ -108,7 +108,7 @@ public int getMean() {
      * @return value at percentile (from cache if possible)
      */
     public int getValueAtPercentile(double percentile) {
-        int permyriad = (int) percentile * 100;
+        int permyriad = (int) (percentile * 100);
         switch (permyriad) {
             case 0: return p0;
             case 500: return p5;

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixObservableCommandTest.java
Patch:
@@ -128,7 +128,7 @@ public void testCompletable() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(1);
         final HystrixObservableCommand<Integer> command = new CompletableCommand();
 
-        (new CompletableCommand()).observe().subscribe(new Subscriber<Integer>() {
+        command.observe().subscribe(new Subscriber<Integer>() {
             @Override
             public void onCompleted() {
                 System.out.println(System.currentTimeMillis() + " : " + Thread.currentThread().getName() + " OnCompleted");

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/AbstractHystrixCommand.java
Patch:
@@ -202,7 +202,7 @@ abstract class Action {
      * Builder to create error message for failed fallback operation.
      */
     static class FallbackErrorMessageBuilder {
-        private StringBuilder builder = new StringBuilder("failed to processed fallback");
+        private StringBuilder builder = new StringBuilder("failed to process fallback");
 
         static FallbackErrorMessageBuilder create() {
             return new FallbackErrorMessageBuilder();

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/AbstractHystrixCommand.java
Patch:
@@ -202,7 +202,7 @@ abstract class Action {
      * Builder to create error message for failed fallback operation.
      */
     static class FallbackErrorMessageBuilder {
-        private StringBuilder builder = new StringBuilder("failed to processed fallback");
+        private StringBuilder builder = new StringBuilder("failed to process fallback");
 
         static FallbackErrorMessageBuilder create() {
             return new FallbackErrorMessageBuilder();

File: hystrix-contrib/hystrix-codahale-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/codahalemetricspublisher/HystrixCodaHaleMetricsPublisherCommand.java
Patch:
@@ -273,7 +273,7 @@ public HystrixRollingNumberEvent call() {
             }
         });
         // the rolling number of MaxConcurrentExecutionCount. Can be used to determine saturation
-        safelyCreateRollingCountForEvent("rollingMaxConcurentExecutionCount", new Func0<HystrixRollingNumberEvent>() {
+        safelyCreateRollingCountForEvent("rollingMaxConcurrentExecutionCount", new Func0<HystrixRollingNumberEvent>() {
             @Override
             public HystrixRollingNumberEvent call() {
                 return HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE;

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixEventType.java
Patch:
@@ -42,7 +42,8 @@ public enum HystrixEventType {
     EXCEPTION_THROWN(false),
     RESPONSE_FROM_CACHE(true),
     CANCELLED(true),
-    COLLAPSED(false);
+    COLLAPSED(false),
+    COMMAND_MAX_ACTIVE(false);
 
     private final boolean isTerminal;
 
@@ -72,6 +73,7 @@ public static HystrixEventType from(HystrixRollingNumberEvent event) {
             case RESPONSE_FROM_CACHE: return RESPONSE_FROM_CACHE;
             case COLLAPSED: return COLLAPSED;
             case BAD_REQUEST: return BAD_REQUEST;
+            case COMMAND_MAX_ACTIVE: return COMMAND_MAX_ACTIVE;
             default:
                 throw new RuntimeException("Not an event that can be converted to HystrixEventType : " + event);
         }

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -209,7 +209,7 @@ public static Setter withGroupKey(HystrixCommandGroupKey groupKey) {
          *            <p>
          *            NOTE: Every unique {@link HystrixCommandKey} will result in new instances of {@link HystrixCircuitBreaker}, {@link HystrixCommandMetrics} and {@link HystrixCommandProperties}.
          *            Thus,
-         *            the number of variants should be kept to a finite and reasonable number to avoid high-memory usage or memory leacks.
+         *            the number of variants should be kept to a finite and reasonable number to avoid high-memory usage or memory leaks.
          *            <p>
          *            Hundreds of keys is fine, tens of thousands is probably not.
          * @return Setter for fluent interface via method chaining

File: hystrix-core/src/test/java/com/netflix/hystrix/AbstractTestHystrixCommand.java
Patch:
@@ -20,7 +20,7 @@
 public interface AbstractTestHystrixCommand<R> extends HystrixObservable<R>, InspectableBuilder {
 
     enum ExecutionResult {
-        SUCCESS, FAILURE, ASYNC_FAILURE, HYSTRIX_FAILURE, NOT_WRAPPED_FAILURE, ASYNC_HYSTRIX_FAILURE, RECOVERABLE_ERROR, ASYNC_RECOVERABLE_ERROR, UNRECOVERABLE_ERROR, ASYNC_UNRECOVERABLE_ERROR, BAD_REQUEST, ASYNC_BAD_REQUEST, MULTIPLE_EMITS_THEN_SUCCESS, MULTIPLE_EMITS_THEN_FAILURE, NO_EMITS_THEN_SUCCESS
+        SUCCESS, FAILURE, ASYNC_FAILURE, HYSTRIX_FAILURE, NOT_WRAPPED_FAILURE, ASYNC_HYSTRIX_FAILURE, RECOVERABLE_ERROR, ASYNC_RECOVERABLE_ERROR, UNRECOVERABLE_ERROR, ASYNC_UNRECOVERABLE_ERROR, BAD_REQUEST, ASYNC_BAD_REQUEST, BAD_REQUEST_NOT_WRAPPED, MULTIPLE_EMITS_THEN_SUCCESS, MULTIPLE_EMITS_THEN_FAILURE, NO_EMITS_THEN_SUCCESS
     }
 
     enum FallbackResult {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -209,7 +209,7 @@ public static Setter withGroupKey(HystrixCommandGroupKey groupKey) {
          *            <p>
          *            NOTE: Every unique {@link HystrixCommandKey} will result in new instances of {@link HystrixCircuitBreaker}, {@link HystrixCommandMetrics} and {@link HystrixCommandProperties}.
          *            Thus,
-         *            the number of variants should be kept to a finite and reasonable number to avoid high-memory usage or memory leacks.
+         *            the number of variants should be kept to a finite and reasonable number to avoid high-memory usage or memory leaks.
          *            <p>
          *            Hundreds of keys is fine, tens of thousands is probably not.
          * @return Setter for fluent interface via method chaining

File: hystrix-contrib/hystrix-codahale-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/codahalemetricspublisher/HystrixCodaHaleMetricsPublisherCommand.java
Patch:
@@ -273,7 +273,7 @@ public HystrixRollingNumberEvent call() {
             }
         });
         // the rolling number of MaxConcurrentExecutionCount. Can be used to determine saturation
-        safelyCreateRollingCountForEvent("rollingMaxConcurentExecutionCount", new Func0<HystrixRollingNumberEvent>() {
+        safelyCreateRollingCountForEvent("rollingMaxConcurrentExecutionCount", new Func0<HystrixRollingNumberEvent>() {
             @Override
             public HystrixRollingNumberEvent call() {
                 return HystrixRollingNumberEvent.COMMAND_MAX_ACTIVE;

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixEventType.java
Patch:
@@ -42,7 +42,8 @@ public enum HystrixEventType {
     EXCEPTION_THROWN(false),
     RESPONSE_FROM_CACHE(true),
     CANCELLED(true),
-    COLLAPSED(false);
+    COLLAPSED(false),
+    COMMAND_MAX_ACTIVE(false);
 
     private final boolean isTerminal;
 
@@ -72,6 +73,7 @@ public static HystrixEventType from(HystrixRollingNumberEvent event) {
             case RESPONSE_FROM_CACHE: return RESPONSE_FROM_CACHE;
             case COLLAPSED: return COLLAPSED;
             case BAD_REQUEST: return BAD_REQUEST;
+            case COMMAND_MAX_ACTIVE: return COMMAND_MAX_ACTIVE;
             default:
                 throw new RuntimeException("Not an event that can be converted to HystrixEventType : " + event);
         }

File: hystrix-core/src/test/java/com/netflix/hystrix/AbstractTestHystrixCommand.java
Patch:
@@ -20,7 +20,7 @@
 public interface AbstractTestHystrixCommand<R> extends HystrixObservable<R>, InspectableBuilder {
 
     enum ExecutionResult {
-        SUCCESS, FAILURE, ASYNC_FAILURE, HYSTRIX_FAILURE, NOT_WRAPPED_FAILURE, ASYNC_HYSTRIX_FAILURE, RECOVERABLE_ERROR, ASYNC_RECOVERABLE_ERROR, UNRECOVERABLE_ERROR, ASYNC_UNRECOVERABLE_ERROR, BAD_REQUEST, ASYNC_BAD_REQUEST, MULTIPLE_EMITS_THEN_SUCCESS, MULTIPLE_EMITS_THEN_FAILURE, NO_EMITS_THEN_SUCCESS
+        SUCCESS, FAILURE, ASYNC_FAILURE, HYSTRIX_FAILURE, NOT_WRAPPED_FAILURE, ASYNC_HYSTRIX_FAILURE, RECOVERABLE_ERROR, ASYNC_RECOVERABLE_ERROR, UNRECOVERABLE_ERROR, ASYNC_UNRECOVERABLE_ERROR, BAD_REQUEST, ASYNC_BAD_REQUEST, BAD_REQUEST_NOT_WRAPPED, MULTIPLE_EMITS_THEN_SUCCESS, MULTIPLE_EMITS_THEN_FAILURE, NO_EMITS_THEN_SUCCESS
     }
 
     enum FallbackResult {

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/AsyncResult.java
Patch:
@@ -27,7 +27,7 @@
  */
 public abstract class AsyncResult<T> implements Future<T>, ClosureCommand<T> {
 
-    private static final String ERROR_MSG = "AsyncResult is just a stab and cannot be used as complete implementation of Future";
+    private static final String ERROR_MSG = "AsyncResult is just a stub and cannot be used as complete implementation of Future";
 
     @Override
     public boolean cancel(boolean mayInterruptIfRunning) throws UnsupportedOperationException {

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/AsyncResult.java
Patch:
@@ -27,7 +27,7 @@
  */
 public abstract class AsyncResult<T> implements Future<T>, ClosureCommand<T> {
 
-    private static final String ERROR_MSG = "AsyncResult is just a stab and cannot be used as complete implementation of Future";
+    private static final String ERROR_MSG = "AsyncResult is just a stub and cannot be used as complete implementation of Future";
 
     @Override
     public boolean cancel(boolean mayInterruptIfRunning) throws UnsupportedOperationException {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPool.java
Patch:
@@ -174,7 +174,7 @@ public HystrixThreadPoolDefault(HystrixThreadPoolKey threadPoolKey, HystrixThrea
             this.queueSize = properties.maxQueueSize().get();
             this.queue = concurrencyStrategy.getBlockingQueue(queueSize);
 
-            if (properties.getAllowMaximumSizeToDivergeFromCoreSize()) {
+            if (properties.getAllowMaximumSizeToDivergeFromCoreSize().get()) {
                 this.metrics = HystrixThreadPoolMetrics.getInstance(threadPoolKey,
                         concurrencyStrategy.getThreadPool(threadPoolKey, properties.coreSize(), properties.maximumSize(), properties.keepAliveTimeMinutes(), TimeUnit.MINUTES, queue),
                         properties);
@@ -218,7 +218,7 @@ private void touchConfig() {
             final int dynamicCoreSize = properties.coreSize().get();
             final int dynamicMaximumSize = properties.maximumSize().get();
             int updatedMaximumSize = dynamicMaximumSize;
-            final boolean allowSizesToDiverge = properties.getAllowMaximumSizeToDivergeFromCoreSize();
+            final boolean allowSizesToDiverge = properties.getAllowMaximumSizeToDivergeFromCoreSize().get();
             boolean maxTooLow = false;
 
             if (allowSizesToDiverge && dynamicMaximumSize < dynamicCoreSize) {

File: hystrix-core/src/main/java/com/netflix/hystrix/config/HystrixThreadPoolConfiguration.java
Patch:
@@ -53,7 +53,7 @@ public static HystrixThreadPoolConfiguration sample(HystrixThreadPoolKey threadP
                 threadPoolProperties.maxQueueSize().get(),
                 threadPoolProperties.queueSizeRejectionThreshold().get(),
                 threadPoolProperties.keepAliveTimeMinutes().get(),
-                threadPoolProperties.getAllowMaximumSizeToDivergeFromCoreSize(),
+                threadPoolProperties.getAllowMaximumSizeToDivergeFromCoreSize().get(),
                 threadPoolProperties.metricsRollingStatisticalWindowBuckets().get(),
                 threadPoolProperties.metricsRollingStatisticalWindowInMilliseconds().get());
     }

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPool.java
Patch:
@@ -174,7 +174,7 @@ public HystrixThreadPoolDefault(HystrixThreadPoolKey threadPoolKey, HystrixThrea
             this.queueSize = properties.maxQueueSize().get();
             this.queue = concurrencyStrategy.getBlockingQueue(queueSize);
 
-            if (properties.getAllowMaximumSizeToDivergeFromCoreSize()) {
+            if (properties.getAllowMaximumSizeToDivergeFromCoreSize().get()) {
                 this.metrics = HystrixThreadPoolMetrics.getInstance(threadPoolKey,
                         concurrencyStrategy.getThreadPool(threadPoolKey, properties.coreSize(), properties.maximumSize(), properties.keepAliveTimeMinutes(), TimeUnit.MINUTES, queue),
                         properties);
@@ -218,7 +218,7 @@ private void touchConfig() {
             final int dynamicCoreSize = properties.coreSize().get();
             final int dynamicMaximumSize = properties.maximumSize().get();
             int updatedMaximumSize = dynamicMaximumSize;
-            final boolean allowSizesToDiverge = properties.getAllowMaximumSizeToDivergeFromCoreSize();
+            final boolean allowSizesToDiverge = properties.getAllowMaximumSizeToDivergeFromCoreSize().get();
             boolean maxTooLow = false;
 
             if (allowSizesToDiverge && dynamicMaximumSize < dynamicCoreSize) {

File: hystrix-core/src/main/java/com/netflix/hystrix/config/HystrixThreadPoolConfiguration.java
Patch:
@@ -53,7 +53,7 @@ public static HystrixThreadPoolConfiguration sample(HystrixThreadPoolKey threadP
                 threadPoolProperties.maxQueueSize().get(),
                 threadPoolProperties.queueSizeRejectionThreshold().get(),
                 threadPoolProperties.keepAliveTimeMinutes().get(),
-                threadPoolProperties.getAllowMaximumSizeToDivergeFromCoreSize(),
+                threadPoolProperties.getAllowMaximumSizeToDivergeFromCoreSize().get(),
                 threadPoolProperties.metricsRollingStatisticalWindowBuckets().get(),
                 threadPoolProperties.metricsRollingStatisticalWindowInMilliseconds().get());
     }

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolProperties.java
Patch:
@@ -50,7 +50,7 @@ public abstract class HystrixThreadPoolProperties {
     static int default_maximumSize = 10;         // maximum size of thread pool
     static int default_keepAliveTimeMinutes = 1; // minutes to keep a thread alive
     static int default_maxQueueSize = -1;        // size of queue (this can't be dynamically changed so we use 'queueSizeRejectionThreshold' to artificially limit and reject)
-                                                 // -1 turns if off and makes us use SynchronousQueue
+                                                 // -1 turns it off and makes us use SynchronousQueue
     static boolean default_allow_maximum_size_to_diverge_from_core_size = false; //should the maximumSize config value get read and used in configuring the threadPool
                                                                                  //turning this on should be a conscious decision by the user, so we default it to false
 

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolProperties.java
Patch:
@@ -50,7 +50,7 @@ public abstract class HystrixThreadPoolProperties {
     static int default_maximumSize = 10;         // maximum size of thread pool
     static int default_keepAliveTimeMinutes = 1; // minutes to keep a thread alive
     static int default_maxQueueSize = -1;        // size of queue (this can't be dynamically changed so we use 'queueSizeRejectionThreshold' to artificially limit and reject)
-                                                 // -1 turns if off and makes us use SynchronousQueue
+                                                 // -1 turns it off and makes us use SynchronousQueue
     static boolean default_allow_maximum_size_to_diverge_from_core_size = false; //should the maximumSize config value get read and used in configuring the threadPool
                                                                                  //turning this on should be a conscious decision by the user, so we default it to false
 

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java
Patch:
@@ -29,7 +29,6 @@
 import com.netflix.hystrix.strategy.concurrency.HystrixRequestContext;
 import com.netflix.hystrix.strategy.executionhook.HystrixCommandExecutionHook;
 import com.netflix.hystrix.strategy.properties.HystrixProperty;
-import com.sun.javafx.collections.NonIterableChange;
 import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolProperties.java
Patch:
@@ -82,7 +82,7 @@ protected HystrixThreadPoolProperties(HystrixThreadPoolKey key, Setter builder,
 
         this.corePoolSize = getProperty(propertyPrefix, key, "coreSize", builder.getCoreSize(), default_coreSize);
         //this object always contains a reference to the configuration value for the maximumSize of the threadpool
-        //it only gets applied if .threadpool
+        //it only gets applied if allowMaximumSizeToDivergeFromCoreSize is true
         this.maximumPoolSize = getProperty(propertyPrefix, key, "maximumSize", builder.getMaximumSize(), default_maximumSize);
 
         this.keepAliveTime = getProperty(propertyPrefix, key, "keepAliveTimeMinutes", builder.getKeepAliveTimeMinutes(), default_keepAliveTimeMinutes);

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolProperties.java
Patch:
@@ -82,7 +82,7 @@ protected HystrixThreadPoolProperties(HystrixThreadPoolKey key, Setter builder,
 
         this.corePoolSize = getProperty(propertyPrefix, key, "coreSize", builder.getCoreSize(), default_coreSize);
         //this object always contains a reference to the configuration value for the maximumSize of the threadpool
-        //it only gets applied if .threadpool
+        //it only gets applied if allowMaximumSizeToDivergeFromCoreSize is true
         this.maximumPoolSize = getProperty(propertyPrefix, key, "maximumSize", builder.getMaximumSize(), default_maximumSize);
 
         this.keepAliveTime = getProperty(propertyPrefix, key, "keepAliveTimeMinutes", builder.getKeepAliveTimeMinutes(), default_keepAliveTimeMinutes);

File: hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/test/common/error/BasicDefaultIgnoreExceptionsTest.java
Patch:
@@ -33,7 +33,7 @@ public void testCommandOverridesDefaultIgnoreExceptions() {
         service.commandOverridesDefaultIgnoreExceptions(SpecificException.class);
     }
 
-    @Test(expected = HystrixRuntimeException.class)
+    @Test(expected = BadRequestException.class)
     public void testCommandOverridesDefaultIgnoreExceptions_nonIgnoreExceptionShouldBePropagated() {
         // method throws BadRequestException that isn't ignored
         service.commandOverridesDefaultIgnoreExceptions(BadRequestException.class);

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/aop/aspectj/HystrixCommandAspect.java
Patch:
@@ -21,6 +21,7 @@
 import com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;
 import com.netflix.hystrix.contrib.javanica.annotation.HystrixCollapser;
 import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
+import com.netflix.hystrix.contrib.javanica.annotation.HystrixException;
 import com.netflix.hystrix.contrib.javanica.command.CommandExecutor;
 import com.netflix.hystrix.contrib.javanica.command.ExecutionType;
 import com.netflix.hystrix.contrib.javanica.command.HystrixCommandFactory;
@@ -103,7 +104,7 @@ public Object methodsAnnotatedWithHystrixCommand(final ProceedingJoinPoint joinP
         } catch (HystrixBadRequestException e) {
             throw e.getCause();
         } catch (HystrixRuntimeException e) {
-            if (metaHolder.getRaiseHystrixRuntimeExceptions()) {
+            if (metaHolder.raiseHystrixExceptionsContains(HystrixException.RUNTIME_EXCEPTION)) {
                 throw e;
             }
             throw getCause(e);
@@ -256,7 +257,6 @@ public MetaHolder create(Object proxy, Method method, Object obj, Object[] args,
             return builder.defaultCommandKey(method.getName())
                             .hystrixCommand(hystrixCommand)
                             .observableExecutionMode(hystrixCommand.observableExecutionMode())
-                            .raiseHystrixRuntimeExceptions(hystrixCommand.raiseHystrixRuntimeExceptions())
                             .executionType(executionType)
                             .observable(ExecutionType.OBSERVABLE == executionType)
                             .build();

File: hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/test/common/error/BasicDefaultIgnoreExceptionsTest.java
Patch:
@@ -64,7 +64,7 @@ public Object commandInheritsDefaultIgnoreExceptions() throws BadRequestExceptio
             throw new BadRequestException("from 'commandInheritsIgnoreExceptionsFromDefault'");
         }
 
-        @HystrixCommand(ignoreExceptions = SpecificException.class, raiseHystrixRuntimeExceptions = true)
+        @HystrixCommand(ignoreExceptions = SpecificException.class)
         public Object commandOverridesDefaultIgnoreExceptions(Class<? extends Throwable> errorType) throws BadRequestException, SpecificException  {
             if(errorType.equals(BadRequestException.class)){
                 // isn't ignored because command doesn't specify this exception type in 'ignoreExceptions'

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/properties/HystrixPropertiesFactory.java
Patch:
@@ -43,6 +43,7 @@ public class HystrixPropertiesFactory {
     public static void reset() {
         commandProperties.clear();
         threadPoolProperties.clear();
+        collapserProperties.clear();
     }
 
     // String is CommandKey.name() (we can't use CommandKey directly as we can't guarantee it implements hashcode/equals correctly)

File: hystrix-core/src/test/java/com/netflix/hystrix/metric/consumer/HealthCountsStreamTest.java
Patch:
@@ -231,7 +231,7 @@ public void testShortCircuited() {
         failure3.observe();
 
         try {
-            Thread.sleep(100);
+            Thread.sleep(500);
         } catch (InterruptedException ie) {
             fail(ie.getMessage());
         }

File: hystrix-contrib/hystrix-rx-netty-metrics-stream/src/main/java/com/netflix/hystrix/contrib/rxnetty/metricsstream/HystrixMetricsStreamHandler.java
Patch:
@@ -85,7 +85,7 @@ private Observable<Void> handleHystrixRequest(final HttpServerResponse<O> respon
 
         final Subject<Void, Void> subject = PublishSubject.create();
         final MultipleAssignmentSubscription subscription = new MultipleAssignmentSubscription();
-        Subscription actionSubscription = Observable.timer(0, interval, TimeUnit.MILLISECONDS, Schedulers.computation())
+        Subscription actionSubscription = Observable.interval(interval, TimeUnit.MILLISECONDS)
                 .subscribe(new Action1<Long>() {
                     @Override
                     public void call(Long tick) {

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixObservableCommandTest.java
Patch:
@@ -2757,7 +2757,7 @@ public Boolean call(Boolean b) {
                             return b;
                         }
 
-                    }).finallyDo(new Action0() {
+                    }).doAfterTerminate(new Action0() {
 
                         @Override
                         public void call() {
@@ -2807,7 +2807,7 @@ public Boolean call(Boolean b) {
                             return b;
                         }
 
-                    }).finallyDo(new Action0() {
+                    }).doAfterTerminate(new Action0() {
 
                         @Override
                         public void call() {
@@ -2857,7 +2857,7 @@ public Boolean call(Boolean b) {
                             return b;
                         }
 
-                    }).finallyDo(new Action0() {
+                    }).doAfterTerminate(new Action0() {
 
                         @Override
                         public void call() {

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/HystrixCommandBuilder.java
Patch:
@@ -155,7 +155,7 @@ public Builder collapsedRequests(Collection<HystrixCollapser.CollapsedRequest<Ob
          * @param pIgnoreExceptions the exceptions to be ignored
          * @return this {@link HystrixCommandBuilder.Builder}
          */
-        public Builder ignoreExceptions(Class<? extends Throwable>[] pIgnoreExceptions) {
+        public Builder ignoreExceptions(List<Class<? extends Throwable>> pIgnoreExceptions) {
             this.ignoreExceptions = ImmutableList.copyOf(pIgnoreExceptions);
             return this;
         }

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/annotation/DefaultProperties.java
Patch:
@@ -35,15 +35,15 @@
 public @interface DefaultProperties {
 
     /**
-     * Specifies default group key used for each hystrix command by default unless a command specifies it's own group key.
+     * Specifies default group key used for each hystrix command by default unless a command specifies group key explicitly.
      * For additional info about this property see {@link HystrixCommand#groupKey()}.
      *
      * @return default group key
      */
     String groupKey() default "";
 
     /**
-     * Specifies default thread pool key used for each hystrix command by default unless a command specifies it's own thread pool key.
+     * Specifies default thread pool key used for each hystrix command by default unless a command specifies thread pool key explicitly.
      * For additional info about this property see {@link HystrixCommand#threadPoolKey()}
      *
      * @return default thread pool

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/HystrixCommandBuilderFactory.java
Patch:
@@ -122,6 +122,8 @@ private CommandAction createFallbackAction(MetaHolder metaHolder) {
                         .observable(ExecutionType.OBSERVABLE == fallbackMethod.getExecutionType())
                         .defaultCommandKey(fMethod.getName())
                         .defaultGroupKey(metaHolder.getDefaultGroupKey())
+                        .defaultThreadPoolKey(metaHolder.getDefaultThreadPoolKey())
+                        .defaultProperties(metaHolder.getDefaultProperties().orNull())
                         .hystrixCollapser(metaHolder.getHystrixCollapser())
                         .observableExecutionMode(hystrixCommand.observableExecutionMode())
                         .hystrixCommand(hystrixCommand).build();

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/HystrixCommandBuilder.java
Patch:
@@ -155,7 +155,7 @@ public Builder collapsedRequests(Collection<HystrixCollapser.CollapsedRequest<Ob
          * @param pIgnoreExceptions the exceptions to be ignored
          * @return this {@link HystrixCommandBuilder.Builder}
          */
-        public Builder ignoreExceptions(Class<? extends Throwable>[] pIgnoreExceptions) {
+        public Builder ignoreExceptions(List<Class<? extends Throwable>> pIgnoreExceptions) {
             this.ignoreExceptions = ImmutableList.copyOf(pIgnoreExceptions);
             return this;
         }

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/aop/aspectj/HystrixCommandAspect.java
Patch:
@@ -17,14 +17,15 @@
 
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableMap;
-import com.netflix.hystrix.HystrixExecutable;
 import com.netflix.hystrix.HystrixInvokable;
+import com.netflix.hystrix.contrib.javanica.annotation.DefaultProperties;
 import com.netflix.hystrix.contrib.javanica.annotation.HystrixCollapser;
 import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
 import com.netflix.hystrix.contrib.javanica.command.CommandExecutor;
 import com.netflix.hystrix.contrib.javanica.command.ExecutionType;
 import com.netflix.hystrix.contrib.javanica.command.HystrixCommandFactory;
 import com.netflix.hystrix.contrib.javanica.command.MetaHolder;
+import com.netflix.hystrix.contrib.javanica.utils.AopUtils;
 import com.netflix.hystrix.contrib.javanica.utils.FallbackMethod;
 import com.netflix.hystrix.contrib.javanica.utils.MethodProvider;
 import com.netflix.hystrix.exception.HystrixBadRequestException;
@@ -206,6 +207,7 @@ public MetaHolder create(Object proxy, Method method, Object obj, Object[] args,
             HystrixCommand hystrixCommand = method.getAnnotation(HystrixCommand.class);
             ExecutionType executionType = ExecutionType.getExecutionType(method.getReturnType());
             MetaHolder.Builder builder = metaHolderBuilder(proxy, method, obj, args, joinPoint);
+            builder.defaultProperties(AopUtils.getAnnotation(joinPoint, DefaultProperties.class));
             return builder.defaultCommandKey(method.getName())
                             .hystrixCommand(hystrixCommand)
                             .observableExecutionMode(hystrixCommand.observableExecutionMode())

File: hystrix-contrib/hystrix-metrics-event-stream/src/test/java/com/netflix/hystrix/contrib/metrics/eventstream/HystrixMetricsPollerTest.java
Patch:
@@ -78,6 +78,7 @@ protected Boolean run() {
             int v2 = metricsCount.get();
 
             // they should be the same since we were paused
+            System.out.println("First poll got : " + v1 + ", second got : " + v2);
             assertTrue(v2 == v1);
 
             poller.start();

File: hystrix-core/src/test/java/com/netflix/hystrix/metric/consumer/RollingThreadPoolMaxConcurrencyStreamTest.java
Patch:
@@ -159,7 +159,7 @@ public void testOneCommandCarriesOverToNextBucket() throws InterruptedException
         final CountDownLatch latch = new CountDownLatch(1);
         stream.observe().take(10).subscribe(getSubscriber(latch));
 
-        Command cmd1 = Command.from(groupKey, key, HystrixEventType.SUCCESS, 160);
+        Command cmd1 = Command.from(groupKey, key, HystrixEventType.SUCCESS, 560);
         Command cmd2 = Command.from(groupKey, key, HystrixEventType.SUCCESS, 50);
         Command cmd3 = Command.from(groupKey, key, HystrixEventType.SUCCESS, 75);
 

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/GenericCommand.java
Patch:
@@ -64,15 +64,15 @@ Object execute() {
      */
     @Override
     protected Object getFallback() {
-        if (getFallbackAction() != null) {
-            final CommandAction commandAction = getFallbackAction();
+        final CommandAction commandAction = getFallbackAction();
+        if (commandAction != null) {
             try {
                 return process(new Action() {
                     @Override
                     Object execute() {
                         MetaHolder metaHolder = commandAction.getMetaHolder();
                         Object[] args = createArgsForFallback(metaHolder, getExecutionException());
-                        return commandAction.executeWithArgs(commandAction.getMetaHolder().getFallbackExecutionType(), args);
+                        return commandAction.executeWithArgs(metaHolder.getFallbackExecutionType(), args);
                     }
                 });
             } catch (Throwable e) {

File: hystrix-core/src/main/java/com/netflix/hystrix/metric/HystrixRequestEvents.java
Patch:
@@ -61,9 +61,8 @@ public Map<ExecutionSignature, List<Integer>> getExecutionsMappedToLatencies() {
         Map<ExecutionSignature, List<Integer>> commandDeduper = new HashMap<ExecutionSignature, List<Integer>>();
         for (HystrixInvokableInfo<?> execution: nonCachedExecutions) {
             int cachedCount = 0;
-            String cacheKey = null;
-            if (execution.getPublicCacheKey() != null) {
-                cacheKey = execution.getPublicCacheKey();
+            String cacheKey = execution.getPublicCacheKey();
+            if (cacheKey != null) {
                 CommandAndCacheKey key = new CommandAndCacheKey(execution.getCommandKey().name(), cacheKey);
                 cachedCount = cachingDetector.get(key);
             }

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/GenericCommand.java
Patch:
@@ -64,15 +64,15 @@ Object execute() {
      */
     @Override
     protected Object getFallback() {
-        if (getFallbackAction() != null) {
-            final CommandAction commandAction = getFallbackAction();
+        final CommandAction commandAction = getFallbackAction();
+        if (commandAction != null) {
             try {
                 return process(new Action() {
                     @Override
                     Object execute() {
                         MetaHolder metaHolder = commandAction.getMetaHolder();
                         Object[] args = createArgsForFallback(metaHolder, getExecutionException());
-                        return commandAction.executeWithArgs(commandAction.getMetaHolder().getFallbackExecutionType(), args);
+                        return commandAction.executeWithArgs(metaHolder.getFallbackExecutionType(), args);
                     }
                 });
             } catch (Throwable e) {

File: hystrix-core/src/main/java/com/netflix/hystrix/metric/HystrixRequestEvents.java
Patch:
@@ -61,9 +61,8 @@ public Map<ExecutionSignature, List<Integer>> getExecutionsMappedToLatencies() {
         Map<ExecutionSignature, List<Integer>> commandDeduper = new HashMap<ExecutionSignature, List<Integer>>();
         for (HystrixInvokableInfo<?> execution: nonCachedExecutions) {
             int cachedCount = 0;
-            String cacheKey = null;
-            if (execution.getPublicCacheKey() != null) {
-                cacheKey = execution.getPublicCacheKey();
+            String cacheKey = execution.getPublicCacheKey();
+            if (cacheKey != null) {
                 CommandAndCacheKey key = new CommandAndCacheKey(execution.getCommandKey().name(), cacheKey);
                 cachedCount = cachingDetector.get(key);
             }

File: hystrix-core/src/main/java/com/netflix/hystrix/config/HystrixCommandConfiguration.java
Patch:
@@ -30,7 +30,7 @@ public class HystrixCommandConfiguration {
     private final HystrixCommandCircuitBreakerConfig circuitBreakerConfig;
     private final HystrixCommandMetricsConfig metricsConfig;
 
-    private HystrixCommandConfiguration(HystrixCommandKey commandKey, HystrixThreadPoolKey threadPoolKey, HystrixCommandGroupKey groupKey,
+    public HystrixCommandConfiguration(HystrixCommandKey commandKey, HystrixThreadPoolKey threadPoolKey, HystrixCommandGroupKey groupKey,
                                        HystrixCommandExecutionConfig executionConfig,
                                        HystrixCommandCircuitBreakerConfig circuitBreakerConfig,
                                        HystrixCommandMetricsConfig metricsConfig) {

File: hystrix-core/src/main/java/com/netflix/hystrix/config/HystrixConfiguration.java
Patch:
@@ -26,7 +26,7 @@ public class HystrixConfiguration {
     private final Map<HystrixThreadPoolKey, HystrixThreadPoolConfiguration> threadPoolConfig;
     private final Map<HystrixCollapserKey, HystrixCollapserConfiguration> collapserConfig;
 
-    private HystrixConfiguration(Map<HystrixCommandKey, HystrixCommandConfiguration> commandConfig,
+    public HystrixConfiguration(Map<HystrixCommandKey, HystrixCommandConfiguration> commandConfig,
                                  Map<HystrixThreadPoolKey, HystrixThreadPoolConfiguration> threadPoolConfig,
                                  Map<HystrixCollapserKey, HystrixCollapserConfiguration> collapserConfig) {
         this.commandConfig = commandConfig;

File: hystrix-core/src/main/java/com/netflix/hystrix/config/HystrixThreadPoolConfiguration.java
Patch:
@@ -29,7 +29,7 @@ public class HystrixThreadPoolConfiguration {
     private final int rollingCounterNumberOfBuckets;
     private final int rollingCounterBucketSizeInMilliseconds;
 
-    private HystrixThreadPoolConfiguration(HystrixThreadPoolKey threadPoolKey, int coreSize, int maxQueueSize, int queueRejectionThreshold,
+    public HystrixThreadPoolConfiguration(HystrixThreadPoolKey threadPoolKey, int coreSize, int maxQueueSize, int queueRejectionThreshold,
                                            int keepAliveTimeInMinutes, int rollingCounterNumberOfBuckets,
                                            int rollingCounterBucketSizeInMilliseconds) {
         this.threadPoolKey = threadPoolKey;

File: hystrix-contrib/hystrix-servo-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/servopublisher/HystrixServoMetricsPublisherCommand.java
Patch:
@@ -515,7 +515,7 @@ public HystrixEventType call() {
         monitors.add(getTotalLatencyPercentileMonitor("latencyTotal_percentile_75", 75));
         monitors.add(getTotalLatencyPercentileMonitor("latencyTotal_percentile_90", 90));
         monitors.add(getTotalLatencyPercentileMonitor("latencyTotal_percentile_99", 99));
-        monitors.add(getTotalLatencyPercentileMonitor("latencyTotal_percentile_995", 995));
+        monitors.add(getTotalLatencyPercentileMonitor("latencyTotal_percentile_995", 99.5));
 
         // group
         monitors.add(new InformationalMetric<String>(MonitorConfig.builder("commandGroup").build()) {

File: hystrix-contrib/hystrix-servo-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/servopublisher/HystrixServoMetricsPublisherCommand.java
Patch:
@@ -515,7 +515,7 @@ public HystrixEventType call() {
         monitors.add(getTotalLatencyPercentileMonitor("latencyTotal_percentile_75", 75));
         monitors.add(getTotalLatencyPercentileMonitor("latencyTotal_percentile_90", 90));
         monitors.add(getTotalLatencyPercentileMonitor("latencyTotal_percentile_99", 99));
-        monitors.add(getTotalLatencyPercentileMonitor("latencyTotal_percentile_995", 995));
+        monitors.add(getTotalLatencyPercentileMonitor("latencyTotal_percentile_995", 99.5));
 
         // group
         monitors.add(new InformationalMetric<String>(MonitorConfig.builder("commandGroup").build()) {

File: hystrix-contrib/hystrix-codahale-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/codahalemetricspublisher/HystrixCodaHaleMetricsPublisherThreadPool.java
Patch:
@@ -36,7 +36,7 @@ public class HystrixCodaHaleMetricsPublisherThreadPool implements HystrixMetrics
     private final String metricGroup;
     private final String metricType;
 
-    static final Logger logger = LoggerFactory.getLogger(HystrixCodaHaleMetricsPublisherCollapser.class);
+    static final Logger logger = LoggerFactory.getLogger(HystrixCodaHaleMetricsPublisherThreadPool.class);
 
     public HystrixCodaHaleMetricsPublisherThreadPool(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolMetrics metrics, HystrixThreadPoolProperties properties, MetricRegistry metricRegistry) {
         this.key = threadPoolKey;

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/BatchHystrixCommand.java
Patch:
@@ -34,7 +34,7 @@
 @ThreadSafe
 public class BatchHystrixCommand extends AbstractHystrixCommand<List<Object>> {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(GenericCommand.class);
+    private static final Logger LOGGER = LoggerFactory.getLogger(BatchHystrixCommand.class);
 
     public BatchHystrixCommand(HystrixCommandBuilder builder) {
         super(builder);

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestBatch.java
Patch:
@@ -28,7 +28,6 @@
 import rx.functions.Action0;
 import rx.functions.Action1;
 
-import com.netflix.hystrix.HystrixCollapser;
 import com.netflix.hystrix.HystrixCollapser.CollapsedRequest;
 import com.netflix.hystrix.HystrixCollapserProperties;
 
@@ -41,7 +40,7 @@
  */
 public class RequestBatch<BatchReturnType, ResponseType, RequestArgumentType> {
 
-    private static final Logger logger = LoggerFactory.getLogger(HystrixCollapser.class);
+    private static final Logger logger = LoggerFactory.getLogger(RequestBatch.class);
 
     private final HystrixCollapserBridge<BatchReturnType, ResponseType, RequestArgumentType> commandCollapser;
     private final int maxBatchSize;
@@ -273,4 +272,4 @@ public void shutdown() {
     public int getSize() {
         return count.get();
     }
-}
\ No newline at end of file
+}

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapser.java
Patch:
@@ -25,7 +25,6 @@
 
 import rx.Observable;
 
-import com.netflix.hystrix.HystrixCollapser;
 import com.netflix.hystrix.HystrixCollapserProperties;
 import com.netflix.hystrix.strategy.concurrency.HystrixConcurrencyStrategy;
 import com.netflix.hystrix.strategy.concurrency.HystrixContextCallable;
@@ -41,7 +40,7 @@
  * @ThreadSafe
  */
 public class RequestCollapser<BatchReturnType, ResponseType, RequestArgumentType> {
-    static final Logger logger = LoggerFactory.getLogger(HystrixCollapser.class);
+    static final Logger logger = LoggerFactory.getLogger(RequestCollapser.class);
 
     private final HystrixCollapserBridge<BatchReturnType, ResponseType, RequestArgumentType> commandCollapser;
     // batch can be null once shutdown
@@ -178,4 +177,4 @@ public int getIntervalTimeInMilliseconds() {
 
     }
 
-}
\ No newline at end of file
+}

File: hystrix-contrib/hystrix-codahale-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/codahalemetricspublisher/HystrixCodaHaleMetricsPublisherThreadPool.java
Patch:
@@ -36,7 +36,7 @@ public class HystrixCodaHaleMetricsPublisherThreadPool implements HystrixMetrics
     private final String metricGroup;
     private final String metricType;
 
-    static final Logger logger = LoggerFactory.getLogger(HystrixCodaHaleMetricsPublisherCollapser.class);
+    static final Logger logger = LoggerFactory.getLogger(HystrixCodaHaleMetricsPublisherThreadPool.class);
 
     public HystrixCodaHaleMetricsPublisherThreadPool(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolMetrics metrics, HystrixThreadPoolProperties properties, MetricRegistry metricRegistry) {
         this.key = threadPoolKey;

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/BatchHystrixCommand.java
Patch:
@@ -34,7 +34,7 @@
 @ThreadSafe
 public class BatchHystrixCommand extends AbstractHystrixCommand<List<Object>> {
 
-    private static final Logger LOGGER = LoggerFactory.getLogger(GenericCommand.class);
+    private static final Logger LOGGER = LoggerFactory.getLogger(BatchHystrixCommand.class);
 
     public BatchHystrixCommand(HystrixCommandBuilder builder) {
         super(builder);

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestBatch.java
Patch:
@@ -28,7 +28,6 @@
 import rx.functions.Action0;
 import rx.functions.Action1;
 
-import com.netflix.hystrix.HystrixCollapser;
 import com.netflix.hystrix.HystrixCollapser.CollapsedRequest;
 import com.netflix.hystrix.HystrixCollapserProperties;
 
@@ -41,7 +40,7 @@
  */
 public class RequestBatch<BatchReturnType, ResponseType, RequestArgumentType> {
 
-    private static final Logger logger = LoggerFactory.getLogger(HystrixCollapser.class);
+    private static final Logger logger = LoggerFactory.getLogger(RequestBatch.class);
 
     private final HystrixCollapserBridge<BatchReturnType, ResponseType, RequestArgumentType> commandCollapser;
     private final int maxBatchSize;
@@ -273,4 +272,4 @@ public void shutdown() {
     public int getSize() {
         return count.get();
     }
-}
\ No newline at end of file
+}

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapser.java
Patch:
@@ -25,7 +25,6 @@
 
 import rx.Observable;
 
-import com.netflix.hystrix.HystrixCollapser;
 import com.netflix.hystrix.HystrixCollapserProperties;
 import com.netflix.hystrix.strategy.concurrency.HystrixConcurrencyStrategy;
 import com.netflix.hystrix.strategy.concurrency.HystrixContextCallable;
@@ -41,7 +40,7 @@
  * @ThreadSafe
  */
 public class RequestCollapser<BatchReturnType, ResponseType, RequestArgumentType> {
-    static final Logger logger = LoggerFactory.getLogger(HystrixCollapser.class);
+    static final Logger logger = LoggerFactory.getLogger(RequestCollapser.class);
 
     private final HystrixCollapserBridge<BatchReturnType, ResponseType, RequestArgumentType> commandCollapser;
     // batch can be null once shutdown
@@ -178,4 +177,4 @@ public int getIntervalTimeInMilliseconds() {
 
     }
 
-}
\ No newline at end of file
+}

File: hystrix-contrib/hystrix-reactivesocket-event-stream/src/main/java/com/netflix/hystrix/contrib/reactivesocket/EventStreamEnum.java
Patch:
@@ -1,7 +1,7 @@
 package com.netflix.hystrix.contrib.reactivesocket;
 
 
-import com.netflix.hystrix.contrib.reactivesocket.metrics.HystrixCollasperMetricsStream;
+import com.netflix.hystrix.contrib.reactivesocket.metrics.HystrixCollapserMetricsStream;
 import com.netflix.hystrix.contrib.reactivesocket.metrics.HystrixCommandMetricsStream;
 import com.netflix.hystrix.contrib.reactivesocket.metrics.HystrixThreadPoolMetricsStream;
 import com.netflix.hystrix.contrib.reactivesocket.requests.HystrixRequestEventsStream;
@@ -45,7 +45,7 @@ public Observable<Payload> get() {
             return Observable.merge(
                     HystrixCommandMetricsStream.getInstance().get(),
                     HystrixThreadPoolMetricsStream.getInstance().get(),
-                    HystrixCollasperMetricsStream.getInstance().get());
+                    HystrixCollapserMetricsStream.getInstance().get());
         }
     }
 

File: hystrix-contrib/hystrix-reactivesocket-event-stream/src/test/java/com/netflix/hystrix/contrib/reactivesocket/metrics/HystrixCollapserMetricsStreamTest.java
Patch:
@@ -7,7 +7,7 @@
 import java.nio.ByteBuffer;
 import java.util.concurrent.CountDownLatch;
 
-public class HystrixCollasperMetricsStreamTest {
+public class HystrixCollapserMetricsStreamTest {
 
     @Test
     public void test() throws Exception {

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/executionhook/HystrixCommandExecutionHook.java
Patch:
@@ -101,8 +101,8 @@ public <T> void onThreadStart(HystrixInvokable<T> commandInstance) {
 
     /**
      * Invoked at completion of thread execution when {@link HystrixCommand} is executed using {@link ExecutionIsolationStrategy#THREAD}.
-     * This will get invoked if the Hystrix thread successfully executes, regardless of whether the calling thread
-     * encountered a timeout.
+     * This will get invoked whenever the Hystrix thread is done executing, regardless of whether the thread finished
+     * naturally, or was unsubscribed externally
      *
      * @param commandInstance The executing HystrixCommand instance.
      *

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandMetricsTest.java
Patch:
@@ -143,7 +143,7 @@ public void testCurrentConcurrentExecutionCount() {
         }
 
         try {
-            Thread.sleep(25);
+            Thread.sleep(150);
         } catch (InterruptedException ie) {
             fail(ie.getMessage());
         }
@@ -160,7 +160,7 @@ public Command(String commandKey, boolean shouldFail, boolean shouldFailWithBadR
             super(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("Command"))
                     .andCommandKey(HystrixCommandKey.Factory.asKey(commandKey))
                     .andCommandPropertiesDefaults(HystrixCommandPropertiesTest.getUnitTestPropertiesSetter()
-                            .withExecutionTimeoutInMilliseconds(100)
+                            .withExecutionTimeoutInMilliseconds(1000)
                             .withCircuitBreakerRequestVolumeThreshold(20)));
             this.shouldFail = shouldFail;
             this.shouldFailWithBadRequest = shouldFailWithBadRequest;

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/executionhook/HystrixCommandExecutionHook.java
Patch:
@@ -101,8 +101,8 @@ public <T> void onThreadStart(HystrixInvokable<T> commandInstance) {
 
     /**
      * Invoked at completion of thread execution when {@link HystrixCommand} is executed using {@link ExecutionIsolationStrategy#THREAD}.
-     * This will get invoked if the Hystrix thread successfully executes, regardless of whether the calling thread
-     * encountered a timeout.
+     * This will get invoked whenever the Hystrix thread is done executing, regardless of whether the thread finished
+     * naturally, or was unsubscribed externally
      *
      * @param commandInstance The executing HystrixCommand instance.
      *

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java
Patch:
@@ -39,11 +39,8 @@
 import rx.Subscription;
 import rx.functions.Action0;
 import rx.functions.Action1;
-import rx.functions.Action2;
 import rx.functions.Func0;
-import rx.observables.AsyncOnSubscribe;
 import rx.observers.TestSubscriber;
-import rx.schedulers.Schedulers;
 
 import java.io.IOException;
 import java.util.List;

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixRequestCacheTest.java
Patch:
@@ -27,6 +27,8 @@
 import com.netflix.hystrix.strategy.concurrency.HystrixConcurrencyStrategy;
 import com.netflix.hystrix.strategy.concurrency.HystrixConcurrencyStrategyDefault;
 import com.netflix.hystrix.strategy.concurrency.HystrixRequestContext;
+import rx.Subscription;
+import rx.subjects.ReplaySubject;
 
 public class HystrixRequestCacheTest {
 
@@ -109,8 +111,7 @@ public void testCacheWithoutRequestContext() {
 
     private static class TestObservable extends HystrixCachedObservable<String> {
         public TestObservable(String arg) {
-            super(Observable.just(arg), null);
+            super(Observable.just(arg));
         }
     }
-
 }

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandMetrics.java
Patch:
@@ -343,9 +343,9 @@ public int getCurrentConcurrentExecutionCount() {
         HystrixThreadEventStream.getInstance().commandExecutionStarted(commandKey, threadPoolKey, isolationStrategy, currentCount);
     }
 
-    /* package-private */ void markCommandDone(ExecutionResult executionResult, HystrixCommandKey commandKey, HystrixThreadPoolKey threadPoolKey) {
+    /* package-private */ void markCommandDone(ExecutionResult executionResult, HystrixCommandKey commandKey, HystrixThreadPoolKey threadPoolKey, boolean executionStarted) {
         HystrixThreadEventStream.getInstance().executionDone(executionResult, commandKey, threadPoolKey);
-        if (executionResult.executionOccurred()) {
+        if (executionStarted) {
             concurrentExecutionCount.decrementAndGet();
         }
     }

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandMetrics.java
Patch:
@@ -343,9 +343,9 @@ public int getCurrentConcurrentExecutionCount() {
         HystrixThreadEventStream.getInstance().commandExecutionStarted(commandKey, threadPoolKey, isolationStrategy, currentCount);
     }
 
-    /* package-private */ void markCommandDone(ExecutionResult executionResult, HystrixCommandKey commandKey, HystrixThreadPoolKey threadPoolKey) {
+    /* package-private */ void markCommandDone(ExecutionResult executionResult, HystrixCommandKey commandKey, HystrixThreadPoolKey threadPoolKey, boolean executionStarted) {
         HystrixThreadEventStream.getInstance().executionDone(executionResult, commandKey, threadPoolKey);
-        if (executionResult.executionOccurred()) {
+        if (executionStarted) {
             concurrentExecutionCount.decrementAndGet();
         }
     }

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandMetrics.java
Patch:
@@ -343,9 +343,9 @@ public int getCurrentConcurrentExecutionCount() {
         HystrixThreadEventStream.getInstance().commandExecutionStarted(commandKey, threadPoolKey, isolationStrategy, currentCount);
     }
 
-    /* package-private */ void markCommandDone(ExecutionResult executionResult, HystrixCommandKey commandKey, HystrixThreadPoolKey threadPoolKey, boolean executionStarted) {
+    /* package-private */ void markCommandDone(ExecutionResult executionResult, HystrixCommandKey commandKey, HystrixThreadPoolKey threadPoolKey) {
         HystrixThreadEventStream.getInstance().executionDone(executionResult, commandKey, threadPoolKey);
-        if (executionStarted) {
+        if (executionResult.executionOccurred()) {
             concurrentExecutionCount.decrementAndGet();
         }
     }

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/AbstractHystrixCommand.java
Patch:
@@ -170,7 +170,7 @@ Object process(Action action) throws Exception {
      */
     @Override
     protected T getFallback() {
-        throw new RuntimeException("No fallback available.", getFailedExecutionException());
+        throw new RuntimeException("No fallback available.", getExecutionException());
     }
 
     /**

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/BatchHystrixCommand.java
Patch:
@@ -72,7 +72,7 @@ protected List<Object> getFallback() {
                     Object execute() {
                         MetaHolder metaHolder = commandAction.getMetaHolder();
                         Object[] args = toArgs(getCollapsedRequests());
-                        args = createArgsForFallback(args, metaHolder, getFailedExecutionException());
+                        args = createArgsForFallback(args, metaHolder, getExecutionException());
                         return commandAction.executeWithArgs(commandAction.getMetaHolder().getFallbackExecutionType(), args);
                     }
                 });

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/GenericCommand.java
Patch:
@@ -71,7 +71,7 @@ protected Object getFallback() {
                     @Override
                     Object execute() {
                         MetaHolder metaHolder = commandAction.getMetaHolder();
-                        Object[] args = createArgsForFallback(metaHolder, getFailedExecutionException());
+                        Object[] args = createArgsForFallback(metaHolder, getExecutionException());
                         return commandAction.executeWithArgs(commandAction.getMetaHolder().getFallbackExecutionType(), args);
                     }
                 });

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/GenericObservableCommand.java
Patch:
@@ -85,7 +85,7 @@ protected Observable construct() {
     protected Observable resumeWithFallback() {
         if (commandActions.hasFallbackAction()) {
             MetaHolder metaHolder = commandActions.getFallbackAction().getMetaHolder();
-            Throwable cause = getFailedExecutionException();
+            Throwable cause = getExecutionException();
             if (cause instanceof CommandActionExecutionException) {
                 cause = cause.getCause();
             }

File: hystrix-contrib/hystrix-metrics-event-stream/src/main/java/com/netflix/hystrix/contrib/metrics/eventstream/HystrixMetricsStreamServlet.java
Patch:
@@ -60,6 +60,7 @@ public class HystrixMetricsStreamServlet extends HttpServlet {
     /* used to track number of connections and throttle */
     private static AtomicInteger concurrentConnections = new AtomicInteger(0);
     private static DynamicIntProperty maxConcurrentConnections = DynamicPropertyFactory.getInstance().getIntProperty("hystrix.stream.maxConcurrentConnections", 5);
+    private static DynamicIntProperty defaultMetricListenerQueueSize = DynamicPropertyFactory.getInstance().getIntProperty("hystrix.stream.defaultMetricListenerQueueSize", 1000);
 
     private static volatile boolean isDestroyed = false;
     
@@ -133,11 +134,11 @@ private void handleRequest(HttpServletRequest request, HttpServletResponse respo
                 response.setHeader("Cache-Control", "no-cache, no-store, max-age=0, must-revalidate");
                 response.setHeader("Pragma", "no-cache");
 
-                int queueSize = 1000;
+                int queueSize = defaultMetricListenerQueueSize.get();
                 try {
                     String q = request.getParameter("queueSize");
                     if (q != null) {
-                        queueSize = Math.max(Integer.parseInt(q), queueSize);
+                        queueSize = Integer.parseInt(q);
                     }
                 } catch (Exception e) {
                     // ignore if it's not a number

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixObservableCommandTest.java
Patch:
@@ -925,7 +925,6 @@ public void testShortCircuitFallbackCounter() {
 
         assertCommandExecutionEvents(command1, HystrixEventType.SHORT_CIRCUITED, HystrixEventType.FALLBACK_EMIT, HystrixEventType.FALLBACK_SUCCESS);
         assertCommandExecutionEvents(command2, HystrixEventType.SHORT_CIRCUITED, HystrixEventType.FALLBACK_EMIT, HystrixEventType.FALLBACK_SUCCESS);
-        assertEquals(0, circuitBreaker.metrics.getCurrentConcurrentExecutionCount());
         assertSaneHystrixRequestLog(2);
     }
 
@@ -1182,7 +1181,6 @@ public void onNext(Boolean b) {
             }
         }
         assertEquals("expected some of shared semaphore commands to get rejected", sharedSemaphore.numberOfPermits.get().longValue(), numSemaphoreRejected);
-        assertEquals(0, circuitBreaker.metrics.getCurrentConcurrentExecutionCount());
     }
 
     /**

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixObservableCommandTest.java
Patch:
@@ -925,7 +925,6 @@ public void testShortCircuitFallbackCounter() {
 
         assertCommandExecutionEvents(command1, HystrixEventType.SHORT_CIRCUITED, HystrixEventType.FALLBACK_EMIT, HystrixEventType.FALLBACK_SUCCESS);
         assertCommandExecutionEvents(command2, HystrixEventType.SHORT_CIRCUITED, HystrixEventType.FALLBACK_EMIT, HystrixEventType.FALLBACK_SUCCESS);
-        assertEquals(0, circuitBreaker.metrics.getCurrentConcurrentExecutionCount());
         assertSaneHystrixRequestLog(2);
     }
 
@@ -1182,7 +1181,6 @@ public void onNext(Boolean b) {
             }
         }
         assertEquals("expected some of shared semaphore commands to get rejected", sharedSemaphore.numberOfPermits.get().longValue(), numSemaphoreRejected);
-        assertEquals(0, circuitBreaker.metrics.getCurrentConcurrentExecutionCount());
     }
 
     /**

File: hystrix-core/src/test/java/com/netflix/hystrix/strategy/HystrixPluginsTest.java
Patch:
@@ -54,6 +54,8 @@ public void reset() {
     
     @Test
     public void testDynamicProperties() throws Exception {
+        fakeServiceLoaderResource = 
+                "FAKE_META_INF_SERVICES/com.netflix.hystrix.strategy.properties.HystrixDynamicProperties";
         HystrixPlugins plugins = setupMockServiceLoader();
         HystrixDynamicProperties properties = plugins.getDynamicProperties();
         plugins.getCommandExecutionHook();

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixTimerThreadPoolProperties.java
Patch:
@@ -1,6 +1,6 @@
 package com.netflix.hystrix;
 
-import com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedArchaiusProperty;
+import com.netflix.hystrix.strategy.properties.HystrixPropertiesChainedProperty;
 import com.netflix.hystrix.strategy.properties.HystrixPropertiesStrategy;
 import com.netflix.hystrix.strategy.properties.HystrixProperty;
 
@@ -24,8 +24,8 @@ protected HystrixTimerThreadPoolProperties(Setter setter) {
     }
 
     private static HystrixProperty<Integer> getProperty(String propertyPrefix, String instanceProperty, Integer defaultValue) {
-        return asProperty(new HystrixPropertiesChainedArchaiusProperty.IntegerProperty(
-                new HystrixPropertiesChainedArchaiusProperty.DynamicIntegerProperty(propertyPrefix + ".timer.threadpool.default." + instanceProperty, defaultValue)));
+        return asProperty(new HystrixPropertiesChainedProperty.IntegerProperty(
+                new HystrixPropertiesChainedProperty.DynamicIntegerProperty(propertyPrefix + ".timer.threadpool.default." + instanceProperty, defaultValue)));
     }
 
     public HystrixProperty<Integer> getCorePoolSize() {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPool.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
@@ -27,6 +28,7 @@
 import com.netflix.hystrix.strategy.concurrency.HystrixContextScheduler;
 import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisherFactory;
 import com.netflix.hystrix.strategy.properties.HystrixPropertiesFactory;
+
 import rx.functions.Func0;
 
 /**
@@ -49,7 +51,7 @@ public interface HystrixThreadPool {
      * 
      * @return ThreadPoolExecutor
      */
-    public ThreadPoolExecutor getExecutor();
+    public ExecutorService getExecutor();
 
     public Scheduler getScheduler();
 

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixTest.java
Patch:
@@ -416,14 +416,14 @@ public void testResetCommandProperties() {
         HystrixCommand<Boolean> cmd1 = new ResettableCommand(100, 1, 10);
         assertEquals(100L, (long) cmd1.getProperties().executionTimeoutInMilliseconds().get());
         assertEquals(1L, (long) cmd1.getProperties().executionIsolationSemaphoreMaxConcurrentRequests().get());
-        assertEquals(10L, (long) cmd1.threadPool.getExecutor().getCorePoolSize());
+        //assertEquals(10L, (long) cmd1.threadPool.getExecutor()..getCorePoolSize());
 
         Hystrix.reset();
 
         HystrixCommand<Boolean> cmd2 = new ResettableCommand(700, 2, 40);
         assertEquals(700L, (long) cmd2.getProperties().executionTimeoutInMilliseconds().get());
         assertEquals(2L, (long) cmd2.getProperties().executionIsolationSemaphoreMaxConcurrentRequests().get());
-        assertEquals(40L, (long) cmd2.threadPool.getExecutor().getCorePoolSize());
+        //assertEquals(40L, (long) cmd2.threadPool.getExecutor().getCorePoolSize());
 	}
 
     private static class SynchronousObservableCommand extends HystrixObservableCommand<Integer> {

File: hystrix-core/src/jmh/java/com/netflix/hystrix/perf/CommandExecutionPerfTest.java
Patch:
@@ -36,8 +36,11 @@
 import org.openjdk.jmh.infra.Blackhole;
 import rx.Observable;
 import rx.functions.Func0;
+import rx.schedulers.Schedulers;
 
 import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;

File: hystrix-contrib/hystrix-servo-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/servopublisher/HystrixServoMetricsPublisherCommand.java
Patch:
@@ -27,6 +27,7 @@
 import com.netflix.hystrix.metric.CumulativeCommandEventCounterStream;
 import com.netflix.hystrix.metric.RollingCommandEventCounterStream;
 import com.netflix.hystrix.metric.RollingCommandLatencyDistributionStream;
+import com.netflix.hystrix.metric.RollingCommandMaxConcurrencyStream;
 import com.netflix.hystrix.metric.RollingCommandUserLatencyDistributionStream;
 import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisherCommand;
 import com.netflix.hystrix.util.HystrixRollingNumberEvent;
@@ -113,6 +114,7 @@ public void initialize() {
         CumulativeCommandEventCounterStream.getInstance(key, properties).startCachingStreamValuesIfUnstarted();
         RollingCommandLatencyDistributionStream.getInstance(key, properties).startCachingStreamValuesIfUnstarted();
         RollingCommandUserLatencyDistributionStream.getInstance(key, properties).startCachingStreamValuesIfUnstarted();
+        RollingCommandMaxConcurrencyStream.getInstance(key, properties).startCachingStreamValuesIfUnstarted();
     }
 
     @Override

File: hystrix-contrib/hystrix-servo-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/servopublisher/HystrixServoMetricsPublisherThreadPool.java
Patch:
@@ -22,6 +22,7 @@
 import com.netflix.hystrix.HystrixThreadPoolMetrics;
 import com.netflix.hystrix.HystrixThreadPoolProperties;
 import com.netflix.hystrix.metric.CumulativeThreadPoolEventCounterStream;
+import com.netflix.hystrix.metric.RollingThreadPoolConcurrencyStream;
 import com.netflix.hystrix.metric.RollingThreadPoolEventCounterStream;
 import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisherThreadPool;
 import com.netflix.hystrix.util.HystrixRollingNumberEvent;
@@ -98,6 +99,7 @@ public void initialize() {
         DefaultMonitorRegistry.getInstance().register(commandMetricsMonitor);
         RollingThreadPoolEventCounterStream.getInstance(key, properties).startCachingStreamValuesIfUnstarted();
         CumulativeThreadPoolEventCounterStream.getInstance(key, properties).startCachingStreamValuesIfUnstarted();
+        RollingThreadPoolConcurrencyStream.getInstance(key, properties).startCachingStreamValuesIfUnstarted();
     }
 
     @Override

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java
Patch:
@@ -490,6 +490,7 @@ private Observable<R> getRunObservableDecoratedForMetricsAndErrorHandling() {
                 @Override
                 public void call(Subscriber<? super R> s) {
                     metrics.markCommandStart(commandKey, threadPoolKey, ExecutionIsolationStrategy.THREAD);
+
                     if (isCommandTimedOut.get() == TimedOutStatus.TIMED_OUT) {
                         // the command timed out in the wrapping thread so we will return immediately
                         // and not increment any of the counters below or other such logic

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPool.java
Patch:
@@ -210,14 +210,17 @@ private void touchConfig() {
 
         @Override
         public void markThreadExecution() {
+            metrics.markThreadExecution();
         }
 
         @Override
         public void markThreadCompletion() {
+            metrics.markThreadCompletion();
         }
 
         @Override
         public void markThreadRejection() {
+            metrics.markThreadRejection();
         }
 
         /**

File: hystrix-core/src/main/java/com/netflix/hystrix/metric/CumulativeCommandEventCounterStream.java
Patch:
@@ -78,7 +78,7 @@ public static void reset() {
     private CumulativeCommandEventCounterStream(HystrixCommandKey commandKey, int numCounterBuckets, int counterBucketSizeInMs,
                                                 Func2<long[], HystrixCommandCompletion, long[]> reduceCommandCompletion,
                                                 Func2<long[], long[], long[]> reduceBucket) {
-        super(HystrixCommandEventStream.getInstance(commandKey), numCounterBuckets, counterBucketSizeInMs, reduceCommandCompletion, reduceBucket);
+        super(HystrixCommandCompletionStream.getInstance(commandKey), numCounterBuckets, counterBucketSizeInMs, reduceCommandCompletion, reduceBucket);
     }
 
     @Override

File: hystrix-core/src/main/java/com/netflix/hystrix/metric/CumulativeThreadPoolEventCounterStream.java
Patch:
@@ -79,7 +79,7 @@ public static void reset() {
     private CumulativeThreadPoolEventCounterStream(HystrixThreadPoolKey threadPoolKey, int numCounterBuckets, int counterBucketSizeInMs,
                                                    Func2<long[], HystrixCommandCompletion, long[]> reduceCommandCompletion,
                                                    Func2<long[], long[], long[]> reduceBucket) {
-        super(HystrixThreadPoolEventStream.getInstance(threadPoolKey), numCounterBuckets, counterBucketSizeInMs, reduceCommandCompletion, reduceBucket);
+        super(HystrixThreadPoolCompletionStream.getInstance(threadPoolKey), numCounterBuckets, counterBucketSizeInMs, reduceCommandCompletion, reduceBucket);
     }
 
     @Override

File: hystrix-core/src/main/java/com/netflix/hystrix/metric/HealthCountsStream.java
Patch:
@@ -90,7 +90,7 @@ public static void removeByKey(HystrixCommandKey key) {
 
     private HealthCountsStream(final HystrixCommandKey commandKey, final int numBuckets, final int bucketSizeInMs,
                                Func2<long[], HystrixCommandCompletion, long[]> reduceCommandCompletion) {
-        super(HystrixCommandEventStream.getInstance(commandKey), numBuckets, bucketSizeInMs, reduceCommandCompletion, healthCheckAccumulator);
+        super(HystrixCommandCompletionStream.getInstance(commandKey), numBuckets, bucketSizeInMs, reduceCommandCompletion, healthCheckAccumulator);
     }
 
     @Override

File: hystrix-core/src/main/java/com/netflix/hystrix/metric/RollingCommandEventCounterStream.java
Patch:
@@ -76,7 +76,7 @@ public static void reset() {
     private RollingCommandEventCounterStream(HystrixCommandKey commandKey, int numCounterBuckets, int counterBucketSizeInMs,
                                              Func2<long[], HystrixCommandCompletion, long[]> reduceCommandCompletion,
                                              Func2<long[], long[], long[]> reduceBucket) {
-        super(HystrixCommandEventStream.getInstance(commandKey), numCounterBuckets, counterBucketSizeInMs, reduceCommandCompletion, reduceBucket);
+        super(HystrixCommandCompletionStream.getInstance(commandKey), numCounterBuckets, counterBucketSizeInMs, reduceCommandCompletion, reduceBucket);
     }
 
     @Override

File: hystrix-core/src/main/java/com/netflix/hystrix/metric/RollingCommandLatencyDistributionStream.java
Patch:
@@ -49,7 +49,6 @@ public class RollingCommandLatencyDistributionStream extends RollingDistribution
     private static final Func2<Histogram, HystrixCommandCompletion, Histogram> addValuesToBucket = new Func2<Histogram, HystrixCommandCompletion, Histogram>() {
         @Override
         public Histogram call(Histogram initialDistribution, HystrixCommandCompletion event) {
-            System.out.println("Received event : " + event);
             if (event.didCommandExecute() && event.getExecutionLatency() > -1) {
                 initialDistribution.recordValue(event.getExecutionLatency());
             }
@@ -88,6 +87,6 @@ public static void reset() {
     }
 
     private RollingCommandLatencyDistributionStream(HystrixCommandKey commandKey, int numPercentileBuckets, int percentileBucketSizeInMs) {
-        super(HystrixCommandEventStream.getInstance(commandKey), numPercentileBuckets, percentileBucketSizeInMs, addValuesToBucket);
+        super(HystrixCommandCompletionStream.getInstance(commandKey), numPercentileBuckets, percentileBucketSizeInMs, addValuesToBucket);
     }
 }

File: hystrix-core/src/main/java/com/netflix/hystrix/metric/RollingCommandUserLatencyDistributionStream.java
Patch:
@@ -89,6 +89,6 @@ public static void reset() {
     }
 
     private RollingCommandUserLatencyDistributionStream(HystrixCommandKey commandKey, int numPercentileBuckets, int percentileBucketSizeInMs) {
-        super(HystrixCommandEventStream.getInstance(commandKey), numPercentileBuckets, percentileBucketSizeInMs, addValuesToBucket);
+        super(HystrixCommandCompletionStream.getInstance(commandKey), numPercentileBuckets, percentileBucketSizeInMs, addValuesToBucket);
     }
 }

File: hystrix-core/src/main/java/com/netflix/hystrix/metric/RollingThreadPoolEventCounterStream.java
Patch:
@@ -15,8 +15,6 @@
  */
 package com.netflix.hystrix.metric;
 
-import com.netflix.hystrix.HystrixCommandKey;
-import com.netflix.hystrix.HystrixCommandProperties;
 import com.netflix.hystrix.HystrixEventType;
 import com.netflix.hystrix.HystrixThreadPoolKey;
 import com.netflix.hystrix.HystrixThreadPoolMetrics;
@@ -80,7 +78,7 @@ public static void reset() {
     private RollingThreadPoolEventCounterStream(HystrixThreadPoolKey threadPoolKey, int numCounterBuckets, int counterBucketSizeInMs,
                                                 Func2<long[], HystrixCommandCompletion, long[]> reduceCommandCompletion,
                                                 Func2<long[], long[], long[]> reduceBucket) {
-        super(HystrixThreadPoolEventStream.getInstance(threadPoolKey), numCounterBuckets, counterBucketSizeInMs, reduceCommandCompletion, reduceBucket);
+        super(HystrixThreadPoolCompletionStream.getInstance(threadPoolKey), numCounterBuckets, counterBucketSizeInMs, reduceCommandCompletion, reduceBucket);
     }
 
     @Override

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java
Patch:
@@ -2054,7 +2054,7 @@ public boolean isResponseFromCache() {
      * @return boolean
      */
     public boolean isResponseRejected() {
-        return executionResult.events.contains(HystrixEventType.THREAD_POOL_REJECTED) || executionResult.events.contains(HystrixEventType.SEMAPHORE_REJECTED);
+        return executionResult.isResponseRejected();
     }
 
     /**

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java
Patch:
@@ -1807,6 +1807,9 @@ public long[] getEventCounts() {
                 } else if (eventType.equals(HystrixEventType.FALLBACK_EMIT)) {
                     eventCounts[eventType.ordinal()] += numFallbackEmissions;
                 } else {
+                    if (eventType.equals(HystrixEventType.FALLBACK_FAILURE) || eventType.equals(HystrixEventType.FALLBACK_REJECTION) || eventType.equals(HystrixEventType.FALLBACK_MISSING)) {
+                        eventCounts[HystrixEventType.EXCEPTION_THROWN.ordinal()]++;
+                    }
                     eventCounts[eventType.ordinal()]++;
                 }
             }

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandProperties.java
Patch:
@@ -42,7 +42,7 @@ public abstract class HystrixCommandProperties {
     private static final Integer default_metricsRollingStatisticalWindowBuckets = 10;// default => statisticalWindowBuckets: 10 = 10 buckets in a 10 second window so each bucket is 1 second
     private static final Integer default_circuitBreakerRequestVolumeThreshold = 20;// default => statisticalWindowVolumeThreshold: 20 requests in 10 seconds must occur before statistics matter
     private static final Integer default_circuitBreakerSleepWindowInMilliseconds = 5000;// default => sleepWindow: 5000 = 5 seconds that we will sleep before trying again after tripping the circuit
-    private static final Integer default_circuitBreakerErrorThresholdPercentage = 50;// default => errorThresholdPercentage = 50 = if 50%+ of requests in 10 seconds are failures or latent when we will trip the circuit
+    private static final Integer default_circuitBreakerErrorThresholdPercentage = 50;// default => errorThresholdPercentage = 50 = if 50%+ of requests in 10 seconds are failures or latent then we will trip the circuit
     private static final Boolean default_circuitBreakerForceOpen = false;// default => forceCircuitOpen = false (we want to allow traffic)
     /* package */ static final Boolean default_circuitBreakerForceClosed = false;// default => ignoreErrors = false 
     private static final Integer default_executionTimeoutInMilliseconds = 1000; // default => executionTimeoutInMilliseconds: 1000 = 1 second
@@ -762,4 +762,4 @@ public Setter withRequestLogEnabled(boolean value) {
     }
 
 
-}
\ No newline at end of file
+}

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandProperties.java
Patch:
@@ -42,7 +42,7 @@ public abstract class HystrixCommandProperties {
     private static final Integer default_metricsRollingStatisticalWindowBuckets = 10;// default => statisticalWindowBuckets: 10 = 10 buckets in a 10 second window so each bucket is 1 second
     private static final Integer default_circuitBreakerRequestVolumeThreshold = 20;// default => statisticalWindowVolumeThreshold: 20 requests in 10 seconds must occur before statistics matter
     private static final Integer default_circuitBreakerSleepWindowInMilliseconds = 5000;// default => sleepWindow: 5000 = 5 seconds that we will sleep before trying again after tripping the circuit
-    private static final Integer default_circuitBreakerErrorThresholdPercentage = 50;// default => errorThresholdPercentage = 50 = if 50%+ of requests in 10 seconds are failures or latent when we will trip the circuit
+    private static final Integer default_circuitBreakerErrorThresholdPercentage = 50;// default => errorThresholdPercentage = 50 = if 50%+ of requests in 10 seconds are failures or latent then we will trip the circuit
     private static final Boolean default_circuitBreakerForceOpen = false;// default => forceCircuitOpen = false (we want to allow traffic)
     /* package */ static final Boolean default_circuitBreakerForceClosed = false;// default => ignoreErrors = false 
     private static final Integer default_executionTimeoutInMilliseconds = 1000; // default => executionTimeoutInMilliseconds: 1000 = 1 second
@@ -762,4 +762,4 @@ public Setter withRequestLogEnabled(boolean value) {
     }
 
 
-}
\ No newline at end of file
+}

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/CollapsedRequestObservableFunction.java
Patch:
@@ -17,6 +17,8 @@
 
 import rx.Observable.OnSubscribe;
 import rx.Subscriber;
+import rx.functions.Action0;
+import rx.functions.Action1;
 import rx.subjects.PublishSubject;
 
 import com.netflix.hystrix.HystrixCollapser.CollapsedRequest;

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapser.java
Patch:
@@ -87,7 +87,7 @@ public Observable<ResponseType> submitRequest(RequestArgumentType arg) {
         while (true) {
             RequestBatch<BatchReturnType, ResponseType, RequestArgumentType> b = batch.get();
             if (b == null) {
-                throw new IllegalStateException("Submitting requests after collapser is shutdown");
+                return Observable.error(new IllegalStateException("Submitting requests after collapser is shutdown"));
             }
             Observable<ResponseType> f = b.offer(arg);
             // it will always get an Observable unless we hit the max batch size
@@ -150,9 +150,9 @@ public Void call() throws Exception {
                             createNewBatchAndExecutePreviousIfNeeded(currentBatch);
                         }
                     } catch (Throwable t) {
-                        logger.error("Error occurred trying to executeRequestsFromQueue.", t);
+                        logger.error("Error occurred trying to execute the batch.", t);
+                        t.printStackTrace();
                         // ignore error so we don't kill the Timer mainLoop and prevent further items from being scheduled
-                        // http://jira.netflix.com/browse/API-5042 HystrixCommand: Collapser TimerThread Vulnerable to Shutdown
                     }
                     return null;
                 }

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/CollapsedRequestObservableFunction.java
Patch:
@@ -17,6 +17,8 @@
 
 import rx.Observable.OnSubscribe;
 import rx.Subscriber;
+import rx.functions.Action0;
+import rx.functions.Action1;
 import rx.subjects.PublishSubject;
 
 import com.netflix.hystrix.HystrixCollapser.CollapsedRequest;

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapser.java
Patch:
@@ -87,7 +87,7 @@ public Observable<ResponseType> submitRequest(RequestArgumentType arg) {
         while (true) {
             RequestBatch<BatchReturnType, ResponseType, RequestArgumentType> b = batch.get();
             if (b == null) {
-                throw new IllegalStateException("Submitting requests after collapser is shutdown");
+                return Observable.error(new IllegalStateException("Submitting requests after collapser is shutdown"));
             }
             Observable<ResponseType> f = b.offer(arg);
             // it will always get an Observable unless we hit the max batch size
@@ -150,9 +150,9 @@ public Void call() throws Exception {
                             createNewBatchAndExecutePreviousIfNeeded(currentBatch);
                         }
                     } catch (Throwable t) {
-                        logger.error("Error occurred trying to executeRequestsFromQueue.", t);
+                        logger.error("Error occurred trying to execute the batch.", t);
+                        t.printStackTrace();
                         // ignore error so we don't kill the Timer mainLoop and prevent further items from being scheduled
-                        // http://jira.netflix.com/browse/API-5042 HystrixCommand: Collapser TimerThread Vulnerable to Shutdown
                     }
                     return null;
                 }

File: hystrix-contrib/hystrix-network-auditor-agent/src/main/java/com/netflix/hystrix/contrib/networkauditor/HystrixNetworkAuditorEventListener.java
Patch:
@@ -36,6 +36,7 @@ public interface HystrixNetworkAuditorEventListener {
      *      // this event is not inside a Hystrix context (according to ThreadLocal variables)
      *      StackTraceElement[] stack = Thread.currentThread().getStackTrace();
      *      // increment counters, fire alerts, log stack traces etc
+     * }
      * } </pre>
      * 
      */

File: hystrix-contrib/hystrix-network-auditor-agent/src/main/java/com/netflix/hystrix/contrib/networkauditor/HystrixNetworkAuditorEventListener.java
Patch:
@@ -36,6 +36,7 @@ public interface HystrixNetworkAuditorEventListener {
      *      // this event is not inside a Hystrix context (according to ThreadLocal variables)
      *      StackTraceElement[] stack = Thread.currentThread().getStackTrace();
      *      // increment counters, fire alerts, log stack traces etc
+     * }
      * } </pre>
      * 
      */

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/CommandAction.java
Patch:
@@ -22,6 +22,8 @@
  */
 public abstract class CommandAction {
 
+    public abstract MetaHolder getMetaHolder();
+
     /**
      * Executes action in accordance with the given execution type.
      *

File: hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/test/common/domain/User.java
Patch:
@@ -18,7 +18,7 @@
 /**
  * Simple domain object for tests.
  */
-public class User {
+public class User extends Domain{
 
     private String id;
     private String name;

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/annotation/HystrixCommand.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.lang.annotation.Documented;
 import java.lang.annotation.ElementType;
+import java.lang.annotation.Inherited;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
@@ -27,6 +28,7 @@
  */
 @Target({ElementType.METHOD})
 @Retention(RetentionPolicy.RUNTIME)
+@Inherited
 @Documented
 public @interface HystrixCommand {
 

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/utils/ajc/AjcUtils.java
Patch:
@@ -45,7 +45,7 @@ public static Method getAjcMethod(final Class<?> target, final String methodName
                     Class<?>[] origParamTypes = removeAspectjArgs(parameterTypes);
                     int index = 0;
                     for (Class<?> pType : origParamTypes) {
-                        Class<?> expected = pTypes[index];
+                        Class<?> expected = pTypes[index++];
                         if (pType != expected) {
                             match = false;
                         }

File: hystrix-contrib/hystrix-metrics-event-stream/src/main/java/com/netflix/hystrix/contrib/metrics/eventstream/HystrixMetricsPoller.java
Patch:
@@ -206,7 +206,7 @@ private String getCommandJson(HystrixCommandMetrics commandMetrics) throws IOExc
             json.writeNumberField("rollingCountEmit", commandMetrics.getRollingCount(HystrixRollingNumberEvent.EMIT));
             json.writeNumberField("rollingCountExceptionsThrown", commandMetrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
             json.writeNumberField("rollingCountFailure", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
-            json.writeNumberField("rollingCountEmit", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_EMIT));
+            json.writeNumberField("rollingCountFallbackEmit", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_EMIT));
             json.writeNumberField("rollingCountFallbackFailure", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
             json.writeNumberField("rollingCountFallbackMissing", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_MISSING));
             json.writeNumberField("rollingCountFallbackRejection", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));

File: hystrix-contrib/hystrix-metrics-event-stream/src/main/java/com/netflix/hystrix/contrib/metrics/eventstream/HystrixMetricsPoller.java
Patch:
@@ -206,7 +206,7 @@ private String getCommandJson(HystrixCommandMetrics commandMetrics) throws IOExc
             json.writeNumberField("rollingCountEmit", commandMetrics.getRollingCount(HystrixRollingNumberEvent.EMIT));
             json.writeNumberField("rollingCountExceptionsThrown", commandMetrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
             json.writeNumberField("rollingCountFailure", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
-            json.writeNumberField("rollingCountFalbackEmit", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_EMIT));
+            json.writeNumberField("rollingCountFallbackEmit", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_EMIT));
             json.writeNumberField("rollingCountFallbackFailure", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
             json.writeNumberField("rollingCountFallbackMissing", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_MISSING));
             json.writeNumberField("rollingCountFallbackRejection", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));

File: hystrix-contrib/hystrix-metrics-event-stream/src/main/java/com/netflix/hystrix/contrib/metrics/eventstream/HystrixMetricsPoller.java
Patch:
@@ -206,7 +206,7 @@ private String getCommandJson(HystrixCommandMetrics commandMetrics) throws IOExc
             json.writeNumberField("rollingCountEmit", commandMetrics.getRollingCount(HystrixRollingNumberEvent.EMIT));
             json.writeNumberField("rollingCountExceptionsThrown", commandMetrics.getRollingCount(HystrixRollingNumberEvent.EXCEPTION_THROWN));
             json.writeNumberField("rollingCountFailure", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FAILURE));
-            json.writeNumberField("rollingCountEmit", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_EMIT));
+            json.writeNumberField("rollingCountFalbackEmit", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_EMIT));
             json.writeNumberField("rollingCountFallbackFailure", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_FAILURE));
             json.writeNumberField("rollingCountFallbackMissing", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_MISSING));
             json.writeNumberField("rollingCountFallbackRejection", commandMetrics.getRollingCount(HystrixRollingNumberEvent.FALLBACK_REJECTION));

File: hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixRollingNumberEvent.java
Patch:
@@ -30,7 +30,7 @@
  */
 public enum HystrixRollingNumberEvent {
     SUCCESS(1), FAILURE(1), TIMEOUT(1), SHORT_CIRCUITED(1), THREAD_POOL_REJECTED(1), SEMAPHORE_REJECTED(1), BAD_REQUEST(1),
-    FALLBACK_SUCCESS(1), FALLBACK_FAILURE(1), FALLBACK_REJECTION(1), EXCEPTION_THROWN(1), COMMAND_MAX_ACTIVE(2), EMIT(1), FALLBACK_EMIT(1),
+    FALLBACK_SUCCESS(1), FALLBACK_FAILURE(1), FALLBACK_REJECTION(1), FALLBACK_MISSING(1), EXCEPTION_THROWN(1), COMMAND_MAX_ACTIVE(2), EMIT(1), FALLBACK_EMIT(1),
     THREAD_EXECUTION(1), THREAD_MAX_ACTIVE(2), COLLAPSED(1), RESPONSE_FROM_CACHE(1),
     COLLAPSER_REQUEST_BATCHED(1), COLLAPSER_BATCH(1);
 

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCollapserTest.java
Patch:
@@ -743,9 +743,10 @@ public void testRequestCacheWithException() {
         assertEquals(1, HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().size());
 
         HystrixInvokableInfo<?> command = HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().toArray(new HystrixInvokableInfo<?>[1])[0];
-        assertEquals(2, command.getExecutionEvents().size());
+        assertEquals(3, command.getExecutionEvents().size());
         assertTrue(command.getExecutionEvents().contains(HystrixEventType.FAILURE));
         assertTrue(command.getExecutionEvents().contains(HystrixEventType.COLLAPSED));
+        assertTrue(command.getExecutionEvents().contains(HystrixEventType.FALLBACK_MISSING));
 
         HystrixCollapserMetrics metrics = command1.getMetrics();
         assertEquals(1L, metrics.getRollingCount(HystrixRollingNumberEvent.COLLAPSER_REQUEST_BATCHED));

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixRequestLogTest.java
Patch:
@@ -128,7 +128,7 @@ public void testTimeout() {
             String log = HystrixRequestLog.getCurrentRequest().getExecutedCommandsAsString();
             // strip the actual count so we can compare reliably
             log = log.replaceAll(DIGITS_REGEX, "[");
-            assertEquals("TestCommand[TIMEOUT][ms]", log);
+            assertEquals("TestCommand[TIMEOUT, FALLBACK_MISSING][ms]", log);
         } finally {
             context.shutdown();
         }

File: hystrix-contrib/hystrix-servo-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/servopublisher/HystrixServoMetricsPublisherCommand.java
Patch:
@@ -176,7 +176,7 @@ public Long getValue() {
     }
 
     protected Monitor<?> getRollingMonitor(final String name, final HystrixEventType event) {
-        return new CounterMetric(MonitorConfig.builder(name).withTag(getServoTypeTag()).withTag(getServoInstanceTag()).build()) {
+        return new GaugeMetric(MonitorConfig.builder(name).withTag(DataSourceLevel.DEBUG).withTag(getServoTypeTag()).withTag(getServoInstanceTag()).build()) {
             @Override
             public Long getValue() {
                 return metrics.getRollingCount(getRollingNumberTypeFromEventType(event));

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPool.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 
@@ -27,6 +28,7 @@
 import com.netflix.hystrix.strategy.concurrency.HystrixContextScheduler;
 import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisherFactory;
 import com.netflix.hystrix.strategy.properties.HystrixPropertiesFactory;
+
 import rx.functions.Func0;
 
 /**
@@ -49,7 +51,7 @@ public interface HystrixThreadPool {
      * 
      * @return ThreadPoolExecutor
      */
-    public ThreadPoolExecutor getExecutor();
+    public ExecutorService getExecutor();
 
     public Scheduler getScheduler();
 

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixTest.java
Patch:
@@ -194,14 +194,14 @@ public void testResetCommandProperties() {
         HystrixCommand<Boolean> cmd1 = new ResettableCommand(100, 1, 10);
         assertEquals(100L, (long) cmd1.getProperties().executionTimeoutInMilliseconds().get());
         assertEquals(1L, (long) cmd1.getProperties().executionIsolationSemaphoreMaxConcurrentRequests().get());
-        assertEquals(10L, (long) cmd1.threadPool.getExecutor().getCorePoolSize());
+        //assertEquals(10L, (long) cmd1.threadPool.getExecutor()..getCorePoolSize());
 
         Hystrix.reset();
 
         HystrixCommand<Boolean> cmd2 = new ResettableCommand(700, 2, 40);
         assertEquals(700L, (long) cmd2.getProperties().executionTimeoutInMilliseconds().get());
         assertEquals(2L, (long) cmd2.getProperties().executionIsolationSemaphoreMaxConcurrentRequests().get());
-        assertEquals(40L, (long) cmd2.threadPool.getExecutor().getCorePoolSize());
+        //assertEquals(40L, (long) cmd2.threadPool.getExecutor().getCorePoolSize());
 	}
 
     private static class ResettableCommand extends HystrixCommand<Boolean> {

File: hystrix-contrib/hystrix-servo-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/servopublisher/HystrixServoMetricsPublisherCommandAbstract.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2012 Netflix, Inc.
+ * Copyright 2015 Netflix, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/cache/HystrixCacheKeyGenerator.java
Patch:
@@ -58,7 +58,7 @@ public HystrixGeneratedCacheKey generateCacheKey(CacheInvocationContext<? extend
                 StringBuilder cacheKeyBuilder = new StringBuilder();
                 for (CacheInvocationParameter parameter : cacheInvocationContext.getKeyParameters()) {
                     CacheKey cacheKey = parameter.getCacheKeyAnnotation();
-                    if (StringUtils.isNotBlank(cacheKey.value())) {
+                    if (cacheKey != null && StringUtils.isNotBlank(cacheKey.value())) {
                         appendPropertyValue(cacheKeyBuilder, Arrays.asList(StringUtils.split(cacheKey.value(), ".")), parameter.getValue());
                     } else {
                         cacheKeyBuilder.append(parameter.getValue());

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/cache/HystrixCacheKeyGenerator.java
Patch:
@@ -58,7 +58,7 @@ public HystrixGeneratedCacheKey generateCacheKey(CacheInvocationContext<? extend
                 StringBuilder cacheKeyBuilder = new StringBuilder();
                 for (CacheInvocationParameter parameter : cacheInvocationContext.getKeyParameters()) {
                     CacheKey cacheKey = parameter.getCacheKeyAnnotation();
-                    if (StringUtils.isNotBlank(cacheKey.value())) {
+                    if (cacheKey != null && StringUtils.isNotBlank(cacheKey.value())) {
                         appendPropertyValue(cacheKeyBuilder, Arrays.asList(StringUtils.split(cacheKey.value(), ".")), parameter.getValue());
                     } else {
                         cacheKeyBuilder.append(parameter.getValue());

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java
Patch:
@@ -613,6 +613,7 @@ public Observable<R> call(Throwable t) {
                      */
                     try {
                         metrics.markBadRequest(System.currentTimeMillis() - invocationStartTime);
+                        executionResult = executionResult.addEvents(HystrixEventType.BAD_REQUEST);
                         Exception decorated = executionHook.onError(_self, FailureType.BAD_REQUEST_EXCEPTION, (Exception) t);
 
                         if (decorated instanceof HystrixBadRequestException) {

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java
Patch:
@@ -613,6 +613,7 @@ public Observable<R> call(Throwable t) {
                      */
                     try {
                         metrics.markBadRequest(System.currentTimeMillis() - invocationStartTime);
+                        executionResult = executionResult.addEvents(HystrixEventType.BAD_REQUEST);
                         Exception decorated = executionHook.onError(_self, FailureType.BAD_REQUEST_EXCEPTION, (Exception) t);
 
                         if (decorated instanceof HystrixBadRequestException) {

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java
Patch:
@@ -3513,7 +3513,7 @@ public void testSemaphoreExecutionWithTimeout() {
      * Test a recoverable java.lang.Error being thrown with no fallback
      */
     @Test
-    public void testRecoverableErrorThrownWithNoFallback() {
+    public void testRecoverableErrorWithNoFallbackThrowsError() {
         TestHystrixCommand<?> command = getRecoverableErrorCommand(ExecutionIsolationStrategy.THREAD, AbstractTestHystrixCommand.FallbackResult.UNIMPLEMENTED);
         try {
             command.execute();
@@ -3539,7 +3539,7 @@ public void testRecoverableErrorThrownWithNoFallback() {
     }
 
     @Test
-    public void testRecoverableErrorThrownWithFallback() {
+    public void testRecoverableErrorMaskedByFallbackButLogged() {
         TestHystrixCommand<?> command = getRecoverableErrorCommand(ExecutionIsolationStrategy.THREAD, AbstractTestHystrixCommand.FallbackResult.SUCCESS);
         try {
             assertEquals(FlexibleTestHystrixCommand.FALLBACK_VALUE, command.execute());

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java
Patch:
@@ -3513,7 +3513,7 @@ public void testSemaphoreExecutionWithTimeout() {
      * Test a recoverable java.lang.Error being thrown with no fallback
      */
     @Test
-    public void testRecoverableErrorThrownWithNoFallback() {
+    public void testRecoverableErrorWithNoFallbackThrowsError() {
         TestHystrixCommand<?> command = getRecoverableErrorCommand(ExecutionIsolationStrategy.THREAD, AbstractTestHystrixCommand.FallbackResult.UNIMPLEMENTED);
         try {
             command.execute();
@@ -3539,7 +3539,7 @@ public void testRecoverableErrorThrownWithNoFallback() {
     }
 
     @Test
-    public void testRecoverableErrorThrownWithFallback() {
+    public void testRecoverableErrorMaskedByFallbackButLogged() {
         TestHystrixCommand<?> command = getRecoverableErrorCommand(ExecutionIsolationStrategy.THREAD, AbstractTestHystrixCommand.FallbackResult.SUCCESS);
         try {
             assertEquals(FlexibleTestHystrixCommand.FALLBACK_VALUE, command.execute());

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java
Patch:
@@ -1360,7 +1360,7 @@ public void onCompleted() {
                     try {
                         executionHook.onExecutionSuccess(cmd);
                     } catch (Throwable hookEx) {
-                        logger.warn("Error calling HystrixCommandExecutionHook.onError", hookEx);
+                        logger.warn("Error calling HystrixCommandExecutionHook.onExecutionSuccess", hookEx);
                     }
                     subscriber.onCompleted();
                 }
@@ -1395,7 +1395,7 @@ public void onCompleted() {
                     try {
                         executionHook.onFallbackSuccess(cmd);
                     } catch (Throwable hookEx) {
-                        logger.warn("Error calling HystrixCommandExecutionHook.onError", hookEx);
+                        logger.warn("Error calling HystrixCommandExecutionHook.onFallbackSuccess", hookEx);
                     }
                     subscriber.onCompleted();
                 }

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapserMetrics.java
Patch:
@@ -92,8 +92,8 @@ public static Collection<HystrixCollapserMetrics> getInstances() {
         this.key = key;
         this.properties = properties;
 
-        this.percentileBatchSize = new HystrixRollingPercentile(properties.metricsRollingPercentileWindowInMilliseconds(), properties.metricsRollingPercentileWindowBuckets(), properties.metricsRollingPercentileBucketSize(), properties.metricsRollingPercentileEnabled());
-        this.percentileShardSize = new HystrixRollingPercentile(properties.metricsRollingPercentileWindowInMilliseconds(), properties.metricsRollingPercentileWindowBuckets(), properties.metricsRollingPercentileBucketSize(), properties.metricsRollingPercentileEnabled());
+        this.percentileBatchSize = new HystrixRollingPercentile(properties.metricsRollingPercentileWindowInMilliseconds(), properties.metricsRollingPercentileWindowBuckets(), properties.metricsRollingPercentileEnabled());
+        this.percentileShardSize = new HystrixRollingPercentile(properties.metricsRollingPercentileWindowInMilliseconds(), properties.metricsRollingPercentileWindowBuckets(), properties.metricsRollingPercentileEnabled());
     }
 
     /**

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandMetrics.java
Patch:
@@ -142,8 +142,8 @@ public static Collection<HystrixCommandMetrics> getInstances() {
         this.group = commandGroup;
         this.threadPoolKey = threadPoolKey;
         this.properties = properties;
-        this.percentileExecution = new HystrixRollingPercentile(properties.metricsRollingPercentileWindowInMilliseconds(), properties.metricsRollingPercentileWindowBuckets(), properties.metricsRollingPercentileBucketSize(), properties.metricsRollingPercentileEnabled());
-        this.percentileTotal = new HystrixRollingPercentile(properties.metricsRollingPercentileWindowInMilliseconds(), properties.metricsRollingPercentileWindowBuckets(), properties.metricsRollingPercentileBucketSize(), properties.metricsRollingPercentileEnabled());
+        this.percentileExecution = new HystrixRollingPercentile(properties.metricsRollingPercentileWindowInMilliseconds(), properties.metricsRollingPercentileWindowBuckets(), properties.metricsRollingPercentileEnabled());
+        this.percentileTotal = new HystrixRollingPercentile(properties.metricsRollingPercentileWindowInMilliseconds(), properties.metricsRollingPercentileWindowBuckets(), properties.metricsRollingPercentileEnabled());
         this.eventNotifier = eventNotifier;
     }
 

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixConcurrencyStrategy.java
Patch:
@@ -76,7 +76,9 @@ public ThreadPoolExecutor getThreadPool(final HystrixThreadPoolKey threadPoolKey
 
             @Override
             public Thread newThread(Runnable r) {
-                return new Thread(r, "hystrix-" + threadPoolKey.name() + "-" + threadNumber.incrementAndGet());
+                Thread thread = new Thread(r, "hystrix-" + threadPoolKey.name() + "-" + threadNumber.incrementAndGet());
+                thread.setDaemon(true);
+                return thread; 
             }
         });
     }

File: hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixTimer.java
Patch:
@@ -152,7 +152,9 @@ public void initialize() {
 
                 @Override
                 public Thread newThread(Runnable r) {
-                    return new Thread(r, "HystrixTimer-" + counter.incrementAndGet());
+                    Thread thread = new Thread(r, "HystrixTimer-" + counter.incrementAndGet());
+                    thread.setDaemon(true);
+                    return thread;
                 }
 
             });

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixConcurrencyStrategy.java
Patch:
@@ -76,7 +76,9 @@ public ThreadPoolExecutor getThreadPool(final HystrixThreadPoolKey threadPoolKey
 
             @Override
             public Thread newThread(Runnable r) {
-                return new Thread(r, "hystrix-" + threadPoolKey.name() + "-" + threadNumber.incrementAndGet());
+                Thread thread = new Thread(r, "hystrix-" + threadPoolKey.name() + "-" + threadNumber.incrementAndGet());
+                thread.setDaemon(true);
+                return thread; 
             }
         });
     }

File: hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixTimer.java
Patch:
@@ -152,7 +152,9 @@ public void initialize() {
 
                 @Override
                 public Thread newThread(Runnable r) {
-                    return new Thread(r, "HystrixTimer-" + counter.incrementAndGet());
+                    Thread thread = new Thread(r, "HystrixTimer-" + counter.incrementAndGet());
+                    thread.setDaemon(true);
+                    return thread;
                 }
 
             });

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolProperties.java
Patch:
@@ -161,7 +161,7 @@ public static Setter Setter() {
      * <p>
      * <pre> {@code
      * HystrixThreadPoolProperties.Setter()
-     *           .setCoreSize(10)
+     *           .withCoreSize(10)
      *           .withQueueSizeRejectionThreshold(10);
      * } </pre>
      * 

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolProperties.java
Patch:
@@ -161,7 +161,7 @@ public static Setter Setter() {
      * <p>
      * <pre> {@code
      * HystrixThreadPoolProperties.Setter()
-     *           .setCoreSize(10)
+     *           .withCoreSize(10)
      *           .withQueueSizeRejectionThreshold(10);
      * } </pre>
      * 

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java
Patch:
@@ -857,11 +857,11 @@ private boolean isUnrecoverable(Throwable t) {
             Throwable cause = t.getCause();
             if (cause instanceof StackOverflowError) {
                 return true;
-            } else if (t instanceof VirtualMachineError) {
+            } else if (cause instanceof VirtualMachineError) {
                 return true;
-            } else if (t instanceof ThreadDeath) {
+            } else if (cause instanceof ThreadDeath) {
                 return true;
-            } else if (t instanceof LinkageError) {
+            } else if (cause instanceof LinkageError) {
                 return true;
             }
         }

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java
Patch:
@@ -857,11 +857,11 @@ private boolean isUnrecoverable(Throwable t) {
             Throwable cause = t.getCause();
             if (cause instanceof StackOverflowError) {
                 return true;
-            } else if (t instanceof VirtualMachineError) {
+            } else if (cause instanceof VirtualMachineError) {
                 return true;
-            } else if (t instanceof ThreadDeath) {
+            } else if (cause instanceof ThreadDeath) {
                 return true;
-            } else if (t instanceof LinkageError) {
+            } else if (cause instanceof LinkageError) {
                 return true;
             }
         }

File: hystrix-core/src/test/java/com/netflix/hystrix/AbstractTestHystrixCommand.java
Patch:
@@ -20,7 +20,7 @@
 public interface AbstractTestHystrixCommand<R> extends HystrixObservable<R>, InspectableBuilder {
 
     public static enum ExecutionResult {
-        SUCCESS, FAILURE, ASYNC_FAILURE, HYSTRIX_FAILURE, ASYNC_HYSTRIX_FAILURE, ERROR, ASYNC_ERROR, BAD_REQUEST, ASYNC_BAD_REQUEST, MULTIPLE_EMITS_THEN_SUCCESS, MULTIPLE_EMITS_THEN_FAILURE, NO_EMITS_THEN_SUCCESS
+        SUCCESS, FAILURE, ASYNC_FAILURE, HYSTRIX_FAILURE, ASYNC_HYSTRIX_FAILURE, RECOVERABLE_ERROR, ASYNC_RECOVERABLE_ERROR, UNRECOVERABLE_ERROR, ASYNC_UNRECOVERABLE_ERROR, BAD_REQUEST, ASYNC_BAD_REQUEST, MULTIPLE_EMITS_THEN_SUCCESS, MULTIPLE_EMITS_THEN_FAILURE, NO_EMITS_THEN_SUCCESS
     }
 
     public static enum FallbackResult {

File: hystrix-core/src/test/java/com/netflix/hystrix/AbstractTestHystrixCommand.java
Patch:
@@ -20,7 +20,7 @@
 public interface AbstractTestHystrixCommand<R> extends HystrixObservable<R>, InspectableBuilder {
 
     public static enum ExecutionResult {
-        SUCCESS, FAILURE, ASYNC_FAILURE, HYSTRIX_FAILURE, ASYNC_HYSTRIX_FAILURE, ERROR, ASYNC_ERROR, BAD_REQUEST, ASYNC_BAD_REQUEST, MULTIPLE_EMITS_THEN_SUCCESS, MULTIPLE_EMITS_THEN_FAILURE, NO_EMITS_THEN_SUCCESS
+        SUCCESS, FAILURE, ASYNC_FAILURE, HYSTRIX_FAILURE, ASYNC_HYSTRIX_FAILURE, RECOVERABLE_ERROR, ASYNC_RECOVERABLE_ERROR, UNRECOVERABLE_ERROR, ASYNC_UNRECOVERABLE_ERROR, BAD_REQUEST, ASYNC_BAD_REQUEST, MULTIPLE_EMITS_THEN_SUCCESS, MULTIPLE_EMITS_THEN_FAILURE, NO_EMITS_THEN_SUCCESS
     }
 
     public static enum FallbackResult {

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/collapser/CommandCollapser.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.netflix.hystrix.contrib.javanica.collapser;
 
-import com.google.common.base.Optional;
 import com.netflix.hystrix.HystrixCollapser;
 import com.netflix.hystrix.HystrixCollapserKey;
 import com.netflix.hystrix.HystrixCommand;
@@ -73,7 +72,6 @@ public Object getRequestArgument() {
     protected HystrixCommand<List<Object>> createCommand(
             Collection<CollapsedRequest<Object, Object>> collapsedRequests) {
         BatchHystrixCommand command = BatchHystrixCommandFactory.getInstance().create(metaHolder, collapsedRequests);
-        command.setFallbackEnabled(metaHolder.getHystrixCollapser().fallbackEnabled());
         return command;
     }
 
@@ -118,7 +116,8 @@ public Setter build() {
 
     private String createMessage(Collection<CollapsedRequest<Object, Object>> requests,
                                  List<Object> response) {
-        return ERROR_MSG + arrayFormat(ERROR_MSF_TEMPLATE, new Object[]{getCollapserKey().name(), requests.size(), response.size()}).getMessage();
+        return ERROR_MSG + arrayFormat(ERROR_MSF_TEMPLATE, new Object[]{getCollapserKey().name(),
+                requests.size(), response.size()}).getMessage();
     }
 
 }

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixObservableCommand.java
Patch:
@@ -69,7 +69,7 @@ protected boolean shouldOutputOnNextEvents() {
      * <p>
      * Do not create multiple {@link HystrixObservableCommand} implementations with the same {@link HystrixCommandKey} but different injected default properties as the first instantiated will win.
      * <p>
-     * Properties passed in via {@link Setter#andCommandPropertiesDefaults} or {@link Setter#andThreadPoolPropertiesDefaults} are cached for the given {@link HystrixCommandKey} for the life of the JVM
+     * Properties passed in via {@link Setter#andCommandPropertiesDefaults} are cached for the given {@link HystrixCommandKey} for the life of the JVM
      * or until {@link Hystrix#reset()} is called. Dynamic properties allow runtime changes. Read more on the <a href="https://github.com/Netflix/Hystrix/wiki/Configuration">Hystrix Wiki</a>.
      * 
      * @param setter
@@ -194,14 +194,14 @@ private HystrixCommandProperties.Setter setDefaults(HystrixCommandProperties.Set
     }
 
     /**
-     * Implement this method with code to be executed when {@link #execute()} or {@link #queue()} are invoked.
+     * Implement this method with code to be executed when {@link #observe()} or {@link #toObservable()} are invoked.
      * 
      * @return R response type
      */
     protected abstract Observable<R> construct();
 
     /**
-     * If {@link #execute()} or {@link #queue()} fails in any way then this method will be invoked to provide an opportunity to return a fallback response.
+     * If {@link #observe()} or {@link #toObservable()} fails in any way then this method will be invoked to provide an opportunity to return a fallback response.
      * <p>
      * This should do work that does not require network transport to produce.
      * <p>

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixObservableCommand.java
Patch:
@@ -69,7 +69,7 @@ protected boolean shouldOutputOnNextEvents() {
      * <p>
      * Do not create multiple {@link HystrixObservableCommand} implementations with the same {@link HystrixCommandKey} but different injected default properties as the first instantiated will win.
      * <p>
-     * Properties passed in via {@link Setter#andCommandPropertiesDefaults} or {@link Setter#andThreadPoolPropertiesDefaults} are cached for the given {@link HystrixCommandKey} for the life of the JVM
+     * Properties passed in via {@link Setter#andCommandPropertiesDefaults} are cached for the given {@link HystrixCommandKey} for the life of the JVM
      * or until {@link Hystrix#reset()} is called. Dynamic properties allow runtime changes. Read more on the <a href="https://github.com/Netflix/Hystrix/wiki/Configuration">Hystrix Wiki</a>.
      * 
      * @param setter
@@ -194,14 +194,14 @@ private HystrixCommandProperties.Setter setDefaults(HystrixCommandProperties.Set
     }
 
     /**
-     * Implement this method with code to be executed when {@link #execute()} or {@link #queue()} are invoked.
+     * Implement this method with code to be executed when {@link #observe()} or {@link #toObservable()} are invoked.
      * 
      * @return R response type
      */
     protected abstract Observable<R> construct();
 
     /**
-     * If {@link #execute()} or {@link #queue()} fails in any way then this method will be invoked to provide an opportunity to return a fallback response.
+     * If {@link #observe()} or {@link #toObservable()} fails in any way then this method will be invoked to provide an opportunity to return a fallback response.
      * <p>
      * This should do work that does not require network transport to produce.
      * <p>

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java
Patch:
@@ -519,7 +519,7 @@ public interface CollapsedRequest<ResponseType, RequestArgumentType> {
         /**
          * When set any client thread blocking on get() will immediately be unblocked and receive the exception.
          * 
-         * @param exception
+         * @param exception exception to set on response
          * @throws IllegalStateException
          *             if called more than once or after setResponse.
          */

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapserKey.java
Patch:
@@ -42,7 +42,7 @@ private Factory() {
         /**
          * Retrieve (or create) an interned HystrixCollapserKey instance for a given name.
          * 
-         * @param name
+         * @param name collapser name
          * @return HystrixCollapserKey instance that is interned (cached) so a given name will always retrieve the same instance.
          */
         public static HystrixCollapserKey asKey(String name) {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapserProperties.java
Patch:
@@ -325,7 +325,7 @@ public Setter withMetricsRollingPercentileWindowBuckets(int value) {
          * Return a static representation of the properties with values from the Builder so that UnitTests can create properties that are not affected by the actual implementations which pick up their
          * values dynamically.
          * 
-         * @param builder
+         * @param builder collapser properties builder
          * @return HystrixCollapserProperties
          */
         /* package */static HystrixCollapserProperties asMock(final Setter builder) {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandGroupKey.java
Patch:
@@ -44,7 +44,7 @@ private Factory() {
         /**
          * Retrieve (or create) an interned HystrixCommandGroup instance for a given name.
          * 
-         * @param name
+         * @param name command group name
          * @return HystrixCommandGroup instance that is interned (cached) so a given name will always retrieve the same instance.
          */
         public static HystrixCommandGroupKey asKey(String name) {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandKey.java
Patch:
@@ -42,7 +42,7 @@ private Factory() {
         /**
          * Retrieve (or create) an interned HystrixCommandKey instance for a given name.
          * 
-         * @param name
+         * @param name command name
          * @return HystrixCommandKey instance that is interned (cached) so a given name will always retrieve the same instance.
          */
         public static HystrixCommandKey asKey(String name) {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixObservableCollapser.java
Patch:
@@ -503,7 +503,7 @@ public static Setter withCollapserKey(HystrixCollapserKey collapserKey) {
         /**
          * {@link Scope} defining what scope the collapsing should occur within
          * 
-         * @param scope
+         * @param scope collapser scope
          * 
          * @return Setter for fluent interface via method chaining
          */

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolKey.java
Patch:
@@ -44,7 +44,7 @@ private Factory() {
         /**
          * Retrieve (or create) an interned HystrixThreadPoolKey instance for a given name.
          * 
-         * @param name
+         * @param name thread pool name
          * @return HystrixThreadPoolKey instance that is interned (cached) so a given name will always retrieve the same instance.
          */
         public static HystrixThreadPoolKey asKey(String name) {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolProperties.java
Patch:
@@ -249,7 +249,7 @@ public Setter withMetricsRollingStatisticalWindowBuckets(int value) {
          * Return a static representation of the properties with values from the Builder so that UnitTests can create properties that are not affected by the actual implementations which pick up their
          * values dynamically.
          * 
-         * @param builder
+         * @param builder builder for a {@link HystrixThreadPoolProperties}
          * @return HystrixThreadPoolProperties
          */
         /* package */static HystrixThreadPoolProperties asMock(final Setter builder) {

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/CollapsedRequestObservableFunction.java
Patch:
@@ -59,7 +59,7 @@ public R getArgument() {
      * 
      * @throws IllegalStateException
      *             if called more than once or after setException.
-     * @param response
+     * @param response response to give to initial command
      */
     @Override
     public void setResponse(T response) {
@@ -89,7 +89,7 @@ public void setResponse(T response) {
     /**
      * Set an exception if a response is not yet received otherwise skip it
      * 
-     * @param e
+     * @param e synthetic error to set on initial command when no actual response is available
      */
     public void setExceptionIfResponseNotReceived(Exception e) {
         while (true) {
@@ -139,7 +139,7 @@ public Exception setExceptionIfResponseNotReceived(Exception e, String exception
      * 
      * @throws IllegalStateException
      *             if called more than once or after setResponse.
-     * @param response
+     * @param e received exception that gets set on the initial command
      */
     @Override
     public void setException(Exception e) {

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestBatch.java
Patch:
@@ -103,7 +103,6 @@ public Observable<ResponseType> offer(RequestArgumentType arg) {
      * think a response was never received and will either block indefinitely or will timeout while waiting.</li>
      * </ul>
      * 
-     * @param args
      */
     public void executeBatchIfNotAlreadyStarted() {
         /*

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapserFactory.java
Patch:
@@ -136,7 +136,7 @@ private RequestCollapser<BatchReturnType, ResponseType, RequestArgumentType> get
     /**
      * Lookup (or create and store) the RequestVariable for a given HystrixCollapserKey.
      * 
-     * @param key
+     * @param commandCollapser collapser to retrieve {@link HystrixRequestVariableHolder} for
      * @return HystrixRequestVariableHolder
      */
     @SuppressWarnings("unchecked")
@@ -259,7 +259,7 @@ public static Setter withCollapserKey(HystrixCollapserKey collapserKey) {
         /**
          * {@link Scope} defining what scope the collapsing should occur within
          * 
-         * @param scope
+         * @param scope collapser scope
          * 
          * @return Setter for fluent interface via method chaining
          */

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/eventnotifier/HystrixEventNotifier.java
Patch:
@@ -42,8 +42,8 @@ public abstract class HystrixEventNotifier {
      * <p>
      * <b>Default Implementation: </b> Does nothing
      * 
-     * @param eventType
-     * @param key
+     * @param eventType event type
+     * @param key event key
      */
     public void markEvent(HystrixEventType eventType, HystrixCommandKey key) {
         // do nothing

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/properties/HystrixPropertiesChainedArchaiusProperty.java
Patch:
@@ -70,7 +70,7 @@ public ChainLink() {
         }
 
         /**
-         * @param nextProperty
+         * @param nextProperty next property in the chain
          */
         public ChainLink(ChainLink<T> nextProperty) {
             next = nextProperty;
@@ -110,7 +110,7 @@ public T get() {
         }
 
         /**
-         * @param r
+         * @param r callback to execut
          */
         public void addCallback(Runnable r) {
             callbacks.add(r);

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/properties/HystrixProperty.java
Patch:
@@ -130,7 +130,7 @@ public T get() {
         /**
          * When retrieved this will iterate over the contained {@link HystrixProperty} instances until a non-null value is found and return that.
          * 
-         * @param values
+         * @param values properties to iterate over
          * @return first non-null value or null if none found
          */
         @SafeVarargs

File: hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixRollingNumber.java
Patch:
@@ -114,8 +114,8 @@ public void add(HystrixRollingNumberEvent type, long value) {
      * <p>
      * The {@link HystrixRollingNumberEvent} must be a "max updater" type <code>HystrixRollingNumberEvent.isMaxUpdater() == true</code>.
      * 
-     * @param type
-     * @param value
+     * @param type  HystrixRollingNumberEvent defining which counter to retrieve values from
+     * @param value long value to be given to the max updater
      */
     public void updateRollingMax(HystrixRollingNumberEvent type, long value) {
         getCurrentBucket().getMaxUpdater(type).update(value);
@@ -144,7 +144,7 @@ public void reset() {
      * <p>
      * The {@link HystrixRollingNumberEvent} must be a "counter" type <code>HystrixRollingNumberEvent.isCounter() == true</code>.
      * 
-     * @param type
+     * @param type HystrixRollingNumberEvent defining which counter to retrieve values from
      * @return cumulative sum of all increments and adds for the given {@link HystrixRollingNumberEvent} counter type
      */
     public long getCumulativeSum(HystrixRollingNumberEvent type) {

File: hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixRollingPercentile.java
Patch:
@@ -379,8 +379,8 @@ public int getPercentile(double percentile) {
          * @see <a href="http://en.wikipedia.org/wiki/Percentile">Percentile (Wikipedia)</a>
          * @see <a href="http://cnx.org/content/m10805/latest/">Percentile</a>
          * 
-         * @param percent
-         * @return
+         * @param percent percentile of data desired
+         * @return data at the asked-for percentile.  Interpolation is used if exactness is not possible
          */
         private int computePercentile(double percent) {
             // Some just-in-case edge cases

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCollapserTest.java
Patch:
@@ -1224,7 +1224,7 @@ public void clear() {
          * <p>
          * This is because executing multiple times in a tight-loop would not achieve the correct behavior, such as batching, since it will all execute "now" not after intervals of time.
          * 
-         * @param timeInMilliseconds
+         * @param timeInMilliseconds amount of time to increment
          */
         public synchronized void incrementTime(int timeInMilliseconds) {
             for (ATask t : tasks) {

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandPropertiesTest.java
Patch:
@@ -59,7 +59,7 @@ public class HystrixCommandPropertiesTest {
      * Return a static representation of the properties with values from the Builder so that UnitTests can create properties that are not affected by the actual implementations which pick up their
      * values dynamically.
      * 
-     * @param builder
+     * @param builder command properties builder
      * @return HystrixCommandProperties
      */
     /* package */static HystrixCommandProperties asMock(final Setter builder) {

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixObservableCommandTest.java
Patch:
@@ -6503,8 +6503,8 @@ private static class LatchedSemaphoreCommand extends TestHystrixObservableComman
 
         /**
          * 
-         * @param circuitBreaker
-         * @param semaphore
+         * @param circuitBreaker circuit breaker (passed in so it may be shared)
+         * @param semaphore semaphore (passed in so it may be shared)
          * @param startLatch
          *            this command calls {@link CountDownLatch#countDown()} immediately
          *            upon running

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java
Patch:
@@ -519,7 +519,7 @@ public interface CollapsedRequest<ResponseType, RequestArgumentType> {
         /**
          * When set any client thread blocking on get() will immediately be unblocked and receive the exception.
          * 
-         * @param exception
+         * @param exception exception to set on response
          * @throws IllegalStateException
          *             if called more than once or after setResponse.
          */

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapserKey.java
Patch:
@@ -42,7 +42,7 @@ private Factory() {
         /**
          * Retrieve (or create) an interned HystrixCollapserKey instance for a given name.
          * 
-         * @param name
+         * @param name collapser name
          * @return HystrixCollapserKey instance that is interned (cached) so a given name will always retrieve the same instance.
          */
         public static HystrixCollapserKey asKey(String name) {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapserProperties.java
Patch:
@@ -325,7 +325,7 @@ public Setter withMetricsRollingPercentileWindowBuckets(int value) {
          * Return a static representation of the properties with values from the Builder so that UnitTests can create properties that are not affected by the actual implementations which pick up their
          * values dynamically.
          * 
-         * @param builder
+         * @param builder collapser properties builder
          * @return HystrixCollapserProperties
          */
         /* package */static HystrixCollapserProperties asMock(final Setter builder) {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandGroupKey.java
Patch:
@@ -44,7 +44,7 @@ private Factory() {
         /**
          * Retrieve (or create) an interned HystrixCommandGroup instance for a given name.
          * 
-         * @param name
+         * @param name command group name
          * @return HystrixCommandGroup instance that is interned (cached) so a given name will always retrieve the same instance.
          */
         public static HystrixCommandGroupKey asKey(String name) {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandKey.java
Patch:
@@ -42,7 +42,7 @@ private Factory() {
         /**
          * Retrieve (or create) an interned HystrixCommandKey instance for a given name.
          * 
-         * @param name
+         * @param name command name
          * @return HystrixCommandKey instance that is interned (cached) so a given name will always retrieve the same instance.
          */
         public static HystrixCommandKey asKey(String name) {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixObservableCollapser.java
Patch:
@@ -503,7 +503,7 @@ public static Setter withCollapserKey(HystrixCollapserKey collapserKey) {
         /**
          * {@link Scope} defining what scope the collapsing should occur within
          * 
-         * @param scope
+         * @param scope collapser scope
          * 
          * @return Setter for fluent interface via method chaining
          */

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolKey.java
Patch:
@@ -44,7 +44,7 @@ private Factory() {
         /**
          * Retrieve (or create) an interned HystrixThreadPoolKey instance for a given name.
          * 
-         * @param name
+         * @param name thread pool name
          * @return HystrixThreadPoolKey instance that is interned (cached) so a given name will always retrieve the same instance.
          */
         public static HystrixThreadPoolKey asKey(String name) {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolProperties.java
Patch:
@@ -249,7 +249,7 @@ public Setter withMetricsRollingStatisticalWindowBuckets(int value) {
          * Return a static representation of the properties with values from the Builder so that UnitTests can create properties that are not affected by the actual implementations which pick up their
          * values dynamically.
          * 
-         * @param builder
+         * @param builder builder for a {@link HystrixThreadPoolProperties}
          * @return HystrixThreadPoolProperties
          */
         /* package */static HystrixThreadPoolProperties asMock(final Setter builder) {

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/CollapsedRequestObservableFunction.java
Patch:
@@ -59,7 +59,7 @@ public R getArgument() {
      * 
      * @throws IllegalStateException
      *             if called more than once or after setException.
-     * @param response
+     * @param response response to give to initial command
      */
     @Override
     public void setResponse(T response) {
@@ -89,7 +89,7 @@ public void setResponse(T response) {
     /**
      * Set an exception if a response is not yet received otherwise skip it
      * 
-     * @param e
+     * @param e synthetic error to set on initial command when no actual response is available
      */
     public void setExceptionIfResponseNotReceived(Exception e) {
         while (true) {
@@ -139,7 +139,7 @@ public Exception setExceptionIfResponseNotReceived(Exception e, String exception
      * 
      * @throws IllegalStateException
      *             if called more than once or after setResponse.
-     * @param response
+     * @param e received exception that gets set on the initial command
      */
     @Override
     public void setException(Exception e) {

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestBatch.java
Patch:
@@ -103,7 +103,6 @@ public Observable<ResponseType> offer(RequestArgumentType arg) {
      * think a response was never received and will either block indefinitely or will timeout while waiting.</li>
      * </ul>
      * 
-     * @param args
      */
     public void executeBatchIfNotAlreadyStarted() {
         /*

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapserFactory.java
Patch:
@@ -136,7 +136,7 @@ private RequestCollapser<BatchReturnType, ResponseType, RequestArgumentType> get
     /**
      * Lookup (or create and store) the RequestVariable for a given HystrixCollapserKey.
      * 
-     * @param key
+     * @param commandCollapser collapser to retrieve {@link HystrixRequestVariableHolder} for
      * @return HystrixRequestVariableHolder
      */
     @SuppressWarnings("unchecked")
@@ -259,7 +259,7 @@ public static Setter withCollapserKey(HystrixCollapserKey collapserKey) {
         /**
          * {@link Scope} defining what scope the collapsing should occur within
          * 
-         * @param scope
+         * @param scope collapser scope
          * 
          * @return Setter for fluent interface via method chaining
          */

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/eventnotifier/HystrixEventNotifier.java
Patch:
@@ -42,8 +42,8 @@ public abstract class HystrixEventNotifier {
      * <p>
      * <b>Default Implementation: </b> Does nothing
      * 
-     * @param eventType
-     * @param key
+     * @param eventType event type
+     * @param key event key
      */
     public void markEvent(HystrixEventType eventType, HystrixCommandKey key) {
         // do nothing

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/properties/HystrixPropertiesChainedArchaiusProperty.java
Patch:
@@ -70,7 +70,7 @@ public ChainLink() {
         }
 
         /**
-         * @param nextProperty
+         * @param nextProperty next property in the chain
          */
         public ChainLink(ChainLink<T> nextProperty) {
             next = nextProperty;
@@ -110,7 +110,7 @@ public T get() {
         }
 
         /**
-         * @param r
+         * @param r callback to execut
          */
         public void addCallback(Runnable r) {
             callbacks.add(r);

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/properties/HystrixProperty.java
Patch:
@@ -130,7 +130,7 @@ public T get() {
         /**
          * When retrieved this will iterate over the contained {@link HystrixProperty} instances until a non-null value is found and return that.
          * 
-         * @param values
+         * @param values properties to iterate over
          * @return first non-null value or null if none found
          */
         @SafeVarargs

File: hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixRollingNumber.java
Patch:
@@ -114,8 +114,8 @@ public void add(HystrixRollingNumberEvent type, long value) {
      * <p>
      * The {@link HystrixRollingNumberEvent} must be a "max updater" type <code>HystrixRollingNumberEvent.isMaxUpdater() == true</code>.
      * 
-     * @param type
-     * @param value
+     * @param type  HystrixRollingNumberEvent defining which counter to retrieve values from
+     * @param value long value to be given to the max updater
      */
     public void updateRollingMax(HystrixRollingNumberEvent type, long value) {
         getCurrentBucket().getMaxUpdater(type).update(value);
@@ -144,7 +144,7 @@ public void reset() {
      * <p>
      * The {@link HystrixRollingNumberEvent} must be a "counter" type <code>HystrixRollingNumberEvent.isCounter() == true</code>.
      * 
-     * @param type
+     * @param type HystrixRollingNumberEvent defining which counter to retrieve values from
      * @return cumulative sum of all increments and adds for the given {@link HystrixRollingNumberEvent} counter type
      */
     public long getCumulativeSum(HystrixRollingNumberEvent type) {

File: hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixRollingPercentile.java
Patch:
@@ -379,8 +379,8 @@ public int getPercentile(double percentile) {
          * @see <a href="http://en.wikipedia.org/wiki/Percentile">Percentile (Wikipedia)</a>
          * @see <a href="http://cnx.org/content/m10805/latest/">Percentile</a>
          * 
-         * @param percent
-         * @return
+         * @param percent percentile of data desired
+         * @return data at the asked-for percentile.  Interpolation is used if exactness is not possible
          */
         private int computePercentile(double percent) {
             // Some just-in-case edge cases

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCollapserTest.java
Patch:
@@ -1224,7 +1224,7 @@ public void clear() {
          * <p>
          * This is because executing multiple times in a tight-loop would not achieve the correct behavior, such as batching, since it will all execute "now" not after intervals of time.
          * 
-         * @param timeInMilliseconds
+         * @param timeInMilliseconds amount of time to increment
          */
         public synchronized void incrementTime(int timeInMilliseconds) {
             for (ATask t : tasks) {

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandPropertiesTest.java
Patch:
@@ -59,7 +59,7 @@ public class HystrixCommandPropertiesTest {
      * Return a static representation of the properties with values from the Builder so that UnitTests can create properties that are not affected by the actual implementations which pick up their
      * values dynamically.
      * 
-     * @param builder
+     * @param builder command properties builder
      * @return HystrixCommandProperties
      */
     /* package */static HystrixCommandProperties asMock(final Setter builder) {

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixObservableCommandTest.java
Patch:
@@ -6503,8 +6503,8 @@ private static class LatchedSemaphoreCommand extends TestHystrixObservableComman
 
         /**
          * 
-         * @param circuitBreaker
-         * @param semaphore
+         * @param circuitBreaker circuit breaker (passed in so it may be shared)
+         * @param semaphore semaphore (passed in so it may be shared)
          * @param startLatch
          *            this command calls {@link CountDownLatch#countDown()} immediately
          *            upon running

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java
Patch:
@@ -370,6 +370,7 @@ final public Observable<R> toObservable() {
             public void call(Subscriber<? super R> observer) {
                 // async record keeping
                 recordExecutedCommand();
+                metrics.incrementConcurrentExecutionCount();
 
                 // mark that we're starting execution on the ExecutionHook
                 executionHook.onStart(_this);
@@ -497,8 +498,6 @@ public void call() {
      */
     private Observable<R> getRunObservableDecoratedForMetricsAndErrorHandling() {
         final AbstractCommand<R> _self = this;
-        // allow tracking how many concurrent commands are executing
-        metrics.incrementConcurrentExecutionCount();
 
         final HystrixRequestContext currentRequestContext = HystrixRequestContext.getContextForCurrentThread();
 

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixObservableCommandTest.java
Patch:
@@ -607,8 +607,8 @@ private void testObserveFailureWithTimeoutAndFallback(ExecutionIsolationStrategy
 
         System.out.println("Command time : " + command.getExecutionTimeInMilliseconds());
         System.out.println("Observed command time : " + observedCommandDuration);
-        assertTrue(command.getExecutionTimeInMilliseconds() > 200);
-        assertTrue(observedCommandDuration > 200);
+        assertTrue(command.getExecutionTimeInMilliseconds() >= 200);
+        assertTrue(observedCommandDuration >= 200);
         assertTrue(command.getExecutionTimeInMilliseconds() < 1000);
         assertTrue(observedCommandDuration < 1000);
         assertFalse(command.isFailedExecution());

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -367,8 +367,6 @@ final public Future<R> queue() {
          * We use the 'immediate' schedule since Future.get() is blocking so we don't want to bother doing the callback to the Future on a separate thread
          * as we don't need to separate the Hystrix thread from user threads since they are already providing it via the Future.get() call.
          * 
-         * --- performAsyncTimeout: false
-         * 
          * We pass 'false' to tell the Observable we will block on it so it doesn't schedule an async timeout.
          * 
          * This optimizes for using the calling thread to do the timeout rather than scheduling another thread.

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -367,8 +367,6 @@ final public Future<R> queue() {
          * We use the 'immediate' schedule since Future.get() is blocking so we don't want to bother doing the callback to the Future on a separate thread
          * as we don't need to separate the Hystrix thread from user threads since they are already providing it via the Future.get() call.
          * 
-         * --- performAsyncTimeout: false
-         * 
          * We pass 'false' to tell the Observable we will block on it so it doesn't schedule an async timeout.
          * 
          * This optimizes for using the calling thread to do the timeout rather than scheduling another thread.

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixEventType.java
Patch:
@@ -21,5 +21,5 @@
  * These are most often accessed via {@link HystrixRequestLog} or {@link HystrixCommand#getExecutionEvents()}.
  */
 public enum HystrixEventType {
-    SUCCESS, FAILURE, TIMEOUT, SHORT_CIRCUITED, THREAD_POOL_REJECTED, SEMAPHORE_REJECTED, FALLBACK_SUCCESS, FALLBACK_FAILURE, FALLBACK_REJECTION, EXCEPTION_THROWN, RESPONSE_FROM_CACHE, COLLAPSED, BAD_REQUEST
+    EMIT, SUCCESS, FAILURE, TIMEOUT, SHORT_CIRCUITED, THREAD_POOL_REJECTED, SEMAPHORE_REJECTED, FALLBACK_EMIT, FALLBACK_SUCCESS, FALLBACK_FAILURE, FALLBACK_REJECTION, EXCEPTION_THROWN, RESPONSE_FROM_CACHE, COLLAPSED, BAD_REQUEST
 }
\ No newline at end of file

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixEventType.java
Patch:
@@ -21,5 +21,5 @@
  * These are most often accessed via {@link HystrixRequestLog} or {@link HystrixCommand#getExecutionEvents()}.
  */
 public enum HystrixEventType {
-    SUCCESS, FAILURE, TIMEOUT, SHORT_CIRCUITED, THREAD_POOL_REJECTED, SEMAPHORE_REJECTED, FALLBACK_SUCCESS, FALLBACK_FAILURE, FALLBACK_REJECTION, EXCEPTION_THROWN, RESPONSE_FROM_CACHE, COLLAPSED, BAD_REQUEST
+    EMIT, SUCCESS, FAILURE, TIMEOUT, SHORT_CIRCUITED, THREAD_POOL_REJECTED, SEMAPHORE_REJECTED, FALLBACK_EMIT, FALLBACK_SUCCESS, FALLBACK_FAILURE, FALLBACK_REJECTION, EXCEPTION_THROWN, RESPONSE_FROM_CACHE, COLLAPSED, BAD_REQUEST
 }
\ No newline at end of file

File: hystrix-core/src/main/java/com/netflix/hystrix/Hystrix.java
Patch:
@@ -5,7 +5,6 @@
 import java.util.concurrent.TimeUnit;
 
 import com.netflix.hystrix.strategy.HystrixPlugins;
-import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisherFactory;
 import com.netflix.hystrix.strategy.properties.HystrixPropertiesFactory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java
Patch:
@@ -20,7 +20,6 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Future;
 
-import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisherCollapser;
 import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisherFactory;
 import com.netflix.hystrix.strategy.properties.HystrixPropertiesFactory;
 import org.slf4j.Logger;
@@ -379,7 +378,7 @@ public Observable<ResponseType> toObservable() {
     public Observable<ResponseType> toObservable(Scheduler observeOn) {
 
         /* try from cache first */
-        if (getProperties().requestCachingEnabled().get()) {
+        if (getProperties().requestCacheEnabled().get()) {
             Observable<ResponseType> fromCache = requestCache.get(getCacheKey());
             if (fromCache != null) {
                 metrics.markResponseFromCache();
@@ -390,7 +389,7 @@ public Observable<ResponseType> toObservable(Scheduler observeOn) {
         RequestCollapser<BatchReturnType, ResponseType, RequestArgumentType> requestCollapser = collapserFactory.getRequestCollapser(collapserInstanceWrapper);
         Observable<ResponseType> response = requestCollapser.submitRequest(getRequestArgument());
         metrics.markRequestBatched();
-        if (getProperties().requestCachingEnabled().get()) {
+        if (getProperties().requestCacheEnabled().get()) {
             /*
              * A race can occur here with multiple threads queuing but only one will be cached.
              * This means we can have some duplication of requests in a thread-race but we're okay

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapserProperties.java
Patch:
@@ -350,7 +350,7 @@ public HystrixProperty<Integer> timerDelayInMilliseconds() {
         }
 
         private static enum TestHystrixCollapserKey implements HystrixCollapserKey {
-            TEST;
+            TEST
         }
     }
 

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixObservableCollapser.java
Patch:
@@ -370,7 +370,7 @@ public Observable<ResponseType> toObservable() {
     public Observable<ResponseType> toObservable(Scheduler observeOn) {
 
         /* try from cache first */
-        if (getProperties().requestCachingEnabled().get()) {
+        if (getProperties().requestCacheEnabled().get()) {
             Observable<ResponseType> fromCache = requestCache.get(getCacheKey());
             if (fromCache != null) {
                 /* mark that we received this response from cache */
@@ -384,7 +384,7 @@ public Observable<ResponseType> toObservable(Scheduler observeOn) {
 
         RequestCollapser<BatchReturnType, ResponseType, RequestArgumentType> requestCollapser = collapserFactory.getRequestCollapser(collapserInstanceWrapper);
         Observable<ResponseType> response = requestCollapser.submitRequest(getRequestArgument());
-        if (getProperties().requestCachingEnabled().get()) {
+        if (getProperties().requestCacheEnabled().get()) {
             /*
              * A race can occur here with multiple threads queuing but only one will be cached.
              * This means we can have some duplication of requests in a thread-race but we're okay

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixRequestCache.java
Patch:
@@ -57,7 +57,7 @@ public ConcurrentHashMap<ValueCacheKey, Observable<?>> initialValue() {
         @Override
         public void shutdown(ConcurrentHashMap<ValueCacheKey, Observable<?>> value) {
             // nothing to shutdown
-        };
+        }
 
     });
 

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixRequestLog.java
Patch:
@@ -58,7 +58,7 @@ public HystrixRequestLog initialValue() {
 
         public void shutdown(HystrixRequestLog value) {
             // nothing to shutdown
-        };
+        }
 
     });
 

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolProperties.java
Patch:
@@ -290,7 +290,7 @@ public HystrixProperty<Integer> metricsRollingStatisticalWindowBuckets() {
         }
 
         private static enum TestThreadPoolKey implements HystrixThreadPoolKey {
-            TEST;
+            TEST
         }
     }
 }

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestBatch.java
Patch:
@@ -115,7 +115,7 @@ public void executeBatchIfNotAlreadyStarted() {
                             @Override
                             public void call(Throwable e) {
                                 // handle Throwable in case anything is thrown so we don't block Observers waiting for onError/onCompleted
-                                Exception ee = null;
+                                Exception ee;
                                 if (e instanceof Exception) {
                                     ee = (Exception) e;
                                 } else {

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapserFactory.java
Patch:
@@ -2,8 +2,6 @@
 
 import java.util.concurrent.ConcurrentHashMap;
 
-import com.netflix.hystrix.HystrixCollapserMetrics;
-import com.netflix.hystrix.HystrixCommandMetrics;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixConcurrencyStrategy.java
Patch:
@@ -147,7 +147,7 @@ public T initialValue() {
 
             public void shutdown(T value) {
                 rv.shutdown(value);
-            };
+            }
         };
     }
     

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixRequestContext.java
Patch:
@@ -141,5 +141,5 @@ public void shutdown() {
             // being held in ThreadLocals on threads that weren't cleaned up
             state = null;
         }
-    };
+    }
 }
\ No newline at end of file

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCircuitBreakerTest.java
Patch:
@@ -490,15 +490,15 @@ private static HystrixCircuitBreaker getCircuitBreaker(HystrixCommandKey key, Hy
     }
 
     private static enum CommandOwnerForUnitTest implements HystrixCommandGroupKey {
-        OWNER_ONE, OWNER_TWO;
+        OWNER_ONE, OWNER_TWO
     }
 
     private static enum ThreadPoolKeyForUnitTest implements HystrixThreadPoolKey {
-        THREAD_POOL_ONE, THREAD_POOL_TWO;
+        THREAD_POOL_ONE, THREAD_POOL_TWO
     }
 
     private static enum CommandKeyForUnitTest implements HystrixCommandKey {
-        KEY_ONE, KEY_TWO;
+        KEY_ONE, KEY_TWO
     }
 
     // ignoring since this never ends ... useful for testing https://github.com/Netflix/Hystrix/issues/236

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandPropertiesTest.java
Patch:
@@ -166,7 +166,7 @@ public HystrixProperty<Boolean> requestLogEnabled() {
     // NOTE: We use "unitTestPrefix" as a prefix so we can't end up pulling in external properties that change unit test behavior
 
     public enum TestKey implements HystrixCommandKey {
-        TEST;
+        TEST
     }
 
     private static class TestPropertiesCommand extends HystrixCommandProperties {

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixObservableCollapserTest.java
Patch:
@@ -209,7 +209,7 @@ public void call(Subscriber<? super String> s) {
                         if (request.getArgument() == null) {
                             throw new NullPointerException("Simulated Error");
                         }
-                        if (request.getArgument() == "TIMEOUT") {
+                        if (request.getArgument().equals("TIMEOUT")) {
                             try {
                                 Thread.sleep(200);
                             } catch (InterruptedException e) {

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixThreadPoolMetricsTest.java
Patch:
@@ -1,6 +1,5 @@
 package com.netflix.hystrix;
 
-import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixThreadPoolTest.java
Patch:
@@ -8,10 +8,8 @@
 
 import com.netflix.hystrix.HystrixThreadPool.Factory;
 import com.netflix.hystrix.strategy.HystrixPlugins;
-import com.netflix.hystrix.strategy.HystrixPluginsTest;
 import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisher;
 import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisherFactory;
-import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisherFactoryTest;
 import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisherThreadPool;
 import org.junit.Before;
 import org.junit.Test;

File: hystrix-core/src/test/java/com/netflix/hystrix/strategy/metrics/HystrixMetricsPublisherFactoryTest.java
Patch:
@@ -121,11 +121,11 @@ public void initialize() {
     }
 
     private static enum TestCommandKey implements HystrixCommandKey {
-        TEST_A, TEST_B;
+        TEST_A, TEST_B
     }
 
     private static enum TestThreadPoolKey implements HystrixThreadPoolKey {
-        TEST_A, TEST_B;
+        TEST_A, TEST_B
     }
 
     static class CustomPublisher extends HystrixMetricsPublisher{

File: hystrix-core/src/test/java/com/netflix/hystrix/util/HystrixRollingPercentileTest.java
Patch:
@@ -183,8 +183,7 @@ public void testSampleDataOverTime2() {
     }
 
     public PercentileSnapshot getPercentileForValues(int... values) {
-        PercentileSnapshot p = new PercentileSnapshot(values);
-        return p;
+        return new PercentileSnapshot(values);
     }
 
     @Test

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java
Patch:
@@ -479,7 +479,7 @@ public void call() {
                 o = new CachedObservableResponse<>((CachedObservableOriginal<R>) fromCache, this);
             }
             // we just created an ObservableCommand so we cast and return it
-            return (ObservableCommand<R>) o;
+            return o;
         } else {
             // no request caching so a simple wrapper just to pass 'this' along with the Observable
             return new ObservableCommand<>(o, this);
@@ -604,7 +604,7 @@ public Observable<R> call(Throwable t) {
                         Exception decorated = executionHook.onError(_self, FailureType.BAD_REQUEST_EXCEPTION, (Exception) t);
 
                         if (decorated instanceof HystrixBadRequestException) {
-                            t = (HystrixBadRequestException) decorated;
+                            t = decorated;
                         } else {
                             logger.warn("ExecutionHook.onError returned an exception that was not an instance of HystrixBadRequestException so will be ignored.", decorated);
                         }
@@ -744,7 +744,7 @@ public Observable<R> call(Throwable t) {
                     Exception decorated = executionHook.onFallbackError(_cmd, e);
 
                     if (decorated instanceof RuntimeException) {
-                        e = (RuntimeException) decorated;
+                        e = decorated;
                     } else {
                         logger.warn("ExecutionHook.onFallbackError returned an exception that was not an instance of RuntimeException so will be ignored.", decorated);
                     }

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCollapserTest.java
Patch:
@@ -1096,7 +1096,7 @@ protected List<String> run() {
                 if (request.getArgument() == null) {
                     throw new NullPointerException("Simulated Error");
                 }
-                if (request.getArgument() == "TIMEOUT") {
+                if (request.getArgument().equals("TIMEOUT")) {
                     try {
                         Thread.sleep(200);
                     } catch (InterruptedException e) {

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixObservableCollapserTest.java
Patch:
@@ -209,7 +209,7 @@ public void call(Subscriber<? super String> s) {
                         if (request.getArgument() == null) {
                             throw new NullPointerException("Simulated Error");
                         }
-                        if (request.getArgument() == "TIMEOUT") {
+                        if (request.getArgument().equals("TIMEOUT")) {
                             try {
                                 Thread.sleep(200);
                             } catch (InterruptedException e) {

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java
Patch:
@@ -3149,10 +3149,10 @@ public void testCacheKeyExecutionRequiresRequestVariable() {
             TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
 
             SuccessfulCacheableCommand command = new SuccessfulCacheableCommand(circuitBreaker, true, "one");
-            assertEquals(true, command.execute());
+            assertEquals("one", command.execute());
 
             SuccessfulCacheableCommand command2 = new SuccessfulCacheableCommand(circuitBreaker, true, "two");
-            assertEquals(true, command2.queue().get());
+            assertEquals("two", command2.queue().get());
 
             fail("We expect an exception because cacheKey requires RequestVariable.");
 

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixObservableCommandTest.java
Patch:
@@ -2738,10 +2738,10 @@ public void testCacheKeyExecutionRequiresRequestVariable() {
             TestCircuitBreaker circuitBreaker = new TestCircuitBreaker();
 
             SuccessfulCacheableCommand command = new SuccessfulCacheableCommand(circuitBreaker, true, "one");
-            assertEquals(true, command.observe().toBlocking().single());
+            assertEquals("one", command.observe().toBlocking().single());
 
             SuccessfulCacheableCommand command2 = new SuccessfulCacheableCommand(circuitBreaker, true, "two");
-            assertEquals(true, command2.observe().toBlocking().toFuture().get());
+            assertEquals("two", command2.observe().toBlocking().toFuture().get());
 
             fail("We expect an exception because cacheKey requires RequestVariable.");
 

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java
Patch:
@@ -378,7 +378,7 @@ public Observable<ResponseType> toObservable() {
     public Observable<ResponseType> toObservable(Scheduler observeOn) {
 
         /* try from cache first */
-        if (getProperties().requestCachingEnabled().get()) {
+        if (getProperties().requestCacheEnabled().get()) {
             Observable<ResponseType> fromCache = requestCache.get(getCacheKey());
             if (fromCache != null) {
                 metrics.markResponseFromCache();
@@ -389,7 +389,7 @@ public Observable<ResponseType> toObservable(Scheduler observeOn) {
         RequestCollapser<BatchReturnType, ResponseType, RequestArgumentType> requestCollapser = collapserFactory.getRequestCollapser(collapserInstanceWrapper);
         Observable<ResponseType> response = requestCollapser.submitRequest(getRequestArgument());
         metrics.markRequestBatched();
-        if (getProperties().requestCachingEnabled().get()) {
+        if (getProperties().requestCacheEnabled().get()) {
             /*
              * A race can occur here with multiple threads queuing but only one will be cached.
              * This means we can have some duplication of requests in a thread-race but we're okay

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixObservableCollapser.java
Patch:
@@ -370,7 +370,7 @@ public Observable<ResponseType> toObservable() {
     public Observable<ResponseType> toObservable(Scheduler observeOn) {
 
         /* try from cache first */
-        if (getProperties().requestCachingEnabled().get()) {
+        if (getProperties().requestCacheEnabled().get()) {
             Observable<ResponseType> fromCache = requestCache.get(getCacheKey());
             if (fromCache != null) {
                 /* mark that we received this response from cache */
@@ -384,7 +384,7 @@ public Observable<ResponseType> toObservable(Scheduler observeOn) {
 
         RequestCollapser<BatchReturnType, ResponseType, RequestArgumentType> requestCollapser = collapserFactory.getRequestCollapser(collapserInstanceWrapper);
         Observable<ResponseType> response = requestCollapser.submitRequest(getRequestArgument());
-        if (getProperties().requestCachingEnabled().get()) {
+        if (getProperties().requestCacheEnabled().get()) {
             /*
              * A race can occur here with multiple threads queuing but only one will be cached.
              * This means we can have some duplication of requests in a thread-race but we're okay

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java
Patch:
@@ -343,7 +343,7 @@ final public Observable<R> observe() {
      *             if invoked more than once
      */
     final public Observable<R> toObservable() {
-         /* this is a stateful object so can only be used once */
+        /* this is a stateful object so can only be used once */
         if (!started.compareAndSet(false, true)) {
             throw new IllegalStateException("This instance can only be executed once. Please instantiate a new instance.");
         }

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/cache/CacheInvocationContextFactory.java
Patch:
@@ -44,7 +44,7 @@ public static CacheInvocationContext<CacheResult> createCacheResultInvocationCon
             Method method = metaHolder.getMethod();
             CacheResult cacheResult = method.getAnnotation(CacheResult.class);
             MethodExecutionAction cacheKeyMethod = createCacheKeyAction(cacheResult.cacheKeyMethod(), metaHolder);
-            return new CacheInvocationContext<CacheResult>(cacheResult, cacheKeyMethod, metaHolder.getObj(), method, metaHolder.getArgs());
+            return new CacheInvocationContext<>(cacheResult, cacheKeyMethod, metaHolder.getObj(), method, metaHolder.getArgs());
         }
         return null;
     }
@@ -60,7 +60,7 @@ public static CacheInvocationContext<CacheRemove> createCacheRemoveInvocationCon
             Method method = metaHolder.getMethod();
             CacheRemove cacheRemove = method.getAnnotation(CacheRemove.class);
             MethodExecutionAction cacheKeyMethod = createCacheKeyAction(cacheRemove.cacheKeyMethod(), metaHolder);
-            return new CacheInvocationContext<CacheRemove>(cacheRemove, cacheKeyMethod, metaHolder.getObj(), method, metaHolder.getArgs());
+            return new CacheInvocationContext<>(cacheRemove, cacheKeyMethod, metaHolder.getObj(), method, metaHolder.getArgs());
         }
         return null;
     }

File: hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/test/spring/cache/CacheTest.java
Patch:
@@ -257,7 +257,7 @@ public void testGetUserByName_givenNonexistentCacheKeyMethod_shouldThrowExceptio
     }
 
     public static class UserService {
-        private Map<String, User> storage = new ConcurrentHashMap<String, User>();
+        private Map<String, User> storage = new ConcurrentHashMap<>();
 
         @PostConstruct
         private void init() {

File: hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/test/spring/error/ErrorPropagationTest.java
Patch:
@@ -38,7 +38,7 @@ public class ErrorPropagationTest {
     private static final Map<String, User> USERS;
 
     static {
-        USERS = new HashMap<String, User>();
+        USERS = new HashMap<>();
         USERS.put("1", new User("1", "user_1"));
         USERS.put("2", new User("2", "user_2"));
         USERS.put("3", new User("3", "user_3"));

File: hystrix-contrib/hystrix-metrics-event-stream/src/main/java/com/netflix/hystrix/contrib/metrics/eventstream/HystrixMetricsStreamServlet.java
Patch:
@@ -203,7 +203,7 @@ private static class MetricJsonListener implements HystrixMetricsPoller.MetricsA
          * <p>
          * This is a safety check against a runaway poller causing memory leaks.
          */
-        private final LinkedBlockingQueue<String> jsonMetrics = new LinkedBlockingQueue<String>(1000);
+        private final LinkedBlockingQueue<String> jsonMetrics = new LinkedBlockingQueue<>(1000);
 
         /**
          * Store JSON messages in a queue.
@@ -219,7 +219,7 @@ public void handleJsonMetric(String json) {
          * @return
          */
         public List<String> getJsonMetrics() {
-            ArrayList<String> metrics = new ArrayList<String>();
+            ArrayList<String> metrics = new ArrayList<>();
             jsonMetrics.drainTo(metrics);
             return metrics;
         }

File: hystrix-contrib/hystrix-rx-netty-metrics-stream/src/test/java/com/netflix/hystrix/contrib/rxnetty/metricsstream/HystrixMetricsStreamHandlerTest.java
Patch:
@@ -100,7 +100,7 @@ private HttpServer<ByteBuf, ByteBuf> createServer() {
         for (int i = 0; i < 3 && server == null; i++) {
             port = 10000 + random.nextInt(50000);
             try {
-                return RxNetty.newHttpServerBuilder(port, new HystrixMetricsStreamHandler<ByteBuf, ByteBuf>(
+                return RxNetty.newHttpServerBuilder(port, new HystrixMetricsStreamHandler<>(
                         DEFAULT_HYSTRIX_PREFIX,
                         DEFAULT_INTERVAL,
                         new RequestHandler<ByteBuf, ByteBuf>() {  // Application handler

File: hystrix-contrib/hystrix-servo-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/servopublisher/HystrixServoMetricsPublisherCollapser.java
Patch:
@@ -111,7 +111,7 @@ protected Tag getServoInstanceTag() {
      */
     private List<Monitor<?>> getServoMonitors() {
 
-        List<Monitor<?>> monitors = new ArrayList<Monitor<?>>();
+        List<Monitor<?>> monitors = new ArrayList<>();
 
         monitors.add(new InformationalMetric<String>(MonitorConfig.builder("name").build()) {
             @Override

File: hystrix-contrib/hystrix-servo-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/servopublisher/HystrixServoMetricsPublisherCommand.java
Patch:
@@ -116,7 +116,7 @@ protected Tag getServoInstanceTag() {
      */
     private List<Monitor<?>> getServoMonitors() {
 
-        List<Monitor<?>> monitors = new ArrayList<Monitor<?>>();
+        List<Monitor<?>> monitors = new ArrayList<>();
 
         monitors.add(new InformationalMetric<Boolean>(MonitorConfig.builder("isCircuitBreakerOpen").build()) {
             @Override

File: hystrix-contrib/hystrix-servo-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/servopublisher/HystrixServoMetricsPublisherThreadPool.java
Patch:
@@ -111,7 +111,7 @@ protected Tag getServoInstanceTag() {
      */
     private List<Monitor<?>> getServoMonitors() {
 
-        List<Monitor<?>> monitors = new ArrayList<Monitor<?>>();
+        List<Monitor<?>> monitors = new ArrayList<>();
 
         monitors.add(new InformationalMetric<String>(MonitorConfig.builder("name").build()) {
             @Override

File: hystrix-core/src/main/java/com/netflix/hystrix/Hystrix.java
Patch:
@@ -67,7 +67,7 @@ private static void _reset() {
     private static ThreadLocal<LinkedList<HystrixCommandKey>> currentCommand = new ThreadLocal<LinkedList<HystrixCommandKey>>() {
         @Override
         protected LinkedList<HystrixCommandKey> initialValue() {
-            return new LinkedList<HystrixCommandKey>();
+            return new LinkedList<>();
         }
     };
 

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCircuitBreaker.java
Patch:
@@ -55,7 +55,7 @@ public interface HystrixCircuitBreaker {
      */
     public static class Factory {
         // String is HystrixCommandKey.name() (we can't use HystrixCommandKey directly as we can't guarantee it implements hashcode/equals correctly)
-        private static ConcurrentHashMap<String, HystrixCircuitBreaker> circuitBreakersByCommand = new ConcurrentHashMap<String, HystrixCircuitBreaker>();
+        private static ConcurrentHashMap<String, HystrixCircuitBreaker> circuitBreakersByCommand = new ConcurrentHashMap<>();
 
         /**
          * Get the {@link HystrixCircuitBreaker} instance for a given {@link HystrixCommandKey}.

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java
Patch:
@@ -126,7 +126,7 @@ protected HystrixCollapser(Setter setter) {
         }
 
         HystrixCollapserProperties properties = HystrixPropertiesFactory.getCollapserProperties(collapserKey, propertiesBuilder);
-        this.collapserFactory = new RequestCollapserFactory<BatchReturnType, ResponseType, RequestArgumentType>(collapserKey, scope, timer, properties);
+        this.collapserFactory = new RequestCollapserFactory<>(collapserKey, scope, timer, properties);
         this.requestCache = HystrixRequestCache.getInstance(collapserKey, HystrixPlugins.getInstance().getConcurrencyStrategy());
 
         if (metrics == null) {
@@ -593,6 +593,6 @@ public Setter andCollapserPropertiesDefaults(HystrixCollapserProperties.Setter p
     // this is a micro-optimization but saves about 1-2microseconds (on 2011 MacBook Pro) 
     // on the repetitive string processing that will occur on the same classes over and over again
     @SuppressWarnings("rawtypes")
-    private static ConcurrentHashMap<Class<? extends HystrixCollapser>, String> defaultNameCache = new ConcurrentHashMap<Class<? extends HystrixCollapser>, String>();
+    private static ConcurrentHashMap<Class<? extends HystrixCollapser>, String> defaultNameCache = new ConcurrentHashMap<>();
 
 }

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapserKey.java
Patch:
@@ -37,7 +37,7 @@ private Factory() {
         }
 
         // used to intern instances so we don't keep re-creating them millions of times for the same key
-        private static ConcurrentHashMap<String, HystrixCollapserKey> intern = new ConcurrentHashMap<String, HystrixCollapserKey>();
+        private static ConcurrentHashMap<String, HystrixCollapserKey> intern = new ConcurrentHashMap<>();
 
         /**
          * Retrieve (or create) an interned HystrixCollapserKey instance for a given name.

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapserMetrics.java
Patch:
@@ -36,7 +36,7 @@ public class HystrixCollapserMetrics extends HystrixMetrics {
     private static final Logger logger = LoggerFactory.getLogger(HystrixCollapserMetrics.class);
 
     // String is HystrixCollapserKey.name() (we can't use HystrixCollapserKey directly as we can't guarantee it implements hashcode/equals correctly)
-    private static final ConcurrentHashMap<String, HystrixCollapserMetrics> metrics = new ConcurrentHashMap<String, HystrixCollapserMetrics>();
+    private static final ConcurrentHashMap<String, HystrixCollapserMetrics> metrics = new ConcurrentHashMap<>();
 
     /**
      * Get or create the {@link HystrixCollapserMetrics} instance for a given {@link HystrixCollapserKey}.

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandGroupKey.java
Patch:
@@ -39,7 +39,7 @@ private Factory() {
         }
 
         // used to intern instances so we don't keep re-creating them millions of times for the same key
-        private static ConcurrentHashMap<String, HystrixCommandGroupKey> intern = new ConcurrentHashMap<String, HystrixCommandGroupKey>();
+        private static ConcurrentHashMap<String, HystrixCommandGroupKey> intern = new ConcurrentHashMap<>();
 
         /**
          * Retrieve (or create) an interned HystrixCommandGroup instance for a given name.

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandKey.java
Patch:
@@ -37,7 +37,7 @@ private Factory() {
         }
 
         // used to intern instances so we don't keep re-creating them millions of times for the same key
-        private static ConcurrentHashMap<String, HystrixCommandKey> intern = new ConcurrentHashMap<String, HystrixCommandKey>();
+        private static ConcurrentHashMap<String, HystrixCommandKey> intern = new ConcurrentHashMap<>();
 
         /**
          * Retrieve (or create) an interned HystrixCommandKey instance for a given name.

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandMetrics.java
Patch:
@@ -41,7 +41,7 @@ public class HystrixCommandMetrics extends HystrixMetrics {
     private static final Logger logger = LoggerFactory.getLogger(HystrixCommandMetrics.class);
 
     // String is HystrixCommandKey.name() (we can't use HystrixCommandKey directly as we can't guarantee it implements hashcode/equals correctly)
-    private static final ConcurrentHashMap<String, HystrixCommandMetrics> metrics = new ConcurrentHashMap<String, HystrixCommandMetrics>();
+    private static final ConcurrentHashMap<String, HystrixCommandMetrics> metrics = new ConcurrentHashMap<>();
 
     /**
      * Get or create the {@link HystrixCommandMetrics} instance for a given {@link HystrixCommandKey}.

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixObservableCollapser.java
Patch:
@@ -121,7 +121,7 @@ protected HystrixObservableCollapser(Setter setter) {
             collapserKey = HystrixCollapserKey.Factory.asKey(defaultKeyName);
         }
 
-        this.collapserFactory = new RequestCollapserFactory<BatchReturnType, ResponseType, RequestArgumentType>(collapserKey, scope, timer, propertiesBuilder);
+        this.collapserFactory = new RequestCollapserFactory<>(collapserKey, scope, timer, propertiesBuilder);
         this.requestCache = HystrixRequestCache.getInstance(collapserKey, HystrixPlugins.getInstance().getConcurrencyStrategy());
 
         final HystrixObservableCollapser<K, BatchReturnType, ResponseType, RequestArgumentType> self = this;
@@ -153,7 +153,7 @@ public Observable<Void> mapResponseToRequests(Observable<BatchReturnType> batchR
                 final Func1<BatchReturnType, ResponseType> mapBatchTypeToResponseType = self.getBatchReturnTypeToResponseTypeMapper();
 
                 // index the requests by key
-                final Map<K, CollapsedRequest<ResponseType, RequestArgumentType>> requestsByKey = new HashMap<K, CollapsedRequest<ResponseType, RequestArgumentType>>(requests.size());
+                final Map<K, CollapsedRequest<ResponseType, RequestArgumentType>> requestsByKey = new HashMap<>(requests.size());
                 for (CollapsedRequest<ResponseType, RequestArgumentType> cr : requests) {
                     requestsByKey.put(requestKeySelector.call(cr.getArgument()), cr);
                 }
@@ -510,6 +510,6 @@ public Setter andCollapserPropertiesDefaults(HystrixCollapserProperties.Setter p
     // this is a micro-optimization but saves about 1-2microseconds (on 2011 MacBook Pro) 
     // on the repetitive string processing that will occur on the same classes over and over again
     @SuppressWarnings("rawtypes")
-    private static ConcurrentHashMap<Class<? extends HystrixObservableCollapser>, String> defaultNameCache = new ConcurrentHashMap<Class<? extends HystrixObservableCollapser>, String>();
+    private static ConcurrentHashMap<Class<? extends HystrixObservableCollapser>, String> defaultNameCache = new ConcurrentHashMap<>();
 
 }
\ No newline at end of file

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixRequestCache.java
Patch:
@@ -37,7 +37,7 @@ public class HystrixRequestCache {
     private static final Logger logger = LoggerFactory.getLogger(HystrixRequestCache.class);
 
     // the String key must be: HystrixRequestCache.prefix + concurrencyStrategy + cacheKey
-    private final static ConcurrentHashMap<RequestCacheKey, HystrixRequestCache> caches = new ConcurrentHashMap<RequestCacheKey, HystrixRequestCache>();
+    private final static ConcurrentHashMap<RequestCacheKey, HystrixRequestCache> caches = new ConcurrentHashMap<>();
 
     private final RequestCacheKey rcKey;
     private final HystrixConcurrencyStrategy concurrencyStrategy;
@@ -47,11 +47,11 @@ public class HystrixRequestCache {
      * <p>
      * Key => CommandPrefix + CacheKey : Future<?> from queue()
      */
-    private static final HystrixRequestVariableHolder<ConcurrentHashMap<ValueCacheKey, Observable<?>>> requestVariableForCache = new HystrixRequestVariableHolder<ConcurrentHashMap<ValueCacheKey, Observable<?>>>(new HystrixRequestVariableLifecycle<ConcurrentHashMap<ValueCacheKey, Observable<?>>>() {
+    private static final HystrixRequestVariableHolder<ConcurrentHashMap<ValueCacheKey, Observable<?>>> requestVariableForCache = new HystrixRequestVariableHolder<>(new HystrixRequestVariableLifecycle<ConcurrentHashMap<ValueCacheKey, Observable<?>>>() {
 
         @Override
         public ConcurrentHashMap<ValueCacheKey, Observable<?>> initialValue() {
-            return new ConcurrentHashMap<ValueCacheKey, Observable<?>>();
+            return new ConcurrentHashMap<>();
         }
 
         @Override

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPool.java
Patch:
@@ -80,7 +80,7 @@ public interface HystrixThreadPool {
          * Use the String from HystrixThreadPoolKey.name() instead of the HystrixThreadPoolKey instance as it's just an interface and we can't ensure the object
          * we receive implements hashcode/equals correctly and do not want the default hashcode/equals which would create a new threadpool for every object we get even if the name is the same
          */
-        /* package */final static ConcurrentHashMap<String, HystrixThreadPool> threadPools = new ConcurrentHashMap<String, HystrixThreadPool>();
+        /* package */final static ConcurrentHashMap<String, HystrixThreadPool> threadPools = new ConcurrentHashMap<>();
 
         /**
          * Get the {@link HystrixThreadPool} instance for a given {@link HystrixThreadPoolKey}.

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolKey.java
Patch:
@@ -39,7 +39,7 @@ private Factory() {
         }
 
         // used to intern instances so we don't keep re-creating them millions of times for the same key
-        private static ConcurrentHashMap<String, HystrixThreadPoolKey> intern = new ConcurrentHashMap<String, HystrixThreadPoolKey>();
+        private static ConcurrentHashMap<String, HystrixThreadPoolKey> intern = new ConcurrentHashMap<>();
 
         /**
          * Retrieve (or create) an interned HystrixThreadPoolKey instance for a given name.

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolMetrics.java
Patch:
@@ -36,7 +36,7 @@ public class HystrixThreadPoolMetrics extends HystrixMetrics {
     private static final Logger logger = LoggerFactory.getLogger(HystrixThreadPoolMetrics.class);
 
     // String is HystrixThreadPoolKey.name() (we can't use HystrixThreadPoolKey directly as we can't guarantee it implements hashcode/equals correctly)
-    private static final ConcurrentHashMap<String, HystrixThreadPoolMetrics> metrics = new ConcurrentHashMap<String, HystrixThreadPoolMetrics>();
+    private static final ConcurrentHashMap<String, HystrixThreadPoolMetrics> metrics = new ConcurrentHashMap<>();
 
     /**
      * Get or create the {@link HystrixThreadPoolMetrics} instance for a given {@link HystrixThreadPoolKey}.

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestBatch.java
Patch:
@@ -29,7 +29,7 @@ public class RequestBatch<BatchReturnType, ResponseType, RequestArgumentType> {
     private static final Logger logger = LoggerFactory.getLogger(HystrixCollapser.class);
 
     private final HystrixCollapserBridge<BatchReturnType, ResponseType, RequestArgumentType> commandCollapser;
-    final ConcurrentLinkedQueue<CollapsedRequest<ResponseType, RequestArgumentType>> requests = new ConcurrentLinkedQueue<CollapsedRequest<ResponseType, RequestArgumentType>>();
+    final ConcurrentLinkedQueue<CollapsedRequest<ResponseType, RequestArgumentType>> requests = new ConcurrentLinkedQueue<>();
     // use AtomicInteger to count so we can use ConcurrentLinkedQueue instead of LinkedBlockingQueue
     private final AtomicInteger count = new AtomicInteger(0);
     private final int maxBatchSize;
@@ -65,7 +65,7 @@ public Observable<ResponseType> offer(RequestArgumentType arg) {
                 if (s > maxBatchSize) {
                     return null;
                 } else {
-                    CollapsedRequestObservableFunction<ResponseType, RequestArgumentType> f = new CollapsedRequestObservableFunction<ResponseType, RequestArgumentType>(arg);
+                    CollapsedRequestObservableFunction<ResponseType, RequestArgumentType> f = new CollapsedRequestObservableFunction<>(arg);
                     requests.add(f);
                     return Observable.create(f);
                 }

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixConcurrencyStrategy.java
Patch:
@@ -101,9 +101,9 @@ public BlockingQueue<Runnable> getBlockingQueue(int maxQueueSize) {
          * and rejecting is the preferred solution.
          */
         if (maxQueueSize <= 0) {
-            return new SynchronousQueue<Runnable>();
+            return new SynchronousQueue<>();
         } else {
-            return new LinkedBlockingQueue<Runnable>(maxQueueSize);
+            return new LinkedBlockingQueue<>(maxQueueSize);
         }
     }
 

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextScheduler.java
Patch:
@@ -153,7 +153,7 @@ public Subscription schedule(final Action0 action) {
                 return Subscriptions.empty();
             }
 
-            final AtomicReference<Subscription> sf = new AtomicReference<Subscription>();
+            final AtomicReference<Subscription> sf = new AtomicReference<>();
             Subscription s = Subscriptions.from(threadPool.getExecutor().submit(new Runnable() {
 
                 @Override

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixRequestContext.java
Patch:
@@ -72,7 +72,7 @@ public class HystrixRequestContext {
      * HystrixRequestContext object with the ConcurrentHashMap within it nulled out since once it is nullified
      * from the parent thread it is shared across all child threads.
      */
-    private static ThreadLocal<HystrixRequestContext> requestVariables = new ThreadLocal<HystrixRequestContext>();
+    private static ThreadLocal<HystrixRequestContext> requestVariables = new ThreadLocal<>();
 
     public static boolean isCurrentThreadInitialized() {
         HystrixRequestContext context = requestVariables.get();
@@ -115,7 +115,7 @@ public static HystrixRequestContext initializeContext() {
      * 
      * Only HystrixRequestVariable has a reason to be accessing this field.
      */
-    /* package */ConcurrentHashMap<HystrixRequestVariableDefault<?>, HystrixRequestVariableDefault.LazyInitializer<?>> state = new ConcurrentHashMap<HystrixRequestVariableDefault<?>, HystrixRequestVariableDefault.LazyInitializer<?>>();
+    /* package */ConcurrentHashMap<HystrixRequestVariableDefault<?>, HystrixRequestVariableDefault.LazyInitializer<?>> state = new ConcurrentHashMap<>();
 
     // instantiation should occur via static factory methods.
     private HystrixRequestContext() {

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixRequestVariableDefault.java
Patch:
@@ -93,7 +93,7 @@ public T get() {
          * Whichever instance of LazyInitializer succeeds will then have get() invoked which will call
          * the initialValue() method once-and-only-once.
          */
-        LazyInitializer<T> l = new LazyInitializer<T>(this);
+        LazyInitializer<T> l = new LazyInitializer<>(this);
         LazyInitializer<?> existing = variableMap.putIfAbsent(this, l);
         if (existing == null) {
             /*
@@ -132,7 +132,7 @@ public T initialValue() {
      *            the value to set
      */
     public void set(T value) {
-        HystrixRequestContext.getContextForCurrentThread().state.put(this, new LazyInitializer<T>(this, value));
+        HystrixRequestContext.getContextForCurrentThread().state.put(this, new LazyInitializer<>(this, value));
     }
 
     /**

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixRequestVariableHolder.java
Patch:
@@ -36,7 +36,7 @@ public class HystrixRequestVariableHolder<T> {
 
     static final Logger logger = LoggerFactory.getLogger(HystrixRequestVariableHolder.class);
 
-    private static ConcurrentHashMap<RVCacheKey, HystrixRequestVariable<?>> requestVariableInstance = new ConcurrentHashMap<RVCacheKey, HystrixRequestVariable<?>>();
+    private static ConcurrentHashMap<RVCacheKey, HystrixRequestVariable<?>> requestVariableInstance = new ConcurrentHashMap<>();
 
     private final HystrixRequestVariableLifecycle<T> lifeCycleMethods;
 

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/metrics/HystrixMetricsPublisherFactory.java
Patch:
@@ -98,7 +98,7 @@ public static void reset() {
     /* package */ HystrixMetricsPublisherFactory()  {}
 
     // String is CommandKey.name() (we can't use CommandKey directly as we can't guarantee it implements hashcode/equals correctly)
-    private final ConcurrentHashMap<String, HystrixMetricsPublisherCommand> commandPublishers = new ConcurrentHashMap<String, HystrixMetricsPublisherCommand>();
+    private final ConcurrentHashMap<String, HystrixMetricsPublisherCommand> commandPublishers = new ConcurrentHashMap<>();
 
     /* package */ HystrixMetricsPublisherCommand getPublisherForCommand(HystrixCommandKey commandKey, HystrixCommandGroupKey commandOwner, HystrixCommandMetrics metrics, HystrixCircuitBreaker circuitBreaker, HystrixCommandProperties properties) {
         // attempt to retrieve from cache first
@@ -123,7 +123,7 @@ public static void reset() {
     }
 
     // String is ThreadPoolKey.name() (we can't use ThreadPoolKey directly as we can't guarantee it implements hashcode/equals correctly)
-    private final ConcurrentHashMap<String, HystrixMetricsPublisherThreadPool> threadPoolPublishers = new ConcurrentHashMap<String, HystrixMetricsPublisherThreadPool>();
+    private final ConcurrentHashMap<String, HystrixMetricsPublisherThreadPool> threadPoolPublishers = new ConcurrentHashMap<>();
 
     /* package */ HystrixMetricsPublisherThreadPool getPublisherForThreadPool(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolMetrics metrics, HystrixThreadPoolProperties properties) {
         // attempt to retrieve from cache first
@@ -163,7 +163,7 @@ public static HystrixMetricsPublisherCollapser createOrRetrievePublisherForColla
     }
 
     // String is CollapserKey.name() (we can't use CollapserKey directly as we can't guarantee it implements hashcode/equals correctly)
-    private final ConcurrentHashMap<String, HystrixMetricsPublisherCollapser> collapserPublishers = new ConcurrentHashMap<String, HystrixMetricsPublisherCollapser>();
+    private final ConcurrentHashMap<String, HystrixMetricsPublisherCollapser> collapserPublishers = new ConcurrentHashMap<>();
 
     /* package */ HystrixMetricsPublisherCollapser getPublisherForCollapser(HystrixCollapserKey collapserKey, HystrixCollapserMetrics metrics, HystrixCollapserProperties properties) {
         // attempt to retrieve from cache first

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/properties/HystrixPropertiesFactory.java
Patch:
@@ -46,7 +46,7 @@ public static void reset() {
     }
 
     // String is CommandKey.name() (we can't use CommandKey directly as we can't guarantee it implements hashcode/equals correctly)
-    private static final ConcurrentHashMap<String, HystrixCommandProperties> commandProperties = new ConcurrentHashMap<String, HystrixCommandProperties>();
+    private static final ConcurrentHashMap<String, HystrixCommandProperties> commandProperties = new ConcurrentHashMap<>();
 
     /**
      * Get an instance of {@link HystrixCommandProperties} with the given factory {@link HystrixPropertiesStrategy} implementation for each {@link HystrixCommand} instance.
@@ -85,7 +85,7 @@ public static HystrixCommandProperties getCommandProperties(HystrixCommandKey ke
     }
 
     // String is ThreadPoolKey.name() (we can't use ThreadPoolKey directly as we can't guarantee it implements hashcode/equals correctly)
-    private static final ConcurrentHashMap<String, HystrixThreadPoolProperties> threadPoolProperties = new ConcurrentHashMap<String, HystrixThreadPoolProperties>();
+    private static final ConcurrentHashMap<String, HystrixThreadPoolProperties> threadPoolProperties = new ConcurrentHashMap<>();
 
     /**
      * Get an instance of {@link HystrixThreadPoolProperties} with the given factory {@link HystrixPropertiesStrategy} implementation for each {@link HystrixThreadPool} instance.
@@ -124,7 +124,7 @@ public static HystrixThreadPoolProperties getThreadPoolProperties(HystrixThreadP
     }
 
     // String is CollapserKey.name() (we can't use CollapserKey directly as we can't guarantee it implements hashcode/equals correctly)
-    private static final ConcurrentHashMap<String, HystrixCollapserProperties> collapserProperties = new ConcurrentHashMap<String, HystrixCollapserProperties>();
+    private static final ConcurrentHashMap<String, HystrixCollapserProperties> collapserProperties = new ConcurrentHashMap<>();
 
     /**
      * Get an instance of {@link HystrixCollapserProperties} with the given factory {@link HystrixPropertiesStrategy} implementation for each {@link HystrixCollapserKey} instance.

File: hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixRollingNumber.java
Patch:
@@ -547,7 +547,7 @@ private Bucket[] getArray() {
                  * but since we never clear the data directly, only increment/decrement head/tail we would never get a NULL
                  * just potentially return stale data which we are okay with doing
                  */
-                ArrayList<Bucket> array = new ArrayList<Bucket>();
+                ArrayList<Bucket> array = new ArrayList<>();
                 for (int i = 0; i < size; i++) {
                     array.add(data.get(convert(i)));
                 }
@@ -593,8 +593,8 @@ private int convert(int index) {
         }
 
         BucketCircularArray(int size) {
-            AtomicReferenceArray<Bucket> _buckets = new AtomicReferenceArray<Bucket>(size + 1); // + 1 as extra room for the add/remove;
-            state = new AtomicReference<ListState>(new ListState(_buckets, 0, 0));
+            AtomicReferenceArray<Bucket> _buckets = new AtomicReferenceArray<>(size + 1); // + 1 as extra room for the add/remove;
+            state = new AtomicReference<>(new ListState(_buckets, 0, 0));
             dataLength = _buckets.length();
             numBuckets = size;
         }

File: hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixRollingPercentile.java
Patch:
@@ -471,7 +471,7 @@ private Bucket[] getArray() {
                  * but since we never clear the data directly, only increment/decrement head/tail we would never get a NULL
                  * just potentially return stale data which we are okay with doing
                  */
-                ArrayList<Bucket> array = new ArrayList<Bucket>();
+                ArrayList<Bucket> array = new ArrayList<>();
                 for (int i = 0; i < size; i++) {
                     array.add(data.get(convert(i)));
                 }
@@ -517,8 +517,8 @@ private int convert(int index) {
         }
 
         BucketCircularArray(int size) {
-            AtomicReferenceArray<Bucket> _buckets = new AtomicReferenceArray<Bucket>(size + 1); // + 1 as extra room for the add/remove;
-            state = new AtomicReference<ListState>(new ListState(_buckets, 0, 0));
+            AtomicReferenceArray<Bucket> _buckets = new AtomicReferenceArray<>(size + 1); // + 1 as extra room for the add/remove;
+            state = new AtomicReference<>(new ListState(_buckets, 0, 0));
             dataLength = _buckets.length();
             numBuckets = size;
         }

File: hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixTimer.java
Patch:
@@ -63,7 +63,7 @@ public static void reset() {
         }
     }
 
-    /* package */ AtomicReference<ScheduledExecutor> executor = new AtomicReference<ScheduledExecutor>();
+    /* package */ AtomicReference<ScheduledExecutor> executor = new AtomicReference<>();
 
     /**
      * Add a {@link TimerListener} that will be executed until it is garbage collected or removed by clearing the returned {@link Reference}.

File: hystrix-core/src/test/java/com/netflix/hystrix/strategy/HystrixPluginsTest.java
Patch:
@@ -221,7 +221,7 @@ public T call() throws Exception {
         }
     }
     
-    private static final ThreadLocal<String> testRequestIdThreadLocal = new ThreadLocal<String>();
+    private static final ThreadLocal<String> testRequestIdThreadLocal = new ThreadLocal<>();
 
     public static class DummyCommand extends HystrixCommand<Void> {
 

File: hystrix-core/src/test/java/com/netflix/hystrix/strategy/metrics/HystrixMetricsPublisherFactoryTest.java
Patch:
@@ -34,7 +34,7 @@ public void testSingleInitializePerKey() {
         final TestHystrixMetricsPublisher publisher = new TestHystrixMetricsPublisher();
         HystrixPlugins.getInstance().registerMetricsPublisher(publisher);
         final HystrixMetricsPublisherFactory factory = new HystrixMetricsPublisherFactory();
-        ArrayList<Thread> threads = new ArrayList<Thread>();
+        ArrayList<Thread> threads = new ArrayList<>();
         for (int i = 0; i < 20; i++) {
             threads.add(new Thread(new Runnable() {
 

File: hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandCollapserGetValueForKey.java
Patch:
@@ -74,7 +74,7 @@ private BatchCommand(Collection<CollapsedRequest<String, Integer>> requests) {
 
         @Override
         protected List<String> run() {
-            ArrayList<String> response = new ArrayList<String>();
+            ArrayList<String> response = new ArrayList<>();
             for (CollapsedRequest<String, Integer> request : requests) {
                 // artificial response for each argument received in the batch
                 response.add("ValueForKey: " + request.getArgument());

File: hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandThatFailsSilently.java
Patch:
@@ -46,7 +46,7 @@ protected List<String> run() {
         if (throwException) {
             throw new RuntimeException("failure from CommandThatFailsFast");
         } else {
-            ArrayList<String> values = new ArrayList<String>();
+            ArrayList<String> values = new ArrayList<>();
             values.add("success");
             return values;
         }

File: hystrix-examples/src/main/java/com/netflix/hystrix/examples/demo/CreditCardCommand.java
Patch:
@@ -168,9 +168,9 @@ public Result<Transaction> submit(String creditCardNumber, String expirationMont
             }
 
             if (Math.random() < 0.8) {
-                return new Result<Transaction>(true);
+                return new Result<>(true);
             } else {
-                return new Result<Transaction>(false);
+                return new Result<>(false);
             }
 
         }

File: hystrix-contrib/hystrix-codahale-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/codahalemetricspublisher/HystrixCodaHaleMetricsPublisherCommand.java
Patch:
@@ -43,7 +43,7 @@ public HystrixCodaHaleMetricsPublisherCommand(HystrixCommandKey commandKey, Hyst
         this.circuitBreaker = circuitBreaker;
         this.properties = properties;
         this.metricRegistry = metricRegistry;
-        this.metricGroup = "HystrixCommand";
+        this.metricGroup = commandGroupKey.name();
         this.metricType = key.name();
     }
 

File: hystrix-contrib/hystrix-codahale-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/codahalemetricspublisher/HystrixCodaHaleMetricsPublisherCommand.java
Patch:
@@ -43,7 +43,7 @@ public HystrixCodaHaleMetricsPublisherCommand(HystrixCommandKey commandKey, Hyst
         this.circuitBreaker = circuitBreaker;
         this.properties = properties;
         this.metricRegistry = metricRegistry;
-        this.metricGroup = "HystrixCommand";
+        this.metricGroup = commandGroupKey.name();
         this.metricType = key.name();
     }
 

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java
Patch:
@@ -4778,7 +4778,7 @@ public void call(TestHystrixCommand<Boolean> command) {
      * Fallback: SUCCESS
      */
     @Test
-    public void testExecutionHookSempahoreRejectedSuccessfulFallback() {
+    public void testExecutionHookSemaphoreRejectedSuccessfulFallback() {
         assertHooksOnSuccess(
                 new Func0<TestHystrixCommand<Boolean>>() {
                     @Override

File: hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/test/spring/collapser/CollapserTest.java
Patch:
@@ -111,7 +111,7 @@ public void testCollapserAsyncNotFoundWithFallbackEnabled() throws ExecutionExce
             assertEquals("name: 5", f5.get().getName());
 
             assertEquals(1, HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().size());
-            com.netflix.hystrix.HystrixCommand getUserCommand = getHystrixCommandByKey("getUserAsyncWithFallback");
+            com.netflix.hystrix.HystrixInvokableInfo getUserCommand = getHystrixCommandByKey("getUserAsyncWithFallback");
 
             // confirm that it was a COLLAPSED command execution
             assertTrue(getUserCommand.getExecutionEvents().contains(HystrixEventType.COLLAPSED));
@@ -144,7 +144,7 @@ public void testCollapserAsyncNotFoundWithFallbackCommandEnabled() throws Execut
             assertEquals("name: 5", f5.get().getName());
 
             assertEquals(2, HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().size());
-            com.netflix.hystrix.HystrixCommand getUserCommand = getHystrixCommandByKey("getUserAsyncWithFallbackCommand");
+            com.netflix.hystrix.HystrixInvokableInfo getUserCommand = getHystrixCommandByKey("getUserAsyncWithFallbackCommand");
 
             // confirm that it was a COLLAPSED command execution
             assertTrue(getUserCommand.getExecutionEvents().contains(HystrixEventType.COLLAPSED));

File: hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/test/spring/observable/ObservableTest.java
Patch:
@@ -74,7 +74,7 @@ public void call(User user) {
                 }
             });
             assertEquals(3, HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().size());
-            com.netflix.hystrix.HystrixCommand getUserCommand = getHystrixCommandByKey("getUser");
+            com.netflix.hystrix.HystrixInvokableInfo getUserCommand = getHystrixCommandByKey("getUser");
             assertTrue(getUserCommand.getExecutionEvents().contains(HystrixEventType.SUCCESS));
         } finally {
             context.shutdown();
@@ -90,7 +90,7 @@ public void testGetUserWithFallback() {
             // blocking
             assertEquals(exUser, userService.getUser(" ", "").toBlocking().single());
             assertEquals(1, HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().size());
-            com.netflix.hystrix.HystrixCommand getUserCommand = getHystrixCommandByKey("getUser");
+            com.netflix.hystrix.HystrixInvokableInfo getUserCommand = getHystrixCommandByKey("getUser");
             // confirm that command has failed
             assertTrue(getUserCommand.getExecutionEvents().contains(HystrixEventType.FAILURE));
             // and that fallback was successful

File: hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandCollapserGetValueForKey.java
Patch:
@@ -29,6 +29,7 @@
 import com.netflix.hystrix.HystrixCommandGroupKey;
 import com.netflix.hystrix.HystrixCommandKey;
 import com.netflix.hystrix.HystrixEventType;
+import com.netflix.hystrix.HystrixInvokableInfo;
 import com.netflix.hystrix.HystrixRequestLog;
 import com.netflix.hystrix.strategy.concurrency.HystrixRequestContext;
 
@@ -98,7 +99,7 @@ public void testCollapser() throws Exception {
                 assertEquals("ValueForKey: 3", f3.get());
                 assertEquals("ValueForKey: 4", f4.get());
 
-                int numExecuted = HystrixRequestLog.getCurrentRequest().getExecutedCommands().size();
+                int numExecuted = HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().size();
 
                 System.err.println("num executed: " + numExecuted);
 
@@ -108,11 +109,10 @@ public void testCollapser() throws Exception {
                     fail("some of the commands should have been collapsed");
                 }
 
-                System.err.println("HystrixRequestLog.getCurrentRequest().getExecutedCommands(): " + HystrixRequestLog.getCurrentRequest().getExecutedCommands());
                 System.err.println("HystrixRequestLog.getCurrentRequest().getAllExecutedCommands(): " + HystrixRequestLog.getCurrentRequest().getAllExecutedCommands());
 
                 int numLogs = 0;
-                for (HystrixCommand<?> command : HystrixRequestLog.getCurrentRequest().getExecutedCommands()) {
+                for (HystrixInvokableInfo<?> command : HystrixRequestLog.getCurrentRequest().getAllExecutedCommands()) {
                     numLogs++;
                     
                     // assert the command is the one we're expecting

File: hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandWithFallbackViaNetwork.java
Patch:
@@ -23,6 +23,7 @@
 import com.netflix.hystrix.HystrixCommandGroupKey;
 import com.netflix.hystrix.HystrixCommandKey;
 import com.netflix.hystrix.HystrixEventType;
+import com.netflix.hystrix.HystrixInvokableInfo;
 import com.netflix.hystrix.HystrixRequestLog;
 import com.netflix.hystrix.HystrixThreadPoolKey;
 import com.netflix.hystrix.strategy.concurrency.HystrixRequestContext;
@@ -93,11 +94,11 @@ public void test() {
             try {
                 assertEquals(null, new CommandWithFallbackViaNetwork(1).execute());
 
-                HystrixCommand<?> command1 = HystrixRequestLog.getCurrentRequest().getExecutedCommands().toArray(new HystrixCommand<?>[2])[0];
+                HystrixInvokableInfo<?> command1 = HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().toArray(new HystrixInvokableInfo<?>[2])[0];
                 assertEquals("GetValueCommand", command1.getCommandKey().name());
                 assertTrue(command1.getExecutionEvents().contains(HystrixEventType.FAILURE));
 
-                HystrixCommand<?> command2 = HystrixRequestLog.getCurrentRequest().getExecutedCommands().toArray(new HystrixCommand<?>[2])[1];
+                HystrixInvokableInfo<?> command2 = HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().toArray(new HystrixInvokableInfo<?>[2])[1];
                 assertEquals("GetValueFallbackCommand", command2.getCommandKey().name());
                 assertTrue(command2.getExecutionEvents().contains(HystrixEventType.FAILURE));
             } finally {

File: hystrix-core/src/main/java/com/netflix/hystrix/Hystrix.java
Patch:
@@ -5,6 +5,7 @@
 import java.util.concurrent.TimeUnit;
 
 import com.netflix.hystrix.strategy.HystrixPlugins;
+import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisherFactory;
 import com.netflix.hystrix.strategy.properties.HystrixPropertiesFactory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/HystrixPlugins.java
Patch:
@@ -25,6 +25,7 @@
 import com.netflix.hystrix.strategy.executionhook.HystrixCommandExecutionHookDefault;
 import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisher;
 import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisherDefault;
+import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisherFactory;
 import com.netflix.hystrix.strategy.properties.HystrixPropertiesStrategy;
 import com.netflix.hystrix.strategy.properties.HystrixPropertiesStrategyDefault;
 
@@ -64,6 +65,7 @@ public static void reset() {
         getInstance().metricsPublisher.set(null);
         getInstance().propertiesFactory.set(null);
         getInstance().commandExecutionHook.set(null);
+        HystrixMetricsPublisherFactory.reset();
     }
 
     /**

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixThreadPoolTest.java
Patch:
@@ -79,14 +79,12 @@ public HystrixThreadPoolMetrics getHystrixThreadPoolMetrics() {
 
     @Test
     public void ensureThreadPoolInstanceIsTheOneRegisteredWithMetricsPublisherAndThreadPoolCache() throws IllegalAccessException, NoSuchFieldException {
-        new HystrixPluginsTest().reset();
         HystrixPlugins.getInstance().registerMetricsPublisher(new HystrixMetricsPublisher() {
             @Override
             public HystrixMetricsPublisherThreadPool getMetricsPublisherForThreadPool(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolMetrics metrics, HystrixThreadPoolProperties properties) {
                 return new HystrixMetricsPublisherThreadPoolContainer(metrics);
             }
         });
-        new HystrixMetricsPublisherFactoryTest().reset();
         HystrixThreadPoolKey threadPoolKey = HystrixThreadPoolKey.Factory.asKey("threadPoolFactoryConcurrencyTest");
         HystrixThreadPool poolOne = new HystrixThreadPool.HystrixThreadPoolDefault(
                 threadPoolKey, HystrixThreadPoolProperties.Setter.getUnitTestPropertiesBuilder());

File: hystrix-core/src/main/java/com/netflix/hystrix/Hystrix.java
Patch:
@@ -5,6 +5,7 @@
 import java.util.concurrent.TimeUnit;
 
 import com.netflix.hystrix.strategy.HystrixPlugins;
+import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisherFactory;
 import com.netflix.hystrix.strategy.properties.HystrixPropertiesFactory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/HystrixPlugins.java
Patch:
@@ -25,6 +25,7 @@
 import com.netflix.hystrix.strategy.executionhook.HystrixCommandExecutionHookDefault;
 import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisher;
 import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisherDefault;
+import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisherFactory;
 import com.netflix.hystrix.strategy.properties.HystrixPropertiesStrategy;
 import com.netflix.hystrix.strategy.properties.HystrixPropertiesStrategyDefault;
 
@@ -64,6 +65,7 @@ public static void reset() {
         getInstance().metricsPublisher.set(null);
         getInstance().propertiesFactory.set(null);
         getInstance().commandExecutionHook.set(null);
+        HystrixMetricsPublisherFactory.reset();
     }
 
     /**

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixThreadPoolTest.java
Patch:
@@ -79,14 +79,12 @@ public HystrixThreadPoolMetrics getHystrixThreadPoolMetrics() {
 
     @Test
     public void ensureThreadPoolInstanceIsTheOneRegisteredWithMetricsPublisherAndThreadPoolCache() throws IllegalAccessException, NoSuchFieldException {
-        new HystrixPluginsTest().reset();
         HystrixPlugins.getInstance().registerMetricsPublisher(new HystrixMetricsPublisher() {
             @Override
             public HystrixMetricsPublisherThreadPool getMetricsPublisherForThreadPool(HystrixThreadPoolKey threadPoolKey, HystrixThreadPoolMetrics metrics, HystrixThreadPoolProperties properties) {
                 return new HystrixMetricsPublisherThreadPoolContainer(metrics);
             }
         });
-        new HystrixMetricsPublisherFactoryTest().reset();
         HystrixThreadPoolKey threadPoolKey = HystrixThreadPoolKey.Factory.asKey("threadPoolFactoryConcurrencyTest");
         HystrixThreadPool poolOne = new HystrixThreadPool.HystrixThreadPoolDefault(
                 threadPoolKey, HystrixThreadPoolProperties.Setter.getUnitTestPropertiesBuilder());

File: hystrix-core/src/main/java/com/netflix/hystrix/Hystrix.java
Patch:
@@ -5,6 +5,7 @@
 import java.util.concurrent.TimeUnit;
 
 import com.netflix.hystrix.strategy.HystrixPlugins;
+import com.netflix.hystrix.strategy.properties.HystrixPropertiesFactory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -58,6 +59,7 @@ private static void _reset() {
         // clear circuit breakers
         HystrixCircuitBreaker.Factory.reset();
         HystrixPlugins.reset();
+        HystrixPropertiesFactory.reset();
     }
 
     private static ThreadLocal<LinkedList<HystrixCommandKey>> currentCommand = new ThreadLocal<LinkedList<HystrixCommandKey>>() {

File: hystrix-core/src/main/java/com/netflix/hystrix/Hystrix.java
Patch:
@@ -5,6 +5,7 @@
 import java.util.concurrent.TimeUnit;
 
 import com.netflix.hystrix.strategy.HystrixPlugins;
+import com.netflix.hystrix.strategy.properties.HystrixPropertiesFactory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -58,6 +59,7 @@ private static void _reset() {
         // clear circuit breakers
         HystrixCircuitBreaker.Factory.reset();
         HystrixPlugins.reset();
+        HystrixPropertiesFactory.reset();
     }
 
     private static ThreadLocal<LinkedList<HystrixCommandKey>> currentCommand = new ThreadLocal<LinkedList<HystrixCommandKey>>() {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPool.java
Patch:
@@ -202,11 +202,11 @@ public void markThreadCompletion() {
         /**
          * Whether the threadpool queue has space available according to the <code>queueSizeRejectionThreshold</code> settings.
          * <p>
-         * If a SynchronousQueue implementation is used (<code>maxQueueSize</code> == -1), it always returns 0 as the size so this would always return true.
+         * If a SynchronousQueue implementation is used (<code>maxQueueSize</code> <= 0), it always returns 0 as the size so this would always return true.
          */
         @Override
         public boolean isQueueSpaceAvailable() {
-            if (properties.maxQueueSize().get() < 0) {
+            if (properties.maxQueueSize().get() <= 0) {
                 // we don't have a queue so we won't look for space but instead
                 // let the thread-pool reject or not
                 return true;

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextScheduler.java
Patch:
@@ -180,7 +180,6 @@ public void run() {
 
         @Override
         public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
-            System.out.println("delayed scheduling");
             throw new IllegalStateException("Hystrix does not support delayed scheduling");
         }
 

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPool.java
Patch:
@@ -202,11 +202,11 @@ public void markThreadCompletion() {
         /**
          * Whether the threadpool queue has space available according to the <code>queueSizeRejectionThreshold</code> settings.
          * <p>
-         * If a SynchronousQueue implementation is used (<code>maxQueueSize</code> == -1), it always returns 0 as the size so this would always return true.
+         * If a SynchronousQueue implementation is used (<code>maxQueueSize</code> <= 0), it always returns 0 as the size so this would always return true.
          */
         @Override
         public boolean isQueueSpaceAvailable() {
-            if (properties.maxQueueSize().get() < 0) {
+            if (properties.maxQueueSize().get() <= 0) {
                 // we don't have a queue so we won't look for space but instead
                 // let the thread-pool reject or not
                 return true;

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextScheduler.java
Patch:
@@ -180,7 +180,6 @@ public void run() {
 
         @Override
         public Subscription schedule(Action0 action, long delayTime, TimeUnit unit) {
-            System.out.println("delayed scheduling");
             throw new IllegalStateException("Hystrix does not support delayed scheduling");
         }
 

File: hystrix-core/src/main/java/com/netflix/hystrix/exception/HystrixRuntimeException.java
Patch:
@@ -32,7 +32,7 @@ public class HystrixRuntimeException extends RuntimeException {
     private final FailureType failureCause;
 
     public static enum FailureType {
-        COMMAND_EXCEPTION, TIMEOUT, SHORTCIRCUIT, REJECTED_THREAD_EXECUTION, REJECTED_SEMAPHORE_EXECUTION, REJECTED_SEMAPHORE_FALLBACK
+        BAD_REQUEST_EXCEPTION, COMMAND_EXCEPTION, TIMEOUT, SHORTCIRCUIT, REJECTED_THREAD_EXECUTION, REJECTED_SEMAPHORE_EXECUTION, REJECTED_SEMAPHORE_FALLBACK
     }
 
     public HystrixRuntimeException(FailureType failureCause, Class<? extends HystrixInvokable> commandClass, String message, Exception cause, Throwable fallbackException) {

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestBatch.java
Patch:
@@ -121,7 +121,7 @@ public void call(Throwable e) {
                                 } else {
                                     ee = new RuntimeException("Throwable caught while executing batch and mapping responses.", e);
                                 }
-                                logger.error("Exception mapping responses to requests.", e);
+                                logger.debug("Exception mapping responses to requests.", e);
                                 // if a failure occurs we want to pass that exception to all of the Futures that we've returned
                                 for (CollapsedRequest<ResponseType, RequestArgumentType> request : requests) {
                                     try {

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestBatch.java
Patch:
@@ -121,7 +121,7 @@ public void call(Throwable e) {
                                 } else {
                                     ee = new RuntimeException("Throwable caught while executing batch and mapping responses.", e);
                                 }
-                                logger.error("Exception mapping responses to requests.", e);
+                                logger.debug("Exception mapping responses to requests.", e);
                                 // if a failure occurs we want to pass that exception to all of the Futures that we've returned
                                 for (CollapsedRequest<ResponseType, RequestArgumentType> request : requests) {
                                     try {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -156,8 +156,7 @@ protected HystrixCommand(Setter setter) {
      * Example:
      * <pre> {@code
      *  Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("GroupName"))
-                .andCommandKey(HystrixCommandKey.Factory.asKey("CommandName"))
-                .andEventNotifier(notifier);
+                .andCommandKey(HystrixCommandKey.Factory.asKey("CommandName"));
      * } </pre>
      * 
      * @NotThreadSafe

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -156,8 +156,7 @@ protected HystrixCommand(Setter setter) {
      * Example:
      * <pre> {@code
      *  Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey("GroupName"))
-                .andCommandKey(HystrixCommandKey.Factory.asKey("CommandName"))
-                .andEventNotifier(notifier);
+                .andCommandKey(HystrixCommandKey.Factory.asKey("CommandName"));
      * } </pre>
      * 
      * @NotThreadSafe

File: hystrix-contrib/hystrix-rx-netty-metrics-stream/src/test/java/com/netflix/hystrix/contrib/rxnetty/metricsstream/HystrixMetricsStreamHandlerTest.java
Patch:
@@ -85,7 +85,7 @@ public Observable<? extends ServerSentEvent> call(HttpClientResponse<ServerSentE
                     }
                 });
 
-        Object first = Observable.amb(objectObservable, Observable.timer(1000, TimeUnit.MILLISECONDS)).toBlockingObservable().first();
+        Object first = Observable.amb(objectObservable, Observable.timer(1000, TimeUnit.MILLISECONDS)).toBlocking().first();
 
         assertTrue("Expected SSE message", first instanceof ServerSentEvent);
         ServerSentEvent sse = (ServerSentEvent) first;
@@ -116,4 +116,4 @@ public Observable<Void> handle(HttpServerRequest<ByteBuf> request, HttpServerRes
         }
         throw new RuntimeException("Cannot initialize RxNetty server", error);
     }
-}
\ No newline at end of file
+}

File: hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/command/ExecutionTypeTest.java
Patch:
@@ -7,7 +7,6 @@
 import rx.internal.operators.OperatorMulticast;
 
 import java.util.List;
-import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Future;
 import java.util.concurrent.RunnableFuture;
 
@@ -30,7 +29,6 @@ public static List<Object[]> data() {
                 {returnType(Future.class), shouldHaveExecutionType(ASYNCHRONOUS)},
                 {returnType(AsyncResult.class), shouldHaveExecutionType(ASYNCHRONOUS)},
                 {returnType(RunnableFuture.class), shouldHaveExecutionType(ASYNCHRONOUS)},
-                {returnType(CompletableFuture.class), shouldHaveExecutionType(ASYNCHRONOUS)},
                 {returnType(Observable.class), shouldHaveExecutionType(OBSERVABLE)},
                 {returnType(OperatorMulticast.class), shouldHaveExecutionType(OBSERVABLE)},
         });

File: hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/test/spring/configuration/collapser/CollapserPropertiesTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.netflix.hystrix.contrib.javanica.test.spring.configuration.collapser;
 
 import com.netflix.hystrix.HystrixEventType;
+import com.netflix.hystrix.HystrixInvokableInfo;
 import com.netflix.hystrix.HystrixRequestLog;
 import com.netflix.hystrix.contrib.javanica.annotation.HystrixCollapser;
 import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;
@@ -44,7 +45,7 @@ public void testCollapser() throws ExecutionException, InterruptedException {
             assertEquals("name: 3", u3.getName());
             assertEquals("name: 4", u4.getName());
 
-            com.netflix.hystrix.HystrixExecutableInfo<?> command = HystrixRequestLog.getCurrentRequest()
+            HystrixInvokableInfo<?> command = HystrixRequestLog.getCurrentRequest()
                     .getAllExecutedCommands().iterator().next();
             assertEquals("getUser", command.getCommandKey().name());
             //When a command is fronted by an HystrixCollapser then this marks how many requests are collapsed into the single command execution.

File: hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/test/spring/configuration/command/CommandPropertiesTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.netflix.hystrix.contrib.javanica.test.spring.configuration.command;
 
 import com.netflix.hystrix.HystrixEventType;
+import com.netflix.hystrix.HystrixInvokableInfo;
 import com.netflix.hystrix.HystrixRequestLog;
 import com.netflix.hystrix.HystrixThreadPool;
 import com.netflix.hystrix.HystrixThreadPoolProperties;
@@ -38,7 +39,7 @@ public void testGetUser() throws NoSuchFieldException, IllegalAccessException {
             User u1 = userService.getUser("1", "name: ");
             assertEquals("name: 1", u1.getName());
             assertEquals(1, HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().size());
-            com.netflix.hystrix.HystrixExecutableInfo<?> command = HystrixRequestLog.getCurrentRequest()
+            HystrixInvokableInfo<?> command = HystrixRequestLog.getCurrentRequest()
                     .getAllExecutedCommands().iterator().next();
             assertEquals("GetUserCommand", command.getCommandKey().name());
             assertEquals("UserGroupKey", command.getCommandGroup().name());
@@ -74,7 +75,7 @@ public void testGetUserDefaultPropertiesValues() {
             User u1 = userService.getUserDefProperties("1", "name: ");
             assertEquals("name: 1", u1.getName());
             assertEquals(1, HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().size());
-            com.netflix.hystrix.HystrixExecutableInfo<?> command = HystrixRequestLog.getCurrentRequest()
+            HystrixInvokableInfo<?> command = HystrixRequestLog.getCurrentRequest()
                     .getAllExecutedCommands().iterator().next();
             assertEquals("getUserDefProperties", command.getCommandKey().name());
             assertEquals("UserService", command.getCommandGroup().name());

File: hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/test/spring/observable/ObservableTest.java
Patch:
@@ -41,7 +41,7 @@ public void testGetUserByIdObservable() {
         try {
 
             // blocking
-            assertEquals("name: 1", userService.getUser("1", "name: ").toBlockingObservable().single().getName());
+            assertEquals("name: 1", userService.getUser("1", "name: ").toBlocking().single().getName());
 
             // non-blocking
             // - this is a verbose anonymous inner-class approach and doesn't do assertions
@@ -88,7 +88,7 @@ public void testGetUserWithFallback() {
             final User exUser = new User("def", "def");
 
             // blocking
-            assertEquals(exUser, userService.getUser(" ", "").toBlockingObservable().single());
+            assertEquals(exUser, userService.getUser(" ", "").toBlocking().single());
             assertEquals(1, HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().size());
             com.netflix.hystrix.HystrixCommand getUserCommand = getHystrixCommandByKey("getUser");
             // confirm that command has failed

File: hystrix-core/src/main/java/com/netflix/hystrix/Hystrix.java
Patch:
@@ -51,6 +51,7 @@ public static void reset(long time, TimeUnit unit) {
     private static void _reset() {
         // clear metrics
         HystrixCommandMetrics.reset();
+        HystrixThreadPoolMetrics.reset();
         // clear collapsers
         HystrixCollapser.reset();
         // clear circuit breakers

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/ExecutionType.java
Patch:
@@ -39,16 +39,15 @@ public enum ExecutionType {
      */
     OBSERVABLE;
 
-
     /**
      * Gets execution type for specified class type.
      * @param type the type
      * @return the execution type {@link ExecutionType}
      */
     public static ExecutionType getExecutionType(Class<?> type) {
-        if (type.isAssignableFrom(Future.class)) {
+        if (Future.class.isAssignableFrom(type)) {
             return ExecutionType.ASYNCHRONOUS;
-        } else if (type.isAssignableFrom(Observable.class)) {
+        } else if (Observable.class.isAssignableFrom(type)) {
             return ExecutionType.OBSERVABLE;
         } else {
             return ExecutionType.SYNCHRONOUS;

File: hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandHelloWorld.java
Patch:
@@ -76,8 +76,8 @@ public void testObservable() throws Exception {
             Observable<String> fBob = new CommandHelloWorld("Bob").observe();
 
             // blocking
-            assertEquals("Hello World!", fWorld.toBlockingObservable().single());
-            assertEquals("Hello Bob!", fBob.toBlockingObservable().single());
+            assertEquals("Hello World!", fWorld.toBlocking().single());
+            assertEquals("Hello Bob!", fBob.toBlocking().single());
 
             // non-blocking 
             // - this is a verbose anonymous inner-class approach and doesn't do assertions

File: hystrix-examples/src/main/java/com/netflix/hystrix/examples/basic/CommandHelloWorld.java
Patch:
@@ -76,8 +76,8 @@ public void testObservable() throws Exception {
             Observable<String> fBob = new CommandHelloWorld("Bob").observe();
 
             // blocking
-            assertEquals("Hello World!", fWorld.toBlockingObservable().single());
-            assertEquals("Hello Bob!", fBob.toBlockingObservable().single());
+            assertEquals("Hello World!", fWorld.toBlocking().single());
+            assertEquals("Hello Bob!", fBob.toBlocking().single());
 
             // non-blocking 
             // - this is a verbose anonymous inner-class approach and doesn't do assertions

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/ExecutionType.java
Patch:
@@ -39,16 +39,15 @@ public enum ExecutionType {
      */
     OBSERVABLE;
 
-
     /**
      * Gets execution type for specified class type.
      * @param type the type
      * @return the execution type {@link ExecutionType}
      */
     public static ExecutionType getExecutionType(Class<?> type) {
-        if (type.isAssignableFrom(Future.class)) {
+        if (Future.class.isAssignableFrom(type)) {
             return ExecutionType.ASYNCHRONOUS;
-        } else if (type.isAssignableFrom(Observable.class)) {
+        } else if (Observable.class.isAssignableFrom(type)) {
             return ExecutionType.OBSERVABLE;
         } else {
             return ExecutionType.SYNCHRONOUS;

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java
Patch:
@@ -65,7 +65,7 @@
 import com.netflix.hystrix.util.HystrixTimer;
 import com.netflix.hystrix.util.HystrixTimer.TimerListener;
 
-/* package */abstract class AbstractCommand<R> implements HystrixExecutableInfo<R>, HystrixObservable<R> {
+/* package */abstract class AbstractCommand<R> implements HystrixInvokableInfo<R>, HystrixObservable<R> {
     // TODO make this package private
 
     private static final Logger logger = LoggerFactory.getLogger(AbstractCommand.class);

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -44,7 +44,7 @@
  * 
  * @ThreadSafe
  */
-public abstract class HystrixCommand<R> extends AbstractCommand<R> implements HystrixExecutable<R>, HystrixExecutableInfo<R>, HystrixObservable<R> {
+public abstract class HystrixCommand<R> extends AbstractCommand<R> implements HystrixExecutable<R>, HystrixInvokableInfo<R>, HystrixObservable<R> {
 
     /**
      * Construct a {@link HystrixCommand} with defined {@link HystrixCommandGroupKey}.

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixFutureCommand.java
Patch:
@@ -44,7 +44,7 @@
  * 
  * @ThreadSafe
  */
-public abstract class HystrixFutureCommand<R> extends AbstractCommand<R> implements HystrixExecutable<R>, HystrixExecutableInfo<R>, HystrixObservable<R> {
+public abstract class HystrixFutureCommand<R> extends AbstractCommand<R> implements HystrixExecutable<R>, HystrixInvokableInfo<R>, HystrixObservable<R> {
 
     /**
      * Construct a {@link HystrixFutureCommand} with defined {@link HystrixCommandGroupKey}.

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixInvokableInfo.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.List;
 
-public interface HystrixExecutableInfo<R> {
+public interface HystrixInvokableInfo<R> {
 
     public HystrixCommandGroupKey getCommandGroup();
 

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixObservableCommand.java
Patch:
@@ -34,7 +34,7 @@
  * 
  * @ThreadSafe
  */
-public abstract class HystrixObservableCommand<R> extends AbstractCommand<R> implements HystrixObservable<R>, HystrixExecutableInfo<R> {
+public abstract class HystrixObservableCommand<R> extends AbstractCommand<R> implements HystrixObservable<R>, HystrixInvokableInfo<R> {
 
     /**
      * Construct a {@link HystrixObservableCommand} with defined {@link HystrixCommandGroupKey}.

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCircuitBreakerTest.java
Patch:
@@ -585,8 +585,8 @@ public <T> T onComplete(final HystrixInvokable<T> command, final T response) {
 
         private <T> void logHC(HystrixInvokable<T> command, T response) {
 
-            if(command instanceof HystrixExecutableInfo) {
-                HystrixExecutableInfo<T> commandInfo = (HystrixExecutableInfo<T>)command;
+            if(command instanceof HystrixInvokableInfo) {
+                HystrixInvokableInfo<T> commandInfo = (HystrixInvokableInfo<T>)command;
             HystrixCommandMetrics metrics = commandInfo.getMetrics();
             System.out.println("cb/error-count/%/total: "
                     + commandInfo.isCircuitBreakerOpen() + " "

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java
Patch:
@@ -2838,7 +2838,7 @@ public void testRequestCacheOnTimeoutCausesNullPointerException() throws Excepti
 
         assertEquals(5, HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().size());
 
-        HystrixExecutableInfo<?>[] executeCommands = HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().toArray(new HystrixExecutableInfo<?>[] {});
+        HystrixInvokableInfo<?>[] executeCommands = HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().toArray(new HystrixInvokableInfo<?>[] {});
 
         System.out.println(":executeCommands[0].getExecutionEvents()" + executeCommands[0].getExecutionEvents());
         assertEquals(2, executeCommands[0].getExecutionEvents().size());

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTimeoutConcurrencyTesting.java
Patch:
@@ -19,7 +19,7 @@ public void testTimeoutRace() {
                     throw new RuntimeException("Received NULL");
                 }
 
-                for (HystrixExecutableInfo<?> hi : HystrixRequestLog.getCurrentRequest().getAllExecutedCommands()) {
+                for (HystrixInvokableInfo<?> hi : HystrixRequestLog.getCurrentRequest().getAllExecutedCommands()) {
                     if (hi.isResponseTimedOut() && hi.getExecutionEvents().size() == 1) {
                         System.err.println("Missing fallback status!");
                         throw new RuntimeException("Missing fallback status on timeout.");

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixFutureCommandTest.java
Patch:
@@ -2795,7 +2795,7 @@ public void testRequestCacheOnTimeoutCausesNullPointerException() throws Excepti
 
         assertEquals(5, HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().size());
 
-        HystrixExecutableInfo<?>[] executeCommands = HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().toArray(new HystrixFutureCommand<?>[] {});
+        HystrixInvokableInfo<?>[] executeCommands = HystrixRequestLog.getCurrentRequest().getAllExecutedCommands().toArray(new HystrixFutureCommand<?>[] {});
 
         System.out.println(":executeCommands[0].getExecutionEvents()" + executeCommands[0].getExecutionEvents());
         assertEquals(2, executeCommands[0].getExecutionEvents().size());

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixObservableCommand.java
Patch:
@@ -205,7 +205,7 @@ private HystrixCommandProperties.Setter setDefaults(HystrixCommandProperties.Set
      * 
      * @return R or UnsupportedOperationException if not implemented
      */
-    protected Observable<R> onFailureResumeWithFallback() {
+    protected Observable<R> resumeWithFallback() {
         return Observable.error(new UnsupportedOperationException("No fallback available."));
     }
 
@@ -216,6 +216,6 @@ final protected Observable<R> getExecutionObservable() {
     
     @Override
     final protected Observable<R> getFallbackObservable() {
-        return onFailureResumeWithFallback();
+        return resumeWithFallback();
     }
 }

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractCommand.java
Patch:
@@ -1146,7 +1146,7 @@ public AbstractCommand<R> getCommand() {
     }
 
     /**
-     * @return {@link HystrixCommandGroupKey} used to group together multiple {@link HystrixAsyncCommand} objects.
+     * @return {@link HystrixCommandGroupKey} used to group together multiple {@link HystrixFutureCommand} objects.
      *         <p>
      *         The {@link HystrixCommandGroupKey} is used to represent a common relationship between commands. For example, a library or team name, the system all related commands interace with,
      *         common business purpose etc.
@@ -1175,7 +1175,7 @@ public HystrixThreadPoolKey getThreadPoolKey() {
     }
 
     /**
-     * The {@link HystrixCommandMetrics} associated with this {@link HystrixAsyncCommand} instance.
+     * The {@link HystrixCommandMetrics} associated with this {@link HystrixFutureCommand} instance.
      * 
      * @return HystrixCommandMetrics
      */
@@ -1184,7 +1184,7 @@ public HystrixCommandMetrics getMetrics() {
     }
 
     /**
-     * The {@link HystrixCommandProperties} associated with this {@link HystrixAsyncCommand} instance.
+     * The {@link HystrixCommandProperties} associated with this {@link HystrixFutureCommand} instance.
      * 
      * @return HystrixCommandProperties
      */

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixThreadPoolProperties.java
Patch:
@@ -162,7 +162,7 @@ public static Setter Setter() {
      * <pre> {@code
      * HystrixThreadPoolProperties.Setter()
      *           .setCoreSize(10)
-     *           .setQueueSizeRejectionThreshold(10);
+     *           .withQueueSizeRejectionThreshold(10);
      * } </pre>
      * 
      * @NotThreadSafe

File: hystrix-contrib/hystrix-codahale-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/codahalemetricspublisher/ConfigurableCodaHaleMetricFilter.java
Patch:
@@ -9,7 +9,7 @@
 /**
  * An implementation of @MetricFilter based upon an Archaius DynamicPropertyFactory
  *
- * To enable this filter, the property 'filter.graphite,metrics' must be set to TRUE
+ * To enable this filter, the property 'filter.graphite.metrics' must be set to TRUE
  *
  * If this is the case, metrics will be filtered unless METRIC_NAME = true is set in
  * the properties
@@ -59,7 +59,7 @@ public boolean matches(String s, Metric metric) {
 
     protected boolean isFilterEnabled() {
 
-        boolean filterEnabled = archaiusPropertyFactory.getBooleanProperty("filter.graphite,metrics", false).get();
+        boolean filterEnabled = archaiusPropertyFactory.getBooleanProperty("filter.graphite.metrics", false).get();
 
         LOGGER.debug("Is filter enabled? [{}]", filterEnabled);
 

File: hystrix-contrib/hystrix-metrics-event-stream/src/main/java/com/netflix/hystrix/contrib/metrics/eventstream/HystrixMetricsStreamServlet.java
Patch:
@@ -21,7 +21,6 @@
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import javax.annotation.concurrent.ThreadSafe;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
@@ -176,8 +175,8 @@ private void handleRequest(HttpServletRequest request, HttpServletResponse respo
 
     /**
      * This will be called from another thread so needs to be thread-safe.
+     * @ThreadSafe
      */
-    @ThreadSafe
     private static class MetricJsonListener implements HystrixMetricsPoller.MetricsAsJsonPollerListener {
 
         /**

File: hystrix-contrib/hystrix-metrics-event-stream/src/main/java/com/netflix/hystrix/contrib/metrics/eventstream/HystrixMetricsStreamServlet.java
Patch:
@@ -21,7 +21,6 @@
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import javax.annotation.concurrent.ThreadSafe;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServlet;
 import javax.servlet.http.HttpServletRequest;
@@ -176,8 +175,8 @@ private void handleRequest(HttpServletRequest request, HttpServletResponse respo
 
     /**
      * This will be called from another thread so needs to be thread-safe.
+     * @ThreadSafe
      */
-    @ThreadSafe
     private static class MetricJsonListener implements HystrixMetricsPoller.MetricsAsJsonPollerListener {
 
         /**

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandMetrics.java
Patch:
@@ -232,8 +232,10 @@ public int getTotalTimeMean() {
     }
 
     /* package */void resetCounter() {
-        counter.reset();
         // TODO can we do without this somehow?
+        counter.reset();
+        lastHealthCountsSnapshot.set(System.currentTimeMillis());
+        healthCountsSnapshot = new HealthCounts(0, 0, 0);
     }
 
     /**

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandMetrics.java
Patch:
@@ -232,8 +232,10 @@ public int getTotalTimeMean() {
     }
 
     /* package */void resetCounter() {
-        counter.reset();
         // TODO can we do without this somehow?
+        counter.reset();
+        lastHealthCountsSnapshot.set(System.currentTimeMillis());
+        healthCountsSnapshot = new HealthCounts(0, 0, 0);
     }
 
     /**

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/BatchHystrixCommandFactory.java
Patch:
@@ -36,9 +36,10 @@ public static HystrixCommandFactory<BatchHystrixCommand> getInstance() {
     BatchHystrixCommand create(CommandSetterBuilder setterBuilder,
                                Map<String, Object> commandProperties, CommandAction action,
                                CommandAction fallbackAction,
-                               Collection<HystrixCollapser.CollapsedRequest<Object, Object>> collapsedRequests) {
+                               Collection<HystrixCollapser.CollapsedRequest<Object, Object>> collapsedRequests,
+                               Class<? extends Throwable>[] ignoreExceptions) {
         BatchHystrixCommand batchHystrixCommand = new BatchHystrixCommand(setterBuilder, action, fallbackAction,
-            commandProperties, collapsedRequests);
+            commandProperties, collapsedRequests, ignoreExceptions);
         return batchHystrixCommand;
     }
 }

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/GenericHystrixCommandFactory.java
Patch:
@@ -35,9 +35,10 @@ public static HystrixCommandFactory<GenericCommand> getInstance() {
     @Override
     GenericCommand create(CommandSetterBuilder setterBuilder, Map<String, Object> commandProperties,
                           CommandAction action, CommandAction fallbackAction,
-                          Collection<HystrixCollapser.CollapsedRequest<Object, Object>> collapsedRequests) {
+                          Collection<HystrixCollapser.CollapsedRequest<Object, Object>> collapsedRequests,
+                          Class<? extends Throwable>[] ignoreExceptions) {
         GenericCommand genericCommand = new GenericCommand(setterBuilder, action, fallbackAction, commandProperties,
-            collapsedRequests);
+            collapsedRequests, ignoreExceptions);
         return genericCommand;
     }
 

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixObservableCommand.java
Patch:
@@ -877,6 +877,8 @@ public void onError(Throwable e) {
 
                 @Override
                 public void onNext(R v) {
+                    // TODO does this need to compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.NOT_EXECUTED)
+                    // to be thread-safe, and does that even work?
                     if (originalCommand.isCommandTimedOut.get().equals(TimedOutStatus.NOT_EXECUTED)) {
                         child.onNext(v);
                     }

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/BatchHystrixCommandFactory.java
Patch:
@@ -36,9 +36,10 @@ public static HystrixCommandFactory<BatchHystrixCommand> getInstance() {
     BatchHystrixCommand create(CommandSetterBuilder setterBuilder,
                                Map<String, Object> commandProperties, CommandAction action,
                                CommandAction fallbackAction,
-                               Collection<HystrixCollapser.CollapsedRequest<Object, Object>> collapsedRequests) {
+                               Collection<HystrixCollapser.CollapsedRequest<Object, Object>> collapsedRequests,
+                               Class<? extends Throwable>[] ignoreExceptions) {
         BatchHystrixCommand batchHystrixCommand = new BatchHystrixCommand(setterBuilder, action, fallbackAction,
-            commandProperties, collapsedRequests);
+            commandProperties, collapsedRequests, ignoreExceptions);
         return batchHystrixCommand;
     }
 }

File: hystrix-contrib/hystrix-javanica/src/main/java/com/netflix/hystrix/contrib/javanica/command/GenericHystrixCommandFactory.java
Patch:
@@ -35,9 +35,10 @@ public static HystrixCommandFactory<GenericCommand> getInstance() {
     @Override
     GenericCommand create(CommandSetterBuilder setterBuilder, Map<String, Object> commandProperties,
                           CommandAction action, CommandAction fallbackAction,
-                          Collection<HystrixCollapser.CollapsedRequest<Object, Object>> collapsedRequests) {
+                          Collection<HystrixCollapser.CollapsedRequest<Object, Object>> collapsedRequests,
+                          Class<? extends Throwable>[] ignoreExceptions) {
         GenericCommand genericCommand = new GenericCommand(setterBuilder, action, fallbackAction, commandProperties,
-            collapsedRequests);
+            collapsedRequests, ignoreExceptions);
         return genericCommand;
     }
 

File: hystrix-contrib/hystrix-javanica/src/test/java/com/netflix/hystrix/contrib/javanica/test/spring/rest/client/RestClient.java
Patch:
@@ -17,6 +17,8 @@ public interface RestClient {
 
     User getUserByName(String name);
 
+    User getUserByNameIgnoreExc(String name);
+
     User getUserByIdSecondary(String id);
 
     List<User> findAll(int pageNum, int pageSize);

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixObservableCommand.java
Patch:
@@ -791,7 +791,7 @@ public Subscriber<? super R> call(final Subscriber<? super R> child) {
              * Define the action to perform on timeout outside of the TimerListener to it can capture the HystrixRequestContext
              * of the calling thread which doesn't exist on the Timer thread.
              */
-            final HystrixContextRunnable timeoutRunnable = new HystrixContextRunnable(new Runnable() {
+            final HystrixContextRunnable timeoutRunnable = new HystrixContextRunnable(originalCommand.concurrencyStrategy, new Runnable() {
 
                 @Override
                 public void run() {

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapser.java
Patch:
@@ -121,7 +121,7 @@ private class CollapsedTask implements TimerListener {
         CollapsedTask() {
             // this gets executed from the context of a HystrixCommand parent thread (such as a Tomcat thread)
             // so we create the callable now where we can capture the thread context
-            callableWithContextOfParent = concurrencyStrategy.wrapCallable(new HystrixContextCallable<Void>(new Callable<Void>() {
+            callableWithContextOfParent = new HystrixContextCallable<Void>(concurrencyStrategy, new Callable<Void>() {
                 // the wrapCallable call allows a strategy to capture thread-context if desired
 
                 @Override
@@ -144,7 +144,7 @@ public Void call() throws Exception {
                     return null;
                 }
 
-            }));
+            });
         }
 
         @Override

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextCallable.java
Patch:
@@ -30,8 +30,8 @@ public class HystrixContextCallable<K> implements Callable<K> {
     private final Callable<K> actual;
     private final HystrixRequestContext parentThreadState;
 
-    public HystrixContextCallable(Callable<K> actual) {
-        this.actual = actual;
+    public HystrixContextCallable(HystrixConcurrencyStrategy concurrencyStrategy, Callable<K> actual) {
+        this.actual = concurrencyStrategy.wrapCallable(actual);
         this.parentThreadState = HystrixRequestContext.getContextForCurrentThread();
     }
 

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCollapserTest.java
Patch:
@@ -22,6 +22,7 @@
 import com.netflix.hystrix.collapser.RealCollapserTimer;
 import com.netflix.hystrix.collapser.RequestCollapser;
 import com.netflix.hystrix.collapser.RequestCollapserFactory;
+import com.netflix.hystrix.strategy.HystrixPlugins;
 import com.netflix.hystrix.strategy.concurrency.HystrixContextRunnable;
 import com.netflix.hystrix.strategy.concurrency.HystrixRequestContext;
 import com.netflix.hystrix.strategy.concurrency.HystrixRequestVariableHolder;
@@ -329,7 +330,7 @@ public void testRequestVariableLifecycle2() throws Exception {
 
         // kick off work (simulating a single request with multiple threads)
         for (int t = 0; t < 5; t++) {
-            Thread th = new Thread(new HystrixContextRunnable(new Runnable() {
+            Thread th = new Thread(new HystrixContextRunnable(HystrixPlugins.getInstance().getConcurrencyStrategy(), new Runnable() {
 
                 @Override
                 public void run() {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java
Patch:
@@ -880,7 +880,7 @@ public void testRequestVariableLifecycle2() throws Exception {
 
             // kick off work (simulating a single request with multiple threads)
             for (int t = 0; t < 5; t++) {
-                Thread th = new Thread(new HystrixContextRunnable(new Runnable() {
+                Thread th = new Thread(new HystrixContextRunnable(HystrixPlugins.getInstance().getConcurrencyStrategy(), new Runnable() {
 
                     @Override
                     public void run() {

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapser.java
Patch:
@@ -121,7 +121,7 @@ private class CollapsedTask implements TimerListener {
         CollapsedTask() {
             // this gets executed from the context of a HystrixCommand parent thread (such as a Tomcat thread)
             // so we create the callable now where we can capture the thread context
-            callableWithContextOfParent = concurrencyStrategy.wrapCallable(new HystrixContextCallable<Void>(new Callable<Void>() {
+            callableWithContextOfParent = new HystrixContextCallable<Void>(concurrencyStrategy, new Callable<Void>() {
                 // the wrapCallable call allows a strategy to capture thread-context if desired
 
                 @Override
@@ -144,7 +144,7 @@ public Void call() throws Exception {
                     return null;
                 }
 
-            }));
+            });
         }
 
         @Override

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixConcurrencyStrategy.java
Patch:
@@ -32,6 +32,7 @@
 import rx.util.functions.Func1;
 
 import com.netflix.config.ConfigurationManager;
+import com.netflix.hystrix.Hystrix;
 import com.netflix.hystrix.HystrixCommand;
 import com.netflix.hystrix.HystrixCommandGroupKey;
 import com.netflix.hystrix.HystrixRequestLog;
@@ -218,6 +219,7 @@ protected String run() throws Exception {
             }
             
         }
+        
     }
 
 }

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextCallable.java
Patch:
@@ -30,8 +30,8 @@ public class HystrixContextCallable<K> implements Callable<K> {
     private final Callable<K> actual;
     private final HystrixRequestContext parentThreadState;
 
-    public HystrixContextCallable(Callable<K> actual) {
-        this.actual = actual;
+    public HystrixContextCallable(HystrixConcurrencyStrategy concurrencyStrategy, Callable<K> actual) {
+        this.actual = concurrencyStrategy.wrapCallable(actual);
         this.parentThreadState = HystrixRequestContext.getContextForCurrentThread();
     }
 

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextScheduler.java
Patch:
@@ -15,12 +15,10 @@
  */
 package com.netflix.hystrix.strategy.concurrency;
 
-import java.util.concurrent.Callable;
 import java.util.concurrent.TimeUnit;
 
 import rx.Scheduler;
 import rx.Subscription;
-import rx.subscriptions.MultipleAssignmentSubscription;
 import rx.util.functions.Func2;
 
 /**

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java
Patch:
@@ -880,7 +880,7 @@ public void testRequestVariableLifecycle2() throws Exception {
 
             // kick off work (simulating a single request with multiple threads)
             for (int t = 0; t < 5; t++) {
-                Thread th = new Thread(new HystrixContextRunnable(new Runnable() {
+                Thread th = new Thread(new HystrixContextRunnable(HystrixPlugins.getInstance().getConcurrencyStrategy(), new Runnable() {
 
                     @Override
                     public void run() {

File: hystrix-core/src/main/java/com/netflix/hystrix/collapser/RequestCollapser.java
Patch:
@@ -121,7 +121,7 @@ private class CollapsedTask implements TimerListener {
         CollapsedTask() {
             // this gets executed from the context of a HystrixCommand parent thread (such as a Tomcat thread)
             // so we create the callable now where we can capture the thread context
-            callableWithContextOfParent = concurrencyStrategy.wrapCallable(new HystrixContextCallable<Void>(new Callable<Void>() {
+            callableWithContextOfParent = new HystrixContextCallable<Void>(concurrencyStrategy, new Callable<Void>() {
                 // the wrapCallable call allows a strategy to capture thread-context if desired
 
                 @Override
@@ -144,7 +144,7 @@ public Void call() throws Exception {
                     return null;
                 }
 
-            }));
+            });
         }
 
         @Override

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixConcurrencyStrategy.java
Patch:
@@ -32,6 +32,7 @@
 import rx.util.functions.Func1;
 
 import com.netflix.config.ConfigurationManager;
+import com.netflix.hystrix.Hystrix;
 import com.netflix.hystrix.HystrixCommand;
 import com.netflix.hystrix.HystrixCommandGroupKey;
 import com.netflix.hystrix.HystrixRequestLog;
@@ -218,6 +219,7 @@ protected String run() throws Exception {
             }
             
         }
+        
     }
 
 }

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextCallable.java
Patch:
@@ -30,8 +30,8 @@ public class HystrixContextCallable<K> implements Callable<K> {
     private final Callable<K> actual;
     private final HystrixRequestContext parentThreadState;
 
-    public HystrixContextCallable(Callable<K> actual) {
-        this.actual = actual;
+    public HystrixContextCallable(HystrixConcurrencyStrategy concurrencyStrategy, Callable<K> actual) {
+        this.actual = concurrencyStrategy.wrapCallable(actual);
         this.parentThreadState = HystrixRequestContext.getContextForCurrentThread();
     }
 

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextScheduler.java
Patch:
@@ -15,12 +15,10 @@
  */
 package com.netflix.hystrix.strategy.concurrency;
 
-import java.util.concurrent.Callable;
 import java.util.concurrent.TimeUnit;
 
 import rx.Scheduler;
 import rx.Subscription;
-import rx.subscriptions.MultipleAssignmentSubscription;
 import rx.util.functions.Func2;
 
 /**

File: hystrix-core/src/main/java/com/netflix/hystrix/AbstractHystrixCommand.java
Patch:
@@ -1012,7 +1012,7 @@ protected String getCacheKey() {
     }
 
     protected boolean isRequestCachingEnabled() {
-        return properties.requestCacheEnabled().get();
+        return properties.requestCacheEnabled().get() && getCacheKey() != null;
     }
 
     protected String getLogMessagePrefix() {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixObservableCommand.java
Patch:
@@ -43,7 +43,6 @@
 import com.netflix.hystrix.exception.HystrixRuntimeException.FailureType;
 import com.netflix.hystrix.strategy.concurrency.HystrixContextRunnable;
 import com.netflix.hystrix.strategy.concurrency.HystrixContextScheduler;
-import com.netflix.hystrix.strategy.concurrency.HystrixRequestContext;
 import com.netflix.hystrix.strategy.executionhook.HystrixCommandExecutionHook;
 import com.netflix.hystrix.strategy.properties.HystrixPropertiesStrategy;
 import com.netflix.hystrix.util.HystrixTimer;
@@ -425,6 +424,8 @@ private Observable<R> getRunObservableDecoratedForMetricsAndErrorHandling(final
         }
 
         if (properties.executionIsolationStrategy().get().equals(ExecutionIsolationStrategy.THREAD)) {
+            // mark that we are executing in a thread (even if we end up being rejected we still were a THREAD execution and not SEMAPHORE)
+            isExecutedInThread.set(true);
             run = run.subscribeOn(threadPool.getScheduler());
         }
 

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixRequestLog.java
Patch:
@@ -124,7 +124,6 @@ public Collection<AbstractHystrixCommand<?>> getAllExecutedCommands() {
      *            {@code HystrixCommand<?>}
      */
     /* package */void addExecutedCommand(AbstractHystrixCommand<?> command) {
-        System.out.println("&&&&&&& add request to log: " + command + "  thread: " + Thread.currentThread());
         if (!allExecutedCommands.offer(command)) {
             // see RequestLog: Reduce Chance of Memory Leak https://github.com/Netflix/Hystrix/issues/53
             logger.warn("RequestLog ignoring command after reaching limit of " + MAX_STORAGE + ". See https://github.com/Netflix/Hystrix/issues/53 for more information.");

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixRequestLog.java
Patch:
@@ -54,7 +54,6 @@ public class HystrixRequestLog {
     private static final HystrixRequestVariableHolder<HystrixRequestLog> currentRequestLog = new HystrixRequestVariableHolder<HystrixRequestLog>(new HystrixRequestVariableLifecycle<HystrixRequestLog>() {
         @Override
         public HystrixRequestLog initialValue() {
-            System.out.println("$$$$$$$$$$ new requestLog on thread: " + Thread.currentThread());
             return new HystrixRequestLog();
         }
 

File: hystrix-core/src/test/java/com/netflix/hystrix/HystrixCommandTest.java
Patch:
@@ -88,6 +88,8 @@ public void testExecutionSuccess() {
 
             assertEquals(0, command.builder.metrics.getHealthCounts().getErrorPercentage());
 
+            System.out.println("request log: " + HystrixRequestLog.getCurrentRequest());
+            
             assertEquals(1, HystrixRequestLog.getCurrentRequest().getExecutedCommands().size());
 
         } catch (Exception e) {

File: hystrix-core/src/main/java/com/netflix/hystrix/Hystrix.java
Patch:
@@ -10,7 +10,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.netflix.hystrix.HystrixCommand.Setter;
+import com.netflix.hystrix.AbstractHystrixCommand.Setter;
 import com.netflix.hystrix.HystrixCommandProperties.ExecutionIsolationStrategy;
 
 /**

File: hystrix-core/src/main/java/com/netflix/hystrix/strategy/concurrency/HystrixContextFunc2.java
Patch:
@@ -64,7 +64,7 @@ public Subscription call() throws Exception {
                     // set the state of this thread to that of its parent
                     HystrixRequestContext.setContextOnCurrentThread(parentThreadState);
                     // execute actual Func2 with the state of the parent
-                    return actual.call(t1Holder.get(), t2Holder.get());
+                    return actual.call(new HystrixContextScheduler(concurrencyStrategy, t1Holder.get()), t2Holder.get());
                 } finally {
                     // restore this thread back to its original state
                     HystrixRequestContext.setContextOnCurrentThread(existingState);

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -853,7 +853,7 @@ public Observable<R> call(Throwable e) {
             // don't waste overhead if it's the 'immediate' scheduler
             // otherwise we'll 'observeOn' and wrap with the HystrixContextScheduler
             // to copy state across threads (if threads are involved)
-            o = o.observeOn(new HystrixContextScheduler(observeOn));
+            o = o.observeOn(new HystrixContextScheduler(concurrencyStrategy, observeOn));
         }
 
         o = o.finallyDo(new Action0() {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -853,7 +853,7 @@ public Observable<R> call(Throwable e) {
             // don't waste overhead if it's the 'immediate' scheduler
             // otherwise we'll 'observeOn' and wrap with the HystrixContextScheduler
             // to copy state across threads (if threads are involved)
-            o = o.observeOn(new HystrixContextScheduler(observeOn));
+            o = o.observeOn(new HystrixContextScheduler(concurrencyStrategy, observeOn));
         }
 
         o = o.finallyDo(new Action0() {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -1264,11 +1264,10 @@ private R executeCommand() {
                 if (decorated instanceof HystrixBadRequestException) {
                     e = (HystrixBadRequestException) decorated;
                 } else {
-                    logger.warn("ExecutionHook.endRunFailure returned an exception that was not an instance of HystrixBadRequestException so will be ignored.", decorated);
+                    logger.warn("ExecutionHook.onRunError returned an exception that was not an instance of HystrixBadRequestException so will be ignored.", decorated);
                 }
-                throw e;
             } catch (Exception hookException) {
-                logger.warn("Error calling ExecutionHook.endRunFailure", hookException);
+                logger.warn("Error calling ExecutionHook.onRunError", hookException);
             }
 
             /*

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -1264,11 +1264,10 @@ private R executeCommand() {
                 if (decorated instanceof HystrixBadRequestException) {
                     e = (HystrixBadRequestException) decorated;
                 } else {
-                    logger.warn("ExecutionHook.endRunFailure returned an exception that was not an instance of HystrixBadRequestException so will be ignored.", decorated);
+                    logger.warn("ExecutionHook.onRunError returned an exception that was not an instance of HystrixBadRequestException so will be ignored.", decorated);
                 }
-                throw e;
             } catch (Exception hookException) {
-                logger.warn("Error calling ExecutionHook.endRunFailure", hookException);
+                logger.warn("Error calling ExecutionHook.onRunError", hookException);
             }
 
             /*

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixRequestCache.java
Patch:
@@ -24,6 +24,7 @@
 import org.slf4j.LoggerFactory;
 
 import rx.Observable;
+import rx.Observable.OnSubscribeFunc;
 import rx.Observer;
 import rx.Subscription;
 import rx.subscriptions.Subscriptions;
@@ -334,10 +335,10 @@ public void testClearCache() {
 
         private static class TestObservable extends Observable<String> {
             public TestObservable(final String value) {
-                super(new Func1<Observer<String>, Subscription>() {
+                super(new OnSubscribeFunc<String>() {
 
                     @Override
-                    public Subscription call(Observer<String> observer) {
+                    public Subscription onSubscribe(Observer<? super String> observer) {
                         observer.onNext(value);
                         observer.onCompleted();
                         return Subscriptions.empty();

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -834,10 +834,10 @@ public Subscription call(Observer<R> observer) {
         }
 
         // error handling
-        o = o.onErrorResumeNext(new Func1<Exception, Observable<R>>() {
+        o = o.onErrorResumeNext(new Func1<Throwable, Observable<R>>() {
 
             @Override
-            public Observable<R> call(Exception e) {
+            public Observable<R> call(Throwable e) {
                 // count that we are throwing an exception and re-throw it
                 metrics.markExceptionThrown();
                 return Observable.error(e);

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -834,10 +834,10 @@ public Subscription call(Observer<R> observer) {
         }
 
         // error handling
-        o = o.onErrorResumeNext(new Func1<Exception, Observable<R>>() {
+        o = o.onErrorResumeNext(new Func1<Throwable, Observable<R>>() {
 
             @Override
-            public Observable<R> call(Exception e) {
+            public Observable<R> call(Throwable e) {
                 // count that we are throwing an exception and re-throw it
                 metrics.markExceptionThrown();
                 return Observable.error(e);

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java
Patch:
@@ -1351,8 +1351,9 @@ public void testVoidResponseTypeFireAndForgetCollapsing2() throws Exception {
             try {
                 assertEquals(null, response1.get());
                 fail("expected an error as mapResponseToRequests did not set responses");
-            } catch (Exception e) {
-                // do nothing
+            } catch (ExecutionException e) {
+                assertTrue(e.getCause() instanceof IllegalStateException);
+                assertTrue(e.getCause().getMessage().startsWith("No response set by"));
             }
 
             assertEquals(1, counter.get());

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java
Patch:
@@ -1351,8 +1351,9 @@ public void testVoidResponseTypeFireAndForgetCollapsing2() throws Exception {
             try {
                 assertEquals(null, response1.get());
                 fail("expected an error as mapResponseToRequests did not set responses");
-            } catch (Exception e) {
-                // do nothing
+            } catch (ExecutionException e) {
+                assertTrue(e.getCause() instanceof IllegalStateException);
+                assertTrue(e.getCause().getMessage().startsWith("No response set by"));
             }
 
             assertEquals(1, counter.get());

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -1235,10 +1235,10 @@ private R executeCommand() {
                 // this means we have already timed out then we don't count this error stat and we just return
                 // as this means the user-thread has already returned, we've already done fallback logic
                 // and we've already counted the timeout stat
-                logger.error("Error executing HystrixCommand.run() [TimedOut]. Proceeding to fallback logic ...", e);
+                logger.debug("Error executing HystrixCommand.run() [TimedOut]. Proceeding to fallback logic ...", e);
                 return null;
             } else {
-                logger.error("Error executing HystrixCommand.run(). Proceeding to fallback logic ...", e);
+                logger.debug("Error executing HystrixCommand.run(). Proceeding to fallback logic ...", e);
             }
             // report failure
             metrics.markFailure(System.currentTimeMillis() - startTime);
@@ -1551,7 +1551,7 @@ private R getFallbackOrThrowException(HystrixEventType eventType, FailureType fa
 
                     throw new HystrixRuntimeException(failureType, this.getClass(), getLogMessagePrefix() + " " + message + " and no fallback available.", e, fe);
                 } catch (Exception fe) {
-                    logger.error("Error retrieving fallback for HystrixCommand. ", fe);
+                    logger.debug("HystrixCommand execution " + failureType.name() + " and fallback retrieval failed.", fe);
                     metrics.markFallbackFailure();
                     // record the executionResult
                     executionResult = executionResult.addEvents(HystrixEventType.FALLBACK_FAILURE);

File: hystrix-core/src/main/java/com/netflix/hystrix/util/HystrixTimer.java
Patch:
@@ -31,9 +31,10 @@
 import org.slf4j.LoggerFactory;
 
 import com.netflix.hystrix.HystrixCollapser;
+import com.netflix.hystrix.HystrixCommand;
 
 /**
- * Timer used by the {@link HystrixCollapser} to trigger batch executions.
+ * Timer used by {@link HystrixCommand} to timeout async executions and {@link HystrixCollapser} to trigger batch executions.
  */
 public class HystrixTimer {
 
@@ -46,7 +47,7 @@ private HystrixTimer() {
     }
 
     /**
-     * Retrieve the global instance with a single backing thread.
+     * Retrieve the global instance.
      */
     public static HystrixTimer getInstance() {
         return INSTANCE;

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -806,10 +806,10 @@ private R executeCommand() {
                 // this means we have already timed out then we don't count this error stat and we just return
                 // as this means the user-thread has already returned, we've already done fallback logic
                 // and we've already counted the timeout stat
-                logger.error("Error executing HystrixCommand [TimedOut]", e);
+                logger.error("Error executing HystrixCommand.run() [TimedOut]. Proceeding to fallback logic ...", e);
                 return null;
             } else {
-                logger.error("Error executing HystrixCommand", e);
+                logger.error("Error executing HystrixCommand.run(). Proceeding to fallback logic ...", e);
             }
             // report failure
             metrics.markFailure(System.currentTimeMillis() - startTime);

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java
Patch:
@@ -160,7 +160,7 @@ private HystrixCollapser(HystrixCollapserKey collapserKey, Scope scope, Collapse
      * 
      * @return {@link HystrixCollapserKey} identifying this {@link HystrixCollapser} instance
      */
-    public final HystrixCollapserKey getCollapserKey() {
+    public HystrixCollapserKey getCollapserKey() {
         return collapserKey;
     }
 
@@ -179,7 +179,7 @@ public final HystrixCollapserKey getCollapserKey() {
      * 
      * @return {@link Scope} that collapsing should be performed within.
      */
-    public final Scope getScope() {
+    public Scope getScope() {
         return scope;
     }
 

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java
Patch:
@@ -160,7 +160,7 @@ private HystrixCollapser(HystrixCollapserKey collapserKey, Scope scope, Collapse
      * 
      * @return {@link HystrixCollapserKey} identifying this {@link HystrixCollapser} instance
      */
-    public final HystrixCollapserKey getCollapserKey() {
+    public HystrixCollapserKey getCollapserKey() {
         return collapserKey;
     }
 
@@ -179,7 +179,7 @@ public final HystrixCollapserKey getCollapserKey() {
      * 
      * @return {@link Scope} that collapsing should be performed within.
      */
-    public final Scope getScope() {
+    public Scope getScope() {
         return scope;
     }
 

File: hystrix-contrib/hystrix-metrics-event-stream/src/main/java/com/netflix/hystrix/contrib/metrics/eventstream/HystrixMetricsStreamServlet.java
Patch:
@@ -102,7 +102,7 @@ private void handleRequest(HttpServletRequest request, HttpServletResponse respo
                 }
 
                 /* initialize response */
-                response.setHeader("Content-Type", "text/event-stream");
+                response.setHeader("Content-Type", "text/event-stream;charset=UTF-8");
                 response.setHeader("Cache-Control", "no-cache, no-store, max-age=0, must-revalidate");
                 response.setHeader("Pragma", "no-cache");
 

File: hystrix-contrib/hystrix-metrics-event-stream/src/main/java/com/netflix/hystrix/contrib/metrics/eventstream/HystrixMetricsPoller.java
Patch:
@@ -277,6 +277,8 @@ public void run() {
                     json.writeNumberField("propertyValue_queueSizeRejectionThreshold", threadPoolMetrics.getProperties().queueSizeRejectionThreshold().get());
                     json.writeNumberField("propertyValue_metricsRollingStatisticalWindowInMilliseconds", threadPoolMetrics.getProperties().metricsRollingStatisticalWindowInMilliseconds().get());
 
+                    json.writeNumberField("reportingHosts", 1); // this will get summed across all instances in a cluster
+                    
                     json.writeEndObject();
                     json.close();
                     // output to stream

File: hystrix-contrib/hystrix-metrics-event-stream/src/main/java/com/netflix/hystrix/contrib/metrics/eventstream/HystrixMetricsPoller.java
Patch:
@@ -277,6 +277,8 @@ public void run() {
                     json.writeNumberField("propertyValue_queueSizeRejectionThreshold", threadPoolMetrics.getProperties().queueSizeRejectionThreshold().get());
                     json.writeNumberField("propertyValue_metricsRollingStatisticalWindowInMilliseconds", threadPoolMetrics.getProperties().metricsRollingStatisticalWindowInMilliseconds().get());
 
+                    json.writeNumberField("reportingHosts", 1); // this will get summed across all instances in a cluster
+                    
                     json.writeEndObject();
                     json.close();
                     // output to stream

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -303,8 +303,9 @@ private static String getDefaultNameFromClass(@SuppressWarnings("rawtypes") Clas
      * Implement this method with code to be executed when {@link #execute()} or {@link #queue()} are invoked.
      * 
      * @return R response type
+     * @throws Exception if command execution fails
      */
-    protected abstract R run();
+    protected abstract R run() throws Exception;
 
     /**
      * If {@link #execute()} or {@link #queue()} fails in any way then this method will be invoked to provide an opportunity to return a fallback response.

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -4398,7 +4398,7 @@ private TestCommandWithTimeout(long timeout, int fallbackBehavior) {
             protected Boolean run() {
                 System.out.println("***** running");
                 try {
-                    Thread.sleep(timeout * 2);
+                    Thread.sleep(timeout * 10);
                 } catch (InterruptedException e) {
                     e.printStackTrace();
                 }

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommand.java
Patch:
@@ -4398,7 +4398,7 @@ private TestCommandWithTimeout(long timeout, int fallbackBehavior) {
             protected Boolean run() {
                 System.out.println("***** running");
                 try {
-                    Thread.sleep(timeout * 2);
+                    Thread.sleep(timeout * 10);
                 } catch (InterruptedException e) {
                     e.printStackTrace();
                 }

File: hystrix-contrib/hystrix-servo-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/servopublisher/HystrixServoMetricsPublisherCommand.java
Patch:
@@ -205,7 +205,7 @@ public Number getValue() {
         monitors.add(new GaugeMetric(MonitorConfig.builder("latencyExecute_percentile_75").build()) {
             @Override
             public Number getValue() {
-                return metrics.getExecutionTimePercentile(90);
+                return metrics.getExecutionTimePercentile(75);
             }
         });
         monitors.add(new GaugeMetric(MonitorConfig.builder("latencyExecute_percentile_90").build()) {

File: hystrix-contrib/hystrix-servo-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/servopublisher/HystrixServoMetricsPublisherCommand.java
Patch:
@@ -205,7 +205,7 @@ public Number getValue() {
         monitors.add(new GaugeMetric(MonitorConfig.builder("latencyExecute_percentile_75").build()) {
             @Override
             public Number getValue() {
-                return metrics.getExecutionTimePercentile(90);
+                return metrics.getExecutionTimePercentile(75);
             }
         });
         monitors.add(new GaugeMetric(MonitorConfig.builder("latencyExecute_percentile_90").build()) {

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixRequestLog.java
Patch:
@@ -82,7 +82,7 @@ public static HystrixRequestLog getCurrentRequest(HystrixConcurrencyStrategy con
      * @return {@link HystrixRequestLog}
      */
     public static HystrixRequestLog getCurrentRequest() {
-        return getCurrentRequest(HystrixPlugins.getInstance().getConcurrencyStrategy(null));
+        return currentRequestLog.get(HystrixPlugins.getInstance().getConcurrencyStrategy());
     }
 
     /**

File: hystrix-contrib/hystrix-servo-metrics-publisher/src/main/java/com/netflix/hystrix/contrib/servopublisher/HystrixServoMetricsPublisherAbstract.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.netflix.hystrix.strategy.metrics;
+package com.netflix.hystrix.contrib.servopublisher;
 
 import com.netflix.hystrix.HystrixCommandMetrics;
 import com.netflix.hystrix.util.HystrixRollingNumberEvent;
@@ -27,9 +27,9 @@
 import com.netflix.servo.tag.Tag;
 
 /**
- * Utility used for Servo (https://github.com/Netflix/servo) based default implementations of metrics publishers.
+ * Utility used for Servo (https://github.com/Netflix/servo) based implementations of metrics publishers.
  */
-/* package */abstract class HystrixMetricsServoPublisherAbstract {
+/* package */abstract class HystrixServoMetricsPublisherAbstract {
 
     protected abstract Tag getServoTypeTag();
 

File: hystrix-examples/src/main/java/com/netflix/hystrix/examples/demo/CreditCardAuthorizationResult.java
Patch:
@@ -80,7 +80,7 @@ public boolean isDuplicateTransaction() {
      * <p>
      * If <code>isSuccess() == false</code> this will return NULL.
      * 
-     * @return
+     * @return String
      */
     public String getAuthorizationCode() {
         return authorizationCode;
@@ -91,7 +91,7 @@ public String getAuthorizationCode() {
      * <p>
      * If <code>isSuccess() == false</code> this will return NULL.
      * 
-     * @return
+     * @return String
      */
     public String getTransactionID() {
         return transactionID;
@@ -102,7 +102,7 @@ public String getTransactionID() {
      * <p>
      * If <code>isSuccess() == true</code> this will return NULL.
      * 
-     * @return
+     * @return String
      */
     public String getErrorMessage() {
         return errorMessage;

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCommandMetrics.java
Patch:
@@ -334,7 +334,7 @@ public int getCurrentConcurrentExecutionCount() {
         }
     }
 
-    private volatile HealthCounts healthCountsSnapshot = null;
+    private volatile HealthCounts healthCountsSnapshot = new HealthCounts(0, 0, 0);
     private volatile AtomicLong lastHealthCountsSnapshot = new AtomicLong(System.currentTimeMillis());
 
     /**

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java
Patch:
@@ -1009,7 +1009,7 @@ private static String getDefaultNameFromClass(@SuppressWarnings("rawtypes") Clas
     @NotThreadSafe
     public static class Setter {
         private final HystrixCollapserKey collapserKey;
-        private Scope scope;
+        private Scope scope = Scope.REQUEST; // default if nothing is set
         private HystrixPropertiesStrategy propertiesStrategy;
         private HystrixCollapserProperties.Setter propertiesSetter;
         private HystrixConcurrencyStrategy concurrencyStrategy;

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java
Patch:
@@ -1009,7 +1009,7 @@ private static String getDefaultNameFromClass(@SuppressWarnings("rawtypes") Clas
     @NotThreadSafe
     public static class Setter {
         private final HystrixCollapserKey collapserKey;
-        private Scope scope;
+        private Scope scope = Scope.REQUEST; // default if nothing is set
         private HystrixPropertiesStrategy propertiesStrategy;
         private HystrixCollapserProperties.Setter propertiesSetter;
         private HystrixConcurrencyStrategy concurrencyStrategy;

File: hystrix-core/src/main/java/com/netflix/hystrix/HystrixCollapser.java
Patch:
@@ -853,7 +853,7 @@ public boolean isDone() {
         @Override
         public T get() throws InterruptedException, ExecutionException {
             try {
-                return get(15, TimeUnit.SECONDS); // use a maximum wait time instead of forever
+                return get(15, TimeUnit.SECONDS); // use a maximum wait time instead of forever (this is just a safety net to prevent permanently blocking if there is a bug somewhere)
             } catch (TimeoutException e) {
                 throw new ExecutionException("Timeout while waiting.", e);
             }

