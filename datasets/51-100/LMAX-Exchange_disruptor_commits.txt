File: src/main/java/com/lmax/disruptor/dsl/ConsumerRepository.java
Patch:
@@ -31,10 +31,8 @@
 
 /**
  * Provides a repository mechanism to associate {@link EventHandler}s with {@link EventProcessor}s
- *
- * @param <T> the type of the {@link EventHandler}
  */
-class ConsumerRepository<T>
+class ConsumerRepository
 {
     private final Map<EventHandlerIdentity, EventProcessorInfo> eventProcessorInfoByEventHandler =
         new IdentityHashMap<>();

File: src/main/java/com/lmax/disruptor/dsl/Disruptor.java
Patch:
@@ -63,7 +63,7 @@ public class Disruptor<T>
 {
     private final RingBuffer<T> ringBuffer;
     private final ThreadFactory threadFactory;
-    private final ConsumerRepository<T> consumerRepository = new ConsumerRepository<>();
+    private final ConsumerRepository consumerRepository = new ConsumerRepository();
     private final AtomicBoolean started = new AtomicBoolean(false);
     private ExceptionHandler<? super T> exceptionHandler = new ExceptionHandlerWrapper<>();
 

File: src/main/java/com/lmax/disruptor/dsl/EventHandlerGroup.java
Patch:
@@ -33,12 +33,12 @@
 public class EventHandlerGroup<T>
 {
     private final Disruptor<T> disruptor;
-    private final ConsumerRepository<T> consumerRepository;
+    private final ConsumerRepository consumerRepository;
     private final Sequence[] sequences;
 
     EventHandlerGroup(
         final Disruptor<T> disruptor,
-        final ConsumerRepository<T> consumerRepository,
+        final ConsumerRepository consumerRepository,
         final Sequence[] sequences)
     {
         this.disruptor = disruptor;

File: src/main/java/com/lmax/disruptor/dsl/ExceptionHandlerSetting.java
Patch:
@@ -30,11 +30,11 @@
 public class ExceptionHandlerSetting<T>
 {
     private final EventHandlerIdentity handlerIdentity;
-    private final ConsumerRepository<T> consumerRepository;
+    private final ConsumerRepository consumerRepository;
 
     ExceptionHandlerSetting(
         final EventHandlerIdentity handlerIdentity,
-        final ConsumerRepository<T> consumerRepository)
+        final ConsumerRepository consumerRepository)
     {
         this.handlerIdentity = handlerIdentity;
         this.consumerRepository = consumerRepository;

File: src/test/java/com/lmax/disruptor/dsl/ConsumerRepositoryTest.java
Patch:
@@ -21,7 +21,6 @@
 import com.lmax.disruptor.dsl.stubs.SleepingEventHandler;
 import com.lmax.disruptor.support.DummyEventProcessor;
 import com.lmax.disruptor.support.DummySequenceBarrier;
-import com.lmax.disruptor.support.TestEvent;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
@@ -34,7 +33,7 @@
 
 public class ConsumerRepositoryTest
 {
-    private ConsumerRepository<TestEvent> consumerRepository;
+    private ConsumerRepository consumerRepository;
     private EventProcessor eventProcessor1;
     private EventProcessor eventProcessor2;
     private SleepingEventHandler handler1;
@@ -45,7 +44,7 @@ public class ConsumerRepositoryTest
     @BeforeEach
     public void setUp()
     {
-        consumerRepository = new ConsumerRepository<>();
+        consumerRepository = new ConsumerRepository();
         eventProcessor1 = new DummyEventProcessor(new Sequence());
         eventProcessor2 = new DummyEventProcessor(new Sequence());
 

File: src/main/java/com/lmax/disruptor/EventHandlerBase.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.lmax.disruptor;
 
-interface EventHandlerBase<T> extends EventHandlerIdentity<T>
+interface EventHandlerBase<T> extends EventHandlerIdentity
 {
     /**
      * Called when a publisher has published an event to the {@link RingBuffer}.  The {@link BatchEventProcessor} will

File: src/main/java/com/lmax/disruptor/EventHandlerIdentity.java
Patch:
@@ -1,5 +1,5 @@
 package com.lmax.disruptor;
 
-public interface EventHandlerIdentity<T>
+public interface EventHandlerIdentity
 {
 }

File: src/main/java/com/lmax/disruptor/dsl/Disruptor.java
Patch:
@@ -502,8 +502,8 @@ EventHandlerGroup<T> createEventProcessors(
         {
             final EventHandler<? super T> eventHandler = eventHandlers[i];
 
-            final BatchEventProcessor<T> batchEventProcessor = new BatchEventProcessorBuilder()
-                    .build(ringBuffer, barrier, eventHandler);
+            final BatchEventProcessor<T> batchEventProcessor =
+                    new BatchEventProcessorBuilder().build(ringBuffer, barrier, eventHandler);
 
             if (exceptionHandler != null)
             {

File: src/test/java/com/lmax/disruptor/LifecycleAwareTest.java
Patch:
@@ -34,8 +34,7 @@ public final class LifecycleAwareTest
     private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
     private final LifecycleAwareEventHandler handler = new LifecycleAwareEventHandler();
     private final BatchEventProcessor<StubEvent> batchEventProcessor =
-            new BatchEventProcessorBuilder()
-                    .build(ringBuffer, sequenceBarrier, handler);
+            new BatchEventProcessorBuilder().build(ringBuffer, sequenceBarrier, handler);
 
     @Test
     public void shouldNotifyOfBatchProcessorLifecycle() throws Exception

File: src/test/java/com/lmax/disruptor/SequenceReportingCallbackTest.java
Patch:
@@ -35,8 +35,8 @@ public void shouldReportProgressByUpdatingSequenceViaCallback()
         final RingBuffer<StubEvent> ringBuffer = createMultiProducer(StubEvent.EVENT_FACTORY, 16);
         final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
         final EventHandler<StubEvent> handler = new TestSequenceReportingEventHandler();
-        final BatchEventProcessor<StubEvent> batchEventProcessor = new BatchEventProcessorBuilder()
-                .build(ringBuffer, sequenceBarrier, handler);
+        final BatchEventProcessor<StubEvent> batchEventProcessor = new BatchEventProcessorBuilder().build(
+                ringBuffer, sequenceBarrier, handler);
         ringBuffer.addGatingSequences(batchEventProcessor.getSequence());
 
         Thread thread = new Thread(batchEventProcessor);

File: src/main/java/com/lmax/disruptor/EventHandlerBase.java
Patch:
@@ -37,8 +37,9 @@ interface EventHandlerBase<T>
      * Invoked by {@link BatchEventProcessor} prior to processing a batch of events
      *
      * @param batchSize the size of the batch that is starting
+     * @param queueDepth the total number of queued up events including the batch about to be processed
      */
-    default void onBatchStart(long batchSize)
+    default void onBatchStart(long batchSize, long queueDepth)
     {
     }
 

File: src/perftest/java/com/lmax/disruptor/offheap/OneToOneOffHeapThroughputTest.java
Patch:
@@ -137,7 +137,7 @@ public void reset(final CountDownLatch latch, final long expectedCount)
         }
 
         @Override
-        public void onBatchStart(final long batchSize)
+        public void onBatchStart(final long batchSize, final long queueDepth)
         {
             batchesProcessed.increment();
         }

File: src/perftest/java/com/lmax/disruptor/offheap/OneToOneOnHeapThroughputTest.java
Patch:
@@ -141,7 +141,7 @@ public void reset(final CountDownLatch latch, final long expectedCount)
         }
 
         @Override
-        public void onBatchStart(final long batchSize)
+        public void onBatchStart(final long batchSize, final long queueDepth)
         {
             batchesProcessed.increment();
         }

File: src/perftest/java/com/lmax/disruptor/support/LongArrayEventHandler.java
Patch:
@@ -60,7 +60,7 @@ public void onEvent(final long[] event, final long sequence, final boolean endOf
     }
 
     @Override
-    public void onBatchStart(final long batchSize)
+    public void onBatchStart(final long batchSize, final long queueDepth)
     {
         batchesProcessed.increment();
     }

File: src/perftest/java/com/lmax/disruptor/support/ValueAdditionEventHandler.java
Patch:
@@ -57,7 +57,7 @@ public void onEvent(final ValueEvent event, final long sequence, final boolean e
     }
 
     @Override
-    public void onBatchStart(final long batchSize)
+    public void onBatchStart(final long batchSize, final long queueDepth)
     {
         batchesProcessed.increment();
     }

File: src/perftest/java/com/lmax/disruptor/support/ValueMutationEventHandler.java
Patch:
@@ -63,7 +63,7 @@ public void onEvent(final ValueEvent event, final long sequence, final boolean e
     }
 
     @Override
-    public void onBatchStart(final long batchSize)
+    public void onBatchStart(final long batchSize, final long queueDepth)
     {
         batchesProcessed.increment();
     }

File: src/test/java/com/lmax/disruptor/BatchEventProcessorTest.java
Patch:
@@ -162,7 +162,7 @@ final class LoopbackEventHandler
         {
 
             @Override
-            public void onBatchStart(final long batchSize)
+            public void onBatchStart(final long batchSize, final long queueDepth)
             {
                 batchSizes.add(batchSize);
             }
@@ -367,7 +367,7 @@ public void onEvent(final StubEvent event, final long sequence, final boolean en
         }
 
         @Override
-        public void onBatchStart(final long batchSize)
+        public void onBatchStart(final long batchSize, final long queueDepth)
         {
             final Integer currentCount = batchSizeToCountMap.get(batchSize);
             final int nextCount = null == currentCount ? 1 : currentCount + 1;

File: src/main/java/com/lmax/disruptor/BatchEventProcessor.java
Patch:
@@ -33,6 +33,7 @@ public final class BatchEventProcessor<T>
     private static final int IDLE = 0;
     private static final int HALTED = IDLE + 1;
     private static final int RUNNING = HALTED + 1;
+    private static final int DEFAULT_MAX_BATCH_SIZE = Integer.MAX_VALUE;
 
     private final AtomicInteger running = new AtomicInteger(IDLE);
     private ExceptionHandler<? super T> exceptionHandler;
@@ -86,7 +87,7 @@ public BatchEventProcessor(
             final EventHandler<? super T> eventHandler
     )
     {
-        this(dataProvider, sequenceBarrier, eventHandler, Integer.MAX_VALUE);
+        this(dataProvider, sequenceBarrier, eventHandler, DEFAULT_MAX_BATCH_SIZE);
     }
 
     @Override

File: src/examples/java/com/lmax/disruptor/examples/longevent/LongEvent.java
Patch:
@@ -9,9 +9,10 @@ public void set(long value)
     {
         this.value = value;
     }
-    
+
     @Override
-    public String toString() {
+    public String toString()
+    {
         return "LongEvent{" + "value=" + value + '}';
     }
 }

File: src/main/java/com/lmax/disruptor/RingBuffer.java
Patch:
@@ -57,7 +57,7 @@ abstract class RingBufferFields<E> extends RingBufferPad
         }
 
         this.indexMask = bufferSize - 1;
-        this.entries = (E[]) new Object[sequencer.getBufferSize() + 2 * BUFFER_PAD];
+        this.entries = (E[]) new Object[bufferSize + 2 * BUFFER_PAD];
         fill(eventFactory);
     }
 

File: src/examples/java/com/lmax/disruptor/examples/longevent/LongEventFactory.java
Patch:
@@ -5,6 +5,7 @@
 // tag::example[]
 public class LongEventFactory implements EventFactory<LongEvent>
 {
+    @Override
     public LongEvent newInstance()
     {
         return new LongEvent();

File: src/examples/java/com/lmax/disruptor/examples/longevent/LongEventHandler.java
Patch:
@@ -5,6 +5,7 @@
 // tag::example[]
 public class LongEventHandler implements EventHandler<LongEvent>
 {
+    @Override
     public void onEvent(LongEvent event, long sequence, boolean endOfBatch)
     {
         System.out.println("Event: " + event);

File: src/examples/java/com/lmax/disruptor/examples/longevent/LongEventProducer.java
Patch:
@@ -19,6 +19,7 @@ public LongEventProducer(RingBuffer<LongEvent> ringBuffer)
     private static final EventTranslatorOneArg<LongEvent, ByteBuffer> TRANSLATOR =
         new EventTranslatorOneArg<LongEvent, ByteBuffer>()
         {
+            @Override
             public void translateTo(LongEvent event, long sequence, ByteBuffer bb)
             {
                 event.set(bb.getLong(0));

File: src/examples/java/com/lmax/disruptor/examples/longevent/LongEventProducerWithTranslator.java
Patch:
@@ -18,6 +18,7 @@ public LongEventProducerWithTranslator(RingBuffer<LongEvent> ringBuffer)
     private static final EventTranslatorOneArg<LongEvent, ByteBuffer> TRANSLATOR =
         new EventTranslatorOneArg<LongEvent, ByteBuffer>()
         {
+            @Override
             public void translateTo(LongEvent event, long sequence, ByteBuffer bb)
             {
                 event.set(bb.getLong(0));

File: src/examples/java/com/lmax/disruptor/examples/objectevent/ClearingEventHandler.java
Patch:
@@ -5,6 +5,7 @@
 
 public class ClearingEventHandler<T> implements EventHandler<ObjectEvent<T>>
 {
+    @Override
     public void onEvent(ObjectEvent<T> event, long sequence, boolean endOfBatch)
     {
         event.clear(); // <1>

File: src/main/java/com/lmax/disruptor/RingBuffer.java
Patch:
@@ -440,6 +440,7 @@ public long getCursor()
      *
      * @return size of buffer
      */
+    @Override
     public int getBufferSize()
     {
         return bufferSize;
@@ -455,6 +456,7 @@ public int getBufferSize()
      * @return <code>true</code> If the specified <code>requiredCapacity</code> is available
      * <code>false</code> if not.
      */
+    @Override
     public boolean hasAvailableCapacity(final int requiredCapacity)
     {
         return sequencer.hasAvailableCapacity(requiredCapacity);
@@ -898,6 +900,7 @@ public void publish(final long lo, final long hi)
      *
      * @return The number of slots remaining.
      */
+    @Override
     public long remainingCapacity()
     {
         return sequencer.remainingCapacity();

File: src/test/java/com/lmax/disruptor/RewindBatchEventProcessorTest.java
Patch:
@@ -451,6 +451,7 @@ public void setRewindable(final BatchEventProcessor<LongEvent> processor)
             this.processor = processor;
         }
 
+        @Override
         public void onEvent(final LongEvent event, final long sequence, final boolean endOfBatch) throws Exception
         {
 

File: src/test/java/com/lmax/disruptor/alternatives/RingBufferArray.java
Patch:
@@ -459,6 +459,7 @@ public long getCursor()
      *
      * @return size of buffer
      */
+    @Override
     public int getBufferSize()
     {
         return bufferSize;
@@ -474,6 +475,7 @@ public int getBufferSize()
      * @return <code>true</code> If the specified <code>requiredCapacity</code> is available
      * <code>false</code> if not.
      */
+    @Override
     public boolean hasAvailableCapacity(final int requiredCapacity)
     {
         return sequencer.hasAvailableCapacity(requiredCapacity);
@@ -917,6 +919,7 @@ public void publish(final long lo, final long hi)
      *
      * @return The number of slots remaining.
      */
+    @Override
     public long remainingCapacity()
     {
         return sequencer.remainingCapacity();

File: src/test/java/com/lmax/disruptor/alternatives/RingBufferUnsafe.java
Patch:
@@ -472,6 +472,7 @@ public long getCursor()
      *
      * @return size of buffer
      */
+    @Override
     public int getBufferSize()
     {
         return bufferSize;
@@ -487,6 +488,7 @@ public int getBufferSize()
      * @return <code>true</code> If the specified <code>requiredCapacity</code> is available
      * <code>false</code> if not.
      */
+    @Override
     public boolean hasAvailableCapacity(final int requiredCapacity)
     {
         return sequencer.hasAvailableCapacity(requiredCapacity);
@@ -930,6 +932,7 @@ public void publish(final long lo, final long hi)
      *
      * @return The number of slots remaining.
      */
+    @Override
     public long remainingCapacity()
     {
         return sequencer.remainingCapacity();

File: src/test/java/com/lmax/disruptor/dsl/stubs/StubExceptionHandler.java
Patch:
@@ -28,6 +28,7 @@ public StubExceptionHandler(final AtomicReference<Throwable> exceptionHandled)
         this.exceptionHandled = exceptionHandled;
     }
 
+    @Override
     public void handleEventException(final Throwable ex, final long sequence, final Object event)
     {
         exceptionHandled.set(ex);

File: src/main/java/com/lmax/disruptor/SingleProducerSequencer.java
Patch:
@@ -71,7 +71,8 @@ public final class SingleProducerSequencer extends SingleProducerSequencerFields
         p70, p71, p72, p73, p74, p75, p76, p77;
 
     /**
-     * <p>Only used when assertions are enabled.
+     * Only used when assertions are enabled.
+     *
      * <p>Used for asserting that only one thread publishes to this Sequencer.
      * I.e. helps developers detect early if they use the wrong
      * {@link com.lmax.disruptor.dsl.ProducerType}.

File: src/examples/java/com/lmax/disruptor/examples/longevent/LongEventFactory.java
Patch:
@@ -5,6 +5,7 @@
 // tag::example[]
 public class LongEventFactory implements EventFactory<LongEvent>
 {
+    @Override
     public LongEvent newInstance()
     {
         return new LongEvent();

File: src/examples/java/com/lmax/disruptor/examples/longevent/LongEventHandler.java
Patch:
@@ -5,6 +5,7 @@
 // tag::example[]
 public class LongEventHandler implements EventHandler<LongEvent>
 {
+    @Override
     public void onEvent(LongEvent event, long sequence, boolean endOfBatch)
     {
         System.out.println("Event: " + event);

File: src/examples/java/com/lmax/disruptor/examples/longevent/LongEventProducer.java
Patch:
@@ -19,6 +19,7 @@ public LongEventProducer(RingBuffer<LongEvent> ringBuffer)
     private static final EventTranslatorOneArg<LongEvent, ByteBuffer> TRANSLATOR =
         new EventTranslatorOneArg<LongEvent, ByteBuffer>()
         {
+            @Override
             public void translateTo(LongEvent event, long sequence, ByteBuffer bb)
             {
                 event.set(bb.getLong(0));

File: src/examples/java/com/lmax/disruptor/examples/longevent/LongEventProducerWithTranslator.java
Patch:
@@ -18,6 +18,7 @@ public LongEventProducerWithTranslator(RingBuffer<LongEvent> ringBuffer)
     private static final EventTranslatorOneArg<LongEvent, ByteBuffer> TRANSLATOR =
         new EventTranslatorOneArg<LongEvent, ByteBuffer>()
         {
+            @Override
             public void translateTo(LongEvent event, long sequence, ByteBuffer bb)
             {
                 event.set(bb.getLong(0));

File: src/examples/java/com/lmax/disruptor/examples/objectevent/ClearingEventHandler.java
Patch:
@@ -5,6 +5,7 @@
 
 public class ClearingEventHandler<T> implements EventHandler<ObjectEvent<T>>
 {
+    @Override
     public void onEvent(ObjectEvent<T> event, long sequence, boolean endOfBatch)
     {
         event.clear(); // <1>

File: src/main/java/com/lmax/disruptor/RingBuffer.java
Patch:
@@ -440,6 +440,7 @@ public long getCursor()
      *
      * @return size of buffer
      */
+    @Override
     public int getBufferSize()
     {
         return bufferSize;
@@ -455,6 +456,7 @@ public int getBufferSize()
      * @return <code>true</code> If the specified <code>requiredCapacity</code> is available
      * <code>false</code> if not.
      */
+    @Override
     public boolean hasAvailableCapacity(final int requiredCapacity)
     {
         return sequencer.hasAvailableCapacity(requiredCapacity);
@@ -898,6 +900,7 @@ public void publish(final long lo, final long hi)
      *
      * @return The number of slots remaining.
      */
+    @Override
     public long remainingCapacity()
     {
         return sequencer.remainingCapacity();

File: src/test/java/com/lmax/disruptor/RewindBatchEventProcessorTest.java
Patch:
@@ -451,6 +451,7 @@ public void setRewindable(final BatchEventProcessor<LongEvent> processor)
             this.processor = processor;
         }
 
+        @Override
         public void onEvent(final LongEvent event, final long sequence, final boolean endOfBatch) throws Exception
         {
 

File: src/test/java/com/lmax/disruptor/alternatives/RingBufferArray.java
Patch:
@@ -459,6 +459,7 @@ public long getCursor()
      *
      * @return size of buffer
      */
+    @Override
     public int getBufferSize()
     {
         return bufferSize;
@@ -474,6 +475,7 @@ public int getBufferSize()
      * @return <code>true</code> If the specified <code>requiredCapacity</code> is available
      * <code>false</code> if not.
      */
+    @Override
     public boolean hasAvailableCapacity(final int requiredCapacity)
     {
         return sequencer.hasAvailableCapacity(requiredCapacity);
@@ -917,6 +919,7 @@ public void publish(final long lo, final long hi)
      *
      * @return The number of slots remaining.
      */
+    @Override
     public long remainingCapacity()
     {
         return sequencer.remainingCapacity();

File: src/test/java/com/lmax/disruptor/alternatives/RingBufferUnsafe.java
Patch:
@@ -472,6 +472,7 @@ public long getCursor()
      *
      * @return size of buffer
      */
+    @Override
     public int getBufferSize()
     {
         return bufferSize;
@@ -487,6 +488,7 @@ public int getBufferSize()
      * @return <code>true</code> If the specified <code>requiredCapacity</code> is available
      * <code>false</code> if not.
      */
+    @Override
     public boolean hasAvailableCapacity(final int requiredCapacity)
     {
         return sequencer.hasAvailableCapacity(requiredCapacity);
@@ -930,6 +932,7 @@ public void publish(final long lo, final long hi)
      *
      * @return The number of slots remaining.
      */
+    @Override
     public long remainingCapacity()
     {
         return sequencer.remainingCapacity();

File: src/test/java/com/lmax/disruptor/dsl/stubs/StubExceptionHandler.java
Patch:
@@ -28,6 +28,7 @@ public StubExceptionHandler(final AtomicReference<Throwable> exceptionHandled)
         this.exceptionHandled = exceptionHandled;
     }
 
+    @Override
     public void handleEventException(final Throwable ex, final long sequence, final Object event)
     {
         exceptionHandled.set(ex);

File: src/main/java/com/lmax/disruptor/ExceptionHandler.java
Patch:
@@ -35,14 +35,14 @@ public interface ExceptionHandler<T>
     void handleEventException(Throwable ex, long sequence, T event);
 
     /**
-     * Callback to notify of an exception during {@link LifecycleAware#onStart()}
+     * Callback to notify of an exception during {@link EventHandler#onStart()}
      *
      * @param ex throw during the starting process.
      */
     void handleOnStartException(Throwable ex);
 
     /**
-     * Callback to notify of an exception during {@link LifecycleAware#onShutdown()}
+     * Callback to notify of an exception during {@link EventHandler#onShutdown()}
      *
      * @param ex throw during the shutdown process.
      */

File: src/main/java/com/lmax/disruptor/TimeoutBlockingWaitStrategy.java
Patch:
@@ -7,8 +7,8 @@
 /**
  * Blocking strategy that uses a lock and condition variable for {@link EventProcessor}s waiting on a barrier.
  * However it will periodically wake up if it has been idle for specified period by throwing a
- * {@link TimeoutException}.  To make use of this, the event handler class should implement the {@link TimeoutHandler},
- * which the {@link BatchEventProcessor} will call if the timeout occurs.
+ * {@link TimeoutException}.  To make use of this, the event handler class should override
+ * {@link EventHandler#onTimeout(long)}, which the {@link BatchEventProcessor} will call if the timeout occurs.
  *
  * <p>This strategy can be used when throughput and low-latency are not as important as CPU resource.
  */

File: src/examples/java/com/lmax/disruptor/examples/EarlyReleaseHandler.java
Patch:
@@ -1,12 +1,12 @@
 package com.lmax.disruptor.examples;
 
+import com.lmax.disruptor.EventHandler;
 import com.lmax.disruptor.Sequence;
-import com.lmax.disruptor.SequenceReportingEventHandler;
 import com.lmax.disruptor.examples.support.LongEvent;
 
 @SuppressWarnings("unused")
 // tag::example[]
-public class EarlyReleaseHandler implements SequenceReportingEventHandler<LongEvent>
+public class EarlyReleaseHandler implements EventHandler<LongEvent>
 {
     private Sequence sequenceCallback;
     private int batchRemaining = 20;

File: src/main/java/com/lmax/disruptor/BatchStartAware.java
Patch:
@@ -9,5 +9,7 @@ public interface BatchStartAware
      * Invoked by {@link BatchEventProcessor} prior to processing a batch of events
      * @param batchSize the size of the batch that is starting
      */
-    void onBatchStart(long batchSize);
+    default void onBatchStart(long batchSize)
+    {
+    }
 }

File: src/main/java/com/lmax/disruptor/EventHandler.java
Patch:
@@ -21,7 +21,7 @@
  * @param <T> event implementation storing the data for sharing during exchange or parallel coordination of an event.
  * @see BatchEventProcessor#setExceptionHandler(ExceptionHandler) if you want to handle exceptions propagated out of the handler.
  */
-public interface EventHandler<T>
+public interface EventHandler<T> extends BatchStartAware, LifecycleAware, SequenceReportingEventHandler<T>, TimeoutHandler
 {
     /**
      * Called when a publisher has published an event to the {@link RingBuffer}.  The {@link BatchEventProcessor} will

File: src/main/java/com/lmax/disruptor/SequenceReportingEventHandler.java
Patch:
@@ -26,12 +26,13 @@
  * @param <T> event implementation storing the data for sharing during exchange or parallel coordination of an event.
  */
 public interface SequenceReportingEventHandler<T>
-    extends EventHandler<T>
 {
     /**
      * Call by the {@link BatchEventProcessor} to setup the callback.
      *
      * @param sequenceCallback callback on which to notify the {@link BatchEventProcessor} that the sequence has progressed.
      */
-    void setSequenceCallback(Sequence sequenceCallback);
+    default void setSequenceCallback(Sequence sequenceCallback)
+    {
+    }
 }

File: src/main/java/com/lmax/disruptor/TimeoutHandler.java
Patch:
@@ -13,5 +13,7 @@ public interface TimeoutHandler
      * @param sequence - the last processed sequence.
      * @throws Exception if the implementation is unable to handle this timeout.
      */
-    void onTimeout(long sequence) throws Exception;
+    default void onTimeout(long sequence) throws Exception
+    {
+    }
 }

File: src/test/java/com/lmax/disruptor/SequenceReportingCallbackTest.java
Patch:
@@ -34,7 +34,7 @@ public void shouldReportProgressByUpdatingSequenceViaCallback()
     {
         final RingBuffer<StubEvent> ringBuffer = createMultiProducer(StubEvent.EVENT_FACTORY, 16);
         final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();
-        final SequenceReportingEventHandler<StubEvent> handler = new TestSequenceReportingEventHandler();
+        final EventHandler<StubEvent> handler = new TestSequenceReportingEventHandler();
         final BatchEventProcessor<StubEvent> batchEventProcessor = new BatchEventProcessor<>(
                 ringBuffer, sequenceBarrier, handler);
         ringBuffer.addGatingSequences(batchEventProcessor.getSequence());
@@ -56,7 +56,7 @@ public void shouldReportProgressByUpdatingSequenceViaCallback()
         thread.join();
     }
 
-    private class TestSequenceReportingEventHandler implements SequenceReportingEventHandler<StubEvent>
+    private class TestSequenceReportingEventHandler implements EventHandler<StubEvent>
     {
         private Sequence sequenceCallback;
 

File: src/main/java/com/lmax/disruptor/EventPoller.java
Patch:
@@ -109,7 +109,7 @@ public PollState poll(final Handler<T> eventHandler) throws Exception
                     nextSequence++;
 
                 }
-                while (nextSequence <= availableSequence & processNextEvent);
+                while (nextSequence <= availableSequence && processNextEvent);
             }
             finally
             {

File: src/main/java/com/lmax/disruptor/util/DaemonThreadFactory.java
Patch:
@@ -22,6 +22,9 @@
  */
 public enum DaemonThreadFactory implements ThreadFactory
 {
+    /**
+     * The singleton instance
+     */
     INSTANCE;
 
     @Override

File: src/main/java/com/lmax/disruptor/SimpleBatchRewindStrategy.java
Patch:
@@ -1,5 +1,8 @@
 package com.lmax.disruptor;
 
+/**
+ * Batch rewind strategy that always rewinds
+ */
 public class SimpleBatchRewindStrategy implements BatchRewindStrategy
 {
     @Override

File: src/main/java/module-info.java
Patch:
@@ -1,7 +1,7 @@
-module disruptor.main {
+module com.lmax.disruptor {
     requires jdk.unsupported; // Temporarily required for sum.misc.Unsafe until Unsafe is removed
 
     exports com.lmax.disruptor;
     exports com.lmax.disruptor.dsl;
     exports com.lmax.disruptor.util;
-}
\ No newline at end of file
+}

File: src/main/java/module-info.java
Patch:
@@ -1,7 +1,7 @@
-module disruptor.main {
+module com.lmax.disruptor {
     requires jdk.unsupported; // Temporarily required for sum.misc.Unsafe until Unsafe is removed
 
     exports com.lmax.disruptor;
     exports com.lmax.disruptor.dsl;
     exports com.lmax.disruptor.util;
-}
\ No newline at end of file
+}

File: src/main/java/com/lmax/disruptor/SleepingWaitStrategy.java
Patch:
@@ -30,6 +30,7 @@
  */
 public final class SleepingWaitStrategy implements WaitStrategy
 {
+    private static final int SPIN_THRESHOLD = 100;
     private static final int DEFAULT_RETRIES = 200;
     private static final long DEFAULT_SLEEP = 100;
 
@@ -78,7 +79,7 @@ private int applyWaitMethod(final SequenceBarrier barrier, final int counter)
     {
         barrier.checkAlert();
 
-        if (counter > 100)
+        if (counter > SPIN_THRESHOLD)
         {
             return counter - 1;
         }

File: src/test/java/com/lmax/disruptor/alternatives/SequenceVarHandle.java
Patch:
@@ -121,7 +121,7 @@ public void setVolatile(final long value)
      */
     public boolean compareAndSet(final long expectedValue, final long newValue)
     {
-        return (boolean) VALUE_FIELD.compareAndSet(this, expectedValue, newValue);
+        return VALUE_FIELD.compareAndSet(this, expectedValue, newValue);
     }
 
     /**
@@ -142,8 +142,7 @@ public long incrementAndGet()
      */
     public long addAndGet(final long increment)
     {
-        final long oldValue = (Long) VALUE_FIELD.getAndAdd(this, increment);
-        return oldValue + increment;
+        return (long) VALUE_FIELD.getAndAdd(this, increment) + increment;
     }
 
     @Override

File: src/test/java/com/lmax/disruptor/alternatives/SequenceVarHandleArray.java
Patch:
@@ -83,7 +83,7 @@ public void setVolatile(final long value)
      */
     public boolean compareAndSet(final long expectedValue, final long newValue)
     {
-        return (boolean) VALUE_FIELD.compareAndSet(this.paddedValue, VALUE_INDEX, expectedValue, newValue);
+        return VALUE_FIELD.compareAndSet(this.paddedValue, VALUE_INDEX, expectedValue, newValue);
     }
 
     /**
@@ -104,8 +104,7 @@ public long incrementAndGet()
      */
     public long addAndGet(final long increment)
     {
-        final long oldValue = (Long) VALUE_FIELD.getAndAdd(this.paddedValue, VALUE_INDEX, increment);
-        return oldValue + increment;
+        return (long) VALUE_FIELD.getAndAdd(this.paddedValue, VALUE_INDEX, increment) + increment;
     }
 
     @Override

File: src/main/java/com/lmax/disruptor/AlertException.java
Patch:
@@ -20,7 +20,7 @@
  * <p>
  * It does not fill in a stack trace for performance reasons.
  */
-@SuppressWarnings("serial")
+@SuppressWarnings({"serial", "lgtm[java/non-sync-override]"})
 public final class AlertException extends Exception
 {
     /**

File: src/main/java/com/lmax/disruptor/InsufficientCapacityException.java
Patch:
@@ -22,7 +22,7 @@
  *
  * <p>For efficiency this exception will not have a stack trace.</p>
  */
-@SuppressWarnings("serial")
+@SuppressWarnings({"serial", "lgtm[java/non-sync-override]"})
 public final class InsufficientCapacityException extends Exception
 {
     public static final InsufficientCapacityException INSTANCE = new InsufficientCapacityException();

File: src/main/java/com/lmax/disruptor/TimeoutException.java
Patch:
@@ -1,6 +1,6 @@
 package com.lmax.disruptor;
 
-@SuppressWarnings("serial")
+@SuppressWarnings({"serial", "lgtm[java/non-sync-override]"})
 public final class TimeoutException extends Exception
 {
     public static final TimeoutException INSTANCE = new TimeoutException();

File: src/test/java/com/lmax/disruptor/FixedSequenceGroupTest.java
Patch:
@@ -15,10 +15,10 @@
  */
 package com.lmax.disruptor;
 
-import static org.hamcrest.CoreMatchers.is;
-import static org.junit.Assert.assertThat;
+import org.junit.jupiter.api.Test;
 
-import org.junit.Test;
+import static org.hamcrest.CoreMatchers.is;
+import static org.hamcrest.MatcherAssert.assertThat;
 
 
 public class FixedSequenceGroupTest

File: src/jmh/java/com/lmax/disruptor/util/SimpleEventHandler.java
Patch:
@@ -8,7 +8,8 @@ public class SimpleEventHandler implements EventHandler<SimpleEvent>
 {
     private final AtomicLong eventsHandled;
 
-    public SimpleEventHandler(final AtomicLong eventsHandled) {
+    public SimpleEventHandler(final AtomicLong eventsHandled)
+    {
         this.eventsHandled = eventsHandled;
     }
 

File: src/jmh/java/com/lmax/disruptor/SimpleBenchmark.java
Patch:
@@ -76,7 +76,6 @@ public static void main(String[] args) throws RunnerException
     {
         Options opt = new OptionsBuilder()
                 .include(SimpleBenchmark.class.getSimpleName())
-                .threads(4)
                 .forks(1)
                 .build();
         new Runner(opt).run();

File: src/main/java/com/lmax/disruptor/WorkProcessor.java
Patch:
@@ -137,7 +137,8 @@ public void run()
 
                 if (processedSequence)
                 {
-                    if (!running.get()){
+                    if (!running.get())
+                    {
                         sequenceBarrier.alert();
                         sequenceBarrier.checkAlert();
                     }

File: src/test/java/com/lmax/disruptor/BatchEventProcessorTest.java
Patch:
@@ -23,7 +23,8 @@
 import java.util.concurrent.TimeUnit;
 
 import static com.lmax.disruptor.RingBuffer.createMultiProducer;
-import static org.hamcrest.CoreMatchers.*;
+import static org.hamcrest.CoreMatchers.not;
+import static org.hamcrest.CoreMatchers.nullValue;
 import static org.junit.Assert.*;
 
 public final class BatchEventProcessorTest
@@ -305,7 +306,7 @@ private static class DelegatingSequenceBarrier implements SequenceBarrier
         private SequenceBarrier delegate;
         private boolean suppress = true;
 
-        public DelegatingSequenceBarrier(SequenceBarrier delegate)
+        DelegatingSequenceBarrier(SequenceBarrier delegate)
         {
             this.delegate = delegate;
         }

File: src/main/java/com/lmax/disruptor/EventHandler.java
Patch:
@@ -29,7 +29,7 @@ public interface EventHandler<T>
      * processed without having to wait for any new event to arrive.  This can be useful for event handlers that need
      * to do slower operations like I/O as they can group together the data from multiple events into a single
      * operation.  Implementations should ensure that the operation is always performed when endOfBatch is true as
-     * the time between that message an the next one is inderminate.
+     * the time between that message and the next one is indeterminate.
      *
      * @param event      published to the {@link RingBuffer}
      * @param sequence   of the event being processed

File: src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedBatchThroughputTest.java
Patch:
@@ -111,7 +111,7 @@ protected PerfTestContext runDisruptorPass() throws InterruptedException
 
         latch.await();
         perfTestContext.setDisruptorOps((BATCH_SIZE * ITERATIONS * 1000L) / (System.currentTimeMillis() - start));
-        perfTestContext.setBatchData(handler.getBatchesProcessed(), ITERATIONS);
+        perfTestContext.setBatchData(handler.getBatchesProcessed(), ITERATIONS * BATCH_SIZE);
         waitForEventProcessorSequence(expectedCount);
         batchEventProcessor.halt();
 

File: src/perftest/java/com/lmax/disruptor/AbstractPerfTestDisruptor.java
Patch:
@@ -21,7 +21,8 @@ public abstract class AbstractPerfTestDisruptor
     public static final int RUNS = 7;
 
     protected void testImplementations()
-        throws Exception {
+        throws Exception
+    {
         final int availableProcessors = Runtime.getRuntime().availableProcessors();
         if (getRequiredProcessorCount() > availableProcessors)
         {

File: src/perftest/java/com/lmax/disruptor/PerfTestContext.java
Patch:
@@ -21,6 +21,7 @@ public long getBatchesProcessedCount() {
     }
 
     public double getBatchPercent() {
+        if (batchesProcessedCount == 0) return 0;
         return 1 - (double)batchesProcessedCount / iterations;
     }
 

File: src/test/java/com/lmax/disruptor/example/ShutdownOnError.java
Patch:
@@ -16,7 +16,7 @@ private static class Event
     {
         public long value;
 
-        public static EventFactory<Event> FACTORY = new EventFactory<Event>()
+        public static final EventFactory<Event> FACTORY = new EventFactory<Event>()
         {
             @Override
             public Event newInstance()
@@ -44,11 +44,11 @@ public void onEvent(Event event, long sequence, boolean endOfBatch) throws Excep
         }
     }
 
-    private static class ErrorHandler implements ExceptionHandler<Event>
+    private static final class ErrorHandler implements ExceptionHandler<Event>
     {
         private final AtomicBoolean running;
 
-        public ErrorHandler(AtomicBoolean running)
+        private ErrorHandler(AtomicBoolean running)
         {
             this.running = running;
         }

File: src/main/java/com/lmax/disruptor/AggregateEventHandler.java
Patch:
@@ -30,6 +30,7 @@ public final class AggregateEventHandler<T>
      *
      * @param eventHandlers to be called in sequence.
      */
+    @SafeVarargs
     public AggregateEventHandler(final EventHandler<T>... eventHandlers)
     {
         this.eventHandlers = eventHandlers;

File: src/main/java/com/lmax/disruptor/SequenceGroup.java
Patch:
@@ -60,9 +60,9 @@ public long get()
     public void set(final long value)
     {
         final Sequence[] sequences = this.sequences;
-        for (int i = 0, size = sequences.length; i < size; i++)
+        for (Sequence sequence : sequences)
         {
-            sequences[i].set(value);
+            sequence.set(value);
         }
     }
 

File: src/main/java/com/lmax/disruptor/dsl/BasicExecutor.java
Patch:
@@ -11,7 +11,7 @@
 public class BasicExecutor implements Executor
 {
     private final ThreadFactory factory;
-    private final Queue<Thread> threads = new ConcurrentLinkedQueue<Thread>();
+    private final Queue<Thread> threads = new ConcurrentLinkedQueue<>();
 
     public BasicExecutor(ThreadFactory factory)
     {

File: src/main/java/com/lmax/disruptor/AbstractSequencer.java
Patch:
@@ -39,7 +39,7 @@ public abstract class AbstractSequencer implements Sequencer
      * Create with the specified buffer size and wait strategy.
      *
      * @param bufferSize   The total number of entries, must be a positive power of 2.
-     * @param waitStrategy
+     * @param waitStrategy The wait strategy used by this sequencer
      */
     public AbstractSequencer(int bufferSize, WaitStrategy waitStrategy)
     {

File: src/main/java/com/lmax/disruptor/EventTranslator.java
Patch:
@@ -17,7 +17,7 @@
 
 /**
  * <p>Implementations translate (write) data representations into events claimed from the {@link RingBuffer}.</p>
- * <p>
+ *
  * <p>When publishing to the RingBuffer, provide an EventTranslator. The RingBuffer will select the next available
  * event by sequence and provide it to the EventTranslator (which should update the event), before publishing
  * the sequence update.</p>

File: src/main/java/com/lmax/disruptor/ExceptionHandler.java
Patch:
@@ -22,7 +22,7 @@ public interface ExceptionHandler<T>
 {
     /**
      * <p>Strategy for handling uncaught exceptions when processing an event.</p>
-     * <p>
+     *
      * <p>If the strategy wishes to terminate further processing by the {@link BatchEventProcessor}
      * then it should throw a {@link RuntimeException}.</p>
      *

File: src/main/java/com/lmax/disruptor/InsufficientCapacityException.java
Patch:
@@ -18,9 +18,9 @@
 /**
  * <p>Exception thrown when it is not possible to insert a value into
  * the ring buffer without it wrapping the consuming sequences.  Used
- * specifically when claiming with the {@link RingBuffer#tryNext()} call.
- * <p>
- * <p>For efficiency this exception will not have a stack trace.
+ * specifically when claiming with the {@link RingBuffer#tryNext()} call.</p>
+ *
+ * <p>For efficiency this exception will not have a stack trace.</p>
  */
 @SuppressWarnings("serial")
 public final class InsufficientCapacityException extends Exception

File: src/main/java/com/lmax/disruptor/MultiProducerSequencer.java
Patch:
@@ -25,10 +25,10 @@
 /**
  * <p>Coordinator for claiming sequences for access to a data structure while tracking dependent {@link Sequence}s.
  * Suitable for use for sequencing across multiple publisher threads.</p>
- * <p>
- * <p> * <p>Note on {@link Sequencer#getCursor()}:  With this sequencer the cursor value is updated after the call
+ *
+ * <p> * Note on {@link Sequencer#getCursor()}:  With this sequencer the cursor value is updated after the call
  * to {@link Sequencer#next()}, to determine the highest available sequence that can be read, then
- * {@link Sequencer#getHighestPublishedSequence(long, long)} should be used.
+ * {@link Sequencer#getHighestPublishedSequence(long, long)} should be used.</p>
  */
 public final class MultiProducerSequencer extends AbstractSequencer
 {

File: src/main/java/com/lmax/disruptor/SequenceBarrier.java
Patch:
@@ -29,7 +29,7 @@ public interface SequenceBarrier
      * @return the sequence up to which is available
      * @throws AlertException       if a status change has occurred for the Disruptor
      * @throws InterruptedException if the thread needs awaking on a condition variable.
-     * @throws TimeoutException
+     * @throws TimeoutException     if a timeout occurs while waiting for the supplied sequence.
      */
     long waitFor(long sequence) throws AlertException, InterruptedException, TimeoutException;
 

File: src/main/java/com/lmax/disruptor/Sequenced.java
Patch:
@@ -56,7 +56,7 @@ public interface Sequenced
      * available.
      *
      * @return the claimed sequence value
-     * @throws InsufficientCapacityException
+     * @throws InsufficientCapacityException thrown if there is no space available in the ring buffer.
      */
     long tryNext() throws InsufficientCapacityException;
 
@@ -68,14 +68,14 @@ public interface Sequenced
      *
      * @param n the number of sequences to claim
      * @return the claimed sequence value
-     * @throws InsufficientCapacityException
+     * @throws InsufficientCapacityException thrown if there is no space available in the ring buffer.
      */
     long tryNext(int n) throws InsufficientCapacityException;
 
     /**
      * Publishes a sequence. Call when the event has been filled.
      *
-     * @param sequence
+     * @param sequence the sequence to be published.
      */
     void publish(long sequence);
 

File: src/main/java/com/lmax/disruptor/Sequencer.java
Patch:
@@ -61,7 +61,7 @@ public interface Sequencer extends Cursored, Sequenced
      * Create a new SequenceBarrier to be used by an EventProcessor to track which messages
      * are available to be read from the ring buffer given a list of sequences to track.
      *
-     * @param sequencesToTrack
+     * @param sequencesToTrack All of the sequences that the newly constructed barrier will wait on.
      * @return A sequence barrier that will track the specified sequences.
      * @see SequenceBarrier
      */

File: src/main/java/com/lmax/disruptor/SingleProducerSequencer.java
Patch:
@@ -46,9 +46,9 @@ public SingleProducerSequencerFields(int bufferSize, WaitStrategy waitStrategy)
 /**
  * <p>Coordinator for claiming sequences for access to a data structure while tracking dependent {@link Sequence}s.
  * Not safe for use from multiple threads as it does not implement any barriers.</p>
- * <p>
- * <p>Note on {@link Sequencer#getCursor()}:  With this sequencer the cursor value is updated after the call
- * to {@link Sequencer#publish(long)} is made.
+ *
+ * <p>* Note on {@link Sequencer#getCursor()}:  With this sequencer the cursor value is updated after the call
+ * to {@link Sequencer#publish(long)} is made.</p>
  */
 
 public final class SingleProducerSequencer extends SingleProducerSequencerFields

File: src/main/java/com/lmax/disruptor/WaitStrategy.java
Patch:
@@ -36,7 +36,7 @@ public interface WaitStrategy
      * @return the sequence that is available which may be greater than the requested sequence.
      * @throws AlertException       if the status of the Disruptor has changed.
      * @throws InterruptedException if the thread is interrupted.
-     * @throws TimeoutException
+     * @throws TimeoutException if a timeout occurs before waiting completes (not used by some strategies)
      */
     long waitFor(long sequence, Sequence cursor, Sequence dependentSequence, SequenceBarrier barrier)
         throws AlertException, InterruptedException, TimeoutException;

File: src/main/java/com/lmax/disruptor/WorkProcessor.java
Patch:
@@ -20,7 +20,7 @@
 /**
  * <p>A {@link WorkProcessor} wraps a single {@link WorkHandler}, effectively consuming the sequence
  * and ensuring appropriate barriers.</p>
- * <p>
+ *
  * <p>Generally, this will be used as part of a {@link WorkerPool}.</p>
  *
  * @param <T> event implementation storing the details for the work to processed.

File: src/main/java/com/lmax/disruptor/dsl/EventProcessorFactory.java
Patch:
@@ -16,6 +16,7 @@ public interface EventProcessorFactory<T>
     /**
      * Create a new event processor that gates on <code>barrierSequences</code>.
      *
+     * @param ringBuffer the ring buffer to receive events from.
      * @param barrierSequences the sequences to gate on
      * @return a new EventProcessor that gates on <code>barrierSequences</code> before processing events
      */

File: src/main/java/com/lmax/disruptor/util/Util.java
Patch:
@@ -129,7 +129,7 @@ public static Unsafe getUnsafe()
     /**
      * Gets the address value for the memory that backs a direct byte buffer.
      *
-     * @param buffer
+     * @param buffer a direct buffer to get the address from.
      * @return The system address for the buffers
      */
     public static long getAddressFromDirectByteBuffer(ByteBuffer buffer)

File: src/test/java/com/lmax/disruptor/dsl/DisruptorTest.java
Patch:
@@ -96,7 +96,7 @@ public void tearDown() throws Exception
     @Test
     public void shouldProcessMessagesPublishedBeforeStartIsCalled() throws Exception
     {
-        final CountDownLatch eventCounter = new CountDownLatch(0);
+        final CountDownLatch eventCounter = new CountDownLatch(2);
         disruptor.handleEventsWith(new EventHandler<TestEvent>()
         {
             @Override

File: src/main/java/com/lmax/disruptor/RingBuffer.java
Patch:
@@ -433,7 +433,7 @@ public int getBufferSize()
      *
      * @param requiredCapacity The capacity to check for.
      * @return <tt>true</tt> If the specified <tt>requiredCapacity</tt> is available
-     * <tt>false</tt> if now.
+     * <tt>false</tt> if not.
      */
     public boolean hasAvailableCapacity(int requiredCapacity)
     {

File: src/main/java/com/lmax/disruptor/Sequencer.java
Patch:
@@ -82,7 +82,7 @@ public interface Sequencer extends Cursored, Sequenced
      * in the Sequencer.  The scan will range from nextSequence to availableSequence.  If
      * there are no available values <code>&gt;= nextSequence</code> the return value will be
      * <code>nextSequence - 1</code>.  To work correctly a consumer should pass a value that
-     * it 1 higher than the last sequence that was successfully processed.
+     * is 1 higher than the last sequence that was successfully processed.
      *
      * @param nextSequence      The sequence to start scanning from.
      * @param availableSequence The sequence to scan to.

File: src/main/java/com/lmax/disruptor/dsl/EventProcessorInfo.java
Patch:
@@ -27,7 +27,7 @@
  * <p>
  * <p>Tracks the event processor instance, the event handler instance, and sequence barrier which the stage is attached to.</p>
  *
- * @param T the type of the configured {@link EventHandler}
+ * @param <T> the type of the configured {@link EventHandler}
  */
 class EventProcessorInfo<T> implements ConsumerInfo
 {

File: src/perftest/java/com/lmax/disruptor/sequenced/ThreeToOneSequencedBatchThroughputTest.java
Patch:
@@ -76,9 +76,7 @@
  * EP1 - EventProcessor 1
  *
  * </pre>
- */
-
-/**
+ *
  * @author mikeb01
  */
 public final class ThreeToOneSequencedBatchThroughputTest extends AbstractPerfTestDisruptor

File: src/test/java/com/lmax/disruptor/RingBufferTest.java
Patch:
@@ -1240,13 +1240,13 @@ public void shouldAddAndRemoveSequences() throws Exception
     }
 
     @Test
-    public void shouldHandleResetToAndNotWrapUnecessarilySingleProducer() throws Exception
+    public void shouldHandleResetToAndNotWrapUnnecessarilySingleProducer() throws Exception
     {
         assertHandleResetAndNotWrap(RingBuffer.createSingleProducer(StubEvent.EVENT_FACTORY, 4));
     }
 
     @Test
-    public void shouldHandleResetToAndNotWrapUnecessarilyMultiProducer() throws Exception
+    public void shouldHandleResetToAndNotWrapUnnecessarilyMultiProducer() throws Exception
     {
         assertHandleResetAndNotWrap(RingBuffer.createMultiProducer(StubEvent.EVENT_FACTORY, 4));
     }

File: src/main/java/com/lmax/disruptor/RingBuffer.java
Patch:
@@ -433,7 +433,7 @@ public int getBufferSize()
      *
      * @param requiredCapacity The capacity to check for.
      * @return <tt>true</tt> If the specified <tt>requiredCapacity</tt> is available
-     * <tt>false</tt> if now.
+     * <tt>false</tt> if not.
      */
     public boolean hasAvailableCapacity(int requiredCapacity)
     {

File: src/main/java/com/lmax/disruptor/Sequencer.java
Patch:
@@ -82,7 +82,7 @@ public interface Sequencer extends Cursored, Sequenced
      * in the Sequencer.  The scan will range from nextSequence to availableSequence.  If
      * there are no available values <code>&gt;= nextSequence</code> the return value will be
      * <code>nextSequence - 1</code>.  To work correctly a consumer should pass a value that
-     * it 1 higher than the last sequence that was successfully processed.
+     * is 1 higher than the last sequence that was successfully processed.
      *
      * @param nextSequence      The sequence to start scanning from.
      * @param availableSequence The sequence to scan to.

File: src/main/java/com/lmax/disruptor/dsl/EventProcessorInfo.java
Patch:
@@ -27,7 +27,7 @@
  * <p>
  * <p>Tracks the event processor instance, the event handler instance, and sequence barrier which the stage is attached to.</p>
  *
- * @param T the type of the configured {@link EventHandler}
+ * @param <T> the type of the configured {@link EventHandler}
  */
 class EventProcessorInfo<T> implements ConsumerInfo
 {

File: src/perftest/java/com/lmax/disruptor/sequenced/ThreeToOneSequencedBatchThroughputTest.java
Patch:
@@ -76,9 +76,7 @@
  * EP1 - EventProcessor 1
  *
  * </pre>
- */
-
-/**
+ *
  * @author mikeb01
  */
 public final class ThreeToOneSequencedBatchThroughputTest extends AbstractPerfTestDisruptor

File: src/test/java/com/lmax/disruptor/RingBufferTest.java
Patch:
@@ -1240,13 +1240,13 @@ public void shouldAddAndRemoveSequences() throws Exception
     }
 
     @Test
-    public void shouldHandleResetToAndNotWrapUnecessarilySingleProducer() throws Exception
+    public void shouldHandleResetToAndNotWrapUnnecessarilySingleProducer() throws Exception
     {
         assertHandleResetAndNotWrap(RingBuffer.createSingleProducer(StubEvent.EVENT_FACTORY, 4));
     }
 
     @Test
-    public void shouldHandleResetToAndNotWrapUnecessarilyMultiProducer() throws Exception
+    public void shouldHandleResetToAndNotWrapUnnecessarilyMultiProducer() throws Exception
     {
         assertHandleResetAndNotWrap(RingBuffer.createMultiProducer(StubEvent.EVENT_FACTORY, 4));
     }

File: src/main/java/com/lmax/disruptor/WorkerPool.java
Patch:
@@ -95,7 +95,6 @@ public WorkerPool(
                 workSequence);
         }
 
-        ringBuffer.addGatingSequences(workSequence);
         ringBuffer.addGatingSequences(getWorkerSequences());
     }
 

File: src/main/java/com/lmax/disruptor/dsl/Disruptor.java
Patch:
@@ -560,6 +560,7 @@ EventHandlerGroup<T> createWorkerPool(
     {
         final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier(barrierSequences);
         final WorkerPool<T> workerPool = new WorkerPool<T>(ringBuffer, sequenceBarrier, exceptionHandler, workHandlers);
+        ringBuffer.addGatingSequences(workerPool.getWorkerSequences());
         consumerRepository.add(workerPool, sequenceBarrier);
         return new EventHandlerGroup<T>(this, consumerRepository, workerPool.getWorkerSequences());
     }

File: src/main/java/com/lmax/disruptor/InsufficientCapacityException.java
Patch:
@@ -16,8 +16,8 @@
 package com.lmax.disruptor;
 
 /**
- * <p>Exception thrown when the it is not possible to insert a value into
- * the ring buffer without it wrapping the consuming sequenes.  Used
+ * <p>Exception thrown when it is not possible to insert a value into
+ * the ring buffer without it wrapping the consuming sequences.  Used
  * specifically when claiming with the {@link RingBuffer#tryNext()} call.
  * <p>
  * <p>For efficiency this exception will not have a stack trace.

File: src/main/java/com/lmax/disruptor/RingBuffer.java
Patch:
@@ -405,7 +405,7 @@ public EventPoller<E> newPoller(Sequence... gatingSequences)
     }
 
     /**
-     * Get the current cursor value for the ring buffer.  The actual value recieved
+     * Get the current cursor value for the ring buffer.  The actual value received
      * will depend on the type of {@link Sequencer} that is being used.
      *
      * @see MultiProducerSequencer

File: src/main/java/com/lmax/disruptor/WaitStrategy.java
Patch:
@@ -24,7 +24,7 @@ public interface WaitStrategy
     /**
      * Wait for the given sequence to be available.  It is possible for this method to return a value
      * less than the sequence number supplied depending on the implementation of the WaitStrategy.  A common
-     * use for this is to signal a timeout.  Any EventProcessor that is using a WaitStragegy to get notifications
+     * use for this is to signal a timeout.  Any EventProcessor that is using a WaitStrategy to get notifications
      * about message becoming available should remember to handle this case.  The {@link BatchEventProcessor} explicitly
      * handles this case and will signal a timeout if required.
      *

File: src/main/java/com/lmax/disruptor/dsl/Disruptor.java
Patch:
@@ -70,7 +70,7 @@ public class Disruptor<T>
      * {@link ProducerType}.MULTI
      *
      * @deprecated Use a {@link ThreadFactory} instead of an {@link Executor} as a the ThreadFactory
-     * is able to report errors then it is unable to construct a thread to run a producer.
+     * is able to report errors when it is unable to construct a thread to run a producer.
      *
      * @param eventFactory   the factory to create events in the ring buffer.
      * @param ringBufferSize the size of the ring buffer.
@@ -86,7 +86,7 @@ public Disruptor(final EventFactory<T> eventFactory, final int ringBufferSize, f
      * Create a new Disruptor.
      *
      * @deprecated Use a {@link ThreadFactory} instead of an {@link Executor} as a the ThreadFactory
-     * is able to report errors then it is unable to construct a thread to run a producer.
+     * is able to report errors when it is unable to construct a thread to run a producer.
      *
      * @param eventFactory   the factory to create events in the ring buffer.
      * @param ringBufferSize the size of the ring buffer, must be power of 2.

File: src/perftest/java/com/lmax/disruptor/queue/OneToOneQueueBatchedThroughputTest.java
Patch:
@@ -17,7 +17,6 @@
 
 import com.lmax.disruptor.AbstractPerfTestQueue;
 import com.lmax.disruptor.support.ValueAdditionBatchQueueProcessor;
-import com.lmax.disruptor.support.ValueAdditionQueueProcessor;
 import com.lmax.disruptor.util.DaemonThreadFactory;
 
 import java.util.concurrent.*;

File: src/perftest/java/com/lmax/disruptor/support/ValueAdditionBatchQueueProcessor.java
Patch:
@@ -27,7 +27,7 @@ public final class ValueAdditionBatchQueueProcessor implements Runnable
     private CountDownLatch latch;
 
     private final BlockingQueue<Long> blockingQueue;
-    private final ArrayList<Long> batch = new ArrayList<>(100);
+    private final ArrayList<Long> batch = new ArrayList<Long>(100);
     private final long count;
 
     public ValueAdditionBatchQueueProcessor(final BlockingQueue<Long> blockingQueue, final long count)

File: src/main/java/com/lmax/disruptor/BlockingWaitStrategy.java
Patch:
@@ -34,12 +34,12 @@ public long waitFor(long sequence, Sequence cursorSequence, Sequence dependentSe
         throws AlertException, InterruptedException
     {
         long availableSequence;
-        if ((availableSequence = cursorSequence.get()) < sequence)
+        if (cursorSequence.get() < sequence)
         {
             lock.lock();
             try
             {
-                while ((availableSequence = cursorSequence.get()) < sequence)
+                while (cursorSequence.get() < sequence)
                 {
                     barrier.checkAlert();
                     processorNotifyCondition.await();

File: src/main/java/com/lmax/disruptor/LiteBlockingWaitStrategy.java
Patch:
@@ -37,7 +37,7 @@ public long waitFor(long sequence, Sequence cursorSequence, Sequence dependentSe
         throws AlertException, InterruptedException
     {
         long availableSequence;
-        if ((availableSequence = cursorSequence.get()) < sequence)
+        if (cursorSequence.get() < sequence)
         {
             lock.lock();
 
@@ -47,15 +47,15 @@ public long waitFor(long sequence, Sequence cursorSequence, Sequence dependentSe
                 {
                     signalNeeded.getAndSet(true);
 
-                    if ((availableSequence = cursorSequence.get()) >= sequence)
+                    if (cursorSequence.get() >= sequence)
                     {
                         break;
                     }
 
                     barrier.checkAlert();
                     processorNotifyCondition.await();
                 }
-                while ((availableSequence = cursorSequence.get()) < sequence);
+                while (cursorSequence.get() < sequence);
             }
             finally
             {

File: src/main/java/com/lmax/disruptor/TimeoutBlockingWaitStrategy.java
Patch:
@@ -27,12 +27,12 @@ public long waitFor(
         long nanos = timeoutInNanos;
 
         long availableSequence;
-        if ((availableSequence = cursorSequence.get()) < sequence)
+        if (cursorSequence.get() < sequence)
         {
             lock.lock();
             try
             {
-                while ((availableSequence = cursorSequence.get()) < sequence)
+                while (cursorSequence.get() < sequence)
                 {
                     barrier.checkAlert();
                     nanos = processorNotifyCondition.awaitNanos(nanos);

File: src/main/java/com/lmax/disruptor/BlockingWaitStrategy.java
Patch:
@@ -34,12 +34,12 @@ public long waitFor(long sequence, Sequence cursorSequence, Sequence dependentSe
         throws AlertException, InterruptedException
     {
         long availableSequence;
-        if ((availableSequence = cursorSequence.get()) < sequence)
+        if (cursorSequence.get() < sequence)
         {
             lock.lock();
             try
             {
-                while ((availableSequence = cursorSequence.get()) < sequence)
+                while (cursorSequence.get() < sequence)
                 {
                     barrier.checkAlert();
                     processorNotifyCondition.await();

File: src/main/java/com/lmax/disruptor/LiteBlockingWaitStrategy.java
Patch:
@@ -37,7 +37,7 @@ public long waitFor(long sequence, Sequence cursorSequence, Sequence dependentSe
         throws AlertException, InterruptedException
     {
         long availableSequence;
-        if ((availableSequence = cursorSequence.get()) < sequence)
+        if (cursorSequence.get() < sequence)
         {
             lock.lock();
 
@@ -47,15 +47,15 @@ public long waitFor(long sequence, Sequence cursorSequence, Sequence dependentSe
                 {
                     signalNeeded.getAndSet(true);
 
-                    if ((availableSequence = cursorSequence.get()) >= sequence)
+                    if (cursorSequence.get() >= sequence)
                     {
                         break;
                     }
 
                     barrier.checkAlert();
                     processorNotifyCondition.await();
                 }
-                while ((availableSequence = cursorSequence.get()) < sequence);
+                while (cursorSequence.get() < sequence);
             }
             finally
             {

File: src/main/java/com/lmax/disruptor/TimeoutBlockingWaitStrategy.java
Patch:
@@ -27,12 +27,12 @@ public long waitFor(
         long nanos = timeoutInNanos;
 
         long availableSequence;
-        if ((availableSequence = cursorSequence.get()) < sequence)
+        if (cursorSequence.get() < sequence)
         {
             lock.lock();
             try
             {
-                while ((availableSequence = cursorSequence.get()) < sequence)
+                while (cursorSequence.get() < sequence)
                 {
                     barrier.checkAlert();
                     nanos = processorNotifyCondition.awaitNanos(nanos);

File: src/test/java/com/lmax/disruptor/ShutdownOnFatalExceptionTest.java
Patch:
@@ -26,7 +26,7 @@ public void setUp()
             new ByteArrayFactory(256), 1024, Executors.newCachedThreadPool(), ProducerType.SINGLE,
             new BlockingWaitStrategy());
         disruptor.handleEventsWith(eventHandler);
-        disruptor.handleExceptionsWith(new FatalExceptionHandler());
+        disruptor.setDefaultExceptionHandler(new FatalExceptionHandler());
     }
 
     @Test(timeout = 1000)

File: src/main/java/com/lmax/disruptor/dsl/Disruptor.java
Patch:
@@ -248,7 +248,7 @@ public void setDefaultExceptionHandler(final ExceptionHandler<? super T> excepti
         checkNotStarted();
         if (!(this.exceptionHandler instanceof ExceptionHandlerWrapper))
         {
-            throw new IllegalStateException("Mixing calls to handleExceptionsWith and setDefaultExceptionHandler is not supported.");
+            throw new IllegalStateException("setDefaultExceptionHandler can not be used after handleExceptionsWith");
         }
         ((ExceptionHandlerWrapper<T>)this.exceptionHandler).switchTo(exceptionHandler);
     }

File: src/test/java/com/lmax/disruptor/ShutdownOnFatalExceptionTest.java
Patch:
@@ -26,7 +26,7 @@ public void setUp()
             new ByteArrayFactory(256), 1024, Executors.newCachedThreadPool(), ProducerType.SINGLE,
             new BlockingWaitStrategy());
         disruptor.handleEventsWith(eventHandler);
-        disruptor.handleExceptionsWith(new FatalExceptionHandler());
+        disruptor.setDefaultExceptionHandler(new FatalExceptionHandler());
     }
 
     @Test(timeout = 1000)

File: src/test/java/com/lmax/disruptor/example/DynamiclyAddHandler.java
Patch:
@@ -43,7 +43,8 @@ public static void main(String[] args) throws InterruptedException
         ExecutorService executor = Executors.newCachedThreadPool(DaemonThreadFactory.INSTANCE);
 
         // Build a disruptor and start it.
-        Disruptor<StubEvent> disruptor = new Disruptor<StubEvent>(StubEvent.EVENT_FACTORY, 1024, executor);
+        Disruptor<StubEvent> disruptor = new Disruptor<StubEvent>(
+            StubEvent.EVENT_FACTORY, 1024, DaemonThreadFactory.INSTANCE);
         RingBuffer<StubEvent> ringBuffer = disruptor.start();
 
         // Construct 2 batch event processors.

File: src/test/java/com/lmax/disruptor/example/ThreeToOneDisruptor.java
Patch:
@@ -4,6 +4,7 @@
 import com.lmax.disruptor.EventFactory;
 import com.lmax.disruptor.EventHandler;
 import com.lmax.disruptor.dsl.Disruptor;
+import com.lmax.disruptor.util.DaemonThreadFactory;
 
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
@@ -70,7 +71,8 @@ private void collate(Object[] output)
     public static void main(String[] args)
     {
         Executor executor = Executors.newFixedThreadPool(4);
-        Disruptor<DataEvent> disruptor = new Disruptor<DataEvent>(DataEvent.FACTORY, 1024, executor);
+        Disruptor<DataEvent> disruptor = new Disruptor<DataEvent>(
+            DataEvent.FACTORY, 1024, DaemonThreadFactory.INSTANCE);
 
         TransformingHandler handler1 = new TransformingHandler(0);
         TransformingHandler handler2 = new TransformingHandler(1);

File: src/main/java/com/lmax/disruptor/util/Util.java
Patch:
@@ -60,7 +60,8 @@ public static long getMinimumSequence(final Sequence[] sequences)
      * @param sequences to compare.
      * @param minimum   an initial default minimum.  If the array is empty this value will be
      *                  returned.
-     * @return the minimum sequence found or Long.MAX_VALUE if the array is empty.
+     * @return the smaller of minimum sequence value found in {@code sequences} and {@code minimum};
+     * {@code minimum} if {@code sequences} is empty
      */
     public static long getMinimumSequence(final Sequence[] sequences, long minimum)
     {

File: src/main/java/com/lmax/disruptor/util/Util.java
Patch:
@@ -60,7 +60,8 @@ public static long getMinimumSequence(final Sequence[] sequences)
      * @param sequences to compare.
      * @param minimum   an initial default minimum.  If the array is empty this value will be
      *                  returned.
-     * @return the minimum sequence found or Long.MAX_VALUE if the array is empty.
+     * @return the smaller of minimum sequence value found in {@code sequences} and {@code minimum};
+     * {@code minimum} if {@code sequences} is empty
      */
     public static long getMinimumSequence(final Sequence[] sequences, long minimum)
     {

File: src/main/java/com/lmax/disruptor/BatchEventProcessor.java
Patch:
@@ -31,7 +31,7 @@ public final class BatchEventProcessor<T>
     implements EventProcessor
 {
     private final AtomicBoolean running = new AtomicBoolean(false);
-    private ExceptionHandler exceptionHandler = new FatalExceptionHandler();
+    private ExceptionHandler<? super T> exceptionHandler = new FatalExceptionHandler();
     private final DataProvider<T> dataProvider;
     private final SequenceBarrier sequenceBarrier;
     private final EventHandler<? super T> eventHandler;
@@ -86,7 +86,7 @@ public boolean isRunning()
      *
      * @param exceptionHandler to replace the existing exceptionHandler.
      */
-    public void setExceptionHandler(final ExceptionHandler exceptionHandler)
+    public void setExceptionHandler(final ExceptionHandler<? super T> exceptionHandler)
     {
         if (null == exceptionHandler)
         {

File: src/main/java/com/lmax/disruptor/ExceptionHandler.java
Patch:
@@ -18,7 +18,7 @@
 /**
  * Callback handler for uncaught exceptions in the event processing cycle of the {@link BatchEventProcessor}
  */
-public interface ExceptionHandler
+public interface ExceptionHandler<T>
 {
     /**
      * <p>Strategy for handling uncaught exceptions when processing an event.</p>
@@ -30,7 +30,7 @@ public interface ExceptionHandler
      * @param sequence of the event which cause the exception.
      * @param event being processed when the exception occurred.  This can be null.
      */
-    void handleEventException(Throwable ex, long sequence, Object event);
+    void handleEventException(Throwable ex, long sequence, T event);
 
     /**
      * Callback to notify of an exception during {@link LifecycleAware#onStart()}

File: src/test/java/com/lmax/disruptor/dsl/ConsumerRepositoryTest.java
Patch:
@@ -124,7 +124,7 @@ public void shouldIterateAllEventProcessors() throws Exception
         boolean seen2 = false;
         for (ConsumerInfo testEntryEventProcessorInfo : consumerRepository)
         {
-            final EventProcessorInfo eventProcessorInfo = (EventProcessorInfo) testEntryEventProcessorInfo;
+            final EventProcessorInfo<?> eventProcessorInfo = (EventProcessorInfo<?>) testEntryEventProcessorInfo;
             if (!seen1 && eventProcessorInfo.getEventProcessor() == eventProcessor1 &&
                 eventProcessorInfo.getHandler() == handler1)
             {

File: src/test/java/com/lmax/disruptor/dsl/ConsumerRepositoryTest.java
Patch:
@@ -124,7 +124,7 @@ public void shouldIterateAllEventProcessors() throws Exception
         boolean seen2 = false;
         for (ConsumerInfo testEntryEventProcessorInfo : consumerRepository)
         {
-            final EventProcessorInfo eventProcessorInfo = (EventProcessorInfo) testEntryEventProcessorInfo;
+            final EventProcessorInfo<?> eventProcessorInfo = (EventProcessorInfo<?>) testEntryEventProcessorInfo;
             if (!seen1 && eventProcessorInfo.getEventProcessor() == eventProcessor1 &&
                 eventProcessorInfo.getHandler() == handler1)
             {

File: src/main/java/com/lmax/disruptor/dsl/EventProcessorFactory.java
Patch:
@@ -8,7 +8,7 @@
  * A factory interface to make it possible to include custom event processors in a chain:
  *
  * <pre><code>
- * disruptor.handleEventsWith(handler1).then((ringBuffer, barrierSequences) -> new CustomEventProcessor(ringBuffer, barrierSequences));
+ * disruptor.handleEventsWith(handler1).then((ringBuffer, barrierSequences) -&gt; new CustomEventProcessor(ringBuffer, barrierSequences));
  * </code></pre>
  */
 public interface EventProcessorFactory<T>

File: src/main/java/com/lmax/disruptor/RingBuffer.java
Patch:
@@ -87,15 +87,15 @@ else if (8 == scale)
         this.entries   = new Object[sequencer.getBufferSize() + 2 * BUFFER_PAD];
         fill(eventFactory);
     }
-    
+
     private void fill(EventFactory<E> eventFactory)
     {
         for (int i = 0; i < bufferSize; i++)
         {
             entries[BUFFER_PAD + i] = eventFactory.newInstance();
         }
     }
-    
+
     @SuppressWarnings("unchecked")
     protected final E elementAt(long sequence)
     {

File: src/main/java/com/lmax/disruptor/BatchEventProcessor.java
Patch:
@@ -34,7 +34,7 @@ public final class BatchEventProcessor<T>
     private ExceptionHandler exceptionHandler = new FatalExceptionHandler();
     private final DataProvider<T> dataProvider;
     private final SequenceBarrier sequenceBarrier;
-    private final EventHandler<T> eventHandler;
+    private final EventHandler<? super T> eventHandler;
     private final Sequence sequence = new Sequence(Sequencer.INITIAL_CURSOR_VALUE);
     private final TimeoutHandler timeoutHandler;
 
@@ -48,7 +48,7 @@ public final class BatchEventProcessor<T>
      */
     public BatchEventProcessor(final DataProvider<T> dataProvider,
                                final SequenceBarrier sequenceBarrier,
-                               final EventHandler<T> eventHandler)
+                               final EventHandler<? super T> eventHandler)
     {
         this.dataProvider = dataProvider;
         this.sequenceBarrier = sequenceBarrier;

File: src/main/java/com/lmax/disruptor/dsl/ConsumerRepository.java
Patch:
@@ -31,7 +31,7 @@ class ConsumerRepository<T> implements Iterable<ConsumerInfo>
     private final Collection<ConsumerInfo> consumerInfos = new ArrayList<ConsumerInfo>();
 
     public void add(final EventProcessor eventprocessor,
-                    final EventHandler<T> handler,
+                    final EventHandler<? super T> handler,
                     final SequenceBarrier barrier)
     {
         final EventProcessorInfo<T> consumerInfo = new EventProcessorInfo<T>(eventprocessor, handler, barrier);
@@ -96,6 +96,7 @@ public void unMarkEventProcessorsAsEndOfChain(final Sequence... barrierEventProc
         }
     }
 
+    @Override
     public Iterator<ConsumerInfo> iterator()
     {
         return consumerInfos.iterator();

File: src/main/java/com/lmax/disruptor/dsl/Disruptor.java
Patch:
@@ -109,7 +109,7 @@ private Disruptor(final RingBuffer<T> ringBuffer, final Executor executor)
      * @return a {@link EventHandlerGroup} that can be used to chain dependencies.
      */
     @SuppressWarnings("varargs")
-    public EventHandlerGroup<T> handleEventsWith(final EventHandler<T>... handlers)
+    public EventHandlerGroup<T> handleEventsWith(final EventHandler<? super T>... handlers)
     {
         return createEventProcessors(new Sequence[0], handlers);
     }
@@ -393,7 +393,7 @@ private boolean hasBacklog()
     }
 
     EventHandlerGroup<T> createEventProcessors(final Sequence[] barrierSequences,
-                                               final EventHandler<T>[] eventHandlers)
+                                               final EventHandler<? super T>[] eventHandlers)
     {
         checkNotStarted();
 
@@ -402,7 +402,7 @@ EventHandlerGroup<T> createEventProcessors(final Sequence[] barrierSequences,
 
         for (int i = 0, eventHandlersLength = eventHandlers.length; i < eventHandlersLength; i++)
         {
-            final EventHandler<T> eventHandler = eventHandlers[i];
+            final EventHandler<? super T> eventHandler = eventHandlers[i];
 
             final BatchEventProcessor<T> batchEventProcessor = new BatchEventProcessor<T>(ringBuffer, barrier, eventHandler);
 

File: src/main/java/com/lmax/disruptor/dsl/EventProcessorInfo.java
Patch:
@@ -32,11 +32,11 @@
 class EventProcessorInfo<T> implements ConsumerInfo
 {
     private final EventProcessor eventprocessor;
-    private final EventHandler<T> handler;
+    private final EventHandler<? super T> handler;
     private final SequenceBarrier barrier;
     private boolean endOfChain = true;
 
-    EventProcessorInfo(final EventProcessor eventprocessor, final EventHandler<T> handler, final SequenceBarrier barrier)
+    EventProcessorInfo(final EventProcessor eventprocessor, final EventHandler<? super T> handler, final SequenceBarrier barrier)
     {
         this.eventprocessor = eventprocessor;
         this.handler = handler;
@@ -54,7 +54,7 @@ public Sequence[] getSequences()
         return new Sequence[] { eventprocessor.getSequence() };
     }
 
-    public EventHandler<T> getHandler()
+    public EventHandler<? super T> getHandler()
     {
         return handler;
     }

File: src/main/java/com/lmax/disruptor/BatchEventProcessor.java
Patch:
@@ -34,7 +34,7 @@ public final class BatchEventProcessor<T>
     private ExceptionHandler exceptionHandler = new FatalExceptionHandler();
     private final DataProvider<T> dataProvider;
     private final SequenceBarrier sequenceBarrier;
-    private final EventHandler<T> eventHandler;
+    private final EventHandler<? super T> eventHandler;
     private final Sequence sequence = new Sequence(Sequencer.INITIAL_CURSOR_VALUE);
     private final TimeoutHandler timeoutHandler;
 
@@ -48,7 +48,7 @@ public final class BatchEventProcessor<T>
      */
     public BatchEventProcessor(final DataProvider<T> dataProvider,
                                final SequenceBarrier sequenceBarrier,
-                               final EventHandler<T> eventHandler)
+                               final EventHandler<? super T> eventHandler)
     {
         this.dataProvider = dataProvider;
         this.sequenceBarrier = sequenceBarrier;

File: src/main/java/com/lmax/disruptor/dsl/ConsumerRepository.java
Patch:
@@ -31,7 +31,7 @@ class ConsumerRepository<T> implements Iterable<ConsumerInfo>
     private final Collection<ConsumerInfo> consumerInfos = new ArrayList<ConsumerInfo>();
 
     public void add(final EventProcessor eventprocessor,
-                    final EventHandler<T> handler,
+                    final EventHandler<? super T> handler,
                     final SequenceBarrier barrier)
     {
         final EventProcessorInfo<T> consumerInfo = new EventProcessorInfo<T>(eventprocessor, handler, barrier);

File: src/main/java/com/lmax/disruptor/dsl/Disruptor.java
Patch:
@@ -109,7 +109,7 @@ private Disruptor(final RingBuffer<T> ringBuffer, final Executor executor)
      * @return a {@link EventHandlerGroup} that can be used to chain dependencies.
      */
     @SuppressWarnings("varargs")
-    public EventHandlerGroup<T> handleEventsWith(final EventHandler<T>... handlers)
+    public EventHandlerGroup<T> handleEventsWith(final EventHandler<? super T>... handlers)
     {
         return createEventProcessors(new Sequence[0], handlers);
     }
@@ -393,7 +393,7 @@ private boolean hasBacklog()
     }
 
     EventHandlerGroup<T> createEventProcessors(final Sequence[] barrierSequences,
-                                               final EventHandler<T>[] eventHandlers)
+                                               final EventHandler<? super T>[] eventHandlers)
     {
         checkNotStarted();
 
@@ -402,7 +402,7 @@ EventHandlerGroup<T> createEventProcessors(final Sequence[] barrierSequences,
 
         for (int i = 0, eventHandlersLength = eventHandlers.length; i < eventHandlersLength; i++)
         {
-            final EventHandler<T> eventHandler = eventHandlers[i];
+            final EventHandler<? super T> eventHandler = eventHandlers[i];
 
             final BatchEventProcessor<T> batchEventProcessor = new BatchEventProcessor<T>(ringBuffer, barrier, eventHandler);
 

File: src/main/java/com/lmax/disruptor/dsl/EventProcessorInfo.java
Patch:
@@ -32,11 +32,11 @@
 class EventProcessorInfo<T> implements ConsumerInfo
 {
     private final EventProcessor eventprocessor;
-    private final EventHandler<T> handler;
+    private final EventHandler<? super T> handler;
     private final SequenceBarrier barrier;
     private boolean endOfChain = true;
 
-    EventProcessorInfo(final EventProcessor eventprocessor, final EventHandler<T> handler, final SequenceBarrier barrier)
+    EventProcessorInfo(final EventProcessor eventprocessor, final EventHandler<? super T> handler, final SequenceBarrier barrier)
     {
         this.eventprocessor = eventprocessor;
         this.handler = handler;
@@ -54,7 +54,7 @@ public Sequence[] getSequences()
         return new Sequence[] { eventprocessor.getSequence() };
     }
 
-    public EventHandler<T> getHandler()
+    public EventHandler<? super T> getHandler()
     {
         return handler;
     }

File: src/main/java/com/lmax/disruptor/RingBuffer.java
Patch:
@@ -261,8 +261,8 @@ public long tryNext(int n) throws InsufficientCapacityException
     }
 
     /**
-     * Resets the cursor to a specific value.  This can be applied at any time, but it is worth not
-     * that it is a racy thing to do and should only be used in controlled circumstances.  E.g. during
+     * Resets the cursor to a specific value.  This can be applied at any time, but it is worth noting
+     * that it can cause a data rate and should only be used in controlled circumstances.  E.g. during
      * initialisation.
      *
      * @param sequence The sequence to reset too.
@@ -276,7 +276,7 @@ public void resetTo(long sequence)
 
     /**
      * Sets the cursor to a specific sequence and returns the preallocated entry that is stored there.  This
-     * is another deliberately racy call, that should only be done in controlled circumstances, e.g. initialisation.
+     * can cause a data race and should only be done in controlled circumstances, e.g. during initialisation.
      *
      * @param sequence The sequence to claim.
      * @return The preallocated event.

File: src/main/java/com/lmax/disruptor/EventPoller.java
Patch:
@@ -32,7 +32,7 @@ public PollState poll(Handler<T> eventHandler) throws Exception
     {
         long currentSequence = sequence.get();
         long nextSequence = currentSequence + 1;
-        long availableSequence = sequencer.getHighestPublishedSequence(currentSequence, gatingSequence.get());
+        long availableSequence = sequencer.getHighestPublishedSequence(nextSequence, gatingSequence.get());
 
         if (nextSequence <= availableSequence)
         {

File: src/test/java/com/lmax/disruptor/dsl/DisruptorTest.java
Patch:
@@ -361,10 +361,9 @@ public void shouldSupportUsingWorkerPoolAsDependency() throws Exception
         publishEvent();
         publishEvent();
 
-        workHandler2.processEvent();
-
         assertThat(disruptor.getBarrierFor(delayedEventHandler).getCursor(), equalTo(-1L));
-
+        
+        workHandler2.processEvent();
         workHandler1.processEvent();
 
         delayedEventHandler.processEvent();

File: src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedBatchThroughputTest.java
Patch:
@@ -103,7 +103,8 @@ protected long runDisruptorPass() throws InterruptedException
         {
             long hi = rb.next(BATCH_SIZE);
             long lo = hi - (BATCH_SIZE - 1);
-            for (long l = lo; l <= hi; l++) {
+            for (long l = lo; l <= hi; l++)
+            {
                 rb.get(l).setValue(i);
             }
             rb.publish(lo, hi);

File: src/perftest/java/com/lmax/disruptor/sequenced/OneToOneSequencedBatchThroughputTest.java
Patch:
@@ -103,7 +103,8 @@ protected long runDisruptorPass() throws InterruptedException
         {
             long hi = rb.next(BATCH_SIZE);
             long lo = hi - (BATCH_SIZE - 1);
-            for (long l = lo; l <= hi; l++) {
+            for (long l = lo; l <= hi; l++)
+            {
                 rb.get(l).setValue(i);
             }
             rb.publish(lo, hi);

File: src/perftest/java/com/lmax/disruptor/offheap/OneToOneOnHeapThroughputTest.java
Patch:
@@ -127,7 +127,7 @@ public void reset(CountDownLatch latch, long expectedCount)
         }
     }
 
-    private static class BufferFactory implements EventFactory<ByteBuffer>
+    private static final class BufferFactory implements EventFactory<ByteBuffer>
     {
         private final boolean isDirect;
         private final int size;

File: src/main/java/com/lmax/disruptor/RingBuffer.java
Patch:
@@ -969,7 +969,7 @@ private void checkBatchSizing(int batchStartsAt, int batchSize)
     {
         if(batchStartsAt < 0 || batchSize < 0)
         {
-            throw new IllegalArgumentException("Both batchStartsAt and batchSize must be positive but got: batchStartsAt " + batchStartsAt + " and bachSize " + batchSize);
+            throw new IllegalArgumentException("Both batchStartsAt and batchSize must be positive but got: batchStartsAt " + batchStartsAt + " and batchSize " + batchSize);
         }
         else if(batchSize > bufferSize)
         {

File: src/main/java/com/lmax/disruptor/RingBuffer.java
Patch:
@@ -969,7 +969,7 @@ private void checkBatchSizing(int batchStartsAt, int batchSize)
     {
         if(batchStartsAt < 0 || batchSize < 0)
         {
-            throw new IllegalArgumentException("Both batchStartsAt and batchSize must be positive but got: batchStartsAt " + batchStartsAt + " and bachSize " + batchSize);
+            throw new IllegalArgumentException("Both batchStartsAt and batchSize must be positive but got: batchStartsAt " + batchStartsAt + " and batchSize " + batchSize);
         }
         else if(batchSize > bufferSize)
         {

File: src/main/java/com/lmax/disruptor/MultiProducerSequencer.java
Patch:
@@ -242,7 +242,7 @@ public void publish(long lo, long hi)
      * sequence as the index into the buffer (indexMask). (aka modulo operator)
      * -- The upper portion of the sequence becomes the value to check for availability.
      * ie: it tells us how many times around the ring buffer we've been (aka division)
-     * -- Beause we can't wrap without the gating sequences moving forward (i.e. the
+     * -- Because we can't wrap without the gating sequences moving forward (i.e. the
      * minimum gating sequence is effectively our last available position in the
      * buffer), when we have new data and successfully claimed a slot we can simply
      * write over the top.

File: src/main/java/com/lmax/disruptor/MultiProducerSequencer.java
Patch:
@@ -242,7 +242,7 @@ public void publish(long lo, long hi)
      * sequence as the index into the buffer (indexMask). (aka modulo operator)
      * -- The upper portion of the sequence becomes the value to check for availability.
      * ie: it tells us how many times around the ring buffer we've been (aka division)
-     * -- Beause we can't wrap without the gating sequences moving forward (i.e. the
+     * -- Because we can't wrap without the gating sequences moving forward (i.e. the
      * minimum gating sequence is effectively our last available position in the
      * buffer), when we have new data and successfully claimed a slot we can simply
      * write over the top.

File: src/main/java/com/lmax/disruptor/EventTranslator.java
Patch:
@@ -16,11 +16,11 @@
 package com.lmax.disruptor;
 
 /**
- * Implementations translate (write) data representations into events claimed from the {@link RingBuffer}.<p/>
+ * <p>Implementations translate (write) data representations into events claimed from the {@link RingBuffer}.</p>
  *
- * When publishing to the RingBuffer, provide an EventTranslator. The RingBuffer will select the next available
+ * <p>When publishing to the RingBuffer, provide an EventTranslator. The RingBuffer will select the next available
  * event by sequence and provide it to the EventTranslator (which should update the event), before publishing
- * the sequence update.
+ * the sequence update.</p>
  *
  * @param <T> event implementation storing the data for sharing during exchange or parallel coordination of an event.
  */

File: src/main/java/com/lmax/disruptor/ExceptionHandler.java
Patch:
@@ -21,10 +21,10 @@
 public interface ExceptionHandler
 {
     /**
-     * Strategy for handling uncaught exceptions when processing an event.<p/>
+     * <p>Strategy for handling uncaught exceptions when processing an event.</p>
      *
-     * If the strategy wishes to terminate further processing by the {@link BatchEventProcessor}
-     * then it should throw a {@link RuntimeException}.<p/>
+     * <p>If the strategy wishes to terminate further processing by the {@link BatchEventProcessor}
+     * then it should throw a {@link RuntimeException}.</p>
      *
      * @param ex the exception that propagated from the {@link EventHandler}.
      * @param sequence of the event which cause the exception.

File: src/main/java/com/lmax/disruptor/LifecycleAware.java
Patch:
@@ -17,7 +17,7 @@
 
 /**
  * Implement this interface in your {@link EventHandler} to be notified when a thread for the
- * {@link BatchEventProcessor} starts and shuts down.<p/>
+ * {@link BatchEventProcessor} starts and shuts down.
  */
 public interface LifecycleAware
 {
@@ -27,7 +27,7 @@ public interface LifecycleAware
     void onStart();
 
     /**
-     * Called once just before the thread is shutdown.<p/>
+     * <p>Called once just before the thread is shutdown.</p>
      *
      * Sequence event processing will already have stopped before this method is called. No events will
      * be processed after this message.

File: src/main/java/com/lmax/disruptor/Sequencer.java
Patch:
@@ -51,7 +51,7 @@ public interface Sequencer extends Cursored
      * int n = 10;
      * long hi = sequencer.next(n);
      * long lo = hi - (n - 1);
-     * for (long sequence = lo; sequence <= hi; sequence++) {
+     * for (long sequence = lo; sequence &lt;= hi; sequence++) {
      *     // Do work.
      * }
      * sequencer.publish(lo, hi);

File: src/main/java/com/lmax/disruptor/SingleProducerSequencer.java
Patch:
@@ -21,9 +21,9 @@
 
 
 /**
- * Coordinator for claiming sequences for access to a data structure while tracking dependent {@link Sequence}s.<p/>
+ * <p>Coordinator for claiming sequences for access to a data structure while tracking dependent {@link Sequence}s.<p>
  *
- * Generally not safe for use from multiple threads as it does not implement any barriers.
+ * <p>Generally not safe for use from multiple threads as it does not implement any barriers.</p>
  */
 public final class SingleProducerSequencer extends AbstractSequencer
 {

File: src/main/java/com/lmax/disruptor/WorkProcessor.java
Patch:
@@ -18,10 +18,10 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
- * A {@link WorkProcessor} wraps a single {@link WorkHandler}, effectively consuming the sequence
- * and ensuring appropriate barriers.<p/>
+ * <p>A {@link WorkProcessor} wraps a single {@link WorkHandler}, effectively consuming the sequence
+ * and ensuring appropriate barriers.</p>
  *
- * Generally, this will be used as part of a {@link WorkerPool}.
+ * <p>Generally, this will be used as part of a {@link WorkerPool}.</p>
  *
  * @param <T> event implementation storing the details for the work to processed.
  */

File: src/main/java/com/lmax/disruptor/dsl/EventProcessorInfo.java
Patch:
@@ -23,9 +23,9 @@
 import java.util.concurrent.Executor;
 
 /**
- * Wrapper class to tie together a particular event processing stage<p/>
+ * <p>Wrapper class to tie together a particular event processing stage</p>
  *
- * Tracks the event processor instance, the event handler instance, and sequence barrier which the stage is attached to
+ * <p>Tracks the event processor instance, the event handler instance, and sequence barrier which the stage is attached to.</p>
  *
  * @param T the type of the configured {@link EventHandler}
  */

File: src/main/java/com/lmax/disruptor/dsl/ProducerType.java
Patch:
@@ -16,7 +16,7 @@
 package com.lmax.disruptor.dsl;
 
 /**
- * Defines producer types to support creation of RingBuffer with correct sequencer and publisher.<p/>
+ * Defines producer types to support creation of RingBuffer with correct sequencer and publisher.
  */
 public enum ProducerType
 {

File: src/test/java/com/lmax/disruptor/dsl/DisruptorTest.java
Patch:
@@ -62,8 +62,8 @@ public class DisruptorTest
     private static final int TIMEOUT_IN_SECONDS = 2;
     private Disruptor<TestEvent> disruptor;
     private StubExecutor executor;
-    private Collection<DelayedEventHandler> delayedEventHandlers = new ArrayList<DelayedEventHandler>();
-    private Collection<TestWorkHandler> testWorkHandlers = new ArrayList<TestWorkHandler>();
+    private final Collection<DelayedEventHandler> delayedEventHandlers = new ArrayList<DelayedEventHandler>();
+    private final Collection<TestWorkHandler> testWorkHandlers = new ArrayList<TestWorkHandler>();
     private RingBuffer<TestEvent> ringBuffer;
     private TestEvent lastPublishedEvent;
 

File: src/main/java/com/lmax/disruptor/RingBuffer.java
Patch:
@@ -275,7 +275,7 @@ public void resetTo(long sequence)
 
     /**
      * Sets the cursor to a specific sequence and returns the preallocated entry that is stored there.  This
-     * is another deliberatly racy call, that should only be done in controlled circumstances, e.g. initialisation.
+     * is another deliberately racy call, that should only be done in controlled circumstances, e.g. initialisation.
      *
      * @param sequence The sequence to claim.
      * @return The preallocated event.

File: src/main/java/com/lmax/disruptor/AlertException.java
Patch:
@@ -21,7 +21,7 @@
  * It does not fill in a stack trace for performance reasons.
  */
 @SuppressWarnings("serial")
-public class AlertException extends Exception
+public final class AlertException extends Exception
 {
     /** Pre-allocated exception to avoid garbage generation */
     public static final AlertException INSTANCE = new AlertException();

File: src/main/java/com/lmax/disruptor/EventFactory.java
Patch:
@@ -22,8 +22,8 @@
  */
 public interface EventFactory<T>
 {
-	/*
-	 * Implementations should instantiate an event object, with all memory already allocated where possible.
-	 */
+    /*
+     * Implementations should instantiate an event object, with all memory already allocated where possible.
+     */
     T newInstance();
 }
\ No newline at end of file

File: src/main/java/com/lmax/disruptor/FatalExceptionHandler.java
Patch:
@@ -24,7 +24,7 @@
  */
 public final class FatalExceptionHandler implements ExceptionHandler
 {
-    private final static Logger LOGGER = Logger.getLogger(FatalExceptionHandler.class.getName());
+    private static final Logger LOGGER = Logger.getLogger(FatalExceptionHandler.class.getName());
     private final Logger logger;
 
     public FatalExceptionHandler()

File: src/main/java/com/lmax/disruptor/IgnoreExceptionHandler.java
Patch:
@@ -24,7 +24,7 @@
  */
 public final class IgnoreExceptionHandler implements ExceptionHandler
 {
-    private final static Logger LOGGER = Logger.getLogger(IgnoreExceptionHandler.class.getName());
+    private static final Logger LOGGER = Logger.getLogger(IgnoreExceptionHandler.class.getName());
     private final Logger logger;
 
     public IgnoreExceptionHandler()

File: src/main/java/com/lmax/disruptor/InsufficientCapacityException.java
Patch:
@@ -25,7 +25,7 @@
  *
  */
 @SuppressWarnings("serial")
-public class InsufficientCapacityException extends Exception
+public final class InsufficientCapacityException extends Exception
 {
     public static final InsufficientCapacityException INSTANCE = new InsufficientCapacityException();
 

File: src/main/java/com/lmax/disruptor/Sequencer.java
Patch:
@@ -21,7 +21,7 @@
 public interface Sequencer extends Cursored
 {
     /** Set to -1 as sequence starting point */
-    public static final long INITIAL_CURSOR_VALUE = -1L;
+    long INITIAL_CURSOR_VALUE = -1L;
 
     /**
      * The capacity of the data structure to hold entries.

File: src/main/java/com/lmax/disruptor/TimeoutException.java
Patch:
@@ -1,7 +1,7 @@
 package com.lmax.disruptor;
 
 @SuppressWarnings("serial")
-public class TimeoutException extends Exception
+public final class TimeoutException extends Exception
 {
     public static final TimeoutException INSTANCE = new TimeoutException();
     

File: src/main/java/com/lmax/disruptor/collections/Histogram.java
Patch:
@@ -63,7 +63,8 @@ public Histogram(final long[] upperBounds)
     private void validateBounds(final long[] upperBounds)
     {
         long lastBound = -1L;
-        if (upperBounds.length <= 0) {
+        if (upperBounds.length <= 0) 
+        {
             throw new IllegalArgumentException("Must provide at least one interval");
         }
         for (final long bound : upperBounds)

File: src/main/java/com/lmax/disruptor/dsl/ProducerType.java
Patch:
@@ -20,9 +20,9 @@
  */
 public enum ProducerType
 {
-	/** Create a RingBuffer with a single event publisher to the RingBuffer */
+    /** Create a RingBuffer with a single event publisher to the RingBuffer */
     SINGLE,
- 
+     
     /** Create a RingBuffer supporting multiple event publishers to the one RingBuffer */
     MULTI
 }

File: src/perftest/java/com/lmax/disruptor/AbstractPerfTestQueueVsDisruptor.java
Patch:
@@ -31,8 +31,8 @@ protected void testImplementations()
             System.out.println("Processors required = " + getRequiredProcessorCount() + " available = " + availableProcessors);
         }
 
-        long queueOps[] = new long[RUNS];
-        long disruptorOps[] = new long[RUNS];
+        long[] queueOps = new long[RUNS];
+        long[] disruptorOps = new long[RUNS];
 
         if ("true".equalsIgnoreCase(System.getProperty("com.lmax.runQueueTests", "false")))
         {

File: src/perftest/java/com/lmax/disruptor/DirectVsEventTranslatorWithByteArrayBenchmark.java
Patch:
@@ -28,7 +28,7 @@
 public class DirectVsEventTranslatorWithByteArrayBenchmark extends SimpleBenchmark
 {
     private static final int BUFFER_SIZE = 1024 * 8;
-    private final ExecutorService EXECUTOR = Executors.newCachedThreadPool();
+    private final ExecutorService executor = Executors.newCachedThreadPool();
 
     private final RingBuffer<byte[]> ringBuffer = 
             createSingleProducer(new ByteArrayFactory(), BUFFER_SIZE, new YieldingWaitStrategy());
@@ -40,7 +40,7 @@ public class DirectVsEventTranslatorWithByteArrayBenchmark extends SimpleBenchma
     private final byte[] data = new byte[128];
     {
         ringBuffer.addGatingSequences(batchEventProcessor.getSequence());
-        EXECUTOR.submit(batchEventProcessor);
+        executor.submit(batchEventProcessor);
         Arrays.fill(data, (byte) 'a');
     }
 

File: src/perftest/java/com/lmax/disruptor/DirectVsEventTranslatorWithSingleLongBenchmark.java
Patch:
@@ -29,7 +29,7 @@
 public class DirectVsEventTranslatorWithSingleLongBenchmark extends SimpleBenchmark
 {
     private static final int BUFFER_SIZE = 1024 * 8;
-    private final ExecutorService EXECUTOR = Executors.newCachedThreadPool();
+    private final ExecutorService executor = Executors.newCachedThreadPool();
 
     private final RingBuffer<ValueEvent> ringBuffer =
             createSingleProducer(ValueEvent.EVENT_FACTORY, BUFFER_SIZE, new YieldingWaitStrategy());
@@ -40,7 +40,7 @@ public class DirectVsEventTranslatorWithSingleLongBenchmark extends SimpleBenchm
             new BatchEventProcessor<ValueEvent>(ringBuffer, sequenceBarrier, handler);
     {
         ringBuffer.addGatingSequences(batchEventProcessor.getSequence());
-        EXECUTOR.submit(batchEventProcessor);
+        executor.submit(batchEventProcessor);
         try
         {
             Thread.sleep(1000);

File: src/perftest/java/com/lmax/disruptor/OnePublisherToOneProcessorRawBatchThroughputTest.java
Patch:
@@ -70,7 +70,7 @@ public final class OnePublisherToOneProcessorRawBatchThroughputTest extends Abst
 {
     private static final int BUFFER_SIZE = 1024 * 64;
     private static final long ITERATIONS = 1000L * 1000L * 200L;
-    private final ExecutorService EXECUTOR = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
+    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
 
     ///////////////////////////////////////////////////////////////////////////////////////////////
 
@@ -108,7 +108,7 @@ protected long runDisruptorPass() throws InterruptedException
         final CountDownLatch latch = new CountDownLatch(1);
         long expectedCount = myRunnable.sequence.get() + (ITERATIONS * batchSize);
         myRunnable.reset(latch, expectedCount);
-        EXECUTOR.submit(myRunnable);
+        executor.submit(myRunnable);
         long start = System.currentTimeMillis();
         
         final Sequencer sequencer = this.sequencer;

File: src/perftest/java/com/lmax/disruptor/OnePublisherToOneProcessorRawThroughputTest.java
Patch:
@@ -70,7 +70,7 @@ public final class OnePublisherToOneProcessorRawThroughputTest extends AbstractP
 {
     private static final int BUFFER_SIZE = 1024 * 64;
     private static final long ITERATIONS = 1000L * 1000L * 200L;
-    private final ExecutorService EXECUTOR = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
+    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
 
     ///////////////////////////////////////////////////////////////////////////////////////////////
 
@@ -107,7 +107,7 @@ protected long runDisruptorPass() throws InterruptedException
         final CountDownLatch latch = new CountDownLatch(1);
         long expectedCount = myRunnable.sequence.get() + ITERATIONS;
         myRunnable.reset(latch, expectedCount);
-        EXECUTOR.submit(myRunnable);
+        executor.submit(myRunnable);
         long start = System.currentTimeMillis();
         
         final Sequencer sequencer = this.sequencer;

File: src/perftest/java/com/lmax/disruptor/OnePublisherToOneProcessorUniCastThroughputTest.java
Patch:
@@ -72,7 +72,7 @@ public final class OnePublisherToOneProcessorUniCastThroughputTest extends Abstr
 {
     private static final int BUFFER_SIZE = 1024 * 64;
     private static final long ITERATIONS = 1000L * 1000L * 100L;
-    private final ExecutorService EXECUTOR = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
+    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
     private final long expectedResult = PerfTestUtil.accumulatedAddition(ITERATIONS);
 
     ///////////////////////////////////////////////////////////////////////////////////////////////
@@ -111,7 +111,7 @@ protected long runQueuePass() throws InterruptedException
     {
         final CountDownLatch latch = new CountDownLatch(1);
         queueProcessor.reset(latch);
-        Future<?> future = EXECUTOR.submit(queueProcessor);
+        Future<?> future = executor.submit(queueProcessor);
         long start = System.currentTimeMillis();
 
         for (long i = 0; i < ITERATIONS; i++)
@@ -135,7 +135,7 @@ protected long runDisruptorPass() throws InterruptedException
         final CountDownLatch latch = new CountDownLatch(1);
         long expectedCount = batchEventProcessor.getSequence().get() + ITERATIONS;
         handler.reset(latch, expectedCount);
-        EXECUTOR.submit(batchEventProcessor);
+        executor.submit(batchEventProcessor);
         long start = System.currentTimeMillis();
         
         final RingBuffer<ValueEvent> rb = ringBuffer;

File: src/perftest/java/com/lmax/disruptor/OnePublisherToThreeProcessorMultiCastThroughputTest.java
Patch:
@@ -96,7 +96,7 @@ public final class OnePublisherToThreeProcessorMultiCastThroughputTest extends A
     private static final int NUM_EVENT_PROCESSORS = 3;
     private static final int BUFFER_SIZE = 1024 * 8;
     private static final long ITERATIONS = 1000L * 1000L * 100L;
-    private final ExecutorService EXECUTOR = Executors.newFixedThreadPool(NUM_EVENT_PROCESSORS);
+    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_EVENT_PROCESSORS);
 
     private final long[] results = new long[NUM_EVENT_PROCESSORS];
     {
@@ -173,7 +173,7 @@ protected long runQueuePass() throws InterruptedException
         for (int i = 0; i < NUM_EVENT_PROCESSORS; i++)
         {
             queueProcessors[i].reset(latch);
-            futures[i] = EXECUTOR.submit(queueProcessors[i]);
+            futures[i] = executor.submit(queueProcessors[i]);
         }
 
         long start = System.currentTimeMillis();
@@ -206,7 +206,7 @@ protected long runDisruptorPass() throws InterruptedException
         for (int i = 0; i < NUM_EVENT_PROCESSORS; i++)
         {
             handlers[i].reset(latch, batchEventProcessors[i].getSequence().get() + ITERATIONS);
-            EXECUTOR.submit(batchEventProcessors[i]);
+            executor.submit(batchEventProcessors[i]);
         }
 
         long start = System.currentTimeMillis();

File: src/perftest/java/com/lmax/disruptor/OnePublisherToThreeWorkerPoolThroughputTest.java
Patch:
@@ -29,7 +29,7 @@ public final class OnePublisherToThreeWorkerPoolThroughputTest
     private static final int NUM_WORKERS = 3;
     private static final int BUFFER_SIZE = 1024 * 8;
     private static final long ITERATIONS = 1000L * 1000L * 100L;
-    private final ExecutorService EXECUTOR = Executors.newFixedThreadPool(NUM_WORKERS);
+    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_WORKERS);
 
     private final PaddedLong[] counters = new PaddedLong[NUM_WORKERS];
     {
@@ -93,7 +93,7 @@ protected long runQueuePass() throws InterruptedException
         Future<?>[] futures = new Future[NUM_WORKERS];
         for (int i = 0; i < NUM_WORKERS; i++)
         {
-            futures[i] = EXECUTOR.submit(queueWorkers[i]);
+            futures[i] = executor.submit(queueWorkers[i]);
         }
 
         long start = System.currentTimeMillis();
@@ -126,7 +126,7 @@ protected long runDisruptorPass() throws InterruptedException
     {
 
         resetCounters();
-        RingBuffer<ValueEvent> ringBuffer = workerPool.start(EXECUTOR);
+        RingBuffer<ValueEvent> ringBuffer = workerPool.start(executor);
         long start = System.currentTimeMillis();
 
         for (long i = 0; i < ITERATIONS; i++)

File: src/perftest/java/com/lmax/disruptor/TwoPublisherToTwoProcessorWorkProcessorThroughputTest.java
Patch:
@@ -52,7 +52,7 @@ public final class TwoPublisherToTwoProcessorWorkProcessorThroughputTest extends
     private static final int NUM_PUBLISHERS = 2;
     private static final int BUFFER_SIZE = 1024 * 64;
     private static final long ITERATIONS = 1000L * 1000L * 1L;
-    private final ExecutorService EXECUTOR = Executors.newFixedThreadPool(NUM_PUBLISHERS + 2);
+    private final ExecutorService executor = Executors.newFixedThreadPool(NUM_PUBLISHERS + 2);
     private final CyclicBarrier cyclicBarrier = new CyclicBarrier(NUM_PUBLISHERS + 1);
 
     ///////////////////////////////////////////////////////////////////////////////////////////////
@@ -118,12 +118,12 @@ protected long runDisruptorPass() throws Exception
         Future<?>[] futures = new Future[NUM_PUBLISHERS];
         for (int i = 0; i < NUM_PUBLISHERS; i++)
         {
-            futures[i] = EXECUTOR.submit(valuePublishers[i]);
+            futures[i] = executor.submit(valuePublishers[i]);
         }
         
         for (WorkProcessor<ValueEvent> processor : workProcessors)
         {            
-            EXECUTOR.submit(processor);
+            executor.submit(processor);
         }
 
         long start = System.currentTimeMillis();

File: src/perftest/java/com/lmax/disruptor/support/FizzBuzzEvent.java
Patch:
@@ -55,7 +55,7 @@ public void setBuzz(final boolean buzz)
         this.buzz = buzz;
     }
 
-    public final static EventFactory<FizzBuzzEvent> EVENT_FACTORY = new EventFactory<FizzBuzzEvent>()
+    public static final EventFactory<FizzBuzzEvent> EVENT_FACTORY = new EventFactory<FizzBuzzEvent>()
     {
         public FizzBuzzEvent newInstance()
         {

File: src/perftest/java/com/lmax/disruptor/support/FunctionEvent.java
Patch:
@@ -64,7 +64,7 @@ public void setStepTwoResult(final long stepTwoResult)
         this.stepTwoResult = stepTwoResult;
     }
 
-    public final static EventFactory<FunctionEvent> EVENT_FACTORY = new EventFactory<FunctionEvent>()
+    public static final EventFactory<FunctionEvent> EVENT_FACTORY = new EventFactory<FunctionEvent>()
     {
         public FunctionEvent newInstance()
         {

File: src/perftest/java/com/lmax/disruptor/support/ValueEvent.java
Patch:
@@ -31,7 +31,7 @@ public void setValue(final long value)
         this.value = value;
     }
 
-    public final static EventFactory<ValueEvent> EVENT_FACTORY = new EventFactory<ValueEvent>()
+    public static final EventFactory<ValueEvent> EVENT_FACTORY = new EventFactory<ValueEvent>()
     {
         public ValueEvent newInstance()
         {

File: src/test/java/com/lmax/disruptor/MultiProducerSequencerTest.java
Patch:
@@ -22,7 +22,7 @@
 
 public class MultiProducerSequencerTest
 {
-    private AbstractSequencer publisher = new MultiProducerSequencer(1024, new BlockingWaitStrategy());
+    private Sequencer publisher = new MultiProducerSequencer(1024, new BlockingWaitStrategy());
         
     @Test
     public void shouldOnlyAllowMessagesToBeAvailableIfSpecificallyPublished() throws Exception

File: src/test/java/com/lmax/disruptor/SequenceBarrierTest.java
Patch:
@@ -257,7 +257,7 @@ public void run()
         }
     }
 
-    private final static class CountDownLatchSequence extends Sequence
+    private static final class CountDownLatchSequence extends Sequence
     {
         private final CountDownLatch latch;
 

File: src/test/java/com/lmax/disruptor/SequencerTest.java
Patch:
@@ -22,8 +22,8 @@
 @RunWith(Parameterized.class)
 public class SequencerTest
 {
-    private final ExecutorService EXECUTOR = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
     private static final int BUFFER_SIZE = 16;
+    private final ExecutorService executor = Executors.newSingleThreadExecutor(DaemonThreadFactory.INSTANCE);
     
     private final Sequencer sequencer;
     private final Sequence gatingSequence = new Sequence();
@@ -98,7 +98,7 @@ public void shouldHoldUpPublisherWhenBufferIsFull()
         final long expectedFullSequence = Sequencer.INITIAL_CURSOR_VALUE + sequencer.getBufferSize();
         assertThat(sequencer.getCursor(), is(expectedFullSequence));
 
-        EXECUTOR.submit(new Runnable()
+        executor.submit(new Runnable()
         {
             @Override
             public void run()

File: src/test/java/com/lmax/disruptor/dsl/stubs/StubPublisher.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.lmax.disruptor.dsl.stubs;
 
-import com.lmax.disruptor.RingBuffer;
 import com.lmax.disruptor.RingBuffer;
 import com.lmax.disruptor.support.TestEvent;
 

File: src/test/java/com/lmax/disruptor/support/StubEvent.java
Patch:
@@ -62,7 +62,7 @@ public void setTestString(final String testString)
         this.testString = testString;
     }
 
-    public final static EventFactory<StubEvent> EVENT_FACTORY = new EventFactory<StubEvent>()
+    public static final EventFactory<StubEvent> EVENT_FACTORY = new EventFactory<StubEvent>()
     {
         public StubEvent newInstance()
         {

File: src/test/java/com/lmax/disruptor/support/TestEvent.java
Patch:
@@ -25,7 +25,7 @@ public String toString()
         return "Test Event";
     }
 
-    public final static EventFactory<TestEvent> EVENT_FACTORY = new EventFactory<TestEvent>()
+    public static final EventFactory<TestEvent> EVENT_FACTORY = new EventFactory<TestEvent>()
     {
         public TestEvent newInstance()
         {

File: src/main/java/com/lmax/disruptor/RingBuffer.java
Patch:
@@ -255,7 +255,7 @@ public void resetTo(long sequence)
      * @param sequence The sequence to claim.
      * @return The preallocated event.
      */
-    public E claimAndget(long sequence)
+    public E claimAndGetPreallocated(long sequence)
     {
         sequencer.claim(sequence);
         return get(sequence);

File: src/test/java/com/lmax/disruptor/MultiProducerSequencerTest.java
Patch:
@@ -18,11 +18,8 @@
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
 
-import org.jmock.integration.junit4.JMock;
 import org.junit.Test;
-import org.junit.runner.RunWith;
 
-@RunWith(JMock.class)
 public class MultiProducerSequencerTest
 {
     private AbstractSequencer publisher = new MultiProducerSequencer(1024, new BlockingWaitStrategy());

File: src/main/java/com/lmax/disruptor/MultiProducerSequencer.java
Patch:
@@ -211,7 +211,7 @@ public void publish(final long sequence)
     @Override
     public void publish(long lo, long hi)
     {
-        for (long l = lo; l < hi; l++)
+        for (long l = lo; l <= hi; l++)
         {
             setAvailable(l);
         }

File: src/test/java/com/lmax/disruptor/RingBufferTest.java
Patch:
@@ -307,6 +307,7 @@ public void translateTo(Object[] event, long sequence, Object...args)
         assertThat(ringBuffer.getPublished(1)[0], is((Object) "FooBarBazBam1"));
     }
 
+    @SuppressWarnings("unchecked")
     @Test
     public void shouldPublishEvents() throws Exception
     {
@@ -321,7 +322,7 @@ public void translateTo(final Object[] event, long sequence) {
                 event[0] = sequence;
             }
         };
-        final EventTranslator[] translators = new EventTranslator[] {eventTranslator1, eventTranslator2};
+        final EventTranslator<Object[]>[] translators = new EventTranslator[] {eventTranslator1, eventTranslator2};
 
         ringBuffer.publishEvents(translators);
         assertTrue(ringBuffer.tryPublishEvents(translators));

File: src/main/java/com/lmax/disruptor/Cursored.java
Patch:
@@ -17,7 +17,7 @@
 
 /**
  * Implementors of this interface must provide a single long value
- * that represents their current cursor value.  Use during dynamic
+ * that represents their current cursor value.  Used during dynamic
  * add/remove of Sequences from a 
  * {@link SequenceGroups#addSequences(Object, java.util.concurrent.atomic.AtomicReferenceFieldUpdater, Cursored, Sequence...)}.
  */

File: src/main/java/com/lmax/disruptor/SequenceGroup.java
Patch:
@@ -68,9 +68,9 @@ public void set(final long value)
 
     /**
      * Add a {@link Sequence} into this aggregate.  This should only be used during
-     * initialisation.  Use {@link SequenceGroup#addWhileRunning(RingBuffer, Sequence)}
+     * initialisation.  Use {@link SequenceGroup#addWhileRunning(Cursored, Sequence)}
      *
-     * @see SequenceGroup#addWhileRunning(RingBuffer, Sequence)
+     * @see SequenceGroup#addWhileRunning(Cursored, Sequence)
      * @param sequence to be added to the aggregate.
      */
     public void add(final Sequence sequence)

File: src/test/java/com/lmax/disruptor/dsl/stubs/StubExecutor.java
Patch:
@@ -51,6 +51,7 @@ public void joinAllThreads()
             {
                 try
                 {
+                    thread.interrupt();
                     thread.join(5000);
                 }
                 catch (InterruptedException e)

File: src/main/java/com/lmax/disruptor/dsl/Disruptor.java
Patch:
@@ -322,7 +322,7 @@ private boolean hasBacklog()
         final long cursor = ringBuffer.getCursor();
         for (Sequence consumer : consumerRepository.getLastSequenceInChain())
         {
-            if (cursor != consumer.get())
+            if (cursor > consumer.get())
             {
                 return true;
             }

File: src/perftest/java/com/lmax/disruptor/ThrottledOnePublisherToThreeProcessorPipelineLatencyTest.java
Patch:
@@ -270,8 +270,9 @@ private void runDisruptorPass() throws InterruptedException
 
         for (long i = 0; i < ITERATIONS; i++)
         {
+            long t0 = System.nanoTime();
             long sequence = ringBuffer.next();
-            ringBuffer.getPreallocated(sequence).setValue(System.nanoTime());
+            ringBuffer.getPreallocated(sequence).setValue(t0);
             ringBuffer.publish(sequence);
 
             long pauseStart = System.nanoTime();

File: src/main/java/com/lmax/disruptor/Sequencer.java
Patch:
@@ -74,4 +74,6 @@ interface Sequencer
      * @param sequence The sequence to initialise too.
      */
     void claim(long sequence);
+
+    long getBackOffCount();
 }
\ No newline at end of file

File: src/main/java/com/lmax/disruptor/BatchEventProcessor.java
Patch:
@@ -114,7 +114,7 @@ public void run()
                     nextSequence++;
                 }
 
-                sequence.setOrdered(availableSequence);
+                sequence.set(availableSequence);
             }
             catch (final AlertException ex)
             {
@@ -126,7 +126,7 @@ public void run()
             catch (final Throwable ex)
             {
                 exceptionHandler.handleEventException(ex, nextSequence, event);
-                sequence.setOrdered(nextSequence);
+                sequence.set(nextSequence);
                 nextSequence++;
             }
         }

File: src/main/java/com/lmax/disruptor/FixedSequenceGroup.java
Patch:
@@ -49,7 +49,7 @@ public String toString()
      * Not supported.
      */
     @Override
-    public void setOrdered(long value)
+    public void set(long value)
     {
         throw new UnsupportedOperationException();
     }

File: src/main/java/com/lmax/disruptor/Sequence.java
Patch:
@@ -29,6 +29,7 @@
  */
 public class Sequence
 {
+    static final long INITIAL_VALUE = -1L;
     private static final Unsafe unsafe;
     private static final long valueOffset;
 
@@ -47,7 +48,7 @@ public class Sequence
      */
     public Sequence()
     {
-        this(-1L);
+        this(INITIAL_VALUE);
     }
 
     /**
@@ -77,7 +78,7 @@ public long get()
      * 
      * @param value The new value for the sequence.
      */
-    public void setOrdered(final long value)
+    public void set(final long value)
     {
         unsafe.putOrderedLong(paddedValue, valueOffset, value);
     }

File: src/main/java/com/lmax/disruptor/SequenceGroup.java
Patch:
@@ -23,7 +23,7 @@
  * {@link Sequence} group that can dynamically have {@link Sequence}s added and removed while being
  * thread safe.
  * <p>
- * The {@link SequenceGroup#get()} and {@link SequenceGroup#setOrdered(long)} methods are lock free and can be
+ * The {@link SequenceGroup#get()} and {@link SequenceGroup#set(long)} methods are lock free and can be
  * concurrently be called with the {@link SequenceGroup#add(Sequence)} and {@link SequenceGroup#remove(Sequence)}.
  */
 public final class SequenceGroup extends Sequence
@@ -57,12 +57,12 @@ public long get()
      * @param value to set the group of sequences to.
      */
     @Override
-    public void setOrdered(final long value)
+    public void set(final long value)
     {
         final Sequence[] sequences = this.sequences;
         for (int i = 0, size = sequences.length; i < size; i++)
         {
-            sequences[i].setOrdered(value);
+            sequences[i].set(value);
         }
     }
 

File: src/main/java/com/lmax/disruptor/SequenceGroups.java
Patch:
@@ -39,7 +39,7 @@ static <T> void addSequences(final T holder,
             int index = currentSequences.length;
             for (Sequence sequence : sequencesToAdd)
             {
-                sequence.setOrdered(cursorSequence);
+                sequence.set(cursorSequence);
                 updatedSequences[index++] = sequence;
             }
         }
@@ -48,7 +48,7 @@ static <T> void addSequences(final T holder,
         cursorSequence = cursor.getCursor();
         for (Sequence sequence : sequencesToAdd)
         {
-            sequence.setOrdered(cursorSequence);
+            sequence.set(cursorSequence);
         }
     }
 

File: src/main/java/com/lmax/disruptor/SingleProducerPublisher.java
Patch:
@@ -28,7 +28,7 @@ public SingleProducerPublisher(WaitStrategy waitStrategy)
     @Override
     public void publish(long sequence)
     {
-        cursor.setOrdered(sequence);
+        cursor.set(sequence);
         waitStrategy.signalAllWhenBlocking();
     }
 

File: src/main/java/com/lmax/disruptor/WorkProcessor.java
Patch:
@@ -96,7 +96,7 @@ public void run()
                 {
                     processedSequence = false;
                     nextSequence = workSequence.incrementAndGet();
-                    sequence.setOrdered(nextSequence - 1L);
+                    sequence.set(nextSequence - 1L);
                 }
 
                 sequenceBarrier.waitFor(nextSequence);

File: src/main/java/com/lmax/disruptor/WorkerPool.java
Patch:
@@ -124,11 +124,11 @@ public RingBuffer<T> start(final Executor executor)
         }
 
         final long cursor = ringBuffer.getCursor();
-        workSequence.setOrdered(cursor);
+        workSequence.set(cursor);
 
         for (WorkProcessor<?> processor : workProcessors)
         {
-            processor.getSequence().setOrdered(cursor);
+            processor.getSequence().set(cursor);
             executor.execute(processor);
         }
 

File: src/main/java/com/lmax/disruptor/dsl/Disruptor.java
Patch:
@@ -61,16 +61,16 @@ public Disruptor(final EventFactory<T> eventFactory, final int ringBufferSize, f
      *
      * @param eventFactory   the factory to create events in the ring buffer.
      * @param executor       an {@link Executor} to execute event processors.
-     * @param claimStrategy  the claim strategy to use for the ring buffer.
+     * @param producerType   the claim strategy to use for the ring buffer.
      * @param waitStrategy   the wait strategy to use for the ring buffer.
      */
     public Disruptor(final EventFactory<T> eventFactory,
                      final int ringBufferSize,
                      final Executor executor,
-                     final ProducerType claimStrategy,
+                     final ProducerType producerType,
                      final WaitStrategy waitStrategy)
     {
-        this(RingBuffer.createMultiProducer(eventFactory, ringBufferSize, waitStrategy),
+        this(RingBuffer.create(producerType, eventFactory, ringBufferSize, waitStrategy),
              executor);
     }
 

File: src/test/java/com/lmax/disruptor/FixedSequenceGroupTest.java
Patch:
@@ -32,9 +32,9 @@ public void shouldReturnMinimumOf2Sequences() throws Exception
         Sequence group = new FixedSequenceGroup(new Sequence[] { sequence1, sequnece2 });
 
         assertThat(group.get(), is(34L));
-        sequence1.setOrdered(35);
+        sequence1.set(35);
         assertThat(group.get(), is(35L));
-        sequence1.setOrdered(48);
+        sequence1.set(48);
         assertThat(group.get(), is(47L));
     }
 }

File: src/test/java/com/lmax/disruptor/RingBufferTest.java
Patch:
@@ -318,8 +318,8 @@ public void shouldAddAndRemoveSequences() throws Exception
             ringBuffer.publish(ringBuffer.next());
         }
         
-        sequenceThree.setOrdered(3);
-        sequenceSeven.setOrdered(7);
+        sequenceThree.set(3);
+        sequenceSeven.set(7);
         
         assertThat(ringBuffer.getMinimumGatingSequence(), is(3L));
         assertTrue(ringBuffer.removeGatingSequence(sequenceThree));
@@ -372,7 +372,7 @@ public void run()
                 throw new RuntimeException(ex);
             }
 
-            sequence.setOrdered(sequence.get() + 1L);
+            sequence.set(sequence.get() + 1L);
         }
     }
     

File: src/test/java/com/lmax/disruptor/SequenceBarrierTest.java
Patch:
@@ -237,7 +237,7 @@ private static final class StubEventProcessor implements EventProcessor
 
         public void setSequence(long sequence)
         {
-            this.sequence.setOrdered(sequence);
+            this.sequence.set(sequence);
         }
 
         @Override

File: src/test/java/com/lmax/disruptor/SequenceGroupTest.java
Patch:
@@ -121,7 +121,7 @@ public void shouldSetGroupSequenceToSameValue()
         sequenceGroup.add(sequenceThree);
 
         final long expectedSequence = 11L;
-        sequenceGroup.setOrdered(expectedSequence);
+        sequenceGroup.set(expectedSequence);
 
         assertEquals(expectedSequence, sequenceThree.get());
         assertEquals(expectedSequence, sequenceSeven.get());

File: src/test/java/com/lmax/disruptor/SequenceReportingCallbackTest.java
Patch:
@@ -68,7 +68,7 @@ public void setSequenceCallback(final Sequence sequenceTrackerCallback)
         @Override
         public void onEvent(final StubEvent event, final long sequence, final boolean endOfBatch) throws Exception
         {
-            sequenceCallback.setOrdered(sequence);
+            sequenceCallback.set(sequence);
             callbackLatch.countDown();
         }
     }

File: src/test/java/com/lmax/disruptor/SingleProducerSequencerTest.java
Patch:
@@ -79,7 +79,7 @@ public void run()
                 waitingLatch.countDown();
 
                 long next = sequencer.next(gatingSequences);
-                cursor.setOrdered(next);
+                cursor.set(next);
 
                 doneLatch.countDown();
             }
@@ -88,7 +88,7 @@ public void run()
         waitingLatch.await();
         assertThat(sequencer.getNextValue(), is(expectedFullSequence));
 
-        gatingSequences[0].setOrdered(Sequencer.INITIAL_CURSOR_VALUE + 1L);
+        gatingSequences[0].set(Sequencer.INITIAL_CURSOR_VALUE + 1L);
 
         doneLatch.await();
         assertThat(sequencer.getNextValue(), is(expectedFullSequence + 1L));
@@ -121,7 +121,7 @@ private void fillBuffer()
         for (int i = 0; i < BUFFER_SIZE; i++)
         {
             long next = sequencer.next(gatingSequences);
-            cursor.setOrdered(next);
+            cursor.set(next);
         }
     }
 }

File: src/main/java/com/lmax/disruptor/dsl/Disruptor.java
Patch:
@@ -164,7 +164,7 @@ public EventHandlerGroup<T> after(final EventHandler<T>... handlers)
      *
      * @param processors the event processors, previously set up with {@link #handleEventsWith(com.lmax.disruptor.EventProcessor...)},
      *                   that will form the barrier for subsequent handlers or processors.
-     * @return an {@link EventHandlerGroup} that can be used to setup a {@link SequenceBarrier} over hte specified event processors.
+     * @return an {@link EventHandlerGroup} that can be used to setup a {@link SequenceBarrier} over the specified event processors.
      * @see #after(com.lmax.disruptor.EventHandler[])
      */
     public EventHandlerGroup<T> after(final EventProcessor... processors)

File: src/perftest/java/com/lmax/disruptor/TwoPublisherToTwoProcessorWorkProcessorThroughputTest.java
Patch:
@@ -97,7 +97,7 @@
  */
 public final class TwoPublisherToTwoProcessorWorkProcessorThroughputTest extends AbstractPerfTestQueueVsDisruptor
 {
-    private static final int NUM_PUBLISHERS = 1;
+    private static final int NUM_PUBLISHERS = 2;
     private static final int BUFFER_SIZE = 1024 * 64;
     private static final long ITERATIONS = 1000L * 1000L * 1L;
     private final ExecutorService EXECUTOR = Executors.newFixedThreadPool(NUM_PUBLISHERS + 2);
@@ -132,7 +132,7 @@ handlers[1], new IgnoreExceptionHandler(),
     {
         for (int i = 0; i < NUM_PUBLISHERS; i++)
         {
-            valuePublishers[i] = new ValuePublisher(cyclicBarrier, ringBuffer, ITERATIONS / NUM_PUBLISHERS);
+            valuePublishers[i] = new ValuePublisher(cyclicBarrier, ringBuffer, ITERATIONS);
         }
 
         ringBuffer.addGatingSequences(workProcessors[0].getSequence(), workProcessors[1].getSequence());

File: src/main/java/com/lmax/disruptor/Sequence.java
Patch:
@@ -47,7 +47,7 @@ public class Sequence
      */
     public Sequence()
     {
-        setOrdered(-1);
+        this(-1L);
     }
 
     /**
@@ -57,7 +57,7 @@ public Sequence()
      */
     public Sequence(final long initialValue)
     {
-        setOrdered(initialValue);
+        unsafe.putOrderedLong(paddedValue, valueOffset, initialValue);
     }
 
     /**

File: src/test/java/com/lmax/disruptor/dsl/EventProcessorRepositoryTest.java
Patch:
@@ -38,7 +38,6 @@ public class EventProcessorRepositoryTest
     private SequenceBarrier barrier1;
     private SequenceBarrier barrier2;
 
-    @SuppressWarnings({"unchecked"})
     @Before
     public void setUp() throws Exception
     {

File: src/test/java/com/lmax/disruptor/util/UtilTest.java
Patch:
@@ -16,7 +16,6 @@
 package com.lmax.disruptor.util;
 
 import static org.hamcrest.CoreMatchers.*;
-import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
 
 import java.nio.ByteBuffer;

File: src/main/java/com/lmax/disruptor/SequenceGroups.java
Patch:
@@ -93,7 +93,7 @@ private static <T> int countMatching(T[] values, final T toMatch)
         int numToRemove = 0;
         for (T value : values)
         {
-            if (value == toMatch) // Specificly uses identity
+            if (value == toMatch) // Specifically uses identity
             {
                 numToRemove++;
             }

File: src/main/java/com/lmax/disruptor/AbstractSequencer.java
Patch:
@@ -50,8 +50,6 @@ public void setGatingSequences(final Sequence cursor, final Sequence... sequence
         }
         while (!sequenceUpdater.compareAndSet(this, gatingSequences, tempGatingSequences));
         
-        this.gatingSequences = tempGatingSequences;
-        
         cursorSequence = cursor.get();
         for (Sequence sequence : tempGatingSequences)
         {

File: src/main/java/com/lmax/disruptor/SequenceBarrier.java
Patch:
@@ -33,7 +33,7 @@ public interface SequenceBarrier
     long waitFor(long sequence) throws AlertException, InterruptedException;
 
     /**
-     * Delegate a call to the {@link SingleProducerSequencer#getCursor()}
+     * Get the current cursor value that can be read.
      *
      * @return value of the cursor for entries that have been published.
      */

File: src/main/java/com/lmax/disruptor/dsl/Disruptor.java
Patch:
@@ -252,7 +252,6 @@ public RingBuffer<T> getRingBuffer()
      * Get the value of the cursor indicating the published sequence.
      *
      * @return value of the cursor for events that have been published.
-     * @see com.lmax.disruptor.Sequencer#getCursor()
      */
     public long getCursor()
     {

File: code/src/test/com/lmax/disruptor/WaitStrategyTestUtil.java
Patch:
@@ -17,7 +17,7 @@ static void assertWaitForWithDelayOf(long sleepTimeMillis, WaitStrategy waitStra
         SequenceUpdater sequenceUpdater = new SequenceUpdater(sleepTimeMillis, waitStrategy);
         EXECUTOR.execute(sequenceUpdater);
         sequenceUpdater.waitForStartup();
-        Sequence cursor = new Sequence();
+        Sequence cursor = new Sequence(0);
         long sequence = waitStrategy.waitFor(0, cursor, sequenceUpdater.sequence, new DummySequenceBarrier());
         
         assertThat(sequence, is(0L));

File: code/src/main/com/lmax/disruptor/BusySpinWaitStrategy.java
Patch:
@@ -26,7 +26,7 @@
 public final class BusySpinWaitStrategy implements WaitStrategy
 {
     @Override
-    public long waitFor(final long sequence, final Sequence dependentSequence, final SequenceBarrier barrier)
+    public long waitFor(final long sequence, Sequence cursor, final Sequence dependentSequence, final SequenceBarrier barrier)
         throws AlertException, InterruptedException
     {
         long availableSequence;

File: code/src/main/com/lmax/disruptor/PhasedBackoffWaitStrategy.java
Patch:
@@ -60,7 +60,7 @@ public static PhasedBackoffWaitStrategy withSleep(long spinTimeoutMillis,
     }
     
     @Override
-    public long waitFor(long sequence, Sequence dependentSequence, SequenceBarrier barrier) 
+    public long waitFor(long sequence, Sequence cursor, Sequence dependentSequence, SequenceBarrier barrier) 
         throws AlertException, InterruptedException
     {
         return waitFor(sequence, dependentSequence, barrier, Long.MAX_VALUE, TimeUnit.SECONDS);

File: code/src/main/com/lmax/disruptor/ProcessingSequenceBarrier.java
Patch:
@@ -25,12 +25,14 @@ final class ProcessingSequenceBarrier implements SequenceBarrier
     private final WaitStrategy waitStrategy;
     private final Sequence dependentSequence;
     private volatile boolean alerted = false;
+    private Sequence cursorSequence;
 
     public ProcessingSequenceBarrier(final WaitStrategy waitStrategy,
                                      final Sequence cursorSequence,
                                      final Sequence[] dependentSequences)
     {
         this.waitStrategy = waitStrategy;
+        this.cursorSequence = cursorSequence;
         if (0 == dependentSequences.length)
         {
             dependentSequence = cursorSequence;
@@ -47,7 +49,7 @@ public long waitFor(final long sequence)
     {
         checkAlert();
 
-        return waitStrategy.waitFor(sequence, dependentSequence, this);
+        return waitStrategy.waitFor(sequence, cursorSequence, dependentSequence, this);
     }
 
     @Override

File: code/src/main/com/lmax/disruptor/SleepingWaitStrategy.java
Patch:
@@ -29,7 +29,7 @@ public final class SleepingWaitStrategy implements WaitStrategy
     private static final int RETRIES = 200;
 
     @Override
-    public long waitFor(final long sequence, final Sequence dependentSequence, final SequenceBarrier barrier)
+    public long waitFor(final long sequence, Sequence cursor, final Sequence dependentSequence, final SequenceBarrier barrier)
         throws AlertException, InterruptedException
     {
         long availableSequence;

File: code/src/main/com/lmax/disruptor/WaitStrategy.java
Patch:
@@ -26,13 +26,14 @@ public interface WaitStrategy
      * Wait for the given sequence to be available
      *
      * @param sequence to be waited on.
+     * @param cursor TODO
      * @param dependentSequence on which to wait.
      * @param barrier the processor is waiting on.
      * @return the sequence that is available which may be greater than the requested sequence.
      * @throws AlertException if the status of the Disruptor has changed.
      * @throws InterruptedException if the thread is interrupted.
      */
-    long waitFor(long sequence, Sequence dependentSequence, SequenceBarrier barrier)
+    long waitFor(long sequence, Sequence cursor, Sequence dependentSequence, SequenceBarrier barrier)
         throws AlertException, InterruptedException;
 
     /**

File: code/src/main/com/lmax/disruptor/YieldingWaitStrategy.java
Patch:
@@ -28,7 +28,7 @@ public final class YieldingWaitStrategy implements WaitStrategy
     private static final int SPIN_TRIES = 100;
 
     @Override
-    public long waitFor(final long sequence, final Sequence dependentSequence, final SequenceBarrier barrier)
+    public long waitFor(final long sequence, Sequence cursor, final Sequence dependentSequence, final SequenceBarrier barrier)
         throws AlertException, InterruptedException
     {
         long availableSequence;

File: code/src/test/com/lmax/disruptor/WaitStrategyTestUtil.java
Patch:
@@ -18,7 +18,8 @@ static void assertWaitForWithDelayOf(long sleepTimeMillis, WaitStrategy waitStra
         SequenceUpdater sequenceUpdater = new SequenceUpdater(sleepTimeMillis, waitStrategy);
         EXECUTOR.execute(sequenceUpdater);
         sequenceUpdater.waitForStartup();
-        long sequence = waitStrategy.waitFor(0, sequenceUpdater.sequence, new DummySequenceBarrier());
+        Sequence cursor = new Sequence();
+        long sequence = waitStrategy.waitFor(0, cursor, sequenceUpdater.sequence, new DummySequenceBarrier());
         
         assertThat(sequence, is(0L));
     }

File: code/src/main/com/lmax/disruptor/EventTranslator.java
Patch:
@@ -27,7 +27,6 @@ public interface EventTranslator<T>
      *
      * @param event into which the data should be translated.
      * @param sequence that is assigned to event.
-     * @return the resulting event after it has been updated.
      */
     void translateTo(final T event, long sequence);
 }

File: code/src/main/com/lmax/disruptor/EventPublisher.java
Patch:
@@ -55,7 +55,7 @@ public void publishEvent(final EventTranslator<E> translator)
      * 
      * @param translator The user specified translation for the event
      * @param capacity The capacity that should be available before publishing
-     * @returns true if the value was published, false if there was insufficient
+     * @return true if the value was published, false if there was insufficient
      * capacity.
      */
     public boolean tryPublishEvent(EventTranslator<E> translator, int capacity)

File: code/src/perf/com/lmax/disruptor/OnePublisherToThreeProcessorDiamondThroughputTest.java
Patch:
@@ -180,7 +180,7 @@ protected long runQueuePass() throws Exception
         final CountDownLatch latch = new CountDownLatch(1);
         fizzBuzzQueueProcessor.reset(latch);
 
-        Future[] futures = new Future[NUM_EVENT_PROCESSORS];
+        Future<?>[] futures = new Future[NUM_EVENT_PROCESSORS];
         futures[0] = EXECUTOR.submit(fizzQueueProcessor);
         futures[1] = EXECUTOR.submit(buzzQueueProcessor);
         futures[2] = EXECUTOR.submit(fizzBuzzQueueProcessor);
@@ -201,7 +201,7 @@ protected long runQueuePass() throws Exception
         buzzQueueProcessor.halt();
         fizzBuzzQueueProcessor.halt();
 
-        for (Future future : futures)
+        for (Future<?> future : futures)
         {
             future.cancel(true);
         }

File: code/src/perf/com/lmax/disruptor/OnePublisherToThreeProcessorMultiCastThroughputTest.java
Patch:
@@ -139,7 +139,7 @@ public final class OnePublisherToThreeProcessorMultiCastThroughputTest extends A
         handlers[2] = new ValueMutationEventHandler(Operation.AND);
     }
 
-    private final BatchEventProcessor[] batchEventProcessors = new BatchEventProcessor[NUM_EVENT_PROCESSORS];
+    private final BatchEventProcessor<?>[] batchEventProcessors = new BatchEventProcessor[NUM_EVENT_PROCESSORS];
     {
         batchEventProcessors[0] = new BatchEventProcessor<ValueEvent>(ringBuffer, sequenceBarrier, handlers[0]);
         batchEventProcessors[1] = new BatchEventProcessor<ValueEvent>(ringBuffer, sequenceBarrier, handlers[1]);
@@ -169,7 +169,7 @@ public void shouldCompareDisruptorVsQueues() throws Exception
     protected long runQueuePass() throws InterruptedException
     {
         CountDownLatch latch = new CountDownLatch(NUM_EVENT_PROCESSORS);
-        Future[] futures = new Future[NUM_EVENT_PROCESSORS];
+        Future<?>[] futures = new Future[NUM_EVENT_PROCESSORS];
         for (int i = 0; i < NUM_EVENT_PROCESSORS; i++)
         {
             queueProcessors[i].reset(latch);

File: code/src/perf/com/lmax/disruptor/OnePublisherToThreeProcessorPipelineThroughputTest.java
Patch:
@@ -163,7 +163,7 @@ protected long runQueuePass() throws Exception
         CountDownLatch latch = new CountDownLatch(1);
         stepThreeQueueProcessor.reset(latch);
 
-        Future[] futures = new Future[NUM_EVENT_PROCESSORS];
+        Future<?>[] futures = new Future[NUM_EVENT_PROCESSORS];
         futures[0] = EXECUTOR.submit(stepOneQueueProcessor);
         futures[1] = EXECUTOR.submit(stepTwoQueueProcessor);
         futures[2] = EXECUTOR.submit(stepThreeQueueProcessor);
@@ -186,7 +186,7 @@ protected long runQueuePass() throws Exception
         stepTwoQueueProcessor.halt();
         stepThreeQueueProcessor.halt();
 
-        for (Future future : futures)
+        for (Future<?> future : futures)
         {
             future.cancel(true);
         }

File: code/src/perf/com/lmax/disruptor/OnePublisherToThreeWorkerPoolThroughputTest.java
Patch:
@@ -86,7 +86,7 @@ public void shouldCompareDisruptorVsQueues() throws Exception
     protected long runQueuePass() throws InterruptedException
     {
         resetCounters();
-        Future[] futures = new Future[NUM_WORKERS];
+        Future<?>[] futures = new Future[NUM_WORKERS];
         for (int i = 0; i < NUM_WORKERS; i++)
         {
             futures[i] = EXECUTOR.submit(queueWorkers[i]);

File: code/src/perf/com/lmax/disruptor/ThreePublisherToOneProcessorSequencedThroughputTest.java
Patch:
@@ -149,12 +149,12 @@ protected long runQueuePass() throws Exception
         final CountDownLatch latch = new CountDownLatch(1);
         queueProcessor.reset(latch);
 
-        Future[] futures = new Future[NUM_PUBLISHERS];
+        Future<?>[] futures = new Future[NUM_PUBLISHERS];
         for (int i = 0; i < NUM_PUBLISHERS; i++)
         {
             futures[i] = EXECUTOR.submit(valueQueuePublishers[i]);
         }
-        Future processorFuture = EXECUTOR.submit(queueProcessor);
+        Future<?> processorFuture = EXECUTOR.submit(queueProcessor);
 
         long start = System.currentTimeMillis();
         cyclicBarrier.await();
@@ -179,7 +179,7 @@ protected long runDisruptorPass() throws Exception
         final CountDownLatch latch = new CountDownLatch(1);
         handler.reset(latch, batchEventProcessor.getSequence().get() + ((ITERATIONS / NUM_PUBLISHERS) * NUM_PUBLISHERS));
 
-        Future[] futures = new Future[NUM_PUBLISHERS];
+        Future<?>[] futures = new Future[NUM_PUBLISHERS];
         for (int i = 0; i < NUM_PUBLISHERS; i++)
         {
             futures[i] = EXECUTOR.submit(valuePublishers[i]);

File: code/src/perf/com/lmax/disruptor/ThrottledOnePublisherToThreeProcessorPipelineLatencyTest.java
Patch:
@@ -233,7 +233,7 @@ private void runQueuePass() throws Exception
         CountDownLatch latch = new CountDownLatch(1);
         stepThreeQueueProcessor.reset(latch);
 
-        Future[] futures = new Future[NUM_EVENT_PROCESSORS];
+        Future<?>[] futures = new Future[NUM_EVENT_PROCESSORS];
         futures[0] = EXECUTOR.submit(stepOneQueueProcessor);
         futures[1] = EXECUTOR.submit(stepTwoQueueProcessor);
         futures[2] = EXECUTOR.submit(stepThreeQueueProcessor);
@@ -254,7 +254,7 @@ private void runQueuePass() throws Exception
         stepTwoQueueProcessor.halt();
         stepThreeQueueProcessor.halt();
 
-        for (Future future : futures)
+        for (Future<?> future : futures)
         {
             future.cancel(true);
         }

File: code/src/main/com/lmax/disruptor/SequenceGroup.java
Patch:
@@ -28,13 +28,15 @@
  */
 public final class SequenceGroup extends Sequence
 {
-    private final AtomicReference<Sequence[]> sequencesRef = new AtomicReference<Sequence[]>(new Sequence[0]);
+    private final AtomicReference<Sequence[]> sequencesRef;
 
     /**
      * Default Constructor
      */
     public SequenceGroup()
     {
+        super(-1);
+        sequencesRef = new AtomicReference<Sequence[]>(new Sequence[0]);
     }
 
     /**

File: code/src/main/com/lmax/disruptor/collections/Histogram.java
Patch:
@@ -137,7 +137,8 @@ private void trackRange(final long value)
         {
             minValue = value;
         }
-        else if (value > maxValue)
+        
+        if (value > maxValue)
         {
             maxValue = value;
         }

File: code/src/main/com/lmax/disruptor/RingBuffer.java
Patch:
@@ -53,7 +53,7 @@ public RingBuffer(final EventFactory<T> eventFactory,
 
     /**
      * Construct a RingBuffer with default strategies of:
-     * {@link MultiThreadedClaimStrategy} and {@link BlockingWaitStrategy}
+     * {@link MultiThreadedLowContentionClaimStrategy} and {@link BlockingWaitStrategy}
      *
      * @param eventFactory to newInstance entries for filling the RingBuffer
      * @param bufferSize of the RingBuffer that will be rounded up to the next power of 2

File: code/src/perf/com/lmax/disruptor/ThreePublisherToOneProcessorSequencedThroughputTest.java
Patch:
@@ -112,7 +112,7 @@ public final class ThreePublisherToOneProcessorSequencedThroughputTest extends A
 
     private final RingBuffer<ValueEvent> ringBuffer =
         new RingBuffer<ValueEvent>(ValueEvent.EVENT_FACTORY,
-                                   new MultiThreadedClaimStrategy(BUFFER_SIZE),
+                                   new MultiThreadedLowContentionClaimStrategy(BUFFER_SIZE),
                                    new YieldingWaitStrategy());
 
     private final SequenceBarrier sequenceBarrier = ringBuffer.newBarrier();

File: code/src/main/com/lmax/disruptor/EventPublisher.java
Patch:
@@ -54,7 +54,9 @@ public void publishEvent(final EventTranslator<E> translator)
      * after translation.
      * 
      * @param translator The user specified translation for the event
-     * @throws TimeoutException 
+     * @param timeout period to wait
+     * @param units for the timeout period
+     * @throws TimeoutException if the timeout period has expired
      */
     public void publishEvent(final EventTranslator<E> translator, long timeout, TimeUnit units) throws TimeoutException
     {

File: code/src/main/com/lmax/disruptor/BlockingWaitStrategy.java
Patch:
@@ -70,7 +70,7 @@ public long waitFor(final long sequence, final Sequence cursor, final Sequence[]
 
     @Override
     public long waitFor(final long sequence, final Sequence cursor, final Sequence[] dependents, final SequenceBarrier barrier,
-                        final long timeout, final TimeUnit units)
+                        final long timeout, final TimeUnit sourceUnit)
         throws AlertException, InterruptedException
     {
         long availableSequence;
@@ -84,7 +84,7 @@ public long waitFor(final long sequence, final Sequence cursor, final Sequence[]
                 {
                     barrier.checkAlert();
 
-                    if (!processorNotifyCondition.await(timeout, units))
+                    if (!processorNotifyCondition.await(timeout, sourceUnit))
                     {
                         break;
                     }

File: code/src/main/com/lmax/disruptor/BusySpinWaitStrategy.java
Patch:
@@ -53,10 +53,10 @@ public long waitFor(final long sequence, final Sequence cursor, final Sequence[]
 
     @Override
     public long waitFor(final long sequence, final Sequence cursor, final Sequence[] dependents, final SequenceBarrier barrier,
-                        final long timeout, final TimeUnit units)
+                        final long timeout, final TimeUnit sourceUnit)
         throws AlertException, InterruptedException
     {
-        final long timeoutMs = units.convert(timeout, TimeUnit.MILLISECONDS);
+        final long timeoutMs = TimeUnit.MILLISECONDS.convert(timeout, sourceUnit);
         final long startTime = System.currentTimeMillis();
         long availableSequence;
 

File: code/src/main/com/lmax/disruptor/Sequencer.java
Patch:
@@ -235,9 +235,9 @@ private void publish(final long sequence, final int batchSize)
         waitStrategy.signalAllWhenBlocking();
     }
 
-    private void waitForCapacity(final int capacity, final long timeout, final TimeUnit units) throws TimeoutException
+    private void waitForCapacity(final int capacity, final long timeout, final TimeUnit sourceUnit) throws TimeoutException
     {
-        final long timeoutMs = units.convert(timeout, TimeUnit.MILLISECONDS);
+        final long timeoutMs = TimeUnit.MILLISECONDS.convert(timeout, sourceUnit);
         final long startTime = System.currentTimeMillis();
 
         while (!claimStrategy.hasAvailableCapacity(capacity, gatingSequences))

File: code/src/main/com/lmax/disruptor/SleepingWaitStrategy.java
Patch:
@@ -57,10 +57,10 @@ public long waitFor(final long sequence, final Sequence cursor, final Sequence[]
 
     @Override
     public long waitFor(final long sequence, final Sequence cursor, final Sequence[] dependents, final SequenceBarrier barrier,
-                        final long timeout, final TimeUnit units)
+                        final long timeout, final TimeUnit sourceUnit)
         throws AlertException, InterruptedException
     {
-        final long timeoutMs = units.convert(timeout, TimeUnit.MILLISECONDS);
+        final long timeoutMs = TimeUnit.MILLISECONDS.convert(timeout, sourceUnit);
         final long startTime = System.currentTimeMillis();
         long availableSequence;
         int counter = RETRIES;

File: code/src/main/com/lmax/disruptor/YieldingWaitStrategy.java
Patch:
@@ -56,10 +56,10 @@ public long waitFor(final long sequence, final Sequence cursor, final Sequence[]
 
     @Override
     public long waitFor(final long sequence, final Sequence cursor, final Sequence[] dependents, final SequenceBarrier barrier,
-                        final long timeout, final TimeUnit units)
+                        final long timeout, final TimeUnit sourceUnit)
         throws AlertException, InterruptedException
     {
-        final long timeoutMs = units.convert(timeout, TimeUnit.MILLISECONDS);
+        final long timeoutMs = TimeUnit.MILLISECONDS.convert(timeout, sourceUnit);
         final long startTime = System.currentTimeMillis();
         long availableSequence;
         int counter = SPIN_TRIES;

File: code/src/main/com/lmax/disruptor/dsl/Disruptor.java
Patch:
@@ -81,7 +81,7 @@ private Disruptor(final RingBuffer<T> ringBuffer, final Executor executor)
     }
 
     /**
-     * Set up event handlers to handle events from the ring buffer. These handlers will process events
+     * Set up event handlers to handleEventException events from the ring buffer. These handlers will process events
      * as soon as they become available, in parallel.
      * <p/>
      * <p>This method can be used as the start of a chain. For example if the handler <code>A</code> must
@@ -99,7 +99,7 @@ public EventHandlerGroup<T> handleEventsWith(final EventHandler<T>... handlers)
     }
 
     /**
-     * Set up custom event processors to handle events from the ring buffer. The Disruptor will
+     * Set up custom event processors to handleEventException events from the ring buffer. The Disruptor will
      * automatically start this processors when {@link #start()} is called.
      *
      * @param processors the event processors that will process events.

File: code/src/main/com/lmax/disruptor/dsl/EventHandlerGroup.java
Patch:
@@ -98,7 +98,7 @@ public EventHandlerGroup<T> then(final EventHandler<T>... handlers)
     }
 
     /**
-     * Set up batch handlers to handle events from the ring buffer. These handlers will only process events
+     * Set up batch handlers to handleEventException events from the ring buffer. These handlers will only process events
      * after every {@link EventProcessor} in this group has processed the event.
      *
      * <p>This method is generally used as part of a chain. For example if the handler <code>A</code> must

File: code/src/test/com/lmax/disruptor/AggregateEventHandlerTest.java
Patch:
@@ -30,6 +30,7 @@ public final class AggregateEventHandlerTest
             setImposteriser(ClassImposteriser.INSTANCE);
         }
     };
+
     private final org.jmock.Sequence callSequence = context.sequence("callSequence");
 
     private final LifecycleAwareEventHandler<int[]> eh1 = context.mock(LifecycleAwareEventHandler.class, "eh1");
@@ -119,10 +120,9 @@ public void shouldHandleEmptyListOfEventHandlers() throws Exception
         aggregateEventHandler.onShutdown();
     }
 
-    private static class LifecycleAwareEventHandler<T>
+    public static class LifecycleAwareEventHandler<T>
         implements EventHandler<T>, LifecycleAware
     {
-
         @Override
         public void onEvent(final T event, final long sequence, final boolean endOfBatch) throws Exception
         {

File: code/src/test/com/lmax/disruptor/BatchEventProcessorTest.java
Patch:
@@ -138,7 +138,7 @@ public void describeTo(final Description description)
                     }
                 });
 
-                oneOf(exceptionHandler).handle(ex, 0L, ringBuffer.get(0));
+                oneOf(exceptionHandler).handleEventException(ex, 0L, ringBuffer.get(0));
                 inSequence(lifecycleSequence);
                 will(countDown(latch));
             }

File: code/src/test/com/lmax/disruptor/FatalExceptionHandlerTest.java
Patch:
@@ -56,7 +56,7 @@ public void shouldHandleFatalException()
 
         try
         {
-            exceptionHandler.handle(causeException, 0L, event);
+            exceptionHandler.handleEventException(causeException, 0L, event);
         }
         catch (RuntimeException ex)
         {

File: code/src/test/com/lmax/disruptor/IgnoreExceptionHandlerTest.java
Patch:
@@ -52,6 +52,6 @@ public void shouldHandleAndIgnoreException()
         });
 
         ExceptionHandler exceptionHandler = new IgnoreExceptionHandler(logger);
-        exceptionHandler.handle(ex, 0L, event);
+        exceptionHandler.handleEventException(ex, 0L, event);
     }
 }

File: code/src/main/com/lmax/disruptor/ClaimStrategy.java
Patch:
@@ -112,7 +112,7 @@ static final class MultiThreadedStrategy
         private final int bufferSize;
         private final PaddedAtomicLong sequence = new PaddedAtomicLong(Sequencer.INITIAL_CURSOR_VALUE);
 
-        private static final ThreadLocal<MutableLong> minGatingSequenceThreadLocal = new ThreadLocal<MutableLong>()
+        private final ThreadLocal<MutableLong> minGatingSequenceThreadLocal = new ThreadLocal<MutableLong>()
         {
             @Override
             protected MutableLong initialValue()

File: code/src/main/com/lmax/disruptor/RingBuffer.java
Patch:
@@ -63,7 +63,7 @@ public RingBuffer(final EventFactory<T> eventFactory, final int size)
     {
         this(eventFactory, size,
              ClaimStrategy.Option.MULTI_THREADED,
-             WaitStrategy.Option.SLEEPING);
+             WaitStrategy.Option.BLOCKING);
     }
 
     /**

File: code/src/main/com/lmax/disruptor/RingBuffer.java
Patch:
@@ -61,7 +61,7 @@ public RingBuffer(final EventFactory<T> eventFactory, final int size,
 
     /**
      * Construct a RingBuffer with default strategies of:
-     * {@link ClaimStrategy.Option#MULTI_THREADED} and {@link WaitStrategy.Option#BLOCKING}
+     * {@link ClaimStrategy.Option#MULTI_THREADED} and {@link WaitStrategy.Option#SLEEPING}
      *
      * @param eventFactory to create events for filling the RingBuffer
      * @param size of the RingBuffer that will be rounded up to the next power of 2
@@ -70,7 +70,7 @@ public RingBuffer(final EventFactory<T> eventFactory, final int size)
     {
         this(eventFactory, size,
              ClaimStrategy.Option.MULTI_THREADED,
-             WaitStrategy.Option.BLOCKING);
+             WaitStrategy.Option.SLEEPING);
     }
 
     /**

File: code/src/main/com/lmax/disruptor/EventFactory.java
Patch:
@@ -16,11 +16,11 @@
 package com.lmax.disruptor;
 
 /**
- * Called by the {@link RingBuffer} to pre-populate all the {@link AbstractEvent}s to fill the RingBuffer.
+ * Called by the {@link RingBuffer} to pre-populate all the events to fill the RingBuffer.
  * 
- * @param <T> AbstractEvent implementation storing the data for sharing during exchange or parallel coordination of an event.
+ * @param <T> event implementation storing the data for sharing during exchange or parallel coordination of an event.
  */
-public interface EventFactory<T extends AbstractEvent>
+public interface EventFactory<T>
 {
     T create();
 }
\ No newline at end of file

File: code/src/main/com/lmax/disruptor/EventProcessor.java
Patch:
@@ -16,7 +16,7 @@
 package com.lmax.disruptor;
 
 /**
- * EventProcessors waitFor {@link AbstractEvent}s to become available for consumption from the {@link RingBuffer}
+ * EventProcessors waitFor events to become available for consumption from the {@link RingBuffer}
  *
  * An EventProcessor will be associated with a Thread for execution.
  */

File: code/src/main/com/lmax/disruptor/FatalExceptionHandler.java
Patch:
@@ -38,9 +38,9 @@ public FatalExceptionHandler(final Logger logger)
     }
 
     @Override
-    public void handle(final Exception ex, final AbstractEvent currentEvent)
+    public void handle(final Exception ex, final long sequence, final Object event)
     {
-        logger.log(Level.SEVERE, "Exception processing: " + currentEvent, ex);
+        logger.log(Level.SEVERE, "Exception processing: " + sequence + " " + event, ex);
 
         throw new RuntimeException(ex);
     }

File: code/src/main/com/lmax/disruptor/IgnoreExceptionHandler.java
Patch:
@@ -38,8 +38,8 @@ public IgnoreExceptionHandler(final Logger logger)
     }
 
     @Override
-    public void handle(final Exception ex, final AbstractEvent currentEvent)
+    public void handle(final Exception ex, final long sequence, final Object event)
     {
-        logger.log(Level.INFO, "Exception processing: " + currentEvent, ex);
+        logger.log(Level.INFO, "Exception processing: " + sequence + " " + event, ex);
     }
 }

File: code/src/main/com/lmax/disruptor/SequenceReportingEventHandler.java
Patch:
@@ -17,13 +17,13 @@
 
 /**
  * Used by the {@link BatchEventProcessor} to set a callback allowing the {@link EventHandler} to notify
- * when it has finished consuming an {@link AbstractEvent} if this happens after the {@link EventHandler#onEvent(AbstractEvent, boolean)} call.
+ * when it has finished consuming an event if this happens after the {@link EventHandler#onEvent(Object, long, boolean)} call.
  * <p>
  * Typically this would be used when the handler is performing some sort of batching operation such are writing to an IO device.
  * </p>
- * @param <T> AbstractEvent implementation storing the data for sharing during exchange or parallel coordination of an event.
+ * @param <T> event implementation storing the data for sharing during exchange or parallel coordination of an event.
  */
-public interface SequenceReportingEventHandler<T extends AbstractEvent>
+public interface SequenceReportingEventHandler<T>
     extends EventHandler<T>
 {
     /**

File: code/src/main/com/lmax/disruptor/wizard/ConsumerInfo.java
Patch:
@@ -15,12 +15,11 @@
  */
 package com.lmax.disruptor.wizard;
 
-import com.lmax.disruptor.AbstractEvent;
 import com.lmax.disruptor.EventHandler;
 import com.lmax.disruptor.EventProcessor;
 import com.lmax.disruptor.DependencyBarrier;
 
-class EventProcessorInfo<T extends AbstractEvent>
+class EventProcessorInfo<T>
 {
     private final EventProcessor eventprocessor;
     private final EventHandler<T> handler;

File: code/src/main/com/lmax/disruptor/wizard/ConsumerRepository.java
Patch:
@@ -15,14 +15,13 @@
  */
 package com.lmax.disruptor.wizard;
 
-import com.lmax.disruptor.AbstractEvent;
 import com.lmax.disruptor.EventHandler;
 import com.lmax.disruptor.EventProcessor;
 import com.lmax.disruptor.DependencyBarrier;
 
 import java.util.*;
 
-class EventProcessorRepository<T extends AbstractEvent> implements Iterable<EventProcessorInfo<T>>
+class EventProcessorRepository<T> implements Iterable<EventProcessorInfo<T>>
 {
     private final Map<EventHandler, EventProcessorInfo<T>> eventProcessorInfoByHandler = new IdentityHashMap<EventHandler, EventProcessorInfo<T>>();
     private final Map<EventProcessor, EventProcessorInfo<T>> eventProcessorInfoByEventProcessor = new IdentityHashMap<EventProcessor, EventProcessorInfo<T>>();

File: code/src/main/com/lmax/disruptor/wizard/DisruptorWizard.java
Patch:
@@ -33,9 +33,9 @@
  * <p/>
  * RingBuffer ringBuffer = dw.start();</code></pre>
  *
- * @param <T> the type of {@link AbstractEvent} used.
+ * @param <T> the type of event used.
  */
-public class DisruptorWizard<T extends AbstractEvent>
+public class DisruptorWizard<T>
 {
     private final RingBuffer<T> ringBuffer;
     private final Executor executor;

File: code/src/main/com/lmax/disruptor/wizard/EventHandlerGroup.java
Patch:
@@ -15,15 +15,14 @@
  */
 package com.lmax.disruptor.wizard;
 
-import com.lmax.disruptor.AbstractEvent;
 import com.lmax.disruptor.EventHandler;
 import com.lmax.disruptor.EventProcessor;
 
 /** A group of {@link EventProcessor}s set up via the {@link DisruptorWizard}.
  *
- * @param <T> the type of entry used by the eventProcessors.
+ * @param <T> the type of entry used by the event processors.
  */
-public class EventHandlerGroup<T extends AbstractEvent>
+public class EventHandlerGroup<T>
 {
     private final DisruptorWizard<T> disruptorWizard;
     private final EventProcessorRepository<T> eventProcessorRepository;

File: code/src/main/com/lmax/disruptor/wizard/ExceptionHandlerSetting.java
Patch:
@@ -15,12 +15,11 @@
  */
 package com.lmax.disruptor.wizard;
 
-import com.lmax.disruptor.AbstractEvent;
 import com.lmax.disruptor.BatchEventProcessor;
 import com.lmax.disruptor.EventHandler;
 import com.lmax.disruptor.ExceptionHandler;
 
-public class ExceptionHandlerSetting<T extends AbstractEvent>
+public class ExceptionHandlerSetting<T>
 {
     private final EventHandler<T> eventHandler;
     private final EventProcessorRepository<T> eventProcessorRepository;
@@ -33,7 +32,7 @@ public class ExceptionHandlerSetting<T extends AbstractEvent>
 
     public void with(ExceptionHandler exceptionHandler)
     {
-        ((BatchEventProcessor) eventProcessorRepository.getEventProcessorFor(eventHandler)).setExceptionHandler(exceptionHandler);
+        ((BatchEventProcessor)eventProcessorRepository.getEventProcessorFor(eventHandler)).setExceptionHandler(exceptionHandler);
         eventProcessorRepository.getBarrierFor(eventHandler).alert();
     }
 }

File: code/src/perf/com/lmax/disruptor/DiamondPath1P3CPerfTest.java
Patch:
@@ -182,9 +182,10 @@ protected long runDisruptorPass(int PassNumber) throws Exception
 
         for (long i = 0; i < ITERATIONS; i++)
         {
-            FizzBuzzEvent event = ringBuffer.nextEvent();
+            long sequence = ringBuffer.nextSequence();
+            FizzBuzzEvent event = ringBuffer.get(sequence);
             event.setValue(i);
-            ringBuffer.publish(event);
+            ringBuffer.publish(sequence);
         }
 
         final long expectedSequence = ringBuffer.getCursor();

File: code/src/perf/com/lmax/disruptor/MultiCast1P3CPerfTest.java
Patch:
@@ -220,9 +220,10 @@ protected long runDisruptorPass(final int passNumber)
 
         for (long i = 0; i < ITERATIONS; i++)
         {
-            ValueEvent event = ringBuffer.nextEvent();
+            long sequence = ringBuffer.nextSequence();
+            ValueEvent event = ringBuffer.get(sequence);
             event.setValue(i);
-            ringBuffer.publish(event);
+            ringBuffer.publish(sequence);
         }
 
         final long expectedSequence = ringBuffer.getCursor();

File: code/src/perf/com/lmax/disruptor/Pipeline3StepLatencyPerfTest.java
Patch:
@@ -216,9 +216,10 @@ private void runDisruptorPass()
 
         for (long i = 0; i < ITERATIONS; i++)
         {
-            ValueEvent event = ringBuffer.nextEvent();
+            long sequence = ringBuffer.nextSequence();
+            ValueEvent event = ringBuffer.get(sequence);
             event.setValue(System.nanoTime());
-            ringBuffer.publish(event);
+            ringBuffer.publish(sequence);
 
             long pauseStart = System.nanoTime();
             while (PAUSE_NANOS > (System.nanoTime() -  pauseStart))

File: code/src/perf/com/lmax/disruptor/Pipeline3StepPerfTest.java
Patch:
@@ -166,10 +166,11 @@ protected long runDisruptorPass(final int passNumber)
         long operandTwo = OPERAND_TWO_INITIAL_VALUE;
         for (long i = 0; i < ITERATIONS; i++)
         {
-            FunctionEvent event = ringBuffer.nextEvent();
+            long sequence = ringBuffer.nextSequence();
+            FunctionEvent event = ringBuffer.get(sequence);
             event.setOperandOne(i);
             event.setOperandTwo(operandTwo--);
-            ringBuffer.publish(event);
+            ringBuffer.publish(sequence);
         }
 
         final long expectedSequence = ringBuffer.getCursor();

File: code/src/perf/com/lmax/disruptor/UniCast1P1CBatchPerfTest.java
Patch:
@@ -144,10 +144,10 @@ protected long runDisruptorPass(final int passNumber) throws InterruptedExceptio
         long offset = 0;
         for (long i = 0; i < ITERATIONS; i += batchSize)
         {
-            ringBuffer.nextEvents(sequenceBatch);
+            ringBuffer.nextSequenceBatch(sequenceBatch);
             for (long c = sequenceBatch.getStart(), end = sequenceBatch.getEnd(); c <= end; c++)
             {
-                ValueEvent event = ringBuffer.getEvent(c);
+                ValueEvent event = ringBuffer.get(c);
                 event.setValue(offset++);
             }
             ringBuffer.publish(sequenceBatch);

File: code/src/perf/com/lmax/disruptor/UniCast1P1CPerfTest.java
Patch:
@@ -135,9 +135,10 @@ protected long runDisruptorPass(final int passNumber) throws InterruptedExceptio
 
         for (long i = 0; i < ITERATIONS; i++)
         {
-            ValueEvent event = ringBuffer.nextEvent();
+            long sequence = ringBuffer.nextSequence();
+            ValueEvent event = ringBuffer.get(sequence);
             event.setValue(i);
-            ringBuffer.publish(event);
+            ringBuffer.publish(sequence);
         }
 
         final long expectedSequence = ringBuffer.getCursor();

File: code/src/perf/com/lmax/disruptor/support/FunctionEvent.java
Patch:
@@ -15,10 +15,9 @@
  */
 package com.lmax.disruptor.support;
 
-import com.lmax.disruptor.AbstractEvent;
 import com.lmax.disruptor.EventFactory;
 
-public final class FunctionEvent extends AbstractEvent
+public final class FunctionEvent
 {
     private long operandOne;
     private long operandTwo;

File: code/src/perf/com/lmax/disruptor/support/LatencyStepEventHandler.java
Patch:
@@ -32,7 +32,7 @@ public LatencyStepEventHandler(final FunctionStep functionStep, final Histogram
     }
 
     @Override
-    public void onEvent(final ValueEvent event, final boolean endOfBatch) throws Exception
+    public void onEvent(final ValueEvent event, final long sequence, final boolean endOfBatch) throws Exception
     {
         switch (functionStep)
         {

File: code/src/perf/com/lmax/disruptor/support/ValueEvent.java
Patch:
@@ -15,10 +15,9 @@
  */
 package com.lmax.disruptor.support;
 
-import com.lmax.disruptor.AbstractEvent;
 import com.lmax.disruptor.EventFactory;
 
-public final class ValueEvent extends AbstractEvent
+public final class ValueEvent
 {
     private long value;
 

File: code/src/perf/com/lmax/disruptor/support/ValuePublisher.java
Patch:
@@ -42,9 +42,10 @@ public void run()
 
             for (long i = 0; i < iterations; i++)
             {
-                ValueEvent event = ringBuffer.nextEvent();
+                long sequence = ringBuffer.nextSequence();
+                ValueEvent event = ringBuffer.get(sequence);
                 event.setValue(i);
-                ringBuffer.publish(event);
+                ringBuffer.publish(sequence);
             }
         }
         catch (Exception ex)

File: code/src/test/com/lmax/disruptor/BatchPublisherTest.java
Patch:
@@ -35,7 +35,7 @@ public void shouldClaimBatchAndPublishBack() throws Exception
         final int batchSize = 5;
         final SequenceBatch sequenceBatch = new SequenceBatch(batchSize);
 
-        ringBuffer.nextEvents(sequenceBatch);
+        ringBuffer.nextSequenceBatch(sequenceBatch);
 
         assertThat(Long.valueOf(sequenceBatch.getStart()), is(Long.valueOf(0L)));
         assertThat(Long.valueOf(sequenceBatch.getEnd()), is(Long.valueOf(4L)));

File: code/src/test/com/lmax/disruptor/FatalExceptionHandlerTest.java
Patch:
@@ -41,22 +41,22 @@ public FatalExceptionHandlerTest()
     public void shouldHandleFatalException()
     {
         final Exception causeException = new Exception();
-        final AbstractEvent event = new TestEvent();
+        final TestEvent event = new TestEvent();
 
         final Logger logger = context.mock(Logger.class);
 
         context.checking(new Expectations()
         {
             {
-                oneOf(logger).log(Level.SEVERE, "Exception processing: " + event, causeException);
+                oneOf(logger).log(Level.SEVERE, "Exception processing: 0 " + event, causeException);
             }
         });
 
         ExceptionHandler exceptionHandler = new FatalExceptionHandler(logger);
 
         try
         {
-            exceptionHandler.handle(causeException, event);
+            exceptionHandler.handle(causeException, 0L, event);
         }
         catch (RuntimeException ex)
         {

File: code/src/test/com/lmax/disruptor/IgnoreExceptionHandlerTest.java
Patch:
@@ -40,18 +40,18 @@ public IgnoreExceptionHandlerTest()
     public void shouldHandleAndIgnoreException()
     {
         final Exception ex = new Exception();
-        final AbstractEvent event = new TestEvent();
+        final TestEvent event = new TestEvent();
 
         final Logger logger = context.mock(Logger.class);
 
         context.checking(new Expectations()
         {
             {
-                oneOf(logger).log(Level.INFO, "Exception processing: " + event, ex);
+                oneOf(logger).log(Level.INFO, "Exception processing: 0 " + event, ex);
             }
         });
 
         ExceptionHandler exceptionHandler = new IgnoreExceptionHandler(logger);
-        exceptionHandler.handle(ex, event);
+        exceptionHandler.handle(ex, 0L, event);
     }
 }

File: code/src/test/com/lmax/disruptor/LifecycleAwareTest.java
Patch:
@@ -54,7 +54,7 @@ private final class LifecycleAwareEventHandler implements EventHandler<StubEvent
         private int shutdownCounter = 0;
 
         @Override
-        public void onEvent(final StubEvent event, final boolean endOfBatch) throws Exception
+        public void onEvent(final StubEvent event, final long sequence, final boolean endOfBatch) throws Exception
         {
         }
 

File: code/src/test/com/lmax/disruptor/SequenceReportingCallbackTest.java
Patch:
@@ -42,7 +42,7 @@ public void shouldReportProgressByUpdatingSequenceViaCallback()
         thread.start();
 
         assertEquals(-1L, batchEventProcessor.getSequence().get());
-        ringBuffer.publish(ringBuffer.nextEvent());
+        ringBuffer.publish(ringBuffer.nextSequence());
 
         callbackLatch.await();
         assertEquals(0L, batchEventProcessor.getSequence().get());
@@ -65,9 +65,9 @@ public void setSequenceCallback(final Sequence sequenceTrackerCallback)
         }
 
         @Override
-        public void onEvent(final StubEvent event, final boolean endOfBatch) throws Exception
+        public void onEvent(final StubEvent event, final long sequence, final boolean endOfBatch) throws Exception
         {
-            sequenceCallback.set(event.getSequence());
+            sequenceCallback.set(sequence);
             callbackLatch.countDown();
         }
     }

File: code/src/test/com/lmax/disruptor/support/StubEvent.java
Patch:
@@ -15,10 +15,9 @@
  */
 package com.lmax.disruptor.support;
 
-import com.lmax.disruptor.AbstractEvent;
 import com.lmax.disruptor.EventFactory;
 
-public final class StubEvent extends AbstractEvent
+public final class StubEvent
 {
     private int value;
     private String testString;

File: code/src/test/com/lmax/disruptor/support/TestEvent.java
Patch:
@@ -15,11 +15,9 @@
  */
 package com.lmax.disruptor.support;
 
-import com.lmax.disruptor.AbstractEvent;
 import com.lmax.disruptor.EventFactory;
 
 public final class TestEvent
-    extends AbstractEvent
 {
     @Override
     public String toString()

File: code/src/test/com/lmax/disruptor/support/TestWaiter.java
Patch:
@@ -53,7 +53,7 @@ public List<StubEvent> call() throws Exception
         final List<StubEvent> messages = new ArrayList<StubEvent>();
         for (long l = initialSequence; l <= toWaitForSequence; l++)
         {
-            messages.add(ringBuffer.getEvent(l));
+            messages.add(ringBuffer.get(l));
         }
 
         return messages;

File: code/src/test/com/lmax/disruptor/wizard/DisruptorWizardTest.java
Patch:
@@ -310,8 +310,9 @@ private TestEvent publishEvent()
             ringBuffer = disruptorWizard.start();
         }
 
-        final TestEvent stubEntry = ringBuffer.nextEvent();
-        ringBuffer.publish(stubEntry);
+        final long sequence = ringBuffer.nextSequence();
+        final TestEvent stubEntry = ringBuffer.get(sequence);
+        ringBuffer.publish(sequence);
         return stubEntry;
     }
 

File: code/src/test/com/lmax/disruptor/wizard/stubs/DelayedEventHandler.java
Patch:
@@ -26,7 +26,7 @@ public class DelayedEventHandler implements EventHandler<TestEvent>
     private volatile boolean stopped = false;
 
     @Override
-    public void onEvent(final TestEvent entry, final boolean endOfBatch) throws Exception
+    public void onEvent(final TestEvent entry, final long sequence, final boolean endOfBatch) throws Exception
     {
         waitForAndSetFlag(false);
     }

File: code/src/test/com/lmax/disruptor/wizard/stubs/EventHandlerStub.java
Patch:
@@ -30,7 +30,7 @@ public EventHandlerStub(final CountDownLatch countDownLatch)
     }
 
     @Override
-    public void onEvent(final TestEvent entry, final boolean endOfBatch) throws Exception
+    public void onEvent(final TestEvent entry, final long sequence, final boolean endOfBatch) throws Exception
     {
         countDownLatch.countDown();
     }

File: code/src/test/com/lmax/disruptor/wizard/stubs/EvilEqualsEventHandler.java
Patch:
@@ -21,7 +21,7 @@
 public class EvilEqualsEventHandler implements EventHandler<TestEvent>
 {
     @Override
-    public void onEvent(final TestEvent entry, boolean endOfBatch) throws Exception
+    public void onEvent(final TestEvent entry, final long sequence, boolean endOfBatch) throws Exception
     {
     }
 

File: code/src/test/com/lmax/disruptor/wizard/stubs/ExceptionThrowingEventHandler.java
Patch:
@@ -28,7 +28,7 @@ public ExceptionThrowingEventHandler(final RuntimeException testException)
     }
 
     @Override
-    public void onEvent(final TestEvent entry, final boolean endOfBatch) throws Exception
+    public void onEvent(final TestEvent entry, final long sequence, final boolean endOfBatch) throws Exception
     {
         throw testException;
     }

File: code/src/test/com/lmax/disruptor/wizard/stubs/NoOpEventHandler.java
Patch:
@@ -21,7 +21,7 @@
 public class NoOpEventHandler implements EventHandler<TestEvent>
 {
     @Override
-    public void onEvent(final TestEvent entry, final boolean endOfBatch) throws Exception
+    public void onEvent(final TestEvent entry, final long sequence, final boolean endOfBatch) throws Exception
     {
         Thread.sleep(1000);
     }

File: code/src/test/com/lmax/disruptor/wizard/stubs/StubExceptionHandler.java
Patch:
@@ -15,22 +15,20 @@
  */
 package com.lmax.disruptor.wizard.stubs;
 
-import com.lmax.disruptor.AbstractEvent;
 import com.lmax.disruptor.ExceptionHandler;
 
 import java.util.concurrent.atomic.AtomicReference;
 
 public class StubExceptionHandler implements ExceptionHandler
 {
-
     private final AtomicReference<Exception> exceptionHandled;
 
     public StubExceptionHandler(final AtomicReference<Exception> exceptionHandled)
     {
         this.exceptionHandled = exceptionHandled;
     }
 
-    public void handle(final Exception ex, final AbstractEvent currentEntry)
+    public void handle(final Exception ex, final long sequence, final Object event)
     {
         exceptionHandled.set(ex);
     }

File: code/src/test/com/lmax/disruptor/wizard/stubs/StubPublisher.java
Patch:
@@ -34,8 +34,9 @@ public void run()
     {
         while (running)
         {
-            final TestEvent entry = ringBuffer.nextEvent();
-            ringBuffer.publish(entry);
+            final long sequence = ringBuffer.nextSequence();
+            //final TestEvent entry = ringBuffer.get(sequence);
+            ringBuffer.publish(sequence);
             publicationCount++;
         }
     }

File: code/src/main/com/lmax/disruptor/RingBuffer.java
Patch:
@@ -189,7 +189,7 @@ public void publish(final SequenceBatch sequenceBatch)
      * @return the claimed {@link AbstractEvent}
      */
     @SuppressWarnings("unchecked")
-    public T publishEventAtSequence(final long sequence)
+    public T claimEventAtSequence(final long sequence)
     {
         claimStrategy.ensureProcessorsAreInRange(sequence, processorSequencesToTrack);
         AbstractEvent event = events[(int)sequence & ringModMask];

File: code/src/test/com/lmax/disruptor/RingBufferTest.java
Patch:
@@ -148,7 +148,7 @@ public void shouldSetAtSpecificSequence() throws Exception
     {
         long expectedSequence = 5;
 
-        StubEvent expectedEvent = ringBuffer.publishEventAtSequence(expectedSequence);
+        StubEvent expectedEvent = ringBuffer.claimEventAtSequence(expectedSequence);
         expectedEvent.setValue((int) expectedSequence);
         ringBuffer.publishWithForce(expectedEvent);
 

File: code/src/main/com/lmax/disruptor/collections/Histogram.java
Patch:
@@ -237,9 +237,9 @@ public BigDecimal getMean()
 
                 BigDecimal intervalTotal = new BigDecimal(midPoint).multiply(new BigDecimal(counts[i]));
                 total = total.add(intervalTotal);
-
-                lowerBound = Math.max(upperBounds[i] + 1L, minValue);
             }
+
+            lowerBound = Math.max(upperBounds[i] + 1L, minValue);
         }
 
         return total.divide(new BigDecimal(getCount()), 2, RoundingMode.HALF_UP);

File: code/src/test/com/lmax/disruptor/collections/HistogramTest.java
Patch:
@@ -178,8 +178,7 @@ public void shouldToString()
     {
         addObservations(histogram, 1L, 7L, 10L, 300L);
 
-        String expectedResults =
-            "Histogram{min=1, max=300, mean=42.00, 99%=1000, 99.99%=1000, [1=1, 10=2, 100=0, 1000=1, 9223372036854775807=0]}";
+        String expectedResults = "Histogram{min=1, max=300, mean=53.25, 99%=1000, 99.99%=1000, [1=1, 10=2, 100=0, 1000=1, 9223372036854775807=0]}";
         assertThat(histogram.toString(), is(expectedResults));
     }
 

File: code/src/main/com/lmax/disruptor/collections/Histogram.java
Patch:
@@ -212,7 +212,8 @@ public long getMax()
      * Calculate the mean of all recorded observations.
      *
      * The mean is calculated by the summing the mid points of each interval multiplied by the count
-     * for that interval, then dividing by the total count of observations.
+     * for that interval, then dividing by the total count of observations.  The max and min are
+     * considered for adjusting the top and bottom bin when calculating the mid point.
      *
      * @return the mean of all recorded observations.
      */

File: code/src/main/com/lmax/disruptor/ClaimStrategy.java
Patch:
@@ -24,7 +24,7 @@ public interface ClaimStrategy
     void setSequence(long sequence);
 
     /**
-     * Wait for the current nextEntry to reach a given sequence.
+     * Wait for the current commit to reach a given sequence.
      *
      * @param sequence to wait for.
      * @param ringBuffer on which to wait forCursor

File: code/src/main/com/lmax/disruptor/RingBuffer.java
Patch:
@@ -183,7 +183,7 @@ public void clearAlert()
     }
 
     /**
-     * ProducerBarrier that tracks multiple {@link Consumer}s when trying to nextEntry
+     * ProducerBarrier that tracks multiple {@link Consumer}s when trying to claim
      * a {@link Entry} in the {@link RingBuffer}.
      */
     public final class ConsumerTrackingProducerBarrier implements ProducerBarrier<T>

File: code/src/perf/com/lmax/disruptor/DiamondPath1P3CPerfTest.java
Patch:
@@ -56,7 +56,7 @@
  * +----+    +====+    +====+            +=====+    +----+
  * | P0 |--->| PB |--->| RB |<-----------| CB1 |<---| C2 |
  * +----+    +====+    +====+            +=====+    +----+
- *                nextEntry   ^  get            |   waitFor
+ *                claim   ^  get            |   waitFor
  *                        |                 |
  *                     +=====+    +----+    |
  *                     | CB0 |<---| C0 |<---+

File: code/src/perf/com/lmax/disruptor/MultiCast1P3CPerfTest.java
Patch:
@@ -60,7 +60,7 @@
  * +----+    +====+    +====+    +====+    +----+    +----+    +----+
  * | P0 |--->| PB |--->| RB |<---| CB |    | C0 |    | C1 |    | C2 |
  * +----+    +====+    +====+    +====+    +----+    +----+    +----+
- *                nextEntry      get    ^        |         |         |
+ *                claim      get    ^        |         |         |
  *                                  |        |         |         |
  *                                  +--------+---------+---------+
  *                                               waitFor

File: code/src/perf/com/lmax/disruptor/Pipeline3StagePerfTest.java
Patch:
@@ -46,7 +46,7 @@
  * +----+    +====+    +====+    +=====+    +----+    +=====+    +----+    +=====+    +----+
  * | P0 |--->| PB |--->| RB |    | CB0 |<---| C0 |<---| CB1 |<---| C1 |<---| CB2 |<---| C2 |
  * +----+    +====+    +====+    +=====+    +----+    +=====+    +----+    +=====+    +----+
- *                nextEntry   ^  get    |   waitFor          |  waitFor           |  waitFor
+ *                claim   ^  get    |   waitFor          |  waitFor           |  waitFor
  *                        |         |                    |                    |
  *                        +---------+--------------------+--------------------+
  *

File: code/src/perf/com/lmax/disruptor/Sequencer3P1CPerfTest.java
Patch:
@@ -54,7 +54,7 @@
  * +----+    +====+    +====+    +====+    +----+
  * | P0 |--->| PB |--->| RB |<---| CB |    | C0 |
  * +----+    +====+    +====+    +====+    +----+
- *             ^  nextEntry      get    ^        |
+ *             ^  claim      get    ^        |
  * +----+      |                    |        |
  * | P1 |------+                    +--------+
  * +----+      |                      waitFor

File: code/src/perf/com/lmax/disruptor/UniCast1P1CPerfTest.java
Patch:
@@ -39,7 +39,7 @@
  * +----+    +====+    +====+    +====+    +----+
  * | P0 |--->| PB |--->| RB |<---| CB |    | C0 |
  * +----+    +====+    +====+    +====+    +----+
- *                nextEntry      get    ^        |
+ *                claim      get    ^        |
  *                                  |        |
  *                                  +--------+
  *                                    waitFor

