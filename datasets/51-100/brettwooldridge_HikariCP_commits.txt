File: src/test/java/com/zaxxer/hikari/pool/TestPropertySetter.java
Patch:
@@ -98,7 +98,7 @@ public void testDurationPropertiesSet() throws Exception
       HikariConfig config = new HikariConfig(durationProperties);
       config.validate();
 
-      assertEquals(Duration.ofMillis(11), Duration.ofMillis(config.getConnectionTimeout()));
+      assertEquals(Duration.ofMillis(2000), Duration.ofMillis(config.getConnectionTimeout()));
       assertEquals(Duration.ofSeconds(22), Duration.ofMillis(config.getValidationTimeout()));
       assertEquals(Duration.ofMinutes(33), Duration.ofMillis(config.getIdleTimeout()));
       assertEquals(Duration.ofHours(44), Duration.ofMillis(config.getLeakDetectionThreshold()));
@@ -108,7 +108,7 @@ public void testDurationPropertiesSet() throws Exception
       DataSource dataSource = (DataSource) clazz.getDeclaredConstructor().newInstance();
       PropertyElf.setTargetFromProperties(dataSource, config.getDataSourceProperties());
 
-      assertEquals(Duration.ofMinutes(47), Duration.ofMillis(dataSource.getLoginTimeout()));
+      assertEquals(Duration.ofMinutes(1), Duration.ofMillis(dataSource.getLoginTimeout()));
    }
 
    @Test

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -52,7 +52,7 @@ public class HikariConfig implements HikariConfigMXBean
    private static final long SOFT_TIMEOUT_FLOOR = Long.getLong("com.zaxxer.hikari.timeoutMs.floor", 250L);
    private static final long IDLE_TIMEOUT = MINUTES.toMillis(10);
    private static final long MAX_LIFETIME = MINUTES.toMillis(30);
-   private static final long DEFAULT_KEEPALIVE_TIME = 0L;
+   private static final long DEFAULT_KEEPALIVE_TIME = MINUTES.toMillis(2);
    private static final int DEFAULT_POOL_SIZE = 10;
 
    private static boolean unitTest = false;
@@ -1101,13 +1101,13 @@ private void validateNumerics()
       // keepalive time must larger than 30 seconds
       if (keepaliveTime != 0 && keepaliveTime < SECONDS.toMillis(30)) {
          LOGGER.warn("{} - keepaliveTime is less than 30000ms, disabling it.", poolName);
-         keepaliveTime = DEFAULT_KEEPALIVE_TIME;
+         keepaliveTime = 0L;
       }
 
       // keepalive time must be less than maxLifetime (if maxLifetime is enabled)
       if (keepaliveTime != 0 && maxLifetime != 0 && keepaliveTime >= maxLifetime) {
          LOGGER.warn("{} - keepaliveTime is greater than or equal to maxLifetime, disabling it.", poolName);
-         keepaliveTime = DEFAULT_KEEPALIVE_TIME;
+         keepaliveTime = 0L;
       }
 
       if (leakDetectionThreshold > 0 && !unitTest) {

File: src/main/java/com/zaxxer/hikari/pool/PoolBase.java
Patch:
@@ -602,7 +602,7 @@ private void createNetworkTimeoutExecutor(final DataSource dataSource, final Str
       }
       else {
          ThreadFactory threadFactory = config.getThreadFactory();
-         threadFactory = threadFactory != null ? threadFactory : new DefaultThreadFactory(poolName + " network timeout executor");
+         threadFactory = threadFactory != null ? threadFactory : new DefaultThreadFactory(poolName + ":network-timeout-executor");
          ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newCachedThreadPool(threadFactory);
          executor.setKeepAliveTime(15, SECONDS);
          executor.allowCoreThreadTimeOut(true);

File: src/main/java/com/zaxxer/hikari/pool/ProxyCallableStatement.java
Patch:
@@ -19,7 +19,7 @@
 import java.sql.CallableStatement;
 
 /**
- * This is the proxy class for java.sql.CallableStatement.
+ * This is the proxy class for {@link CallableStatement}.
  *
  * @author Brett Wooldridge
  */
@@ -34,4 +34,4 @@ protected ProxyCallableStatement(ProxyConnection connection, CallableStatement s
    //               Overridden java.sql.CallableStatement Methods
    // **********************************************************************
 
-}
\ No newline at end of file
+}

File: src/main/java/com/zaxxer/hikari/pool/ProxyConnection.java
Patch:
@@ -30,7 +30,7 @@
 import static com.zaxxer.hikari.SQLExceptionOverride.Override.DO_NOT_EVICT;
 
 /**
- * This is the proxy class for java.sql.Connection.
+ * This is the proxy class for {@link Connection}.
  *
  * @author Brett Wooldridge
  */

File: src/main/java/com/zaxxer/hikari/pool/ProxyPreparedStatement.java
Patch:
@@ -21,7 +21,7 @@
 import java.sql.SQLException;
 
 /**
- * This is the proxy class for java.sql.PreparedStatement.
+ * This is the proxy class for {@link PreparedStatement}.
  *
  * @author Brett Wooldridge
  */

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -454,11 +454,11 @@ public void setDataSourceClassName(String className)
 
    /**
     * Add a property (name/value pair) that will be used to configure the {@link DataSource}/{@link java.sql.Driver}.
-    * <p/>
+    * <p>
     * In the case of a {@link DataSource}, the property names will be translated to Java setters following the Java Bean
     * naming convention.  For example, the property {@code cachePrepStmts} will translate into {@code setCachePrepStmts()}
     * with the {@code value} passed as a parameter.
-    * <p/>
+    * <p>
     * In the case of a {@link java.sql.Driver}, the property will be added to a {@link Properties} instance that will
     * be passed to the driver during {@link java.sql.Driver#connect(String, Properties)} calls.
     *

File: src/main/java/com/zaxxer/hikari/pool/PoolBase.java
Patch:
@@ -98,7 +98,7 @@ abstract class PoolBase
       this.schema = config.getSchema();
       this.isReadOnly = config.isReadOnly();
       this.isAutoCommit = config.isAutoCommit();
-      this.exceptionOverride = UtilityElf.createInstance(config.getExceptionOverrideClassName(), SQLExceptionOverride.class);
+      this.exceptionOverride = config.getExceptionOverride();
       this.transactionIsolation = UtilityElf.getTransactionIsolation(config.getTransactionIsolation());
 
       this.isQueryTimeoutSupported = UNINITIALIZED;

File: src/main/java/com/zaxxer/hikari/pool/PoolBase.java
Patch:
@@ -73,7 +73,7 @@ abstract class PoolBase
    private static final int MINIMUM_LOGIN_TIMEOUT = Integer.getInteger("com.zaxxer.hikari.minimumLoginTimeoutSecs", 1);
 
    private int networkTimeout;
-   private int isNetworkTimeoutSupported;
+   private volatile int isNetworkTimeoutSupported;
    private int isQueryTimeoutSupported;
    private int defaultTransactionIsolation;
    private int transactionIsolation;
@@ -244,6 +244,7 @@ void resetConnectionState(final Connection connection, final ProxyConnection pro
 
    void shutdownNetworkTimeoutExecutor()
    {
+      isNetworkTimeoutSupported = UNINITIALIZED;
       if (netTimeoutExecutor instanceof ThreadPoolExecutor) {
          ((ThreadPoolExecutor) netTimeoutExecutor).shutdownNow();
       }

File: src/main/java/com/zaxxer/hikari/pool/ProxyConnection.java
Patch:
@@ -392,7 +392,7 @@ public void rollback() throws SQLException
    public void rollback(Savepoint savepoint) throws SQLException
    {
       delegate.rollback(savepoint);
-      isCommitStateDirty = false;
+      isCommitStateDirty = true;
    }
 
    /** {@inheritDoc} */

File: src/test/java/com/zaxxer/hikari/pool/ConnectionStateTest.java
Patch:
@@ -160,7 +160,7 @@ public void testCommitTracking() throws SQLException
             assertTrue(TestElf.getConnectionCommitDirtyState(connection));
 
             connection.rollback(null);
-            assertFalse(TestElf.getConnectionCommitDirtyState(connection));
+            assertTrue(TestElf.getConnectionCommitDirtyState(connection));
 
             resultSet.updateRow();
             assertTrue(TestElf.getConnectionCommitDirtyState(connection));

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -677,14 +677,16 @@ private SQLException createTimeoutException(long startTime)
       metricsTracker.recordConnectionTimeout();
 
       String sqlState = null;
+      int errorCode = 0;
       final var originalException = getLastConnectionFailure();
       if (originalException instanceof SQLException) {
          sqlState = ((SQLException) originalException).getSQLState();
+         errorCode = ((SQLException) originalException).getErrorCode();
       }
       final var connectionException = new SQLTransientConnectionException(
          poolName + " - Connection is not available, request timed out after " + elapsedMillis(startTime) + "ms " +
             "(total=" + getTotalConnections() + ", active=" + getActiveConnections() + ", idle=" + getIdleConnections() + ", waiting=" + getThreadsAwaitingConnection() + ")",
-         sqlState, originalException);
+         sqlState, errorCode, originalException);
       if (originalException instanceof SQLException) {
          connectionException.setNextException((SQLException) originalException);
       }

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -402,9 +402,9 @@ public synchronized void resumePool()
    void logPoolState(String... prefix)
    {
       if (logger.isDebugEnabled()) {
-         logger.debug("{} - {}stats (total={}, active={}, idle={}, waiting={})",
+         logger.debug("{} - {}stats (total={}/{}, idle={}/{}, active={}, waiting={})",
                       poolName, (prefix.length > 0 ? prefix[0] : ""),
-                      getTotalConnections(), getActiveConnections(), getIdleConnections(), getThreadsAwaitingConnection());
+                      getTotalConnections(), config.getMaximumPoolSize(), getIdleConnections(), config.getMinimumIdle(), getActiveConnections(), getThreadsAwaitingConnection());
       }
    }
 

File: src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java
Patch:
@@ -45,7 +45,7 @@
  * ThreadLocal lists can be "stolen" when the borrowing thread has none
  * of its own.  It is a "lock-less" implementation using a specialized
  * AbstractQueuedLongSynchronizer to manage cross-thread signaling.
- *
+ * <p>
  * Note that items that are "borrowed" from the bag are not actually
  * removed from any collection, so garbage collection will not occur
  * even if the reference is abandoned.  Thus care must be taken to

File: src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java
Patch:
@@ -45,7 +45,7 @@
  * ThreadLocal lists can be "stolen" when the borrowing thread has none
  * of its own.  It is a "lock-less" implementation using a specialized
  * AbstractQueuedLongSynchronizer to manage cross-thread signaling.
- *
+ * <p>
  * Note that items that are "borrowed" from the bag are not actually
  * removed from any collection, so garbage collection will not occur
  * even if the reference is abandoned.  Thus care must be taken to

File: src/main/java/com/zaxxer/hikari/pool/PoolBase.java
Patch:
@@ -133,7 +133,7 @@ void quietlyCloseConnection(final Connection connection, final String closureRea
             logger.debug("{} - Closing connection {}: {}", poolName, connection, closureReason);
 
             // continue with the close even if setNetworkTimeout() throws
-            try (connection; connection) {
+            try (connection) {
                if (!connection.isClosed())
                   setNetworkTimeout(connection, SECONDS.toMillis(15));
                } catch (SQLException e) {

File: src/main/java/com/zaxxer/hikari/pool/PoolBase.java
Patch:
@@ -69,6 +69,7 @@ abstract class PoolBase
    private static final int UNINITIALIZED = -1;
    private static final int TRUE = 1;
    private static final int FALSE = 0;
+   private static final int MINIMUM_LOGIN_TIMEOUT = Integer.getInteger("com.zaxxer.hikari.minimumLoginTimeoutSecs", 1);
 
    private int networkTimeout;
    private int isNetworkTimeoutSupported;
@@ -616,7 +617,7 @@ private void setLoginTimeout(final DataSource dataSource)
    {
       if (connectionTimeout != Integer.MAX_VALUE) {
          try {
-            dataSource.setLoginTimeout(Math.max(1, (int) MILLISECONDS.toSeconds(500L + connectionTimeout)));
+            dataSource.setLoginTimeout(Math.max(MINIMUM_LOGIN_TIMEOUT, (int) MILLISECONDS.toSeconds(500L + connectionTimeout)));
          }
          catch (Exception e) {
             logger.info("{} - Failed to set login timeout for data source. ({})", poolName, e.getMessage());

File: src/test/java/com/zaxxer/hikari/pool/ConnectionPoolSizeVsThreadsTest.java
Patch:
@@ -111,7 +111,7 @@ private Counts testPoolSize(final int minIdle, final int maxPoolSize, final int
       try (final HikariDataSource ds = new HikariDataSource(config)) {
          final StubDataSource stubDataSource = ds.unwrap(StubDataSource.class);
          // connection acquisition takes more than 0 ms in a real system
-         stubDataSource.setConnectionAcquistionTime(connectionAcquisitionTimeMs);
+         stubDataSource.setConnectionAcquisitionTime(connectionAcquisitionTimeMs);
 
          final ExecutorService threadPool = newFixedThreadPool(threadCount);
          final CountDownLatch allThreadsDone = new CountDownLatch(iterations);

File: src/test/java/com/zaxxer/hikari/pool/MetricsTrackerTest.java
Patch:
@@ -29,7 +29,7 @@ public void connectionTimeoutIsRecorded() throws Exception
          int timeToCreateNewConnectionMillis = timeoutMillis * 2;
 
          StubDataSource stubDataSource = new StubDataSource();
-         stubDataSource.setConnectionAcquistionTime(timeToCreateNewConnectionMillis);
+         stubDataSource.setConnectionAcquisitionTime(timeToCreateNewConnectionMillis);
 
          StubMetricsTracker metricsTracker = new StubMetricsTracker();
 

File: src/test/java/com/zaxxer/hikari/pool/TestMBean.java
Patch:
@@ -152,7 +152,7 @@ public void testMBeanConnectionTimeoutChange() throws SQLException {
 
          final StubDataSource stubDataSource = ds.unwrap(StubDataSource.class);
          // connection acquisition takes more than 0 ms in a real system
-         stubDataSource.setConnectionAcquistionTime(1200);
+         stubDataSource.setConnectionAcquisitionTime(1200);
 
          hikariConfigMXBean.setConnectionTimeout(1000);
 

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -1046,7 +1046,7 @@ private void validateNumerics()
          maxLifetime = MAX_LIFETIME;
       }
 
-      // keepalive time must larger then 30 seconds
+      // keepalive time must larger than 30 seconds
       if (keepaliveTime != 0 && keepaliveTime < SECONDS.toMillis(30)) {
          LOGGER.warn("{} - keepaliveTime is less than 30000ms, disabling it.", poolName);
          keepaliveTime = DEFAULT_KEEPALIVE_TIME;

File: src/main/java/com/zaxxer/hikari/util/PropertyElf.java
Patch:
@@ -141,6 +141,9 @@ else if (paramClass == short.class) {
          else if (paramClass == boolean.class || paramClass == Boolean.class) {
             writeMethod.invoke(target, Boolean.parseBoolean(propValue.toString()));
          }
+         else if (paramClass.isArray() && char.class.isAssignableFrom(paramClass.getComponentType())) {
+            writeMethod.invoke(target, propValue.toString().toCharArray());
+         }
          else if (paramClass == String.class) {
             writeMethod.invoke(target, propValue.toString());
          }

File: src/test/java/com/zaxxer/hikari/util/PropertyElfTest.java
Patch:
@@ -5,6 +5,7 @@
 
 import java.util.Properties;
 
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.fail;
@@ -18,10 +19,12 @@ public void setTargetFromProperties() throws Exception
       properties.setProperty("string", "aString");
       properties.setProperty("testObject", "com.zaxxer.hikari.mocks.TestObject");
       properties.setProperty("shortRaw", "1");
+      properties.setProperty("charArray", "aCharArray");
       TestObject testObject = new TestObject();
       PropertyElf.setTargetFromProperties(testObject, properties);
       assertEquals("aString", testObject.getString());
       assertEquals((short) 1, testObject.getShortRaw());
+      assertArrayEquals("aCharArray".toCharArray(), testObject.getCharArray());
       assertEquals(com.zaxxer.hikari.mocks.TestObject.class, testObject.getTestObject().getClass());
       assertNotSame(testObject, testObject.getTestObject());
    }

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -580,7 +580,6 @@ private void checkFailFast()
     */
    private void throwPoolInitializationException(Throwable t)
    {
-      logger.error("{} - Exception during pool initialization.", poolName, t);
       destroyHouseKeepingExecutorService();
       throw new PoolInitializationException(t);
    }

File: src/test/java/com/zaxxer/hikari/pool/TestMetrics.java
Patch:
@@ -71,7 +71,7 @@ public void testMetricWait() throws SQLException
             @Override
             public boolean matches(String name, Metric metric)
             {
-               return "testMetricWait.pool.Wait".equals(MetricRegistry.name("testMetricWait", "pool", "Wait"));
+               return name.equals(MetricRegistry.name("testMetricWait", "pool", "Wait"));
             }
          }).values().iterator().next();
 

File: src/main/java/com/zaxxer/hikari/pool/ProxyConnection.java
Patch:
@@ -80,6 +80,7 @@ public abstract class ProxyConnection implements Connection
       ERROR_CODES = new HashSet<>();
       ERROR_CODES.add(500150);
       ERROR_CODES.add(2399);
+      ERROR_CODES.add(1105);
    }
 
    protected ProxyConnection(final PoolEntry poolEntry,

File: src/test/java/com/zaxxer/hikari/pool/ExceptionTest.java
Patch:
@@ -139,7 +139,7 @@ public void testLastErrorTimeout() throws Exception
 
          // force the last access of this connection to be older than 'aliveBypassWindowMs'
          // thus forcing isConnectionDead to be called (and setNetworkTimeout)
-         Thread.sleep(500);
+         Thread.sleep(505);
 
          AtomicInteger callCount = new AtomicInteger();
          StubConnection.networkTimeoutSetter = () -> {

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -173,7 +173,7 @@ public Connection getConnection(final long hardTimeout) throws SQLException
             }
             else {
                metricsTracker.recordBorrowStats(poolEntry, startTime);
-               return poolEntry.createProxyConnection(leakTaskFactory.schedule(poolEntry), now);
+               return poolEntry.createProxyConnection(leakTaskFactory.schedule(poolEntry));
             }
          } while (timeout > 0L);
 
@@ -518,7 +518,7 @@ private synchronized void fillPool(final boolean isAfterAdd)
          addConnectionExecutor.submit(isAfterAdd ? postFillPoolEntryCreator : poolEntryCreator);
       }
       else if (isAfterAdd) {
-         logger.debug("{} - Fill pool skipped, pool has sufficient level or currently being filled (queueDepth={}.", poolName, queueDepth);
+         logger.debug("{} - Fill pool skipped, pool has sufficient level or currently being filled (queueDepth={}).", poolName, queueDepth);
       }
    }
 

File: src/main/java/com/zaxxer/hikari/pool/ProxyFactory.java
Patch:
@@ -39,12 +39,11 @@ private ProxyFactory()
     * @param connection the raw database Connection
     * @param openStatements a reusable list to track open Statement instances
     * @param leakTask the ProxyLeakTask for this connection
-    * @param now the current timestamp
     * @param isReadOnly the default readOnly state of the connection
     * @param isAutoCommit the default autoCommit state of the connection
     * @return a proxy that wraps the specified {@link Connection}
     */
-   static ProxyConnection getProxyConnection(final PoolEntry poolEntry, final Connection connection, final FastList<Statement> openStatements, final ProxyLeakTask leakTask, final long now, final boolean isReadOnly, final boolean isAutoCommit)
+   static ProxyConnection getProxyConnection(final PoolEntry poolEntry, final Connection connection, final FastList<Statement> openStatements, final ProxyLeakTask leakTask, final boolean isReadOnly, final boolean isAutoCommit)
    {
       // Body is replaced (injected) by JavassistProxyFactory
       throw new IllegalStateException("You need to run the CLI build and you need target/classes in your classpath to run.");

File: src/test/java/com/zaxxer/hikari/db/BasicPoolTest.java
Patch:
@@ -77,14 +77,14 @@ public void testIdleTimeout() throws InterruptedException, SQLException
       System.setProperty("com.zaxxer.hikari.housekeeping.periodMs", "1000");
 
       try (HikariDataSource ds = new HikariDataSource(config)) {
+         getUnsealedConfig(ds).setIdleTimeout(3000);
+
          System.clearProperty("com.zaxxer.hikari.housekeeping.periodMs");
 
          SECONDS.sleep(1);
 
          HikariPool pool = getPool(ds);
 
-         getUnsealedConfig(ds).setIdleTimeout(3000);
-
          assertEquals("Total connections not as expected", 5, pool.getTotalConnections());
          assertEquals("Idle connections not as expected", 5, pool.getIdleConnections());
 
@@ -99,7 +99,7 @@ public void testIdleTimeout() throws InterruptedException, SQLException
 
          assertEquals("Idle connections not as expected", 6, pool.getIdleConnections());
 
-         SECONDS.sleep(2);
+         MILLISECONDS.sleep(3000);
 
          assertEquals("Third total connections not as expected", 5, pool.getTotalConnections());
          assertEquals("Third idle connections not as expected", 5, pool.getIdleConnections());

File: src/test/java/com/zaxxer/hikari/pool/TestJavassistCodegen.java
Patch:
@@ -48,7 +48,6 @@ public void testCodegen() throws Exception {
             connection,
             fastList,
             null /*leakTask*/,
-            0L /*now*/,
             Boolean.FALSE /*isReadOnly*/,
             Boolean.FALSE /*isAutoCommit*/);
       Assert.assertNotNull(proxyConnection);

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -1132,7 +1132,7 @@ else if (value instanceof String) {
             else if (value == null) {
                value = "none";
             }
-            LOGGER.debug("{}{}", (prop + "................................................".substring(0, 32)), value);
+            LOGGER.debug("{}{}", (prop + "................................................").substring(0, 32), value);
          }
          catch (Exception e) {
             // continue

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -146,8 +146,8 @@ public HikariPool(final HikariConfig config)
             quietlySleep(MILLISECONDS.toMillis(100));
          }
 
-         addConnectionExecutor.setMaximumPoolSize(1);
          addConnectionExecutor.setCorePoolSize(1);
+         addConnectionExecutor.setMaximumPoolSize(1);
       }
    }
 

File: src/main/java/com/zaxxer/hikari/metrics/prometheus/PrometheusMetricsTrackerFactory.java
Patch:
@@ -49,9 +49,9 @@ public class PrometheusMetricsTrackerFactory implements MetricsTrackerFactory
 
    private final CollectorRegistry collectorRegistry;
 
-   public enum RegistrationStatus
+   enum RegistrationStatus
    {
-      REGISTERED;
+      REGISTERED
    }
 
    /**

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -639,7 +639,7 @@ public void setMetricsTrackerFactory(MetricsTrackerFactory metricsTrackerFactory
    }
 
    /**
-    * Get the MetricRegistry instance to used for registration of metrics used by HikariCP.  Default is {@code null}.
+    * Get the MetricRegistry instance to use for registration of metrics used by HikariCP.  Default is {@code null}.
     *
     * @return the MetricRegistry instance that will be used
     */

File: src/main/java/com/zaxxer/hikari/metrics/micrometer/MicrometerMetricsTrackerFactory.java
Patch:
@@ -5,7 +5,8 @@
 import com.zaxxer.hikari.metrics.PoolStats;
 import io.micrometer.core.instrument.MeterRegistry;
 
-public class MicrometerMetricsTrackerFactory implements MetricsTrackerFactory {
+public class MicrometerMetricsTrackerFactory implements MetricsTrackerFactory
+{
 
    private final MeterRegistry registry;
 

File: src/main/java/com/zaxxer/hikari/metrics/prometheus/PrometheusMetricsTrackerFactory.java
Patch:
@@ -26,6 +26,9 @@
  * HikariConfig config = new HikariConfig();
  * config.setMetricsTrackerFactory(new PrometheusMetricsTrackerFactory());
  * }</pre>
+ *
+ * Note: the internal {@see io.prometheus.client.Summary} requires heavy locks. Consider using
+ * {@see PrometheusHistogramMetricsTrackerFactory} if performance plays a role and you don't need the summary per se.
  */
 public class PrometheusMetricsTrackerFactory implements MetricsTrackerFactory {
 

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -137,16 +137,16 @@ public HikariPool(final HikariConfig config)
       this.houseKeeperTask = houseKeepingExecutorService.scheduleWithFixedDelay(new HouseKeeper(), 100L, housekeepingPeriodMs, MILLISECONDS);
 
       if (Boolean.getBoolean("com.zaxxer.hikari.blockUntilFilled") && config.getInitializationFailTimeout() > 1) {
-         addConnectionExecutor.setMaximumPoolSize(Runtime.getRuntime().availableProcessors());
          addConnectionExecutor.setCorePoolSize(Runtime.getRuntime().availableProcessors());
+         addConnectionExecutor.setMaximumPoolSize(Runtime.getRuntime().availableProcessors());
 
          final long startTime = currentTime();
          while (elapsedMillis(startTime) < config.getInitializationFailTimeout() && getTotalConnections() < config.getMinimumIdle()) {
             quietlySleep(MILLISECONDS.toMillis(100));
          }
 
-         addConnectionExecutor.setMaximumPoolSize(1);
          addConnectionExecutor.setCorePoolSize(1);
+         addConnectionExecutor.setMaximumPoolSize(1);
       }
    }
 

File: src/test/java/com/zaxxer/hikari/pool/TestValidation.java
Patch:
@@ -158,6 +158,7 @@ public void validateIdleTimeoutTooSmall()
 
       HikariConfig config = newHikariConfig();
       config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
+      config.setMinimumIdle(5);
       config.setIdleTimeout(TimeUnit.SECONDS.toMillis(5));
       config.validate();
       assertTrue(new String(baos.toByteArray()).contains("less than 10000ms"));
@@ -172,7 +173,7 @@ public void validateIdleTimeoutExceedsLifetime()
 
       HikariConfig config = newHikariConfig();
       config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
-      config.setMinimumIdle(9);
+      config.setMinimumIdle(5);
       config.setMaxLifetime(TimeUnit.MINUTES.toMillis(2));
       config.setIdleTimeout(TimeUnit.MINUTES.toMillis(3));
       config.validate();

File: src/test/java/com/zaxxer/hikari/pool/TestValidation.java
Patch:
@@ -172,6 +172,7 @@ public void validateIdleTimeoutExceedsLifetime()
 
       HikariConfig config = newHikariConfig();
       config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
+      config.setMinimumIdle(9);
       config.setMaxLifetime(TimeUnit.MINUTES.toMillis(2));
       config.setIdleTimeout(TimeUnit.MINUTES.toMillis(3));
       config.validate();

File: src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java
Patch:
@@ -215,7 +215,7 @@ public void add(final T bagEntry)
       sharedList.add(bagEntry);
 
       // spin until a thread takes it or none are waiting
-      while (waiters.get() > 0 && bagEntry.getState() != STATE_NOT_IN_USE && !handoffQueue.offer(bagEntry)) {
+      while (waiters.get() > 0 && bagEntry.getState() == STATE_NOT_IN_USE && !handoffQueue.offer(bagEntry)) {
          yield();
       }
    }

File: src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java
Patch:
@@ -215,7 +215,7 @@ public void add(final T bagEntry)
       sharedList.add(bagEntry);
 
       // spin until a thread takes it or none are waiting
-      while (waiters.get() > 0 && !handoffQueue.offer(bagEntry)) {
+      while (waiters.get() > 0 && bagEntry.getState() != STATE_NOT_IN_USE && !handoffQueue.offer(bagEntry)) {
          yield();
       }
    }

File: src/main/java/com/zaxxer/hikari/pool/PoolBase.java
Patch:
@@ -520,7 +520,7 @@ private int getAndSetNetworkTimeout(final Connection connection, final long time
             isNetworkTimeoutSupported = TRUE;
             return originalTimeout;
          }
-         catch (Exception e) {
+         catch (Exception | AbstractMethodError e) {
             if (isNetworkTimeoutSupported == UNINITIALIZED) {
                isNetworkTimeoutSupported = FALSE;
 

File: src/test/java/com/zaxxer/hikari/pool/TestConnections.java
Patch:
@@ -745,7 +745,7 @@ public Connection getConnection() throws SQLException {
             return new StubConnection();
          }
 
-         throw new Error("Bad thing happens on datasource.");
+         throw new RuntimeException("Bad thing happens on datasource.");
       }
 
       public void setErrorOnConnection(boolean errorOnConnection) {

File: src/main/java/com/zaxxer/hikari/HikariDataSource.java
Patch:
@@ -30,7 +30,7 @@
 import java.sql.SQLFeatureNotSupportedException;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import static com.zaxxer.hikari.pool.HikariPool.POOL_SHUTDOWN;
+import static com.zaxxer.hikari.pool.HikariPool.POOL_NORMAL;
 
 /**
  * The HikariCP pooled DataSource.
@@ -294,7 +294,7 @@ public void setHealthCheckRegistry(Object healthCheckRegistry)
     */
    public boolean isRunning()
    {
-      return pool != null && pool.poolState != POOL_SHUTDOWN;
+      return pool != null && pool.poolState == POOL_NORMAL;
    }
 
    /**

File: src/test/java/com/zaxxer/hikari/mocks/MockDataSource.java
Patch:
@@ -148,7 +148,7 @@ public Void answer(InvocationOnMock invocation) throws Throwable
 //            public Void answer(InvocationOnMock invocation) throws Throwable {
 //                return null;
 //            }
-//        }).doThrow(new SQLException("Transaction already commited")).when(mockConnection).commit();
+//        }).doThrow(new SQLException("Transaction already committed")).when(mockConnection).commit();
 
         // Handle Connection.rollback()
 //        doAnswer(new Answer<Void>() {

File: src/main/java/com/zaxxer/hikari/pool/PoolBase.java
Patch:
@@ -58,6 +58,7 @@ abstract class PoolBase
 
    protected volatile String catalog;
    protected final String poolName;
+   protected final AtomicReference<Throwable> lastConnectionFailure;
 
    long connectionTimeout;
    long validationTimeout;
@@ -81,7 +82,6 @@ abstract class PoolBase
 
    private final boolean isUseJdbc4Validation;
    private final boolean isIsolateInternalQueries;
-   private final AtomicReference<Throwable> lastConnectionFailure;
 
    private volatile boolean isValidChecked;
 

File: src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java
Patch:
@@ -195,7 +195,9 @@ else if ((i & 0xff) == 0xff) {
       }
 
       final List<Object> threadLocalList = threadList.get();
-      threadLocalList.add(weakThreadLocals ? new WeakReference<>(bagEntry) : bagEntry);
+      if (threadLocalList.size() < 50) {
+         threadLocalList.add(weakThreadLocals ? new WeakReference<>(bagEntry) : bagEntry);
+      }
    }
 
    /**

File: src/main/java/com/zaxxer/hikari/util/DriverDataSource.java
Patch:
@@ -125,7 +125,9 @@ public Connection getConnection(final String username, final String password) th
       final Properties cloned = (Properties) driverProperties.clone();
       if (username != null) {
          cloned.put("user", username);
-         cloned.put("username", username);
+         if (cloned.containsKey("username")) {
+            cloned.put("username", username);
+         }
       }
       if (password != null) {
          cloned.put("password", password);

File: src/main/java/com/zaxxer/hikari/HikariPoolMXBean.java
Patch:
@@ -58,7 +58,7 @@ public interface HikariPoolMXBean
    int getThreadsAwaitingConnection();
 
    /**
-    * Evict currently idle connections from the pool, and mark active (in-use) connection for eviction when they are
+    * Evict currently idle connections from the pool, and mark active (in-use) connections for eviction when they are
     * returned to the pool.
     */
    void softEvictConnections();

File: src/main/java/com/zaxxer/hikari/HikariPoolMXBean.java
Patch:
@@ -59,7 +59,7 @@ public interface HikariPoolMXBean
 
    /**
     * Evict currently idle connections from the pool, and mark active (in-use) connection for eviction when they are
-    * return to the pool.
+    * returned to the pool.
     */
    void softEvictConnections();
 

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -856,6 +856,8 @@ public String getSchema() {
 
    /**
     * Set the default schema name to be set on connections.
+    *
+    * @param schema the name of the default schema
     */
    public void setSchema(String schema)
    {

File: src/main/java/com/zaxxer/hikari/HikariPoolMXBean.java
Patch:
@@ -66,7 +66,7 @@ public interface HikariPoolMXBean
    /**
     * Suspend the pool.  When the pool is suspended, threads calling {@link DataSource#getConnection()} will be
     * blocked <i>with no timeout</i> until the pool is resumed via the {@link #resumePool()} method.
-    * <p/>
+    * <br>
     * This method has no effect unless the {@link HikariConfig#setAllowPoolSuspension(boolean)} method or equivalent
     * property has been set to {@code true}.
     */
@@ -75,7 +75,7 @@ public interface HikariPoolMXBean
    /**
     * Resume the pool.  Enables connection borrowing to resume on a pool that has been suspended via the
     * {@link #suspendPool()} method.
-    * <p/>
+    * <br>
     * This method has no effect unless the {@link HikariConfig#setAllowPoolSuspension(boolean)} method or equivalent
     * property has been set to {@code true}.
     */

File: src/main/java/com/zaxxer/hikari/pool/PoolBase.java
Patch:
@@ -54,10 +54,10 @@ abstract class PoolBase
    private final Logger LOGGER = LoggerFactory.getLogger(PoolBase.class);
 
    public final HikariConfig config;
+   public IMetricsTrackerDelegate metricsTracker;
    protected final String poolName;
    long connectionTimeout;
    long validationTimeout;
-   IMetricsTrackerDelegate metricsTracker;
 
    private static final String[] RESET_STATES = {"readOnly", "autoCommit", "isolation", "catalog", "netTimeout", "schema"};
    private static final int UNINITIALIZED = -1;

File: src/test/java/com/zaxxer/hikari/pool/TestMBean.java
Patch:
@@ -95,7 +95,7 @@ public void testMBeanReporting() throws SQLException, InterruptedException, Malf
       }
    }
 
-   @Test(expected = IllegalStateException.class)
+   @Test
    public void testMBeanChange() {
       HikariConfig config = newHikariConfig();
       config.setMinimumIdle(3);
@@ -109,7 +109,7 @@ public void testMBeanChange() {
          HikariConfigMXBean hikariConfigMXBean = ds.getHikariConfigMXBean();
          hikariConfigMXBean.setIdleTimeout(3000);
 
-         ds.setIdleTimeout(1000);
+         assertEquals(3000, ds.getIdleTimeout());
       }
    }
 }

File: src/main/java/com/zaxxer/hikari/util/SuspendResumeLock.java
Patch:
@@ -64,10 +64,11 @@ public void acquire() throws SQLException
       if (acquisitionSemaphore.tryAcquire()) {
          return;
       }
-
-      if (Boolean.getBoolean("com.zaxxer.hikari.throwIfSuspended")) {
+      else if (Boolean.getBoolean("com.zaxxer.hikari.throwIfSuspended")) {
          throw new SQLTransientException("The pool is currently suspended and configured to throw exceptions upon acquisition");
       }
+
+      acquisitionSemaphore.acquireUninterruptibly();
    }
 
    public void release()

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -1026,6 +1026,8 @@ public void copyStateTo(HikariConfig other)
             }
          }
       }
+
+      other.sealed = false;
    }
 
    // ***********************************************************************

File: src/main/java/com/zaxxer/hikari/HikariDataSource.java
Patch:
@@ -47,7 +47,7 @@ public class HikariDataSource extends HikariConfig implements DataSource, Closea
    private volatile HikariPool pool;
 
    /**
-    * Default constructor.  Setters are be used to configure the pool.  Using
+    * Default constructor.  Setters are used to configure the pool.  Using
     * this constructor vs. {@link #HikariDataSource(HikariConfig)} will
     * result in {@link #getConnection()} performance that is slightly lower
     * due to lazy initialization checks.

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -32,6 +32,7 @@
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.security.AccessControlException;
+import java.sql.Connection;
 import java.util.Properties;
 import java.util.Set;
 import java.util.TreeSet;
@@ -631,7 +632,7 @@ public void setInitializationFailFast(boolean failFast)
 
    /**
     * Determine whether internal pool queries, principally aliveness checks, will be isolated in their own transaction
-    * (via {@link java.sql.Connection#rollback())}.  Defaults to {@code false}.
+    * via {@link Connection#rollback()}.  Defaults to {@code false}.
     *
     * @return {@code true} if internal pool queries are isolated, {@code false} if not
     */
@@ -642,7 +643,7 @@ public boolean isIsolateInternalQueries()
 
    /**
     * Configure whether internal pool queries, principally aliveness checks, will be isolated in their own transaction
-    * (via {@link java.sql.Connection#rollback())}.  Defaults to {@code false}.
+    * via {@link Connection#rollback()}.  Defaults to {@code false}.
     *
     * @param isolate {@code true} if internal pool queries should be isolated, {@code false} if not
     */

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -631,7 +631,7 @@ public void setInitializationFailFast(boolean failFast)
 
    /**
     * Determine whether internal pool queries, principally aliveness checks, will be isolated in their own transaction
-    * (via {@link java.sql.Connection#rollback()).  Defaults to {@code false}.
+    * (via {@link java.sql.Connection#rollback())}.  Defaults to {@code false}.
     *
     * @return {@code true} if internal pool queries are isolated, {@code false} if not
     */
@@ -642,7 +642,7 @@ public boolean isIsolateInternalQueries()
 
    /**
     * Configure whether internal pool queries, principally aliveness checks, will be isolated in their own transaction
-    * (via {@link java.sql.Connection#rollback()).  Defaults to {@code false}.
+    * (via {@link java.sql.Connection#rollback())}.  Defaults to {@code false}.
     *
     * @param isolate {@code true} if internal pool queries should be isolated, {@code false} if not
     */

File: src/main/java/com/zaxxer/hikari/pool/ProxyConnection.java
Patch:
@@ -78,6 +78,7 @@ public abstract class ProxyConnection implements Connection
       LOGGER = LoggerFactory.getLogger(ProxyConnection.class);
 
       ERROR_STATES = new HashSet<>();
+      ERROR_STATES.add("0A000"); // FEATURE UNSUPPORTED
       ERROR_STATES.add("57P01"); // ADMIN SHUTDOWN
       ERROR_STATES.add("57P02"); // CRASH SHUTDOWN
       ERROR_STATES.add("57P03"); // CANNOT CONNECT NOW

File: src/main/java/com/zaxxer/hikari/HikariDataSource.java
Patch:
@@ -66,7 +66,7 @@ public HikariDataSource()
    public HikariDataSource(HikariConfig configuration)
    {
       configuration.validate();
-      configuration.copyState(this);
+      configuration.copyStateTo(this);
 
       LOGGER.info("{} - Starting...", configuration.getPoolName());
       pool = fastPathPool = new HikariPool(this);

File: src/test/java/com/zaxxer/hikari/pool/HouseKeeperCleanupTest.java
Patch:
@@ -62,7 +62,7 @@ public void testHouseKeeperCleanupWithCustomExecutor() throws Exception
       config.setScheduledExecutor(executor);
 
       HikariConfig config2 = newHikariConfig();
-      config.copyState(config2);
+      config.copyStateTo(config2);
 
       try (
          final HikariDataSource ds1 = new HikariDataSource(config);

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -272,10 +272,10 @@ public void evictConnection(Connection connection)
 
    public void setMetricRegistry(Object metricRegistry)
    {
-      if (metricRegistry.getClass().getName().contains("MetricRegistry")) {
+      if (metricRegistry != null && metricRegistry.getClass().getName().contains("MetricRegistry")) {
          setMetricsTrackerFactory(new CodahaleMetricsTrackerFactory((MetricRegistry) metricRegistry));
       }
-      else if (metricRegistry.getClass().getName().contains("MeterRegistry")) {
+      else if (metricRegistry != null && metricRegistry.getClass().getName().contains("MeterRegistry")) {
          setMetricsTrackerFactory(new MicrometerMetricsTrackerFactory((MeterRegistry) metricRegistry));
       }
       else {

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -272,10 +272,10 @@ public void evictConnection(Connection connection)
 
    public void setMetricRegistry(Object metricRegistry)
    {
-      if (metricRegistry instanceof MetricRegistry) {
+      if (metricRegistry.getClass().getName().contains("MetricRegistry")) {
          setMetricsTrackerFactory(new CodahaleMetricsTrackerFactory((MetricRegistry) metricRegistry));
       }
-      else if (metricRegistry instanceof MeterRegistry) {
+      else if (metricRegistry.getClass().getName().contains("MeterRegistry")) {
          setMetricsTrackerFactory(new MicrometerMetricsTrackerFactory((MeterRegistry) metricRegistry));
       }
       else {

File: src/test/java/com/zaxxer/hikari/pool/TestValidation.java
Patch:
@@ -106,7 +106,7 @@ public void validateBadDriver()
          fail();
       }
       catch (RuntimeException ise) {
-         assertTrue(ise.getMessage().contains("class of driverClassName "));
+         assertTrue(ise.getMessage().startsWith("Failed to load driver class invalid "));
       }
    }
 

File: src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java
Patch:
@@ -186,7 +186,7 @@ public void requite(final T bagEntry)
          if (bagEntry.getState() != STATE_NOT_IN_USE || handoffQueue.offer(bagEntry)) {
             return;
          }
-         else if ((i & 0x100) == 0x100) {
+         else if ((i & 0xff) == 0xff) {
             parkNanos(MICROSECONDS.toNanos(10));
          }
          else {

File: src/main/java/com/zaxxer/hikari/metrics/micrometer/MicrometerMetricsTracker.java
Patch:
@@ -54,7 +54,7 @@ public class MicrometerMetricsTracker implements IMetricsTracker
 
       this.connectionUsage = meterRegistry
          .summaryBuilder(METRIC_NAME_USAGE)
-         .tags(poolName, METRIC_CATEGORY)
+         .tags(METRIC_CATEGORY, poolName)
          .quantiles(WindowSketchQuantiles.quantiles(0.5, 0.95).create())
          .histogram(buckets(linear(0, 10, 20), TimeUnit.MILLISECONDS))
          .create();

File: src/main/java/com/zaxxer/hikari/metrics/prometheus/PrometheusMetricsTrackerFactory.java
Patch:
@@ -43,8 +43,7 @@ public PrometheusMetricsTrackerFactory(CollectorRegistry registry) {
    }
 
    @Override
-   public IMetricsTracker create(String poolName, PoolStats poolStats)
-   {
+   public IMetricsTracker create(String poolName, PoolStats poolStats) {
       Collector collector = new HikariCPCollector(poolName, poolStats).register(registry);
       return new PrometheusMetricsTracker(poolName, collector, registry);
    }

File: src/test/java/com/zaxxer/hikari/pool/ConnectionPoolSizeVsThreadsTest.java
Patch:
@@ -45,9 +45,9 @@
  */
 public class ConnectionPoolSizeVsThreadsTest {
 
-   public static final Logger LOGGER = LoggerFactory.getLogger(ConnectionPoolSizeVsThreadsTest.class);
+   private static final Logger LOGGER = LoggerFactory.getLogger(ConnectionPoolSizeVsThreadsTest.class);
 
-   public static final int ITERATIONS = 50_000;
+   private static final int ITERATIONS = 50_000;
 
    @Test
    public void testPoolSizeAboutSameSizeAsThreadCount() throws Exception {

File: src/test/java/com/zaxxer/hikari/metrics/prometheus/PrometheusMetricsTrackerTest.java
Patch:
@@ -60,7 +60,7 @@ public void recordConnectionTimeout() throws Exception {
          assertThat(CollectorRegistry.defaultRegistry.getSampleValue(
             "hikaricp_connection_acquired_nanos_count",
             labelNames,
-            labelValues), is(equalTo(2.0)));
+            labelValues), is(equalTo(3.0)));
          assertTrue(CollectorRegistry.defaultRegistry.getSampleValue(
             "hikaricp_connection_acquired_nanos_sum",
             labelNames,

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -303,7 +303,7 @@ public void setHealthCheckRegistry(Object healthCheckRegistry)
    @Override
    public Future<Boolean> addBagItem(final int waiting)
    {
-      final boolean shouldAdd = waiting - addConnectionQueue.size() > 0;
+      final boolean shouldAdd = waiting - addConnectionQueue.size() >= 0; // Yes, >= is intentional.
       if (shouldAdd) {
          return addConnectionExecutor.submit(POOL_ENTRY_CREATOR);
       }

File: src/main/java/com/zaxxer/hikari/util/UtilityElf.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.zaxxer.hikari.util;
 
+import static java.lang.Thread.currentThread;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
 import java.lang.reflect.Constructor;
@@ -44,7 +45,7 @@ public static String getNullIfEmpty(final String text)
    }
 
    /**
-    * Sleep and transform an InterruptedException into a RuntimeException.
+    * Sleep and suppress InterruptedException (but re-signal it).
     *
     * @param millis the number of milliseconds to sleep
     */
@@ -55,6 +56,7 @@ public static void quietlySleep(final long millis)
       }
       catch (InterruptedException e) {
          // I said be quiet!
+         currentThread().interrupt();
       }
    }
 

File: src/main/java/com/zaxxer/hikari/pool/PoolEntry.java
Patch:
@@ -39,7 +39,7 @@ final class PoolEntry implements IConcurrentBagEntry
    private static final Logger LOGGER = LoggerFactory.getLogger(PoolEntry.class);
    private static final AtomicIntegerFieldUpdater<PoolEntry> stateUpdater;
 
-   static final Comparator<PoolEntry> LASTACCESS_COMPARABLE;
+   static final Comparator<PoolEntry> LASTACCESS_REVERSE_COMPARABLE;
 
    Connection connection;
    long lastAccessed;
@@ -57,10 +57,10 @@ final class PoolEntry implements IConcurrentBagEntry
 
    static
    {
-      LASTACCESS_COMPARABLE = new Comparator<PoolEntry>() {
+      LASTACCESS_REVERSE_COMPARABLE = new Comparator<PoolEntry>() {
          @Override
          public int compare(final PoolEntry entryOne, final PoolEntry entryTwo) {
-            return Long.compare(entryOne.lastAccessed, entryTwo.lastAccessed);
+            return Long.compare(entryTwo.lastAccessed, entryOne.lastAccessed);
          }
       };
 

File: src/test/java/com/zaxxer/hikari/util/TomcatConcurrentBagLeakTest.java
Patch:
@@ -135,7 +135,7 @@ public static class FauxWebContext
 
       public void createConcurrentBag() throws InterruptedException
       {
-         try (ConcurrentBag<PoolEntry> bag = new ConcurrentBag<>(() -> CompletableFuture.completedFuture(Boolean.TRUE))) {
+         try (ConcurrentBag<PoolEntry> bag = new ConcurrentBag<>((x) -> CompletableFuture.completedFuture(Boolean.TRUE))) {
 
             PoolEntry entry = new PoolEntry();
             bag.add(entry);

File: src/main/java/com/zaxxer/hikari/util/FastList.java
Patch:
@@ -84,7 +84,7 @@ public boolean add(T element)
          @SuppressWarnings("unchecked")
          final T[] newElementData = (T[]) Array.newInstance(clazz, newCapacity);
          System.arraycopy(elementData, 0, newElementData, 0, oldCapacity);
-         newElementData[size] = element;
+         newElementData[size++] = element;
          elementData = newElementData;
       }
 

File: src/main/java/com/zaxxer/hikari/util/FastList.java
Patch:
@@ -84,7 +84,7 @@ public boolean add(T element)
          @SuppressWarnings("unchecked")
          final T[] newElementData = (T[]) Array.newInstance(clazz, newCapacity);
          System.arraycopy(elementData, 0, newElementData, 0, oldCapacity);
-         newElementData[size - 1] = element;
+         newElementData[size] = element;
          elementData = newElementData;
       }
 

File: src/main/java/com/zaxxer/hikari/pool/PoolBase.java
Patch:
@@ -168,7 +168,7 @@ boolean isConnectionAlive(final Connection connection)
 
          return true;
       }
-      catch (SQLException e) {
+      catch (Exception e) {
          lastConnectionFailure.set(e);
          LOGGER.warn("{} - Failed to validate connection {} ({})", poolName, connection, e.getMessage());
          return false;

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -413,11 +413,13 @@ public long getInitializationFailTimeout()
     */
    public void setInitializationFailTimeout(long initializationFailTimeout)
    {
-      if (initializationFailTimeout < 0L) {
+      if (initializationFailTimeout <= 0L) {
          initializationFailTimeout = 0L;
+         isInitializationFailFast = true;
       }
       else if (initializationFailTimeout < 1000L) {
          initializationFailTimeout = 1000L;
+         isInitializationFailFast = false;
       }
 
       this.initializationFailTimeout = initializationFailTimeout;

File: src/test/java/com/zaxxer/hikari/pool/ConnectionPoolSizeVsThreadsTest.java
Patch:
@@ -43,7 +43,7 @@ public void testPoolSizeAboutSameSizeAsThreadCount() throws Exception {
       {
          final int threadCount = 50;
          final Counts counts = testPoolSize(2, 100, threadCount, 1, 0, 20);
-         Assert.assertEquals(threadCount, counts.getTotal(), 2);
+         Assert.assertEquals(threadCount, counts.getTotal(), 5);
       }
 //      {
 //         final int threadCount = 2;

File: src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java
Patch:
@@ -316,7 +316,7 @@ public void unreserve(final T bagEntry)
     */
    public int getPendingQueue()
    {
-      return synchronizer.getQueueLength();
+      return waiters.get();
    }
 
    /**

File: src/test/java/com/zaxxer/hikari/pool/RampUpDown.java
Patch:
@@ -44,6 +44,9 @@ public void rampUpDownTest() throws SQLException, InterruptedException
            ds.setIdleTimeout(1000);
            HikariPool pool = TestElf.getPool(ds);
 
+           // wait two housekeeping periods so we don't fail if this part of test runs too quickly
+           Thread.sleep(500);
+
            Assert.assertSame("Total connections not as expected", 5, pool.getTotalConnections());
 
            Connection[] connections = new Connection[ds.getMaximumPoolSize()];

File: src/test/java/com/zaxxer/hikari/pool/ConnectionRaceConditionTest.java
Patch:
@@ -44,7 +44,7 @@ public void testRaceCondition() throws Exception
       HikariConfig config = new HikariConfig();
       config.setMinimumIdle(0);
       config.setMaximumPoolSize(10);
-      config.setInitializationFailFast(false);
+      config.setInitializationFailTimeout(Long.MAX_VALUE);
       config.setConnectionTimeout(2500);
       config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 

File: src/test/java/com/zaxxer/hikari/pool/HouseKeeperCleanupTest.java
Patch:
@@ -53,7 +53,7 @@ public void testHouseKeeperCleanupWithCustomExecutor() throws Exception
       HikariConfig config = new HikariConfig();
       config.setMinimumIdle(0);
       config.setMaximumPoolSize(10);
-      config.setInitializationFailFast(false);
+      config.setInitializationFailTimeout(Long.MAX_VALUE);
       config.setConnectionTimeout(2500);
       config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
       config.setScheduledExecutorService(executor);

File: src/test/java/com/zaxxer/hikari/pool/RampUpDown.java
Patch:
@@ -33,7 +33,7 @@ public void rampUpDownTest() throws SQLException, InterruptedException
         HikariConfig config = new HikariConfig();
         config.setMinimumIdle(5);
         config.setMaximumPoolSize(60);
-        config.setInitializationFailFast(true);
+        config.setInitializationFailTimeout(0);
         config.setConnectionTestQuery("VALUES 1");
         config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 

File: src/test/java/com/zaxxer/hikari/pool/TestConcurrentBag.java
Patch:
@@ -46,7 +46,7 @@ public static void setup()
       HikariConfig config = new HikariConfig();
       config.setMinimumIdle(1);
       config.setMaximumPoolSize(2);
-      config.setInitializationFailFast(true);
+      config.setInitializationFailTimeout(0);
       config.setConnectionTestQuery("VALUES 1");
       config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 

File: src/test/java/com/zaxxer/hikari/pool/TestConnectionTimeoutRetry.java
Patch:
@@ -74,7 +74,7 @@ public void testConnectionRetries2() throws SQLException
       config.setMaximumPoolSize(1);
       config.setConnectionTimeout(2800);
       config.setValidationTimeout(2800);
-      config.setInitializationFailFast(true);
+      config.setInitializationFailTimeout(0);
       config.setConnectionTestQuery("VALUES 1");
       config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 

File: src/test/java/com/zaxxer/hikari/pool/TestMetrics.java
Patch:
@@ -56,7 +56,7 @@ public void testMetricWait() throws SQLException
       config.setMinimumIdle(1);
       config.setMaximumPoolSize(1);
       config.setMetricRegistry(metricRegistry);
-      config.setInitializationFailFast(false);
+      config.setInitializationFailTimeout(Long.MAX_VALUE);
       config.setPoolName("test");
       config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 
@@ -87,7 +87,7 @@ public void testMetricUsage() throws SQLException
       config.setMinimumIdle(1);
       config.setMaximumPoolSize(1);
       config.setMetricRegistry(metricRegistry);
-      config.setInitializationFailFast(false);
+      config.setInitializationFailTimeout(Long.MAX_VALUE);
       config.setPoolName("test");
       config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 

File: src/test/java/com/zaxxer/hikari/pool/UnwrapTest.java
Patch:
@@ -38,7 +38,7 @@ public void testUnwrapConnection() throws SQLException
         HikariConfig config = new HikariConfig();
         config.setMinimumIdle(1);
         config.setMaximumPoolSize(1);
-        config.setInitializationFailFast(true);
+        config.setInitializationFailTimeout(0);
         config.setConnectionTestQuery("VALUES 1");
         config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 
@@ -60,7 +60,7 @@ public void testUnwrapDataSource() throws SQLException
        HikariConfig config = new HikariConfig();
        config.setMinimumIdle(1);
        config.setMaximumPoolSize(1);
-       config.setInitializationFailFast(true);
+       config.setInitializationFailTimeout(0);
        config.setConnectionTestQuery("VALUES 1");
        config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 

File: src/test/java/com/zaxxer/hikari/pool/TestConnections.java
Patch:
@@ -500,7 +500,7 @@ public Connection getConnection() throws SQLException
       config.setMaximumPoolSize(2);
       config.setConnectionTimeout(TimeUnit.SECONDS.toMillis(3));
       config.setConnectionTestQuery("VALUES 1");
-      config.setInitializationFailFast(false);
+      config.setInitializationFailTimeout(TimeUnit.SECONDS.toMillis(2));
       config.setDataSource(stubDataSource);
 
       try (HikariDataSource ds = new HikariDataSource(config); Connection c = ds.getConnection()) {

File: src/main/java/com/zaxxer/hikari/pool/ProxyConnection.java
Patch:
@@ -151,10 +151,10 @@ final SQLException checkException(SQLException sqle)
       SQLException nse = sqle;
       for (int depth = 0; nse != null && delegate != ClosedConnection.CLOSED_CONNECTION && depth < 10; depth++) {
          final String sqlState = nse.getSQLState();
-         if (sqlState != null && sqlState.startsWith("08") || ERROR_STATES.contains(sqlState) || ERROR_CODES.contains(sqle.getErrorCode())) {
+         if (sqlState != null && sqlState.startsWith("08") || ERROR_STATES.contains(sqlState) || ERROR_CODES.contains(nse.getErrorCode())) {
             // broken connection
             LOGGER.warn("{} - Connection {} marked as broken because of SQLSTATE({}), ErrorCode({})",
-                        poolEntry.getPoolName(), delegate, sqlState, sqle.getErrorCode(), sqle);
+                        poolEntry.getPoolName(), delegate, sqlState, nse.getErrorCode(), nse);
             leakTask.cancel();
             poolEntry.evict("(connection is broken)");
             delegate = ClosedConnection.CLOSED_CONNECTION;

File: src/main/java/com/zaxxer/hikari/pool/PoolBase.java
Patch:
@@ -176,7 +176,7 @@ boolean isConnectionAlive(final Connection connection)
 
    Throwable getLastConnectionFailure()
    {
-      return lastConnectionFailure.getAndSet(null);
+      return lastConnectionFailure.get();
    }
 
    public DataSource getUnwrappedDataSource()

File: src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java
Patch:
@@ -75,7 +75,7 @@ public interface IConcurrentBagEntry
       int STATE_RESERVED = -2;
 
       boolean compareAndSet(int expectState, int newState);
-      void lazySet(int newState);
+      void setState(int newState);
       int getState();
    }
 
@@ -187,7 +187,7 @@ public T borrow(long timeout, final TimeUnit timeUnit) throws InterruptedExcepti
     */
    public void requite(final T bagEntry)
    {
-      bagEntry.lazySet(STATE_NOT_IN_USE);
+      bagEntry.setState(STATE_NOT_IN_USE);
 
       final List<Object> threadLocalList = threadList.get();
       if (threadLocalList != null) {

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -769,7 +769,7 @@ else if (dataSourceClassName != null) {
             LOGGER.error("{} - cannot use driverClassName and dataSourceClassName together.", poolName);
             // NOTE: This exception text is referenced by a Spring Boot FailureAnalyzer, it should not be
             // changed without first notifying the Spring Boot developers.
-            throw new IllegalArgumentException("cannot use driverClassName and dataSourceClassName together.");
+            throw new IllegalStateException("cannot use driverClassName and dataSourceClassName together.");
          }
          else if (jdbcUrl != null) {
             LOGGER.warn("{} - using dataSourceClassName and ignoring jdbcUrl.", poolName);

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -767,6 +767,8 @@ else if (isRegisterMbeans && poolName.contains(":")) {
       else if (dataSourceClassName != null) {
          if (driverClassName != null) {
             LOGGER.error("{} - cannot use driverClassName and dataSourceClassName together.", poolName);
+            // NOTE: This exception text is referenced by a Spring Boot FailureAnalyzer, it should not be
+            // changed without first notifying the Spring Boot developers.
             throw new IllegalArgumentException("cannot use driverClassName and dataSourceClassName together.");
          }
          else if (jdbcUrl != null) {

File: src/main/java/com/zaxxer/hikari/pool/ProxyConnection.java
Patch:
@@ -231,7 +231,7 @@ public final void close() throws SQLException
          leakTask.cancel();
 
          try {
-            if (isCommitStateDirty && !isAutoCommit && !isReadOnly) {
+            if (isCommitStateDirty && !isAutoCommit) {
                delegate.rollback();
                lastAccess = clockSource.currentTime();
                LOGGER.debug("{} - Executed rollback on connection {} due to dirty commit state on close().", poolEntry.getPoolName(), delegate);

File: src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java
Patch:
@@ -46,7 +46,7 @@
  * Note that items that are "borrowed" from the bag are not actually
  * removed from any collection, so garbage collection will not occur
  * even if the reference is abandoned.  Thus care must be taken to
- * "requite" borrowed objects otherwise a memory leak will result.  Only
+ * "recycle" borrowed objects otherwise a memory leak will result.  Only
  * the "remove" method can completely remove an object from the bag.
  *
  * @author Brett Wooldridge

File: src/test/java/com/zaxxer/hikari/pool/TestConcurrentBag.java
Patch:
@@ -89,7 +89,7 @@ public Future<Boolean> addBagItem()
       PrintStream ps = new PrintStream(baos, true);
       TestElf.setSlf4jTargetStream(ConcurrentBag.class, ps);
 
-      bag.requite(reserved);
+      bag.recycle(reserved);
 
       bag.remove(notinuse);
       Assert.assertTrue(new String(baos.toByteArray()).contains("not borrowed or reserved"));

File: src/main/java/com/zaxxer/hikari/pool/ProxyConnection.java
Patch:
@@ -82,10 +82,10 @@ public abstract class ProxyConnection implements Connection
       ERROR_STATES.add("01002"); // SQL92 disconnect error
       ERROR_STATES.add("JZ0C0"); // Sybase disconnect error
       ERROR_STATES.add("JZ0C1"); // Sybase disconnect error
-      ERROR_STATES.add("61000"); // Oracle ORA-02399: exceeded maximum connect time.
 
       ERROR_CODES = new HashSet<>();
       ERROR_CODES.add(500150);
+      ERROR_CODES.add(2399);
    }
 
    protected ProxyConnection(final PoolEntry poolEntry, final Connection connection, final FastList<Statement> openStatements, final ProxyLeakTask leakTask, final long now, final boolean isReadOnly, final boolean isAutoCommit) {

File: src/main/java/com/zaxxer/hikari/util/UtilityElf.java
Patch:
@@ -21,6 +21,7 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.sql.Connection;
+import java.util.Locale;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.RejectedExecutionHandler;
 import java.util.concurrent.ThreadFactory;
@@ -125,7 +126,8 @@ public static int getTransactionIsolation(final String transactionIsolationName)
    {
       if (transactionIsolationName != null) {
          try {
-            final String upperName = transactionIsolationName.toUpperCase();
+            // use the english locale to avoid the infamous turkish locale bug
+            final String upperName = transactionIsolationName.toUpperCase(Locale.ENGLISH);
             if (upperName.startsWith("TRANSACTION_")) {
                Field field = Connection.class.getField(upperName);
                return field.getInt(null);

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -53,6 +53,7 @@ public class HikariConfig implements HikariConfigMXBean
    private static final long VALIDATION_TIMEOUT = SECONDS.toMillis(5);
    private static final long IDLE_TIMEOUT = MINUTES.toMillis(10);
    private static final long MAX_LIFETIME = MINUTES.toMillis(30);
+   private static final int DEFAULT_POOL_SIZE = 10;
 
    private static boolean unitTest;
 
@@ -825,7 +826,7 @@ private void validateNumerics()
       }
 
       if (maxPoolSize < 1) {
-         maxPoolSize = (minIdle <= 0) ? 10 : minIdle;
+         maxPoolSize = (minIdle <= 0) ? DEFAULT_POOL_SIZE : minIdle;
       }
 
       if (minIdle < 0 || minIdle > maxPoolSize) {

File: src/main/java/com/zaxxer/hikari/pool/ProxyConnection.java
Patch:
@@ -81,6 +81,7 @@ public abstract class ProxyConnection implements Connection
       SQL_ERRORS.add("01002"); // SQL92 disconnect error
       SQL_ERRORS.add("JZ0C0"); // Sybase disconnect error
       SQL_ERRORS.add("JZ0C1"); // Sybase disconnect error
+      SQL_ERRORS.add("61000"); // Oracle ORA-02399: exceeded maximum connect time.
    }
 
    protected ProxyConnection(final PoolEntry poolEntry, final Connection connection, final FastList<Statement> openStatements, final ProxyLeakTask leakTask, final long now, final boolean isReadOnly, final boolean isAutoCommit) {

File: src/main/java/com/zaxxer/hikari/pool/ProxyConnection.java
Patch:
@@ -81,6 +81,7 @@ public abstract class ProxyConnection implements Connection
       SQL_ERRORS.add("01002"); // SQL92 disconnect error
       SQL_ERRORS.add("JZ0C0"); // Sybase disconnect error
       SQL_ERRORS.add("JZ0C1"); // Sybase disconnect error
+      SQL_ERRORS.add("61000"); // Oracle ORA-02399: exceeded maximum connect time.
    }
 
    protected ProxyConnection(final PoolEntry poolEntry, final Connection connection, final FastList<Statement> openStatements, final ProxyLeakTask leakTask, final long now, final boolean isReadOnly, final boolean isAutoCommit) {

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -27,7 +27,6 @@
 import java.util.TreeSet;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.atomic.AtomicInteger;
 
 import javax.naming.InitialContext;
 import javax.naming.NamingException;

File: src/main/java/com/zaxxer/hikari/HikariDataSource.java
Patch:
@@ -251,7 +251,9 @@ public void setHealthCheckRegistry(Object healthCheckRegistry)
    }
 
    /**
-    * Evict a connection from the pool.
+    * Evict a connection from the pool.  If the connection has already been closed (returned to the pool)
+    * this may result in a "soft" eviction; the connection will be evicted sometime in the future if it is
+    * currently in use.  If the connection has not been closed, the eviction is immediate.
     *
     * @param connection the connection to evict from the pool
     */

File: src/main/java/com/zaxxer/hikari/pool/ProxyConnection.java
Patch:
@@ -162,7 +162,7 @@ final SQLException checkException(final SQLException sqle)
       return sqle;
    }
 
-   final void untrackStatement(final Statement statement)
+   final synchronized void untrackStatement(final Statement statement)
    {
       openStatements.remove(statement);
    }

File: src/main/java/com/zaxxer/hikari/pool/PoolBase.java
Patch:
@@ -436,7 +436,7 @@ private int getAndSetNetworkTimeout(final Connection connection, final long time
             if (isNetworkTimeoutSupported == UNINITIALIZED) {
                isNetworkTimeoutSupported = FALSE;
 
-               LOGGER.warn("{} - Failed to get/set network timeout for connection. ({})", poolName, e.getMessage());
+               LOGGER.info("{} - Driver does not support get/set network timeout for connections. ({})", poolName, e.getMessage());
                if (validationTimeout < SECONDS.toMillis(1)) {
                   LOGGER.warn("{} - A validationTimeout of less than 1 second cannot be honored on drivers without setNetworkTimeout() support.", poolName);
                }

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -174,7 +174,7 @@ public final Connection getConnection(final long hardTimeout) throws SQLExceptio
             }
             else {
                metricsTracker.recordBorrowStats(poolEntry, startTime);
-               return poolEntry.createProxyConnection(leakTask.start(poolEntry), now);
+               return poolEntry.createProxyConnection(leakTask.schedule(poolEntry), now);
             }
          } while (timeout > 0L);
       }
@@ -553,7 +553,7 @@ private class PoolEntryCreator implements Callable<Boolean>
       @Override
       public Boolean call() throws Exception
       {
-         long sleepBackoff = 200L;
+         long sleepBackoff = 250L;
          while (poolState == POOL_NORMAL && totalConnections.get() < config.getMaximumPoolSize()) {
             final PoolEntry poolEntry = createPoolEntry();
             if (poolEntry != null) {
@@ -564,7 +564,7 @@ public Boolean call() throws Exception
 
             // failed to get connection from db, sleep and retry
             quietlySleep(sleepBackoff);
-            sleepBackoff = Math.min(SECONDS.toMillis(10), Math.min(connectionTimeout, (long) (sleepBackoff * 1.3)));
+            sleepBackoff = Math.min(SECONDS.toMillis(10), Math.min(connectionTimeout, (long) (sleepBackoff * 1.5)));
          }
          // Pool is suspended or shutdown or at max size
          return Boolean.FALSE;

File: src/main/java/com/zaxxer/hikari/pool/PoolBase.java
Patch:
@@ -436,7 +436,7 @@ private int getAndSetNetworkTimeout(final Connection connection, final long time
             if (isNetworkTimeoutSupported == UNINITIALIZED) {
                isNetworkTimeoutSupported = FALSE;
 
-               LOGGER.warn("{} - Unable to get/set network timeout for connection. ({})", poolName, e.getMessage());
+               LOGGER.warn("{} - Failed to get/set network timeout for connection. ({})", poolName, e.getMessage());
                if (validationTimeout < SECONDS.toMillis(1)) {
                   LOGGER.warn("{} - A validationTimeout of less than 1 second cannot be honored on drivers without setNetworkTimeout() support.", poolName);
                }

File: src/main/java/com/zaxxer/hikari/pool/PoolEntry.java
Patch:
@@ -136,8 +136,7 @@ public String toString()
    {
       final long now = ClockSource.INSTANCE.currentTime();
       return connection
-         + ", borrowed " + ClockSource.INSTANCE.elapsedMillis(lastBorrowed, now) + "ms ago"
-         + ", accessed " + ClockSource.INSTANCE.elapsedMillis(lastAccessed, now) + "ms ago, "
+         + ", accessed " + ClockSource.INSTANCE.elapsedDisplayString(lastAccessed, now) + " ago, "
          + stateToString();
    }
 

File: src/main/java/com/zaxxer/hikari/pool/ProxyLeakTask.java
Patch:
@@ -65,7 +65,7 @@ private ProxyLeakTask()
    {
    }
    
-   ProxyLeakTask start(final PoolEntry bagEntry)
+   ProxyLeakTask schedule(final PoolEntry bagEntry)
    {
       return (leakDetectionThreshold == 0) ? NO_LEAK : new ProxyLeakTask(this, bagEntry);
    }

File: src/test/java/com/zaxxer/hikari/pool/ShutdownTest.java
Patch:
@@ -250,7 +250,7 @@ public void testShutdownDuringInit() throws Exception
       config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 
       try (HikariDataSource ds = new HikariDataSource(config)) {
-         StubConnection.slowCreate = true;
+      StubConnection.slowCreate = true;
          UtilityElf.quietlySleep(3000L);
       }
    }

File: src/main/java/com/zaxxer/hikari/HikariDataSource.java
Patch:
@@ -166,7 +166,7 @@ public <T> T unwrap(Class<T> iface) throws SQLException
          }
 
          if (unwrappedDataSource != null) {
-            return (T) unwrappedDataSource.unwrap(iface);
+            return unwrappedDataSource.unwrap(iface);
          }
       }
 

File: src/main/java/com/zaxxer/hikari/pool/ProxyResultSet.java
Patch:
@@ -98,9 +98,9 @@ public final <T> T unwrap(Class<T> iface) throws SQLException
          return (T) delegate;
       }
       else if (delegate instanceof Wrapper) {
-          return (T) delegate.unwrap(iface);
+          return delegate.unwrap(iface);
       }
 
       throw new SQLException("Wrapped ResultSet is not an instance of " + iface);
-   }   
+   }
 }

File: src/main/java/com/zaxxer/hikari/pool/ProxyStatement.java
Patch:
@@ -109,7 +109,7 @@ public ResultSet executeQuery(String sql) throws SQLException
    {
       connection.markCommitStateDirty();
       ResultSet resultSet = delegate.executeQuery(sql);
-      return ProxyFactory.getProxyResultSet(connection, this, resultSet); 
+      return ProxyFactory.getProxyResultSet(connection, this, resultSet);
    }
 
    /** {@inheritDoc} */
@@ -232,7 +232,7 @@ public final <T> T unwrap(Class<T> iface) throws SQLException
          return (T) delegate;
       }
       else if (delegate instanceof Wrapper) {
-          return (T) delegate.unwrap(iface);
+          return delegate.unwrap(iface);
       }
 
       throw new SQLException("Wrapped statement is not an instance of " + iface);

File: src/main/java/com/zaxxer/hikari/util/Sequence.java
Patch:
@@ -45,7 +45,7 @@ public interface Sequence
    /**
     * Factory class used to create a platform-specific ClockSource.
     */
-   public final class Factory
+   final class Factory
    {
       public static Sequence create()
       {

File: src/test/java/com/zaxxer/hikari/pool/ConnectionRaceConditionTest.java
Patch:
@@ -34,7 +34,7 @@ public void testRaceCondition() throws Exception
 
       TestElf.setSlf4jLogLevel(ConcurrentBag.class, Level.INFO);
 
-      final AtomicReference<Exception> ref = new AtomicReference<Exception>(null);
+      final AtomicReference<Exception> ref = new AtomicReference<>(null);
 
       // Initialize HikariPool with no initial connections and room to grow
       try (final HikariDataSource ds = new HikariDataSource(config)) {

File: src/test/java/com/zaxxer/hikari/pool/ShutdownTest.java
Patch:
@@ -304,7 +304,7 @@ public void run() {
                   try { connection.close(); } catch (SQLException e) { e.printStackTrace(); }
                   ds.close();
                }
-            };
+            }
          };
          t.start();
 
@@ -318,7 +318,7 @@ public void run() {
                catch (IllegalStateException e) {
                   Assert.fail(e.getMessage());
                }
-            };
+            }
          };
          t2.start();
 

File: src/test/java/com/zaxxer/hikari/pool/TestConcurrentBag.java
Patch:
@@ -63,7 +63,7 @@ public static void teardown()
    @Test
    public void testConcurrentBag() throws Exception
    {
-      ConcurrentBag<PoolEntry> bag = new ConcurrentBag<PoolEntry>( new IBagStateListener() {
+      ConcurrentBag<PoolEntry> bag = new ConcurrentBag<>(new IBagStateListener() {
          @Override
          public Future<Boolean> addBagItem()
          {

File: src/main/java/com/zaxxer/hikari/HikariDataSource.java
Patch:
@@ -166,7 +166,7 @@ public <T> T unwrap(Class<T> iface) throws SQLException
          }
 
          if (unwrappedDataSource != null) {
-            return (T) unwrappedDataSource.unwrap(iface);
+            return unwrappedDataSource.unwrap(iface);
          }
       }
 

File: src/main/java/com/zaxxer/hikari/pool/ProxyResultSet.java
Patch:
@@ -98,9 +98,9 @@ public final <T> T unwrap(Class<T> iface) throws SQLException
          return (T) delegate;
       }
       else if (delegate instanceof Wrapper) {
-          return (T) delegate.unwrap(iface);
+          return delegate.unwrap(iface);
       }
 
       throw new SQLException("Wrapped ResultSet is not an instance of " + iface);
-   }   
+   }
 }

File: src/main/java/com/zaxxer/hikari/pool/ProxyStatement.java
Patch:
@@ -109,7 +109,7 @@ public ResultSet executeQuery(String sql) throws SQLException
    {
       connection.markCommitStateDirty();
       ResultSet resultSet = delegate.executeQuery(sql);
-      return ProxyFactory.getProxyResultSet(connection, this, resultSet); 
+      return ProxyFactory.getProxyResultSet(connection, this, resultSet);
    }
 
    /** {@inheritDoc} */
@@ -232,7 +232,7 @@ public final <T> T unwrap(Class<T> iface) throws SQLException
          return (T) delegate;
       }
       else if (delegate instanceof Wrapper) {
-          return (T) delegate.unwrap(iface);
+          return delegate.unwrap(iface);
       }
 
       throw new SQLException("Wrapped statement is not an instance of " + iface);

File: src/main/java/com/zaxxer/hikari/util/Sequence.java
Patch:
@@ -45,7 +45,7 @@ public interface Sequence
    /**
     * Factory class used to create a platform-specific ClockSource.
     */
-   public final class Factory
+   final class Factory
    {
       public static Sequence create()
       {

File: src/test/java/com/zaxxer/hikari/pool/ConnectionRaceConditionTest.java
Patch:
@@ -34,7 +34,7 @@ public void testRaceCondition() throws Exception
 
       TestElf.setSlf4jLogLevel(ConcurrentBag.class, Level.INFO);
 
-      final AtomicReference<Exception> ref = new AtomicReference<Exception>(null);
+      final AtomicReference<Exception> ref = new AtomicReference<>(null);
 
       // Initialize HikariPool with no initial connections and room to grow
       try (final HikariDataSource ds = new HikariDataSource(config)) {

File: src/test/java/com/zaxxer/hikari/pool/ShutdownTest.java
Patch:
@@ -304,7 +304,7 @@ public void run() {
                   try { connection.close(); } catch (SQLException e) { e.printStackTrace(); }
                   ds.close();
                }
-            };
+            }
          };
          t.start();
 
@@ -318,7 +318,7 @@ public void run() {
                catch (IllegalStateException e) {
                   Assert.fail(e.getMessage());
                }
-            };
+            }
          };
          t2.start();
 

File: src/test/java/com/zaxxer/hikari/pool/TestConcurrentBag.java
Patch:
@@ -63,7 +63,7 @@ public static void teardown()
    @Test
    public void testConcurrentBag() throws Exception
    {
-      ConcurrentBag<PoolEntry> bag = new ConcurrentBag<PoolEntry>( new IBagStateListener() {
+      ConcurrentBag<PoolEntry> bag = new ConcurrentBag<>(new IBagStateListener() {
          @Override
          public Future<Boolean> addBagItem()
          {

File: src/main/java/com/zaxxer/hikari/pool/ProxyConnection.java
Patch:
@@ -144,9 +144,8 @@ final PoolEntry getPoolEntry()
    final SQLException checkException(final SQLException sqle)
    {
       final String sqlState = sqle.getSQLState();
-      if (sqlState != null) {
-         final boolean isForceClose = sqlState.startsWith("08") || SQL_ERRORS.contains(sqlState);
-         if (isForceClose && delegate != ClosedConnection.CLOSED_CONNECTION) {
+      if (sqlState != null && delegate != ClosedConnection.CLOSED_CONNECTION) {
+         if (sqlState.startsWith("08") || SQL_ERRORS.contains(sqlState)) {
             LOGGER.warn("{} - Connection {} marked as broken because of SQLSTATE({}), ErrorCode({})",
                         poolEntry.getPoolName(), delegate, sqlState, sqle.getErrorCode(), sqle);
             leakTask.cancel();

File: src/test/java/com/zaxxer/hikari/pool/MiscTest.java
Patch:
@@ -91,6 +91,7 @@ public void testLeakDetection() throws Exception
       ByteArrayOutputStream baos = new ByteArrayOutputStream();
       PrintStream ps = new PrintStream(baos, true);
       TestElf.setSlf4jTargetStream(Class.forName("com.zaxxer.hikari.pool.ProxyLeakTask"), ps);
+      TestElf.setConfigUnitTest(true);
 
       HikariConfig config = new HikariConfig();
       config.setMinimumIdle(0);
@@ -100,7 +101,6 @@ public void testLeakDetection() throws Exception
       config.setMetricRegistry(null);
       config.setLeakDetectionThreshold(TimeUnit.SECONDS.toMillis(1));
       config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
-      TestElf.setConfigUnitTest(true);
 
       final HikariDataSource ds = new HikariDataSource(config);
       try {

File: src/test/java/com/zaxxer/hikari/pool/TestJNDI.java
Patch:
@@ -41,7 +41,7 @@ public void testJndiLookup1() throws Exception
       ref.add(new BogusRef("username", "foo"));
       ref.add(new BogusRef("password", "foo"));
       ref.add(new BogusRef("minimumIdle", "0"));
-      ref.add(new BogusRef("maxLifetime", "20000"));
+      ref.add(new BogusRef("maxLifetime", "30000"));
       ref.add(new BogusRef("maximumPoolSize", "10"));
       ref.add(new BogusRef("dataSource.loginTimeout", "10"));
       Context nameCtx = new BogusContext();
@@ -63,7 +63,7 @@ public void testJndiLookup2() throws Exception
       ref.add(new BogusRef("username", "foo"));
       ref.add(new BogusRef("password", "foo"));
       ref.add(new BogusRef("minimumIdle", "0"));
-      ref.add(new BogusRef("maxLifetime", "20000"));
+      ref.add(new BogusRef("maxLifetime", "30000"));
       ref.add(new BogusRef("maximumPoolSize", "10"));
       ref.add(new BogusRef("dataSource.loginTimeout", "10"));
       Context nameCtx = new BogusContext2();

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -597,7 +597,7 @@ public long getLeakDetectionThreshold()
    @Override
    public void setLeakDetectionThreshold(long leakDetectionThresholdMs)
    {
-      if (leakDetectionThresholdMs != 0 && leakDetectionThresholdMs < SECONDS.toMillis(2)) {
+      if (!unitTest && leakDetectionThresholdMs != 0 && leakDetectionThresholdMs < SECONDS.toMillis(2)) {
          throw new IllegalArgumentException("leakDetectionThreshold cannot be less than 2000ms");
       }
       this.leakDetectionThreshold = leakDetectionThresholdMs;
@@ -614,7 +614,7 @@ public long getMaxLifetime()
    @Override
    public void setMaxLifetime(long maxLifetimeMs)
    {
-      if (maxLifetimeMs != 0 && maxLifetimeMs < SECONDS.toMillis(30)) {
+      if (!unitTest && maxLifetimeMs != 0 && maxLifetimeMs < SECONDS.toMillis(30)) {
          throw new IllegalArgumentException("maxLifetime cannot be less than 30000ms");
       }
       this.maxLifetime = maxLifetimeMs;

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -648,7 +648,7 @@ public int getMinimumIdle()
    @Override
    public void setMinimumIdle(int minIdle)
    {
-      if (minIdle < 0 || minIdle > maxPoolSize) {
+      if (minIdle < 0 || (minIdle > maxPoolSize && maxPoolSize > 0)) {
          throw new IllegalArgumentException("minimumIdle cannot be negative or more than maximumPoolSize");
       }
       this.minIdle = minIdle;

File: src/main/java/com/zaxxer/hikari/pool/PoolBase.java
Patch:
@@ -123,14 +123,14 @@ boolean isConnectionAlive(final Connection connection)
    {
       try {
          if (isUseJdbc4Validation) {
-            return connection.isValid((int) TimeUnit.MILLISECONDS.toSeconds(validationTimeout));
+            return connection.isValid((int) TimeUnit.MILLISECONDS.toSeconds(Math.max(1000L, validationTimeout)));
          }
 
          setNetworkTimeout(connection, validationTimeout);
 
          try (Statement statement = connection.createStatement()) {
             if (isNetworkTimeoutSupported != TRUE) {
-               setQueryTimeout(statement, (int) TimeUnit.MILLISECONDS.toSeconds(validationTimeout));
+               setQueryTimeout(statement, (int) TimeUnit.MILLISECONDS.toSeconds(Math.max(1000L, validationTimeout)));
             }
 
             statement.execute(config.getConnectionTestQuery());

File: src/main/java/com/zaxxer/hikari/pool/PoolBase.java
Patch:
@@ -363,7 +363,7 @@ private void checkDriverSupport(final Connection connection) throws SQLException
                connection.isValid(1);
             }
             catch (Throwable e) {
-               LOGGER.warn("{} - Failed to execute isValid() for connection, configure connection test query. ({})", poolName, e.getMessage());
+               LOGGER.error("{} - Failed to execute isValid() for connection, configure connection test query. ({})", poolName, e.getMessage());
                throw e;
             }
          }
@@ -372,7 +372,7 @@ private void checkDriverSupport(final Connection connection) throws SQLException
                executeSql(connection, config.getConnectionTestQuery(), false, isIsolateInternalQueries && !isAutoCommit);
             }
             catch (Throwable e) {
-               LOGGER.warn("{} - Failed to execute connection test query. ({})", poolName, e.getMessage());
+               LOGGER.error("{} - Failed to execute connection test query. ({})", poolName, e.getMessage());
                throw e;
             }
          }

File: src/test/java/com/zaxxer/hikari/pool/TestValidation.java
Patch:
@@ -23,7 +23,6 @@
 import org.junit.Test;
 
 import com.zaxxer.hikari.HikariConfig;
-import com.zaxxer.hikari.mocks.StubDataSource;
 
 /**
  * @author Brett Wooldridge
@@ -115,7 +114,7 @@ public void validateInvalidConnectionTimeout()
          Assert.fail();
       }
       catch (IllegalArgumentException ise) {
-         Assert.assertTrue(ise.getMessage().contains("connectionTimeout cannot be less than 1000ms"));
+         Assert.assertTrue(ise.getMessage().contains("connectionTimeout cannot be less than 250ms"));
       }
    }
 

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -463,7 +463,8 @@ public void run() {
     */
    private void fillPool()
    {
-      final int connectionsToAdd = Math.min(config.getMaximumPoolSize() - totalConnections.get(), config.getMinimumIdle() - getIdleConnections());
+      final int connectionsToAdd = Math.min(config.getMaximumPoolSize() - totalConnections.get(), config.getMinimumIdle() - getIdleConnections())
+                                   - addConnectionExecutor.getQueue().size();
       for (int i = 0; i < connectionsToAdd; i++) {
          addBagItem();
       }

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -593,7 +593,7 @@ public void run()
 
          // Detect retrograde time as well as forward leaps of unacceptable duration
          if (now < previous || now > clockSource.plusMillis(previous, (2 * HOUSEKEEPING_PERIOD_MS))) {
-            LOGGER.warn("{} - Unusual system clock change detected, soft-evicting connections from pool.", poolName);
+            LOGGER.warn("{} - Unusual system clock change detected (delta={}), soft-evicting connections from pool.", clockSource.elapsedDisplayString(previous, now), poolName);
             previous = now;
             softEvictConnections();
             fillPool();

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -405,7 +405,7 @@ final void closeConnection(final PoolEntry poolEntry, final String closureReason
       if (connectionBag.remove(poolEntry)) {
          final int tc = totalConnections.decrementAndGet();
          if (tc < 0) {
-            LOGGER.warn("{} - Internal accounting inconsistency, totalConnections={}", poolName, tc, new Exception());
+            LOGGER.warn("{} - Unexpected value of totalConnections={}", poolName, tc, new Exception());
          }
          final Connection connection = poolEntry.connection;
          poolEntry.close();

File: src/main/java/com/zaxxer/hikari/util/PropertyElf.java
Patch:
@@ -81,7 +81,7 @@ public static Set<String> getPropertyNames(final Class<?> targetClass)
       Matcher matcher = GETTER_PATTERN.matcher("");
       for (Method method : targetClass.getMethods()) {
          String name = method.getName();
-         if (method.getParameterTypes().length == 0 && matcher.reset(name).matches()) {
+         if (method.getParameterCount() == 0 && matcher.reset(name).matches()) {
             name = name.replaceFirst("(get|is)", "");
             try {
                if (targetClass.getMethod("set" + name, method.getReturnType()) != null) {
@@ -132,7 +132,7 @@ private static void setProperty(final Object target, final String propName, fina
       String methodName = "set" + propName.substring(0, 1).toUpperCase() + propName.substring(1);
 
       for (Method method : methods) {
-         if (method.getName().equals(methodName) && method.getParameterTypes().length == 1) {
+         if (method.getName().equals(methodName) && method.getParameterCount() == 1) {
             writeMethod = method;
             break;
          }
@@ -141,7 +141,7 @@ private static void setProperty(final Object target, final String propName, fina
       if (writeMethod == null) {
          methodName = "set" + propName.toUpperCase();
          for (Method method : methods) {
-            if (method.getName().equals(methodName) && method.getParameterTypes().length == 1) {
+            if (method.getName().equals(methodName) && method.getParameterCount() == 1) {
                writeMethod = method;
                break;
             }

File: src/test/java/com/zaxxer/hikari/pool/TestJNDI.java
Patch:
@@ -84,7 +84,7 @@ public void testJndiLookup3() throws Exception
          Assert.fail();
       }
       catch (RuntimeException e) {
-         Assert.assertTrue(e.getMessage().contains("JNDI context is null"));
+         Assert.assertTrue(e.getMessage().contains("JNDI context does not found"));
       }
    }
 

File: src/main/java/com/zaxxer/hikari/pool/ProxyConnection.java
Patch:
@@ -252,7 +252,7 @@ public final void close() throws SQLException
                delegate = ClosedConnection.CLOSED_CONNECTION;
                poolEntry.recycle(lastAccess);
             }
-            poolEntry = null; leakTask = null; openStatements = null; // HELP GC
+            poolEntry = null; leakTask = null; // HELP GC
          }
       }
    }

File: src/test/java/com/zaxxer/hikari/pool/TestConnectionCloseBlocking.java
Patch:
@@ -12,7 +12,6 @@
 import java.util.concurrent.TimeUnit;
 
 import org.junit.Assert;
-import org.junit.Test;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 

File: src/test/java/com/zaxxer/hikari/pool/TestConnections.java
Patch:
@@ -366,7 +366,7 @@ public void run()
 
          pool.logPoolState("before check ");
          Assert.assertNull((ref.get() != null ? ref.get().toString() : ""), ref.get());
-         Assert.assertSame("StubConnection count not as expected", 4, StubConnection.count.get());
+         Assert.assertSame("StubConnection count not as expected", 4+1, StubConnection.count.get()); // 1 connection is created in init 
       }
    }
 

File: src/test/java/com/zaxxer/hikari/pool/TestConnections.java
Patch:
@@ -114,7 +114,7 @@ public void testMaxLifetime() throws Exception
       HikariConfig config = new HikariConfig();
       config.setMinimumIdle(0);
       config.setMaximumPoolSize(1);
-      config.setConnectionTimeout(700);
+      config.setConnectionTimeout(2500);
       config.setConnectionTestQuery("VALUES 1");
       config.setInitializationFailFast(false);
       config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
@@ -166,7 +166,7 @@ public void testMaxLifetime2() throws Exception
       HikariConfig config = new HikariConfig();
       config.setMinimumIdle(0);
       config.setMaximumPoolSize(1);
-      config.setConnectionTimeout(700);
+      config.setConnectionTimeout(2500);
       config.setConnectionTestQuery("VALUES 1");
       config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 
@@ -347,6 +347,7 @@ public void run()
                      Connection connection = ds.getConnection();
                      pool.logPoolState("After  acquire ");
                      quietlySleep(500);
+                     pool.logPoolState("After sleeping ");
                      connection.close();
                   }
                   catch (Exception e) {

File: src/test/java/com/zaxxer/hikari/pool/TestConnections.java
Patch:
@@ -317,6 +317,7 @@ public void testMaximumPoolLimit() throws Exception
       config.setInitializationFailFast(true);
       config.setConnectionTestQuery("VALUES 1");
       config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
+      config.setPoolName("===TestMaximumPoolLimit===");
 
       StubConnection.count.set(0);
 

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -573,7 +573,7 @@ public Boolean call() throws Exception
 
             // failed to get connection from db, sleep and retry
             quietlySleep(sleepBackoff);
-            sleepBackoff = Math.min(connectionTimeout / 4, (long) (sleepBackoff * 1.3));
+            sleepBackoff = Math.min(connectionTimeout / 5, (long) (sleepBackoff * 1.3));
          }
          // Pool is suspended or shutdown or at max size
          return Boolean.FALSE;

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -438,7 +438,7 @@ private PoolEntry createPoolEntry()
          final long maxLifetime = config.getMaxLifetime();
          if (maxLifetime > 0) {
             // variance up to 2.5% of the maxlifetime
-            final long variance = maxLifetime > 10_000 ? ThreadLocalRandom.current().nextLong( Math.max(10_000, maxLifetime / 40) ) : 0;
+            final long variance = maxLifetime > 10_000 ? ThreadLocalRandom.current().nextLong( maxLifetime / 40 ) : 0;
             final long lifetime = maxLifetime - variance;
             poolEntry.setFutureEol(houseKeepingExecutorService.schedule(new Runnable() {
                @Override
@@ -573,7 +573,7 @@ public Boolean call() throws Exception
 
             // failed to get connection from db, sleep and retry
             quietlySleep(sleepBackoff);
-            sleepBackoff = Math.min(connectionTimeout / 2, (long) (sleepBackoff * 1.3));
+            sleepBackoff = Math.min(connectionTimeout / 4, (long) (sleepBackoff * 1.3));
          }
          // Pool is suspended or shutdown or at max size
          return Boolean.FALSE;

File: src/test/java/com/zaxxer/hikari/pool/TestValidation.java
Patch:
@@ -74,7 +74,7 @@ public void validateMissingUrl()
          Assert.fail();
       }
       catch (IllegalArgumentException ise) {
-         Assert.assertTrue(ise.getMessage().contains("dataSource or dataSourceClassName or jdbcUrl is required."));
+         Assert.assertTrue(ise.getMessage().contains("jdbcUrl is required with driverClassName"));
       }
    }
 

File: src/test/java/com/zaxxer/hikari/pool/ShutdownTest.java
Patch:
@@ -31,6 +31,7 @@
 import com.zaxxer.hikari.mocks.StubConnection;
 import com.zaxxer.hikari.util.ClockSource;
 import com.zaxxer.hikari.util.UtilityElf;
+import org.apache.logging.log4j.Level;
 
 /**
  * @author Brett Wooldridge
@@ -40,6 +41,7 @@ public class ShutdownTest
    @Before
    public void beforeTest()
    {
+      TestElf.setSlf4jLogLevel(ShutdownTest.class, Level.DEBUG);
       StubConnection.count.set(0);
    }
 

File: src/test/java/com/zaxxer/hikari/pool/TestConnectionTimeoutRetry.java
Patch:
@@ -269,13 +269,12 @@ public void testConnectionIdleFill() throws Exception
    @Before
    public void before()
    {
-      TestElf.setSlf4jTargetStream(HikariPool.class, System.err);
+      TestElf.setSlf4jLogLevel(HikariPool.class, Level.INFO);
    }
 
    @After
    public void after()
    {
       System.getProperties().remove("com.zaxxer.hikari.housekeeping.periodMs");
-      TestElf.setSlf4jLogLevel(HikariPool.class, Level.WARN);
    }
 }

File: src/main/java/com/zaxxer/hikari/util/Sequence.java
Patch:
@@ -50,7 +50,7 @@ public final class Factory
       public static Sequence create()
       {
          try {
-            if (Sequence.class.getClassLoader().loadClass("java.util.concurrent.atomic.LongAdder") != null) {
+            if (Sequence.class.getClassLoader().loadClass("java.util.concurrent.atomic.LongAdder") != null && !Boolean.getBoolean("com.zaxxer.hikari.useAtomicLongSequence")) {
                return new Java8Sequence();
             }
          }

File: src/main/java/com/zaxxer/hikari/pool/PoolEntry.java
Patch:
@@ -90,7 +90,7 @@ void setFutureEol(final ScheduledFuture<?> endOfLife)
 
    Connection createProxyConnection(final ProxyLeakTask leakTask, final long now)
    {
-      return ProxyFactory.getProxyConnection(this, connection, openStatements, leakTask, now);
+      return ProxyFactory.getProxyConnection(this, connection, openStatements, leakTask, now, hikariPool.isAutoCommit());
    }
 
    void resetConnectionState(final ProxyConnection proxyConnection, final int dirtyBits) throws SQLException

File: src/main/java/com/zaxxer/hikari/pool/ProxyConnection.java
Patch:
@@ -63,7 +63,7 @@ public abstract class ProxyConnection implements Connection
    private long lastAccess;
    private boolean isCommitStateDirty;
 
-   private boolean isAutoCommit;
+   protected boolean isAutoCommit;
    private int networkTimeout;
    private int transactionIsolation;
    private String dbcatalog;
@@ -83,12 +83,13 @@ public abstract class ProxyConnection implements Connection
       SQL_ERRORS.add("JZ0C1"); // Sybase disconnect error
    }
 
-   protected ProxyConnection(final PoolEntry poolEntry, final Connection connection, final FastList<Statement> openStatements, final ProxyLeakTask leakTask, final long now) {
+   protected ProxyConnection(final PoolEntry poolEntry, final Connection connection, final FastList<Statement> openStatements, final ProxyLeakTask leakTask, final long now, final boolean isAutoCommit) {
       this.poolEntry = poolEntry;
       this.delegate = connection;
       this.openStatements = openStatements;
       this.leakTask = leakTask;
       this.lastAccess = now;
+      this.isAutoCommit = isAutoCommit;
    }
 
    /** {@inheritDoc} */

File: src/main/java/com/zaxxer/hikari/pool/ProxyFactory.java
Patch:
@@ -47,7 +47,7 @@ private ProxyFactory()
     * @param now current timestamp in milliseconds
     * @return a proxy that wraps the specified {@link Connection}
     */
-   static ProxyConnection getProxyConnection(final PoolEntry poolEntry, final Connection connection, final FastList<Statement> openStatements, final ProxyLeakTask leakTask, final long now)
+   static ProxyConnection getProxyConnection(final PoolEntry poolEntry, final Connection connection, final FastList<Statement> openStatements, final ProxyLeakTask leakTask, final long now, final boolean isAutoCommit)
    {
       // Body is replaced (injected) by JavassistProxyFactory
       throw new IllegalStateException("You need to run the CLI build and you need target/classes in your classpath to run.");

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -763,6 +763,9 @@ else if (driverClassName != null && dataSourceClassName != null) {
          LOGGER.error("cannot use driverClassName and dataSourceClassName together");
          throw new IllegalArgumentException("cannot use driverClassName and dataSourceClassName together");
       }
+      else if (jdbcUrl != null && dataSourceClassName != null) {
+         LOGGER.warn("using dataSourceClassName and ignoring jdbcUrl");
+      }
       else if (jdbcUrl != null) {
          // OK
       }

File: src/main/java/com/zaxxer/hikari/util/JavassistProxyFactory.java
Patch:
@@ -42,6 +42,7 @@
 import javassist.LoaderClassPath;
 import javassist.Modifier;
 import javassist.NotFoundException;
+import javassist.bytecode.ClassFile;
 
 /**
  * This class generates the proxy objects for {@link Connection}, {@link Statement},
@@ -190,6 +191,7 @@ private static <T> void generateProxyClass(Class<T> primaryInterface, String sup
          }
       }
 
+      targetCt.getClassFile().setMajorVersion(ClassFile.JAVA_7);
       targetCt.writeFile("target/classes");
    }
 

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -167,7 +167,7 @@ public final Connection getConnection(final long hardTimeout) throws SQLExceptio
             final long now = clockSource.currentTime();
             if (poolEntry.evict || (clockSource.elapsedMillis(poolEntry.lastAccessed, now) > ALIVE_BYPASS_WINDOW_MS && !isConnectionAlive(poolEntry.connection))) {
                closeConnection(poolEntry, "(connection evicted or dead)"); // Throw away the dead connection and try again
-               timeout = hardTimeout - clockSource.elapsedMillis(startTime, now);
+               timeout = hardTimeout - clockSource.elapsedMillis(startTime);
             }
             else {
                metricsTracker.recordBorrowStats(poolEntry, startTime);
@@ -626,7 +626,7 @@ public void run()
                }
             }
          }
-         
+
          logPoolState("After cleanup\t");
 
          fillPool(); // Try to maintain minimum connections

File: src/main/java/com/zaxxer/hikari/util/PropertyElf.java
Patch:
@@ -127,7 +127,7 @@ private static void setProperty(Object target, String propName, Object propValue
 
       List<Method> methods = Arrays.asList(target.getClass().getMethods());
       for (Method method : methods) {
-         if (method.getName().equals(methodName) && method.getParameterCount() == 1) {
+         if (method.getName().equals(methodName) && method.getParameterTypes().length == 1) {
             writeMethod = method;
             break;
          }
@@ -136,7 +136,7 @@ private static void setProperty(Object target, String propName, Object propValue
       if (writeMethod == null) {
          methodName = "set" + propName.toUpperCase();
          for (Method method : methods) {
-            if (method.getName().equals(methodName) && method.getParameterCount() == 1) {
+            if (method.getName().equals(methodName) && method.getParameterTypes().length == 1) {
                writeMethod = method;
                break;
             }

File: src/main/java/com/zaxxer/hikari/util/PropertyElf.java
Patch:
@@ -75,7 +75,7 @@ public static Set<String> getPropertyNames(Class<?> targetClass)
       HashSet<String> set = new HashSet<>();
       for (Method method : targetClass.getMethods()) {
          String name = method.getName();
-         if (name.matches("(get|is)[A-Z].+") && method.getParameterCount() == 0) {
+         if (name.matches("(get|is)[A-Z].+") && method.getParameterTypes().length == 0) {
             name = name.replaceFirst("(get|is)", "");
             try {
                if (targetClass.getMethod("set" + name, method.getReturnType()) != null) {

File: src/test/java/com/zaxxer/hikari/mocks/StubConnection.java
Patch:
@@ -50,7 +50,7 @@ public class StubConnection extends StubBaseConnection implements Connection
 
    private static long foo;
    private boolean autoCommit;
-   private int isolation;
+   private int isolation = Connection.TRANSACTION_READ_COMMITTED;
    private String catalog;
 
    static {

File: src/test/java/com/zaxxer/hikari/mocks/StubConnection.java
Patch:
@@ -50,7 +50,7 @@ public class StubConnection extends StubBaseConnection implements Connection
 
    private static long foo;
    private boolean autoCommit;
-   private int isolation;
+   private int isolation = Connection.TRANSACTION_READ_COMMITTED;
    private String catalog;
 
    static {

File: src/main/java/com/zaxxer/hikari/HikariConfigMXBean.java
Patch:
@@ -157,7 +157,7 @@ public interface HikariConfigMXBean
     * Altering this at runtime only works for DataSource-based connections, not Driver-class or JDBC URL-based
     * connections.
     *
-    * @param username the database password
+    * @param password the database password
     */
    void setPassword(String password);
 

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -129,8 +129,8 @@ public HikariConfig(Properties properties)
 
    /**
     * Construct a HikariConfig from the specified property file name.  <code>propertyFileName</code>
-    * will first be treated as a path in the file-system, and if that fails the 
-    * ClassLoader.getResourceAsStream(propertyFileName) will be tried.
+    * will first be treated as a path in the file-system, and if that fails the
+    * Class.getResourceAsStream(propertyFileName) will be tried.
     *
     * @param propertyFileName the name of the property file
     */

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -129,8 +129,8 @@ public HikariConfig(Properties properties)
 
    /**
     * Construct a HikariConfig from the specified property file name.  <code>propertyFileName</code>
-    * will first be treated as a path in the file-system, and if that fails the 
-    * ClassLoader.getResourceAsStream(propertyFileName) will be tried.
+    * will first be treated as a path in the file-system, and if that fails the
+    * Class.getResourceAsStream(propertyFileName) will be tried.
     *
     * @param propertyFileName the name of the property file
     */

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -79,7 +79,7 @@ public class HikariConfig implements HikariConfigMXBean
    private String transactionIsolationName;
    private String username;
    private boolean isAutoCommit;
-   private Boolean isReadOnly;
+   private boolean isReadOnly;
    private boolean isInitializationFailFast;
    private boolean isIsolateInternalQueries;
    private boolean isRegisterMbeans;
@@ -548,12 +548,12 @@ public void addHealthCheckProperty(String key, String value)
       healthCheckProperties.setProperty(key, value);
    }
 
-   public Boolean isReadOnly()
+   public boolean isReadOnly()
    {
       return isReadOnly;
    }
 
-   public void setReadOnly(Boolean readOnly)
+   public void setReadOnly(boolean readOnly)
    {
       this.isReadOnly = readOnly;
    }

File: src/test/java/com/zaxxer/hikari/mocks/StubPreparedStatement.java
Patch:
@@ -439,6 +439,7 @@ public void setAsciiStream(int parameterIndex, InputStream x, int length) throws
 
     /** {@inheritDoc} */
     @Override
+    @SuppressWarnings("deprecation")
     public void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException
     {
     }

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -125,14 +125,15 @@ public HikariPool(final HikariConfig config)
       if (config.getScheduledExecutorService() == null) {
          ThreadFactory threadFactory = config.getThreadFactory() != null ? config.getThreadFactory() : new DefaultThreadFactory("Hikari housekeeper (pool " + poolName + ")", true);
          this.houseKeepingExecutorService = new ScheduledThreadPoolExecutor(1, threadFactory, new ThreadPoolExecutor.DiscardPolicy());
-         this.houseKeepingExecutorService.scheduleAtFixedRate(new HouseKeeper(), HOUSEKEEPING_PERIOD_MS, HOUSEKEEPING_PERIOD_MS, TimeUnit.MILLISECONDS);
          this.houseKeepingExecutorService.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
          this.houseKeepingExecutorService.setRemoveOnCancelPolicy(true);
       }
       else {
          this.houseKeepingExecutorService = config.getScheduledExecutorService();
       }
 
+      this.houseKeepingExecutorService.scheduleAtFixedRate(new HouseKeeper(), HOUSEKEEPING_PERIOD_MS, HOUSEKEEPING_PERIOD_MS, TimeUnit.MILLISECONDS);
+
       this.leakTask = new LeakTask(config.getLeakDetectionThreshold(), houseKeepingExecutorService);
       
       if (config.getMetricsTrackerFactory() != null) {

File: src/main/java/com/zaxxer/hikari/pool/PoolBagEntry.java
Patch:
@@ -94,7 +94,7 @@ public void run()
                   pool.closeConnection(PoolBagEntry.this, "(connection reached maxLifetime)");
                }
                else {
-                  // else the connection is "in-use" and we mark it for eviction by pool.releaseConnection() or the housekeeper
+                  // else the connection is "in-use" and we mark it for eviction by pool.releaseConnection()
                   PoolBagEntry.this.evicted = true;
                }
             }

File: src/main/java/com/zaxxer/hikari/pool/PoolElf.java
Patch:
@@ -207,7 +207,7 @@ void setupConnection(final Connection connection, final long connectionTimeout)
     * @param lastConnectionFailure last connection failure
     * @return true if the connection is alive, false if it is not alive or we timed out
     */
-   boolean isConnectionAlive(final Connection connection, AtomicReference<Throwable> lastConnectionFailure)
+   boolean isConnectionAlive(final Connection connection, final AtomicReference<Throwable> lastConnectionFailure)
    {
       try {
          int timeoutSec = (int) TimeUnit.MILLISECONDS.toSeconds(validationTimeout);

File: src/main/java/com/zaxxer/hikari/pool/PoolInitializationException.java
Patch:
@@ -31,6 +31,6 @@ public class PoolInitializationException extends RuntimeException
     */
    public PoolInitializationException(Throwable t)
    {
-      super("Exception during pool initialization", t);
+      super("Exception during pool initialization: " + t.getMessage(), t);
    }
 }

File: src/main/java/com/zaxxer/hikari/pool/PoolInitializationException.java
Patch:
@@ -31,6 +31,6 @@ public class PoolInitializationException extends RuntimeException
     */
    public PoolInitializationException(Throwable t)
    {
-      super("Exception during pool initialization", t);
+      super(t);
    }
 }

File: src/main/java/com/zaxxer/hikari/pool/PoolElf.java
Patch:
@@ -175,7 +175,7 @@ else if (jdbcUrl != null && dataSource == null) {
    void setupConnection(final Connection connection, final long connectionTimeout) throws SQLException
    {
       if (isUseJdbc4Validation && !isJdbc4ValidationSupported(connection)) {
-         throw new SQLException("Connection.isValid() method is not supported, connection test query must be configured");
+         throw new SQLException("Connection.isValid() is not supported, configure connection test query.");
       }
 
       networkTimeout = getAndSetNetworkTimeout(connection, connectionTimeout);
@@ -269,7 +269,7 @@ void resetConnectionState(final PoolBagEntry poolEntry) throws SQLException
       }
       
       if (LOGGER.isDebugEnabled()) {
-         LOGGER.debug("{} - Reset ({}) on connection {}", resetBits != 0 ? stringFromResetBits(resetBits) : "nothing", poolEntry.connection);
+         LOGGER.debug("{} - Reset ({}) on connection {}", poolName, resetBits != 0 ? stringFromResetBits(resetBits) : "nothing", poolEntry.connection);
       }
    }
 

File: src/main/java/com/zaxxer/hikari/pool/PoolElf.java
Patch:
@@ -175,7 +175,7 @@ else if (jdbcUrl != null && dataSource == null) {
    void setupConnection(final Connection connection, final long connectionTimeout) throws SQLException
    {
       if (isUseJdbc4Validation && !isJdbc4ValidationSupported(connection)) {
-         throw new SQLException("Connection.isValid() method is not supported, connection test query must be configured");
+         throw new SQLException("Connection.isValid() is not supported, configure connection test query.");
       }
 
       networkTimeout = getAndSetNetworkTimeout(connection, connectionTimeout);
@@ -269,7 +269,7 @@ void resetConnectionState(final PoolBagEntry poolEntry) throws SQLException
       }
       
       if (LOGGER.isDebugEnabled()) {
-         LOGGER.debug("{} - Reset ({}) on connection {}", resetBits != 0 ? stringFromResetBits(resetBits) : "nothing", poolEntry.connection);
+         LOGGER.debug("{} - Reset ({}) on connection {}", poolName, resetBits != 0 ? stringFromResetBits(resetBits) : "nothing", poolEntry.connection);
       }
    }
 

File: src/main/java/com/zaxxer/hikari/metrics/CodahaleHealthChecker.java
Patch:
@@ -52,6 +52,7 @@ public final class CodahaleHealthChecker
     * Register Dropwizard health checks.
     *
     * @param pool the pool to register health checks for
+    * @param hikariConfig the pool configuration
     * @param registry the HealthCheckRegistry into which checks will be registered
     */
    public static void registerHealthChecks(final HikariPool pool, final HikariConfig hikariConfig, final HealthCheckRegistry registry)

File: src/main/java/com/zaxxer/hikari/pool/PoolInitializationException.java
Patch:
@@ -27,6 +27,7 @@ public class PoolInitializationException extends RuntimeException
 
    /**
     * Construct an exception, possibly wrapping the provided Throwable as the cause.
+    * @param t the Throwable to wrap
     */
    public PoolInitializationException(Throwable t)
    {

File: src/test/java/com/zaxxer/hikari/TestValidation.java
Patch:
@@ -59,7 +59,7 @@ public void validateMissingUrl()
          config.validate();
          Assert.fail();
       }
-      catch (IllegalStateException ise) {
+      catch (IllegalArgumentException ise) {
          // pass
       }
    }
@@ -183,7 +183,7 @@ public void validateBothDriverAndDS()
          config.validate();
          Assert.fail();
       }
-      catch (IllegalStateException ise) {
+      catch (IllegalArgumentException ise) {
          Assert.assertTrue(ise.getMessage().contains("together"));
       }
    }

File: src/test/java/com/zaxxer/hikari/ShutdownTest.java
Patch:
@@ -225,7 +225,7 @@ public void testAfterShutdown() throws Exception
            ds.getConnection();
        }
        catch (SQLException e) {
-          Assert.assertTrue(e.getMessage().contains("has been shutdown"));
+          Assert.assertTrue(e.getMessage().contains("has been closed."));
        }
    }
 

File: src/test/java/com/zaxxer/hikari/TestValidation.java
Patch:
@@ -184,7 +184,7 @@ public void validateBothDriverAndDS()
          Assert.fail();
       }
       catch (IllegalStateException ise) {
-         Assert.assertTrue(ise.getMessage().contains("cannot use"));
+         Assert.assertTrue(ise.getMessage().contains("together"));
       }
    }
 

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -474,6 +474,7 @@ public Object getMetricRegistry()
     * @param metricRegistry the Codahale MetricRegistry to set
     */
    public void setMetricRegistry(Object metricRegistry)
+   {
       if (metricsTrackerFactory != null) {
          throw new IllegalStateException("cannot use setMetricRegistry() and setMetricsTrackerFactory() together");
       }

File: src/main/java/com/zaxxer/hikari/pool/PoolElf.java
Patch:
@@ -205,8 +205,8 @@ boolean isConnectionAlive(final Connection connection, AtomicReference<Throwable
    
          try (Statement statement = connection.createStatement()) {
             setQueryTimeout(statement, timeoutSec);
-            try (ResultSet rs = statement.executeQuery(config.getConnectionTestQuery())) { 
-               /* auto close */
+            if (statement.execute(config.getConnectionTestQuery())) {
+               statement.getResultSet().close();
             }
          }
    

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -79,7 +79,7 @@ public class HikariConfig implements HikariConfigMXBean
    private String transactionIsolationName;
    private String username;
    private boolean isAutoCommit;
-   private boolean isReadOnly;
+   private Boolean isReadOnly;
    private boolean isInitializationFailFast;
    private boolean isIsolateInternalQueries;
    private boolean isRegisterMbeans;
@@ -529,12 +529,12 @@ public void addHealthCheckProperty(String key, String value)
       healthCheckProperties.setProperty(key, value);
    }
 
-   public boolean isReadOnly()
+   public Boolean isReadOnly()
    {
       return isReadOnly;
    }
 
-   public void setReadOnly(boolean readOnly)
+   public void setReadOnly(Boolean readOnly)
    {
       this.isReadOnly = readOnly;
    }

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -176,7 +176,7 @@ public final Connection getConnection(final long hardTimeout) throws SQLExceptio
             }
 
             final long now = clockSource.currentTime();
-            if (bagEntry.evicted || (clockSource.elapsedMillis(bagEntry.lastAccess, now) > ALIVE_BYPASS_WINDOW_MS && !poolElf.isConnectionAlive(bagEntry.connection))) {
+            if (bagEntry.evicted || (clockSource.elapsedMillis(bagEntry.lastAccess, now) > ALIVE_BYPASS_WINDOW_MS && !poolElf.isConnectionAlive(bagEntry.connection, lastConnectionFailure))) {
                closeConnection(bagEntry, "(connection evicted or dead)"); // Throw away the dead connection and try again
                timeout = hardTimeout - clockSource.elapsedMillis(startTime, now);
             }

File: src/main/java/com/zaxxer/hikari/util/PropertyElf.java
Patch:
@@ -151,7 +151,7 @@ private static void setProperty(Object target, String propName, Object propValue
          else if (paramClass == long.class) {
             writeMethod.invoke(target, Long.parseLong(propValue.toString()));
          }
-         else if (paramClass == boolean.class) {
+         else if (paramClass == boolean.class || paramClass == Boolean.class) {
             writeMethod.invoke(target, Boolean.parseBoolean(propValue.toString()));
          }
          else if (paramClass == String.class) {

File: src/main/java/com/zaxxer/hikari/HikariJNDIFactory.java
Patch:
@@ -87,6 +87,7 @@ private DataSource lookupJndiDataSource(Properties properties, Context context)
       if (jndiDS == null) {
          context = new InitialContext();
          jndiDS = (DataSource) context.lookup(jndiName);
+         context.close();
       }
 
       if (jndiDS != null) {

File: hikaricp-common/src/main/java/com/zaxxer/hikari/AbstractHikariConfig.java
Patch:
@@ -38,7 +38,7 @@
 import com.zaxxer.hikari.util.PropertyBeanSetter;
 import com.zaxxer.hikari.util.UtilityElf;
 
-public abstract class AbstractHikariConfig implements HikariConfigMBean
+public abstract class AbstractHikariConfig implements HikariConfigMXBean
 {
    private static final Logger LOGGER = LoggerFactory.getLogger(HikariConfig.class);
 

File: hikaricp-common/src/main/java/com/zaxxer/hikari/HikariConfigMXBean.java
Patch:
@@ -21,7 +21,7 @@
  *
  * @author Brett Wooldridge
  */
-public interface HikariConfigMBean
+public interface HikariConfigMXBean
 {
    /**
     * Get the maximum number of milliseconds that a client will wait for a connection from the pool. If this 

File: hikaricp-common/src/main/java/com/zaxxer/hikari/pool/BaseHikariPool.java
Patch:
@@ -67,7 +67,7 @@
  *
  * @author Brett Wooldridge
  */
-public abstract class BaseHikariPool implements HikariPoolMBean, IBagStateListener
+public abstract class BaseHikariPool implements HikariPoolMXBean, IBagStateListener
 {
    protected final Logger LOGGER = LoggerFactory.getLogger(getClass());
    private static final long ALIVE_BYPASS_WINDOW = Long.getLong("com.zaxxer.hikari.aliveBypassWindow", 1000L);

File: hikaricp-common/src/main/java/com/zaxxer/hikari/pool/HikariPoolMXBean.java
Patch:
@@ -21,7 +21,7 @@
  *
  * @author Brett Wooldridge
  */
-public interface HikariPoolMBean
+public interface HikariPoolMXBean
 {
    int getIdleConnections();
 

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -129,7 +129,7 @@ public HikariPool(final HikariConfig config)
          this.houseKeepingExecutorService = config.getScheduledExecutorService();
       }
 
-      this.leakTask = (config.getLeakDetectionThreshold() == 0) ? LeakTask.NO_LEAK : new LeakTask(config.getLeakDetectionThreshold(), houseKeepingExecutorService);
+      this.leakTask = new LeakTask(config.getLeakDetectionThreshold(), houseKeepingExecutorService);
       
       setMetricRegistry(config.getMetricRegistry());
       setHealthCheckRegistry(config.getHealthCheckRegistry());

File: src/main/java/com/zaxxer/hikari/HikariPoolMXBean.java
Patch:
@@ -21,7 +21,7 @@
  *
  * @author Brett Wooldridge
  */
-public interface HikariPoolMBean
+public interface HikariPoolMXBean 
 {
    int getIdleConnections();
 

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -43,7 +43,7 @@
 import com.codahale.metrics.MetricRegistry;
 import com.codahale.metrics.health.HealthCheckRegistry;
 import com.zaxxer.hikari.HikariConfig;
-import com.zaxxer.hikari.HikariPoolMBean;
+import com.zaxxer.hikari.HikariPoolMXBean;
 import com.zaxxer.hikari.metrics.CodaHaleMetricsTracker;
 import com.zaxxer.hikari.metrics.CodahaleHealthChecker;
 import com.zaxxer.hikari.metrics.MetricsTracker;
@@ -64,7 +64,7 @@
  *
  * @author Brett Wooldridge
  */
-public class HikariPool implements HikariPoolMBean, IBagStateListener
+public class HikariPool implements HikariPoolMXBean, IBagStateListener
 {
    final Logger LOGGER = LoggerFactory.getLogger(getClass());
 

File: src/main/java/com/zaxxer/hikari/pool/PoolElf.java
Patch:
@@ -202,7 +202,7 @@ boolean isConnectionAlive(final Connection connection)
             return connection.isValid(timeoutSec);
          }
    
-         networkTimeout = getAndSetNetworkTimeout(connection, validationTimeout);
+         final int originalTimeout = getAndSetNetworkTimeout(connection, validationTimeout);
    
          try (Statement statement = connection.createStatement()) {
             setQueryTimeout(statement, timeoutSec);
@@ -215,7 +215,7 @@ boolean isConnectionAlive(final Connection connection)
             connection.rollback();
          }
    
-         setNetworkTimeout(connection, networkTimeout);
+         setNetworkTimeout(connection, originalTimeout);
    
          return true;
       }

File: src/test/java/com/zaxxer/hikari/JdbcDriverTest.java
Patch:
@@ -74,7 +74,7 @@ public void driverTest2() throws SQLException
          ds = new HikariDataSource(config);
       }
       catch (RuntimeException e) {
-         Assert.assertTrue(e.getMessage().contains("Unable to get driver"));
+         Assert.assertTrue(e.getMessage().contains("claims to not accept"));
       }
    }
 }

File: hikaricp-common/src/main/java/com/zaxxer/hikari/pool/PoolBagEntry.java
Patch:
@@ -51,7 +51,7 @@ public void run()
             {
                // If we can reserve it, close it
                if (pool.connectionBag.reserve(PoolBagEntry.this)) {
-                  pool.closeConnection(PoolBagEntry.this);
+                  pool.closeConnection(PoolBagEntry.this, "(connection reached maxLifetime)");
                }
                else {
                   // else the connection is "in-use" and we mark it for eviction by pool.releaseConnection() or the housekeeper

File: hikaricp-common/src/test/java/com/zaxxer/hikari/ShutdownTest.java
Patch:
@@ -305,7 +305,7 @@ public void run() {
                   Assert.fail(e.getMessage());
                }
                finally {
-                  new PoolUtilities(config).quietlyCloseConnection(connection);
+                  new PoolUtilities(config).quietlyCloseConnection(connection, "(because this is a test)");
                   ds.shutdown();
                }
             };

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -658,18 +658,18 @@ protected void update() {
     */
    private class HouseKeeper implements Runnable
    {
-      private volatile long previous = System.currentTimeMillis();
+      private volatile long previous = clockSource.currentTime();
 
       @Override
       public void run()
       {
          connectionTimeout = configuration.getConnectionTimeout(); // refresh member in case it changed
 
-         final long now = System.currentTimeMillis();
+         final long now = clockSource.currentTime();
          final long idleTimeout = configuration.getIdleTimeout();
 
          // Detect retrograde time as well as forward leaps of unacceptable duration
-         if (now < previous || now > previous + (2 * HOUSEKEEPING_PERIOD_MS)) {
+         if (now < previous || now > clockSource.plusMillis(previous, (2 * HOUSEKEEPING_PERIOD_MS))) {
             LOGGER.warn("Unusual system clock change detected, soft-evicting connections from pool.");
             softEvictConnections();
             fillPool();

File: src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java
Patch:
@@ -115,7 +115,7 @@ public T borrow(long timeout, final TimeUnit timeUnit) throws InterruptedExcepti
 
          for (int i = list.size() - 1; i >= 0; i--) {
             final T bagEntry = (T) (weakThreadLocals ? ((WeakReference) list.remove(i)).get() : list.remove(i));
-            if (bagEntry != null & bagEntry.state().compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {
+            if (bagEntry != null && bagEntry.state().compareAndSet(STATE_NOT_IN_USE, STATE_IN_USE)) {
                return bagEntry;
             }
          }

File: src/main/java/com/zaxxer/hikari/metrics/MetricsTracker.java
Patch:
@@ -35,7 +35,7 @@ public MetricsTracker(final HikariPool pool)
       this.pool = pool;
    }
 
-   public MetricsContext recordConnectionRequest(long requestTimeMillis)
+   public MetricsContext recordConnectionRequest()
    {
       return NO_CONTEXT;
    }
@@ -67,9 +67,9 @@ public void stop()
        * Set the lastOpenTime on the provided bag entry.
        *
        * @param bagEntry the bag entry
-       * @param nowMillis the last open timestamp from {@link System#currentTimeMillis()}
+       * @param now the last open timestamp from {@link ClockSource#currentTime()}
        */
-      public void setConnectionLastOpen(final PoolBagEntry bagEntry, final long nowMillis)
+      public void setConnectionLastOpen(final PoolBagEntry bagEntry, final long now)
       {
          // do nothing
       }

File: src/main/java/com/zaxxer/hikari/pool/PoolBagEntry.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import com.zaxxer.hikari.util.ClockSource;
 import com.zaxxer.hikari.util.FastList;
 import com.zaxxer.hikari.util.IConcurrentBagEntry;
 
@@ -48,7 +49,7 @@ public final class PoolBagEntry implements IConcurrentBagEntry
    public PoolBagEntry(final Connection connection, final HikariPool pool) {
       this.connection = connection;
       this.parentPool = pool;
-      this.lastAccess = System.currentTimeMillis();
+      this.lastAccess = ClockSource.INSTANCE.currentTime();
       this.openStatements = new FastList<Statement>(Statement.class, 16);
 
       final long variance = pool.configuration.getMaxLifetime() > 60_000 ? ThreadLocalRandom.current().nextLong(10_000) : 0;

File: src/test/java/com/zaxxer/hikari/ShutdownTest.java
Patch:
@@ -29,6 +29,7 @@
 import com.zaxxer.hikari.mocks.StubConnection;
 import com.zaxxer.hikari.pool.HikariPool;
 import com.zaxxer.hikari.pool.PoolUtilities;
+import com.zaxxer.hikari.util.ClockSource;
 import com.zaxxer.hikari.util.UtilityElf;
 
 /**
@@ -170,8 +171,8 @@ public void testShutdown4() throws SQLException
 
       ds.close();
 
-      long startNanos = System.nanoTime();
-      while (UtilityElf.elapsedNanos(startNanos) < TimeUnit.SECONDS.toMillis(5) && threadCount() > 0) {
+      long startTime = ClockSource.INSTANCE.currentTime();
+      while (ClockSource.INSTANCE.elapsedTimeMs(startTime) < TimeUnit.SECONDS.toMillis(5) && threadCount() > 0) {
          UtilityElf.quietlySleep(250);
       }
 

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -513,7 +513,9 @@ private boolean addConnection()
       catch (Exception e) {
          totalConnections.decrementAndGet(); // We failed, so undo speculative increment of totalConnections
          lastConnectionFailure.set(e);
-         LOGGER.debug("Connection attempt to database in pool {} failed: {}", configuration.getPoolName(), e.getMessage(), e);
+         if (poolState == POOL_NORMAL) {
+            LOGGER.debug("Connection attempt to database in pool {} failed: {}", configuration.getPoolName(), e.getMessage(), e);
+         }
          poolUtils.quietlyCloseConnection(connection, "exception during connection creation");
          return false;
       }

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -120,7 +120,7 @@ public HikariPool(HikariConfig config)
       this.poolUtils = new PoolUtilities(config);
       this.dataSource = poolUtils.initializeDataSource(config.getDataSourceClassName(), config.getDataSource(), config.getDataSourceProperties(), config.getDriverClassName(), config.getJdbcUrl(), username, password);
 
-      this.connectionBag = new ConcurrentBag<>(this);
+      this.connectionBag = new ConcurrentBag<>(this, config.isWeakThreadLocals());
       this.totalConnections = new AtomicInteger();
       this.connectionTimeout = config.getConnectionTimeout();
       this.validationTimeout = config.getValidationTimeout();

File: src/test/java/com/zaxxer/hikari/RampUpDown.java
Patch:
@@ -14,6 +14,7 @@ public void rampUpDownTest() throws SQLException, InterruptedException
         HikariConfig config = new HikariConfig();
         config.setMinimumIdle(5);
         config.setMaximumPoolSize(60);
+        config.setWeakThreadLocals(true);
         config.setInitializationFailFast(true);
         config.setConnectionTestQuery("VALUES 1");
         config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

File: src/main/java/com/zaxxer/hikari/metrics/CodaHaleMetricsTracker.java
Patch:
@@ -102,7 +102,7 @@ public Context recordConnectionRequest(final long requestTime)
    @Override
    public void recordConnectionUsage(final PoolBagEntry bagEntry)
    {
-      connectionUsage.update(elapsedTimeMs(bagEntry.lastOpenNano));
+      connectionUsage.update(elapsedTimeMs(bagEntry.lastOpenTime));
    }
 
    public Timer getConnectionAcquisitionTimer()
@@ -132,9 +132,9 @@ public void stop()
 
       /** {@inheritDoc} */
       @Override
-      public void setConnectionLastOpen(final PoolBagEntry bagEntry, final long nowNanos)
+      public void setConnectionLastOpen(final PoolBagEntry bagEntry, final long nowMillis)
       {
-         bagEntry.lastOpenNano = nowNanos;
+         bagEntry.lastOpenTime = nowMillis;
       }
    }
 }

File: src/main/java/com/zaxxer/hikari/proxy/ProxyFactory.java
Patch:
@@ -22,7 +22,6 @@
 import java.sql.ResultSet;
 import java.sql.Statement;
 
-import com.zaxxer.hikari.pool.HikariPool;
 import com.zaxxer.hikari.pool.LeakTask;
 import com.zaxxer.hikari.pool.PoolBagEntry;
 
@@ -42,12 +41,12 @@ private ProxyFactory()
    /**
     * Create a proxy for the specified {@link Connection} instance.
     *
-    * @param pool the {@link HikariPool} that will own this proxy
     * @param bagEntry the PoolBagEntry entry for this proxy
     * @param leakTask a leak detetection task
+    * @param now current timestamp in milliseconds
     * @return a proxy that wraps the specified {@link Connection}
     */
-   public static IHikariConnectionProxy getProxyConnection(final HikariPool pool, final PoolBagEntry bagEntry, final LeakTask leakTask)
+   public static IHikariConnectionProxy getProxyConnection(final PoolBagEntry bagEntry, final LeakTask leakTask, final long now)
    {
       // Body is injected by JavassistProxyFactory
       return null;

File: src/test/java/com/zaxxer/hikari/MiscTest.java
Patch:
@@ -108,9 +108,9 @@ public void testLeakDetection() throws SQLException
          TestElf.getPool(ds).logPoolState();
 
          Connection connection = ds.getConnection();
-         UtilityElf.quietlySleepMs(TimeUnit.SECONDS.toMillis(4));
+         UtilityElf.quietlySleep(TimeUnit.SECONDS.toMillis(4));
          connection.close();
-         UtilityElf.quietlySleepMs(TimeUnit.SECONDS.toMillis(1));
+         UtilityElf.quietlySleep(TimeUnit.SECONDS.toMillis(1));
          ps.close();
          String s = new String(baos.toByteArray());
          Assert.assertNotNull("Exception string was null", s);

File: src/test/java/com/zaxxer/hikari/TestConcurrentBag.java
Patch:
@@ -78,7 +78,7 @@ public Future<Boolean> addBagItem()
 
       PoolBagEntry inuse = new PoolBagEntry(null, pool);
       bag.add(inuse);
-      bag.borrow(TimeUnit.SECONDS.toNanos(2)); // in use
+      bag.borrow(2, TimeUnit.MILLISECONDS); // in use
       
       PoolBagEntry notinuse = new PoolBagEntry(null, pool);
       bag.add(notinuse); // not in use
@@ -106,7 +106,7 @@ public Future<Boolean> addBagItem()
       try {
          PoolBagEntry bagEntry = new PoolBagEntry(null, pool);
          bag.add(bagEntry);
-         Assert.assertNotEquals(bagEntry, bag.borrow(TimeUnit.MILLISECONDS.toNanos(100)));
+         Assert.assertNotEquals(bagEntry, bag.borrow(100, TimeUnit.MILLISECONDS));
       }
       catch (IllegalStateException e) {
          Assert.assertTrue(new String(baos.toByteArray()).contains("ignoring add()"));

File: src/test/java/com/zaxxer/hikari/TestConnectionCloseBlocking.java
Patch:
@@ -44,7 +44,7 @@ public void testConnectionCloseBlocking() throws SQLException {
          connection.close();
          // Hikari only checks for validity for connections with lastAccess > 1000 ms so we sleep for 1001 ms to force
          // Hikari to do a connection validation which will fail and will trigger the connection to be closed
-         UtilityElf.quietlySleepMs(1001);
+         UtilityElf.quietlySleep(1001);
          startNanos = System.nanoTime();
          connection = ds.getConnection(); // on physical connection close we sleep 2 seconds
          Assert.assertTrue("Waited longer than timeout",

File: src/test/java/com/zaxxer/hikari/TestJNDI.java
Patch:
@@ -86,7 +86,6 @@ public void testJndiLookup3() throws Exception
       }
    }
 
-   @SuppressWarnings("unchecked")
    private class BogusContext extends AbstractContext
    {
       @Override

File: src/test/java/com/zaxxer/hikari/TestMetrics.java
Patch:
@@ -90,7 +90,7 @@ public void testMetricUsage() throws SQLException
       HikariDataSource ds = new HikariDataSource(config);
       try {
          Connection connection = ds.getConnection();
-         UtilityElf.quietlySleepMs(250L);
+         UtilityElf.quietlySleep(250L);
          connection.close();
 
          Histogram histo = metricRegistry.getHistograms(new MetricFilter() {
@@ -128,7 +128,7 @@ public void testHealthChecks() throws Exception
 
       HikariDataSource ds = new HikariDataSource(config);
       try {
-         UtilityElf.quietlySleepMs(TimeUnit.SECONDS.toMillis(2));
+         UtilityElf.quietlySleep(TimeUnit.SECONDS.toMillis(2));
 
          Connection connection = ds.getConnection();
          connection.close();

File: src/test/java/com/zaxxer/hikari/mocks/StubConnection.java
Patch:
@@ -34,7 +34,6 @@
 import java.util.Map;
 import java.util.Properties;
 import java.util.concurrent.Executor;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import com.zaxxer.hikari.util.UtilityElf;
@@ -61,7 +60,7 @@ public class StubConnection extends StubBaseConnection implements Connection
    public StubConnection() {
       count.incrementAndGet();
       if (slowCreate) {
-         UtilityElf.quietlySleep(1, TimeUnit.SECONDS);
+         UtilityElf.quietlySleep(1000);
       }
    }
 

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -258,7 +258,7 @@ public final synchronized void shutdown() throws InterruptedException
                softEvictConnections();
                abortActiveConnections(assassinExecutor);
             }
-            while (getTotalConnections() > 0 && elapsedTimeMs(start) < TimeUnit.SECONDS.toNanos(5));
+            while (getTotalConnections() > 0 && elapsedTimeMs(start) < TimeUnit.SECONDS.toMillis(5));
          } finally {
             assassinExecutor.shutdown();
             assassinExecutor.awaitTermination(5L, TimeUnit.SECONDS);

File: src/main/java/com/zaxxer/hikari/HikariJNDIFactory.java
Patch:
@@ -85,7 +85,7 @@ private DataSource lookupJndiDataSource(Properties properties, Context context)
       String jndiName = properties.getProperty("dataSourceJNDI");
       DataSource jndiDS = (DataSource) context.lookup(jndiName);
       if (jndiDS == null) {
-         context = (Context) (new InitialContext());
+         context = new InitialContext();
          jndiDS = (DataSource) context.lookup(jndiName);
       }
 

File: src/main/java/com/zaxxer/hikari/pool/LeakTask.java
Patch:
@@ -44,7 +44,7 @@ public class LeakTask implements Runnable
    {
       NO_LEAK = new LeakTask() {
          @Override
-         public void cancel() {};
+         public void cancel() {}
 
          @Override
          public LeakTask start(final PoolBagEntry bagEntry)

File: src/main/java/com/zaxxer/hikari/proxy/JavassistProxyFactory.java
Patch:
@@ -47,7 +47,7 @@
  */
 public final class JavassistProxyFactory
 {
-   private ClassPool classPool;
+   private final ClassPool classPool;
 
    static {
       ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
@@ -224,7 +224,7 @@ private boolean isDefaultMethod(Class<?> intf, CtClass intfCt, CtMethod intfMeth
          paramTypes.add(toJavaClass(pt));
       }
 
-      return intf.getDeclaredMethod(intfMethod.getName(), paramTypes.toArray(new Class[0])).toString().contains("default ");
+      return intf.getDeclaredMethod(intfMethod.getName(), paramTypes.toArray(new Class[paramTypes.size()])).toString().contains("default ");
    }
 
    private Class<?> toJavaClass(CtClass cls) throws Exception

File: src/main/java/com/zaxxer/hikari/util/DefaultThreadFactory.java
Patch:
@@ -19,8 +19,8 @@
 
 public class DefaultThreadFactory implements ThreadFactory {
 
-   private String threadName;
-   private boolean daemon;
+   private final String threadName;
+   private final boolean daemon;
 
    public DefaultThreadFactory(String threadName, boolean daemon) {
       this.threadName = threadName;

File: src/main/java/com/zaxxer/hikari/util/DriverDataSource.java
Patch:
@@ -122,6 +122,7 @@ public int getLoginTimeout() throws SQLException
       return DriverManager.getLoginTimeout();
    }
 
+   @Override
    public java.util.logging.Logger getParentLogger() throws SQLFeatureNotSupportedException
    {
       return driver.getParentLogger();

File: hikaricp-common/src/main/java/com/zaxxer/hikari/util/DriverDataSource.java
Patch:
@@ -32,7 +32,7 @@
 
 public final class DriverDataSource implements DataSource
 {
-   private final Logger LOGGER = LoggerFactory.getLogger(ConcurrentBag.class);
+   private final Logger LOGGER = LoggerFactory.getLogger(DriverDataSource.class);
 
    private final String jdbcUrl;
    private final Properties driverProperties;
@@ -60,6 +60,7 @@ public DriverDataSource(String jdbcUrl, String driverClassName, Properties prope
             Driver d = drivers.nextElement();
             if (d.getClass().getName().equals(driverClassName)) {
                this.driver = d;
+               break;
             }
          }
 

File: src/main/java/com/zaxxer/hikari/HikariDataSource.java
Patch:
@@ -142,6 +142,7 @@ public int getLoginTimeout() throws SQLException
    }
 
    /** {@inheritDoc} */
+   @Override
    public java.util.logging.Logger getParentLogger() throws SQLFeatureNotSupportedException
    {
       throw new SQLFeatureNotSupportedException();

File: src/main/java/com/zaxxer/hikari/HikariJNDIFactory.java
Patch:
@@ -85,7 +85,7 @@ private DataSource lookupJndiDataSource(Properties properties, Context context)
       String jndiName = properties.getProperty("dataSourceJNDI");
       DataSource jndiDS = (DataSource) context.lookup(jndiName);
       if (jndiDS == null) {
-         context = (Context) (new InitialContext());
+         context = new InitialContext();
          jndiDS = (DataSource) context.lookup(jndiName);
       }
 

File: src/main/java/com/zaxxer/hikari/metrics/MetricsTracker.java
Patch:
@@ -24,7 +24,7 @@
  *
  * @author Brett Wooldridge
  */
-public class MetricsTracker
+public class MetricsTracker implements AutoCloseable
 {
    public static final MetricsContext NO_CONTEXT = new MetricsContext();
 
@@ -44,6 +44,7 @@ public void recordConnectionUsage(final PoolBagEntry bagEntry)
    {
    }
 
+   @Override
    public void close()
    {
    }

File: src/main/java/com/zaxxer/hikari/pool/LeakTask.java
Patch:
@@ -44,7 +44,7 @@ public class LeakTask implements Runnable
    {
       NO_LEAK = new LeakTask() {
          @Override
-         public void cancel() {};
+         public void cancel() {}
 
          @Override
          public LeakTask start(final PoolBagEntry bagEntry)

File: src/main/java/com/zaxxer/hikari/pool/PoolBagEntry.java
Patch:
@@ -47,6 +47,7 @@ public PoolBagEntry(final Connection connection, final HikariPool pool) {
       final long maxLifetime = pool.configuration.getMaxLifetime();
       if (maxLifetime > 0) {
          endOfLife = pool.houseKeepingExecutorService.schedule(new Runnable() {
+            @Override
             public void run()
             {
                // If we can reserve it, close it

File: src/main/java/com/zaxxer/hikari/proxy/JavassistProxyFactory.java
Patch:
@@ -47,7 +47,7 @@
  */
 public final class JavassistProxyFactory
 {
-   private ClassPool classPool;
+   private final ClassPool classPool;
 
    static {
       ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
@@ -224,7 +224,7 @@ private boolean isDefaultMethod(Class<?> intf, CtClass intfCt, CtMethod intfMeth
          paramTypes.add(toJavaClass(pt));
       }
 
-      return intf.getDeclaredMethod(intfMethod.getName(), paramTypes.toArray(new Class[0])).toString().contains("default ");
+      return intf.getDeclaredMethod(intfMethod.getName(), paramTypes.toArray(new Class[paramTypes.size()])).toString().contains("default ");
    }
 
    private Class<?> toJavaClass(CtClass cls) throws Exception

File: src/main/java/com/zaxxer/hikari/util/DefaultThreadFactory.java
Patch:
@@ -19,8 +19,8 @@
 
 public class DefaultThreadFactory implements ThreadFactory {
 
-   private String threadName;
-   private boolean daemon;
+   private final String threadName;
+   private final boolean daemon;
 
    public DefaultThreadFactory(String threadName, boolean daemon) {
       this.threadName = threadName;

File: src/main/java/com/zaxxer/hikari/util/DriverDataSource.java
Patch:
@@ -113,6 +113,7 @@ public int getLoginTimeout() throws SQLException
       return DriverManager.getLoginTimeout();
    }
 
+   @Override
    public java.util.logging.Logger getParentLogger() throws SQLFeatureNotSupportedException
    {
       return driver.getParentLogger();

File: src/test/java/com/zaxxer/hikari/TestConnections.java
Patch:
@@ -209,7 +209,7 @@ public void testDoubleClose() throws Exception
 
          Assert.assertTrue("Connection should have closed", connection.isClosed());
          Assert.assertFalse("Connection should have closed", connection.isValid(5));
-         Assert.assertTrue("Expected to contain ClosedConnection, but was " + connection.toString(), connection.toString().contains("ClosedConnection"));
+         Assert.assertTrue("Expected to contain ClosedConnection, but was " + connection, connection.toString().contains("ClosedConnection"));
 
          connection.close();
       }

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -445,7 +445,7 @@ public final synchronized void resumePool()
    /**
     * Permanently close the real (underlying) connection (eat any exception).
     *
-    * @param connectionProxy the connection to actually close
+    * @param bagEntry the connection to actually close
     */
    void closeConnection(final PoolBagEntry bagEntry, final String closureReason)
    {
@@ -535,7 +535,6 @@ public void run() {
     * Check whether the connection is alive or not.
     *
     * @param connection the connection to test
-    * @param timeoutMs the timeout before we consider the test a failure
     * @return true if the connection is alive, false if it is not alive or we timed out
     */
    private boolean isConnectionAlive(final Connection connection)

File: src/main/java/com/zaxxer/hikari/HikariDataSource.java
Patch:
@@ -79,7 +79,7 @@ public HikariDataSource(HikariConfig configuration)
    public Connection getConnection() throws SQLException
    {
       if (isShutdown) {
-         throw new SQLException("Pool {} has been shutdown", pool.getConfiguration().getPoolName());
+         throw new SQLException(String.format("Pool %s has been shutdown", pool.getConfiguration().getPoolName()));
       }
 
       if (fastPathPool != null) {

File: src/test/java/com/zaxxer/hikari/ShutdownTest.java
Patch:
@@ -222,7 +222,7 @@ public void testAfterShutdown() throws Exception
            ds.getConnection();
        }
        catch (SQLException e) {
-          Assert.assertTrue(e.getMessage().contains("Pool has been shutdown"));
+          Assert.assertTrue(e.getMessage().contains("has been shutdown"));
        }
    }
 

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -425,7 +425,7 @@ public void setHealthCheckRegistry(Object healthCheckRegistry)
    protected final boolean addConnection()
    {
       // Speculative increment of totalConnections with expectation of success
-      if (totalConnections.incrementAndGet() <= configuration.getMaximumPoolSize()) {
+      if (totalConnections.incrementAndGet() > configuration.getMaximumPoolSize()) {
          totalConnections.decrementAndGet(); // Pool is maxed out, so undo speculative increment of totalConnections
          lastConnectionFailure.set(new SQLException(String.format("HikariCP pool %s is at maximum capacity", configuration.getPoolName())));
          return true;

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -222,7 +222,6 @@ public final void releaseConnection(final PoolBagEntry bagEntry)
          closeConnection(bagEntry, "connection broken or evicted");
       }
       else {
-         bagEntry.lastAccess = System.currentTimeMillis();
          connectionBag.requite(bagEntry);
       }
    }

File: src/main/java/com/zaxxer/hikari/pool/PoolBagEntry.java
Patch:
@@ -32,11 +32,11 @@ public final class PoolBagEntry implements IConcurrentBagEntry
    public final AtomicInteger state = new AtomicInteger();
 
    public Connection connection;
+   public long lastAccess;
    public long lastOpenTime;
    public volatile boolean evicted;
    public volatile boolean aborted;
    
-   protected long lastAccess;
 
    private volatile ScheduledFuture<?> endOfLife;
 

File: hikaricp-common/src/main/java/com/zaxxer/hikari/pool/BaseHikariPool.java
Patch:
@@ -239,7 +239,6 @@ public final void releaseConnection(final PoolBagEntry bagEntry)
          closeConnection(bagEntry);
       }
       else {
-         bagEntry.lastAccess = System.currentTimeMillis();
          connectionBag.requite(bagEntry);
       }
    }

File: hikaricp-common/src/main/java/com/zaxxer/hikari/pool/PoolBagEntry.java
Patch:
@@ -32,11 +32,11 @@ public final class PoolBagEntry implements IConcurrentBagEntry
    public final AtomicInteger state = new AtomicInteger();
 
    public Connection connection;
+   public long lastAccess;
    public long lastOpenTime;
    public volatile boolean evicted;
    public volatile boolean aborted;
    
-   protected long lastAccess;
 
    private volatile ScheduledFuture<?> endOfLife;
 

File: src/main/java/com/zaxxer/hikari/metrics/CodaHaleMetricsTracker.java
Patch:
@@ -24,7 +24,7 @@
 import com.codahale.metrics.Histogram;
 import com.codahale.metrics.MetricRegistry;
 import com.codahale.metrics.Timer;
-import com.zaxxer.hikari.pool.BaseHikariPool;
+import com.zaxxer.hikari.pool.HikariPool;
 import com.zaxxer.hikari.pool.PoolBagEntry;
 
 public final class CodaHaleMetricsTracker extends MetricsTracker
@@ -33,7 +33,7 @@ public final class CodaHaleMetricsTracker extends MetricsTracker
    private final Histogram connectionUsage;
    private final MetricRegistry registry;
 
-   public CodaHaleMetricsTracker(final BaseHikariPool pool, final MetricRegistry registry) {
+   public CodaHaleMetricsTracker(final HikariPool pool, final MetricRegistry registry) {
       super(pool);
 
       this.registry = registry;

File: src/main/java/com/zaxxer/hikari/metrics/MetricsTracker.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.zaxxer.hikari.metrics;
 
-import com.zaxxer.hikari.pool.BaseHikariPool;
+import com.zaxxer.hikari.pool.HikariPool;
 import com.zaxxer.hikari.pool.PoolBagEntry;
 
 /**
@@ -28,9 +28,9 @@ public class MetricsTracker
 {
    public static final MetricsContext NO_CONTEXT = new MetricsContext();
 
-   protected final BaseHikariPool pool;
+   protected final HikariPool pool;
 
-   public MetricsTracker(final BaseHikariPool pool)
+   public MetricsTracker(final HikariPool pool)
    {
       this.pool = pool;
    }

File: src/main/java/com/zaxxer/hikari/pool/HikariMBeanElf.java
Patch:
@@ -52,7 +52,7 @@ private HikariMBeanElf()
     * @param configuration a HikariConfig instance
     * @param pool a HikariPool instance
     */
-   public static void registerMBeans(final HikariConfig configuration, final BaseHikariPool pool)
+   public static void registerMBeans(final HikariConfig configuration, final HikariPool pool)
    {
       if (!configuration.isRegisterMbeans()) {
          return;
@@ -82,7 +82,7 @@ public static void registerMBeans(final HikariConfig configuration, final BaseHi
     * @param configuration a HikariConfig instance
     * @param pool a HikariPool instance
     */
-   public static void unregisterMBeans(final HikariConfig configuration, final BaseHikariPool pool)
+   public static void unregisterMBeans(final HikariConfig configuration, final HikariPool pool)
    {
       try {
          final MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();

File: src/main/java/com/zaxxer/hikari/pool/PoolBagEntry.java
Patch:
@@ -40,7 +40,7 @@ public final class PoolBagEntry implements IConcurrentBagEntry
 
    private volatile ScheduledFuture<?> endOfLife;
 
-   public PoolBagEntry(final Connection connection, final BaseHikariPool pool) {
+   public PoolBagEntry(final Connection connection, final HikariPool pool) {
       this.connection = connection;
       this.lastAccess = System.currentTimeMillis();
 
@@ -51,7 +51,7 @@ public void run()
             {
                // If we can reserve it, close it
                if (pool.connectionBag.reserve(PoolBagEntry.this)) {
-                  pool.closeConnection(PoolBagEntry.this);
+                  pool.closeConnection(PoolBagEntry.this, "connection reached maxLifetime");
                }
                else {
                   // else the connection is "in-use" and we mark it for eviction by pool.releaseConnection() or the housekeeper

File: src/main/java/com/zaxxer/hikari/proxy/ProxyFactory.java
Patch:
@@ -23,8 +23,8 @@
 import java.sql.Statement;
 
 import com.zaxxer.hikari.pool.HikariPool;
+import com.zaxxer.hikari.pool.LeakTask;
 import com.zaxxer.hikari.pool.PoolBagEntry;
-import com.zaxxer.hikari.util.LeakTask;
 
 /**
  * A factory class that produces proxies around instances of the standard

File: src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java
Patch:
@@ -303,7 +303,6 @@ public void dumpState()
       }
    }
 
-
    /**
     * Our private synchronizer that handles notify/wait type semantics.
     */

File: src/test/java/com/zaxxer/hikari/ConnectionStateTest.java
Patch:
@@ -12,15 +12,13 @@
 
 public class ConnectionStateTest
 {
-   @SuppressWarnings("deprecation")
    @Test
    public void testAutoCommit() throws SQLException
    {
       HikariDataSource ds = new HikariDataSource();
       ds.setAutoCommit(true);
       ds.setMinimumIdle(1);
       ds.setMaximumPoolSize(1);
-      ds.setJdbc4ConnectionTest(false);
       ds.setConnectionTestQuery("VALUES 1");
       ds.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
       ds.addDataSourceProperty("user", "bar");

File: src/test/java/com/zaxxer/hikari/MiscTest.java
Patch:
@@ -29,7 +29,7 @@
 import org.slf4j.spi.LocationAwareLogger;
 
 import com.zaxxer.hikari.pool.HikariPool;
-import com.zaxxer.hikari.util.LeakTask;
+import com.zaxxer.hikari.pool.LeakTask;
 import com.zaxxer.hikari.util.UtilityElf;
 
 /**
@@ -114,7 +114,7 @@ public void testLeakDetection() throws SQLException
          ps.close();
          String s = new String(baos.toByteArray());
          Assert.assertNotNull("Exception string was null", s);
-         Assert.assertTrue("Expected exception to contain 'Connection leak detection' but contains *" + s + "*", s.contains("Connection leak detection"));
+         Assert.assertTrue("Expected exception to contain 'Apparent connection leak detected' but contains *" + s + "*", s.contains("Apparent connection leak detected"));
       }
       finally
       {

File: src/test/java/com/zaxxer/hikari/TestConcurrentBag.java
Patch:
@@ -28,7 +28,6 @@
 import com.zaxxer.hikari.pool.HikariPool;
 import com.zaxxer.hikari.pool.PoolBagEntry;
 import com.zaxxer.hikari.util.ConcurrentBag;
-import com.zaxxer.hikari.util.Java8ConcurrentBag;
 
 /**
  *
@@ -60,7 +59,7 @@ public static void teardown()
    @Test
    public void testConcurrentBag() throws InterruptedException
    {
-      ConcurrentBag<PoolBagEntry> bag = new Java8ConcurrentBag(null);
+      ConcurrentBag<PoolBagEntry> bag = new ConcurrentBag<PoolBagEntry>(null);
       Assert.assertEquals(0, bag.values(8).size());
 
       HikariPool pool = TestElf.getPool(ds);
@@ -79,7 +78,7 @@ public void testConcurrentBag() throws InterruptedException
 
       ByteArrayOutputStream baos = new ByteArrayOutputStream();
       PrintStream ps = new PrintStream(baos, true);
-      TestElf.setSlf4jTargetStream(Java8ConcurrentBag.class, ps);
+      TestElf.setSlf4jTargetStream(ConcurrentBag.class, ps);
       
       bag.requite(reserved);
       Assert.assertTrue(new String(baos.toByteArray()).contains("does not exist"));

File: src/main/java/com/zaxxer/hikari/pool/PoolBagEntry.java
Patch:
@@ -51,7 +51,7 @@ public void run()
             {
                // If we can reserve it, close it
                if (pool.connectionBag.reserve(PoolBagEntry.this)) {
-                  pool.closeConnection(PoolBagEntry.this);
+                  pool.closeConnection(PoolBagEntry.this, "connection reached maxLifetime");
                }
                else {
                   // else the connection is "in-use" and we mark it for eviction by pool.releaseConnection() or the housekeeper

File: src/main/java/com/zaxxer/hikari/pool/PoolUtilities.java
Patch:
@@ -45,11 +45,12 @@ public PoolUtilities(final HikariConfig configuration)
     * Close connection and eat any exception.
     *
     * @param connection the connection to close
+    * @param closureReason the reason the connection was closed (if known)
     */
-   public void quietlyCloseConnection(final Connection connection)
+   public void quietlyCloseConnection(final Connection connection, final String closureReason)
    {
       try {
-         LOGGER.debug("Closing connection {}", connection);
+         LOGGER.debug("Closing connection {} {}", connection, (closureReason != null ? "(" + closureReason + ")" : ""));
          if (connection != null && !connection.isClosed()) {
             setNetworkTimeout(connection, TimeUnit.SECONDS.toMillis(30));
             connection.close();

File: src/test/java/com/zaxxer/hikari/ShutdownTest.java
Patch:
@@ -282,7 +282,7 @@ public void run() {
                   Assert.fail(e.getMessage());
                }
                finally {
-                  new PoolUtilities(config).quietlyCloseConnection(connection);
+                  new PoolUtilities(config).quietlyCloseConnection(connection, "because this is a test");
                   ds.shutdown();
                }
             };

File: hikaricp-common/src/main/java/com/zaxxer/hikari/pool/BaseHikariPool.java
Patch:
@@ -150,7 +150,7 @@ public BaseHikariPool(HikariConfig configuration, String username, String passwo
       setMetricRegistry(configuration.getMetricRegistry());
       setHealthCheckRegistry(configuration.getHealthCheckRegistry());
 
-      this.dataSource = poolUtils.initializeDataSource(configuration.getDataSourceClassName(), configuration.getDataSource(), configuration.getDataSourceProperties(), configuration.getJdbcUrl(), username, password);
+      this.dataSource = poolUtils.initializeDataSource(configuration.getDataSourceClassName(), configuration.getDataSource(), configuration.getDataSourceProperties(), configuration.getDriverClassName(), configuration.getJdbcUrl(), username, password);
 
       this.addConnectionExecutor = createThreadPoolExecutor(configuration.getMaximumPoolSize(), "HikariCP connection filler (pool " + configuration.getPoolName() + ")", configuration.getThreadFactory(), new ThreadPoolExecutor.DiscardPolicy());
       this.closeConnectionExecutor = createThreadPoolExecutor(4, "HikariCP connection closer (pool " + configuration.getPoolName() + ")", configuration.getThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());

File: hikaricp-common/src/main/java/com/zaxxer/hikari/pool/PoolUtilities.java
Patch:
@@ -90,12 +90,13 @@ public void executeSql(final Connection connection, final String sql, final bool
     * @param dsClassName a DataSource class name (optional)
     * @param dataSource a DataSource instance (optional)
     * @param dataSourceProperties a Properties instance of DataSource properties
+    * @param driverClassName the JDBC driver class name (optional)
     * @param jdbcUrl a JDBC connection URL (optional)
     * @param username a username (optional)
     * @param password a password (optional)
     * @return a DataSource instance
     */
-   public DataSource initializeDataSource(final String dsClassName, DataSource dataSource, final Properties dataSourceProperties, final String jdbcUrl, final String username, final String password)
+   public DataSource initializeDataSource(final String dsClassName, DataSource dataSource, final Properties dataSourceProperties, final String driverClassName, final String jdbcUrl, final String username, final String password)
    {
       try {
          if (dataSource == null && dsClassName != null) {
@@ -104,7 +105,7 @@ public DataSource initializeDataSource(final String dsClassName, DataSource data
             return dataSource;
          }
          else if (jdbcUrl != null) {
-            return new DriverDataSource(jdbcUrl, dataSourceProperties, username, password);
+            return new DriverDataSource(jdbcUrl, driverClassName, dataSourceProperties, username, password);
          }
    
          return dataSource;

File: hikaricp-common/src/main/java/com/zaxxer/hikari/pool/BaseHikariPool.java
Patch:
@@ -67,7 +67,7 @@
  */
 public abstract class BaseHikariPool implements HikariPoolMBean, IBagStateListener
 {
-   protected static final Logger LOGGER = LoggerFactory.getLogger("HikariPool");
+   protected final Logger LOGGER = LoggerFactory.getLogger(getClass());
    private static final long ALIVE_BYPASS_WINDOW = Long.getLong("com.zaxxer.hikari.aliveBypassWindow", 1000L);
 
    protected static final int POOL_RUNNING = 0;

File: hikaricp-common/src/main/java/com/zaxxer/hikari/pool/BaseHikariPool.java
Patch:
@@ -139,7 +139,7 @@ public BaseHikariPool(HikariConfig configuration, String username, String passwo
       this.isReadOnly = configuration.isReadOnly();
       this.isAutoCommit = configuration.isAutoCommit();
 
-      this.suspendResumeLock = configuration.isAllowPoolSuspension() ? GlobalPoolLock.SUSPEND_RESUME_LOCK : GlobalPoolLock.FAUX_LOCK;
+      this.suspendResumeLock = configuration.isAllowPoolSuspension() ? new GlobalPoolLock(true) : GlobalPoolLock.FAUX_LOCK;
 
       this.catalog = configuration.getCatalog();
       this.connectionCustomizer = initializeCustomizer();

File: hikaricp-common/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -109,7 +109,7 @@ public final SQLException checkException(final SQLException sqle)
             LOGGER.warn(String.format("Connection %s (%s) marked as broken because of SQLSTATE(%s), ErrorCode(%d).", delegate.toString(),
                                       parentPool.toString(), sqlState, sqle.getErrorCode()), sqle);
          }
-         else if (sqle.getNextException() instanceof SQLException) {
+         else if (sqle.getNextException() instanceof SQLException && sqle != sqle.getNextException()) {
             checkException(sqle.getNextException());
          }
       }

File: hikaricp-common/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -109,7 +109,7 @@ public final SQLException checkException(final SQLException sqle)
             LOGGER.warn(String.format("Connection %s (%s) marked as broken because of SQLSTATE(%s), ErrorCode(%d).", delegate.toString(),
                                       parentPool.toString(), sqlState, sqle.getErrorCode()), sqle);
          }
-         else if (sqle.getNextException() instanceof SQLException) {
+         else if (sqle.getNextException() instanceof SQLException && sqle != sqle.getNextException()) {
             checkException(sqle.getNextException());
          }
       }

File: hikaricp-common/src/main/java/com/zaxxer/hikari/util/LeakTask.java
Patch:
@@ -65,7 +65,7 @@ private LeakTask()
    
    private LeakTask(final LeakTask parent)
    {
-      exception = new Exception();
+      exception = new Exception("Apparent connection leak detected");
       scheduledFuture = parent.executorService.schedule(this, parent.leakDetectionThreshold, TimeUnit.MILLISECONDS);
    }
 

File: hikaricp-common/src/main/java/com/zaxxer/hikari/pool/PoolUtilities.java
Patch:
@@ -50,6 +50,7 @@ public void quietlyCloseConnection(final Connection connection)
    {
       if (connection != null) {
          try {
+            LOGGER.debug("Closing connection {}", connection);
             setNetworkTimeout(connection, TimeUnit.SECONDS.toMillis(30));
             connection.close();
          }

File: hikaricp-common/src/test/java/com/zaxxer/hikari/TestValidation.java
Patch:
@@ -170,9 +170,9 @@ public void validateIdleTimeoutTooSmall()
 
       HikariConfig config = new HikariConfig();
       config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
-      config.setIdleTimeout(TimeUnit.SECONDS.toMillis(25));
+      config.setIdleTimeout(TimeUnit.SECONDS.toMillis(5));
       config.validate();
-      Assert.assertTrue(new String(baos.toByteArray()).contains("less than 30000ms"));
+      Assert.assertTrue(new String(baos.toByteArray()).contains("less than 10000ms"));
    }
 
    @Test

File: hikaricp-common/src/main/java/com/zaxxer/hikari/util/PropertyBeanSetter.java
Patch:
@@ -130,7 +130,7 @@ private static void setProperty(Object target, String propName, Object propValue
             propertyDescriptor = new PropertyDescriptor(propName, target.getClass(), null, capitalized);
          }
          catch (IntrospectionException e1) {
-            LOGGER.error("Property {} is does not exist on target class {}", propName, target.getClass());
+            LOGGER.error("Property {} does not exist on target {}", propName, target.getClass());
             throw new RuntimeException(e);
          }
       }
@@ -155,7 +155,7 @@ else if (paramClass == String.class) {
          }
       }
       catch (Exception e) {
-         LOGGER.error("Exception setting property {} on target class {}", propName, target.getClass(), e);
+         LOGGER.error("Exception setting property {} on target {}", propName, target.getClass(), e);
          throw new RuntimeException(e);
       }
    }

File: hikaricp-common/src/main/java/com/zaxxer/hikari/AbstractHikariConfig.java
Patch:
@@ -759,7 +759,7 @@ private void logConfiguration()
 
    abstract protected void loadProperties(String propertyFileName);
 
-   void copyState(AbstractHikariConfig other)
+   public void copyState(AbstractHikariConfig other)
    {
       for (Field field : AbstractHikariConfig.class.getDeclaredFields()) {
          if (!Modifier.isFinal(field.getModifiers())) {

File: hikaricp-java6/src/test/java/com/zaxxer/hikari/osgi/OSGiBundleTest.java
Patch:
@@ -48,7 +48,7 @@ public Option[] config()
             systemProperty("org.ops4j.pax.logging.DefaultServiceLog.level").value("WARN"),
             mavenBundle("org.slf4j","slf4j-api","1.7.5"),
             mavenBundle("org.slf4j","slf4j-simple","1.7.5").noStart(),
-            mavenBundle("org.javassist", "javassist", "3.18.1-GA"),
+            mavenBundle("org.javassist", "javassist", "3.19.0-GA"),
             new File("target/classes").exists()
                 ?  bundle("reference:file:target/classes")
                 :  bundle("reference:file:../target/classes"),

File: hikaricp/src/test/java/com/zaxxer/hikari/osgi/OSGiBundleTest.java
Patch:
@@ -48,7 +48,7 @@ public Option[] config()
             systemProperty("org.ops4j.pax.logging.DefaultServiceLog.level").value("WARN"),
             mavenBundle("org.slf4j","slf4j-api","1.7.5"),
             mavenBundle("org.slf4j","slf4j-simple","1.7.5").noStart(),
-            mavenBundle("org.javassist", "javassist", "3.18.1-GA"),
+            mavenBundle("org.javassist", "javassist", "3.19.0-GA"),
             new File("target/classes").exists()
                 ?  bundle("reference:file:target/classes")
                 :  bundle("reference:file:../target/classes"),

File: hikaricp-common/src/main/java/com/zaxxer/hikari/pool/BaseHikariPool.java
Patch:
@@ -153,7 +153,7 @@ public BaseHikariPool(HikariConfig configuration, String username, String passwo
       long delayPeriod = Long.getLong("com.zaxxer.hikari.housekeeping.periodMs", TimeUnit.SECONDS.toMillis(30L));
       ThreadFactory threadFactory = configuration.getThreadFactory() != null ? configuration.getThreadFactory() : new DefaultThreadFactory("Hikari Housekeeping Timer (pool " + configuration.getPoolName() + ")", true);
       this.houseKeepingExecutorService = new ScheduledThreadPoolExecutor(1, threadFactory, new ThreadPoolExecutor.DiscardPolicy());
-      this.houseKeepingExecutorService.scheduleAtFixedRate(getHouseKeeper(), TimeUnit.SECONDS.toMillis(10L), delayPeriod, TimeUnit.MILLISECONDS);
+      this.houseKeepingExecutorService.scheduleAtFixedRate(getHouseKeeper(), delayPeriod, delayPeriod, TimeUnit.MILLISECONDS);
       this.leakTask = (configuration.getLeakDetectionThreshold() == 0) ? LeakTask.NO_LEAK : new LeakTask(configuration.getLeakDetectionThreshold(), houseKeepingExecutorService);
 
       setRemoveOnCancelPolicy(houseKeepingExecutorService);

File: hikaricp-common/src/test/java/com/zaxxer/hikari/TestConnections.java
Patch:
@@ -244,7 +244,7 @@ public void testBackfill() throws Exception
 
       HikariDataSource ds = new HikariDataSource(config);
       try {
-         UtilityElf.quietlySleep(250L);
+         UtilityElf.quietlySleep(1200L);
 
          Assert.assertSame("Totals connections not as expected", 1, TestElf.getPool(ds).getTotalConnections());
          Assert.assertSame("Idle connections not as expected", 1, TestElf.getPool(ds).getIdleConnections());

File: hikaricp-common/src/main/java/com/zaxxer/hikari/pool/PoolUtilities.java
Patch:
@@ -134,7 +134,6 @@ public void setupConnection(final Connection connection, final boolean isAutoCom
     *
     * @param connection a Connection to check
     * @return true if JDBC 4.1 compliance, false otherwise
-    * @throws SQLException re-thrown exception from Connection.getNetworkTimeout()
     */
    public boolean isJdbc4ValidationSupported(final Connection connection)
    {
@@ -158,7 +157,6 @@ public boolean isJdbc4ValidationSupported(final Connection connection)
     *
     * @param statement a statement to set the query timeout on
     * @param timeoutSec the number of seconds before timeout
-    * @throws SQLException re-thrown exception from Statement.setQueryTimeout()
     */
    public void setQueryTimeout(final Statement statement, final int timeoutSec)
    {
@@ -224,7 +222,6 @@ public void setNetworkTimeout(final Connection connection, final long timeoutMs,
     *
     * @param dataSource the DataSource
     * @param connectionTimeout the timeout in milliseconds
-    * @param logger a logger to use for a warning
     */
    public void setLoginTimeout(final DataSource dataSource, final long connectionTimeout)
    {

File: hikaricp-common/src/main/java/com/zaxxer/hikari/pool/BaseHikariPool.java
Patch:
@@ -365,7 +365,7 @@ protected final boolean addConnection()
          try {
             connection = (username == null && password == null) ? dataSource.getConnection() : dataSource.getConnection(username, password);
             
-            if (isUseJdbc4Validation && !poolUtils.isJdbc40Compliant(connection)) {
+            if (isUseJdbc4Validation && !poolUtils.isJdbc4ValidationSupported(connection)) {
                throw new SQLException("JDBC4 Connection.isValid() method not supported, connection test query must be configured");
             }
             

File: hikaricp-common/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java
Patch:
@@ -13,6 +13,7 @@
 import javax.sql.DataSource;
 
 import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import com.zaxxer.hikari.HikariConfig;
 
@@ -44,6 +45,7 @@ public void quietlyCloseConnection(final Connection connection)
             connection.close();
          }
          catch (Exception e) {
+            LoggerFactory.getLogger(getClass()).debug("Exception closing connection {}", connection.toString(), e);
             return;
          }
       }

File: hikaricp-common/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java
Patch:
@@ -130,6 +130,9 @@ public boolean isJdbc40Compliant(final Connection connection) throws SQLExceptio
          catch (AbstractMethodError e) {
             IS_JDBC40 = false;
          }
+         catch (UnsupportedOperationException e) {
+            IS_JDBC40 = false;
+         }
          catch (NoSuchMethodError e) {
             IS_JDBC40 = false;
          }

File: hikaricp-common/src/test/java/com/zaxxer/hikari/StatementTest.java
Patch:
@@ -43,7 +43,7 @@ public void testStatementClose() throws SQLException
         Assert.assertNotNull(connection);
 
         Assert.assertTrue("Totals connections not as expected", TestElf.getPool(ds).getTotalConnections() >= 1);
-        Assert.assertSame("Idle connections not as expected", 0, TestElf.getPool(ds).getIdleConnections());
+        Assert.assertTrue("Idle connections not as expected", TestElf.getPool(ds).getIdleConnections() >= 1);
 
         Statement statement = connection.createStatement();
         Assert.assertNotNull(statement);

File: hikaricp-common/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -102,7 +102,7 @@ public final PoolBagEntry getPoolBagEntry()
    public final SQLException checkException(final SQLException sqle)
    {
       String sqlState = sqle.getSQLState();
-      if (sqlState != null && !bagEntry.evicted) {
+      if (sqlState != null) {
          boolean isForceClose = sqlState.startsWith("08") | SQL_ERRORS.contains(sqlState);
          if (isForceClose) {
             bagEntry.evicted = true;

File: hikaricp-common/src/main/java/com/zaxxer/hikari/util/UtilityElf.java
Patch:
@@ -88,10 +88,10 @@ public static void setRemoveOnCancelPolicy(ScheduledThreadPoolExecutor executor)
     * Create and instance of the specified class using the constructor matching the specified
     * arguments.
     *
+    * @param <T> the class type
     * @param className the name of the classto instantiate
     * @param clazz a class to cast the result as
     * @param args arguments to a constructor
-    * @param T the class type
     * @return an instance of the specified class
     */
    @SuppressWarnings("unchecked")

File: hikaricp-common/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java
Patch:
@@ -173,7 +173,7 @@ public void add(final T bagEntry)
 
    /**
     * Remove a value from the bag.  This method should only be called
-    * with objects obtained by <code>borrow(long, TimeUnit)<code> or <code>reserve(T)</code>
+    * with objects obtained by <code>borrow(long, TimeUnit)</code> or <code>reserve(T)</code>
     *
     * @param bagEntry the value to remove
     * @return true if the entry was removed, false otherwise

File: hikaricp-common/src/main/java/com/zaxxer/hikari/util/UtilityElf.java
Patch:
@@ -91,6 +91,7 @@ public static void setRemoveOnCancelPolicy(ScheduledThreadPoolExecutor executor)
     * @param className the name of the classto instantiate
     * @param clazz a class to cast the result as
     * @param args arguments to a constructor
+    * @param T the class type
     * @return an instance of the specified class
     */
    @SuppressWarnings("unchecked")
@@ -126,6 +127,7 @@ public static <T> T createInstance(final String className, final Class<T> clazz,
     * @param queueSize the queue size
     * @param threadName the thread name
     * @param threadFactory an optional ThreadFactory
+    * @param policy the RejectedExecutionHandler policy
     * @return a ThreadPoolExecutor
     */
    public static ThreadPoolExecutor createThreadPoolExecutor(final int queueSize, final String threadName, ThreadFactory threadFactory, final RejectedExecutionHandler policy)

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/util/Java6ConcurrentBag.java
Patch:
@@ -61,7 +61,7 @@ protected AbstractQueuedLongSynchronizer createQueuedSynchronizer()
    /**
     * This method provides a "snaphot" in time of the BagEntry
     * items in the bag in the specified state.  It does not "lock"
-    * or reserve items in any way.  Call {@link #reserve(BagEntry)}
+    * or reserve items in any way.  Call <code>reserve(BagEntry)</code>
     * on items in list before performing any action on them.
     *
     * @param state one of STATE_NOT_IN_USE or STATE_IN_USE

File: hikaricp/src/main/java/com/zaxxer/hikari/util/Java8ConcurrentBag.java
Patch:
@@ -66,7 +66,7 @@ protected AbstractQueuedLongSynchronizer createQueuedSynchronizer()
    /**
     * This method provides a "snaphot" in time of the BagEntry
     * items in the bag in the specified state.  It does not "lock"
-    * or reserve items in any way.  Call {@link #reserve(BagEntry)}
+    * or reserve items in any way.  Call <code>reserve(BagEntry)</code>
     * on items in list before performing any action on them.
     *
     * @param state one of STATE_NOT_IN_USE or STATE_IN_USE

File: hikaricp-common/src/main/java/com/zaxxer/hikari/pool/PoolBagEntry.java
Patch:
@@ -71,7 +71,8 @@ public String toString()
    {
       return "Connection......" + connection + "\n"
            + "  Last  access.." + lastAccess + "\n"
-           + "  Last open....." + lastOpenTime + "\n";
+           + "  Last open....." + lastOpenTime + "\n"
+           + "  State........." + super.toString();
    }
 }
 

File: hikaricp-common/src/main/java/com/zaxxer/hikari/util/IConcurrentBagEntry.java
Patch:
@@ -23,4 +23,5 @@ public interface IConcurrentBagEntry
    int STATE_NOT_IN_USE = 0;
    int STATE_IN_USE = 1;
    int STATE_REMOVED = -1;
+   int STATE_RESERVED = -2;
 }

File: hikaricp-common/src/main/java/com/zaxxer/hikari/HikariDataSource.java
Patch:
@@ -178,7 +178,7 @@ public java.util.logging.Logger getParentLogger() throws SQLFeatureNotSupportedE
    @SuppressWarnings("unchecked")
    public <T> T unwrap(Class<T> iface) throws SQLException
    {
-      if (iface == this.getClass()) {
+      if (iface.isInstance(this)) {
          return (T) this;
       }
       else if (pool != null) {
@@ -197,7 +197,7 @@ else if (pool.getDataSource() instanceof Wrapper) {
    @Override
    public boolean isWrapperFor(Class<?> iface) throws SQLException
    {
-      if (iface == this.getClass()) {
+      if (iface.isInstance(this)) {
          return true;
       }
       else if (pool != null) {

File: hikaricp-common/src/test/java/com/zaxxer/hikari/TestConnections.java
Patch:
@@ -377,7 +377,6 @@ public void testOldDriver() throws Exception
 
       StubConnection.oldDriver = true;
       StubStatement.oldDriver = true;
-      TestElf.resetPoolUtilities();
       HikariDataSource ds = new HikariDataSource(config);
       try {
          UtilityElf.quietlySleep(1001L);
@@ -391,7 +390,6 @@ public void testOldDriver() throws Exception
       finally {
          StubConnection.oldDriver = false;
          StubStatement.oldDriver = false;
-         TestElf.resetPoolUtilities();
          ds.close();
       }
    }

File: hikaricp-common/src/main/java/com/zaxxer/hikari/metrics/CodaHaleMetricsTracker.java
Patch:
@@ -16,6 +16,8 @@
 
 package com.zaxxer.hikari.metrics;
 
+import static com.zaxxer.hikari.util.UtilityElf.elapsedTimeMs;
+
 import java.util.concurrent.TimeUnit;
 
 import com.codahale.metrics.CachedGauge;
@@ -24,7 +26,6 @@
 import com.codahale.metrics.Timer;
 import com.zaxxer.hikari.pool.BaseHikariPool;
 import com.zaxxer.hikari.pool.PoolBagEntry;
-import com.zaxxer.hikari.util.PoolUtilities;
 
 public final class CodaHaleMetricsTracker extends MetricsTracker
 {
@@ -99,7 +100,7 @@ public Context recordConnectionRequest(final long requestTime)
    @Override
    public void recordConnectionUsage(final PoolBagEntry bagEntry)
    {
-      connectionUsage.update(PoolUtilities.elapsedTimeMs(bagEntry.lastOpenTime));
+      connectionUsage.update(elapsedTimeMs(bagEntry.lastOpenTime));
    }
 
    public Timer getConnectionAcquisitionTimer()

File: hikaricp-common/src/main/java/com/zaxxer/hikari/proxy/ProxyFactory.java
Patch:
@@ -22,7 +22,6 @@
 import java.sql.ResultSet;
 import java.sql.Statement;
 
-import com.zaxxer.hikari.pool.BaseHikariPool;
 import com.zaxxer.hikari.pool.HikariPool;
 import com.zaxxer.hikari.pool.PoolBagEntry;
 import com.zaxxer.hikari.util.LeakTask;

File: hikaricp-common/src/test/java/com/zaxxer/hikari/ConnectionStateTest.java
Patch:
@@ -8,7 +8,7 @@
 import org.junit.Assert;
 import org.junit.Test;
 
-import com.zaxxer.hikari.util.PoolUtilities;
+import com.zaxxer.hikari.util.UtilityElf;
 
 public class ConnectionStateTest
 {
@@ -72,7 +72,7 @@ public void testIsolation() throws Exception
       config.setTransactionIsolation("TRANSACTION_REPEATABLE_READ");
       config.validate();
 
-      int transactionIsolation = PoolUtilities.getTransactionIsolation(config.getTransactionIsolation());
+      int transactionIsolation = UtilityElf.getTransactionIsolation(config.getTransactionIsolation());
       Assert.assertSame(Connection.TRANSACTION_REPEATABLE_READ, transactionIsolation);
    }
 

File: hikaricp-common/src/test/java/com/zaxxer/hikari/ExceptionTest.java
Patch:
@@ -10,7 +10,7 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import com.zaxxer.hikari.util.PoolUtilities;
+import com.zaxxer.hikari.util.UtilityElf;
 
 public class ExceptionTest
 {
@@ -28,7 +28,7 @@ public void setup()
 
         ds = new HikariDataSource(config);
 
-        PoolUtilities.quietlySleep(250L);
+        UtilityElf.quietlySleep(250L);
     }
 
     @After

File: hikaricp-common/src/test/java/com/zaxxer/hikari/mocks/StubConnection.java
Patch:
@@ -37,7 +37,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import com.zaxxer.hikari.util.PoolUtilities;
+import com.zaxxer.hikari.util.UtilityElf;
 
 /**
  *
@@ -61,7 +61,7 @@ public class StubConnection extends StubBaseConnection implements Connection
    public StubConnection() {
       count.incrementAndGet();
       if (slowCreate) {
-         PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(1));
+         UtilityElf.quietlySleep(TimeUnit.SECONDS.toMillis(1));
       }
    }
 

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.zaxxer.hikari.util;
 
-import static com.zaxxer.hikari.util.PoolUtilities.IS_JAVA7;
+import static com.zaxxer.hikari.util.UtilityElf.IS_JAVA7;
 
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;

File: hikaricp-java6/src/test/java/com/zaxxer/hikari/TestMetrics.java
Patch:
@@ -27,7 +27,7 @@
 import com.codahale.metrics.MetricFilter;
 import com.codahale.metrics.MetricRegistry;
 import com.codahale.metrics.Timer;
-import com.zaxxer.hikari.util.PoolUtilities;
+import com.zaxxer.hikari.util.UtilityElf;
 
 /**
  * Test HikariCP/CodaHale metrics integration.
@@ -84,7 +84,7 @@ public void testMetricUsage() throws SQLException
       HikariDataSource ds = new HikariDataSource(config);
       try {
          Connection connection = ds.getConnection();
-         PoolUtilities.quietlySleep(250L);
+         UtilityElf.quietlySleep(250L);
          connection.close();
 
          Histogram histo = metricRegistry.getHistograms(new MetricFilter() {

File: hikaricp-common/src/main/java/com/zaxxer/hikari/pool/BaseHikariPool.java
Patch:
@@ -37,6 +37,7 @@
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -150,7 +151,8 @@ public BaseHikariPool(HikariConfig configuration, String username, String passwo
       this.closeConnectionExecutor = createThreadPoolExecutor(4, "HikariCP connection closer (pool " + configuration.getPoolName() + ")", configuration.getThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());
 
       long delayPeriod = Long.getLong("com.zaxxer.hikari.housekeeping.periodMs", TimeUnit.SECONDS.toMillis(30L));
-      this.houseKeepingExecutorService = new ScheduledThreadPoolExecutor(1, configuration.getThreadFactory() != null ? configuration.getThreadFactory() : new DefaultThreadFactory("Hikari Housekeeping Timer (pool " + configuration.getPoolName() + ")", true));
+      ThreadFactory threadFactory = configuration.getThreadFactory() != null ? configuration.getThreadFactory() : new DefaultThreadFactory("Hikari Housekeeping Timer (pool " + configuration.getPoolName() + ")", true);
+      this.houseKeepingExecutorService = new ScheduledThreadPoolExecutor(1, threadFactory, new ThreadPoolExecutor.DiscardPolicy());
       this.houseKeepingExecutorService.scheduleAtFixedRate(getHouseKeeper(), delayPeriod, delayPeriod, TimeUnit.MILLISECONDS);
       this.leakTask = (configuration.getLeakDetectionThreshold() == 0) ? LeakTask.NO_LEAK : new LeakTask(configuration.getLeakDetectionThreshold(), houseKeepingExecutorService);
 

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java
Patch:
@@ -103,7 +103,7 @@ public static void quietlySleep(final long millis)
          Thread.sleep(millis);
       }
       catch (InterruptedException e) {
-         throw new RuntimeException(e);
+         // I said be quiet!
       }
    }
 

File: hikaricp/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java
Patch:
@@ -85,7 +85,7 @@ public static void quietlySleep(final long millis)
          Thread.sleep(millis);
       }
       catch (InterruptedException e) {
-         throw new RuntimeException(e);
+         // I said be quiet!
       }
    }
 

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java
Patch:
@@ -179,7 +179,7 @@ public void requite(final T bagEntry)
    public void add(final T bagEntry)
    {
       if (closed) {
-         LOGGER.warn("ConcurrentBag has been closed, ignoring add()");
+         throw new IllegalStateException("ConcurrentBag has been closed, ignoring add()");
       }
       else {
          sharedList.add(bagEntry);

File: hikaricp/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java
Patch:
@@ -178,7 +178,7 @@ public void requite(final T bagEntry)
    public void add(final T bagEntry)
    {
       if (closed) {
-         LOGGER.warn("ConcurrentBag has been closed, ignoring add()");
+         throw new IllegalStateException("ConcurrentBag has been closed, ignoring add()");
       }
       else {
          sharedList.add(bagEntry);

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -259,6 +259,7 @@ public void shutdown() throws InterruptedException
          logPoolState("After shutdown ");
 
          unregisterMBeans(configuration, this);
+         metricsTracker.close();
       }
    }
 

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -256,6 +256,7 @@ public void shutdown() throws InterruptedException
          logPoolState("After shutdown ");
 
          unregisterMBeans(configuration, this);
+         metricsTracker.close();
       }
    }
 

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -537,7 +537,7 @@ private void abortActiveConnections() throws InterruptedException
       ExecutorService assassinExecutor = createThreadPoolExecutor(configuration.getMaximumPoolSize(), "HikariCP connection assassin", configuration.getThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());
       for (PoolBagEntry bagEntry : connectionBag.values(STATE_IN_USE)) {
          try {
-            bagEntry.evicted = true;
+            bagEntry.aborted = bagEntry.evicted = true;
             bagEntry.connection.abort(assassinExecutor);
          }
          catch (AbstractMethodError e) {

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/PoolBagEntry.java
Patch:
@@ -31,6 +31,7 @@ public final class PoolBagEntry extends BagEntry
    public final long expirationTime;
    public long lastOpenTime;
    public volatile boolean evicted;
+   public volatile boolean aborted;
    long lastAccess;
 
    public PoolBagEntry(final Connection connection, long maxLifetime) {

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -202,8 +202,8 @@ public final void close() throws SQLException
             delegate.clearWarnings();
          }
          catch (SQLException e) {
-            // when connections are evicted, exceptions are often thrown that should not reach the application
-            if (!bagEntry.evicted) {
+            // when connections are aborted, exceptions are often thrown that should not reach the application
+            if (!bagEntry.aborted) {
                throw checkException(e);
             }
          }

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -513,10 +513,10 @@ private void abortActiveConnections() throws InterruptedException
       ExecutorService assassinExecutor = createThreadPoolExecutor(configuration.getMaximumPoolSize(), "HikariCP connection assassin", configuration.getThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());
       connectionBag.values(STATE_IN_USE).stream().forEach(bagEntry -> {
          try {
-            bagEntry.evicted = true;
+            bagEntry.aborted = bagEntry.evicted = true;
             bagEntry.connection.abort(assassinExecutor);
          }
-         catch (SQLException | AbstractMethodError e) {
+         catch (SQLException | NoSuchMethodError | AbstractMethodError e) {
             quietlyCloseConnection(bagEntry.connection);
          }
          finally {

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/PoolBagEntry.java
Patch:
@@ -31,6 +31,7 @@ public final class PoolBagEntry extends BagEntry
    public final long expirationTime;
    public long lastOpenTime;
    public volatile boolean evicted;
+   public volatile boolean aborted;
    long lastAccess;
 
    public PoolBagEntry(final Connection connection, long maxLifetime) {

File: hikaricp/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -202,8 +202,8 @@ public final void close() throws SQLException
             delegate.clearWarnings();
          }
          catch (SQLException e) {
-            // when connections are evicted, exceptions are often thrown that should not reach the application
-            if (!bagEntry.evicted) {
+            // when connections are aborted, exceptions are often thrown that should not reach the application
+            if (!bagEntry.aborted) {
                throw checkException(e);
             }
          }

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/PoolBagEntry.java
Patch:
@@ -30,7 +30,7 @@ public final class PoolBagEntry extends BagEntry
    public final Connection connection;
    public final long expirationTime;
    public long lastOpenTime;
-   volatile boolean evicted;
+   public volatile boolean evicted;
    long lastAccess;
 
    public PoolBagEntry(final Connection connection, long maxLifetime) {

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/PoolBagEntry.java
Patch:
@@ -30,7 +30,7 @@ public final class PoolBagEntry extends BagEntry
    public final Connection connection;
    public final long expirationTime;
    public long lastOpenTime;
-   volatile boolean evicted;
+   public volatile boolean evicted;
    long lastAccess;
 
    public PoolBagEntry(final Connection connection, long maxLifetime) {

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -432,7 +432,7 @@ private boolean addConnection()
       // Speculative increment of totalConnections with expectation of success
       if (totalConnections.incrementAndGet() > configuration.getMaximumPoolSize() || isShutdown || isPoolSuspended) {
          totalConnections.decrementAndGet();
-         return true;
+         return !isPoolSuspended;
       }
 
       Connection connection = null;

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -412,7 +412,7 @@ private boolean addConnection()
       // Speculative increment of totalConnections with expectation of success
       if (totalConnections.incrementAndGet() > configuration.getMaximumPoolSize() || isShutdown || isPoolSuspended) {
          totalConnections.decrementAndGet();
-         return true;
+         return !isPoolSuspended;
       }
 
       Connection connection = null;

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -539,6 +539,7 @@ private void abortActiveConnections() throws InterruptedException
       ExecutorService assassinExecutor = createThreadPoolExecutor(configuration.getMaximumPoolSize(), "HikariCP connection assassin", configuration.getThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());
       for (PoolBagEntry bagEntry : connectionBag.values(STATE_IN_USE)) {
          try {
+            bagEntry.evicted = true;
             bagEntry.connection.abort(assassinExecutor);
          }
          catch (AbstractMethodError e) {

File: hikaricp-java6/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java
Patch:
@@ -84,8 +84,9 @@ public void testConcurrentBag() throws InterruptedException
 
       bag.close();
       try {
-         bag.add(new PoolBagEntry(null, 0));
-         Assert.fail();
+         PoolBagEntry bagEntry = new PoolBagEntry(null, 0);
+         bag.add(bagEntry);
+         Assert.assertNotEquals(bagEntry, bag.borrow(100, TimeUnit.MILLISECONDS));
       }
       catch (IllegalStateException e) {
          // pass

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -515,6 +515,7 @@ private void abortActiveConnections() throws InterruptedException
       ExecutorService assassinExecutor = createThreadPoolExecutor(configuration.getMaximumPoolSize(), "HikariCP connection assassin", configuration.getThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());
       connectionBag.values(STATE_IN_USE).stream().forEach(bagEntry -> {
          try {
+            bagEntry.evicted = true;
             bagEntry.connection.abort(assassinExecutor);
          }
          catch (SQLException | AbstractMethodError e) {

File: hikaricp/src/test/java/com/zaxxer/hikari/TestConcurrentBag.java
Patch:
@@ -84,8 +84,9 @@ public void testConcurrentBag() throws InterruptedException
 
       bag.close();
       try {
-         bag.add(new PoolBagEntry(null, 0));
-         Assert.fail();
+         PoolBagEntry bagEntry = new PoolBagEntry(null, 0);
+         bag.add(bagEntry);
+         Assert.assertNotEquals(bagEntry, bag.borrow(100, TimeUnit.MILLISECONDS));
       }
       catch (IllegalStateException e) {
          // pass

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -51,14 +51,14 @@ public abstract class ConnectionProxy implements IHikariConnectionProxy
    private final LeakTask leakTask;
    private FastList<Statement> openStatements;
    
+   private boolean isClosed;
    private boolean forceClose;
    private boolean commitStateDirty;
    private boolean isAnythingDirty;
    private boolean isAutoCommitDirty;
    private boolean isCatalogDirty;
    private boolean isReadOnlyDirty;
    private boolean isTransactionIsolationDirty;
-   private volatile boolean isClosed;
 
    // static initializer
    static {

File: hikaricp/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -51,14 +51,14 @@ public abstract class ConnectionProxy implements IHikariConnectionProxy
    private final LeakTask leakTask;
    private FastList<Statement> openStatements;
    
+   private boolean isClosed;
    private boolean forceClose;
    private boolean commitStateDirty;
    private boolean isAnythingDirty;
    private boolean isAutoCommitDirty;
    private boolean isCatalogDirty;
    private boolean isReadOnlyDirty;
    private boolean isTransactionIsolationDirty;
-   private volatile boolean isClosed;
 
    // static initializer
    static {

File: hikaricp-java6/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java
Patch:
@@ -235,7 +235,7 @@ public void testConnectionIdleFill() throws Exception
          Connection connection6 = ds.getConnection();
          Connection connection7 = ds.getConnection();
 
-         Thread.sleep(1350);
+         Thread.sleep(1500);
 
          Assert.assertSame("Totals connections not as expected", 10, TestElf.getPool(ds).getTotalConnections());
          Assert.assertSame("Idle connections not as expected", 3, TestElf.getPool(ds).getIdleConnections());

File: hikaricp/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java
Patch:
@@ -235,7 +235,7 @@ public void testConnectionIdleFill() throws Exception
          Connection connection6 = ds.getConnection();
          Connection connection7 = ds.getConnection();
 
-         Thread.sleep(1350);
+         Thread.sleep(1500);
 
          Assert.assertSame("Totals connections not as expected", 10, TestElf.getPool(ds).getTotalConnections());
          Assert.assertSame("Idle connections not as expected", 3, TestElf.getPool(ds).getIdleConnections());

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/util/DriverDataSource.java
Patch:
@@ -35,7 +35,8 @@ public DriverDataSource(String jdbcUrl, Properties properties, String username,
    {
       try {
          this.jdbcUrl = jdbcUrl;
-         this.driverProperties = new Properties(properties);
+         this.driverProperties = new Properties();
+         this.driverProperties.putAll(properties);
          if (username != null) {
             driverProperties.put("user", driverProperties.getProperty("user", username));
          }

File: hikaricp/src/main/java/com/zaxxer/hikari/util/DriverDataSource.java
Patch:
@@ -35,7 +35,8 @@ public DriverDataSource(String jdbcUrl, Properties properties, String username,
    {
       try {
          this.jdbcUrl = jdbcUrl;
-         this.driverProperties = new Properties(properties);
+         this.driverProperties = new Properties();
+         this.driverProperties.putAll(properties);
          if (username != null) {
             driverProperties.put("user", driverProperties.getProperty("user", username));
          }

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/util/DriverDataSource.java
Patch:
@@ -35,7 +35,8 @@ public DriverDataSource(String jdbcUrl, Properties properties, String username,
    {
       try {
          this.jdbcUrl = jdbcUrl;
-         this.driverProperties = new Properties(properties);
+         this.driverProperties = new Properties();
+         this.driverProperties.putAll(properties);
          if (username != null) {
             driverProperties.put("user", driverProperties.getProperty("user", username));
          }

File: hikaricp/src/main/java/com/zaxxer/hikari/util/DriverDataSource.java
Patch:
@@ -35,7 +35,8 @@ public DriverDataSource(String jdbcUrl, Properties properties, String username,
    {
       try {
          this.jdbcUrl = jdbcUrl;
-         this.driverProperties = new Properties(properties);
+         this.driverProperties = new Properties();
+         this.driverProperties.putAll(properties);
          if (username != null) {
             driverProperties.put("user", driverProperties.getProperty("user", username));
          }

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/util/DriverDataSource.java
Patch:
@@ -35,7 +35,8 @@ public DriverDataSource(String jdbcUrl, Properties properties, String username,
    {
       try {
          this.jdbcUrl = jdbcUrl;
-         this.driverProperties = new Properties(properties);
+         this.driverProperties = new Properties();
+         this.driverProperties.putAll(properties);
          if (username != null) {
             driverProperties.put("user", driverProperties.getProperty("user", username));
          }

File: hikaricp/src/main/java/com/zaxxer/hikari/util/DriverDataSource.java
Patch:
@@ -35,7 +35,8 @@ public DriverDataSource(String jdbcUrl, Properties properties, String username,
    {
       try {
          this.jdbcUrl = jdbcUrl;
-         this.driverProperties = new Properties(properties);
+         this.driverProperties = new Properties();
+         this.driverProperties.putAll(properties);
          if (username != null) {
             driverProperties.put("user", driverProperties.getProperty("user", username));
          }

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java
Patch:
@@ -326,7 +326,7 @@ public static void setLoginTimeout(final DataSource dataSource, final long conne
    {
       if (connectionTimeout != Integer.MAX_VALUE) {
          try {
-            dataSource.setLoginTimeout((int) TimeUnit.MILLISECONDS.toSeconds(Math.min(1000L, connectionTimeout)));
+            dataSource.setLoginTimeout((int) TimeUnit.MILLISECONDS.toSeconds(Math.max(1000L, connectionTimeout)));
          }
          catch (SQLException e) {
             logger.warn("Unable to set DataSource login timeout", e);

File: hikaricp/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java
Patch:
@@ -290,7 +290,7 @@ public static void setLoginTimeout(final DataSource dataSource, final long conne
    {
       if (connectionTimeout != Integer.MAX_VALUE) {
          try {
-            dataSource.setLoginTimeout((int) TimeUnit.MILLISECONDS.toSeconds(Math.min(1000L, connectionTimeout)));
+            dataSource.setLoginTimeout((int) TimeUnit.MILLISECONDS.toSeconds(Math.max(1000L, connectionTimeout)));
          }
          catch (SQLException e) {
             logger.warn("Unable to set DataSource login timeout", e);

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java
Patch:
@@ -195,8 +195,10 @@ public static int getTransactionIsolation(final String transactionIsolationName)
    public static void setupConnection(final Connection connection, final boolean isAutoCommit, final boolean isReadOnly, final int transactionIsolation, final String catalog) throws SQLException
    {
       connection.setAutoCommit(isAutoCommit);
-      connection.setTransactionIsolation(transactionIsolation);
       connection.setReadOnly(isReadOnly);
+      if (transactionIsolation != connection.getTransactionIsolation()) {
+         connection.setTransactionIsolation(transactionIsolation);
+      }
       if (catalog != null) {
          connection.setCatalog(catalog);
       }

File: hikaricp/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java
Patch:
@@ -177,8 +177,10 @@ public static int getTransactionIsolation(final String transactionIsolationName)
    public static void setupConnection(final Connection connection, final boolean isAutoCommit, final boolean isReadOnly, final int transactionIsolation, final String catalog) throws SQLException
    {
       connection.setAutoCommit(isAutoCommit);
-      connection.setTransactionIsolation(transactionIsolation);
       connection.setReadOnly(isReadOnly);
+      if (transactionIsolation != connection.getTransactionIsolation()) {
+         connection.setTransactionIsolation(transactionIsolation);
+      }
       if (catalog != null) {
          connection.setCatalog(catalog);
       }

File: hikaricp/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java
Patch:
@@ -241,8 +241,7 @@ public static boolean isJdbc41Compliant(final Connection connection) throws SQLE
          jdbc41checked = true;
 
          try {
-            connection.getNetworkTimeout();  // This will throw AbstractMethodError or SQLException in the case of a non-JDBC 41 compliant driver
-            IS_JDBC41 = true;
+            IS_JDBC41 = connection.getNetworkTimeout() != Integer.MIN_VALUE;  // This will throw AbstractMethodError or SQLException in the case of a non-JDBC 41 compliant driver
          }
          catch (NoSuchMethodError | AbstractMethodError | SQLFeatureNotSupportedException e) {
             IS_JDBC41 = false;
@@ -290,7 +289,7 @@ public static int setNetworkTimeout(final Executor executor, final Connection co
             connection.setNetworkTimeout(executor, (int) timeoutMs);
             return networkTimeout;
          }
-         catch (SQLFeatureNotSupportedException e) {
+         catch (SQLFeatureNotSupportedException | AbstractMethodError | NoSuchMethodError e) {
             IS_JDBC41 = false;
          }
       }

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/HikariPoolMBean.java
Patch:
@@ -31,5 +31,5 @@ public interface HikariPoolMBean
 
    int getThreadsAwaitingConnection();
 
-   void closeIdleConnections();
+   void softEvictConnections();
 }

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/PoolBagEntry.java
Patch:
@@ -30,6 +30,7 @@ public final class PoolBagEntry extends BagEntry
    public final Connection connection;
    public final long expirationTime;
    public long lastOpenTime;
+   volatile boolean evicted;
    long lastAccess;
 
    public PoolBagEntry(final Connection connection, long maxLifetime) {

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPoolMBean.java
Patch:
@@ -31,5 +31,5 @@ public interface HikariPoolMBean
 
    int getThreadsAwaitingConnection();
 
-   void closeIdleConnections();
+   void softEvictConnections();
 }

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/PoolBagEntry.java
Patch:
@@ -30,6 +30,7 @@ public final class PoolBagEntry extends BagEntry
    public final Connection connection;
    public final long expirationTime;
    public long lastOpenTime;
+   volatile boolean evicted;
    long lastAccess;
 
    public PoolBagEntry(final Connection connection, long maxLifetime) {

File: hikaricp/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -131,7 +131,7 @@ public final void untrackStatement(Statement statement)
 
    /** {@inheritDoc} */
    @Override
-   public final void setCommitStateDirty()
+   public final void markCommitStateDirty()
    {
       commitStateDirty = true;
    }

File: hikaricp/src/main/java/com/zaxxer/hikari/proxy/IHikariConnectionProxy.java
Patch:
@@ -57,5 +57,5 @@ public interface IHikariConnectionProxy extends Connection
    /**
     * Sets the commit state of the connection to dirty.
     */
-   void setCommitStateDirty();
+   void markCommitStateDirty();
 }

File: hikaricp/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java
Patch:
@@ -220,7 +220,7 @@ public static boolean isJdbc40Compliant(final Connection connection) throws SQLE
             connection.isValid(5);  // This will throw AbstractMethodError or SQLException in the case of a non-JDBC 41 compliant driver
             IS_JDBC40 = true;
          }
-         catch (AbstractMethodError | SQLFeatureNotSupportedException e) {
+         catch (NoSuchMethodError | AbstractMethodError | SQLFeatureNotSupportedException e) {
             IS_JDBC40 = false;
          }
       }
@@ -244,7 +244,7 @@ public static boolean isJdbc41Compliant(final Connection connection) throws SQLE
             connection.getNetworkTimeout();  // This will throw AbstractMethodError or SQLException in the case of a non-JDBC 41 compliant driver
             IS_JDBC41 = true;
          }
-         catch (AbstractMethodError | SQLFeatureNotSupportedException e) {
+         catch (NoSuchMethodError | AbstractMethodError | SQLFeatureNotSupportedException e) {
             IS_JDBC41 = false;
          }
       }
@@ -265,7 +265,7 @@ public static void setQueryTimeout(final Statement statement, final int timeoutS
          try {
             statement.setQueryTimeout(timeoutSec);
          }
-         catch (AbstractMethodError | SQLFeatureNotSupportedException e) {
+         catch (NoSuchMethodError | AbstractMethodError | SQLFeatureNotSupportedException e) {
             queryTimeoutSupported = false;
          }
       }

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java
Patch:
@@ -296,7 +296,7 @@ public static int setNetworkTimeout(final Executor executor, final Connection co
       }
 
       final int networkTimeout = connection.getNetworkTimeout();
-      connection.setNetworkTimeout(executor, Math.max(250, (int) timeoutMs)); 
+      connection.setNetworkTimeout(executor, (int) timeoutMs); 
 
       return networkTimeout;
    }

File: hikaricp/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java
Patch:
@@ -269,7 +269,7 @@ public static int setNetworkTimeout(final Executor executor, final Connection co
       }
 
       final int networkTimeout = connection.getNetworkTimeout();
-      connection.setNetworkTimeout(executor, Math.max(250, (int) timeoutMs)); 
+      connection.setNetworkTimeout(executor, (int) timeoutMs); 
 
       return networkTimeout;
    }

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -149,14 +149,14 @@ public HikariPool(HikariConfig configuration, String username, String password)
       addConnectionExecutor = createThreadPoolExecutor(configuration.getMaximumPoolSize(), "HikariCP connection filler (pool " + configuration.getPoolName() + ")", configuration.getThreadFactory(), new ThreadPoolExecutor.DiscardPolicy());
       closeConnectionExecutor = createThreadPoolExecutor(4, "HikariCP connection closer (pool " + configuration.getPoolName() + ")", configuration.getThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());
 
-      fillPool();
-
       long delayPeriod = Long.getLong("com.zaxxer.hikari.housekeeping.periodMs", TimeUnit.SECONDS.toMillis(30L));
       houseKeepingExecutorService = new ScheduledThreadPoolExecutor(1, configuration.getThreadFactory() != null ? configuration.getThreadFactory() : new DefaultThreadFactory("Hikari Housekeeping Timer (pool " + configuration.getPoolName() + ")", true));
       if (IS_JAVA7) {
          houseKeepingExecutorService.setRemoveOnCancelPolicy(true);
       }
       houseKeepingExecutorService.scheduleAtFixedRate(new HouseKeeper(), delayPeriod, delayPeriod, TimeUnit.MILLISECONDS);
+      
+      fillPool();
    }
 
    /**

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -148,12 +148,12 @@ public HikariPool(HikariConfig configuration, String username, String password)
       addConnectionExecutor = createThreadPoolExecutor(configuration.getMaximumPoolSize(), "HikariCP connection filler (pool " + configuration.getPoolName() + ")", configuration.getThreadFactory(), new ThreadPoolExecutor.DiscardPolicy());
       closeConnectionExecutor = createThreadPoolExecutor(4, "HikariCP connection closer (pool " + configuration.getPoolName() + ")", configuration.getThreadFactory(), new ThreadPoolExecutor.CallerRunsPolicy());
 
-      fillPool();
-
       long delayPeriod = Long.getLong("com.zaxxer.hikari.housekeeping.periodMs", TimeUnit.SECONDS.toMillis(30L));
       houseKeepingExecutorService = new ScheduledThreadPoolExecutor(1, configuration.getThreadFactory() != null ? configuration.getThreadFactory() : new DefaultThreadFactory("Hikari Housekeeping Timer (pool " + configuration.getPoolName() + ")", true));
       houseKeepingExecutorService.setRemoveOnCancelPolicy(true);
       houseKeepingExecutorService.scheduleAtFixedRate(new HouseKeeper(), delayPeriod, delayPeriod, TimeUnit.MILLISECONDS);
+
+      fillPool();
    }
 
    /**

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/metrics/CodaHaleShim.java
Patch:
@@ -69,6 +69,8 @@ private void loadOrShimCodahale()
       }
       catch (ClassNotFoundException e) {
          // OK, it is not present, we have to generate a shim
+         LOGGER.debug("com.codahale.metrics.MetricRegistry not found, generating stub");
+
          ClassPool classPool = new ClassPool();
          classPool.appendClassPath(new LoaderClassPath(this.getClass().getClassLoader()));
 

File: hikaricp/src/main/java/com/zaxxer/hikari/metrics/CodaHaleShim.java
Patch:
@@ -69,6 +69,8 @@ private void loadOrShimCodahale()
       }
       catch (ClassNotFoundException e) {
          // OK, it is not present, we have to generate a shim
+         LOGGER.debug("com.codahale.metrics.MetricRegistry not found, generating stub");
+
          ClassPool classPool = new ClassPool();
          classPool.appendClassPath(new LoaderClassPath(this.getClass().getClassLoader()));
 

File: hikaricp-java6/src/test/java/com/zaxxer/hikari/TestConnections.java
Patch:
@@ -245,6 +245,8 @@ public void testBackfill() throws Exception
 
       HikariDataSource ds = new HikariDataSource(config);
       try {
+         PoolUtilities.quietlySleep(250L);
+
          Assert.assertSame("Totals connections not as expected", 1, TestElf.getPool(ds).getTotalConnections());
          Assert.assertSame("Idle connections not as expected", 1, TestElf.getPool(ds).getIdleConnections());
 

File: hikaricp/src/test/java/com/zaxxer/hikari/TestConnections.java
Patch:
@@ -245,6 +245,8 @@ public void testBackfill() throws Exception
 
       HikariDataSource ds = new HikariDataSource(config);
       try {
+         PoolUtilities.quietlySleep(250L);
+
          Assert.assertSame("Totals connections not as expected", 1, TestElf.getPool(ds).getTotalConnections());
          Assert.assertSame("Idle connections not as expected", 1, TestElf.getPool(ds).getIdleConnections());
 

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -509,7 +509,7 @@ private boolean isConnectionAlive(final Connection connection, final long timeou
     */
    private void fillPool()
    {
-      if (configuration.getMinimumIdle() == 0) {
+      if (configuration.getMinimumIdle() > 0) {
          if (configuration.isInitializationFailFast() && !addConnection()) {
             throw new RuntimeException("Fail-fast during pool initialization", lastConnectionFailure.getAndSet(null));
          }

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -488,7 +488,7 @@ private boolean isConnectionAlive(final Connection connection, final long timeou
     */
    private void fillPool()
    {
-      if (configuration.getMinimumIdle() == 0) {
+      if (configuration.getMinimumIdle() > 0) {
          if (configuration.isInitializationFailFast() && !addConnection()) {
             throw new RuntimeException("Fail-fast during pool initialization", lastConnectionFailure.getAndSet(null));
          }

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -101,6 +101,7 @@ public HikariConfig()
       idleTimeout = IDLE_TIMEOUT;
       isAutoCommit = true;
       isJdbc4connectionTest = true;
+      isInitializationFailFast = true;
       minIdle = -1;
       maxPoolSize = 10;
       maxLifetime = MAX_LIFETIME;

File: hikaricp/src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -101,6 +101,7 @@ public HikariConfig()
       idleTimeout = IDLE_TIMEOUT;
       isAutoCommit = true;
       isJdbc4connectionTest = true;
+      isInitializationFailFast = true;
       minIdle = -1;
       maxPoolSize = 10;
       maxLifetime = MAX_LIFETIME;

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -474,7 +474,7 @@ private boolean isConnectionAlive(final Connection connection, final long timeou
    {
       try {
          final boolean timeoutEnabled = (configuration.getConnectionTimeout() != Integer.MAX_VALUE);
-         int timeoutSec = timeoutEnabled ? Math.max(1000, (int) timeoutMs) : 0;
+         int timeoutSec = timeoutEnabled ? (int) Math.max(1L, TimeUnit.MILLISECONDS.toSeconds(timeoutMs)) : 0;
 
          if (isJdbc4ConnectionTest) {
             return connection.isValid(timeoutSec);

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -457,7 +457,7 @@ private boolean isConnectionAlive(final Connection connection, final long timeou
    {
       try {
          final boolean timeoutEnabled = (configuration.getConnectionTimeout() != Integer.MAX_VALUE);
-         int timeoutSec = timeoutEnabled ? Math.max(1000, (int) timeoutMs) : 0;
+         int timeoutSec = timeoutEnabled ? (int) Math.max(1L, TimeUnit.MILLISECONDS.toSeconds(timeoutMs)) : 0;
 
          if (isJdbc4ConnectionTest) {
             return connection.isValid(timeoutSec);

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/HikariPoolMBean.java
Patch:
@@ -32,6 +32,4 @@ public interface HikariPoolMBean
    int getThreadsAwaitingConnection();
 
    void closeIdleConnections();
-
-   void dumpPoolState();
 }

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPoolMBean.java
Patch:
@@ -32,6 +32,4 @@ public interface HikariPoolMBean
    int getThreadsAwaitingConnection();
 
    void closeIdleConnections();
-
-   void dumpPoolState();
 }

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -24,9 +24,10 @@
 import static com.zaxxer.hikari.util.PoolUtilities.createThreadPoolExecutor;
 import static com.zaxxer.hikari.util.PoolUtilities.elapsedTimeMs;
 import static com.zaxxer.hikari.util.PoolUtilities.executeSqlAutoCommit;
+import static com.zaxxer.hikari.util.PoolUtilities.isJdbc41Compliant;
 import static com.zaxxer.hikari.util.PoolUtilities.quietlyCloseConnection;
 import static com.zaxxer.hikari.util.PoolUtilities.quietlySleep;
-import static com.zaxxer.hikari.util.PoolUtilities.isJdbc41Compliant;
+import static com.zaxxer.hikari.util.PoolUtilities.setQueryTimeout;
 
 import java.sql.Connection;
 import java.sql.SQLException;
@@ -495,7 +496,7 @@ private boolean isConnectionAlive(final Connection connection, final long timeou
 
          Statement statement = connection.createStatement();
          try {
-            statement.setQueryTimeout(timeoutSec);
+            setQueryTimeout(statement, timeoutSec);
             statement.executeQuery(configuration.getConnectionTestQuery());
          }
          finally {

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -23,9 +23,10 @@
 import static com.zaxxer.hikari.util.PoolUtilities.createThreadPoolExecutor;
 import static com.zaxxer.hikari.util.PoolUtilities.elapsedTimeMs;
 import static com.zaxxer.hikari.util.PoolUtilities.executeSqlAutoCommit;
+import static com.zaxxer.hikari.util.PoolUtilities.isJdbc41Compliant;
 import static com.zaxxer.hikari.util.PoolUtilities.quietlyCloseConnection;
 import static com.zaxxer.hikari.util.PoolUtilities.quietlySleep;
-import static com.zaxxer.hikari.util.PoolUtilities.isJdbc41Compliant;
+import static com.zaxxer.hikari.util.PoolUtilities.setQueryTimeout;
 
 import java.sql.Connection;
 import java.sql.SQLException;
@@ -477,7 +478,7 @@ private boolean isConnectionAlive(final Connection connection, final long timeou
          }
 
          try (Statement statement = connection.createStatement()) {
-            statement.setQueryTimeout(timeoutSec);
+            setQueryTimeout(statement, timeoutSec);
             statement.executeQuery(configuration.getConnectionTestQuery());
          }
 

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -668,7 +668,7 @@ else if (driverClassName != null && dataSourceClassName != null) {
          logger.error("both driverClassName and dataSourceClassName are specified, one or the other should be used");
          throw new IllegalStateException("both driverClassName and dataSourceClassName are specified, one or the other should be used");
       }
-      else if (driverClassName != null && jdbcUrl != null) {
+      else if (jdbcUrl != null) {
          // OK
       }
       else if (dataSource == null && dataSourceClassName == null) {

File: hikaricp/src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -668,7 +668,7 @@ else if (driverClassName != null && dataSourceClassName != null) {
          logger.error("both driverClassName and dataSourceClassName are specified, one or the other should be used");
          throw new IllegalStateException("both driverClassName and dataSourceClassName are specified, one or the other should be used");
       }
-      else if (driverClassName != null && jdbcUrl != null) {
+      else if (jdbcUrl != null) {
          // OK
       }
       else if (dataSource == null && dataSourceClassName == null) {

File: hikaricp-java6/src/test/java/com/zaxxer/hikari/MiscTest.java
Patch:
@@ -108,7 +108,7 @@ public void testLeakDetection() throws SQLException
          TestElf.setSlf4jTargetStream(LeakTask.class, ps);
 
          Connection connection = ds.getConnection();
-         PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(4));
+         PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(5));
          ps.close();
          connection.close();
          String s = new String(baos.toByteArray());

File: hikaricp/src/test/java/com/zaxxer/hikari/MiscTest.java
Patch:
@@ -108,7 +108,7 @@ public void testLeakDetection() throws SQLException
          TestElf.setSlf4jTargetStream(LeakTask.class, ps);
 
          Connection connection = ds.getConnection();
-         PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(4));
+         PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(5));
          ps.close();
          connection.close();
          String s = new String(baos.toByteArray());

File: hikaricp-java6/src/test/java/com/zaxxer/hikari/MiscTest.java
Patch:
@@ -112,6 +112,7 @@ public void testLeakDetection() throws SQLException
          ps.close();
          connection.close();
          String s = new String(baos.toByteArray());
+         Assert.assertNotNull("Exception string was null", s);
          Assert.assertTrue(s.contains("Connection leak detection"));
       }
       finally

File: hikaricp/src/test/java/com/zaxxer/hikari/MiscTest.java
Patch:
@@ -112,6 +112,7 @@ public void testLeakDetection() throws SQLException
          ps.close();
          connection.close();
          String s = new String(baos.toByteArray());
+         Assert.assertNotNull("Exception string was null", s);
          Assert.assertTrue(s.contains("Connection leak detection"));
       }
       finally

File: hikaricp-java6/src/test/java/com/zaxxer/hikari/MiscTest.java
Patch:
@@ -108,7 +108,7 @@ public void testLeakDetection() throws SQLException
          TestElf.setSlf4jTargetStream(LeakTask.class, ps);
 
          Connection connection = ds.getConnection();
-         PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(3));
+         PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(4));
          ps.close();
          connection.close();
          String s = new String(baos.toByteArray());

File: hikaricp/src/test/java/com/zaxxer/hikari/MiscTest.java
Patch:
@@ -108,7 +108,7 @@ public void testLeakDetection() throws SQLException
          TestElf.setSlf4jTargetStream(LeakTask.class, ps);
 
          Connection connection = ds.getConnection();
-         PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(3));
+         PoolUtilities.quietlySleep(TimeUnit.SECONDS.toMillis(4));
          ps.close();
          connection.close();
          String s = new String(baos.toByteArray());

File: hikaricp-java6/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java
Patch:
@@ -83,7 +83,7 @@ public void run()
         }
         catch (SQLException e)
         {
-            Assert.fail("Should not have timed out.");
+            Assert.fail("Should not have timed out: " + e.getMessage());
         }
         finally
         {

File: hikaricp/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java
Patch:
@@ -83,7 +83,7 @@ public void run()
         }
         catch (SQLException e)
         {
-            Assert.fail("Should not have timed out.");
+            Assert.fail("Should not have timed out: " + e.getMessage());
         }
         finally
         {

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -354,7 +354,7 @@ public long getIdleTimeout()
    @Override
    public void setIdleTimeout(long idleTimeoutMs)
    {
-      if (idleTimeout < 0) {
+      if (idleTimeoutMs < 0) {
          throw new IllegalArgumentException("idleTimeout cannot be negative");
       }
       this.idleTimeout = idleTimeoutMs;
@@ -506,8 +506,8 @@ public int getMaximumPoolSize()
    @Override
    public void setMaximumPoolSize(int maxPoolSize)
    {
-      if (maxPoolSize < 0) {
-         throw new IllegalArgumentException("maxPoolSize cannot be negative");
+      if (maxPoolSize < 1) {
+         throw new IllegalArgumentException("maxPoolSize cannot be less than 1");
       }
       this.maxPoolSize = maxPoolSize;
    }

File: hikaricp/src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -354,7 +354,7 @@ public long getIdleTimeout()
    @Override
    public void setIdleTimeout(long idleTimeoutMs)
    {
-      if (idleTimeout < 0) {
+      if (idleTimeoutMs < 0) {
          throw new IllegalArgumentException("idleTimeout cannot be negative");
       }
       this.idleTimeout = idleTimeoutMs;
@@ -506,8 +506,8 @@ public int getMaximumPoolSize()
    @Override
    public void setMaximumPoolSize(int maxPoolSize)
    {
-      if (maxPoolSize < 0) {
-         throw new IllegalArgumentException("maxPoolSize cannot be negative");
+      if (maxPoolSize < 1) {
+         throw new IllegalArgumentException("maxPoolSize cannot be less than 1");
       }
       this.maxPoolSize = maxPoolSize;
    }

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/util/PoolUtilities.java
Patch:
@@ -5,12 +5,15 @@
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.sql.Statement;
+import java.util.Properties;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.AbstractQueuedLongSynchronizer;
 
+import javax.sql.DataSource;
+
 public final class PoolUtilities
 {
    public static final boolean IS_JAVA7;

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -250,6 +250,7 @@ public void shutdown() throws InterruptedException
          isShutdown = true;
          LOGGER.info("HikariCP pool {} is shutting down.", configuration.getPoolName());
 
+         connectionBag.close();
          logPoolState("Before shutdown ");
          houseKeepingExecutorService.shutdownNow();
          addConnectionExecutor.shutdownNow();

File: hikaricp-java6/src/test/java/com/zaxxer/hikari/ShutdownTest.java
Patch:
@@ -167,7 +167,7 @@ public void testShutdown4() throws SQLException
          PoolUtilities.quietlySleep(250);
       }
 
-      Assert.assertSame("Thread was leaked", 0, threadCount());
+      Assert.assertSame("Unreleased connections after shutdown", 0, TestElf.getPool(ds).getTotalConnections());
    }
 
    @Test

File: hikaricp-java6/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java
Patch:
@@ -253,7 +253,7 @@ public void testConnectionIdleFill() throws Exception
             Connection connection6 = ds.getConnection();
             Connection connection7 = ds.getConnection();
     
-            Thread.sleep(1250);
+            Thread.sleep(1350);
     
             Assert.assertSame("Totals connections not as expected", 10, TestElf.getPool(ds).getTotalConnections());
             Assert.assertSame("Idle connections not as expected", 3, TestElf.getPool(ds).getIdleConnections());

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -247,6 +247,7 @@ public void shutdown() throws InterruptedException
          isShutdown = true;
          LOGGER.info("HikariCP pool {} is shutting down.", configuration.getPoolName());
 
+         connectionBag.close();
          logPoolState("Before shutdown ");
          houseKeepingExecutorService.shutdownNow();
          addConnectionExecutor.shutdownNow();

File: hikaricp/src/test/java/com/zaxxer/hikari/ShutdownTest.java
Patch:
@@ -167,7 +167,7 @@ public void testShutdown4() throws SQLException
          PoolUtilities.quietlySleep(250);
       }
 
-      Assert.assertSame("Thread was leaked", 0, threadCount());
+      Assert.assertSame("Unreleased connections after shutdown", 0, TestElf.getPool(ds).getTotalConnections());
    }
 
    @Test

File: hikaricp/src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java
Patch:
@@ -253,7 +253,7 @@ public void testConnectionIdleFill() throws Exception
             Connection connection6 = ds.getConnection();
             Connection connection7 = ds.getConnection();
     
-            Thread.sleep(1250);
+            Thread.sleep(1350);
     
             Assert.assertSame("Totals connections not as expected", 10, TestElf.getPool(ds).getTotalConnections());
             Assert.assertSame("Idle connections not as expected", 3, TestElf.getPool(ds).getIdleConnections());

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -210,7 +210,7 @@ public Connection getConnection() throws SQLException
    /**
     * Release a connection back to the pool, or permanently close it if it is broken.
     *
-    * @param connectionProxy the connection to release back to the pool
+    * @param bagEntry the PoolBagEntry to release back to the pool
     * @param isBroken true if the connection was detected as broken
     */
    public void releaseConnection(final PoolBagEntry bagEntry, final boolean isBroken)

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java
Patch:
@@ -96,6 +96,8 @@ public ConcurrentBag()
 
    /**
     * Construct a ConcurrentBag with the specified listener.
+    *
+    * @param listener the IBagStateListener to attach to this bag
     */
    public ConcurrentBag(IBagStateListener listener)
    {

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -207,7 +207,7 @@ public Connection getConnection() throws SQLException
    /**
     * Release a connection back to the pool, or permanently close it if it is broken.
     *
-    * @param connectionProxy the connection to release back to the pool
+    * @param bagEntry the PoolBagEntry to release back to the pool
     * @param isBroken true if the connection was detected as broken
     */
    public void releaseConnection(final PoolBagEntry bagEntry, final boolean isBroken)

File: hikaricp/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -108,8 +108,7 @@ public final void captureStack(long leakDetectionThreshold, ScheduledExecutorSer
       executorService.schedule(leakTask, leakDetectionThreshold, TimeUnit.MILLISECONDS);
    }
 
-   /** {@inheritDoc} 
-    * @return */
+   /** {@inheritDoc} */
    @Override
    public final SQLException checkException(SQLException sqle)
    {

File: hikaricp/src/main/java/com/zaxxer/hikari/util/ConcurrentBag.java
Patch:
@@ -95,6 +95,8 @@ public ConcurrentBag()
 
    /**
     * Construct a ConcurrentBag with the specified listener.
+    *
+    * @param listener the IBagStateListener to attach to this bag
     */
    public ConcurrentBag(IBagStateListener listener)
    {

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -473,7 +473,7 @@ public final void setCatalog(String catalog) throws SQLException
       checkClosed();
       try {
          delegate.setCatalog(catalog);
-         isCatalogDirty = !catalog.equals(parentPool.catalog);
+         isCatalogDirty = (catalog != null && !catalog.equals(parentPool.catalog)) || (catalog == null && parentPool.catalog != null);
       }
       catch (SQLException e) {
          throw checkException(e);

File: hikaricp/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -474,7 +474,7 @@ public final void setCatalog(String catalog) throws SQLException
       checkClosed();
       try {
          delegate.setCatalog(catalog);
-         isCatalogDirty = !catalog.equals(parentPool.catalog);
+         isCatalogDirty = (catalog != null && !catalog.equals(parentPool.catalog)) || (catalog == null && parentPool.catalog != null);
       }
       catch (SQLException e) {
          throw checkException(e);

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/proxy/JavassistProxyFactory.java
Patch:
@@ -81,15 +81,15 @@ private JavassistProxyFactory()
 
       try {
          // Connection is special, it has a checkClosed() call at the beginning
-         String methodBody = "{ checkClosed(); try { return delegate.method($$); } catch (SQLException e) { checkException(e); throw e;} }";
+         String methodBody = "{ checkClosed(); try { return delegate.method($$); } catch (SQLException e) { throw checkException(e); } }";
          generateProxyClass(Connection.class, ConnectionProxy.class, methodBody);
 
          // Cast is not needed for these
-         methodBody = "{ try { return delegate.method($$); } catch (SQLException e) { checkException(e); throw e;} }";
+         methodBody = "{ try { return delegate.method($$); } catch (SQLException e) { throw checkException(e); } }";
          generateProxyClass(Statement.class, StatementProxy.class, methodBody);
 
          // For these we have to cast the delegate
-         methodBody = "{ try { return ((cast) delegate).method($$); } catch (SQLException e) { checkException(e); throw e;} }";
+         methodBody = "{ try { return ((cast) delegate).method($$); } catch (SQLException e) { throw checkException(e); } }";
          generateProxyClass(PreparedStatement.class, PreparedStatementProxy.class, methodBody);
          generateProxyClass(CallableStatement.class, CallableStatementProxy.class, methodBody);
       }

File: hikaricp/src/main/java/com/zaxxer/hikari/proxy/JavassistProxyFactory.java
Patch:
@@ -81,15 +81,15 @@ private JavassistProxyFactory()
 
       try {
          // Connection is special, it has a checkClosed() call at the beginning
-         String methodBody = "{ checkClosed(); try { return delegate.method($$); } catch (SQLException e) { checkException(e); throw e;} }";
+         String methodBody = "{ checkClosed(); try { return delegate.method($$); } catch (SQLException e) { throw checkException(e); } }";
          generateProxyClass(Connection.class, ConnectionProxy.class, methodBody);
 
          // Cast is not needed for these
-         methodBody = "{ try { return delegate.method($$); } catch (SQLException e) { checkException(e); throw e;} }";
+         methodBody = "{ try { return delegate.method($$); } catch (SQLException e) { throw checkException(e); } }";
          generateProxyClass(Statement.class, StatementProxy.class, methodBody);
 
          // For these we have to cast the delegate
-         methodBody = "{ try { return ((cast) delegate).method($$); } catch (SQLException e) { checkException(e); throw e;} }";
+         methodBody = "{ try { return ((cast) delegate).method($$); } catch (SQLException e) { throw checkException(e); } }";
          generateProxyClass(PreparedStatement.class, PreparedStatementProxy.class, methodBody);
          generateProxyClass(CallableStatement.class, CallableStatementProxy.class, methodBody);
       }

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -53,6 +53,7 @@
 import com.zaxxer.hikari.util.ConcurrentBag.IBagStateListener;
 import com.zaxxer.hikari.util.DefaultThreadFactory;
 import com.zaxxer.hikari.util.DriverDataSource;
+import com.zaxxer.hikari.util.PoolUtilities;
 import com.zaxxer.hikari.util.PropertyBeanSetter;
 
 /**
@@ -129,7 +130,7 @@ public HikariPool(HikariConfig configuration, String username, String password)
       this.isRegisteredMbeans = configuration.isRegisterMbeans();
       this.isJdbc4ConnectionTest = configuration.isJdbc4ConnectionTest();
       this.leakDetectionThreshold = configuration.getLeakDetectionThreshold();
-      this.transactionIsolation = configuration.getTransactionIsolation();
+      this.transactionIsolation = PoolUtilities.getTransactionIsolation(configuration.getTransactionIsolation());
       this.isRecordMetrics = configuration.isRecordMetrics();
       this.metricsTracker = MetricsFactory.createMetricsTracker((isRecordMetrics ? configuration.getMetricsTrackerClassName()
             : "com.zaxxer.hikari.metrics.MetricsTracker"), configuration.getPoolName());

File: hikaricp-java6/src/test/java/com/zaxxer/hikari/ConnectionStateTest.java
Patch:
@@ -6,6 +6,8 @@
 import org.junit.Assert;
 import org.junit.Test;
 
+import com.zaxxer.hikari.util.PoolUtilities;
+
 public class ConnectionStateTest
 {
     @Test
@@ -74,7 +76,7 @@ public void testIsolation() throws Exception
         config.setTransactionIsolation("TRANSACTION_REPEATABLE_READ");
         config.validate();
         
-        int transactionIsolation = config.getTransactionIsolation();
+        int transactionIsolation = PoolUtilities.getTransactionIsolation(config.getTransactionIsolation());
         Assert.assertSame(Connection.TRANSACTION_REPEATABLE_READ, transactionIsolation);
     }
 

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -52,6 +52,7 @@
 import com.zaxxer.hikari.util.ConcurrentBag.IBagStateListener;
 import com.zaxxer.hikari.util.DefaultThreadFactory;
 import com.zaxxer.hikari.util.DriverDataSource;
+import com.zaxxer.hikari.util.PoolUtilities;
 import com.zaxxer.hikari.util.PropertyBeanSetter;
 
 /**
@@ -128,7 +129,7 @@ public HikariPool(HikariConfig configuration, String username, String password)
       this.isRegisteredMbeans = configuration.isRegisterMbeans();
       this.isJdbc4ConnectionTest = configuration.isJdbc4ConnectionTest();
       this.leakDetectionThreshold = configuration.getLeakDetectionThreshold();
-      this.transactionIsolation = configuration.getTransactionIsolation();
+      this.transactionIsolation = PoolUtilities.getTransactionIsolation(configuration.getTransactionIsolation());
       this.isRecordMetrics = configuration.isRecordMetrics();
       this.metricsTracker = MetricsFactory.createMetricsTracker((isRecordMetrics ? configuration.getMetricsTrackerClassName()
             : "com.zaxxer.hikari.metrics.MetricsTracker"), configuration.getPoolName());

File: hikaricp/src/test/java/com/zaxxer/hikari/ConnectionStateTest.java
Patch:
@@ -6,6 +6,8 @@
 import org.junit.Assert;
 import org.junit.Test;
 
+import com.zaxxer.hikari.util.PoolUtilities;
+
 public class ConnectionStateTest
 {
     @Test
@@ -74,7 +76,7 @@ public void testIsolation() throws Exception
         config.setTransactionIsolation("TRANSACTION_REPEATABLE_READ");
         config.validate();
         
-        int transactionIsolation = config.getTransactionIsolation();
+        int transactionIsolation = PoolUtilities.getTransactionIsolation(config.getTransactionIsolation());
         Assert.assertSame(Connection.TRANSACTION_REPEATABLE_READ, transactionIsolation);
     }
 

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/util/FastList.java
Patch:
@@ -86,9 +86,9 @@ public T get(int index)
    }
 
    /**
-    * This remove method is most efficient when the element being removed
-    * is the last element.  Equality is identity based, not equals() based.
-    * Only the first matching element is removed.
+    * Remove the last element from the list.  No bound check is performed, so if this
+    * method is called on an empty list and ArrayIndexOutOfBounds exception will be
+    * thrown.
     *
     * @return the last element of the list
     */

File: hikaricp/src/main/java/com/zaxxer/hikari/util/FastList.java
Patch:
@@ -86,9 +86,9 @@ public T get(int index)
    }
 
    /**
-    * This remove method is most efficient when the element being removed
-    * is the last element.  Equality is identity based, not equals() based.
-    * Only the first matching element is removed.
+    * Remove the last element from the list.  No bound check is performed, so if this
+    * method is called on an empty list and ArrayIndexOutOfBounds exception will be
+    * thrown.
     *
     * @return the last element of the list
     */

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -484,6 +484,7 @@ private void abortActiveConnections() throws InterruptedException
       for (IHikariConnectionProxy connectionProxy : connectionBag.values(STATE_IN_USE)) {
          try {
             connectionProxy.abort(assassinExecutor);
+            totalConnections.decrementAndGet();
          }
          catch (AbstractMethodError e) {
             quietlyCloseConnection(connectionProxy);
@@ -492,7 +493,6 @@ private void abortActiveConnections() throws InterruptedException
             quietlyCloseConnection(connectionProxy);
          }
          finally {
-            totalConnections.decrementAndGet();
             try {
                connectionBag.remove(connectionProxy);
             }

File: hikaricp-java6/src/test/java/com/zaxxer/hikari/mocks/StubConnection.java
Patch:
@@ -402,6 +402,7 @@ public String getSchema() throws SQLException
     /** {@inheritDoc} */
     public void abort(Executor executor) throws SQLException
     {
+       throw new SQLException("Intentianal exception during abort");
     }
 
     /** {@inheritDoc} */

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -473,12 +473,12 @@ private void abortActiveConnections() throws InterruptedException
       connectionBag.values(STATE_IN_USE).parallelStream().forEach(connectionProxy -> {
          try {
             connectionProxy.abort(assassinExecutor);
+            totalConnections.decrementAndGet();
          }
          catch (SQLException | AbstractMethodError e) {
             quietlyCloseConnection(connectionProxy);
          }
          finally {
-            totalConnections.decrementAndGet();
             try {
                connectionBag.remove(connectionProxy);
             }

File: hikaricp/src/test/java/com/zaxxer/hikari/mocks/StubConnection.java
Patch:
@@ -402,6 +402,7 @@ public String getSchema() throws SQLException
     /** {@inheritDoc} */
     public void abort(Executor executor) throws SQLException
     {
+       throw new SQLException("Intentianal exception during abort");
     }
 
     /** {@inheritDoc} */

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -566,7 +566,9 @@ public void run()
 
          logPoolState("After cleanup ");
 
-         addBagItem(); // Try to maintain minimum connections
+         if (configuration.getMinimumIdle() > 0) {
+             addBagItem(); // Try to maintain minimum connections
+          }
       }
    }
 }

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -555,7 +555,9 @@ public void run()
 
          logPoolState("After cleanup ");
 
-         addBagItem(); // Try to maintain minimum connections
+         if (configuration.getMinimumIdle() > 0) {
+            addBagItem(); // Try to maintain minimum connections
+         }
       }
    }
 }

File: hikaricp-java6/src/test/java/com/zaxxer/hikari/TestFastList.java
Patch:
@@ -86,7 +86,7 @@ class Bar extends Foo {
           
        }
 
-       FastList<Base> list = new FastList<>(Base.class, 2);
+       FastList<Base> list = new FastList<Base>(Base.class, 2);
        list.add(new Foo());
        list.add(new Foo());
        list.add(new Bar());

File: hikaricp/src/main/java/com/zaxxer/hikari/HikariDataSource.java
Patch:
@@ -273,13 +273,13 @@ public boolean equals(Object obj)
          if (username != null && !username.equals(otherKey.username)) {
             return false;
          }
-         else if (!username.equals(otherKey.username)) {
+         else if (username != otherKey.username) {
             return false;
          }
          else if (password != null && !password.equals(otherKey.password)) {
             return false;
          }
-         else if (!password.equals(otherKey.password)) {
+         else if (password != otherKey.password) {
             return false;
          }
 

File: hikaricp/src/main/java/com/zaxxer/hikari/HikariDataSource.java
Patch:
@@ -273,13 +273,13 @@ public boolean equals(Object obj)
          if (username != null && !username.equals(otherKey.username)) {
             return false;
          }
-         else if (!username.equals(otherKey.username)) {
+         else if (username != otherKey.username) {
             return false;
          }
          else if (password != null && !password.equals(otherKey.password)) {
             return false;
          }
-         else if (!password.equals(otherKey.password)) {
+         else if (password != otherKey.password) {
             return false;
          }
 

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -170,7 +170,7 @@ public Connection getConnection() throws SQLException
 
             if (now > connection.getExpirationTime() || (now - connection.getLastAccess() > 1000L && !isConnectionAlive(connection, timeout))) {
                closeConnection(connection); // Throw away the dead connection and try again
-               timeout -= elapsedTimeMs(start);
+               timeout = connectionTimeout - elapsedTimeMs(start);
                continue;
             }
             else if (leakDetectionThreshold != 0) {

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -169,7 +169,7 @@ public Connection getConnection() throws SQLException
 
             if (now > connection.getExpirationTime() || (now - connection.getLastAccess() > 1000L && !isConnectionAlive(connection, timeout))) {
                closeConnection(connection); // Throw away the dead connection and try again
-               timeout -= elapsedTimeMs(start);
+               timeout = connectionTimeout - elapsedTimeMs(start);
                continue;
             }
             else if (leakDetectionThreshold != 0) {

File: hikaricp-java6/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -170,7 +170,7 @@ public Connection getConnection() throws SQLException
 
             if (now > connection.getExpirationTime() || (now - connection.getLastAccess() > 1000L && !isConnectionAlive(connection, timeout))) {
                closeConnection(connection); // Throw away the dead connection and try again
-               timeout -= elapsedTimeMs(start);
+               timeout = connectionTimeout - elapsedTimeMs(start);
                continue;
             }
             else if (leakDetectionThreshold != 0) {

File: hikaricp/src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -169,7 +169,7 @@ public Connection getConnection() throws SQLException
 
             if (now > connection.getExpirationTime() || (now - connection.getLastAccess() > 1000L && !isConnectionAlive(connection, timeout))) {
                closeConnection(connection); // Throw away the dead connection and try again
-               timeout -= elapsedTimeMs(start);
+               timeout = connectionTimeout - elapsedTimeMs(start);
                continue;
             }
             else if (leakDetectionThreshold != 0) {

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -546,7 +546,7 @@ public int getMinimumIdle()
    @Override
    public void setMinimumIdle(int minIdle)
    {
-      if (minIdle < 0 || minIdle > maxPoolSize) {
+      if (minIdle < 0) {
          throw new IllegalArgumentException("maxPoolSize cannot be negative or greater than maximumPoolSize");
       }
       this.minIdle = minIdle;
@@ -696,7 +696,7 @@ else if (connectionTimeout < TimeUnit.MILLISECONDS.toMillis(250)) {
          connectionTimeout = CONNECTION_TIMEOUT;
       }
 
-      if (minIdle < 0) {
+      if (minIdle < 0 || minIdle > maxPoolSize) {
          minIdle = maxPoolSize;
       }
 

File: hikaricp-java6/src/test/java/com/zaxxer/hikari/TestConnections.java
Patch:
@@ -259,8 +259,8 @@ public void testBackfill() throws Exception
             connection = ds.getConnection();
             connection.close();
 
-            Assert.assertTrue("Totals connections not as expected", TestElf.getPool(ds).getTotalConnections() > 1);
-            Assert.assertTrue("Idle connections not as expected", TestElf.getPool(ds).getIdleConnections() > 1);
+            Assert.assertTrue("Totals connections not as expected", TestElf.getPool(ds).getTotalConnections() > 0);
+            Assert.assertTrue("Idle connections not as expected", TestElf.getPool(ds).getIdleConnections() > 0);
         }
         finally
         {

File: hikaricp/src/test/java/com/zaxxer/hikari/TestConnections.java
Patch:
@@ -259,8 +259,8 @@ public void testBackfill() throws Exception
             connection = ds.getConnection();
             connection.close();
 
-            Assert.assertTrue("Totals connections not as expected", TestElf.getPool(ds).getTotalConnections() > 1);
-            Assert.assertTrue("Idle connections not as expected", TestElf.getPool(ds).getIdleConnections() > 1);
+            Assert.assertTrue("Totals connections not as expected", TestElf.getPool(ds).getTotalConnections() > 0);
+            Assert.assertTrue("Idle connections not as expected", TestElf.getPool(ds).getIdleConnections() > 0);
         }
         finally
         {

File: hikaricp-java6/src/test/java/com/zaxxer/hikari/TestConnections.java
Patch:
@@ -259,8 +259,8 @@ public void testBackfill() throws Exception
             connection = ds.getConnection();
             connection.close();
 
-            Assert.assertSame("Totals connections not as expected", 1, TestElf.getPool(ds).getTotalConnections());
-            Assert.assertSame("Idle connections not as expected", 1, TestElf.getPool(ds).getIdleConnections());
+            Assert.assertTrue("Totals connections not as expected", TestElf.getPool(ds).getTotalConnections() > 1);
+            Assert.assertTrue("Idle connections not as expected", TestElf.getPool(ds).getIdleConnections() > 1);
         }
         finally
         {

File: hikaricp/src/test/java/com/zaxxer/hikari/TestConnections.java
Patch:
@@ -259,8 +259,8 @@ public void testBackfill() throws Exception
             connection = ds.getConnection();
             connection.close();
 
-            Assert.assertSame("Totals connections not as expected", 1, TestElf.getPool(ds).getTotalConnections());
-            Assert.assertSame("Idle connections not as expected", 1, TestElf.getPool(ds).getIdleConnections());
+            Assert.assertTrue("Totals connections not as expected", TestElf.getPool(ds).getTotalConnections() > 1);
+            Assert.assertTrue("Idle connections not as expected", TestElf.getPool(ds).getIdleConnections() > 1);
         }
         finally
         {

File: src/main/java/com/zaxxer/hikari/metrics/IMetricsTracker.java
Patch:
@@ -23,7 +23,7 @@
 public interface IMetricsTracker
 {
    /**
-    * This method is called when a connection request starts.  The {@#MetricsContext.stop()}
+    * This method is called when a connection request starts.  The {@link MetricsContext#stop()}
     * method will be called at the completion of the connection request, whether or not an
     * exception occurred.
     * 
@@ -43,7 +43,7 @@ public interface IMetricsTracker
    /**
     * A base instance of a MetricsContext.  Classes extending this class should exhibit the
     * behavior of "starting" a timer upon contruction, and "stopping" the timer when the
-    * {@#stop()} method is called.
+    * {@link MetricsContext#stop()} method is called.
     *
     * @author Brett Wooldridge
     */

File: src/main/java/com/zaxxer/hikari/metrics/CodaHaleMetricsTracker.java
Patch:
@@ -46,7 +46,7 @@ public void recordConnectionUsage(long usageMilleseconds)
         connectionUsage.update(usageMilleseconds);
     }
 
-    public static final class Context extends MetricsTracker.Context
+    public static final class Context extends MetricsContext
     {
         Timer.Context innerContext;
 

File: src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -58,7 +58,7 @@ public abstract class ConnectionProxy implements IHikariConnectionProxy
     private boolean forceClose;
     private boolean isAutoCommitDirty;
     private boolean isCatalogDirty;
-    private volatile boolean isClosed;
+    private boolean isClosed;
     private boolean isReadOnlyDirty;
     private boolean isTransactionIsolationDirty;
     private volatile long lastAccess;

File: src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -58,7 +58,7 @@ public abstract class ConnectionProxy implements IHikariConnectionProxy
     private boolean forceClose;
     private boolean isAutoCommitDirty;
     private boolean isCatalogDirty;
-    private volatile boolean isClosed;
+    private boolean isClosed;
     private boolean isReadOnlyDirty;
     private boolean isTransactionIsolationDirty;
     private volatile long lastAccess;

File: src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -64,7 +64,6 @@ public abstract class ConnectionProxy implements IHikariConnectionProxy
     private volatile long lastAccess;
     private long uncloseTime;
 
-    private StackTraceElement[] leakTrace;
     private TimerTask leakTask;
 
     private final int hashCode;
@@ -126,7 +125,7 @@ public final int hashCode()
     public final void captureStack(long leakDetectionThreshold, Timer scheduler)
     {
         StackTraceElement[] trace = Thread.currentThread().getStackTrace();
-        leakTrace = new StackTraceElement[trace.length - 4];
+        StackTraceElement[] leakTrace = new StackTraceElement[trace.length - 4];
         System.arraycopy(trace, 4, leakTrace, 0, leakTrace.length);
 
         leakTask = new LeakTask(leakTrace, leakDetectionThreshold);

File: src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -58,7 +58,7 @@ public abstract class ConnectionProxy implements IHikariConnectionProxy
     private boolean forceClose;
     private boolean isAutoCommitDirty;
     private boolean isCatalogDirty;
-    private boolean isClosed;
+    private volatile boolean isClosed;
     private boolean isReadOnlyDirty;
     private boolean isTransactionIsolationDirty;
     private volatile long lastAccess;

File: src/main/java/com/zaxxer/hikari/HikariDataSource.java
Patch:
@@ -190,7 +190,7 @@ public <T> T unwrap(Class<T> iface) throws SQLException
     @Override
     public boolean isWrapperFor(Class<?> iface) throws SQLException
     {
-        return (pool != null & pool.getDataSource().getClass().isAssignableFrom(iface));
+        return (pool != null && pool.getDataSource().getClass().isAssignableFrom(iface));
     }
 
     /**

File: src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -64,7 +64,6 @@ public abstract class ConnectionProxy implements IHikariConnectionProxy
     private volatile long lastAccess;
     private long uncloseTime;
 
-    private StackTraceElement[] leakTrace;
     private TimerTask leakTask;
 
     private final int hashCode;
@@ -126,7 +125,7 @@ public final int hashCode()
     public final void captureStack(long leakDetectionThreshold, Timer scheduler)
     {
         StackTraceElement[] trace = Thread.currentThread().getStackTrace();
-        leakTrace = new StackTraceElement[trace.length - 4];
+        StackTraceElement[] leakTrace = new StackTraceElement[trace.length - 4];
         System.arraycopy(trace, 4, leakTrace, 0, leakTrace.length);
 
         leakTask = new LeakTask(leakTrace, leakDetectionThreshold);

File: src/main/java/com/zaxxer/hikari/HikariDataSource.java
Patch:
@@ -190,7 +190,7 @@ public <T> T unwrap(Class<T> iface) throws SQLException
     @Override
     public boolean isWrapperFor(Class<?> iface) throws SQLException
     {
-        return (pool != null & pool.getDataSource().getClass().isAssignableFrom(iface));
+        return (pool != null && pool.getDataSource().getClass().isAssignableFrom(iface));
     }
 
     /**

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -197,6 +197,7 @@ else if (leakDetectionThreshold != 0)
      * Release a connection back to the pool, or permanently close it if it is broken.
      *
      * @param connectionProxy the connection to release back to the pool
+     * @param isBroken true if the connection was detected as broken
      */
     public void releaseConnection(final IHikariConnectionProxy connectionProxy, final boolean isBroken)
     {

File: src/main/java/com/zaxxer/hikari/proxy/IHikariConnectionProxy.java
Patch:
@@ -18,6 +18,7 @@
 
 import java.sql.Connection;
 import java.sql.SQLException;
+import java.sql.Statement;
 import java.util.Timer;
 
 import com.zaxxer.hikari.util.ConcurrentBag.IBagManagable;
@@ -101,5 +102,5 @@ public interface IHikariConnectionProxy extends Connection, IBagManagable
      *
      * @param statement the Statement to remove from tracking
      */
-    void untrackStatement(Object statement);
+    void untrackStatement(Statement statement);
 }

File: src/main/java/com/zaxxer/hikari/proxy/ProxyFactory.java
Patch:
@@ -41,6 +41,7 @@ private ProxyFactory()
      *
      * @param pool the {@link HikariPool} that will own this proxy
      * @param connection the {@link Connection} that will be wrapped by this proxy
+     * @param maxLifeTime the lifetime of the connection
      * @param defaultIsolationLevel the default transaction isolation level of the underlying {@link Connection}
      * @param defaultAutoCommit the default auto-commit state of the underlying {@link Connection}
      * @param defaultIReadOnly the default readOnly state of the underlying {@link Connection}

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -146,7 +146,6 @@ public void setAcquireIncrement(int acquireIncrement)
         LOGGER.warn("The acquireIncrement property has been retired, remove it from your pool configuration to avoid this warning.");
     }
 
-    /** {@inheritDoc} */
     @Deprecated
     public void setAcquireRetries(int acquireRetries)
     {

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -295,7 +295,7 @@ public void run()
                 int sleepBackoff = 200;
                 final int maxPoolSize = configuration.getMaximumPoolSize();
                 final int minIdle = configuration.getMinimumIdle();
-                while (totalConnections.get() < maxPoolSize && (minIdle == 0 || getIdleConnections() < minIdle))
+                while (!isShutdown && totalConnections.get() < maxPoolSize && (minIdle == 0 || getIdleConnections() < minIdle))
                 {
                     if (!addConnection())
                     {

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -295,7 +295,7 @@ public void run()
                 int sleepBackoff = 200;
                 final int maxPoolSize = configuration.getMaximumPoolSize();
                 final int minIdle = configuration.getMinimumIdle();
-                while (totalConnections.get() < maxPoolSize && (minIdle == 0 || getIdleConnections() < minIdle))
+                while (!isShutdown && totalConnections.get() < maxPoolSize && (minIdle == 0 || getIdleConnections() < minIdle))
                 {
                     if (!addConnection())
                     {

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -97,7 +97,6 @@ public HikariConfig()
         minIdle = -1;
         maxPoolSize = 10;
         maxLifetime = MAX_LIFETIME;
-        poolName = "HikariPool-" + poolNumber++;
         isRecordMetrics = false;
         transactionIsolation = -1;
     }
@@ -682,6 +681,8 @@ else if (!isJdbc4connectionTest)
                 throw new IllegalArgumentException("Invalid transaction isolation value: " + transactionIsolationName);
             }
         }
+
+        poolName = "HikariPool-" + poolNumber++;
     }
 
     private void validateNumerics()

File: src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -329,7 +329,7 @@ public final void close() throws SQLException
             finally
             {
                 lastAccess = System.currentTimeMillis();
-                parentPool.releaseConnection(this);
+                parentPool.releaseConnection(this, forceClose);
             }
         }
     }

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -127,7 +127,7 @@ public HikariPool(HikariConfig configuration, String username, String password)
             HikariMBeanElf.registerMBeans(configuration, this);
         }
 
-        houseKeepingTimer = new Timer("Hikari Housekeeping Timer", true);
+        houseKeepingTimer = new Timer("Hikari Housekeeping Timer (pool " + configuration.getPoolName() + ")", true);
 
         addConnectionExecutor = PoolUtilities.createThreadPoolExecutor(configuration.getMaximumPoolSize(), "HikariCP connection filler");
 

File: src/test/java/com/zaxxer/hikari/TestConnections.java
Patch:
@@ -20,6 +20,7 @@
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
+import java.util.concurrent.TimeUnit;
 
 import org.junit.Assert;
 import org.junit.Test;
@@ -223,6 +224,7 @@ public void testMaximumPoolLimit() throws Exception
         HikariConfig config = new HikariConfig();
         config.setMinimumIdle(1);
         config.setMaximumPoolSize(4);
+        config.setConnectionTimeout(TimeUnit.MINUTES.toMillis(1));
         config.setInitializationFailFast(true);
         config.setConnectionTestQuery("VALUES 1");
         config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

File: src/test/java/com/zaxxer/hikari/mocks/StubConnection.java
Patch:
@@ -42,7 +42,7 @@
  */
 public class StubConnection extends StubBaseConnection implements Connection
 {
-    public static AtomicInteger count = new AtomicInteger();
+    public static final AtomicInteger count = new AtomicInteger();
 
     private static long foo;
     private boolean autoCommit;

File: src/main/java/com/zaxxer/hikari/pool/HikariMBeanElf.java
Patch:
@@ -53,7 +53,7 @@ public static void registerMBeans(HikariConfig configuration, HikariPool pool)
             MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
             
             ObjectName poolConfigName = new ObjectName("com.zaxxer.hikari:type=PoolConfig (" + configuration.getPoolName() + ")");
-            ObjectName poolName = new ObjectName("com.zaxxer.hikari.pool:type=Pool (" + configuration.getPoolName() + ")");
+            ObjectName poolName = new ObjectName("com.zaxxer.hikari:type=Pool (" + configuration.getPoolName() + ")");
             if (!mBeanServer.isRegistered(poolConfigName))
             {
                 mBeanServer.registerMBean(configuration, poolConfigName);

File: src/main/java/com/zaxxer/hikari/pool/HikariMBeanElf.java
Patch:
@@ -53,7 +53,7 @@ public static void registerMBeans(HikariConfig configuration, HikariPool pool)
             MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
             
             ObjectName poolConfigName = new ObjectName("com.zaxxer.hikari:type=PoolConfig (" + configuration.getPoolName() + ")");
-            ObjectName poolName = new ObjectName("com.zaxxer.hikari:type=Pool (" + configuration.getPoolName() + ")");
+            ObjectName poolName = new ObjectName("com.zaxxer.hikari.pool:type=Pool (" + configuration.getPoolName() + ")");
             if (!mBeanServer.isRegistered(poolConfigName))
             {
                 mBeanServer.registerMBean(configuration, poolConfigName);

File: src/main/java/com/zaxxer/hikari/pool/HikariPool.java
Patch:
@@ -33,7 +33,6 @@
 import org.slf4j.LoggerFactory;
 
 import com.zaxxer.hikari.HikariConfig;
-import com.zaxxer.hikari.HikariPoolMBean;
 import com.zaxxer.hikari.IConnectionCustomizer;
 import com.zaxxer.hikari.metrics.CodaHaleMetricsTracker;
 import com.zaxxer.hikari.metrics.MetricsTracker;

File: src/main/java/com/zaxxer/hikari/pool/HikariPoolMBean.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.zaxxer.hikari;
+package com.zaxxer.hikari.pool;
 
 /**
  * The javax.management MBean for a Hikiri pool instance.

File: src/main/java/com/zaxxer/hikari/HikariJNDIFactory.java
Patch:
@@ -28,7 +28,6 @@
 import javax.naming.spi.ObjectFactory;
 import javax.sql.DataSource;
 
-import com.zaxxer.hikari.pool.HikariPool;
 import com.zaxxer.hikari.util.PropertyBeanSetter;
 
 /**
@@ -54,7 +53,7 @@ public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtabl
         }
 
         Properties properties = new Properties();
-        for (String propertyName : PropertyBeanSetter.getPropertyNames(HikariPool.class))
+        for (String propertyName : PropertyBeanSetter.getPropertyNames(HikariConfig.class))
         {
             RefAddr ra = ref.get(propertyName);
             if (ra != null)

File: src/main/java/com/zaxxer/hikari/metrics/CodaHaleMetricsTracker.java
Patch:
@@ -19,7 +19,7 @@
 import com.codahale.metrics.Histogram;
 import com.codahale.metrics.MetricRegistry;
 import com.codahale.metrics.Timer;
-import com.zaxxer.hikari.HikariPool;
+import com.zaxxer.hikari.pool.HikariPool;
 
 public final class CodaHaleMetricsTracker extends MetricsTracker
 {

File: src/main/java/com/zaxxer/hikari/pool/HikariMBeanElf.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.zaxxer.hikari;
+package com.zaxxer.hikari.pool;
 
 import java.lang.management.ManagementFactory;
 
@@ -24,6 +24,8 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import com.zaxxer.hikari.HikariConfig;
+
 /**
  * Helper class to register our MBeans.
  *

File: src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -30,7 +30,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.zaxxer.hikari.HikariPool;
+import com.zaxxer.hikari.pool.HikariPool;
 import com.zaxxer.hikari.util.FastStatementList;
 
 /**

File: src/main/java/com/zaxxer/hikari/proxy/ProxyFactory.java
Patch:
@@ -21,7 +21,7 @@
 import java.sql.PreparedStatement;
 import java.sql.Statement;
 
-import com.zaxxer.hikari.HikariPool;
+import com.zaxxer.hikari.pool.HikariPool;
 
 /**
  * A factory class that produces proxies around instances of the standard

File: src/test/java/com/zaxxer/hikari/RampUpDown.java
Patch:
@@ -23,15 +23,15 @@ public void rampUpDownTest() throws SQLException, InterruptedException
         HikariDataSource ds = new HikariDataSource(config);
         ds.setIdleTimeout(1000);
 
-        Assert.assertSame("Totals connections not as expected", 5, ds.pool.getTotalConnections());
+        Assert.assertSame("Totals connections not as expected", 5, TestElf.getPool(ds).getTotalConnections());
 
         Connection[] connections = new Connection[ds.getMaximumPoolSize()];
         for (int i = 0; i < connections.length; i++)
         {
             connections[i] = ds.getConnection();
         }
 
-        Assert.assertSame("Totals connections not as expected", 60, ds.pool.getTotalConnections());
+        Assert.assertSame("Totals connections not as expected", 60, TestElf.getPool(ds).getTotalConnections());
 
         for (Connection connection : connections)
         {
@@ -40,7 +40,7 @@ public void rampUpDownTest() throws SQLException, InterruptedException
 
         Thread.sleep(2500);
 
-        Assert.assertSame("Totals connections not as expected", 5, ds.pool.getTotalConnections());
+        Assert.assertSame("Totals connections not as expected", 5, TestElf.getPool(ds).getTotalConnections());
 
         ds.shutdown();
     }

File: src/test/java/com/zaxxer/hikari/UnwrapTest.java
Patch:
@@ -42,7 +42,7 @@ public void testUnwrapConnection() throws SQLException
 
         HikariDataSource ds = new HikariDataSource(config);
 
-        Assert.assertSame("Idle connections not as expected", 1, ds.pool.getIdleConnections());
+        Assert.assertSame("Idle connections not as expected", 1, TestElf.getPool(ds).getIdleConnections());
 
         Connection connection = ds.getConnection();
         Assert.assertNotNull(connection);

File: src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -141,7 +141,7 @@ public final void checkException(SQLException sqle)
             forceClose |= sqlState.startsWith("08") | SQL_ERRORS.contains(sqlState);
             if (forceClose)
             {
-                LOGGER.warn("Connection {} ({}) marked as broken because of SQLSTATE({}), ErrorCode({}): {}", delegate.toString(), parentPool.toString(), sqle.getErrorCode(), sqle.getNextException());
+                LOGGER.warn(String.format("Connection %s (%s) marked as broken because of SQLSTATE(%s), ErrorCode(%d).", delegate.toString(), parentPool.toString(), sqlState, sqle.getErrorCode()), sqle);
             }
             else if (sqle.getNextException() instanceof SQLException)
             {

File: src/main/java/com/zaxxer/hikari/HikariPool.java
Patch:
@@ -67,14 +67,14 @@ public final class HikariPool implements HikariPoolMBean, IBagStateListener
     private final boolean isRegisteredMbeans;
     private final boolean isJdbc4ConnectionTest;
     private final long leakDetectionThreshold;
+    private final AtomicReference<Throwable> lastConnectionFailure;
     private final AtomicInteger totalConnections;
     private final Timer houseKeepingTimer;
     private final String catalog;
     private final String username;
     private final String password;
 
     private volatile boolean isShutdown;
-    private volatile AtomicReference<Throwable> lastConnectionFailure;
     private int transactionIsolation;
     private boolean isDebug;
 
@@ -254,7 +254,7 @@ else if (!addConnection())
                         sleepBackoff = (int) Math.min(1000f, ((float) sleepBackoff) * 1.5);
                         if (getThreadsAwaitingConnection() == 0)
                         {
-                            lastConnectionFailure = null;
+                            lastConnectionFailure.set(null);
                             break;
                         }
                         continue;

File: src/main/java/com/zaxxer/hikari/HikariJNDIFactory.java
Patch:
@@ -28,7 +28,6 @@
 import javax.naming.spi.ObjectFactory;
 import javax.sql.DataSource;
 
-import com.zaxxer.hikari.pool.HikariPool;
 import com.zaxxer.hikari.util.PropertyBeanSetter;
 
 /**
@@ -54,7 +53,7 @@ public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtabl
         }
 
         Properties properties = new Properties();
-        for (String propertyName : PropertyBeanSetter.getPropertyNames(HikariPool.class))
+        for (String propertyName : PropertyBeanSetter.getPropertyNames(HikariConfig.class))
         {
             RefAddr ra = ref.get(propertyName);
             if (ra != null)

File: src/main/java/com/zaxxer/hikari/metrics/CodaHaleMetricsTracker.java
Patch:
@@ -19,7 +19,7 @@
 import com.codahale.metrics.Histogram;
 import com.codahale.metrics.MetricRegistry;
 import com.codahale.metrics.Timer;
-import com.zaxxer.hikari.HikariPool;
+import com.zaxxer.hikari.pool.HikariPool;
 
 public final class CodaHaleMetricsTracker extends MetricsTracker
 {

File: src/main/java/com/zaxxer/hikari/pool/HikariMBeanElf.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.zaxxer.hikari;
+package com.zaxxer.hikari.pool;
 
 import java.lang.management.ManagementFactory;
 
@@ -24,6 +24,8 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import com.zaxxer.hikari.HikariConfig;
+
 /**
  * Helper class to register our MBeans.
  *

File: src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -30,7 +30,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.zaxxer.hikari.HikariPool;
+import com.zaxxer.hikari.pool.HikariPool;
 import com.zaxxer.hikari.util.FastStatementList;
 
 /**

File: src/main/java/com/zaxxer/hikari/proxy/ProxyFactory.java
Patch:
@@ -21,7 +21,7 @@
 import java.sql.PreparedStatement;
 import java.sql.Statement;
 
-import com.zaxxer.hikari.HikariPool;
+import com.zaxxer.hikari.pool.HikariPool;
 
 /**
  * A factory class that produces proxies around instances of the standard

File: src/test/java/com/zaxxer/hikari/RampUpDown.java
Patch:
@@ -23,15 +23,15 @@ public void rampUpDownTest() throws SQLException, InterruptedException
         HikariDataSource ds = new HikariDataSource(config);
         ds.setIdleTimeout(1000);
 
-        Assert.assertSame("Totals connections not as expected", 5, ds.pool.getTotalConnections());
+        Assert.assertSame("Totals connections not as expected", 5, TestElf.getPool(ds).getTotalConnections());
 
         Connection[] connections = new Connection[ds.getMaximumPoolSize()];
         for (int i = 0; i < connections.length; i++)
         {
             connections[i] = ds.getConnection();
         }
 
-        Assert.assertSame("Totals connections not as expected", 60, ds.pool.getTotalConnections());
+        Assert.assertSame("Totals connections not as expected", 60, TestElf.getPool(ds).getTotalConnections());
 
         for (Connection connection : connections)
         {
@@ -40,7 +40,7 @@ public void rampUpDownTest() throws SQLException, InterruptedException
 
         Thread.sleep(2500);
 
-        Assert.assertSame("Totals connections not as expected", 5, ds.pool.getTotalConnections());
+        Assert.assertSame("Totals connections not as expected", 5, TestElf.getPool(ds).getTotalConnections());
 
         ds.shutdown();
     }

File: src/test/java/com/zaxxer/hikari/UnwrapTest.java
Patch:
@@ -42,7 +42,7 @@ public void testUnwrapConnection() throws SQLException
 
         HikariDataSource ds = new HikariDataSource(config);
 
-        Assert.assertSame("Idle connections not as expected", 1, ds.pool.getIdleConnections());
+        Assert.assertSame("Idle connections not as expected", 1, TestElf.getPool(ds).getIdleConnections());
 
         Connection connection = ds.getConnection();
         Assert.assertNotNull(connection);

File: src/main/java/com/zaxxer/hikari/HikariPool.java
Patch:
@@ -67,14 +67,14 @@ public final class HikariPool implements HikariPoolMBean, IBagStateListener
     private final boolean isRegisteredMbeans;
     private final boolean isJdbc4ConnectionTest;
     private final long leakDetectionThreshold;
+    private final AtomicReference<Throwable> lastConnectionFailure;
     private final AtomicInteger totalConnections;
     private final Timer houseKeepingTimer;
     private final String catalog;
     private final String username;
     private final String password;
 
     private volatile boolean isShutdown;
-    private volatile AtomicReference<Throwable> lastConnectionFailure;
     private int transactionIsolation;
     private boolean isDebug;
 
@@ -254,7 +254,7 @@ else if (!addConnection())
                         sleepBackoff = (int) Math.min(1000f, ((float) sleepBackoff) * 1.5);
                         if (getThreadsAwaitingConnection() == 0)
                         {
-                            lastConnectionFailure = null;
+                            lastConnectionFailure.set(null);
                             break;
                         }
                         continue;

File: src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -141,7 +141,7 @@ public final void checkException(SQLException sqle)
             forceClose |= sqlState.startsWith("08") | SQL_ERRORS.contains(sqlState);
             if (forceClose)
             {
-                LOGGER.warn("Connection {} ({}) marked as broken because of SQLSTATE({}), ErrorCode({}): {}", delegate.toString(), parentPool.toString(), sqle.getErrorCode(), sqle.getNextException());
+                LOGGER.warn(String.format("Connection %s (%s) marked as broken because of SQLSTATE(%s), ErrorCode(%d).", delegate.toString(), parentPool.toString(), sqlState, sqle.getErrorCode()), sqle);
             }
             else if (sqle.getNextException() instanceof SQLException)
             {

File: src/main/java/com/zaxxer/hikari/HikariPool.java
Patch:
@@ -67,14 +67,14 @@ public final class HikariPool implements HikariPoolMBean, IBagStateListener
     private final boolean isRegisteredMbeans;
     private final boolean isJdbc4ConnectionTest;
     private final long leakDetectionThreshold;
+    private final AtomicReference<Throwable> lastConnectionFailure;
     private final AtomicInteger totalConnections;
     private final Timer houseKeepingTimer;
     private final String catalog;
     private final String username;
     private final String password;
 
     private volatile boolean isShutdown;
-    private volatile AtomicReference<Throwable> lastConnectionFailure;
     private int transactionIsolation;
     private boolean isDebug;
 
@@ -254,7 +254,7 @@ else if (!addConnection())
                         sleepBackoff = (int) Math.min(1000f, ((float) sleepBackoff) * 1.5);
                         if (getThreadsAwaitingConnection() == 0)
                         {
-                            lastConnectionFailure = null;
+                            lastConnectionFailure.set(null);
                             break;
                         }
                         continue;

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -215,7 +215,7 @@ public String getConnectionTestQuery()
 
     /**
      * Set the SQL query to be executed to test the validity of connections. Using
-     * the JDBC4 {@link Connection.isValid()} method to test connection validity can
+     * the JDBC4 <code>Connection.isValid()</code> method to test connection validity can
      * be more efficient on some databases and is recommended.  See 
      * {@link HikariConfig#setJdbc4ConnectionTest(boolean)}.
      *
@@ -438,7 +438,7 @@ public boolean isRecordMetrics()
 
     /**
      * Currently not supported.
-     * @param recordMetrics
+     * @param recordMetrics <code>true</code> if metrics should be recorded
      */
     @Deprecated
     public void setRecordMetrics(boolean recordMetrics)

File: src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -141,7 +141,7 @@ public final void checkException(SQLException sqle)
             forceClose |= sqlState.startsWith("08") | SQL_ERRORS.contains(sqlState);
             if (forceClose)
             {
-                LOGGER.warn("Connection {} marked as broken because of SQLSTATE({}), ErrorCode({}): {}", delegate.toString(), sqlState, sqle.getErrorCode(), sqle.getNextException());
+                LOGGER.warn("Connection {} ({}) marked as broken because of SQLSTATE({}), ErrorCode({}): {}", delegate.toString(), parentPool.toString(), sqle.getErrorCode(), sqle.getNextException());
             }
             else if (sqle.getNextException() instanceof SQLException)
             {

File: src/main/java/com/zaxxer/hikari/proxy/JavassistProxyFactory.java
Patch:
@@ -192,7 +192,7 @@ private <T> Class<T> generateProxyClass(Class<T> primaryInterface, Class<?> supe
                 }
                 else
                 {
-                    modifiedBody = "return ((cast) delegate).method($$);".replace("method", method.getName()).replace("cast", primaryInterface.getName());
+                    modifiedBody = "{ return ((cast) delegate).method($$); }".replace("method", method.getName()).replace("cast", primaryInterface.getName());
                 }
 
                 if (method.getReturnType() == CtClass.voidType)

File: src/main/java/com/zaxxer/hikari/util/PoolUtilities.java
Patch:
@@ -26,6 +26,7 @@ public static void quietlyCloseConnection(Connection connection)
      * Execute the user-specified init SQL.
      *
      * @param connection the connection to initialize
+     * @param sql the SQL to execute
      * @throws SQLException throws if the init SQL execution fails
      */
     public static void executeSqlAutoCommit(Connection connection, String sql) throws SQLException

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -215,7 +215,7 @@ public String getConnectionTestQuery()
 
     /**
      * Set the SQL query to be executed to test the validity of connections. Using
-     * the JDBC4 {@link Connection.isValid()} method to test connection validity can
+     * the JDBC4 <code>Connection.isValid()</code> method to test connection validity can
      * be more efficient on some databases and is recommended.  See 
      * {@link HikariConfig#setJdbc4ConnectionTest(boolean)}.
      *
@@ -438,7 +438,7 @@ public boolean isRecordMetrics()
 
     /**
      * Currently not supported.
-     * @param recordMetrics
+     * @param recordMetrics <code>true</code> if metrics should be recorded
      */
     @Deprecated
     public void setRecordMetrics(boolean recordMetrics)

File: src/main/java/com/zaxxer/hikari/proxy/JavassistProxyFactory.java
Patch:
@@ -192,7 +192,7 @@ private <T> Class<T> generateProxyClass(Class<T> primaryInterface, Class<?> supe
                 }
                 else
                 {
-                    modifiedBody = "return ((cast) delegate).method($$);".replace("method", method.getName()).replace("cast", primaryInterface.getName());
+                    modifiedBody = "{ return ((cast) delegate).method($$); }".replace("method", method.getName()).replace("cast", primaryInterface.getName());
                 }
 
                 if (method.getReturnType() == CtClass.voidType)

File: src/main/java/com/zaxxer/hikari/util/PoolUtilities.java
Patch:
@@ -26,6 +26,7 @@ public static void quietlyCloseConnection(Connection connection)
      * Execute the user-specified init SQL.
      *
      * @param connection the connection to initialize
+     * @param sql the SQL to execute
      * @throws SQLException throws if the init SQL execution fails
      */
     public static void executeSqlAutoCommit(Connection connection, String sql) throws SQLException

File: src/main/java/com/zaxxer/hikari/proxy/JavassistProxyFactory.java
Patch:
@@ -192,7 +192,7 @@ private <T> Class<T> generateProxyClass(Class<T> primaryInterface, Class<?> supe
                 }
                 else
                 {
-                    modifiedBody = "return ((cast) delegate).method($$);".replace("method", method.getName()).replace("cast", primaryInterface.getName());
+                    modifiedBody = "{ return ((cast) delegate).method($$); }".replace("method", method.getName()).replace("cast", primaryInterface.getName());
                 }
 
                 if (method.getReturnType() == CtClass.voidType)

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -215,7 +215,7 @@ public String getConnectionTestQuery()
 
     /**
      * Set the SQL query to be executed to test the validity of connections. Using
-     * the JDBC4 {@link Connection.isValid()} method to test connection validity can
+     * the JDBC4 <code>Connection.isValid()</code> method to test connection validity can
      * be more efficient on some databases and is recommended.  See 
      * {@link HikariConfig#setJdbc4ConnectionTest(boolean)}.
      *
@@ -438,7 +438,7 @@ public boolean isRecordMetrics()
 
     /**
      * Currently not supported.
-     * @param recordMetrics
+     * @param recordMetrics <code>true</code> if metrics should be recorded
      */
     @Deprecated
     public void setRecordMetrics(boolean recordMetrics)

File: src/main/java/com/zaxxer/hikari/util/PoolUtilities.java
Patch:
@@ -26,6 +26,7 @@ public static void quietlyCloseConnection(Connection connection)
      * Execute the user-specified init SQL.
      *
      * @param connection the connection to initialize
+     * @param sql the SQL to execute
      * @throws SQLException throws if the init SQL execution fails
      */
     public static void executeSqlAutoCommit(Connection connection, String sql) throws SQLException

File: src/main/java/com/zaxxer/hikari/HikariMBeanElf.java
Patch:
@@ -89,7 +89,7 @@ public static void unregisterMBeans(HikariConfig configuration, HikariPool pool)
             }
             else
             {
-                LOGGER.error("No registered MBean for {0}.", configuration.getPoolName());
+                LOGGER.error("No registered MBean for {}.", configuration.getPoolName());
             }
         }
         catch (Exception e)

File: src/main/java/com/zaxxer/hikari/metrics/MetricsTracker.java
Patch:
@@ -24,7 +24,7 @@
  */
 public class MetricsTracker
 {
-    private static final Context NO_CONTEXT = new Context();
+    protected static final Context NO_CONTEXT = new Context();
 
     public static class Context
     {

File: src/main/java/com/zaxxer/hikari/HikariMBeanElf.java
Patch:
@@ -89,7 +89,7 @@ public static void unregisterMBeans(HikariConfig configuration, HikariPool pool)
             }
             else
             {
-                LOGGER.error("No registered MBean for {0}.", configuration.getPoolName());
+                LOGGER.error("No registered MBean for {}.", configuration.getPoolName());
             }
         }
         catch (Exception e)

File: src/main/java/com/zaxxer/hikari/proxy/LeakTask.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * @author Brett Wooldridge
  */
-public class LeakTask extends TimerTask
+class LeakTask extends TimerTask
 {
     private final long leakTime;
     private StackTraceElement[] stackTrace;

File: src/main/java/com/zaxxer/hikari/proxy/PreparedStatementProxy.java
Patch:
@@ -37,6 +37,7 @@ protected PreparedStatementProxy(ConnectionProxy connection, PreparedStatement s
     // **********************************************************************
     
     /** {@inheritDoc} */
+    @Override
     public final ResultSet executeQuery() throws SQLException
     {
     	try

File: src/main/java/com/zaxxer/hikari/util/FastStatementList.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Brett Wooldridge
+ * Copyright (C) 2013, 2014 Brett Wooldridge
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -31,7 +31,7 @@ public final class FastStatementList
     private int size;
 
     /**
-     * Construct a FastList with a default size of 16.
+     * Construct a FastList with a default size of 32.
      */
     public FastStatementList()
     {

File: src/test/java/com/zaxxer/hikari/RampUpDown.java
Patch:
@@ -12,9 +12,9 @@ public class RampUpDown
     public void rampUpDownTest() throws SQLException, InterruptedException
     {
         HikariConfig config = new HikariConfig();
-        config.setMinimumPoolSize(5);
+        config.setMinimumIdle(5);
         config.setMaximumPoolSize(60);
-        config.setAcquireIncrement(1);
+        config.setInitializationFailFast(true);
         config.setConnectionTestQuery("VALUES 1");
         config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 

File: src/test/java/com/zaxxer/hikari/UnwrapTest.java
Patch:
@@ -34,9 +34,9 @@ public class UnwrapTest
     public void testUnwrapConnection() throws SQLException
     {
         HikariConfig config = new HikariConfig();
-        config.setMinimumPoolSize(1);
+        config.setMinimumIdle(1);
         config.setMaximumPoolSize(1);
-        config.setAcquireIncrement(1);
+        config.setInitializationFailFast(true);
         config.setConnectionTestQuery("VALUES 1");
         config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 

File: src/test/java/com/zaxxer/hikari/mocks/StubBaseConnection.java
Patch:
@@ -8,12 +8,14 @@
 public abstract class StubBaseConnection implements Connection
 {
     /** {@inheritDoc} */
+    @Override
     public Statement createStatement() throws SQLException
     {
         return new StubStatement(this);
     }
 
     /** {@inheritDoc} */
+    @Override
     public PreparedStatement prepareStatement(String sql) throws SQLException
     {
         return new StubPreparedStatement(this);

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -37,7 +37,7 @@ public class HikariConfig implements HikariConfigMBean
 {
     private static final Logger LOGGER = LoggerFactory.getLogger(HikariConfig.class);
 
-	private static final long CONNECTION_TIMEOUT = 5000L;
+	private static final long CONNECTION_TIMEOUT = TimeUnit.SECONDS.toMillis(30);
 	private static final long IDLE_TIMEOUT = TimeUnit.MINUTES.toMillis(10);
 	private static final long MAX_LIFETIME = TimeUnit.MINUTES.toMillis(30);
 
@@ -93,7 +93,7 @@ public HikariConfig()
         isAutoCommit = true;
         isJdbc4connectionTest = true;
         minIdle = -1;
-        maxPoolSize = 32;
+        maxPoolSize = 10;
         maxLifetime = MAX_LIFETIME;
         poolName = "HikariPool-" + poolNumber++;
         transactionIsolation = -1;

File: src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java
Patch:
@@ -38,7 +38,8 @@ public void testConnectionRetries() throws SQLException
         catch (SQLException e)
         {
             long elapsed = System.currentTimeMillis() - start;
-            Assert.assertTrue("Didn't wait long enough for timeout", (elapsed > config.getConnectionTimeout()));
+            long timeout = config.getConnectionTimeout();
+            Assert.assertTrue("Didn't wait long enough for timeout", (elapsed >= timeout));
         }
         finally
         {

File: src/test/java/com/zaxxer/hikari/ConnectionStateTest.java
Patch:
@@ -13,7 +13,7 @@ public void testAutoCommit() throws SQLException
     {
         HikariDataSource ds = new HikariDataSource();
         ds.setAutoCommit(true);
-        ds.setMinimumPoolSize(1);
+        ds.setMinimumIdle(1);
         ds.setMaximumPoolSize(1);
         ds.setConnectionTestQuery("VALUES 1");
         ds.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
@@ -40,7 +40,7 @@ public void testTransactionIsolation() throws SQLException
     {
         HikariDataSource ds = new HikariDataSource();
         ds.setTransactionIsolation("TRANSACTION_READ_COMMITTED");
-        ds.setMinimumPoolSize(1);
+        ds.setMinimumIdle(1);
         ds.setMaximumPoolSize(1);
         ds.setConnectionTestQuery("VALUES 1");
         ds.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
@@ -67,7 +67,7 @@ public void testCatalog() throws SQLException
     {
         HikariDataSource ds = new HikariDataSource();
         ds.setCatalog("test");
-        ds.setMinimumPoolSize(1);
+        ds.setMinimumIdle(1);
         ds.setMaximumPoolSize(1);
         ds.setConnectionTestQuery("VALUES 1");
         ds.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");

File: src/test/java/com/zaxxer/hikari/ExceptionTest.java
Patch:
@@ -18,7 +18,7 @@ public class ExceptionTest
     public void setup()
     {
         HikariConfig config = new HikariConfig();
-        config.setMinimumPoolSize(1);
+        config.setMinimumIdle(1);
         config.setMaximumPoolSize(2);
         config.setInitializationFailFast(true);
         config.setConnectionTestQuery("VALUES 1");
@@ -91,7 +91,7 @@ public void testUseAfterStatementClose() throws SQLException
     public void testUseAfterClose() throws SQLException
     {
         HikariConfig config = new HikariConfig();
-        config.setMinimumPoolSize(1);
+        config.setMinimumIdle(1);
         config.setMaximumPoolSize(2);
         config.setInitializationFailFast(true);
         config.setConnectionTestQuery("VALUES 1");

File: src/test/java/com/zaxxer/hikari/JdbcDriverTest.java
Patch:
@@ -26,7 +26,7 @@ public class JdbcDriverTest
     public void driverTest1() throws SQLException
     {
         HikariConfig config = new HikariConfig();
-        config.setMinimumPoolSize(1);
+        config.setMinimumIdle(1);
         config.setMaximumPoolSize(1);
         config.setConnectionTestQuery("VALUES 1");
         config.setDriverClassName("com.zaxxer.hikari.mocks.StubDriver");

File: src/test/java/com/zaxxer/hikari/RampUpDown.java
Patch:
@@ -12,7 +12,7 @@ public class RampUpDown
     public void rampUpDownTest() throws SQLException, InterruptedException
     {
         HikariConfig config = new HikariConfig();
-        config.setMinimumPoolSize(5);
+        config.setMinimumIdle(5);
         config.setMaximumPoolSize(60);
         config.setInitializationFailFast(true);
         config.setConnectionTestQuery("VALUES 1");

File: src/test/java/com/zaxxer/hikari/TestPropertySetter.java
Patch:
@@ -20,7 +20,7 @@ public void testProperty1()
         HikariConfig config = new HikariConfig(file.getPath());
         config.validate();
 
-        Assert.assertEquals(5, config.getAcquireRetries());
+        Assert.assertEquals(5, config.getMinimumIdle());
         Assert.assertEquals("SELECT 1", config.getConnectionTestQuery());
     }
 

File: src/test/java/com/zaxxer/hikari/UnwrapTest.java
Patch:
@@ -34,7 +34,7 @@ public class UnwrapTest
     public void testUnwrapConnection() throws SQLException
     {
         HikariConfig config = new HikariConfig();
-        config.setMinimumPoolSize(1);
+        config.setMinimumIdle(1);
         config.setMaximumPoolSize(1);
         config.setInitializationFailFast(true);
         config.setConnectionTestQuery("VALUES 1");

File: src/main/java/com/zaxxer/hikari/HikariDataSource.java
Patch:
@@ -246,7 +246,7 @@ private static class MultiPoolKey
         @Override
         public int hashCode()
         {
-            return password.hashCode();
+            return (password == null ? 0 : password.hashCode());
         }
 
         @Override

File: src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java
Patch:
@@ -61,7 +61,7 @@ public void testConnectionRetries2() throws SQLException
         final StubDataSource stubDataSource = ds.unwrap(StubDataSource.class);
         stubDataSource.setThrowException(new SQLException("Connection refused"));
 
-        final long timePerTry = config.getConnectionTimeout() / (config.getAcquireRetries() + 1);
+        final long timePerTry = Math.max(config.getConnectionTimeout() / (config.getAcquireRetries() + 1), 1000);
         
         ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
         scheduler.schedule(new Runnable() {
@@ -78,7 +78,8 @@ public void run()
             connection.close();
 
             long elapsed = System.currentTimeMillis() - start;
-            Assert.assertTrue("Waited too long to get a connection.", (elapsed >= timePerTry * 3) && (elapsed < config.getConnectionTimeout()));
+            Assert.assertTrue("Connection returned too quickly, something is wrong.", elapsed >= timePerTry * 3);
+            Assert.assertTrue("Waited too long to get a connection.", elapsed < config.getConnectionTimeout());
         }
         catch (SQLException e)
         {

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -652,10 +652,10 @@ else if (maxLifetime < TimeUnit.SECONDS.toMillis(120) && maxLifetime != 0)
             long retryTimeoutMs = (connectionTimeout / (acquireRetries + 1));
             if (retryTimeoutMs < TimeUnit.SECONDS.toMillis(1))
             {
-                logger.warn("JDBC setLoginTimeout() has a minimum resolution of 1 second, but requested acquireRetries({})" + 
+                logger.warn("JDBC setLoginTimeout() has a minimum resolution of 1 second, but requested acquireRetries({}) " + 
                             "in connectionTimeout({}ms) would result in sub-second values.  Using {}ms for connectionTimeout instead.",
-                            acquireRetries, connectionTimeout, TimeUnit.SECONDS.toMillis(acquireRetries));
-                connectionTimeout = TimeUnit.SECONDS.toMillis(acquireRetries);
+                            acquireRetries, connectionTimeout, TimeUnit.SECONDS.toMillis(acquireRetries + 1));
+                connectionTimeout = TimeUnit.SECONDS.toMillis(acquireRetries + 1);
             }
         }
 

File: src/test/java/com/zaxxer/hikari/ExceptionTest.java
Patch:
@@ -20,6 +20,7 @@ public void setup()
         HikariConfig config = new HikariConfig();
         config.setMinimumPoolSize(1);
         config.setMaximumPoolSize(2);
+        config.setInitializationFailFast(true);
         config.setConnectionTestQuery("VALUES 1");
         config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 
@@ -92,6 +93,7 @@ public void testUseAfterClose() throws SQLException
         HikariConfig config = new HikariConfig();
         config.setMinimumPoolSize(1);
         config.setMaximumPoolSize(2);
+        config.setInitializationFailFast(true);
         config.setConnectionTestQuery("VALUES 1");
         config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 

File: src/test/java/com/zaxxer/hikari/RampUpDown.java
Patch:
@@ -14,6 +14,7 @@ public void rampUpDownTest() throws SQLException, InterruptedException
         HikariConfig config = new HikariConfig();
         config.setMinimumPoolSize(5);
         config.setMaximumPoolSize(60);
+        config.setInitializationFailFast(true);
         config.setConnectionTestQuery("VALUES 1");
         config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 

File: src/test/java/com/zaxxer/hikari/UnwrapTest.java
Patch:
@@ -36,6 +36,7 @@ public void testUnwrapConnection() throws SQLException
         HikariConfig config = new HikariConfig();
         config.setMinimumPoolSize(1);
         config.setMaximumPoolSize(1);
+        config.setInitializationFailFast(true);
         config.setConnectionTestQuery("VALUES 1");
         config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 

File: src/test/java/com/zaxxer/hikari/TestConnectionTimeoutRetry.java
Patch:
@@ -185,7 +185,7 @@ public void testConnectionRetries4() throws SQLException
         catch (SQLException e)
         {
             long elapsed = System.currentTimeMillis() - start;
-            Assert.assertTrue("Didn't wait long enough for timeout", (elapsed > config.getConnectionTimeout()));
+            Assert.assertTrue("Didn't wait long enough for timeout", (elapsed >= config.getConnectionTimeout()));
         }
         finally
         {

File: src/test/java/com/zaxxer/hikari/TestConnections.java
Patch:
@@ -32,7 +32,7 @@
  *
  * @author Brett Wooldridge
  */
-public class CreationTest
+public class TestConnections
 {
     @Test
     public void testCreate() throws SQLException

File: src/main/java/com/zaxxer/hikari/HikariPool.java
Patch:
@@ -338,7 +338,7 @@ private void addConnection()
     {
         final int acquireTimeout = (int) configuration.getConnectionTimeout();
         final int acquireRetries = configuration.getAcquireRetries();
-        final int loginTimeout = Math.max((acquireRetries > 0 && acquireTimeout > 0) ? (acquireTimeout / (acquireRetries + 1)) : acquireTimeout, 50);
+        final int loginTimeout = (acquireRetries > 0 && acquireTimeout > 0) ? Math.max((acquireTimeout / (acquireRetries + 1)), 50) : acquireTimeout;
 
         for (int retries = 0; retries <= acquireRetries && !shutdown; retries++)
         {

File: src/main/java/com/zaxxer/hikari/HikariPool.java
Patch:
@@ -511,6 +511,7 @@ private void logPoolState(String... prefix)
      */
     private class HouseKeeper extends TimerTask
     {
+        @Override
         public void run()
         {
             debug = LOGGER.isDebugEnabled();

File: src/main/java/com/zaxxer/hikari/proxy/PreparedStatementProxy.java
Patch:
@@ -37,6 +37,7 @@ protected PreparedStatementProxy(ConnectionProxy connection, PreparedStatement s
     // **********************************************************************
     
     /** {@inheritDoc} */
+    @Override
     public final ResultSet executeQuery() throws SQLException
     {
     	try

File: src/test/java/com/zaxxer/hikari/mocks/StubBaseConnection.java
Patch:
@@ -8,12 +8,14 @@
 public abstract class StubBaseConnection implements Connection
 {
     /** {@inheritDoc} */
+    @Override
     public Statement createStatement() throws SQLException
     {
         return new StubStatement(this);
     }
 
     /** {@inheritDoc} */
+    @Override
     public PreparedStatement prepareStatement(String sql) throws SQLException
     {
         return new StubPreparedStatement(this);

File: src/main/java/com/zaxxer/hikari/HikariPool.java
Patch:
@@ -340,7 +340,7 @@ private void addConnection()
             try
             {
                 // Speculative increment of totalConnections with expectation of success
-                if (totalConnections.incrementAndGet() > configuration.getMaximumPoolSize())
+                if (retries == 0 && totalConnections.incrementAndGet() > configuration.getMaximumPoolSize())
                 {
                     totalConnections.decrementAndGet();
                     break;

File: src/main/java/com/zaxxer/hikari/proxy/ProxyFactory.java
Patch:
@@ -33,7 +33,7 @@ public final class ProxyFactory
 {
     private ProxyFactory()
     {
-        // unconstrucable
+        // unconstructable
     }
 
     /**

File: src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -95,7 +95,7 @@ protected ConnectionProxy(HikariPool pool, Connection connection, int defaultIso
         this.hashCode = System.identityHashCode(this);
 
         isCatalogDirty = true;
-        isReadOnlyDirty = true;
+        isReadOnlyDirty = defaultReadOnly;
         isAutoCommitDirty = true;
         isTransactionIsolationDirty = true;
     }

File: src/test/java/com/zaxxer/hikari/CreationTest.java
Patch:
@@ -221,9 +221,11 @@ public void testBackfill() throws Exception
     public void testIsolation() throws Exception
     {
         HikariConfig config = new HikariConfig();
+        config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
         config.setTransactionIsolation("TRANSACTION_REPEATABLE_READ");
+        config.validate();
+        
         int transactionIsolation = config.getTransactionIsolation();
-
         Assert.assertSame(Connection.TRANSACTION_REPEATABLE_READ, transactionIsolation);
     }
 }

File: src/main/java/com/zaxxer/hikari/HikariPool.java
Patch:
@@ -226,6 +226,7 @@ public String toString()
     void shutdown()
     {
         LOGGER.info("HikariCP pool " + configuration.getPoolName() + " is being shutdown.");
+        logPoolState("State at shutdown ");
 
         shutdown = true;
         houseKeepingTimer.cancel();

File: src/main/java/com/zaxxer/hikari/proxy/ProxyFactory.java
Patch:
@@ -30,7 +30,7 @@
  */
 public final class ProxyFactory
 {
-    public static Connection getProxyConnection(HikariPool pool, Connection connection, int defaultIsolationLevels)
+    public static Connection getProxyConnection(HikariPool pool, Connection connection, int defaultIsolationLevel, boolean defaultAutoCommit)
     {
         // Body is injected by JavassistProxyFactory
         return null;

File: src/main/java/com/zaxxer/hikari/proxy/IHikariConnectionProxy.java
Patch:
@@ -20,11 +20,13 @@
 import java.sql.SQLException;
 import java.util.Timer;
 
+import com.zaxxer.hikari.util.ConcurrentBag.IBagManagable;
+
 /**
  *
  * @author Brett Wooldridge
  */
-public interface IHikariConnectionProxy extends Connection
+public interface IHikariConnectionProxy extends Connection, IBagManagable
 {
     void unclose();
 

File: src/main/java/com/zaxxer/hikari/util/FastStatementList.java
Patch:
@@ -57,7 +57,8 @@ public void add(Statement element)
     {
         try
         {
-            elementData[size++] = element;
+            elementData[size] = element;
+            size++;
         }
         catch (ArrayIndexOutOfBoundsException oob)
         {
@@ -66,7 +67,7 @@ public void add(Statement element)
             int newCapacity = oldCapacity << 1;
             Statement[] newElementData = new Statement[newCapacity];
             System.arraycopy(elementData, 0, newElementData, 0, oldCapacity);
-            newElementData[size] = element;
+            newElementData[size++] = element;
             elementData = (Statement[]) newElementData;
         }
     }

File: src/test/java/com/zaxxer/hikari/TestFastStatementList.java
Patch:
@@ -19,7 +19,7 @@ public void testOverflow()
 
         for (int i = 0; i < 100; i++)
         {
-            Assert.assertNotNull(list.get(i));
+            Assert.assertNotNull("Element " + i, list.get(i));
         }
     }
 }

File: src/main/java/com/zaxxer/hikari/util/FastStatementList.java
Patch:
@@ -62,12 +62,11 @@ public void add(Statement element)
         catch (ArrayIndexOutOfBoundsException oob)
         {
             // overflow-conscious code
-            size--;
             int oldCapacity = elementData.length;
             int newCapacity = oldCapacity << 1;
             Statement[] newElementData = new Statement[newCapacity];
             System.arraycopy(elementData, 0, newElementData, 0, oldCapacity);
-            newElementData[size++] = element;
+            newElementData[size] = element;
             elementData = (Statement[]) newElementData;
         }
     }

File: src/main/java/com/zaxxer/hikari/util/FastStatementList.java
Patch:
@@ -35,7 +35,7 @@ public final class FastStatementList
      */
     public FastStatementList()
     {
-        this.elementData = new Statement[16];
+        this.elementData = new Statement[32];
     }
 
     /**
@@ -64,7 +64,7 @@ public void add(Statement element)
             // overflow-conscious code
             size--;
             int oldCapacity = elementData.length;
-            int newCapacity = oldCapacity << 2;
+            int newCapacity = oldCapacity << 1;
             Statement[] newElementData = new Statement[newCapacity];
             System.arraycopy(elementData, 0, newElementData, 0, oldCapacity);
             newElementData[size++] = element;

File: src/main/java/com/zaxxer/hikari/util/FastStatementList.java
Patch:
@@ -62,6 +62,7 @@ public void add(Statement element)
         catch (ArrayIndexOutOfBoundsException oob)
         {
             // overflow-conscious code
+        	size--;
             int oldCapacity = elementData.length;
             int newCapacity = oldCapacity << 2;
             Statement[] newElementData = new Statement[newCapacity];

File: src/main/java/com/zaxxer/hikari/util/FastStatementList.java
Patch:
@@ -62,6 +62,7 @@ public void add(Statement element)
         catch (ArrayIndexOutOfBoundsException oob)
         {
             // overflow-conscious code
+        	size--;
             int oldCapacity = elementData.length;
             int newCapacity = oldCapacity << 2;
             Statement[] newElementData = new Statement[newCapacity];

File: src/main/java/com/zaxxer/hikari/HikariPool.java
Patch:
@@ -237,6 +237,7 @@ public void releaseConnection(IHikariConnectionProxy connectionProxy)
         }
         else
         {
+            LOGGER.debug("Connection returned to pool is broken, or the pool is shutting down.  Closing connection.");
             closeConnection(connectionProxy);
         }
     }

File: src/test/java/com/zaxxer/hikari/CreationTest.java
Patch:
@@ -177,7 +177,7 @@ public void testBackfill() throws Exception
 
         try
         {
-            resultSet.getFloat(1);
+            statement.getMaxFieldSize();
             Assert.fail();
         }
         catch (Exception e)

File: src/test/java/com/zaxxer/hikari/ExceptionTest.java
Patch:
@@ -39,7 +39,7 @@ public void testException1() throws SQLException
 
         try
         {
-            resultSet.getFloat(1);
+            statement.getMaxFieldSize();
             Assert.fail();
         }
         catch (Exception e)

File: src/test/java/com/zaxxer/hikari/mocks/StubPreparedStatement.java
Patch:
@@ -65,7 +65,7 @@ public int executeUpdate(String sql) throws SQLException
     /** {@inheritDoc} */
     public int getMaxFieldSize() throws SQLException
     {
-        return 0;
+        throw new SQLException("No reason", "08999");
     }
 
     /** {@inheritDoc} */

File: src/main/java/com/zaxxer/hikari/HikariPool.java
Patch:
@@ -237,6 +237,7 @@ public void releaseConnection(IHikariConnectionProxy connectionProxy)
         }
         else
         {
+            LOGGER.debug("Connection returned to pool is broken, or the pool is shutting down.  Closing connection.");
             closeConnection(connectionProxy);
         }
     }

File: src/test/java/com/zaxxer/hikari/CreationTest.java
Patch:
@@ -177,7 +177,7 @@ public void testBackfill() throws Exception
 
         try
         {
-            resultSet.getFloat(1);
+            statement.getMaxFieldSize();
             Assert.fail();
         }
         catch (Exception e)

File: src/test/java/com/zaxxer/hikari/ExceptionTest.java
Patch:
@@ -39,7 +39,7 @@ public void testException1() throws SQLException
 
         try
         {
-            resultSet.getFloat(1);
+            statement.getMaxFieldSize();
             Assert.fail();
         }
         catch (Exception e)

File: src/test/java/com/zaxxer/hikari/mocks/StubPreparedStatement.java
Patch:
@@ -65,7 +65,7 @@ public int executeUpdate(String sql) throws SQLException
     /** {@inheritDoc} */
     public int getMaxFieldSize() throws SQLException
     {
-        return 0;
+        throw new SQLException("No reason", "08999");
     }
 
     /** {@inheritDoc} */

File: src/main/java/com/zaxxer/hikari/util/FastStatementList.java
Patch:
@@ -91,7 +91,7 @@ public Statement get(int index)
      */
     public void remove(Object element)
     {
-        for (int index = size - 1; index >= 0; index++)
+        for (int index = size - 1; index >= 0; index--)
         {
             if (element == elementData[index])
             {

File: src/main/java/com/zaxxer/hikari/HikariPool.java
Patch:
@@ -429,7 +429,7 @@ private boolean isConnectionAlive(final IHikariConnectionProxy connection, long
         }
         catch (SQLException e)
         {
-            LOGGER.error("Exception during keep alive check.  Connection must be dead.", e);
+            LOGGER.warn("Exception during keep alive check, that means the connection must be dead.", e);
             return false;
         }
     }

File: core/src/main/java/com/zaxxer/hikari/HikariPool.java
Patch:
@@ -462,7 +462,7 @@ private void logPoolState(String... prefix)
     {
         int total = totalConnections.get();
         int idle = idleConnectionCount.get();
-        LOGGER.debug("{}Pool stats (total={}, inUse={}, avail={}", (prefix != null ? prefix : ""), total, total - idle, idle);
+        LOGGER.debug("{}Pool stats (total={}, inUse={}, avail={})", (prefix != null ? prefix[0] : ""), total, total - idle, idle);
     }
 
     /**

File: core/src/main/java/com/zaxxer/hikari/HikariPool.java
Patch:
@@ -267,7 +267,7 @@ private void fillPool()
             addConnection();
         }
 
-        logPoolState();
+        logPoolState("Initial fill ");
     }
 
     /**

File: core/src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -403,7 +403,7 @@ else if (connectionTimeout < 100)
             logger.error("idleTimeout cannot be negative.");
             throw new IllegalStateException("idleTimeout cannot be negative.");
         }
-        else if (idleTimeout < 30000)
+        else if (idleTimeout < 30000 && idleTimeout != 0)
         {
             logger.warn("idleTimeout is less than 30000ms, did you specify the wrong time unit?  Using default instead.");
             idleTimeout = IDLE_TIMEOUT;
@@ -438,7 +438,7 @@ else if (idleTimeout < 30000)
             logger.error("maxLifetime cannot be negative.");
             throw new IllegalStateException("maxLifetime cannot be negative.");
         }
-        else if (maxLifetime < 120000)
+        else if (maxLifetime < 120000 && maxLifetime != 0)
         {
             logger.warn("maxLifetime is less than 120000ms, did you specify the wrong time unit?  Using default instead.");
             maxLifetime = MAX_LIFETIME;

File: core/src/main/java/com/zaxxer/hikari/proxy/IHikariStatementProxy.java
Patch:
@@ -1,9 +1,9 @@
 package com.zaxxer.hikari.proxy;
 
-import java.sql.CallableStatement;
 import java.sql.SQLException;
+import java.sql.Statement;
 
-public interface IHikariStatementProxy extends CallableStatement
+public interface IHikariStatementProxy extends Statement
 {
     void close() throws SQLException;
 

File: core/src/main/java/com/zaxxer/hikari/proxy/IHikariStatementProxy.java
Patch:
@@ -1,9 +1,9 @@
 package com.zaxxer.hikari.proxy;
 
-import java.sql.CallableStatement;
 import java.sql.SQLException;
+import java.sql.Statement;
 
-public interface IHikariStatementProxy extends CallableStatement
+public interface IHikariStatementProxy extends Statement
 {
     void close() throws SQLException;
 

File: core/src/main/java/com/zaxxer/hikari/javassist/AgentRegistrationElf.java
Patch:
@@ -55,6 +55,8 @@ public static boolean loadTransformerAgent(String dsClassName, String shadedCode
             HikariClassTransformer transformer = new HikariClassTransformer();
             systemProperties.put("com.zaxxer.hikari.transformer", transformer);
 
+            LOGGER.info("Using HikariCP agent jar found at: {}", agentJarPath);
+
             registerInstrumentation(agentJarPath);
             LOGGER.info("Successfully loaded instrumentation agent.  Scanning classes...");
 

File: core/src/main/java/com/zaxxer/hikari/proxy/IHikariConnectionProxy.java
Patch:
@@ -26,15 +26,15 @@
  *
  * @author Brett Wooldridge
  */
-public interface IHikariConnectionProxy
+public interface IHikariConnectionProxy extends Connection
 {
     void _unclose();
 
     void __close() throws SQLException;
 
     void _unregisterStatement(Object statement);
 
-    SQLException _checkException(SQLException sqle);
+    void _checkException(SQLException sqle);
 
     boolean _isBrokenConnection();
 

File: core/src/main/java/com/zaxxer/hikari/proxy/IHikariStatementProxy.java
Patch:
@@ -1,8 +1,9 @@
 package com.zaxxer.hikari.proxy;
 
+import java.sql.CallableStatement;
 import java.sql.SQLException;
 
-public interface IHikariStatementProxy
+public interface IHikariStatementProxy extends CallableStatement
 {
     void close() throws SQLException;
 
@@ -12,5 +13,5 @@ public interface IHikariStatementProxy
 
     void _releaseResultSet(IHikariResultSetProxy resultSet);
 
-    SQLException _checkException(SQLException e);
+    void _checkException(SQLException e);
 }

File: core/src/main/java/com/zaxxer/hikari/proxy/PreparedStatementProxy.java
Patch:
@@ -63,7 +63,8 @@ public ResultSet executeQuery() throws SQLException
     	}
     	catch (SQLException e)
     	{
-    		throw _checkException(e);
+            _connection._checkException(e);
+            throw e;
     	}
     }
 

File: core/src/main/java/com/zaxxer/hikari/proxy/ResultSetProxy.java
Patch:
@@ -50,9 +50,9 @@ protected ResultSetProxy(IHikariStatementProxy statement, ResultSet resultSet)
     }
 
     @HikariInject
-    public SQLException _checkException(SQLException e)
+    public final void _checkException(SQLException e)
     {
-        return _statement._checkException(e);
+        _statement._checkException(e);
     }
 
     @HikariInject

File: core/src/test/java/com/zaxxer/hikari/mocks/StubDataSource.java
Patch:
@@ -32,6 +32,7 @@ public class StubDataSource implements DataSource
 {
     private String user;
     private String password;
+    private PrintWriter logWriter;
 
     public String getUser()
     {
@@ -56,12 +57,13 @@ public void setPassword(String password)
     /** {@inheritDoc} */
     public PrintWriter getLogWriter() throws SQLException
     {
-        return null;
+        return logWriter;
     }
 
     /** {@inheritDoc} */
     public void setLogWriter(PrintWriter out) throws SQLException
     {
+        this.logWriter = out;
     }
 
     /** {@inheritDoc} */

File: core/src/main/java/com/zaxxer/hikari/HikariPool.java
Patch:
@@ -46,13 +46,14 @@ public final class HikariPool implements HikariPoolMBean
 {
     private static final Logger LOGGER = LoggerFactory.getLogger(HikariPool.class);
 
+    final DataSource dataSource;
+
     private final HikariConfig configuration;
     private final LinkedTransferQueue<IHikariConnectionProxy> idleConnections;
 
     private final AtomicInteger totalConnections;
     private final AtomicInteger idleConnectionCount;
     private final AtomicBoolean backgroundFillQueued;
-    private final DataSource dataSource;
     private final long leakDetectionThreshold;
     private final boolean jdbc4ConnectionTest;
     private final boolean isAutoCommit;

File: core/src/test/java/com/zaxxer/hikari/mocks/StubDataSource.java
Patch:
@@ -32,6 +32,7 @@ public class StubDataSource implements DataSource
 {
     private String user;
     private String password;
+    private PrintWriter logWriter;
 
     public String getUser()
     {
@@ -56,12 +57,13 @@ public void setPassword(String password)
     /** {@inheritDoc} */
     public PrintWriter getLogWriter() throws SQLException
     {
-        return null;
+        return logWriter;
     }
 
     /** {@inheritDoc} */
     public void setLogWriter(PrintWriter out) throws SQLException
     {
+        this.logWriter = out;
     }
 
     /** {@inheritDoc} */

File: core/src/main/java/com/zaxxer/hikari/javassist/HikariClassTransformer.java
Patch:
@@ -419,6 +419,7 @@ private void specialConnectionInjectCloseCheck(CtClass targetClass) throws Excep
             {
                 if ("java.sql.SQLException".equals(exception.getName()))         // only add check to methods throwing SQLException
                 {
+                    LOGGER.debug("Injecting _checkClosed() call into {}{}", method.getName(), method.getSignature());
                     method.insertBefore("_checkClosed();");
                     break;
                 }

File: core/src/main/java/com/zaxxer/hikari/javassist/HikariClassTransformer.java
Patch:
@@ -212,7 +212,7 @@ private byte[] transformConnectionSubclass(ClassFile classFile) throws Exception
 
         if (LOGGER.isDebugEnabled())
         {
-            target.debugWriteFile("/tmp");
+            target.debugWriteFile(System.getProperty("java.io.tmpdir"));
         }
         return target.toBytecode();
     }

File: core/src/main/java/com/zaxxer/hikari/HikariPool.java
Patch:
@@ -304,7 +304,7 @@ public void run()
                         }
                         backgroundFillQueued.set(false);
                     }
-    	        }, configuration.getConnectionTimeout() - 50/*ms*/);
+    	        }, 50/*ms*/);
     	    }
     	    break;
     	}

File: core/src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -67,7 +67,7 @@ public HikariConfig()
     {
         dataSourceProperties = new Properties();
 
-        acquireIncrement = 5;
+        acquireIncrement = 1;
         acquireRetries = 3;
         acquireRetryDelay = ACQUIRE_RETRY_DELAY;
         connectionTimeout = CONNECTION_TIMEOUT;
@@ -186,9 +186,9 @@ public long getConnectionTimeout()
     /** {@inheritDoc} */
     public void setConnectionTimeout(long connectionTimeoutMs)
     {
-        if (connectionTimeoutMs < 0)
+        if (connectionTimeoutMs < 100)
         {
-            throw new IllegalArgumentException("connectionTimeout cannot be negative");
+            throw new IllegalArgumentException("connectionTimeout cannot be less than 100ms");
         }
         if (connectionTimeoutMs == 0)
         {

File: core/src/main/java/com/zaxxer/hikari/javassist/AgentRegistrationElf.java
Patch:
@@ -44,7 +44,7 @@ public static boolean loadTransformerAgent(String dsClassName, String shadedCode
         String agentJarPath = getAgentJarPath();
         if (agentJarPath == null)
         {
-            LOGGER.warn("Cannot find the HikariCP-agent jar file through introspection.");
+            LOGGER.info("Cannot find the HikariCP-agent jar file through introspection.");
             return false;
         }
 

File: core/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -41,11 +41,11 @@
  *  2) If instrumentation IS used, Javassist will be used to inject all of
  *     the &amp;HikariInject and &amp;HikariOverride annotated fields and methods
  *     of this class into the  actual Connection implementation provided by the
- *     JDBC driver.  In order to avoid name conflicts some of the fields and
- *     methods are prefixed with _ or __.
+ *     JDBC driver.  In order to avoid name conflicts when injecting code into
+ *     a driver class some of the fields and methods are prefixed with _ or __.
  *     
  *     Methods prefixed with __, like __createStatement() are especially
- *     important because when we inject out own createStatement() into the
+ *     important because when we inject our own createStatement() into the
  *     target implementation, the original method is renamed to __createStatement()
  *     so that the call operates the same whether delegation or instrumentation
  *     is used.

File: core/src/main/java/com/zaxxer/hikari/proxy/ResultSetProxy.java
Patch:
@@ -27,13 +27,13 @@
  * 
  *  1) If instrumentation is not used, Javassist will generate a new class
  *     that extends this class and delegates all method calls to the 'delegate'
- *     member (which points to the real Connection).
+ *     member (which points to the real ResultSet).
  *
  *  2) If instrumentation IS used, Javassist will be used to inject all of
  *     the &amp;HikariInject and &amp;HikariOverride annotated fields and methods
  *     of this class into the actual ResultSet implementation provided by the
- *     JDBC driver.  In order to avoid name conflicts some of the fields and
- *     methods are prefixed with _ or __.
+ *     JDBC driver.  In order to avoid name conflicts when injecting code into
+ *     a driver class some of the fields and methods are prefixed with _ or __.
  *
  * @author Brett Wooldridge
  */

File: core/src/main/java/com/zaxxer/hikari/proxy/ConnectionProxy.java
Patch:
@@ -41,11 +41,11 @@
  *  2) If instrumentation IS used, Javassist will be used to inject all of
  *     the &amp;HikariInject and &amp;HikariOverride annotated fields and methods
  *     of this class into the  actual Connection implementation provided by the
- *     JDBC driver.  In order to avoid name conflicts some of the fields and
- *     methods are prefixed with _ or __.
+ *     JDBC driver.  In order to avoid name conflicts when injecting code into
+ *     a driver class some of the fields and methods are prefixed with _ or __.
  *     
  *     Methods prefixed with __, like __createStatement() are especially
- *     important because when we inject out own createStatement() into the
+ *     important because when we inject our own createStatement() into the
  *     target implementation, the original method is renamed to __createStatement()
  *     so that the call operates the same whether delegation or instrumentation
  *     is used.

File: core/src/main/java/com/zaxxer/hikari/proxy/ResultSetProxy.java
Patch:
@@ -27,13 +27,13 @@
  * 
  *  1) If instrumentation is not used, Javassist will generate a new class
  *     that extends this class and delegates all method calls to the 'delegate'
- *     member (which points to the real Connection).
+ *     member (which points to the real ResultSet).
  *
  *  2) If instrumentation IS used, Javassist will be used to inject all of
  *     the &amp;HikariInject and &amp;HikariOverride annotated fields and methods
  *     of this class into the actual ResultSet implementation provided by the
- *     JDBC driver.  In order to avoid name conflicts some of the fields and
- *     methods are prefixed with _ or __.
+ *     JDBC driver.  In order to avoid name conflicts when injecting code into
+ *     a driver class some of the fields and methods are prefixed with _ or __.
  *
  * @author Brett Wooldridge
  */

File: core/src/main/java/com/zaxxer/hikari/javassist/AgentRegistrationElf.java
Patch:
@@ -44,7 +44,7 @@ public static boolean loadTransformerAgent(String dsClassName, String shadedCode
         String agentJarPath = getAgentJarPath();
         if (agentJarPath == null)
         {
-            LOGGER.warn("Cannot find the HikariCP jar file through introspection.");
+            LOGGER.warn("Cannot find the HikariCP-agent jar file through introspection.");
             return false;
         }
 

File: core/src/test/java/com/zaxxer/hikari/CreationTest.java
Patch:
@@ -92,12 +92,13 @@ public void testMaxLifetime() throws Exception
         config.setMinimumPoolSize(1);
         config.setMaximumPoolSize(1);
         config.setAcquireIncrement(1);
-        config.setMaxLifetime(500);
         config.setConnectionTestQuery("VALUES 1");
         config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 
         HikariDataSource ds = new HikariDataSource(config);
 
+        config.setMaxLifetime(500);
+
         Assert.assertSame("Totals connections not as expected", 1, ds.pool.getTotalConnections());
         Assert.assertSame("Idle connections not as expected", 1, ds.pool.getIdleConnections());
 
@@ -132,7 +133,6 @@ public void testDoubleClose() throws Exception
         config.setMinimumPoolSize(1);
         config.setMaximumPoolSize(1);
         config.setAcquireIncrement(1);
-        config.setMaxLifetime(500);
         config.setConnectionTestQuery("VALUES 1");
         config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 

File: src/test/java/com/zaxxer/hikari/performance/Benchmark1.java
Patch:
@@ -58,6 +58,7 @@ else if (args[0].equals("bone"))
         System.out.println("\nMixedBench");
         System.out.println(" Warming up JIT");
         benchmarks.startMixedBench();
+        benchmarks.startMixedBench();
         System.out.println(" MixedBench Final Timing Runs");
         benchmarks.startMixedBench();
         benchmarks.startMixedBench();
@@ -67,6 +68,7 @@ else if (args[0].equals("bone"))
         System.out.println("\nBoneBench");
         System.out.println(" Warming up JIT");
         benchmarks.startSillyBench();
+        benchmarks.startSillyBench();
         System.out.println(" BoneBench Final Timing Run");
         benchmarks.startSillyBench();
         benchmarks.startSillyBench();
@@ -83,7 +85,6 @@ private DataSource setupHikari()
         config.setConnectionTimeout(8000);
         config.setIdleTimeout(TimeUnit.MINUTES.toMillis(30));
         config.setJdbc4ConnectionTest(true);
-        config.setPoolName("This has spaces");
         config.setDataSourceClassName("com.zaxxer.hikari.mocks.StubDataSource");
 
         HikariDataSource ds = new HikariDataSource(config);
@@ -94,7 +95,7 @@ private DataSource setupBone()
     {
         try
         {
-            Class.forName("com.zaxxer.hikari.performance.StubDriver");
+            Class.forName("com.zaxxer.hikari.mocks.StubDriver");
         }
         catch (ClassNotFoundException e)
         {

File: src/main/java/com/zaxxer/hikari/HikariPool.java
Patch:
@@ -217,7 +217,7 @@ public void closeIdleConnections()
 
     private void fillPool()
     {
-        int maxIters = configuration.getMinimumPoolSize() / configuration.getAcquireIncrement();
+        int maxIters = (configuration.getMinimumPoolSize() / configuration.getAcquireIncrement()) + 1;
         while (totalConnections.get() < configuration.getMinimumPoolSize() && maxIters-- > 0)
         {
             addConnections();

File: src/test/java/com/zaxxer/hikari/CreationTest.java
Patch:
@@ -39,6 +39,7 @@ public void testCreate() throws SQLException
     {
         HikariConfig config = new HikariConfig();
         config.setMinimumPoolSize(1);
+        config.setAcquireIncrement(1);
         config.setConnectionTestQuery("VALUES 1");
         config.setDataSourceClassName("com.zaxxer.hikari.mocks.MockDataSource");
 
@@ -77,6 +78,7 @@ public void testMaxLifetime() throws Exception
     {
         HikariConfig config = new HikariConfig();
         config.setMinimumPoolSize(1);
+        config.setAcquireIncrement(1);
         config.setMaxLifetime(500);
         config.setConnectionTestQuery("VALUES 1");
         config.setDataSourceClassName("com.zaxxer.hikari.mocks.MockDataSource");

File: src/test/java/com/zaxxer/hikari/mocks/MockDataSource.java
Patch:
@@ -99,6 +99,7 @@ public static Connection createMockConnection() throws SQLException {
         when(mockConnection.createStatement()).thenReturn(statement);
         when(mockConnection.createStatement(anyInt(), anyInt())).thenReturn(statement);
         when(mockConnection.createStatement(anyInt(), anyInt(), anyInt())).thenReturn(statement);
+        when(mockConnection.isValid(anyInt())).thenReturn(true);
 
         // Handle Connection.prepareStatement()
         PreparedStatement mockPreparedStatement = mock(PreparedStatement.class);

File: src/main/java/com/zaxxer/hikari/ConnectionProxy.java
Patch:
@@ -54,7 +54,7 @@ public class ConnectionProxy extends HikariProxyBase<Connection> implements IHik
     {
         openStatements = new ArrayList<Statement>(64);
         isClosed = new AtomicBoolean();
-        creationTime = System.currentTimeMillis();
+        creationTime = lastAccess = System.currentTimeMillis();
     }
 
     /**

File: src/main/java/com/zaxxer/hikari/HikariConfig.java
Patch:
@@ -55,6 +55,7 @@ public HikariConfig()
         connectionTimeout = Integer.MAX_VALUE;
         idleTimeout = TimeUnit.MINUTES.toMillis(30);
         proxyFactoryType = "auto";
+        isJdbc4connectionTest = true;
     }
 
     public HikariConfig(String propertyFileName)

File: src/main/java/com/zaxxer/hikari/ConnectionProxy.java
Patch:
@@ -73,7 +73,7 @@ void initialize(HikariPool parentPool, Connection connection)
         this.delegate = connection;
     }
 
-    void unregisterStatement(Statement statement)
+    void unregisterStatement(Object statement)
     {
         openStatements.remove(statement);
     }
@@ -128,9 +128,9 @@ public void close() throws SQLException
     {
         if (isClosed.compareAndSet(false, true))
         {
-            for (Statement statement : openStatements)
+            for (Object statement : openStatements)
             {
-                statement.close();
+                ((Statement) statement).close();
             }
 
             parentPool.releaseConnection((IHikariConnectionProxy) proxy);

File: src/main/java/com/zaxxer/hikari/PreparedStatementProxy.java
Patch:
@@ -63,8 +63,9 @@ public void close() throws SQLException
             return;
         }
 
-        connection.unregisterStatement(delegate);
+        connection.unregisterStatement(proxy);
         delegate.close();
+        delegate = null;
     }
 
     public ResultSet getResultSet() throws SQLException

File: src/main/java/com/zaxxer/hikari/StatementProxy.java
Patch:
@@ -57,8 +57,9 @@ public void close() throws SQLException
             return;
         }
 
-        connection.unregisterStatement(delegate);
+        connection.unregisterStatement(proxy);
         delegate.close();
+        delegate = null;
     }
 
     public ResultSet executeQuery(String sql) throws SQLException

