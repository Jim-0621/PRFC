File: src/main/java/com/williamfiset/algorithms/datastructures/suffixarray/SuffixArray.java
Patch:
@@ -88,6 +88,7 @@ private void kasai() {
 
   @Override
   public String toString() {
+    if (!constructedLcpArray) buildLcpArray();
     StringBuilder sb = new StringBuilder();
     sb.append("-----i-----SA-----LCP---Suffix\n");
 

File: src/test/java/com/williamfiset/algorithms/datastructures/balancedtree/AVLTreeTest.java
Patch:
@@ -6,8 +6,8 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.TreeSet;
-import org.junit.Before;
-import org.junit.Test;
+
+import org.junit.jupiter.api.*;
 
 public class AVLTreeTest {
 
@@ -18,7 +18,7 @@ public class AVLTreeTest {
 
   private AVLTreeRecursive<Integer> tree;
 
-  @Before
+  @BeforeEach
   public void setup() {
     tree = new AVLTreeRecursive<>();
   }

File: src/test/java/com/williamfiset/algorithms/datastructures/binarysearchtree/SplayTreeTest.java
Patch:
@@ -4,7 +4,8 @@
 
 import com.williamfiset.algorithms.datastructures.utils.TestUtils;
 import java.util.*;
-import org.junit.Test;
+
+import org.junit.jupiter.api.Test;
 
 public class SplayTreeTest {
 

File: src/test/java/com/williamfiset/algorithms/datastructures/bloomfilter/BloomFilterTest.java
Patch:
@@ -6,8 +6,8 @@
 import java.util.HashSet;
 import java.util.Random;
 import java.util.Set;
-import org.junit.Before;
-import org.junit.Test;
+
+import org.junit.jupiter.api.*;
 
 public class BloomFilterTest {
 
@@ -20,7 +20,7 @@ public class BloomFilterTest {
   static final int TEST_SZ = 1000;
   static final int LOOPS = 1000;
 
-  @Before
+  @BeforeEach
   public void setup() {}
 
   @Test

File: src/test/java/com/williamfiset/algorithms/datastructures/priorityqueue/BinaryHeapQuickRemovalsTest.java
Patch:
@@ -6,14 +6,15 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.PriorityQueue;
-import org.junit.*;
+
+import org.junit.jupiter.api.*;
 
 public class BinaryHeapQuickRemovalsTest {
 
   static final int LOOPS = 100;
   static final int MAX_SZ = 100;
 
-  @Before
+  @BeforeEach
   public void setup() {}
 
   @Test

File: src/test/java/com/williamfiset/algorithms/datastructures/priorityqueue/BinaryHeapTest.java
Patch:
@@ -6,14 +6,15 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.PriorityQueue;
-import org.junit.*;
+
+import org.junit.jupiter.api.*;
 
 public class BinaryHeapTest {
 
   static final int LOOPS = 100;
   static final int MAX_SZ = 100;
 
-  @Before
+  @BeforeEach
   public void setup() {}
 
   @Test

File: src/test/java/com/williamfiset/algorithms/datastructures/priorityqueue/MinDHeapTest.java
Patch:
@@ -6,15 +6,15 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.PriorityQueue;
-import org.junit.Before;
-import org.junit.Test;
+
+import org.junit.jupiter.api.*;
 
 public class MinDHeapTest {
 
   static final int LOOPS = 1000;
   static final int MAX_SZ = 100;
 
-  @Before
+  @BeforeEach
   public void setup() {}
 
   @Test

File: src/test/java/com/williamfiset/algorithms/datastructures/quadtree/QuadTreeTest.java
Patch:
@@ -2,16 +2,15 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import org.junit.Before;
-import org.junit.Test;
+import org.junit.jupiter.api.*;
 
 public class QuadTreeTest {
 
   static final int LOOPS = 50;
   static final int TEST_SZ = 1000;
   static final int MAX_RAND_NUM = +2000;
 
-  @Before
+  @BeforeEach
   public void setup() {}
 
   @Test

File: src/test/java/com/williamfiset/algorithms/datastructures/queue/IntQueueTest.java
Patch:
@@ -3,12 +3,12 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import java.util.*;
-import org.junit.Before;
-import org.junit.Test;
+
+import org.junit.jupiter.api.*;
 
 public class IntQueueTest {
 
-  @Before
+  @BeforeEach
   public void setup() {}
 
   @Test

File: src/test/java/com/williamfiset/algorithms/datastructures/segmenttree/GenericSegmentTree2Test.java
Patch:
@@ -7,15 +7,15 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.williamfiset.algorithms.utils.TestUtils;
-import org.junit.Before;
-import org.junit.Test;
+
+import org.junit.jupiter.api.*;
 
 public class GenericSegmentTree2Test {
 
   static int ITERATIONS = 100;
   static int MAX_N = 28;
 
-  @Before
+  @BeforeEach
   public void setup() {}
 
   @Test

File: src/test/java/com/williamfiset/algorithms/datastructures/segmenttree/GenericSegmentTreeTest.java
Patch:
@@ -7,7 +7,8 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.williamfiset.algorithms.utils.TestUtils;
-import org.junit.Test;
+
+import org.junit.jupiter.api.Test;
 
 public class GenericSegmentTreeTest {
 

File: src/test/java/com/williamfiset/algorithms/datastructures/segmenttree/MaxQuerySumUpdateSegmentTreeTest.java
Patch:
@@ -7,14 +7,14 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.williamfiset.algorithms.utils.TestUtils;
-import org.junit.Before;
-import org.junit.Test;
+
+import org.junit.jupiter.api.*;
 
 public class MaxQuerySumUpdateSegmentTreeTest {
 
   static int ITERATIONS = 1000;
 
-  @Before
+  @BeforeEach
   public void setup() {}
 
   @Test

File: src/test/java/com/williamfiset/algorithms/datastructures/segmenttree/MinQueryAssignUpdateSegmentTreeTest.java
Patch:
@@ -7,14 +7,14 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.williamfiset.algorithms.utils.TestUtils;
-import org.junit.Before;
-import org.junit.Test;
+
+import org.junit.jupiter.api.*;
 
 public class MinQueryAssignUpdateSegmentTreeTest {
 
   static int ITERATIONS = 500;
 
-  @Before
+  @BeforeEach
   public void setup() {}
 
   @Test

File: src/test/java/com/williamfiset/algorithms/datastructures/segmenttree/MinQuerySumUpdateSegmentTreeTest.java
Patch:
@@ -7,14 +7,14 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.williamfiset.algorithms.utils.TestUtils;
-import org.junit.Before;
-import org.junit.Test;
+
+import org.junit.jupiter.api.*;
 
 public class MinQuerySumUpdateSegmentTreeTest {
 
   static int ITERATIONS = 1000;
 
-  @Before
+  @BeforeEach
   public void setup() {}
 
   @Test

File: src/test/java/com/williamfiset/algorithms/datastructures/segmenttree/SumQueryAssignUpdateSegmentTreeTest.java
Patch:
@@ -7,14 +7,14 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.williamfiset.algorithms.utils.TestUtils;
-import org.junit.Before;
-import org.junit.Test;
+
+import org.junit.jupiter.api.*;
 
 public class SumQueryAssignUpdateSegmentTreeTest {
 
   static int ITERATIONS = 100;
 
-  @Before
+  @BeforeEach
   public void setup() {}
 
   @Test

File: src/test/java/com/williamfiset/algorithms/datastructures/segmenttree/SumQueryMultiplicationUpdateSegmentTreeTest.java
Patch:
@@ -7,15 +7,14 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.williamfiset.algorithms.utils.TestUtils;
-import org.junit.Before;
-import org.junit.Test;
+import org.junit.jupiter.api.*;
 
 public class SumQueryMultiplicationUpdateSegmentTreeTest {
 
   static int ITERATIONS = 100;
   static int MAX_N = 28;
 
-  @Before
+  @BeforeEach
   public void setup() {}
 
   @Test

File: src/test/java/com/williamfiset/algorithms/datastructures/segmenttree/SumQuerySumUpdateSegmentTreeTest.java
Patch:
@@ -7,14 +7,14 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import com.williamfiset.algorithms.utils.TestUtils;
-import org.junit.Before;
-import org.junit.Test;
+
+import org.junit.jupiter.api.*;
 
 public class SumQuerySumUpdateSegmentTreeTest {
 
   static int ITERATIONS = 100;
 
-  @Before
+  @BeforeEach
   public void setup() {}
 
   @Test

File: src/test/java/com/williamfiset/algorithms/datastructures/set/HSetTest.java
Patch:
@@ -7,7 +7,8 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Random;
-import org.junit.*;
+
+import org.junit.jupiter.api.*;
 
 // You can set the hash value of this object to be whatever you want
 // This makes it great for testing special cases.
@@ -40,7 +41,7 @@ public class HSetTest {
 
   HSet<Integer> hs;
 
-  @Before
+  @BeforeEach
   public void setup() {
     hs = new HSet<>();
   }

File: src/test/java/com/williamfiset/algorithms/datastructures/sparsetable/SparseTableTest.java
Patch:
@@ -3,7 +3,8 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import java.util.*;
-import org.junit.*;
+
+import org.junit.jupiter.api.*;
 
 public class SparseTableTest {
 

File: src/test/java/com/williamfiset/algorithms/datastructures/suffixarray/SuffixArrayTest.java
Patch:
@@ -4,7 +4,8 @@
 
 import java.security.SecureRandom;
 import java.util.Random;
-import org.junit.*;
+
+import org.junit.jupiter.api.*;
 
 public class SuffixArrayTest {
 
@@ -18,7 +19,7 @@ public class SuffixArrayTest {
 
   String ASCII_LETTERS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
 
-  @Before
+  @BeforeEach
   public void setup() {}
 
   @Test

File: src/test/java/com/williamfiset/algorithms/dp/CoinChangeTest.java
Patch:
@@ -2,10 +2,11 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import java.util.*;
+
 import com.google.common.primitives.Ints;
 import com.williamfiset.algorithms.utils.TestUtils;
-import java.util.*;
-import org.junit.*;
+import org.junit.jupiter.api.*;
 
 public class CoinChangeTest {
 

File: src/test/java/com/williamfiset/algorithms/dp/WeightedMaximumCardinalityMatchingTest.java
Patch:
@@ -3,7 +3,8 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import java.util.*;
-import org.junit.*;
+
+import org.junit.jupiter.api.*;
 
 public class WeightedMaximumCardinalityMatchingTest {
 

File: src/test/java/com/williamfiset/algorithms/geometry/ConvexHullMonotoneChainsAlgorithmTest.java
Patch:
@@ -4,7 +4,8 @@
 
 import com.google.common.collect.ImmutableList;
 import java.awt.geom.*;
-import org.junit.*;
+
+import org.junit.jupiter.api.*;
 
 public class ConvexHullMonotoneChainsAlgorithmTest {
 

File: src/test/java/com/williamfiset/algorithms/geometry/MinimumCostConvexPolygonTriangulationTest.java
Patch:
@@ -3,7 +3,8 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import java.awt.geom.*;
-import org.junit.*;
+
+import org.junit.jupiter.api.*;
 
 public class MinimumCostConvexPolygonTriangulationTest {
 

File: src/test/java/com/williamfiset/algorithms/graphtheory/ArticulationPointsAdjacencyListTest.java
Patch:
@@ -3,7 +3,8 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import java.util.*;
-import org.junit.*;
+
+import org.junit.jupiter.api.*;
 
 public class ArticulationPointsAdjacencyListTest {
 

File: src/test/java/com/williamfiset/algorithms/graphtheory/BridgesAdjacencyListIterativeTest.java
Patch:
@@ -2,10 +2,11 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import com.google.common.collect.ImmutableList;
 import java.util.*;
+
+import com.google.common.collect.ImmutableList;
 import org.apache.commons.lang3.tuple.Pair;
-import org.junit.*;
+import org.junit.jupiter.api.*;
 
 public class BridgesAdjacencyListIterativeTest {
 

File: src/test/java/com/williamfiset/algorithms/graphtheory/BridgesAdjacencyListTest.java
Patch:
@@ -2,10 +2,11 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import com.google.common.collect.ImmutableList;
 import java.util.*;
+
+import com.google.common.collect.ImmutableList;
 import org.apache.commons.lang3.tuple.Pair;
-import org.junit.*;
+import org.junit.jupiter.api.*;
 
 public class BridgesAdjacencyListTest {
 

File: src/test/java/com/williamfiset/algorithms/graphtheory/EulerianPathDirectedEdgesAdjacencyListTest.java
Patch:
@@ -3,13 +3,14 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import java.util.*;
-import org.junit.*;
+
+import org.junit.jupiter.api.*;
 
 public class EulerianPathDirectedEdgesAdjacencyListTest {
 
   EulerianPathDirectedEdgesAdjacencyList solver;
 
-  @Before
+  @BeforeEach
   public void setUp() {
     solver = null;
   }

File: src/test/java/com/williamfiset/algorithms/graphtheory/FloydWarshallSolverTest.java
Patch:
@@ -3,8 +3,8 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import java.util.*;
-import org.junit.Before;
-import org.junit.Test;
+
+import org.junit.jupiter.api.*;
 
 public class FloydWarshallSolverTest {
 
@@ -13,7 +13,7 @@ public class FloydWarshallSolverTest {
 
   static double[][] matrix1, matrix2, matrix3;
 
-  @Before
+  @BeforeEach
   public void setup() {
     matrix1 =
         new double[][] {

File: src/test/java/com/williamfiset/algorithms/graphtheory/SteinerTreeTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import org.junit.*;
+import org.junit.jupiter.api.*;
 
 public class SteinerTreeTest {
 

File: src/test/java/com/williamfiset/algorithms/graphtheory/TwoSatSolverAdjacencyListTest.java
Patch:
@@ -3,7 +3,8 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import java.util.*;
-import org.junit.*;
+
+import org.junit.jupiter.api.*;
 
 public class TwoSatSolverAdjacencyListTest {
 

File: src/test/java/com/williamfiset/algorithms/graphtheory/networkflow/MinCostMaxFlowTests.java
Patch:
@@ -3,13 +3,14 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import java.util.*;
-import org.junit.*;
+
+import org.junit.jupiter.api.*;
 
 public class MinCostMaxFlowTests {
 
   List<NetworkFlowSolverBase> solvers;
 
-  @Before
+  @BeforeEach
   public void setUp() {
     solvers = new ArrayList<>();
   }

File: src/test/java/com/williamfiset/algorithms/graphtheory/treealgorithms/LowestCommonAncestorEulerTourTest.java
Patch:
@@ -3,7 +3,8 @@
 import static com.google.common.truth.Truth.assertThat;
 
 import java.util.*;
-import org.junit.*;
+
+import org.junit.jupiter.api.*;
 
 public class LowestCommonAncestorEulerTourTest {
 

File: src/test/java/com/williamfiset/algorithms/graphtheory/treealgorithms/LowestCommonAncestorTest.java
Patch:
@@ -4,9 +4,10 @@
 import static com.williamfiset.algorithms.graphtheory.treealgorithms.LowestCommonAncestor.addUndirectedEdge;
 import static com.williamfiset.algorithms.graphtheory.treealgorithms.LowestCommonAncestor.createEmptyGraph;
 
-import com.williamfiset.algorithms.graphtheory.treealgorithms.LowestCommonAncestor.TreeNode;
 import java.util.*;
-import org.junit.*;
+
+import com.williamfiset.algorithms.graphtheory.treealgorithms.LowestCommonAncestor.TreeNode;
+import org.junit.jupiter.api.*;
 
 public class LowestCommonAncestorTest {
 

File: src/test/java/com/williamfiset/algorithms/graphtheory/treealgorithms/RootingTreeTest.java
Patch:
@@ -2,9 +2,10 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import com.williamfiset.algorithms.graphtheory.treealgorithms.RootingTree.TreeNode;
 import java.util.*;
-import org.junit.*;
+
+import com.williamfiset.algorithms.graphtheory.treealgorithms.RootingTree.TreeNode;
+import org.junit.jupiter.api.*;
 
 public class RootingTreeTest {
 

File: src/test/java/com/williamfiset/algorithms/graphtheory/treealgorithms/TreeCenterLongestPathImplTest.java
Patch:
@@ -11,7 +11,8 @@
 import static com.williamfiset.algorithms.graphtheory.treealgorithms.TreeCenterLongestPathImpl.findTreeCenters;
 
 import java.util.*;
-import org.junit.*;
+
+import org.junit.jupiter.api.*;
 
 public class TreeCenterLongestPathImplTest {
 

File: src/test/java/com/williamfiset/algorithms/graphtheory/treealgorithms/TreeCenterTest.java
Patch:
@@ -11,7 +11,8 @@
 import static com.williamfiset.algorithms.graphtheory.treealgorithms.TreeCenter.findTreeCenters;
 
 import java.util.*;
-import org.junit.*;
+
+import org.junit.jupiter.api.*;
 
 public class TreeCenterTest {
 

File: src/test/java/com/williamfiset/algorithms/graphtheory/treealgorithms/TreeIsomorphismWithBfsTest.java
Patch:
@@ -13,7 +13,8 @@
 import static com.williamfiset.algorithms.graphtheory.treealgorithms.TreeIsomorphismWithBfs.treesAreIsomorphic;
 
 import java.util.*;
-import org.junit.*;
+
+import org.junit.jupiter.api.*;
 
 public class TreeIsomorphismWithBfsTest {
 

File: src/test/java/com/williamfiset/algorithms/other/BitManipulationsTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import org.junit.*;
+import org.junit.jupiter.api.*;
 
 public class BitManipulationsTest {
 

File: src/test/java/com/williamfiset/algorithms/other/LazyRangeAdderTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class LazyRangeAdderTest {
 

File: src/test/java/com/williamfiset/algorithms/other/SlidingWindowMaximumTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import org.junit.*;
+import org.junit.jupiter.api.*;
 
 public class SlidingWindowMaximumTest {
 

File: src/test/java/com/williamfiset/algorithms/sorting/QuickSelectTest.java
Patch:
@@ -4,7 +4,7 @@
 
 import com.williamfiset.algorithms.utils.TestUtils;
 import java.util.Arrays;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class QuickSelectTest {
 

File: src/test/java/com/williamfiset/algorithms/sorting/RadixSortTest.java
Patch:
@@ -4,7 +4,7 @@
 
 import java.util.Arrays;
 import java.util.Random;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 public class RadixSortTest {
   static Random random = new Random();

File: src/test/java/com/williamfiset/algorithms/sorting/SortingTest.java
Patch:
@@ -5,7 +5,7 @@
 import com.williamfiset.algorithms.utils.TestUtils;
 import java.util.Arrays;
 import java.util.EnumSet;
-import org.junit.Test;
+import org.junit.jupiter.api.Test;
 
 // Test all sorting algorithms under various constraints.
 //

File: src/test/java/com/williamfiset/algorithms/strings/BoyerMooreStringSearchTest.java
Patch:
@@ -6,16 +6,16 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Random;
-import org.junit.Before;
-import org.junit.Test;
+
+import org.junit.jupiter.api.*;
 
 public class BoyerMooreStringSearchTest {
 
   private BoyerMooreStringSearch underTest;
   private Random random;
   private final int MAX_ITERATION = 20;
 
-  @Before
+  @BeforeEach
   public void setup() {
     underTest = new BoyerMooreStringSearch();
     random = new Random();

File: src/test/java/com/williamfiset/algorithms/strings/LongestCommonSubstringTest.java
Patch:
@@ -6,10 +6,11 @@
 import static com.google.common.truth.Truth.assertThat;
 import static com.williamfiset.algorithms.strings.LongestCommonSubstring.LcsSolver;
 
+import java.util.*;
+
 import com.google.common.collect.ImmutableList;
 import com.williamfiset.algorithms.utils.TestUtils;
-import java.util.*;
-import org.junit.*;
+import org.junit.jupiter.api.*;
 
 public class LongestCommonSubstringTest {
 

File: src/test/java/com/williamfiset/algorithms/strings/ZAlgorithmTest.java
Patch:
@@ -2,13 +2,12 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import org.junit.Before;
-import org.junit.Test;
+import org.junit.jupiter.api.*;
 
 public class ZAlgorithmTest {
   private ZAlgorithm underTest;
 
-  @Before
+  @BeforeEach
   public void setup() {
     underTest = new ZAlgorithm();
   }

File: src/main/java/com/williamfiset/algorithms/ai/GeneticAlgorithm_textSearch.java
Patch:
@@ -12,7 +12,8 @@ public class GeneticAlgorithm_textSearch {
 
   // Target sentence
   static final String TARGET = "to be or not to be that is the question";
-  static final char[] ALPHA = " abcdefghijklmnopqrstuvwxyz".toCharArray();;
+  static final char[] ALPHA = " abcdefghijklmnopqrstuvwxyz".toCharArray();
+  ;
   static final int TL = TARGET.length();
 
   static final Random RANDOM = new Random();

File: src/main/java/com/williamfiset/algorithms/dp/examples/boardtilings/BoardTilingsSolver.java
Patch:
@@ -1,3 +1,5 @@
+package com.williamfiset.algorithms.dp.examples.boardtilings;
+
 import java.util.*;
 
 public class BoardTilingsSolver {

File: src/main/java/com/williamfiset/algorithms/dp/examples/editdistance/EditDistance.java
Patch:
@@ -1,3 +1,5 @@
+package com.williamfiset.algorithms.dp.examples.editdistance;
+
 import java.io.*;
 import java.util.*;
 

File: src/main/java/com/williamfiset/algorithms/dp/examples/houserobber/HouseRobber.java
Patch:
@@ -14,7 +14,7 @@
  *
  * <p>Run: $ java -cp src/main/java com/williamfiset/algorithms/dp/examples/HouseRobber
  */
-package com.williamfiset.algorithms.dp.examples;
+package com.williamfiset.algorithms.dp.examples.houserobber;
 
 import java.util.*;
 

File: src/main/java/com/williamfiset/algorithms/dp/examples/magicalcows/MagicalCows.java
Patch:
@@ -1,3 +1,5 @@
+package com.williamfiset.algorithms.dp.examples.magicalcows;
+
 /**
  * Solution to Magical Cows (https://open.kattis.com/problems/magicalcows)
  *

File: src/main/java/com/williamfiset/algorithms/dp/examples/narrowartgallery/NarrowArtGalleryRecursive.java
Patch:
@@ -1,3 +1,5 @@
+package com.williamfiset.algorithms.dp.examples.narrowartgallery;
+
 /**
  * Solution to the Narrow Art Gallery problem from the 2014 ICPC North America Qualifier
  *

File: src/main/java/com/williamfiset/algorithms/dp/examples/scenes/Scenes.java
Patch:
@@ -1,3 +1,5 @@
+package com.williamfiset.algorithms.dp.examples.scenes;
+
 /**
  * Solution to the Mountain Scenes problem (https://open.kattis.com/problems/scenes)
  *

File: src/main/java/com/williamfiset/algorithms/dp/examples/tilingdominoes/TilingDominoes.java
Patch:
@@ -1,3 +1,5 @@
+package com.williamfiset.algorithms.dp.examples.tilingdominoes;
+
 /**
  * Solution to Tri Tiling (https://open.kattis.com/problems/tritiling)
  *

File: src/main/java/com/williamfiset/algorithms/datastructures/balancedtree/AVLTreeRecursive.java
Patch:
@@ -253,7 +253,7 @@ private Node remove(Node node, T elem) {
         // successor of the node being removed can either be the largest
         // value in the left subtree or the smallest value in the right
         // subtree. As a heuristic, I will remove from the subtree with
-        // the greatest hieght in hopes that this may help with balancing.
+        // the greatest height in hopes that this may help with balancing.
       } else {
 
         // Choose to remove from left subtree

File: src/main/java/com/williamfiset/algorithms/dp/CoinChange.java
Patch:
@@ -83,9 +83,6 @@ public static Solution coinChange(int[] coins, final int n) {
       if (canSelectCoin && dp[coinIndex][change - coinValue] < dp[coinIndex][change]) {
         solution.selectedCoins.add(coinValue);
         change -= coinValue;
-      } else if (canSelectCoin && dp[coinIndex][change - coinValue] == dp[coinIndex][change]) {
-        System.out.println("here");
-        change -= coinValue;
       } else {
         coinIndex--;
       }

File: src/main/java/com/williamfiset/algorithms/datastructures/linkedlist/DoublyLinkedList.java
Patch:
@@ -79,7 +79,7 @@ public void addFirst(T elem) {
 
   // Add an element at a specified index
   public void addAt(int index, T data) throws Exception {
-    if (index < 0) {
+    if (index < 0 || index > size) {
       throw new Exception("Illegal Index");
     }
     if (index == 0) {

File: src/main/java/com/williamfiset/algorithms/datastructures/linkedlist/DoublyLinkedList.java
Patch:
@@ -79,7 +79,7 @@ public void addFirst(T elem) {
 
   // Add an element at a specified index
   public void addAt(int index, T data) throws Exception {
-    if (index < 0 || index > size) {
+    if (index < 0) {
       throw new Exception("Illegal Index");
     }
     if (index == 0) {

File: src/test/java/com/williamfiset/algorithms/datastructures/linkedlist/LinkedListTest.java
Patch:
@@ -74,8 +74,6 @@ public void testAddAt() throws Exception {
     assertThat(list.size()).isEqualTo(4);
     list.addAt(1, 8);
     assertThat(list.size()).isEqualTo(5);
-    list.addAt(100, 8);
-    assertThat(list.size()).isEqualTo(6);
   }
 
   @Test

File: src/main/java/com/williamfiset/algorithms/datastructures/linkedlist/DoublyLinkedList.java
Patch:
@@ -79,7 +79,7 @@ public void addFirst(T elem) {
 
   // Add an element at a specified index
   public void addAt(int index, T data) throws Exception {
-    if (index < 0) {
+    if (index < 0 || index > size) {
       throw new Exception("Illegal Index");
     }
     if (index == 0) {

File: src/test/java/com/williamfiset/algorithms/datastructures/linkedlist/LinkedListTest.java
Patch:
@@ -74,6 +74,8 @@ public void testAddAt() throws Exception {
     assertThat(list.size()).isEqualTo(4);
     list.addAt(1, 8);
     assertThat(list.size()).isEqualTo(5);
+    list.addAt(100, 8);
+    assertThat(list.size()).isEqualTo(6);
   }
 
   @Test

File: src/main/java/com/williamfiset/algorithms/datastructures/unionfind/UnionFind.java
Patch:
@@ -93,11 +93,11 @@ public void unify(int p, int q) {
     if (sz[root1] < sz[root2]) {
       sz[root2] += sz[root1];
       id[root1] = root2;
-      sz[root2] = 0;
+      sz[root1] = 0;
     } else {
       sz[root1] += sz[root2];
       id[root2] = root1;
-      sz[root1] = 0;
+      sz[root2] = 0;
     }
 
     // Since the roots found are different we know that the

File: src/main/java/com/williamfiset/algorithms/datastructures/unionfind/UnionFind.java
Patch:
@@ -93,11 +93,11 @@ public void unify(int p, int q) {
     if (sz[root1] < sz[root2]) {
       sz[root2] += sz[root1];
       id[root1] = root2;
-      id[root2] = 0;
+      sz[root2] = 0;
     } else {
       sz[root1] += sz[root2];
       id[root2] = root1;
-      id[root1] = 0;
+      sz[root1] = 0;
     }
 
     // Since the roots found are different we know that the

File: src/main/java/com/williamfiset/algorithms/graphtheory/FloydWarshallSolver.java
Patch:
@@ -80,7 +80,7 @@ public void solve() {
     for (int k = 0; k < n; k++)
       for (int i = 0; i < n; i++)
         for (int j = 0; j < n; j++)
-          if (dp[i][k] + dp[k][j] < dp[i][j]) {
+          if (dp[i][k] != POSITIVE_INFINITY && dp[k][j] != POSITIVE_INFINITY && dp[k][k] < 0) {
             dp[i][j] = NEGATIVE_INFINITY;
             next[i][j] = REACHES_NEGATIVE_CYCLE;
           }

File: src/test/java/com/williamfiset/algorithms/graphtheory/EulerianPathDirectedEdgesAdjacencyListTest.java
Patch:
@@ -289,7 +289,7 @@ public void testGraphWithUniquePath() {
     EulerianPathDirectedEdgesAdjacencyList solver;
     solver = new EulerianPathDirectedEdgesAdjacencyList(graph);
     int[] path = solver.getEulerianPath();
-    int[] expected = {6,7,8,9,6,3,0,2,1,3,4};
+    int[] expected = {6, 7, 8, 9, 6, 3, 0, 2, 1, 3, 4};
     assertThat(path).isEqualTo(expected);
   }
 

File: src/test/java/com/williamfiset/algorithms/datastructures/stack/StackTest.java
Patch:
@@ -6,7 +6,6 @@
 import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
-import org.junit.function.ThrowingRunnable;
 
 public class StackTest {
 
@@ -16,6 +15,7 @@ public class StackTest {
   public void setup() {
     stacks.add(new ListStack<Integer>());
     stacks.add(new ArrayStack<Integer>());
+    stacks.add(new IntStack(2));
   }
 
   @Test
@@ -33,10 +33,10 @@ public void testPopOnEmpty() {
     }
   }
 
-  @Test(expected = Exception.class)
+  @Test
   public void testPeekOnEmpty() {
     for (Stack stack : stacks) {
-      assertThrows(Exception.class, (ThrowingRunnable) stack.peek());
+      assertThrows(Exception.class, stack::peek);
     }
   }
 

File: src/test/java/com/williamfiset/algorithms/sorting/SortingTest.java
Patch:
@@ -24,6 +24,7 @@ enum SortingAlgorithm {
     INSERTION_SORT(new InsertionSort()),
     MERGE_SORT(new MergeSort()),
     QUICK_SORT(new QuickSort()),
+    QUICK_SORT3(new QuickSort3()),
     RADIX_SORT(new RadixSort()),
     SELECTION_SORT(new SelectionSort());
 
@@ -47,6 +48,7 @@ public InplaceSort getSortingAlgorithm() {
           SortingAlgorithm.INSERTION_SORT,
           SortingAlgorithm.MERGE_SORT,
           SortingAlgorithm.QUICK_SORT,
+          SortingAlgorithm.QUICK_SORT3,
           SortingAlgorithm.RADIX_SORT,
           SortingAlgorithm.SELECTION_SORT);
 

File: src/main/java/com/williamfiset/algorithms/graphtheory/ArticulationPointsAdjacencyList.java
Patch:
@@ -24,7 +24,7 @@ public class ArticulationPointsAdjacencyList {
   public ArticulationPointsAdjacencyList(List<List<Integer>> graph, int n) {
     if (graph == null || n <= 0 || graph.size() != n) throw new IllegalArgumentException();
     this.graph = graph;
-    this.n = n-1;
+    this.n = n;
   }
 
   // Returns the indexes for all articulation points in the graph even if the

File: src/main/java/com/williamfiset/algorithms/graphtheory/AStar_GridHeuristic.java
Patch:
@@ -96,7 +96,7 @@ public static double astar(
 
           double g = node.g + edge.cost;
           double h = heuristic(X, Y, edge.to, end);
-          
+
           if (g < G[edge.to] || !openSet.contains(edge.to)) {
 
             G[edge.to] = g;

File: src/test/java/com/williamfiset/algorithms/search/InterpolationSearchTest.java
Patch:
@@ -5,7 +5,7 @@
 import org.junit.Test;
 
 public class InterpolationSearchTest {
-  
+
   @Test
   public void testCoverage1() {
     int[] arr = {0, 1, 2, 3, 4, 5};

File: src/main/java/com/williamfiset/algorithms/dp/examples/NarrowArtGalleryRecursive.java
Patch:
@@ -80,5 +80,6 @@ public static void main(String[] Fiset) {
 
       System.out.println(f(K, N));
     }
+    sc.close();
   }
 }

File: src/main/java/com/williamfiset/algorithms/graphtheory/networkflow/examples/FordFulkersonExample.java
Patch:
@@ -99,6 +99,7 @@ public NetworkFlowSolverBase(int n, int s, int t) {
     }
 
     // Constructs an empty graph with n nodes including s and t.
+    @SuppressWarnings("unchecked")
     private void initializeEmptyFlowGraph() {
       graph = new List[n];
       for (int i = 0; i < n; i++) graph[i] = new ArrayList<Edge>();

File: src/main/java/com/williamfiset/algorithms/graphtheory/networkflow/examples/MiceAndOwls.java
Patch:
@@ -164,6 +164,7 @@ public NetworkFlowSolverBase(int n, int s, int t) {
     }
 
     // Constructs an empty graph with n nodes including s and t.
+    @SuppressWarnings("unchecked")
     private void initializeEmptyFlowGraph() {
       graph = new List[n];
       for (int i = 0; i < n; i++) graph[i] = new ArrayList<Edge>();

File: src/main/java/com/williamfiset/algorithms/strings/ManachersAlgorithm.java
Patch:
@@ -51,7 +51,6 @@ private static char[] preProcess(char[] str) {
   // of each palindrome centered at each position.
   public static java.util.TreeSet<String> findPalindromeSubstrings(String str) {
     char[] S = str.toCharArray();
-    int N = S.length;
     int[] centers = manachers(S);
     java.util.TreeSet<String> palindromes = new java.util.TreeSet<>();
 

File: src/test/java/com/williamfiset/algorithms/datastructures/balancedtree/AVLTreeTest.java
Patch:
@@ -115,7 +115,7 @@ public void testRandomizedBalanceFactorTest() {
   }
 
   // Make sure all balance factor values are either -1, 0 or +1
-  static boolean validateBalanceFactorValues(AVLTreeRecursive.Node node) {
+  static boolean validateBalanceFactorValues(AVLTreeRecursive<Integer>.Node node) {
     if (node == null) return true;
     if (node.bf > +1 || node.bf < -1) return false;
     return validateBalanceFactorValues(node.left) && validateBalanceFactorValues(node.right);

File: src/test/java/com/williamfiset/algorithms/datastructures/priorityqueue/MinDHeapTest.java
Patch:
@@ -63,7 +63,7 @@ public void testPriorityRandomOperations() {
       if (p2 < p1) {
         double tmp = p1;
         p1 = p2;
-        p2 = p1;
+        p2 = tmp;
       }
 
       Integer[] ar = genRandArray(LOOPS);

File: src/test/java/com/williamfiset/algorithms/graphtheory/BridgesAdjacencyListIterativeTest.java
Patch:
@@ -81,7 +81,6 @@ public void graphWithCyclesTest() {
     addEdge(graph, 11, 6);
 
     BridgesAdjacencyList solver = new BridgesAdjacencyList(graph, n);
-    List<Integer> bridges = solver.findBridges();
     List<Pair<Integer, Integer>> sortedBridges = getSortedBridges(solver.findBridges());
 
     List<Pair<Integer, Integer>> expected =
@@ -106,7 +105,6 @@ public void testGraphInSlides() {
     addEdge(graph, 8, 5);
 
     BridgesAdjacencyList solver = new BridgesAdjacencyList(graph, n);
-    List<Integer> bridges = solver.findBridges();
     List<Pair<Integer, Integer>> sortedBridges = getSortedBridges(solver.findBridges());
 
     List<Pair<Integer, Integer>> expected =

File: src/test/java/com/williamfiset/algorithms/graphtheory/BridgesAdjacencyListTest.java
Patch:
@@ -81,7 +81,6 @@ public void graphWithCyclesTest() {
     addEdge(graph, 11, 6);
 
     BridgesAdjacencyList solver = new BridgesAdjacencyList(graph, n);
-    List<Integer> bridges = solver.findBridges();
     List<Pair<Integer, Integer>> sortedBridges = getSortedBridges(solver.findBridges());
 
     List<Pair<Integer, Integer>> expected =
@@ -106,7 +105,6 @@ public void testGraphInSlides() {
     addEdge(graph, 8, 5);
 
     BridgesAdjacencyList solver = new BridgesAdjacencyList(graph, n);
-    List<Integer> bridges = solver.findBridges();
     List<Pair<Integer, Integer>> sortedBridges = getSortedBridges(solver.findBridges());
 
     List<Pair<Integer, Integer>> expected =

File: src/test/java/com/williamfiset/algorithms/other/LazyRangeAdderTest.java
Patch:
@@ -13,7 +13,7 @@ public void rangeUpdateTest1() {
     lazyRangeAdder.add(0, 1, 10);
     lazyRangeAdder.add(1, 3, 20);
     lazyRangeAdder.add(2, 2, 30);
-    lazyRangeAdder.finalize();
+    lazyRangeAdder.done();
     int[] expected = {20, 35, 70, 60};
     assertArrayEquals(expected, a);
   }
@@ -25,7 +25,7 @@ public void rangeUpdateTest2() {
     lazyRangeAdder.add(2, 5, 32);
     lazyRangeAdder.add(0, 4, 101);
     lazyRangeAdder.add(5, 6, -73);
-    lazyRangeAdder.finalize();
+    lazyRangeAdder.done();
     int[] expected = {371, 412, 560, 668, 467, 152, 101};
     assertArrayEquals(expected, a);
   }
@@ -54,7 +54,7 @@ public void randomRangeAdditionTests() {
         slowRangeAdd(arr2, l, r, x);
       }
 
-      lazyRangeAdder.finalize();
+      lazyRangeAdder.done();
 
       assertArrayEquals(arr1, arr2);
     }

File: src/main/java/com/williamfiset/algorithms/datastructures/hashtable/HashTableDoubleHashing.java
Patch:
@@ -7,7 +7,7 @@
 
 import java.math.BigInteger;
 
-@SuppressWarnings("unchecked")
+
 public class HashTableDoubleHashing<K extends SecondaryHash, V>
     extends HashTableOpenAddressingBase<K, V> {
 

File: src/main/java/com/williamfiset/algorithms/datastructures/hashtable/HashTableLinearProbing.java
Patch:
@@ -6,7 +6,7 @@
  */
 package com.williamfiset.algorithms.datastructures.hashtable;
 
-@SuppressWarnings("unchecked")
+
 public class HashTableLinearProbing<K, V> extends HashTableOpenAddressingBase<K, V> {
 
   // This is the linear constant used in the linear probing, it can be

File: src/main/java/com/williamfiset/algorithms/datastructures/hashtable/HashTableQuadraticProbing.java
Patch:
@@ -13,7 +13,7 @@
  */
 package com.williamfiset.algorithms.datastructures.hashtable;
 
-@SuppressWarnings("unchecked")
+
 public class HashTableQuadraticProbing<K, V> extends HashTableOpenAddressingBase<K, V> {
 
   public HashTableQuadraticProbing() {

File: src/main/java/com/williamfiset/algorithms/geometry/ConvexPolygonCutWithLineSegment.java
Patch:
@@ -113,8 +113,8 @@ public static void main(String[] args) {
     Pt p1 = new Pt(-1, -1);
     Pt p2 = new Pt(5, 5);
 
-    int l = squarePolygon.length;
-    List list = makeList(squarePolygon);
+    
+    List<Pt> list = makeList(squarePolygon);
     list = sortCW(list);
     squarePolygon = makeArray(list);
 

File: src/test/java/com/williamfiset/algorithms/graphtheory/BridgesAdjacencyListIterativeTest.java
Patch:
@@ -109,7 +109,8 @@ public void testGraphInSlides() {
     List<Integer> bridges = solver.findBridges();
     List<Pair<Integer, Integer>> sortedBridges = getSortedBridges(solver.findBridges());
 
-    List<Pair<Integer, Integer>> expected = ImmutableList.of(Pair.of(2, 3), Pair.of(3, 4), Pair.of(2, 5));
+    List<Pair<Integer, Integer>> expected =
+        ImmutableList.of(Pair.of(2, 3), Pair.of(3, 4), Pair.of(2, 5));
 
     assertThat(sortedBridges).containsExactlyElementsIn(expected);
   }

File: src/test/java/com/williamfiset/algorithms/strings/BoyerMooreStringSearchTest.java
Patch:
@@ -38,8 +38,8 @@ public void shouldReturnOneOccurrence() {
   public void shouldReturnMultiplyOccurrences() {
     assertThat(
             underTest.findOccurrences("Sample text for testing the Boyer-Moore algorithm.", "te"))
-        .containsAllOf(7, 16);
+        .containsExactly(7, 16);
     assertThat(underTest.findOccurrences("Sample text for testing the Boyer-Moore algorithm.", " "))
-        .containsAllOf(6, 11, 15, 23, 39);
+        .containsExactly(6, 11, 15, 23, 27, 39);
   }
 }

File: src/main/java/com/williamfiset/algorithms/datastructures/sparsetable/examples/MinSparseTable.java
Patch:
@@ -51,13 +51,13 @@ public static void main(String[] args) {
   private int[][] it;
 
   public MinSparseTable(long[] values) {
-    n = v.length;
+    n = values.length;
     P = (int) (Math.log(n) / Math.log(2));
     dp = new long[P + 1][n];
     it = new int[P + 1][n];
 
     for (int i = 0; i < n; i++) {
-      dp[0][i] = v[i];
+      dp[0][i] = values[i];
       it[0][i] = i;
     }
 

File: src/test/java/com/williamfiset/algorithms/strings/BoyerMooreStringSearchTest.java
Patch:
@@ -1,4 +1,4 @@
-package javatests.com.williamfiset.algorithms.strings;
+package com.williamfiset.algorithms.strings;
 
 import static com.google.common.truth.Truth.assertThat;
 

File: src/test/java/com/williamfiset/algorithms/strings/BoyerMooreStringSearchTest.java
Patch:
@@ -1,4 +1,4 @@
-package javatests.com.williamfiset.algorithms.strings;
+package com.williamfiset.algorithms.strings;
 
 import static com.google.common.truth.Truth.assertThat;
 

File: src/main/java/com/williamfiset/algorithms/graphtheory/BreadthFirstSearchAdjacencyListIterative.java
Patch:
@@ -130,7 +130,7 @@ public static void main(String[] args) {
     solver = new BreadthFirstSearchAdjacencyListIterative(graph);
 
     int start = 10, end = 5;
-    List<Integer> path = solver.reconstructPath(10, 5);
+    List<Integer> path = solver.reconstructPath(start, end);
     System.out.printf("The shortest path from %d to %d is: [%s]\n", start, end, formatPath(path));
     // Prints:
     // The shortest path from 10 to 5 is: [10 -> 9 -> 0 -> 7 -> 6 -> 5]

File: src/main/java/com/williamfiset/algorithms/datastructures/sparsetable/SparseTable.java
Patch:
@@ -112,7 +112,7 @@ private void init(long[] v) {
   }
 
   // For debugging, testing and slides.
-  private static void printTable() {
+  private void printTable() {
     for (long[] r : dp) {
       for (int i = 0; i < r.length; i++) {
         System.out.printf("%02d, ", r[i]);

File: src/main/java/com/williamfiset/algorithms/graphtheory/treealgorithms/TreeIsomorphism.java
Patch:
@@ -191,7 +191,7 @@ private static void simpleIsomorphismTest() {
   }
 
   private static void testEncodingTreeFromSlides() {
-    List<List<Integer>> tree = createGraph(10);
+    List<List<Integer>> tree = createEmptyGraph(10);
     addUndirectedEdge(tree, 0, 2);
     addUndirectedEdge(tree, 0, 1);
     addUndirectedEdge(tree, 0, 3);

File: src/main/java/com/williamfiset/algorithms/graphtheory/examples/EagerPrimsExample.java
Patch:
@@ -6,9 +6,9 @@
  *
  * <p>Change directory to the root of the Algorithms directory: $ cd Algorithms
  *
- * <p>Compile: $ javac com/williamfiset/algorithms/graphtheory/examples/EagerPrimsExample.java
+ * <p>Compile: $ javac -d src/main/java src/main/java/com/williamfiset/algorithms/graphtheory/examples/EagerPrimsExample.java
  *
- * <p>Run: $ java com/williamfiset/algorithms/graphtheory/examples/EagerPrimsExample
+ * <p>Run: $ java -cp src/main/java com/williamfiset/algorithms/graphtheory/examples/EagerPrimsExample
  *
  * <p>Time Complexity: O(ElogV)
  *

File: src/main/java/com/williamfiset/algorithms/graphtheory/treealgorithms/examples/TreeHeight.java
Patch:
@@ -5,10 +5,9 @@
  *
  * <p>Change directory to the root of the Algorithms directory: $ cd Algorithms
  *
- * <p>Compile: $ javac
- * com/williamfiset/algorithms/graphtheory/treealgorithms/examples/TreeHeight.java
+ * <p>Compile: $ javac -d src/main/java src/main/java/com/williamfiset/algorithms/graphtheory/treealgorithms/examples/TreeHeight.java
  *
- * <p>Run: $ java com/williamfiset/algorithms/graphtheory/treealgorithms/examples/TreeHeight
+ * <p>Run: $ java -cp src/main/java com/williamfiset/algorithms/graphtheory/treealgorithms/examples/TreeHeight
  *
  * <p>Time Complexity: O(n)
  *

File: src/main/java/com/williamfiset/algorithms/graphtheory/treealgorithms/examples/TreeSum.java
Patch:
@@ -5,9 +5,9 @@
  *
  * <p>Change directory to the root of the Algorithms directory: $ cd Algorithms
  *
- * <p>Compile: $ javac com/williamfiset/algorithms/graphtheory/treealgorithms/examples/TreeSum.java
+ * <p>Compile: $ javac -d src/main/java src/main/java/com/williamfiset/algorithms/graphtheory/treealgorithms/examples/TreeSum.java
  *
- * <p>Run: $ java com/williamfiset/algorithms/graphtheory/treealgorithms/examples/TreeSum
+ * <p>Run: $ java -cp src/main/java com/williamfiset/algorithms/graphtheory/treealgorithms/examples/TreeSum
  *
  * <p>Time Complexity: O(n)
  *

File: src/main/java/com/williamfiset/algorithms/math/CompressedPrimeSieve.java
Patch:
@@ -7,9 +7,9 @@
  *
  * <p>Time Complexity: ~O(nloglogn)
  *
- * <p>Compile: javac com/williamfiset/algorithms/math/CompressedPrimeSieve.java
+ * <p>Compile: javac -d src/main/java src/main/java/com/williamfiset/algorithms/math/CompressedPrimeSieve.java
  *
- * <p>Run: java com/williamfiset/algorithms/math/CompressedPrimeSieve
+ * <p>Run: java -cp src/main/java com/williamfiset/algorithms/math/CompressedPrimeSieve
  *
  * @author William Fiset, william.alexandre.fiset@gmail.com
  */

File: com/williamfiset/algorithms/datastructures/dynamicarray/IntArray.java
Patch:
@@ -54,7 +54,7 @@ public void set(int index, int elem) {
     arr[index] = elem;
   }
 
-  // An an element to this dynamic array
+  // Add an element to this dynamic array
   public void add(int elem) {
     if (len + 1 >= capacity) {
       if (capacity == 0) capacity = 1;

File: com/williamfiset/algorithms/math/FastFourierTransform.java
Patch:
@@ -112,7 +112,7 @@ public static void main(String[] args) {
     long[] polynomial2 = {0, 0, 6, 2, 5};
 
     // Multiply the polynomials using the FFT algorithm
-    long[] result = FFT.multiply(polynomial1, polynomial2);
+    long[] result = FastFourierTransform.multiply(polynomial1, polynomial2);
 
     // Prints [0, 0, 6, 32, 33, 43, 19, 10] or equivalently
     // 6*x^2 + 32*x^3 + 33*x^4 + 43*x^5 + 19*x^6 + 10*x^7

File: com/williamfiset/algorithms/datastructures/hashtable/HashTableOpenAddressingBase.java
Patch:
@@ -278,7 +278,7 @@ public V get(K key) {
     setupProbing(key);
     final int offset = normalizeIndex(key.hashCode());
 
-    // Start at the original hash value and probe until we find a spot where our key 
+    // Start at the original hash value and probe until we find a spot where our key
     // is or we hit a null element in which case our element does not exist.
     for (int i = offset, j = -1, x = 1; ; i = normalizeIndex(offset + probe(x++))) {
 

File: com/williamfiset/algorithms/math/CompressedPrimeSieve.java
Patch:
@@ -8,6 +8,7 @@
  * <p>Time Complexity: ~O(nloglogn)
  *
  * <p>Compile: javac com/williamfiset/algorithms/math/CompressedPrimeSieve.java
+ *
  * <p>Run: java com/williamfiset/algorithms/math/CompressedPrimeSieve
  *
  * @author William Fiset, william.alexandre.fiset@gmail.com

File: com/williamfiset/algorithms/graphtheory/networkflow/examples/FordFulkersonExample.java
Patch:
@@ -171,15 +171,16 @@ private long dfs(int node, long flow) {
       // At sink node, return augmented path flow.
       if (node == t) return flow;
 
-      List<Edge> edges = graph[node];
+      // Mark the current node as visited.
       visited[node] = visitedToken;
 
+      List<Edge> edges = graph[node];
       for (Edge edge : edges) {
         if (edge.capacity > 0 && visited[edge.to] != visitedToken) {
           long bottleNeck = dfs(edge.to, min(flow, edge.capacity));
 
           // If we made it from s -> t (a.k.a bottleNeck > 0) then
-          // augment flow with bottle neck value and recurse.
+          // augment flow with bottleneck value.
           if (bottleNeck > 0) {
             Edge res = edge.residual;
             edge.flow += bottleNeck;

File: com/williamfiset/algorithms/graphtheory/networkflow/CapacityScalingSolverAdjacencyList.java
Patch:
@@ -72,7 +72,7 @@ private long dfs(int node, long flow) {
     // At sink node, return augmented path flow.
     if (node == t) return flow;
 
-    List<Edge> edges = graph.get(node);
+    List<Edge> edges = graph[node];
     visited[node] = visitedToken;
 
     for (Edge edge : edges) {

File: com/williamfiset/algorithms/graphtheory/networkflow/Dinics.java
Patch:
@@ -57,7 +57,7 @@ private boolean bfs() {
     q.offer(s);
     while(!q.isEmpty()) {
       int node = q.poll();
-      for (Edge edge : graph.get(node)) {
+      for (Edge edge : graph[node]) {
         if (edge.flow < edge.capacity && level[edge.to] == -1) {
           level[edge.to] = level[node] + 1;
           q.offer(edge.to);
@@ -69,10 +69,10 @@ private boolean bfs() {
 
   private long dfs(int at, int[] p, long flow) {
     if (at == t) return flow;
-    final int sz = graph.get(at).size();
+    final int sz = graph[at].size();
     
     for (;p[at] < sz; p[at]++) {
-      Edge edge = graph.get(at).get(p[at]);
+      Edge edge = graph[at].get(p[at]);
       if (edge.flow < edge.capacity && level[edge.to] == level[at] + 1) {
 
         long bottleNeck = dfs(edge.to, p, min(flow, edge.capacity - edge.flow));

File: com/williamfiset/algorithms/graphtheory/networkflow/EdmondsKarpAdjacencyList.java
Patch:
@@ -33,7 +33,6 @@ public void solve() {
     do {
       visitedToken++;
       flow = bfs();
-      System.out.println(flow);
       maxFlow += flow;
     } while (flow != 0);
 
@@ -55,7 +54,7 @@ private long bfs() {
       int node = q.poll();
       if (node == t) break;
 
-      for (Edge edge : graph.get(node)) {
+      for (Edge edge : graph[node]) {
         final long cap = edge.capacity - edge.flow; // Remaining capacity
         if (cap > 0 && visited[edge.to] != visitedToken) {
           visited[edge.to] = visitedToken;

File: com/williamfiset/algorithms/graphtheory/networkflow/FordFulkersonDfsSolverAdjacencyList.java
Patch:
@@ -49,7 +49,7 @@ private long dfs(int node, long flow) {
     // At sink node, return augmented path flow.
     if (node == t) return flow;
 
-    List<Edge> edges = graph.get(node);
+    List<Edge> edges = graph[node];
     visited[node] = visitedToken;
 
     for (Edge edge : edges) {

File: com/williamfiset/algorithms/graphtheory/networkflow/MinCostMaxFlow.java
Patch:
@@ -15,7 +15,7 @@
 
 import java.util.*;
 
-public class class MinCostMaxFlowSolver {
+public class MinCostMaxFlow {
 
   private static final long INF = 987654321;
 
@@ -51,7 +51,7 @@ public Edge(int from, int to, long capacity, long cost) {
    * @param source - The index of the source node, 0 <= source < n
    * @param sink   - The index of the source node, 0 <= sink < n
    */
-  public MinCostMaxFlowSolver(int n, int source, int sink) {
+  public MinCostMaxFlow(int n, int source, int sink) {
     this.n = n;
     initializeGraph();
     this.source = source;

File: com/williamfiset/algorithms/graphtheory/treealgorithms/TreeCanonicalFormAdjacencyList.java
Patch:
@@ -15,7 +15,7 @@
 
 import java.util.*;
 
-public class TreeCanonicalFormAdjacencyList2 {
+public class TreeCanonicalFormAdjacencyList {
 
   public static List<List<Integer>> createEmptyTree(int n) {
     List<List<Integer>> tree = new ArrayList<>(n);

File: javatests/com/williamfiset/algorithms/dp/CoinChangeTest.java
Patch:
@@ -12,10 +12,10 @@
 public class CoinChangeTest {
   
   static final int LOOPS = 100;
+
   @Test
   public void testCoinChange() {
     for (int i = 1; i < LOOPS; i++) {
-      
       List<Integer> values = TestUtils.randomIntegerList(i, 1, 1000);
       int[] coinValues = Ints.toArray(values);
       
@@ -25,10 +25,8 @@ public void testCoinChange() {
       int v2 = CoinChange.coinChangeSpaceEfficient(coinValues, amount);
       int v3 = CoinChange.coinChangeRecursive(coinValues, amount);
       
-      System.out.println(v1 + " " + v2 + " " + v3);
       assertThat(v1).isEqualTo(v2);
       assertThat(v2).isEqualTo(v3);
-      
     }
   }
   

File: GraphTheory/tests/TravelingSalesmanProblemTest.java
Patch:
@@ -67,10 +67,9 @@ public void testGeneratedTour() {
         randomFillDistMatrix(dist);
         
         TspDynamicProgramming dpSolver = new TspDynamicProgramming(dist);
-        List<Integer> dpPath = dpSolver.getTour();
         int[] bfPath = TspBruteForce.tsp(dist);
 
-        double dp = TspDynamicProgramming.tourCost(dpPath, dist);
+        double dp = dpSolver.getTourCost();
         double bf = TspBruteForce.computeTourCost(bfPath, dist);
 
         assertThat(dp).isWithin(EPS).of(bf);

File: GraphTheory/TreeAlgorithms/[UNTESTED]TreeCenter.java
Patch:
@@ -8,7 +8,7 @@
 
 import java.util.*;
 
-public class TreeCenter {
+class TreeCenter {
 
   public static List <Integer> findTreeCenters(List<List<Integer>> graph) {
     

File: GraphTheory/TopologicalSortAdjacencyList.java
Patch:
@@ -65,7 +65,7 @@ public static int[] topologicalSort(Map<Integer, List<Edge>> graph, int numNodes
   }
 
   // A useful application of the topological sort is to find the shortest path 
-  // between two nodes in a Directed Acyclic Graph (DAG). Given an adjacency matrix
+  // between two nodes in a Directed Acyclic Graph (DAG). Given an adjacency list
   // this method finds the shortest path to all nodes starting at 'start'
   //
   // NOTE: 'numNodes' is not necessarily the number of nodes currently present

File: Geometry/CircleCircleIntersection.java
Patch:
@@ -63,12 +63,12 @@ public static Point2D[] circleCircleIntersection(Point2D c1, double r1, Point2D
     Point2D point = new Point2D.Double(x, y);
 
     // Single intersection (kissing circles)
-    if (abs((R+r)-d) < EPS || abs(R-(r+d)) < EPS) {
+    if (abs((R+r)-d) < EPS || abs(R-(r+d)) < EPS)
       return new Point2D[]{ point };
     
     // No intersection. Either the small circle contained within 
     // big circle or circles are simply disjoint.
-    } else if (abs((d+r)-R) < EPS || (R+r < d))
+    if (d + r < R || R + r < d)
       return new Point2D[]{};
 
     // Find the angle of rotation via cos law

File: Math/ModPow.java
Patch:
@@ -14,7 +14,7 @@ public class ModPow {
   private final static long MAX = (long) Math.sqrt(Long.MAX_VALUE);
   private final static long MIN = -MAX;
 
-  // Computed the Greatest Common Divisor (GCD) of a & b
+  // Computes the Greatest Common Divisor (GCD) of a & b
   private static long gcd(long a, long b) { return b == 0 ? (a < 0 ? -a : a) : gcd(b, a % b); }
 
   // This function performs the extended euclidean algorithm on two numbers a and b.
@@ -126,8 +126,6 @@ public static void main(String[] args) {
 
   }
 
-
-
 }
 
 

File: Math/ModularInverse.java
Patch:
@@ -1,3 +1,5 @@
+
+
 public class ModularInverse {
   
   // This function performs the extended euclidean algorithm on two numbers a and b.

