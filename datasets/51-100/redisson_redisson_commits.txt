File: redisson/src/test/java/org/redisson/jcache/JCacheTest.java
Patch:
@@ -45,7 +45,7 @@ public class JCacheTest {
     private static final GenericContainer<?> REDIS =
             new GenericContainer<>("redis:latest")
                     .withCreateContainerCmdModifier(cmd -> {
-                        cmd.withCmd("redis-server", "--save", "''", "--notify-keyspace-events", "Eh");
+                        cmd.withCmd("redis-server", "--save", "''", "--notify-keyspace-events", "Ehx");
                     })
                     .withExposedPorts(6379);
 

File: redisson/src/main/java/org/redisson/jcache/JCache.java
Patch:
@@ -1025,7 +1025,7 @@ RFuture<Map<K, V>> getAllOperation(CommandAsyncExecutor commandExecutor, String
                                       + "redis.call('hdel', KEYS[1], key); "
                                       + "redis.call('zrem', KEYS[2], key); "
                                       + "local msg = struct.pack('Lc0Lc0', string.len(key), key, string.len(value), value); "
-                                      + "redis.call('publish', KEYS[3], {key, value}); "
+                                      + "redis.call('publish', KEYS[3], msg); "
                                   + "elseif accessTimeout ~= '-1' then "
                                       + "redis.call('zadd', KEYS[2], accessTimeout, key); "
                                   + "end; "

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -508,7 +508,8 @@ private CompletionStage<RedisClient> checkMasterChange(SentinelServersConfig cfg
         RFuture<RedisURI> masterFuture = connection.async(1, cfg.getRetryInterval(), cfg.getTimeout(),
                                                             StringCodec.INSTANCE, masterHostCommand, cfg.getMasterName());
         return masterFuture
-                .thenCompose(u -> serviceManager.resolveIP(scheme, u))
+                .thenCompose(u -> resolveIP(u.getHost(), "" + u.getPort()))
+                .thenApply(this::toURI)
                 .thenCompose(newMaster -> {
                     RedisURI current = currentMaster.get();
                     if (!newMaster.equals(current)

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -508,7 +508,8 @@ private CompletionStage<RedisClient> checkMasterChange(SentinelServersConfig cfg
         RFuture<RedisURI> masterFuture = connection.async(1, cfg.getRetryInterval(), cfg.getTimeout(),
                                                             StringCodec.INSTANCE, masterHostCommand, cfg.getMasterName());
         return masterFuture
-                .thenCompose(u -> serviceManager.resolveIP(scheme, u))
+                .thenCompose(u -> resolveIP(u.getHost(), "" + u.getPort()))
+                .thenApply(this::toURI)
                 .thenCompose(newMaster -> {
                     RedisURI current = currentMaster.get();
                     if (!newMaster.equals(current)

File: redisson/src/main/java/org/redisson/api/search/index/IndexOptions.java
Patch:
@@ -39,7 +39,7 @@ public final class IndexOptions {
     private String scoreField;
     private boolean noHL;
     private boolean noFreqs;
-    private List<String> stopwords = Collections.emptyList();
+    private List<String> stopwords;
     private boolean skipInitialScan;
     private IndexType on;
     private byte[] payloadField;

File: redisson/src/test/java/org/redisson/RedissonSearchTest.java
Patch:
@@ -61,6 +61,7 @@ public void testMapAggregateWithCursor() {
         RSearch s = redisson.getSearch();
         s.createIndex("idx", IndexOptions.defaults()
                                     .on(IndexType.HASH)
+                                    .stopwords(Collections.emptyList())
                                     .prefix(Arrays.asList("doc:")),
                                     FieldIndex.text("t1"),
                                     FieldIndex.text("t2"));

File: redisson/src/test/java/org/redisson/executor/RedissonScheduledExecutorServiceTest.java
Patch:
@@ -380,7 +380,7 @@ public void testCronExpressionMultipleTasks() throws InterruptedException {
         RScheduledExecutorService executor = redisson.getExecutorService("test", ExecutorOptions.defaults().taskRetryInterval(2, TimeUnit.SECONDS));
         executor.schedule(new ScheduledRunnableTask("executed1"), CronSchedule.of("0/5 * * * * ?"));
         executor.schedule(new ScheduledRunnableTask("executed2"), CronSchedule.of("0/1 * * * * ?"));
-        Thread.sleep(30500);
+        Thread.sleep(30100);
         assertThat(redisson.getAtomicLong("executed1").get()).isEqualTo(6);
         assertThat(redisson.getAtomicLong("executed2").get()).isEqualTo(30);
     }

File: redisson-micronaut/redisson-micronaut-20/src/main/java/org/redisson/micronaut/session/RedissonSession.java
Patch:
@@ -181,7 +181,7 @@ public void superPut(CharSequence name, Object value) {
     @Override
     public MutableConvertibleValues<Object> put(CharSequence key, Object value) {
         if (value == null) {
-            return super.put(key, value);
+            return remove(key);
         }
 
         if (updateMode == RedissonHttpSessionConfiguration.UpdateMode.WRITE_BEHIND && map != null) {

File: redisson-micronaut/redisson-micronaut-30/src/main/java/org/redisson/micronaut/session/RedissonSession.java
Patch:
@@ -181,7 +181,7 @@ public void superPut(CharSequence name, Object value) {
     @Override
     public MutableConvertibleValues<Object> put(CharSequence key, Object value) {
         if (value == null) {
-            return super.put(key, value);
+            return remove(key);
         }
 
         if (updateMode == RedissonHttpSessionConfiguration.UpdateMode.WRITE_BEHIND && map != null) {

File: redisson-micronaut/redisson-micronaut-40/src/main/java/org/redisson/micronaut/session/RedissonSession.java
Patch:
@@ -181,7 +181,7 @@ public void superPut(CharSequence name, Object value) {
     @Override
     public MutableConvertibleValues<Object> put(CharSequence key, Object value) {
         if (value == null) {
-            return super.put(key, value);
+            return remove(key);
         }
 
         if (updateMode == RedissonHttpSessionConfiguration.UpdateMode.WRITE_BEHIND && map != null) {

File: redisson-micronaut/redisson-micronaut-40/src/test/java/org/redisson/micronaut/RedissonCacheTest.java
Patch:
@@ -25,13 +25,13 @@ public class RedissonCacheTest {
 
     @Container
     public static final GenericContainer REDIS = new FixedHostPortGenericContainer("redis:latest")
-                                                        .withFixedExposedPort(6379, 6379);
+                                                        .withExposedPorts(6379);
 
     @Test
     public void testCache() throws InterruptedException {
         Map<String, Object> map = new HashMap<>();
         map.put("redisson.threads", "10");
-        map.put("redisson.single-server-config.address", "redis://127.0.0.1:6379");
+        map.put("redisson.single-server-config.address", "redis://127.0.0.1:" + REDIS.getFirstMappedPort());
 //        map.put("redisson.clusterServersConfig.scanInterval", "3333");
 //        map.put("redisson.clusterServersConfig.nodeAddresses", Arrays.asList("redis://127.0.0.2:6379","redis://127.0.0.3:6379"));
         map.put("redisson.caches.test.expire-after-write", "10s");
@@ -55,7 +55,7 @@ public void testCache() throws InterruptedException {
     public void testCacheNative() throws InterruptedException {
         Map<String, Object> map = new HashMap<>();
         map.put("redisson.threads", "10");
-        map.put("redisson.single-server-config.address", "redis://127.0.0.1:6379");
+        map.put("redisson.single-server-config.address", "redis://127.0.0.1:" + REDIS.getFirstMappedPort());
 //        map.put("redisson.clusterServersConfig.scanInterval", "3333");
 //        map.put("redisson.clusterServersConfig.nodeAddresses", Arrays.asList("redis://127.0.0.2:6379","redis://127.0.0.3:6379"));
         map.put("redisson.caches-native.test.expire-after-write", "3s");

File: redisson/src/main/java/org/redisson/RedissonReadLock.java
Patch:
@@ -94,7 +94,7 @@ protected RFuture<Boolean> unlockInnerAsync(long threadId, String requestId, int
                 "if (mode == false) then " +
                     "redis.call(ARGV[3], KEYS[2], ARGV[1]); " +
                     "redis.call('set', KEYS[5], 1, 'px', ARGV[4]); " +
-                    "return 1; " +
+                    "return nil; " +
                 "end; " +
                 "local lockExists = redis.call('hexists', KEYS[1], ARGV[2]); " +
                 "if (lockExists == 0) then " +

File: redisson/src/main/java/org/redisson/RedissonWriteLock.java
Patch:
@@ -87,7 +87,7 @@ protected RFuture<Boolean> unlockInnerAsync(long threadId, String requestId, int
                 "if (mode == false) then " +
                     "redis.call(ARGV[4], KEYS[2], ARGV[1]); " +
                     "redis.call('set', KEYS[3], 1, 'px', ARGV[5]); " +
-                    "return 1; " +
+                    "return nil; " +
                 "end;" +
                 "if (mode == 'write') then " +
                     "local lockExists = redis.call('hexists', KEYS[1], ARGV[3]); " +

File: redisson/src/test/java/org/redisson/misc/LogHelperTest.java
Patch:
@@ -213,10 +213,10 @@ public void toStringWithSmallString() {
 
     @Test
     public void toStringWithBigString() {
-        char[] charsForStr = new char[150];
+        char[] charsForStr = new char[1500];
         Arrays.fill(charsForStr, '7');
         String string = new String(charsForStr);
 
-        assertThat(LogHelper.toString(string)).isEqualTo(string.substring(0, 100) + "...");
+        assertThat(LogHelper.toString(string)).isEqualTo(string.substring(0, 1000) + "...");
     }
 }

File: redisson/src/test/java/org/redisson/executor/RedissonScheduledExecutorServiceTest.java
Patch:
@@ -380,7 +380,7 @@ public void testCronExpressionMultipleTasks() throws InterruptedException {
         RScheduledExecutorService executor = redisson.getExecutorService("test", ExecutorOptions.defaults().taskRetryInterval(2, TimeUnit.SECONDS));
         executor.schedule(new ScheduledRunnableTask("executed1"), CronSchedule.of("0/5 * * * * ?"));
         executor.schedule(new ScheduledRunnableTask("executed2"), CronSchedule.of("0/1 * * * * ?"));
-        Thread.sleep(30000);
+        Thread.sleep(30500);
         assertThat(redisson.getAtomicLong("executed1").get()).isEqualTo(6);
         assertThat(redisson.getAtomicLong("executed2").get()).isEqualTo(30);
     }

File: redisson/src/main/java/org/redisson/RedissonRemoteService.java
Patch:
@@ -264,7 +264,7 @@ private <T> void subscribe(Class<T> remoteInterface, RBlockingQueue<String> requ
                 }
 
                 int freeWorkers = entry.getFreeWorkers().decrementAndGet();
-                if (freeWorkers > 0 && requestId != null) {
+                if (freeWorkers > 0) {
                     subscribe(remoteInterface, requestQueue, executor, bean);
                 }
 

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -447,7 +447,7 @@ protected RFuture<V> removeOperationAsync(K key) {
     @Override
     protected RFuture<List<Long>> fastRemoveOperationBatchAsync(@SuppressWarnings("unchecked") K... keys) {
         if (storeMode == LocalCachedMapOptions.StoreMode.LOCALCACHE) {
-            return new CompletableFutureWrapper<>(Collections.emptyList());
+            return new CompletableFutureWrapper<>(Collections.<Long>emptyList());
         }
 
             if (invalidateEntryOnChange == 1) {

File: redisson/src/main/java/org/redisson/RedissonSet.java
Patch:
@@ -403,7 +403,7 @@ public RFuture<Integer> removeAllCountedAsync(Collection<? extends V> c) {
     @Override
     public RFuture<List<V>> containsEachAsync(Collection<V> c) {
         if (c.isEmpty()) {
-            return new CompletableFutureWrapper<>((List<V>) Collections.emptyList());
+            return new CompletableFutureWrapper<>(Collections.<V>emptyList());
         }
 
         List<Object> args = new ArrayList<>(c.size() + 1);

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -673,7 +673,8 @@ public RFuture<Map<K, V>> getAllAsync(Set<K> keys) {
             }
 
             if (!missedKeys.isEmpty()) {
-                CompletionStage<Map<K, V>> f = loadAllMapAsync(missedKeys.spliterator(), false, 1);
+                CompletionStage<Map<K, V>> f = loadAllMapAsync(missedKeys.spliterator(),
+                                                    false, 1, Thread.currentThread().getId());
                 CompletionStage<Map<K, V>> ff = f.thenApply(map -> {
                     result.putAll(map);
                     return result;

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -1724,12 +1724,13 @@ public RFuture<Map<K, V>> getAllWithTTLOnlyAsync(Set<K> keys) {
             return future;
         }
 
+        long threadId = Thread.currentThread().getId();
         CompletionStage<Map<K, V>> f = future.thenCompose(res -> {
             if (!res.keySet().containsAll(keys)) {
                 Set<K> newKeys = new HashSet<K>(keys);
                 newKeys.removeAll(res.keySet());
 
-                CompletionStage<Map<K, V>> ff = loadAllMapAsync(newKeys.spliterator(), false, 1);
+                CompletionStage<Map<K, V>> ff = loadAllMapAsync(newKeys.spliterator(), false, 1, threadId);
                 return ff.thenApply(map -> {
                     res.putAll(map);
                     return res;

File: redisson/src/main/java/org/redisson/transaction/BaseTransactionalMap.java
Patch:
@@ -484,7 +484,7 @@ protected RFuture<Long> fastRemoveOperationAsync(K... keys) {
             }
 
             // TODO optimize
-            return map.getAllAsync(new HashSet<>(keyList)).thenApply(res -> {
+            return ((RedissonMap<K, V>) map).getAllAsync(new HashSet<>(keyList), Long.MIN_VALUE).thenApply(res -> {
                 for (K key : res.keySet()) {
                     HashValue keyHash = toKeyHash(key);
                     operations.add(new MapFastRemoveOperation(map, key, transactionId, threadId));

File: redisson/src/main/java/org/redisson/spring/cache/CacheConfig.java
Patch:
@@ -123,7 +123,7 @@ public void addListener(MapEntryListener listener) {
         listeners.add(listener);
     }
     
-    protected List<MapEntryListener> getListeners() {
+    public List<MapEntryListener> getListeners() {
         return listeners;
     }
     

File: redisson/src/test/java/org/redisson/client/protocol/decoder/ClusterNodesDecoderTest.java
Patch:
@@ -15,7 +15,7 @@ public class ClusterNodesDecoderTest {
 
     @Test
     public void testIPs() throws IOException {
-        ClusterNodesDecoder decoder = new ClusterNodesDecoder(RedisURI.REDIS_PROTOCOL);
+        ClusterNodesDecoder decoder = new ClusterNodesDecoder("redis");
         ByteBuf buf = Unpooled.buffer();
         
         String info = "7af253f8c20a3b3fbd481801bd361ec6643c6f0b 192.168.234.129:7001@17001 master - 0 1478865073260 8 connected 5461-10922\n" +
@@ -35,7 +35,7 @@ public void testIPs() throws IOException {
     
     @Test
     public void testHostnames() throws IOException {
-        ClusterNodesDecoder decoder = new ClusterNodesDecoder(RedisURI.REDIS_PROTOCOL);
+        ClusterNodesDecoder decoder = new ClusterNodesDecoder("redis");
         ByteBuf buf = Unpooled.buffer();
 
         String info = "7af253f8c20a3b3fbd481801bd361ec6643c6f0b 192.168.234.129:7001@17001,hostname1 master - 0 1478865073260 8 connected 5461-10922\n" +

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -741,7 +741,7 @@ public Boolean convert(Object obj) {
             Arrays.asList(HSCAN.getName(), SCAN.getName(), ZSCAN.getName(), SSCAN.getName()));
 
     RedisStrictCommand<List<ClusterNodeInfo>> REDIS_CLUSTER_NODES = new RedisStrictCommand<List<ClusterNodeInfo>>("CLUSTER", "NODES",
-            new ObjectDecoder(new ClusterNodesDecoder(RedisURI.REDIS_PROTOCOL)));
+            new ObjectDecoder(new ClusterNodesDecoder("redis")));
 
     RedisStrictCommand<Long> TIME_LONG = new RedisStrictCommand<Long>("TIME", new TimeLongObjectDecoder());
     RedisStrictCommand<Time> TIME = new RedisStrictCommand<Time>("TIME", new TimeObjectDecoder());

File: redisson/src/main/java/org/redisson/executor/TasksRunnerService.java
Patch:
@@ -176,9 +176,6 @@ private RemoteExecutorServiceAsync asyncScheduledServiceAtFixed(String executorI
     @Override
     public void scheduleWithFixedDelay(ScheduledWithFixedDelayParameters params) {
         executeRunnable(params, false);
-        if (!redisson.getMap(tasksName, StringCodec.INSTANCE).containsKey(params.getRequestId())) {
-            return;
-        }
         
         long newStartTime = System.currentTimeMillis() + params.getDelay();
         params.setStartTime(newStartTime);

File: redisson/src/main/java/org/redisson/executor/TasksRunnerService.java
Patch:
@@ -176,9 +176,6 @@ private RemoteExecutorServiceAsync asyncScheduledServiceAtFixed(String executorI
     @Override
     public void scheduleWithFixedDelay(ScheduledWithFixedDelayParameters params) {
         executeRunnable(params, false);
-        if (!redisson.getMap(tasksName, StringCodec.INSTANCE).containsKey(params.getRequestId())) {
-            return;
-        }
         
         long newStartTime = System.currentTimeMillis() + params.getDelay();
         params.setStartTime(newStartTime);

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -405,6 +405,9 @@ protected void decode(ByteBuf in, CommandData<Object, Object> data, List<Object>
             } else if (error.startsWith("CLUSTERDOWN")) {
                 data.tryFailure(new RedisClusterDownException(error
                         + ". channel: " + channel + " data: " + data));
+            } else if (error.startsWith("MASTERDOWN")) {
+                data.tryFailure(new RedisMasterDownException(error
+                        + ". channel: " + channel + " data: " + data));
             } else if (error.startsWith("BUSY")) {
                 data.tryFailure(new RedisBusyException(error
                         + ". channel: " + channel + " data: " + data));

File: redisson/src/main/java/org/redisson/connection/ClusterConnectionManager.java
Patch:
@@ -489,7 +489,9 @@ private void updateClusterState(ClusterServersConfig cfg, RedisConnection connec
                     for (ClusterNodeInfo clusterNodeInfo : nodes) {
                         nodesValue.append(clusterNodeInfo.getNodeInfo()).append("\n");
                     }
-                    log.debug("cluster nodes state got from {}:\n{}", connection.getRedisClient().getAddr(), nodesValue);
+
+                    log.debug("Cluster nodes state got from {}:\n{}", connection.getRedisClient().getAddr(), nodesValue);
+                    serviceManager.setLastClusterNodes(nodesValue.toString());
                 }
 
                 CompletableFuture<Collection<ClusterPartition>> newPartitionsFuture = parsePartitions(nodes);

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -260,7 +260,7 @@ protected RFuture<Long> pushTaskAsync() {
                                   + "local v = redis.call('zrange', KEYS[2], 0, 0); "
                                   // if new task added to queue head then publish its startTime 
                                   // to all scheduler workers 
-                                  + "if v[1] == expiredTaskIds[i] then "
+                                  + "if v[1] == scheduledName then "
                                       + "redis.call('publish', KEYS[3], startTime); "
                                   + "end;"
                                     

File: redisson/src/main/java/org/redisson/executor/TasksService.java
Patch:
@@ -132,12 +132,13 @@ protected CompletableFuture<Boolean> addAsync(String requestQueueName, RemoteSer
                             + "end; "
 
                             + "if tonumber(ARGV[1]) > 0 then "
+                                + "local scheduledName = 'ff:' .. ARGV[2];"
                                 + "redis.call('set', KEYS[7], ARGV[4]);"
-                                + "redis.call('zadd', KEYS[3], ARGV[1], 'ff:' .. ARGV[2]);"
+                                + "redis.call('zadd', KEYS[3], ARGV[1], scheduledName);"
                                 + "local v = redis.call('zrange', KEYS[3], 0, 0); "
                                 // if new task added to queue head then publish its startTime
                                 // to all scheduler workers
-                                + "if v[1] == ARGV[2] then "
+                                + "if v[1] == scheduledName then "
                                     + "redis.call('publish', KEYS[4], ARGV[1]); "
                                 + "end; "
                             + "end;"

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -260,7 +260,7 @@ protected RFuture<Long> pushTaskAsync() {
                                   + "local v = redis.call('zrange', KEYS[2], 0, 0); "
                                   // if new task added to queue head then publish its startTime 
                                   // to all scheduler workers 
-                                  + "if v[1] == expiredTaskIds[i] then "
+                                  + "if v[1] == scheduledName then "
                                       + "redis.call('publish', KEYS[3], startTime); "
                                   + "end;"
                                     

File: redisson/src/main/java/org/redisson/executor/TasksService.java
Patch:
@@ -132,12 +132,13 @@ protected CompletableFuture<Boolean> addAsync(String requestQueueName, RemoteSer
                             + "end; "
 
                             + "if tonumber(ARGV[1]) > 0 then "
+                                + "local scheduledName = 'ff:' .. ARGV[2];"
                                 + "redis.call('set', KEYS[7], ARGV[4]);"
-                                + "redis.call('zadd', KEYS[3], ARGV[1], 'ff:' .. ARGV[2]);"
+                                + "redis.call('zadd', KEYS[3], ARGV[1], scheduledName);"
                                 + "local v = redis.call('zrange', KEYS[3], 0, 0); "
                                 // if new task added to queue head then publish its startTime
                                 // to all scheduler workers
-                                + "if v[1] == ARGV[2] then "
+                                + "if v[1] == scheduledName then "
                                     + "redis.call('publish', KEYS[4], ARGV[1]); "
                                 + "end; "
                             + "end;"

File: redisson/src/main/java/org/redisson/remote/BaseRemoteProxy.java
Patch:
@@ -201,7 +201,7 @@ private BiConsumer<RRemoteServiceResponse, Throwable> createResponseListener() {
                 List<Result> list = entry.getResponses().get(key);
                 if (list == null) {
                     pollResponse();
-                    return null;
+                    return entry;
                 }
 
                 Result res = list.remove(0);

File: redisson/src/main/java/org/redisson/remote/BaseRemoteProxy.java
Patch:
@@ -201,7 +201,7 @@ private BiConsumer<RRemoteServiceResponse, Throwable> createResponseListener() {
                 List<Result> list = entry.getResponses().get(key);
                 if (list == null) {
                     pollResponse();
-                    return null;
+                    return entry;
                 }
 
                 Result res = list.remove(0);

File: redisson/src/main/java/org/redisson/command/CommandAsyncExecutor.java
Patch:
@@ -26,7 +26,6 @@
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.connection.ConnectionManager;
 import org.redisson.connection.MasterSlaveEntry;
-import org.redisson.connection.NodeSource;
 import org.redisson.connection.ServiceManager;
 import org.redisson.liveobject.core.RedissonObjectBuilder;
 

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -20,7 +20,6 @@
 import org.redisson.client.*;
 import org.redisson.cluster.ClusterSlotRange;
 import org.redisson.command.CommandAsyncExecutor;
-import org.redisson.command.CommandAsyncService;
 import org.redisson.config.*;
 import org.redisson.liveobject.core.RedissonObjectBuilder;
 import org.redisson.misc.RedisURI;

File: redisson/src/main/java/org/redisson/remote/ReactiveRemoteProxy.java
Patch:
@@ -20,7 +20,6 @@
 import org.redisson.executor.RemotePromise;
 import org.redisson.misc.CompletableFutureWrapper;
 import org.redisson.reactive.CommandReactiveExecutor;
-import org.redisson.reactive.CommandReactiveService;
 import reactor.core.publisher.Mono;
 
 import java.util.Arrays;

File: redisson/src/main/java/org/redisson/remote/RxRemoteProxy.java
Patch:
@@ -24,7 +24,6 @@
 import org.redisson.executor.RemotePromise;
 import org.redisson.misc.CompletableFutureWrapper;
 import org.redisson.rx.CommandRxExecutor;
-import org.redisson.rx.CommandRxService;
 
 import java.util.Arrays;
 import java.util.List;

File: redisson/src/main/java/org/redisson/executor/TasksRunnerService.java
Patch:
@@ -251,7 +251,7 @@ protected RFuture<Long> renewRetryTime(String requestId) {
                     + "local v = redis.call('zrange', KEYS[2], 0, 0); "
                     // if new task added to queue head then publish its startTime 
                     // to all scheduler workers 
-                    + "if v[1] == ARGV[2] then "
+                    + "if v[1] == scheduledName then "
                         + "redis.call('publish', KEYS[3], startTime); "
                     + "end;"
                     + "return retryInterval; "

File: redisson/src/main/java/org/redisson/executor/TasksRunnerService.java
Patch:
@@ -251,7 +251,7 @@ protected RFuture<Long> renewRetryTime(String requestId) {
                     + "local v = redis.call('zrange', KEYS[2], 0, 0); "
                     // if new task added to queue head then publish its startTime 
                     // to all scheduler workers 
-                    + "if v[1] == ARGV[2] then "
+                    + "if v[1] == scheduledName then "
                         + "redis.call('publish', KEYS[3], startTime); "
                     + "end;"
                     + "return retryInterval; "

File: redisson/src/main/java/org/redisson/misc/ProxyBuilder.java
Patch:
@@ -50,7 +50,6 @@ public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl
                 Method instanceMethod = getMethod(method, instance, implementation);
 
                 if (instanceMethod.getName().endsWith("Async")) {
-                    instanceMethod.setAccessible(true);
                     Callable<RFuture<Object>> callable = () -> (RFuture<Object>) instanceMethod.invoke(instance, args);
                     return commandExecutor.execute(callable, method);
                 }

File: redisson/src/main/java/org/redisson/misc/ProxyBuilder.java
Patch:
@@ -50,6 +50,7 @@ public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl
                 Method instanceMethod = getMethod(method, instance, implementation);
 
                 if (instanceMethod.getName().endsWith("Async")) {
+                    instanceMethod.setAccessible(true);
                     Callable<RFuture<Object>> callable = () -> (RFuture<Object>) instanceMethod.invoke(instance, args);
                     return commandExecutor.execute(callable, method);
                 }

File: redisson/src/main/java/org/redisson/reactive/RedissonListMultimapReactive.java
Patch:
@@ -45,7 +45,7 @@ public RedissonListMultimapReactive(Codec codec, CommandReactiveExecutor command
 
     public RListReactive<V> get(K key) {
         RList<V> list = ((RListMultimap<K, V>) instance).get(key);
-        return ReactiveProxyBuilder.create(commandExecutor, instance, 
+        return ReactiveProxyBuilder.create(commandExecutor, list,
                 new RedissonListReactive<V>(instance.getCodec(), commandExecutor, list.getName()), RListReactive.class);
     }
 

File: redisson/src/main/java/org/redisson/rx/RedissonListMultimapRx.java
Patch:
@@ -38,7 +38,7 @@ public RedissonListMultimapRx(RListMultimap<K, V> instance, CommandRxExecutor co
 
     public RListRx<V> get(K key) {
         RedissonList<V> list = (RedissonList<V>) instance.get(key);
-        return RxProxyBuilder.create(commandExecutor, instance, 
+        return RxProxyBuilder.create(commandExecutor, list,
                 new RedissonListRx<V>(list), RListRx.class);
     }
 

File: redisson/src/main/java/org/redisson/executor/RedissonExecutorFutureReference.java
Patch:
@@ -18,15 +18,15 @@
 import org.redisson.api.RExecutorFuture;
 
 import java.lang.ref.ReferenceQueue;
-import java.lang.ref.WeakReference;
+import java.lang.ref.SoftReference;
 import java.util.concurrent.CompletableFuture;
 
 /**
  * 
  * @author Nikita Koksharov
  *
  */
-public class RedissonExecutorFutureReference extends WeakReference<RExecutorFuture<?>> {
+public class RedissonExecutorFutureReference extends SoftReference<RExecutorFuture<?>> {
 
     private final CompletableFuture<?> promise;
     private final String requestId;

File: redisson/src/main/java/org/redisson/misc/ProxyBuilder.java
Patch:
@@ -50,6 +50,7 @@ public Object invoke(Object proxy, Method method, Object[] args) throws Throwabl
                 Method instanceMethod = getMethod(method, instance, implementation);
 
                 if (instanceMethod.getName().endsWith("Async")) {
+                    instanceMethod.setAccessible(true);
                     Callable<RFuture<Object>> callable = () -> (RFuture<Object>) instanceMethod.invoke(instance, args);
                     return commandExecutor.execute(callable, method);
                 }

File: redisson/src/main/java/org/redisson/reactive/RedissonListMultimapReactive.java
Patch:
@@ -45,7 +45,7 @@ public RedissonListMultimapReactive(Codec codec, CommandReactiveExecutor command
 
     public RListReactive<V> get(K key) {
         RList<V> list = ((RListMultimap<K, V>) instance).get(key);
-        return ReactiveProxyBuilder.create(commandExecutor, instance, 
+        return ReactiveProxyBuilder.create(commandExecutor, list,
                 new RedissonListReactive<V>(instance.getCodec(), commandExecutor, list.getName()), RListReactive.class);
     }
 

File: redisson/src/main/java/org/redisson/misc/RandomXoshiro256PlusPlus.java
Patch:
@@ -46,7 +46,9 @@ public final class RandomXoshiro256PlusPlus extends Random {
     private static final long serialVersionUID = -2837799889588687855L;
 
     public static Random create() {
-        byte[] seed = SecureRandom.getSeed(32);
+        SecureRandom secureRandom = new SecureRandom();
+        byte[] seed = new byte[32];
+        secureRandom.nextBytes(seed);
         ByteBuffer bbw = ByteBuffer.wrap(seed);
         return new RandomXoshiro256PlusPlus(bbw.getLong(), bbw.getLong(), bbw.getLong(), bbw.getLong());
     }

File: redisson/src/main/java/org/redisson/RedissonPriorityBlockingQueue.java
Patch:
@@ -217,7 +217,7 @@ public RFuture<Integer> drainToAsync(Collection<? super V> c) {
             throw new NullPointerException();
         }
 
-        return commandExecutor.evalWriteAsync(getRawName(), codec, new RedisCommand<Object>("EVAL", new ListDrainToDecoder(c)),
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, new RedisCommand<Object>("EVAL", new ListDrainToDecoder(c)),
               "local vals = redis.call('lrange', KEYS[1], 0, -1); " +
               "redis.call('ltrim', KEYS[1], -1, 0); " +
               "return vals", Collections.<Object>singletonList(getRawName()));
@@ -242,7 +242,7 @@ public RFuture<Integer> drainToAsync(Collection<? super V> c, int maxElements) {
         if (c == null) {
             throw new NullPointerException();
         }
-        return commandExecutor.evalWriteAsync(getRawName(), codec, new RedisCommand<Object>("EVAL", new ListDrainToDecoder(c)),
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, new RedisCommand<Object>("EVAL", new ListDrainToDecoder(c)),
                 "local elemNum = math.min(ARGV[1], redis.call('llen', KEYS[1])) - 1;" +
                         "local vals = redis.call('lrange', KEYS[1], 0, elemNum); " +
                         "redis.call('ltrim', KEYS[1], elemNum + 1, -1); " +

File: redisson/src/test/java/org/redisson/RedissonPermitExpirableSemaphoreTest.java
Patch:
@@ -1,6 +1,5 @@
 package org.redisson;
 
-import net.bytebuddy.utility.RandomString;
 import org.awaitility.Awaitility;
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;

File: redisson/src/main/java/org/redisson/misc/RedisURI.java
Patch:
@@ -83,7 +83,7 @@ private String parseUrl(String uri) {
         if (ipV6Host.contains("@")) {
             ipV6Host = ipV6Host.split("@")[1];
         }
-        if (ipV6Host.contains(":")) {
+        if (ipV6Host.contains(":") && !ipV6Host.startsWith("[")) {
             urlHost = urlHost.replace(ipV6Host, "[" + ipV6Host + "]");
         }
         return urlHost;

File: redisson/src/main/java/org/redisson/eviction/EvictionTask.java
Patch:
@@ -52,6 +52,7 @@ abstract class EvictionTask implements TimerTask {
         this.minDelay = executor.getServiceManager().getCfg().getMinCleanUpDelay();
         this.maxDelay = executor.getServiceManager().getCfg().getMaxCleanUpDelay();
         this.keysLimit = executor.getServiceManager().getCfg().getCleanUpKeysAmount();
+        this.delay = minDelay;
     }
 
     public void schedule() {

File: redisson-quarkus/redisson-quarkus-30/cache/runtime/src/main/java/io/quarkus/cache/redisson/runtime/RedissonCachesConfig.java
Patch:
@@ -31,7 +31,6 @@
  *
  */
 @ConfigRoot(phase = RUN_TIME, name = "cache.redisson")
-@ConfigMapping
 public class RedissonCachesConfig {
 
     /**

File: redisson-quarkus/redisson-quarkus-30/cache/runtime/src/main/java/io/quarkus/cache/redisson/runtime/RedissonCachesConfig.java
Patch:
@@ -23,13 +23,15 @@
 import io.quarkus.runtime.annotations.ConfigDocSection;
 import io.quarkus.runtime.annotations.ConfigItem;
 import io.quarkus.runtime.annotations.ConfigRoot;
+import io.smallrye.config.ConfigMapping;
 
 /**
  *
  * @author Nikita Koksharov
  *
  */
 @ConfigRoot(phase = RUN_TIME, name = "cache.redisson")
+@ConfigMapping
 public class RedissonCachesConfig {
 
     /**

File: redisson/src/test/java/org/redisson/RedissonAtomicLongReactiveTest.java
Patch:
@@ -2,11 +2,8 @@
 
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
-import org.redisson.api.RAtomicLong;
 import org.redisson.api.RAtomicLongReactive;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 public class RedissonAtomicLongReactiveTest extends BaseReactiveTest {
     
     @Test

File: redisson/src/main/java/org/redisson/codec/TypedJsonJacksonCodec.java
Patch:
@@ -51,6 +51,9 @@ public ByteBuf encode(Object in) throws IOException {
             } catch (IOException e) {
                 out.release();
                 throw e;
+            } catch (Exception e) {
+                out.release();
+                throw new IOException(e);
             }
         }
     };

File: redisson/src/main/java/org/redisson/codec/TypedJsonJacksonCodec.java
Patch:
@@ -51,6 +51,9 @@ public ByteBuf encode(Object in) throws IOException {
             } catch (IOException e) {
                 out.release();
                 throw e;
+            } catch (Exception e) {
+                out.release();
+                throw new IOException(e);
             }
         }
     };

File: redisson/src/main/java/org/redisson/RedissonObject.java
Patch:
@@ -321,7 +321,7 @@ public RFuture<Void> renameAsync(String newName) {
             String nn = mapName(newName);
             String oldName = getRawName();
             CompletionStage<Void> f = dumpAsync()
-                                       .thenCompose(val -> commandExecutor.writeAsync(nn, StringCodec.INSTANCE, RedisCommands.RESTORE, nn, 0, val))
+                                       .thenCompose(val -> commandExecutor.writeAsync(nn, StringCodec.INSTANCE, RedisCommands.RESTORE, nn, 0, val, "REPLACE"))
                                        .thenCompose(val -> {
                                            setName(newName);
                                            return deleteAsync(oldName).thenApply(r -> null);

File: redisson/src/main/java/org/redisson/misc/HashValue.java
Patch:
@@ -25,6 +25,8 @@
  */
 public final class HashValue {
 
+    public static final HashValue EMPTY = new HashValue(new long[0]);
+
     private final long[] value;
 
     public HashValue(long[] hash) {

File: redisson/src/main/java/org/redisson/api/RMapCacheReactive.java
Patch:
@@ -140,7 +140,8 @@ public interface RMapCacheReactive<K, V> extends RMapReactive<K, V>, RDestroyabl
      * @param mappingFunction the mapping function to compute a value
      * @return current associated value
      */
-    Mono<V> computeIfAbsentAsync(K key, Duration ttl, Function<? super K, ? extends V> mappingFunction);
+    Mono<V> computeIfAbsent(K key, Duration ttl, Function<? super K, ? extends V> mappingFunction);
+
     /**
      * Stores value mapped by key with specified time to live.
      * Entry expires after specified time to live.

File: redisson/src/main/java/org/redisson/api/RMapCacheRx.java
Patch:
@@ -142,7 +142,7 @@ public interface RMapCacheRx<K, V> extends RMapRx<K, V>, RDestroyable {
      * @param mappingFunction the mapping function to compute a value
      * @return current associated value
      */
-    Maybe<V> computeIfAbsentAsync(K key, Duration ttl, Function<? super K, ? extends V> mappingFunction);
+    Maybe<V> computeIfAbsent(K key, Duration ttl, Function<? super K, ? extends V> mappingFunction);
     /**
      * Stores value mapped by key with specified time to live.
      * Entry expires after specified time to live.

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -144,6 +144,7 @@ private CacheValue cachePut(CacheKey cacheKey, Object key, Object value) {
         }
         listener.notifyInvalidate(new CacheValue(key, oldV));
         listener.notifyUpdate(newValue);
+        localCacheView.putCacheKey(key, cacheKey);
         return oldValue;
     }
 

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -150,6 +150,7 @@ private CacheValue cachePut(CacheKey cacheKey, Object key, Object value) {
         }
         listener.notifyInvalidate(new CacheValue(key, oldV));
         listener.notifyUpdate(newValue);
+        localCacheView.putCacheKey(key, cacheKey);
         return oldValue;
     }
 

File: redisson/src/main/java/org/redisson/connection/balancer/CommandsLoadBalancer.java
Patch:
@@ -65,7 +65,7 @@ public void setAddress(String address) {
      */
     public void setCommands(List<String> commands) {
         this.commands = commands.stream()
-                                    .map(c -> c.toLowerCase())
+                                    .map(c -> c.toLowerCase(Locale.ENGLISH))
                                     .collect(Collectors.toSet());
     }
 }

File: redisson/src/main/java/org/redisson/liveobject/core/AccessorInterceptor.java
Patch:
@@ -296,7 +296,7 @@ private void storeIndex(Field field, Object me, Object arg) {
 
     private String getFieldName(Class<?> clazz, Method method) {
         String fieldName = FIELD_PATTERN.matcher(method.getName()).replaceFirst("");
-        String propName = fieldName.substring(0, 1).toLowerCase() + fieldName.substring(1);
+        String propName = fieldName.substring(0, 1).toLowerCase(Locale.ENGLISH) + fieldName.substring(1);
         try {
             ClassUtils.getDeclaredField(clazz, propName);
             return propName;

File: redisson/src/main/java/org/redisson/connection/balancer/CommandsLoadBalancer.java
Patch:
@@ -20,6 +20,7 @@
 import org.redisson.misc.RedisURI;
 
 import java.util.List;
+import java.util.Locale;
 import java.util.Set;
 import java.util.stream.Collectors;
 
@@ -36,7 +37,7 @@ public class CommandsLoadBalancer extends RoundRobinLoadBalancer implements Load
 
     @Override
     public ClientConnectionsEntry getEntry(List<ClientConnectionsEntry> clientsCopy, RedisCommand<?> redisCommand) {
-        if (commands.contains(redisCommand.getName().toLowerCase())) {
+        if (commands.contains(redisCommand.getName().toLowerCase(Locale.ENGLISH))) {
             return clientsCopy.stream()
                                 .filter(c -> address.equals(c.getClient().getAddr()))
                                 .findAny()

File: redisson-tomcat/redisson-tomcat-10/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -226,7 +226,8 @@ public void superRemove(Session session) {
     public void remove(Session session, boolean update) {
         super.remove(session, update);
         
-        if (session.getIdInternal() != null) {
+        if (session.getIdInternal() != null
+                && !redisson.isShuttingDown()) {
             ((RedissonSession)session).delete();
         }
     }

File: redisson-tomcat/redisson-tomcat-11/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -225,8 +225,9 @@ public void superRemove(Session session) {
     @Override
     public void remove(Session session, boolean update) {
         super.remove(session, update);
-        
-        if (session.getIdInternal() != null) {
+
+        if (session.getIdInternal() != null
+                && !redisson.isShuttingDown()) {
             ((RedissonSession)session).delete();
         }
     }

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -225,8 +225,9 @@ public void superRemove(Session session) {
     @Override
     public void remove(Session session, boolean update) {
         super.remove(session, update);
-        
-        if (session.getIdInternal() != null) {
+
+        if (session.getIdInternal() != null
+                && !redisson.isShuttingDown()) {
             ((RedissonSession)session).delete();
         }
     }

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -225,8 +225,9 @@ public void superRemove(Session session) {
     @Override
     public void remove(Session session, boolean update) {
         super.remove(session, update);
-        
-        if (session.getIdInternal() != null) {
+
+        if (session.getIdInternal() != null
+                && !redisson.isShuttingDown()) {
             ((RedissonSession)session).delete();
         }
     }

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -233,8 +233,9 @@ public void superRemove(Session session) {
     @Override
     public void remove(Session session, boolean update) {
         super.remove(session, update);
-        
-        if (session.getIdInternal() != null) {
+
+        if (session.getIdInternal() != null
+                && !redisson.isShuttingDown()) {
             ((RedissonSession)session).delete();
         }
     }

File: redisson/src/main/java/org/redisson/api/stream/StreamReadArgs.java
Patch:
@@ -37,6 +37,7 @@ public interface StreamReadArgs {
 
     /**
      * Defines time interval to wait for stream data availability.
+     * <code>0</code> is used to wait infinitely.
      *
      * @param timeout timeout duration
      * @return arguments object

File: redisson/src/main/java/org/redisson/api/stream/StreamReadArgs.java
Patch:
@@ -30,15 +30,15 @@ public interface StreamReadArgs {
     /**
      * Defines stream data size limit.
      *
-     * @param count - stream data size limit
+     * @param count stream data size limit
      * @return arguments object
      */
     StreamReadArgs count(int count);
 
     /**
      * Defines time interval to wait for stream data availability.
      *
-     * @param timeout - timeout duration
+     * @param timeout timeout duration
      * @return arguments object
      */
     StreamReadArgs timeout(Duration timeout);
@@ -47,7 +47,7 @@ public interface StreamReadArgs {
      * Defines last stream id received from current Stream.
      * Read stream data with ids greater than defined id.
      *
-     * @param id0 - last stream id of current stream
+     * @param id0 last stream id of current stream
      * @return arguments object
      */
     static StreamReadArgs greaterThan(StreamMessageId id0) {

File: redisson/src/main/java/org/redisson/codec/JsonCodec.java
Patch:
@@ -20,7 +20,6 @@
  *
  * @author Nikita Koksharov
  *
- * @param <T> object type
  */
 public interface JsonCodec extends ObjectCodec {
 

File: redisson/src/main/java/org/redisson/api/RKeys.java
Patch:
@@ -144,7 +144,7 @@ public interface RKeys extends RKeysAsync {
     long touch(String... names);
     
     /**
-     * Checks if provided keys exist
+     * Returns amount of existing keys
      * 
      * @param names of keys
      * @return amount of existing keys

File: redisson/src/main/java/org/redisson/api/RObject.java
Patch:
@@ -182,7 +182,7 @@ public interface RObject extends RObjectAsync {
 
     /**
      * Rename current object key to <code>newName</code>
-     * only if new key is not exists
+     * only if new key doesn't exist.
      *
      * @param newName - new name of object
      * @return <code>true</code> if object has been renamed successfully and <code>false</code> otherwise

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -2753,7 +2753,7 @@ public List<byte[]> rPop(byte[] key, long count) {
         return write(key, ByteArrayCodec.INSTANCE, RedisCommands.RPOP_LIST, key, count);
     }
 
-    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand<>("SMISMEMBER", new ObjectListReplayDecoder<>());
+    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand("SMISMEMBER", new ObjectListReplayDecoder<>(), new BooleanReplayConvertor());
 
     @Override
     public List<Boolean> sMIsMember(byte[] key, byte[]... value) {

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -299,7 +299,7 @@ public Flux<CommandResponse<SRandMembersCommand, Flux<ByteBuffer>>> sRandMember(
         });
     }
 
-    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand<>("SMISMEMBER", new ObjectListReplayDecoder<>());
+    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand("SMISMEMBER", new ObjectListReplayDecoder<>(), new BooleanReplayConvertor());
 
     @Override
     public Flux<ReactiveRedisConnection.MultiValueResponse<SMIsMemberCommand, Boolean>> sMIsMember(Publisher<SMIsMemberCommand> commands) {

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -2752,7 +2752,7 @@ public List<byte[]> rPop(byte[] key, long count) {
         return write(key, ByteArrayCodec.INSTANCE, RedisCommands.RPOP_LIST, key, count);
     }
 
-    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand<>("SMISMEMBER", new ObjectListReplayDecoder<>());
+    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand("SMISMEMBER", new ObjectListReplayDecoder<>(), new BooleanReplayConvertor());
 
     @Override
     public List<Boolean> sMIsMember(byte[] key, byte[]... value) {

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -299,7 +299,7 @@ public Flux<CommandResponse<SRandMembersCommand, Flux<ByteBuffer>>> sRandMember(
         });
     }
 
-    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand<>("SMISMEMBER", new ObjectListReplayDecoder<>());
+    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand("SMISMEMBER", new ObjectListReplayDecoder<>(), new BooleanReplayConvertor());
 
     @Override
     public Flux<ReactiveRedisConnection.MultiValueResponse<SMIsMemberCommand, Boolean>> sMIsMember(Publisher<SMIsMemberCommand> commands) {

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -2688,7 +2688,7 @@ public List<byte[]> rPop(byte[] key, long count) {
         return write(key, ByteArrayCodec.INSTANCE, RedisCommands.RPOP_LIST, key, count);
     }
 
-    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand<>("SMISMEMBER", new ObjectListReplayDecoder<>());
+    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand("SMISMEMBER", new ObjectListReplayDecoder<>(), new BooleanReplayConvertor());
 
     @Override
     public List<Boolean> sMIsMember(byte[] key, byte[]... value) {

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -299,7 +299,7 @@ public Flux<CommandResponse<SRandMembersCommand, Flux<ByteBuffer>>> sRandMember(
         });
     }
 
-    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand<>("SMISMEMBER", new ObjectListReplayDecoder<>());
+    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand("SMISMEMBER", new ObjectListReplayDecoder<>(), new BooleanReplayConvertor());
 
     @Override
     public Flux<ReactiveRedisConnection.MultiValueResponse<SMIsMemberCommand, Boolean>> sMIsMember(Publisher<SMIsMemberCommand> commands) {

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -2688,7 +2688,7 @@ public List<byte[]> rPop(byte[] key, long count) {
         return write(key, ByteArrayCodec.INSTANCE, RedisCommands.RPOP_LIST, key, count);
     }
 
-    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand<>("SMISMEMBER", new ObjectListReplayDecoder<>());
+    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand("SMISMEMBER", new ObjectListReplayDecoder<>(), new BooleanReplayConvertor());
 
     @Override
     public List<Boolean> sMIsMember(byte[] key, byte[]... value) {

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -299,7 +299,7 @@ public Flux<CommandResponse<SRandMembersCommand, Flux<ByteBuffer>>> sRandMember(
         });
     }
 
-    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand<>("SMISMEMBER", new ObjectListReplayDecoder<>());
+    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand("SMISMEMBER", new ObjectListReplayDecoder<>(), new BooleanReplayConvertor());
 
     @Override
     public Flux<ReactiveRedisConnection.MultiValueResponse<SMIsMemberCommand, Boolean>> sMIsMember(Publisher<SMIsMemberCommand> commands) {

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -2688,7 +2688,7 @@ public List<byte[]> rPop(byte[] key, long count) {
         return write(key, ByteArrayCodec.INSTANCE, RedisCommands.RPOP_LIST, key, count);
     }
 
-    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand<>("SMISMEMBER", new ObjectListReplayDecoder<>());
+    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand("SMISMEMBER", new ObjectListReplayDecoder<>(), new BooleanReplayConvertor());
 
     @Override
     public List<Boolean> sMIsMember(byte[] key, byte[]... value) {

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -299,7 +299,7 @@ public Flux<CommandResponse<SRandMembersCommand, Flux<ByteBuffer>>> sRandMember(
         });
     }
 
-    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand<>("SMISMEMBER", new ObjectListReplayDecoder<>());
+    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand("SMISMEMBER", new ObjectListReplayDecoder<>(), new BooleanReplayConvertor());
 
     @Override
     public Flux<ReactiveRedisConnection.MultiValueResponse<SMIsMemberCommand, Boolean>> sMIsMember(Publisher<SMIsMemberCommand> commands) {

File: redisson-spring-data/redisson-spring-data-33/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -2688,7 +2688,7 @@ public List<byte[]> rPop(byte[] key, long count) {
         return write(key, ByteArrayCodec.INSTANCE, RedisCommands.RPOP_LIST, key, count);
     }
 
-    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand<>("SMISMEMBER", new ObjectListReplayDecoder<>());
+    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand("SMISMEMBER", new ObjectListReplayDecoder<>(), new BooleanReplayConvertor());
 
     @Override
     public List<Boolean> sMIsMember(byte[] key, byte[]... value) {

File: redisson-spring-data/redisson-spring-data-33/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -299,7 +299,7 @@ public Flux<CommandResponse<SRandMembersCommand, Flux<ByteBuffer>>> sRandMember(
         });
     }
 
-    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand<>("SMISMEMBER", new ObjectListReplayDecoder<>());
+    private static final RedisCommand<List<Boolean>> SMISMEMBER = new RedisCommand("SMISMEMBER", new ObjectListReplayDecoder<>(), new BooleanReplayConvertor());
 
     @Override
     public Flux<ReactiveRedisConnection.MultiValueResponse<SMIsMemberCommand, Boolean>> sMIsMember(Publisher<SMIsMemberCommand> commands) {

File: redisson/src/main/java/org/redisson/RedissonLiveObjectService.java
Patch:
@@ -724,7 +724,7 @@ public Object convert(Object obj) {
             }
         });
 
-        return keys.getKeysByPattern(command, pattern, 0, count);
+        return keys.getKeysByPattern(command, pattern, 0, count, null);
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson-spring-data/redisson-spring-data-33/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-33/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson-spring-data/redisson-spring-data-33/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStreamCommands.java
Patch:
@@ -70,7 +70,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<RecordId
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
             params.add("JUSTID");
 
@@ -95,7 +95,7 @@ public Flux<ReactiveRedisConnection.CommandResponse<XClaimCommand, Flux<ByteBuff
             params.add(k);
             params.add(command.getGroupName());
             params.add(command.getNewOwner());
-            params.add(Objects.requireNonNull(command.getOptions().getIdleTime()).toMillis());
+            params.add(Objects.requireNonNull(command.getOptions().getMinIdleTime()).toMillis());
             params.addAll(Arrays.asList(command.getOptions().getIdsAsStringArray()));
 
             Mono<Map<StreamMessageId, Map<byte[], byte[]>>> m = write(k, ByteArrayCodec.INSTANCE, RedisCommands.XCLAIM, params.toArray());

File: redisson-spring-data/redisson-spring-data-33/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -80,7 +80,7 @@ public List<RecordId> xClaimJustId(byte[] key, String group, String newOwner, XC
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
         params.add("JUSTID");
 
@@ -98,7 +98,7 @@ public List<ByteRecord> xClaim(byte[] key, String group, String newOwner, XClaim
         params.add(key);
         params.add(group);
         params.add(newOwner);
-        params.add(Objects.requireNonNull(options.getIdleTime()).toMillis());
+        params.add(Objects.requireNonNull(options.getMinIdleTime()).toMillis());
         params.addAll(Arrays.asList(options.getIdsAsStringArray()));
 
         return connection.write(key, ByteArrayCodec.INSTANCE, new RedisCommand<List<ByteRecord>>("XCLAIM",

File: redisson/src/main/java/org/redisson/connection/ServiceManager.java
Patch:
@@ -520,8 +520,9 @@ private <T> void execute(AtomicInteger attempts, CompletableFuture<T> result, Su
         CompletionStage<T> future = supplier.get();
         future.whenComplete((r, e) -> {
             if (e != null) {
-                if (e.getCause().getMessage() != null
-                        && e.getCause().getMessage().equals("None of slaves were synced")) {
+                if (e.getCause() != null
+                        && e.getCause().getMessage() != null
+                            && e.getCause().getMessage().equals("None of slaves were synced")) {
                     if (attempts.decrementAndGet() < 0) {
                         result.completeExceptionally(e);
                         return;

File: redisson/src/test/java/org/redisson/jcache/JCacheTest.java
Patch:
@@ -43,7 +43,7 @@ public class JCacheTest {
 
     @Container
     private static final GenericContainer<?> REDIS =
-            new GenericContainer<>("redis:7.2")
+            new GenericContainer<>("redis:latest")
                     .withCreateContainerCmdModifier(cmd -> {
                         cmd.withCmd("redis-server", "--save", "''");
                     })

File: redisson/src/test/java/org/redisson/executor/RedissonExecutorServiceTest.java
Patch:
@@ -226,7 +226,7 @@ void finish(Invocation invocation, String requestId, boolean removeTask) {
 
         redisson.getKeys().delete("counter");
         f.get();
-        assertThat(redisson.getKeys().count()).isEqualTo(1);
+        assertThat(redisson.getKeys().count()).isEqualTo(3);
     }
     
     @Test

File: redisson/src/main/java/org/redisson/client/handler/CommandsQueue.java
Patch:
@@ -29,7 +29,6 @@
 import java.util.Iterator;
 import java.util.Queue;
 import java.util.concurrent.ConcurrentLinkedDeque;
-import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  *

File: redisson/src/main/java/org/redisson/client/codec/BaseCodec.java
Patch:
@@ -21,6 +21,7 @@
 import org.redisson.cache.LocalCachedMessageCodec;
 import org.redisson.client.protocol.Decoder;
 import org.redisson.client.protocol.Encoder;
+import org.redisson.codec.ProtobufCodec;
 import org.redisson.jcache.JCacheEventCodec;
 
 /**
@@ -32,7 +33,7 @@ public abstract class BaseCodec implements Codec {
 
     public static final List<Class<?>> SKIPPED_CODECS = Arrays.asList(
             StringCodec.class, ByteArrayCodec.class, LocalCachedMessageCodec.class, BitSetCodec.class,
-            JCacheEventCodec.class, LongCodec.class, IntegerCodec.class);
+            JCacheEventCodec.class, LongCodec.class, IntegerCodec.class, ProtobufCodec.class);
     
     public static <T> T copy(ClassLoader classLoader, T codec) throws ReflectiveOperationException {
         if (codec == null) {

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -445,8 +445,8 @@ protected void decode(ByteBuf in, CommandData<Object, Object> data, List<Object>
             }
             handleResult(data, parts, result, false);
         } else if (code == '*' || code == '>' || code == '~') {
-            long size = readLong(in);
-            List<Object> respParts = new ArrayList<Object>(Math.max((int) size, 0));
+            Long size = readLong(in);
+            List<Object> respParts = new ArrayList<Object>(Math.max(size.intValue(), 0));
             
             state.incLevel();
             
@@ -576,7 +576,7 @@ private void readCRLF(ByteBuf is) {
         is.skipBytes(2);
     }
 
-    private long readLong(ByteBuf is) {
+    private Long readLong(ByteBuf is) {
         String value = readString(is, StandardCharsets.US_ASCII);
         return Long.parseLong(value);
     }

File: redisson/src/main/java/org/redisson/liveobject/core/AccessorInterceptor.java
Patch:
@@ -215,9 +215,9 @@ private void removeIndex(RMap<String, Object> liveMap, Object me, Field field) {
                     || commandExecutor.getServiceManager().getCfg().isClusterConfig()) {
                 CompletableFuture<Object> f;
                 if (commandExecutor instanceof CommandBatchService) {
-                    f = liveMap.removeAsync(field.getName()).toCompletableFuture();
+                    f = liveMap.getAsync(field.getName()).toCompletableFuture();
                 } else {
-                    Object value = liveMap.remove(field.getName());
+                    Object value = liveMap.get(field.getName());
                     f = CompletableFuture.completedFuture(value);
                 }
                 f.thenAccept(value -> {
@@ -248,7 +248,6 @@ private void removeAsync(CommandBatchService ce, String name, String mapName, Co
                         "if oldArg == false then " +
                             "return; " +
                         "end;" +
-                        "redis.call('hdel', KEYS[2], ARGV[2]); " +
                         "local hash = redis.call('hget', KEYS[1], oldArg); " +
                         "local setName = KEYS[1] .. ':' .. hash; " +
                         "local res = redis.call('srem', setName, ARGV[1]); " +

File: redisson/src/main/java/org/redisson/RedissonSetCache.java
Patch:
@@ -1306,7 +1306,7 @@ public RFuture<Integer> addAllIfAbsentAsync(Map<V, Duration> objects) {
                   "local result = 0; " +
                         "for i=2, #ARGV, 2 do " +
                             "local expireDateScore = redis.call('zscore', KEYS[1], ARGV[i+1]); " +
-                            "if expireDateScore ~= false and tonumber(expireDateScore) <= tonumber(ARGV[1]) then " +
+                            "if expireDateScore == false or tonumber(expireDateScore) <= tonumber(ARGV[1]) then " +
                                 "result = result + 1; " +
                                 "redis.call('zadd', KEYS[1], ARGV[i], ARGV[i+1]); " +
                             "end; " +

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -1684,8 +1684,9 @@ protected RFuture<Map<K, V>> getAllWithTTLOnlyOperationAsync(Set<K> keys) {
                         "local currentTime = tonumber(table.remove(ARGV, 1)); " + // index is the first parameter
                         "local hasExpire = #expireHead == 2 and tonumber(expireHead[2]) <= currentTime; " +
                         "local map = {}; " +
-                        "for i = 1, #ARGV, 1 do " +
-                        "    local value = redis.call('hget', KEYS[1], ARGV[i]); " +
+                        "local values = redis.call('hmget', KEYS[1], unpack(ARGV));" +
+                        "for i = 1, #values, 1 do " +
+                        "    local value = values[i]; " +
                         "    map[i] = false;" +
                         "    if value ~= false then " +
                         "        local key = ARGV[i]; " +

File: redisson/src/main/java/org/redisson/codec/Kryo5Codec.java
Patch:
@@ -163,6 +163,7 @@ protected Kryo createKryo(ClassLoader classLoader, boolean useReferences) throws
         } catch (Exception e) {
             logger.warn("Unable to register Collections serializer", e);
         }
+        kryo.addDefaultSerializer(EnumMap.class, new JavaSerializer());
         kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());
         kryo.addDefaultSerializer(UUID.class, new DefaultSerializers.UUIDSerializer());
         kryo.addDefaultSerializer(URI.class, new DefaultSerializers.URISerializer());

File: redisson-spring-boot-starter/src/main/java/org/redisson/spring/starter/RedissonAutoConfigurationCustomizer.java
Patch:
@@ -30,5 +30,6 @@ public interface RedissonAutoConfigurationCustomizer {
      * Customize the RedissonClient configuration.
      * @param configuration the {@link Config} to customize
      */
-    void customize(final Config configuration);
+    void customize(Config configuration);
+
 }

File: redisson/src/main/java/org/redisson/jcache/JCache.java
Patch:
@@ -3141,6 +3141,7 @@ public void close() {
             for (CacheEntryListenerConfiguration<K, V> config : listeners.keySet()) {
                 deregisterCacheEntryListener(config);
             }
+            redisson.getEvictionScheduler().remove(getRawName());
         }
     }
 

File: redisson/src/main/java/org/redisson/api/RMultimapCache.java
Patch:
@@ -25,7 +25,7 @@
  * @param <K> key type
  * @param <V> value type
  */
-public interface RMultimapCache<K, V> extends RMultimap<K, V>, RMultimapCacheAsync<K, V> {
+public interface RMultimapCache<K, V> extends RMultimap<K, V>, RMultimapCacheAsync<K, V>, RDestroyable {
 
     /**
      * Set a timeout for key. After the timeout has expired,

File: redisson/src/main/java/org/redisson/connection/ReplicatedConnectionManager.java
Patch:
@@ -204,7 +204,7 @@ private CompletableFuture<Role> checkNode(RedisURI uri, ReplicatedServersConfig
                         return CompletableFuture.<Map<String, String>>completedFuture(null);
                     }
 
-                    return connection.async(3, cfg.getRetryInterval(), cfg.getTimeout(),
+                    return connection.async(1, cfg.getRetryInterval(), cfg.getTimeout(),
                                                 StringCodec.INSTANCE, RedisCommands.INFO_REPLICATION);
                 })
                 .thenCompose(r -> {

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -394,7 +394,7 @@ private CompletionStage<Void> checkSentinelsChange(SentinelServersConfig cfg, Re
             return CompletableFuture.completedFuture(null);
         }
 
-        RFuture<List<Map<String, String>>> sentinelsFuture = connection.async(3, cfg.getRetryInterval(), cfg.getTimeout(),
+        RFuture<List<Map<String, String>>> sentinelsFuture = connection.async(1, cfg.getRetryInterval(), cfg.getTimeout(),
                                                                                 StringCodec.INSTANCE, RedisCommands.SENTINEL_SENTINELS, cfg.getMasterName());
         return sentinelsFuture.thenCompose(list -> {
             if (list.isEmpty()) {
@@ -437,7 +437,7 @@ private CompletionStage<Void> checkSentinelsChange(SentinelServersConfig cfg, Re
     }
 
     private CompletionStage<Void> checkSlavesChange(SentinelServersConfig cfg, RedisConnection connection) {
-        RFuture<List<Map<String, String>>> slavesFuture = connection.async(3, cfg.getRetryInterval(), cfg.getTimeout(),
+        RFuture<List<Map<String, String>>> slavesFuture = connection.async(1, cfg.getRetryInterval(), cfg.getTimeout(),
                                                                             StringCodec.INSTANCE, RedisCommands.SENTINEL_SLAVES, cfg.getMasterName());
         return slavesFuture.thenCompose(slavesMap -> {
             Set<RedisURI> currentSlaves = Collections.newSetFromMap(new ConcurrentHashMap<>(slavesMap.size()));
@@ -506,7 +506,7 @@ private CompletionStage<Void> checkSlavesChange(SentinelServersConfig cfg, Redis
     }
 
     private CompletionStage<RedisClient> checkMasterChange(SentinelServersConfig cfg, RedisConnection connection) {
-        RFuture<RedisURI> masterFuture = connection.async(3, cfg.getRetryInterval(), cfg.getTimeout(),
+        RFuture<RedisURI> masterFuture = connection.async(1, cfg.getRetryInterval(), cfg.getTimeout(),
                                                             StringCodec.INSTANCE, masterHostCommand, cfg.getMasterName());
         return masterFuture
                 .thenCompose(u -> serviceManager.resolveIP(scheme, u))

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -394,7 +394,7 @@ private CompletionStage<Void> checkSentinelsChange(SentinelServersConfig cfg, Re
             return CompletableFuture.completedFuture(null);
         }
 
-        RFuture<List<Map<String, String>>> sentinelsFuture = connection.async(cfg.getRetryAttempts(), cfg.getRetryInterval(), cfg.getTimeout(),
+        RFuture<List<Map<String, String>>> sentinelsFuture = connection.async(3, cfg.getRetryInterval(), cfg.getTimeout(),
                                                                                 StringCodec.INSTANCE, RedisCommands.SENTINEL_SENTINELS, cfg.getMasterName());
         return sentinelsFuture.thenCompose(list -> {
             if (list.isEmpty()) {
@@ -437,7 +437,7 @@ private CompletionStage<Void> checkSentinelsChange(SentinelServersConfig cfg, Re
     }
 
     private CompletionStage<Void> checkSlavesChange(SentinelServersConfig cfg, RedisConnection connection) {
-        RFuture<List<Map<String, String>>> slavesFuture = connection.async(cfg.getRetryAttempts(), cfg.getRetryInterval(), cfg.getTimeout(),
+        RFuture<List<Map<String, String>>> slavesFuture = connection.async(3, cfg.getRetryInterval(), cfg.getTimeout(),
                                                                             StringCodec.INSTANCE, RedisCommands.SENTINEL_SLAVES, cfg.getMasterName());
         return slavesFuture.thenCompose(slavesMap -> {
             Set<RedisURI> currentSlaves = Collections.newSetFromMap(new ConcurrentHashMap<>(slavesMap.size()));
@@ -506,7 +506,7 @@ private CompletionStage<Void> checkSlavesChange(SentinelServersConfig cfg, Redis
     }
 
     private CompletionStage<RedisClient> checkMasterChange(SentinelServersConfig cfg, RedisConnection connection) {
-        RFuture<RedisURI> masterFuture = connection.async(cfg.getRetryAttempts(), cfg.getRetryInterval(), cfg.getTimeout(),
+        RFuture<RedisURI> masterFuture = connection.async(3, cfg.getRetryInterval(), cfg.getTimeout(),
                                                             StringCodec.INSTANCE, masterHostCommand, cfg.getMasterName());
         return masterFuture
                 .thenCompose(u -> serviceManager.resolveIP(scheme, u))

File: redisson-micronaut/redisson-micronaut-20/src/main/java/org/redisson/micronaut/cache/RedissonSyncCache.java
Patch:
@@ -37,15 +37,15 @@ public class RedissonSyncCache extends AbstractMapBasedSyncCache<RMap<Object, Ob
 
     private final ConversionService<?> conversionService;
     private final ExecutorService executorService;
-    private final RedissonCacheConfiguration configuration;
+    private final BaseCacheConfiguration configuration;
     private final RMapCache<Object, Object> mapCache;
     private final RMap<Object, Object> map;
 
     public RedissonSyncCache(ConversionService<?> conversionService,
                              RMapCache<Object, Object> mapCache,
                              RMap<Object, Object> map,
                              ExecutorService executorService,
-                             RedissonCacheConfiguration configuration) {
+                             BaseCacheConfiguration configuration) {
         super(conversionService, map);
         this.executorService = executorService;
         this.configuration = configuration;

File: redisson-micronaut/redisson-micronaut-30/src/main/java/org/redisson/micronaut/cache/RedissonSyncCache.java
Patch:
@@ -37,15 +37,15 @@ public class RedissonSyncCache extends AbstractMapBasedSyncCache<RMap<Object, Ob
 
     private final ConversionService<?> conversionService;
     private final ExecutorService executorService;
-    private final RedissonCacheConfiguration configuration;
+    private final BaseCacheConfiguration configuration;
     private final RMapCache<Object, Object> mapCache;
     private final RMap<Object, Object> map;
 
     public RedissonSyncCache(ConversionService<?> conversionService,
                              RMapCache<Object, Object> mapCache,
                              RMap<Object, Object> map,
                              ExecutorService executorService,
-                             RedissonCacheConfiguration configuration) {
+                             BaseCacheConfiguration configuration) {
         super(conversionService, map);
         this.executorService = executorService;
         this.configuration = configuration;

File: redisson/src/main/java/org/redisson/connection/ReplicatedConnectionManager.java
Patch:
@@ -204,7 +204,7 @@ private CompletableFuture<Role> checkNode(RedisURI uri, ReplicatedServersConfig
                         return CompletableFuture.<Map<String, String>>completedFuture(null);
                     }
 
-                    return connection.async(cfg.getRetryAttempts(), cfg.getRetryInterval(), cfg.getTimeout(),
+                    return connection.async(3, cfg.getRetryInterval(), cfg.getTimeout(),
                                                 StringCodec.INSTANCE, RedisCommands.INFO_REPLICATION);
                 })
                 .thenCompose(r -> {

File: redisson/src/main/java/org/redisson/connection/ReplicatedConnectionManager.java
Patch:
@@ -237,7 +237,7 @@ private CompletableFuture<Role> checkNode(RedisURI uri, ReplicatedServersConfig
                 })
                 .whenComplete((r, ex) -> {
                     if (ex != null) {
-                        log.error(ex.getMessage(), ex);
+                        log.error("Unable to update node {} status. A new attempt will be made.", uri, ex);
                     }
                 })
                 .toCompletableFuture();

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -20,6 +20,7 @@
 import org.redisson.api.NodeType;
 import org.redisson.api.RFuture;
 import org.redisson.client.*;
+import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.RedisStrictCommand;
 import org.redisson.cluster.ClusterNodeInfo.Flag;
@@ -454,7 +455,8 @@ private void checkClusterState(ClusterServersConfig cfg, Iterator<RedisURI> iter
 
     private void updateClusterState(ClusterServersConfig cfg, RedisConnection connection,
             Iterator<RedisURI> iterator, RedisURI uri, AtomicReference<Throwable> lastException, List<RedisURI> allNodes) {
-        RFuture<List<ClusterNodeInfo>> future = connection.async(clusterNodesCommand);
+        RFuture<List<ClusterNodeInfo>> future = connection.async(cfg.getRetryAttempts(), cfg.getRetryInterval(), cfg.getTimeout(),
+                                                                        StringCodec.INSTANCE, clusterNodesCommand);
         future.whenComplete((nodes, e) -> {
                 if (e != null) {
                     log.error("Unable to execute {}", clusterNodesCommand, e);

File: redisson/src/main/java/org/redisson/connection/ReplicatedConnectionManager.java
Patch:
@@ -20,6 +20,7 @@
 import org.redisson.client.RedisClient;
 import org.redisson.client.RedisConnection;
 import org.redisson.client.RedisConnectionException;
+import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.config.*;
 import org.redisson.misc.RedisURI;
@@ -203,7 +204,8 @@ private CompletableFuture<Role> checkNode(RedisURI uri, ReplicatedServersConfig
                         return CompletableFuture.<Map<String, String>>completedFuture(null);
                     }
 
-                    return connection.async(RedisCommands.INFO_REPLICATION);
+                    return connection.async(cfg.getRetryAttempts(), cfg.getRetryInterval(), cfg.getTimeout(),
+                                                StringCodec.INSTANCE, RedisCommands.INFO_REPLICATION);
                 })
                 .thenCompose(r -> {
                     if (r == null) {

File: redisson/src/test/java/org/redisson/RedissonRateLimiterTest.java
Patch:
@@ -122,7 +122,7 @@ public void testPermitsExceeding() throws InterruptedException {
         limiter.trySetRate(RateType.PER_CLIENT, 1, 1, RateIntervalUnit.SECONDS);
         
         org.assertj.core.api.Assertions.assertThatThrownBy(() -> limiter.tryAcquire(20))
-                    .hasMessageContaining("Requested permits amount could not exceed defined rate");
+                    .hasMessageContaining("Requested permits amount cannot exceed defined rate");
         assertThat(limiter.tryAcquire()).isTrue();
     }
 

File: redisson/src/main/java/org/redisson/api/RType.java
Patch:
@@ -22,6 +22,6 @@
  */
 public enum RType {
 
-    OBJECT, MAP, LIST, SET, ZSET
+    OBJECT, MAP, LIST, SET, ZSET, STREAM, JSON
     
 }

File: redisson/src/test/java/org/redisson/RedissonJsonBucketTest.java
Patch:
@@ -4,6 +4,7 @@
 import org.junit.jupiter.api.Test;
 import org.redisson.api.JsonType;
 import org.redisson.api.RJsonBucket;
+import org.redisson.api.RType;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.codec.JacksonCodec;
 
@@ -88,6 +89,8 @@ public void testType() {
         t.setName("name1");
         al.set(t);
 
+        assertThat(redisson.getKeys().getType("test")).isEqualTo(RType.JSON);
+
         JsonType s = al.getType();
         assertThat(s).isEqualTo(JsonType.OBJECT);
         JsonType s1 = al.getType("name");

File: redisson/src/main/java/org/redisson/RedissonKeys.java
Patch:
@@ -617,7 +617,8 @@ public void removeListener(int listenerId) {
     public RFuture<Void> removeListenerAsync(int listenerId) {
         PublishSubscribeService subscribeService = commandExecutor.getConnectionManager().getSubscribeService();
         CompletableFuture<Void> f = subscribeService.removeFlushListenerAsync(listenerId);
-        f = f.thenCompose(r -> removeListenerAsync(null, listenerId, "__keyevent@*:expired", "__keyevent@*:del"));
+        f = f.thenCompose(r -> removeListenerAsync(null, listenerId,
+                "__keyevent@*:expired", "__keyevent@*:del", "__keyevent@*:set", "__keyevent@*:new"));
         return new CompletableFutureWrapper<>(f);
     }
 

File: redisson/src/main/java/org/redisson/Redisson.java
Patch:
@@ -290,7 +290,7 @@ public <V> RJsonBucket<V> getJsonBucket(String name, JsonCodec codec) {
     @Override
     public <V> RJsonBucket<V> getJsonBucket(JsonBucketOptions<V> options) {
         JsonBucketParams<V> params = (JsonBucketParams) options;
-        return new RedissonJsonBucket<>(params.getCodec(), commandExecutor, params.getName());
+        return new RedissonJsonBucket<>(params.getCodec(), commandExecutor.copy(params), params.getName());
     }
     
     @Override
@@ -550,7 +550,7 @@ public <K, V> RMapCache<K, V> getMapCache(org.redisson.api.options.MapCacheOptio
         MapCacheParams<K, V> params = (MapCacheParams<K, V>) options;
         MapCacheOptions<K, V> ops = createOptions(params);
         return new RedissonMapCache<>(params.getCodec(), evictionScheduler,
-                commandExecutor, params.getName(), this, ops, writeBehindService);
+                commandExecutor.copy(params), params.getName(), this, ops, writeBehindService);
     }
 
     private static <K, V> MapCacheOptions<K, V> createOptions(MapCacheParams<K, V> params) {

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -422,6 +422,8 @@ private ClassBody getClassBody(Object task) {
                 try {
                     ObjectOutput oo = new ObjectOutputStream(os);
                     oo.writeObject(task);
+                    oo.flush();
+                    oo.close();
                 } catch (Exception e) {
                     throw new IllegalArgumentException("Unable to serialize lambda", e);
                 }

File: redisson/src/main/java/org/redisson/api/RLiveObjectService.java
Patch:
@@ -198,7 +198,7 @@ public interface RLiveObjectService {
      *
      * @param <T> Entity type
      * @param attachedObject - proxied object
-     * @return proxied object
+     * @return detachedObject object - not proxied object
      */
     <T> T detach(T attachedObject);
 

File: redisson/src/main/java/org/redisson/client/FailedCommandsTimeoutDetector.java
Patch:
@@ -24,6 +24,9 @@
  */
 public class FailedCommandsTimeoutDetector extends FailedCommandsDetector {
 
+    public FailedCommandsTimeoutDetector() {
+    }
+
     public FailedCommandsTimeoutDetector(long checkInterval, int failedCommandsLimit) {
         super(checkInterval, failedCommandsLimit);
     }

File: redisson/src/main/java/org/redisson/codec/Kryo5Codec.java
Patch:
@@ -22,6 +22,7 @@
 import com.esotericsoftware.kryo.serializers.DefaultSerializers;
 import com.esotericsoftware.kryo.serializers.JavaSerializer;
 import com.esotericsoftware.kryo.util.Pool;
+import de.javakaffee.kryoserializers.SynchronizedCollectionsSerializer;
 import de.javakaffee.kryoserializers.UnmodifiableCollectionsSerializer;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
@@ -142,6 +143,7 @@ protected Kryo createKryo(ClassLoader classLoader) {
         kryo.addDefaultSerializer(URI.class, new DefaultSerializers.URISerializer());
         kryo.addDefaultSerializer(Pattern.class, new DefaultSerializers.PatternSerializer());
         UnmodifiableCollectionsSerializer.registerSerializers(kryo);
+        SynchronizedCollectionsSerializer.registerSerializers(kryo);
         return kryo;
     }
 

File: redisson/src/main/java/org/redisson/codec/Kryo5Codec.java
Patch:
@@ -22,6 +22,7 @@
 import com.esotericsoftware.kryo.serializers.DefaultSerializers;
 import com.esotericsoftware.kryo.serializers.JavaSerializer;
 import com.esotericsoftware.kryo.util.Pool;
+import de.javakaffee.kryoserializers.UnmodifiableCollectionsSerializer;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.ByteBufInputStream;
@@ -140,6 +141,7 @@ protected Kryo createKryo(ClassLoader classLoader) {
         kryo.addDefaultSerializer(UUID.class, new DefaultSerializers.UUIDSerializer());
         kryo.addDefaultSerializer(URI.class, new DefaultSerializers.URISerializer());
         kryo.addDefaultSerializer(Pattern.class, new DefaultSerializers.PatternSerializer());
+        UnmodifiableCollectionsSerializer.registerSerializers(kryo);
         return kryo;
     }
 

File: redisson/src/main/java/org/redisson/api/RMultimapCacheReactive.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.redisson.api;
 
-import io.reactivex.rxjava3.core.Single;
+import reactor.core.publisher.Mono;
 
 import java.util.concurrent.TimeUnit;
 
@@ -38,5 +38,5 @@ public interface RMultimapCacheReactive<K, V> {
      * @return A Single that will emit <code>true</code> if key exists and the timeout was set and <code>false</code>
      * if key not exists
      */
-    Single<Boolean> expireKey(K key, long timeToLive, TimeUnit timeUnit);
+    Mono<Boolean> expireKey(K key, long timeToLive, TimeUnit timeUnit);
 }

File: redisson/src/test/java/org/redisson/RedissonLiveObjectServiceTest.java
Patch:
@@ -6,6 +6,7 @@
 import org.redisson.api.*;
 import org.redisson.api.annotation.*;
 import org.redisson.api.condition.Conditions;
+import org.redisson.codec.JsonJacksonCodec;
 import org.redisson.liveobject.resolver.DefaultNamingScheme;
 import org.redisson.liveobject.resolver.LongGenerator;
 import org.redisson.liveobject.resolver.UUIDGenerator;
@@ -2005,7 +2006,8 @@ public static class SetterEncapsulation {
         
         @RId(generator = LongGenerator.class)
         private Long id;
-        
+
+        @RObjectField(codec = JsonJacksonCodec.class)
         private Map<String, Integer> map;
         
         public SetterEncapsulation() {

File: redisson/src/main/java/org/redisson/RedissonObject.java
Patch:
@@ -629,7 +629,7 @@ protected final void addListenerId(String name, Integer id) {
     protected final void removeListeners() {
         for (Map.Entry<String, Collection<Integer>> entry : listeners.entrySet()) {
             for (Integer id : entry.getValue()) {
-                removeListener(id, name);
+                removeListener(id, entry.getKey());
             }
         }
     }
@@ -653,7 +653,7 @@ public RFuture<Integer> addListenerAsync(ObjectListener listener) {
         if (listener instanceof DeletedObjectListener) {
             return addListenerAsync("__keyevent@*:del", (DeletedObjectListener) listener, DeletedObjectListener::onDeleted);
         }
-        throw new IllegalArgumentException();
+        throw new IllegalArgumentException("This type of listener can't be added to this object");
     }
     
     @Override

File: redisson/src/main/java/org/redisson/RedissonDelayedQueue.java
Patch:
@@ -534,6 +534,7 @@ public V pollLastAndOfferFirstTo(String dequeName) {
     @Override
     public void destroy() {
         commandExecutor.getServiceManager().getQueueTransferService().remove(queueName);
+        removeListeners();
     }
     
 }

File: redisson/src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -1728,6 +1728,7 @@ public void destroy() {
         if (writeBehindService != null) {
             writeBehindService.stop(getRawName());
         }
+        removeListeners();
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonSetCache.java
Patch:
@@ -449,6 +449,7 @@ public void destroy() {
         if (evictionScheduler != null) {
             evictionScheduler.remove(getRawName());
         }
+        removeListeners();
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonTimeSeries.java
Patch:
@@ -981,6 +981,7 @@ public void destroy() {
         if (evictionScheduler != null) {
             evictionScheduler.remove(getRawName());
         }
+        removeListeners();
     }
 
     @Override

File: redisson/src/main/java/org/redisson/api/RSearch.java
Patch:
@@ -195,7 +195,9 @@ public interface RSearch extends RSearchAsync {
     void dropIndex(String indexName);
 
     /**
-     * Deletes index by name and associated documents
+     * Deletes index by name and associated documents.
+     * Associated documents are deleted asynchronously.
+     * Method {@link #info(String)} can be used to check for process completion.
      *
      * @param indexName index name
      */

File: redisson/src/main/java/org/redisson/api/RSearchAsync.java
Patch:
@@ -188,7 +188,9 @@ public interface RSearchAsync {
     RFuture<List<String>> dumpDictAsync(String dictionary);
 
     /**
-     * Deletes index by name
+     * Deletes index by name and associated documents.
+     * Associated documents are deleted asynchronously.
+     * Method {@link #infoAsync(String)} can be used to check for process completion.
      *
      * @param indexName index name
      */

File: redisson/src/main/java/org/redisson/api/RSearchReactive.java
Patch:
@@ -196,7 +196,9 @@ public interface RSearchReactive {
     Mono<Void> dropIndex(String indexName);
 
     /**
-     * Deletes index by name and associated documents
+     * Deletes index by name and associated documents.
+     * Associated documents are deleted asynchronously.
+     * Method {@link #info(String)} can be used to check for process completion.
      *
      * @param indexName index name
      */

File: redisson/src/main/java/org/redisson/api/RSearchRx.java
Patch:
@@ -198,7 +198,9 @@ public interface RSearchRx {
     Completable dropIndex(String indexName);
 
     /**
-     * Deletes index by name and associated documents
+     * Deletes index by name and associated documents.
+     * Associated documents are deleted asynchronously.
+     * Method {@link #info(String)} can be used to check for process completion.
      *
      * @param indexName index name
      */

File: redisson/src/main/java/org/redisson/api/StreamMessageId.java
Patch:
@@ -62,6 +62,9 @@ public class StreamMessageId {
      * Defines id to receive Stream entries since the last message.
      * <p>
      * Used in {@link RStream#read}, {@link RStream#createGroup} methods
+     * <p>
+     * Requires Redis 7.4+
+     *
      */
     public static final StreamMessageId LAST = new StreamMessageId(-1);
 

File: redisson/src/main/java/org/redisson/api/RSearch.java
Patch:
@@ -211,6 +211,8 @@ public interface RSearch extends RSearchAsync {
 
     /**
      * Executes spell checking by defined index name and query.
+     * Returns a map of misspelled terms and their score.
+     *
      * <pre>
      * Map<String, Map<String, Double>> res = s.spellcheck("idx", "Hocke sti", SpellcheckOptions.defaults()
      *                                                                                          .includedTerms("name"));
@@ -219,7 +221,7 @@ public interface RSearch extends RSearchAsync {
      * @param indexName index name
      * @param query query
      * @param options spell checking options
-     * @return result
+     * @return map of misspelled terms and their score
      */
     Map<String, Map<String, Double>> spellcheck(String indexName, String query, SpellcheckOptions options);
 

File: redisson/src/main/java/org/redisson/api/RSearchAsync.java
Patch:
@@ -211,6 +211,8 @@ public interface RSearchAsync {
 
     /**
      * Executes spell checking by defined index name and query.
+     * Returns a map of misspelled terms and their score.
+     *
      * <pre>
      * Map<String, Map<String, Double>> res = s.spellcheck("idx", "Hocke sti", SpellcheckOptions.defaults()
      *                                                                                          .includedTerms("name"));
@@ -219,7 +221,7 @@ public interface RSearchAsync {
      * @param indexName index name
      * @param query query
      * @param options spell checking options
-     * @return result
+     * @return map of misspelled terms and their score
      */
     RFuture<Map<String, Map<String, Double>>> spellcheckAsync(String indexName, String query, SpellcheckOptions options);
 

File: redisson/src/main/java/org/redisson/api/RSearchReactive.java
Patch:
@@ -212,6 +212,8 @@ public interface RSearchReactive {
 
     /**
      * Executes spell checking by defined index name and query.
+     * Returns a map of misspelled terms and their score.
+     *
      * <pre>
      * Map<String, Map<String, Double>> res = s.spellcheck("idx", "Hocke sti", SpellcheckOptions.defaults()
      *                                                                                          .includedTerms("name"));
@@ -220,7 +222,7 @@ public interface RSearchReactive {
      * @param indexName index name
      * @param query query
      * @param options spell checking options
-     * @return result
+     * @return map of misspelled terms and their score
      */
     Mono<Map<String, Map<String, Double>>> spellcheck(String indexName, String query, SpellcheckOptions options);
 

File: redisson/src/main/java/org/redisson/api/RSearchRx.java
Patch:
@@ -214,6 +214,8 @@ public interface RSearchRx {
 
     /**
      * Executes spell checking by defined index name and query.
+     * Returns a map of misspelled terms and their score.
+     *
      * <pre>
      * Map<String, Map<String, Double>> res = s.spellcheck("idx", "Hocke sti", SpellcheckOptions.defaults()
      *                                                                                          .includedTerms("name"));
@@ -222,7 +224,7 @@ public interface RSearchRx {
      * @param indexName index name
      * @param query     query
      * @param options   spell checking options
-     * @return result
+     * @return map of misspelled terms and their score
      */
     Single<Map<String, Map<String, Double>>> spellcheck(String indexName, String query, SpellcheckOptions options);
 

File: redisson/src/test/java/org/redisson/RedissonFailoverTest.java
Patch:
@@ -254,7 +254,7 @@ public void run() {
 
             assertThat(futures.get(futures.size() - 1).isDone()).isTrue();
             assertThat(futures.get(futures.size() - 1).toCompletableFuture().isCompletedExceptionally()).isFalse();
-            assertThat(errors).isBetween(100, 820);
+            assertThat(errors).isBetween(30, 800);
             assertThat(readonlyErrors).isZero();
 
             redisson.shutdown();

File: redisson/src/main/java/org/redisson/remote/BaseRemoteProxy.java
Patch:
@@ -17,7 +17,6 @@
 
 import io.netty.util.Timeout;
 import org.redisson.RedissonBlockingQueue;
-import org.redisson.RedissonShutdownException;
 import org.redisson.api.RBlockingQueue;
 import org.redisson.api.RFuture;
 import org.redisson.api.RemoteInvocationOptions;

File: redisson/src/main/java/org/redisson/ElementsSubscribeService.java
Patch:
@@ -81,7 +81,7 @@ private <V> void resubscribe(Supplier<CompletionStage<V>> func, Consumer<V> cons
 
         f.whenComplete((r, e) -> {
             if (e != null) {
-                if (e.getCause() instanceof RedissonShutdownException) {
+                if (serviceManager.isShuttingDown(e)) {
                     return;
                 }
 
@@ -107,7 +107,7 @@ private <V> void resubscribe(Supplier<CompletionStage<V>> func, Function<V, Comp
 
         f.thenCompose(consumer).whenComplete((r, ex) -> {
             if (ex != null) {
-                if (ex.getCause() instanceof RedissonShutdownException) {
+                if (serviceManager.isShuttingDown(ex)) {
                     return;
                 }
 

File: redisson/src/main/java/org/redisson/QueueTransferTask.java
Patch:
@@ -143,7 +143,7 @@ private void pushTask() {
         RFuture<Long> startTimeFuture = pushTaskAsync();
         startTimeFuture.whenComplete((res, e) -> {
             if (e != null) {
-                if (e instanceof RedissonShutdownException) {
+                if (serviceManager.isShuttingDown(e)) {
                     return;
                 }
                 log.error(e.getMessage(), e);

File: redisson/src/main/java/org/redisson/RedissonIdGenerator.java
Patch:
@@ -125,7 +125,7 @@ private void handleIdRequests() {
                     Arrays.asList(getRawName(), getAllocationSizeName()));
             future.whenComplete((res, ex) -> {
                 if (ex != null) {
-                    if (ex instanceof RedissonShutdownException) {
+                    if (getServiceManager().isShuttingDown(ex)) {
                         return;
                     }
 

File: redisson/src/main/java/org/redisson/RedissonPermitExpirableSemaphore.java
Patch:
@@ -371,7 +371,7 @@ private RFuture<List<String>> tryAcquireAsync(int permits, long timeoutDate) {
         return getServiceManager().execute(() -> {
             RFuture<List<String>> future = tryAcquireAsync(ids, timeoutDate);
             return commandExecutor.handleNoSync(future, () -> releaseAsync(ids));
-        }, Collections.emptyList());
+        });
     }
 
     private RFuture<List<String>> tryAcquireAsync(List<String> ids, long timeoutDate) {

File: redisson/src/main/java/org/redisson/RedissonReliableTopic.java
Patch:
@@ -183,7 +183,7 @@ private void poll(String id) {
 
         ff.whenComplete((res, ex) -> {
             if (ex != null) {
-                if (ex instanceof RedissonShutdownException) {
+                if (getServiceManager().isShuttingDown(ex)) {
                     return;
                 }
 
@@ -250,7 +250,7 @@ private void poll(String id) {
 
                 updateFuture.whenComplete((re, exc) -> {
                     if (exc != null) {
-                        if (exc instanceof RedissonShutdownException) {
+                        if (getServiceManager().isShuttingDown(exc)) {
                             return;
                         }
                         log.error("Unable to update subscriber status", exc);

File: redisson/src/main/java/org/redisson/RedissonSemaphore.java
Patch:
@@ -263,7 +263,7 @@ public RFuture<Boolean> tryAcquireAsync(int permits) {
         return commandExecutor.getServiceManager().execute(() -> {
             RFuture<Boolean> future = tryAcquireAsync0(permits);
             return commandExecutor.handleNoSync(future, () -> releaseAsync(permits));
-        }, false);
+        });
     }
 
     private RFuture<Boolean> tryAcquireAsync0(int permits) {

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -487,7 +487,7 @@ private void handleBlockingOperations(CompletableFuture<R> attemptPromise, Redis
                 return;
             }
 
-            if (e instanceof RedissonShutdownException) {
+            if (connectionManager.getServiceManager().isShuttingDown(e)) {
                 attemptPromise.completeExceptionally(e);
             }
         });

File: redisson/src/main/java/org/redisson/remote/BaseRemoteProxy.java
Patch:
@@ -183,7 +183,7 @@ private void pollResponse() {
     private BiConsumer<RRemoteServiceResponse, Throwable> createResponseListener() {
         return (response, e) -> {
             if (e != null) {
-                if (e instanceof RedissonShutdownException) {
+                if (commandExecutor.getServiceManager().isShuttingDown(e)) {
                     return;
                 }
 

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -506,7 +506,7 @@ public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {
         serviceManager.getResolverGroup().close();
 
         long startTime = System.nanoTime();
-        serviceManager.shutdownFutures(quietPeriod, unit);
+        serviceManager.shutdownFutures(timeout, unit);
         timeoutInNanos = Math.max(0, timeoutInNanos - (System.nanoTime() - startTime));
 
         if (isInitialized()) {

File: redisson/src/main/java/org/redisson/RedissonPermitExpirableSemaphore.java
Patch:
@@ -371,7 +371,7 @@ private RFuture<List<String>> tryAcquireAsync(int permits, long timeoutDate) {
         return getServiceManager().execute(() -> {
             RFuture<List<String>> future = tryAcquireAsync(ids, timeoutDate);
             return commandExecutor.handleNoSync(future, () -> releaseAsync(ids));
-        });
+        }, Collections.emptyList());
     }
 
     private RFuture<List<String>> tryAcquireAsync(List<String> ids, long timeoutDate) {

File: redisson/src/main/java/org/redisson/RedissonSemaphore.java
Patch:
@@ -263,7 +263,7 @@ public RFuture<Boolean> tryAcquireAsync(int permits) {
         return commandExecutor.getServiceManager().execute(() -> {
             RFuture<Boolean> future = tryAcquireAsync0(permits);
             return commandExecutor.handleNoSync(future, () -> releaseAsync(permits));
-        });
+        }, false);
     }
 
     private RFuture<Boolean> tryAcquireAsync0(int permits) {

File: redisson/src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -33,14 +33,11 @@
 import org.redisson.client.protocol.convertor.NumberConvertor;
 import org.redisson.client.protocol.decoder.*;
 import org.redisson.command.CommandAsyncExecutor;
-import org.redisson.command.CommandBatchService;
 import org.redisson.connection.decoder.MapGetAllDecoder;
 import org.redisson.iterator.RedissonMapIterator;
 import org.redisson.iterator.RedissonMapKeyIterator;
 import org.redisson.mapreduce.RedissonMapReduce;
 import org.redisson.misc.CompletableFutureWrapper;
-import org.redisson.reactive.CommandReactiveBatchService;
-import org.redisson.rx.CommandRxBatchService;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: redisson/src/main/java/org/redisson/command/CommandBatchService.java
Patch:
@@ -50,7 +50,7 @@
  * @author Nikita Koksharov
  *
  */
-public class CommandBatchService extends CommandAsyncService {
+public class CommandBatchService extends CommandAsyncService implements BatchService {
 
     public static class ConnectionEntry {
 

File: redisson/src/main/java/org/redisson/reactive/CommandReactiveBatchService.java
Patch:
@@ -20,6 +20,7 @@
 import org.redisson.api.RFuture;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.protocol.RedisCommand;
+import org.redisson.command.BatchService;
 import org.redisson.command.CommandBatchService;
 import org.redisson.connection.ConnectionManager;
 import org.redisson.connection.NodeSource;
@@ -36,7 +37,7 @@
  * @author Nikita Koksharov
  *
  */
-public class CommandReactiveBatchService extends CommandReactiveService {
+public class CommandReactiveBatchService extends CommandReactiveService implements BatchService {
 
     private final CommandBatchService batchService;
 

File: redisson/src/main/java/org/redisson/rx/CommandRxBatchService.java
Patch:
@@ -21,6 +21,7 @@
 import org.redisson.api.RFuture;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.protocol.RedisCommand;
+import org.redisson.command.BatchService;
 import org.redisson.command.CommandAsyncExecutor;
 import org.redisson.command.CommandBatchService;
 import org.redisson.connection.ConnectionManager;
@@ -37,7 +38,7 @@
  * @author Nikita Koksharov
  *
  */
-public class CommandRxBatchService extends CommandRxService {
+public class CommandRxBatchService extends CommandRxService implements BatchService {
 
     private final CommandBatchService batchService;
 

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -583,7 +583,9 @@ protected void checkAttemptPromise(CompletableFuture<R> attemptFuture, Completab
             }
 
             if (cause instanceof RedisRetryException
-                    || cause instanceof RedisReadonlyException) {
+                    || cause instanceof RedisReadonlyException
+                        || (cause instanceof RedisReconnectedException
+                                && (writeFuture.cancel(false) || isResendAllowed(attempt, attempts)))) {
                 if (attempt < attempts) {
                     onException();
                     connectionManager.getServiceManager().newTimeout(timeout -> {

File: redisson/src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -258,14 +258,14 @@ public RFuture<V> computeAsync(K key, BiFunction<? super K, ? super V, ? extends
                 return oldValueFuture.thenCompose(oldValue -> {
                     return CompletableFuture.supplyAsync(() -> remappingFunction.apply(key, oldValue), getServiceManager().getExecutor())
                             .thenCompose(newValue -> {
-                                if (newValue != null) {
+                                if (newValue == null) {
                                     if (oldValue != null) {
-                                        return fastPutAsync(key, newValue)
+                                        return fastRemoveAsync(key)
                                                 .thenApply(rr -> newValue);
                                     }
                                     return CompletableFuture.completedFuture(newValue);
                                 }
-                                return fastRemoveAsync(key)
+                                return fastPutAsync(key, newValue)
                                         .thenApply(rr -> newValue);
                             });
                 }).whenComplete((c, e) -> {

File: redisson/src/test/java/org/redisson/RedissonBinaryStreamTest.java
Patch:
@@ -95,6 +95,9 @@ public void testChannelTruncate() throws IOException {
         b.get(bb);
         assertThat(c.size()).isEqualTo(3);
         assertThat(bb).isEqualTo(new byte[]{1, 2, 3});
+        
+        c.truncate(0);
+        assertThat(c.size()).isEqualTo(0);
     }
 
     @Test

File: redisson/src/test/java/org/redisson/RedissonBinaryStreamTest.java
Patch:
@@ -95,6 +95,9 @@ public void testChannelTruncate() throws IOException {
         b.get(bb);
         assertThat(c.size()).isEqualTo(3);
         assertThat(bb).isEqualTo(new byte[]{1, 2, 3});
+        
+        c.truncate(0);
+        assertThat(c.size()).isEqualTo(0);
     }
 
     @Test

File: redisson/src/main/java/org/redisson/BaseRedissonList.java
Patch:
@@ -139,7 +139,7 @@ public RFuture<Boolean> containsAllAsync(Collection<?> c) {
         return commandExecutor.evalReadAsync(getRawName(), codec, RedisCommands.EVAL_BOOLEAN,
                 "local items = redis.call('lrange', KEYS[1], 0, -1) " +
                 "for i=1, #items do " +
-                    "for j = 1, #ARGV, 1 do " +
+                    "for j = #ARGV, 1, -1 do " +
                         "if items[i] == ARGV[j] then " +
                             "table.remove(ARGV, j) " +
                         "end " +

File: redisson/src/main/java/org/redisson/RedissonDelayedQueue.java
Patch:
@@ -320,7 +320,7 @@ public RFuture<Boolean> containsAllAsync(Collection<?> c) {
                     + "local v = redis.call('lindex', KEYS[1], i);"
                     + "local randomId, value = struct.unpack('Bc0Lc0', v);"
                     
-                    + "for j = 1, #ARGV, 1 do "
+                    + "for j = #ARGV, 1, -1 do "
                         + "if value == ARGV[j] then "
                           + "table.remove(ARGV, j) "
                         + "end; "

File: redisson/src/main/java/org/redisson/RedissonListMultimapValues.java
Patch:
@@ -232,7 +232,7 @@ public RFuture<Boolean> containsAllAsync(Collection<?> c) {
               + "end; " +
                 "local items = redis.call('lrange', KEYS[2], 0, -1);" +
                         "for i = 1, #items, 1 do " +
-                            "for j = 2, #ARGV, 1 do "
+                            "for j = #ARGV, 3, -1 do "
                             + "if ARGV[j] == items[i] "
                             + "then table.remove(ARGV, j) end "
                         + "end; "
@@ -285,7 +285,7 @@ public RFuture<Boolean> removeAllAsync(Collection<?> c) {
                       + "end; " +
                 
                         "local v = 0 " +
-                        "for i = 2, #ARGV, 1 do "
+                        "for i = 3, #ARGV, 1 do "
                             + "if redis.call('lrem', KEYS[2], 0, ARGV[i]) == 1 "
                             + "then v = 1 end "
                         +"end "
@@ -326,7 +326,7 @@ public RFuture<Boolean> retainAllAsync(Collection<?> c) {
                        + "while i <= #s do "
                             + "local element = s[i]; "
                             + "local isInAgrs = false; "
-                            + "for j = 2, #ARGV, 1 do "
+                            + "for j = 3, #ARGV, 1 do "
                                 + "if ARGV[j] == element then "
                                     + "isInAgrs = true; "
                                     + "break; "

File: redisson/src/main/java/org/redisson/RedissonSetMultimapValues.java
Patch:
@@ -454,7 +454,7 @@ public RFuture<Boolean> containsAllAsync(Collection<?> c) {
               + "end; " +
                 "local s = redis.call('smembers', KEYS[2]);" +
                         "for i = 1, #s, 1 do " +
-                            "for j = 2, #ARGV, 1 do "
+                            "for j = #ARGV, 3, -1 do "
                             + "if ARGV[j] == s[i] "
                             + "then table.remove(ARGV, j) end "
                         + "end; "
@@ -536,7 +536,7 @@ public RFuture<Boolean> retainAllAsync(Collection<?> c) {
                        + "while i <= #s do "
                             + "local element = s[i] "
                             + "local isInAgrs = false "
-                            + "for j = 2, #ARGV, 1 do "
+                            + "for j = 3, #ARGV, 1 do "
                                 + "if ARGV[j] == element then "
                                     + "isInAgrs = true "
                                     + "break "
@@ -570,7 +570,7 @@ public RFuture<Boolean> removeAllAsync(Collection<?> c) {
                       + "end; " +
                 
                         "local v = 0 " +
-                        "for i = 2, #ARGV, 1 do "
+                        "for i = 3, #ARGV, 1 do "
                             + "if redis.call('srem', KEYS[2], ARGV[i]) == 1 "
                             + "then v = 1 end "
                         +"end "

File: redisson/src/main/java/org/redisson/api/RandomIdGenerator.java
Patch:
@@ -28,12 +28,12 @@
  */
 public class RandomIdGenerator implements IdGenerator {
 
-    private static final Random random = RandomXoshiro256PlusPlus.create();
+    private static final Random RANDOM = RandomXoshiro256PlusPlus.create();
 
     @Override
     public String generateId() {
         byte[] id = new byte[16];
-        random.nextBytes(id);
+        RANDOM.nextBytes(id);
         return ByteBufUtil.hexDump(id);
     }
 

File: redisson/src/main/java/org/redisson/api/search/aggregate/AggregationOptions.java
Patch:
@@ -68,7 +68,7 @@ public AggregationOptions timeout(Long timeout) {
     }
 
     public AggregationOptions loadAll() {
-        this.loadAll = loadAll;
+        this.loadAll = true;
         return this;
     }
 

File: redisson/src/test/java/org/redisson/RedissonListMultimapCacheTest.java
Patch:
@@ -44,7 +44,7 @@ public void testContainsAll() {
         multimap.put("1", "3");
         multimap.put("1", "3");
 
-        assertThat(multimap.get("1").containsAll(List.of("1", "2"))).isTrue();
+        assertThat(multimap.get("1").containsAll(List.of("1", "1", "1"))).isTrue();
         assertThat(multimap.get("1").containsAll(List.of("1", "2", "4"))).isFalse();
         assertThat(multimap.get("1").containsAll(List.of("1", "2", "1"))).isTrue();
         assertThat(multimap.get("1").containsAll(List.of("1", "1"))).isTrue();

File: redisson/src/test/java/org/redisson/RedissonSetMultimapCacheTest.java
Patch:
@@ -42,7 +42,7 @@ public void testContainsAll() {
         multimap.put("1", "3");
         multimap.put("1", "3");
 
-        assertThat(multimap.get("1").containsAll(List.of("1", "2"))).isTrue();
+        assertThat(multimap.get("1").containsAll(List.of("1", "1", "1"))).isTrue();
         assertThat(multimap.get("1").containsAll(List.of("1", "2", "4"))).isFalse();
         assertThat(multimap.get("1").containsAll(List.of("1", "2", "1"))).isTrue();
         assertThat(multimap.get("1").containsAll(List.of("1", "1"))).isTrue();

File: redisson/src/main/java/org/redisson/BaseRedissonList.java
Patch:
@@ -139,7 +139,7 @@ public RFuture<Boolean> containsAllAsync(Collection<?> c) {
         return commandExecutor.evalReadAsync(getRawName(), codec, RedisCommands.EVAL_BOOLEAN,
                 "local items = redis.call('lrange', KEYS[1], 0, -1) " +
                 "for i=1, #items do " +
-                    "for j = 1, #ARGV, 1 do " +
+                    "for j = #ARGV, 1, -1 do " +
                         "if items[i] == ARGV[j] then " +
                             "table.remove(ARGV, j) " +
                         "end " +

File: redisson/src/main/java/org/redisson/RedissonDelayedQueue.java
Patch:
@@ -320,7 +320,7 @@ public RFuture<Boolean> containsAllAsync(Collection<?> c) {
                     + "local v = redis.call('lindex', KEYS[1], i);"
                     + "local randomId, value = struct.unpack('Bc0Lc0', v);"
                     
-                    + "for j = 1, #ARGV, 1 do "
+                    + "for j = #ARGV, 1, -1 do "
                         + "if value == ARGV[j] then "
                           + "table.remove(ARGV, j) "
                         + "end; "

File: redisson/src/main/java/org/redisson/RedissonListMultimapValues.java
Patch:
@@ -232,7 +232,7 @@ public RFuture<Boolean> containsAllAsync(Collection<?> c) {
               + "end; " +
                 "local items = redis.call('lrange', KEYS[2], 0, -1);" +
                         "for i = 1, #items, 1 do " +
-                            "for j = 2, #ARGV, 1 do "
+                            "for j = #ARGV, 3, -1 do "
                             + "if ARGV[j] == items[i] "
                             + "then table.remove(ARGV, j) end "
                         + "end; "
@@ -285,7 +285,7 @@ public RFuture<Boolean> removeAllAsync(Collection<?> c) {
                       + "end; " +
                 
                         "local v = 0 " +
-                        "for i = 2, #ARGV, 1 do "
+                        "for i = 3, #ARGV, 1 do "
                             + "if redis.call('lrem', KEYS[2], 0, ARGV[i]) == 1 "
                             + "then v = 1 end "
                         +"end "
@@ -326,7 +326,7 @@ public RFuture<Boolean> retainAllAsync(Collection<?> c) {
                        + "while i <= #s do "
                             + "local element = s[i]; "
                             + "local isInAgrs = false; "
-                            + "for j = 2, #ARGV, 1 do "
+                            + "for j = 3, #ARGV, 1 do "
                                 + "if ARGV[j] == element then "
                                     + "isInAgrs = true; "
                                     + "break; "

File: redisson/src/main/java/org/redisson/RedissonSetMultimapValues.java
Patch:
@@ -454,7 +454,7 @@ public RFuture<Boolean> containsAllAsync(Collection<?> c) {
               + "end; " +
                 "local s = redis.call('smembers', KEYS[2]);" +
                         "for i = 1, #s, 1 do " +
-                            "for j = 2, #ARGV, 1 do "
+                            "for j = #ARGV, 3, -1 do "
                             + "if ARGV[j] == s[i] "
                             + "then table.remove(ARGV, j) end "
                         + "end; "
@@ -536,7 +536,7 @@ public RFuture<Boolean> retainAllAsync(Collection<?> c) {
                        + "while i <= #s do "
                             + "local element = s[i] "
                             + "local isInAgrs = false "
-                            + "for j = 2, #ARGV, 1 do "
+                            + "for j = 3, #ARGV, 1 do "
                                 + "if ARGV[j] == element then "
                                     + "isInAgrs = true "
                                     + "break "
@@ -570,7 +570,7 @@ public RFuture<Boolean> removeAllAsync(Collection<?> c) {
                       + "end; " +
                 
                         "local v = 0 " +
-                        "for i = 2, #ARGV, 1 do "
+                        "for i = 3, #ARGV, 1 do "
                             + "if redis.call('srem', KEYS[2], ARGV[i]) == 1 "
                             + "then v = 1 end "
                         +"end "

File: redisson-micronaut/redisson-micronaut-40/src/main/java/org/redisson/micronaut/cache/RedissonSyncCache.java
Patch:
@@ -37,15 +37,15 @@ public class RedissonSyncCache extends AbstractMapBasedSyncCache<RMap<Object, Ob
 
     private final ConversionService conversionService;
     private final ExecutorService executorService;
-    private final RedissonCacheConfiguration configuration;
+    private final BaseCacheConfiguration configuration;
     private final RMapCache<Object, Object> mapCache;
     private final RMap<Object, Object> map;
 
     public RedissonSyncCache(ConversionService conversionService,
                              RMapCache<Object, Object> mapCache,
                              RMap<Object, Object> map,
                              ExecutorService executorService,
-                             RedissonCacheConfiguration configuration) {
+                             BaseCacheConfiguration configuration) {
         super(conversionService, map);
         this.executorService = executorService;
         this.configuration = configuration;

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -118,9 +118,6 @@ public void execute() {
 
         if (getClass() == RedisExecutor.class) {
             connectionManager.getServiceManager().addFuture(mainPromise);
-            mainPromise.whenComplete((r, e) -> {
-                connectionManager.getServiceManager().removeFuture(mainPromise);
-            });
         }
 
         if (connectionManager.getServiceManager().isShuttingDown()) {

File: redisson/src/main/java/org/redisson/misc/AsyncSemaphore.java
Patch:
@@ -62,7 +62,7 @@ public CompletableFuture<Void> acquire() {
     private void tryForkAndRun() {
         if (executorService != null) {
             int val = tasksLatch.get();
-            if (stackSize.get() > 100 * val
+            if (stackSize.get() > 25 * val
                     && tasksLatch.compareAndSet(val, val+1)) {
                 executorService.submit(() -> {
                     tasksLatch.decrementAndGet();

File: redisson/src/main/java/org/redisson/connection/TrackedConnectionsHolder.java
Patch:
@@ -42,7 +42,7 @@ public class TrackedConnectionsHolder extends ConnectionsHolder<RedisConnection>
     private final AtomicInteger usage = new AtomicInteger();
 
     public TrackedConnectionsHolder(ConnectionsHolder<RedisConnection> holder) {
-        super(null, 0, null, null, false);
+        super(null, 0, null, holder.getServiceManager(), false);
         this.holder = holder;
     }
 

File: redisson/src/main/java/org/redisson/client/RedisConnection.java
Patch:
@@ -249,7 +249,7 @@ public <T, R> RFuture<R> async(long timeout, Codec encoder, RedisCommand<T> comm
         }
 
         Timeout scheduledFuture = redisClient.getTimer().newTimeout(t -> {
-            RedisTimeoutException ex = new RedisTimeoutException("Command execution timeout for command: "
+            RedisTimeoutException ex = new RedisTimeoutException("Command execution timeout for "
                     + LogHelper.toString(command, params) + ", Redis client: " + redisClient);
             promise.completeExceptionally(ex);
         }, timeout, TimeUnit.MILLISECONDS);

File: redisson/src/main/java/org/redisson/client/protocol/CommandData.java
Patch:
@@ -93,8 +93,7 @@ public Codec getCodec() {
 
     @Override
     public String toString() {
-        return "CommandData [promise=" + promise + ", command=" + command + ", params="
-                + LogHelper.toString(params) + ", codec=" + codec + "]";
+        return "CommandData [command=" + LogHelper.toString(this) + ", codec=" + codec + "]";
     }
 
     @Override

File: redisson/src/main/java/org/redisson/command/RedisQueuedBatchExecutor.java
Patch:
@@ -169,8 +169,8 @@ protected void sendCommand(CompletableFuture<R> attemptPromise, RedisConnection
             writeFuture = connection.send(new CommandsData(main, list, true, syncSlaves));
         } else {
             if (log.isDebugEnabled()) {
-                log.debug("acquired connection for command {} and params {} from slot {} using node {}... {}",
-                        command, LogHelper.toString(params), source, connection.getRedisClient().getAddr(), connection);
+                log.debug("acquired connection for {} from slot: {} using node: {}... {}",
+                            LogHelper.toString(command, params), source, connection.getRedisClient().getAddr(), connection);
             }
             
             if (connectionEntry.isFirstCommand()) {

File: redisson/src/main/java/org/redisson/misc/LogHelper.java
Patch:
@@ -37,9 +37,9 @@ private LogHelper() {
     
     public static String toString(RedisCommand<?> command, Object... params) {
         if (RedisCommands.AUTH.equals(command)) {
-            return command + ", params: (password masked)";
+            return "command: " + command + ", params: (password masked)";
         }
-        return command + ", params: " + LogHelper.toString(params);
+        return "command: " + command + ", params: " + LogHelper.toString(params);
     }
     
     public static String toString(Object object) {
@@ -56,7 +56,7 @@ public static String toString(Object object) {
             if (RedisCommands.AUTH.equals(cd.getCommand())) {
                 return cd.getCommand() + ", params: (password masked)";
             }
-            return cd.getCommand() + ", promise: " + cd.getPromise() + ", params: " + LogHelper.toString(cd.getParams());
+            return cd.getCommand() + ", params: " + LogHelper.toString(cd.getParams()) + ", promise: " + cd.getPromise();
         } else if (object instanceof ByteBuf) {
             final ByteBuf byteBuf = (ByteBuf) object;
             // can't be used due to Buffer Leak error is appeared in log

File: redisson/src/main/java/org/redisson/api/search/index/IndexInfo.java
Patch:
@@ -66,7 +66,7 @@ public class IndexInfo {
     private Double bytesPerRecordAverage;
 
     private Double offsetsPerTermAverage;
-    private Long offsetBitsPerRecordAverage;
+    private Double offsetBitsPerRecordAverage;
 
     private Long hashIndexingFailures;
 
@@ -267,11 +267,11 @@ public IndexInfo setOffsetsPerTermAverage(Double offsetsPerTermAverage) {
         return this;
     }
 
-    public Long getOffsetBitsPerRecordAverage() {
+    public Double getOffsetBitsPerRecordAverage() {
         return offsetBitsPerRecordAverage;
     }
 
-    public IndexInfo setOffsetBitsPerRecordAverage(Long offsetBitsPerRecordAverage) {
+    public IndexInfo setOffsetBitsPerRecordAverage(Double offsetBitsPerRecordAverage) {
         this.offsetBitsPerRecordAverage = offsetBitsPerRecordAverage;
         return this;
     }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/IndexInfoDecoder.java
Patch:
@@ -60,11 +60,11 @@ public Object decode(List<Object> parts, State state) {
             ii.setRecordsPerDocAverage(toDouble(result, "records_per_doc_avg"));
             ii.setBytesPerRecordAverage(toDouble(result, "bytes_per_record_avg"));
             ii.setOffsetsPerTermAverage(toDouble(result, "offsets_per_term_avg"));
-            ii.setOffsetBitsPerRecordAverage(toLong(result, "offset_bits_per_record_avg"));
+            ii.setOffsetBitsPerRecordAverage(toDouble(result, "offset_bits_per_record_avg"));
             ii.setHashIndexingFailures(toLong(result, "hash_indexing_failures"));
-            ii.setTotalIndexingTime(Double.valueOf(result.get("total_indexing_time").toString()));
+            ii.setTotalIndexingTime(toDouble(result, "total_indexing_time"));
             ii.setIndexing(toLong(result, "indexing"));
-            ii.setPercentIndexed(Double.valueOf(result.get("percent_indexed").toString()));
+            ii.setPercentIndexed(toDouble(result, "percent_indexed"));
             ii.setNumberOfUses(toLong(result, "number_of_uses"));
             ii.setGcStats((Map<String, Object>) result.get("gc_stats"));
             ii.setCursorStats((Map<String, Object>) result.get("cursor_stats"));

File: redisson/src/main/java/org/redisson/api/search/index/IndexInfo.java
Patch:
@@ -66,7 +66,7 @@ public class IndexInfo {
     private Double bytesPerRecordAverage;
 
     private Double offsetsPerTermAverage;
-    private Long offsetBitsPerRecordAverage;
+    private Double offsetBitsPerRecordAverage;
 
     private Long hashIndexingFailures;
 
@@ -267,11 +267,11 @@ public IndexInfo setOffsetsPerTermAverage(Double offsetsPerTermAverage) {
         return this;
     }
 
-    public Long getOffsetBitsPerRecordAverage() {
+    public Double getOffsetBitsPerRecordAverage() {
         return offsetBitsPerRecordAverage;
     }
 
-    public IndexInfo setOffsetBitsPerRecordAverage(Long offsetBitsPerRecordAverage) {
+    public IndexInfo setOffsetBitsPerRecordAverage(Double offsetBitsPerRecordAverage) {
         this.offsetBitsPerRecordAverage = offsetBitsPerRecordAverage;
         return this;
     }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/IndexInfoDecoder.java
Patch:
@@ -60,11 +60,11 @@ public Object decode(List<Object> parts, State state) {
             ii.setRecordsPerDocAverage(toDouble(result, "records_per_doc_avg"));
             ii.setBytesPerRecordAverage(toDouble(result, "bytes_per_record_avg"));
             ii.setOffsetsPerTermAverage(toDouble(result, "offsets_per_term_avg"));
-            ii.setOffsetBitsPerRecordAverage(toLong(result, "offset_bits_per_record_avg"));
+            ii.setOffsetBitsPerRecordAverage(toDouble(result, "offset_bits_per_record_avg"));
             ii.setHashIndexingFailures(toLong(result, "hash_indexing_failures"));
-            ii.setTotalIndexingTime(Double.valueOf(result.get("total_indexing_time").toString()));
+            ii.setTotalIndexingTime(toDouble(result, "total_indexing_time"));
             ii.setIndexing(toLong(result, "indexing"));
-            ii.setPercentIndexed(Double.valueOf(result.get("percent_indexed").toString()));
+            ii.setPercentIndexed(toDouble(result, "percent_indexed"));
             ii.setNumberOfUses(toLong(result, "number_of_uses"));
             ii.setGcStats((Map<String, Object>) result.get("gc_stats"));
             ii.setCursorStats((Map<String, Object>) result.get("cursor_stats"));

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -36,6 +36,7 @@
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.AtomicReferenceArray;
+import java.util.function.BinaryOperator;
 import java.util.function.Function;
 import java.util.stream.Collectors;
 
@@ -983,7 +984,8 @@ public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {
     }
 
     private Collection<ClusterPartition> getLastPartitions() {
-        return new HashSet<>(lastUri2Partition.values());
+        return lastUri2Partition.values().stream().collect(Collectors.toMap(e -> e.getNodeId(), Function.identity(),
+                                                                BinaryOperator.maxBy(Comparator.comparing(e -> e.getTime())))).values();
     }
 
     public int getSlot(MasterSlaveEntry entry) {

File: redisson/src/main/java/org/redisson/RedissonFairLock.java
Patch:
@@ -205,10 +205,12 @@ <T> RFuture<T> tryLockInnerAsync(long waitTime, long leaseTime, TimeUnit unit, l
                     // check if the thread is already in the queue
                     "local timeout = redis.call('zscore', KEYS[3], ARGV[2]);" +
                     "if timeout ~= false then " +
+                            "local ttl = redis.call('pttl', KEYS[1]);" +
+                            "return math.max(0, ttl); " +
                         // the real timeout is the timeout of the prior thread
                         // in the queue, but this is approximately correct, and
                         // avoids having to traverse the queue
-                        "return timeout - tonumber(ARGV[3]) - tonumber(ARGV[4]);" +
+//                        "return timeout - tonumber(ARGV[3]) - tonumber(ARGV[4]);" +
                     "end;" +
 
                     // add the thread to the queue at the end, and set its timeout in the timeout set to the timeout of

File: redisson/src/main/java/org/redisson/connection/DNSMonitor.java
Patch:
@@ -33,7 +33,6 @@
 import java.util.*;
 import java.util.Map.Entry;
 import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.TimeUnit;
 
 /**

File: redisson/src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -597,6 +597,9 @@ public RFuture<Boolean> containsValueAsync(Object value) {
 
     @Override
     public Map<K, V> getAll(Set<K> keys) {
+        if (keys.getClass().getPackage().getName().startsWith("org.redisson")) {
+            keys = new HashSet<>(keys);
+        }
         return get(getAllAsync(keys));
     }
 

File: redisson/src/main/java/org/redisson/RedissonBaseLock.java
Patch:
@@ -165,11 +165,11 @@ public void run(Timeout timeout) throws Exception {
     
     protected void scheduleExpirationRenewal(long threadId) {
         ExpirationEntry entry = new ExpirationEntry();
+        entry.addThreadId(threadId);
         ExpirationEntry oldEntry = EXPIRATION_RENEWAL_MAP.putIfAbsent(getEntryName(), entry);
         if (oldEntry != null) {
             oldEntry.addThreadId(threadId);
         } else {
-            entry.addThreadId(threadId);
             try {
                 renewExpiration();
             } finally {

File: redisson/src/main/java/org/redisson/RedissonBaseLock.java
Patch:
@@ -165,11 +165,11 @@ public void run(Timeout timeout) throws Exception {
     
     protected void scheduleExpirationRenewal(long threadId) {
         ExpirationEntry entry = new ExpirationEntry();
+        entry.addThreadId(threadId);
         ExpirationEntry oldEntry = EXPIRATION_RENEWAL_MAP.putIfAbsent(getEntryName(), entry);
         if (oldEntry != null) {
             oldEntry.addThreadId(threadId);
         } else {
-            entry.addThreadId(threadId);
             try {
                 renewExpiration();
             } finally {

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -965,7 +965,7 @@ public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {
     }
 
     private Collection<ClusterPartition> getLastPartitions() {
-        return lastUri2Partition.values();
+        return new HashSet<>(lastUri2Partition.values());
     }
 
     public int getSlot(MasterSlaveEntry entry) {

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -204,8 +204,7 @@ public void execute() {
                 checkAttemptPromise(attemptPromise, connectionFuture);
             }).whenComplete((r, e) -> {
                 if (e != null
-                        && !e.getMessage().contains("NOSCRIPT")
-                            && !e.getMessage().contains("ERR unknown command")) {
+                        && !attemptPromise.isCompletedExceptionally()) {
                     log.error(e.getMessage(), e);
                 }
             });

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -203,7 +203,9 @@ public void execute() {
 
                 checkAttemptPromise(attemptPromise, connectionFuture);
             }).whenComplete((r, e) -> {
-                if (e != null) {
+                if (e != null
+                        && !e.getMessage().contains("NOSCRIPT")
+                            && !e.getMessage().contains("ERR unknown command")) {
                     log.error(e.getMessage(), e);
                 }
             });

File: redisson/src/main/java/org/redisson/connection/SequentialDnsAddressResolverFactory.java
Patch:
@@ -86,7 +86,7 @@ private void execute(Callable<?> callable, Promise<?> promise) {
     private final AsyncSemaphore asyncSemaphore;
 
     public SequentialDnsAddressResolverFactory() {
-        this(6);
+        this(2);
     }
 
     /**

File: redisson/src/main/java/org/redisson/command/RedisQueuedBatchExecutor.java
Patch:
@@ -99,7 +99,7 @@ protected void releaseConnection(CompletableFuture<R> attemptPromise, Completabl
         if (RedisCommands.EXEC.getName().equals(command.getName())
                 || RedisCommands.DISCARD.getName().equals(command.getName())) {
             if (attempt < attempts
-                    && attemptPromise.isCompletedExceptionally()) {
+                    && attemptPromise.isCancelled()) {
                 return;
             }
 

File: redisson/src/main/java/org/redisson/api/RKeys.java
Patch:
@@ -378,6 +378,7 @@ public interface RKeys extends RKeysAsync {
      * @see org.redisson.api.listener.TrackingListener
      * @see org.redisson.api.listener.SetObjectListener
      * @see org.redisson.api.listener.NewObjectListener
+     * @see org.redisson.api.listener.FlushListener
      * @see org.redisson.api.ExpiredObjectListener
      * @see org.redisson.api.DeletedObjectListener
      *

File: redisson/src/main/java/org/redisson/api/RKeysAsync.java
Patch:
@@ -256,6 +256,7 @@ public interface RKeysAsync {
      * @see org.redisson.api.listener.TrackingListener
      * @see org.redisson.api.listener.SetObjectListener
      * @see org.redisson.api.listener.NewObjectListener
+     * @see org.redisson.api.listener.FlushListener
      * @see org.redisson.api.ExpiredObjectListener
      * @see org.redisson.api.DeletedObjectListener
      *

File: redisson/src/main/java/org/redisson/api/RKeysReactive.java
Patch:
@@ -311,6 +311,7 @@ public interface RKeysReactive {
      * @see org.redisson.api.listener.TrackingListener
      * @see org.redisson.api.listener.SetObjectListener
      * @see org.redisson.api.listener.NewObjectListener
+     * @see org.redisson.api.listener.FlushListener
      * @see org.redisson.api.ExpiredObjectListener
      * @see org.redisson.api.DeletedObjectListener
      *

File: redisson/src/main/java/org/redisson/api/RKeysRx.java
Patch:
@@ -314,6 +314,7 @@ public interface RKeysRx {
      * @see org.redisson.api.listener.TrackingListener
      * @see org.redisson.api.listener.SetObjectListener
      * @see org.redisson.api.listener.NewObjectListener
+     * @see org.redisson.api.listener.FlushListener
      * @see org.redisson.api.ExpiredObjectListener
      * @see org.redisson.api.DeletedObjectListener
      *

File: redisson/src/main/java/org/redisson/RedissonSet.java
Patch:
@@ -245,7 +245,7 @@ public V random() {
 
     @Override
     public RFuture<V> randomAsync() {
-        return commandExecutor.writeAsync(getRawName(), codec, RedisCommands.SRANDMEMBER_SINGLE, getRawName());
+        return commandExecutor.readAsync(getRawName(), codec, RedisCommands.SRANDMEMBER_SINGLE, getRawName());
     }
 
     @Override
@@ -255,7 +255,7 @@ public Set<V> random(int count) {
 
     @Override
     public RFuture<Set<V>> randomAsync(int count) {
-        return commandExecutor.writeAsync(getRawName(), codec, RedisCommands.SRANDMEMBER, getRawName(), count);
+        return commandExecutor.readAsync(getRawName(), codec, RedisCommands.SRANDMEMBER, getRawName(), count);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonSetMultimapValues.java
Patch:
@@ -387,7 +387,7 @@ public V random() {
 
     @Override
     public RFuture<V> randomAsync() {
-        return commandExecutor.writeAsync(getRawName(), codec, RedisCommands.SRANDMEMBER_SINGLE, getRawName());
+        return commandExecutor.readAsync(getRawName(), codec, RedisCommands.SRANDMEMBER_SINGLE, getRawName());
     }
 
     @Override
@@ -397,7 +397,7 @@ public Set<V> random(int count) {
 
     @Override
     public RFuture<Set<V>> randomAsync(int count) {
-        return commandExecutor.writeAsync(getRawName(), codec, RedisCommands.SRANDMEMBER, getRawName(), count);
+        return commandExecutor.readAsync(getRawName(), codec, RedisCommands.SRANDMEMBER, getRawName(), count);
     }
     
     @Override

File: redisson/src/test/java/org/redisson/RedissonBatchTest.java
Patch:
@@ -604,7 +604,7 @@ public void testBatchPing(BatchOptions batchOptions) throws InterruptedException
 
     @ParameterizedTest
     @MethodSource("data")
-    @Timeout(1)
+    @Timeout(3)
     public void testShutdownTimeout(BatchOptions batchOptions) {
         RedissonClient redisson = createInstance();
 

File: redisson/src/test/java/org/redisson/RedissonBatchTest.java
Patch:
@@ -429,7 +429,7 @@ public void testWriteTimeout(BatchOptions batchOptions) {
         batch.execute();
         long executionTime = System.currentTimeMillis() - s;
         if (batchOptions.getExecutionMode() == ExecutionMode.IN_MEMORY) {
-            assertThat(executionTime).isLessThan(1000);
+            assertThat(executionTime).isLessThan(1200);
         } else {
             assertThat(executionTime).isLessThan(300);
         }

File: redisson/src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -784,10 +784,11 @@ public void testSingleConnectionFail() {
 
     @Test
     public void testClusterConnectionFail() {
-        Awaitility.await().atLeast(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(5)).untilAsserted(() -> {
+            Awaitility.await().atLeast(Duration.ofSeconds(3)).atMost(Duration.ofSeconds(7)).untilAsserted(() -> {
             Assertions.assertThrows(RedisConnectionException.class, () -> {
                 Config config = new Config();
-                config.useClusterServers().addNodeAddress("redis://127.99.0.1:1111");
+                config.useClusterServers()
+                        .addNodeAddress("redis://127.99.0.1:1111");
                 Redisson.create(config);
             });
         });

File: redisson/src/test/java/org/redisson/RedissonTopicTest.java
Patch:
@@ -1259,7 +1259,7 @@ public void onMessage(CharSequence channel, Integer msg) {
                 stop(slave);
             }
 
-            await().atMost(25, TimeUnit.SECONDS).until(() -> subscriptions.get() == 2);
+            await().atMost(30, TimeUnit.SECONDS).until(() -> subscriptions.get() == 2);
 
             executed.set(false);
             redisson.getTopic("topic").publish(1);

File: redisson/src/main/java/org/redisson/RedissonObject.java
Patch:
@@ -523,12 +523,11 @@ protected final void removeTrackingListener(int listenerId) {
 
     protected final RFuture<Void> removeTrackingListenerAsync(int listenerId) {
         PublishSubscribeService subscribeService = commandExecutor.getConnectionManager().getSubscribeService();
-        ChannelName cn = new ChannelName("__redis__:invalidate");
-        if (!subscribeService.hasEntry(cn)) {
+        if (!subscribeService.hasEntry(ChannelName.TRACKING)) {
             return new CompletableFutureWrapper<>((Void) null);
         }
 
-        CompletableFuture<Void> f = subscribeService.removeListenerAsync(PubSubType.UNSUBSCRIBE, new ChannelName("__redis__:invalidate"), listenerId);
+        CompletableFuture<Void> f = subscribeService.removeListenerAsync(PubSubType.UNSUBSCRIBE, ChannelName.TRACKING, listenerId);
         f = f.whenComplete((r, e) -> {
             if (!commandExecutor.isTrackChanges()) {
                 commandExecutor = commandExecutor.copy(false);

File: redisson/src/main/java/org/redisson/client/handler/CommandPubSubDecoder.java
Patch:
@@ -243,7 +243,7 @@ protected MultiDecoder<Object> messageDecoder(CommandData<Object, Object> data,
 
         if ("invalidate".equals(parts.get(0))) {
             parts.set(0, "message");
-            parts.add(1, "__redis__:invalidate".getBytes());
+            parts.add(1, ChannelName.TRACKING.getName());
         }
 
         String command = parts.get(0).toString();

File: redisson/src/test/java/org/redisson/RedissonTopicPatternTest.java
Patch:
@@ -349,7 +349,7 @@ public void onPSubscribe(String channel) {
         t.removeAllListeners();
     }
 
-//    @Test
+    @Test
     public void testReattachInClusterSlave() {
         testReattachInCluster(SubscriptionMode.SLAVE);
     }

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -170,8 +170,6 @@ public void doConnect(Function<RedisURI, String> hostnameMapper) {
                 } catch (Exception e) {
                     // skip
                 }
-
-                break;
             } catch (RedisConnectionException e) {
                 internalShutdown();
                 throw e;

File: redisson/src/test/java/org/redisson/RedissonReliableTopicTest.java
Patch:
@@ -123,8 +123,11 @@ public void testListenerOldMessages() throws InterruptedException {
             messages.add(m);
         });
 
+        Thread.sleep(50);
         assertThat(messages).containsOnly("1");
+
         rt.publish("2");
+
         Thread.sleep(50);
         assertThat(messages).containsOnly("1", "2");
 

File: redisson/src/test/java/org/redisson/RedissonLiveObjectServiceTest.java
Patch:
@@ -2410,7 +2410,7 @@ public void testBatchedPersist() {
         RLiveObjectService s = redisson.getLiveObjectService();
 
         List<TestREntity> objects = new ArrayList<>();
-        int objectsAmount = 1000000;
+        int objectsAmount = 800000;
         for (int i = 0; i < objectsAmount; i++) {
             TestREntity e = new TestREntity();
             e.setName("" + i);

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -280,6 +280,7 @@ protected MasterSlaveServersConfig create(BaseMasterSlaveServersConfig<?> cfg) {
         c.setPingConnectionInterval(cfg.getPingConnectionInterval());
         c.setSslEnableEndpointIdentification(cfg.isSslEnableEndpointIdentification());
         c.setSslProvider(cfg.getSslProvider());
+        c.setSslKeystoreType(cfg.getSslKeystoreType());
         c.setSslTruststore(cfg.getSslTruststore());
         c.setSslTruststorePassword(cfg.getSslTruststorePassword());
         c.setSslKeystore(cfg.getSslKeystore());
@@ -361,6 +362,7 @@ protected RedisClientConfig createRedisConfig(NodeType type, RedisURI address, i
                 .setSslHostname(sslHostname)
                 .setSslEnableEndpointIdentification(config.isSslEnableEndpointIdentification())
                 .setSslProvider(config.getSslProvider())
+                .setSslKeystoreType(config.getSslKeystoreType())
                 .setSslTruststore(config.getSslTruststore())
                 .setSslTruststorePassword(config.getSslTruststorePassword())
                 .setSslKeystore(config.getSslKeystore())

File: redisson/src/main/java/org/redisson/connection/SingleConnectionManager.java
Patch:
@@ -34,6 +34,7 @@ private static MasterSlaveServersConfig create(SingleServerConfig cfg) {
         newconfig.setPingConnectionInterval(cfg.getPingConnectionInterval());
         newconfig.setSslEnableEndpointIdentification(cfg.isSslEnableEndpointIdentification());
         newconfig.setSslProvider(cfg.getSslProvider());
+        newconfig.setSslKeystoreType(cfg.getSslKeystoreType());
         newconfig.setSslTruststore(cfg.getSslTruststore());
         newconfig.setSslTruststorePassword(cfg.getSslTruststorePassword());
         newconfig.setSslKeystore(cfg.getSslKeystore());

File: redisson/src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -567,7 +567,6 @@ public void testCredentials() {
 
         Config config = createConfig(redis);
         config.useSingleServer()
-                .setPassword("1234")
                 .setCredentialsResolver(new CredentialsResolver() {
                     @Override
                     public CompletionStage<Credentials> resolve(InetSocketAddress address) {

File: redisson/src/main/java/org/redisson/connection/ReplicatedConnectionManager.java
Patch:
@@ -247,6 +247,7 @@ private CompletableFuture<Void> slaveUp(InetSocketAddress address, RedisURI uri)
                     return;
                 }
 
+                entry.excludeMasterFromSlaves(address);
                 log.info("slave: {} added", address);
             });
         }

File: redisson/src/main/java/org/redisson/connection/ClientConnectionsEntry.java
Patch:
@@ -238,7 +238,9 @@ public <T extends RedisConnection> void returnConnection(T connection) {
         } else {
             handler = (ConnectionsHolder<T>) connection2holder.remove(connection);
         }
-        handler.releaseConnection(this, connection);
+        if (handler != null) {
+            handler.releaseConnection(this, connection);
+        }
     }
 
     @Override

File: redisson/src/main/java/org/redisson/transaction/RedissonTransaction.java
Patch:
@@ -56,7 +56,7 @@ public class RedissonTransaction implements RTransaction {
     private final TransactionOptions options;
     private List<TransactionalOperation> operations = new CopyOnWriteArrayList<>();
     private Set<String> localCaches = new HashSet<>();
-    private final Map<RLocalCachedMap<?, ?>, RLocalCachedMap<?, ?>> localCacheInstances = new HashMap<>();
+    private final Map<RLocalCachedMap<?, ?>, RLocalCachedMap<?, ?>> localCacheInstances = new IdentityHashMap<>();
     private final Map<String, Object> instances = new HashMap<>();
 
     private RedissonTransactionalBuckets bucketsInstance;

File: redisson/src/main/java/org/redisson/transaction/RedissonTransaction.java
Patch:
@@ -56,7 +56,7 @@ public class RedissonTransaction implements RTransaction {
     private final TransactionOptions options;
     private List<TransactionalOperation> operations = new CopyOnWriteArrayList<>();
     private Set<String> localCaches = new HashSet<>();
-    private final Map<RLocalCachedMap<?, ?>, RLocalCachedMap<?, ?>> localCacheInstances = new HashMap<>();
+    private final Map<String, RLocalCachedMap<?, ?>> localCacheInstances = new HashMap<>();
     private final Map<String, Object> instances = new HashMap<>();
 
     private RedissonTransactionalBuckets bucketsInstance;
@@ -89,7 +89,7 @@ public <K, V> RLocalCachedMap<K, V> getLocalCachedMap(RLocalCachedMap<K, V> from
         checkState();
 
         localCaches.add(fromInstance.getName());
-        return (RLocalCachedMap<K, V>) localCacheInstances.computeIfAbsent(fromInstance, k -> {
+        return (RLocalCachedMap<K, V>) localCacheInstances.computeIfAbsent(fromInstance.getName(), k -> {
             return new RedissonTransactionalLocalCachedMap<>(commandExecutor,
                     operations, options.getTimeout(), executed, fromInstance, id);
         });

File: redisson/src/main/java/org/redisson/Redisson.java
Patch:
@@ -416,7 +416,7 @@ public <K, V> RMap<K, V> getMap(org.redisson.api.options.MapOptions<K, V> option
             ops.writerRetryAttempts(params.getWriteRetryAttempts());
         }
 
-        return new RedissonMap<>(commandExecutor.copy(params), params.getName(),
+        return new RedissonMap<>(params.getCodec(), commandExecutor.copy(params), params.getName(),
                 this, ops, writeBehindService);
     }
 

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -274,7 +274,7 @@ protected RedisClientConfig createRedisConfig(NodeType type, RedisURI address, i
     private void scheduleSentinelDNSCheck() {
         monitorFuture = serviceManager.newTimeout(t -> {
             CompletableFuture<Void> f = performSentinelDNSCheck();
-            f.thenAccept(r -> scheduleSentinelDNSCheck());
+            f.whenComplete((r, e) -> scheduleSentinelDNSCheck());
         }, config.getDnsMonitoringInterval(), TimeUnit.MILLISECONDS);
     }
 
@@ -328,7 +328,7 @@ private void checkState(SentinelServersConfig cfg, Iterator<RedisClient> iterato
             }
             disconnectedSentinels.clear();
             CompletableFuture<Void> f = performSentinelDNSCheck();
-            f.thenAccept(r -> scheduleChangeCheck(cfg, null));
+            f.whenComplete((r, e) -> scheduleChangeCheck(cfg, null));
             return;
         }
         if (serviceManager.isShuttingDown()) {

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -2244,7 +2244,7 @@ protected RFuture<Boolean> fastPutIfExistsOperationAsync(K key, V value) {
                         + "end; "
 
                         + "return 0; ",
-                Arrays.asList(name, getTimeoutSetName(name), getIdleSetName(name), getCreatedChannelName(name),
+                Arrays.asList(name, getTimeoutSetName(name), getIdleSetName(name), getUpdatedChannelName(name),
                         getLastAccessTimeSetName(name), getRemovedChannelName(name), getOptionsName(name)),
                 System.currentTimeMillis(), encodeMapKey(key), encodeMapValue(value), publishCommand);
     }

File: redisson/src/test/java/org/redisson/RedissonBatchTest.java
Patch:
@@ -273,8 +273,7 @@ public void testSkipResult() throws InterruptedException, ExecutionException, Ti
         }
     }
 
-    @ParameterizedTest
-    @MethodSource("data")
+    @Test
     public void testConnectionLeakAfterError() throws InterruptedException {
         Config config = createConfig();
         config.useSingleServer()

File: redisson/src/main/java/org/redisson/RedissonSearch.java
Patch:
@@ -574,6 +574,7 @@ public RFuture<AggregationResult> aggregateAsync(String indexName, String query,
         for (Expression expression : options.getExpressions()) {
             args.add("APPLY");
             args.add(expression.getValue());
+            args.add("AS");
             args.add(expression.getAs());
         }
         if (options.getOffset() != null

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -661,7 +661,7 @@ public Object decode(List parts, State state) {
     RedisCommand<Map<StreamMessageId, Map<Object, Object>>> XAUTOCLAIM = new RedisCommand<>("XAUTOCLAIM",
             new ListMultiDecoder2(
                     new AutoClaimDecoder(),
-                    new ObjectMapReplayDecoder2(),
+                    new AutoClaimMapReplayDecoder(),
                     new ObjectDecoder(new StreamIdDecoder()),
                     new StreamObjectMapReplayDecoder()));
 

File: redisson/src/main/java/org/redisson/cluster/ClusterPartition.java
Patch:
@@ -18,6 +18,7 @@
 import org.redisson.misc.RedisURI;
 
 import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
 
 import static org.redisson.connection.MasterSlaveConnectionManager.MAX_SLOT;
 
@@ -35,8 +36,8 @@ public enum Type {MASTER, SLAVE}
     private final String nodeId;
     private boolean masterFail;
     private RedisURI masterAddress;
-    private final Set<RedisURI> slaveAddresses = new HashSet<>();
-    private final Set<RedisURI> failedSlaves = new HashSet<>();
+    private final Set<RedisURI> slaveAddresses = Collections.newSetFromMap(new ConcurrentHashMap<>());
+    private final Set<RedisURI> failedSlaves = Collections.newSetFromMap(new ConcurrentHashMap<>());
 
     private BitSet slots;
     private Set<ClusterSlotRange> slotRanges = Collections.emptySet();

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -243,7 +243,7 @@ private void scheduleWriteTimeout(CompletableFuture<R> attemptPromise) {
         TimerTask task = timeout -> {
             if (writeFuture.cancel(false)) {
                 exception = new RedisTimeoutException("Command still hasn't been written into connection! " +
-                        "Check CPU usage of the JVM. Check connection with Redis node: " + connectionFuture.join().getRedisClient().getAddr() +
+                        "Check CPU usage of the JVM. Check that there are no blocking invocations in async/reactive/rx listeners or subscribeOnElements method. Check connection with Redis node: " + connectionFuture.join().getRedisClient().getAddr() +
                         " for TCP packet drops. Try to increase nettyThreads setting. "
                         + " Node source: " + source + ", connection: " + connectionFuture.join()
                         + ", command: " + LogHelper.toString(command, params)
@@ -281,7 +281,7 @@ public void run(Timeout t) throws Exception {
                                 if (writeFuture != null && writeFuture.cancel(false)) {
                                     if (exception == null) {
                                         exception = new RedisTimeoutException("Command still hasn't been written into connection! " +
-                                                "Check CPU usage of the JVM. Check connection with Redis node: " + getNow(connectionFuture).getRedisClient().getAddr() +
+                                                "Check CPU usage of the JVM. Check that there are no blocking invocations in async/reactive/rx listeners or subscribeOnElements method. Check connection with Redis node: " + getNow(connectionFuture).getRedisClient().getAddr() +
                                                 " for TCP packet drops. Try to increase nettyThreads setting. "
                                                 + " Node source: " + source + ", connection: " + getNow(connectionFuture)
                                                 + ", command: " + LogHelper.toString(command, params)

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -27,7 +27,6 @@
 import org.redisson.executor.params.*;
 import org.redisson.misc.CompletableFutureWrapper;
 import org.redisson.misc.Injector;
-import org.redisson.misc.WrappedLock;
 import org.redisson.remote.ResponseEntry;
 import org.redisson.remote.ResponseEntry.Result;
 import org.slf4j.Logger;

File: redisson/src/main/java/org/redisson/connection/ServiceManager.java
Patch:
@@ -60,7 +60,6 @@
 import org.redisson.config.TransportMode;
 import org.redisson.misc.CompletableFutureWrapper;
 import org.redisson.misc.RedisURI;
-import org.redisson.misc.WrappedLock;
 import org.redisson.remote.ResponseEntry;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: redisson/src/main/java/org/redisson/remote/BaseRemoteProxy.java
Patch:
@@ -25,7 +25,6 @@
 import org.redisson.client.codec.LongCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.command.CommandAsyncExecutor;
-import org.redisson.misc.WrappedLock;
 import org.redisson.remote.ResponseEntry.Result;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;

File: redisson/src/test/java/org/redisson/RedissonRemoteServiceTest.java
Patch:
@@ -341,7 +341,7 @@ public void testFreeWorkers() throws InterruptedException, ExecutionException {
         RemoteInterfaceAsync ri = r2.getRemoteService().get(RemoteInterfaceAsync.class);
         
         RFuture<Void> f = ri.timeoutMethod();
-        Thread.sleep(100);
+        Thread.sleep(200);
         assertThat(rs.getFreeWorkers(RemoteInterface.class)).isEqualTo(0);
         f.get();
         assertThat(rs.getFreeWorkers(RemoteInterface.class)).isEqualTo(1);

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/ObjectListReplayDecoder2.java
Patch:
@@ -55,7 +55,7 @@ public List<T> decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
 }

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/ScoredSortedListReplayDecoder.java
Patch:
@@ -34,7 +34,7 @@
 public class ScoredSortedListReplayDecoder implements MultiDecoder<List<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoder.java
Patch:
@@ -35,7 +35,7 @@
 public class ScoredSortedSetReplayDecoder implements MultiDecoder<Set<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoderV2.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSetReplayDecoderV2 implements MultiDecoder<RedisZSetCommands.Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/SetReplayDecoder.java
Patch:
@@ -39,7 +39,7 @@ public SetReplayDecoder(Decoder<Object> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
     

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/ObjectListReplayDecoder2.java
Patch:
@@ -55,7 +55,7 @@ public List<T> decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
 }

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/PointDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class PointDecoder implements MultiDecoder<Point> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return DoubleCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/ScoredSortedListReplayDecoder.java
Patch:
@@ -34,11 +34,11 @@
 public class ScoredSortedListReplayDecoder implements MultiDecoder<List<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetReplayDecoder implements MultiDecoder<Set<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoderV2.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSetReplayDecoderV2 implements MultiDecoder<RedisZSetCommands.Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/SetReplayDecoder.java
Patch:
@@ -39,7 +39,7 @@ public SetReplayDecoder(Decoder<Object> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
     

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/ObjectListReplayDecoder2.java
Patch:
@@ -55,7 +55,7 @@ public List<T> decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
 }

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/PointDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class PointDecoder implements MultiDecoder<Point> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return DoubleCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/ScoredSortedListReplayDecoder.java
Patch:
@@ -34,11 +34,11 @@
 public class ScoredSortedListReplayDecoder implements MultiDecoder<List<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetReplayDecoder implements MultiDecoder<Set<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoderV2.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSetReplayDecoderV2 implements MultiDecoder<RedisZSetCommands.Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/SetReplayDecoder.java
Patch:
@@ -39,7 +39,7 @@ public SetReplayDecoder(Decoder<Object> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
     

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/ObjectListReplayDecoder2.java
Patch:
@@ -55,7 +55,7 @@ public List<T> decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
 }

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/PointDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class PointDecoder implements MultiDecoder<Point> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return DoubleCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/ScoredSortedListReplayDecoder.java
Patch:
@@ -34,11 +34,11 @@
 public class ScoredSortedListReplayDecoder implements MultiDecoder<List<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetReplayDecoder implements MultiDecoder<Set<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoderV2.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSetReplayDecoderV2 implements MultiDecoder<RedisZSetCommands.Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/SetReplayDecoder.java
Patch:
@@ -39,7 +39,7 @@ public SetReplayDecoder(Decoder<Object> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
     

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/ObjectListReplayDecoder2.java
Patch:
@@ -55,7 +55,7 @@ public List<T> decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
 }

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/PointDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class PointDecoder implements MultiDecoder<Point> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return DoubleCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/ScoredSortedListReplayDecoder.java
Patch:
@@ -34,11 +34,11 @@
 public class ScoredSortedListReplayDecoder implements MultiDecoder<List<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetReplayDecoder implements MultiDecoder<Set<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoderV2.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSetReplayDecoderV2 implements MultiDecoder<RedisZSetCommands.Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/SetReplayDecoder.java
Patch:
@@ -39,7 +39,7 @@ public SetReplayDecoder(Decoder<Object> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
     

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/ObjectListReplayDecoder2.java
Patch:
@@ -55,7 +55,7 @@ public List<T> decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
 }

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/PointDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class PointDecoder implements MultiDecoder<Point> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return DoubleCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/ScoredSortedListReplayDecoder.java
Patch:
@@ -34,11 +34,11 @@
 public class ScoredSortedListReplayDecoder implements MultiDecoder<List<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetReplayDecoder implements MultiDecoder<Set<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoderV2.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSetReplayDecoderV2 implements MultiDecoder<RedisZSetCommands.Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/SetReplayDecoder.java
Patch:
@@ -39,7 +39,7 @@ public SetReplayDecoder(Decoder<Object> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
     

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/ObjectListReplayDecoder2.java
Patch:
@@ -55,7 +55,7 @@ public List<T> decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
 }

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/PointDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class PointDecoder implements MultiDecoder<Point> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return DoubleCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/ScoredSortedListReplayDecoder.java
Patch:
@@ -34,11 +34,11 @@
 public class ScoredSortedListReplayDecoder implements MultiDecoder<List<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetReplayDecoder implements MultiDecoder<Set<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoderV2.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSetReplayDecoderV2 implements MultiDecoder<RedisZSetCommands.Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/SetReplayDecoder.java
Patch:
@@ -39,7 +39,7 @@ public SetReplayDecoder(Decoder<Object> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
     

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/ObjectListReplayDecoder2.java
Patch:
@@ -55,7 +55,7 @@ public List<T> decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
 }

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/PointDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class PointDecoder implements MultiDecoder<Point> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return DoubleCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/ScoredSortedListReplayDecoder.java
Patch:
@@ -34,11 +34,11 @@
 public class ScoredSortedListReplayDecoder implements MultiDecoder<List<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetReplayDecoder implements MultiDecoder<Set<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoderV2.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSetReplayDecoderV2 implements MultiDecoder<RedisZSetCommands.Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/SetReplayDecoder.java
Patch:
@@ -39,7 +39,7 @@ public SetReplayDecoder(Decoder<Object> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
     

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/ObjectListReplayDecoder2.java
Patch:
@@ -55,7 +55,7 @@ public List<T> decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
 }

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/PointDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class PointDecoder implements MultiDecoder<Point> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return DoubleCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/ScoredSortedListReplayDecoder.java
Patch:
@@ -34,11 +34,11 @@
 public class ScoredSortedListReplayDecoder implements MultiDecoder<List<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetReplayDecoder implements MultiDecoder<Set<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoderV2.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSetReplayDecoderV2 implements MultiDecoder<RedisZSetCommands.Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/SetReplayDecoder.java
Patch:
@@ -39,7 +39,7 @@ public SetReplayDecoder(Decoder<Object> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
     

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/ObjectListReplayDecoder2.java
Patch:
@@ -55,7 +55,7 @@ public List<T> decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
 }

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/ObjectMapEntryReplayDecoder.java
Patch:
@@ -34,7 +34,7 @@
 public class ObjectMapEntryReplayDecoder implements MultiDecoder<List<Entry<Object, Object>>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return codec.getMapValueDecoder();
         }

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/PointDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class PointDecoder implements MultiDecoder<Point> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return DoubleCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/ScoredSortedListReplayDecoder.java
Patch:
@@ -34,11 +34,11 @@
 public class ScoredSortedListReplayDecoder implements MultiDecoder<List<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetBlockingReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetBlockingReplayDecoder implements MultiDecoder<Set<RedisZSetCommands.Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum == 2) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetReplayDecoder implements MultiDecoder<Set<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoderV2.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSetReplayDecoderV2 implements MultiDecoder<RedisZSetCommands.Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/ScoredSortedSingleBlockingReplayDecoder.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSingleBlockingReplayDecoder implements MultiDecoder<RedisZSetCommands.Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum == 2) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/ScoredSortedSingleReplayDecoder.java
Patch:
@@ -23,7 +23,6 @@
 import org.springframework.data.redis.connection.DefaultTuple;
 import org.springframework.data.redis.connection.RedisZSetCommands.Tuple;
 
-import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -34,11 +33,11 @@
 public class ScoredSortedSingleReplayDecoder implements MultiDecoder<Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/SetReplayDecoder.java
Patch:
@@ -39,7 +39,7 @@ public SetReplayDecoder(Decoder<Object> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
     

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/SingleMapEntryDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class SingleMapEntryDecoder implements MultiDecoder<Entry<Object, Object>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return codec.getMapValueDecoder();
         }

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/ObjectListReplayDecoder2.java
Patch:
@@ -55,7 +55,7 @@ public List<T> decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
 }

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/ObjectMapEntryReplayDecoder.java
Patch:
@@ -34,7 +34,7 @@
 public class ObjectMapEntryReplayDecoder implements MultiDecoder<List<Entry<Object, Object>>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return codec.getMapValueDecoder();
         }

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/PointDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class PointDecoder implements MultiDecoder<Point> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return DoubleCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/ScoredSortedListReplayDecoder.java
Patch:
@@ -34,11 +34,11 @@
 public class ScoredSortedListReplayDecoder implements MultiDecoder<List<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetBlockingReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetBlockingReplayDecoder implements MultiDecoder<Set<RedisZSetCommands.Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum == 2) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetReplayDecoder implements MultiDecoder<Set<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoderV2.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSetReplayDecoderV2 implements MultiDecoder<RedisZSetCommands.Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/ScoredSortedSingleBlockingReplayDecoder.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSingleBlockingReplayDecoder implements MultiDecoder<RedisZSetCommands.Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum == 2) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/ScoredSortedSingleReplayDecoder.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSingleReplayDecoder implements MultiDecoder<Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/SetReplayDecoder.java
Patch:
@@ -39,7 +39,7 @@ public SetReplayDecoder(Decoder<Object> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
     

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/SingleMapEntryDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class SingleMapEntryDecoder implements MultiDecoder<Entry<Object, Object>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return codec.getMapValueDecoder();
         }

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/ObjectListReplayDecoder2.java
Patch:
@@ -55,7 +55,7 @@ public List<T> decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
 }

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/ObjectMapEntryReplayDecoder.java
Patch:
@@ -31,7 +31,7 @@
 public class ObjectMapEntryReplayDecoder implements MultiDecoder<List<Entry<Object, Object>>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return codec.getMapValueDecoder();
         }

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/PointDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class PointDecoder implements MultiDecoder<Point> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return DoubleCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/ScoredSortedListReplayDecoder.java
Patch:
@@ -34,11 +34,11 @@
 public class ScoredSortedListReplayDecoder implements MultiDecoder<List<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetBlockingReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetBlockingReplayDecoder implements MultiDecoder<Set<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum == 2) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetReplayDecoder implements MultiDecoder<Set<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoderV2.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSetReplayDecoderV2 implements MultiDecoder<Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/ScoredSortedSingleBlockingReplayDecoder.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSingleBlockingReplayDecoder implements MultiDecoder<Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum == 2) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/ScoredSortedSingleReplayDecoder.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSingleReplayDecoder implements MultiDecoder<Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/SetReplayDecoder.java
Patch:
@@ -39,7 +39,7 @@ public SetReplayDecoder(Decoder<Object> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
     

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/SingleMapEntryDecoder.java
Patch:
@@ -31,7 +31,7 @@
 public class SingleMapEntryDecoder implements MultiDecoder<Entry<Object, Object>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return codec.getMapValueDecoder();
         }

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/ObjectListReplayDecoder2.java
Patch:
@@ -55,7 +55,7 @@ public List<T> decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
 }

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/ObjectMapEntryReplayDecoder.java
Patch:
@@ -31,7 +31,7 @@
 public class ObjectMapEntryReplayDecoder implements MultiDecoder<List<Entry<Object, Object>>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return codec.getMapValueDecoder();
         }

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/PointDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class PointDecoder implements MultiDecoder<Point> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return DoubleCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/ScoredSortedListReplayDecoder.java
Patch:
@@ -34,11 +34,11 @@
 public class ScoredSortedListReplayDecoder implements MultiDecoder<List<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetBlockingReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetBlockingReplayDecoder implements MultiDecoder<Set<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum == 2) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetReplayDecoder implements MultiDecoder<Set<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/ScoredSortedSingleBlockingReplayDecoder.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSingleBlockingReplayDecoder implements MultiDecoder<Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum == 2) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/ScoredSortedSingleReplayDecoder.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSingleReplayDecoder implements MultiDecoder<Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/SetReplayDecoder.java
Patch:
@@ -39,7 +39,7 @@ public SetReplayDecoder(Decoder<Object> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
     

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/SingleMapEntryDecoder.java
Patch:
@@ -31,7 +31,7 @@
 public class SingleMapEntryDecoder implements MultiDecoder<Entry<Object, Object>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return codec.getMapValueDecoder();
         }

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/ObjectListReplayDecoder2.java
Patch:
@@ -55,7 +55,7 @@ public List<T> decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
 }

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/ObjectMapEntryReplayDecoder.java
Patch:
@@ -31,7 +31,7 @@
 public class ObjectMapEntryReplayDecoder implements MultiDecoder<List<Entry<Object, Object>>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return codec.getMapValueDecoder();
         }

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/PointDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class PointDecoder implements MultiDecoder<Point> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return DoubleCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/ScoredSortedListReplayDecoder.java
Patch:
@@ -34,11 +34,11 @@
 public class ScoredSortedListReplayDecoder implements MultiDecoder<List<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetBlockingReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetBlockingReplayDecoder implements MultiDecoder<Set<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum == 2) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/ScoredSortedSetReplayDecoder.java
Patch:
@@ -35,11 +35,11 @@
 public class ScoredSortedSetReplayDecoder implements MultiDecoder<Set<Tuple>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/ScoredSortedSingleBlockingReplayDecoder.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSingleBlockingReplayDecoder implements MultiDecoder<Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum == 2) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/ScoredSortedSingleReplayDecoder.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSingleReplayDecoder implements MultiDecoder<Tuple> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/SetReplayDecoder.java
Patch:
@@ -39,7 +39,7 @@ public SetReplayDecoder(Decoder<Object> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
     

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/SingleMapEntryDecoder.java
Patch:
@@ -31,7 +31,7 @@
 public class SingleMapEntryDecoder implements MultiDecoder<Entry<Object, Object>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return codec.getMapValueDecoder();
         }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/AutoClaimDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class AutoClaimDecoder implements MultiDecoder<Object> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return new StreamIdDecoder();
     }
 

File: redisson/src/main/java/org/redisson/client/protocol/decoder/FastAutoClaimDecoder.java
Patch:
@@ -31,7 +31,7 @@
 public class FastAutoClaimDecoder implements MultiDecoder<FastAutoClaimResult> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return new StreamIdDecoder();
     }
 

File: redisson/src/main/java/org/redisson/client/protocol/decoder/GeoDistanceDecoder.java
Patch:
@@ -30,11 +30,11 @@
 public class GeoDistanceDecoder implements MultiDecoder<List<Object>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/client/protocol/decoder/GeoPositionDecoder.java
Patch:
@@ -31,7 +31,7 @@
 public class GeoPositionDecoder implements MultiDecoder<GeoPosition> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return DoubleCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ListFirstObjectDecoder.java
Patch:
@@ -45,11 +45,11 @@ public ListFirstObjectDecoder(MultiDecoder<Object> inner) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (inner != null) {
-            return inner.getDecoder(codec, paramNum, state);
+            return inner.getDecoder(codec, paramNum, state, size);
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ListMultiDecoder2.java
Patch:
@@ -36,9 +36,9 @@ public ListMultiDecoder2(MultiDecoder<?>... decoders) {
     }
     
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         int index = state.getLevel();
-        return decoders[index].getDecoder(codec, paramNum, state);
+        return decoders[index].getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ListObjectDecoder.java
Patch:
@@ -37,11 +37,11 @@ public ListObjectDecoder(int index) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum == 0) {
             return StringCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ListResultReplayDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class ListResultReplayDecoder implements MultiDecoder<List<Map<Object, Object>>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return StringCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ListScanResultReplayDecoder.java
Patch:
@@ -30,7 +30,7 @@
 public class ListScanResultReplayDecoder implements MultiDecoder<ListScanResult<Object>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return StringCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson/src/main/java/org/redisson/client/protocol/decoder/Long2MultiDecoder.java
Patch:
@@ -30,7 +30,7 @@
 public class Long2MultiDecoder implements MultiDecoder<Object> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return LongCodec.INSTANCE.getValueDecoder();
     }
 

File: redisson/src/main/java/org/redisson/client/protocol/decoder/MapCacheKeyScanResultDecoder.java
Patch:
@@ -38,7 +38,7 @@ public MapCacheKeyScanResult<Object> decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return StringCodec.INSTANCE.getValueDecoder();
     }
 

File: redisson/src/main/java/org/redisson/client/protocol/decoder/MapCacheScanResultReplayDecoder.java
Patch:
@@ -39,7 +39,7 @@ public MapCacheScanResult<Object, Object> decode(List<Object> parts, State state
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return StringCodec.INSTANCE.getValueDecoder();
     }
 

File: redisson/src/main/java/org/redisson/client/protocol/decoder/MapEntriesDecoder.java
Patch:
@@ -37,7 +37,7 @@ public MapEntriesDecoder() {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return codec.getMapValueDecoder();
         } else {

File: redisson/src/main/java/org/redisson/client/protocol/decoder/MapKeyDecoder.java
Patch:
@@ -33,7 +33,7 @@ public MapKeyDecoder(MultiDecoder<Object> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return codec.getMapKeyDecoder();
     }
 

File: redisson/src/main/java/org/redisson/client/protocol/decoder/MapScanResultReplayDecoder.java
Patch:
@@ -31,7 +31,7 @@
 public class MapScanResultReplayDecoder implements MultiDecoder<MapScanResult<Object, Object>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return StringCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson/src/main/java/org/redisson/client/protocol/decoder/MapValueDecoder.java
Patch:
@@ -37,7 +37,7 @@ public MapValueDecoder() {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return codec.getMapValueDecoder();
     }
 

File: redisson/src/main/java/org/redisson/client/protocol/decoder/MultiDecoder.java
Patch:
@@ -31,7 +31,7 @@
  */
 public interface MultiDecoder<T> {
 
-    default Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    default Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (codec == null) {
             codec = StringCodec.INSTANCE;
         }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ObjectDecoder.java
Patch:
@@ -36,7 +36,7 @@ public ObjectDecoder(Decoder<T> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return (Decoder<Object>) decoder;
     }
 

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ObjectFirstScoreReplayDecoder.java
Patch:
@@ -31,11 +31,11 @@
 public class ObjectFirstScoreReplayDecoder implements MultiDecoder<Double> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ObjectListReplayDecoder.java
Patch:
@@ -56,10 +56,10 @@ public List<T> decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (decoder != null) {
             return decoder;
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
 }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ObjectMapDecoder.java
Patch:
@@ -37,7 +37,7 @@ public ObjectMapDecoder(boolean decodeList) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (state.getValue() != null && (Boolean) state.getValue()) {
             return codec.getMapKeyDecoder();
         }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ObjectMapEntryReplayDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class ObjectMapEntryReplayDecoder implements MultiDecoder<Set<Entry<Object, Object>>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return codec.getMapValueDecoder();
         }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ObjectMapReplayDecoder.java
Patch:
@@ -47,7 +47,7 @@ public ObjectMapReplayDecoder(boolean swapKeyValue, Codec codec) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         Codec c = Optional.ofNullable(this.codec).orElse(codec);
         if (paramNum % 2 != 0) {
             return c.getMapValueDecoder();

File: redisson/src/main/java/org/redisson/client/protocol/decoder/RankedEntryDecoder.java
Patch:
@@ -32,7 +32,7 @@
 public class RankedEntryDecoder implements MultiDecoder<RankedEntry<?>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/RedisURIDecoder.java
Patch:
@@ -42,7 +42,7 @@ public RedisURIDecoder(boolean ssl) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return StringCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ScoredEntryScanDecoder.java
Patch:
@@ -33,7 +33,7 @@
 public class ScoredEntryScanDecoder<T> implements MultiDecoder<ListScanResult<ScoredEntry<T>>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return StringCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ScoredSortedSetPolledObjectDecoder.java
Patch:
@@ -39,14 +39,14 @@ public Object decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum == 0) {
             return StringCodec.INSTANCE.getValueDecoder();
         }
         if (paramNum == 2) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
 
 }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ScoredSortedSetRandomMapDecoder.java
Patch:
@@ -32,9 +32,9 @@
 public class ScoredSortedSetRandomMapDecoder extends ObjectMapReplayDecoder<Object, Object> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 == 0) {
-            return super.getDecoder(codec, paramNum, state);
+            return super.getDecoder(codec, paramNum, state, size);
         }
         return DoubleCodec.INSTANCE.getValueDecoder();
     }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ScoredSortedSetReplayDecoder.java
Patch:
@@ -33,11 +33,11 @@
 public class ScoredSortedSetReplayDecoder<T> implements MultiDecoder<List<ScoredEntry<T>>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ScoredSortedSetReplayDecoderV2.java
Patch:
@@ -32,11 +32,11 @@
 public class ScoredSortedSetReplayDecoderV2<T> implements MultiDecoder<ScoredEntry<T>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ScoredSortedSetScanDecoder.java
Patch:
@@ -29,11 +29,11 @@
 public class ScoredSortedSetScanDecoder<T> extends ObjectListReplayDecoder<T> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 2 != 0) {
             return DoubleCodec.INSTANCE.getValueDecoder();
         }
-        return super.getDecoder(codec, paramNum, state);
+        return super.getDecoder(codec, paramNum, state, size);
     }
     
 }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ScoredSortedSetScanReplayDecoder.java
Patch:
@@ -30,7 +30,7 @@
 public class ScoredSortedSetScanReplayDecoder implements MultiDecoder<ListScanResult<Object>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return StringCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson/src/main/java/org/redisson/client/protocol/decoder/SlotsDecoder.java
Patch:
@@ -36,7 +36,7 @@
 public class SlotsDecoder implements MultiDecoder<Object> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return StringCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson/src/main/java/org/redisson/client/protocol/decoder/StreamObjectMapReplayDecoder.java
Patch:
@@ -61,11 +61,11 @@ public Map<Object, Object> decode(List<Object> parts, State state) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (this.codec != null) {
             return this.codec;
         }
-        return super.getDecoder(codec, paramNum, state);
+        return super.getDecoder(codec, paramNum, state, size);
     }
 
 }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/StreamResultDecoderV2.java
Patch:
@@ -41,7 +41,7 @@ public StreamResultDecoderV2(boolean firstResult) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return StringCodec.INSTANCE.getValueDecoder();
     }
 

File: redisson/src/main/java/org/redisson/client/protocol/decoder/StringListReplayDecoder.java
Patch:
@@ -31,7 +31,7 @@
 public class StringListReplayDecoder implements MultiDecoder<List<String>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return StringCodec.INSTANCE.getValueDecoder();
     }
     

File: redisson/src/main/java/org/redisson/client/protocol/decoder/StringMapDataDecoder.java
Patch:
@@ -50,7 +50,7 @@ public Object decode(ByteBuf buf, State state) throws IOException {
     };
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
 

File: redisson/src/main/java/org/redisson/client/protocol/decoder/TimeSeriesEntryReplayDecoder.java
Patch:
@@ -43,11 +43,11 @@ public TimeSeriesEntryReplayDecoder(boolean reverse) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum % 4 == 2 || paramNum % 4 == 3) {
             return LongCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/client/protocol/decoder/TimeSeriesFirstEntryReplayDecoder.java
Patch:
@@ -32,8 +32,8 @@ public class TimeSeriesFirstEntryReplayDecoder implements MultiDecoder<Object> {
     private final TimeSeriesEntryReplayDecoder decoder = new TimeSeriesEntryReplayDecoder();
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
-        return decoder.getDecoder(codec, paramNum, state);
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
+        return decoder.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/client/protocol/decoder/TimeSeriesSingleEntryReplayDecoder.java
Patch:
@@ -31,11 +31,11 @@
 public class TimeSeriesSingleEntryReplayDecoder implements MultiDecoder<TimeSeriesEntry<Object, Object>> {
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         if (paramNum == 0 || paramNum == 1) {
             return LongCodec.INSTANCE.getValueDecoder();
         }
-        return MultiDecoder.super.getDecoder(codec, paramNum, state);
+        return MultiDecoder.super.getDecoder(codec, paramNum, state, size);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/client/protocol/pubsub/PubSubMessageDecoder.java
Patch:
@@ -38,7 +38,7 @@ public PubSubMessageDecoder(Decoder<Object> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
     

File: redisson/src/main/java/org/redisson/client/protocol/pubsub/PubSubPatternMessageDecoder.java
Patch:
@@ -38,7 +38,7 @@ public PubSubPatternMessageDecoder(Decoder<Object> decoder) {
     }
 
     @Override
-    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
+    public Decoder<Object> getDecoder(Codec codec, int paramNum, State state, long size) {
         return decoder;
     }
     

File: redisson/src/main/java/org/redisson/transaction/BaseTransactionalSet.java
Patch:
@@ -417,8 +417,8 @@ private boolean isEqual(Object value, Object oldValue) {
         try {
             return valueBuf.equals(oldValueBuf);
         } finally {
-            valueBuf.readableBytes();
-            oldValueBuf.readableBytes();
+            valueBuf.release();
+            oldValueBuf.release();
         }
     }
 

File: redisson/src/main/java/org/redisson/api/search/aggregate/GroupParams.java
Patch:
@@ -16,6 +16,7 @@
 package org.redisson.api.search.aggregate;
 
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
 /**
@@ -26,7 +27,7 @@
 public final class GroupParams implements GroupBy {
 
     private List<String> fieldNames;
-    private List<Reducer> reducers;
+    private List<Reducer> reducers = Collections.emptyList();
 
     GroupParams(List<String> fieldNames) {
         this.fieldNames = fieldNames;

File: redisson/src/main/java/org/redisson/RedissonSearch.java
Patch:
@@ -561,7 +561,7 @@ public RFuture<AggregationResult> aggregateAsync(String indexName, String query,
         }
         if (!options.getSortedByFields().isEmpty()) {
             args.add("SORTBY");
-            args.add(options.getSortedByFields().size());
+            args.add(options.getSortedByFields().size()*2);
             for (SortedField sortedByField : options.getSortedByFields()) {
                 args.add(sortedByField.getName());
                 args.add(sortedByField.getOrder());

File: redisson/src/main/java/org/redisson/transaction/BaseTransactionalSet.java
Patch:
@@ -417,8 +417,8 @@ private boolean isEqual(Object value, Object oldValue) {
         try {
             return valueBuf.equals(oldValueBuf);
         } finally {
-            valueBuf.readableBytes();
-            oldValueBuf.readableBytes();
+            valueBuf.release();
+            oldValueBuf.release();
         }
     }
 

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -267,8 +267,9 @@ public <T, R> RFuture<R> readRandomAsync(RedisClient client, Codec codec, RedisC
     
     private <R, T> void retryReadRandomAsync(Codec codec, RedisCommand<T> command, CompletableFuture<R> mainPromise,
             List<RedisClient> nodes, Object... params) {
-        RedisClient entry = nodes.remove(0);
-        RFuture<R> attemptPromise  = async(true, new NodeSource(entry), codec, command, params, false, false);
+        RedisClient client = nodes.remove(0);
+        MasterSlaveEntry masterSlaveEntry = connectionManager.getEntry(client);
+        RFuture<R> attemptPromise  = async(true, new NodeSource(masterSlaveEntry, client), codec, command, params, false, false);
         attemptPromise.whenComplete((res, e) -> {
             if (e == null) {
                 if (res == null) {

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -177,7 +177,7 @@ private void detectSharding() {
         MasterSlaveEntry entry = getEntrySet().iterator().next();
         RedisConnection c = entry.connectionWriteOp(null).join();
         try {
-            c.sync(RedisCommands.SPUBLISH, "", "");
+            c.sync(RedisCommands.PUBSUB_SHARDNUMSUB);
             subscribeService.setShardingSupported(true);
         } catch (Exception e) {
             // skip

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -267,8 +267,9 @@ public <T, R> RFuture<R> readRandomAsync(RedisClient client, Codec codec, RedisC
     
     private <R, T> void retryReadRandomAsync(Codec codec, RedisCommand<T> command, CompletableFuture<R> mainPromise,
             List<RedisClient> nodes, Object... params) {
-        RedisClient entry = nodes.remove(0);
-        RFuture<R> attemptPromise  = async(true, new NodeSource(entry), codec, command, params, false, false);
+        RedisClient client = nodes.remove(0);
+        MasterSlaveEntry masterSlaveEntry = connectionManager.getEntry(client);
+        RFuture<R> attemptPromise  = async(true, new NodeSource(masterSlaveEntry, client), codec, command, params, false, false);
         attemptPromise.whenComplete((res, e) -> {
             if (e == null) {
                 if (res == null) {

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -531,7 +531,7 @@ private CompletableFuture<Void> upDownSlaves(MasterSlaveEntry entry, ClusterPart
                     if (v) {
                         log.info("slave: {} is up for slot ranges: {}", uri, currentPart.getSlotRanges());
                         currentPart.removeFailedSlaveAddress(uri);
-                        return entry.excludeMasterFromSlaves(uri);
+                        entry.excludeMasterFromSlaves(uri);
                     }
                     return v;
                 });
@@ -578,7 +578,7 @@ private CompletableFuture<Set<RedisURI>> addRemoveSlaves(MasterSlaveEntry entry,
                     if (v) {
                         currentPart.addSlaveAddress(uri);
                         log.info("slave: {} added for slot ranges: {}", uri, currentPart.getSlotRanges());
-                        return entry.excludeMasterFromSlaves(uri);
+                        entry.excludeMasterFromSlaves(uri);
                     }
                     return v;
                 });

File: redisson/src/main/java/org/redisson/connection/ServiceManager.java
Patch:
@@ -653,9 +653,9 @@ public Codec getCodec(Codec codec) {
         return codec;
     }
 
-    private final Map<String, AtomicInteger> addersUsage = new ConcurrentHashMap<>();
+    private final Map<String, AdderEntry> addersUsage = new ConcurrentHashMap<>();
 
-    public Map<String, AtomicInteger> getAddersUsage() {
+    public Map<String, AdderEntry> getAddersUsage() {
         return addersUsage;
     }
 

File: redisson/src/test/java/org/redisson/RedissonBatchTest.java
Patch:
@@ -283,7 +283,7 @@ public void testConnectionLeakAfterError() throws InterruptedException {
         });
 
         // time to reconnect broken connection
-        Thread.sleep(300);
+        Thread.sleep(700);
 
         redisson.getBucket("test3").set(4);
         assertThat(redisson.getBucket("test3").get()).isEqualTo(4);

File: redisson/src/test/java/org/redisson/RedissonFailoverTest.java
Patch:
@@ -254,7 +254,7 @@ public void run() {
 
             assertThat(futures.get(futures.size() - 1).isDone()).isTrue();
             assertThat(futures.get(futures.size() - 1).toCompletableFuture().isCompletedExceptionally()).isFalse();
-            assertThat(errors).isBetween(150, 820);
+            assertThat(errors).isBetween(100, 820);
             assertThat(readonlyErrors).isZero();
 
             redisson.shutdown();

File: redisson/src/test/java/org/redisson/RedissonBatchTest.java
Patch:
@@ -229,7 +229,7 @@ public void testPerformance(BatchOptions batchOptions) {
     }
 
     @Test
-    public void testSkipResult() throws InterruptedException {
+    public void testSkipResult() throws InterruptedException, ExecutionException, TimeoutException {
         ExecutorService e = Executors.newFixedThreadPool(8);
         Queue<RFuture<?>> futures = new ConcurrentLinkedQueue<>();
         for (int i = 0; i < 8; i++) {
@@ -257,7 +257,7 @@ public void testSkipResult() throws InterruptedException {
         assertThat(e.awaitTermination(10, TimeUnit.SECONDS)).isTrue();
 
         for (RFuture<?> future : futures) {
-            future.toCompletableFuture().join();
+            future.toCompletableFuture().get(1, TimeUnit.SECONDS);
         }
     }
 

File: redisson-tomcat/redisson-tomcat-10/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -236,7 +236,7 @@ protected void expireSession() {
 
     protected AttributesPutAllMessage createPutAllMessage(Map<String, Object> newMap) {
         try {
-            return new AttributesPutAllMessage(redissonManager.getNodeId(), getId(), newMap, this.map.getCodec().getMapValueEncoder());
+            return new AttributesPutAllMessage(redissonManager, getId(), newMap, this.map.getCodec().getMapValueEncoder());
         } catch (Exception e) {
             throw new IllegalStateException(e);
         }

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -230,7 +230,7 @@ protected void expireSession() {
 
     protected AttributesPutAllMessage createPutAllMessage(Map<String, Object> newMap) {
         try {
-            return new AttributesPutAllMessage(redissonManager.getNodeId(), getId(), newMap, this.map.getCodec().getMapValueEncoder());
+            return new AttributesPutAllMessage(redissonManager, getId(), newMap, this.map.getCodec().getMapValueEncoder());
         } catch (Exception e) {
             throw new IllegalStateException(e);
         }

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -231,7 +231,7 @@ protected void expireSession() {
 
     protected AttributesPutAllMessage createPutAllMessage(Map<String, Object> newMap) {
         try {
-            return new AttributesPutAllMessage(redissonManager.getNodeId(), getId(), newMap, this.map.getCodec().getMapValueEncoder());
+            return new AttributesPutAllMessage(redissonManager, getId(), newMap, this.map.getCodec().getMapValueEncoder());
         } catch (Exception e) {
             throw new IllegalStateException(e);
         }

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -231,7 +231,7 @@ protected void expireSession() {
 
     protected AttributesPutAllMessage createPutAllMessage(Map<String, Object> newMap) {
         try {
-            return new AttributesPutAllMessage(redissonManager.getNodeId(), getId(), newMap, this.map.getCodec().getMapValueEncoder());
+            return new AttributesPutAllMessage(redissonManager, getId(), newMap, this.map.getCodec().getMapValueEncoder());
         } catch (Exception e) {
             throw new IllegalStateException(e);
         }

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -1001,7 +1001,9 @@ public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
         RExecutorBatchFuture future = submit(tasks.toArray(new Callable[0]));
         try {
             future.toCompletableFuture().get(timeout, unit);
-        } catch (ExecutionException | TimeoutException | CancellationException e) {
+        } catch (ExecutionException e) {
+            LOGGER.error(e.getMessage(), e);
+        } catch (TimeoutException | CancellationException e) {
             // skip
         }
         List<?> futures = future.getTaskFutures();

File: redisson/src/main/java/org/redisson/connection/ClientConnectionsEntry.java
Patch:
@@ -177,6 +177,7 @@ private void reattachBlockingQueue(CommandData<?, ?> commandData) {
 
         MasterSlaveEntry entry = connectionManager.getEntry(key);
         if (entry == null) {
+            log.debug("Unable to get entry for {} during blocking command reattach {}", key, commandData);
             connectionManager.getServiceManager().newTimeout(timeout ->
                     reattachBlockingQueue(commandData), 1, TimeUnit.SECONDS);
             return;
@@ -185,6 +186,7 @@ private void reattachBlockingQueue(CommandData<?, ?> commandData) {
         CompletableFuture<RedisConnection> newConnectionFuture = entry.connectionWriteOp(commandData.getCommand());
         newConnectionFuture.whenComplete((newConnection, e) -> {
             if (e != null) {
+                log.debug("Unable to acquire connection during blocking command reattach {}", commandData, e);
                 connectionManager.getServiceManager().newTimeout(timeout ->
                         reattachBlockingQueue(commandData), 1, TimeUnit.SECONDS);
                 return;
@@ -197,6 +199,7 @@ private void reattachBlockingQueue(CommandData<?, ?> commandData) {
             ChannelFuture channelFuture = newConnection.send(commandData);
             channelFuture.addListener(future -> {
                 if (!future.isSuccess()) {
+                    log.debug("Unable to send a command during blocking command reattach {}", commandData, future.cause());
                     connectionManager.getServiceManager().newTimeout(timeout ->
                             reattachBlockingQueue(commandData), 1, TimeUnit.SECONDS);
                     return;

File: redisson/src/main/java/org/redisson/codec/Kryo5Codec.java
Patch:
@@ -101,7 +101,7 @@ public Kryo5Codec(ClassLoader classLoader, Kryo5Codec codec) {
     }
 
     public Kryo5Codec(ClassLoader classLoader) {
-        this(null, false);
+        this(classLoader, false);
     }
 
     public Kryo5Codec(ClassLoader classLoader, boolean registrationRequired) {

File: redisson/src/main/java/org/redisson/RedissonFairLock.java
Patch:
@@ -320,7 +320,7 @@ public RFuture<Boolean> clearExpireAsync() {
     
     @Override
     public RFuture<Boolean> forceUnlockAsync() {
-        cancelExpirationRenewal(null);
+        cancelExpirationRenewal(null, null);
         return commandExecutor.syncedEvalWithRetry(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 // remove stale threads
                 "while true do "

File: redisson/src/main/java/org/redisson/RedissonReadLock.java
Patch:
@@ -180,7 +180,7 @@ public Condition newCondition() {
 
     @Override
     public RFuture<Boolean> forceUnlockAsync() {
-        cancelExpirationRenewal(null);
+        cancelExpirationRenewal(null, null);
         return commandExecutor.syncedEvalWithRetry(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 "if (redis.call('hget', KEYS[1], 'mode') == 'read') then " +
                     "redis.call('del', KEYS[1]); " +

File: redisson/src/main/java/org/redisson/RedissonWriteLock.java
Patch:
@@ -137,7 +137,7 @@ protected CompletionStage<Boolean> renewExpirationAsync(long threadId) {
 
     @Override
     public RFuture<Boolean> forceUnlockAsync() {
-        cancelExpirationRenewal(null);
+        cancelExpirationRenewal(null, null);
         return commandExecutor.syncedEvalWithRetry(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
               "if (redis.call('hget', KEYS[1], 'mode') == 'write') then " +
                   "redis.call('del', KEYS[1]); " +

File: redisson/src/main/java/org/redisson/RedissonObject.java
Patch:
@@ -513,7 +513,7 @@ public RFuture<Void> removeListenerAsync(int listenerId) {
     }
 
     protected final RFuture<Void> removeListenerAsync(int listenerId, String... names) {
-        List<String> ns = Arrays.asList(names);
+        List<String> ns = new ArrayList<>(Arrays.asList(names));
         ns.addAll(Arrays.asList("__keyevent@*:expired", "__keyevent@*:del"));
         return removeListenerAsync(null, listenerId, ns.toArray(new String[0]));
     }

File: redisson/src/main/java/org/redisson/PubSubStatusListener.java
Patch:
@@ -72,9 +72,9 @@ public void onPatternMessage(CharSequence pattern, CharSequence channel, Object
     @Override
     public void onStatus(PubSubType type, CharSequence channel) {
         if (channel.toString().equals(name)) {
-            if (type == PubSubType.SUBSCRIBE) {
+            if (type == PubSubType.SUBSCRIBE || type == PubSubType.SSUBSCRIBE || type == PubSubType.PSUBSCRIBE) {
                 listener.onSubscribe(channel.toString());
-            } else if (type == PubSubType.UNSUBSCRIBE) {
+            } else if (type == PubSubType.UNSUBSCRIBE || type == PubSubType.SUNSUBSCRIBE || type == PubSubType.PUNSUBSCRIBE) {
                 listener.onUnsubscribe(channel.toString());
             }
         }

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -710,6 +710,7 @@ public Object decode(List parts, State state) {
     RedisStrictCommand<Long> SPUBLISH = new RedisStrictCommand<Long>("SPUBLISH");
     RedisCommand<Long> PUBSUB_NUMSUB = new RedisCommand<Long>("PUBSUB", "NUMSUB", new ListObjectDecoder<Long>(1));
     RedisCommand<List<String>> PUBSUB_CHANNELS = new RedisStrictCommand<>("PUBSUB", "CHANNELS", new StringListReplayDecoder());
+    RedisCommand<List<String>> PUBSUB_SHARDCHANNELS = new RedisStrictCommand<>("PUBSUB", "SHARDCHANNELS", new StringListReplayDecoder());
 
     RedisCommand<Object> SSUBSCRIBE = new RedisCommand<Object>("SSUBSCRIBE", new PubSubStatusDecoder());
     RedisCommand<Object> SUBSCRIBE = new RedisCommand<Object>("SUBSCRIBE", new PubSubStatusDecoder());

File: redisson/src/main/java/org/redisson/pubsub/PublishSubscribeService.java
Patch:
@@ -784,7 +784,7 @@ public void reattachPubSub(int slot) {
                 if (scodec != null) {
                     Queue<RedisPubSubListener<?>> listeners = pubSubEntry.getListeners(entry.getKey().getChannelName());
                     unsubscribe(entry.getKey().getChannelName(), pubSubEntry, PubSubType.SUNSUBSCRIBE);
-                    subscribe(codec, entry.getKey().getChannelName(), listeners.toArray(new RedisPubSubListener[0]));
+                    ssubscribe(codec, entry.getKey().getChannelName(), listeners.toArray(new RedisPubSubListener[0]));
                 }
 
                 Codec patternCodec = pubSubEntry.getConnection().getPatternChannels().get(entry.getKey().getChannelName());
@@ -876,7 +876,7 @@ private void ssubscribe(ChannelName channelName, Collection<RedisPubSubListener<
                 return;
             }
 
-            log.info("listeners of '{}' channel have been resubscribed to '{}'", channelName, res);
+            log.info("listeners of '{}' sharded-channel have been resubscribed to '{}'", channelName, res);
         });
     }
 

File: redisson/src/test/java/org/redisson/RedissonStreamTest.java
Patch:
@@ -615,7 +615,7 @@ public void run() {
         };
         t.start();
 
-        Awaitility.await().between(Duration.ofMillis(1900), Duration.ofMillis(2200)).untilAsserted(() -> {
+        Awaitility.await().between(Duration.ofMillis(1900), Duration.ofMillis(2700)).untilAsserted(() -> {
             Map<String, Map<StreamMessageId, Map<String, String>>> s = stream.read(StreamMultiReadArgs.greaterThan(new StreamMessageId(0), "test1", StreamMessageId.NEWEST)
                     .timeout(Duration.ofSeconds(5))
                     .count(2));

File: redisson/src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -154,7 +154,7 @@ public void testPerformance() throws InterruptedException {
         }
 
         ex.shutdown();
-        assertThat(ex.awaitTermination(10, TimeUnit.SECONDS)).isTrue();
+        assertThat(ex.awaitTermination(12, TimeUnit.SECONDS)).isTrue();
         assertThat(s.get()).isEqualTo(200_000L);
         inst.shutdown();
     }

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -587,11 +587,10 @@ private CompletableFuture<Set<RedisURI>> addRemoveSlaves(MasterSlaveEntry entry,
             }
 
             CompletableFuture<Void> slaveUpFuture = entry.addSlave(uri, false, configEndpointHostName);
-            CompletableFuture<Void> f = slaveUpFuture.thenCompose(res -> {
+            CompletableFuture<Void> f = slaveUpFuture.thenAccept(res -> {
                 currentPart.addSlaveAddress(uri);
                 log.info("slave: {} added for slot ranges: {}", uri, currentPart.getSlotRanges());
                 entry.excludeMasterFromSlaves(uri);
-                return null;
             });
             futures.add(f);
         }

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -543,7 +543,7 @@ private CompletableFuture<Void> upDownSlaves(MasterSlaveEntry entry, ClusterPart
                 .filter(uri -> !currentPart.getFailedSlaveAddresses().contains(uri))
                 .forEach(uri -> {
                     currentPart.addFailedSlaveAddress(uri);
-                    if (entry.slaveDown(uri, FreezeReason.MANAGER)) {
+                    if (config.isSlaveNotUsed() || entry.slaveDown(uri, FreezeReason.MANAGER)) {
                         disconnectNode(uri);
                         log.warn("slave: {} has down for slot ranges: {}", uri, currentPart.getSlotRanges());
                     }
@@ -558,7 +558,7 @@ private CompletableFuture<Set<RedisURI>> addRemoveSlaves(MasterSlaveEntry entry,
         for (RedisURI uri : removedSlaves) {
             currentPart.removeSlaveAddress(uri);
 
-            if (entry.slaveDown(uri, FreezeReason.MANAGER)) {
+            if (config.isSlaveNotUsed() || entry.slaveDown(uri, FreezeReason.MANAGER)) {
                 disconnectNode(uri);
                 log.info("slave {} removed for slot ranges: {}", uri, currentPart.getSlotRanges());
             }

File: redisson/src/main/java/org/redisson/connection/ReplicatedConnectionManager.java
Patch:
@@ -172,7 +172,7 @@ private void checkFailedSlaves(Set<InetSocketAddress> slaveIPs) {
                 .collect(Collectors.toSet());
 
         for (RedisClient slave : failedSlaves) {
-            if (entry.slaveDown(slave.getAddr(), FreezeReason.MANAGER)) {
+            if (config.isSlaveNotUsed() || entry.slaveDown(slave.getAddr(), FreezeReason.MANAGER)) {
                 log.info("slave: {} is down", slave);
                 disconnectNode(new RedisURI(slave.getConfig().getAddress().getScheme(),
                                             slave.getAddr().getAddress().getHostAddress(),

File: redisson/src/main/java/org/redisson/RedissonObject.java
Patch:
@@ -525,8 +525,8 @@ protected final void removeTrackingListener(int listenerId) {
     protected final RFuture<Void> removeTrackingListenerAsync(int listenerId) {
         PublishSubscribeService subscribeService = commandExecutor.getConnectionManager().getSubscribeService();
         CompletableFuture<Void> f = subscribeService.removeListenerAsync(PubSubType.UNSUBSCRIBE, new ChannelName("__redis__:invalidate"), listenerId);
-        f.whenComplete((r, e) -> {
-            if (commandExecutor.isTrackChanges()) {
+        f = f.whenComplete((r, e) -> {
+            if (!commandExecutor.isTrackChanges()) {
                 commandExecutor = new CommandAsyncService(commandExecutor, false);
             }
         });

File: redisson/src/main/java/org/redisson/api/LocalCachedMapOptions.java
Patch:
@@ -24,7 +24,7 @@
  import org.redisson.api.map.MapWriterAsync;
 
 /**
- * Configuration for LocalCachedMap object.
+ * Use org.redisson.api.options.LocalCachedMapOptions instead
  * 
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/api/MapOptions.java
Patch:
@@ -25,7 +25,7 @@
 import java.time.Duration;
 
 /**
- * Configuration for RMap object.
+ * Use org.redisson.api.options.MapOptions instead
  * 
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/client/protocol/decoder/SlotsDecoder.java
Patch:
@@ -42,7 +42,7 @@ public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
     
     @Override
     public Object decode(List<Object> parts, State state) {
-        if (parts.get(0) instanceof List) {
+        if (!parts.isEmpty() && parts.get(0) instanceof List) {
             Map<ClusterSlotRange, Set<String>> result = new HashMap<>();
             List<List<Object>> rows = (List<List<Object>>) (Object) parts;
             for (List<Object> row : rows) {

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -622,7 +622,7 @@ private CompletableFuture<Void> checkMasterNodesChange(ClusterServersConfig cfg,
             if (masterFound && newPart.isMasterFail()) {
                 for (Integer slot : currentPart.getSlots()) {
                     ClusterPartition newMasterPart = find(newPartitions, slot);
-                    // does partition has a new master?
+                    // does partition have a new master?
                     if (!Objects.equals(newMasterPart.getMasterAddress(), currentPart.getMasterAddress())) {
                         RedisURI newUri = newMasterPart.getMasterAddress();
                         RedisURI oldUri = currentPart.getMasterAddress();

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -504,15 +504,15 @@ private CompletableFuture<Void> checkSlaveNodesChange(Collection<ClusterPartitio
             // should be invoked first in order to remove stale failedSlaveAddresses
             CompletableFuture<Set<RedisURI>> addedSlavesFuture = addRemoveSlaves(entry, currentPart, newPart);
             CompletableFuture<Void> f = addedSlavesFuture.thenCompose(addedSlaves -> {
-                // Do some slaves have changed state from failed to alive?
+                // Have some slaves changed state from failed to alive?
                 return upDownSlaves(entry, currentPart, newPart, addedSlaves);
             });
             futures.add(f);
         }
         return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                                     .exceptionally(e -> {
                                         if (e != null) {
-                                            log.error(e.getMessage(), e);
+                                            log.error("Unable to add/remove slave nodes", e);
                                         }
                                         return null;
                                     });
@@ -656,7 +656,7 @@ private CompletableFuture<Void> checkMasterNodesChange(ClusterServersConfig cfg,
         return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                                     .exceptionally(e -> {
                                         if (e != null) {
-                                            log.error(e.getMessage(), e);
+                                            log.error("Unable to add/change master node", e);
                                         }
                                         return null;
                                     });

File: redisson/src/main/java/org/redisson/codec/Kryo5Codec.java
Patch:
@@ -101,7 +101,7 @@ public Kryo5Codec(ClassLoader classLoader, Kryo5Codec codec) {
     }
 
     public Kryo5Codec(ClassLoader classLoader) {
-        this(null, false);
+        this(classLoader, false);
     }
 
     public Kryo5Codec(ClassLoader classLoader, boolean registrationRequired) {

File: redisson/src/main/java/org/redisson/spring/cache/RedissonCache.java
Patch:
@@ -160,7 +160,7 @@ public boolean evictIfPresent(Object key) {
         return delta > 0;
     }
 
-    CompletableFuture<?> retrieve(Object key) {
+    public CompletableFuture<?> retrieve(Object key) {
         RFuture<Object> f = map.getAsync(key);
         return f.thenApply(value -> {
             if (value == null) {
@@ -175,7 +175,7 @@ CompletableFuture<?> retrieve(Object key) {
         }).toCompletableFuture();
     }
 
-    <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {
+    public <T> CompletableFuture<T> retrieve(Object key, Supplier<CompletableFuture<T>> valueLoader) {
         return retrieve(key).thenCompose(v -> {
             if (v != null) {
                 return CompletableFuture.completedFuture((T) v);

File: redisson/src/main/java/org/redisson/client/RedisConnection.java
Patch:
@@ -303,6 +303,9 @@ private void closeInternal() {
         } else {
             RFuture<Void> f = async(RedisCommands.QUIT);
             f.whenComplete((res, e) -> {
+                if (redisClient.isShutdown()) {
+                    return;
+                }
                 channel.close();
             });
         }

File: redisson/src/main/java/org/redisson/command/RedisQueuedBatchExecutor.java
Patch:
@@ -99,8 +99,6 @@ protected void releaseConnection(CompletableFuture<R> attemptPromise, Completabl
         if (RedisCommands.EXEC.getName().equals(command.getName())
                 || RedisCommands.DISCARD.getName().equals(command.getName())) {
             super.releaseConnection(attemptPromise, connectionFuture);
-        } else {
-            connectionManager.getServiceManager().getShutdownLatch().release();
         }
     }
     

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -334,7 +334,7 @@ private void checkState(SentinelServersConfig cfg, Iterator<RedisClient> iterato
             f.thenAccept(r -> scheduleChangeCheck(cfg, null));
             return;
         }
-        if (!serviceManager.getShutdownLatch().acquire()) {
+        if (serviceManager.isShuttingDown()) {
             return;
         }
 
@@ -348,7 +348,6 @@ private void checkState(SentinelServersConfig cfg, Iterator<RedisClient> iterato
         connectionFuture.whenComplete((connection, e) -> {
             if (e != null) {
                 lastException.set(e);
-                serviceManager.getShutdownLatch().release();
                 checkState(cfg, iterator, lastException);
                 return;
             }
@@ -377,7 +376,6 @@ private void updateState(SentinelServersConfig cfg, RedisConnection connection,
                 log.error("Can't execute SENTINEL commands on {}", connection.getRedisClient().getAddr(), e);
             }
 
-            serviceManager.getShutdownLatch().release();
             if (e != null) {
                 scheduleChangeCheck(cfg, iterator);
             } else {

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -406,6 +406,9 @@ protected void decode(ByteBuf in, CommandData<Object, Object> data, List<Object>
             } else if (error.startsWith("WAIT")) {
                 data.tryFailure(new RedisWaitException(error
                         + ". channel: " + channel + " data: " + data));
+            } else if (error.startsWith("READONLY")) {
+                data.tryFailure(new RedisReadonlyException(error
+                        + ". channel: " + channel + " data: " + data));
             }else {
                 if (data != null) {
                     data.tryFailure(new RedisException(error + ". channel: " + channel + " command: " + LogHelper.toString(data)));

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -570,7 +570,8 @@ protected void checkAttemptPromise(CompletableFuture<R> attemptFuture, Completab
                 }
             }
 
-            if (cause instanceof RedisRetryException) {
+            if (cause instanceof RedisRetryException
+                    || cause instanceof RedisReadonlyException) {
                 if (attempt < attempts) {
                     onException();
                     connectionManager.getServiceManager().newTimeout(timeout -> {

File: redisson/src/main/java/org/redisson/pubsub/PublishSubscribeService.java
Patch:
@@ -407,7 +407,7 @@ private CompletableFuture<PubSubConnectionEntry> subscribe(PubSubType type, Code
         Timeout lockTimeout = connectionManager.getServiceManager().newTimeout(t -> {
             promise.completeExceptionally(new RedisTimeoutException(
                     "Unable to acquire subscription lock after " + timeout + "ms. " +
-                            "Try to increase 'timeout', 'subscriptionsPerConnection', 'subscriptionConnectionPoolSize' parameters."));
+                            "Try to increase 'subscriptionTimeout', 'subscriptionsPerConnection', 'subscriptionConnectionPoolSize' parameters."));
         }, timeout, TimeUnit.MILLISECONDS);
         lock.acquire().thenAccept(r -> {
             if (!lockTimeout.cancel() || promise.isDone()) {

File: redisson/src/main/java/org/redisson/api/RQueue.java
Patch:
@@ -58,10 +58,7 @@ public interface RQueue<V> extends Queue<V>, RExpirable, RQueueAsync<V> {
      * @see org.redisson.api.ExpiredObjectListener
      * @see org.redisson.api.DeletedObjectListener
      * @see org.redisson.api.listener.ListAddListener
-     * @see org.redisson.api.listener.ListInsertListener
-     * @see org.redisson.api.listener.ListSetListener
      * @see org.redisson.api.listener.ListRemoveListener
-     * @see org.redisson.api.listener.ListTrimListener
      *
      * @param listener - object event listener
      * @return listener id

File: redisson/src/main/java/org/redisson/api/RQueueReactive.java
Patch:
@@ -84,10 +84,7 @@ public interface RQueueReactive<V> extends RCollectionReactive<V> {
      * @see org.redisson.api.ExpiredObjectListener
      * @see org.redisson.api.DeletedObjectListener
      * @see org.redisson.api.listener.ListAddListener
-     * @see org.redisson.api.listener.ListInsertListener
-     * @see org.redisson.api.listener.ListSetListener
      * @see org.redisson.api.listener.ListRemoveListener
-     * @see org.redisson.api.listener.ListTrimListener
      *
      * @param listener - object event listener
      * @return listener id

File: redisson/src/main/java/org/redisson/api/RQueueRx.java
Patch:
@@ -85,10 +85,7 @@ public interface RQueueRx<V> extends RCollectionRx<V> {
      * @see org.redisson.api.ExpiredObjectListener
      * @see org.redisson.api.DeletedObjectListener
      * @see org.redisson.api.listener.ListAddListener
-     * @see org.redisson.api.listener.ListInsertListener
-     * @see org.redisson.api.listener.ListSetListener
      * @see org.redisson.api.listener.ListRemoveListener
-     * @see org.redisson.api.listener.ListTrimListener
      *
      * @param listener - object event listener
      * @return listener id

File: redisson/src/main/java/org/redisson/api/listener/ListInsertListener.java
Patch:
@@ -18,7 +18,7 @@
 import org.redisson.api.ObjectListener;
 
 /**
- * Redisson Object Event listener for <b>lset</b> event published by Redis.
+ * Redisson Object Event listener for <b>linsert</b> event published by Redis.
  * <p>
  * Redis notify-keyspace-events setting should contain El letters
  *

File: redisson/src/main/java/org/redisson/RedissonSetCache.java
Patch:
@@ -1191,7 +1191,7 @@ public RFuture<Boolean> addIfAbsentAsync(Duration ttl, V object) {
                             "return 0; " +
                         "end; " +
 
-                        "redis.call('zadd', KEYS[1], ARGV[2], ARGV[1]); " +
+                        "redis.call('zadd', KEYS[1], ARGV[2], ARGV[3]); " +
                         "return 1; ",
                 Arrays.asList(getRawName()),
                 System.currentTimeMillis(), timeoutDate, encode(object));

File: redisson/src/main/java/org/redisson/RedissonSetCache.java
Patch:
@@ -1191,7 +1191,7 @@ public RFuture<Boolean> addIfAbsentAsync(Duration ttl, V object) {
                             "return 0; " +
                         "end; " +
 
-                        "redis.call('zadd', KEYS[1], ARGV[2], ARGV[1]); " +
+                        "redis.call('zadd', KEYS[1], ARGV[2], ARGV[3]); " +
                         "return 1; ",
                 Arrays.asList(getRawName()),
                 System.currentTimeMillis(), timeoutDate, encode(object));

File: redisson/src/test/java/org/redisson/RedissonSemaphoreTest.java
Patch:
@@ -83,7 +83,7 @@ public void testAddPermits() throws InterruptedException {
 
     @Test
     public void testReducePermits() throws InterruptedException {
-        RSemaphore s = redisson.getSemaphore("test");
+        RSemaphore s = redisson.getSemaphore("test2");
         s.trySetPermits(10);
         
         s.acquire(10);

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -539,7 +539,9 @@ public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {
             if (timeoutInNanos < quietPeriod) {
                 quietPeriod = 0;
             }
-            serviceManager.getGroup().shutdownGracefully(unit.toNanos(quietPeriod), timeoutInNanos, TimeUnit.NANOSECONDS).syncUninterruptibly();
+            serviceManager.getGroup()
+                    .shutdownGracefully(unit.toNanos(quietPeriod), timeoutInNanos, TimeUnit.NANOSECONDS)
+                    .awaitUninterruptibly(timeoutInNanos, TimeUnit.NANOSECONDS);
         }
 
         serviceManager.getTimer().stop();

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -195,6 +195,9 @@ public final void connect() {
                 }
                 doConnect(new HashSet<>(), u -> null);
                 return;
+            } catch (IllegalArgumentException e) {
+                shutdown();
+                throw e;
             } catch (Exception e) {
                 if (i == attempts - 1) {
                     lastAttempt = false;

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -420,7 +420,7 @@ protected void decode(ByteBuf in, CommandData<Object, Object> data, List<Object>
             ByteBuf buf = readBytes(in);
             Object result = null;
             if (buf != null) {
-                buf.skipBytes(3);
+                buf.skipBytes(4);
                 Decoder<Object> decoder = selectDecoder(data, parts);
                 result = decoder.decode(buf, state());
             }

File: redisson/src/test/java/org/redisson/RedissonBatchTest.java
Patch:
@@ -175,7 +175,7 @@ public void testConnectionLeak(BatchOptions batchOptions) {
                 });
             }
 
-            Awaitility.await().atMost(13, TimeUnit.SECONDS).until(() -> {
+            Awaitility.await().atMost(14, TimeUnit.SECONDS).until(() -> {
                 return counter.get() == 0;
             });
             Assertions.assertThat(hasErrors).isTrue();

File: redisson/src/test/java/org/redisson/executor/RedissonScheduledExecutorServiceTest.java
Patch:
@@ -119,7 +119,7 @@ public void testScheduleAtFixedRate() throws InterruptedException {
 
         long start2 = list.get(5);
         list.stream().skip(6).limit(15).reduce(start2, (r, e) -> {
-            assertThat(e - r).isBetween(160L, 310L);
+            assertThat(e - r).isBetween(160L, 380L);
             return e;
         });
     }
@@ -231,7 +231,7 @@ void finish(Invocation invocation, String requestId, boolean removeTask) {
         long start = System.currentTimeMillis();
         RExecutorFuture<?> f = executor.schedule(new IncrementRunnableTask("counter"), 1, TimeUnit.SECONDS);
         f.toCompletableFuture().join();
-        assertThat(System.currentTimeMillis() - start).isBetween(900L, 1300L);
+        assertThat(System.currentTimeMillis() - start).isBetween(900L, 1350L);
         assertThat(redisson.getAtomicLong("counter").get()).isEqualTo(1);
         Thread.sleep(2000);
         node.shutdown();

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterKeyCommands.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
@@ -64,7 +65,7 @@ public Mono<List<ByteBuffer>> keys(RedisClusterNode node, ByteBuffer pattern) {
 
     @Override
     public Mono<ByteBuffer> randomKey(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<byte[]> m = executorService.reactive(() -> {
             return executorService.readRandomAsync(entry, ByteArrayCodec.INSTANCE, RedisCommands.RANDOM_KEY);
         });

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterServerCommands.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.List;
 import java.util.Properties;
 
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.RedisStrictCommand;
@@ -126,7 +127,7 @@ public Mono<Long> time(RedisClusterNode node) {
     
     @Override
     public Flux<RedisClientInfo> getClientList(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<List<String>> m = executorService.reactive(() -> {
             return executorService.readAsync(entry, StringCodec.INSTANCE, RedisCommands.CLIENT_LIST);
         });

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterKeyCommands.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
@@ -66,7 +67,7 @@ public Mono<List<ByteBuffer>> keys(RedisClusterNode node, ByteBuffer pattern) {
 
     @Override
     public Mono<ByteBuffer> randomKey(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<byte[]> m = executorService.reactive(() -> {
             return executorService.readRandomAsync(entry, ByteArrayCodec.INSTANCE, RedisCommands.RANDOM_KEY);
         });

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterServerCommands.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.List;
 import java.util.Properties;
 
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.RedisStrictCommand;
@@ -126,7 +127,7 @@ public Mono<Long> time(RedisClusterNode node) {
     
     @Override
     public Flux<RedisClientInfo> getClientList(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<List<String>> m = executorService.reactive(() -> {
             return executorService.readAsync(entry, StringCodec.INSTANCE, RedisCommands.CLIENT_LIST);
         });

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterKeyCommands.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
@@ -66,7 +67,7 @@ public Mono<List<ByteBuffer>> keys(RedisClusterNode node, ByteBuffer pattern) {
 
     @Override
     public Mono<ByteBuffer> randomKey(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<byte[]> m = executorService.reactive(() -> {
             return executorService.readRandomAsync(entry, ByteArrayCodec.INSTANCE, RedisCommands.RANDOM_KEY);
         });

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterServerCommands.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.List;
 import java.util.Properties;
 
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.RedisStrictCommand;
@@ -126,7 +127,7 @@ public Mono<Long> time(RedisClusterNode node) {
     
     @Override
     public Flux<RedisClientInfo> getClientList(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<List<String>> m = executorService.reactive(() -> {
             return executorService.readAsync(entry, StringCodec.INSTANCE, RedisCommands.CLIENT_LIST);
         });

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterKeyCommands.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
@@ -66,7 +67,7 @@ public Mono<List<ByteBuffer>> keys(RedisClusterNode node, ByteBuffer pattern) {
 
     @Override
     public Mono<ByteBuffer> randomKey(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<byte[]> m = executorService.reactive(() -> {
             return executorService.readRandomAsync(entry, ByteArrayCodec.INSTANCE, RedisCommands.RANDOM_KEY);
         });

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterServerCommands.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.List;
 import java.util.Properties;
 
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.RedisStrictCommand;
@@ -126,7 +127,7 @@ public Mono<Long> time(RedisClusterNode node) {
     
     @Override
     public Flux<RedisClientInfo> getClientList(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<List<String>> m = executorService.reactive(() -> {
             return executorService.readAsync(entry, StringCodec.INSTANCE, RedisCommands.CLIENT_LIST);
         });

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterKeyCommands.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
@@ -66,7 +67,7 @@ public Mono<List<ByteBuffer>> keys(RedisClusterNode node, ByteBuffer pattern) {
 
     @Override
     public Mono<ByteBuffer> randomKey(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<byte[]> m = executorService.reactive(() -> {
             return executorService.readRandomAsync(entry, ByteArrayCodec.INSTANCE, RedisCommands.RANDOM_KEY);
         });

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterServerCommands.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.List;
 import java.util.Properties;
 
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.RedisStrictCommand;
@@ -126,7 +127,7 @@ public Mono<Long> time(RedisClusterNode node) {
     
     @Override
     public Flux<RedisClientInfo> getClientList(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<List<String>> m = executorService.reactive(() -> {
             return executorService.readAsync(entry, StringCodec.INSTANCE, RedisCommands.CLIENT_LIST);
         });

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterKeyCommands.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
@@ -66,7 +67,7 @@ public Mono<List<ByteBuffer>> keys(RedisClusterNode node, ByteBuffer pattern) {
 
     @Override
     public Mono<ByteBuffer> randomKey(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<byte[]> m = executorService.reactive(() -> {
             return executorService.readRandomAsync(entry, ByteArrayCodec.INSTANCE, RedisCommands.RANDOM_KEY);
         });

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterServerCommands.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.List;
 import java.util.Properties;
 
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.RedisStrictCommand;
@@ -126,7 +127,7 @@ public Mono<Long> time(RedisClusterNode node) {
     
     @Override
     public Flux<RedisClientInfo> getClientList(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<List<String>> m = executorService.reactive(() -> {
             return executorService.readAsync(entry, StringCodec.INSTANCE, RedisCommands.CLIENT_LIST);
         });

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterKeyCommands.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
@@ -66,7 +67,7 @@ public Mono<List<ByteBuffer>> keys(RedisClusterNode node, ByteBuffer pattern) {
 
     @Override
     public Mono<ByteBuffer> randomKey(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<byte[]> m = executorService.reactive(() -> {
             return executorService.readRandomAsync(entry, ByteArrayCodec.INSTANCE, RedisCommands.RANDOM_KEY);
         });

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterServerCommands.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.List;
 import java.util.Properties;
 
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.RedisStrictCommand;
@@ -126,7 +127,7 @@ public Mono<Long> time(RedisClusterNode node) {
     
     @Override
     public Flux<RedisClientInfo> getClientList(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<List<String>> m = executorService.reactive(() -> {
             return executorService.readAsync(entry, StringCodec.INSTANCE, RedisCommands.CLIENT_LIST);
         });

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterKeyCommands.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
@@ -66,7 +67,7 @@ public Mono<List<ByteBuffer>> keys(RedisClusterNode node, ByteBuffer pattern) {
 
     @Override
     public Mono<ByteBuffer> randomKey(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<byte[]> m = executorService.reactive(() -> {
             return executorService.readRandomAsync(entry, ByteArrayCodec.INSTANCE, RedisCommands.RANDOM_KEY);
         });

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterServerCommands.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.List;
 import java.util.Properties;
 
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.RedisStrictCommand;
@@ -143,7 +144,7 @@ public Mono<Long> time(RedisClusterNode node) {
     
     @Override
     public Flux<RedisClientInfo> getClientList(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<List<String>> m = executorService.reactive(() -> {
             return executorService.readAsync(entry, StringCodec.INSTANCE, RedisCommands.CLIENT_LIST);
         });

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterKeyCommands.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
@@ -66,7 +67,7 @@ public Mono<List<ByteBuffer>> keys(RedisClusterNode node, ByteBuffer pattern) {
 
     @Override
     public Mono<ByteBuffer> randomKey(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<byte[]> m = executorService.reactive(() -> {
             return executorService.readRandomAsync(entry, ByteArrayCodec.INSTANCE, RedisCommands.RANDOM_KEY);
         });

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterServerCommands.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.List;
 import java.util.Properties;
 
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.RedisStrictCommand;
@@ -143,7 +144,7 @@ public Mono<Long> time(RedisClusterNode node) {
     
     @Override
     public Flux<RedisClientInfo> getClientList(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<List<String>> m = executorService.reactive(() -> {
             return executorService.readAsync(entry, StringCodec.INSTANCE, RedisCommands.CLIENT_LIST);
         });

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterKeyCommands.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
@@ -66,7 +67,7 @@ public Mono<List<ByteBuffer>> keys(RedisClusterNode node, ByteBuffer pattern) {
 
     @Override
     public Mono<ByteBuffer> randomKey(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<byte[]> m = executorService.reactive(() -> {
             return executorService.readRandomAsync(entry, ByteArrayCodec.INSTANCE, RedisCommands.RANDOM_KEY);
         });

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterServerCommands.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.List;
 import java.util.Properties;
 
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.RedisStrictCommand;
@@ -143,7 +144,7 @@ public Mono<Long> time(RedisClusterNode node) {
     
     @Override
     public Flux<RedisClientInfo> getClientList(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<List<String>> m = executorService.reactive(() -> {
             return executorService.readAsync(entry, StringCodec.INSTANCE, RedisCommands.CLIENT_LIST);
         });

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/RedissonReactiveClusterServerCommands.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.List;
 import java.util.Properties;
 
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.RedisStrictCommand;
@@ -143,7 +144,7 @@ public Mono<Long> time(RedisClusterNode node) {
     
     @Override
     public Flux<RedisClientInfo> getClientList(RedisClusterNode node) {
-        MasterSlaveEntry entry = getEntry(node);
+        RedisClient entry = getEntry(node);
         Mono<List<String>> m = executorService.reactive(() -> {
             return executorService.readAsync(entry, StringCodec.INSTANCE, RedisCommands.CLIENT_LIST);
         });

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -228,6 +228,9 @@ public MasterSlaveEntry getEntry(InetSocketAddress address) {
             if (addr.getAddress().equals(address.getAddress()) && addr.getPort() == address.getPort()) {
                 return entry;
             }
+            if (entry.hasSlave(address)) {
+                return entry;
+            }
         }
         return null;
     }

File: redisson/src/main/java/org/redisson/command/CommandAsyncExecutor.java
Patch:
@@ -121,7 +121,7 @@ public interface CommandAsyncExecutor {
 
     <T, R> RFuture<R> readRandomAsync(Codec codec, RedisCommand<T> command, Object... params);
 
-    <T, R> RFuture<R> readRandomAsync(MasterSlaveEntry entry, Codec codec, RedisCommand<T> command, Object... params);
+    <T, R> RFuture<R> readRandomAsync(RedisClient client, Codec codec, RedisCommand<T> command, Object... params);
 
     <V, R> RFuture<R> async(boolean readOnlyMode, NodeSource source, Codec codec,
                             RedisCommand<V> command, Object[] params, boolean ignoreRedirect, boolean noRetry);

File: redisson/src/main/java/org/redisson/connection/MasterSlaveEntry.java
Patch:
@@ -428,7 +428,7 @@ public Collection<ClientConnectionsEntry> getAllEntries() {
         return Collections.unmodifiableCollection(client2Entry.values());
     }
 
-    private ClientConnectionsEntry getEntry(InetSocketAddress address) {
+    public ClientConnectionsEntry getEntry(InetSocketAddress address) {
         InetSocketAddress masterAddr = masterEntry.getClient().getAddr();
         if (masterAddr.getAddress().equals(address.getAddress()) && masterAddr.getPort() == address.getPort()) {
             return masterEntry;

File: redisson/src/main/java/org/redisson/jcache/JCacheManager.java
Patch:
@@ -286,7 +286,7 @@ public JCacheStatisticsMXBean getStatBean(JCache<?, ?> cache) {
     
     private String getName(String name, JCache<?, ?> cache) {
         return "javax.cache:type=Cache" + name + ",CacheManager="
-                + cache.getCacheManager().getURI().toString().replaceAll(",|:|=|\n", ".") 
+                + cache.getURI().toString().replaceAll(",|:|=|\n", ".")
                 + ",Cache=" + cache.getRawName().replaceAll(",|:|=|\n", ".");
     }
     

File: redisson/src/main/java/org/redisson/redisnode/RedissonBaseNodes.java
Patch:
@@ -74,8 +74,7 @@ protected RedisNode getNode(String address, NodeType nodeType) {
         RedisURI addr = new RedisURI(address);
         for (MasterSlaveEntry masterSlaveEntry : entries) {
             if (nodeType == NodeType.MASTER
-                    && masterSlaveEntry.getAllEntries().isEmpty()
-                        && addr.equals(masterSlaveEntry.getClient().getAddr())) {
+                    && addr.equals(masterSlaveEntry.getClient().getAddr())) {
                 return new RedisNode(masterSlaveEntry.getClient(), commandExecutor, NodeType.MASTER);
             }
 

File: redisson/src/main/java/org/redisson/redisnode/RedissonBaseNodes.java
Patch:
@@ -52,10 +52,10 @@ protected <T extends org.redisson.api.redisnode.RedisNode> Collection<T> getNode
         Collection<MasterSlaveEntry> entries = connectionManager.getEntrySet();
         List<T> result = new ArrayList<>();
         for (MasterSlaveEntry masterSlaveEntry : entries) {
-            if (masterSlaveEntry.getAllEntries().isEmpty()
-                    && type == NodeType.MASTER) {
+            if (type == NodeType.MASTER) {
                 RedisNode entry = new RedisNode(masterSlaveEntry.getClient(), commandExecutor, NodeType.MASTER);
                 result.add((T) entry);
+                continue;
             }
 
             for (ClientConnectionsEntry slaveEntry : masterSlaveEntry.getAllEntries()) {

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -524,9 +524,10 @@ protected void completeResponse(CommandData<Object, Object> data, Object result)
 
     protected MultiDecoder<Object> messageDecoder(CommandData<Object, Object> data, List<Object> parts) {
         if (data == null) {
-            if (parts.isEmpty()) {
-                return null;
+            if (!parts.isEmpty()) {
+                log.error("No decoder found for decoding: {}", parts);
             }
+            return null;
         }
         return data.getCommand().getReplayMultiDecoder();
     }

File: redisson/src/test/java/org/redisson/RedissonBatchTest.java
Patch:
@@ -364,7 +364,7 @@ public void testSyncSlavesAOF(BatchOptions batchOptions) {
         GenericContainer<?> redisClusterContainer =
                 new GenericContainer<>("vishnunair/docker-redis-cluster")
                         .withExposedPorts(6379, 6380, 6381, 6382, 6383, 6384)
-                        .withStartupCheckStrategy(new MinimumDurationRunningStartupCheckStrategy(Duration.ofSeconds(10)));
+                        .withStartupCheckStrategy(new MinimumDurationRunningStartupCheckStrategy(Duration.ofSeconds(15)));
         redisClusterContainer.start();
 
         Config config = new Config();

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -868,8 +868,8 @@ public Map decode(List parts, State state) {
                     new ListFirstObjectDecoder(new EmptyMapConvertor()),
                     new ObjectMapReplayDecoder(true, new CompositeCodec(DoubleCodec.INSTANCE, StringCodec.INSTANCE))));
 
-    RedisStrictCommand<Void> FT_DICTADD = new RedisStrictCommand<>("FT.DICTADD", new VoidReplayConvertor());
-    RedisStrictCommand<Void> FT_DICTDEL = new RedisStrictCommand<>("FT.DICTDEL", new VoidReplayConvertor());
+    RedisStrictCommand<Long> FT_DICTADD = new RedisStrictCommand<>("FT.DICTADD");
+    RedisStrictCommand<Long> FT_DICTDEL = new RedisStrictCommand<>("FT.DICTDEL");
 
     RedisStrictCommand<List<String>> FT_DICTDUMP = new RedisStrictCommand<>("FT.DICTDUMP", new StringListReplayDecoder());
 

File: redisson/src/main/java/org/redisson/connection/ServiceManager.java
Patch:
@@ -282,7 +282,8 @@ public EventLoopGroup getGroup() {
 
     public CompletableFuture<List<RedisURI>> resolveAll(RedisURI uri) {
         if (uri.isIP()) {
-            return CompletableFuture.completedFuture(Collections.singletonList(uri));
+            RedisURI mappedUri = toURI(uri.getScheme(), uri.getHost(), "" + uri.getPort());
+            return CompletableFuture.completedFuture(Collections.singletonList(mappedUri));
         }
 
         AddressResolver<InetSocketAddress> resolver = resolverGroup.getResolver(group.next());

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -856,9 +856,6 @@ private CompletableFuture<Collection<ClusterPartition>> parsePartitions(List<Clu
                     index = r.nextInt(addresses.size());
                 }
 
-                log.debug("resolved hostname: {} ips: {} index: {} amount: {}",
-                        clusterNodeInfo.getAddress(), addresses, index, addresses.size());
-
                 RedisURI address = addresses.get(index);
 
                 if (clusterNodeInfo.containsFlag(Flag.SLAVE)) {

File: redisson/src/test/java/org/redisson/RedissonStreamTest.java
Patch:
@@ -536,7 +536,7 @@ public void testAutogenerateStreamSequenceId() {
         stream.add(id,StreamAddArgs.entries(entry2));
         
         Map<StreamMessageId, Map<String, String>> r = stream.range(10, StreamMessageId.MIN, StreamMessageId.MAX);
-        System.out.println("r:" + r);
+
         assertThat(r).size().isEqualTo(2);
         assertThat(r.keySet()).containsExactly(
             new StreamMessageId(1,0),new StreamMessageId(1,1)

File: redisson/src/main/java/org/redisson/api/StreamMessageId.java
Patch:
@@ -130,6 +130,7 @@ public boolean equals(Object obj) {
     }
     
     @Override
+    @SuppressWarnings("AvoidInlineConditionals")
     public String toString() {
         if (this == NEVER_DELIVERED) {
             return ">";

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -849,7 +849,7 @@ private CompletableFuture<Collection<ClusterPartition>> parsePartitions(List<Clu
                 int index = 0;
                 if (addresses.size() > 1) {
                     addresses.sort(Comparator.comparing(RedisURI::getHost));
-                    Random r = new Random(serviceManager.getId().hashCode());
+                    SplittableRandom r = new SplittableRandom(serviceManager.getId().hashCode());
                     index = r.nextInt(addresses.size());
                 }
                 RedisURI address = addresses.get(index);

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -846,7 +846,7 @@ private CompletableFuture<Collection<ClusterPartition>> parsePartitions(List<Clu
 
             CompletableFuture<List<RedisURI>> ipsFuture = serviceManager.resolveAll(clusterNodeInfo.getAddress());
             CompletableFuture<Void> f = ipsFuture.thenAccept(addresses -> {
-                if (addresses.size() > 1 && clusterNodeInfo.containsFlag(Flag.MASTER)) {
+                if (addresses.size() > 1) {
                     addresses.sort(Comparator.comparing(RedisURI::getHost));
                     Collections.shuffle(addresses, new Random(serviceManager.getId().hashCode()));
                 }

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -847,7 +847,7 @@ private CompletableFuture<Collection<ClusterPartition>> parsePartitions(List<Clu
             CompletableFuture<List<RedisURI>> ipsFuture = serviceManager.resolveAll(clusterNodeInfo.getAddress());
             CompletableFuture<Void> f = ipsFuture.thenAccept(addresses -> {
                 if (addresses.size() > 1 && clusterNodeInfo.containsFlag(Flag.MASTER)) {
-                    addresses.sort(null);
+                    addresses.sort(Comparator.comparing(RedisURI::getHost));
                     Collections.shuffle(addresses, new Random(serviceManager.getId().hashCode()));
                 }
                 RedisURI address = addresses.get(0);

File: redisson/src/main/java/org/redisson/client/handler/PingConnectionHandler.java
Patch:
@@ -62,7 +62,8 @@ private void sendPing(ChannelHandlerContext ctx) {
         RFuture<String> future;
         CommandData<?, ?> currentCommand = connection.getCurrentCommand();
         if (connection.getUsage() == 0 && (currentCommand == null || !currentCommand.isBlockingCommand())) {
-            future = connection.async(config.getPingConnectionInterval() / 2, StringCodec.INSTANCE, RedisCommands.PING);
+            int timeout = Math.max(config.getCommandTimeout(), config.getPingConnectionInterval() / 2);
+            future = connection.async(timeout, StringCodec.INSTANCE, RedisCommands.PING);
         } else {
             future = null;
         }

File: redisson/src/test/java/org/redisson/RedissonSpinLockTest.java
Patch:
@@ -6,6 +6,7 @@
 import org.redisson.api.RFuture;
 import org.redisson.api.RLock;
 import org.redisson.api.RedissonClient;
+import org.redisson.client.RedisException;
 import org.redisson.client.WriteRedisConnectionException;
 import org.redisson.config.Config;
 import org.testcontainers.containers.GenericContainer;
@@ -65,7 +66,7 @@ public void testRedisFailed() {
         config.useSingleServer().setAddress("redis://127.0.0.1:" + redis.getFirstMappedPort());
         RedissonClient redisson = Redisson.create(config);
 
-        Assertions.assertThrows(WriteRedisConnectionException.class, () -> {
+        Assertions.assertThrows(RedisException.class, () -> {
 
             RLock lock = redisson.getSpinLock("myLock");
             // kill RedisServer while main thread is sleeping.

File: redisson/src/main/java/org/redisson/connection/ServiceManager.java
Patch:
@@ -473,7 +473,8 @@ private <T> void execute(AtomicInteger attempts, CompletableFuture<T> result, Su
         CompletionStage<T> future = supplier.get();
         future.whenComplete((r, e) -> {
             if (e != null) {
-                if (e.getCause().getMessage().equals("None of slaves were synced")) {
+                if (e.getCause().getMessage() != null
+                        && e.getCause().getMessage().equals("None of slaves were synced")) {
                     if (attempts.decrementAndGet() < 0) {
                         result.completeExceptionally(e);
                         return;

File: redisson/src/test/java/org/redisson/RedissonLockTest.java
Patch:
@@ -185,7 +185,7 @@ public void testRedisFailed() {
         config.useSingleServer().setAddress("redis://127.0.0.1:" + redis.getFirstMappedPort());
         RedissonClient redisson = Redisson.create(config);
 
-        Assertions.assertThrows(WriteRedisConnectionException.class, () -> {
+        Assertions.assertThrows(RedisException.class, () -> {
 
             RLock lock = redisson.getLock("myLock");
             // kill RedisServer while main thread is sleeping.

File: redisson-micronaut/redisson-micronaut-40/src/test/java/org/redisson/micronaut/RedissonSessionTest.java
Patch:
@@ -179,7 +179,7 @@ public void testSessionCreate() throws ExecutionException, InterruptedException
         Optional<RedissonSession> noSession = sessionStore.findSession(saved.getId()).get();
         assertThat(noSession).isEmpty();
 
-        Thread.sleep(11000);
+        Thread.sleep(15000);
 
         assertThat(rc.getKeys().count()).isZero();
 

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -2914,7 +2914,7 @@ public RedisListCommands listCommands() {
 
     @Override
     public RedisSetCommands setCommands() {
-        return null;
+        return this;
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -2915,7 +2915,7 @@ public RedisListCommands listCommands() {
 
     @Override
     public RedisSetCommands setCommands() {
-        return null;
+        return this;
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -2915,7 +2915,7 @@ public RedisListCommands listCommands() {
 
     @Override
     public RedisSetCommands setCommands() {
-        return null;
+        return this;
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -2822,7 +2822,7 @@ public int addListener(MapEntryListener listener) {
 
     protected RTopic getTopic(String name) {
         if (getSubscribeService().isShardingSupported()) {
-            return new RedissonShardedTopic(topicCodec, commandExecutor, name);
+            return RedissonShardedTopic.createRaw(topicCodec, commandExecutor, name);
         }
         return RedissonTopic.createRaw(topicCodec, commandExecutor, name);
     }

File: redisson/src/main/java/org/redisson/cache/LocalCacheListener.java
Patch:
@@ -145,7 +145,7 @@ public void add(Map<CacheKey, ? extends CacheValue> cache) {
         this.cache = cache;
 
         if (isSharded) {
-            invalidationTopic = new RedissonShardedTopic(LocalCachedMessageCodec.INSTANCE, commandExecutor, getInvalidationTopicName());
+            invalidationTopic = RedissonShardedTopic.createRaw(LocalCachedMessageCodec.INSTANCE, commandExecutor, getInvalidationTopicName());
         } else {
             invalidationTopic = RedissonTopic.createRaw(LocalCachedMessageCodec.INSTANCE, commandExecutor, getInvalidationTopicName());
         }

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -112,7 +112,7 @@ public void doConnect(Set<RedisURI> disconnectedSlaves, Function<RedisURI, Strin
                     throw new RedisConnectionException("Master node is undefined! SENTINEL GET-MASTER-ADDR-BY-NAME command returns empty result!");
                 }
 
-                InetSocketAddress masterHost = serviceManager.resolve(master).join();
+                InetSocketAddress masterHost = resolveIP(master.getHost(), String.valueOf(master.getPort())).join();
                 RedisURI masterUri = toURI(masterHost);
                 if (!master.isIP()) {
                     uri2hostname.put(masterUri, master.getHost());

File: redisson/src/main/java/org/redisson/connection/ServiceManager.java
Patch:
@@ -380,9 +380,8 @@ public CompletableFuture<RedisURI> resolveIP(String scheme, RedisURI address) {
     public CompletableFuture<InetSocketAddress> resolve(RedisURI address) {
         if (address.isIP()) {
             try {
-                RedisURI uri = natMapper.map(address);
-                InetAddress ip = InetAddress.getByName(uri.getHost());
-                InetSocketAddress addr = new InetSocketAddress(InetAddress.getByAddress(uri.getHost(), ip.getAddress()), uri.getPort());
+                InetAddress ip = InetAddress.getByName(address.getHost());
+                InetSocketAddress addr = new InetSocketAddress(InetAddress.getByAddress(address.getHost(), ip.getAddress()), address.getPort());
                 return CompletableFuture.completedFuture(addr);
             } catch (UnknownHostException e) {
                 throw new IllegalArgumentException(e);

File: redisson/src/test/java/org/redisson/RedissonTopicTest.java
Patch:
@@ -1470,7 +1470,7 @@ public void testReattachInClusterMaster2() throws Exception {
                 .addNode(master3, slave3);
         ClusterProcesses process = clusterRunner.run();
 
-        Thread.sleep(5000);
+        Thread.sleep(7000);
 
         Config config = new Config();
         config.useClusterServers()

File: redisson/src/test/java/org/redisson/rx/RedissonMapCacheRxTest.java
Patch:
@@ -187,7 +187,7 @@ public void onExpired(EntryEvent<String, String> event) {
             }
         }).blockingGet();
 
-        Awaitility.await().atMost(Duration.ofSeconds(6)).untilAsserted(() -> {
+        Awaitility.await().atMost(Duration.ofSeconds(7)).untilAsserted(() -> {
             assertThat(received).isTrue();
             assertThat(cache.size().blockingGet()).isZero();
         });

File: redisson/src/test/java/org/redisson/RedissonSemaphoreTest.java
Patch:
@@ -190,7 +190,7 @@ public void run() {
         t.start();
         t.join(1);
 
-        Awaitility.await().between(Duration.ofMillis(900), Duration.ofMillis(1020)).untilAsserted(() -> {
+        Awaitility.await().between(Duration.ofMillis(900), Duration.ofMillis(1200)).untilAsserted(() -> {
             assertThat(s.tryAcquire(4, 2, TimeUnit.SECONDS)).isTrue();
         });
 

File: redisson/src/main/java/org/redisson/BaseRedissonList.java
Patch:
@@ -308,7 +308,7 @@ private RFuture<ScanResult<Object>> distributedScanIteratorAsync(String iterator
                     + "start_index = 0;"
                 + "end;"
                 + "if start_index == -1 then "
-                    + "return {0, {}};"
+                    + "return {'0', {}};"
                 + "end;"
                 + "local end_index = start_index + ARGV[1];"
                 + "local result; "
@@ -317,8 +317,8 @@ private RFuture<ScanResult<Object>> distributedScanIteratorAsync(String iterator
                     + "end_index = -1;"
                 + "end; "
                 + "redis.call('setex', KEYS[2], 3600, end_index);"
-                + "return {end_index, result};",
-                Arrays.<Object>asList(getRawName(), iteratorName), count);
+                + "return {tostring(end_index), result};",
+                Arrays.asList(getRawName(), iteratorName), count);
     }
 
     public RFuture<List<V>> getAsync(int... indexes) {

File: redisson/src/main/java/org/redisson/RedissonScoredSortedSet.java
Patch:
@@ -1046,7 +1046,7 @@ private RFuture<ScanResult<Object>> distributedScanIteratorAsync(String iterator
                     + "cursor = 0;"
                 + "end;"
                 + "if cursor == -1 then "
-                    + "return {0, {}}; "
+                    + "return {'0', {}}; "
                 + "end;"
                 + "local result; "
                 + "if (#ARGV == 2) then "
@@ -1066,8 +1066,8 @@ private RFuture<ScanResult<Object>> distributedScanIteratorAsync(String iterator
                         + "table.insert(res, result[2][i-1]); "
                     + "end; "
                 + "end;"
-                + "return {result[1], res};",
-                Arrays.<Object>asList(getRawName(), iteratorName), args.toArray());
+                + "return {tostring(result[1]), res};",
+                Arrays.asList(getRawName(), iteratorName), args.toArray());
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonTimeSeries.java
Patch:
@@ -916,7 +916,7 @@ public RFuture<ListScanResult<Object>> scanIteratorAsync(String name, RedisClien
                     "nextPos = 0;" +
                   "end;"
 
-                + "return {nextPos, result};",
+                + "return {tostring(nextPos), result};",
                 Arrays.asList(name, getTimeoutSetName()),
                 params.toArray());
     }

File: redisson/src/main/java/org/redisson/iterator/BaseIterator.java
Patch:
@@ -32,7 +32,7 @@
 public abstract class BaseIterator<V, E> implements Iterator<V> {
 
     private Iterator<E> lastIter;
-    protected String nextIterPos;
+    protected String nextIterPos = "0";
     protected RedisClient client;
 
     private boolean finished;

File: redisson/src/main/java/org/redisson/RedissonLiveObjectService.java
Patch:
@@ -713,9 +713,11 @@ public <K> Iterable<K> findIds(Class<?> entityClass, int count) {
 
         RedisCommand<ListScanResult<String>> command = new RedisCommand<>("SCAN",
                 new ListMultiDecoder2(new ListScanResultReplayDecoder(), new ObjectListReplayDecoder<Object>()), new Convertor<Object>() {
+            int index;
             @Override
             public Object convert(Object obj) {
-                if (!(obj instanceof String)) {
+                index++;
+                if (index == 1) {
                     return obj;
                 }
                 return namingScheme.resolveId(obj.toString());

File: redisson/src/main/java/org/redisson/RedissonSet.java
Patch:
@@ -161,7 +161,7 @@ private RFuture<ScanResult<Object>> distributedScanIteratorAsync(String iterator
                     + "cursor = 0;"
                 + "end;"
                 + "if cursor == -1 then "
-                    + "return {0, {}}; "
+                    + "return {'0', {}}; "
                 + "end;"
                 + "local result; "
                 + "if (#ARGV == 2) then "

File: redisson/src/main/java/org/redisson/RedissonSortedSet.java
Patch:
@@ -427,7 +427,7 @@ private RFuture<ScanResult<Object>> distributedScanIteratorAsync(String iterator
                     + "start_index = 0;"
                 + "end;"
                 + "if start_index == -1 then "
-                    + "return {0, {}}; "
+                    + "return {'0', {}}; "
                 + "end;"
                 + "local end_index = start_index + ARGV[1];"
                 + "local result; "
@@ -436,7 +436,7 @@ private RFuture<ScanResult<Object>> distributedScanIteratorAsync(String iterator
                     + "end_index = -1;"
                 + "end; "
                 + "redis.call('setex', KEYS[2], 3600, end_index);"
-                + "return {end_index, result};",
+                + "return {tostring(end_index), result};",
                 Arrays.asList(list.getRawName(), iteratorName), count);
     }
 

File: redisson/src/main/java/org/redisson/rx/RedissonKeysRx.java
Patch:
@@ -68,7 +68,7 @@ private Publisher<String> createKeysIterator(MasterSlaveEntry entry, String patt
 
             private RedisClient client;
             private List<String> firstValues;
-            private String nextIterPos;
+            private String nextIterPos = "0";
             
             private long currentIndex;
             

File: redisson/src/main/java/org/redisson/rx/RedissonMapRxIterator.java
Patch:
@@ -50,7 +50,7 @@ public Flowable<M> create() {
         ReplayProcessor<M> p = ReplayProcessor.create();
         return p.doOnRequest(new LongConsumer() {
 
-            private String nextIterPos;
+            private String nextIterPos = "0";
             private RedisClient client;
             private AtomicLong elementsRead = new AtomicLong();
             

File: redisson/src/main/java/org/redisson/rx/SetRxIterator.java
Patch:
@@ -36,7 +36,7 @@ public Flowable<V> create() {
         ReplayProcessor<V> p = ReplayProcessor.create();
         return p.doOnRequest(new LongConsumer() {
             
-            private String nextIterPos;
+            private String nextIterPos = "0";
             private RedisClient client;
             private AtomicLong elementsRead = new AtomicLong();
             

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -222,7 +222,7 @@ protected void doConnect(Set<RedisURI> disconnectedSlaves, Function<RedisURI, St
             String hostname = hostnameMapper.apply(uri);
             CompletableFuture<RedisClient> masterFuture = masterSlaveEntry.setupMasterEntry(uri, hostname);
             try {
-                masterFuture.get(config.getConnectTimeout(), TimeUnit.MILLISECONDS);
+                masterFuture.get(config.getConnectTimeout()*config.getMasterConnectionMinimumIdleSize(), TimeUnit.MILLISECONDS);
             } catch (InterruptedException e) {
                 Thread.currentThread().interrupt();
             } catch (ExecutionException | TimeoutException e) {
@@ -232,7 +232,7 @@ protected void doConnect(Set<RedisURI> disconnectedSlaves, Function<RedisURI, St
             if (!config.isSlaveNotUsed()) {
                 CompletableFuture<Void> fs = masterSlaveEntry.initSlaveBalancer(disconnectedSlaves, hostnameMapper);
                 try {
-                    fs.get(config.getConnectTimeout(), TimeUnit.MILLISECONDS);
+                    fs.get(config.getConnectTimeout()*config.getSlaveConnectionMinimumIdleSize(), TimeUnit.MILLISECONDS);
                 } catch (InterruptedException e) {
                     Thread.currentThread().interrupt();
                 } catch (ExecutionException | TimeoutException e) {

File: redisson/src/test/java/org/redisson/RedissonSearchTest.java
Patch:
@@ -313,7 +313,9 @@ public void testVector() {
                         .distance(VectorDistParam.DistanceMetric.COSINE),
                 FieldIndex.text("$.content").as("content"));
 
-        SearchResult r = s.search("text_index", "*", QueryOptions.defaults());
+        SearchResult r = s.search("text_index", "*", QueryOptions.defaults()
+                                                                            .returnAttributes(new ReturnAttribute("vector", "vector11"),
+                                                                                                new ReturnAttribute("vector2", "vector22")));
         assertThat(r.getTotal()).isEqualTo(1);
     }
 

File: redisson/src/main/java/org/redisson/RedissonFuction.java
Patch:
@@ -19,6 +19,7 @@
 import org.redisson.client.codec.ByteArrayCodec;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.codec.StringCodec;
+import org.redisson.client.protocol.RedisCommand;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.command.CommandAsyncExecutor;
 import org.redisson.misc.CompletableFutureWrapper;
@@ -210,7 +211,8 @@ public <R> RFuture<R> callAsync(String key, FunctionMode mode, String name, Func
         }
         args.addAll(encode(Arrays.asList(values), codec));
         if (mode == FunctionMode.READ) {
-            return commandExecutor.readAsync(key, codec, returnType.getCommand(), args.toArray());
+            RedisCommand cmd = new RedisCommand("FCALL_RO", returnType.getCommand().getReplayMultiDecoder(), returnType.getCommand().getConvertor());
+            return commandExecutor.readAsync(key, codec, cmd, args.toArray());
         }
         return commandExecutor.writeAsync(key, codec, returnType.getCommand(), args.toArray());
     }

File: redisson/src/test/java/org/redisson/RedisDockerTest.java
Patch:
@@ -103,7 +103,7 @@ protected void testInCluster(Consumer<RedissonClient> redissonCallback) {
         if (redissonCluster == null) {
             REDIS_CLUSTER = new GenericContainer<>("vishnunair/docker-redis-cluster")
                             .withExposedPorts(6379, 6380, 6381, 6382, 6383, 6384)
-                            .withStartupCheckStrategy(new MinimumDurationRunningStartupCheckStrategy(Duration.ofSeconds(10)));
+                            .withStartupCheckStrategy(new MinimumDurationRunningStartupCheckStrategy(Duration.ofSeconds(15)));
             REDIS_CLUSTER.start();
 
             Config config = new Config();

File: redisson/src/test/java/org/redisson/RedissonFunctionTest.java
Patch:
@@ -54,7 +54,7 @@ public void testCluster() {
             testMap.put("i", "j");
             testMap.put("k", "l");
 
-            RFunction f = redisson.getFunction();
+            RFunction f = r.getFunction();
             f.flush();
             f.load("lib", "redis.register_function('myfun', function(keys, args) return args[1] end)");
 
@@ -65,7 +65,7 @@ public void testCluster() {
                 throw new RuntimeException(e);
             }
 
-            RBatch batch = redisson.createBatch();
+            RBatch batch = r.createBatch();
             RFunctionAsync function = batch.getFunction();
             for (Map.Entry<String, Object> property : testMap.entrySet()) {
                 List<Object> key = Collections.singletonList(property.getKey());

File: redisson/src/main/java/org/redisson/RedissonKeys.java
Patch:
@@ -100,7 +100,7 @@ public Iterable<String> getKeysByPattern(String pattern) {
                                                                                 new ListScanResultReplayDecoder() {
                                                                                     @Override
                                                                                     public ListScanResult<Object> decode(List<Object> parts, State state) {
-                                                                                        return new ListScanResult<>((Long) parts.get(0), (List<Object>) (Object) unmap((List<String>) parts.get(1)));
+                                                                                        return new ListScanResult<>((String) parts.get(0), (List<Object>) (Object) unmap((List<String>) parts.get(1)));
                                                                                     }
                                                                                 }, new ObjectListReplayDecoder<String>()));
 

File: redisson/src/main/java/org/redisson/ScanResult.java
Patch:
@@ -30,7 +30,7 @@ public interface ScanResult<R> {
 
     RedisClient getRedisClient();
     
-    long getPos();
+    String getPos();
     
     Collection<R> getValues();
 

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ListScanResult.java
Patch:
@@ -28,17 +28,17 @@
  */
 public class ListScanResult<V> implements ScanResult<V> {
 
-    private final long pos;
+    private final String pos;
     private final List<V> values;
     private RedisClient client;
 
-    public ListScanResult(long pos, List<V> values) {
+    public ListScanResult(String pos, List<V> values) {
         this.pos = pos;
         this.values = values;
     }
 
     @Override
-    public long getPos() {
+    public String getPos() {
         return pos;
     }
 

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ListScanResultReplayDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package org.redisson.client.protocol.decoder;
 
 import org.redisson.client.codec.Codec;
-import org.redisson.client.codec.UnsignedLongCodec;
+import org.redisson.client.codec.StringCodec;
 import org.redisson.client.handler.State;
 import org.redisson.client.protocol.Decoder;
 
@@ -31,12 +31,12 @@ public class ListScanResultReplayDecoder implements MultiDecoder<ListScanResult<
 
     @Override
     public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
-        return UnsignedLongCodec.INSTANCE.getValueDecoder();
+        return StringCodec.INSTANCE.getValueDecoder();
     }
     
     @Override
     public ListScanResult<Object> decode(List<Object> parts, State state) {
-        return new ListScanResult<Object>((Long) parts.get(0), (List<Object>) parts.get(1));
+        return new ListScanResult<>((String) parts.get(0), (List<Object>) parts.get(1));
     }
 
 }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/MapCacheKeyScanResult.java
Patch:
@@ -30,11 +30,11 @@
 public class MapCacheKeyScanResult<K> implements ScanResult<K> {
 
     private final List<K> idleKeys;
-    private final long pos;
+    private final String pos;
     private final List<K> keys;
     private RedisClient client;
 
-    public MapCacheKeyScanResult(long pos, List<K> keys, List<K> idleKeys) {
+    public MapCacheKeyScanResult(String pos, List<K> keys, List<K> idleKeys) {
         super();
         this.pos = pos;
         this.keys = keys;
@@ -47,7 +47,7 @@ public Collection<K> getValues() {
     }
 
     @Override
-    public long getPos() {
+    public String getPos() {
         return pos;
     }
 

File: redisson/src/main/java/org/redisson/client/protocol/decoder/MapCacheKeyScanResultDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package org.redisson.client.protocol.decoder;
 
 import org.redisson.client.codec.Codec;
-import org.redisson.client.codec.UnsignedLongCodec;
+import org.redisson.client.codec.StringCodec;
 import org.redisson.client.handler.State;
 import org.redisson.client.protocol.Decoder;
 
@@ -31,15 +31,15 @@ public class MapCacheKeyScanResultDecoder implements MultiDecoder<MapCacheKeySca
 
     @Override
     public MapCacheKeyScanResult<Object> decode(List<Object> parts, State state) {
-        Long pos = (Long) parts.get(0);
+        String pos = (String) parts.get(0);
         List<Object> values = (List<Object>) parts.get(1);
         List<Object> idleKeys = (List<Object>) parts.get(2);
         return new MapCacheKeyScanResult<>(pos, values, idleKeys);
     }
 
     @Override
     public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
-        return UnsignedLongCodec.INSTANCE.getValueDecoder();
+        return StringCodec.INSTANCE.getValueDecoder();
     }
 
 }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/MapCacheScanResult.java
Patch:
@@ -29,7 +29,7 @@ public class MapCacheScanResult<K, V> extends MapScanResult<K, V> {
 
     private final List<K> idleKeys;
 
-    public MapCacheScanResult(Long pos, Map<K, V> values, List<K> idleKeys) {
+    public MapCacheScanResult(String pos, Map<K, V> values, List<K> idleKeys) {
         super(pos, values);
         this.idleKeys = idleKeys;
     };

File: redisson/src/main/java/org/redisson/client/protocol/decoder/MapCacheScanResultReplayDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package org.redisson.client.protocol.decoder;
 
 import org.redisson.client.codec.Codec;
-import org.redisson.client.codec.UnsignedLongCodec;
+import org.redisson.client.codec.StringCodec;
 import org.redisson.client.handler.State;
 import org.redisson.client.protocol.Decoder;
 
@@ -32,15 +32,15 @@ public class MapCacheScanResultReplayDecoder implements MultiDecoder<MapCacheSca
 
     @Override
     public MapCacheScanResult<Object, Object> decode(List<Object> parts, State state) {
-        Long pos = (Long) parts.get(0);
+        String pos = (String) parts.get(0);
         Map<Object, Object> values = (Map<Object, Object>) parts.get(1);
         List<Object> idleKeys = (List<Object>) parts.get(2);
         return new MapCacheScanResult<Object, Object>(pos, values, idleKeys);
     }
 
     @Override
     public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
-        return UnsignedLongCodec.INSTANCE.getValueDecoder();
+        return StringCodec.INSTANCE.getValueDecoder();
     }
 
 }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/MapScanResult.java
Patch:
@@ -30,11 +30,11 @@
  */
 public class MapScanResult<K, V> implements ScanResult<Map.Entry<K, V>> {
 
-    private final long pos;
+    private final String pos;
     private final Map<K, V> values;
     private RedisClient client;
 
-    public MapScanResult(long pos, Map<K, V> values) {
+    public MapScanResult(String pos, Map<K, V> values) {
         super();
         this.pos = pos;
         this.values = values;
@@ -50,7 +50,7 @@ public Map<K, V> getMap() {
     }
     
     @Override
-    public long getPos() {
+    public String getPos() {
         return pos;
     }
 

File: redisson/src/main/java/org/redisson/client/protocol/decoder/MapScanResultReplayDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package org.redisson.client.protocol.decoder;
 
 import org.redisson.client.codec.Codec;
-import org.redisson.client.codec.UnsignedLongCodec;
+import org.redisson.client.codec.StringCodec;
 import org.redisson.client.handler.State;
 import org.redisson.client.protocol.Decoder;
 
@@ -32,12 +32,12 @@ public class MapScanResultReplayDecoder implements MultiDecoder<MapScanResult<Ob
 
     @Override
     public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
-        return UnsignedLongCodec.INSTANCE.getValueDecoder();
+        return StringCodec.INSTANCE.getValueDecoder();
     }
     
     @Override
     public MapScanResult<Object, Object> decode(List<Object> parts, State state) {
-        return new MapScanResult<Object, Object>((Long) parts.get(0), (Map<Object, Object>) parts.get(1));
+        return new MapScanResult<>((String) parts.get(0), (Map<Object, Object>) parts.get(1));
     }
 
 }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ScoredEntryScanDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package org.redisson.client.protocol.decoder;
 
 import org.redisson.client.codec.Codec;
-import org.redisson.client.codec.UnsignedLongCodec;
+import org.redisson.client.codec.StringCodec;
 import org.redisson.client.handler.State;
 import org.redisson.client.protocol.Decoder;
 import org.redisson.client.protocol.ScoredEntry;
@@ -34,7 +34,7 @@ public class ScoredEntryScanDecoder<T> implements MultiDecoder<ListScanResult<Sc
 
     @Override
     public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
-        return UnsignedLongCodec.INSTANCE.getValueDecoder();
+        return StringCodec.INSTANCE.getValueDecoder();
     }
     
     @Override
@@ -44,7 +44,7 @@ public ListScanResult<ScoredEntry<T>> decode(List<Object> parts, State state) {
         for (int i = 0; i < values.size(); i += 2) {
             result.add(new ScoredEntry<T>(((Number) values.get(i+1)).doubleValue(), (T) values.get(i)));
         }
-        return new ListScanResult<>((Long) parts.get(0), result);
+        return new ListScanResult<>((String) parts.get(0), result);
     }
 
 }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ScoredSortedSetScanReplayDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package org.redisson.client.protocol.decoder;
 
 import org.redisson.client.codec.Codec;
-import org.redisson.client.codec.UnsignedLongCodec;
+import org.redisson.client.codec.StringCodec;
 import org.redisson.client.handler.State;
 import org.redisson.client.protocol.Decoder;
 
@@ -31,7 +31,7 @@ public class ScoredSortedSetScanReplayDecoder implements MultiDecoder<ListScanRe
 
     @Override
     public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
-        return UnsignedLongCodec.INSTANCE.getValueDecoder();
+        return StringCodec.INSTANCE.getValueDecoder();
     }
     
     @Override
@@ -40,7 +40,7 @@ public ListScanResult<Object> decode(List<Object> parts, State state) {
         for (int i = 1; i < values.size(); i++) {
             values.remove(i);
         }
-        return new ListScanResult<Object>((Long) parts.get(0), values);
+        return new ListScanResult<>((String) parts.get(0), values);
     }
 
 }

File: redisson/src/main/java/org/redisson/reactive/IteratorConsumer.java
Patch:
@@ -30,7 +30,7 @@ public abstract class IteratorConsumer<V> implements LongConsumer {
 
     private final FluxSink<V> emitter;
 
-    private long nextIterPos = 0;
+    private String nextIterPos = "0";
     private RedisClient client;
 
     private final AtomicLong requested = new AtomicLong();
@@ -47,7 +47,7 @@ public void accept(long value) {
     }
 
     protected void nextValues() {
-        scanIterator(client, Long.toUnsignedString(nextIterPos)).whenComplete((res, e) -> {
+        scanIterator(client, nextIterPos).whenComplete((res, e) -> {
             if (e != null) {
                 emitter.error(e);
                 return;
@@ -62,7 +62,7 @@ protected void nextValues() {
                 requested.decrementAndGet();
             }
 
-            if (nextIterPos == 0 && !tryAgain()) {
+            if ("0".equals(nextIterPos) && !tryAgain()) {
                 emitter.complete();
                 return;
             }

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonReactiveHashCommands.java
Patch:
@@ -229,7 +229,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Entry<ByteBuffer, ByteBuffer>>>> hS
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Entry<Object, Object>> flux = Flux.create(new MapReactiveIterator<Object, Object, Entry<Object, Object>>(null, null, 0) {
                 @Override
-                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.HSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -268,7 +268,7 @@ public Flux<CommandResponse<KeyCommand, Flux<ByteBuffer>>> sScan(Publisher<KeySc
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<byte[]> flux = Flux.create(new SetReactiveIterator<byte[]>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.SSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonReactiveZSetCommands.java
Patch:
@@ -298,7 +298,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Tuple>>> zScan(Publisher<KeyScanCom
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Tuple> flux = Flux.create(new SetReactiveIterator<Tuple>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, ZSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonReactiveHashCommands.java
Patch:
@@ -229,7 +229,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Entry<ByteBuffer, ByteBuffer>>>> hS
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Entry<Object, Object>> flux = Flux.create(new MapReactiveIterator<Object, Object, Entry<Object, Object>>(null, null, 0) {
                 @Override
-                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.HSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -268,7 +268,7 @@ public Flux<CommandResponse<KeyCommand, Flux<ByteBuffer>>> sScan(Publisher<KeySc
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<byte[]> flux = Flux.create(new SetReactiveIterator<byte[]>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.SSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonReactiveZSetCommands.java
Patch:
@@ -298,7 +298,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Tuple>>> zScan(Publisher<KeyScanCom
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Tuple> flux = Flux.create(new SetReactiveIterator<Tuple>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, ZSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonReactiveHashCommands.java
Patch:
@@ -229,7 +229,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Entry<ByteBuffer, ByteBuffer>>>> hS
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Entry<Object, Object>> flux = Flux.create(new MapReactiveIterator<Object, Object, Entry<Object, Object>>(null, null, 0) {
                 @Override
-                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.HSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -268,7 +268,7 @@ public Flux<CommandResponse<KeyCommand, Flux<ByteBuffer>>> sScan(Publisher<KeySc
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<byte[]> flux = Flux.create(new SetReactiveIterator<byte[]>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.SSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonReactiveZSetCommands.java
Patch:
@@ -298,7 +298,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Tuple>>> zScan(Publisher<KeyScanCom
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Tuple> flux = Flux.create(new SetReactiveIterator<Tuple>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, ZSCAN,
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonReactiveHashCommands.java
Patch:
@@ -229,7 +229,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Entry<ByteBuffer, ByteBuffer>>>> hS
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Entry<Object, Object>> flux = Flux.create(new MapReactiveIterator<Object, Object, Entry<Object, Object>>(null, null, 0) {
                 @Override
-                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.HSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -268,7 +268,7 @@ public Flux<CommandResponse<KeyCommand, Flux<ByteBuffer>>> sScan(Publisher<KeySc
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<byte[]> flux = Flux.create(new SetReactiveIterator<byte[]>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.SSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonReactiveZSetCommands.java
Patch:
@@ -300,7 +300,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Tuple>>> zScan(Publisher<KeyScanCom
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Tuple> flux = Flux.create(new SetReactiveIterator<Tuple>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, ZSCAN,
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/RedissonReactiveHashCommands.java
Patch:
@@ -229,7 +229,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Entry<ByteBuffer, ByteBuffer>>>> hS
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Entry<Object, Object>> flux = Flux.create(new MapReactiveIterator<Object, Object, Entry<Object, Object>>(null, null, 0) {
                 @Override
-                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.HSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -268,7 +268,7 @@ public Flux<CommandResponse<KeyCommand, Flux<ByteBuffer>>> sScan(Publisher<KeySc
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<byte[]> flux = Flux.create(new SetReactiveIterator<byte[]>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.SSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/RedissonReactiveZSetCommands.java
Patch:
@@ -300,7 +300,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Tuple>>> zScan(Publisher<KeyScanCom
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Tuple> flux = Flux.create(new SetReactiveIterator<Tuple>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, ZSCAN,
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonReactiveHashCommands.java
Patch:
@@ -229,7 +229,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Entry<ByteBuffer, ByteBuffer>>>> hS
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Entry<Object, Object>> flux = Flux.create(new MapReactiveIterator<Object, Object, Entry<Object, Object>>(null, null, 0) {
                 @Override
-                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.HSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -271,7 +271,7 @@ public Flux<CommandResponse<KeyCommand, Flux<ByteBuffer>>> sScan(Publisher<KeySc
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<byte[]> flux = Flux.create(new SetReactiveIterator<byte[]>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.SSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonReactiveZSetCommands.java
Patch:
@@ -302,7 +302,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Tuple>>> zScan(Publisher<KeyScanCom
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Tuple> flux = Flux.create(new SetReactiveIterator<Tuple>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, ZSCAN,
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/RedissonReactiveHashCommands.java
Patch:
@@ -229,7 +229,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Entry<ByteBuffer, ByteBuffer>>>> hS
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Entry<Object, Object>> flux = Flux.create(new MapReactiveIterator<Object, Object, Entry<Object, Object>>(null, null, 0) {
                 @Override
-                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.HSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -271,7 +271,7 @@ public Flux<CommandResponse<KeyCommand, Flux<ByteBuffer>>> sScan(Publisher<KeySc
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<byte[]> flux = Flux.create(new SetReactiveIterator<byte[]>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.SSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/RedissonReactiveZSetCommands.java
Patch:
@@ -302,7 +302,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Tuple>>> zScan(Publisher<KeyScanCom
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Tuple> flux = Flux.create(new SetReactiveIterator<Tuple>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, ZSCAN,
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/RedissonReactiveHashCommands.java
Patch:
@@ -229,7 +229,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Entry<ByteBuffer, ByteBuffer>>>> hS
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Entry<Object, Object>> flux = Flux.create(new MapReactiveIterator<Object, Object, Entry<Object, Object>>(null, null, 0) {
                 @Override
-                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.HSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -271,7 +271,7 @@ public Flux<CommandResponse<KeyCommand, Flux<ByteBuffer>>> sScan(Publisher<KeySc
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<byte[]> flux = Flux.create(new SetReactiveIterator<byte[]>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.SSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/RedissonReactiveZSetCommands.java
Patch:
@@ -302,7 +302,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Tuple>>> zScan(Publisher<KeyScanCom
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Tuple> flux = Flux.create(new SetReactiveIterator<Tuple>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, ZSCAN,
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/RedissonReactiveHashCommands.java
Patch:
@@ -229,7 +229,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Entry<ByteBuffer, ByteBuffer>>>> hS
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Entry<Object, Object>> flux = Flux.create(new MapReactiveIterator<Object, Object, Entry<Object, Object>>(null, null, 0) {
                 @Override
-                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.HSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -271,7 +271,7 @@ public Flux<CommandResponse<KeyCommand, Flux<ByteBuffer>>> sScan(Publisher<KeySc
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<byte[]> flux = Flux.create(new SetReactiveIterator<byte[]>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.SSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/RedissonReactiveZSetCommands.java
Patch:
@@ -302,7 +302,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Tuple>>> zScan(Publisher<KeyScanCom
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Tuple> flux = Flux.create(new SetReactiveIterator<Tuple>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, ZSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/RedissonReactiveHashCommands.java
Patch:
@@ -229,7 +229,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Entry<ByteBuffer, ByteBuffer>>>> hS
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Entry<Object, Object>> flux = Flux.create(new MapReactiveIterator<Object, Object, Entry<Object, Object>>(null, null, 0) {
                 @Override
-                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.HSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -271,7 +271,7 @@ public Flux<CommandResponse<KeyCommand, Flux<ByteBuffer>>> sScan(Publisher<KeySc
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<byte[]> flux = Flux.create(new SetReactiveIterator<byte[]>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.SSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-32/src/main/java/org/redisson/spring/data/connection/RedissonReactiveZSetCommands.java
Patch:
@@ -302,7 +302,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Tuple>>> zScan(Publisher<KeyScanCom
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Tuple> flux = Flux.create(new SetReactiveIterator<Tuple>() {
                 @Override
-                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, ZSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson/src/main/java/org/redisson/BaseRedissonList.java
Patch:
@@ -286,7 +286,7 @@ public Iterator<V> distributedIterator(final String iteratorName, final int coun
         return new RedissonBaseIterator<V>() {
 
             @Override
-            protected ScanResult<Object> iterator(RedisClient client, long nextIterPos) {
+            protected ScanResult<Object> iterator(RedisClient client, String nextIterPos) {
                 return distributedScanIterator(iteratorName, count);
             }
 

File: redisson/src/main/java/org/redisson/RedissonKeys.java
Patch:
@@ -143,7 +143,7 @@ public Iterable<String> getKeys(int count) {
         return getKeysByPattern(null, count);
     }
 
-    private RFuture<ScanResult<Object>> scanIteratorAsync(RedisClient client, MasterSlaveEntry entry, RedisCommand<?> command, long startPos,
+    private RFuture<ScanResult<Object>> scanIteratorAsync(RedisClient client, MasterSlaveEntry entry, RedisCommand<?> command, String startPos,
                                                              String pattern, int count) {
         if (pattern == null) {
             return commandExecutor.readAsync(client, entry, StringCodec.INSTANCE, command, startPos, "COUNT",
@@ -155,7 +155,7 @@ private RFuture<ScanResult<Object>> scanIteratorAsync(RedisClient client, Master
                 pattern, "COUNT", count);
     }
 
-    public RFuture<ScanResult<Object>> scanIteratorAsync(RedisClient client, MasterSlaveEntry entry, long startPos,
+    public RFuture<ScanResult<Object>> scanIteratorAsync(RedisClient client, MasterSlaveEntry entry, String startPos,
             String pattern, int count) {
         return scanIteratorAsync(client, entry, scan, startPos, pattern, count);
     }
@@ -164,7 +164,7 @@ private <T> Iterator<T> createKeysIterator(MasterSlaveEntry entry, RedisCommand<
         return new RedissonBaseIterator<T>() {
 
             @Override
-            protected ScanResult<Object> iterator(RedisClient client, long nextIterPos) {
+            protected ScanResult<Object> iterator(RedisClient client, String nextIterPos) {
                 return commandExecutor
                         .get(RedissonKeys.this.scanIteratorAsync(client, entry, command, nextIterPos, pattern, count));
             }

File: redisson/src/main/java/org/redisson/RedissonListMultimapValues.java
Patch:
@@ -364,7 +364,7 @@ public Iterator<V> distributedIterator(final String iteratorName, final int coun
         return new RedissonBaseIterator<V>() {
 
             @Override
-            protected ScanResult<Object> iterator(RedisClient client, long nextIterPos) {
+            protected ScanResult<Object> iterator(RedisClient client, String nextIterPos) {
                 return distributedScanIterator(iteratorName, count);
             }
 

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -1919,7 +1919,7 @@ protected RFuture<Long> fastRemoveOperationAsync(K... keys) {
     }
 
     @Override
-    public RFuture<ScanResult<Object>> scanKeyIteratorAsync(String name, RedisClient client, long startPos, String pattern, int count) {
+    public RFuture<ScanResult<Object>> scanKeyIteratorAsync(String name, RedisClient client, String startPos, String pattern, int count) {
         List<Object> params = new ArrayList<>();
         params.add(System.currentTimeMillis());
         params.add(startPos);
@@ -2013,7 +2013,7 @@ public RFuture<ScanResult<Object>> scanKeyIteratorAsync(String name, RedisClient
                         new ObjectMapDecoder(true)));
 
     @Override
-    public RFuture<ScanResult<Map.Entry<Object, Object>>> scanIteratorAsync(String name, RedisClient client, long startPos, String pattern, int count) {
+    public RFuture<ScanResult<Map.Entry<Object, Object>>> scanIteratorAsync(String name, RedisClient client, String startPos, String pattern, int count) {
         List<Object> params = new ArrayList<Object>();
         params.add(System.currentTimeMillis());
         params.add(startPos);

File: redisson/src/main/java/org/redisson/RedissonMultiMapIterator.java
Patch:
@@ -73,7 +73,7 @@ public boolean hasNext() {
 
         while (true) {
             if (!keysFinished && (keysIter == null || !keysIter.hasNext())) {
-                MapScanResult<Object, Object> res = map.scanIterator(client, keysIterPos);
+                MapScanResult<Object, Object> res = map.scanIterator(client, Long.toUnsignedString(keysIterPos));
                 client = res.getRedisClient();
                 keysIter = res.getMap().entrySet().iterator();
                 keysIterPos = res.getPos();

File: redisson/src/main/java/org/redisson/RedissonMultimap.java
Patch:
@@ -396,7 +396,7 @@ public RFuture<Integer> keySizeAsync() {
     }
     
     
-    MapScanResult<Object, Object> scanIterator(RedisClient client, long startPos) {
+    MapScanResult<Object, Object> scanIterator(RedisClient client, String startPos) {
         RFuture<MapScanResult<Object, Object>> f = commandExecutor.readAsync(client, getRawName(), new CompositeCodec(codec, StringCodec.INSTANCE, codec), RedisCommands.HSCAN, getRawName(), startPos);
         return get(f);
     }
@@ -421,7 +421,7 @@ protected Object put(Entry<Object, Object> entry, Object value) {
                 }
 
                 @Override
-                protected ScanResult<Entry<Object, Object>> iterator(RedisClient client, long nextIterPos) {
+                protected ScanResult<Entry<Object, Object>> iterator(RedisClient client, String nextIterPos) {
                     return RedissonMultimap.this.scanIterator(client, nextIterPos);
                 }
 

File: redisson/src/main/java/org/redisson/RedissonSetMultimapValues.java
Patch:
@@ -175,7 +175,7 @@ public RFuture<Boolean> containsAsync(Object o) {
          System.currentTimeMillis(), encodeMapKey(key), encodeMapValue(o));
     }
 
-    private ListScanResult<Object> scanIterator(RedisClient client, long startPos, String pattern, int count) {
+    private ListScanResult<Object> scanIterator(RedisClient client, String startPos, String pattern, int count) {
         List<Object> params = new ArrayList<Object>();
         params.add(System.currentTimeMillis());
         params.add(startPos);
@@ -235,7 +235,7 @@ public Iterator<V> distributedIterator(final String iteratorName, final String p
         return new RedissonBaseIterator<V>() {
 
             @Override
-            protected ScanResult<Object> iterator(RedisClient client, long nextIterPos) {
+            protected ScanResult<Object> iterator(RedisClient client, String nextIterPos) {
                 return distributedScanIterator(iteratorName, pattern, count);
             }
 
@@ -300,7 +300,7 @@ public Iterator<V> iterator(final String pattern, final int count) {
         return new RedissonBaseIterator<V>() {
 
             @Override
-            protected ListScanResult<Object> iterator(RedisClient client, long nextIterPos) {
+            protected ListScanResult<Object> iterator(RedisClient client, String nextIterPos) {
                 return scanIterator(client, nextIterPos, pattern, count);
             }
 

File: redisson/src/main/java/org/redisson/RedissonSortedSet.java
Patch:
@@ -403,7 +403,7 @@ public Iterator<V> distributedIterator(final String iteratorName, final int coun
         return new RedissonBaseIterator<V>() {
 
             @Override
-            protected ScanResult<Object> iterator(RedisClient client, long nextIterPos) {
+            protected ScanResult<Object> iterator(RedisClient client, String nextIterPos) {
                 return distributedScanIterator(iteratorName, count);
             }
 

File: redisson/src/main/java/org/redisson/RedissonTimeSeries.java
Patch:
@@ -889,12 +889,12 @@ private <T> RFuture<T> pollEntriesAsync(int startScore, int limit, RedisCommand<
     }
 
 
-    public ListScanResult<Object> scanIterator(String name, RedisClient client, long startPos, int count) {
+    public ListScanResult<Object> scanIterator(String name, RedisClient client, String startPos, int count) {
         RFuture<ListScanResult<Object>> f = scanIteratorAsync(name, client, startPos, count);
         return get(f);
     }
 
-    public RFuture<ListScanResult<Object>> scanIteratorAsync(String name, RedisClient client, long startPos, int count) {
+    public RFuture<ListScanResult<Object>> scanIteratorAsync(String name, RedisClient client, String startPos, int count) {
         List<Object> params = new ArrayList<>();
         params.add(startPos);
         params.add(System.currentTimeMillis());
@@ -926,7 +926,7 @@ public Iterator<V> iterator(int count) {
         return new RedissonBaseIterator<V>() {
 
             @Override
-            protected ListScanResult<Object> iterator(RedisClient client, long nextIterPos) {
+            protected ListScanResult<Object> iterator(RedisClient client, String nextIterPos) {
                 return scanIterator(getRawName(), client, nextIterPos, count);
             }
 

File: redisson/src/main/java/org/redisson/ScanIterator.java
Patch:
@@ -25,9 +25,9 @@
  */
 public interface ScanIterator {
 
-    ScanResult<Object> scanIterator(String name, RedisClient client, long startPos, String pattern, int count);
+    ScanResult<Object> scanIterator(String name, RedisClient client, String startPos, String pattern, int count);
 
-    RFuture<ScanResult<Object>> scanIteratorAsync(String name, RedisClient client, long startPos, String pattern, int count);
+    RFuture<ScanResult<Object>> scanIteratorAsync(String name, RedisClient client, String startPos, String pattern, int count);
     
     boolean remove(Object value);
     

File: redisson/src/main/java/org/redisson/client/protocol/decoder/MapCacheKeyScanResultDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package org.redisson.client.protocol.decoder;
 
 import org.redisson.client.codec.Codec;
-import org.redisson.client.codec.LongCodec;
+import org.redisson.client.codec.UnsignedLongCodec;
 import org.redisson.client.handler.State;
 import org.redisson.client.protocol.Decoder;
 
@@ -39,7 +39,7 @@ public MapCacheKeyScanResult<Object> decode(List<Object> parts, State state) {
 
     @Override
     public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
-        return LongCodec.INSTANCE.getValueDecoder();
+        return UnsignedLongCodec.INSTANCE.getValueDecoder();
     }
 
 }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ScoredEntryScanDecoder.java
Patch:
@@ -16,7 +16,7 @@
 package org.redisson.client.protocol.decoder;
 
 import org.redisson.client.codec.Codec;
-import org.redisson.client.codec.LongCodec;
+import org.redisson.client.codec.UnsignedLongCodec;
 import org.redisson.client.handler.State;
 import org.redisson.client.protocol.Decoder;
 import org.redisson.client.protocol.ScoredEntry;
@@ -34,7 +34,7 @@ public class ScoredEntryScanDecoder<T> implements MultiDecoder<ListScanResult<Sc
 
     @Override
     public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
-        return LongCodec.INSTANCE.getValueDecoder();
+        return UnsignedLongCodec.INSTANCE.getValueDecoder();
     }
     
     @Override

File: redisson/src/main/java/org/redisson/iterator/BaseIterator.java
Patch:
@@ -58,14 +58,14 @@ public boolean hasNext() {
             do {
                 ScanResult<E> res;
                 try {
-                    res = iterator(client, nextIterPos);
+                    res = iterator(client, Long.toUnsignedString(nextIterPos));
                 } catch (RedisNodeNotFoundException e) {
                     if (client != null) {
                         client = null;
                         nextIterPos = 0;
                     }
                     reset();
-                    res = iterator(client, nextIterPos);
+                    res = iterator(client, Long.toUnsignedString(nextIterPos));
                 }
                 
                 client = res.getRedisClient();
@@ -96,7 +96,7 @@ protected boolean tryAgain() {
         return false;
     }
 
-    protected abstract ScanResult<E> iterator(RedisClient client, long nextIterPos);
+    protected abstract ScanResult<E> iterator(RedisClient client, String nextIterPos);
 
     @Override
     public V next() {

File: redisson/src/main/java/org/redisson/iterator/RedissonMapIterator.java
Patch:
@@ -45,7 +45,7 @@ protected Object put(Entry<Object, Object> entry, Object value) {
     }
 
     @Override
-    protected ScanResult<Entry<Object, Object>> iterator(RedisClient client, long nextIterPos) {
+    protected ScanResult<Entry<Object, Object>> iterator(RedisClient client, String nextIterPos) {
         return map.scanIterator(map.getRawName(), client, nextIterPos, pattern, count);
     }
 

File: redisson/src/main/java/org/redisson/iterator/RedissonMapKeyIterator.java
Patch:
@@ -38,7 +38,7 @@ public RedissonMapKeyIterator(RedissonMap map, String pattern, int count) {
     }
 
     @Override
-    protected ScanResult<M> iterator(RedisClient client, long nextIterPos) {
+    protected ScanResult<M> iterator(RedisClient client, String nextIterPos) {
         return map.scanKeyIterator(map.getRawName(), client, nextIterPos, pattern, count);
     }
 

File: redisson/src/main/java/org/redisson/jcache/JCache.java
Patch:
@@ -2952,7 +2952,7 @@ public RFuture<Void> removeAllAsync(Set<? extends K> keys) {
         return new CompletableFutureWrapper<>(f);
     }
 
-    MapScanResult<Object, Object> scanIterator(String name, RedisClient client, long startPos) {
+    MapScanResult<Object, Object> scanIterator(String name, RedisClient client, String startPos) {
         RFuture<MapScanResult<Object, Object>> f
             = commandExecutor.readAsync(client, name, codec, RedisCommands.HSCAN, name, startPos, "COUNT", 50);
         try {
@@ -2981,7 +2981,7 @@ protected Object put(Map.Entry<Object, Object> entry, Object value) {
 
             @Override
             protected ScanResult<Map.Entry<Object, Object>> iterator(RedisClient client,
-                                                                     long nextIterPos) {
+                                                                     String nextIterPos) {
                 return JCache.this.scanIterator(JCache.this.getRawName(), client, nextIterPos);
             }
         };
@@ -3343,7 +3343,7 @@ protected Object put(Map.Entry<Object, Object> entry, Object value) {
 
             @Override
             protected ScanResult<Map.Entry<Object, Object>> iterator(RedisClient client,
-                                                                     long nextIterPos) {
+                                                                     String nextIterPos) {
                 return JCache.this.scanIterator(JCache.this.getRawName(), client, nextIterPos);
             }
 

File: redisson/src/main/java/org/redisson/reactive/IteratorConsumer.java
Patch:
@@ -47,7 +47,7 @@ public void accept(long value) {
     }
 
     protected void nextValues() {
-        scanIterator(client, nextIterPos).whenComplete((res, e) -> {
+        scanIterator(client, Long.toUnsignedString(nextIterPos)).whenComplete((res, e) -> {
             if (e != null) {
                 emitter.error(e);
                 return;
@@ -77,6 +77,6 @@ protected Object transformValue(Object value) {
 
     protected abstract boolean tryAgain();
 
-    protected abstract RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos);
+    protected abstract RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos);
 
 }

File: redisson/src/main/java/org/redisson/reactive/MapReactiveIterator.java
Patch:
@@ -59,7 +59,7 @@ protected Object transformValue(Object value) {
             }
 
             @Override
-            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                 return MapReactiveIterator.this.scanIterator(client, nextIterPos);
             }
         });
@@ -80,7 +80,7 @@ public V setValue(V value) {
         };
     }
 
-    public RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+    public RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
         return (RFuture<ScanResult<Object>>) (Object) map.scanIteratorAsync(map.getRawName(), client, nextIterPos, pattern, count);
     }
 

File: redisson/src/main/java/org/redisson/reactive/RedissonKeysReactive.java
Patch:
@@ -63,7 +63,7 @@ public Flux<String> getKeysByPattern(String pattern, int count) {
         return Flux.merge(publishers);
     }
 
-    private Flux<String> createKeysIterator(final MasterSlaveEntry entry, final String pattern, final int count) {
+    private Flux<String> createKeysIterator(MasterSlaveEntry entry, String pattern, int count) {
         return Flux.create(emitter -> emitter.onRequest(new IteratorConsumer<String>(emitter) {
 
             @Override
@@ -72,7 +72,7 @@ protected boolean tryAgain() {
             }
 
             @Override
-            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                 return instance.scanIteratorAsync(client, entry, nextIterPos, pattern, count);
             }
         }));

File: redisson/src/main/java/org/redisson/reactive/RedissonLexSortedSetReactive.java
Patch:
@@ -49,7 +49,7 @@ public RFuture<Boolean> add(Object e) {
     private Publisher<String> scanIteratorReactive(final String pattern, final int count) {
         return Flux.create(new SetReactiveIterator<String>() {
             @Override
-            protected RFuture<ScanResult<Object>> scanIterator(final RedisClient client, final long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                 return ((RedissonScoredSortedSet<String>) instance).scanIteratorAsync(client, nextIterPos, pattern, count);
             }
         });

File: redisson/src/main/java/org/redisson/reactive/RedissonScoredSortedSetReactive.java
Patch:
@@ -73,7 +73,7 @@ public RFuture<V> call() throws Exception {
     private Flux<V> scanIteratorReactive(String pattern, int count) {
         return Flux.create(new SetReactiveIterator<V>() {
             @Override
-            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                 return ((RedissonScoredSortedSet<V>) instance).scanIteratorAsync(client, nextIterPos, pattern, count);
             }
         });
@@ -102,7 +102,7 @@ public Flux<V> iterator(String pattern, int count) {
     private Flux<ScoredEntry<V>> entryScanIteratorReactive(String pattern, int count) {
         return Flux.create(new SetReactiveIterator<ScoredEntry<V>>() {
             @Override
-            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                 return ((RedissonScoredSortedSet<V>) instance).entryScanIteratorAsync(client, nextIterPos, pattern, count);
             }
         });

File: redisson/src/main/java/org/redisson/reactive/RedissonSetCacheReactive.java
Patch:
@@ -42,7 +42,7 @@ public RedissonSetCacheReactive(RSetCache<V> instance, RedissonReactiveClient re
     public Publisher<V> iterator() {
         return Flux.create(new SetReactiveIterator<V>() {
             @Override
-            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                 return ((ScanIterator) instance).scanIteratorAsync(((RedissonObject) instance).getRawName(), client, nextIterPos, null, 10);
             }
         });

File: redisson/src/main/java/org/redisson/reactive/RedissonSetReactive.java
Patch:
@@ -60,7 +60,7 @@ public Publisher<V> iterator(String pattern) {
     public Publisher<V> iterator(String pattern, int count) {
         return Flux.create(new SetReactiveIterator<V>() {
             @Override
-            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                 return ((ScanIterator) instance).scanIteratorAsync(((RedissonObject) instance).getRawName(), client, nextIterPos, pattern, count);
             }
         });

File: redisson/src/main/java/org/redisson/reactive/RedissonTimeSeriesReactive.java
Patch:
@@ -45,7 +45,7 @@ public RedissonTimeSeriesReactive(RTimeSeries<V, L> instance, RedissonReactiveCl
     public Publisher<V> iterator() {
         return Flux.create(new SetReactiveIterator<V>() {
             @Override
-            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                 return ((RedissonTimeSeries) instance).scanIteratorAsync(((RedissonObject) instance).getRawName(), client, nextIterPos, 10);
             }
         });

File: redisson/src/main/java/org/redisson/reactive/SetReactiveIterator.java
Patch:
@@ -39,7 +39,7 @@ protected boolean tryAgain() {
             }
 
             @Override
-            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                 return SetReactiveIterator.this.scanIterator(client, nextIterPos);
             }
         });
@@ -49,6 +49,6 @@ protected boolean tryAgain() {
         return false;
     }
     
-    protected abstract RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos);
+    protected abstract RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos);
 
 }

File: redisson/src/main/java/org/redisson/rx/RedissonKeysRx.java
Patch:
@@ -79,7 +79,7 @@ public void accept(long value) {
             }
             
             protected void nextValues() {
-                instance.scanIteratorAsync(client, entry, nextIterPos, pattern, count).whenComplete((res, e) -> {
+                instance.scanIteratorAsync(client, entry, Long.toUnsignedString(nextIterPos), pattern, count).whenComplete((res, e) -> {
                     if (e != null) {
                         p.onError(e);
                         return;

File: redisson/src/main/java/org/redisson/rx/RedissonLexSortedSetRx.java
Patch:
@@ -49,7 +49,7 @@ public RFuture<Boolean> add(Object e) {
     private Flowable<String> scanIteratorReactive(String pattern, int count) {
         return new SetRxIterator<String>() {
             @Override
-            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                 return ((RedissonScoredSortedSet<String>) instance).scanIteratorAsync(client, nextIterPos, pattern, count);
             }
         }.create();

File: redisson/src/main/java/org/redisson/rx/RedissonMapRxIterator.java
Patch:
@@ -68,7 +68,7 @@ public void accept(long value) throws Exception {
             }
             
             protected void nextValues() {
-                map.scanIteratorAsync(map.getRawName(), client, nextIterPos, pattern, count).whenComplete((res, e) -> {
+                map.scanIteratorAsync(map.getRawName(), client, Long.toUnsignedString(nextIterPos), pattern, count).whenComplete((res, e) -> {
                     if (e != null) {
                         p.onError(e);
                         return;

File: redisson/src/main/java/org/redisson/rx/RedissonScoredSortedSetRx.java
Patch:
@@ -41,7 +41,7 @@ public RedissonScoredSortedSetRx(RScoredSortedSetAsync<V> instance) {
     private Flowable<V> scanIteratorReactive(String pattern, int count) {
         return new SetRxIterator<V>() {
             @Override
-            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                 return ((RedissonScoredSortedSet<V>) instance).scanIteratorAsync(client, nextIterPos, pattern, count);
             }
         }.create();
@@ -78,7 +78,7 @@ public Flowable<V> iterator(String pattern, int count) {
     private Flowable<ScoredEntry<V>> entryScanIteratorReactive(String pattern, int count) {
         return new SetRxIterator<ScoredEntry<V>>() {
             @Override
-            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                 return ((RedissonScoredSortedSet<V>) instance).entryScanIteratorAsync(client, nextIterPos, pattern, count);
             }
         }.create();

File: redisson/src/main/java/org/redisson/rx/RedissonSetCacheRx.java
Patch:
@@ -42,7 +42,7 @@ public RedissonSetCacheRx(RSetCache<V> instance, RedissonRxClient redisson) {
     public Publisher<V> iterator() {
         return new SetRxIterator<V>() {
             @Override
-            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                 return ((ScanIterator) instance).scanIteratorAsync(((RedissonObject) instance).getRawName(), client, nextIterPos, null, 10);
             }
         }.create();

File: redisson/src/main/java/org/redisson/rx/RedissonSetRx.java
Patch:
@@ -61,7 +61,7 @@ public Flowable<V> iterator(String pattern) {
     public Flowable<V> iterator(String pattern, int count) {
         return new SetRxIterator<V>() {
             @Override
-            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                 return ((ScanIterator) instance).scanIteratorAsync(((RedissonObject) instance).getRawName(), client, nextIterPos, pattern, count);
             }
         }.create();

File: redisson/src/main/java/org/redisson/rx/RedissonTimeSeriesRx.java
Patch:
@@ -44,7 +44,7 @@ public RedissonTimeSeriesRx(RTimeSeries<V, L> instance, RedissonRxClient redisso
     public Publisher<V> iterator() {
         return new SetRxIterator<V>() {
             @Override
-            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos) {
                 return ((RedissonTimeSeries) instance).scanIteratorAsync(((RedissonObject) instance).getRawName(), client, nextIterPos, 10);
             }
         }.create();

File: redisson/src/main/java/org/redisson/rx/SetRxIterator.java
Patch:
@@ -54,7 +54,7 @@ public void accept(long value) {
             }
             
             protected void nextValues() {
-                scanIterator(client, nextIterPos).whenComplete((res, e) -> {
+                scanIterator(client, Long.toUnsignedString(nextIterPos)).whenComplete((res, e) -> {
                     if (e != null) {
                         p.onError(e);
                         return;
@@ -98,6 +98,6 @@ protected boolean tryAgain() {
         return false;
     }
 
-    protected abstract RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos);
+    protected abstract RFuture<ScanResult<Object>> scanIterator(RedisClient client, String nextIterPos);
 
 }

File: redisson/src/main/java/org/redisson/transaction/BaseTransactionalMap.java
Patch:
@@ -148,7 +148,7 @@ protected RFuture<Boolean> deleteAsync(CommandAsyncExecutor commandExecutor, Tra
     }
     
     protected ScanResult<Map.Entry<Object, Object>> scanIterator(String name, RedisClient client,
-            long startPos, String pattern, int count) {
+                                                                 String startPos, String pattern, int count) {
         ScanResult<Map.Entry<Object, Object>> res = ((RedissonMap<?, ?>) map).scanIterator(name, client, startPos, pattern, count);
         Map<HashValue, MapEntry> newstate = new HashMap<>(state);
         Map<Object, Object> newres = null;
@@ -172,7 +172,7 @@ protected ScanResult<Map.Entry<Object, Object>> scanIterator(String name, RedisC
             }
         }
         
-        if (startPos == 0) {
+        if ("0".equals(startPos)) {
             for (Entry<HashValue, MapEntry> entry : newstate.entrySet()) {
                 if (entry.getValue() == MapEntry.NULL) {
                     continue;

File: redisson/src/main/java/org/redisson/transaction/BaseTransactionalSet.java
Patch:
@@ -140,10 +140,10 @@ public RFuture<Boolean> containsAsync(Object value) {
     }
     
     protected abstract ScanResult<Object> scanIteratorSource(String name, RedisClient client,
-                                                             long startPos, String pattern, int count);
+                                                             String startPos, String pattern, int count);
     
     protected ScanResult<Object> scanIterator(String name, RedisClient client,
-            long startPos, String pattern, int count) {
+                                              String startPos, String pattern, int count) {
         ScanResult<Object> res = scanIteratorSource(name, client, startPos, pattern, count);
         Map<HashValue, Object> newstate = new HashMap<>(state);
         for (Iterator<Object> iterator = res.getValues().iterator(); iterator.hasNext();) {
@@ -154,7 +154,7 @@ protected ScanResult<Object> scanIterator(String name, RedisClient client,
             }
         }
         
-        if (startPos == 0) {
+        if ("0".equals(startPos)) {
             for (Entry<HashValue, Object> entry : newstate.entrySet()) {
                 if (entry.getValue() == NULL) {
                     continue;

File: redisson/src/main/java/org/redisson/transaction/RedissonTransactionalMap.java
Patch:
@@ -98,7 +98,7 @@ public <KOut, VOut> RMapReduce<K, V, KOut, VOut> mapReduce() {
     
     @Override
     public ScanResult<Map.Entry<Object, Object>> scanIterator(String name, RedisClient client,
-                                                   long startPos, String pattern, int count) {
+                                                              String startPos, String pattern, int count) {
         checkState();
         return transactionalMap.scanIterator(name, client, startPos, pattern, count);
     }

File: redisson/src/main/java/org/redisson/transaction/RedissonTransactionalMapCache.java
Patch:
@@ -148,7 +148,7 @@ public <KOut, VOut> RMapReduce<K, V, KOut, VOut> mapReduce() {
     
     @Override
     public ScanResult<Entry<Object, Object>> scanIterator(String name, RedisClient client,
-                                                          long startPos, String pattern, int count) {
+                                                          String startPos, String pattern, int count) {
         checkState();
         return transactionalMap.scanIterator(name, client, startPos, pattern, count);
     }

File: redisson/src/main/java/org/redisson/transaction/RedissonTransactionalSet.java
Patch:
@@ -88,7 +88,7 @@ public <KOut, VOut> RCollectionMapReduce<V, KOut, VOut> mapReduce() {
     }
 
     @Override
-    public ScanResult<Object> scanIterator(String name, RedisClient client, long startPos, String pattern, int count) {
+    public ScanResult<Object> scanIterator(String name, RedisClient client, String startPos, String pattern, int count) {
         checkState();
         return transactionalSet.scanIterator(name, client, startPos, pattern, count);
     }

File: redisson/src/main/java/org/redisson/transaction/RedissonTransactionalSetCache.java
Patch:
@@ -88,7 +88,7 @@ public <KOut, VOut> RCollectionMapReduce<V, KOut, VOut> mapReduce() {
     }
 
     @Override
-    public ScanResult<Object> scanIterator(String name, RedisClient client, long startPos, String pattern, int count) {
+    public ScanResult<Object> scanIterator(String name, RedisClient client, String startPos, String pattern, int count) {
         checkState();
         return transactionalSet.scanIterator(name, client, startPos, pattern, count);
     }

File: redisson/src/main/java/org/redisson/transaction/TransactionalSet.java
Patch:
@@ -48,7 +48,7 @@ public TransactionalSet(CommandAsyncExecutor commandExecutor, long timeout, List
     }
 
     @Override
-    protected ScanResult<Object> scanIteratorSource(String name, RedisClient client, long startPos,
+    protected ScanResult<Object> scanIteratorSource(String name, RedisClient client, String startPos,
                                                     String pattern, int count) {
         return ((ScanIterator) set).scanIterator(name, client, startPos, pattern, count);
     }

File: redisson/src/main/java/org/redisson/transaction/TransactionalSetCache.java
Patch:
@@ -49,7 +49,7 @@ public TransactionalSetCache(CommandAsyncExecutor commandExecutor, long timeout,
     }
 
     @Override
-    protected ScanResult<Object> scanIteratorSource(String name, RedisClient client, long startPos,
+    protected ScanResult<Object> scanIteratorSource(String name, RedisClient client, String startPos,
                                                     String pattern, int count) {
         return ((ScanIterator) set).scanIterator(name, client, startPos, pattern, count);
     }

File: redisson/src/main/java/org/redisson/connection/ServiceManager.java
Patch:
@@ -67,6 +67,7 @@
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.UnknownHostException;
+import java.nio.charset.StandardCharsets;
 import java.security.MessageDigest;
 import java.util.*;
 import java.util.concurrent.*;
@@ -453,7 +454,7 @@ public String calcSHA(String script) {
         return SHA_CACHE.computeIfAbsent(script, k -> {
             try {
                 MessageDigest mdigest = MessageDigest.getInstance("SHA-1");
-                byte[] s = mdigest.digest(script.getBytes());
+                byte[] s = mdigest.digest(script.getBytes(StandardCharsets.UTF_8));
                 return ByteBufUtil.hexDump(s);
             } catch (Exception e) {
                 throw new IllegalStateException(e);

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -193,7 +193,7 @@ public final void connect() {
                 if (i == attempts - 1) {
                     lastAttempt = true;
                 }
-                doConnect(new HashSet<>(), u -> u.getHost());
+                doConnect(new HashSet<>(), u -> null);
                 return;
             } catch (Exception e) {
                 if (i == attempts - 1) {

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -193,7 +193,7 @@ public final void connect() {
                 if (i == attempts - 1) {
                     lastAttempt = true;
                 }
-                doConnect(new HashSet<>(), RedisURI::toString);
+                doConnect(new HashSet<>(), u -> u.getHost());
                 return;
             } catch (Exception e) {
                 if (i == attempts - 1) {

File: redisson/src/main/java/org/redisson/client/handler/RedisChannelInitializer.java
Patch:
@@ -179,7 +179,7 @@ private void initSsl(RedisClientConfig config, Channel ch) throws GeneralSecurit
         SslContext sslContext = sslContextBuilder.build();
         String hostname = config.getSslHostname();
         if (hostname == null || NetUtil.createByteArrayFromIpAddressString(hostname) != null) {
-            hostname = redisClient.getAddr().getHostName();
+            hostname = config.getAddress().getHost();
         }
         
         SSLEngine sslEngine = sslContext.newEngine(ch.alloc(), hostname, config.getAddress().getPort());

File: redisson/src/test/java/org/redisson/RedisClientTest.java
Patch:
@@ -38,7 +38,7 @@ public class RedisClientTest  {
     @BeforeAll
     public static void beforeAll() {
         RedisClientConfig config = new RedisClientConfig();
-        config.setProtocol(Protocol.RESP2);
+        config.setProtocol(Protocol.RESP3);
         config.setAddress("redis://127.0.0.1:" + REDIS.getFirstMappedPort());
         redisClient = RedisClient.create(config);
     }

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -806,7 +806,7 @@ private void cancelResponseHandling(String requestId) {
             List<Result> list = entry.getResponses().remove(requestId);
             if (list != null) {
                 for (Result result : list) {
-                    result.getResponseTimeoutFuture().cancel(true);
+                    result.cancelResponseTimeout();
                 }
             }
             if (entry.getResponses().isEmpty()) {

File: redisson/src/main/java/org/redisson/RedissonPriorityBlockingQueue.java
Patch:
@@ -74,7 +74,7 @@ public RFuture<V> takeAsync() {
 
     protected <T> void takeAsync(CompletableFuture<V> result, long delay, long timeoutInMicro, RedisCommand<T> command, Object... params) {
         long start = System.currentTimeMillis();
-        commandExecutor.getServiceManager().getGroup().schedule(() -> {
+        commandExecutor.getServiceManager().newTimeout(t -> {
             RFuture<V> future = wrapLockedAsync(command, params);
             future.whenComplete((res, e) -> {
                     if (e != null && !(e instanceof RedisConnectionException)) {

File: redisson/src/main/java/org/redisson/RedissonRateLimiter.java
Patch:
@@ -134,7 +134,7 @@ private CompletableFuture<Boolean> tryAcquireAsync(long permits, long timeoutInM
             
             if (timeoutInMillis == -1) {
                 CompletableFuture<Boolean> f = new CompletableFuture<>();
-                getServiceManager().getGroup().schedule(() -> {
+                getServiceManager().newTimeout(t -> {
                     CompletableFuture<Boolean> r = tryAcquireAsync(permits, timeoutInMillis);
                     commandExecutor.transfer(r, f);
                 }, delay, TimeUnit.MILLISECONDS);
@@ -149,12 +149,12 @@ private CompletableFuture<Boolean> tryAcquireAsync(long permits, long timeoutInM
 
             CompletableFuture<Boolean> f = new CompletableFuture<>();
             if (remains < delay) {
-                getServiceManager().getGroup().schedule(() -> {
+                getServiceManager().newTimeout(t -> {
                     f.complete(false);
                 }, remains, TimeUnit.MILLISECONDS);
             } else {
                 long start = System.currentTimeMillis();
-                getServiceManager().getGroup().schedule(() -> {
+                getServiceManager().newTimeout(t -> {
                     long elapsed = System.currentTimeMillis() - start;
                     if (remains <= elapsed) {
                         f.complete(false);

File: redisson/src/main/java/org/redisson/eviction/EvictionScheduler.java
Patch:
@@ -88,8 +88,8 @@ public void schedule(String name, String timeoutSetName, String maxIdleSetName,
 
     public void remove(String name) {
         EvictionTask task = tasks.remove(name);
-        if (task != null && task.getScheduledFuture() != null) {
-            task.getScheduledFuture().cancel(false);
+        if (task != null) {
+            task.cancel();
         }
     }
 

File: redisson/src/main/java/org/redisson/executor/RedissonExecutorRemoteService.java
Patch:
@@ -97,7 +97,7 @@ protected <T> void invokeMethod(RemoteServiceRequest request, RemoteServiceMetho
         startedListeners.forEach(l -> l.onStarted(request.getId()));
 
         if (taskTimeout > 0) {
-            commandExecutor.getServiceManager().getGroup().schedule(() -> {
+            commandExecutor.getServiceManager().newTimeout(t -> {
                 cancelRequestFuture.complete(new RemoteServiceCancelRequest(true, false));
             }, taskTimeout, TimeUnit.MILLISECONDS);
         }

File: redisson-spring-data/redisson-spring-data-32/src/test/java/org/redisson/RedissonRuntimeEnvironment.java
Patch:
@@ -9,7 +9,7 @@
 public class RedissonRuntimeEnvironment {
 
     public static final boolean isTravis = "true".equalsIgnoreCase(System.getProperty("travisEnv"));
-    public static final String redisBinaryPath = System.getProperty("redisBinary", "C:\\redis\\redis-server2.cmd");
+    public static final String redisBinaryPath = System.getProperty("redisBinary", "C:\\redis\\redis-server.exe");
     public static final String tempDir = System.getProperty("java.io.tmpdir");
     public static final String OS;
     public static final boolean isWindows;

File: redisson/src/main/java/org/redisson/command/RedisQueuedBatchExecutor.java
Patch:
@@ -215,13 +215,13 @@ protected void sendCommand(CompletableFuture<R> attemptPromise, RedisConnection
     }
 
     @Override
-    protected CompletableFuture<RedisConnection> getConnection() {
+    protected CompletableFuture<RedisConnection> getConnection(CompletableFuture<R> attemptPromise) {
         MasterSlaveEntry msEntry = getEntry();
         ConnectionEntry entry = connections.computeIfAbsent(msEntry, k -> {
             if (this.options.getExecutionMode() == ExecutionMode.REDIS_WRITE_ATOMIC) {
-                connectionFuture = connectionWriteOp(null);
+                connectionFuture = connectionWriteOp(null, attemptPromise);
             } else {
-                connectionFuture = connectionReadOp(null);
+                connectionFuture = connectionReadOp(null, attemptPromise);
             }
 
             ConnectionEntry ce = new ConnectionEntry(connectionFuture);

File: redisson/src/main/java/org/redisson/connection/decoder/MapGetAllDecoder.java
Patch:
@@ -47,10 +47,10 @@ public MapGetAllDecoder(List<Object> args, int shiftIndex, boolean allowNulls) {
     @Override
     public Map<Object, Object> decode(List<Object> parts, State state) {
         if (parts.isEmpty()) {
-            return new HashMap<Object, Object>();
+            return new HashMap<>();
         }
-        Map<Object, Object> result = new LinkedHashMap<Object, Object>(parts.size());
-        for (int index = 0; index < args.size()-shiftIndex; index++) {
+        Map<Object, Object> result = new LinkedHashMap<>(parts.size());
+        for (int index = 0; index < parts.size()-shiftIndex; index++) {
             Object value = parts.get(index);
             if (!allowNulls && value == null) {
                 continue;

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -41,6 +41,7 @@
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.AtomicReferenceArray;
+import java.util.function.Function;
 import java.util.stream.Collectors;
 
 /**
@@ -80,7 +81,7 @@ protected MasterSlaveServersConfig create(BaseMasterSlaveServersConfig<?> cfg) {
     }
 
     @Override
-    public void doConnect() {
+    public void doConnect(Set<RedisURI> disconnectedSlaves, Function<RedisURI, String> hostnameMapper) {
         if (cfg.getNodeAddresses().isEmpty()) {
             throw new IllegalArgumentException("At least one cluster node should be defined!");
         }
@@ -335,7 +336,7 @@ private CompletionStage<Void> addMasterEntry(ClusterPartition partition, Cluster
                 }
 
                 if (!config.isSlaveNotUsed()) {
-                    CompletableFuture<Void> fs = entry.initSlaveBalancer(partition.getFailedSlaveAddresses(), configEndpointHostName);
+                    CompletableFuture<Void> fs = entry.initSlaveBalancer(partition.getFailedSlaveAddresses(), r -> configEndpointHostName);
                     return fs.thenAccept(r -> {
                         if (!partition.getSlaveAddresses().isEmpty()) {
                             log.info("slaves: {} added for slot ranges: {}", partition.getSlaveAddresses(), partition.getSlotRanges());

File: redisson/src/main/java/org/redisson/connection/ReplicatedConnectionManager.java
Patch:
@@ -40,6 +40,7 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Function;
 import java.util.stream.Collectors;
 
 /**
@@ -72,7 +73,7 @@ public ReplicatedConnectionManager(ReplicatedServersConfig cfg, ServiceManager s
     }
 
     @Override
-    public void doConnect() {
+    public void doConnect(Set<RedisURI> disconnectedSlaves, Function<RedisURI, String> hostnameMapper) {
         for (String address : cfg.getNodeAddresses()) {
             RedisURI addr = new RedisURI(address);
             CompletionStage<RedisConnection> connectionFuture = connectToNode(cfg, addr, addr.getHost());
@@ -105,7 +106,7 @@ public void doConnect() {
             log.warn("ReadMode = {}, but slave nodes are not found! Please specify all nodes in replicated mode.", this.config.getReadMode());
         }
 
-        super.doConnect();
+        super.doConnect(disconnectedSlaves, hostnameMapper);
 
         scheduleMasterChangeCheck(cfg);
     }

File: redisson/src/test/java/org/redisson/transaction/RedissonBaseTransactionalMapTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
-import org.redisson.BaseTest;
+import org.redisson.RedisDockerTest;
 import org.redisson.api.RMap;
 import org.redisson.api.RTransaction;
 import org.redisson.api.TransactionOptions;
@@ -17,7 +17,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public abstract class RedissonBaseTransactionalMapTest extends BaseTest {
+public abstract class RedissonBaseTransactionalMapTest extends RedisDockerTest {
 
     protected abstract RMap<String, String> getMap();
     

File: redisson/src/test/java/org/redisson/transaction/RedissonTransactionalMapCacheTest.java
Patch:
@@ -14,13 +14,13 @@
 public class RedissonTransactionalMapCacheTest extends RedissonBaseTransactionalMapTest {
 
     @Test
-    public void testSyncWait() throws IOException, InterruptedException {
+    public void testSyncWait() {
         String mapCacheName = "map";
         String dataKey = "key";
 
         Config redisConfig = new Config();
         redisConfig.useReplicatedServers()
-                .addNodeAddress(RedisRunner.getDefaultRedisServerBindAddressAndPort());
+                .addNodeAddress(redisson.getConfig().useSingleServer().getAddress());
         RedissonClient client = Redisson.create(redisConfig);
 
         RTransaction transaction = client.createTransaction(TransactionOptions.defaults());

File: redisson/src/test/java/org/redisson/RedissonFunctionTest.java
Patch:
@@ -21,14 +21,15 @@ public void testEmpty() {
     }
 
     @Test
-    public void testStats() {
+    public void testStats() throws InterruptedException {
         RFunction f = redisson.getFunction();
         f.flush();
         f.load("lib", "redis.register_function('myfun', function(keys, args) for i = 1, 88293819831, 1 do end return args[1] end)" +
                 "redis.register_function('myfun2', function(keys, args) return 'test' end)" +
                 "redis.register_function('myfun3', function(keys, args) return 123 end)");
         f.callAsync(FunctionMode.READ, "myfun", FunctionResult.VALUE, Collections.emptyList(), "test");
         try {
+            Thread.sleep(500);
             FunctionStats stats = f.stats();
             FunctionStats.RunningFunction func = stats.getRunningFunction();
             assertThat(func.getName()).isEqualTo("myfun");

File: redisson/src/main/java/org/redisson/client/handler/RedisChannelInitializer.java
Patch:
@@ -179,7 +179,7 @@ private void initSsl(RedisClientConfig config, Channel ch) throws GeneralSecurit
         SslContext sslContext = sslContextBuilder.build();
         String hostname = config.getSslHostname();
         if (hostname == null || NetUtil.createByteArrayFromIpAddressString(hostname) != null) {
-            hostname = config.getAddress().getHost();
+            hostname = redisClient.getAddr().getHostName();
         }
         
         SSLEngine sslEngine = sslContext.newEngine(ch.alloc(), hostname, config.getAddress().getPort());

File: redisson/src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -794,7 +794,7 @@ public void run() {
         slave.restart(20);
         System.out.println("slave " + slave.getRedisServerAddressAndPort() + " has been stopped!");
 
-        assertThat(latch.await(60, TimeUnit.SECONDS)).isTrue();
+        assertThat(latch.await(70, TimeUnit.SECONDS)).isTrue();
 
         int errors = 0;
         int success = 0;

File: redisson/src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -171,7 +171,7 @@ public void testResponseHandling() throws InterruptedException {
             });
         }
         e.shutdown();
-        assertThat(e.awaitTermination(30, TimeUnit.SECONDS)).isTrue();
+        assertThat(e.awaitTermination(35, TimeUnit.SECONDS)).isTrue();
         assertThat(counter.get()).isEqualTo(10000 * 100);
     }
     

File: redisson-quarkus/redisson-quarkus-30/integration-tests/src/test/java/org/redisson/quarkus/client/it/QuarkusRedissonClientResourceTest.java
Patch:
@@ -53,7 +53,7 @@ public void testDeleteBucket() {
                 .when().get("/quarkus-redisson-client/delBucket")
                 .then()
                 .statusCode(200)
-                .body(is(true));
+                .body(is("true"));
     }
 
 //    @Test

File: redisson/src/test/java/org/redisson/RedissonPermitExpirableSemaphoreTest.java
Patch:
@@ -25,6 +25,7 @@ public class RedissonPermitExpirableSemaphoreTest extends BaseConcurrentTest {
     public void testGetInClusterNameMapper() throws RedisRunner.FailedToStartRedisException, InterruptedException {
         testInCluster(client -> {
             Config config = client.getConfig();
+            config.setSlavesSyncTimeout(2000);
             config.useClusterServers()
                     .setNameMapper(new NameMapper() {
                         @Override

File: redisson/src/test/java/org/redisson/RedissonStreamTest.java
Patch:
@@ -2,7 +2,6 @@
 
 import org.awaitility.Awaitility;
 import org.junit.jupiter.api.Assertions;
-import org.junit.jupiter.api.Assumptions;
 import org.junit.jupiter.api.Test;
 import org.redisson.api.*;
 import org.redisson.api.stream.*;
@@ -33,7 +32,7 @@ public void testEmptyMap() {
     }
 
     @Test
-    public void testAutoClaim() {
+    public void testAutoClaim() throws InterruptedException {
         RStream<String, String> stream = redisson.getStream("test");
 
         stream.add(StreamAddArgs.entry("0", "0"));
@@ -52,6 +51,8 @@ public void testAutoClaim() {
         Map<StreamMessageId, Map<String, String>> s2 = stream.readGroup("testGroup", "consumer2", StreamReadGroupArgs.neverDelivered());
         assertThat(s2.size()).isEqualTo(2);
 
+        Thread.sleep(5);
+
         AutoClaimResult<String, String> res = stream.autoClaim("testGroup", "consumer1", 1, TimeUnit.MILLISECONDS, id3, 2);
         assertThat(res.getMessages().size()).isEqualTo(2);
         for (Map.Entry<StreamMessageId, Map<String, String>> entry : res.getMessages().entrySet()) {

File: redisson/src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -653,7 +653,7 @@ public void testFailoverInCluster() throws Exception {
                 .addNode(master3, slave3);
         ClusterProcesses process = clusterRunner.run();
         
-        Thread.sleep(5000); 
+        Thread.sleep(7000);
         
         Config config = new Config();
         config.useClusterServers()
@@ -758,7 +758,7 @@ public void testFailoverInClusterSlave() throws Exception {
                 .addNode(master3, slave3);
         ClusterProcesses process = clusterRunner.run();
 
-        Thread.sleep(5000);
+        Thread.sleep(7000);
 
         Config config = new Config();
         config.useClusterServers()

File: redisson/src/test/java/org/redisson/RedisDockerTest.java
Patch:
@@ -27,7 +27,7 @@ public class RedisDockerTest {
                     })
                     .withExposedPorts(6379);
 
-    protected static final Protocol protocol = Protocol.RESP3;
+    protected static final Protocol protocol = Protocol.RESP2;
 
     protected static RedissonClient redisson;
 

File: redisson/src/test/java/org/redisson/RedissonBaseMultimapCacheTest.java
Patch:
@@ -122,7 +122,7 @@ public void testScheduler() throws InterruptedException {
         
         assertThat(cache.size()).isEqualTo(6);
         
-        Thread.sleep(10000);
+        Thread.sleep(12000);
 
         assertThat(cache.size()).isZero();
 

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -903,7 +903,7 @@ public <T> RFuture<T> syncedEval(String key, Codec codec, RedisCommand<T> evalCo
                 if (getServiceManager().getCfg().isCheckLockSyncedSlaves()
                         && res.getSyncedSlaves() == 0 && availableSlaves > 0) {
                     throw new CompletionException(
-                            new IllegalStateException("None of slaves were synced"));
+                            new IllegalStateException("None of slaves were synced. Try to increase slavesSyncTimeout setting."));
                 }
 
                 return getNow(result.toCompletableFuture());

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -240,7 +240,7 @@ private void scheduleWriteTimeout(CompletableFuture<R> attemptPromise) {
         TimerTask task = timeout -> {
             if (writeFuture.cancel(false)) {
                 exception = new RedisTimeoutException("Command still hasn't been written into connection! " +
-                        "Check CPU load on the application side. Check connection with Redis node: " + connectionFuture.join().getRedisClient().getAddr() +
+                        "Check CPU usage of the JVM. Check connection with Redis node: " + connectionFuture.join().getRedisClient().getAddr() +
                         " for TCP packet drops. Try to increase nettyThreads setting. "
                         + " Node source: " + source + ", connection: " + connectionFuture.join()
                         + ", command: " + LogHelper.toString(command, params)
@@ -278,7 +278,7 @@ public void run(Timeout t) throws Exception {
                                 if (writeFuture != null && writeFuture.cancel(false)) {
                                     if (exception == null) {
                                         exception = new RedisTimeoutException("Command still hasn't been written into connection! " +
-                                                "Check CPU load on the application side. Check connection with Redis node: " + getNow(connectionFuture).getRedisClient().getAddr() +
+                                                "Check CPU usage of the JVM. Check connection with Redis node: " + getNow(connectionFuture).getRedisClient().getAddr() +
                                                 " for TCP packet drops. Try to increase nettyThreads setting. "
                                                 + " Node source: " + source + ", connection: " + getNow(connectionFuture)
                                                 + ", command: " + LogHelper.toString(command, params)
@@ -351,7 +351,7 @@ private void checkWriteFuture(ChannelFuture future, CompletableFuture<R> attempt
 
         if (!future.isSuccess()) {
             exception = new WriteRedisConnectionException(
-                    "Unable to write command into connection! Increase nettyThreads setting. Node source: "
+                    "Unable to write command into connection! Check CPU usage of the JVM. Try to increase nettyThreads setting. Node source: "
                     + source + ", connection: " + connection +
                     ", command: " + LogHelper.toString(command, params)
                     + " after " + attempt + " retry attempts", future.cause());

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -623,7 +623,7 @@ private boolean isSlaveDown(String flags, String masterLinkStatus) {
 
     private boolean isUseSameMaster(RedisURI slaveAddr, RedisURI slaveMasterAddr) {
         RedisURI master = currentMaster.get();
-        if (!master.equals(slaveMasterAddr)) {
+        if (!master.equals(slaveMasterAddr) && !slaveAddr.equals(master)) {
             log.warn("Skipped slave up {} for master {} differs from current {}", slaveAddr, slaveMasterAddr, master);
             return false;
         }

File: redisson/src/main/java/org/redisson/codec/JsonJacksonCodec.java
Patch:
@@ -65,7 +65,7 @@ public class JsonJacksonCodec extends BaseCodec {
     public static final JsonJacksonCodec INSTANCE = new JsonJacksonCodec();
 
     @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="@id")
-    @JsonAutoDetect(fieldVisibility = Visibility.ANY, 
+    @JsonAutoDetect(fieldVisibility = Visibility.NON_PRIVATE,
                     getterVisibility = Visibility.PUBLIC_ONLY, 
                     setterVisibility = Visibility.NONE, 
                     isGetterVisibility = Visibility.NONE)

File: redisson/src/main/java/org/redisson/codec/JsonJacksonCodec.java
Patch:
@@ -65,7 +65,7 @@ public class JsonJacksonCodec extends BaseCodec {
     public static final JsonJacksonCodec INSTANCE = new JsonJacksonCodec();
 
     @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="@id")
-    @JsonAutoDetect(fieldVisibility = Visibility.ANY, 
+    @JsonAutoDetect(fieldVisibility = Visibility.NON_PRIVATE,
                     getterVisibility = Visibility.PUBLIC_ONLY, 
                     setterVisibility = Visibility.NONE, 
                     isGetterVisibility = Visibility.NONE)

File: redisson/src/test/java/org/redisson/RedissonBlockingDequeReactiveTest.java
Patch:
@@ -52,7 +52,7 @@ public void onComplete() {
     @Test
     public void testPollLastAndOfferFirstTo() {
         RBlockingDequeReactive<String> blockingDeque = redisson.getBlockingDeque("blocking_deque");
-        Awaitility.await().between(Duration.ofMillis(950), Duration.ofMillis(1150)).untilAsserted(() -> {
+        Awaitility.await().between(Duration.ofMillis(950), Duration.ofMillis(1350)).untilAsserted(() -> {
             String redisTask = sync(blockingDeque.pollLastAndOfferFirstTo("deque", 1, TimeUnit.SECONDS));
             assertThat(redisTask).isNull();
         });

File: redisson/src/test/java/org/redisson/RedissonFunctionTest.java
Patch:
@@ -24,7 +24,7 @@ public void testEmpty() {
     public void testStats() {
         RFunction f = redisson.getFunction();
         f.flush();
-        f.load("lib", "redis.register_function('myfun', function(keys, args) for i = 1, 8829381983, 1 do end return args[1] end)" +
+        f.load("lib", "redis.register_function('myfun', function(keys, args) for i = 1, 88293819831, 1 do end return args[1] end)" +
                 "redis.register_function('myfun2', function(keys, args) return 'test' end)" +
                 "redis.register_function('myfun3', function(keys, args) return 123 end)");
         f.callAsync(FunctionMode.READ, "myfun", FunctionResult.VALUE, Collections.emptyList(), "test");

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -294,7 +294,7 @@ public Object decode(List<Object> parts, State state) {
     RedisCommand<Map<String, Map<Object, Double>>> BZMPOP = new RedisCommand<>("BZMPOP", ZMPOP.getReplayMultiDecoder());
     RedisCommand<List<Object>> BZMPOP_SINGLE_LIST = new RedisCommand("BZMPOP", ZMPOP_VALUES.getReplayMultiDecoder(), new EmptyListConvertor());
     RedisCommand<Object> BLPOP_VALUE = new RedisCommand<Object>("BLPOP", new ListObjectDecoder<Object>(1));
-    RedisCommand<Object> BLMOVE = new RedisCommand<Object>("BLMOVE");
+    RedisCommand<Object> BLMOVE = new RedisCommand<Object>("BLMOVE", new ListFirstObjectDecoder());
     RedisCommand<Object> BRPOP_VALUE = new RedisCommand<Object>("BRPOP", new ListObjectDecoder<Object>(1));
     RedisCommand<Object> BZPOPMIN_VALUE = new RedisCommand<Object>("BZPOPMIN", new ScoredSortedSetPolledObjectDecoder());
     RedisCommand<Object> BZPOPMAX_VALUE = new RedisCommand<Object>("BZPOPMAX", new ScoredSortedSetPolledObjectDecoder());

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ListFirstObjectDecoder.java
Patch:
@@ -18,7 +18,6 @@
 import org.redisson.client.codec.Codec;
 import org.redisson.client.handler.State;
 import org.redisson.client.protocol.Decoder;
-import org.redisson.client.protocol.ScoredEntry;
 import org.redisson.client.protocol.convertor.Convertor;
 
 import java.util.List;

File: redisson/src/main/java/org/redisson/RedissonRemoteService.java
Patch:
@@ -226,6 +226,7 @@ public <T> RFuture<Boolean> tryExecuteAsync(Class<T> remoteInterface, T object)
         return tryExecuteAsync(remoteInterface, object, -1, null);
     }
     
+    @SuppressWarnings("MethodLength")
     private <T> void subscribe(Class<T> remoteInterface, RBlockingQueue<String> requestQueue,
             ExecutorService executor, Object bean) {
         Entry entry = remoteMap.get(remoteInterface);

File: redisson/src/main/java/org/redisson/RedissonRemoteService.java
Patch:
@@ -226,6 +226,7 @@ public <T> RFuture<Boolean> tryExecuteAsync(Class<T> remoteInterface, T object)
         return tryExecuteAsync(remoteInterface, object, -1, null);
     }
     
+    @SuppressWarnings("MethodLength")
     private <T> void subscribe(Class<T> remoteInterface, RBlockingQueue<String> requestQueue,
             ExecutorService executor, Object bean) {
         Entry entry = remoteMap.get(remoteInterface);

File: redisson/src/test/java/org/redisson/RedissonBlockingDequeTest.java
Patch:
@@ -15,12 +15,10 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class RedissonBlockingDequeTest extends BaseTest {
+public class RedissonBlockingDequeTest extends RedisDockerTest {
 
     @Test
     public void testMove() {
-        Assumptions.assumeTrue(RedisRunner.getDefaultRedisServerInstance().getRedisVersion().compareTo("6.2.0") > 0);
-
         RBlockingDeque<Integer> deque1 = redisson.getBlockingDeque("deque1");
         RBlockingDeque<Integer> deque2 = redisson.getBlockingDeque("deque2");
 

File: redisson/src/test/java/org/redisson/RedissonJsonBucketTest.java
Patch:
@@ -13,7 +13,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class RedissonJsonBucketTest extends BaseTest {
+public class RedissonJsonBucketTest extends BaseStackTest {
 
     public static class NestedType {
 

File: redisson/src/test/java/org/redisson/RedissonSearchTest.java
Patch:
@@ -22,7 +22,7 @@
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class RedissonSearchTest extends BaseTest {
+public class RedissonSearchTest extends BaseStackTest {
 
     public static class SimpleObject {
 

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -282,7 +282,7 @@ public Object decode(List<Object> parts, State state) {
     RedisCommand<List<Object>> BLPOP = new RedisCommand<List<Object>>("BLPOP", new ObjectListReplayDecoder<Object>());
     RedisCommand<List<Object>> BRPOP = new RedisCommand<List<Object>>("BRPOP", new ObjectListReplayDecoder<Object>());
     RedisCommand<Map<String, Map<Object, Double>>> BZMPOP = new RedisCommand<>("BZMPOP", ZMPOP.getReplayMultiDecoder());
-    RedisCommand<List<Object>> BZMPOP_SINGLE_LIST = new RedisCommand<>("BZMPOP", ZMPOP_VALUES.getReplayMultiDecoder());
+    RedisCommand<List<Object>> BZMPOP_SINGLE_LIST = new RedisCommand("BZMPOP", ZMPOP_VALUES.getReplayMultiDecoder(), new EmptyListConvertor());
     RedisCommand<Object> BLPOP_VALUE = new RedisCommand<Object>("BLPOP", new ListObjectDecoder<Object>(1));
     RedisCommand<Object> BLMOVE = new RedisCommand<Object>("BLMOVE");
     RedisCommand<Object> BRPOP_VALUE = new RedisCommand<Object>("BRPOP", new ListObjectDecoder<Object>(1));

File: redisson/src/test/java/org/redisson/RedissonSearchTest.java
Patch:
@@ -78,13 +78,13 @@ public void testMapAggregateWithCursor() {
 
         assertThat(r3.getTotal()).isEqualTo(1);
         assertThat(r3.getCursorId()).isPositive();
-        assertThat(new HashSet<>(r3.getAttributes())).isEqualTo(new HashSet<>(Arrays.asList(m2.readAllMap())));
+        assertThat(new HashSet<>(r3.getAttributes())).isEqualTo(new HashSet<>(Arrays.asList(m.readAllMap())));
 
         AggregationResult r2 = s.readCursor("idx", r3.getCursorId());
         assertThat(r2.getTotal()).isEqualTo(1);
         assertThat(r2.getCursorId()).isPositive();
 
-        assertThat(new HashSet<>(r2.getAttributes())).isEqualTo(new HashSet<>(Arrays.asList(m.readAllMap())));
+        assertThat(new HashSet<>(r2.getAttributes())).isEqualTo(new HashSet<>(Arrays.asList(m2.readAllMap())));
 
     }
 
@@ -128,7 +128,7 @@ public void testMapAggregate() {
         AggregationResult r = s.aggregate("idx", "*", AggregationOptions.defaults()
                                                                             .load("t1", "t2"));
 
-        assertThat(r.getTotal()).isEqualTo(2);
+        assertThat(r.getTotal()).isEqualTo(1);
         assertThat(r.getCursorId()).isEqualTo(-1);
         assertThat(new HashSet<>(r.getAttributes())).isEqualTo(new HashSet<>(Arrays.asList(m2.readAllMap(), m.readAllMap())));
     }

File: redisson/src/main/java/org/redisson/RedissonPriorityDeque.java
Patch:
@@ -329,7 +329,4 @@ public RFuture<V> moveAsync(DequeMoveArgs args) {
         throw new UnsupportedOperationException();
     }
 
-    public RedissonPriorityDeque<V> reversed() {
-        throw new UnsupportedOperationException();
-    }
 }

File: redisson/src/main/java/org/redisson/RedissonPriorityQueue.java
Patch:
@@ -38,7 +38,7 @@
  *
  * @param <V> value type
  */
-public class RedissonPriorityQueue<V> extends RedissonList<V> implements RPriorityQueue<V> {
+public class RedissonPriorityQueue<V> extends BaseRedissonList<V> implements RPriorityQueue<V> {
 
     public static class BinarySearchResult<V> {
 

File: redisson/src/main/java/org/redisson/RedissonQueue.java
Patch:
@@ -33,7 +33,7 @@
  *
  * @param <V> the type of elements held in this collection
  */
-public class RedissonQueue<V> extends RedissonList<V> implements RQueue<V> {
+public class RedissonQueue<V> extends BaseRedissonList<V> implements RQueue<V> {
 
     public RedissonQueue(CommandAsyncExecutor commandExecutor, String name, RedissonClient redisson) {
         super(commandExecutor, name, redisson);

File: redisson/src/test/java/org/redisson/RedissonBlockingQueueReactiveTest.java
Patch:
@@ -44,7 +44,7 @@ public void testTakeElements2() throws InterruptedException {
                 .repeat()
                 .subscribe();
 
-        Awaitility.await().atMost(Duration.ofSeconds(1)).untilAsserted(() -> {
+        Awaitility.await().atMost(Duration.ofSeconds(2)).untilAsserted(() -> {
             assertThat(counter.get()).isEqualTo(100);
         });
     }

File: redisson/src/test/java/org/redisson/rx/RedissonBlockingDequeRxTest.java
Patch:
@@ -52,7 +52,7 @@ public void testPollLastAndOfferFirstTo() throws InterruptedException {
         RBlockingDequeRx<String> blockingDeque = redisson.getBlockingDeque("blocking_deque");
         long start = System.currentTimeMillis();
         String redisTask = sync(blockingDeque.pollLastAndOfferFirstTo("deque", 1, TimeUnit.SECONDS));
-        assertThat(System.currentTimeMillis() - start).isBetween(950L, 1500L);
+        assertThat(System.currentTimeMillis() - start).isBetween(950L, 1600L);
         assertThat(redisTask).isNull();
     }
     

File: redisson/src/main/java/org/redisson/client/protocol/decoder/IndexInfoDecoder.java
Patch:
@@ -57,14 +57,14 @@ public Object decode(List<Object> parts, State state) {
             ii.setDocTableSize(Double.valueOf(result.get("doc_table_size_mb").toString()));
             ii.setSortableValuesSize(Double.valueOf(result.get("sortable_values_size_mb").toString()));
             ii.setKeyTableSize(Double.valueOf(result.get("key_table_size_mb").toString()));
-            ii.setRecordsPerDocAverage(toLong(result, "records_per_doc_avg"));
+            ii.setRecordsPerDocAverage(Double.valueOf(result.get("records_per_doc_avg").toString()));
             ii.setBytesPerRecordAverage(toLong(result, "bytes_per_record_avg"));
             ii.setOffsetsPerTermAverage(toLong(result, "offsets_per_term_avg"));
             ii.setOffsetBitsPerRecordAverage(toLong(result, "offset_bits_per_record_avg"));
             ii.setHashIndexingFailures(toLong(result, "hash_indexing_failures"));
             ii.setTotalIndexingTime(Double.valueOf(result.get("total_indexing_time").toString()));
             ii.setIndexing(toLong(result, "indexing"));
-            ii.setPercentIndexed(toLong(result, "percent_indexed"));
+            ii.setPercentIndexed(Double.valueOf(result.get("percent_indexed").toString()));
             ii.setNumberOfUses(toLong(result, "number_of_uses"));
             ii.setGcStats((Map<String, Object>) result.get("gc_stats"));
             ii.setCursorStats((Map<String, Object>) result.get("cursor_stats"));

File: redisson/src/main/java/org/redisson/api/search/aggregate/ReducerParams.java
Patch:
@@ -36,7 +36,7 @@ public final class ReducerParams implements Reducer {
 
     @Override
     public Reducer as(String alias) {
-        this.as = as;
+        this.as = alias;
         return this;
     }
 

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -240,7 +240,7 @@ private void scheduleWriteTimeout(CompletableFuture<R> attemptPromise) {
         TimerTask task = timeout -> {
             if (writeFuture.cancel(false)) {
                 exception = new RedisTimeoutException("Command still hasn't been written into connection! " +
-                        "Check connection with Redis node: " + connectionFuture.join().getRedisClient().getAddr() +
+                        "Check CPU load on the application side. Check connection with Redis node: " + connectionFuture.join().getRedisClient().getAddr() +
                         " for TCP packet drops. Try to increase nettyThreads setting. "
                         + " Node source: " + source + ", connection: " + connectionFuture.join()
                         + ", command: " + LogHelper.toString(command, params)
@@ -278,7 +278,7 @@ public void run(Timeout t) throws Exception {
                                 if (writeFuture != null && writeFuture.cancel(false)) {
                                     if (exception == null) {
                                         exception = new RedisTimeoutException("Command still hasn't been written into connection! " +
-                                                "Check connection with Redis node: " + getNow(connectionFuture).getRedisClient().getAddr() +
+                                                "Check CPU load on the application side. Check connection with Redis node: " + getNow(connectionFuture).getRedisClient().getAddr() +
                                                 " for TCP packet drops. Try to increase nettyThreads setting. "
                                                 + " Node source: " + source + ", connection: " + getNow(connectionFuture)
                                                 + ", command: " + LogHelper.toString(command, params)

File: redisson/src/main/java/org/redisson/api/search/aggregate/ReducerParams.java
Patch:
@@ -36,7 +36,7 @@ public final class ReducerParams implements Reducer {
 
     @Override
     public Reducer as(String alias) {
-        this.as = as;
+        this.as = alias;
         return this;
     }
 

File: redisson/src/main/java/org/redisson/RedissonBaseLock.java
Patch:
@@ -338,6 +338,7 @@ protected final RFuture<Boolean> unlockInnerAsync(long threadId) {
         String id = getServiceManager().generateId();
         MasterSlaveServersConfig config = getServiceManager().getConfig();
         int timeout = (config.getTimeout() + config.getRetryInterval()) * config.getRetryAttempts();
+        timeout = Math.max(timeout, 1);
         RFuture<Boolean> r = unlockInnerAsync(threadId, id, timeout);
         CompletionStage<Boolean> ff = r.thenApply(v -> {
             CommandAsyncExecutor ce = commandExecutor;

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -519,6 +519,9 @@ public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {
         serviceManager.getShutdownLatch().awaitUninterruptibly();
 
         if (serviceManager.getCfg().getEventLoopGroup() == null) {
+            if (timeoutInNanos < quietPeriod) {
+                quietPeriod = 0;
+            }
             serviceManager.getGroup().shutdownGracefully(unit.toNanos(quietPeriod), timeoutInNanos, TimeUnit.NANOSECONDS).syncUninterruptibly();
         }
 

File: redisson/src/main/java/org/redisson/pubsub/PublishSubscribeService.java
Patch:
@@ -280,7 +280,7 @@ private CompletableFuture<PubSubConnectionEntry> subscribe(PubSubType type, Code
                 return;
             }
 
-            long newTimeout = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
+            long newTimeout = timeout - TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
             subscribeNoTimeout(codec, channelName, entry, clientEntry, promise, type, lock, new AtomicInteger(), listeners);
             timeout(promise, newTimeout);
         });

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -501,7 +501,8 @@ protected void checkAttemptPromise(CompletableFuture<R> attemptFuture, Completab
             Throwable cause = cause(attemptFuture);
             if (cause instanceof RedisMovedException && !ignoreRedirect) {
                 RedisMovedException ex = (RedisMovedException) cause;
-                if (source.getRedirect() == Redirect.MOVED) {
+                if (source.getRedirect() == Redirect.MOVED
+                        && source.getAddr().equals(ex.getUrl())) {
                     mainPromise.completeExceptionally(new RedisException("MOVED redirection loop detected. Node " + source.getAddr() + " has further redirect to " + ex.getUrl()));
                     return;
                 }

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -486,7 +486,7 @@ public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {
             try {
                 long startTime = System.nanoTime();
                 future.get(timeoutInNanos, TimeUnit.NANOSECONDS);
-                timeoutInNanos -= (System.nanoTime() - startTime);
+                timeoutInNanos -= System.nanoTime() - startTime;
             } catch (Exception e) {
                 // skip
             }
@@ -500,7 +500,7 @@ public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {
             try {
                 long startTime = System.nanoTime();
                 serviceManager.getExecutor().awaitTermination(timeoutInNanos, TimeUnit.NANOSECONDS);
-                timeoutInNanos -= (System.nanoTime() - startTime);
+                timeoutInNanos -= System.nanoTime() - startTime;
             } catch (InterruptedException e) {
                 Thread.currentThread().interrupt();
             }
@@ -512,7 +512,7 @@ public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {
         if (serviceManager.getCfg().getEventLoopGroup() == null) {
             long startTime = System.nanoTime();
             serviceManager.getGroup().shutdownGracefully(quietPeriod, timeoutInNanos, TimeUnit.NANOSECONDS).syncUninterruptibly();
-            timeoutInNanos -= (System.nanoTime() - startTime);
+            timeoutInNanos -= System.nanoTime() - startTime;
         }
 
         serviceManager.getTimer().stop();

File: redisson/src/main/java/org/redisson/client/handler/PingConnectionHandler.java
Patch:
@@ -62,7 +62,7 @@ private void sendPing(ChannelHandlerContext ctx) {
         RFuture<String> future;
         CommandData<?, ?> currentCommand = connection.getCurrentCommand();
         if (connection.getUsage() == 0 && (currentCommand == null || !currentCommand.isBlockingCommand())) {
-            future = connection.async(StringCodec.INSTANCE, RedisCommands.PING);
+            future = connection.async(config.getPingConnectionInterval() / 2, StringCodec.INSTANCE, RedisCommands.PING);
         } else {
             future = null;
         }

File: redisson-quarkus/redisson-quarkus-30/deployment/src/main/java/io/quarkus/redisson/client/deployment/QuarkusRedissonClientProcessor.java
Patch:
@@ -5,7 +5,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- * http://www.apache.org/licenses/LICENSE-2.0
+ *    http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,

File: redisson-spring-boot-starter/src/main/java/org/redisson/spring/starter/RedissonAutoConfiguration.java
Patch:
@@ -26,6 +26,7 @@
 import org.springframework.boot.autoconfigure.AutoConfigureBefore;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
 import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;
 import org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration;
 import org.springframework.boot.autoconfigure.data.redis.RedisConnectionDetails;
 import org.springframework.boot.autoconfigure.data.redis.RedisProperties;
@@ -54,6 +55,7 @@
 import java.util.List;
 
 /**
+ * Spring configuration used with Spring Boot 2.6 and lower
  *
  * @author Nikita Koksharov
  * @author Nikos Kakavas (https://github.com/nikakis)
@@ -62,6 +64,7 @@
  */
 @Configuration
 @ConditionalOnClass({Redisson.class, RedisOperations.class})
+@ConditionalOnMissingClass("org.springframework.boot.autoconfigure.AutoConfiguration")
 @AutoConfigureBefore(RedisAutoConfiguration.class)
 @EnableConfigurationProperties({RedissonProperties.class, RedisProperties.class})
 public class RedissonAutoConfiguration {

File: redisson/src/main/java/org/redisson/pubsub/CountDownLatchPubSub.java
Patch:
@@ -42,8 +42,9 @@ protected RedissonCountDownLatchEntry createEntry(CompletableFuture<RedissonCoun
     protected void onMessage(RedissonCountDownLatchEntry value, Long message) {
         if (message.equals(ZERO_COUNT_MESSAGE)) {
             Runnable runnableToExecute = value.getListeners().poll();
-            if (runnableToExecute != null) {
+            while (runnableToExecute != null) {
                 runnableToExecute.run();
+                runnableToExecute = value.getListeners().poll();
             }
 
             value.getLatch().open();

File: redisson/src/main/java/org/redisson/RedissonStream.java
Patch:
@@ -1406,7 +1406,7 @@ private RFuture<Long> trimAsync(StreamTrimArgs args, boolean trimStrict) {
         List<Object> params = new LinkedList<>();
         params.add(getRawName());
 
-        if (pps.getMaxLen() > 0) {
+        if (pps.getMaxLen() != null) {
             params.add("MAXLEN");
             if (!trimStrict) {
                 params.add("~");

File: redisson/src/main/java/org/redisson/api/stream/StreamTrimParams.java
Patch:
@@ -26,7 +26,7 @@ public final class StreamTrimParams implements StreamTrimStrategyArgs<StreamTrim
                                          StreamTrimArgs,
                                          StreamTrimLimitArgs<StreamTrimArgs> {
 
-    int maxLen;
+    Integer maxLen;
     StreamMessageId minId;
     int limit;
 
@@ -62,7 +62,7 @@ public StreamTrimArgs limit(int size) {
         return this;
     }
 
-    public int getMaxLen() {
+    public Integer getMaxLen() {
         return maxLen;
     }
 

File: redisson/src/main/java/org/redisson/pubsub/CountDownLatchPubSub.java
Patch:
@@ -42,8 +42,9 @@ protected RedissonCountDownLatchEntry createEntry(CompletableFuture<RedissonCoun
     protected void onMessage(RedissonCountDownLatchEntry value, Long message) {
         if (message.equals(ZERO_COUNT_MESSAGE)) {
             Runnable runnableToExecute = value.getListeners().poll();
-            if (runnableToExecute != null) {
+            while (runnableToExecute != null) {
                 runnableToExecute.run();
+                runnableToExecute = value.getListeners().poll();
             }
 
             value.getLatch().open();

File: redisson/src/test/java/org/redisson/RedissonFairLockTest.java
Patch:
@@ -931,7 +931,7 @@ public void testConcurrency_MultiInstance_Ordering() throws InterruptedException
             t1.start();
         }
 
-        await().atMost(35, TimeUnit.SECONDS).until(() -> lockedCounter.get() == totalThreads);
+        await().atMost(45, TimeUnit.SECONDS).until(() -> lockedCounter.get() == totalThreads);
     }
 
 

File: redisson/src/main/java/org/redisson/client/RedisConnection.java
Patch:
@@ -58,7 +58,7 @@ public enum Status {OPEN, CLOSED, CLOSED_IDLE}
     volatile Channel channel;
 
     private CompletableFuture<?> connectionPromise;
-    private long lastUsageTime;
+    private volatile long lastUsageTime;
     @Deprecated
     private Runnable connectedListener;
     @Deprecated

File: redisson/src/main/java/org/redisson/connection/balancer/WeightedRoundRobinBalancer.java
Patch:
@@ -18,7 +18,6 @@
 import org.redisson.connection.ClientConnectionsEntry;
 import org.redisson.misc.RedisURI;
 
-import java.net.InetSocketAddress;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;

File: redisson/src/main/java/org/redisson/client/handler/CommandPubSubDecoder.java
Patch:
@@ -284,7 +284,7 @@ protected Decoder<Object> selectDecoder(CommandData<Object, Object> data, List<O
             if (parts.size() == 2 && "pmessage".equals(parts.get(0))) {
                 return ByteArrayCodec.INSTANCE.getValueDecoder();
             }
-            if (parts.size() == 2 && TYPE_MESSAGES.contains(parts.get(0).toString())) {
+            if (parts.size() == 2 && TYPE_MESSAGES.contains(parts.get(0))) {
                 byte[] channelName = (byte[]) parts.get(1);
                 return getDecoder(null, parts, channelName);
             }

File: redisson/src/test/java/org/redisson/rx/RedissonBatchRxTest.java
Patch:
@@ -129,7 +129,7 @@ public void testConnectionLeakAfterError() {
         
         BatchOptions batchOptions = BatchOptions.defaults().executionMode(ExecutionMode.REDIS_WRITE_ATOMIC);
         RBatchRx batch = redisson.createBatch(batchOptions);
-        for (int i = 0; i < 25000; i++) {
+        for (int i = 0; i < 100000; i++) {
             batch.getBucket("test").set(123);
         }
         
@@ -193,7 +193,7 @@ public void testSyncSlaves(BatchOptions batchOptions) throws FailedToStartRedisE
         Config config = new Config();
         config.useClusterServers()
         .setTimeout(1000000)
-        .setRetryInterval(1000000)
+        .setRetryInterval(1000)
         .addNodeAddress(process.getNodes().stream().findAny().get().getRedisServerAddressAndPort());
         RedissonRxClient redisson = Redisson.create(config).rxJava();
         

File: redisson/src/main/java/org/redisson/config/BaseMasterSlaveServersConfig.java
Patch:
@@ -114,11 +114,11 @@ public int getSlaveConnectionPoolSize() {
     }
     
     /**
-     * Interval of Redis Slave reconnection attempt when
-     * it was excluded from internal list of available servers.
+     * When the retry interval <code>failedSlavesReconnectionTimeout<code/>
+     * reached Redisson tries to connect to failed Redis node reported by <code>failedSlaveNodeDetector</code>.
      * <p>
      * On every such timeout event Redisson tries
-     * to connect to disconnected Redis server.
+     * to connect to failed Redis server.
      * <p>
      * Default is 3000
      *

File: redisson/src/main/java/org/redisson/api/JsonType.java
Patch:
@@ -23,8 +23,6 @@
  */
 public enum JsonType {
 
-    NULL,
-
     BOOLEAN,
 
     STRING,

File: redisson/src/main/java/org/redisson/client/protocol/convertor/JsonTypeConvertor.java
Patch:
@@ -27,6 +27,9 @@ public class JsonTypeConvertor implements Convertor<JsonType> {
 
     @Override
     public JsonType convert(Object obj) {
+        if (obj == null) {
+            return null;
+        }
         return JsonType.valueOf(obj.toString().toUpperCase());
     }
 }

File: redisson/src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -121,8 +121,8 @@ public void testResponseHandling2() throws InterruptedException {
         bucket1.set("val1");
         bucket2.set("val2");
 
-        ExecutorService executor1 = Executors.newCachedThreadPool();
-        ExecutorService executor2 = Executors.newCachedThreadPool();
+        ExecutorService executor1 = Executors.newFixedThreadPool(16);
+        ExecutorService executor2 = Executors.newFixedThreadPool(16);
 
         AtomicBoolean hasError = new AtomicBoolean();
         for (int i = 0; i < 100000; i++) {

File: redisson/src/main/java/org/redisson/RedissonSearch.java
Patch:
@@ -184,7 +184,7 @@ private static void addFlatVectorIndex(List<Object> args, FieldIndex field) {
             args.add(params.getFieldName());
             args.add("VECTOR");
             args.add("FLAT");
-            args.add(params.getCount());
+            args.add(params.getCount()*2);
             args.add("TYPE");
             args.add(params.getType());
             args.add("DIM");

File: redisson/src/test/java/org/redisson/RedissonPermitExpirableSemaphoreTest.java
Patch:
@@ -541,8 +541,6 @@ public void testReleaseManyExpiredDoesNotThrow() throws InterruptedException, Ex
         Awaitility.await().atMost(Duration.ofMillis(250)).pollDelay(Duration.ofMillis(10)).untilAsserted(() -> {
             assertThat(semaphore.availablePermits()).isEqualTo(10);
         });
-
-        Assertions.assertDoesNotThrow(() -> semaphore.release(permitsIds));
     }
 
     @Test

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -756,8 +756,7 @@ private void checkSlotsMigration(Collection<ClusterPartition> newPartitions) {
 
                 if (!addedSlots.isEmpty() || !removedSlots.isEmpty()) {
                     // https://github.com/redisson/redisson/issues/3695, slotRanges not update when slots of node changed.
-                    currentPartition.clear();
-                    currentPartition.addSlotRanges(newPartition.getSlotRanges());
+                    currentPartition.updateSlotRanges(newPartition.getSlotRanges(), newPartition.slots());
                 }
                 break;
             }
@@ -852,7 +851,7 @@ private CompletableFuture<Collection<ClusterPartition>> parsePartitions(List<Clu
                     }
                 } else if (clusterNodeInfo.containsFlag(Flag.MASTER)) {
                     ClusterPartition masterPartition = partitions.computeIfAbsent(masterId, k -> new ClusterPartition(masterId));
-                    masterPartition.addSlotRanges(clusterNodeInfo.getSlotRanges());
+                    masterPartition.setSlotRanges(clusterNodeInfo.getSlotRanges());
                     masterPartition.setMasterAddress(address);
                     masterPartition.setType(Type.MASTER);
                     if (clusterNodeInfo.containsFlag(Flag.FAIL)) {

File: redisson/src/main/java/org/redisson/cluster/ClusterNodeInfo.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.redisson.cluster;
 
+import java.util.Collections;
 import java.util.EnumSet;
 import java.util.HashSet;
 import java.util.Set;
@@ -50,7 +51,7 @@ public String getValue() {
     private final Set<Flag> flags = EnumSet.noneOf(Flag.class);
     private String slaveOf;
 
-    private final Set<ClusterSlotRange> slotRanges = new HashSet<ClusterSlotRange>();
+    private final Set<ClusterSlotRange> slotRanges = new HashSet<>();
 
     public ClusterNodeInfo(String nodeInfo) {
         this.nodeInfo = nodeInfo;
@@ -74,7 +75,7 @@ public void addSlotRange(ClusterSlotRange range) {
         slotRanges.add(range);
     }
     public Set<ClusterSlotRange> getSlotRanges() {
-        return slotRanges;
+        return Collections.unmodifiableSet(slotRanges);
     }
 
     public boolean containsFlag(Flag flag) {

File: redisson/src/main/java/org/redisson/config/ConfigSupport.java
Patch:
@@ -68,7 +68,7 @@ public static class ConfigPropsMixIn {
 
     }
 
-    @JsonIgnoreProperties({"clusterConfig", "sentinelConfig", "slaveNotUsed"})
+    @JsonIgnoreProperties({"clusterConfig", "sentinelConfig", "singleConfig"})
     public static class ConfigMixIn {
 
         @JsonProperty

File: redisson/src/main/java/org/redisson/api/RPermitExpirableSemaphore.java
Patch:
@@ -103,7 +103,6 @@ public interface RPermitExpirableSemaphore extends RExpirable, RPermitExpirableS
      *         if the waiting time elapsed before a permit was acquired
      * @throws InterruptedException if the current thread is interrupted
      */
-
     String tryAcquire(long waitTime, TimeUnit unit) throws InterruptedException;
 
     /**

File: redisson/src/main/java/org/redisson/RedissonPermitExpirableSemaphore.java
Patch:
@@ -708,7 +708,7 @@ public RFuture<Void> setPermitsAsync(int permits) {
                 "end;" +
                 "local acquired = redis.call('zcount', KEYS[3], 0, '+inf'); " +
                 "local maximum = (acquired == false and 0 or acquired) + tonumber(available); " +
-                "if (maximum == ARGV[1]) then " +
+                "if (maximum == tonumber(ARGV[1])) then " +
                     "return;" +
                 "end;" +
                 "redis.call('incrby', KEYS[1], tonumber(ARGV[1]) - maximum); " +

File: redisson-tomcat/redisson-tomcat-10/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -185,7 +185,7 @@ private Session findSession(String id, boolean notify) throws IOException {
                 }
 
                 if (attrs.isEmpty() || (broadcastSessionEvents && getNotifiedNodes(id).contains(nodeId))) {
-                    log.info("Session " + id + " can't be found");
+                    log.debug("Session " + id + " can't be found");
                     return null;    
                 }
                 

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -185,7 +185,7 @@ private Session findSession(String id, boolean notify) throws IOException {
                 }
 
                 if (attrs.isEmpty() || (broadcastSessionEvents && getNotifiedNodes(id).contains(nodeId))) {
-                    log.info("Session " + id + " can't be found");
+                    log.debug("Session " + id + " can't be found");
                     return null;    
                 }
                 

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -185,7 +185,7 @@ private Session findSession(String id, boolean notify) throws IOException {
                 }
 
                 if (attrs.isEmpty() || (broadcastSessionEvents && getNotifiedNodes(id).contains(nodeId))) {
-                    log.info("Session " + id + " can't be found");
+                    log.debug("Session " + id + " can't be found");
                     return null;    
                 }
                 

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -185,7 +185,7 @@ private Session findSession(String id, boolean notify) throws IOException {
                 }
 
                 if (attrs.isEmpty() || (broadcastSessionEvents && getNotifiedNodes(id).contains(nodeId))) {
-                    log.info("Session " + id + " can't be found");
+                    log.debug("Session " + id + " can't be found");
                     return null;    
                 }
                 

File: redisson/src/main/java/org/redisson/codec/ProtobufCodec.java
Patch:
@@ -189,7 +189,7 @@ public static <T> T deserialize(byte[] data, Class<T> clazz) {
 
     }
 
-    private static abstract class BasicSerializerFactoryConcreteGetter extends BasicSerializerFactory {
+    private abstract static class BasicSerializerFactoryConcreteGetter extends BasicSerializerFactory {
         protected BasicSerializerFactoryConcreteGetter(SerializerFactoryConfig config) {
             super(config);
         }

File: redisson/src/main/java/org/redisson/RedissonBoundedBlockingQueue.java
Patch:
@@ -60,7 +60,7 @@ protected RedissonBoundedBlockingQueue(Codec codec, CommandAsyncExecutor command
     }
     
     private String getSemaphoreName() {
-        return prefixName("redisson_bqs", getName());
+        return prefixName("redisson_bqs", getRawName());
     }
     
     @Override

File: redisson/src/main/java/org/redisson/RedissonQueueSemaphore.java
Patch:
@@ -41,6 +41,7 @@ public class RedissonQueueSemaphore extends RedissonSemaphore {
     public RedissonQueueSemaphore(CommandAsyncExecutor commandExecutor, String name, Codec codec) {
         super(commandExecutor, name);
         this.codec = codec;
+        this.name = name;
     }
     
     public void setQueueName(String queueName) {

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -741,7 +741,8 @@ public <T> RFuture<T> syncedEvalWithRetry(String key, Codec codec, RedisCommand<
     @Override
     public <T> RFuture<T> syncedEval(String key, Codec codec, RedisCommand<T> evalCommandType, String script, List<Object> keys, Object... params) {
         CompletionStage<Map<String, String>> replicationFuture = CompletableFuture.completedFuture(Collections.emptyMap());
-        if (!getServiceManager().getCfg().isSingleConfig()) {
+        if (!getServiceManager().getCfg().isSingleConfig()
+                && !(this instanceof CommandBatchService)) {
             replicationFuture = writeAsync(key, RedisCommands.INFO_REPLICATION);
         }
         CompletionStage<T> resFuture = replicationFuture.thenCompose(r -> {

File: redisson/src/main/java/org/redisson/client/handler/CommandEncoder.java
Patch:
@@ -65,14 +65,14 @@ public class CommandEncoder extends MessageToByteEncoder<CommandData<?, ?>> {
 
     private static final Integer STRING_CACHE_SIZE = 100_000;
 
-    private static final List<byte[]> longToStringCache = LongStream.range(0, STRING_CACHE_SIZE)
+    private static final List<byte[]> LONG_TO_STRING_CACHE = LongStream.range(0, STRING_CACHE_SIZE)
         .mapToObj(Long::toString)
         .map(s -> s.getBytes(CharsetUtil.US_ASCII))
         .collect(Collectors.toList());
 
     public static byte[] longToString(long number) {
-        if (number < longToStringCache.size()) {
-            return longToStringCache.get((int)number);
+        if (number < LONG_TO_STRING_CACHE.size()) {
+            return LONG_TO_STRING_CACHE.get((int) number);
         } else {
             return Long.toString(number).getBytes(CharsetUtil.US_ASCII);
         }

File: redisson/src/test/java/org/redisson/RedissonLocalCachedMapTest.java
Patch:
@@ -150,6 +150,7 @@ public void testExpiration() throws IOException, InterruptedException {
                 .randomPort()
                 .randomDir()
                 .notifyKeyspaceEvents(
+                        RedisRunner.KEYSPACE_EVENTS_OPTIONS.E,
                         RedisRunner.KEYSPACE_EVENTS_OPTIONS.K,
                         RedisRunner.KEYSPACE_EVENTS_OPTIONS.x)
                 .run();
@@ -433,7 +434,7 @@ public String unmap(String name) {
         map2.put("2", 4);
         Thread.sleep(50);
 
-        assertThat(redisson.getKeys().getKeys()).containsOnly("test:suffix:");
+        assertThat(redisson.getKeys().getKeys()).containsOnly("test");
 
         RedisClientConfig destinationCfg = new RedisClientConfig();
         destinationCfg.setAddress(RedisRunner.getDefaultRedisServerBindAddressAndPort());

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.redisson.cluster;
 
-import io.netty.resolver.AddressResolver;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.FutureListener;
 import io.netty.util.concurrent.ScheduledFuture;
@@ -360,8 +359,7 @@ public void run() {
                 if (configEndpointHostName != null) {
                     String address = cfg.getNodeAddresses().iterator().next();
                     RedisURI uri = new RedisURI(address);
-                    AddressResolver<InetSocketAddress> resolver = serviceManager.getResolverGroup().getResolver(serviceManager.getGroup().next());
-                    Future<List<InetSocketAddress>> allNodes = resolver.resolveAll(InetSocketAddress.createUnresolved(uri.getHost(), uri.getPort()));
+                    Future<List<InetSocketAddress>> allNodes = serviceManager.resolveAll(uri);
                     allNodes.addListener(new FutureListener<List<InetSocketAddress>>() {
                         @Override
                         public void operationComplete(Future<List<InetSocketAddress>> future) throws Exception {

File: redisson-tomcat/redisson-tomcat-10/src/test/java/org/redisson/tomcat/RedissonSessionManagerTest.java
Patch:
@@ -53,7 +53,7 @@ public void testUpdateTwoServers_readValue(String contextName) throws Exception
             write(8081, executor, "test", "from_server2");
 
             read(8080, executor, "test", "from_server2");
-            read(8080, executor, "test", "from_server2");
+            read(8081, executor, "test", "from_server2");
 
         } finally {
             Executor.closeIdleConnections();

File: redisson-tomcat/redisson-tomcat-7/src/test/java/org/redisson/tomcat/RedissonSessionManagerTest.java
Patch:
@@ -53,7 +53,7 @@ public void testUpdateTwoServers_readValue(String contextName) throws Exception
             write(8081, executor, "test", "from_server2");
 
             read(8080, executor, "test", "from_server2");
-            read(8080, executor, "test", "from_server2");
+            read(8081, executor, "test", "from_server2");
 
         } finally {
             Executor.closeIdleConnections();

File: redisson-tomcat/redisson-tomcat-8/src/test/java/org/redisson/tomcat/RedissonSessionManagerTest.java
Patch:
@@ -53,7 +53,7 @@ public void testUpdateTwoServers_readValue(String contextName) throws Exception
             write(8081, executor, "test", "from_server2");
 
             read(8080, executor, "test", "from_server2");
-            read(8080, executor, "test", "from_server2");
+            read(8081, executor, "test", "from_server2");
 
         } finally {
             Executor.closeIdleConnections();

File: redisson-tomcat/redisson-tomcat-9/src/test/java/org/redisson/tomcat/RedissonSessionManagerTest.java
Patch:
@@ -53,7 +53,7 @@ public void testUpdateTwoServers_readValue(String contextName) throws Exception
             write(8081, executor, "test", "from_server2");
 
             read(8080, executor, "test", "from_server2");
-            read(8080, executor, "test", "from_server2");
+            read(8081, executor, "test", "from_server2");
 
         } finally {
             Executor.closeIdleConnections();

File: redisson/src/main/java/org/redisson/connection/balancer/LoadBalancerManager.java
Patch:
@@ -195,13 +195,14 @@ private CompletableFuture<Boolean> unfreezeAsync(ClientConnectionsEntry entry, F
                     future.whenComplete((r, e) -> {
                         if (e != null) {
                             int maxAttempts = connectionManager.getServiceManager().getConfig().getRetryAttempts();
+                            int retryInterval = connectionManager.getServiceManager().getConfig().getRetryInterval();
                             log.error("Unable to unfreeze entry: {} attempt: {} of {}", entry, retry, maxAttempts, e);
                             entry.setInitialized(false);
                             if (retry < maxAttempts) {
                                 connectionManager.getServiceManager().newTimeout(t -> {
                                     CompletableFuture<Boolean> ff = unfreezeAsync(entry, freezeReason, retry + 1);
                                     connectionManager.getServiceManager().transfer(ff, f);
-                                }, 1, TimeUnit.SECONDS);
+                                }, retryInterval, TimeUnit.MILLISECONDS);
                             } else {
                                 f.complete(false);
                             }

File: redisson/src/main/java/org/redisson/pubsub/PublishSubscribeService.java
Patch:
@@ -201,7 +201,7 @@ public boolean onStatus(PubSubType type, CharSequence channel) {
         return f.thenApply(res -> Collections.singletonList(res));
     }
 
-    private boolean isMultiEntity(ChannelName channelName) {
+    public boolean isMultiEntity(ChannelName channelName) {
         return connectionManager.isClusterMode()
                 && (channelName.toString().startsWith("__keyspace@")
                 || channelName.toString().startsWith("__keyevent@"));

File: redisson/src/test/java/org/redisson/RedissonTopicTest.java
Patch:
@@ -165,9 +165,6 @@ public void onUnsubscribe(String channel) {
         assertThat(unsubscribedCounter.get()).isZero();
 
         topic.removeListener(id1, id2);
-        Thread.sleep(1000);
-
-        assertThat(unsubscribedCounter.get()).isEqualTo(1);
 
         redisson.shutdown();
         process.shutdown();

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -711,7 +711,7 @@ protected RFuture<Void> putAllOperationAsync(Map<? extends K, ? extends V> map)
         ByteBuf msgEncoded = null;
         if (syncStrategy == SyncStrategy.UPDATE) {
             List<LocalCachedMapUpdate.Entry> entries = new ArrayList<LocalCachedMapUpdate.Entry>();
-            for (int j = 2; j < params.size(); j += 2) {
+            for (int j = 3; j < params.size(); j += 2) {
                 ByteBuf key = (ByteBuf) params.get(j);
                 ByteBuf value = (ByteBuf) params.get(j+1);
                 entries.add(new LocalCachedMapUpdate.Entry(key, value));

File: redisson/src/main/java/org/redisson/connection/ClientConnectionsEntry.java
Patch:
@@ -113,7 +113,7 @@ public void resetFirstFail() {
     }
 
     public boolean isFailed() {
-        if (client.getFirstFailTime() != 0) {
+        if (client.getFirstFailTime() != 0 && config.getFailedSlaveCheckInterval() > 0) {
             return System.currentTimeMillis() - client.getFirstFailTime() > config.getFailedSlaveCheckInterval();
         }
         return false;

File: redisson/src/main/java/org/redisson/api/search/aggregate/AggregationOptions.java
Patch:
@@ -73,7 +73,6 @@ public AggregationOptions loadAll() {
     }
 
     public AggregationOptions groupBy(GroupBy... groups) {
-        groupBy(GroupBy.fieldNames("123").reducers(Reducer.avg("12").as("23")));
         groupByParams = Arrays.stream(groups).map(g -> (GroupParams) g).collect(Collectors.toList());
         return this;
     }

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/RedissonSubscription.java
Patch:
@@ -52,7 +52,7 @@ public RedissonSubscription(CommandAsyncExecutor commandExecutor, PublishSubscri
     protected void doSubscribe(byte[]... channels) {
         List<CompletableFuture<?>> list = new ArrayList<>();
         for (byte[] channel : channels) {
-            CompletableFuture<PubSubConnectionEntry> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
+            CompletableFuture<List<PubSubConnectionEntry>> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
                 @Override
                 public void onMessage(CharSequence ch, Object message) {
                     if (!Arrays.equals(((ChannelName) ch).getName(), channel)) {

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/RedissonSubscription.java
Patch:
@@ -52,7 +52,7 @@ public RedissonSubscription(CommandAsyncExecutor commandExecutor, PublishSubscri
     protected void doSubscribe(byte[]... channels) {
         List<CompletableFuture<?>> list = new ArrayList<>();
         for (byte[] channel : channels) {
-            CompletableFuture<PubSubConnectionEntry> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
+            CompletableFuture<List<PubSubConnectionEntry>> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
                 @Override
                 public void onMessage(CharSequence ch, Object message) {
                     if (!Arrays.equals(((ChannelName) ch).getName(), channel)) {

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/RedissonSubscription.java
Patch:
@@ -52,7 +52,7 @@ public RedissonSubscription(CommandAsyncExecutor commandExecutor, PublishSubscri
     protected void doSubscribe(byte[]... channels) {
         List<CompletableFuture<?>> list = new ArrayList<>();
         for (byte[] channel : channels) {
-            CompletableFuture<PubSubConnectionEntry> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
+            CompletableFuture<List<PubSubConnectionEntry>> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
                 @Override
                 public void onMessage(CharSequence ch, Object message) {
                     if (!Arrays.equals(((ChannelName) ch).getName(), channel)) {

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonSubscription.java
Patch:
@@ -52,7 +52,7 @@ public RedissonSubscription(CommandAsyncExecutor commandExecutor, PublishSubscri
     protected void doSubscribe(byte[]... channels) {
         List<CompletableFuture<?>> list = new ArrayList<>();
         for (byte[] channel : channels) {
-            CompletableFuture<PubSubConnectionEntry> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
+            CompletableFuture<List<PubSubConnectionEntry>> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
                 @Override
                 public void onMessage(CharSequence ch, Object message) {
                     if (!Arrays.equals(((ChannelName) ch).getName(), channel)) {

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonSubscription.java
Patch:
@@ -52,7 +52,7 @@ public RedissonSubscription(CommandAsyncExecutor commandExecutor, PublishSubscri
     protected void doSubscribe(byte[]... channels) {
         List<CompletableFuture<?>> list = new ArrayList<>();
         for (byte[] channel : channels) {
-            CompletableFuture<PubSubConnectionEntry> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
+            CompletableFuture<List<PubSubConnectionEntry>> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
                 @Override
                 public void onMessage(CharSequence ch, Object message) {
                     if (!Arrays.equals(((ChannelName) ch).getName(), channel)) {

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonSubscription.java
Patch:
@@ -52,7 +52,7 @@ public RedissonSubscription(CommandAsyncExecutor commandExecutor, PublishSubscri
     protected void doSubscribe(byte[]... channels) {
         List<CompletableFuture<?>> list = new ArrayList<>();
         for (byte[] channel : channels) {
-            CompletableFuture<PubSubConnectionEntry> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
+            CompletableFuture<List<PubSubConnectionEntry>> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
                 @Override
                 public void onMessage(CharSequence ch, Object message) {
                     if (!Arrays.equals(((ChannelName) ch).getName(), channel)) {

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonSubscription.java
Patch:
@@ -52,7 +52,7 @@ public RedissonSubscription(CommandAsyncExecutor commandExecutor, PublishSubscri
     protected void doSubscribe(byte[]... channels) {
         List<CompletableFuture<?>> list = new ArrayList<>();
         for (byte[] channel : channels) {
-            CompletableFuture<PubSubConnectionEntry> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
+            CompletableFuture<List<PubSubConnectionEntry>> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
                 @Override
                 public void onMessage(CharSequence ch, Object message) {
                     if (!Arrays.equals(((ChannelName) ch).getName(), channel)) {

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonSubscription.java
Patch:
@@ -52,7 +52,7 @@ public RedissonSubscription(CommandAsyncExecutor commandExecutor, PublishSubscri
     protected void doSubscribe(byte[]... channels) {
         List<CompletableFuture<?>> list = new ArrayList<>();
         for (byte[] channel : channels) {
-            CompletableFuture<PubSubConnectionEntry> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
+            CompletableFuture<List<PubSubConnectionEntry>> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
                 @Override
                 public void onMessage(CharSequence ch, Object message) {
                     if (!Arrays.equals(((ChannelName) ch).getName(), channel)) {

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/RedissonSubscription.java
Patch:
@@ -52,7 +52,7 @@ public RedissonSubscription(CommandAsyncExecutor commandExecutor, PublishSubscri
     protected void doSubscribe(byte[]... channels) {
         List<CompletableFuture<?>> list = new ArrayList<>();
         for (byte[] channel : channels) {
-            CompletableFuture<PubSubConnectionEntry> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
+            CompletableFuture<List<PubSubConnectionEntry>> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
                 @Override
                 public void onMessage(CharSequence ch, Object message) {
                     if (!Arrays.equals(((ChannelName) ch).getName(), channel)) {

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonSubscription.java
Patch:
@@ -53,7 +53,7 @@ protected void doSubscribe(byte[]... channels) {
         List<CompletableFuture<?>> list = new ArrayList<>();
         Queue<byte[]> subscribed = new ConcurrentLinkedQueue<>();
         for (byte[] channel : channels) {
-            CompletableFuture<PubSubConnectionEntry> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
+            CompletableFuture<List<PubSubConnectionEntry>> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
                 @Override
                 public void onMessage(CharSequence ch, Object message) {
                     if (!Arrays.equals(((ChannelName) ch).getName(), channel)) {

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/RedissonSubscription.java
Patch:
@@ -57,7 +57,7 @@ protected void doSubscribe(byte[]... channels) {
                 continue;
             }
 
-            CompletableFuture<PubSubConnectionEntry> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
+            CompletableFuture<List<PubSubConnectionEntry>> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
                 @Override
                 public void onMessage(CharSequence ch, Object message) {
                     if (!Arrays.equals(((ChannelName) ch).getName(), channel)) {

File: redisson-spring-data/redisson-spring-data-30/src/main/java/org/redisson/spring/data/connection/RedissonSubscription.java
Patch:
@@ -57,7 +57,7 @@ protected void doSubscribe(byte[]... channels) {
                 continue;
             }
 
-            CompletableFuture<PubSubConnectionEntry> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
+            CompletableFuture<List<PubSubConnectionEntry>> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
                 @Override
                 public void onMessage(CharSequence ch, Object message) {
                     if (!Arrays.equals(((ChannelName) ch).getName(), channel)) {

File: redisson-spring-data/redisson-spring-data-31/src/main/java/org/redisson/spring/data/connection/RedissonSubscription.java
Patch:
@@ -57,7 +57,7 @@ protected void doSubscribe(byte[]... channels) {
                 continue;
             }
 
-            CompletableFuture<PubSubConnectionEntry> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
+            CompletableFuture<List<PubSubConnectionEntry>> f = subscribeService.subscribe(ByteArrayCodec.INSTANCE, new ChannelName(channel), new BaseRedisPubSubListener() {
                 @Override
                 public void onMessage(CharSequence ch, Object message) {
                     if (!Arrays.equals(((ChannelName) ch).getName(), channel)) {

File: redisson/src/main/java/org/redisson/RedissonTopic.java
Patch:
@@ -123,7 +123,7 @@ public <M> RFuture<Integer> addListenerAsync(Class<M> type, MessageListener<? ex
     }
 
     protected RFuture<Integer> addListenerAsync(RedisPubSubListener<?> pubSubListener) {
-        CompletableFuture<PubSubConnectionEntry> future = subscribeService.subscribe(codec, channelName, pubSubListener);
+        CompletableFuture<List<PubSubConnectionEntry>> future = subscribeService.subscribe(codec, channelName, pubSubListener);
         CompletableFuture<Integer> f = future.thenApply(res -> {
             return System.identityHashCode(pubSubListener);
         });

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -80,7 +80,7 @@ protected MasterSlaveServersConfig create(BaseMasterSlaveServersConfig<?> cfg) {
     }
 
     @Override
-    public void connect() {
+    public void doConnect() {
         if (cfg.getNodeAddresses().isEmpty()) {
             throw new IllegalArgumentException("At least one cluster node should be defined!");
         }

File: redisson/src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -31,7 +31,7 @@
  */
 public interface ConnectionManager {
 
-    void connect();
+    void connect() throws InterruptedException;
 
     PublishSubscribeService getSubscribeService();
     

File: redisson/src/main/java/org/redisson/connection/ReplicatedConnectionManager.java
Patch:
@@ -72,7 +72,7 @@ public ReplicatedConnectionManager(ReplicatedServersConfig cfg, ServiceManager s
     }
 
     @Override
-    public void connect() {
+    public void doConnect() {
         for (String address : cfg.getNodeAddresses()) {
             RedisURI addr = new RedisURI(address);
             CompletionStage<RedisConnection> connectionFuture = connectToNode(cfg, addr, addr.getHost());
@@ -105,7 +105,7 @@ public void connect() {
             log.warn("ReadMode = {}, but slave nodes are not found! Please specify all nodes in replicated mode.", this.config.getReadMode());
         }
 
-        super.connect();
+        super.doConnect();
 
         scheduleMasterChangeCheck(cfg);
     }

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -84,7 +84,7 @@ public SentinelConnectionManager(SentinelServersConfig cfg, ServiceManager servi
     }
 
     @Override
-    public void connect() {
+    public void doConnect() {
         checkAuth(cfg);
 
         if ("redis".equals(scheme)) {
@@ -202,7 +202,7 @@ public void connect() {
             log.warn("ReadMode = {}, but slave nodes are not found!", this.config.getReadMode());
         }
 
-        super.connect();
+        super.doConnect();
 
         scheduleChangeCheck(cfg, null);
     }

File: redisson/src/test/java/org/redisson/executor/RedissonScheduledExecutorServiceTest.java
Patch:
@@ -160,7 +160,7 @@ public void testSingleWorker() throws InterruptedException {
         RScheduledExecutorService executorService = client.getExecutorService("JobA");
         executorService.schedule(new TestTask() , CronSchedule.of("0/1 * * * * ?"));
         
-        TimeUnit.MILLISECONDS.sleep(4900);
+        TimeUnit.MILLISECONDS.sleep(5000);
         
         assertThat(client.getAtomicLong("counter").get()).isEqualTo(4);
         

File: redisson/src/test/java/org/redisson/executor/RedissonScheduledExecutorServiceTest.java
Patch:
@@ -420,7 +420,8 @@ public void testCancelAndInterruptCronExpression() throws InterruptedException,
         assertThat(redisson.getAtomicLong("counter").get()).isEqualTo(3);
 
         cancel(future);
-        assertThat(redisson.<Long>getBucket("executed").get()).isBetween(1000L, Long.MAX_VALUE);
+        Thread.sleep(50);
+        assertThat(redisson.<Long>getBucket("executed").get()).isGreaterThan(1000L);
 
         Thread.sleep(TimeUnit.SECONDS.toMillis(3));
         assertThat(redisson.getAtomicLong("counter").get()).isEqualTo(3);

File: redisson/src/main/java/org/redisson/client/protocol/BatchCommandData.java
Patch:
@@ -83,4 +83,7 @@ public void updateCommand(RedisCommand command) {
         this.command = command;
     }
 
+    public int getIndex() {
+        return index;
+    }
 }

File: redisson/src/main/java/org/redisson/command/RedisQueuedBatchExecutor.java
Patch:
@@ -186,7 +186,7 @@ protected void sendCommand(CompletableFuture<R> attemptPromise, RedisConnection
                         BatchCommandData<?, ?> waitCommand = new BatchCommandData<>(RedisCommands.WAIT,
                                 new Object[] { this.options.getSyncSlaves(), this.options.getSyncTimeout() }, index.incrementAndGet());
                         list.add(waitCommand);
-                        entry.getCommands().add(waitCommand);
+                        entry.add(waitCommand);
                     }
 
                     CompletableFuture<Void> main = new CompletableFuture<>();

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -698,6 +698,7 @@ public Object decode(List parts, State state) {
     RedisStrictCommand<Map<String, String>> CONFIG_GET_MAP = new RedisStrictCommand<>("CONFIG", "GET", new ObjectMapReplayDecoder());
     RedisStrictCommand<Void> CONFIG_SET = new RedisStrictCommand<Void>("CONFIG", "SET", new VoidReplayConvertor());
     RedisStrictCommand<Void> CONFIG_RESETSTAT = new RedisStrictCommand<Void>("CONFIG", "RESETSTAT", new VoidReplayConvertor());
+    RedisStrictCommand<Void> CONFIG_REWRITE = new RedisStrictCommand<>("CONFIG", "REWRITE", new VoidReplayConvertor());
     RedisStrictCommand<List<String>> CLIENT_LIST = new RedisStrictCommand<List<String>>("CLIENT", "LIST", new StringToListConvertor());
     
     RedisStrictCommand<Map<String, String>> INFO_ALL = new RedisStrictCommand<Map<String, String>>("INFO", "ALL", new StringMapDataDecoder());

File: redisson/src/main/java/org/redisson/transaction/BaseTransactionalMap.java
Patch:
@@ -469,7 +469,7 @@ protected RFuture<Long> fastRemoveOperationAsync(K... keys) {
         List<RLock> locks = Arrays.stream(keys).map(k -> getLock(k)).collect(Collectors.toList());
         return executeLocked(timeout, () -> {
             AtomicLong counter = new AtomicLong();
-            List<K> keyList = Arrays.asList(keys);
+            List<K> keyList = new ArrayList<>(Arrays.asList(keys));
             for (Iterator<K> iterator = keyList.iterator(); iterator.hasNext();) {
                 K key = iterator.next();
                 HashValue keyHash = toKeyHash(key);

File: redisson/src/main/java/org/redisson/RedissonBloomFilter.java
Patch:
@@ -120,7 +120,7 @@ public boolean add(T object) {
             try {
                 List<Boolean> result = (List<Boolean>) executorService.execute().getResponses();
 
-                for (Boolean val : result.subList(1, result.size()-1)) {
+                for (Boolean val : result.subList(1, result.size())) {
                     if (!val) {
                         return true;
                     }
@@ -171,7 +171,7 @@ public boolean contains(T object) {
             try {
                 List<Boolean> result = (List<Boolean>) executorService.execute().getResponses();
 
-                for (Boolean val : result.subList(1, result.size()-1)) {
+                for (Boolean val : result.subList(1, result.size())) {
                     if (!val) {
                         return false;
                     }

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -339,7 +339,8 @@ private void checkWriteFuture(ChannelFuture future, CompletableFuture<R> attempt
 
         if (!future.isSuccess()) {
             exception = new WriteRedisConnectionException(
-                    "Unable to write command into connection! Increase connection pool size. Node source: " + source + ", connection: " + connection +
+                    "Unable to write command into connection! Increase nettyThreads setting. Node source: "
+                    + source + ", connection: " + connection +
                     ", command: " + LogHelper.toString(command, params)
                     + " after " + attempt + " retry attempts", future.cause());
             if (attempt == attempts) {

File: redisson/src/main/java/org/redisson/RedissonLiveObjectService.java
Patch:
@@ -598,7 +598,7 @@ private void deleteCollection(Set<String> deleted, Iterable<?> objs) {
     @Override
     public <T> long delete(Class<T> entityClass, Object... ids) {
         CommandBatchService ce = new CommandBatchService(commandExecutor);
-        FieldList<InDefinedShape> fields = Introspectior.getFieldsWithAnnotation(entityClass.getSuperclass(), RIndex.class);
+        FieldList<InDefinedShape> fields = Introspectior.getFieldsWithAnnotation(entityClass, RIndex.class);
         Set<String> fieldNames = fields.stream().map(f -> f.getName()).collect(Collectors.toSet());
 
         NamingScheme namingScheme = commandExecutor.getObjectBuilder().getNamingScheme(entityClass);

File: redisson/src/main/java/org/redisson/RedissonSetMultimap.java
Patch:
@@ -82,6 +82,9 @@ public RFuture<Long> fastRemoveValueAsync(V... values) {
                         "for j = 2, #ARGV, 1 do " +
                             "size = size + redis.call('srem', name, ARGV[j]); " +
                         "end; " +
+                        "if redis.call('exists', name) == 0 then " +
+                            "redis.call('hdel', KEYS[1], keys[i-1]); " +
+                        "end; " +
                     "end;" +
                 "end; " +
                 "return 0; ",

File: redisson/src/test/java/org/redisson/RedissonLiveObjectServiceTest.java
Patch:
@@ -1721,7 +1721,7 @@ public void testExpirable() throws InterruptedException, IOException {
         service.asRMap(myObject).expire(Duration.ofSeconds(1));
         Thread.sleep(2000);
         assertFalse(service.asLiveObject(myObject).isExists());
-        assertThat(redisson.getKeys().count()).isEqualTo(1);
+        assertThat(redisson.getKeys().count()).isZero();
 
         redisson.shutdown();
         instance.stop();

File: redisson/src/main/java/org/redisson/RedissonSearch.java
Patch:
@@ -454,7 +454,7 @@ public RFuture<SearchResult> searchAsync(String indexName, String query, QueryOp
         }
         if (!options.getParams().isEmpty()) {
             args.add("PARAMS");
-            args.add(options.getParams().size());
+            args.add(options.getParams().size()*2);
             for (Map.Entry<String, Object> entry : options.getParams().entrySet()) {
                 args.add(entry.getKey());
                 args.add(entry.getValue());
@@ -573,7 +573,7 @@ public RFuture<AggregationResult> aggregateAsync(String indexName, String query,
         }
         if (!options.getParams().isEmpty()) {
             args.add("PARAMS");
-            args.add(options.getParams().size());
+            args.add(options.getParams().size()*2);
             for (Map.Entry<String, Object> entry : options.getParams().entrySet()) {
                 args.add(entry.getKey());
                 args.add(entry.getValue());

File: redisson/src/test/java/org/redisson/RedissonSearchTest.java
Patch:
@@ -224,6 +224,7 @@ public void testJSONSearch() {
         SearchResult r2 = s.search("idx", "*", QueryOptions.defaults()
                 .returnAttributes(new ReturnAttribute("arr"),
                         new ReturnAttribute("val"))
+                        .params(Collections.singletonMap("12", "323"))
                 .dialect(3));
 
         Map<String, Object> map2 = new LinkedHashMap<>();

File: redisson/src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -172,7 +172,7 @@ private RFuture<Boolean> tryAcquireOnceAsync(long waitTime, long leaseTime, Time
         return new CompletableFutureWrapper<>(f);
     }
 
-    private <T> RFuture<Long> tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) {
+    private RFuture<Long> tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) {
         RFuture<Long> ttlRemainingFuture;
         if (leaseTime > 0) {
             ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);

File: redisson/src/main/java/org/redisson/reactive/ReactiveProxyBuilder.java
Patch:
@@ -40,7 +40,7 @@ public static <T> T create(CommandReactiveExecutor commandExecutor, Object insta
             @Override
             public Object execute(Callable<RFuture<Object>> callable, Method instanceMethod) {
                 Mono<Object> result = commandExecutor.reactive(callable);
-                if(instanceMethod.getReturnType().isAssignableFrom(Flux.class)){
+                if (instanceMethod.getReturnType().isAssignableFrom(Flux.class)) {
                     Mono<Iterable> monoListResult = result.cast(Iterable.class);
                     return monoListResult.flatMapMany(Flux::fromIterable);
                 }

File: redisson/src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -172,7 +172,7 @@ private RFuture<Boolean> tryAcquireOnceAsync(long waitTime, long leaseTime, Time
         return new CompletableFutureWrapper<>(f);
     }
 
-    private <T> RFuture<Long> tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) {
+    private RFuture<Long> tryAcquireAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) {
         RFuture<Long> ttlRemainingFuture;
         if (leaseTime > 0) {
             ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);

File: redisson/src/main/java/org/redisson/jcache/JCacheManager.java
Patch:
@@ -177,10 +177,10 @@ public <K, V> Cache<K, V> getCache(String cacheName) {
         checkNotClosed();
         Cache<K, V> cache = (Cache<K, V>) getCache(cacheName, Object.class, Object.class);
         if (cache != null) {
-            if (cache.getConfiguration(CompleteConfiguration.class).getKeyType() != Object.class) {
+            if (!cache.getConfiguration(CompleteConfiguration.class).getKeyType().isAssignableFrom(Object.class)) {
                 throw new IllegalArgumentException("Wrong type of key for " + cacheName);
             }
-            if (cache.getConfiguration(CompleteConfiguration.class).getValueType() != Object.class) {
+            if (!cache.getConfiguration(CompleteConfiguration.class).getValueType().isAssignableFrom(Object.class)) {
                 throw new IllegalArgumentException("Wrong type of value for " + cacheName);
             }
         }

File: redisson/src/main/java/org/redisson/api/StreamConsumer.java
Patch:
@@ -64,6 +64,8 @@ public long getIdleTime() {
 
     /**
      * Returns time in milliseconds since the last successful interaction of this consumer
+     * <p>
+     * Requires <b>Redis 7.2.0 and higher.</b>
      *
      * @return time in milliseconds
      */

File: redisson/src/main/java/org/redisson/RedissonScoredSortedSet.java
Patch:
@@ -1029,7 +1029,7 @@ private RFuture<ScanResult<Object>> distributedScanIteratorAsync(String iterator
         }
         args.add(count);
 
-        return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.SCAN,
+        return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_SCAN,
                 "local cursor = redis.call('get', KEYS[2]); "
                 + "if cursor ~= false then "
                     + "cursor = tonumber(cursor); "

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -120,6 +120,7 @@ private void broadcastLocalCacheStore(V value, ByteBuf mapKey, CacheKey cacheKey
             if (syncStrategy == SyncStrategy.UPDATE) {
                 ByteBuf mapValue = encodeMapValue(value);
                 msg = new LocalCachedMapUpdate(instanceId, mapKey, mapValue);
+                mapValue.release();
             } else {
                 msg = new LocalCachedMapInvalidate(instanceId, cacheKey.getKeyHash());
             }

File: redisson/src/main/java/org/redisson/codec/CustomObjectInputStream.java
Patch:
@@ -31,7 +31,7 @@ public class CustomObjectInputStream extends ObjectInputStream {
     private final ClassLoader classLoader;
     private Set<String> allowedClasses;
 
-    public CustomObjectInputStream(ClassLoader classLoader, InputStream in,Set<String> allowedClasses) throws IOException {
+    public CustomObjectInputStream(ClassLoader classLoader, InputStream in, Set<String> allowedClasses) throws IOException {
         super(in);
         this.classLoader = classLoader;
         this.allowedClasses = allowedClasses;

File: redisson/src/test/java/org/redisson/RedissonLocalCachedMapTest.java
Patch:
@@ -165,6 +165,9 @@ public void testExpiration() throws IOException, InterruptedException {
         Thread.sleep(1500);
         assertThat(m.cachedEntrySet()).hasSize(0);
         assertThat(m.get("12")).isNull();
+
+        redisson.shutdown();
+        instance.stop();
     }
 
     @Test

File: redisson/src/main/java/org/redisson/RedissonLiveObjectService.java
Patch:
@@ -65,15 +65,15 @@ public class RedissonLiveObjectService implements RLiveObjectService {
     private final ConcurrentMap<Class<?>, Class<?>> classCache;
     private final CommandAsyncExecutor commandExecutor;
     private final LiveObjectSearch seachEngine;
-    private final AtomicBoolean listenerLatch = new AtomicBoolean();
+    private static final AtomicBoolean LISTENER_LATCH = new AtomicBoolean();
 
     public RedissonLiveObjectService(ConcurrentMap<Class<?>, Class<?>> classCache,
                                      CommandAsyncExecutor commandExecutor) {
         this.classCache = classCache;
         this.commandExecutor = commandExecutor;
         this.seachEngine = new LiveObjectSearch(commandExecutor);
 
-        if (listenerLatch.compareAndSet(false, true)) {
+        if (LISTENER_LATCH.compareAndSet(false, true)) {
             RPatternTopic topic = new RedissonPatternTopic(StringCodec.INSTANCE, commandExecutor, "__keyevent@*:expired");
             topic.addListenerAsync(String.class, (pattern, channel, msg) -> {
                 if (msg.contains("redisson_live_object:")) {

File: redisson/src/main/java/org/redisson/RedissonPatternTopic.java
Patch:
@@ -54,7 +54,7 @@ protected RedissonPatternTopic(CommandAsyncExecutor commandExecutor, String name
         this(commandExecutor.getServiceManager().getCfg().getCodec(), commandExecutor, name);
     }
 
-    protected RedissonPatternTopic(Codec codec, CommandAsyncExecutor commandExecutor, String name) {
+    public RedissonPatternTopic(Codec codec, CommandAsyncExecutor commandExecutor, String name) {
         this.commandExecutor = commandExecutor;
         this.name = name;
         this.channelName = new ChannelName(name);

File: redisson-spring-boot-starter/src/test/java/org/redisson/spring/starter/RedissonSessionManagerAutoConfigurationTest.java
Patch:
@@ -21,7 +21,7 @@
         properties = {
             "spring.redis.redisson.file=classpath:redisson.yaml",
             "spring.session.store-type=redis",
-            "spring.session.timeout.seconds=900",
+//            "spring.session.timeout.seconds=900",
         })
 public class RedissonSessionManagerAutoConfigurationTest {
 

File: redisson/src/main/java/org/redisson/command/CommandBatchService.java
Patch:
@@ -133,7 +133,7 @@ public void clearErrors() {
     private final AtomicBoolean executed = new AtomicBoolean();
 
     private final long retryInterval;
-    private final long retryAttempts;
+    private final int retryAttempts;
 
     public CommandBatchService(CommandAsyncExecutor executor) {
         this(executor, RedissonObjectBuilder.ReferenceType.DEFAULT);
@@ -406,8 +406,8 @@ private void execute(CompletableFuture<Map<NodeSource, Entry>> voidPromise) {
                             .executionMode(this.options.getExecutionMode())
                             .syncSlaves(this.options.getSyncSlaves(), this.options.getSyncTimeout(), TimeUnit.MILLISECONDS)
                             .responseTimeout(this.options.getResponseTimeout(), TimeUnit.MILLISECONDS)
-                            .retryAttempts(Math.max(0, this.options.getRetryAttempts() - attempt.get()))
-                            .retryInterval(this.options.getRetryInterval(), TimeUnit.MILLISECONDS);
+                            .retryAttempts(Math.max(0, retryAttempts - attempt.get()))
+                            .retryInterval(retryInterval, TimeUnit.MILLISECONDS);
 
                     if (this.options.isSkipResult()) {
                         options.skipResult();

File: redisson/src/main/java/org/redisson/RedissonBitSet.java
Patch:
@@ -320,7 +320,7 @@ public RFuture<Void> setAsync(long[] indexArray, boolean value) {
             paramArray[j++] = indexArray[i];
             paramArray[j++] = val;
         }
-        return commandExecutor.writeAsync(getRawName(), RedisCommands.BITFIELD_VOID, paramArray);
+        return commandExecutor.writeAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.BITFIELD_VOID, paramArray);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonBitSet.java
Patch:
@@ -324,8 +324,7 @@ public RFuture<Void> setAsync(long[] indexArray, boolean value) {
             paramArray[j++] = indexArray[i];
             paramArray[j++] = val;
         }
-        return commandExecutor.writeAsync(getRawName(), ByteArrayCodec.INSTANCE, RedisCommands.BITFIELD_VOID,
-            paramArray);
+        return commandExecutor.writeAsync(getRawName(), RedisCommands.BITFIELD_VOID, paramArray);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/pubsub/PublishSubscribeService.java
Patch:
@@ -475,7 +475,7 @@ private CompletableFuture<RedisPubSubConnection> connect(Codec codec, ChannelNam
     }
 
     public CompletableFuture<Void> unsubscribeLocked(PubSubType topicType, ChannelName channelName) {
-        Collection<MasterSlaveEntry> coll = name2entry.remove(channelName);
+        Collection<MasterSlaveEntry> coll = name2entry.get(channelName);
         if (coll == null || coll.isEmpty()) {
             RedisNodeNotFoundException ex = new RedisNodeNotFoundException("Node for name: " + channelName + " hasn't been discovered yet. Check cluster slots coverage using CLUSTER NODES command. Increase value of retryAttempts and/or retryInterval settings.");
             CompletableFuture<Void> promise = new CompletableFuture<>();
@@ -487,6 +487,7 @@ public CompletableFuture<Void> unsubscribeLocked(PubSubType topicType, ChannelNa
     }
 
     private CompletableFuture<Void> unsubscribeLocked(PubSubType topicType, ChannelName channelName, MasterSlaveEntry msEntry) {
+        name2entry.remove(channelName);
         PubSubConnectionEntry entry = name2PubSubConnection.remove(new PubSubKey(channelName, msEntry));
         if (entry == null || connectionManager.getServiceManager().isShuttingDown()) {
             return CompletableFuture.completedFuture(null);
@@ -763,7 +764,7 @@ private CompletableFuture<Void> removeListenerAsync(PubSubType type, ChannelName
         }, timeout, TimeUnit.MILLISECONDS);
 
         return sf.thenCompose(res -> {
-            Collection<MasterSlaveEntry> entries = name2entry.remove(channelName);
+            Collection<MasterSlaveEntry> entries = name2entry.get(channelName);
             if (entries == null || entries.isEmpty()) {
                 semaphore.release();
                 return CompletableFuture.completedFuture(null);

File: redisson/src/main/java/org/redisson/pubsub/PublishSubscribeService.java
Patch:
@@ -544,7 +544,7 @@ public void remove(MasterSlaveEntry entry) {
     }
 
     public CompletableFuture<Codec> unsubscribe(ChannelName channelName, PubSubType topicType) {
-        Collection<MasterSlaveEntry> coll = name2entry.remove(channelName);
+        Collection<MasterSlaveEntry> coll = name2entry.get(channelName);
         if (coll == null || coll.isEmpty()) {
             RedisNodeNotFoundException ex = new RedisNodeNotFoundException("Node for name: " + channelName + " hasn't been discovered yet. Check cluster slots coverage using CLUSTER NODES command. Increase value of retryAttempts and/or retryInterval settings.");
             CompletableFuture<Codec> promise = new CompletableFuture<>();
@@ -563,6 +563,7 @@ private CompletableFuture<Codec> unsubscribe(ChannelName channelName, MasterSlav
         AsyncSemaphore lock = getSemaphore(channelName);
         CompletableFuture<Void> f = lock.acquire();
         return f.thenCompose(v -> {
+            name2entry.remove(channelName);
             PubSubConnectionEntry entry = name2PubSubConnection.remove(new PubSubKey(channelName, e));
             if (entry == null) {
                 lock.release();

File: redisson/src/main/java/org/redisson/api/BatchOptions.java
Patch:
@@ -67,7 +67,7 @@ public enum ExecutionMode {
     private ExecutionMode executionMode = ExecutionMode.IN_MEMORY;
     
     private long responseTimeout;
-    private int retryAttempts;
+    private int retryAttempts = -1;
     private long retryInterval;
 
     private long syncTimeout;

File: redisson/src/main/java/org/redisson/command/BaseRedisBatchExecutor.java
Patch:
@@ -59,7 +59,7 @@ public BaseRedisBatchExecutor(boolean readOnlyMode, NodeSource source, Codec cod
         this.index = index;
         this.executed = executed;
 
-        if (options.getRetryAttempts() > 0) {
+        if (options.getRetryAttempts() >= 0) {
             this.attempts = options.getRetryAttempts();
         }
         if (options.getRetryInterval() > 0) {

File: redisson/src/main/java/org/redisson/command/RedisCommonBatchExecutor.java
Patch:
@@ -61,7 +61,7 @@ public RedisCommonBatchExecutor(NodeSource source, CompletableFuture<Void> mainP
         this.entry = entry;
         this.slots = slots;
         
-        if (options.getRetryAttempts() > 0) {
+        if (options.getRetryAttempts() >= 0) {
             this.attempts = options.getRetryAttempts();
         }
         if (options.getRetryInterval() > 0) {

File: redisson/src/main/java/org/redisson/api/RMapCache.java
Patch:
@@ -295,7 +295,7 @@ public interface RMapCache<K, V> extends RMap<K, V>, RMapCacheAsync<K, V> {
      * If map doesn't contain value for specified key and {@link MapLoader} is defined
      * then value will be loaded in read-through mode.
      * <p>
-     * Idle time of entry is not taken into account.
+     * NOTE: Idle time of entry is not taken into account.
      * Entry last access time isn't modified if map limited by size.
      *
      * @param key the key

File: redisson/src/main/java/org/redisson/api/RMapCacheAsync.java
Patch:
@@ -280,7 +280,7 @@ public interface RMapCacheAsync<K, V> extends RMapAsync<K, V> {
      * If map doesn't contain value for specified key and {@link MapLoader} is defined
      * then value will be loaded in read-through mode.
      * <p>
-     * Idle time of entry is not taken into account.
+     * NOTE: Idle time of entry is not taken into account.
      * Entry last access time isn't modified if map limited by size.
      *
      * @param key the key

File: redisson/src/main/java/org/redisson/JndiRedissonFactory.java
Patch:
@@ -54,7 +54,8 @@ protected RedissonClient buildClient(String configPath) throws NamingException {
             try {
                 config = Config.fromJSON(new File(configPath), getClass().getClassLoader());
             } catch (IOException e1) {
-                NamingException ex = new NamingException("Can't parse yaml config " + configPath);
+                NamingException ex = new NamingException("Can't parse config " + configPath);
+                e1.addSuppressed(e);
                 ex.initCause(e1);
                 throw ex;
             }

File: redisson/src/main/java/org/redisson/spring/cache/RedissonSpringCacheManager.java
Patch:
@@ -298,12 +298,13 @@ public void afterPropertiesSet() throws Exception {
 
         Resource resource = resourceLoader.getResource(configLocation);
         try {
-            this.configMap = (Map<String, CacheConfig>) CacheConfig.fromJSON(resource.getInputStream());
+            this.configMap = (Map<String, CacheConfig>) CacheConfig.fromYAML(resource.getInputStream());
         } catch (IOException e) {
             // try to read yaml
             try {
-                this.configMap = (Map<String, CacheConfig>) CacheConfig.fromYAML(resource.getInputStream());
+                this.configMap = (Map<String, CacheConfig>) CacheConfig.fromJSON(resource.getInputStream());
             } catch (IOException e1) {
+                e1.addSuppressed(e);
                 throw new BeanDefinitionStoreException(
                         "Could not parse cache configuration at [" + configLocation + "]", e1);
             }

File: redisson/src/main/java/org/redisson/RedissonPermitExpirableSemaphore.java
Patch:
@@ -714,7 +714,7 @@ public RFuture<Void> setPermitsAsync(int permits) {
                 "end;" +
                 "local acquired = redis.call('zcount', KEYS[3], 0, '+inf'); " +
                 "local maximum = (acquired == false and 0 or acquired) + tonumber(available); " +
-                "if (maximum == ARGV[1]) then " +
+                "if (maximum == tonumber(ARGV[1])) then " +
                     "return;" +
                 "end;" +
                 "redis.call('incrby', KEYS[1], tonumber(ARGV[1]) - maximum); " +

File: redisson/src/main/java/org/redisson/connection/SequentialDnsAddressResolverFactory.java
Patch:
@@ -82,7 +82,7 @@ private void execute(Callable<?> callable, Promise<?> promise) {
     private final AsyncSemaphore asyncSemaphore;
 
     public SequentialDnsAddressResolverFactory() {
-        this(8);
+        this(6);
     }
 
     public SequentialDnsAddressResolverFactory(int concurrencyLevel) {

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -1625,6 +1625,8 @@ protected RFuture<Boolean> fastPutOperationAsync(K key, V value) {
                                 + "end; "
                             + "end; "
                             + "if expireDate <= tonumber(ARGV[1]) then "
+                                + "redis.call('zrem', KEYS[2], ARGV[2]); "
+                                + "redis.call('zrem', KEYS[3], ARGV[2]); "
                                 + "insertable = true; "
                             + "end; "
                         + "end; " +

File: redisson/src/main/java/org/redisson/config/BaseMasterSlaveServersConfig.java
Patch:
@@ -134,7 +134,7 @@ public int getFailedSlaveReconnectionInterval() {
     /**
      * Redis Slave node failing to execute commands is excluded from the internal list of available nodes
      * when the time interval from the moment of first Redis command execution failure
-     * on this server reaches <code>slaveFailsInterval</code> value.
+     * on this server reaches <code>failedSlaveCheckInterval</code> value.
      * <p>
      * Default is <code>180000</code>
      *

File: redisson-tomcat/redisson-tomcat-10/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -315,10 +315,9 @@ public void onMessage(CharSequence channel, AttributeMessage msg) {
                             
                             if (msg instanceof SessionDestroyedMessage) {
                                 Session s = findSession(msg.getSessionId(), false);
-                                if (s == null) {
-                                    throw new IllegalStateException("Unable to find session: " + msg.getSessionId());
+                                if (s != null) {
+                                    s.expire();
                                 }
-                                s.expire();
                                 RSet<String> set = getNotifiedNodes(msg.getSessionId());
                                 set.add(nodeId);
                             }

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -315,10 +315,9 @@ public void onMessage(CharSequence channel, AttributeMessage msg) {
                             
                             if (msg instanceof SessionDestroyedMessage) {
                                 Session s = findSession(msg.getSessionId(), false);
-                                if (s == null) {
-                                    throw new IllegalStateException("Unable to find session: " + msg.getSessionId());
+                                if (s != null) {
+                                    s.expire();
                                 }
-                                s.expire();
                                 RSet<String> set = getNotifiedNodes(msg.getSessionId());
                                 set.add(nodeId);
                             }

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -315,10 +315,9 @@ public void onMessage(CharSequence channel, AttributeMessage msg) {
                             
                             if (msg instanceof SessionDestroyedMessage) {
                                 Session s = findSession(msg.getSessionId(), false);
-                                if (s == null) {
-                                    throw new IllegalStateException("Unable to find session: " + msg.getSessionId());
+                                if (s != null) {
+                                    s.expire();
                                 }
-                                s.expire();
                                 RSet<String> set = getNotifiedNodes(msg.getSessionId());
                                 set.add(nodeId);
                             }

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -315,10 +315,9 @@ public void onMessage(CharSequence channel, AttributeMessage msg) {
                             
                             if (msg instanceof SessionDestroyedMessage) {
                                 Session s = findSession(msg.getSessionId(), false);
-                                if (s == null) {
-                                    throw new IllegalStateException("Unable to find session: " + msg.getSessionId());
+                                if (s != null) {
+                                    s.expire();
                                 }
-                                s.expire();
                                 RSet<String> set = getNotifiedNodes(msg.getSessionId());
                                 set.add(nodeId);
                             }

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -310,6 +310,9 @@ private NodeType getNodeType(NodeType type, InetSocketAddress address) {
         if (type != NodeType.SENTINEL) {
             MasterSlaveEntry entry = getEntry(address);
             if (entry != null) {
+                if (!entry.isInit()) {
+                    return type;
+                }
                 InetSocketAddress addr = entry.getClient().getAddr();
                 if (addr.getAddress().equals(address.getAddress())
                         && addr.getPort() == address.getPort()) {

File: redisson/src/main/java/org/redisson/connection/pool/ConnectionPool.java
Patch:
@@ -86,7 +86,7 @@ private CompletableFuture<Void> initConnections(ClientConnectionsEntry entry, bo
 
         CompletableFuture<Void> initPromise = new CompletableFuture<>();
         AtomicInteger initializedConnections = new AtomicInteger(minimumIdleSize);
-        int startAmount = Math.min(2, minimumIdleSize);
+        int startAmount = Math.min(1, minimumIdleSize);
         AtomicInteger requests = new AtomicInteger(startAmount);
         for (int i = 0; i < startAmount; i++) {
             createConnection(checkFreezed, requests, entry, initPromise, minimumIdleSize, initializedConnections);

File: redisson/src/main/java/org/redisson/RedissonReadWriteLock.java
Patch:
@@ -42,12 +42,12 @@ public RedissonReadWriteLock(CommandAsyncExecutor commandExecutor, String name)
 
     @Override
     public RLock readLock() {
-        return new RedissonReadLock(commandExecutor, getRawName());
+        return new RedissonReadLock(commandExecutor, getName());
     }
 
     @Override
     public RLock writeLock() {
-        return new RedissonWriteLock(commandExecutor, getRawName());
+        return new RedissonWriteLock(commandExecutor, getName());
     }
 
 }

File: redisson-spring-boot-starter/src/test/java/org/redisson/spring/starter/RedissonSessionManagerAutoConfigurationTest.java
Patch:
@@ -5,7 +5,7 @@
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.boot.test.context.SpringBootTest;
 import org.springframework.boot.test.web.client.TestRestTemplate;
-import org.springframework.boot.web.server.LocalServerPort;
+import org.springframework.boot.test.web.server.LocalServerPort;
 import org.springframework.http.HttpEntity;
 import org.springframework.http.HttpHeaders;
 import org.springframework.http.HttpMethod;

File: redisson-spring-boot-starter/src/test/java/org/redisson/spring/starter/TestRestController.java
Patch:
@@ -1,12 +1,10 @@
 package org.redisson.spring.starter;
 
-import org.springframework.beans.factory.annotation.Autowired;
+import jakarta.servlet.http.HttpSession;
 import org.springframework.web.bind.annotation.GetMapping;
-import org.springframework.web.bind.annotation.PostMapping;
 import org.springframework.web.bind.annotation.RequestMapping;
 import org.springframework.web.bind.annotation.RestController;
 
-import javax.servlet.http.HttpSession;
 
 /**
  * @author Nikita Koksharov

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -23,6 +23,7 @@
 import io.netty.util.concurrent.FutureListener;
 import org.redisson.RedissonShutdownException;
 import org.redisson.ScanResult;
+import org.redisson.api.NodeType;
 import org.redisson.cache.LRUCacheMap;
 import org.redisson.client.*;
 import org.redisson.client.codec.BaseCodec;
@@ -31,6 +32,7 @@
 import org.redisson.client.protocol.CommandsData;
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.client.protocol.RedisCommands;
+import org.redisson.connection.ClientConnectionsEntry;
 import org.redisson.connection.ConnectionManager;
 import org.redisson.connection.MasterSlaveEntry;
 import org.redisson.connection.NodeSource;

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -23,7 +23,6 @@
 import io.netty.util.concurrent.FutureListener;
 import org.redisson.RedissonShutdownException;
 import org.redisson.ScanResult;
-import org.redisson.api.NodeType;
 import org.redisson.cache.LRUCacheMap;
 import org.redisson.client.*;
 import org.redisson.client.codec.BaseCodec;
@@ -32,7 +31,6 @@
 import org.redisson.client.protocol.CommandsData;
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.client.protocol.RedisCommands;
-import org.redisson.connection.ClientConnectionsEntry;
 import org.redisson.connection.ConnectionManager;
 import org.redisson.connection.MasterSlaveEntry;
 import org.redisson.connection.NodeSource;

File: redisson/src/main/java/org/redisson/client/RedisBusyException.java
Patch:
@@ -21,7 +21,7 @@
  * @author wuqian
  *
  */
-public class RedisBusyException extends RedisException{
+public class RedisBusyException extends RedisRetryException {
 
     private static final long serialVersionUID = -5658453331593019251L;
 

File: redisson/src/main/java/org/redisson/client/RedisClusterDownException.java
Patch:
@@ -21,7 +21,7 @@
  * @author Nikita Koksharov
  *
  */
-public class RedisClusterDownException extends RedisException {
+public class RedisClusterDownException extends RedisRetryException {
 
     private static final long serialVersionUID = -2565335188503354660L;
 

File: redisson/src/main/java/org/redisson/client/RedisLoadingException.java
Patch:
@@ -20,7 +20,7 @@
  * @author Nikita Koksharov
  *
  */
-public class RedisLoadingException extends RedisException {
+public class RedisLoadingException extends RedisRetryException {
 
     private static final long serialVersionUID = -2565335188503354660L;
 

File: redisson/src/main/java/org/redisson/client/RedisTryAgainException.java
Patch:
@@ -20,7 +20,7 @@
  * @author Nikita Koksharov
  *
  */
-public class RedisTryAgainException extends RedisException {
+public class RedisTryAgainException extends RedisRetryException {
 
     private static final long serialVersionUID = -2565335188503354660L;
 

File: redisson/src/main/java/org/redisson/client/RedisWaitException.java
Patch:
@@ -21,7 +21,7 @@
  * @author Nikita Koksharov
  *
  */
-public class RedisWaitException extends RedisException{
+public class RedisWaitException extends RedisRetryException {
 
     private static final long serialVersionUID = -5658453331593019251L;
 

File: redisson/src/main/java/org/redisson/connection/pool/ConnectionPool.java
Patch:
@@ -97,7 +97,7 @@ private CompletableFuture<Void> initConnections(ClientConnectionsEntry entry, bo
     private void createConnection(boolean checkFreezed, AtomicInteger requests, ClientConnectionsEntry entry,
                                   CompletableFuture<Void> initPromise, int minimumIdleSize, AtomicInteger initializedConnections) {
 
-        if ((checkFreezed && entry.isFreezed()) || !tryAcquireConnection(entry)) {
+        if (checkFreezed && (entry.isFreezed() || !isHealthy(entry))) {
             int totalInitializedConnections = minimumIdleSize - initializedConnections.get();
             Throwable cause = new RedisConnectionException(
                     "Unable to init enough connections amount! Only " + totalInitializedConnections + " of " + minimumIdleSize + " were initialized. Server: "
@@ -181,7 +181,7 @@ public CompletableFuture<T> get(RedisCommand<?> command) {
         for (Iterator<ClientConnectionsEntry> iterator = entriesCopy.iterator(); iterator.hasNext();) {
             ClientConnectionsEntry entry = iterator.next();
             if (!((!entry.isFreezed() || entry.isMasterForRead()) 
-                    && tryAcquireConnection(entry))) {
+                    && isHealthy(entry))) {
                 iterator.remove();
             }
         }
@@ -233,7 +233,7 @@ protected final CompletableFuture<T> acquireConnection(RedisCommand<?> command,
         return result;
     }
         
-    protected boolean tryAcquireConnection(ClientConnectionsEntry entry) {
+    private boolean isHealthy(ClientConnectionsEntry entry) {
         if (entry.getNodeType() == NodeType.SLAVE && entry.isFailed()) {
             checkForReconnect(entry, null);
             return false;

File: redisson/src/test/java/org/redisson/RedissonMapCacheTest.java
Patch:
@@ -1251,6 +1251,8 @@ public void testAddAndGetTTL() {
         assertThat(mapCache.putIfAbsent("4", 0L, 10000L, TimeUnit.SECONDS)).isNull();
         assertThat(mapCache.addAndGet("4", 1L)).isEqualTo(1L);
         assertThat(mapCache.putIfAbsent("4", 0L)).isEqualTo(1L);
+        assertThat(mapCache.addAndGet("key", Long.MAX_VALUE-10)).isEqualTo(Long.MAX_VALUE-10);
+        assertThat(mapCache.addAndGet("key", 10L)).isEqualTo(Long.MAX_VALUE);
         Assertions.assertEquals(1L, mapCache.get("4"));
         mapCache.destroy();
         mapCache = redisson.getMapCache("test_put_if_absent_1", LongCodec.INSTANCE);

File: redisson/src/test/java/org/redisson/RedissonBatchTest.java
Patch:
@@ -187,7 +187,9 @@ public void testConnectionLeak(BatchOptions batchOptions) throws Exception {
 			});
 		}
 
-		Awaitility.await().atMost(10, TimeUnit.SECONDS).until(() -> counter.get() == 0);
+		Awaitility.await().atMost(13, TimeUnit.SECONDS).until(() -> {
+            return counter.get() == 0;
+        });
 		Assertions.assertThat(hasErrors).isTrue();
 
 		executeBatch(redisson, batchOptions).toCompletableFuture().join();

File: redisson/src/main/java/org/redisson/command/RedisBatchExecutor.java
Patch:
@@ -20,7 +20,6 @@
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.command.CommandBatchService.Entry;
 import org.redisson.connection.ConnectionManager;
-import org.redisson.connection.MasterSlaveEntry;
 import org.redisson.connection.NodeSource;
 import org.redisson.liveobject.core.RedissonObjectBuilder;
 
@@ -41,7 +40,7 @@ public class RedisBatchExecutor<V, R> extends BaseRedisBatchExecutor<V, R> {
     @SuppressWarnings("ParameterNumber")
     public RedisBatchExecutor(boolean readOnlyMode, NodeSource source, Codec codec, RedisCommand<V> command,
                               Object[] params, CompletableFuture<R> mainPromise, boolean ignoreRedirect, ConnectionManager connectionManager,
-                              RedissonObjectBuilder objectBuilder, ConcurrentMap<MasterSlaveEntry, Entry> commands,
+                              RedissonObjectBuilder objectBuilder, ConcurrentMap<NodeSource, Entry> commands,
                               BatchOptions options, AtomicInteger index,
                               AtomicBoolean executed, RedissonObjectBuilder.ReferenceType referenceType, boolean noRetry) {
         super(readOnlyMode, source, codec, command, params, mainPromise, ignoreRedirect, connectionManager, objectBuilder,

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -908,13 +908,13 @@ private void addCascadeSlaves(Collection<ClusterPartition> partitions) {
     }
 
     @Override
-    public void shutdown() {
+    public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {
         if (monitorFuture != null) {
             monitorFuture.cancel(true);
         }
         
         closeNodeConnections();
-        super.shutdown();
+        super.shutdown(quietPeriod, timeout, unit);
     }
 
     private Map<RedisURI, ClusterPartition> getLastPartitonsByURI() {

File: redisson/src/main/java/org/redisson/connection/ReplicatedConnectionManager.java
Patch:
@@ -254,13 +254,13 @@ private CompletableFuture<Void> slaveUp(InetSocketAddress address, RedisURI uri)
     }
 
     @Override
-    public void shutdown() {
+    public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {
         if (monitorFuture != null) {
             monitorFuture.cancel(true);
         }
         
         closeNodeConnections();
-        super.shutdown();
+        super.shutdown(quietPeriod, timeout, unit);
     }
 }
 

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -656,7 +656,7 @@ public Collection<RedisClient> getSentinels() {
     }
 
     @Override
-    public void shutdown() {
+    public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {
         if (monitorFuture != null) {
             monitorFuture.cancel(true);
         }
@@ -665,7 +665,7 @@ public void shutdown() {
                 .map(s -> s.shutdownAsync())
                 .forEach(f -> f.toCompletableFuture().join());
 
-        super.shutdown();
+        super.shutdown(quietPeriod, timeout, unit);
     }
 
     private RedisURI applyNatMap(RedisURI address) {

File: redisson/src/main/java/org/redisson/config/ConfigSupport.java
Patch:
@@ -41,7 +41,6 @@
 import java.io.*;
 import java.net.URL;
 import java.util.Scanner;
-import java.util.UUID;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 

File: redisson/src/test/java/org/redisson/rx/RedissonBlockingDequeRxTest.java
Patch:
@@ -53,7 +53,7 @@ public void testPollLastAndOfferFirstTo() throws InterruptedException {
         RBlockingDequeRx<String> blockingDeque = redisson.getBlockingDeque("blocking_deque");
         long start = System.currentTimeMillis();
         String redisTask = sync(blockingDeque.pollLastAndOfferFirstTo("deque", 1, TimeUnit.SECONDS));
-        assertThat(System.currentTimeMillis() - start).isBetween(950L, 1400L);
+        assertThat(System.currentTimeMillis() - start).isBetween(950L, 1500L);
         assertThat(redisTask).isNull();
     }
     

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -523,7 +523,8 @@ protected void checkAttemptPromise(CompletableFuture<R> attemptFuture, Completab
             if (cause instanceof RedisLoadingException
                     || cause instanceof RedisTryAgainException
                         || cause instanceof RedisClusterDownException
-                            || cause instanceof RedisBusyException) {
+                            || cause instanceof RedisBusyException
+                                || cause instanceof RedisWaitException) {
                 if (attempt < attempts) {
                     onException();
                     connectionManager.newTimeout(timeout -> {

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -267,7 +267,7 @@ protected RFuture<V> getAsync(K key, long threadId) {
             return new CompletableFutureWrapper<>(f);
         }
 
-        RFuture<V> future = super.getAsync((K) key);
+        RFuture<V> future = super.getAsync((K) key, threadId);
         CompletionStage<V> result = future.thenApply(value -> {
             if (storeCacheMiss || value != null) {
                 cachePut(cacheKey, key, value);

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -243,7 +243,7 @@ public RFuture<Boolean> containsValueAsync(Object value) {
     }
     
     @Override
-    public RFuture<V> getAsync(Object key) {
+    protected RFuture<V> getAsync(K key, long threadId) {
         checkKey(key);
 
         CacheKey cacheKey = localCacheView.toCacheKey(key);
@@ -257,7 +257,7 @@ public RFuture<V> getAsync(Object key) {
                 return new CompletableFutureWrapper((Void) null);
             }
 
-            CompletableFuture<V> future = loadValue((K) key, false);
+            CompletableFuture<V> future = loadValue((K) key, false, threadId);
             CompletableFuture<V> f = future.thenApply(value -> {
                 if (storeCacheMiss || value != null) {
                     cachePut(cacheKey, key, value);

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -139,9 +139,6 @@ public void execute() {
                 if (command.isBlockingCommand()) {
                     RedisConnection c = connectionFuture.getNow(null);
                     if (writeFuture.cancel(false)) {
-                        if (c.getCurrentCommand().getCommand() == command) {
-                            c.clearCurrentCommand();
-                        }
                         attemptPromise.cancel(false);
                     } else {
                         c.forceFastReconnectAsync().whenComplete((res, ex) -> {

File: redisson/src/test/java/org/redisson/RedissonStreamTest.java
Patch:
@@ -18,8 +18,6 @@ public class RedissonStreamTest extends BaseTest {
 
     @Test
     public void testEmptyMap() {
-        Assumptions.assumeTrue(RedisRunner.getDefaultRedisServerInstance().getRedisVersion().compareTo("6.2.0") > 0);
-
         RStream<Object, Object> stream = redisson.getStream("stream");
         stream.createGroup("group");
         stream.add(StreamAddArgs.entry("key", "value"));

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -259,6 +259,9 @@ public Object decode(List<Object> parts, State state) {
                     new ObjectDecoder(StringCodec.INSTANCE.getValueDecoder()) {
                         @Override
                         public Object decode(List parts, State state) {
+                            if (parts.isEmpty()) {
+                                return null;
+                            }
                             return Collections.singletonMap(parts.get(0), parts.get(1));
                         }
                     },

File: redisson/src/test/java/org/redisson/RedissonBlockingDequeTest.java
Patch:
@@ -69,7 +69,7 @@ public void testMove() {
     @Test
     public void testPollLastAndOfferFirstTo() throws InterruptedException {
         RBlockingDeque<String> blockingDeque = redisson.getBlockingDeque("blocking_deque");
-        Awaitility.await().between(Duration.ofMillis(1000), Duration.ofMillis(1200)).untilAsserted(() -> {
+        Awaitility.await().between(Duration.ofMillis(1000), Duration.ofMillis(1300)).untilAsserted(() -> {
             String redisTask = blockingDeque.pollLastAndOfferFirstTo("deque", 1, TimeUnit.SECONDS);
             assertThat(redisTask).isNull();
         });

File: redisson/src/main/java/org/redisson/api/RSet.java
Patch:
@@ -328,6 +328,8 @@ public interface RSet<V> extends Set<V>, RExpirable, RSetAsync<V>, RSortable<Set
     /**
      * Check if each element is contained in the specified collection.
      * Returns contained elements.
+     * <p>
+     * Requires <b>Redis 6.2.0 and higher.</b>
      *
      * @param c - collection to check
      * @return contained elements

File: redisson/src/main/java/org/redisson/api/RSetAsync.java
Patch:
@@ -183,6 +183,8 @@ public interface RSetAsync<V> extends RCollectionAsync<V>, RSortableAsync<Set<V>
     /**
      * Check if each element is contained in the specified collection.
      * Returns contained elements.
+     * <p>
+     * Requires <b>Redis 6.2.0 and higher.</b>
      *
      * @param c - collection to check
      * @return contained elements

File: redisson/src/main/java/org/redisson/api/RSetReactive.java
Patch:
@@ -252,6 +252,8 @@ public interface RSetReactive<V> extends RCollectionReactive<V>, RSortableReacti
     /**
      * Check if each element is contained in the specified collection.
      * Returns contained elements.
+     * <p>
+     * Requires <b>Redis 6.2.0 and higher.</b>
      *
      * @param c - collection to check
      * @return contained elements

File: redisson/src/main/java/org/redisson/api/RSetRx.java
Patch:
@@ -254,6 +254,8 @@ public interface RSetRx<V> extends RCollectionRx<V>, RSortableRx<Set<V>> {
     /**
      * Check if each element is contained in the specified collection.
      * Returns contained elements.
+     * <p>
+     * Requires <b>Redis 6.2.0 and higher.</b>
      *
      * @param c - collection to check
      * @return contained elements

File: redisson/src/main/java/org/redisson/codec/Kryo5Codec.java
Patch:
@@ -59,14 +59,14 @@ public <T> ObjectInstantiator<T> newInstantiatorOf(Class<T> type) {
             try {
                 Constructor ctor;
                 try {
-                    ctor = type.getConstructor((Class[])null);
+                    ctor = type.getConstructor((Class[]) null);
                 } catch (Exception ex) {
-                    ctor = type.getDeclaredConstructor((Class[])null);
+                    ctor = type.getDeclaredConstructor((Class[]) null);
                     ctor.setAccessible(true);
                 }
                 final Constructor constructor = ctor;
                 return new ObjectInstantiator() {
-                    public Object newInstance () {
+                    public Object newInstance() {
                         try {
                             return constructor.newInstance();
                         } catch (Exception ex) {

File: redisson/src/main/java/org/redisson/RedissonFuction.java
Patch:
@@ -126,8 +126,8 @@ public void loadAndReplace(String libraryName, String code) {
 
     @Override
     public RFuture<Void> loadAndReplaceAsync(String libraryName, String code) {
-        return commandExecutor.writeAllVoidAsync(RedisCommands.FUNCTION_LOAD,
-                                                "Lua", libraryName, "REPLACE", code);
+        return commandExecutor.writeAllVoidAsync(RedisCommands.FUNCTION_LOAD, "REPLACE",
+                                                                                "#!lua name=" + libraryName + " \n " + code);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonFuction.java
Patch:
@@ -116,7 +116,7 @@ public void load(String libraryName, String code) {
 
     @Override
     public RFuture<Void> loadAsync(String libraryName, String code) {
-        return commandExecutor.writeAllVoidAsync(RedisCommands.FUNCTION_LOAD, "Lua", libraryName, code);
+        return commandExecutor.writeAllVoidAsync(RedisCommands.FUNCTION_LOAD, "#!lua name=" + libraryName + " \n " + code);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/api/RPermitExpirableSemaphore.java
Patch:
@@ -131,14 +131,13 @@ public interface RPermitExpirableSemaphore extends RExpirable, RPermitExpirableS
     boolean trySetPermits(int permits);
 
     /**
-     * Sets the number of permits to the provided value and returns the number of permits added.
+     * Sets the number of permits to the provided value.
      * Calculates the <code>delta</code> between the given <code>permits</code> value and the
      * current number of permits, then increases the number of available permits by <code>delta</code>.
      *
      * @param permits - number of permits
-     * @return delta - number of permits that were added, will be negative if permits were removed
      */
-    int setPermits(int permits);
+    void setPermits(int permits);
 
     /**
      * Increases or decreases the number of available permits by defined value. 

File: redisson/src/main/java/org/redisson/api/RBatch.java
Patch:
@@ -258,7 +258,7 @@ public interface RBatch {
      * @param name - name of object
      * @return ListMultimapCache object
      */
-    <K, V> RMultimapAsync<K, V> getListMultimapCache(String name);
+    <K, V> RMultimapCacheAsync<K, V> getListMultimapCache(String name);
     
     /**
      * Returns List based Multimap instance by name
@@ -273,7 +273,7 @@ public interface RBatch {
      * @param codec - codec for keys and values
      * @return ListMultimapCache object
      */
-    <K, V> RMultimapAsync<K, V> getListMultimapCache(String name, Codec codec);
+    <K, V> RMultimapCacheAsync<K, V> getListMultimapCache(String name, Codec codec);
     
     /**
      * Returns map instance by name.

File: redisson/src/main/java/org/redisson/RedissonBloomFilter.java
Patch:
@@ -187,7 +187,7 @@ public boolean contains(T object) {
     }
 
     protected RBitSetAsync createBitSet(CommandBatchService executorService) {
-        return new RedissonBitSet(executorService, getRawName());
+        return new RedissonBitSet(executorService, getName());
     }
 
     private void addConfigCheck(int hashIterations, long size, CommandBatchService executorService) {

File: redisson/src/main/java/org/redisson/RedissonTopic.java
Patch:
@@ -106,7 +106,7 @@ public int addListener(StatusListener listener) {
 
     @Override
     public <M> int addListener(Class<M> type, MessageListener<? extends M> listener) {
-        RFuture<Integer> future = addListenerAsync(type, (MessageListener<M>) listener);
+        RFuture<Integer> future = addListenerAsync(type, listener);
         return commandExecutor.get(future.toCompletableFuture());
     }
 
@@ -117,8 +117,8 @@ public RFuture<Integer> addListenerAsync(StatusListener listener) {
     }
 
     @Override
-    public <M> RFuture<Integer> addListenerAsync(Class<M> type, MessageListener<M> listener) {
-        PubSubMessageListener<M> pubSubListener = new PubSubMessageListener<>(type, listener, name);
+    public <M> RFuture<Integer> addListenerAsync(Class<M> type, MessageListener<? extends M> listener) {
+        PubSubMessageListener<M> pubSubListener = new PubSubMessageListener<>(type, (MessageListener<M>) listener, name);
         return addListenerAsync(pubSubListener);
     }
 

File: redisson/src/main/java/org/redisson/api/RTopicAsync.java
Patch:
@@ -54,7 +54,7 @@ public interface RTopicAsync {
      * @return locally unique listener id
      * @see org.redisson.api.listener.MessageListener
      */
-    <M> RFuture<Integer> addListenerAsync(Class<M> type, MessageListener<M> listener);
+    <M> RFuture<Integer> addListenerAsync(Class<M> type, MessageListener<? extends M> listener);
     
     /**
      * Removes the listener by <code>id</code> for listening this topic

File: redisson/src/main/java/org/redisson/RedissonBloomFilter.java
Patch:
@@ -187,7 +187,7 @@ public boolean contains(T object) {
     }
 
     protected RBitSetAsync createBitSet(CommandBatchService executorService) {
-        return new RedissonBitSet(executorService, getRawName());
+        return new RedissonBitSet(executorService, getName());
     }
 
     private void addConfigCheck(int hashIterations, long size, CommandBatchService executorService) {

File: redisson/src/main/java/org/redisson/pubsub/PublishSubscribeService.java
Patch:
@@ -324,7 +324,8 @@ private void subscribeNoTimeout(Codec codec, ChannelName channelName, MasterSlav
 
                 CompletableFuture<RedisPubSubConnection> connectFuture = connect(codec, channelName, entry, promise, type, lock, listeners);
                 connectionManager.newTimeout(t -> {
-                    if (!connectFuture.cancel(false)) {
+                    if (!connectFuture.cancel(false)
+                            && !connectFuture.isCompletedExceptionally()) {
                         return;
                     }
 

File: redisson/src/test/java/org/redisson/executor/RedissonExecutorServiceTest.java
Patch:
@@ -318,7 +318,7 @@ public void testTaskId() throws ExecutionException, InterruptedException {
         RExecutorFuture<?> future = executor.submit(new TestClass());
         future.get();
         String id = redisson.<String>getBucket("id").get();
-        assertThat(id).hasSize(34);
+        assertThat(future.getTaskId()).isEqualTo(id);
     }
 
     @Test

File: redisson/src/test/java/org/redisson/executor/RedissonScheduledExecutorServiceTest.java
Patch:
@@ -254,7 +254,7 @@ void finish(Invocation invocation, String requestId, boolean removeTask) {
         assertThat(redisson.getAtomicLong("counter").get()).isEqualTo(2);
         
         redisson.getKeys().delete("counter");
-        assertThat(redisson.getKeys().count()).isEqualTo(2);
+        assertThat(redisson.getKeys().count()).isEqualTo(1);
     }
 
     @Test

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -261,10 +261,10 @@ protected RFuture<Long> pushTaskAsync() {
                               + "for i = 1, #expiredTaskIds, 1 do "
                                   + "local name = expiredTaskIds[i];"
                                   + "local scheduledName = expiredTaskIds[i];"
-                                  + "if string.sub(scheduledName, 1, 2) ~= 'ff' then "
-                                      + "scheduledName = 'ff' .. scheduledName; "
+                                  + "if string.sub(scheduledName, 1, 3) ~= 'ff:' then "
+                                      + "scheduledName = 'ff:' .. scheduledName; "
                                   + "else "
-                                      + "name = string.sub(name, 3, string.len(name)); "
+                                      + "name = string.sub(name, 4, string.len(name)); "
                                   + "end;"
                                       
                                   + "redis.call('zadd', KEYS[2], startTime, scheduledName);"

File: redisson/src/main/java/org/redisson/executor/RedissonExecutorRemoteService.java
Patch:
@@ -71,7 +71,7 @@ protected RFuture<RemoteServiceRequest> getTask(String requestId, RMap<String, R
                     + "redis.call('zrem', KEYS[2], ARGV[1]); "
 
                     + "redis.call('zrem', KEYS[7], ARGV[1]); "
-                    + "redis.call('zrem', KEYS[7], 'ff' .. ARGV[1]);"
+                    + "redis.call('zrem', KEYS[7], 'ff:' .. ARGV[1]);"
 
                     + "redis.call('hdel', KEYS[1], ARGV[1]); "
                     + "if redis.call('decr', KEYS[3]) == 0 then "

File: redisson/src/main/java/org/redisson/executor/ScheduledTasksService.java
Patch:
@@ -62,11 +62,11 @@ protected CompletableFuture<Boolean> addAsync(String requestQueueName, RemoteSer
                     + "local retryInterval = redis.call('get', KEYS[6]); "
                     + "if retryInterval ~= false then "
                         + "local time = tonumber(ARGV[1]) + tonumber(retryInterval);"
-                        + "redis.call('zadd', KEYS[3], time, 'ff' .. ARGV[2]);"
+                        + "redis.call('zadd', KEYS[3], time, 'ff:' .. ARGV[2]);"
                     + "elseif tonumber(ARGV[4]) > 0 then "
                         + "redis.call('set', KEYS[6], ARGV[4]);"
                         + "local time = tonumber(ARGV[1]) + tonumber(ARGV[4]);"
-                        + "redis.call('zadd', KEYS[3], time, 'ff' .. ARGV[2]);"
+                        + "redis.call('zadd', KEYS[3], time, 'ff:' .. ARGV[2]);"
                     + "end; "
 
                     + "if tonumber(ARGV[5]) > 0 then "
@@ -102,7 +102,7 @@ protected CompletableFuture<Boolean> removeAsync(String requestQueueName, String
                   + "local task = redis.call('hget', KEYS[6], ARGV[1]); "
                   + "redis.call('hdel', KEYS[6], ARGV[1]); "
                   
-                  + "redis.call('zrem', KEYS[2], 'ff' .. ARGV[1]); "
+                  + "redis.call('zrem', KEYS[2], 'ff:' .. ARGV[1]); "
                   + "redis.call('zrem', KEYS[8], ARGV[1]); "
 
                   + "local removedScheduled = redis.call('zrem', KEYS[2], ARGV[1]); "

File: redisson/src/main/java/org/redisson/executor/TasksService.java
Patch:
@@ -133,7 +133,7 @@ protected CompletableFuture<Boolean> addAsync(String requestQueueName, RemoteSer
 
                             + "if tonumber(ARGV[1]) > 0 then "
                                 + "redis.call('set', KEYS[7], ARGV[4]);"
-                                + "redis.call('zadd', KEYS[3], ARGV[1], 'ff' .. ARGV[2]);"
+                                + "redis.call('zadd', KEYS[3], ARGV[1], 'ff:' .. ARGV[2]);"
                                 + "local v = redis.call('zrange', KEYS[3], 0, 0); "
                                 // if new task added to queue head then publish its startTime
                                 // to all scheduler workers
@@ -157,7 +157,7 @@ protected CompletableFuture<Boolean> removeAsync(String requestQueueName, String
                     "return nil;" +
                 "end;" +
 
-                "redis.call('zrem', KEYS[2], 'ff' .. ARGV[1]); "
+                "redis.call('zrem', KEYS[2], 'ff:' .. ARGV[1]); "
               + "redis.call('zrem', KEYS[8], ARGV[1]); "
               + "local task = redis.call('hget', KEYS[6], ARGV[1]); "
               + "redis.call('hdel', KEYS[6], ARGV[1]); "

File: redisson/src/test/java/org/redisson/RedissonTopicTest.java
Patch:
@@ -290,6 +290,7 @@ public void onMessage(CharSequence channel, Long msg) {
         
         await().atMost(Duration.ofSeconds(1)).untilTrue(stringMessageReceived);
         await().atMost(Duration.ofSeconds(1)).untilTrue(longMessageReceived);
+        redisson.shutdown();
     }
     
     @Test
@@ -366,6 +367,7 @@ public void onUnsubscribe(String channel) {
         topic1.removeListener(listenerId2);
 
         assertThat(l.await(5, TimeUnit.SECONDS)).isTrue();
+        redisson.shutdown();
     }
 
     @Test

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -244,7 +244,6 @@ private void removeEntry(Integer slot) {
 
     private void shutdownEntry(MasterSlaveEntry entry) {
         if (entry != null && entry.decReference() == 0) {
-            client2entry.remove(entry.getClient());
             entry.getAllEntries().forEach(e -> {
                 RedisURI uri = new RedisURI(e.getClient().getConfig().getAddress().getScheme(),
                         e.getClient().getAddr().getAddress().getHostAddress(),
@@ -260,6 +259,8 @@ private void shutdownEntry(MasterSlaveEntry entry) {
                                         entry.getClient().getAddr().getPort());
             disconnectNode(uri);
 
+            client2entry.remove(entry.getClient());
+
             String slaves = entry.getAllEntries().stream()
                     .filter(e -> !e.getClient().getAddr().equals(entry.getClient().getAddr()))
                     .map(e -> e.getClient().toString())

File: redisson/src/test/java/org/redisson/RedissonFunctionTest.java
Patch:
@@ -7,6 +7,7 @@
 import org.redisson.client.codec.LongCodec;
 import org.redisson.client.codec.StringCodec;
 
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
@@ -73,11 +74,11 @@ public void testKeysLoadAsExpected() {
 	f.flush();
 	f.load("lib", "redis.register_function('myfun', function(keys, args) return keys[1] end)" +
 					"redis.register_function('myfun2', function(keys, args) return args[1] end");
-	String s = f.call(FunctionMode.READ, "myfun", FunctionResult.VALUE, List.of("testKey"), "arg1");
+	String s = f.call(FunctionMode.READ, "myfun", FunctionResult.VALUE, Arrays.asList("testKey"), "arg1");
 	assertThat(s).isEqualTo("testKey");
 
 	RFunction f2 = redisson.getFunction(StringCodec.INSTANCE);
-	String s2 = f2.call(FunctionMode.READ, "myfun2", FunctionResult.STRING, List.of("testKey1", "testKey2"), "arg1");
+	String s2 = f2.call(FunctionMode.READ, "myfun2", FunctionResult.STRING, Arrays.asList("testKey1", "testKey2"), "arg1");
 	assertThat(s2).isEqualTo("arg1");
     }
 

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -98,7 +98,7 @@ protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object>
                 }
             }
         } else {
-            if (!holder.getChannelPromise().isSuccess()) {
+            if (holder.getChannelPromise().isDone() && !holder.getChannelPromise().isSuccess()) {
                 sendNext(ctx.channel());
                 // throw REPLAY error
                 in.indexOf(Integer.MAX_VALUE/2, Integer.MAX_VALUE, (byte) 0);

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -187,7 +187,7 @@ private void scheduleConnectionTimeout(CompletableFuture<R> attemptPromise, Comp
         TimerTask task = timeout -> {
             if (connectionFuture.cancel(false)) {
                 exception = new RedisTimeoutException("Unable to acquire connection! " + this.connectionFuture +
-                        "Increase connection pool size. "
+                        "Increase connection pool size or timeout. "
                         + "Node source: " + source
                         + ", command: " + LogHelper.toString(command, params)
                         + " after " + attempt + " retry attempts");

File: redisson/src/main/java/org/redisson/RedissonFuction.java
Patch:
@@ -199,7 +199,7 @@ public <R> RFuture<R> callAsync(String key, FunctionMode mode, String name, Func
         args.add(name);
         args.add(keys.size());
         if (keys.size() > 0) {
-            args.add(keys);
+            args.addAll(keys);
         }
         args.addAll(encode(Arrays.asList(values), codec));
         if (mode == FunctionMode.READ) {

File: redisson/src/main/java/org/redisson/codec/JsonJacksonCodec.java
Patch:
@@ -130,7 +130,7 @@ private void warmup() {
     }
 
     protected static ObjectMapper createObjectMapper(ClassLoader classLoader, ObjectMapper om) {
-        TypeFactory tf = TypeFactory.defaultInstance().withClassLoader(classLoader);
+        TypeFactory tf = om.getTypeFactory().withClassLoader(classLoader);
         om.setTypeFactory(tf);
         return om;
     }

File: redisson/src/main/java/org/redisson/RedissonFuction.java
Patch:
@@ -199,7 +199,7 @@ public <R> RFuture<R> callAsync(String key, FunctionMode mode, String name, Func
         args.add(name);
         args.add(keys.size());
         if (keys.size() > 0) {
-            args.add(keys);
+            args.addAll(keys);
         }
         args.addAll(encode(Arrays.asList(values), codec));
         if (mode == FunctionMode.READ) {

File: redisson/src/main/java/org/redisson/codec/JsonJacksonCodec.java
Patch:
@@ -130,7 +130,7 @@ private void warmup() {
     }
 
     protected static ObjectMapper createObjectMapper(ClassLoader classLoader, ObjectMapper om) {
-        TypeFactory tf = TypeFactory.defaultInstance().withClassLoader(classLoader);
+        TypeFactory tf = om.getTypeFactory().withClassLoader(classLoader);
         om.setTypeFactory(tf);
         return om;
     }

File: redisson-micronaut/redisson-micronaut-20/src/main/java/org/redisson/micronaut/cache/BaseCacheConfiguration.java
Patch:
@@ -57,10 +57,10 @@ public Codec getCodec() {
 
     /**
      * Redis data codec applied to cache entries.
-     * Default is MarshallingCodec codec
+     * Default is Kryo5Codec codec
      *
      * @see Codec
-     * @see org.redisson.codec.MarshallingCodec
+     * @see org.redisson.codec.Kryo5Codec
      *
      * @param codec - data codec
      * @return config

File: redisson-micronaut/redisson-micronaut-20/src/main/java/org/redisson/micronaut/session/RedissonHttpSessionConfiguration.java
Patch:
@@ -72,10 +72,10 @@ public Codec getCodec() {
 
     /**
      * Redis data codec applied to session values.
-     * Default is MarshallingCodec codec
+     * Default is Kryo5Codec codec
      *
      * @see org.redisson.client.codec.Codec
-     * @see org.redisson.codec.MarshallingCodec
+     * @see org.redisson.codec.Kryo5Codec
      *
      * @param codec - data codec
      * @return config

File: redisson-micronaut/redisson-micronaut-30/src/main/java/org/redisson/micronaut/cache/BaseCacheConfiguration.java
Patch:
@@ -57,10 +57,10 @@ public Codec getCodec() {
 
     /**
      * Redis data codec applied to cache entries.
-     * Default is MarshallingCodec codec
+     * Default is Kryo5Codec codec
      *
      * @see Codec
-     * @see org.redisson.codec.MarshallingCodec
+     * @see org.redisson.codec.Kryo5Codec
      *
      * @param codec - data codec
      * @return config

File: redisson-micronaut/redisson-micronaut-30/src/main/java/org/redisson/micronaut/session/RedissonHttpSessionConfiguration.java
Patch:
@@ -72,10 +72,10 @@ public Codec getCodec() {
 
     /**
      * Redis data codec applied to session values.
-     * Default is MarshallingCodec codec
+     * Default is Kryo5Codec codec
      *
      * @see org.redisson.client.codec.Codec
-     * @see org.redisson.codec.MarshallingCodec
+     * @see org.redisson.codec.Kryo5Codec
      *
      * @param codec - data codec
      * @return config

File: redisson-quarkus/redisson-quarkus-16/deployment/src/main/java/io/quarkus/redisson/client/deployment/QuarkusRedissonClientProcessor.java
Patch:
@@ -64,8 +64,7 @@ void addConfig(BuildProducer<NativeImageResourceBuildItem> nativeResources,
         nativeResources.produce(new NativeImageResourceBuildItem("META-INF/services/org.jboss.marshalling.ProviderDescriptor"));
         watchedFiles.produce(new HotDeploymentWatchedFileBuildItem("redisson.yaml"));
 
-        reflectiveItems.produce(new ReflectiveClassBuildItem(false, false, "org.redisson.codec.MarshallingCodec"));
-        reflectiveItems.produce(new ReflectiveClassBuildItem(false, false, "org.jboss.marshalling.river.RiverProviderDescriptor"));
+        reflectiveItems.produce(new ReflectiveClassBuildItem(false, false, "org.redisson.codec.Kryo5Codec"));
 
         reflectiveItems.produce(new ReflectiveClassBuildItem(true, false, "org.redisson.executor.RemoteExecutorService"));
         reflectiveItems.produce(new ReflectiveClassBuildItem(true, false, "org.redisson.executor.RemoteExecutorServiceAsync"));

File: redisson-quarkus/redisson-quarkus-20/deployment/src/main/java/io/quarkus/redisson/client/deployment/QuarkusRedissonClientProcessor.java
Patch:
@@ -64,8 +64,7 @@ void addConfig(BuildProducer<NativeImageResourceBuildItem> nativeResources,
         nativeResources.produce(new NativeImageResourceBuildItem("META-INF/services/org.jboss.marshalling.ProviderDescriptor"));
         watchedFiles.produce(new HotDeploymentWatchedFileBuildItem("redisson.yaml"));
 
-        reflectiveItems.produce(new ReflectiveClassBuildItem(false, false, "org.redisson.codec.MarshallingCodec"));
-        reflectiveItems.produce(new ReflectiveClassBuildItem(false, false, "org.jboss.marshalling.river.RiverProviderDescriptor"));
+        reflectiveItems.produce(new ReflectiveClassBuildItem(false, false, "org.redisson.codec.Kryo5Codec"));
 
         reflectiveItems.produce(new ReflectiveClassBuildItem(true, false, "org.redisson.executor.RemoteExecutorService"));
         reflectiveItems.produce(new ReflectiveClassBuildItem(true, false, "org.redisson.executor.RemoteExecutorServiceAsync"));

File: redisson/src/main/java/org/redisson/codec/Kryo5Codec.java
Patch:
@@ -24,6 +24,7 @@
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.ByteBufInputStream;
 import io.netty.buffer.ByteBufOutputStream;
+import org.objenesis.strategy.StdInstantiatorStrategy;
 import org.redisson.client.codec.BaseCodec;
 import org.redisson.client.handler.State;
 import org.redisson.client.protocol.Decoder;
@@ -82,6 +83,7 @@ protected Kryo createKryo(ClassLoader classLoader) {
         if (classLoader != null) {
             kryo.setClassLoader(classLoader);
         }
+        kryo.setInstantiatorStrategy(new StdInstantiatorStrategy());
         kryo.setRegistrationRequired(false);
         kryo.setReferences(false);
         kryo.addDefaultSerializer(Throwable.class, new JavaSerializer());

File: redisson/src/main/java/org/redisson/codec/SnappyCodec.java
Patch:
@@ -48,15 +48,15 @@ protected Snappy initialValue() {
     private final Codec innerCodec;
 
     public SnappyCodec() {
-        this(new MarshallingCodec());
+        this(new Kryo5Codec());
     }
 
     public SnappyCodec(Codec innerCodec) {
         this.innerCodec = innerCodec;
     }
 
     public SnappyCodec(ClassLoader classLoader) {
-        this(new MarshallingCodec(classLoader));
+        this(new Kryo5Codec(classLoader));
     }
     
     public SnappyCodec(ClassLoader classLoader, SnappyCodec codec) throws ReflectiveOperationException {

File: redisson/src/test/java/org/redisson/RedissonBucketTest.java
Patch:
@@ -187,7 +187,7 @@ public void testSizeInMemory() {
         Assumptions.assumeTrue(RedisRunner.getDefaultRedisServerInstance().getRedisVersion().compareTo("4.0.0") > 0);
         RBucket<Integer> al = redisson.getBucket("test");
         al.set(1234);
-        assertThat(al.sizeInMemory()).isEqualTo(56);
+        assertThat(al.sizeInMemory()).isEqualTo(51);
     }
     
     @Test
@@ -240,7 +240,7 @@ public void testSize() {
         assertThat(bucket.size()).isZero();
         bucket.set("1234");
         // json adds quotes
-        assertThat(bucket.size()).isEqualTo(7);
+        assertThat(bucket.size()).isEqualTo(5);
     }
     
     @Test

File: redisson/src/main/java/org/redisson/config/BaseConfig.java
Patch:
@@ -485,7 +485,7 @@ public CredentialsResolver getCredentialsResolver() {
     }
 
     /**
-     * Defines Credentials resolver which is invoked during connection/reconnection process.
+     * Defines Credentials resolver which is invoked during connection for Redis server authentication.
      * It makes possible to specify dynamically changing Redis credentials.
      *
      * @param credentialsResolver Credentials resolver object

File: redisson/src/test/java/org/redisson/RedissonFairLockTest.java
Patch:
@@ -931,7 +931,7 @@ public void testConcurrency_MultiInstance_Ordering() throws InterruptedException
             t1.start();
         }
 
-        await().atMost(30, TimeUnit.SECONDS).until(() -> lockedCounter.get() == totalThreads);
+        await().atMost(35, TimeUnit.SECONDS).until(() -> lockedCounter.get() == totalThreads);
     }
 
 

File: redisson/src/main/java/org/redisson/RedissonKeys.java
Patch:
@@ -149,6 +149,8 @@ private RFuture<ScanResult<Object>> scanIteratorAsync(RedisClient client, Master
             return commandExecutor.readAsync(client, entry, StringCodec.INSTANCE, command, startPos, "COUNT",
                     count);
         }
+
+        pattern = map(pattern);
         return commandExecutor.readAsync(client, entry, StringCodec.INSTANCE, command, startPos, "MATCH",
                 pattern, "COUNT", count);
     }

File: redisson/src/main/java/org/redisson/client/RedisConnection.java
Patch:
@@ -140,9 +140,9 @@ public static <C extends RedisConnection> C getFrom(Channel channel) {
             }
         }
 
-        QueueCommand command = channel.attr(CommandsQueuePubSub.CURRENT_COMMAND).get();
-        if (command instanceof CommandData) {
-            return (CommandData<?, ?>) command;
+        QueueCommandHolder holder = channel.attr(CommandsQueuePubSub.CURRENT_COMMAND).get();
+        if (holder != null && holder.getCommand() instanceof CommandData) {
+            return (CommandData<?, ?>) holder.getCommand();
         }
         return null;
     }

File: redisson/src/main/java/org/redisson/client/handler/CommandPubSubDecoder.java
Patch:
@@ -65,7 +65,7 @@ public void addPubSubCommand(ChannelName channel, CommandData<Object, Object> da
     }
 
     @Override
-    protected QueueCommand getCommand(ChannelHandlerContext ctx) {
+    protected QueueCommandHolder getCommand(ChannelHandlerContext ctx) {
         return ctx.channel().attr(CommandsQueuePubSub.CURRENT_COMMAND).get();
     }
 

File: redisson/src/main/java/org/redisson/pubsub/PublishSubscribe.java
Patch:
@@ -115,6 +115,7 @@ public CompletableFuture<E> subscribe(String entryName, String channelName) {
             });
             s.whenComplete((r, e) -> {
                 if (e != null) {
+                    entries.remove(entryName);
                     value.getPromise().completeExceptionally(e);
                     return;
                 }

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -860,7 +860,8 @@ private CompletableFuture<Collection<ClusterPartition>> parsePartitions(List<Clu
             List<ClusterPartition> ps = partitions.values()
                     .stream()
                     .filter(cp -> cp.getType() == Type.MASTER
-                            && cp.getMasterAddress() != null)
+                                    && cp.getMasterAddress() != null
+                                        && ((!cp.slots().isEmpty() && partitions.size() == 1) || partitions.size() > 1))
                     .collect(Collectors.toList());
             return ps;
         });

File: redisson/src/main/java/org/redisson/RedissonPermitExpirableSemaphore.java
Patch:
@@ -654,7 +654,7 @@ public boolean trySetPermits(int permits) {
     public RFuture<Boolean> trySetPermitsAsync(int permits) {
         return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 "local value = redis.call('get', KEYS[1]); " +
-                "if (value == false or value == 0) then "
+                "if (value == false) then "
                     + "redis.call('set', KEYS[1], ARGV[1]); "
                     + "redis.call('publish', KEYS[2], ARGV[1]); "
                     + "return 1;"

File: redisson/src/main/java/org/redisson/RedissonPermitExpirableSemaphore.java
Patch:
@@ -654,7 +654,7 @@ public boolean trySetPermits(int permits) {
     public RFuture<Boolean> trySetPermitsAsync(int permits) {
         return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 "local value = redis.call('get', KEYS[1]); " +
-                "if (value == false or value == 0) then "
+                "if (value == false) then "
                     + "redis.call('set', KEYS[1], ARGV[1]); "
                     + "redis.call('publish', KEYS[2], ARGV[1]); "
                     + "return 1;"

File: redisson/src/test/java/org/redisson/spring/session/TomcatServer.java
Patch:
@@ -3,9 +3,8 @@
 import java.io.File;
 import java.net.MalformedURLException;
 
-import javax.servlet.ServletContext;
-import javax.servlet.ServletException;
-
+import jakarta.servlet.ServletContext;
+import jakarta.servlet.ServletException;
 import org.apache.catalina.LifecycleException;
 import org.apache.catalina.core.StandardContext;
 import org.apache.catalina.startup.Tomcat;

File: redisson/src/main/java/org/redisson/RedissonKeys.java
Patch:
@@ -472,7 +472,7 @@ public boolean expire(String name, long timeToLive, TimeUnit timeUnit) {
 
     @Override
     public RFuture<Boolean> expireAsync(String name, long timeToLive, TimeUnit timeUnit) {
-        return commandExecutor.writeAsync(name, StringCodec.INSTANCE, RedisCommands.PEXPIRE, map(name),
+        return commandExecutor.writeAsync(map(name), StringCodec.INSTANCE, RedisCommands.PEXPIRE, map(name),
                 timeUnit.toMillis(timeToLive));
     }
 

File: redisson/src/test/java/org/redisson/RedissonKeysTest.java
Patch:
@@ -208,7 +208,7 @@ public void testKeysIterable() throws InterruptedException {
         Iterator<String> iterator = redisson.getKeys().getKeys().iterator();
         for (; iterator.hasNext();) {
             String key = iterator.next();
-            keys.remove(key);
+            keys.remove(redisson.getConfig().useSingleServer().getNameMapper().map(key));
             iterator.remove();
         }
         Assertions.assertEquals(0, keys.size());

File: redisson/src/main/java/org/redisson/RedissonBaseAdder.java
Patch:
@@ -44,10 +44,10 @@ public abstract class RedissonBaseAdder<T extends Number> extends RedissonExpira
     private final RTopic topic;
     private final int listenerId;
     
-    public RedissonBaseAdder(CommandAsyncExecutor connectionManager, String name, RedissonClient redisson) {
-        super(connectionManager, name);
+    public RedissonBaseAdder(CommandAsyncExecutor commandExecutor, String name, RedissonClient redisson) {
+        super(commandExecutor, name);
         
-        topic = redisson.getTopic(suffixName(getRawName(), "topic"), StringCodec.INSTANCE);
+        topic = RedissonTopic.createRaw(StringCodec.INSTANCE, commandExecutor, suffixName(getRawName(), "topic"));
         this.redisson = redisson;
         listenerId = topic.addListener(String.class, (channel, msg) -> {
             String[] parts = msg.split(":");

File: redisson/src/main/java/org/redisson/cache/LocalCacheListener.java
Patch:
@@ -34,6 +34,7 @@
 import org.slf4j.LoggerFactory;
 
 import java.io.IOException;
+import java.time.Duration;
 import java.util.*;
 import java.util.concurrent.*;
 
@@ -345,6 +346,7 @@ private void loadAfterReconnection() {
     private RSemaphore getClearSemaphore(byte[] requestId) {
         String id = ByteBufUtil.hexDump(requestId);
         RSemaphore semaphore = new RedissonSemaphore(commandExecutor, name + ":clear:" + id);
+        semaphore.expireAsync(Duration.ofSeconds(60));
         return semaphore;
     }
 

File: redisson/src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -76,7 +76,7 @@ public RedissonMap(CommandAsyncExecutor commandExecutor, String name, RedissonCl
                 && options.getWriteMode() == WriteMode.WRITE_BEHIND
                     && (options.getWriter() != null || options.getWriterAsync() != null)) {
             this.writeBehindService = writeBehindService;
-            writeBehindTask = writeBehindService.start(name, options);
+            writeBehindTask = writeBehindService.start(getRawName(), options);
         } else {
             this.writeBehindService = null;
             writeBehindTask = null;
@@ -100,7 +100,7 @@ public RedissonMap(Codec codec, CommandAsyncExecutor commandExecutor, String nam
                 && options.getWriteMode() == WriteMode.WRITE_BEHIND
                     && (options.getWriter() != null || options.getWriterAsync() != null)) {
             this.writeBehindService = writeBehindService;
-            writeBehindTask = writeBehindService.start(name, options);
+            writeBehindTask = writeBehindService.start(getRawName(), options);
         } else {
             this.writeBehindService = null;
             writeBehindTask = null;

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -717,9 +717,9 @@ public Object decode(List parts, State state) {
 
     RedisCommand<List<Long>> JSON_OBJLEN_LIST = new RedisCommand("JSON.OBJLEN", new ObjectListReplayDecoder<Long>(), new LongReplayConvertor());
 
-    RedisCommand<List<String>> JSON_OBJKEYS = new RedisCommand("JSON.OBJKEYS", new StringListReplayDecoder());
+    RedisCommand<List<String>> JSON_OBJKEYS = new RedisCommand("JSON.OBJKEYS", new StringListListReplayDecoder());
 
-    RedisCommand<List<List<String>>> JSON_OBJKEYS_LIST = new RedisCommand("JSON.OBJKEYS", new StringListReplayDecoder());
+    RedisCommand<List<List<String>>> JSON_OBJKEYS_LIST = new RedisCommand("JSON.OBJKEYS", new StringListListReplayDecoder());
 
     RedisCommand<Boolean> JSON_TOGGLE = new RedisCommand<Boolean>("JSON.TOGGLE", new BooleanReplayConvertor());
 

File: redisson/src/main/java/org/redisson/RedissonObject.java
Patch:
@@ -316,7 +316,7 @@ public ByteBuf encode(Object value) {
     public void encode(Collection<?> params, Object value) {
         try {
             Object v = commandExecutor.encode(codec, value);
-            ((Collection<Object>)params).add(v);
+            ((Collection<Object>) params).add(v);
         } catch (Exception e) {
             params.forEach(v -> {
                 ReferenceCountUtil.safeRelease(v);

File: redisson/src/main/java/org/redisson/RedissonSet.java
Patch:
@@ -741,7 +741,7 @@ public RFuture<Boolean> tryAddAsync(V... values) {
                             "redis.call('sadd', KEYS[1], unpack(ARGV, i, math.min(i+4999, #ARGV))); " +
                         "end; " +
                         "return 1; ",
-                       Arrays.asList(getRawName()), encode(values).toArray());
+                Arrays.asList(getRawName()), encode(Arrays.asList(values).toArray()));
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonSetCache.java
Patch:
@@ -265,7 +265,7 @@ public RFuture<Boolean> tryAddAsync(long ttl, TimeUnit unit, V... values) {
         List<Object> params = new ArrayList<>();
         params.add(System.currentTimeMillis());
         params.add(timeoutDate);
-        params.addAll(encode(values));
+        params.addAll(encode(Arrays.asList(values)));
 
         return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_BOOLEAN,
                   "for i, v in ipairs(ARGV) do " +
@@ -363,10 +363,10 @@ public RFuture<Boolean> retainAllAsync(Collection<?> c) {
         }
         
         long score = 92233720368547758L - System.currentTimeMillis();
-        List<Object> params = new ArrayList<Object>(c.size()*2);
+        List<Object> params = new ArrayList<>(c.size() * 2);
         for (Object object : c) {
             params.add(score);
-            params.add(encode((V) object));
+            params.add(encode(params, object));
         }
         
         return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_BOOLEAN,

File: redisson/src/main/java/org/redisson/RedissonTimeSeries.java
Patch:
@@ -117,7 +117,7 @@ public RFuture<Void> addAllAsync(Map<Long, V> objects, long timeToLive, TimeUnit
             byte[] random = new byte[16];
             ThreadLocalRandom.current().nextBytes(random);
             params.add(random);
-            params.add(encode(entry.getValue()));
+            params.add(encode(params, entry.getValue()));
         }
 
         if (timeToLive > 0) {

File: redisson/src/main/java/org/redisson/RedissonSortedSet.java
Patch:
@@ -47,7 +47,7 @@ public class RedissonSortedSet<V> extends RedissonObject implements RSortedSet<V
     public static class BinarySearchResult<V> {
 
         private V value;
-        private Integer index;
+        private int index = -1;
 
         public BinarySearchResult(V value) {
             super();

File: redisson/src/main/java/org/redisson/RedissonSortedSet.java
Patch:
@@ -47,7 +47,7 @@ public class RedissonSortedSet<V> extends RedissonObject implements RSortedSet<V
     public static class BinarySearchResult<V> {
 
         private V value;
-        private Integer index;
+        private int index = -1;
 
         public BinarySearchResult(V value) {
             super();

File: redisson/src/main/java/org/redisson/config/Config.java
Patch:
@@ -90,7 +90,7 @@ public class Config {
 
     private boolean useThreadClassLoader = true;
 
-    private AddressResolverGroupFactory addressResolverGroupFactory = new DnsAddressResolverGroupFactory();
+    private AddressResolverGroupFactory addressResolverGroupFactory = new SequentialDnsAddressResolverFactory();
 
     public Config() {
     }

File: redisson/src/main/java/org/redisson/jcache/JCache.java
Patch:
@@ -2093,9 +2093,7 @@ RFuture<List<Object>> getAndRemoveValuesOperation(CommandAsyncExecutor commandEx
         params.add(System.currentTimeMillis());
         params.add(syncId);
 
-        for (Object key : keys) {
-            params.add(encodeMapKey(key));
-        }
+        encodeMapKeys(params, keys);
 
         String script = "local syncs = 0; "
           + "local values = {}; "

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -844,7 +844,7 @@ private CompletableFuture<Collection<ClusterPartition>> parsePartitions(List<Clu
         }
 
         CompletableFuture<Void> future = CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));
-        return future.handle((r, e) -> {
+        return future.thenApply(r -> {
             addCascadeSlaves(partitions.values());
 
             List<ClusterPartition> ps = partitions.values()

File: redisson/src/main/java/org/redisson/api/CronSchedule.java
Patch:
@@ -16,6 +16,7 @@
 package org.redisson.api;
 
 import org.redisson.executor.CronExpression;
+import org.redisson.executor.CronExpressionEx;
 
 import java.time.ZoneId;
 
@@ -48,7 +49,7 @@ public final class CronSchedule {
      *             wrapping a ParseException if the expression is invalid
      */
     public static CronSchedule of(String expression) {
-        return new CronSchedule(new CronExpression(expression), ZoneId.systemDefault());
+        return new CronSchedule(new CronExpressionEx(expression), ZoneId.systemDefault());
     }
 
     /**
@@ -61,7 +62,7 @@ public static CronSchedule of(String expression) {
      *             wrapping a ParseException if the expression is invalid
      */
     public static CronSchedule of(String expression, ZoneId zoneId) {
-        return new CronSchedule(new CronExpression(expression), zoneId);
+        return new CronSchedule(new CronExpressionEx(expression), zoneId);
     }
 
     /**

File: redisson/src/main/java/org/redisson/executor/TasksRunnerService.java
Patch:
@@ -137,7 +137,7 @@ public void scheduleAtFixedRate(ScheduledAtFixedRateParameters params) {
     
     @Override
     public void schedule(ScheduledCronExpressionParameters params) {
-        CronExpression expression = new CronExpression(params.getCronExpression());
+        CronExpression expression = new CronExpressionEx(params.getCronExpression());
         ZonedDateTime currentDate = ZonedDateTime.of(LocalDateTime.now(), ZoneId.of(params.getTimezone()));
         ZonedDateTime nextStartDate = expression.nextTimeAfter(currentDate);
         RFuture<Void> future = null;

File: redisson/src/test/java/org/redisson/executor/RedissonScheduledExecutorServiceTest.java
Patch:
@@ -357,7 +357,7 @@ public void testTaskIds() throws InterruptedException {
     public void testWrongCronExpression() {
         Assertions.assertThrows(IllegalArgumentException.class, () -> {
             RScheduledExecutorService executor = redisson.getExecutorService("test");
-            executor.schedule(new ScheduledRunnableTask("executed"), CronSchedule.of("0 44 12 19 JUN ? 2018"));
+            executor.schedule(new ScheduledRunnableTask("executed"), CronSchedule.of("0 44 12 19 JUN ? 2018 32"));
         });
     }
     

File: redisson/src/main/java/org/redisson/RedissonListMultimap.java
Patch:
@@ -310,7 +310,9 @@ public RFuture<Collection<V>> replaceValuesAsync(K key, Iterable<? extends V> va
                 "redis.call('hset', KEYS[1], ARGV[1], ARGV[2]); " +
                 "local members = redis.call('lrange', KEYS[2], 0, -1); " +
                 "redis.call('del', KEYS[2]); " +
-                "redis.call('rpush', KEYS[2], unpack(ARGV, 3, #ARGV)); " +
+                "if #ARGV > 2 then " +
+                    "redis.call('rpush', KEYS[2], unpack(ARGV, 3, #ARGV)); " +
+                "end; " +
                 "return members; ",
             Arrays.<Object>asList(getRawName(), setName), params.toArray());
     }

File: redisson/src/main/java/org/redisson/RedissonSetMultimap.java
Patch:
@@ -309,7 +309,9 @@ public RFuture<Collection<V>> replaceValuesAsync(K key, Iterable<? extends V> va
                 "redis.call('hset', KEYS[1], ARGV[1], ARGV[2]); " +
                 "local members = redis.call('smembers', KEYS[2]); " +
                 "redis.call('del', KEYS[2]); " +
-                "redis.call('sadd', KEYS[2], unpack(ARGV, 3, #ARGV)); " +
+                "if #ARGV > 2 then " +
+                    "redis.call('sadd', KEYS[2], unpack(ARGV, 3, #ARGV)); " +
+                "end; " +
                 "return members; ",
             Arrays.<Object>asList(getRawName(), setName), params.toArray());
     }

File: redisson/src/main/java/org/redisson/connection/ReplicatedConnectionManager.java
Patch:
@@ -171,7 +171,7 @@ private void checkNode(AsyncCountDownLatch latch, RedisURI uri, ReplicatedServer
 
                     RedisConnection connection = connectionFuture.toCompletableFuture().join();
                     if (!RedisURI.compare(connection.getRedisClient().getAddr(), ip)) {
-                        closeNodeConnection(connection);
+                        disconnectNode(uri);
                         log.info("Hostname: " + uri + " has changed IP from: "
                                     + connection.getRedisClient().getAddr() + " to " + ip);
                         return CompletableFuture.<Map<String, String>>completedFuture(null);

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -708,7 +708,7 @@ public CompletableFuture<RedisURI> resolveIP(RedisURI address) {
 
     protected CompletableFuture<RedisURI> resolveIP(String scheme, RedisURI address) {
         if (address.isIP()) {
-            RedisURI addr = applyNatMap(address);
+            RedisURI addr = toURI(scheme, address.getHost(), "" + address.getPort());
             return CompletableFuture.completedFuture(addr);
         }
 

File: redisson-spring-boot-starter/src/main/java/org/redisson/spring/starter/RedissonAutoConfiguration.java
Patch:
@@ -135,6 +135,7 @@ public RedissonClient redisson() throws IOException {
                 try {
                     config = Config.fromJSON(redissonProperties.getConfig());
                 } catch (IOException e1) {
+                    e1.addSuppressed(e);
                     throw new IllegalArgumentException("Can't parse config", e1);
                 }
             }
@@ -148,6 +149,7 @@ public RedissonClient redisson() throws IOException {
                     InputStream is = getConfigStream();
                     config = Config.fromJSON(is);
                 } catch (IOException e1) {
+                    e1.addSuppressed(e);
                     throw new IllegalArgumentException("Can't parse config", e1);
                 }
             }

File: redisson/src/main/java/org/redisson/client/handler/PingConnectionHandler.java
Patch:
@@ -87,6 +87,7 @@ private void sendPing(ChannelHandlerContext ctx) {
                         || cause instanceof RedisTryAgainException
                             || cause instanceof RedisClusterDownException
                                 || cause instanceof RedisBusyException)) {
+                    log.debug("channel: {} closed due to PING response timeout set in {} ms", ctx.channel(), config.getPingConnectionInterval());
                     ctx.channel().close();
                 } else {
                     sendPing(ctx);
@@ -95,7 +96,6 @@ private void sendPing(ChannelHandlerContext ctx) {
                 if (cause != null && !future.isCancelled()) {
                     log.error("Unable to send PING command over channel: " + ctx.channel(), cause);
                 }
-                log.debug("channel: {} closed due to PING response timeout set in {} ms", ctx.channel(), config.getPingConnectionInterval());
             } else {
                 sendPing(ctx);
             }

File: redisson/src/main/java/org/redisson/client/handler/PingConnectionHandler.java
Patch:
@@ -88,6 +88,8 @@ private void sendPing(ChannelHandlerContext ctx) {
                             || cause instanceof RedisClusterDownException
                                 || cause instanceof RedisBusyException)) {
                     ctx.channel().close();
+                } else {
+                    sendPing(ctx);
                 }
 
                 if (cause != null && !future.isCancelled()) {

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -362,6 +362,7 @@ protected RFuture<Boolean> fastPutOperationAsync(K key, V value) {
     
     @Override
     public void destroy() {
+        super.destroy();
         cache.clear();
         listener.remove();
     }

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -2698,8 +2698,6 @@ public void destroy() {
         if (evictionScheduler != null) {
             evictionScheduler.remove(getRawName());
         }
-        if (writeBehindService != null) {
-            writeBehindService.stop(getRawName());
-        }
+        super.destroy();
     }
 }

File: redisson/src/main/java/org/redisson/api/RLocalCachedMap.java
Patch:
@@ -30,7 +30,7 @@
  * @param <K> map key
  * @param <V> map value
  */
-public interface RLocalCachedMap<K, V> extends RMap<K, V>, RDestroyable {
+public interface RLocalCachedMap<K, V> extends RMap<K, V> {
     
     /**
      * Pre-warm the cached entries. Not guaranteed to load ALL values, but statistically

File: redisson/src/main/java/org/redisson/api/RMap.java
Patch:
@@ -36,7 +36,7 @@
  * @param <K> map key
  * @param <V> value
  */
-public interface RMap<K, V> extends ConcurrentMap<K, V>, RExpirable, RMapAsync<K, V> {
+public interface RMap<K, V> extends ConcurrentMap<K, V>, RExpirable, RMapAsync<K, V>, RDestroyable {
 
     /**
      * Loads all map entries to this Redis map using {@link org.redisson.api.map.MapLoader}.

File: redisson/src/main/java/org/redisson/api/RMapCache.java
Patch:
@@ -39,7 +39,7 @@
  * @param <K> key
  * @param <V> value
  */
-public interface RMapCache<K, V> extends RMap<K, V>, RMapCacheAsync<K, V>, RDestroyable {
+public interface RMapCache<K, V> extends RMap<K, V>, RMapCacheAsync<K, V> {
 
     /**
      * Sets max size of the map and overrides current value.

File: redisson/src/test/java/org/redisson/BaseMapTest.java
Patch:
@@ -131,9 +131,7 @@ public boolean equals(Object obj) {
     }
     
     protected void destroy(RMap<?, ?> map) {
-        if (map instanceof RDestroyable) {
-            ((RDestroyable) map).destroy();
-        }
+        map.destroy();
     }
 
     @Test

File: redisson/src/main/java/org/redisson/connection/pool/ConnectionPool.java
Patch:
@@ -111,6 +111,7 @@ private void createConnection(boolean checkFreezed, AtomicInteger requests, Clie
             createConnection(entry, promise);
             promise.whenComplete((conn, e) -> {
                 if (e == null) {
+                    conn.decUsage();
                     if (!initPromise.isDone()) {
                         entry.addConnection(conn);
                     } else {
@@ -279,6 +280,7 @@ private void createConnection(ClientConnectionsEntry entry, CompletableFuture<T>
                 return;
             }
 
+            promise.thenApply(c -> c.incUsage());
             connectedSuccessful(entry, promise, conn);
         });
     }

File: redisson/src/main/java/org/redisson/command/RedisCommonBatchExecutor.java
Patch:
@@ -18,6 +18,7 @@
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelPromise;
+import io.netty.util.Timeout;
 import org.redisson.api.BatchOptions;
 import org.redisson.api.BatchOptions.ExecutionMode;
 import org.redisson.client.RedisConnection;
@@ -114,7 +115,7 @@ protected void sendCommand(CompletableFuture<Void> attemptPromise, RedisConnecti
         if (list.isEmpty()) {
             writeFuture = connection.getChannel().newPromise();
             attemptPromise.complete(null);
-            timeout.cancel();
+            timeout.ifPresent(Timeout::cancel);
             return;
         }
 

File: redisson/src/test/java/org/redisson/RedissonBatchTest.java
Patch:
@@ -172,11 +172,11 @@ public void testConnectionLeak(BatchOptions batchOptions) throws Exception {
         RedissonClient redisson = Redisson.create(config);
 
 		ExecutorService executorService = Executors.newFixedThreadPool(5);
-		AtomicInteger counter = new AtomicInteger(5*150);
+		AtomicInteger counter = new AtomicInteger(5*15);
 		AtomicBoolean hasErrors = new AtomicBoolean();
 		for (int i = 0; i < 5; i++) {
 			executorService.submit(() -> {
-				for (int j = 0 ; j < 150; j++) {
+				for (int j = 0 ; j < 15; j++) {
 					executeBatch(redisson, batchOptions).whenComplete((r, e) -> {
                         if (e != null) {
                             hasErrors.set(true);
@@ -198,7 +198,7 @@ public void testConnectionLeak(BatchOptions batchOptions) throws Exception {
 
 	public RFuture<BatchResult<?>> executeBatch(RedissonClient client, BatchOptions batchOptions) {
 		RBatch batch = client.createBatch(batchOptions);
-		for (int i = 0; i < 50; i++) {
+		for (int i = 0; i < 100000; i++) {
 			String key = "" + i;
 			batch.getBucket(key).getAsync();
 		}

File: redisson/src/main/java/org/redisson/RedissonLiveObjectService.java
Patch:
@@ -812,7 +812,7 @@ private <T> Class<? extends T> createProxy(Class<T> entityClass, CommandAsyncExe
                 
                 .method(ElementMatchers.isDeclaredBy(RExpirable.class)
                         .or(ElementMatchers.isDeclaredBy(RExpirableAsync.class)))
-                .intercept(MethodDelegation.to(new RExpirableInterceptor(commandExecutor)))
+                .intercept(MethodDelegation.to(RExpirableInterceptor.class))
                 .implement(RExpirable.class)
                 
                 .method(ElementMatchers.isDeclaredBy(Map.class)

File: redisson/src/main/java/org/redisson/RedissonMultimap.java
Patch:
@@ -105,7 +105,7 @@ public RReadWriteLock getReadWriteLock(K key) {
         return new RedissonReadWriteLock(commandExecutor, lockName);
     }
     
-    public String hash(ByteBuf objectState) {
+    protected String hash(ByteBuf objectState) {
         return Hash.hash128toBase64(objectState);
     }
 
@@ -153,7 +153,7 @@ public boolean put(K key, V value) {
         return get(putAsync(key, value));
     }
 
-    public String getValuesName(String hash) {
+    String getValuesName(String hash) {
         return suffixName(getRawName(), hash);
     }
 

File: redisson/src/main/java/org/redisson/RedissonLiveObjectService.java
Patch:
@@ -812,7 +812,7 @@ private <T> Class<? extends T> createProxy(Class<T> entityClass, CommandAsyncExe
                 
                 .method(ElementMatchers.isDeclaredBy(RExpirable.class)
                         .or(ElementMatchers.isDeclaredBy(RExpirableAsync.class)))
-                .intercept(MethodDelegation.to(RExpirableInterceptor.class))
+                .intercept(MethodDelegation.to(new RExpirableInterceptor(commandExecutor)))
                 .implement(RExpirable.class)
                 
                 .method(ElementMatchers.isDeclaredBy(Map.class)

File: redisson/src/main/java/org/redisson/RedissonMultimap.java
Patch:
@@ -105,7 +105,7 @@ public RReadWriteLock getReadWriteLock(K key) {
         return new RedissonReadWriteLock(commandExecutor, lockName);
     }
     
-    protected String hash(ByteBuf objectState) {
+    public String hash(ByteBuf objectState) {
         return Hash.hash128toBase64(objectState);
     }
 
@@ -153,7 +153,7 @@ public boolean put(K key, V value) {
         return get(putAsync(key, value));
     }
 
-    String getValuesName(String hash) {
+    public String getValuesName(String hash) {
         return suffixName(getRawName(), hash);
     }
 

File: redisson-spring-data/redisson-spring-data-26/src/test/java/org/redisson/spring/data/connection/RedissonConnectionTest.java
Patch:
@@ -73,6 +73,9 @@ public void testGeo() {
         RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands.GeoRadiusCommandArgs.newGeoRadiusArgs().includeCoordinates();
         GeoResults<RedisGeoCommands.GeoLocation<String>> res = redisTemplate.opsForGeo().radius(key, within, args);
         assertThat(res.getContent().get(0).getContent().getName()).isEqualTo("a");
+
+        GeoResults<RedisGeoCommands.GeoLocation<String>> res2 = redisTemplate.opsForGeo().search(key, within);
+        assertThat(res2.getContent().size()).isEqualTo(1);
     }
 
     @Test

File: redisson-helidon/src/main/java/org/redisson/helidon/RedissonExtension.java
Patch:
@@ -74,7 +74,7 @@ private void addBeans(@Observes AfterBeanDiscovery discovery, BeanManager beanMa
                     String yamlConfig = PropertiesConvertor.toYaml(Redisson.class.getName() + "." + instanceName + ".",
                             cfg.getPropertyNames(), prop -> {
                                 return cfg.getValue(prop, String.class);
-                    });
+                    }, true);
 
                     try {
                         org.redisson.config.Config config = org.redisson.config.Config.fromYAML(yamlConfig);

File: redisson-quarkus/redisson-quarkus-16/runtime/src/main/java/io/quarkus/redisson/client/runtime/RedissonClientProducer.java
Patch:
@@ -62,7 +62,7 @@ public RedissonClient create() throws IOException {
         } else {
             String yaml = PropertiesConvertor.toYaml("quarkus.redisson.", ConfigProvider.getConfig().getPropertyNames(), prop -> {
                 return ConfigProvider.getConfig().getValue(prop, String.class);
-            });
+            }, false);
             config = yaml;
         }
 

File: redisson-quarkus/redisson-quarkus-20/runtime/src/main/java/io/quarkus/redisson/client/runtime/RedissonClientProducer.java
Patch:
@@ -62,7 +62,7 @@ public RedissonClient create() throws IOException {
         } else {
             String yaml = PropertiesConvertor.toYaml("quarkus.redisson.", ConfigProvider.getConfig().getPropertyNames(), prop -> {
                 return ConfigProvider.getConfig().getValue(prop, String.class);
-            });
+            }, false);
             config = yaml;
         }
 

File: redisson/src/main/java/org/redisson/RedissonJsonBucket.java
Patch:
@@ -431,7 +431,7 @@ public RFuture<Void> setAndKeepTTLAsync(V value) {
 
     @Override
     public RFuture<Boolean> deleteAsync() {
-        return commandExecutor.writeAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.JSON_DEL, getRawName());
+        return commandExecutor.writeAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.JSON_DEL_BOOLEAN, getRawName());
     }
 
     @Override

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -734,6 +734,8 @@ public Object decode(List parts, State state) {
 
     RedisStrictCommand<Long> JSON_DEL_LONG = new RedisStrictCommand<>("JSON.DEL");
 
+    RedisStrictCommand<Boolean> JSON_DEL_BOOLEAN = new RedisStrictCommand<>("JSON.DEL", new BooleanReplayConvertor());
+
     RedisStrictCommand<Void> JSON_SET = new RedisStrictCommand<>("JSON.SET", new VoidReplayConvertor());
     RedisStrictCommand<Boolean> JSON_SET_BOOLEAN = new RedisStrictCommand<>("JSON.SET", new BooleanNotNullReplayConvertor());
 }

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -577,7 +577,7 @@ public <T> RExecutorFuture<T> submitAsync(Callable<T> task, long timeToLive, Tim
         check(task);
         TaskParameters taskParameters = createTaskParameters(task);
         taskParameters.setTtl(timeUnit.toMillis(timeToLive));
-        RemotePromise<T> result = (RemotePromise<T>) asyncService.executeCallable(taskParameters);
+        RemotePromise<T> result = (RemotePromise<T>) asyncService.executeCallable(taskParameters).toCompletableFuture();
         addListener(result);
         return createFuture(result);
     }

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -577,7 +577,7 @@ public <T> RExecutorFuture<T> submitAsync(Callable<T> task, long timeToLive, Tim
         check(task);
         TaskParameters taskParameters = createTaskParameters(task);
         taskParameters.setTtl(timeUnit.toMillis(timeToLive));
-        RemotePromise<T> result = (RemotePromise<T>) asyncService.executeCallable(taskParameters);
+        RemotePromise<T> result = (RemotePromise<T>) asyncService.executeCallable(taskParameters).toCompletableFuture();
         addListener(result);
         return createFuture(result);
     }

File: redisson/src/main/java/org/redisson/RedissonBatch.java
Patch:
@@ -49,7 +49,7 @@ public <V> RBucketAsync<V> getBucket(String name, Codec codec) {
     }
 
     @Override
-    public <V> RJsonBucket<V> getJsonBucket(String name, JsonCodec<V> codec) {
+    public <V> RJsonBucketAsync<V> getJsonBucket(String name, JsonCodec<V> codec) {
         return new RedissonJsonBucket<>(codec, executorService, name);
     }
 

File: redisson/src/main/java/org/redisson/api/RBatch.java
Patch:
@@ -201,7 +201,7 @@ public interface RBatch {
      * @param codec codec for values
      * @return JsonBucket object
      */
-    <V> RJsonBucket<V> getJsonBucket(String name, JsonCodec<V> codec);
+    <V> RJsonBucketAsync<V> getJsonBucket(String name, JsonCodec<V> codec);
 
     /**
      * Returns HyperLogLog object

File: redisson/src/main/java/org/redisson/RedissonBaseLock.java
Patch:
@@ -221,9 +221,9 @@ protected <T> RFuture<T> evalWriteAsync(String key, Codec codec, RedisCommand<T>
                 throw new CompletionException(ex);
             }
             if (commandExecutor.getConnectionManager().getCfg().isCheckLockSyncedSlaves()
-                    && res.getSyncedSlaves() < availableSlaves) {
+                    && res.getSyncedSlaves() == 0 && availableSlaves > 0) {
                 throw new CompletionException(
-                        new IllegalStateException("Only " + res.getSyncedSlaves() + " of " + availableSlaves + " slaves were synced"));
+                        new IllegalStateException("None of slaves were synced"));
             }
 
             return commandExecutor.getNow(result.toCompletableFuture());

File: redisson/src/test/java/org/redisson/RedissonLockHeavyTest.java
Patch:
@@ -23,7 +23,7 @@ public static Collection<Arguments> data() {
     }
 
     @ParameterizedTest
-    @MethodSource("mapClasses")
+    @MethodSource("data")
     public void lockUnlockRLock(int threads, int loops) throws Exception {
         ExecutorService executor = Executors.newFixedThreadPool(threads);
         for (int i = 0; i < threads; i++) {
@@ -57,9 +57,9 @@ public void run() {
         executor.awaitTermination(threads * loops, TimeUnit.SECONDS);
 
     }
-    
+
     @ParameterizedTest
-    @MethodSource("mapClasses")
+    @MethodSource("data")
     public void tryLockUnlockRLock(int threads, int loops) throws Exception {
         ExecutorService executor = Executors.newFixedThreadPool(threads);
 

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -125,7 +125,7 @@ public RedissonExecutorService(Codec codec, CommandAsyncExecutor commandExecutor
         tasksCounterName = objectName + ":counter";
         tasksName = objectName + ":tasks";
         statusName = objectName + ":status";
-        terminationTopic = redisson.getTopic(objectName + ":termination-topic", LongCodec.INSTANCE);
+        terminationTopic = RedissonTopic.createRaw(LongCodec.INSTANCE, commandExecutor, objectName + ":termination-topic");
 
         tasksRetryIntervalName = objectName + ":retry-interval";
         tasksExpirationTimeName = objectName + ":expiration";
@@ -136,7 +136,7 @@ public RedissonExecutorService(Codec codec, CommandAsyncExecutor commandExecutor
         workersSemaphoreName = objectName + ":workers-semaphore";
         workersCounterName = objectName + ":workers-counter";
         
-        workersTopic = redisson.getTopic(workersChannelName);
+        workersTopic = RedissonTopic.createRaw(commandExecutor, workersChannelName);
 
         remoteService.setStatusName(statusName);
         remoteService.setSchedulerQueueName(schedulerQueueName);

File: redisson/src/main/java/org/redisson/RedissonRemoteService.java
Patch:
@@ -145,7 +145,7 @@ public <T> void register(Class<T> remoteInterface, T object, int workers) {
     }
 
     private <V> RBlockingQueue<V> getBlockingQueue(String name, Codec codec) {
-        return new RedissonBlockingQueue<V>(codec, commandExecutor, name, null);
+        return new RedissonBlockingQueue<>(codec, commandExecutor, name);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/remote/BaseRemoteProxy.java
Patch:
@@ -180,7 +180,7 @@ private <T extends RRemoteServiceResponse> void addCancelHandling(RequestId requ
     }
 
     private void pollResponse() {
-        RBlockingQueue<RRemoteServiceResponse> queue = new RedissonBlockingQueue<>(codec, commandExecutor, responseQueueName, null);
+        RBlockingQueue<RRemoteServiceResponse> queue = new RedissonBlockingQueue<>(codec, commandExecutor, responseQueueName);
         RFuture<RRemoteServiceResponse> future = queue.pollAsync(60, TimeUnit.SECONDS);
         future.whenComplete(createResponseListener());
     }

File: redisson/src/main/java/org/redisson/remote/BaseRemoteService.java
Patch:
@@ -143,7 +143,7 @@ protected long getTimeout(Long executionTimeoutInMillis, RemoteServiceRequest re
     }
 
     protected <K, V> RMap<K, V> getMap(String name) {
-        return new RedissonMap<>(new CompositeCodec(StringCodec.INSTANCE, codec, codec), commandExecutor, name, null, null, null);
+        return new RedissonMap<>(new CompositeCodec(StringCodec.INSTANCE, codec, codec), commandExecutor, name);
     }
     
     protected <T> void scheduleCheck(String mapName, RequestId requestId, CompletableFuture<T> cancelRequest) {

File: redisson/src/main/java/org/redisson/RedissonList.java
Patch:
@@ -300,7 +300,7 @@ public RFuture<V> getAsync(int index) {
         return commandExecutor.readAsync(getRawName(), codec, LINDEX, getRawName(), index);
     }
     
-    public List<V> get(int...indexes) {
+    public List<V> get(int... indexes) {
         return get(getAsync(indexes));
     }
 
@@ -352,7 +352,7 @@ private RFuture<ScanResult<Object>> distributedScanIteratorAsync(String iterator
                 Arrays.<Object>asList(getRawName(), iteratorName), count);
     }
 
-    public RFuture<List<V>> getAsync(int...indexes) {
+    public RFuture<List<V>> getAsync(int... indexes) {
         List<Integer> params = new ArrayList<Integer>();
         for (Integer index : indexes) {
             params.add(index);
@@ -918,7 +918,7 @@ public int addListener(ObjectListener listener) {
             return addListener("__keyevent@*:linsert", (ListInsertListener) listener, ListInsertListener::onListInsert);
         }
         return super.addListener(listener);
-    };
+    }
 
     @Override
     public RFuture<Integer> addListenerAsync(ObjectListener listener) {

File: redisson/src/main/java/org/redisson/RedissonListMultimapValues.java
Patch:
@@ -349,7 +349,7 @@ public void clear() {
     }
 
     @Override
-    public List<V> get(int...indexes) {
+    public List<V> get(int... indexes) {
         return get(getAsync(indexes));
     }
 
@@ -412,7 +412,7 @@ private RFuture<ScanResult<Object>> distributedScanIteratorAsync(String iterator
     }
 
     @Override
-    public RFuture<List<V>> getAsync(int...indexes) {
+    public RFuture<List<V>> getAsync(int... indexes) {
         List<Object> params = new ArrayList<Object>();
         params.add(System.currentTimeMillis());
         params.add(encodeMapKey(key));

File: redisson/src/main/java/org/redisson/RedissonObject.java
Patch:
@@ -403,7 +403,7 @@ public int addListener(ObjectListener listener) {
             return addListener("__keyevent@*:del", (DeletedObjectListener) listener, DeletedObjectListener::onDeleted);
         }
         throw new IllegalArgumentException();
-    };
+    }
     
     @Override
     public RFuture<Integer> addListenerAsync(ObjectListener listener) {

File: redisson/src/main/java/org/redisson/RedissonPatternTopic.java
Patch:
@@ -65,7 +65,7 @@ protected RedissonPatternTopic(Codec codec, CommandAsyncExecutor commandExecutor
     @Override
     public int addListener(PatternStatusListener listener) {
         return addListener(new PubSubPatternStatusListener(listener, name));
-    };
+    }
 
     @Override
     public <T> int addListener(Class<T> type, PatternMessageListener<T> listener) {

File: redisson/src/main/java/org/redisson/RedissonPriorityQueue.java
Patch:
@@ -272,7 +272,7 @@ protected <T> RFuture<V> wrapLockedAsync(RedisCommand<T> command, Object... para
         return wrapLockedAsync(() -> {
             return commandExecutor.writeAsync(getRawName(), codec, command, params);
         });
-    };
+    }
 
     protected final <T, R> RFuture<R> wrapLockedAsync(Supplier<RFuture<R>> callable) {
         long threadId = Thread.currentThread().getId();

File: redisson/src/main/java/org/redisson/RedissonScoredSortedSet.java
Patch:
@@ -1829,7 +1829,7 @@ public int addListener(ObjectListener listener) {
             return addListener("__keyevent@*:zadd", (ScoredSortedSetAddListener) listener, ScoredSortedSetAddListener::onAdd);
         }
         return super.addListener(listener);
-    };
+    }
 
     @Override
     public RFuture<Integer> addListenerAsync(ObjectListener listener) {

File: redisson/src/main/java/org/redisson/RedissonTopic.java
Patch:
@@ -102,7 +102,7 @@ public RFuture<Long> publishAsync(Object message) {
     public int addListener(StatusListener listener) {
         RFuture<Integer> future = addListenerAsync(listener);
         return commandExecutor.get(future.toCompletableFuture());
-    };
+    }
 
     @Override
     public <M> int addListener(Class<M> type, MessageListener<? extends M> listener) {

File: redisson/src/main/java/org/redisson/api/RExecutorService.java
Patch:
@@ -69,7 +69,7 @@ public interface RExecutorService extends ExecutorService, RExecutorServiceAsync
      * @param tasks - tasks to execute
      * @return Future object
      */
-    RExecutorBatchFuture submit(Callable<?>...tasks);
+    RExecutorBatchFuture submit(Callable<?>... tasks);
     
     /**
      * Synchronously submits a Runnable task for execution asynchronously
@@ -116,7 +116,7 @@ public interface RExecutorService extends ExecutorService, RExecutorServiceAsync
      * @param tasks - tasks to execute
      * @return Future object
      */
-    RExecutorBatchFuture submit(Runnable...tasks);
+    RExecutorBatchFuture submit(Runnable... tasks);
     
     /**
      * Returns executor name
@@ -200,6 +200,6 @@ public interface RExecutorService extends ExecutorService, RExecutorServiceAsync
      * 
      * @param tasks - tasks to execute
      */
-    void execute(Runnable...tasks);
+    void execute(Runnable... tasks);
 
 }

File: redisson/src/main/java/org/redisson/api/RExecutorServiceAsync.java
Patch:
@@ -98,7 +98,7 @@ public interface RExecutorServiceAsync {
      * @param tasks - tasks to execute
      * @return Future object
      */
-    RExecutorBatchFuture submitAsync(Callable<?>...tasks);
+    RExecutorBatchFuture submitAsync(Callable<?>... tasks);
     
     /**
      * Submits task for execution asynchronously
@@ -128,6 +128,6 @@ public interface RExecutorServiceAsync {
      * @param tasks - tasks to execute
      * @return Future object
      */
-    RExecutorBatchFuture submitAsync(Runnable...tasks);
+    RExecutorBatchFuture submitAsync(Runnable... tasks);
     
 }

File: redisson/src/main/java/org/redisson/api/RList.java
Patch:
@@ -36,7 +36,7 @@ public interface RList<V> extends List<V>, RExpirable, RListAsync<V>, RSortable<
      * @param indexes of elements
      * @return list of elements
      */
-    List<V> get(int...indexes);
+    List<V> get(int... indexes);
 
     /**
      * Returns element iterator that can be shared across multiple applications.

File: redisson/src/main/java/org/redisson/api/RListAsync.java
Patch:
@@ -34,7 +34,7 @@ public interface RListAsync<V> extends RCollectionAsync<V>, RSortableAsync<List<
      * @param indexes of elements
      * @return elements
      */
-    RFuture<List<V>> getAsync(int...indexes);
+    RFuture<List<V>> getAsync(int... indexes);
     
     /**
      * Inserts <code>element</code> after <code>elementToFind</code>

File: redisson/src/main/java/org/redisson/api/RListReactive.java
Patch:
@@ -37,7 +37,7 @@ public interface RListReactive<V> extends RCollectionReactive<V>, RSortableReact
      * @param indexes of elements
      * @return elements
      */
-    Mono<List<V>> get(int...indexes);
+    Mono<List<V>> get(int... indexes);
     
     /**
      * Add <code>element</code> after <code>elementToFind</code>

File: redisson/src/main/java/org/redisson/api/RListRx.java
Patch:
@@ -39,7 +39,7 @@ public interface RListRx<V> extends RCollectionRx<V>, RSortableRx<List<V>> {
      * @param indexes of elements
      * @return elements
      */
-    Single<List<V>> get(int...indexes);
+    Single<List<V>> get(int... indexes);
     
     /**
      * Add <code>element</code> after <code>elementToFind</code>

File: redisson/src/main/java/org/redisson/client/handler/RedisChannelInitializer.java
Patch:
@@ -190,7 +190,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
             
             @Override
             public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
-                if (!sslInitDone && (evt instanceof SslHandshakeCompletionEvent)) {
+                if (!sslInitDone && evt instanceof SslHandshakeCompletionEvent) {
                     SslHandshakeCompletionEvent e = (SslHandshakeCompletionEvent) evt;
                     if (e.isSuccess()) {
                         sslInitDone = true;

File: redisson/src/main/java/org/redisson/codec/JsonJacksonCodec.java
Patch:
@@ -161,7 +161,7 @@ public boolean useForType(JavaType t) {
                     }
                     // fall through
                 case OBJECT_AND_NON_CONCRETE:
-                    return (t.getRawClass() == Object.class) || !t.isConcrete();
+                    return t.getRawClass() == Object.class || !t.isConcrete();
                 case NON_FINAL:
                     while (t.isArrayType()) {
                         t = t.getContentType();

File: redisson/src/main/java/org/redisson/rx/RedissonMapRxIterator.java
Patch:
@@ -65,7 +65,7 @@ public void accept(long value) throws Exception {
                     nextValues();
                     completed = false;
                 }
-            };
+            }
             
             protected void nextValues() {
                 map.scanIteratorAsync(map.getRawName(), client, nextIterPos, pattern, count).whenComplete((res, e) -> {

File: redisson/src/main/java/org/redisson/api/RLiveObjectService.java
Patch:
@@ -190,7 +190,7 @@ public interface RLiveObjectService {
      *
      * @param <T> Entity type
      * @param attachedObject - proxied object
-     * @return proxied object
+     * @return detachedObject object - not proxied object
      */
     <T> T detach(T attachedObject);
 

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonReactiveScriptingCommands.java
Patch:
@@ -122,7 +122,7 @@ protected <T> Flux<T> convert(Mono<T> m) {
                 return ByteBuffer.wrap((byte[])e);
             }
             if (e instanceof List) {
-                if (((List) e).get(0).getClass().isArray()) {
+                if (!((List) e).isEmpty() && ((List) e).get(0).getClass().isArray()) {
                     return ((List<byte[]>)e).stream().map(v -> ByteBuffer.wrap(v)).collect(Collectors.toList());
                 }
             }

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonReactiveScriptingCommands.java
Patch:
@@ -122,7 +122,7 @@ protected <T> Flux<T> convert(Mono<T> m) {
                 return ByteBuffer.wrap((byte[])e);
             }
             if (e instanceof List) {
-                if (((List) e).get(0).getClass().isArray()) {
+                if (!((List) e).isEmpty() && ((List) e).get(0).getClass().isArray()) {
                     return ((List<byte[]>)e).stream().map(v -> ByteBuffer.wrap(v)).collect(Collectors.toList());
                 }
             }

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonReactiveScriptingCommands.java
Patch:
@@ -122,7 +122,7 @@ protected <T> Flux<T> convert(Mono<T> m) {
                 return ByteBuffer.wrap((byte[])e);
             }
             if (e instanceof List) {
-                if (((List) e).get(0).getClass().isArray()) {
+                if (!((List) e).isEmpty() && ((List) e).get(0).getClass().isArray()) {
                     return ((List<byte[]>)e).stream().map(v -> ByteBuffer.wrap(v)).collect(Collectors.toList());
                 }
             }

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonReactiveScriptingCommands.java
Patch:
@@ -122,7 +122,7 @@ protected <T> Flux<T> convert(Mono<T> m) {
                 return ByteBuffer.wrap((byte[])e);
             }
             if (e instanceof List) {
-                if (((List) e).get(0).getClass().isArray()) {
+                if (!((List) e).isEmpty() && ((List) e).get(0).getClass().isArray()) {
                     return ((List<byte[]>)e).stream().map(v -> ByteBuffer.wrap(v)).collect(Collectors.toList());
                 }
             }

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonReactiveScriptingCommands.java
Patch:
@@ -122,7 +122,7 @@ protected <T> Flux<T> convert(Mono<T> m) {
                 return ByteBuffer.wrap((byte[])e);
             }
             if (e instanceof List) {
-                if (((List) e).get(0).getClass().isArray()) {
+                if (!((List) e).isEmpty() && ((List) e).get(0).getClass().isArray()) {
                     return ((List<byte[]>)e).stream().map(v -> ByteBuffer.wrap(v)).collect(Collectors.toList());
                 }
             }

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/RedissonReactiveScriptingCommands.java
Patch:
@@ -122,7 +122,7 @@ protected <T> Flux<T> convert(Mono<T> m) {
                 return ByteBuffer.wrap((byte[])e);
             }
             if (e instanceof List) {
-                if (((List) e).get(0).getClass().isArray()) {
+                if (!((List) e).isEmpty() && ((List) e).get(0).getClass().isArray()) {
                     return ((List<byte[]>)e).stream().map(v -> ByteBuffer.wrap(v)).collect(Collectors.toList());
                 }
             }

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonReactiveScriptingCommands.java
Patch:
@@ -122,7 +122,7 @@ protected <T> Flux<T> convert(Mono<T> m) {
                 return ByteBuffer.wrap((byte[])e);
             }
             if (e instanceof List) {
-                if (((List) e).get(0).getClass().isArray()) {
+                if (!((List) e).isEmpty() && ((List) e).get(0).getClass().isArray()) {
                     return ((List<byte[]>)e).stream().map(v -> ByteBuffer.wrap(v)).collect(Collectors.toList());
                 }
             }

File: redisson-spring-data/redisson-spring-data-27/src/main/java/org/redisson/spring/data/connection/RedissonReactiveScriptingCommands.java
Patch:
@@ -122,7 +122,7 @@ protected <T> Flux<T> convert(Mono<T> m) {
                 return ByteBuffer.wrap((byte[])e);
             }
             if (e instanceof List) {
-                if (((List) e).get(0).getClass().isArray()) {
+                if (!((List) e).isEmpty() && ((List) e).get(0).getClass().isArray()) {
                     return ((List<byte[]>)e).stream().map(v -> ByteBuffer.wrap(v)).collect(Collectors.toList());
                 }
             }

File: redisson/src/main/java/org/redisson/eviction/EvictionTask.java
Patch:
@@ -74,6 +74,7 @@ public void run() {
         RFuture<Integer> future = execute();
         future.whenComplete((size, e) -> {
             if (e != null) {
+                log.error("Unable to evict elements for '" + getName() + "'", e);
                 schedule();
                 return;
             }

File: redisson/src/main/java/org/redisson/client/handler/ConnectionWatchdog.java
Patch:
@@ -171,6 +171,9 @@ private void reattachPubSub(RedisConnection connection) {
             for (Entry<ChannelName, Codec> entry : conn.getPatternChannels().entrySet()) {
                 conn.psubscribe(entry.getValue(), entry.getKey());
             }
+            for (Entry<ChannelName, Codec> entry : conn.getShardedChannels().entrySet()) {
+                conn.ssubscribe(entry.getValue(), entry.getKey());
+            }
         }
     }
 

File: redisson/src/main/java/org/redisson/connection/IdleConnectionWatcher.java
Patch:
@@ -75,7 +75,8 @@ public IdleConnectionWatcher(ConnectionManager manager, MasterSlaveServersConfig
 
                     if (c instanceof RedisPubSubConnection
                             && (!((RedisPubSubConnection) c).getChannels().isEmpty()
-                                    || !((RedisPubSubConnection) c).getPatternChannels().isEmpty())) {
+                                    || !((RedisPubSubConnection) c).getPatternChannels().isEmpty()
+                                        || !((RedisPubSubConnection) c).getShardedChannels().isEmpty())) {
                         continue;
                     }
 

File: redisson/src/main/java/org/redisson/client/RedisConnection.java
Patch:
@@ -282,8 +282,7 @@ public void clearFastReconnect() {
     
     private void close() {
         CommandData<?, ?> command = getCurrentCommand();
-        if (!isActive()
-                || (command != null && command.isBlockingCommand())
+        if ((command != null && command.isBlockingCommand())
                     || !connectionPromise.isDone()) {
             channel.close();
         } else {

File: redisson/src/main/java/org/redisson/RedissonBaseLock.java
Patch:
@@ -57,7 +57,7 @@ public ExpirationEntry() {
 
         public synchronized void addThreadId(long threadId) {
             threadIds.compute(threadId, (t, counter) -> {
-                counter = Optional.ofNullable(counter).orElse(1);
+                counter = Optional.ofNullable(counter).orElse(0);
                 counter++;
                 return counter;
             });

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -432,7 +432,7 @@ private void updateClusterState(ClusterServersConfig cfg, RedisConnection connec
         RFuture<List<ClusterNodeInfo>> future = connection.async(clusterNodesCommand);
         future.whenComplete((nodes, e) -> {
                 if (e != null) {
-                    closeNodeConnection(connection);
+                    log.error("Unable to execute " + clusterNodesCommand, e);
                     lastException.set(e);
                     getShutdownLatch().release();
                     checkClusterState(cfg, iterator, lastException);

File: redisson/src/main/java/org/redisson/connection/ReplicatedConnectionManager.java
Patch:
@@ -178,7 +178,6 @@ private void checkNode(AsyncCountDownLatch latch, RedisURI uri, ReplicatedServer
             result.whenComplete((r, ex) -> {
                 if (ex != null) {
                     log.error(ex.getMessage(), ex);
-                    closeNodeConnection(connection);
                     latch.countDown();
                     return;
                 }

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -368,7 +368,6 @@ private void updateState(SentinelServersConfig cfg, RedisConnection connection,
         future.whenComplete((r, e) -> {
             if (e != null) {
                 log.error("Can't execute SENTINEL commands on " + connection.getRedisClient().getAddr(), e);
-                closeNodeConnection(connection);
             }
 
             getShutdownLatch().release();

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -668,11 +668,12 @@ public Object decode(List parts, State state) {
     RedisStrictCommand<Map<String, String>> INFO_CLUSTER = new RedisStrictCommand<Map<String, String>>("INFO", "CLUSTER", new StringMapDataDecoder());
     RedisStrictCommand<Map<String, String>> INFO_KEYSPACE = new RedisStrictCommand<Map<String, String>>("INFO", "KEYSPACE", new StringMapDataDecoder());
 
+    Set<RedisCommand> NO_RETRY_COMMANDS = new HashSet<>(Arrays.asList(SET_BOOLEAN));
+
     Set<String> NO_RETRY = new HashSet<>(
             Arrays.asList(RPOPLPUSH.getName(), LPOP.getName(), RPOP.getName(), LPUSH.getName(), RPUSH.getName(),
                     LPUSHX.getName(), RPUSHX.getName(), GEOADD.getName(), XADD.getName(), APPEND.getName(),
                     DECR.getName(), "DECRBY", INCR.getName(), INCRBY.getName(), ZINCRBY.getName(),
-                    "HINCRBYFLOAT", "HINCRBY", "INCRBYFLOAT", SET_BOOLEAN.getName(), SETNX.getName(),
-                    MSETNX.getName(), HSETNX.getName()));
+                    "HINCRBYFLOAT", "HINCRBY", "INCRBYFLOAT", SETNX.getName(), MSETNX.getName(), HSETNX.getName()));
 
 }

File: redisson/src/main/java/org/redisson/client/RedisClient.java
Patch:
@@ -186,7 +186,7 @@ public CompletableFuture<InetSocketAddress> resolveAddr() {
         Future<InetSocketAddress> resolveFuture = resolver.resolve(InetSocketAddress.createUnresolved(uri.getHost(), uri.getPort()));
         resolveFuture.addListener((FutureListener<InetSocketAddress>) future -> {
             if (!future.isSuccess()) {
-                promise.completeExceptionally(future.cause());
+                promise.completeExceptionally(new RedisConnectionException(future.cause()));
                 return;
             }
 
@@ -207,7 +207,7 @@ public RFuture<RedisConnection> connectAsync() {
                 @Override
                 public void operationComplete(final ChannelFuture future) throws Exception {
                     if (bootstrap.config().group().isShuttingDown()) {
-                        IllegalStateException cause = new IllegalStateException("RedisClient is shutdown");
+                        RedisConnectionException cause = new RedisConnectionException("RedisClient is shutdown");
                         r.completeExceptionally(cause);
                         return;
                     }
@@ -264,7 +264,7 @@ public RFuture<RedisPubSubConnection> connectPubSubAsync() {
                 @Override
                 public void operationComplete(final ChannelFuture future) throws Exception {
                     if (bootstrap.config().group().isShuttingDown()) {
-                        IllegalStateException cause = new IllegalStateException("RedisClient is shutdown");
+                        RedisConnectionException cause = new RedisConnectionException("RedisClient is shutdown");
                         r.completeExceptionally(cause);
                         return;
                     }

File: redisson/src/main/java/org/redisson/RedissonBaseLock.java
Patch:
@@ -137,7 +137,7 @@ public void run(Timeout timeout) throws Exception {
                     return;
                 }
                 
-                RFuture<Boolean> future = renewExpirationAsync(threadId);
+                CompletionStage<Boolean> future = renewExpirationAsync(threadId);
                 future.whenComplete((res, e) -> {
                     if (e != null) {
                         log.error("Can't update lock " + getRawName() + " expiration", e);
@@ -175,7 +175,7 @@ protected void scheduleExpirationRenewal(long threadId) {
         }
     }
 
-    protected RFuture<Boolean> renewExpirationAsync(long threadId) {
+    protected CompletionStage<Boolean> renewExpirationAsync(long threadId) {
         return evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 "if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then " +
                         "redis.call('pexpire', KEYS[1], ARGV[1]); " +

File: redisson/src/main/java/org/redisson/RedissonReadLock.java
Patch:
@@ -16,6 +16,7 @@
 package org.redisson;
 
 import java.util.Arrays;
+import java.util.concurrent.CompletionStage;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Condition;
 
@@ -36,7 +37,7 @@
  */
 public class RedissonReadLock extends RedissonLock implements RLock {
 
-    public RedissonReadLock(CommandAsyncExecutor commandExecutor, String name) {
+    protected RedissonReadLock(CommandAsyncExecutor commandExecutor, String name) {
         super(commandExecutor, name);
     }
 
@@ -136,7 +137,7 @@ protected String getKeyPrefix(long threadId, String timeoutPrefix) {
     }
     
     @Override
-    protected RFuture<Boolean> renewExpirationAsync(long threadId) {
+    protected CompletionStage<Boolean> renewExpirationAsync(long threadId) {
         String timeoutPrefix = getReadWriteTimeoutNamePrefix(threadId);
         String keyPrefix = getKeyPrefix(threadId, timeoutPrefix);
         

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -278,6 +278,7 @@ protected ScanIteration<byte[]> doScan(long cursorId, ScanOptions options) {
                     if (entries.hasNext()) {
                         pos = -1;
                         entry = entries.next();
+                        client = null;
                     } else {
                         entry = null;
                     }

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -297,6 +297,7 @@ protected ScanIteration<byte[]> doScan(long cursorId, ScanOptions options) {
                     if (entries.hasNext()) {
                         pos = -1;
                         entry = entries.next();
+                        client = null;
                     } else {
                         entry = null;
                     }

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -300,6 +300,7 @@ protected ScanIteration<byte[]> doScan(long cursorId, ScanOptions options) {
                     if (entries.hasNext()) {
                         pos = -1;
                         entry = entries.next();
+                        client = null;
                     } else {
                         entry = null;
                     }

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -282,6 +282,7 @@ protected ScanIteration<byte[]> doScan(long cursorId, ScanOptions options) {
                     if (entries.hasNext()) {
                         pos = -1;
                         entry = entries.next();
+                        client = null;
                     } else {
                         entry = null;
                     }

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -280,6 +280,7 @@ protected ScanIteration<byte[]> doScan(long cursorId, ScanOptions options) {
                     if (entries.hasNext()) {
                         pos = -1;
                         entry = entries.next();
+                        client = null;
                     } else {
                         entry = null;
                     }

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -280,6 +280,7 @@ protected ScanIteration<byte[]> doScan(long cursorId, ScanOptions options) {
                     if (entries.hasNext()) {
                         pos = -1;
                         entry = entries.next();
+                        client = null;
                     } else {
                         entry = null;
                     }

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -280,6 +280,7 @@ protected ScanIteration<byte[]> doScan(long cursorId, ScanOptions options) {
                     if (entries.hasNext()) {
                         pos = -1;
                         entry = entries.next();
+                        client = null;
                     } else {
                         entry = null;
                     }

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -280,6 +280,7 @@ protected ScanIteration<byte[]> doScan(long cursorId, ScanOptions options) {
                     if (entries.hasNext()) {
                         pos = -1;
                         entry = entries.next();
+                        client = null;
                     } else {
                         entry = null;
                     }

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -280,6 +280,7 @@ protected ScanIteration<byte[]> doScan(long cursorId, ScanOptions options) {
                     if (entries.hasNext()) {
                         pos = -1;
                         entry = entries.next();
+                        client = null;
                     } else {
                         entry = null;
                     }

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -280,6 +280,7 @@ protected ScanIteration<byte[]> doScan(long cursorId, ScanOptions options) {
                     if (entries.hasNext()) {
                         pos = -1;
                         entry = entries.next();
+                        client = null;
                     } else {
                         entry = null;
                     }

File: redisson/src/main/java/org/redisson/RedissonReliableTopic.java
Patch:
@@ -226,7 +226,7 @@ private void poll(String id, StreamMessageId startId) {
                             + "end; "
 
                             + "local t = redis.call('zrange', KEYS[5], 0, 0, 'WITHSCORES'); "
-                            + "if tonumber(t[2]) < tonumber(ARGV[3]) then "
+                            + "if #t == 2 and tonumber(t[2]) < tonumber(ARGV[3]) then "
                                 + "redis.call('hdel', KEYS[3], t[1]); "
                                 + "redis.call('zrem', KEYS[2], t[1]); "
                                 + "redis.call('zrem', KEYS[5], t[1]); "

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -41,7 +41,6 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.time.LocalDateTime;
-import java.time.ZoneId;
 import java.time.ZonedDateTime;
 import java.util.*;
 import java.util.concurrent.*;
@@ -975,7 +974,7 @@ public RScheduledFuture<?> scheduleAsync(Runnable task, CronSchedule cronSchedul
         check(task);
         ClassBody classBody = getClassBody(task);
         byte[] state = encode(task);
-        ZonedDateTime currentDate = ZonedDateTime.of(LocalDateTime.now(), ZoneId.systemDefault());
+        ZonedDateTime currentDate = ZonedDateTime.of(LocalDateTime.now(), cronSchedule.getZoneId());
         ZonedDateTime startDate = cronSchedule.getExpression().nextTimeAfter(currentDate);
         if (startDate == null) {
             throw new IllegalArgumentException("Wrong cron expression! Unable to calculate start date");
@@ -989,7 +988,7 @@ public RScheduledFuture<?> scheduleAsync(Runnable task, CronSchedule cronSchedul
         params.setState(state);
         params.setStartTime(startTime);
         params.setCronExpression(cronSchedule.getExpression().getExpr());
-        params.setTimezone(ZoneId.systemDefault().toString());
+        params.setTimezone(cronSchedule.getZoneId().toString());
         params.setExecutorId(executorId);
         RemotePromise<Void> result = (RemotePromise<Void>) asyncScheduledServiceAtFixed.schedule(params).toCompletableFuture();
         addListener(result);

File: redisson/src/test/java/org/redisson/executor/RedissonScheduledExecutorServiceTest.java
Patch:
@@ -121,7 +121,7 @@ public void testTTL() throws InterruptedException {
         assertThat(executor.getTaskCount()).isEqualTo(2);
         Thread.sleep(3000);
         assertThat(executor.getTaskCount()).isEqualTo(0);
-        assertThat(redisson.getKeys().countExists("testparam")).isEqualTo(0);
+        assertThat(redisson.getAtomicLong("testparam").get()).isEqualTo(1);
     }
 
     

File: redisson/src/main/java/org/redisson/eviction/EvictionScheduler.java
Patch:
@@ -80,7 +80,7 @@ public void schedule(String name, String timeoutSetName, String maxIdleSetName,
 
     public void remove(String name) {
         EvictionTask task = tasks.remove(name);
-        if (task != null) {
+        if (task != null && task.getScheduledFuture() != null) {
             task.getScheduledFuture().cancel(false);
         }
     }

File: redisson/src/main/java/org/redisson/RedissonCountDownLatch.java
Patch:
@@ -149,8 +149,6 @@ public boolean await(long time, TimeUnit unit) throws InterruptedException {
 
     @Override
     public RFuture<Boolean> awaitAsync(long waitTime, TimeUnit unit) {
-        CompletableFuture<Boolean> result = new CompletableFuture<>();
-
         AtomicLong time = new AtomicLong(unit.toMillis(waitTime));
         long currentTime = System.currentTimeMillis();
         CompletableFuture<Long> countFuture = getCountAsync().toCompletableFuture();
@@ -164,6 +162,7 @@ public RFuture<Boolean> awaitAsync(long waitTime, TimeUnit unit) {
 
             long current = System.currentTimeMillis();
             CompletableFuture<RedissonCountDownLatchEntry> subscribeFuture = subscribe();
+            pubSub.timeout(subscribeFuture, time.get());
             return subscribeFuture.thenCompose(entry -> {
                 long elapsed = System.currentTimeMillis() - current;
                 time.addAndGet(-elapsed);

File: redisson/src/main/java/org/redisson/connection/pool/PubSubConnectionPool.java
Patch:
@@ -58,8 +58,8 @@ protected CompletionStage<RedisPubSubConnection> connect(ClientConnectionsEntry
     }
 
     @Override
-    protected void acquireConnection(ClientConnectionsEntry entry, Runnable runnable, RedisCommand<?> command) {
-        entry.acquireSubscribeConnection(runnable);
+    protected CompletableFuture<Void> acquireConnection(ClientConnectionsEntry entry, RedisCommand<?> command) {
+        return entry.acquireSubscribeConnection();
     }
     
     @Override

File: redisson/src/main/java/org/redisson/RedissonFairLock.java
Patch:
@@ -73,7 +73,7 @@ protected void unsubscribe(RedissonLockEntry entry, long threadId) {
     @Override
     protected CompletableFuture<Void> acquireFailedAsync(long waitTime, TimeUnit unit, long threadId) {
         long wait = threadWaitTime;
-        if (waitTime != -1) {
+        if (waitTime > 0) {
             wait = unit.toMillis(waitTime);
         }
 
@@ -103,7 +103,7 @@ protected CompletableFuture<Void> acquireFailedAsync(long waitTime, TimeUnit uni
     @Override
     <T> RFuture<T> tryLockInnerAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand<T> command) {
         long wait = threadWaitTime;
-        if (waitTime != -1) {
+        if (waitTime > 0) {
             wait = unit.toMillis(waitTime);
         }
 

File: redisson/src/main/java/org/redisson/RedissonSpinLock.java
Patch:
@@ -101,7 +101,7 @@ private Long tryAcquire(long leaseTime, TimeUnit unit, long threadId) {
     }
 
     private <T> RFuture<Long> tryAcquireAsync(long leaseTime, TimeUnit unit, long threadId) {
-        if (leaseTime != -1) {
+        if (leaseTime > 0) {
             return tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);
         }
         RFuture<Long> ttlRemainingFuture = tryLockInnerAsync(internalLockLeaseTime,

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -160,7 +160,9 @@ public List<Object> closePipeline() throws RedisPipelineException {
     @Override
     public Object execute(String command, byte[]... args) {
         for (Method method : this.getClass().getDeclaredMethods()) {
-            if (method.getName().equalsIgnoreCase(command) && Modifier.isPublic(method.getModifiers())) {
+            if (method.getName().equalsIgnoreCase(command)
+                    && Modifier.isPublic(method.getModifiers())
+                        && (method.getParameterTypes().length == args.length)) {
                 try {
                     Object t = execute(method, args);
                     if (t instanceof String) {

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -179,7 +179,9 @@ public List<Object> closePipeline() throws RedisPipelineException {
     @Override
     public Object execute(String command, byte[]... args) {
         for (Method method : this.getClass().getDeclaredMethods()) {
-            if (method.getName().equalsIgnoreCase(command) && Modifier.isPublic(method.getModifiers())) {
+            if (method.getName().equalsIgnoreCase(command)
+                    && Modifier.isPublic(method.getModifiers())
+                        && (method.getParameterTypes().length == args.length)) {
                 try {
                     Object t = execute(method, args);
                     if (t instanceof String) {

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -182,7 +182,9 @@ public List<Object> closePipeline() throws RedisPipelineException {
     @Override
     public Object execute(String command, byte[]... args) {
         for (Method method : this.getClass().getDeclaredMethods()) {
-            if (method.getName().equalsIgnoreCase(command) && Modifier.isPublic(method.getModifiers())) {
+            if (method.getName().equalsIgnoreCase(command)
+                    && Modifier.isPublic(method.getModifiers())
+                        && (method.getParameterTypes().length == args.length)) {
                 try {
                     Object t = execute(method, args);
                     if (t instanceof String) {

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -164,7 +164,9 @@ public List<Object> closePipeline() throws RedisPipelineException {
     @Override
     public Object execute(String command, byte[]... args) {
         for (Method method : this.getClass().getDeclaredMethods()) {
-            if (method.getName().equalsIgnoreCase(command) && Modifier.isPublic(method.getModifiers())) {
+            if (method.getName().equalsIgnoreCase(command)
+                    && Modifier.isPublic(method.getModifiers())
+                        && (method.getParameterTypes().length == args.length)) {
                 try {
                     Object t = execute(method, args);
                     if (t instanceof String) {

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -157,7 +157,9 @@ public List<Object> closePipeline() throws RedisPipelineException {
     @Override
     public Object execute(String command, byte[]... args) {
         for (Method method : this.getClass().getDeclaredMethods()) {
-            if (method.getName().equalsIgnoreCase(command) && Modifier.isPublic(method.getModifiers())) {
+            if (method.getName().equalsIgnoreCase(command)
+                    && Modifier.isPublic(method.getModifiers())
+                        && (method.getParameterTypes().length == args.length)) {
                 try {
                     Object t = execute(method, args);
                     if (t instanceof String) {

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -157,7 +157,9 @@ public List<Object> closePipeline() throws RedisPipelineException {
     @Override
     public Object execute(String command, byte[]... args) {
         for (Method method : this.getClass().getDeclaredMethods()) {
-            if (method.getName().equalsIgnoreCase(command) && Modifier.isPublic(method.getModifiers())) {
+            if (method.getName().equalsIgnoreCase(command)
+                    && Modifier.isPublic(method.getModifiers())
+                        && (method.getParameterTypes().length == args.length)) {
                 try {
                     Object t = execute(method, args);
                     if (t instanceof String) {

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -157,7 +157,9 @@ public List<Object> closePipeline() throws RedisPipelineException {
     @Override
     public Object execute(String command, byte[]... args) {
         for (Method method : this.getClass().getDeclaredMethods()) {
-            if (method.getName().equalsIgnoreCase(command) && Modifier.isPublic(method.getModifiers())) {
+            if (method.getName().equalsIgnoreCase(command)
+                    && Modifier.isPublic(method.getModifiers())
+                        && (method.getParameterTypes().length == args.length)) {
                 try {
                     Object t = execute(method, args);
                     if (t instanceof String) {

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -157,7 +157,9 @@ public List<Object> closePipeline() throws RedisPipelineException {
     @Override
     public Object execute(String command, byte[]... args) {
         for (Method method : this.getClass().getDeclaredMethods()) {
-            if (method.getName().equalsIgnoreCase(command) && Modifier.isPublic(method.getModifiers())) {
+            if (method.getName().equalsIgnoreCase(command)
+                    && Modifier.isPublic(method.getModifiers())
+                        && (method.getParameterTypes().length == args.length)) {
                 try {
                     Object t = execute(method, args);
                     if (t instanceof String) {

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -157,7 +157,9 @@ public List<Object> closePipeline() throws RedisPipelineException {
     @Override
     public Object execute(String command, byte[]... args) {
         for (Method method : this.getClass().getDeclaredMethods()) {
-            if (method.getName().equalsIgnoreCase(command) && Modifier.isPublic(method.getModifiers())) {
+            if (method.getName().equalsIgnoreCase(command)
+                    && Modifier.isPublic(method.getModifiers())
+                        && (method.getParameterTypes().length == args.length)) {
                 try {
                     Object t = execute(method, args);
                     if (t instanceof String) {

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -157,7 +157,9 @@ public List<Object> closePipeline() throws RedisPipelineException {
     @Override
     public Object execute(String command, byte[]... args) {
         for (Method method : this.getClass().getDeclaredMethods()) {
-            if (method.getName().equalsIgnoreCase(command) && Modifier.isPublic(method.getModifiers())) {
+            if (method.getName().equalsIgnoreCase(command)
+                    && Modifier.isPublic(method.getModifiers())
+                        && (method.getParameterTypes().length == args.length)) {
                 try {
                     Object t = execute(method, args);
                     if (t instanceof String) {

File: redisson/src/main/java/org/redisson/RedissonMultiLock.java
Patch:
@@ -144,7 +144,7 @@ private void checkLeaseTimeAsync(RPromise<Boolean> result) {
             if (leaseTime != -1) {
                 AtomicInteger counter = new AtomicInteger(acquiredLocks.size());
                 for (RLock rLock : acquiredLocks) {
-                    RFuture<Boolean> future = ((RedissonLock) rLock).expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);
+                    RFuture<Boolean> future = ((RedissonBaseLock) rLock).expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);
                     future.onComplete((res, e) -> {
                         if (e != null) {
                             result.tryFailure(e);
@@ -418,7 +418,7 @@ public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws Inte
 
         if (leaseTime != -1) {
             acquiredLocks.stream()
-                    .map(l -> (RedissonLock) l)
+                    .map(l -> (RedissonBaseLock) l)
                     .map(l -> l.expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS))
                     .forEach(f -> f.toCompletableFuture().join());
         }

File: redisson/src/main/java/org/redisson/api/RFunction.java
Patch:
@@ -30,7 +30,7 @@ public interface RFunction extends RFunctionAsync {
 
     enum Mode {
         /**
-         * Execute script as read operation
+         * Execute function as read operation
          */
         READ,
 
@@ -62,7 +62,7 @@ enum ReturnType {
         STRING(RedisCommands.FCALL_STRING),
 
         /**
-         * Result is a value of Object type
+         * Result is a value of user defined type
          */
         VALUE(RedisCommands.FCALL_OBJECT),
 

File: redisson/src/test/java/org/redisson/RedissonKeysTest.java
Patch:
@@ -246,9 +246,9 @@ public void testDeleteByPattern() {
         map2.fastPut("1", "5");
         assertThat(map2.isExists()).isTrue();
 
-
-        Assertions.assertEquals(4, redisson.getKeys().deleteByPattern("test?"));
-        Assertions.assertEquals(0, redisson.getKeys().deleteByPattern("test?"));
+        assertThat(redisson.getKeys().deleteByPattern("test?")).isEqualTo(4);
+        assertThat(redisson.getKeys().deleteByPattern("test?")).isZero();
+        assertThat(redisson.getKeys().count()).isZero();
     }
 
     @Test

File: redisson/src/main/java/org/redisson/api/RExpirableReactive.java
Patch:
@@ -42,7 +42,7 @@ public interface RExpirableReactive extends RObjectReactive {
     Mono<Boolean> expire(long timeToLive, TimeUnit timeUnit);
 
     /**
-     * Use {@link #expireAt(Instant)} instead
+     * Use {@link #expire(Instant)} instead
      *
      * @param timestamp - expire date
      * @return <code>true</code> if the timeout was set and <code>false</code> if not
@@ -51,7 +51,7 @@ public interface RExpirableReactive extends RObjectReactive {
     Mono<Boolean> expireAt(Date timestamp);
 
     /**
-     * Use {@link #expireAt(Instant)} instead
+     * Use {@link #expire(Instant)} instead
      *
      * @param timestamp - expire date in milliseconds (Unix timestamp)
      * @return <code>true</code> if the timeout was set and <code>false</code> if not
@@ -66,7 +66,7 @@ public interface RExpirableReactive extends RObjectReactive {
      * @param instant - expire date
      * @return <code>true</code> if the timeout was set and <code>false</code> if not
      */
-    Mono<Boolean> expireAt(Instant instant);
+    Mono<Boolean> expire(Instant instant);
 
     /**
      * Sets an expiration date for this object only if it has been already set.

File: redisson/src/main/java/org/redisson/api/RExpirableRx.java
Patch:
@@ -42,7 +42,7 @@ public interface RExpirableRx extends RObjectRx {
     Single<Boolean> expire(long timeToLive, TimeUnit timeUnit);
 
     /**
-     * Use {@link #expireAt(Instant)} instead
+     * Use {@link #expire(Instant)} instead
      *
      * @param timestamp - expire date
      * @return <code>true</code> if the timeout was set and <code>false</code> if not
@@ -51,7 +51,7 @@ public interface RExpirableRx extends RObjectRx {
     Single<Boolean> expireAt(Date timestamp);
 
     /**
-     * Use {@link #expireAt(Instant)} instead
+     * Use {@link #expire(Instant)} instead
      *
      * @param timestamp - expire date in milliseconds (Unix timestamp)
      * @return <code>true</code> if the timeout was set and <code>false</code> if not
@@ -66,7 +66,7 @@ public interface RExpirableRx extends RObjectRx {
      * @param instant - expire date
      * @return <code>true</code> if the timeout was set and <code>false</code> if not
      */
-    Single<Boolean> expireAt(Instant instant);
+    Single<Boolean> expire(Instant instant);
 
     /**
      * Sets an expiration date for this object only if it has been already set.

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -32,6 +32,7 @@
 import org.redisson.client.protocol.convertor.DoubleReplayConvertor;
 import org.redisson.client.protocol.convertor.VoidReplayConvertor;
 import org.redisson.client.protocol.decoder.*;
+import org.redisson.command.BatchPromise;
 import org.redisson.command.CommandAsyncService;
 import org.redisson.command.CommandBatchService;
 import org.redisson.connection.MasterSlaveEntry;
@@ -351,7 +352,7 @@ protected <T> T sync(RFuture<T> f) {
             return null;
         }
         if (isQueueing()) {
-            f.toCompletableFuture().join();
+            ((BatchPromise)f.toCompletableFuture()).getSentPromise().join();
             return null;
         }
 

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -48,6 +48,7 @@
 import org.redisson.client.protocol.convertor.DoubleReplayConvertor;
 import org.redisson.client.protocol.convertor.VoidReplayConvertor;
 import org.redisson.client.protocol.decoder.*;
+import org.redisson.command.BatchPromise;
 import org.redisson.command.CommandAsyncService;
 import org.redisson.command.CommandBatchService;
 import org.redisson.connection.MasterSlaveEntry;
@@ -370,7 +371,7 @@ protected <T> T sync(RFuture<T> f) {
             return null;
         }
         if (isQueueing()) {
-            f.toCompletableFuture().join();
+            ((BatchPromise)f.toCompletableFuture()).getSentPromise().join();
             return null;
         }
 

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -49,6 +49,7 @@
 import org.redisson.client.protocol.convertor.DoubleReplayConvertor;
 import org.redisson.client.protocol.convertor.VoidReplayConvertor;
 import org.redisson.client.protocol.decoder.*;
+import org.redisson.command.BatchPromise;
 import org.redisson.command.CommandAsyncService;
 import org.redisson.command.CommandBatchService;
 import org.redisson.connection.MasterSlaveEntry;
@@ -373,7 +374,7 @@ protected <T> T sync(RFuture<T> f) {
             return null;
         }
         if (isQueueing()) {
-            f.toCompletableFuture().join();
+            ((BatchPromise)f.toCompletableFuture()).getSentPromise().join();
             return null;
         }
 

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -33,6 +33,7 @@
 import org.redisson.client.protocol.convertor.DoubleReplayConvertor;
 import org.redisson.client.protocol.convertor.VoidReplayConvertor;
 import org.redisson.client.protocol.decoder.*;
+import org.redisson.command.BatchPromise;
 import org.redisson.command.CommandAsyncService;
 import org.redisson.command.CommandBatchService;
 import org.redisson.connection.MasterSlaveEntry;
@@ -355,7 +356,7 @@ protected <T> T sync(RFuture<T> f) {
             return null;
         }
         if (isQueueing()) {
-            f.toCompletableFuture().join();
+            ((BatchPromise)f.toCompletableFuture()).getSentPromise().join();
             return null;
         }
 

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -29,6 +29,7 @@
 import org.redisson.client.protocol.RedisStrictCommand;
 import org.redisson.client.protocol.convertor.*;
 import org.redisson.client.protocol.decoder.*;
+import org.redisson.command.BatchPromise;
 import org.redisson.command.CommandAsyncService;
 import org.redisson.command.CommandBatchService;
 import org.redisson.connection.MasterSlaveEntry;
@@ -353,7 +354,7 @@ protected <T> T sync(RFuture<T> f) {
             return null;
         }
         if (isQueueing()) {
-            f.toCompletableFuture().join();
+            ((BatchPromise)f.toCompletableFuture()).getSentPromise().join();
             return null;
         }
 

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -29,6 +29,7 @@
 import org.redisson.client.protocol.RedisStrictCommand;
 import org.redisson.client.protocol.convertor.*;
 import org.redisson.client.protocol.decoder.*;
+import org.redisson.command.BatchPromise;
 import org.redisson.command.CommandAsyncService;
 import org.redisson.command.CommandBatchService;
 import org.redisson.connection.MasterSlaveEntry;
@@ -353,7 +354,7 @@ protected <T> T sync(RFuture<T> f) {
             return null;
         }
         if (isQueueing()) {
-            f.toCompletableFuture().join();
+            ((BatchPromise)f.toCompletableFuture()).getSentPromise().join();
             return null;
         }
 

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -29,6 +29,7 @@
 import org.redisson.client.protocol.RedisStrictCommand;
 import org.redisson.client.protocol.convertor.*;
 import org.redisson.client.protocol.decoder.*;
+import org.redisson.command.BatchPromise;
 import org.redisson.command.CommandAsyncService;
 import org.redisson.command.CommandBatchService;
 import org.redisson.connection.MasterSlaveEntry;
@@ -353,7 +354,7 @@ protected <T> T sync(RFuture<T> f) {
             return null;
         }
         if (isQueueing()) {
-            f.toCompletableFuture().join();
+            ((BatchPromise)f.toCompletableFuture()).getSentPromise().join();
             return null;
         }
 

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -29,6 +29,7 @@
 import org.redisson.client.protocol.RedisStrictCommand;
 import org.redisson.client.protocol.convertor.*;
 import org.redisson.client.protocol.decoder.*;
+import org.redisson.command.BatchPromise;
 import org.redisson.command.CommandAsyncService;
 import org.redisson.command.CommandBatchService;
 import org.redisson.connection.MasterSlaveEntry;
@@ -353,7 +354,7 @@ protected <T> T sync(RFuture<T> f) {
             return null;
         }
         if (isQueueing()) {
-            f.toCompletableFuture().join();
+            ((BatchPromise)f.toCompletableFuture()).getSentPromise().join();
             return null;
         }
 

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -29,6 +29,7 @@
 import org.redisson.client.protocol.RedisStrictCommand;
 import org.redisson.client.protocol.convertor.*;
 import org.redisson.client.protocol.decoder.*;
+import org.redisson.command.BatchPromise;
 import org.redisson.command.CommandAsyncService;
 import org.redisson.command.CommandBatchService;
 import org.redisson.connection.MasterSlaveEntry;
@@ -353,7 +354,7 @@ protected <T> T sync(RFuture<T> f) {
             return null;
         }
         if (isQueueing()) {
-            f.toCompletableFuture().join();
+            ((BatchPromise)f.toCompletableFuture()).getSentPromise().join();
             return null;
         }
 

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -29,6 +29,7 @@
 import org.redisson.client.protocol.RedisStrictCommand;
 import org.redisson.client.protocol.convertor.*;
 import org.redisson.client.protocol.decoder.*;
+import org.redisson.command.BatchPromise;
 import org.redisson.command.CommandAsyncService;
 import org.redisson.command.CommandBatchService;
 import org.redisson.connection.MasterSlaveEntry;
@@ -353,7 +354,7 @@ protected <T> T sync(RFuture<T> f) {
             return null;
         }
         if (isQueueing()) {
-            f.toCompletableFuture().join();
+            ((BatchPromise)f.toCompletableFuture()).getSentPromise().join();
             return null;
         }
 

File: redisson/src/main/java/org/redisson/config/SentinelServersConfig.java
Patch:
@@ -68,6 +68,7 @@ public SentinelServersConfig() {
         setScanInterval(config.getScanInterval());
         setNatMapper(config.getNatMapper());
         setCheckSentinelsList(config.isCheckSentinelsList());
+        setSentinelUsername(config.getSentinelUsername());
         setSentinelPassword(config.getSentinelPassword());
         setCheckSlaveStatusWithSyncing(config.isCheckSlaveStatusWithSyncing());
         setSentinelsDiscovery(config.isSentinelsDiscovery());

File: redisson/src/main/java/org/redisson/config/PropertiesConvertor.java
Patch:
@@ -77,7 +77,8 @@ private static String convertKey(String key) {
         return builder.toString();
     }
 
-    private static final Set<String> LIST_NODES = new HashSet<>(Arrays.asList("node-addresses", "slave-addresses", "addresses"));
+    private static final Set<String> LIST_NODES = new HashSet<>(
+                            Arrays.asList("node-addresses", "nodeaddresses", "slave-addresses", "slaveaddresses", "addresses"));
 
     private static void addValue(StringBuilder yaml, Map.Entry<String, Object> subEntry) {
         String value = (String) subEntry.getValue();

File: redisson/src/main/java/org/redisson/client/protocol/decoder/SlotsDecoder.java
Patch:
@@ -42,7 +42,7 @@ public Decoder<Object> getDecoder(Codec codec, int paramNum, State state) {
     
     @Override
     public Object decode(List<Object> parts, State state) {
-        if (parts.size() > 2 && parts.get(0) instanceof List) {
+        if (parts.get(0) instanceof List) {
             Map<ClusterSlotRange, Set<String>> result = new HashMap<>();
             List<List<Object>> rows = (List<List<Object>>) (Object) parts;
             for (List<Object> row : rows) {

File: redisson-quarkus/redisson-quarkus-16/runtime/src/main/java/io/quarkus/redisson/client/runtime/RedissonClientRecorder.java
Patch:
@@ -26,9 +26,8 @@
 @Recorder
 public class RedissonClientRecorder {
 
-    public void configureRedisson(String config) {
-        RedissonClientProducer producer = Arc.container().instance(RedissonClientProducer.class).get();
-        producer.setConfig(config);
+    public void createProducer() {
+        Arc.container().instance(RedissonClientProducer.class).get();
     }
 
 }

File: redisson/src/test/java/org/redisson/rx/RedissonBlockingDequeRxTest.java
Patch:
@@ -53,7 +53,7 @@ public void testPollLastAndOfferFirstTo() throws InterruptedException {
         RBlockingDequeRx<String> blockingDeque = redisson.getBlockingDeque("blocking_deque");
         long start = System.currentTimeMillis();
         String redisTask = sync(blockingDeque.pollLastAndOfferFirstTo("deque", 1, TimeUnit.SECONDS));
-        assertThat(System.currentTimeMillis() - start).isBetween(950L, 1200L);
+        assertThat(System.currentTimeMillis() - start).isBetween(950L, 1400L);
         assertThat(redisTask).isNull();
     }
     

File: redisson/src/test/java/org/redisson/RedissonSpinLockTest.java
Patch:
@@ -85,7 +85,7 @@ public void testTryLockWait() throws InterruptedException {
 
         RLock lock = redisson.getSpinLock("lock");
 
-        Awaitility.await().between(Duration.ofMillis(3000), Duration.ofMillis(3200)).untilAsserted(() -> {
+        Awaitility.await().between(Duration.ofMillis(3000), Duration.ofMillis(3500)).untilAsserted(() -> {
             lock.tryLock(3, TimeUnit.SECONDS);
         });
     }

File: redisson-quarkus/redisson-quarkus-20/runtime/src/main/java/io/quarkus/redisson/client/runtime/RedissonClientRecorder.java
Patch:
@@ -26,9 +26,8 @@
 @Recorder
 public class RedissonClientRecorder {
 
-    public void configureRedisson(String config) {
-        RedissonClientProducer producer = Arc.container().instance(RedissonClientProducer.class).get();
-        producer.setConfig(config);
+    public void createProducer() {
+        Arc.container().instance(RedissonClientProducer.class).get();
     }
 
 }

File: redisson/src/main/java/org/redisson/pubsub/PublishSubscribe.java
Patch:
@@ -76,6 +76,7 @@ public CompletableFuture<E> subscribe(String entryName, String channelName) {
                     }
                     newPromise.complete(r);
                 });
+                return;
             }
 
             E value = createEntry(newPromise);

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -254,7 +254,7 @@ public interface RedisCommands {
     RedisCommand<Set<Object>> EVAL_MAP_VALUE_SET = new RedisCommand<Set<Object>>("EVAL",
             new MapValueDecoder(new ObjectSetReplayDecoder<>()));
     RedisCommand<Set<Object>> EVAL_MAP_KEY_SET = new RedisCommand<Set<Object>>("EVAL",
-            new MapValueDecoder(new ObjectSetReplayDecoder<>()));
+            new MapKeyDecoder(new ObjectSetReplayDecoder<>()));
 
     RedisStrictCommand<Long> INCR = new RedisStrictCommand<Long>("INCR");
     RedisStrictCommand<Long> INCRBY = new RedisStrictCommand<Long>("INCRBY");

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -368,8 +368,7 @@ public void operationComplete(Future<List<InetSocketAddress>> future) throws Exc
                             
                             List<RedisURI> nodes = new ArrayList<>();
                             for (InetSocketAddress addr : future.getNow()) {
-                                RedisURI node = new RedisURI(uri.getScheme() + "://" + addr.getAddress().getHostAddress() + ":" + addr.getPort());
-                                RedisURI address = applyNatMap(node);
+                                RedisURI address = toURI(uri.getScheme(), addr.getAddress().getHostAddress(), "" + addr.getPort());
                                 nodes.add(address);
                             }
                             

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -2228,6 +2228,7 @@ public Long bitPos(byte[] key, boolean bit, org.springframework.data.domain.Rang
     public void restore(byte[] key, long ttlInMillis, byte[] serializedValue, boolean replace) {
         if (replace) {
             write(key, StringCodec.INSTANCE, RedisCommands.RESTORE, key, ttlInMillis, serializedValue, "REPLACE");
+            return;
         }
         restore(key, ttlInMillis, serializedValue);
     }

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -2233,6 +2233,7 @@ public Long bitPos(byte[] key, boolean bit, org.springframework.data.domain.Rang
     public void restore(byte[] key, long ttlInMillis, byte[] serializedValue, boolean replace) {
         if (replace) {
             write(key, StringCodec.INSTANCE, RedisCommands.RESTORE, key, ttlInMillis, serializedValue, "REPLACE");
+            return;
         }
         restore(key, ttlInMillis, serializedValue);
     }

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -2233,6 +2233,7 @@ public Long bitPos(byte[] key, boolean bit, org.springframework.data.domain.Rang
     public void restore(byte[] key, long ttlInMillis, byte[] serializedValue, boolean replace) {
         if (replace) {
             write(key, StringCodec.INSTANCE, RedisCommands.RESTORE, key, ttlInMillis, serializedValue, "REPLACE");
+            return;
         }
         restore(key, ttlInMillis, serializedValue);
     }

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -2233,6 +2233,7 @@ public Long bitPos(byte[] key, boolean bit, org.springframework.data.domain.Rang
     public void restore(byte[] key, long ttlInMillis, byte[] serializedValue, boolean replace) {
         if (replace) {
             write(key, StringCodec.INSTANCE, RedisCommands.RESTORE, key, ttlInMillis, serializedValue, "REPLACE");
+            return;
         }
         restore(key, ttlInMillis, serializedValue);
     }

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -2272,6 +2272,7 @@ public Long bitPos(byte[] key, boolean bit, org.springframework.data.domain.Rang
     public void restore(byte[] key, long ttlInMillis, byte[] serializedValue, boolean replace) {
         if (replace) {
             write(key, StringCodec.INSTANCE, RedisCommands.RESTORE, key, ttlInMillis, serializedValue, "REPLACE");
+            return;
         }
         restore(key, ttlInMillis, serializedValue);
     }

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -2272,6 +2272,7 @@ public Long bitPos(byte[] key, boolean bit, org.springframework.data.domain.Rang
     public void restore(byte[] key, long ttlInMillis, byte[] serializedValue, boolean replace) {
         if (replace) {
             write(key, StringCodec.INSTANCE, RedisCommands.RESTORE, key, ttlInMillis, serializedValue, "REPLACE");
+            return;
         }
         restore(key, ttlInMillis, serializedValue);
     }

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1786,7 +1786,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1853,7 +1853,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1866,7 +1866,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1856,7 +1856,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1854,7 +1854,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1854,7 +1854,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1854,7 +1854,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1854,7 +1854,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1893,7 +1893,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1893,7 +1893,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1786,7 +1786,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1853,7 +1853,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1866,7 +1866,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1856,7 +1856,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1854,7 +1854,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1854,7 +1854,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1854,7 +1854,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1854,7 +1854,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-25/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1893,7 +1893,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson-spring-data/redisson-spring-data-26/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1893,7 +1893,7 @@ public <T> T eval(byte[] script, ReturnType returnType, int numKeys, byte[]... k
         params.add(script);
         params.add(numKeys);
         params.addAll(Arrays.asList(keysAndArgs));
-        return write(null, StringCodec.INSTANCE, c, params.toArray());
+        return write(null, ByteArrayCodec.INSTANCE, c, params.toArray());
     }
 
     protected RedisCommand<?> toCommand(ReturnType returnType, String name) {

File: redisson/src/test/java/org/redisson/RedissonBlockingDequeTest.java
Patch:
@@ -2,6 +2,7 @@
 
 import org.awaitility.Awaitility;
 import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Assumptions;
 import org.junit.jupiter.api.Test;
 import org.redisson.api.RBlockingDeque;
 import org.redisson.api.queue.DequeMoveArgs;
@@ -17,6 +18,8 @@ public class RedissonBlockingDequeTest extends BaseTest {
 
     @Test
     public void testMove() {
+        Assumptions.assumeTrue(RedisRunner.getDefaultRedisServerInstance().getRedisVersion().compareTo("6.2.0") > 0);
+
         RBlockingDeque<Integer> deque1 = redisson.getBlockingDeque("deque1");
         RBlockingDeque<Integer> deque2 = redisson.getBlockingDeque("deque2");
 

File: redisson/src/test/java/org/redisson/RedissonBucketTest.java
Patch:
@@ -22,6 +22,8 @@ public class RedissonBucketTest extends BaseTest {
 
     @Test
     public void testKeepTTL() {
+        Assumptions.assumeTrue(RedisRunner.getDefaultRedisServerInstance().getRedisVersion().compareTo("6.0.0") > 0);
+
         RBucket<Integer> al = redisson.getBucket("test");
         al.set(1234, 10, TimeUnit.SECONDS);
         al.setAndKeepTTL(222);

File: redisson/src/test/java/org/redisson/RedissonLiveObjectServiceTest.java
Patch:
@@ -372,8 +372,6 @@ public void testIndexedPersist() {
         List<TestIndexed> s = liveObjectService.persist(item1, item2);
         assertThat(s.get(0).getId()).isEqualTo(item1.getId());
         assertThat(s.get(1).getId()).isEqualTo(item2.getId());
-
-        redisson.shutdown();
     }
 
     @Test

File: redisson/src/main/java/org/redisson/client/RedisClient.java
Patch:
@@ -32,12 +32,9 @@
 import io.netty.util.Timer;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.FutureListener;
-import org.redisson.api.RFuture;
 import org.redisson.client.handler.RedisChannelInitializer;
 import org.redisson.client.handler.RedisChannelInitializer.Type;
-import org.redisson.misc.RPromise;
 import org.redisson.misc.RedisURI;
-import org.redisson.misc.RedissonPromise;
 
 import java.net.InetAddress;
 import java.net.InetSocketAddress;

File: redisson/src/main/java/org/redisson/RedissonScoredSortedSet.java
Patch:
@@ -573,13 +573,13 @@ private RFuture<ScanResult<Object>> distributedScanIteratorAsync(String iterator
         args.add(count);
 
         return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_ZSCAN,
-                "local cursor = redis.call('get', KEYS[3]); "
+                "local cursor = redis.call('get', KEYS[2]); "
                 + "if cursor ~= false then "
                     + "cursor = tonumber(cursor); "
                 + "else "
                     + "cursor = 0;"
                 + "end;"
-                + "if start_index == -1 then "
+                + "if cursor == -1 then "
                     + "return {0, {}}; "
                 + "end;"
                 + "local result; "

File: redisson/src/main/java/org/redisson/RedissonSet.java
Patch:
@@ -158,7 +158,7 @@ private RFuture<ScanResult<Object>> distributedScanIteratorAsync(String iterator
                 + "else "
                     + "cursor = 0;"
                 + "end;"
-                + "if start_index == -1 then "
+                + "if cursor == -1 then "
                     + "return {0, {}}; "
                 + "end;"
                 + "local result; "

File: redisson/src/main/java/org/redisson/RedissonSetMultimapValues.java
Patch:
@@ -278,7 +278,7 @@ private RFuture<ScanResult<Object>> distributedScanIteratorAsync(String iterator
                 + "else"
                     + " cursor = 0;"
                 + "end;"
-                + "if start_index == -1 then "
+                + "if cursor == -1 then "
                     + "return {0, {}}; "
                 + "end;"
                 + "local result; "

File: redisson/src/main/java/org/redisson/connection/MasterSlaveEntry.java
Patch:
@@ -37,7 +37,6 @@
 import java.net.InetSocketAddress;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.TimeUnit;

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -337,7 +337,7 @@ protected void initSingleEntry() {
             masterFuture.syncUninterruptibly();
 
             if (!config.checkSkipSlavesInit()) {
-                List<RFuture<Void>> fs = masterSlaveEntry.initSlaveBalancer(getDisconnectedNodes(), masterFuture.getNow());
+                List<RFuture<Void>> fs = masterSlaveEntry.initSlaveBalancer(getDisconnectedNodes());
                 for (RFuture<Void> future : fs) {
                     future.syncUninterruptibly();
                 }

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -444,7 +444,7 @@ private RFuture<List<Map<String, String>>> checkSlavesChange(SentinelServersConf
                 return;
             }
 
-            Set<RedisURI> currentSlaves = new HashSet<>(slavesMap.size());
+            Set<RedisURI> currentSlaves = Collections.newSetFromMap(new ConcurrentHashMap<>(slavesMap.size()));
             AsyncCountDownLatch latch = new AsyncCountDownLatch();
             for (Map<String, String> map : slavesMap) {
                 if (map.isEmpty()) {

File: redisson/src/main/java/org/redisson/misc/TransferListener.java
Patch:
@@ -52,7 +52,7 @@ public void accept(Object t, Throwable u) {
         if (value != null) {
             promise.trySuccess(value);
         } else {
-            promise.trySuccess((T)t);
+            promise.trySuccess((T) t);
         }
     }
     

File: redisson/src/main/java/org/redisson/connection/MasterSlaveEntry.java
Patch:
@@ -144,8 +144,9 @@ private RFuture<RedisClient> setupMasterEntry(RedisClient client) {
 
             CountableListener<RedisClient> listener = new CountableListener<>(result, client, counter);
 
-            if (!slaveBalancer.contains(client.getAddr())) {
-                RFuture<Void> masterAsSlaveFuture = addSlave(client.getAddr(), client.getConfig().getAddress(), false, NodeType.MASTER, client.getConfig().getSslHostname());
+            if (!config.checkSkipSlavesInit() && !slaveBalancer.contains(client.getAddr())) {
+                RFuture<Void> masterAsSlaveFuture = addSlave(client.getAddr(), client.getConfig().getAddress(),
+                                                    false, NodeType.MASTER, client.getConfig().getSslHostname());
                 masterAsSlaveFuture.onComplete(listener);
             }
 

File: redisson-mybatis/src/main/java/org/redisson/mybatis/RedissonCache.java
Patch:
@@ -102,7 +102,7 @@ public ReadWriteLock getReadWriteLock() {
     public void setRedissonConfig(String config) {
         Config cfg;
         try {
-            InputStream is = getClass().getResourceAsStream(config);
+            InputStream is = getClass().getClassLoader().getResourceAsStream(config);
             cfg = Config.fromYAML(is);
         } catch (IOException e) {
             throw new IllegalArgumentException("Can't parse config", e);

File: redisson/src/main/java/org/redisson/RedissonList.java
Patch:
@@ -138,7 +138,7 @@ public RFuture<Boolean> removeAsync(Object o) {
 
     @Override
     public RFuture<Boolean> removeAsync(Object o, int count) {
-        return commandExecutor.writeAsync(getRawName(), codec, LREM_SINGLE, getRawName(), count, encode(o));
+        return commandExecutor.writeAsync(getRawName(), codec, LREM, getRawName(), count, encode(o));
     }
 
     @Override

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -172,7 +172,7 @@ public interface RedisCommands {
     RedisCommand<Void> LSET = new RedisCommand<Void>("LSET", new VoidReplayConvertor());
     RedisCommand<Object> LPOP = new RedisCommand<Object>("LPOP");
     RedisCommand<List<Object>> LPOP_LIST = new RedisCommand<>("LPOP", new ObjectListReplayDecoder<>());
-    RedisCommand<Boolean> LREM_SINGLE = new RedisCommand<Boolean>("LREM", new BooleanReplayConvertor());
+    RedisCommand<Boolean> LREM = new RedisCommand<Boolean>("LREM", new BooleanAmountReplayConvertor());
     RedisCommand<Object> LINDEX = new RedisCommand<Object>("LINDEX");
     RedisCommand<Object> LMOVE = new RedisCommand<Object>("LMOVE");
     RedisCommand<Integer> LINSERT_INT = new RedisCommand<Integer>("LINSERT", new IntegerReplayConvertor());

File: redisson/src/main/java/org/redisson/executor/CronExpression.java
Patch:
@@ -137,6 +137,7 @@
  * Day-of-week field &quot;FRI-MON&quot; is invalid,but &quot;FRI-SUN,MON&quot; is valid
  *
  */
+@SuppressWarnings({"AvoidInlineConditionals", "MultipleVariableDeclarations", "InnerAssignment", "UnnecessaryParentheses"})
 public class CronExpression {
 
     enum CronFieldType {

File: redisson/src/main/java/org/redisson/RedissonList.java
Patch:
@@ -136,7 +136,7 @@ public RFuture<Boolean> removeAsync(Object o) {
 
     @Override
     public RFuture<Boolean> removeAsync(Object o, int count) {
-        return commandExecutor.writeAsync(getRawName(), codec, LREM_SINGLE, getRawName(), count, encode(o));
+        return commandExecutor.writeAsync(getRawName(), codec, LREM, getRawName(), count, encode(o));
     }
 
     @Override

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -172,7 +172,7 @@ public interface RedisCommands {
     RedisCommand<Void> LSET = new RedisCommand<Void>("LSET", new VoidReplayConvertor());
     RedisCommand<Object> LPOP = new RedisCommand<Object>("LPOP");
     RedisCommand<List<Object>> LPOP_LIST = new RedisCommand<>("LPOP", new ObjectListReplayDecoder<>());
-    RedisCommand<Boolean> LREM_SINGLE = new RedisCommand<Boolean>("LREM", new BooleanReplayConvertor());
+    RedisCommand<Boolean> LREM = new RedisCommand<Boolean>("LREM", new BooleanAmountReplayConvertor());
     RedisCommand<Object> LINDEX = new RedisCommand<Object>("LINDEX");
     RedisCommand<Object> LMOVE = new RedisCommand<Object>("LMOVE");
     RedisCommand<Integer> LINSERT_INT = new RedisCommand<Integer>("LINSERT", new IntegerReplayConvertor());

File: redisson/src/main/java/org/redisson/cache/LocalCachedMessageCodec.java
Patch:
@@ -19,11 +19,9 @@
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.util.CharsetUtil;
 import org.redisson.client.codec.BaseCodec;
-import org.redisson.client.handler.State;
 import org.redisson.client.protocol.Decoder;
 import org.redisson.client.protocol.Encoder;
 
-import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -598,7 +598,7 @@ public RFuture<Long> sizeInMemoryAsync() {
     @Override
     public RFuture<Boolean> deleteAsync() {
         cache.clear();
-        ByteBuf msgEncoded = encode(new LocalCachedMapClear(listener.generateId(), false));
+        ByteBuf msgEncoded = encode(new LocalCachedMapClear(instanceId, listener.generateId(), false));
         return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 "if redis.call('del', KEYS[1], KEYS[3]) > 0 and ARGV[2] ~= '0' then "
                 + "redis.call('publish', KEYS[2], ARGV[1]); "

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -698,6 +698,9 @@ public RFuture<RedisURI> resolveIP(RedisURI address) {
     protected RFuture<RedisURI> resolveIP(String scheme, RedisURI address) {
         if (address.isIP()) {
             RedisURI addr = applyNatMap(address);
+            if (!scheme.equals(addr.getScheme())) {
+                addr = new RedisURI(scheme, addr.getHost(), addr.getPort());
+            }
             return RedissonPromise.newSucceededFuture(addr);
         }
 

File: redisson/src/main/java/org/redisson/RedissonScoredSortedSet.java
Patch:
@@ -961,8 +961,8 @@ public RFuture<Integer> countIntersectionAsync(String... names) {
     @Override
     public RFuture<Integer> countIntersectionAsync(int limit, String... names) {
         List<Object> args = new ArrayList<>(names.length + 1);
+        args.add(names.length + 1);
         args.add(getRawName());
-        args.add(names.length);
         args.addAll(Arrays.asList(names));
         if (limit > 0) {
             args.add("LIMIT");

File: redisson/src/main/java/org/redisson/RedissonSet.java
Patch:
@@ -422,8 +422,8 @@ public Integer countIntersection(int limit, String... names) {
     @Override
     public RFuture<Integer> countIntersectionAsync(int limit, String... names) {
         List<Object> args = new ArrayList<>(names.length + 1);
+        args.add(names.length + 1);
         args.add(getRawName());
-        args.add(names.length);
         args.addAll(Arrays.asList(names));
         if (limit > 0) {
             args.add("LIMIT");

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -118,7 +118,7 @@ private void broadcastLocalCacheStore(V value, ByteBuf mapKey, CacheKey cacheKey
             Object msg;
             if (syncStrategy == SyncStrategy.UPDATE) {
                 ByteBuf mapValue = encodeMapValue(value);
-                msg = new LocalCachedMapUpdate(mapKey, mapValue);
+                msg = new LocalCachedMapUpdate(instanceId, mapKey, mapValue);
             } else {
                 msg = new LocalCachedMapInvalidate(instanceId, cacheKey.getKeyHash());
             }
@@ -342,7 +342,7 @@ protected RFuture<V> putOperationAsync(K key, V value) {
 
     protected ByteBuf createSyncMessage(ByteBuf mapKey, ByteBuf mapValue, CacheKey cacheKey) {
         if (syncStrategy == SyncStrategy.UPDATE) {
-            return encode(new LocalCachedMapUpdate(mapKey, mapValue));
+            return encode(new LocalCachedMapUpdate(instanceId, mapKey, mapValue));
         }
         return encode(new LocalCachedMapInvalidate(instanceId, cacheKey.getKeyHash()));
     }
@@ -712,7 +712,7 @@ protected RFuture<Void> putAllOperationAsync(Map<? extends K, ? extends V> map)
                 entries.add(new LocalCachedMapUpdate.Entry(key, value));
                 
             }
-            msgEncoded = encode(new LocalCachedMapUpdate(entries));
+            msgEncoded = encode(new LocalCachedMapUpdate(instanceId, entries));
         } else if (syncStrategy == SyncStrategy.INVALIDATE) {
             msgEncoded = encode(new LocalCachedMapInvalidate(instanceId, hashes));
         }

File: redisson/src/main/java/org/redisson/connection/DNSMonitor.java
Patch:
@@ -34,7 +34,6 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * DNS changes monitor.

File: redisson/src/main/java/org/redisson/RedissonRemoteService.java
Patch:
@@ -294,6 +294,8 @@ private <T> void subscribe(Class<T> remoteInterface, RBlockingQueue<String> requ
 
                 // poll method may return null value
                 if (requestId == null) {
+                    // Because the previous code is already -1, it must be +1 before returning, otherwise the counter will become 0 soon
+                    resubscribe(remoteInterface, requestQueue, executor, bean);
                     return;
                 }
 

File: redisson/src/main/java/org/redisson/RedissonRemoteService.java
Patch:
@@ -295,7 +295,7 @@ private <T> void subscribe(Class<T> remoteInterface, RBlockingQueue<String> requ
                 // poll method may return null value
                 if (requestId == null) {
                     // Because the previous code is already -1, it must be +1 before returning, otherwise the counter will become 0 soon
-                    entry.getCounter().incrementAndGet();
+                    resubscribe(remoteInterface, requestQueue, executor, bean);
                     return;
                 }
 

File: redisson/src/main/java/org/redisson/RedissonRemoteService.java
Patch:
@@ -294,6 +294,8 @@ private <T> void subscribe(Class<T> remoteInterface, RBlockingQueue<String> requ
 
                 // poll method may return null value
                 if (requestId == null) {
+                    // Because the previous code is already -1, it must be +1 before returning, otherwise the counter will become 0 soon
+                    entry.getCounter().incrementAndGet();
                     return;
                 }
 

File: redisson-micronaut/redisson-micronaut-30/src/test/java/org/redisson/micronaut/RedissonSessionTest.java
Patch:
@@ -179,7 +179,7 @@ public void testSessionCreate() throws ExecutionException, InterruptedException
         Optional<RedissonSession> noSession = sessionStore.findSession(saved.getId()).get();
         assertThat(noSession).isEmpty();
 
-        Thread.sleep(10000);
+        Thread.sleep(11000);
 
         assertThat(rc.getKeys().count()).isZero();
 

File: redisson/src/main/java/org/redisson/command/CommandAsyncExecutor.java
Patch:
@@ -28,7 +28,6 @@
 
 import java.util.Collection;
 import java.util.List;
-import java.util.Map;
 
 /**
  *

File: redisson/src/main/java/org/redisson/RedissonBuckets.java
Patch:
@@ -150,7 +150,7 @@ public Object[] createParams(List<String> keys) {
                 }
                 return params.toArray();
             }
-        }, buckets.keySet().toArray(new String[]{}), buckets);
+        }, buckets.keySet().toArray(new String[]{}));
     }
 
 }

File: redisson/src/main/java/org/redisson/command/CommandAsyncExecutor.java
Patch:
@@ -120,7 +120,5 @@ public interface CommandAsyncExecutor {
     <T, R> RFuture<R> readBatchedAsync(Codec codec, RedisCommand<T> command, SlotCallback<T, R> callback, String... keys);
 
     <T, R> RFuture<R> writeBatchedAsync(Codec codec, RedisCommand<T> command, SlotCallback<T, R> callback, String... keys);
-    
-    <T, R> RFuture<R> writeBatchedAsync(Codec codec, RedisCommand<T> command, SlotCallback<T, R> callback, String[] keys, Map<String, ?> valueMap);
-    
+
 }

File: redisson/src/main/java/org/redisson/connection/balancer/LoadBalancerManager.java
Patch:
@@ -227,7 +227,7 @@ public boolean contains(RedisClient redisClient) {
         return getEntry(redisClient) != null;
     }
 
-    private ClientConnectionsEntry getEntry(RedisURI addr) {
+    public ClientConnectionsEntry getEntry(RedisURI addr) {
         for (ClientConnectionsEntry entry : client2Entry.values()) {
             InetSocketAddress entryAddr = entry.getClient().getAddr();
             if (RedisURI.compare(entryAddr, addr)) {

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -790,13 +790,12 @@ private RFuture<Collection<ClusterPartition>> parsePartitions(List<ClusterNodeIn
 
             RFuture<RedisURI> ipFuture = resolveIP(clusterNodeInfo.getAddress());
             counter++;
-            ipFuture.onComplete((addr, e) -> {
+            ipFuture.onComplete((address, e) -> {
                 if (e != null) {
                     latch.countDown();
                     return;
                 }
 
-                RedisURI address = applyNatMap(addr);
                 if (clusterNodeInfo.containsFlag(Flag.SLAVE)) {
                     ClusterPartition masterPartition = partitions.computeIfAbsent(masterId, k -> new ClusterPartition(masterId));
                     ClusterPartition slavePartition = partitions.computeIfAbsent(clusterNodeInfo.getNodeId(),

File: redisson/src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -46,6 +46,8 @@
 public interface ConnectionManager {
     
     RedisURI applyNatMap(RedisURI address);
+
+    RFuture<RedisURI> resolveIP(RedisURI address);
     
     String getId();
     

File: redisson/src/main/java/org/redisson/client/protocol/decoder/StreamObjectMapReplayDecoder.java
Patch:
@@ -43,8 +43,9 @@ public StreamObjectMapReplayDecoder(Decoder<Object> codec) {
 
     @Override
     public Map<Object, Object> decode(List<Object> parts, State state) {
-        if (parts.get(0) == null
-                || (parts.get(0) instanceof List && ((List) parts.get(0)).isEmpty())) {
+        if (parts.isEmpty()
+                || parts.get(0) == null
+                    || (parts.get(0) instanceof List && ((List) parts.get(0)).isEmpty())) {
             parts.clear();
             return Collections.emptyMap();
         }

File: redisson/src/main/java/org/redisson/RedissonIdGenerator.java
Patch:
@@ -63,7 +63,7 @@ public long nextId() {
 
     @Override
     public RFuture<Boolean> tryInitAsync(long value, long allocationSize) {
-        return commandExecutor.evalWriteAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                           "redis.call('setnx', KEYS[1], ARGV[1]); "
                         + "return redis.call('setnx', KEYS[2], ARGV[2]); ",
                 Arrays.asList(getRawName(), getAllocationSizeName()), value, allocationSize);

File: redisson/src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -961,7 +961,7 @@ protected boolean hasNoWriter() {
 
     protected RFuture<V> putIfAbsentOperationAsync(K key, V value) {
         String name = getRawName(key);
-        return commandExecutor.evalWriteAsync(name, codec, RedisCommands.EVAL_MAP_VALUE,
+        return commandExecutor.evalWriteNoRetryAsync(name, codec, RedisCommands.EVAL_MAP_VALUE,
                  "if redis.call('hsetnx', KEYS[1], ARGV[1], ARGV[2]) == 1 then "
                     + "return nil "
                 + "else "

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -106,7 +106,7 @@ public RFuture<Boolean> trySetMaxSizeAsync(int maxSize, EvictionMode mode) {
             throw new IllegalArgumentException("maxSize should be greater than zero");
         }
 
-        return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 "redis.call('hsetnx', KEYS[1], 'max-size', ARGV[1]);"
               + "return redis.call('hsetnx', KEYS[1], 'mode', ARGV[2]);",
                 Collections.singletonList(getOptionsName()), maxSize, mode);

File: redisson/src/main/java/org/redisson/RedissonRateLimiter.java
Patch:
@@ -242,7 +242,7 @@ public boolean trySetRate(RateType type, long rate, long rateInterval, RateInter
 
     @Override
     public RFuture<Boolean> trySetRateAsync(RateType type, long rate, long rateInterval, RateIntervalUnit unit) {
-        return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 "redis.call('hsetnx', KEYS[1], 'rate', ARGV[1]);"
               + "redis.call('hsetnx', KEYS[1], 'interval', ARGV[2]);"
               + "return redis.call('hsetnx', KEYS[1], 'type', ARGV[3]);",

File: redisson/src/main/java/org/redisson/RedissonRemoteService.java
Patch:
@@ -335,7 +335,7 @@ private <T> void subscribe(Class<T> remoteInterface, RBlockingQueue<String> requ
                     if (request.getOptions().isAckExpected()) {
                         String responseName = getResponseQueueName(request.getExecutorId());
                         String ackName = getAckName(request.getId());
-                                RFuture<Boolean> ackClientsFuture = commandExecutor.evalWriteAsync(responseName,
+                                RFuture<Boolean> ackClientsFuture = commandExecutor.evalWriteNoRetryAsync(responseName,
                                         LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                                             "if redis.call('setnx', KEYS[1], 1) == 1 then " 
                                                 + "redis.call('pexpire', KEYS[1], ARGV[1]);"

File: redisson/src/main/java/org/redisson/eviction/MapCacheEvictionTask.java
Patch:
@@ -56,7 +56,7 @@ String getName() {
     @Override
     RFuture<Integer> execute() {
         int latchExpireTime = Math.min(delay, 30);
-        return executor.evalWriteAsync(name, LongCodec.INSTANCE, RedisCommands.EVAL_INTEGER,
+        return executor.evalWriteNoRetryAsync(name, LongCodec.INSTANCE, RedisCommands.EVAL_INTEGER,
                 "if redis.call('setnx', KEYS[6], ARGV[4]) == 0 then "
                  + "return -1;"
               + "end;"

File: redisson/src/main/java/org/redisson/remote/AsyncRemoteProxy.java
Patch:
@@ -345,7 +345,7 @@ private RFuture<Boolean> cancelAsync(RemoteInvocationOptions optionsCopy, Remote
         RPromise<Boolean> result = new RedissonPromise<>();
         if (optionsCopy.isAckExpected()) {
             String ackName = remoteService.getAckName(requestId);
-            RFuture<Boolean> future = commandExecutor.evalWriteAsync(responseQueueName, LongCodec.INSTANCE,
+            RFuture<Boolean> future = commandExecutor.evalWriteNoRetryAsync(responseQueueName, LongCodec.INSTANCE,
                     RedisCommands.EVAL_BOOLEAN,
                     "if redis.call('setnx', KEYS[1], 1) == 1 then "
                         + "redis.call('pexpire', KEYS[1], ARGV[1]);"

File: redisson/src/main/java/org/redisson/remote/BaseRemoteProxy.java
Patch:
@@ -72,8 +72,8 @@ public String getRequestQueueName(Class<?> remoteInterface) {
     
     protected RFuture<RemoteServiceAck> tryPollAckAgainAsync(RemoteInvocationOptions optionsCopy,
             String ackName, RequestId requestId) {
-        RPromise<RemoteServiceAck> promise = new RedissonPromise<RemoteServiceAck>();
-        RFuture<Boolean> ackClientsFuture = commandExecutor.evalWriteAsync(ackName, LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
+        RPromise<RemoteServiceAck> promise = new RedissonPromise<>();
+        RFuture<Boolean> ackClientsFuture = commandExecutor.evalWriteNoRetryAsync(ackName, LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                     "if redis.call('setnx', KEYS[1], 1) == 1 then " 
                         + "redis.call('pexpire', KEYS[1], ARGV[1]);"
                         + "return 0;" 

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -507,6 +507,7 @@ public interface RedisCommands {
             Arrays.asList(RPOPLPUSH.getName(), LPOP.getName(), RPOP.getName(), LPUSH.getName(), RPUSH.getName(),
                     LPUSHX.getName(), RPUSHX.getName(), GEOADD.getName(), XADD.getName(), APPEND.getName(),
                     DECR.getName(), "DECRBY", INCR.getName(), INCRBY.getName(), ZINCRBY.getName(),
-                    "HINCRBYFLOAT", "HINCRBY", "INCRBYFLOAT"));
+                    "HINCRBYFLOAT", "HINCRBY", "INCRBYFLOAT", SET_BOOLEAN.getName(), SETNX.getName(),
+                    MSETNX.getName(), HSETNX.getName()));
 
 }

File: redisson/src/main/java/org/redisson/client/handler/CommandPubSubDecoder.java
Patch:
@@ -208,7 +208,7 @@ private void enqueueMessage(Object res, RedisPubSubConnection pubSubConnection,
     
     @Override
     protected MultiDecoder<Object> messageDecoder(CommandData<Object, Object> data, List<Object> parts) {
-        if (parts.isEmpty()) {
+        if (parts.isEmpty() || parts.get(0) == null) {
             return null;
         }
         String command = parts.get(0).toString();

File: redisson/src/main/java/org/redisson/RedissonCountDownLatch.java
Patch:
@@ -284,7 +284,7 @@ public void countDown() {
 
     @Override
     public RFuture<Void> countDownAsync() {
-        return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                         "local v = redis.call('decr', KEYS[1]);" +
                         "if v <= 0 then redis.call('del', KEYS[1]) end;" +
                         "if v == 0 then redis.call('publish', KEYS[2], ARGV[1]) end;",

File: redisson/src/main/java/org/redisson/RedissonDelayedQueue.java
Patch:
@@ -102,7 +102,7 @@ public RFuture<Void> offerAsync(V e, long delay, TimeUnit timeUnit) {
         long timeout = System.currentTimeMillis() + delayInMs;
      
         long randomId = ThreadLocalRandom.current().nextLong();
-        return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_VOID,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_VOID,
                 "local value = struct.pack('dLc0', tonumber(ARGV[2]), string.len(ARGV[3]), ARGV[3]);" 
               + "redis.call('zadd', KEYS[2], ARGV[1], value);"
               + "redis.call('rpush', KEYS[3], value);"

File: redisson/src/main/java/org/redisson/RedissonList.java
Patch:
@@ -208,7 +208,7 @@ public RFuture<Boolean> addAllAsync(int index, Collection<? extends V> coll) {
         args.add(index);
         encode(args, coll);
         
-        return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_BOOLEAN,
                 "local ind = table.remove(ARGV, 1); " + // index is the first parameter
                         "local size = redis.call('llen', KEYS[1]); " +
                         "assert(tonumber(ind) <= size, 'index: ' .. ind .. ' but current size: ' .. size); " +

File: redisson/src/main/java/org/redisson/RedissonListMultimap.java
Patch:
@@ -137,7 +137,7 @@ public RFuture<Boolean> putAsync(K key, V value) {
         ByteBuf valueState = encodeMapValue(value);
 
         String setName = getValuesName(keyHash);
-        return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_BOOLEAN,
                 "redis.call('hset', KEYS[1], ARGV[1], ARGV[2]); " +
                 "redis.call('rpush', KEYS[2], ARGV[3]); " +
                 "return 1; ",
@@ -173,7 +173,7 @@ public RFuture<Boolean> putAllAsync(K key, Iterable<? extends V> values) {
         }
 
         String setName = getValuesName(keyHash);
-        return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_BOOLEAN_AMOUNT,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_BOOLEAN_AMOUNT,
                 "redis.call('hset', KEYS[1], ARGV[1], ARGV[2]); " +
                 "return redis.call('rpush', KEYS[2], unpack(ARGV, 3, #ARGV)); ",
             Arrays.<Object>asList(getRawName(), setName), params.toArray());
@@ -319,7 +319,7 @@ public RFuture<Collection<V>> replaceValuesAsync(K key, Iterable<? extends V> va
         }
 
         String setName = getValuesName(keyHash);
-        return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_LIST,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_LIST,
                 "redis.call('hset', KEYS[1], ARGV[1], ARGV[2]); " +
                 "local members = redis.call('lrange', KEYS[2], 0, -1); " +
                 "redis.call('del', KEYS[2]); " +

File: redisson/src/main/java/org/redisson/RedissonPriorityQueue.java
Patch:
@@ -161,7 +161,7 @@ public boolean add(V value) {
                 index = res.getIndex() + 1;
             }
                 
-            get(commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_VOID,
+            get(commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_VOID,
                "local len = redis.call('llen', KEYS[1]);"
                 + "if tonumber(ARGV[1]) < len then "
                     + "local pivot = redis.call('lindex', KEYS[1], ARGV[1]);"

File: redisson/src/main/java/org/redisson/RedissonQueueSemaphore.java
Patch:
@@ -64,7 +64,7 @@ public RFuture<Boolean> tryAcquireAsync(int permits) {
             params.add(1);
             params.add(encode(value));
         }
-        return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_BOOLEAN,
                 "local value = redis.call('get', KEYS[1]); " +
                     "assert(value ~= false, 'Capacity of queue ' .. KEYS[1] .. ' has not been set'); " +
                     "if (tonumber(value) >= tonumber(ARGV[1])) then " +

File: redisson/src/main/java/org/redisson/RedissonReliableTopic.java
Patch:
@@ -163,7 +163,7 @@ public <M> RFuture<String> addListenerAsync(Class<M> type, MessageListener<M> li
             StreamMessageId startId = new StreamMessageId(System.currentTimeMillis(), 0);
 
             RPromise<String> promise = new RedissonPromise<>();
-            RFuture<Void> addFuture = commandExecutor.evalWriteAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.EVAL_VOID,
+            RFuture<Void> addFuture = commandExecutor.evalWriteNoRetryAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.EVAL_VOID,
                     "local value = redis.call('incr', KEYS[3]); "
                             + "redis.call('zadd', KEYS[4], ARGV[3], ARGV[2]); "
                             + "redis.call('zadd', KEYS[1], value, ARGV[2]); "

File: redisson/src/main/java/org/redisson/RedissonRingBuffer.java
Patch:
@@ -99,7 +99,7 @@ public RFuture<Boolean> addAllAsync(Collection<? extends V> c) {
 
         List<Object> args = new ArrayList<>(c.size());
         encode(args, c);
-        return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 "local limit = redis.call('get', KEYS[2]); "
               + "assert(limit ~= false, 'RingBuffer capacity is not defined'); "
 

File: redisson/src/main/java/org/redisson/RedissonSortedSet.java
Patch:
@@ -196,7 +196,7 @@ public boolean add(V value) {
                 
                 ByteBuf encodedValue = encode(value);
                 
-                commandExecutor.get(commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_VOID,
+                commandExecutor.get(commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_VOID,
                    "local len = redis.call('llen', KEYS[1]);"
                     + "if tonumber(ARGV[1]) < len then "
                         + "local pivot = redis.call('lindex', KEYS[1], ARGV[1]);"

File: redisson/src/main/java/org/redisson/RedissonSubList.java
Patch:
@@ -140,7 +140,7 @@ public RFuture<Boolean> addAllAsync(int index, Collection<? extends V> coll) {
         args.add(index);
         encode(args, coll);
         
-        return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_BOOLEAN,
                 "local ind = table.remove(ARGV, 1); " + // index is the first parameter
                         "local size = redis.call('llen', KEYS[1]); " +
                         "assert(tonumber(ind) <= size, 'index: ' .. ind .. ' but current size: ' .. size); " +
@@ -230,7 +230,7 @@ public void clear() {
             return;
         }
 
-        get(commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_VOID,
+        get(commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_VOID,
                         "local tail = redis.call('lrange', KEYS[1], ARGV[2], -1); " +
                         "redis.call('ltrim', KEYS[1], 0, ARGV[1] - 1); " +
                         "if #tail > 0 then " +
@@ -309,7 +309,7 @@ private V removeInner(int index) {
             return get(f);
         }
 
-        RFuture<V> f = commandExecutor.evalWriteAsync(getRawName(), codec, EVAL_OBJECT,
+        RFuture<V> f = commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, EVAL_OBJECT,
                 "local v = redis.call('lindex', KEYS[1], ARGV[1]); " +
                         "local tail = redis.call('lrange', KEYS[1], ARGV[1] + 1, -1);" +
                         "redis.call('ltrim', KEYS[1], 0, ARGV[1] - 1);" +

File: redisson/src/main/java/org/redisson/executor/ScheduledTasksService.java
Patch:
@@ -58,7 +58,7 @@ protected RFuture<Boolean> addAsync(String requestQueueName, RemoteServiceReques
             expireTime = System.currentTimeMillis() + params.getTtl();
         }
 
-        return commandExecutor.evalWriteAsync(name, LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWriteNoRetryAsync(name, LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 // check if executor service not in shutdown state
                 "if redis.call('exists', KEYS[2]) == 0 then "
                     + "local retryInterval = redis.call('get', KEYS[6]); "
@@ -94,7 +94,7 @@ protected RFuture<Boolean> addAsync(String requestQueueName, RemoteServiceReques
     
     @Override
     protected RFuture<Boolean> removeAsync(String requestQueueName, RequestId taskId) {
-        return commandExecutor.evalWriteAsync(name, StringCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWriteNoRetryAsync(name, StringCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                    // remove from scheduler queue
                     "if redis.call('exists', KEYS[3]) == 0 then "
                       + "return 1;"

File: redisson/src/main/java/org/redisson/executor/TasksRunnerService.java
Patch:
@@ -384,7 +384,7 @@ void finish(String requestId, boolean removeTask) {
                     + "end;"
                 + "end;";  
 
-        RFuture<Object> f = commandExecutor.evalWriteAsync(name, StringCodec.INSTANCE, RedisCommands.EVAL_VOID,
+        RFuture<Object> f = commandExecutor.evalWriteNoRetryAsync(name, StringCodec.INSTANCE, RedisCommands.EVAL_VOID,
                 script,
                 Arrays.asList(tasksCounterName, statusName, terminationTopicName, tasksName, schedulerQueueName, tasksRetryIntervalName),
                 RedissonExecutorService.SHUTDOWN_STATE, RedissonExecutorService.TERMINATED_STATE, requestId);

File: redisson/src/main/java/org/redisson/RedissonBoundedBlockingQueue.java
Patch:
@@ -177,7 +177,7 @@ public RFuture<Boolean> removeAllAsync(Collection<?> c) {
     @Override
     public RFuture<V> pollAsync() {
         String channelName = RedissonSemaphore.getChannelName(getSemaphoreName());
-        return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_OBJECT,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_OBJECT,
                 "local res = redis.call('lpop', KEYS[1]);"
                 + "if res ~= false then " +
                     "local value = redis.call('incrby', KEYS[2], ARGV[1]); " +

File: redisson/src/main/java/org/redisson/RedissonDelayedQueue.java
Patch:
@@ -275,7 +275,7 @@ public RFuture<List<V>> readAllAsync() {
 
     @Override
     public RFuture<List<V>> pollAsync(int limit) {
-        return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_LIST,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_LIST,
                    "local result = {};"
                  + "for i = 1, ARGV[1], 1 do " +
                        "local v = redis.call('lpop', KEYS[1]);" +
@@ -463,7 +463,7 @@ public RFuture<V> peekAsync() {
 
     @Override
     public RFuture<V> pollAsync() {
-        return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_OBJECT,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_OBJECT,
                   "local v = redis.call('lpop', KEYS[1]); "
                 + "if v ~= false then "
                     + "redis.call('zrem', KEYS[2], v); "
@@ -481,7 +481,7 @@ public RFuture<Boolean> offerAsync(V e) {
 
     @Override
     public RFuture<V> pollLastAndOfferFirstToAsync(String queueName) {
-        return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_OBJECT,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_OBJECT,
                 "local v = redis.call('rpop', KEYS[1]); "
               + "if v ~= false then "
                   + "redis.call('zrem', KEYS[2], v); "

File: redisson/src/main/java/org/redisson/RedissonDeque.java
Patch:
@@ -256,7 +256,7 @@ public List<V> pollLast(int limit) {
 
     @Override
     public RFuture<List<V>> pollLastAsync(int limit) {
-        return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_LIST,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_LIST,
                    "local result = {};"
                  + "for i = 1, ARGV[1], 1 do " +
                        "local value = redis.call('rpop', KEYS[1]);" +

File: redisson/src/main/java/org/redisson/RedissonPriorityBlockingQueue.java
Patch:
@@ -221,7 +221,7 @@ public RFuture<Boolean> offerAsync(V e) {
     @Override
     public RFuture<List<V>> pollAsync(int limit) {
         return wrapLockedAsync(() -> {
-            return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_LIST,
+            return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_LIST,
                        "local result = {};"
                      + "for i = 1, ARGV[1], 1 do " +
                            "local value = redis.call('lpop', KEYS[1]);" +

File: redisson/src/main/java/org/redisson/RedissonPriorityDeque.java
Patch:
@@ -304,7 +304,7 @@ public List<V> pollLast(int limit) {
     @Override
     public RFuture<List<V>> pollLastAsync(int limit) {
         return wrapLockedAsync(() -> {
-            return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_LIST,
+            return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_LIST,
                       "local result = {};"
                           + "for i = 1, ARGV[1], 1 do " +
                                 "local value = redis.call('rpop', KEYS[1]);" +

File: redisson/src/main/java/org/redisson/RedissonPriorityQueue.java
Patch:
@@ -456,7 +456,7 @@ public RFuture<Boolean> addAsync(V e) {
     @Override
     public RFuture<List<V>> pollAsync(int limit) {
         return wrapLockedAsync(() -> {
-            return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_LIST,
+            return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_LIST,
                        "local result = {};"
                      + "for i = 1, ARGV[1], 1 do " +
                            "local value = redis.call('lpop', KEYS[1]);" +

File: redisson/src/main/java/org/redisson/RedissonQueue.java
Patch:
@@ -86,7 +86,7 @@ public List<V> poll(int limit) {
 
     @Override
     public RFuture<List<V>> pollAsync(int limit) {
-        return commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_LIST,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), codec, RedisCommands.EVAL_LIST,
                    "local result = {};"
                  + "for i = 1, ARGV[1], 1 do " +
                        "local value = redis.call('lpop', KEYS[1]);" +

File: redisson/src/main/java/org/redisson/RedissonRingBuffer.java
Patch:
@@ -79,7 +79,7 @@ public void setCapacity(int capacity) {
 
     @Override
     public RFuture<Boolean> addAsync(V e) {
-        return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWriteNoRetryAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 "local limit = redis.call('get', KEYS[2]); "
               + "assert(limit ~= false, 'RingBuffer capacity is not defined'); "
               + "local size = redis.call('rpush', KEYS[1], ARGV[1]); "

File: redisson/src/main/java/org/redisson/RedissonTransferQueue.java
Patch:
@@ -522,7 +522,7 @@ public V getValue(int index) {
             @Override
             public V remove(int index) {
                 if (index == 0) {
-                    RFuture<V> future = commandExecutor.evalWriteAsync(queueName, codec, EVAL_REQUEST,
+                    RFuture<V> future = commandExecutor.evalWriteNoRetryAsync(queueName, codec, EVAL_REQUEST,
                             "local id = redis.call('lpop', KEYS[1]); "
                                 + "if id ~= false then "
                                     + "return redis.call('hget', KEYS[2], id); "

File: redisson/src/main/java/org/redisson/RedissonRemoteService.java
Patch:
@@ -83,7 +83,7 @@ public String getRequestTasksMapName(Class<?> remoteInterface) {
     @Override
     protected RFuture<Boolean> addAsync(String requestQueueName, RemoteServiceRequest request,
             RemotePromise<Object> result) {
-        RFuture<Boolean> future = commandExecutor.evalWriteAsync(name, LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
+        RFuture<Boolean> future = commandExecutor.evalWriteNoRetryAsync(name, LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                   "redis.call('hset', KEYS[2], ARGV[1], ARGV[2]);"
                 + "redis.call('rpush', KEYS[1], ARGV[1]); "
                 + "return 1;",
@@ -96,7 +96,7 @@ protected RFuture<Boolean> addAsync(String requestQueueName, RemoteServiceReques
 
     @Override
     protected RFuture<Boolean> removeAsync(String requestQueueName, RequestId taskId) {
-        return commandExecutor.evalWriteAsync(name, LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWriteNoRetryAsync(name, LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 "if redis.call('lrem', KEYS[1], 1, ARGV[1]) > 0 then "
                         + "redis.call('hdel', KEYS[2], ARGV[1]);" +
                            "return 1;" +

File: redisson/src/main/java/org/redisson/command/BaseRedisBatchExecutor.java
Patch:
@@ -50,10 +50,11 @@ public BaseRedisBatchExecutor(boolean readOnlyMode, NodeSource source, Codec cod
                                   Object[] params, RPromise<R> mainPromise, boolean ignoreRedirect,
                                   ConnectionManager connectionManager, RedissonObjectBuilder objectBuilder,
                                   ConcurrentMap<MasterSlaveEntry, Entry> commands,
-                                  BatchOptions options, AtomicInteger index, AtomicBoolean executed, RedissonObjectBuilder.ReferenceType referenceType) {
+                                  BatchOptions options, AtomicInteger index, AtomicBoolean executed, RedissonObjectBuilder.ReferenceType referenceType,
+                                  boolean noRetry) {
         
         super(readOnlyMode, source, codec, command, params, mainPromise, ignoreRedirect, connectionManager,
-                objectBuilder, referenceType);
+                objectBuilder, referenceType, noRetry);
         this.commands = commands;
         this.options = options;
         this.index = index;

File: redisson/src/main/java/org/redisson/command/CommandAsyncExecutor.java
Patch:
@@ -83,6 +83,8 @@ public interface CommandAsyncExecutor {
     
     <T, R> RFuture<R> evalWriteAsync(String key, Codec codec, RedisCommand<T> evalCommandType, String script, List<Object> keys, Object... params);
 
+    <T, R> RFuture<R> evalWriteNoRetryAsync(String key, Codec codec, RedisCommand<T> evalCommandType, String script, List<Object> keys, Object... params);
+
     <T, R> RFuture<R> evalWriteAsync(MasterSlaveEntry entry, Codec codec, RedisCommand<T> evalCommandType, String script, List<Object> keys, Object... params);
     
     <T, R> RFuture<R> readAsync(byte[] key, Codec codec, RedisCommand<T> command, Object... params);

File: redisson/src/main/java/org/redisson/command/RedisBatchExecutor.java
Patch:
@@ -43,9 +43,9 @@ public RedisBatchExecutor(boolean readOnlyMode, NodeSource source, Codec codec,
                               Object[] params, RPromise<R> mainPromise, boolean ignoreRedirect, ConnectionManager connectionManager,
                               RedissonObjectBuilder objectBuilder, ConcurrentMap<MasterSlaveEntry, Entry> commands,
                               BatchOptions options, AtomicInteger index,
-                              AtomicBoolean executed, RedissonObjectBuilder.ReferenceType referenceType) {
+                              AtomicBoolean executed, RedissonObjectBuilder.ReferenceType referenceType, boolean noRetry) {
         super(readOnlyMode, source, codec, command, params, mainPromise, ignoreRedirect, connectionManager, objectBuilder,
-                commands, options, index, executed, referenceType);
+                commands, options, index, executed, referenceType, noRetry);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/command/RedisCommonBatchExecutor.java
Patch:
@@ -54,9 +54,10 @@ public class RedisCommonBatchExecutor extends RedisExecutor<Object, Void> {
     private final BatchOptions options;
     
     public RedisCommonBatchExecutor(NodeSource source, RPromise<Void> mainPromise,
-                                    ConnectionManager connectionManager, BatchOptions options, Entry entry, AtomicInteger slots, RedissonObjectBuilder.ReferenceType referenceType) {
+                                    ConnectionManager connectionManager, BatchOptions options, Entry entry,
+                                    AtomicInteger slots, RedissonObjectBuilder.ReferenceType referenceType, boolean noRetry) {
         super(entry.isReadOnlyMode(), source, null, null, null,
-                mainPromise, false, connectionManager, null, referenceType);
+                mainPromise, false, connectionManager, null, referenceType, noRetry);
         this.options = options;
         this.entry = entry;
         this.slots = slots;

File: redisson/src/main/java/org/redisson/command/RedisQueuedBatchExecutor.java
Patch:
@@ -57,9 +57,10 @@ public RedisQueuedBatchExecutor(boolean readOnlyMode, NodeSource source, Codec c
                                     Object[] params, RPromise<R> mainPromise, boolean ignoreRedirect, ConnectionManager connectionManager,
                                     RedissonObjectBuilder objectBuilder, ConcurrentMap<MasterSlaveEntry, Entry> commands,
                                     ConcurrentMap<MasterSlaveEntry, ConnectionEntry> connections, BatchOptions options, AtomicInteger index,
-                                    AtomicBoolean executed, AsyncCountDownLatch latch, RedissonObjectBuilder.ReferenceType referenceType) {
+                                    AtomicBoolean executed, AsyncCountDownLatch latch, RedissonObjectBuilder.ReferenceType referenceType,
+                                    boolean noRetry) {
         super(readOnlyMode, source, codec, command, params, mainPromise, ignoreRedirect, connectionManager, objectBuilder,
-                commands, options, index, executed, referenceType);
+                commands, options, index, executed, referenceType, noRetry);
         
         this.connections = connections;
         this.latch = latch;

File: redisson/src/main/java/org/redisson/executor/RedissonExecutorRemoteService.java
Patch:
@@ -65,7 +65,7 @@ public RedissonExecutorRemoteService(Codec codec, String name,
 
     @Override
     protected RFuture<RemoteServiceRequest> getTask(String requestId, RMap<String, RemoteServiceRequest> tasks) {
-        return commandExecutor.evalWriteAsync(((RedissonObject) tasks).getRawName(), codec, RedisCommands.EVAL_OBJECT,
+        return commandExecutor.evalWriteNoRetryAsync(((RedissonObject) tasks).getRawName(), codec, RedisCommands.EVAL_OBJECT,
                   "local value = redis.call('zscore', KEYS[2], ARGV[1]); " +
                   "if (value ~= false and tonumber(value) < tonumber(ARGV[2])) then "
                     + "redis.call('zrem', KEYS[2], ARGV[1]); "

File: redisson/src/main/java/org/redisson/reactive/CommandReactiveBatchService.java
Patch:
@@ -70,8 +70,8 @@ protected <R> RPromise<R> createPromise() {
     
     @Override
     public <V, R> void async(boolean readOnlyMode, NodeSource nodeSource,
-            Codec codec, RedisCommand<V> command, Object[] params, RPromise<R> mainPromise, boolean ignoreRedirect) {
-        batchService.async(readOnlyMode, nodeSource, codec, command, params, mainPromise, ignoreRedirect);
+            Codec codec, RedisCommand<V> command, Object[] params, RPromise<R> mainPromise, boolean ignoreRedirect, boolean noRetry) {
+        batchService.async(readOnlyMode, nodeSource, codec, command, params, mainPromise, ignoreRedirect, noRetry);
     }
 
     public RFuture<BatchResult<?>> executeAsync() {

File: redisson/src/main/java/org/redisson/rx/CommandRxBatchService.java
Patch:
@@ -71,8 +71,8 @@ protected <R> RPromise<R> createPromise() {
     
     @Override
     public <V, R> void async(boolean readOnlyMode, NodeSource nodeSource,
-            Codec codec, RedisCommand<V> command, Object[] params, RPromise<R> mainPromise, boolean ignoreRedirect) {
-        batchService.async(readOnlyMode, nodeSource, codec, command, params, mainPromise, ignoreRedirect);
+            Codec codec, RedisCommand<V> command, Object[] params, RPromise<R> mainPromise, boolean ignoreRedirect, boolean noRetry) {
+        batchService.async(readOnlyMode, nodeSource, codec, command, params, mainPromise, ignoreRedirect, noRetry);
     }
 
     public RFuture<BatchResult<?>> executeAsync() {

File: redisson/src/main/java/org/redisson/RedissonPriorityQueue.java
Patch:
@@ -161,16 +161,16 @@ public boolean add(V value) {
                 index = res.getIndex() + 1;
             }
                 
-            commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_VOID,
+            get(commandExecutor.evalWriteAsync(getRawName(), codec, RedisCommands.EVAL_VOID,
                "local len = redis.call('llen', KEYS[1]);"
                 + "if tonumber(ARGV[1]) < len then "
                     + "local pivot = redis.call('lindex', KEYS[1], ARGV[1]);"
                     + "redis.call('linsert', KEYS[1], 'before', pivot, ARGV[2]);"
                     + "return;"
                 + "end;"
                 + "redis.call('rpush', KEYS[1], ARGV[2]);", 
-                    Arrays.<Object>asList(getRawName()),
-                    index, encode(value));
+                    Arrays.asList(getRawName()),
+                    index, encode(value)));
             return true;
         } finally {
             lock.unlock();

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -504,7 +504,7 @@ public interface RedisCommands {
     RedisStrictCommand<Map<String, String>> INFO_KEYSPACE = new RedisStrictCommand<Map<String, String>>("INFO", "KEYSPACE", new StringMapDataDecoder());
 
     Set<String> NO_RETRY = new HashSet<>(
-            Arrays.asList(LPOP.getName(), RPOP.getName(), LPUSH.getName(), RPUSH.getName(),
+            Arrays.asList(RPOPLPUSH.getName(), LPOP.getName(), RPOP.getName(), LPUSH.getName(), RPUSH.getName(),
                     LPUSHX.getName(), RPUSHX.getName(), GEOADD.getName(), XADD.getName(), APPEND.getName(),
                     DECR.getName(), "DECRBY", INCR.getName(), INCRBY.getName(), ZINCRBY.getName(),
                     "HINCRBYFLOAT", "HINCRBY", "INCRBYFLOAT"));

File: redisson/src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -434,7 +434,7 @@ public void run() {
         
         System.out.println("errors " + errors + " success " + success + " readonly " + readonlyErrors);
         
-        assertThat(errors).isLessThan(820);
+        assertThat(errors).isLessThan(1300);
         assertThat(readonlyErrors).isZero();
         
         redisson.shutdown();

File: redisson/src/main/java/org/redisson/connection/ClientConnectionsEntry.java
Patch:
@@ -32,7 +32,6 @@
 import java.util.Queue;
 import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
 
 /**

File: redisson/src/main/java/org/redisson/connection/pool/ConnectionPool.java
Patch:
@@ -120,7 +120,7 @@ public void run() {
                 promise.onComplete((conn, e) -> {
                         if (e == null) {
                             if (!initPromise.isDone()) {
-                                releaseConnection(entry, conn);
+                                entry.addConnection(conn);
                             } else {
                                 conn.closeAsync();
                             }

File: redisson/src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -434,7 +434,7 @@ public void run() {
         
         System.out.println("errors " + errors + " success " + success + " readonly " + readonlyErrors);
         
-        assertThat(errors).isLessThan(800);
+        assertThat(errors).isLessThan(820);
         assertThat(readonlyErrors).isZero();
         
         redisson.shutdown();

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -712,6 +712,7 @@ protected RFuture<RedisURI> resolveIP(String scheme, RedisURI address) {
 
             InetSocketAddress s = f.getNow();
             RedisURI uri = new RedisURI(scheme + "://" + s.getAddress().getHostAddress() + ":" + address.getPort());
+            uri = applyNatMap(uri);
             result.trySuccess(uri);
         });
         return result;

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -112,6 +112,7 @@ public <V> V get(RFuture<V> future) {
         try {
             future.await();
         } catch (InterruptedException e) {
+            future.cancel(true);
             Thread.currentThread().interrupt();
             throw new RedisException(e);
         }

File: redisson/src/main/java/org/redisson/RedissonBuckets.java
Patch:
@@ -150,7 +150,7 @@ public Object[] createParams(List<String> keys) {
                 }
                 return params.toArray();
             }
-        }, buckets.keySet().toArray(new String[]{}));
+        }, buckets.keySet().toArray(new String[]{}), buckets);
     }
 
 }

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -516,7 +516,6 @@ protected void releaseConnection(RPromise<R> attemptPromise, RFuture<RedisConnec
         }
 
         RedisConnection connection = connectionFuture.getNow();
-        connection.setQueued(false);
         connectionManager.getShutdownLatch().release();
         if (readOnlyMode) {
             connectionManager.releaseRead(source, connection);

File: redisson/src/main/java/org/redisson/command/RedisQueuedBatchExecutor.java
Patch:
@@ -132,8 +132,6 @@ protected void handleError(RFuture<RedisConnection> connectionFuture, Throwable
     
     @Override
     protected void sendCommand(RPromise<R> attemptPromise, RedisConnection connection) {
-        connection.setQueued(true);
-
         MasterSlaveEntry msEntry = getEntry(source);
         ConnectionEntry connectionEntry = connections.get(msEntry);
 

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -112,6 +112,7 @@ public <V> V get(RFuture<V> future) {
         try {
             future.await();
         } catch (InterruptedException e) {
+            future.cancel(true);
             Thread.currentThread().interrupt();
             throw new RedisException(e);
         }

File: redisson/src/main/java/org/redisson/RedissonBuckets.java
Patch:
@@ -150,7 +150,7 @@ public Object[] createParams(List<String> keys) {
                 }
                 return params.toArray();
             }
-        }, buckets.keySet().toArray(new String[]{}));
+        }, buckets.keySet().toArray(new String[]{}), buckets);
     }
 
 }

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -2309,7 +2309,7 @@ public int addListener(MapEntryListener listener) {
             RFuture<Map<String, String>> serverFuture = commandExecutor.readAsync((String) null, StringCodec.INSTANCE, RedisCommands.INFO_SERVER);
             serverFuture.syncUninterruptibly();
             String os = serverFuture.getNow().get("os");
-            if (os.contains("Windows")) {
+            if (os == null || os.contains("Windows")) {
                 osType = BaseEventCodec.OSType.WINDOWS;
             } else if (os.contains("NONSTOP")) {
                 osType = BaseEventCodec.OSType.HPNONSTOP;

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -651,10 +651,10 @@ private <T, R> RFuture<R> executeBatchedAsync(boolean readOnly, Codec codec, Red
                     c = newCommand;
                 }
                 if (readOnly) {
-                    RFuture<T> f = executorService.readAsync(entry.getKey(), codec, c, groupedKeys.toArray());
+                    RFuture<T> f = executorService.readAsync(entry.getKey(), codec, c, callback.createParams(groupedKeys));
                     f.onComplete(listener);
                 } else {
-                    RFuture<T> f = executorService.writeAsync(entry.getKey(), codec, c, groupedKeys.toArray());
+                    RFuture<T> f = executorService.writeAsync(entry.getKey(), codec, c, callback.createParams(groupedKeys));
                     f.onComplete(listener);
                 }
             }

File: redisson/src/test/java/org/redisson/RedissonBucketsTest.java
Patch:
@@ -45,12 +45,12 @@ public void testGetInCluster() throws FailedToStartRedisException, IOException,
         Map<String, Integer> map = new HashMap<>();
         for (int i = 0; i < 10; i++) {
             map.put("test" + i, i);
-            redisson.getBucket("test" + i).set(i);
         }
         for (int i = 10; i < size; i++) {
             map.put("test" + i + "{" + (i%100)+ "}", i);
-            redisson.getBucket("test" + i + "{" + (i%100)+ "}").set(i);
         }
+
+        redisson.getBuckets().set(map);
         
         Set<String> queryKeys = new HashSet<>(map.keySet());
         queryKeys.add("test_invalid");

File: redisson/src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -83,7 +83,7 @@ public void testPerformance() throws InterruptedException {
         }
 
         ex.shutdown();
-        assertThat(ex.awaitTermination(5, TimeUnit.SECONDS)).isTrue();
+        assertThat(ex.awaitTermination(7, TimeUnit.SECONDS)).isTrue();
         inst.shutdown();
     }
 

File: redisson/src/test/java/org/redisson/rx/RedissonBlockingDequeRxTest.java
Patch:
@@ -53,7 +53,7 @@ public void testPollLastAndOfferFirstTo() throws InterruptedException {
         RBlockingDequeRx<String> blockingDeque = redisson.getBlockingDeque("blocking_deque");
         long start = System.currentTimeMillis();
         String redisTask = sync(blockingDeque.pollLastAndOfferFirstTo("deque", 1, TimeUnit.SECONDS));
-        assertThat(System.currentTimeMillis() - start).isBetween(950L, 1150L);
+        assertThat(System.currentTimeMillis() - start).isBetween(950L, 1200L);
         assertThat(redisTask).isNull();
     }
     

File: redisson/src/main/java/org/redisson/api/stream/TrimStrategy.java
Patch:
@@ -20,6 +20,7 @@
  * @author Nikita Koksharov
  *
  */
+@Deprecated
 public enum TrimStrategy {
 
     MAXLEN,

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -504,7 +504,7 @@ private RedisURI toURI(String host, String port) {
                 InetAddress ia = InetAddress.getByAddress(host, addr);
                 host = ia.getHostAddress();
             } catch (UnknownHostException e) {
-                e.printStackTrace();
+                throw new RuntimeException(e);
             }
         }
         RedisURI uri = new RedisURI(scheme + "://" + host + ":" + port);

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -767,7 +767,9 @@ public RedisURI applyNatMap(RedisURI address) {
     private Collection<ClusterPartition> parsePartitions(List<ClusterNodeInfo> nodes) {
         Map<String, ClusterPartition> partitions = new HashMap<>();
         for (ClusterNodeInfo clusterNodeInfo : nodes) {
-            if (clusterNodeInfo.containsFlag(Flag.NOADDR) || clusterNodeInfo.containsFlag(Flag.HANDSHAKE)) {
+            if (clusterNodeInfo.containsFlag(Flag.NOADDR)
+                    || clusterNodeInfo.containsFlag(Flag.HANDSHAKE)
+                        || clusterNodeInfo.getAddress() == null) {
                 // skip it
                 continue;
             }

File: redisson/src/main/java/org/redisson/RedissonSemaphore.java
Patch:
@@ -497,8 +497,9 @@ public RFuture<Void> addPermitsAsync(int permits) {
                 "if (value == false) then "
                   + "value = 0;"
               + "end;"
-              + "redis.call('set', KEYS[1], value + ARGV[1]); ",
-                Arrays.<Object>asList(getRawName(), getChannelName()), permits);
+              + "redis.call('set', KEYS[1], value + ARGV[1]); "
+              + "redis.call('publish', KEYS[2], value + ARGV[1]); ",
+                Arrays.asList(getRawName(), getChannelName()), permits);
     }
 
 

File: redisson/src/main/java/org/redisson/RedissonRateLimiter.java
Patch:
@@ -211,8 +211,8 @@ private <T> RFuture<T> tryAcquireAsync(RedisCommand<T> command, Long value) {
                      + "end;"
 
                      + "if tonumber(currentValue) < tonumber(ARGV[1]) then "
-                         + "local nearest = redis.call('zrangebyscore', permitsName, '(' .. (tonumber(ARGV[2]) - interval), '+inf', 'withscores', 'limit', 0, 1); "
-                         + "return tonumber(nearest[2]) - (tonumber(ARGV[2]) - interval);"
+                         + "local firstValue = redis.call('zrange', permitsName, 0, 0, 'withscores'); "
+                         + "return 3 + interval - (tonumber(ARGV[2]) - tonumber(firstValue[2]));"
                      + "else "
                          + "redis.call('zadd', permitsName, ARGV[2], struct.pack('fI', ARGV[3], ARGV[1])); "
                          + "redis.call('decrby', valueName, ARGV[1]); "

File: redisson/src/main/java/org/redisson/Redisson.java
Patch:
@@ -654,12 +654,14 @@ public RLiveObjectService getLiveObjectService() {
 
     @Override
     public void shutdown() {
+        writeBehindService.stop();
         connectionManager.shutdown();
     }
 
 
     @Override
     public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {
+        writeBehindService.stop();
         connectionManager.shutdown(quietPeriod, timeout, unit);
     }
 

File: redisson/src/main/java/org/redisson/RedissonReactive.java
Patch:
@@ -514,6 +514,7 @@ public NodesGroup<ClusterNode> getClusterNodesGroup() {
 
     @Override
     public void shutdown() {
+        writeBehindService.stop();
         connectionManager.shutdown();
     }
 

File: redisson/src/main/java/org/redisson/RedissonRx.java
Patch:
@@ -523,6 +523,7 @@ public NodesGroup<ClusterNode> getClusterNodesGroup() {
 
     @Override
     public void shutdown() {
+        writeBehindService.stop();
         connectionManager.shutdown();
     }
 

File: redisson/src/main/java/org/redisson/liveobject/core/AccessorInterceptor.java
Patch:
@@ -210,7 +210,9 @@ private void removeIndex(RMap<String, Object> liveMap, Object me, Field field) {
             }
         }
 
-        ce.execute();
+        if (ce != commandExecutor) {
+            ce.execute();
+        }
     }
 
     private void removeAsync(CommandBatchService ce, String name, String mapName, Codec codec, Object value, String fieldName) {

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -566,8 +566,8 @@ private RFuture<Void> checkMasterNodesChange(ClusterServersConfig cfg, Collectio
                     continue;
                 }
                 masterFound = true;
-                // current master marked as failed
-                if (!newPart.isMasterFail() || newPart.getSlotsAmount() == 0) {
+                // skip the new master if it is marked as failed or has no slots
+                if (newPart.isMasterFail() || newPart.getSlotsAmount() == 0) {
                     continue;
                 }
                 for (Integer slot : currentPart.getSlots()) {
@@ -593,7 +593,7 @@ private RFuture<Void> checkMasterNodesChange(ClusterServersConfig cfg, Collectio
                 break;
             }
 
-            if (!masterFound && newPart.getSlotsAmount() > 0) {
+            if (!masterFound && !newPart.isMasterFail() && newPart.getSlotsAmount() > 0) {
                 addedPartitions.put(newPart.getMasterAddress(), newPart);
             }
         }

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -566,8 +566,8 @@ private RFuture<Void> checkMasterNodesChange(ClusterServersConfig cfg, Collectio
                     continue;
                 }
                 masterFound = true;
-                // current master marked as failed
-                if (!newPart.isMasterFail() || newPart.getSlotsAmount() == 0) {
+                // skip the new master if it is marked as failed or has no slots
+                if (newPart.isMasterFail() || newPart.getSlotsAmount() == 0) {
                     continue;
                 }
                 for (Integer slot : currentPart.getSlots()) {
@@ -593,7 +593,7 @@ private RFuture<Void> checkMasterNodesChange(ClusterServersConfig cfg, Collectio
                 break;
             }
 
-            if (!masterFound && newPart.getSlotsAmount() > 0) {
+            if (!masterFound && !newPart.isMasterFail() && newPart.getSlotsAmount() > 0) {
                 addedPartitions.put(newPart.getMasterAddress(), newPart);
             }
         }

File: redisson/src/main/java/org/redisson/connection/ReplicatedConnectionManager.java
Patch:
@@ -20,7 +20,6 @@
 import org.redisson.client.RedisClient;
 import org.redisson.client.RedisConnection;
 import org.redisson.client.RedisConnectionException;
-import org.redisson.client.RedisException;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.config.*;
 import org.redisson.connection.ClientConnectionsEntry.FreezeReason;

File: redisson/src/test/java/org/redisson/RedissonBatchTest.java
Patch:
@@ -185,7 +185,7 @@ public void testConnectionLeak(BatchOptions batchOptions) throws Exception {
 
 	public RFuture<BatchResult<?>> executeBatch(RedissonClient client, BatchOptions batchOptions) {
 		RBatch batch = client.createBatch(batchOptions);
-		for (int i = 0; i < 10; i++) {
+		for (int i = 0; i < 50; i++) {
 			String key = "" + i;
 			batch.getBucket(key).getAsync();
 		}
@@ -254,7 +254,7 @@ public void testConnectionLeakAfterError() throws InterruptedException {
         
         BatchOptions batchOptions = BatchOptions.defaults().executionMode(ExecutionMode.REDIS_WRITE_ATOMIC);
         RBatch batch1 = redisson.createBatch(batchOptions);
-        for (int i = 0; i < 25000; i++) {
+        for (int i = 0; i < 150000; i++) {
             batch1.getBucket("test").setAsync(123);
         }
 

File: redisson/src/main/java/org/redisson/RedissonBaseLock.java
Patch:
@@ -157,6 +157,8 @@ public void run(Timeout timeout) throws Exception {
                     if (res) {
                         // reschedule itself
                         renewExpiration();
+                    } else {
+                        cancelExpirationRenewal(null);
                     }
                 });
             }

File: redisson/src/main/java/org/redisson/RedissonBaseLock.java
Patch:
@@ -158,7 +158,7 @@ public void run(Timeout timeout) throws Exception {
                         // reschedule itself
                         renewExpiration();
                     } else {
-                    	cancelExpirationRenewal(null);
+                        cancelExpirationRenewal(null);
                     }
                 });
             }

File: redisson/src/main/java/org/redisson/RedissonTopic.java
Patch:
@@ -72,7 +72,7 @@ public RedissonTopic(Codec codec, CommandAsyncExecutor commandExecutor, String n
     public RedissonTopic(Codec codec, CommandAsyncExecutor commandExecutor, NameMapper nameMapper, String name) {
         this.commandExecutor = commandExecutor;
         this.name = nameMapper.map(name);
-        this.channelName = new ChannelName(name);
+        this.channelName = new ChannelName(this.name);
         this.codec = codec;
         this.subscribeService = commandExecutor.getConnectionManager().getSubscribeService();
     }

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -233,7 +233,9 @@ public void run(Timeout t) throws Exception {
 
                 if (attempt == attempts) {
                     // filled out in connectionFuture or writeFuture handler
-                    attemptPromise.tryFailure(exception);
+                    if (exception != null) {
+                        attemptPromise.tryFailure(exception);
+                    }
                     return;
                 }
                 if (!attemptPromise.cancel(false)) {

File: redisson/src/main/java/org/redisson/transaction/BaseTransactionalMap.java
Patch:
@@ -184,8 +184,8 @@ protected ScanResult<Map.Entry<Object, Object>> scanIterator(String name, RedisC
         Map<HashValue, MapEntry> newstate = new HashMap<HashValue, MapEntry>(state);
         Map<Object, Object> newres = null;
         for (Iterator<Map.Entry<Object, Object>> iterator = res.getValues().iterator(); iterator.hasNext();) {
-            Object key = iterator.next();
-            MapEntry mapEntry = newstate.remove(toKeyHash(key));
+            Map.Entry<Object, Object> entry = iterator.next();
+            MapEntry mapEntry = newstate.remove(toKeyHash(entry.getKey()));
             if (mapEntry != null) {
                 if (mapEntry == MapEntry.NULL) {
                     iterator.remove();
@@ -199,7 +199,7 @@ protected ScanResult<Map.Entry<Object, Object>> scanIterator(String name, RedisC
                     }
                 }
 
-                newres.put(key, mapEntry.getValue());
+                newres.put(entry.getKey(), mapEntry.getValue());
             }
         }
         

File: redisson/src/main/java/org/redisson/transaction/BaseTransactionalMap.java
Patch:
@@ -119,7 +119,7 @@ public RFuture<Boolean> isExistsAsync() {
     }
     
     public RFuture<Boolean> unlinkAsync(CommandAsyncExecutor commandExecutor) {
-        return deleteAsync(commandExecutor, new UnlinkOperation(map.getName(), null));
+        return deleteAsync(commandExecutor, new UnlinkOperation(map.getName()));
     }
     
     public RFuture<Boolean> touchAsync(CommandAsyncExecutor commandExecutor) {

File: redisson/src/main/java/org/redisson/transaction/RedissonTransactionalBuckets.java
Patch:
@@ -112,9 +112,10 @@ public RFuture<Void> setAsync(Map<String, ?> buckets) {
         checkState();
         
         RPromise<Void> result = new RedissonPromise<>();
+        long currentThreadId = Thread.currentThread().getId();
         executeLocked(result, () -> {
             for (Entry<String, ?> entry : buckets.entrySet()) {
-                operations.add(new BucketSetOperation<>(entry.getKey(), getLockName(entry.getKey()), codec, entry.getValue(), transactionId));
+                operations.add(new BucketSetOperation<>(entry.getKey(), getLockName(entry.getKey()), codec, entry.getValue(), transactionId, currentThreadId));
                 if (entry.getValue() == null) {
                     state.put(entry.getKey(), NULL);
                 } else {

File: redisson/src/main/java/org/redisson/transaction/operation/bucket/BucketGetAndSetOperation.java
Patch:
@@ -46,7 +46,7 @@ public BucketGetAndSetOperation(String name, String lockName, Codec codec, Objec
     }
     
     public BucketGetAndSetOperation(String name, String lockName, Codec codec, Object value, String transactionId) {
-        super(name, codec);
+        super(name, codec, Thread.currentThread().getId());
         this.value = value;
         this.lockName = lockName;
         this.transactionId = transactionId;
@@ -61,13 +61,13 @@ public void commit(CommandAsyncExecutor commandExecutor) {
             bucket.getAndSetAsync((V) value);
         }
         RedissonLock lock = new RedissonTransactionalLock(commandExecutor, lockName, transactionId);
-        lock.unlockAsync();
+        lock.unlockAsync(getThreadId());
     }
 
     @Override
     public void rollback(CommandAsyncExecutor commandExecutor) {
         RedissonLock lock = new RedissonTransactionalLock(commandExecutor, lockName, transactionId);
-        lock.unlockAsync();
+        lock.unlockAsync(getThreadId());
     }
     
     public Object getValue() {

File: redisson/src/main/java/org/redisson/RedissonBloomFilter.java
Patch:
@@ -43,7 +43,6 @@
 import org.redisson.misc.Hash;
 
 import java.math.BigDecimal;
-import java.time.Instant;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;

File: redisson/src/main/java/org/redisson/RedissonBloomFilter.java
Patch:
@@ -43,6 +43,7 @@
 import org.redisson.misc.Hash;
 
 import java.math.BigDecimal;
+import java.time.Instant;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
@@ -289,8 +290,8 @@ public RFuture<Boolean> expireAsync(long timeToLive, TimeUnit timeUnit) {
     }
 
     @Override
-    public RFuture<Boolean> expireAtAsync(long timestamp) {
-        return expireAtAsync(timestamp, getRawName(), configName);
+    protected RFuture<Boolean> expireAtAsync(long timestamp, String... keys) {
+        return super.expireAtAsync(timestamp, getRawName(), configName);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonBoundedBlockingQueue.java
Patch:
@@ -368,8 +368,8 @@ public RFuture<Boolean> expireAsync(long timeToLive, TimeUnit timeUnit) {
     }
 
     @Override
-    public RFuture<Boolean> expireAtAsync(long timestamp) {
-        return expireAtAsync(timestamp, getRawName(), getSemaphoreName());
+    protected RFuture<Boolean> expireAtAsync(long timestamp, String... keys) {
+        return super.expireAtAsync(timestamp, getRawName(), getSemaphoreName());
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonDelayedQueue.java
Patch:
@@ -440,8 +440,8 @@ public RFuture<Boolean> expireAsync(long timeToLive, TimeUnit timeUnit) {
     }
 
     @Override
-    public RFuture<Boolean> expireAtAsync(long timestamp) {
-        return expireAtAsync(timestamp, queueName, timeoutSetName);
+    protected RFuture<Boolean> expireAtAsync(long timestamp, String... keys) {
+        return super.expireAtAsync(timestamp, queueName, timeoutSetName);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonExpirable.java
Patch:
@@ -70,7 +70,7 @@ public boolean expire(Instant instant) {
 
     @Override
     public RFuture<Boolean> expireAsync(Instant instant) {
-        return commandExecutor.writeAsync(getRawName(), StringCodec.INSTANCE, RedisCommands.PEXPIREAT, getRawName(), instant.toEpochMilli());
+        return expireAtAsync(instant.toEpochMilli(), getRawName());
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonFairLock.java
Patch:
@@ -297,8 +297,8 @@ public RFuture<Boolean> expireAsync(long timeToLive, TimeUnit timeUnit) {
     }
 
     @Override
-    public RFuture<Boolean> expireAtAsync(long timestamp) {
-        return expireAtAsync(timestamp, getRawName(), threadsQueueName, timeoutSetName);
+    protected RFuture<Boolean> expireAtAsync(long timestamp, String... keys) {
+        return super.expireAtAsync(timestamp, getRawName(), threadsQueueName, timeoutSetName);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonIdGenerator.java
Patch:
@@ -160,8 +160,8 @@ public RFuture<Boolean> expireAsync(long timeToLive, TimeUnit timeUnit) {
     }
 
     @Override
-    public RFuture<Boolean> expireAtAsync(long timestamp) {
-        return expireAtAsync(timestamp, getRawName(), getAllocationSizeName());
+    protected RFuture<Boolean> expireAtAsync(long timestamp, String... keys) {
+        return super.expireAtAsync(timestamp, getRawName(), getAllocationSizeName());
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -2416,7 +2416,7 @@ public RFuture<Boolean> expireAsync(long timeToLive, TimeUnit timeUnit) {
     }
 
     @Override
-    public RFuture<Boolean> expireAtAsync(long timestamp) {
+    protected RFuture<Boolean> expireAtAsync(long timestamp, String... keys) {
         return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                         "local maxSize = tonumber(redis.call('hget', KEYS[5], 'max-size')); " +
                         "if maxSize ~= nil and maxSize ~= 0 then " +

File: redisson/src/main/java/org/redisson/RedissonMultimap.java
Patch:
@@ -344,7 +344,7 @@ public RFuture<Boolean> expireAsync(long timeToLive, TimeUnit timeUnit) {
     }
 
     @Override
-    public RFuture<Boolean> expireAtAsync(long timestamp) {
+    protected RFuture<Boolean> expireAtAsync(long timestamp, String... keys) {
         return commandExecutor.evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 "local entries = redis.call('hgetall', KEYS[1]); " +
                 "for i, v in ipairs(entries) do " +

File: redisson/src/main/java/org/redisson/RedissonPermitExpirableSemaphore.java
Patch:
@@ -606,8 +606,8 @@ public RFuture<Boolean> expireAsync(long timeToLive, TimeUnit timeUnit) {
     }
 
     @Override
-    public RFuture<Boolean> expireAtAsync(long timestamp) {
-        return expireAtAsync(timestamp, getRawName(), timeoutName);
+    protected RFuture<Boolean> expireAtAsync(long timestamp, String... keys) {
+        return super.expireAtAsync(timestamp, getRawName(), timeoutName);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonPriorityQueue.java
Patch:
@@ -429,8 +429,8 @@ public RFuture<Boolean> expireAsync(long timeToLive, TimeUnit timeUnit) {
     }
 
     @Override
-    public RFuture<Boolean> expireAtAsync(long timestamp) {
-        return expireAtAsync(timestamp, getRawName(), getComparatorKeyName());
+    protected RFuture<Boolean> expireAtAsync(long timestamp, String... keys) {
+        return super.expireAtAsync(timestamp, getRawName(), getComparatorKeyName());
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonRateLimiter.java
Patch:
@@ -336,8 +336,8 @@ public RFuture<Boolean> expireAsync(long timeToLive, TimeUnit timeUnit) {
     }
 
     @Override
-    public RFuture<Boolean> expireAtAsync(long timestamp) {
-        return expireAtAsync(timestamp, getRawName(), getValueName(), getClientValueName(), getPermitsName(), getClientPermitsName());
+    protected RFuture<Boolean> expireAtAsync(long timestamp, String... keys) {
+        return super.expireAtAsync(timestamp, getRawName(), getValueName(), getClientValueName(), getPermitsName(), getClientPermitsName());
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonReliableTopic.java
Patch:
@@ -282,8 +282,8 @@ public RFuture<Boolean> expireAsync(long timeToLive, TimeUnit timeUnit) {
     }
 
     @Override
-    public RFuture<Boolean> expireAtAsync(long timestamp) {
-        return expireAtAsync(timestamp, getRawName(), getSubscribersName(), getMapName(), getCounter(), getTimeout());
+    protected RFuture<Boolean> expireAtAsync(long timestamp, String... keys) {
+        return super.expireAtAsync(timestamp, getRawName(), getSubscribersName(), getMapName(), getCounter(), getTimeout());
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonTimeSeries.java
Patch:
@@ -563,8 +563,8 @@ public RFuture<Boolean> expireAsync(long timeToLive, TimeUnit timeUnit) {
     }
 
     @Override
-    public RFuture<Boolean> expireAtAsync(long timestamp) {
-        return expireAtAsync(timestamp, getRawName(), getTimeoutSetName());
+    protected RFuture<Boolean> expireAtAsync(long timestamp, String... keys) {
+        return super.expireAtAsync(timestamp, getRawName(), getTimeoutSetName());
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonReactiveHashCommands.java
Patch:
@@ -26,6 +26,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.ScanResult;
 import org.redisson.api.RFuture;
 import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
@@ -228,7 +229,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Entry<ByteBuffer, ByteBuffer>>>> hS
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Entry<Object, Object>> flux = Flux.create(new MapReactiveIterator<Object, Object, Entry<Object, Object>>(null, null, 0) {
                 @Override
-                public RFuture<MapScanResult<Object, Object>> scanIterator(RedisClient client, long nextIterPos) {
+                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.HSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.ScanResult;
 import org.redisson.api.RFuture;
 import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
@@ -267,7 +268,7 @@ public Flux<CommandResponse<KeyCommand, Flux<ByteBuffer>>> sScan(Publisher<KeySc
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<byte[]> flux = Flux.create(new SetReactiveIterator<byte[]>() {
                 @Override
-                protected RFuture<ListScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.SSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonReactiveZSetCommands.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.ScanResult;
 import org.redisson.api.RFuture;
 import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
@@ -266,7 +267,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Tuple>>> zScan(Publisher<KeyScanCom
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Tuple> flux = Flux.create(new SetReactiveIterator<Tuple>() {
                 @Override
-                protected RFuture<ListScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, ZSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonReactiveHashCommands.java
Patch:
@@ -26,6 +26,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.ScanResult;
 import org.redisson.api.RFuture;
 import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
@@ -228,7 +229,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Entry<ByteBuffer, ByteBuffer>>>> hS
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Entry<Object, Object>> flux = Flux.create(new MapReactiveIterator<Object, Object, Entry<Object, Object>>(null, null, 0) {
                 @Override
-                public RFuture<MapScanResult<Object, Object>> scanIterator(RedisClient client, long nextIterPos) {
+                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.HSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.ScanResult;
 import org.redisson.api.RFuture;
 import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
@@ -267,7 +268,7 @@ public Flux<CommandResponse<KeyCommand, Flux<ByteBuffer>>> sScan(Publisher<KeySc
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<byte[]> flux = Flux.create(new SetReactiveIterator<byte[]>() {
                 @Override
-                protected RFuture<ListScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.SSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonReactiveZSetCommands.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.ScanResult;
 import org.redisson.api.RFuture;
 import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
@@ -266,7 +267,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Tuple>>> zScan(Publisher<KeyScanCom
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Tuple> flux = Flux.create(new SetReactiveIterator<Tuple>() {
                 @Override
-                protected RFuture<ListScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, ZSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonReactiveHashCommands.java
Patch:
@@ -26,6 +26,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.ScanResult;
 import org.redisson.api.RFuture;
 import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
@@ -228,7 +229,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Entry<ByteBuffer, ByteBuffer>>>> hS
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Entry<Object, Object>> flux = Flux.create(new MapReactiveIterator<Object, Object, Entry<Object, Object>>(null, null, 0) {
                 @Override
-                public RFuture<MapScanResult<Object, Object>> scanIterator(RedisClient client, long nextIterPos) {
+                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.HSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.ScanResult;
 import org.redisson.api.RFuture;
 import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
@@ -267,7 +268,7 @@ public Flux<CommandResponse<KeyCommand, Flux<ByteBuffer>>> sScan(Publisher<KeySc
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<byte[]> flux = Flux.create(new SetReactiveIterator<byte[]>() {
                 @Override
-                protected RFuture<ListScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.SSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonReactiveZSetCommands.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.ScanResult;
 import org.redisson.api.RFuture;
 import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
@@ -266,7 +267,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Tuple>>> zScan(Publisher<KeyScanCom
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Tuple> flux = Flux.create(new SetReactiveIterator<Tuple>() {
                 @Override
-                protected RFuture<ListScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, ZSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonReactiveHashCommands.java
Patch:
@@ -26,6 +26,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.ScanResult;
 import org.redisson.api.RFuture;
 import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
@@ -228,7 +229,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Entry<ByteBuffer, ByteBuffer>>>> hS
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Entry<Object, Object>> flux = Flux.create(new MapReactiveIterator<Object, Object, Entry<Object, Object>>(null, null, 0) {
                 @Override
-                public RFuture<MapScanResult<Object, Object>> scanIterator(RedisClient client, long nextIterPos) {
+                public RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.HSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSetCommands.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.ScanResult;
 import org.redisson.api.RFuture;
 import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
@@ -267,7 +268,7 @@ public Flux<CommandResponse<KeyCommand, Flux<ByteBuffer>>> sScan(Publisher<KeySc
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<byte[]> flux = Flux.create(new SetReactiveIterator<byte[]>() {
                 @Override
-                protected RFuture<ListScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, RedisCommands.SSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonReactiveZSetCommands.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.stream.Collectors;
 
 import org.reactivestreams.Publisher;
+import org.redisson.ScanResult;
 import org.redisson.api.RFuture;
 import org.redisson.client.RedisClient;
 import org.redisson.client.codec.ByteArrayCodec;
@@ -268,7 +269,7 @@ public Flux<CommandResponse<KeyCommand, Flux<Tuple>>> zScan(Publisher<KeyScanCom
             byte[] keyBuf = toByteArray(command.getKey());
             Flux<Tuple> flux = Flux.create(new SetReactiveIterator<Tuple>() {
                 @Override
-                protected RFuture<ListScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+                protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                     if (command.getOptions().getPattern() == null) {
                         return executorService.readAsync(client, keyBuf, ByteArrayCodec.INSTANCE, ZSCAN, 
                                 keyBuf, nextIterPos, "COUNT", Optional.ofNullable(command.getOptions().getCount()).orElse(10L));

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -1516,7 +1516,7 @@ protected RFuture<Long> fastRemoveOperationAsync(K... keys) {
     }
 
     @Override
-    public MapScanResult<Object, Object> scanIterator(String name, RedisClient client, long startPos, String pattern, int count) {
+    public ScanResult<Map.Entry<Object, Object>> scanIterator(String name, RedisClient client, long startPos, String pattern, int count) {
         return get(scanIteratorAsync(name, client, startPos, pattern, count));
     }
 
@@ -1526,7 +1526,7 @@ public MapScanResult<Object, Object> scanIterator(String name, RedisClient clien
                         new ObjectMapDecoder(true)));
 
     @Override
-    public RFuture<MapScanResult<Object, Object>> scanIteratorAsync(String name, RedisClient client, long startPos, String pattern, int count) {
+    public RFuture<ScanResult<Map.Entry<Object, Object>>> scanIteratorAsync(String name, RedisClient client, long startPos, String pattern, int count) {
         List<Object> params = new ArrayList<Object>();
         params.add(System.currentTimeMillis());
         params.add(startPos);
@@ -1609,7 +1609,7 @@ public RFuture<MapScanResult<Object, Object>> scanIteratorAsync(String name, Red
             }
         });
 
-        return (RFuture<MapScanResult<Object, Object>>) (Object) f;
+        return (RFuture<ScanResult<Map.Entry<Object, Object>>>) (Object) f;
     }
 
     @Override

File: redisson/src/main/java/org/redisson/ScanIterator.java
Patch:
@@ -17,7 +17,6 @@
 
 import org.redisson.api.RFuture;
 import org.redisson.client.RedisClient;
-import org.redisson.client.protocol.decoder.ListScanResult;
 
 /**
  * 
@@ -26,9 +25,9 @@
  */
 public interface ScanIterator {
 
-    ListScanResult<Object> scanIterator(String name, RedisClient client, long startPos, String pattern, int count);
+    ScanResult<Object> scanIterator(String name, RedisClient client, long startPos, String pattern, int count);
 
-    RFuture<ListScanResult<Object>> scanIteratorAsync(String name, RedisClient client, long startPos, String pattern, int count);
+    RFuture<ScanResult<Object>> scanIteratorAsync(String name, RedisClient client, long startPos, String pattern, int count);
     
     boolean remove(Object value);
     

File: redisson/src/main/java/org/redisson/reactive/RedissonLexSortedSetReactive.java
Patch:
@@ -17,11 +17,10 @@
 
 import org.reactivestreams.Publisher;
 import org.redisson.RedissonScoredSortedSet;
+import org.redisson.ScanResult;
 import org.redisson.api.RFuture;
 import org.redisson.api.RLexSortedSet;
 import org.redisson.client.RedisClient;
-import org.redisson.client.protocol.decoder.ListScanResult;
-
 import reactor.core.publisher.Flux;
 
 
@@ -50,7 +49,7 @@ public RFuture<Boolean> add(Object e) {
     private Publisher<String> scanIteratorReactive(final String pattern, final int count) {
         return Flux.create(new SetReactiveIterator<String>() {
             @Override
-            protected RFuture<ListScanResult<Object>> scanIterator(final RedisClient client, final long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(final RedisClient client, final long nextIterPos) {
                 return ((RedissonScoredSortedSet<String>) instance).scanIteratorAsync(client, nextIterPos, pattern, count);
             }
         });

File: redisson/src/main/java/org/redisson/reactive/RedissonSetCacheReactive.java
Patch:
@@ -18,9 +18,9 @@
 import org.reactivestreams.Publisher;
 import org.redisson.RedissonObject;
 import org.redisson.ScanIterator;
+import org.redisson.ScanResult;
 import org.redisson.api.*;
 import org.redisson.client.RedisClient;
-import org.redisson.client.protocol.decoder.ListScanResult;
 import reactor.core.publisher.Flux;
 
 /**
@@ -42,7 +42,7 @@ public RedissonSetCacheReactive(RSetCache<V> instance, RedissonReactiveClient re
     public Publisher<V> iterator() {
         return Flux.create(new SetReactiveIterator<V>() {
             @Override
-            protected RFuture<ListScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                 return ((ScanIterator) instance).scanIteratorAsync(((RedissonObject) instance).getRawName(), client, nextIterPos, null, 10);
             }
         });

File: redisson/src/main/java/org/redisson/reactive/RedissonSetReactive.java
Patch:
@@ -18,9 +18,9 @@
 import org.reactivestreams.Publisher;
 import org.redisson.RedissonObject;
 import org.redisson.ScanIterator;
+import org.redisson.ScanResult;
 import org.redisson.api.*;
 import org.redisson.client.RedisClient;
-import org.redisson.client.protocol.decoder.ListScanResult;
 import reactor.core.publisher.Flux;
 
 /**
@@ -60,7 +60,7 @@ public Publisher<V> iterator(String pattern) {
     public Publisher<V> iterator(String pattern, int count) {
         return Flux.create(new SetReactiveIterator<V>() {
             @Override
-            protected RFuture<ListScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                 return ((ScanIterator) instance).scanIteratorAsync(((RedissonObject) instance).getRawName(), client, nextIterPos, pattern, count);
             }
         });

File: redisson/src/main/java/org/redisson/reactive/RedissonTimeSeriesReactive.java
Patch:
@@ -18,11 +18,11 @@
 import org.reactivestreams.Publisher;
 import org.redisson.RedissonObject;
 import org.redisson.RedissonTimeSeries;
+import org.redisson.ScanResult;
 import org.redisson.api.RFuture;
 import org.redisson.api.RTimeSeries;
 import org.redisson.api.RedissonReactiveClient;
 import org.redisson.client.RedisClient;
-import org.redisson.client.protocol.decoder.ListScanResult;
 import reactor.core.publisher.Flux;
 
 /**
@@ -44,7 +44,7 @@ public RedissonTimeSeriesReactive(RTimeSeries<V> instance, RedissonReactiveClien
     public Publisher<V> iterator() {
         return Flux.create(new SetReactiveIterator<V>() {
             @Override
-            protected RFuture<ListScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                 return ((RedissonTimeSeries) instance).scanIteratorAsync(((RedissonObject) instance).getRawName(), client, nextIterPos, 10);
             }
         });

File: redisson/src/main/java/org/redisson/rx/RedissonMapRxIterator.java
Patch:
@@ -83,7 +83,7 @@ protected void nextValues() {
                     client = res.getRedisClient();
                     nextIterPos = res.getPos();
                     
-                    for (Entry<Object, Object> entry : res.getMap().entrySet()) {
+                    for (Entry<Object, Object> entry : res.getValues()) {
                         M val = getValue(entry);
                         p.onNext(val);
                         elementsRead.incrementAndGet();

File: redisson/src/main/java/org/redisson/rx/RedissonSetCacheRx.java
Patch:
@@ -19,9 +19,9 @@
 import org.reactivestreams.Publisher;
 import org.redisson.RedissonObject;
 import org.redisson.ScanIterator;
+import org.redisson.ScanResult;
 import org.redisson.api.*;
 import org.redisson.client.RedisClient;
-import org.redisson.client.protocol.decoder.ListScanResult;
 
 /**
  *
@@ -42,7 +42,7 @@ public RedissonSetCacheRx(RSetCache<V> instance, RedissonRxClient redisson) {
     public Publisher<V> iterator() {
         return new SetRxIterator<V>() {
             @Override
-            protected RFuture<ListScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                 return ((ScanIterator) instance).scanIteratorAsync(((RedissonObject) instance).getRawName(), client, nextIterPos, null, 10);
             }
         }.create();

File: redisson/src/main/java/org/redisson/rx/RedissonSetRx.java
Patch:
@@ -20,9 +20,9 @@
 import org.reactivestreams.Publisher;
 import org.redisson.RedissonObject;
 import org.redisson.ScanIterator;
+import org.redisson.ScanResult;
 import org.redisson.api.*;
 import org.redisson.client.RedisClient;
-import org.redisson.client.protocol.decoder.ListScanResult;
 
 /**
  * Distributed and concurrent implementation of {@link java.util.Set}
@@ -61,7 +61,7 @@ public Flowable<V> iterator(String pattern) {
     public Flowable<V> iterator(String pattern, int count) {
         return new SetRxIterator<V>() {
             @Override
-            protected RFuture<ListScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                 return ((ScanIterator) instance).scanIteratorAsync(((RedissonObject) instance).getRawName(), client, nextIterPos, pattern, count);
             }
         }.create();

File: redisson/src/main/java/org/redisson/rx/RedissonTimeSeriesRx.java
Patch:
@@ -18,11 +18,11 @@
 import org.reactivestreams.Publisher;
 import org.redisson.RedissonObject;
 import org.redisson.RedissonTimeSeries;
+import org.redisson.ScanResult;
 import org.redisson.api.RFuture;
 import org.redisson.api.RTimeSeries;
 import org.redisson.api.RedissonRxClient;
 import org.redisson.client.RedisClient;
-import org.redisson.client.protocol.decoder.ListScanResult;
 
 /**
  *
@@ -43,7 +43,7 @@ public RedissonTimeSeriesRx(RTimeSeries<V> instance, RedissonRxClient redisson)
     public Publisher<V> iterator() {
         return new SetRxIterator<V>() {
             @Override
-            protected RFuture<ListScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
+            protected RFuture<ScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
                 return ((RedissonTimeSeries) instance).scanIteratorAsync(((RedissonObject) instance).getRawName(), client, nextIterPos, 10);
             }
         }.create();

File: redisson/src/main/java/org/redisson/transaction/TransactionalSet.java
Patch:
@@ -17,12 +17,12 @@
 
 import org.redisson.RedissonSet;
 import org.redisson.ScanIterator;
+import org.redisson.ScanResult;
 import org.redisson.api.RCollectionAsync;
 import org.redisson.api.RFuture;
 import org.redisson.api.RLock;
 import org.redisson.api.RSet;
 import org.redisson.client.RedisClient;
-import org.redisson.client.protocol.decoder.ListScanResult;
 import org.redisson.command.CommandAsyncExecutor;
 import org.redisson.transaction.operation.TransactionalOperation;
 import org.redisson.transaction.operation.set.AddOperation;
@@ -51,8 +51,8 @@ public TransactionalSet(CommandAsyncExecutor commandExecutor, long timeout, List
     }
 
     @Override
-    protected ListScanResult<Object> scanIteratorSource(String name, RedisClient client, long startPos,
-            String pattern, int count) {
+    protected ScanResult<Object> scanIteratorSource(String name, RedisClient client, long startPos,
+                                                    String pattern, int count) {
         return ((ScanIterator) set).scanIterator(name, client, startPos, pattern, count);
     }
 

File: redisson/src/main/java/org/redisson/transaction/TransactionalSetCache.java
Patch:
@@ -17,12 +17,12 @@
 
 import org.redisson.RedissonSetCache;
 import org.redisson.ScanIterator;
+import org.redisson.ScanResult;
 import org.redisson.api.RCollectionAsync;
 import org.redisson.api.RFuture;
 import org.redisson.api.RLock;
 import org.redisson.api.RSetCache;
 import org.redisson.client.RedisClient;
-import org.redisson.client.protocol.decoder.ListScanResult;
 import org.redisson.command.CommandAsyncExecutor;
 import org.redisson.transaction.operation.TransactionalOperation;
 import org.redisson.transaction.operation.set.AddCacheOperation;
@@ -52,8 +52,8 @@ public TransactionalSetCache(CommandAsyncExecutor commandExecutor, long timeout,
     }
 
     @Override
-    protected ListScanResult<Object> scanIteratorSource(String name, RedisClient client, long startPos,
-            String pattern, int count) {
+    protected ScanResult<Object> scanIteratorSource(String name, RedisClient client, long startPos,
+                                                    String pattern, int count) {
         return ((ScanIterator) set).scanIterator(name, client, startPos, pattern, count);
     }
 

File: redisson/src/main/java/org/redisson/client/handler/PingConnectionHandler.java
Patch:
@@ -63,7 +63,7 @@ private void sendPing(ChannelHandlerContext ctx) {
         RedisConnection connection = RedisConnection.getFrom(ctx.channel());
         CommandData<?, ?> commandData = connection.getCurrentCommand();
         RFuture<String> future;
-        if (commandData == null || !commandData.isBlockingCommand()) {
+        if ((commandData == null || !commandData.isBlockingCommand()) && !connection.isQueued()) {
             future = connection.async(StringCodec.INSTANCE, RedisCommands.PING);
         } else {
             future = null;

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -510,6 +510,7 @@ protected void releaseConnection(RPromise<R> attemptPromise, RFuture<RedisConnec
         }
 
         RedisConnection connection = connectionFuture.getNow();
+        connection.setQueued(false);
         connectionManager.getShutdownLatch().release();
         if (readOnlyMode) {
             connectionManager.releaseRead(source, connection);

File: redisson/src/main/java/org/redisson/command/RedisQueuedBatchExecutor.java
Patch:
@@ -131,6 +131,8 @@ protected void handleError(RFuture<RedisConnection> connectionFuture, Throwable
     
     @Override
     protected void sendCommand(RPromise<R> attemptPromise, RedisConnection connection) {
+        connection.setQueued(true);
+
         MasterSlaveEntry msEntry = getEntry(source);
         ConnectionEntry connectionEntry = connections.get(msEntry);
 

File: redisson/src/main/java/org/redisson/command/RedisQueuedBatchExecutor.java
Patch:
@@ -101,7 +101,6 @@ protected void handleSuccess(RPromise<R> promise, RFuture<RedisConnection> conne
         try {
             BatchPromise<R> batchPromise = (BatchPromise<R>) promise;
             RPromise<R> sentPromise = (RPromise<R>) batchPromise.getSentPromise();
-            System.out.println("res " + res);
             super.handleSuccess(sentPromise, connectionFuture, null);
         } finally {
             latch.countDown();

File: redisson/src/main/java/org/redisson/redisnode/SentinelRedisNode.java
Patch:
@@ -250,12 +250,12 @@ public RFuture<List<Map<String, String>>> getSlavesAsync(String masterName) {
 
     @Override
     public RFuture<Map<String, String>> getMasterAsync(String masterName) {
-        return executeAsync(null, null, -1, RedisCommands.SENTINEL_MASTER, masterName);
+        return executeAsync(null, StringCodec.INSTANCE, -1, RedisCommands.SENTINEL_MASTER, masterName);
     }
 
     @Override
     public RFuture<Void> failoverAsync(String masterName) {
-        return executeAsync(null, null, -1, RedisCommands.SENTINEL_FAILOVER, masterName);
+        return executeAsync(null, StringCodec.INSTANCE, -1, RedisCommands.SENTINEL_FAILOVER, masterName);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/mapreduce/MapReduceExecutor.java
Patch:
@@ -92,7 +92,7 @@ public RFuture<Map<KOut, VOut>> executeAsync() {
         RFuture<Void> future = executeMapperAsync(resultMapName, null);
         if (timeout > 0) {
             commandExecutor.getConnectionManager().newTimeout(task -> {
-                promise.cancel(true);
+                promise.tryFailure(new MapReduceTimeoutException());
             }, timeout, TimeUnit.MILLISECONDS);
         }
 

File: redisson/src/main/java/org/redisson/api/RBucket.java
Patch:
@@ -139,7 +139,6 @@ public interface RBucket<V> extends RExpirable, RBucketAsync<V> {
      * Requires <b>Redis 6.0.0 and higher.</b>
      *
      * @param value - value to set
-     * @return void
      */
     void setAndKeepTTL(V value);
 

File: redisson/src/main/java/org/redisson/api/RMapCache.java
Patch:
@@ -56,7 +56,6 @@ public interface RMapCache<K, V> extends RMap<K, V>, RMapCacheAsync<K, V>, RDest
      *
      * @param maxSize - max size
      * @param mode - eviction mode
-     * @return void
      */
     void setMaxSize(int maxSize, EvictionMode mode);
 

File: redisson/src/test/java/org/redisson/RedissonSemaphoreTest.java
Patch:
@@ -179,6 +179,8 @@ public void testReleaseWithoutPermits() {
     @Test
     public void testDrainPermits() throws InterruptedException {
         RSemaphore s = redisson.getSemaphore("test");
+        assertThat(s.drainPermits()).isZero();
+
         s.trySetPermits(10);
         s.acquire(3);
 

File: redisson/src/main/java/org/redisson/pubsub/SemaphorePubSub.java
Patch:
@@ -41,7 +41,7 @@ protected void onMessage(RedissonLockEntry value, Long message) {
             runnableToExecute.run();
         }
 
-        value.getLatch().release(Math.min(value.getLatch().getQueueLength(), message.intValue()));
+        value.getLatch().release(Math.min(value.acquired(), message.intValue()));
     }
 
 }

File: redisson/src/main/java/org/redisson/RedissonSemaphore.java
Patch:
@@ -86,7 +86,7 @@ public void acquire(int permits) throws InterruptedException {
                     return;
                 }
 
-                future.getNow().getLatch().acquire(permits);
+                future.getNow().getLatch().acquire();
             }
         } finally {
             unsubscribe(future);
@@ -230,7 +230,7 @@ private void acquireAsync(int permits, RFuture<RedissonLockEntry> subscribeFutur
             }
             
             RedissonLockEntry entry = subscribeFuture.getNow();
-            if (entry.getLatch().tryAcquire(permits)) {
+            if (entry.getLatch().tryAcquire()) {
                 acquireAsync(permits, subscribeFuture, result);
             } else {
                 entry.addListener(() -> {
@@ -319,7 +319,7 @@ public boolean tryAcquire(int permits, long waitTime, TimeUnit unit) throws Inte
                 // waiting for message
                 current = System.currentTimeMillis();
 
-                future.getNow().getLatch().tryAcquire(permits, time, TimeUnit.MILLISECONDS);
+                future.getNow().getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);
 
                 time -= System.currentTimeMillis() - current;
                 if (time <= 0) {

File: redisson/src/main/java/org/redisson/pubsub/SemaphorePubSub.java
Patch:
@@ -40,8 +40,8 @@ protected void onMessage(RedissonLockEntry value, Long message) {
         if (runnableToExecute != null) {
             runnableToExecute.run();
         }
-        
-        value.getLatch().release(message.intValue());
+
+        value.getLatch().release(Math.min(value.getLatch().getQueueLength(), message.intValue()));
     }
 
 }

File: redisson/src/main/java/org/redisson/client/RedisClient.java
Patch:
@@ -180,7 +180,7 @@ public RFuture<InetSocketAddress> resolveAddr() {
         byte[] addr = NetUtil.createByteArrayFromIpAddressString(uri.getHost());
         if (addr != null) {
             try {
-                resolvedAddr = new InetSocketAddress(InetAddress.getByAddress(addr), uri.getPort());
+                resolvedAddr = new InetSocketAddress(InetAddress.getByAddress(uri.getHost(), addr), uri.getPort());
             } catch (UnknownHostException e) {
                 // skip
             }

File: redisson/src/main/java/org/redisson/client/RedisClient.java
Patch:
@@ -180,7 +180,7 @@ public RFuture<InetSocketAddress> resolveAddr() {
         byte[] addr = NetUtil.createByteArrayFromIpAddressString(uri.getHost());
         if (addr != null) {
             try {
-                resolvedAddr = new InetSocketAddress(InetAddress.getByAddress(addr), uri.getPort());
+                resolvedAddr = new InetSocketAddress(InetAddress.getByAddress(uri.getHost(), addr), uri.getPort());
             } catch (UnknownHostException e) {
                 // skip
             }

File: redisson/src/main/java/org/redisson/jcache/JCachingProvider.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.redisson.jcache;
 
-import com.fasterxml.jackson.core.JacksonException;
+import com.fasterxml.jackson.core.JsonProcessingException;
 import org.redisson.Redisson;
 import org.redisson.config.Config;
 
@@ -103,7 +103,7 @@ private Config loadConfig(URI uri) {
             } else {
                 throw new FileNotFoundException("/redisson-jcache.yaml");
             }
-        } catch (JacksonException e) {
+        } catch (JsonProcessingException e) {
             throw new CacheException(e);
         } catch (IOException e) {
             try {

File: redisson/src/test/java/org/redisson/RedissonStreamTest.java
Patch:
@@ -178,7 +178,7 @@ public void testRemoveMessages() {
     }
 
     @Test
-    public void testClaimRemove() {
+    public void testClaimRemove() throws InterruptedException {
         RStream<String, String> stream = redisson.getStream("test");
 
         stream.add(StreamAddArgs.entry("0", "0"));
@@ -199,6 +199,8 @@ public void testClaimRemove() {
 
         stream.remove(id3);
 
+        Thread.sleep(2);
+
         Map<StreamMessageId, Map<String, String>> res = stream.claim("testGroup", "consumer1", 1, TimeUnit.MILLISECONDS, id3, id4);
         assertThat(res.size()).isEqualTo(1);
         assertThat(res.keySet()).containsExactly(id4);

File: redisson/src/main/java/org/redisson/connection/balancer/LoadBalancerManager.java
Patch:
@@ -294,7 +294,7 @@ public RFuture<Void> shutdownAsync() {
         RPromise<Void> result = new RedissonPromise<Void>();
         CountableListener<Void> listener = new CountableListener<Void>(result, null, client2Entry.values().size());
         for (ClientConnectionsEntry entry : client2Entry.values()) {
-            entry.getClient().shutdownAsync().onComplete(listener);
+            entry.shutdownAsync().onComplete(listener);
         }
         return result;
     }

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -109,7 +109,7 @@ public String xGroupCreate(byte[] key, String groupName, ReadOffset readOffset)
         return connection.write(key, StringCodec.INSTANCE, XGROUP_STRING, "CREATE", key, groupName, readOffset.getOffset(), "MKSTREAM");
     }
 
-    private static final RedisStrictCommand<Boolean> XGROUP_BOOLEAN = new RedisStrictCommand<Boolean>("XADD", obj -> ((Long)obj) > 0);
+    private static final RedisStrictCommand<Boolean> XGROUP_BOOLEAN = new RedisStrictCommand<Boolean>("XGROUP", obj -> ((Long)obj) > 0);
 
     @Override
     public Boolean xGroupDelConsumer(byte[] key, Consumer consumer) {

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -395,7 +395,7 @@ public String xGroupCreate(byte[] key, String groupName, ReadOffset readOffset)
         return xGroupCreate(key, groupName, readOffset, false);
     }
 
-    private static final RedisStrictCommand<Boolean> XGROUP_BOOLEAN = new RedisStrictCommand<Boolean>("XADD", obj -> ((Long)obj) > 0);
+    private static final RedisStrictCommand<Boolean> XGROUP_BOOLEAN = new RedisStrictCommand<Boolean>("XGROUP", obj -> ((Long)obj) > 0);
 
     @Override
     public Boolean xGroupDelConsumer(byte[] key, Consumer consumer) {

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -394,7 +394,7 @@ public String xGroupCreate(byte[] key, String groupName, ReadOffset readOffset)
         return xGroupCreate(key, groupName, readOffset, false);
     }
 
-    private static final RedisStrictCommand<Boolean> XGROUP_BOOLEAN = new RedisStrictCommand<Boolean>("XADD", obj -> ((Long)obj) > 0);
+    private static final RedisStrictCommand<Boolean> XGROUP_BOOLEAN = new RedisStrictCommand<Boolean>("XGROUP", obj -> ((Long)obj) > 0);
 
     @Override
     public Boolean xGroupDelConsumer(byte[] key, Consumer consumer) {

File: redisson/src/main/java/org/redisson/jcache/JCacheEventCodec.java
Patch:
@@ -55,6 +55,7 @@ public Object decode(ByteBuf buf, State state) throws IOException {
                     buf.readShortLE();
                     result.add(null);
                 }
+                copy.release();
             }
             
             if (sync) {

File: redisson/src/main/java/org/redisson/jcache/JCacheEventCodec.java
Patch:
@@ -55,6 +55,7 @@ public Object decode(ByteBuf buf, State state) throws IOException {
                     buf.readShortLE();
                     result.add(null);
                 }
+                copy.release();
             }
             
             if (sync) {

File: redisson/src/main/java/org/redisson/jcache/JCache.java
Patch:
@@ -2324,9 +2324,9 @@ private long replaceValueLocked(K key, V oldValue, V newValue) {
                            + "return redis.call('publish', KEYS[6], syncMsg); "
                        + "else "
                            + "redis.call('hset', KEYS[1], ARGV[4], ARGV[6]); "
-                           + "local msg = struct.pack('Lc0Lc0', string.len(ARGV[4]), ARGV[4], string.len(ARGV[6]), ARGV[6]); "
+                           + "local msg = struct.pack('Lc0Lc0h', string.len(ARGV[4]), ARGV[4], string.len(ARGV[6]), ARGV[6], -1); "
                            + "redis.call('publish', KEYS[4], msg); "
-                           + "local syncMsg = struct.pack('Lc0Lc0d', string.len(ARGV[4]), ARGV[4], string.len(ARGV[6]), ARGV[6], ARGV[7]); "
+                           + "local syncMsg = struct.pack('Lc0Lc0hd', string.len(ARGV[4]), ARGV[4], string.len(ARGV[6]), ARGV[6], -1, ARGV[7]); "
                            + "return redis.call('publish', KEYS[6], syncMsg); "
                        + "end; ",
                        Arrays.<Object>asList(getRawName(), getTimeoutSetName(), getRemovedChannelName(), getUpdatedChannelName(),

File: redisson/src/main/java/org/redisson/RedissonRateLimiter.java
Patch:
@@ -205,7 +205,7 @@ private <T> RFuture<T> tryAcquireAsync(RedisCommand<T> command, Long value) {
                      + "end; "
 
                      + "if released > 0 then "
-                          + "redis.call('zrem', permitsName, unpack(expiredValues)); "
+                          + "redis.call('zremrangebyscore', permitsName, 0, tonumber(ARGV[2]) - interval); "
                           + "currentValue = tonumber(currentValue) + released; "
                           + "redis.call('set', valueName, currentValue);"
                      + "end;"
@@ -320,7 +320,7 @@ public RFuture<Long> availablePermitsAsync() {
                      + "end; "
 
                      + "if released > 0 then "
-                          + "redis.call('zrem', permitsName, unpack(expiredValues)); "
+                          + "redis.call('zremrangebyscore', permitsName, 0, tonumber(ARGV[1]) - interval); "
                           + "currentValue = tonumber(currentValue) + released; "
                           + "redis.call('set', valueName, currentValue);"
                      + "end;"

File: redisson/src/main/java/org/redisson/RedissonRateLimiter.java
Patch:
@@ -211,7 +211,7 @@ private <T> RFuture<T> tryAcquireAsync(RedisCommand<T> command, Long value) {
                      + "end;"
 
                      + "if tonumber(currentValue) < tonumber(ARGV[1]) then "
-                         + "local nearest = redis.call('zrangebyscore', permitsName, '(' .. (tonumber(ARGV[2]) - interval), tonumber(ARGV[2]), 'withscores', 'limit', 0, 1); "
+                         + "local nearest = redis.call('zrangebyscore', permitsName, '(' .. (tonumber(ARGV[2]) - interval), '+inf', 'withscores', 'limit', 0, 1); "
                          + "local random, permits = struct.unpack('fI', nearest[1]);"
                          + "return tonumber(nearest[2]) - (tonumber(ARGV[2]) - interval);"
                      + "else "

File: redisson/src/main/java/org/redisson/connection/ConnectionListener.java
Patch:
@@ -18,6 +18,7 @@
 import java.net.InetSocketAddress;
 
 /**
+ * Redis connection listener
  *
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/connection/pool/ConnectionPool.java
Patch:
@@ -35,7 +35,8 @@
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
-import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BiConsumer;
@@ -51,7 +52,7 @@ abstract class ConnectionPool<T extends RedisConnection> {
 
     private final Logger log = LoggerFactory.getLogger(getClass());
 
-    protected final List<ClientConnectionsEntry> entries = new CopyOnWriteArrayList<ClientConnectionsEntry>();
+    protected final Queue<ClientConnectionsEntry> entries = new ConcurrentLinkedQueue<>();
 
     final ConnectionManager connectionManager;
 

File: redisson/src/main/java/org/redisson/connection/pool/MasterConnectionPool.java
Patch:
@@ -38,7 +38,7 @@ public MasterConnectionPool(MasterSlaveServersConfig config,
 
     @Override
     public RFuture<RedisConnection> get(RedisCommand<?> command) {
-        return acquireConnection(command, entries.get(0));
+        return acquireConnection(command, entries.peek());
     }
     
     public void remove(ClientConnectionsEntry entry) {

File: redisson/src/main/java/org/redisson/connection/pool/MasterPubSubConnectionPool.java
Patch:
@@ -38,7 +38,7 @@ public MasterPubSubConnectionPool(MasterSlaveServersConfig config, ConnectionMan
 
     @Override
     public RFuture<RedisPubSubConnection> get(RedisCommand<?> command) {
-        return acquireConnection(command, entries.get(0));
+        return acquireConnection(command, entries.peek());
     }
 
     public void remove(ClientConnectionsEntry entry) {

File: redisson/src/main/java/org/redisson/executor/TasksRunnerService.java
Patch:
@@ -130,7 +130,7 @@ public void scheduleAtFixedRate(ScheduledAtFixedRateParameters params) {
         params.setStartTime(newStartTime);
         RFuture<Void> future = asyncScheduledServiceAtFixed(params.getExecutorId(), params.getRequestId()).scheduleAtFixedRate(params);
         try {
-            executeRunnable(params);
+            executeRunnable(params, false);
         } catch (Exception e) {
             // cancel task if it throws an exception
             future.cancel(true);

File: redisson/src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -145,7 +145,7 @@ private Long tryAcquire(long waitTime, long leaseTime, TimeUnit unit, long threa
     
     private RFuture<Boolean> tryAcquireOnceAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId) {
         RFuture<Boolean> ttlRemainingFuture;
-        if (-1 != leaseTime) {
+        if (leaseTime != -1) {
             ttlRemainingFuture = tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_NULL_BOOLEAN);
         } else {
             ttlRemainingFuture = tryLockInnerAsync(waitTime, internalLockLeaseTime,
@@ -159,7 +159,7 @@ private RFuture<Boolean> tryAcquireOnceAsync(long waitTime, long leaseTime, Time
 
             // lock acquired
             if (ttlRemaining) {
-                if (-1 != leaseTime) {
+                if (leaseTime != -1) {
                     internalLockLeaseTime = unit.toMillis(leaseTime);
                 } else {
                     scheduleExpirationRenewal(threadId);
@@ -184,7 +184,7 @@ private <T> RFuture<Long> tryAcquireAsync(long waitTime, long leaseTime, TimeUni
 
             // lock acquired
             if (ttlRemaining == null) {
-                if (-1 != leaseTime) {
+                if (leaseTime != -1) {
                     internalLockLeaseTime = unit.toMillis(leaseTime);
                 } else {
                     scheduleExpirationRenewal(threadId);

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -20,6 +20,7 @@
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.FutureListener;
 import io.netty.util.concurrent.ScheduledFuture;
+import io.netty.util.internal.StringUtil;
 import org.redisson.api.NatMapper;
 import org.redisson.api.NodeType;
 import org.redisson.api.RFuture;
@@ -34,7 +35,6 @@
 import org.redisson.misc.RedissonPromise;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import org.springframework.util.StringUtils;
 
 import java.net.InetSocketAddress;
 import java.util.*;
@@ -599,7 +599,7 @@ private void slaveDown(RedisURI uri) {
 
     private boolean isSlaveDown(String flags, String masterLinkStatus) {
         boolean baseStatus = flags.contains("s_down") || flags.contains("disconnected");
-        if (this.checkSlaveStatusWithSyncing && StringUtils.hasText(masterLinkStatus)) {
+        if (this.checkSlaveStatusWithSyncing && !StringUtil.isNullOrEmpty(masterLinkStatus)) {
             return baseStatus || masterLinkStatus.contains("err");
         }
         return baseStatus;

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -130,7 +130,7 @@ public boolean isPipelinedAtomic() {
     public void openPipeline() {
         BatchOptions options = BatchOptions.defaults()
                 .executionMode(ExecutionMode.IN_MEMORY);
-        this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+        this.executorService = new CommandBatchService(executorService, options);
     }
 
     @Override
@@ -1426,13 +1426,13 @@ public void multi() {
         if (isPipelined()) {
             BatchOptions options = BatchOptions.defaults()
                     .executionMode(ExecutionMode.IN_MEMORY_ATOMIC);
-            this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+            this.executorService = new CommandBatchService(executorService, options);
             return;
         }
         
         BatchOptions options = BatchOptions.defaults()
             .executionMode(ExecutionMode.REDIS_WRITE_ATOMIC);
-        this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+        this.executorService = new CommandBatchService(executorService, options);
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -160,7 +160,7 @@ public boolean isPipelinedAtomic() {
     public void openPipeline() {
         BatchOptions options = BatchOptions.defaults()
                 .executionMode(ExecutionMode.IN_MEMORY);
-        this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+        this.executorService = new CommandBatchService(executorService, options);
     }
 
     @Override
@@ -1483,13 +1483,13 @@ public void multi() {
         if (isPipelined()) {
             BatchOptions options = BatchOptions.defaults()
                     .executionMode(ExecutionMode.IN_MEMORY_ATOMIC);
-            this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+            this.executorService = new CommandBatchService(executorService, options);
             return;
         }
         
         BatchOptions options = BatchOptions.defaults()
             .executionMode(ExecutionMode.REDIS_WRITE_ATOMIC);
-        this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+        this.executorService = new CommandBatchService(executorService, options);
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -163,7 +163,7 @@ public boolean isPipelinedAtomic() {
     public void openPipeline() {
         BatchOptions options = BatchOptions.defaults()
                 .executionMode(ExecutionMode.IN_MEMORY);
-        this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+        this.executorService = new CommandBatchService(executorService, options);
     }
 
     @Override
@@ -1496,13 +1496,13 @@ public void multi() {
         if (isPipelined()) {
             BatchOptions options = BatchOptions.defaults()
                     .executionMode(ExecutionMode.IN_MEMORY_ATOMIC);
-            this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+            this.executorService = new CommandBatchService(executorService, options);
             return;
         }
         
         BatchOptions options = BatchOptions.defaults()
             .executionMode(ExecutionMode.REDIS_WRITE_ATOMIC);
-        this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+        this.executorService = new CommandBatchService(executorService, options);
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -135,7 +135,7 @@ public boolean isPipelinedAtomic() {
     public void openPipeline() {
         BatchOptions options = BatchOptions.defaults()
                 .executionMode(ExecutionMode.IN_MEMORY);
-        this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+        this.executorService = new CommandBatchService(executorService, options);
     }
 
     @Override
@@ -1484,13 +1484,13 @@ public void multi() {
         if (isPipelined()) {
             BatchOptions options = BatchOptions.defaults()
                     .executionMode(ExecutionMode.IN_MEMORY_ATOMIC);
-            this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+            this.executorService = new CommandBatchService(executorService, options);
             return;
         }
         
         BatchOptions options = BatchOptions.defaults()
             .executionMode(ExecutionMode.REDIS_WRITE_ATOMIC);
-        this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+        this.executorService = new CommandBatchService(executorService, options);
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -161,7 +161,7 @@ public boolean isPipelinedAtomic() {
     public void openPipeline() {
         BatchOptions options = BatchOptions.defaults()
                 .executionMode(ExecutionMode.IN_MEMORY);
-        this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+        this.executorService = new CommandBatchService(executorService, options);
     }
 
     @Override
@@ -1515,13 +1515,13 @@ public void multi() {
         if (isPipelined()) {
             BatchOptions options = BatchOptions.defaults()
                     .executionMode(ExecutionMode.IN_MEMORY_ATOMIC);
-            this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+            this.executorService = new CommandBatchService(executorService, options);
             return;
         }
         
         BatchOptions options = BatchOptions.defaults()
             .executionMode(ExecutionMode.REDIS_WRITE_ATOMIC);
-        this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+        this.executorService = new CommandBatchService(executorService, options);
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -153,7 +153,7 @@ public boolean isPipelinedAtomic() {
     public void openPipeline() {
         BatchOptions options = BatchOptions.defaults()
                 .executionMode(ExecutionMode.IN_MEMORY);
-        this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+        this.executorService = new CommandBatchService(executorService, options);
     }
 
     @Override
@@ -1507,13 +1507,13 @@ public void multi() {
         if (isPipelined()) {
             BatchOptions options = BatchOptions.defaults()
                     .executionMode(ExecutionMode.IN_MEMORY_ATOMIC);
-            this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+            this.executorService = new CommandBatchService(executorService, options);
             return;
         }
         
         BatchOptions options = BatchOptions.defaults()
             .executionMode(ExecutionMode.REDIS_WRITE_ATOMIC);
-        this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+        this.executorService = new CommandBatchService(executorService, options);
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -130,7 +130,7 @@ public boolean isPipelinedAtomic() {
     public void openPipeline() {
         BatchOptions options = BatchOptions.defaults()
                 .executionMode(ExecutionMode.IN_MEMORY);
-        this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+        this.executorService = new CommandBatchService(executorService, options);
     }
 
     @Override
@@ -1484,13 +1484,13 @@ public void multi() {
         if (isPipelined()) {
             BatchOptions options = BatchOptions.defaults()
                     .executionMode(ExecutionMode.IN_MEMORY_ATOMIC);
-            this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+            this.executorService = new CommandBatchService(executorService, options);
             return;
         }
         
         BatchOptions options = BatchOptions.defaults()
             .executionMode(ExecutionMode.REDIS_WRITE_ATOMIC);
-        this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+        this.executorService = new CommandBatchService(executorService, options);
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -130,7 +130,7 @@ public boolean isPipelinedAtomic() {
     public void openPipeline() {
         BatchOptions options = BatchOptions.defaults()
                 .executionMode(ExecutionMode.IN_MEMORY);
-        this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+        this.executorService = new CommandBatchService(executorService, options);
     }
 
     @Override
@@ -1484,13 +1484,13 @@ public void multi() {
         if (isPipelined()) {
             BatchOptions options = BatchOptions.defaults()
                     .executionMode(ExecutionMode.IN_MEMORY_ATOMIC);
-            this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+            this.executorService = new CommandBatchService(executorService, options);
             return;
         }
         
         BatchOptions options = BatchOptions.defaults()
             .executionMode(ExecutionMode.REDIS_WRITE_ATOMIC);
-        this.executorService = new CommandBatchService(redisson.getConnectionManager(), options);
+        this.executorService = new CommandBatchService(executorService, options);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/command/CommandSyncService.java
Patch:
@@ -35,7 +35,7 @@ public class CommandSyncService extends CommandAsyncService implements CommandEx
     final Logger log = LoggerFactory.getLogger(getClass());
 
     public CommandSyncService(ConnectionManager connectionManager, RedissonObjectBuilder objectBuilder) {
-        super(connectionManager, objectBuilder);
+        super(connectionManager, objectBuilder, RedissonObjectBuilder.ReferenceType.DEFAULT);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/liveobject/core/AccessorInterceptor.java
Patch:
@@ -97,7 +97,7 @@ public Object intercept(@Origin Method method,
                 return result;
             }
             if (result instanceof RedissonReference) {
-                return commandExecutor.getObjectBuilder().fromReference((RedissonReference) result);
+                return commandExecutor.getObjectBuilder().fromReference((RedissonReference) result, RedissonObjectBuilder.ReferenceType.DEFAULT);
             }
             return result;
         }

File: redisson/src/main/java/org/redisson/reactive/CommandReactiveBatchService.java
Patch:
@@ -23,6 +23,7 @@
 import org.redisson.command.CommandBatchService;
 import org.redisson.connection.ConnectionManager;
 import org.redisson.connection.NodeSource;
+import org.redisson.liveobject.core.RedissonObjectBuilder;
 import org.redisson.misc.RPromise;
 import reactor.core.publisher.Mono;
 
@@ -39,7 +40,7 @@ public class CommandReactiveBatchService extends CommandReactiveService {
 
     public CommandReactiveBatchService(ConnectionManager connectionManager, BatchOptions options) {
         super(connectionManager);
-        batchService = new CommandBatchService(connectionManager.getCommandExecutor(), options);
+        batchService = new CommandBatchService(connectionManager.getCommandExecutor(), options, RedissonObjectBuilder.ReferenceType.REACTIVE);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/reactive/CommandReactiveService.java
Patch:
@@ -21,6 +21,7 @@
 import org.redisson.command.CommandAsyncService;
 import org.redisson.connection.ConnectionManager;
 
+import org.redisson.liveobject.core.RedissonObjectBuilder;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 
@@ -32,7 +33,7 @@
 public class CommandReactiveService extends CommandAsyncService implements CommandReactiveExecutor {
 
     public CommandReactiveService(ConnectionManager connectionManager) {
-        super(connectionManager, connectionManager.getCommandExecutor().getObjectBuilder());
+        super(connectionManager, connectionManager.getCommandExecutor().getObjectBuilder(), RedissonObjectBuilder.ReferenceType.REACTIVE);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/rx/CommandRxBatchService.java
Patch:
@@ -24,6 +24,7 @@
 import org.redisson.command.CommandBatchService;
 import org.redisson.connection.ConnectionManager;
 import org.redisson.connection.NodeSource;
+import org.redisson.liveobject.core.RedissonObjectBuilder;
 import org.redisson.misc.RPromise;
 
 import java.util.concurrent.Callable;
@@ -39,7 +40,7 @@ public class CommandRxBatchService extends CommandRxService {
 
     public CommandRxBatchService(ConnectionManager connectionManager, BatchOptions options) {
         super(connectionManager);
-        batchService = new CommandBatchService(connectionManager.getCommandExecutor(), options);
+        batchService = new CommandBatchService(connectionManager.getCommandExecutor(), options, RedissonObjectBuilder.ReferenceType.RXJAVA);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/rx/CommandRxService.java
Patch:
@@ -25,6 +25,7 @@
 import io.reactivex.rxjava3.functions.Action;
 import io.reactivex.rxjava3.functions.LongConsumer;
 import io.reactivex.rxjava3.processors.ReplayProcessor;
+import org.redisson.liveobject.core.RedissonObjectBuilder;
 
 /**
  *
@@ -34,7 +35,7 @@
 public class CommandRxService extends CommandAsyncService implements CommandRxExecutor {
 
     public CommandRxService(ConnectionManager connectionManager) {
-        super(connectionManager, connectionManager.getCommandExecutor().getObjectBuilder());
+        super(connectionManager, connectionManager.getCommandExecutor().getObjectBuilder(), RedissonObjectBuilder.ReferenceType.RXJAVA);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/config/BaseConfig.java
Patch:
@@ -90,7 +90,7 @@ public class BaseConfig<T extends BaseConfig<T>> {
 
     private boolean keepAlive;
     
-    private boolean tcpNoDelay;
+    private boolean tcpNoDelay = true;
 
     
     BaseConfig() {
@@ -422,7 +422,7 @@ public boolean isTcpNoDelay() {
     /**
      * Enables TCP noDelay for connection
      * <p>
-     * Default is <code>false</code>
+     * Default is <code>true</code>
      * 
      * @param tcpNoDelay - boolean value
      * @return config

File: redisson/src/main/java/org/redisson/connection/balancer/LoadBalancerManager.java
Patch:
@@ -159,7 +159,6 @@ public void accept(Void r, Throwable ex) {
                                 if (!initConnError.compareAndSet(false, true)) {
                                     return;
                                 }
-                                entry.closeAllConnections();
                                 entry.setInitialized(false);
                             }
                         }

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -331,7 +331,7 @@ private void checkState(SentinelServersConfig cfg, Iterator<RedisClient> iterato
 
         RedisClient client = iterator.next();
         RedisURI addr = getIpAddr(client.getAddr());
-        RFuture<RedisConnection> connectionFuture = connectToNode(cfg, addr, null);
+        RFuture<RedisConnection> connectionFuture = connectToNode(NodeType.SENTINEL, cfg, addr, null);
         connectionFuture.onComplete((connection, e) -> {
             if (e != null) {
                 lastException.set(e);

File: redisson/src/main/java/org/redisson/api/stream/StreamAddParams.java
Patch:
@@ -27,7 +27,7 @@ public class StreamAddParams<K, V> {
     private Map<K, V> entries;
     private boolean noMakeStream;
     private boolean trimStrict;
-    private StreamAddArgs.TrimStrategy trimStrategy;
+    private TrimStrategy trimStrategy;
     private int trimThreshold;
     private int limit;
 
@@ -55,11 +55,11 @@ public void setTrimStrict(boolean trimStrict) {
         this.trimStrict = trimStrict;
     }
 
-    public StreamAddArgs.TrimStrategy getTrimStrategy() {
+    public TrimStrategy getTrimStrategy() {
         return trimStrategy;
     }
 
-    public void setTrimStrategy(StreamAddArgs.TrimStrategy trimStrategy) {
+    public void setTrimStrategy(TrimStrategy trimStrategy) {
         this.trimStrategy = trimStrategy;
     }
 

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -50,7 +50,7 @@ public class RedissonLocalCachedMap<K, V> extends RedissonMap<K, V> implements R
 
     private static final RedisCommand<Set<Object>> ALL_KEYS = new RedisCommand<Set<Object>>("EVAL", new MapKeyDecoder(new ObjectSetReplayDecoder<Object>()));
     private static final RedisCommand<Set<Entry<Object, Object>>> ALL_ENTRIES = new RedisCommand<Set<Entry<Object, Object>>>("EVAL", new MapEntriesDecoder(new ObjectMapEntryReplayDecoder()));
-    private static final RedisCommand<Map<Object, Object>> ALL_MAP = new RedisCommand<Map<Object, Object>>("EVAL", new MapEntriesDecoder(new ObjectMapReplayDecoder()));
+    private static final RedisCommand<Map<Object, Object>> ALL_MAP = new RedisCommand<Map<Object, Object>>("EVAL", new ObjectMapReplayDecoder());
     
     private long cacheUpdateLogTime = TimeUnit.MINUTES.toMillis(10);
     private byte[] instanceId;

File: redisson/src/main/java/org/redisson/RedissonMultiLock.java
Patch:
@@ -422,7 +422,7 @@ public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws Inte
 
         if (leaseTime != -1) {
             acquiredLocks.stream()
-                    .map(l -> (RedissonLock)l)
+                    .map(l -> (RedissonLock) l)
                     .map(l -> l.expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS))
                     .forEach(f -> f.syncUninterruptibly());
         }

File: redisson/src/main/java/org/redisson/api/RPatternTopicReactive.java
Patch:
@@ -64,6 +64,6 @@ public interface RPatternTopicReactive {
      *
      * @param listenerId - message listener id
      */
-    void removeListener(int listenerId);
+    Mono<Void> removeListener(int listenerId);
 
 }

File: redisson/src/main/java/org/redisson/RedissonTopic.java
Patch:
@@ -145,10 +145,9 @@ public void removeAllListeners() {
         }
 
         if (entry.hasListeners(channelName)) {
-            subscribeService.unsubscribe(PubSubType.UNSUBSCRIBE, channelName, semaphore).syncUninterruptibly();
-        } else {
-            semaphore.release();
+            subscribeService.unsubscribe(PubSubType.UNSUBSCRIBE, channelName).syncUninterruptibly();
         }
+        semaphore.release();
     }
 
     protected void acquire(AsyncSemaphore semaphore) {

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -443,7 +443,6 @@ private void updateClusterState(ClusterServersConfig cfg, RedisConnection connec
         RFuture<List<ClusterNodeInfo>> future = connection.async(clusterNodesCommand);
         future.onComplete((nodes, e) -> {
                 if (e != null) {
-                    log.error("Can't execute CLUSTER_NODES with " + connection.getRedisClient().getAddr(), e);
                     closeNodeConnection(connection);
                     lastException.set(e);
                     getShutdownLatch().release();

File: redisson/src/main/java/org/redisson/RedissonTopic.java
Patch:
@@ -31,7 +31,6 @@
 import org.redisson.config.MasterSlaveServersConfig;
 import org.redisson.misc.RPromise;
 import org.redisson.misc.RedissonPromise;
-import org.redisson.misc.TransferListener;
 import org.redisson.pubsub.AsyncSemaphore;
 import org.redisson.pubsub.PubSubConnectionEntry;
 import org.redisson.pubsub.PublishSubscribeService;

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -275,7 +275,6 @@ protected final RFuture<RedisConnection> connectToNode(BaseMasterSlaveServersCon
         RFuture<RedisConnection> future = client.connectAsync();
         future.onComplete((connection, e) -> {
             if (e != null) {
-                connection.closeAsync();
                 result.tryFailure(e);
                 return;
             }

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -402,7 +402,7 @@ public interface RedisCommands {
     RedisStrictCommand<Long> TOUCH_LONG = new RedisStrictCommand<Long>("TOUCH", new LongReplayConvertor());
     RedisStrictCommand<Boolean> TOUCH = new RedisStrictCommand<Boolean>("TOUCH", new BooleanReplayConvertor());
     RedisStrictCommand<Long> EXISTS_LONG = new RedisStrictCommand<Long>("EXISTS", new LongReplayConvertor());
-    RedisStrictCommand<Boolean> EXISTS = new RedisStrictCommand<Boolean>("EXISTS", new BooleanReplayConvertor());
+    RedisStrictCommand<Boolean> EXISTS = new RedisStrictCommand<Boolean>("EXISTS", new BooleanAmountReplayConvertor());
     RedisStrictCommand<Boolean> NOT_EXISTS = new RedisStrictCommand<Boolean>("EXISTS", new BooleanNumberReplayConvertor(1L));
 
     RedisStrictCommand<Long> OBJECT_IDLETIME = new RedisStrictCommand<Long>("OBJECT", "IDLETIME", new LongReplayConvertor());

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -224,7 +224,7 @@ private void checkAuth(SentinelServersConfig cfg) {
                 usePassword = true;
                 return;
             } catch (RedisConnectionException e) {
-                log.warn("Can't connect to sentinel server. {}", e.getMessage());
+                log.warn("Can't connect to sentinel server", e);
             } catch (Exception e) {
                 // skip
             } finally {

File: redisson/src/main/java/org/redisson/client/handler/PingConnectionHandler.java
Patch:
@@ -72,7 +72,7 @@ private void sendPing(ChannelHandlerContext ctx) {
         config.getTimer().newTimeout(new TimerTask() {
             @Override
             public void run(Timeout timeout) throws Exception {
-                if (connection.isClosed()) {
+                if (connection.isClosed() || ctx.isRemoved()) {
                     return;
                 }
 

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -275,6 +275,7 @@ protected final RFuture<RedisConnection> connectToNode(BaseMasterSlaveServersCon
         RFuture<RedisConnection> future = client.connectAsync();
         future.onComplete((connection, e) -> {
             if (e != null) {
+                connection.closeAsync();
                 result.tryFailure(e);
                 return;
             }

File: redisson/src/main/java/org/redisson/api/RScoredSortedSetReactive.java
Patch:
@@ -21,8 +21,6 @@
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
-import io.reactivex.rxjava3.core.Maybe;
-import io.reactivex.rxjava3.core.Single;
 import org.redisson.api.RScoredSortedSet.Aggregate;
 import org.redisson.client.protocol.ScoredEntry;
 

File: redisson/src/main/java/org/redisson/rx/RedissonTransactionRx.java
Patch:
@@ -76,14 +76,14 @@ public <K, V> RMapRx<K, V> getMap(String name, Codec codec) {
     public <K, V> RMapCacheRx<K, V> getMapCache(String name, Codec codec) {
         RMapCache<K, V> map = transaction.<K, V>getMapCache(name, codec);
         return RxProxyBuilder.create(executorService, map, 
-                new RedissonMapCacheRx<K, V>(map), RMapCacheRx.class);
+                new RedissonMapCacheRx<K, V>(map, executorService), RMapCacheRx.class);
     }
 
     @Override
     public <K, V> RMapCacheRx<K, V> getMapCache(String name) {
         RMapCache<K, V> map = transaction.<K, V>getMapCache(name);
         return RxProxyBuilder.create(executorService, map, 
-                new RedissonMapCacheRx<K, V>(map), RMapCacheRx.class);
+                new RedissonMapCacheRx<K, V>(map, executorService), RMapCacheRx.class);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/Redisson.java
Patch:
@@ -352,8 +352,8 @@ public RLock getSpinLock(String name) {
     }
 
     @Override
-    public RLock getSpinLock(String name, LockOptions.BackOffOptions backOffOptions) {
-        return new RedissonSpinLock(connectionManager.getCommandExecutor(), name, backOffOptions);
+    public RLock getSpinLock(String name, LockOptions.BackOff backOff) {
+        return new RedissonSpinLock(connectionManager.getCommandExecutor(), name, backOff);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonReactive.java
Patch:
@@ -133,8 +133,8 @@ public RLockReactive getSpinLock(String name) {
     }
 
     @Override
-    public RLockReactive getSpinLock(String name, LockOptions.BackOffOptions backOffOptions) {
-        RedissonSpinLock spinLock = new RedissonSpinLock(commandExecutor, name, backOffOptions);
+    public RLockReactive getSpinLock(String name, LockOptions.BackOff backOff) {
+        RedissonSpinLock spinLock = new RedissonSpinLock(commandExecutor, name, backOff);
         return ReactiveProxyBuilder.create(commandExecutor, spinLock, RLockReactive.class);
     }
 

File: redisson/src/main/java/org/redisson/RedissonRx.java
Patch:
@@ -121,8 +121,8 @@ public RLockRx getSpinLock(String name) {
     }
 
     @Override
-    public RLockRx getSpinLock(String name, LockOptions.BackOffOptions backOffOptions) {
-        RedissonSpinLock spinLock = new RedissonSpinLock(commandExecutor, name, backOffOptions);
+    public RLockRx getSpinLock(String name, LockOptions.BackOff backOff) {
+        RedissonSpinLock spinLock = new RedissonSpinLock(commandExecutor, name, backOff);
         return RxProxyBuilder.create(commandExecutor, spinLock, RLockRx.class);
     }
     

File: redisson/src/main/java/org/redisson/api/RedissonClient.java
Patch:
@@ -497,7 +497,7 @@ public interface RedissonClient {
      * @param name - name of object
      * @return Lock object
      */
-    RLock getSpinLock(String name, LockOptions.BackOffOptions backOffOptions);
+    RLock getSpinLock(String name, LockOptions.BackOff backOff);
 
     /**
      * Returns MultiLock instance associated with specified <code>locks</code>

File: redisson/src/main/java/org/redisson/api/RedissonReactiveClient.java
Patch:
@@ -187,7 +187,7 @@ public interface RedissonReactiveClient {
      * @param name - name of object
      * @return Lock object
      */
-    RLockReactive getSpinLock(String name, LockOptions.BackOffOptions backOffOptions);
+    RLockReactive getSpinLock(String name, LockOptions.BackOff backOff);
     
     /**
      * Returns MultiLock instance associated with specified <code>locks</code>

File: redisson/src/main/java/org/redisson/api/RedissonRxClient.java
Patch:
@@ -186,7 +186,7 @@ public interface RedissonRxClient {
      * @param name - name of object
      * @return Lock object
      */
-    RLockRx getSpinLock(String name, LockOptions.BackOffOptions backOffOptions);
+    RLockRx getSpinLock(String name, LockOptions.BackOff backOff);
     
     /**
      * Returns MultiLock instance associated with specified <code>locks</code>

File: redisson/src/test/java/org/redisson/LockOptionsTest.java
Patch:
@@ -9,12 +9,12 @@ public class LockOptionsTest {
 
     @Test
     public void testExponentialBackoff() {
-        LockOptions.BackOffOptions backOffOptions = new LockOptions.ExponentialBackOffOptions()
+        LockOptions.BackOff backOff = new LockOptions.ExponentialBackOff()
                 .initialDelay(10)
                 .maxDelay(100)
                 .multiplier(3);
 
-        LockOptions.BackOffPolicy backOffPolicy = backOffOptions.create();
+        LockOptions.BackOffPolicy backOffPolicy = backOff.create();
 
 
         assertThat(backOffPolicy.getNextSleepPeriod()).isBetween(10L, 10L);
@@ -26,7 +26,7 @@ public void testExponentialBackoff() {
 
     @Test
     public void testConstantBackoff() {
-        LockOptions.ConstantBackOffOptions backOffOptions = new LockOptions.ConstantBackOffOptions()
+        LockOptions.ConstantBackOff backOffOptions = new LockOptions.ConstantBackOff()
                 .delay(30);
 
         LockOptions.BackOffPolicy backOffPolicy = backOffOptions.create();

File: redisson/src/main/java/org/redisson/api/RGeoReactive.java
Patch:
@@ -15,12 +15,11 @@
  */
 package org.redisson.api;
 
+import reactor.core.publisher.Mono;
+
 import java.util.List;
 import java.util.Map;
 
-import io.reactivex.rxjava3.core.Single;
-import reactor.core.publisher.Mono;
-
 /**
  * Geospatial items holder. Reactive interface.
  * 

File: redisson/src/main/java/org/redisson/Redisson.java
Patch:
@@ -348,11 +348,11 @@ public RLock getLock(String name) {
 
     @Override
     public RLock getSpinLock(String name) {
-        return getSpinLock(name, RedissonSpinLock.DEFAULT);
+        return getSpinLock(name, LockOptions.defaults());
     }
 
     @Override
-    public RLock getSpinLock(String name, RedissonSpinLock.BackOffOptions backOffOptions) {
+    public RLock getSpinLock(String name, LockOptions.BackOffOptions backOffOptions) {
         return new RedissonSpinLock(connectionManager.getCommandExecutor(), name, backOffOptions);
     }
 

File: redisson/src/main/java/org/redisson/RedissonReactive.java
Patch:
@@ -129,11 +129,11 @@ public RLockReactive getLock(String name) {
 
     @Override
     public RLockReactive getSpinLock(String name) {
-        return getSpinLock(name, RedissonSpinLock.DEFAULT);
+        return getSpinLock(name, LockOptions.defaults());
     }
 
     @Override
-    public RLockReactive getSpinLock(String name, RedissonSpinLock.BackOffOptions backOffOptions) {
+    public RLockReactive getSpinLock(String name, LockOptions.BackOffOptions backOffOptions) {
         RedissonSpinLock spinLock = new RedissonSpinLock(commandExecutor, name, backOffOptions);
         return ReactiveProxyBuilder.create(commandExecutor, spinLock, RLockReactive.class);
     }

File: redisson/src/main/java/org/redisson/RedissonRx.java
Patch:
@@ -117,11 +117,11 @@ public RLockRx getLock(String name) {
 
     @Override
     public RLockRx getSpinLock(String name) {
-        return getSpinLock(name, RedissonSpinLock.DEFAULT);
+        return getSpinLock(name, LockOptions.defaults());
     }
 
     @Override
-    public RLockRx getSpinLock(String name, RedissonSpinLock.BackOffOptions backOffOptions) {
+    public RLockRx getSpinLock(String name, LockOptions.BackOffOptions backOffOptions) {
         RedissonSpinLock spinLock = new RedissonSpinLock(commandExecutor, name, backOffOptions);
         return RxProxyBuilder.create(commandExecutor, spinLock, RLockRx.class);
     }

File: redisson/src/main/java/org/redisson/api/RedissonClient.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.redisson.api;
 
-import org.redisson.RedissonSpinLock;
 import org.redisson.api.redisnode.BaseRedisNodes;
 import org.redisson.api.redisnode.RedisNodes;
 import org.redisson.client.codec.Codec;
@@ -498,7 +497,7 @@ public interface RedissonClient {
      * @param name - name of object
      * @return Lock object
      */
-    RLock getSpinLock(String name, RedissonSpinLock.BackOffOptions backOffOptions);
+    RLock getSpinLock(String name, LockOptions.BackOffOptions backOffOptions);
 
     /**
      * Returns MultiLock instance associated with specified <code>locks</code>

File: redisson/src/main/java/org/redisson/api/RedissonReactiveClient.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.redisson.api;
 
-import org.redisson.RedissonSpinLock;
 import org.redisson.client.codec.Codec;
 import org.redisson.config.Config;
 
@@ -188,7 +187,7 @@ public interface RedissonReactiveClient {
      * @param name - name of object
      * @return Lock object
      */
-    RLockReactive getSpinLock(String name, RedissonSpinLock.BackOffOptions backOffOptions);
+    RLockReactive getSpinLock(String name, LockOptions.BackOffOptions backOffOptions);
     
     /**
      * Returns MultiLock instance associated with specified <code>locks</code>

File: redisson/src/main/java/org/redisson/api/RedissonRxClient.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.redisson.api;
 
-import org.redisson.RedissonSpinLock;
 import org.redisson.client.codec.Codec;
 import org.redisson.config.Config;
 
@@ -187,7 +186,7 @@ public interface RedissonRxClient {
      * @param name - name of object
      * @return Lock object
      */
-    RLockRx getSpinLock(String name, RedissonSpinLock.BackOffOptions backOffOptions);
+    RLockRx getSpinLock(String name, LockOptions.BackOffOptions backOffOptions);
     
     /**
      * Returns MultiLock instance associated with specified <code>locks</code>

File: redisson/src/main/java/org/redisson/api/RedissonClient.java
Patch:
@@ -481,6 +481,7 @@ public interface RedissonClient {
      * <p>
      * Implements a <b>non-fair</b> locking so doesn't guarantees an acquire order by threads.
      * <p>
+     * Lock doesn't use a pub/sub mechanism
      *
      * @param name - name of object
      * @return Lock object
@@ -492,6 +493,7 @@ public interface RedissonClient {
      * <p>
      * Implements a <b>non-fair</b> locking so doesn't guarantees an acquire order by threads.
      * <p>
+     * Lock doesn't use a pub/sub mechanism
      *
      * @param name - name of object
      * @return Lock object

File: redisson/src/main/java/org/redisson/api/RScoredSortedSetReactive.java
Patch:
@@ -21,7 +21,6 @@
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
-import io.reactivex.rxjava3.core.Single;
 import org.redisson.api.RScoredSortedSet.Aggregate;
 import org.redisson.client.protocol.ScoredEntry;
 

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -94,6 +94,7 @@ public interface RedisCommands {
     RedisStrictCommand<Void> ASKING = new RedisStrictCommand<Void>("ASKING", new VoidReplayConvertor());
     RedisStrictCommand<Void> READONLY = new RedisStrictCommand<Void>("READONLY", new VoidReplayConvertor());
 
+    RedisStrictCommand<List<Object>> ZDIFF = new RedisStrictCommand<>("ZDIFF", new ObjectListReplayDecoder<>());
     RedisCommand<List<Object>> ZUNION = new RedisCommand<>("ZUNION", new ObjectListReplayDecoder<>());
     RedisCommand<List<Object>> ZINTER = new RedisCommand<>("ZINTER", new ObjectListReplayDecoder<>());
     RedisStrictCommand<Integer> ZUNIONSTORE_INT = new RedisStrictCommand<Integer>("ZUNIONSTORE", new IntegerReplayConvertor());

File: redisson/src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -25,6 +25,7 @@
 import org.redisson.api.RFuture;
 import org.redisson.client.RedisClient;
 import org.redisson.client.RedisConnection;
+import org.redisson.client.RedisNodeNotFoundException;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.command.CommandSyncService;
@@ -116,4 +117,6 @@ public interface ConnectionManager {
     
     Future<Void> getShutdownPromise();
 
+    RedisNodeNotFoundException createNodeNotFoundException(NodeSource source);
+
 }

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -360,7 +360,7 @@ public void run(Timeout timeout) throws Exception {
                         connection.forceFastReconnectAsync();
                     }
                 }
-            }, popTimeout, TimeUnit.SECONDS);
+            }, popTimeout + 1, TimeUnit.SECONDS);
         } else {
             scheduledFuture = null;
         }

File: redisson/src/main/java/org/redisson/config/SentinelServersConfig.java
Patch:
@@ -81,6 +81,7 @@ public String getMasterName() {
 
     /**
      * Password required by the Redis Sentinel servers for authentication.
+     * Used only if sentinel password differs from master and slave.
      *
      * @param sentinelPassword of Redis
      * @return config

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -1404,7 +1404,8 @@ public RFuture<MapScanResult<Object, Object>> scanIteratorAsync(String name, Red
 
     @Override
     protected RFuture<Boolean> fastPutOperationAsync(K key, V value) {
-        return commandExecutor.evalWriteAsync(getName(key), codec, RedisCommands.EVAL_BOOLEAN,
+        String name = getName(key);
+        return commandExecutor.evalWriteAsync(name, codec, RedisCommands.EVAL_BOOLEAN,
                 "local insertable = false; "
                         + "local v = redis.call('hget', KEYS[1], ARGV[2]); "
                         + "if v == false then "

File: redisson/src/main/java/org/redisson/codec/Kryo5Codec.java
Patch:
@@ -32,6 +32,9 @@
 import java.io.IOException;
 
 /**
+ * Kryo 5 codec
+ * <p>
+ * Fully thread-safe.
  *
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/codec/MsgPackJacksonCodec.java
Patch:
@@ -21,6 +21,8 @@
 
 /**
  * MsgPack binary codec
+ * <p>
+ * Fully thread-safe.
  *
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/codec/SerializationCodec.java
Patch:
@@ -30,6 +30,9 @@
 import io.netty.buffer.ByteBufOutputStream;
 
 /**
+ * JDK's serialization codec.
+ * <p>
+ * Fully thread-safe.*
  *
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/codec/SmileJacksonCodec.java
Patch:
@@ -19,7 +19,9 @@
 import com.fasterxml.jackson.dataformat.smile.SmileFactory;
 
 /**
- * Smile binary codec
+ * Smile binary codec.
+ * <p>
+ * Fully thread-safe.
  *
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -139,6 +139,7 @@ public <V> V get(RFuture<V> future) {
         try {
             future.await();
         } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
             throw new RedisException(e);
         }
         if (future.isSuccess()) {

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -139,7 +139,7 @@ public <V> V get(RFuture<V> future) {
         try {
             future.await();
         } catch (InterruptedException e) {
-            Thread.currentThread().interrupt();
+            throw new RedisException(e);
         }
         if (future.isSuccess()) {
             return future.getNow();

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -131,7 +131,7 @@ public SentinelConnectionManager(SentinelServersConfig cfg, Config config, UUID
 
                     String ip = map.get("ip");
                     String port = map.get("port");
-                    String flags = map.get("flags");
+                    String flags = map.getOrDefault("flags", "");
 
                     RedisURI host = toURI(ip, port);
 
@@ -409,7 +409,7 @@ public void accept(Object t, Throwable u) {
                     
                     String ip = map.get("ip");
                     String port = map.get("port");
-                    String flags = map.get("flags");
+                    String flags = map.getOrDefault("flags", "");
                     String masterHost = map.get("master-host");
                     String masterPort = map.get("master-port");
 
@@ -464,7 +464,7 @@ protected void onSuccess(Void value) {
             }
             
             Set<RedisURI> newUris = list.stream().filter(m -> {
-                String flags = m.get("flags");
+                String flags = m.getOrDefault("flags", "");
                 if (!m.isEmpty() && !flags.contains("disconnected") && !flags.contains("s_down")) {
                     return true;
                 }

File: redisson/src/main/java/org/redisson/connection/ClientConnectionsEntry.java
Patch:
@@ -125,6 +125,9 @@ public boolean isFreezed() {
 
     public void setFreezeReason(FreezeReason freezeReason) {
         this.freezeReason = freezeReason;
+        if (freezeReason != null) {
+            this.initing = false;
+        }
     }
 
     public FreezeReason getFreezeReason() {

File: redisson/src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -873,15 +873,15 @@ public V putIfAbsent(K key, V value) {
     @Override
     public RFuture<V> putIfAbsentAsync(K key, V value) {
         checkKey(key);
-        checkValue(key);
+        checkValue(value);
         
         RFuture<V> future = putIfAbsentOperationAsync(key, value);
         if (hasNoWriter()) {
             return future;
         }
         
         MapWriterTask.Add task = new MapWriterTask.Add(key, value);
-        return mapWriterFuture(future, task, r -> r == null);
+        return mapWriterFuture(future, task, Objects::isNull);
     }
 
     protected boolean hasNoWriter() {

File: redisson/src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -873,15 +873,15 @@ public V putIfAbsent(K key, V value) {
     @Override
     public RFuture<V> putIfAbsentAsync(K key, V value) {
         checkKey(key);
-        checkValue(key);
+        checkValue(value);
         
         RFuture<V> future = putIfAbsentOperationAsync(key, value);
         if (hasNoWriter()) {
             return future;
         }
         
         MapWriterTask.Add task = new MapWriterTask.Add(key, value);
-        return mapWriterFuture(future, task, r -> r == null);
+        return mapWriterFuture(future, task, Objects::isNull);
     }
 
     protected boolean hasNoWriter() {

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -239,7 +239,7 @@ protected void startInternal() throws LifecycleException {
             throw new LifecycleException(e);
         }
         
-        Pipeline pipeline = getEngine().getPipeline();
+        Pipeline pipeline = getContainer().getPipeline();
         synchronized (pipeline) {
             if (readMode == ReadMode.REDIS) {
                 Optional<Valve> res = Arrays.stream(pipeline.getValves()).filter(v -> v.getClass() == UsageValve.class).findAny();
@@ -355,7 +355,7 @@ protected void stopInternal() throws LifecycleException {
         
         setState(LifecycleState.STOPPING);
         
-        Pipeline pipeline = getEngine().getPipeline();
+        Pipeline pipeline = getContainer().getPipeline();
         synchronized (pipeline) {
             if (readMode == ReadMode.REDIS) {
                 Arrays.stream(pipeline.getValves()).filter(v -> v.getClass() == UsageValve.class).forEach(v -> {

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -239,7 +239,7 @@ protected void startInternal() throws LifecycleException {
             throw new LifecycleException(e);
         }
         
-        Pipeline pipeline = getEngine().getPipeline();
+        Pipeline pipeline = getContext().getPipeline();
         synchronized (pipeline) {
             if (readMode == ReadMode.REDIS) {
                 Optional<Valve> res = Arrays.stream(pipeline.getValves()).filter(v -> v.getClass() == UsageValve.class).findAny();
@@ -355,7 +355,7 @@ protected void stopInternal() throws LifecycleException {
         
         setState(LifecycleState.STOPPING);
         
-        Pipeline pipeline = getEngine().getPipeline();
+        Pipeline pipeline = getContext().getPipeline();
         synchronized (pipeline) {
             if (readMode == ReadMode.REDIS) {
                 Arrays.stream(pipeline.getValves()).filter(v -> v.getClass() == UsageValve.class).forEach(v -> {

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -239,7 +239,7 @@ protected void startInternal() throws LifecycleException {
             throw new LifecycleException(e);
         }
         
-        Pipeline pipeline = getEngine().getPipeline();
+        Pipeline pipeline = getContext().getPipeline();
         synchronized (pipeline) {
             if (readMode == ReadMode.REDIS) {
                 Optional<Valve> res = Arrays.stream(pipeline.getValves()).filter(v -> v.getClass() == UsageValve.class).findAny();
@@ -354,8 +354,8 @@ protected void stopInternal() throws LifecycleException {
         super.stopInternal();
         
         setState(LifecycleState.STOPPING);
-        
-        Pipeline pipeline = getEngine().getPipeline();
+
+        Pipeline pipeline = getContext().getPipeline();
         synchronized (pipeline) {
             if (readMode == ReadMode.REDIS) {
                 Arrays.stream(pipeline.getValves()).filter(v -> v.getClass() == UsageValve.class).forEach(v -> {

File: redisson/src/main/java/org/redisson/client/RedisClient.java
Patch:
@@ -325,7 +325,7 @@ public void shutdown() {
 
     public RFuture<Void> shutdownAsync() {
         RPromise<Void> result = new RedissonPromise<Void>();
-        if (channels.isEmpty()) {
+        if (channels.isEmpty() || config.getGroup().isShuttingDown()) {
             shutdown(result);
             return result;
         }

File: redisson/src/main/java/org/redisson/api/RScoredSortedSetReactive.java
Patch:
@@ -268,7 +268,7 @@ public interface RScoredSortedSetReactive<V> extends RExpirableReactive, RSortab
      * @param objects - map of elements to add
      * @return amount of added elements, not including already existing in this sorted set
      */
-    Mono<Long> addAll(Map<V, Double> objects);
+    Mono<Integer> addAll(Map<V, Double> objects);
     
     /**
      * Adds element to this set, overrides previous score if it has been already added.
@@ -575,7 +575,7 @@ public interface RScoredSortedSetReactive<V> extends RExpirableReactive, RSortab
      * @param endScoreInclusive - end score inclusive
      * @return count
      */
-    Mono<Long> count(double startScore, boolean startScoreInclusive, double endScore, boolean endScoreInclusive);
+    Mono<Integer> count(double startScore, boolean startScoreInclusive, double endScore, boolean endScoreInclusive);
     
     /**
      * Read all values at once.

File: redisson/src/main/java/org/redisson/api/RScoredSortedSetRx.java
Patch:
@@ -269,7 +269,7 @@ public interface RScoredSortedSetRx<V> extends RExpirableRx, RSortableRx<Set<V>>
      * @param objects - map of elements to add
      * @return amount of added elements, not including already existing in this sorted set
      */
-    Single<Long> addAll(Map<V, Double> objects);
+    Single<Integer> addAll(Map<V, Double> objects);
     
     /**
      * Adds element to this set, overrides previous score if it has been already added.
@@ -577,7 +577,7 @@ public interface RScoredSortedSetRx<V> extends RExpirableRx, RSortableRx<Set<V>>
      * @param endScoreInclusive - end score inclusive
      * @return count
      */
-    Single<Long> count(double startScore, boolean startScoreInclusive, double endScore, boolean endScoreInclusive);
+    Single<Integer> count(double startScore, boolean startScoreInclusive, double endScore, boolean endScoreInclusive);
     
     /**
      * Read all values at once.

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -659,7 +659,7 @@ protected RFuture<Void> putAllOperationAsync(Map<? extends K, ? extends V> map)
                 + "end;"
                 + "if ARGV[1] == '2' then "
                     + "for i=tonumber(ARGV[2]) + 2 + 1, #ARGV - 1, 5000 do "
-                        + "redis.call('hmset', KEYS[3], unpack(ARGV, i, math.min(i+4999, #ARGV - 1))); "
+                        + "redis.call('zadd', KEYS[3], unpack(ARGV, i, math.min(i+4999, #ARGV - 1))); "
                     + "end; "
                     + "redis.call('publish', KEYS[2], ARGV[#ARGV]); "
                 + "end;",
@@ -671,7 +671,7 @@ protected RFuture<Void> putAllOperationAsync(Map<? extends K, ? extends V> map)
                 result.tryFailure(e);
                 return;
             }
-            
+
             cacheMap(map);
             result.trySuccess(null);
         });

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -831,9 +831,11 @@ public byte[] sRandMember(byte[] key) {
         return read(key, ByteArrayCodec.INSTANCE, RedisCommands.SRANDMEMBER_SINGLE, key);
     }
 
+    private static final RedisCommand<List<Object>> SRANDMEMBER = new RedisCommand<>("SRANDMEMBER", new ObjectListReplayDecoder<>());
+
     @Override
     public List<byte[]> sRandMember(byte[] key, long count) {
-        return read(key, ByteArrayCodec.INSTANCE, RedisCommands.SRANDMEMBER, key, count);
+        return read(key, ByteArrayCodec.INSTANCE, SRANDMEMBER, key, count);
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -888,9 +888,11 @@ public byte[] sRandMember(byte[] key) {
         return read(key, ByteArrayCodec.INSTANCE, RedisCommands.SRANDMEMBER_SINGLE, key);
     }
 
+    private static final RedisCommand<List<Object>> SRANDMEMBER = new RedisCommand<>("SRANDMEMBER", new ObjectListReplayDecoder<>());
+
     @Override
     public List<byte[]> sRandMember(byte[] key, long count) {
-        return read(key, ByteArrayCodec.INSTANCE, RedisCommands.SRANDMEMBER, key, count);
+        return read(key, ByteArrayCodec.INSTANCE, SRANDMEMBER, key, count);
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -901,9 +901,11 @@ public byte[] sRandMember(byte[] key) {
         return read(key, ByteArrayCodec.INSTANCE, RedisCommands.SRANDMEMBER_SINGLE, key);
     }
 
+    private static final RedisCommand<List<Object>> SRANDMEMBER = new RedisCommand<>("SRANDMEMBER", new ObjectListReplayDecoder<>());
+
     @Override
     public List<byte[]> sRandMember(byte[] key, long count) {
-        return read(key, ByteArrayCodec.INSTANCE, RedisCommands.SRANDMEMBER, key, count);
+        return read(key, ByteArrayCodec.INSTANCE, SRANDMEMBER, key, count);
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -887,9 +887,11 @@ public byte[] sRandMember(byte[] key) {
         return read(key, ByteArrayCodec.INSTANCE, RedisCommands.SRANDMEMBER_SINGLE, key);
     }
 
+    private static final RedisCommand<List<Object>> SRANDMEMBER = new RedisCommand<>("SRANDMEMBER", new ObjectListReplayDecoder<>());
+
     @Override
     public List<byte[]> sRandMember(byte[] key, long count) {
-        return read(key, ByteArrayCodec.INSTANCE, RedisCommands.SRANDMEMBER, key, count);
+        return read(key, ByteArrayCodec.INSTANCE, SRANDMEMBER, key, count);
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -918,9 +918,11 @@ public byte[] sRandMember(byte[] key) {
         return read(key, ByteArrayCodec.INSTANCE, RedisCommands.SRANDMEMBER_SINGLE, key);
     }
 
+    private static final RedisCommand<List<Object>> SRANDMEMBER = new RedisCommand<>("SRANDMEMBER", new ObjectListReplayDecoder<>());
+
     @Override
     public List<byte[]> sRandMember(byte[] key, long count) {
-        return read(key, ByteArrayCodec.INSTANCE, RedisCommands.SRANDMEMBER, key, count);
+        return read(key, ByteArrayCodec.INSTANCE, SRANDMEMBER, key, count);
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -910,9 +910,11 @@ public byte[] sRandMember(byte[] key) {
         return read(key, ByteArrayCodec.INSTANCE, RedisCommands.SRANDMEMBER_SINGLE, key);
     }
 
+    private static final RedisCommand<List<Object>> SRANDMEMBER = new RedisCommand<>("SRANDMEMBER", new ObjectListReplayDecoder<>());
+
     @Override
     public List<byte[]> sRandMember(byte[] key, long count) {
-        return read(key, ByteArrayCodec.INSTANCE, RedisCommands.SRANDMEMBER, key, count);
+        return read(key, ByteArrayCodec.INSTANCE, SRANDMEMBER, key, count);
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -887,9 +887,11 @@ public byte[] sRandMember(byte[] key) {
         return read(key, ByteArrayCodec.INSTANCE, RedisCommands.SRANDMEMBER_SINGLE, key);
     }
 
+    private static final RedisCommand<List<Object>> SRANDMEMBER = new RedisCommand<>("SRANDMEMBER", new ObjectListReplayDecoder<>());
+
     @Override
     public List<byte[]> sRandMember(byte[] key, long count) {
-        return read(key, ByteArrayCodec.INSTANCE, RedisCommands.SRANDMEMBER, key, count);
+        return read(key, ByteArrayCodec.INSTANCE, SRANDMEMBER, key, count);
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-24/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -887,9 +887,11 @@ public byte[] sRandMember(byte[] key) {
         return read(key, ByteArrayCodec.INSTANCE, RedisCommands.SRANDMEMBER_SINGLE, key);
     }
 
+    private static final RedisCommand<List<Object>> SRANDMEMBER = new RedisCommand<>("SRANDMEMBER", new ObjectListReplayDecoder<>());
+
     @Override
     public List<byte[]> sRandMember(byte[] key, long count) {
-        return read(key, ByteArrayCodec.INSTANCE, RedisCommands.SRANDMEMBER, key, count);
+        return read(key, ByteArrayCodec.INSTANCE, SRANDMEMBER, key, count);
     }
 
     @Override

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -331,11 +331,11 @@ public void onMessage(CharSequence channel, AttributeMessage msg) {
     protected RedissonClient buildClient() throws LifecycleException {
         Config config = null;
         try {
-            config = Config.fromJSON(new File(configPath), getClass().getClassLoader());
+            config = Config.fromYAML(new File(configPath), getClass().getClassLoader());
         } catch (IOException e) {
             // trying next format
             try {
-                config = Config.fromYAML(new File(configPath), getClass().getClassLoader());
+                config = Config.fromJSON(new File(configPath), getClass().getClassLoader());
             } catch (IOException e1) {
                 log.error("Can't parse json config " + configPath, e);
                 throw new LifecycleException("Can't parse yaml config " + configPath, e1);

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -331,11 +331,11 @@ public void onMessage(CharSequence channel, AttributeMessage msg) {
     protected RedissonClient buildClient() throws LifecycleException {
         Config config = null;
         try {
-            config = Config.fromJSON(new File(configPath), getClass().getClassLoader());
+            config = Config.fromYAML(new File(configPath), getClass().getClassLoader());
         } catch (IOException e) {
             // trying next format
             try {
-                config = Config.fromYAML(new File(configPath), getClass().getClassLoader());
+                config = Config.fromJSON(new File(configPath), getClass().getClassLoader());
             } catch (IOException e1) {
                 log.error("Can't parse json config " + configPath, e);
                 throw new LifecycleException("Can't parse yaml config " + configPath, e1);

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -331,11 +331,11 @@ public void onMessage(CharSequence channel, AttributeMessage msg) {
     protected RedissonClient buildClient() throws LifecycleException {
         Config config = null;
         try {
-            config = Config.fromJSON(new File(configPath), getClass().getClassLoader());
+            config = Config.fromYAML(new File(configPath), getClass().getClassLoader());
         } catch (IOException e) {
             // trying next format
             try {
-                config = Config.fromYAML(new File(configPath), getClass().getClassLoader());
+                config = Config.fromJSON(new File(configPath), getClass().getClassLoader());
             } catch (IOException e1) {
                 log.error("Can't parse json config " + configPath, e);
                 throw new LifecycleException("Can't parse yaml config " + configPath, e1);

File: redisson/src/main/java/org/redisson/JndiRedissonFactory.java
Patch:
@@ -48,11 +48,11 @@ public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtabl
     protected RedissonClient buildClient(String configPath) throws NamingException {
         Config config = null;
         try {
-            config = Config.fromJSON(new File(configPath), getClass().getClassLoader());
+            config = Config.fromYAML(new File(configPath), getClass().getClassLoader());
         } catch (IOException e) {
             // trying next format
             try {
-                config = Config.fromYAML(new File(configPath), getClass().getClassLoader());
+                config = Config.fromJSON(new File(configPath), getClass().getClassLoader());
             } catch (IOException e1) {
                 NamingException ex = new NamingException("Can't parse yaml config " + configPath);
                 ex.initCause(e1);

File: redisson/src/main/java/org/redisson/connection/MasterSlaveEntry.java
Patch:
@@ -426,10 +426,11 @@ public RFuture<RedisClient> changeMaster(RedisURI address) {
         return future;
     }
     
-    public void changeMaster(InetSocketAddress address, RedisURI uri) {
+    public RFuture<RedisClient> changeMaster(InetSocketAddress address, RedisURI uri) {
         ClientConnectionsEntry oldMaster = masterEntry;
         RFuture<RedisClient> future = setupMasterEntry(address, uri);
         changeMaster(uri, oldMaster, future);
+        return future;
     }
 
 

File: redisson/src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -286,6 +286,7 @@ public void run(Timeout timeout) throws Exception {
                 future.onComplete((res, e) -> {
                     if (e != null) {
                         log.error("Can't update lock " + getName() + " expiration", e);
+                        EXPIRATION_RENEWAL_MAP.remove(getEntryName());
                         return;
                     }
                     

File: redisson/src/main/java/org/redisson/api/RTopicReactive.java
Patch:
@@ -85,7 +85,7 @@ public interface RTopicReactive {
     Mono<Void> removeListener(MessageListener<?> listener);
 
     /**
-     * Returns continues stream of messages.
+     * Returns continues stream of published messages.
      * 
      * @param <M> type of message 
      * @param type - type of message to listen

File: redisson/src/main/java/org/redisson/api/RTopicRx.java
Patch:
@@ -86,7 +86,7 @@ public interface RTopicRx {
     Completable removeListener(MessageListener<?> listener);
     
     /**
-     * Returns continues stream of messages.
+     * Returns continues stream of published messages.
      * 
      * @param <M> - type of message
      * @param type - type of message to listen

File: redisson/src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -286,6 +286,7 @@ public void run(Timeout timeout) throws Exception {
                 future.onComplete((res, e) -> {
                     if (e != null) {
                         log.error("Can't update lock " + getName() + " expiration", e);
+                        EXPIRATION_RENEWAL_MAP.remove(getEntryName());
                         return;
                     }
                     

File: redisson/src/main/java/org/redisson/reactive/RedissonTimeSeriesReactive.java
Patch:
@@ -44,7 +44,7 @@ public Publisher<V> iterator() {
         return Flux.create(new SetReactiveIterator<V>() {
             @Override
             protected RFuture<ListScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
-                return ((RedissonTimeSeries) instance).scanIteratorAsync(instance.getName(), client, nextIterPos, null, 10);
+                return ((RedissonTimeSeries) instance).scanIteratorAsync(instance.getName(), client, nextIterPos, 10);
             }
         });
     }

File: redisson/src/main/java/org/redisson/rx/RedissonTimeSeriesRx.java
Patch:
@@ -43,7 +43,7 @@ public Publisher<V> iterator() {
         return new SetRxIterator<V>() {
             @Override
             protected RFuture<ListScanResult<Object>> scanIterator(RedisClient client, long nextIterPos) {
-                return ((RedissonTimeSeries) instance).scanIteratorAsync(instance.getName(), client, nextIterPos, null, 10);
+                return ((RedissonTimeSeries) instance).scanIteratorAsync(instance.getName(), client, nextIterPos, 10);
             }
         }.create();
     }

File: redisson/src/main/java/org/redisson/RedissonRateLimiter.java
Patch:
@@ -194,6 +194,8 @@ private <T> RFuture<T> tryAcquireAsync(RedisCommand<T> command, Long value) {
                   + "permitsName = KEYS[5];"
               + "end;"
 
+              + "assert(tonumber(rate) >= tonumber(ARGV[1]), 'Requested permits amount could not exceed defined rate'); "
+
               + "local currentValue = redis.call('get', valueName); "
               + "if currentValue ~= false then "
                      + "local expiredValues = redis.call('zrangebyscore', permitsName, 0, tonumber(ARGV[2]) - interval); "
@@ -219,7 +221,6 @@ private <T> RFuture<T> tryAcquireAsync(RedisCommand<T> command, Long value) {
                          + "return nil; "
                      + "end; "
               + "else "
-                     + "assert(tonumber(rate) >= tonumber(ARGV[1]), 'Requested permits amount could not exceed defined rate'); "
                      + "redis.call('set', valueName, rate); "
                      + "redis.call('zadd', permitsName, ARGV[2], struct.pack('fI', ARGV[3], ARGV[1])); "
                      + "redis.call('decrby', valueName, ARGV[1]); "

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -52,7 +52,6 @@
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
-import java.util.concurrent.ExecutorService;
 
 /**
  * Redis protocol command decoder

File: redisson/src/main/java/org/redisson/client/handler/CommandPubSubDecoder.java
Patch:
@@ -37,7 +37,6 @@
 import java.io.IOException;
 import java.util.*;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ExecutorService;
 
 /**
  * Redis Publish Subscribe protocol decoder

File: redisson/src/main/java/org/redisson/client/RedisAskException.java
Patch:
@@ -15,6 +15,8 @@
  */
 package org.redisson.client;
 
+import org.redisson.misc.RedisURI;
+
 /**
  * 
  * @author Nikita Koksharov
@@ -24,7 +26,7 @@ public class RedisAskException extends RedisRedirectException {
 
     private static final long serialVersionUID = -6969734163155547631L;
 
-    public RedisAskException(int slot, String url) {
+    public RedisAskException(int slot, RedisURI url) {
         super(slot, url);
     }
 

File: redisson/src/main/java/org/redisson/client/RedisMovedException.java
Patch:
@@ -15,6 +15,8 @@
  */
 package org.redisson.client;
 
+import org.redisson.misc.RedisURI;
+
 /**
  * 
  * @author Nikita Koksharov
@@ -24,7 +26,7 @@ public class RedisMovedException extends RedisRedirectException {
 
     private static final long serialVersionUID = -6969734163155547631L;
 
-    public RedisMovedException(int slot, String url) {
+    public RedisMovedException(int slot, RedisURI url) {
         super(slot, url);
     }
 

File: redisson/src/main/java/org/redisson/client/RedisRedirectException.java
Patch:
@@ -29,9 +29,9 @@ public class RedisRedirectException extends RedisException {
     private final int slot;
     private final RedisURI url;
 
-    public RedisRedirectException(int slot, String url) {
+    public RedisRedirectException(int slot, RedisURI url) {
         this.slot = slot;
-        this.url = new RedisURI("redis://" + url);
+        this.url = url;
     }
 
     public int getSlot() {

File: redisson/src/main/java/org/redisson/client/handler/RedisChannelInitializer.java
Patch:
@@ -95,9 +95,9 @@ protected void initChannel(Channel ch) throws Exception {
         }
         
         if (type == Type.PLAIN) {
-            ch.pipeline().addLast(new CommandDecoder(config.getExecutor()));
+            ch.pipeline().addLast(new CommandDecoder(config.getAddress().getScheme()));
         } else {
-            ch.pipeline().addLast(new CommandPubSubDecoder(config.getExecutor(), config.isKeepPubSubOrder()));
+            ch.pipeline().addLast(new CommandPubSubDecoder(config));
         }
 
         ch.pipeline().addLast(new ErrorsLoggingHandler());

File: redisson/src/test/java/org/redisson/BaseReactiveTest.java
Patch:
@@ -32,7 +32,7 @@ public static void afterClass() throws InterruptedException {
 
     @Before
     public void before() throws IOException, InterruptedException {
-        redisson.getKeys().flushall();
+        sync(redisson.getKeys().flushall());
     }
 
     public static <V> Iterable<V> sync(RScoredSortedSetReactive<V> list) {

File: redisson/src/main/java/org/redisson/config/Config.java
Patch:
@@ -703,9 +703,6 @@ public String toYAML() throws IOException {
      * Most Redisson methods are Lua-script based and this setting turned
      * on could increase speed of such methods execution and save network traffic.
      * <p>
-     * NOTE: <code>readMode</code> option is not taken into account for such calls 
-     * as Redis slave redirects execution of cached Lua-script on Redis master node. 
-     * <p>
      * Default is <code>false</code>.
      * 
      * @param useScriptCache - <code>true</code> if Lua-script caching is required, <code>false</code> otherwise.

File: redisson/src/test/java/org/redisson/executor/RedissonExecutorServiceTest.java
Patch:
@@ -44,9 +44,7 @@ public void before() throws IOException, InterruptedException {
     }
 
     @After
-    @Override
     public void after() throws InterruptedException {
-        super.after();
         node.shutdown();
     }
 

File: redisson/src/test/java/org/redisson/executor/RedissonScheduledExecutorServiceTest.java
Patch:
@@ -44,9 +44,7 @@ public void before() throws IOException, InterruptedException {
     }
 
     @After
-    @Override
     public void after() throws InterruptedException {
-        super.after();
         node.shutdown();
     }
     

File: redisson/src/test/java/org/redisson/spring/support/SpringNamespaceObjectTest.java
Patch:
@@ -115,10 +115,10 @@ protected boolean flushBetweenTests() {
     public static void startContext() {
         TestREntity entity = new TestREntity("live-object");
         entity.setValue("1");
-        defaultRedisson.getLiveObjectService().merge(entity);
+        redisson.getLiveObjectService().merge(entity);
         entity = new TestREntity("live-object-ext");
         entity.setValue("1");
-        defaultRedisson.getLiveObjectService().merge(entity);
+        redisson.getLiveObjectService().merge(entity);
         
         System.setProperty("redisAddress", RedisRunner.getDefaultRedisServerBindAddressAndPort());
         context = new ClassPathXmlApplicationContext("classpath:org/redisson/spring/support/redisson_objects.xml");

File: redisson/src/main/java/org/redisson/api/RListMultimapCacheRx.java
Patch:
@@ -18,7 +18,7 @@
 /**
  * Rx-ified version of {@link RListMultimapCache}.
  *
- * @author Nikita Koksharov
+ * @author Marnix Kammer
  *
  * @param <K> key type
  * @param <V> value type

File: redisson/src/main/java/org/redisson/api/RMultimapCacheRx.java
Patch:
@@ -22,7 +22,7 @@
 /**
  * Rx-ified version of {@link RMultimapCache}.
  *
- * @author Nikita Koksharov
+ * @author Marnix Kammer
  *
  * @param <K> key type
  * @param <V> value type

File: redisson/src/main/java/org/redisson/api/RSetMultimapCacheRx.java
Patch:
@@ -18,7 +18,7 @@
 /**
  * Rx-ified version of {@link RSetMultimapCache}.
  *
- * @author Nikita Koksharov
+ * @author Marnix Kammer
  *
  * @param <K> key type
  * @param <V> value type

File: redisson/src/main/java/org/redisson/api/RedissonRxClient.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.redisson.api;
 
-import org.checkerframework.checker.units.qual.K;
 import org.redisson.client.codec.Codec;
 import org.redisson.config.Config;
 

File: redisson/src/main/java/org/redisson/rx/RedissonListMultimapCacheRx.java
Patch:
@@ -21,7 +21,7 @@
 
 /**
  *
- * @author Nikita Koksharov
+ * @author Marnix Kammer
  *
  * @param <K> key type
  * @param <V> value type

File: redisson/src/main/java/org/redisson/rx/RedissonSetMultimapCacheRx.java
Patch:
@@ -22,7 +22,7 @@
 
 /**
  *
- * @author Nikita Koksharov
+ * @author Marnix Kammer
  *
  * @param <K> key type
  * @param <V> value type

File: redisson/src/main/java/org/redisson/spring/session/ReactiveRedissonSessionRepository.java
Patch:
@@ -19,7 +19,6 @@
 import org.redisson.spring.session.RedissonSessionRepository.RedissonSession;
 import org.springframework.context.ApplicationEventPublisher;
 import org.springframework.session.ReactiveSessionRepository;
-
 import reactor.core.publisher.Mono;
 
 /**

File: redisson/src/main/java/org/redisson/spring/session/config/RedissonHttpSessionConfiguration.java
Patch:
@@ -15,8 +15,6 @@
  */
 package org.redisson.spring.session.config;
 
-import java.util.Map;
-
 import org.redisson.api.RedissonClient;
 import org.redisson.spring.session.RedissonSessionRepository;
 import org.springframework.context.ApplicationEventPublisher;
@@ -26,7 +24,8 @@
 import org.springframework.core.annotation.AnnotationAttributes;
 import org.springframework.core.type.AnnotationMetadata;
 import org.springframework.session.config.annotation.web.http.SpringHttpSessionConfiguration;
-import org.springframework.session.web.http.SessionRepositoryFilter;
+
+import java.util.Map;
 
 /**
  * Deprecated. Use spring-session implementation based on Redisson Redis Data module

File: redisson/src/main/java/org/redisson/spring/session/config/RedissonWebSessionConfiguration.java
Patch:
@@ -15,8 +15,6 @@
  */
 package org.redisson.spring.session.config;
 
-import java.util.Map;
-
 import org.redisson.api.RedissonClient;
 import org.redisson.spring.session.ReactiveRedissonSessionRepository;
 import org.springframework.context.ApplicationEventPublisher;
@@ -26,7 +24,8 @@
 import org.springframework.core.annotation.AnnotationAttributes;
 import org.springframework.core.type.AnnotationMetadata;
 import org.springframework.session.config.annotation.web.server.SpringWebSessionConfiguration;
-import org.springframework.web.server.session.WebSessionManager;
+
+import java.util.Map;
 
 /**
  * Deprecated. Use spring-session implementation based on Redisson Redis Data module

File: redisson/src/main/java/org/redisson/RedissonSetMultimapCache.java
Patch:
@@ -39,15 +39,15 @@ public class RedissonSetMultimapCache<K, V> extends RedissonSetMultimap<K, V> im
 
     private final RedissonMultimapCache<K> baseCache;
     
-    RedissonSetMultimapCache(EvictionScheduler evictionScheduler, CommandAsyncExecutor connectionManager, String name) {
+    public RedissonSetMultimapCache(EvictionScheduler evictionScheduler, CommandAsyncExecutor connectionManager, String name) {
         super(connectionManager, name);
         if (evictionScheduler != null) {
             evictionScheduler.scheduleCleanMultimap(name, getTimeoutSetName());
         }
         baseCache = new RedissonMultimapCache<K>(connectionManager, this, getTimeoutSetName(), prefix);
     }
 
-    RedissonSetMultimapCache(EvictionScheduler evictionScheduler, Codec codec, CommandAsyncExecutor connectionManager, String name) {
+    public RedissonSetMultimapCache(EvictionScheduler evictionScheduler, Codec codec, CommandAsyncExecutor connectionManager, String name) {
         super(codec, connectionManager, name);
         if (evictionScheduler != null) {
             evictionScheduler.scheduleCleanMultimap(name, getTimeoutSetName());

File: redisson/src/main/java/org/redisson/api/LocalCachedMapOptions.java
Patch:
@@ -43,7 +43,7 @@ public enum ReconnectionStrategy {
         NONE,
         
         /**
-         * Clear local cache if map instance has been disconnected for a while.
+         * Clear local cache if map instance disconnected.
          */
         CLEAR,
         

File: redisson-spring-boot-starter/src/test/java/org/redisson/spring/starter/RedissonAutoConfigurationTest.java
Patch:
@@ -17,7 +17,7 @@
 @SpringBootTest(
         classes = RedissonApplication.class,
         properties = {
-            "spring.redis.redisson.config=classpath:redisson.yaml",
+            "spring.redis.redisson.file=classpath:redisson.yaml",
             "spring.redis.timeout=10000"
         })
 public class RedissonAutoConfigurationTest {

File: redisson-spring-boot-starter/src/test/java/org/redisson/spring/starter/RedissonCacheManagerAutoConfigurationTest.java
Patch:
@@ -13,7 +13,7 @@
 @SpringBootTest(
         classes = RedissonApplication.class,
         properties = {
-            "spring.redis.redisson.config=classpath:redisson.yaml",
+            "spring.redis.redisson.file=classpath:redisson.yaml",
             "spring.redis.timeout=10000",
             "spring.cache.type=redis",
         })

File: redisson-spring-boot-starter/src/test/java/org/redisson/spring/starter/RedissonSessionManagerAutoConfigurationTest.java
Patch:
@@ -24,7 +24,7 @@
         classes = RedissonRestApplication.class,
         webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
         properties = {
-            "spring.redis.redisson.config=classpath:redisson.yaml",
+            "spring.redis.redisson.file=classpath:redisson.yaml",
             "spring.session.store-type=redis",
             "spring.session.timeout.seconds=900",
         })

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -429,6 +429,8 @@ private ClassBody getClassBody(Object task) {
                 try {
                     ObjectOutput oo = new ObjectOutputStream(os);
                     oo.writeObject(task);
+                    oo.flush();
+                    oo.close();
                 } catch (Exception e) {
                     throw new IllegalArgumentException("Unable to serialize lambda", e);
                 }

File: redisson-spring-boot-starter/src/main/java/org/redisson/spring/starter/RedissonAutoConfiguration.java
Patch:
@@ -199,7 +199,7 @@ private String[] convert(List<String> nodesObject) {
     }
 
     private InputStream getConfigStream() throws IOException {
-        Resource resource = ctx.getResource(redissonProperties.getConfig());
+        Resource resource = ctx.getResource(redissonProperties.getFile());
         InputStream is = resource.getInputStream();
         return is;
     }

File: redisson/src/main/java/org/redisson/RedissonObject.java
Patch:
@@ -49,6 +49,9 @@ public RedissonObject(Codec codec, CommandAsyncExecutor commandExecutor, String
         this.codec = codec;
         this.name = name;
         this.commandExecutor = commandExecutor;
+        if (name == null) {
+            throw new NullPointerException("name can't be null");
+        }
     }
 
     public RedissonObject(CommandAsyncExecutor commandExecutor, String name) {

File: redisson/src/main/java/org/redisson/command/RedisCommonBatchExecutor.java
Patch:
@@ -51,7 +51,7 @@ public class RedisCommonBatchExecutor extends RedisExecutor<Object, Void> {
     
     public RedisCommonBatchExecutor(NodeSource source, RPromise<Void> mainPromise, 
             ConnectionManager connectionManager, BatchOptions options, Entry entry, AtomicInteger slots) {
-        super(entry.isReadOnlyMode(), source, null, null, null, mainPromise, true, connectionManager, null);
+        super(entry.isReadOnlyMode(), source, null, null, null, mainPromise, false, connectionManager, null);
         this.options = options;
         this.entry = entry;
         this.slots = slots;

File: redisson/src/main/java/org/redisson/RedissonBitSet.java
Patch:
@@ -205,8 +205,8 @@ public void set(long fromIndex, long toIndex) {
     }
 
     @Override
-    public void set(long bitIndex, boolean value) {
-        get(setAsync(bitIndex, value));
+    public boolean set(long bitIndex, boolean value) {
+        return get(setAsync(bitIndex, value));
     }
 
     @Override

File: redisson/src/test/java/org/redisson/RedissonBitSetTest.java
Patch:
@@ -114,8 +114,8 @@ public void testSetGet() {
         assertThat(bitset.cardinality()).isZero();
         assertThat(bitset.size()).isZero();
 
-        bitset.set(10, true);
-        bitset.set(31, true);
+        assertThat(bitset.set(10, true)).isFalse();
+        assertThat(bitset.set(31, true)).isFalse();
         assertThat(bitset.get(0)).isFalse();
         assertThat(bitset.get(31)).isTrue();
         assertThat(bitset.get(10)).isTrue();

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -328,7 +328,7 @@ public interface RedisCommands {
     RedisStrictCommand<Long> DEL = new RedisStrictCommand<Long>("DEL");
     RedisStrictCommand<Long> DBSIZE = new RedisStrictCommand<Long>("DBSIZE");
     RedisStrictCommand<Boolean> DEL_BOOL = new RedisStrictCommand<Boolean>("DEL", new BooleanNullSafeReplayConvertor());
-    RedisStrictCommand<Boolean> DEL_OBJECTS = new RedisStrictCommand<Boolean>("DEL", new BooleanNullSafeReplayConvertor());
+    RedisStrictCommand<Boolean> DEL_OBJECTS = new RedisStrictCommand<Boolean>("DEL", new BooleanAmountReplayConvertor());
     RedisStrictCommand<Void> DEL_VOID = new RedisStrictCommand<Void>("DEL", new VoidReplayConvertor());
     
     RedisStrictCommand<Long> UNLINK = new RedisStrictCommand<Long>("UNLINK");

File: redisson/src/main/java/org/redisson/liveobject/core/AccessorInterceptor.java
Patch:
@@ -188,7 +188,8 @@ private void removeIndex(RMap<String, Object> liveMap, Object me, Field field) {
             RScoredSortedSetAsync<Object> set = new RedissonScoredSortedSet<>(namingScheme.getCodec(), ce, indexName, null);
             set.removeAsync(((RLiveObject) me).getLiveObjectId());
         } else {
-            if (ClassUtils.isAnnotationPresent(field.getType(), REntity.class)) {
+            if (ClassUtils.isAnnotationPresent(field.getType(), REntity.class)
+                    || connectionManager.isClusterMode()) {
                 Object value = liveMap.remove(field.getName());
                 RMultimapAsync<Object, Object> map = new RedissonSetMultimap<>(namingScheme.getCodec(), ce, indexName);
                 map.removeAsync(((RLiveObject) value).getLiveObjectId(), ((RLiveObject) me).getLiveObjectId());

File: redisson/src/main/java/org/redisson/config/BaseConfig.java
Patch:
@@ -86,7 +86,7 @@ public class BaseConfig<T extends BaseConfig<T>> {
     
     private String sslKeystorePassword;
 
-    private int pingConnectionInterval;
+    private int pingConnectionInterval = 30000;
 
     private boolean keepAlive;
     
@@ -388,7 +388,7 @@ public int getPingConnectionInterval() {
      * Defines PING command sending interval per connection to Redis.
      * <code>0</code> means disable.
      * <p>
-     * Default is <code>0</code>
+     * Default is <code>30000</code>
      * 
      * @param pingConnectionInterval - time in milliseconds
      * @return config

File: redisson/src/test/java/org/redisson/RedissonRateLimiterTest.java
Patch:
@@ -204,7 +204,7 @@ public void run() {
         for (Long value : queue) {
             if (count % 10 == 0) {
                 if (start > 0) {
-                    assertThat(value - start).isGreaterThan(990);
+                    assertThat(value - start).isGreaterThan(980);
                 }
                 start = value;
             }

File: redisson/src/main/java/org/redisson/RedissonKeys.java
Patch:
@@ -144,7 +144,7 @@ public RFuture<ListScanResult<Object>> scanIteratorAsync(RedisClient client, Mas
 
     public RFuture<ListScanResult<Object>> scanIteratorAsync(RedisClient client, MasterSlaveEntry entry, long startPos,
             String pattern, int count) {
-        return scanIteratorAsync(client, entry, RedisCommands.SCAN, startPos, "COUNT", count);
+        return scanIteratorAsync(client, entry, RedisCommands.SCAN, startPos, pattern, count);
     }
 
     private <T> Iterator<T> createKeysIterator(MasterSlaveEntry entry, RedisCommand<?> command, String pattern, int count) {

File: redisson/src/test/java/org/redisson/RedissonKeysReactiveTest.java
Patch:
@@ -30,10 +30,13 @@ public void testKeysIterablePattern() {
         sync(redisson.getBucket("test12").set("someValue"));
 
         Iterator<String> iterator = toIterator(redisson.getKeys().getKeysByPattern("test?"));
+        int size = 0;
         for (; iterator.hasNext();) {
             String key = iterator.next();
             assertThat(key).isIn("test1", "test2");
+            size += 1;
         }
+        assertThat(size).isEqualTo(2);
     }
 
     @Test

File: redisson/src/main/java/org/redisson/RedissonKeys.java
Patch:
@@ -144,7 +144,7 @@ public RFuture<ListScanResult<Object>> scanIteratorAsync(RedisClient client, Mas
 
     public RFuture<ListScanResult<Object>> scanIteratorAsync(RedisClient client, MasterSlaveEntry entry, long startPos,
             String pattern, int count) {
-        return scanIteratorAsync(client, entry, RedisCommands.SCAN, startPos, "COUNT", count);
+        return scanIteratorAsync(client, entry, RedisCommands.SCAN, startPos, pattern, count);
     }
 
     private <T> Iterator<T> createKeysIterator(MasterSlaveEntry entry, RedisCommand<?> command, String pattern, int count) {

File: redisson/src/test/java/org/redisson/RedissonKeysReactiveTest.java
Patch:
@@ -30,10 +30,13 @@ public void testKeysIterablePattern() {
         sync(redisson.getBucket("test12").set("someValue"));
 
         Iterator<String> iterator = toIterator(redisson.getKeys().getKeysByPattern("test?"));
+        int size = 0;
         for (; iterator.hasNext();) {
             String key = iterator.next();
             assertThat(key).isIn("test1", "test2");
+            size += 1;
         }
+        assertThat(size).isEqualTo(2);
     }
 
     @Test

File: redisson/src/main/java/org/redisson/liveobject/core/LiveObjectInterceptor.java
Patch:
@@ -126,7 +126,7 @@ public Object intercept(
                 ce = new CommandBatchService(connectionManager);
             }
 
-            Object idd = ((RLiveObject)me).getLiveObjectId();
+            Object idd = ((RLiveObject) me).getLiveObjectId();
             RFuture<Long> deleteFuture = service.delete(idd, me.getClass().getSuperclass(), namingScheme, ce);
             ce.execute();
             

File: redisson/src/test/java/org/redisson/RedissonLiveObjectServiceTest.java
Patch:
@@ -1203,7 +1203,7 @@ public void testRemoveById() {
         ts.setCode("CODE");
         TestClass persisted = service.persist(ts);
         assertTrue(service.isExists(persisted));
-        service.delete(TestClass.class, new ObjectId(100));
+        assertThat(service.delete(TestClass.class, new ObjectId(100))).isEqualTo(1);
         assertFalse(service.isExists(persisted));
     }
 

File: redisson/src/main/java/org/redisson/RedissonTopic.java
Patch:
@@ -97,7 +97,7 @@ public int addListener(StatusListener listener) {
 
     @Override
     public <M> int addListener(Class<M> type, MessageListener<? extends M> listener) {
-        RFuture<Integer> future = addListenerAsync(type, (MessageListener<M>)listener);
+        RFuture<Integer> future = addListenerAsync(type, (MessageListener<M>) listener);
         commandExecutor.syncSubscription(future);
         return future.getNow();
     }
@@ -119,7 +119,7 @@ protected RFuture<Integer> addListenerAsync(RedisPubSubListener<?> pubSubListene
         RPromise<Integer> result = new RedissonPromise<>();
         result.onComplete((res, e) -> {
             if (e != null) {
-                ((RPromise<PubSubConnectionEntry>)future).tryFailure(e);
+                ((RPromise<PubSubConnectionEntry>) future).tryFailure(e);
             }
         });
         future.onComplete((res, e) -> {

File: redisson/src/main/java/org/redisson/RedissonPatternTopic.java
Patch:
@@ -164,7 +164,7 @@ public void removeAllListeners() {
             return;
         }
 
-        if (entry.removeAllListeners(channelName)) {
+        if (entry.hasListeners(channelName)) {
             subscribeService.punsubscribe(channelName, semaphore);
         } else {
             semaphore.release();

File: redisson/src/main/java/org/redisson/RedissonTopic.java
Patch:
@@ -133,7 +133,7 @@ public void removeAllListeners() {
             return;
         }
 
-        if (entry.removeAllListeners(channelName)) {
+        if (entry.hasListeners(channelName)) {
             subscribeService.unsubscribe(channelName, semaphore).syncUninterruptibly();
         } else {
             semaphore.release();

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -445,6 +445,7 @@ public interface RedisCommands {
 
     RedisStrictCommand<Long> PUBLISH = new RedisStrictCommand<Long>("PUBLISH");
     RedisCommand<Long> PUBSUB_NUMSUB = new RedisCommand<Long>("PUBSUB", "NUMSUB", new ListObjectDecoder<Long>(1));
+    RedisCommand<List<String>> PUBSUB_CHANNELS = new RedisStrictCommand<>("PUBSUB", "CHANNELS", new StringListReplayDecoder());
 
     RedisCommand<Object> SUBSCRIBE = new RedisCommand<Object>("SUBSCRIBE", new PubSubStatusDecoder());
     RedisCommand<Object> UNSUBSCRIBE = new RedisCommand<Object>("UNSUBSCRIBE", new PubSubStatusDecoder());

File: redisson/src/main/java/org/redisson/client/handler/PingConnectionHandler.java
Patch:
@@ -78,7 +78,7 @@ public void run(Timeout timeout) throws Exception {
                 if (future != null
                         && (future.cancel(false) || !future.isSuccess())) {
                     ctx.channel().close();
-                    if (future.cause() != null) {
+                    if (future.cause() != null && !future.isCancelled()) {
                         log.error("Unable to send PING command over channel: " + ctx.channel(), future.cause());
                     }
                     log.debug("channel: {} closed due to PING response timeout set in {} ms", ctx.channel(), config.getPingConnectionInterval());

File: redisson/src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -157,7 +157,7 @@ public V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> rem
                 newValue = remappingFunction.apply(oldValue, value);
             }
 
-            if(newValue == null) {
+            if (newValue == null) {
                 fastRemove(key);
             } else {
                 fastPut(key, newValue);

File: redisson/src/test/java/org/redisson/RedissonSetTest.java
Patch:
@@ -824,7 +824,7 @@ public void testRemoveAll() {
 
         Assert.assertTrue(list.removeAll(Arrays.asList(4)));
 
-        assertThat(list).containsExactly(1, 5);
+        assertThat(list).containsExactlyInAnyOrder(1, 5);
 
         Assert.assertTrue(list.removeAll(Arrays.asList(1, 5, 1, 5)));
 

File: redisson/src/main/java/org/redisson/liveobject/core/LiveObjectInterceptor.java
Patch:
@@ -136,7 +136,7 @@ public Object intercept(
 
 
     private String getMapKey(Object id) {
-        return namingScheme.getName(originalClass, idFieldType, idFieldName, id);
+        return namingScheme.getName(originalClass, id);
     }
 
 }

File: redisson/src/main/java/org/redisson/liveobject/resolver/NamingScheme.java
Patch:
@@ -24,13 +24,13 @@
  */
 public interface NamingScheme {
 
-    String getNamePattern(Class<?> entityClass, Class<?> idFieldClass, String idFieldName);
+    String getNamePattern(Class<?> entityClass);
 
-    String getName(Class<?> entityClass, Class<?> idFieldClass, String idFieldName, Object idValue);
+    String getName(Class<?> entityClass, Object idValue);
     
     String getIndexName(Class<?> entityClass, String fieldName);
     
-    String getFieldReferenceName(Class<?> entityClass, Object idValue, Class<?> fieldClass, String fieldName, Object fieldValue);
+    String getFieldReferenceName(Class<?> entityClass, Object idValue, Class<?> fieldClass, String fieldName);
 
     Object resolveId(String name);
     

File: redisson/src/test/java/org/redisson/transaction/RedissonTransactionalBucketsTest.java
Patch:
@@ -63,7 +63,7 @@ public void testTrySet() {
         bbs1.put("test1", "10");
         bbs1.put("test2", "20");
         assertThat(buckets.trySet(bbs1)).isFalse();
-        assertThat(buckets.delete("test1", "test2")).isEqualTo(2);
+        assertThat(redisson.getKeys().delete("test1", "test2")).isEqualTo(2);
         Map<String, Object> bbs2 = new LinkedHashMap<>();
         bbs2.put("test1", "11");
         bbs2.put("test2", "22");

File: redisson/src/main/java/org/redisson/RedissonRateLimiter.java
Patch:
@@ -245,7 +245,7 @@ public RFuture<Boolean> trySetRateAsync(RateType type, long rate, long rateInter
 
     @Override
     public void setRate(RateType type, long rate, long rateInterval, RateIntervalUnit unit) {
-        setRateAsync(type, rate, rateInterval, unit);
+        get(setRateAsync(type, rate, rateInterval, unit));
     }
 
     @Override
@@ -319,7 +319,7 @@ public RFuture<Long> availablePermitsAsync() {
                      + "local expiredValues = redis.call('zrangebyscore', permitsName, 0, tonumber(ARGV[1]) - interval); "
                      + "local released = 0; "
                      + "for i, v in ipairs(expiredValues) do "
-                          + "local random, permits = struct.unpack('dI', v);"
+                          + "local random, permits = struct.unpack('fI', v);"
                           + "released = released + permits;"
                      + "end; "
 

File: redisson/src/test/java/org/redisson/RedissonTransferQueueTest.java
Patch:
@@ -63,7 +63,7 @@ public void testTransfer() throws InterruptedException, ExecutionException {
                 long time = System.currentTimeMillis();
                 queue.transfer(3);
                 assertThat(takeExecuted.get()).isTrue();
-                assertThat(System.currentTimeMillis() - time).isGreaterThan(2950);
+                assertThat(System.currentTimeMillis() - time).isGreaterThan(2850);
             } catch (InterruptedException e) {
                 Thread.currentThread().interrupt();
             }

File: redisson/src/test/java/org/redisson/rx/RedissonBlockingDequeRxTest.java
Patch:
@@ -51,7 +51,7 @@ public void testPollLastAndOfferFirstTo() throws InterruptedException {
         RBlockingDequeRx<String> blockingDeque = redisson.getBlockingDeque("blocking_deque");
         long start = System.currentTimeMillis();
         String redisTask = sync(blockingDeque.pollLastAndOfferFirstTo("deque", 1, TimeUnit.SECONDS));
-        assertThat(System.currentTimeMillis() - start).isBetween(950L, 1110L);
+        assertThat(System.currentTimeMillis() - start).isBetween(950L, 1150L);
         assertThat(redisTask).isNull();
     }
     

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/RedissonConnectionFactory.java
Patch:
@@ -18,6 +18,7 @@
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.redisson.Redisson;
+import org.redisson.RedissonKeys;
 import org.redisson.api.RedissonClient;
 import org.redisson.client.RedisClient;
 import org.redisson.client.protocol.RedisCommands;
@@ -107,7 +108,7 @@ public RedisSentinelConnection getSentinelConnection() {
             throw new InvalidDataAccessResourceUsageException("Redisson is not in Sentinel mode");
         }
         
-        SentinelConnectionManager manager = ((SentinelConnectionManager)((Redisson)redisson).getConnectionManager());
+        SentinelConnectionManager manager = ((SentinelConnectionManager)((RedissonKeys)redisson.getKeys()).getConnectionManager());
         for (RedisClient client : manager.getSentinels()) {
             org.redisson.client.RedisConnection connection = client.connect();
             try {

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/RedissonConnectionFactory.java
Patch:
@@ -18,6 +18,7 @@
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.redisson.Redisson;
+import org.redisson.RedissonKeys;
 import org.redisson.api.RedissonClient;
 import org.redisson.client.RedisClient;
 import org.redisson.client.protocol.RedisCommands;
@@ -116,7 +117,7 @@ public RedisSentinelConnection getSentinelConnection() {
             throw new InvalidDataAccessResourceUsageException("Redisson is not in Sentinel mode");
         }
         
-        SentinelConnectionManager manager = ((SentinelConnectionManager)((Redisson)redisson).getConnectionManager());
+        SentinelConnectionManager manager = ((SentinelConnectionManager)((RedissonKeys)redisson.getKeys()).getConnectionManager());
         for (RedisClient client : manager.getSentinels()) {
             org.redisson.client.RedisConnection connection = client.connect();
             try {

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/RedissonConnectionFactory.java
Patch:
@@ -18,6 +18,7 @@
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.redisson.Redisson;
+import org.redisson.RedissonKeys;
 import org.redisson.api.RedissonClient;
 import org.redisson.client.RedisClient;
 import org.redisson.client.protocol.RedisCommands;
@@ -123,7 +124,7 @@ public RedisSentinelConnection getSentinelConnection() {
             throw new InvalidDataAccessResourceUsageException("Redisson is not in Sentinel mode");
         }
         
-        SentinelConnectionManager manager = ((SentinelConnectionManager)((Redisson)redisson).getConnectionManager());
+        SentinelConnectionManager manager = ((SentinelConnectionManager)((RedissonKeys)redisson.getKeys()).getConnectionManager());
         for (RedisClient client : manager.getSentinels()) {
             org.redisson.client.RedisConnection connection = client.connect();
             try {

File: redisson/src/main/java/org/redisson/RedissonRateLimiter.java
Patch:
@@ -254,7 +254,7 @@ public RFuture<Void> setRateAsync(RateType type, long rate, long rateInterval, R
                 "redis.call('hset', KEYS[1], 'rate', ARGV[1]);"
                         + "redis.call('hset', KEYS[1], 'interval', ARGV[2]);"
                         + "redis.call('hset', KEYS[1], 'type', ARGV[3]);"
-                        + "return redis.call('del', KEYS[2], KEYS[3]);",
+                        + "redis.call('del', KEYS[2], KEYS[3]);",
                 Arrays.asList(getName(), getValueName(), getPermitsName()), rate, unit.toMillis(rateInterval), type.ordinal());
     }
     

File: redisson/src/main/java/org/redisson/api/RRateLimiterReactive.java
Patch:
@@ -46,10 +46,9 @@ public interface RRateLimiterReactive extends RExpirableReactive {
      * @param rate - rate
      * @param rateInterval - rate time interval
      * @param rateIntervalUnit - rate time interval unit
-     * @return {@code true} if rate was set and {@code false}
-     *         otherwise
+     *
      */
-    Mono<Boolean> setRate(RateType mode, long rate, long rateInterval, RateIntervalUnit rateIntervalUnit);
+    Mono<Void> setRate(RateType mode, long rate, long rateInterval, RateIntervalUnit rateIntervalUnit);
 
     /**
      * Acquires a permit only if one is available at the

File: redisson/src/main/java/org/redisson/api/RRateLimiterRx.java
Patch:
@@ -47,10 +47,9 @@ public interface RRateLimiterRx extends RExpirableRx {
      * @param rate - rate
      * @param rateInterval - rate time interval
      * @param rateIntervalUnit - rate time interval unit
-     * @return {@code true} if rate was set and {@code false}
-     *         otherwise
+     *
      */
-    Single<Boolean> setRate(RateType mode, long rate, long rateInterval, RateIntervalUnit rateIntervalUnit);
+    Single<Void> setRate(RateType mode, long rate, long rateInterval, RateIntervalUnit rateIntervalUnit);
 
     /**
      * Acquires a permit only if one is available at the

File: redisson/src/main/java/org/redisson/api/RRateLimiter.java
Patch:
@@ -44,10 +44,8 @@ public interface RRateLimiter extends RRateLimiterAsync, RExpirable {
      * @param rate - rate
      * @param rateInterval - rate time interval
      * @param rateIntervalUnit - rate time interval unit
-     * @return {@code true} if rate was set and {@code false}
-     *         otherwise
      */
-    boolean setRate(RateType mode, long rate, long rateInterval, RateIntervalUnit rateIntervalUnit);
+    void setRate(RateType mode, long rate, long rateInterval, RateIntervalUnit rateIntervalUnit);
     
     /**
      * Acquires a permit only if one is available at the

File: redisson/src/main/java/org/redisson/api/RRateLimiterAsync.java
Patch:
@@ -155,7 +155,7 @@ public interface RRateLimiterAsync extends RExpirableAsync {
      * @return {@code true} if rate was set and {@code false}
      *         otherwise
      */
-    RFuture<Boolean> setRateAsync(RateType mode, long rate, long rateInterval, RateIntervalUnit rateIntervalUnit);
+    RFuture<Void> setRateAsync(RateType mode, long rate, long rateInterval, RateIntervalUnit rateIntervalUnit);
 
     /**
      * Returns current configuration of this RateLimiter object.

File: redisson/src/test/java/org/redisson/RedissonSetTest.java
Patch:
@@ -528,9 +528,9 @@ public void testClusteredIterator() throws FailedToStartRedisException, IOExcept
         .setLoadBalancer(new RandomLoadBalancer())
         .addNodeAddress(process.getNodes().stream().findAny().get().getRedisServerAddressAndPort());
         RedissonClient redisson = Redisson.create(config);
-        
+
         int size = 10000;
-        RSet<String> set = redisson.getSet("test");
+        RSet<String> set = redisson.getSet("{test");
         for (int i = 0; i < size; i++) {
             set.add("" + i);
         }
@@ -541,7 +541,7 @@ public void testClusteredIterator() throws FailedToStartRedisException, IOExcept
         }
         
         assertThat(keys).hasSize(size);
-        
+
         redisson.shutdown();
         process.shutdown();
     }

File: redisson/src/main/java/org/redisson/RedissonScoredSortedSet.java
Patch:
@@ -232,7 +232,7 @@ public RFuture<List<Integer>> addAndGetRevRankAsync(Map<? extends V, Double> map
             params.add(BigDecimal.valueOf(t.getValue()).toPlainString());
         }
 
-        return commandExecutor.evalReadAsync((String) null, IntegerCodec.INSTANCE, RedisCommands.EVAL_INT_LIST,
+        return commandExecutor.evalWriteAsync((String) null, IntegerCodec.INSTANCE, RedisCommands.EVAL_INT_LIST,
                     "local r = {} " +
                     "for i, v in ipairs(ARGV) do " +
                         "if i % 2 == 0 then " +

File: redisson/src/test/java/org/redisson/RedissonSetTest.java
Patch:
@@ -528,9 +528,9 @@ public void testClusteredIterator() throws FailedToStartRedisException, IOExcept
         .setLoadBalancer(new RandomLoadBalancer())
         .addNodeAddress(process.getNodes().stream().findAny().get().getRedisServerAddressAndPort());
         RedissonClient redisson = Redisson.create(config);
-        
+
         int size = 10000;
-        RSet<String> set = redisson.getSet("test");
+        RSet<String> set = redisson.getSet("{test");
         for (int i = 0; i < size; i++) {
             set.add("" + i);
         }
@@ -541,7 +541,7 @@ public void testClusteredIterator() throws FailedToStartRedisException, IOExcept
         }
         
         assertThat(keys).hasSize(size);
-        
+
         redisson.shutdown();
         process.shutdown();
     }

File: redisson/src/main/java/org/redisson/RedissonScoredSortedSet.java
Patch:
@@ -409,7 +409,7 @@ public Double getScore(V o) {
     }
 
     @Override
-    public Collection<Double> getAllScore(List<V> keys) {
+    public List<Double> getAllScore(List<V> keys) {
         return get(getAllScoreAsync(keys));
     }
 
@@ -419,7 +419,7 @@ public RFuture<Double> getScoreAsync(V o) {
     }
 
     @Override
-    public RFuture<Collection<Double>> getAllScoreAsync(Collection<V> elements) {
+    public RFuture<List<Double>> getAllScoreAsync(Collection<V> elements) {
         return commandExecutor.evalReadAsync((String) null, DoubleCodec.INSTANCE, RedisCommands.EVAL_LIST,
                 "local r = {} " +
                 "for i, v in ipairs(ARGV) do " +

File: redisson/src/main/java/org/redisson/api/RScoredSortedSet.java
Patch:
@@ -269,7 +269,7 @@ enum Aggregate {
      * @param elements - elements
      * @return element scores
      */
-    Collection<Double> getAllScore(List<V> elements);
+    List<Double> getAllScore(List<V> elements);
 
     /**
      * Adds element to this set, overrides previous score if it has been already added.

File: redisson/src/main/java/org/redisson/api/RScoredSortedSetAsync.java
Patch:
@@ -230,7 +230,7 @@ public interface RScoredSortedSetAsync<V> extends RExpirableAsync, RSortableAsyn
      * @param elements - elements
      * @return element scores
      */
-    RFuture<Collection<Double>> getAllScoreAsync(Collection<V> elements);
+    RFuture<List<Double>> getAllScoreAsync(Collection<V> elements);
 
     /**
      * Adds element to this set, overrides previous score if it has been already added.

File: redisson/src/main/java/org/redisson/api/RScoredSortedSetReactive.java
Patch:
@@ -242,7 +242,7 @@ public interface RScoredSortedSetReactive<V> extends RExpirableReactive, RSortab
      * @param elements - elements
      * @return element scores
      */
-    Mono<Collection<Double>> getAllScore(Collection<V> elements);
+    Mono<List<Double>> getAllScore(Collection<V> elements);
 
     /**
      * Adds element to this set, overrides previous score if it has been already added.

File: redisson/src/main/java/org/redisson/api/RScoredSortedSetRx.java
Patch:
@@ -243,7 +243,7 @@ public interface RScoredSortedSetRx<V> extends RExpirableRx, RSortableRx<Set<V>>
      * @param elements - elements
      * @return element scores
      */
-    Maybe<Collection<Double>> getAllScore(Collection<V> elements);
+    Maybe<List<Double>> getAllScore(Collection<V> elements);
 
     /**
      * Adds element to this set, overrides previous score if it has been already added.

File: redisson/src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -1044,8 +1044,8 @@ public void testManyConnections() {
         Assume.assumeFalse(RedissonRuntimeEnvironment.isTravis);
         Config redisConfig = new Config();
         redisConfig.useSingleServer()
-        .setConnectionMinimumIdleSize(10000)
-        .setConnectionPoolSize(10000)
+        .setConnectionMinimumIdleSize(5000)
+        .setConnectionPoolSize(5000)
         .setAddress(RedisRunner.getDefaultRedisServerBindAddressAndPort());
         RedissonClient r = Redisson.create(redisConfig);
         r.shutdown();

File: redisson/src/main/java/org/redisson/jcache/JCache.java
Patch:
@@ -1717,6 +1717,9 @@ public RFuture<Boolean> removeAsync(K key) {
         } else {
             RFuture<Boolean> result = removeValue(key);
             result.onComplete((res, ex) -> {
+                if (ex != null) {
+                    return;
+                }
                 if (res) {
                     cacheManager.getStatBean(this).addRemovals(1);
                 }

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -357,7 +357,7 @@ public PendingMessages xPending(byte[] key, String groupName, XPendingOptions op
         }
 
         return connection.write(key, StringCodec.INSTANCE, new RedisCommand<>("XPENDING",
-                            new ListMultiDecoder2(
+                            new ListMultiDecoder2<PendingMessages>(
                             new PendingMessagesReplayDecoder(groupName, options.getRange()),
                             new PendingMessageReplayDecoder(groupName))),
         params.toArray());

File: redisson/src/main/java/org/redisson/connection/MasterSlaveEntry.java
Patch:
@@ -85,13 +85,13 @@ public MasterSlaveServersConfig getConfig() {
         return config;
     }
 
-    public List<RFuture<Void>> initSlaveBalancer(Collection<RedisURI> disconnectedNodes) {
+    public List<RFuture<Void>> initSlaveBalancer(Collection<RedisURI> disconnectedNodes, RedisClient master) {
         boolean freezeMasterAsSlave = !config.getSlaveAddresses().isEmpty()
                     && !config.checkSkipSlavesInit()
                         && disconnectedNodes.size() < config.getSlaveAddresses().size();
 
         List<RFuture<Void>> result = new LinkedList<RFuture<Void>>();
-        RFuture<Void> f = addSlave(new RedisURI(config.getMasterAddress()), freezeMasterAsSlave, NodeType.MASTER);
+        RFuture<Void> f = addSlave(master.getAddr(), master.getConfig().getAddress(), freezeMasterAsSlave, NodeType.MASTER);
         result.add(f);
         for (String address : config.getSlaveAddresses()) {
             RedisURI uri = new RedisURI(address);
@@ -456,7 +456,7 @@ private void changeMaster(RedisURI address, ClientConnectionsEntry oldMaster,
             synchronized (oldMaster) {
                 oldMaster.setFreezeReason(FreezeReason.MANAGER);
             }
-            slaveDown(oldMaster);
+            nodeDown(oldMaster);
 
             slaveBalancer.changeType(oldMaster.getClient().getAddr(), NodeType.SLAVE);
             slaveBalancer.changeType(newMasterClient.getAddr(), NodeType.MASTER);

File: redisson/src/main/java/org/redisson/connection/balancer/LoadBalancerManager.java
Patch:
@@ -115,16 +115,16 @@ public int getAvailableClients() {
     public boolean unfreeze(RedisURI address, FreezeReason freezeReason) {
         ClientConnectionsEntry entry = getEntry(address);
         if (entry == null) {
-            throw new IllegalStateException("Can't find " + address + " in slaves!");
+            throw new IllegalStateException("Can't find " + address + " in slaves! Available slaves: " + client2Entry.keySet());
         }
 
         return unfreeze(entry, freezeReason);
     }
     
-    public boolean unfreeze(InetSocketAddress address, FreezeReason freezeReason) {
+    public boolean  unfreeze(InetSocketAddress address, FreezeReason freezeReason) {
         ClientConnectionsEntry entry = getEntry(address);
         if (entry == null) {
-            throw new IllegalStateException("Can't find " + address + " in slaves!");
+            throw new IllegalStateException("Can't find " + address + " in slaves! Available slaves: " + client2Entry.keySet());
         }
 
         return unfreeze(entry, freezeReason);

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -586,6 +586,8 @@ private void shutdownEntry(MasterSlaveEntry entry) {
             entry.getAllEntries().forEach(e -> entry.nodeDown(e));
             entry.masterDown();
             entry.shutdownAsync();
+            subscribeService.remove(entry);
+
             String slaves = entry.getAllEntries().stream()
                     .filter(e -> !e.getClient().getAddr().equals(entry.getClient().getAddr()))
                     .map(e -> e.getClient().toString())

File: redisson/src/main/java/org/redisson/RedissonReadLock.java
Patch:
@@ -54,7 +54,7 @@ String getReadWriteTimeoutNamePrefix(long threadId) {
     }
     
     @Override
-    <T> RFuture<T> tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand<T> command) {
+    <T> RFuture<T> tryLockInnerAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand<T> command) {
         internalLockLeaseTime = unit.toMillis(leaseTime);
 
         return evalWriteAsync(getName(), LongCodec.INSTANCE, command,

File: redisson/src/main/java/org/redisson/RedissonWriteLock.java
Patch:
@@ -51,7 +51,7 @@ protected String getLockName(long threadId) {
     }
     
     @Override
-    <T> RFuture<T> tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand<T> command) {
+    <T> RFuture<T> tryLockInnerAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand<T> command) {
         internalLockLeaseTime = unit.toMillis(leaseTime);
 
         return evalWriteAsync(getName(), LongCodec.INSTANCE, command,

File: redisson/src/main/java/org/redisson/RedissonLiveObjectService.java
Patch:
@@ -694,9 +694,7 @@ private <T> void copy(T detachedObject, T attachedObject, List<String> excludedF
     }
 
     private String getRIdFieldName(Class<?> cls) {
-        return Introspectior.getFieldsWithAnnotation(cls, RId.class)
-                .getOnly()
-                .getName();
+        return Introspectior.getREntityIdFieldName(cls);
     }
 
     private <T> T instantiateLiveObject(Class<T> proxyClass, Object id) {

File: redisson/src/main/java/org/redisson/command/RedisQueuedBatchExecutor.java
Patch:
@@ -85,6 +85,9 @@ protected void releaseConnection(RPromise<R> attemptPromise, RFuture<RedisConnec
         if (RedisCommands.EXEC.getName().equals(command.getName())) {
             super.releaseConnection(attemptPromise, connectionFuture);
         }
+        if (RedisCommands.DISCARD.getName().equals(command.getName())) {
+            super.releaseConnection(attemptPromise, connectionFuture);
+        }
     }
     
     @Override

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -316,9 +316,9 @@ public List<ByteRecord> xReadGroup(Consumer consumer, StreamReadOptions readOpti
         }
 
         if (readOptions.getBlock() != null && readOptions.getBlock() > 0) {
-            return connection.read(streams[0].getKey(), ByteArrayCodec.INSTANCE, XREADGROUP_BLOCKING, params.toArray());
+            return connection.write(streams[0].getKey(), ByteArrayCodec.INSTANCE, XREADGROUP_BLOCKING, params.toArray());
         }
-        return connection.read(streams[0].getKey(), ByteArrayCodec.INSTANCE, XREADGROUP, params.toArray());
+        return connection.write(streams[0].getKey(), ByteArrayCodec.INSTANCE, XREADGROUP, params.toArray());
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonStreamCommands.java
Patch:
@@ -612,9 +612,9 @@ public List<ByteRecord> xReadGroup(Consumer consumer, StreamReadOptions readOpti
         }
 
         if (readOptions.getBlock() != null && readOptions.getBlock() > 0) {
-            return connection.read(streams[0].getKey(), ByteArrayCodec.INSTANCE, XREADGROUP_BLOCKING, params.toArray());
+            return connection.write(streams[0].getKey(), ByteArrayCodec.INSTANCE, XREADGROUP_BLOCKING, params.toArray());
         }
-        return connection.read(streams[0].getKey(), ByteArrayCodec.INSTANCE, XREADGROUP, params.toArray());
+        return connection.write(streams[0].getKey(), ByteArrayCodec.INSTANCE, XREADGROUP, params.toArray());
     }
 
     @Override

File: redisson/src/main/java/org/redisson/codec/MarshallingCodec.java
Patch:
@@ -16,6 +16,7 @@
 package org.redisson.codec;
 
 import java.io.IOException;
+import java.util.Locale;
 
 import org.jboss.marshalling.ByteInput;
 import org.jboss.marshalling.ByteOutput;
@@ -211,7 +212,7 @@ public MarshallingCodec(ClassLoader classLoader, MarshallingCodec codec) {
     }
     
     public MarshallingCodec(Protocol protocol, MarshallingConfiguration configuration) {
-        this.factory = Marshalling.getProvidedMarshallerFactory(protocol.toString().toLowerCase());
+        this.factory = Marshalling.getProvidedMarshallerFactory(protocol.toString().toLowerCase(Locale.ENGLISH));
         if (factory == null) {
             throw new IllegalArgumentException(protocol.toString());
         }

File: redisson/src/main/java/org/redisson/MapWriteBehindTask.java
Patch:
@@ -120,7 +120,7 @@ private void enqueueTask() {
     }
 
     public void addTask(MapWriterTask task) {
-        writeBehindTasks.add(task);
+        writeBehindTasks.addAsync(task);
     }
 
     public void stop() {

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -458,7 +458,7 @@ protected void onSuccess(Void value) {
                 
         RFuture<List<Map<String, String>>> sentinelsFuture = connection.async(StringCodec.INSTANCE, RedisCommands.SENTINEL_SENTINELS, cfg.getMasterName());
         sentinelsFuture.onComplete((list, e) -> {
-            if (e != null) {
+            if (e != null || list.isEmpty()) {
                 return;
             }
             

File: redisson-hibernate/redisson-hibernate-4/src/main/java/org/redisson/hibernate/region/RedissonQueryRegion.java
Patch:
@@ -20,6 +20,7 @@
 import org.hibernate.cache.spi.QueryResultsRegion;
 import org.hibernate.cache.spi.RegionFactory;
 import org.redisson.api.RMapCache;
+import org.redisson.connection.ConnectionManager;
 
 /**
  * 
@@ -28,9 +29,9 @@
  */
 public class RedissonQueryRegion extends BaseRegion implements QueryResultsRegion {
 
-    public RedissonQueryRegion(RMapCache<Object, Object> mapCache, 
+    public RedissonQueryRegion(RMapCache<Object, Object> mapCache, ConnectionManager connectionManager,
             RegionFactory regionFactory, Properties properties, String defaultKey) {
-        super(mapCache, regionFactory, null, properties, defaultKey);
+        super(mapCache, connectionManager, regionFactory, null, properties, defaultKey);
     }
 
 }

File: redisson-hibernate/redisson-hibernate-4/src/main/java/org/redisson/hibernate/region/RedissonTimestampsRegion.java
Patch:
@@ -20,6 +20,7 @@
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.cache.spi.TimestampsRegion;
 import org.redisson.api.RMapCache;
+import org.redisson.connection.ConnectionManager;
 
 /**
  * 
@@ -28,9 +29,9 @@
  */
 public class RedissonTimestampsRegion extends BaseRegion implements TimestampsRegion {
 
-    public RedissonTimestampsRegion(RMapCache<Object, Object> mapCache, 
+    public RedissonTimestampsRegion(RMapCache<Object, Object> mapCache, ConnectionManager connectionManager,
             RegionFactory regionFactory, Properties properties, String defaultKey) {
-        super(mapCache, regionFactory, null, properties, defaultKey);
+        super(mapCache, connectionManager, regionFactory, null, properties, defaultKey);
     }
 
 }

File: redisson-hibernate/redisson-hibernate-4/src/test/java/org/redisson/hibernate/ReadWriteTest.java
Patch:
@@ -31,7 +31,7 @@ protected Class<?>[] getAnnotatedClasses() {
     protected void configure(Configuration cfg) {
         super.configure(cfg);
         cfg.setProperty(Environment.DRIVER, org.h2.Driver.class.getName());
-        cfg.setProperty(Environment.URL, "jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;MVCC=TRUE");
+        cfg.setProperty(Environment.URL, "jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1");
         cfg.setProperty(Environment.USER, "sa");
         cfg.setProperty(Environment.PASS, "");
         cfg.setProperty(Environment.CACHE_REGION_PREFIX, "");

File: redisson-hibernate/redisson-hibernate-4/src/test/java/org/redisson/hibernate/TransactionalTest.java
Patch:
@@ -31,7 +31,7 @@ protected Class<?>[] getAnnotatedClasses() {
     protected void configure(Configuration cfg) {
         super.configure(cfg);
         cfg.setProperty(Environment.DRIVER, org.h2.Driver.class.getName());
-        cfg.setProperty(Environment.URL, "jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;MVCC=TRUE");
+        cfg.setProperty(Environment.URL, "jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1");
         cfg.setProperty(Environment.USER, "sa");
         cfg.setProperty(Environment.PASS, "");
         cfg.setProperty(Environment.CACHE_REGION_PREFIX, "");

File: redisson-hibernate/redisson-hibernate-5/src/main/java/org/redisson/hibernate/region/RedissonQueryRegion.java
Patch:
@@ -20,6 +20,7 @@
 import org.hibernate.cache.spi.QueryResultsRegion;
 import org.hibernate.cache.spi.RegionFactory;
 import org.redisson.api.RMapCache;
+import org.redisson.connection.ConnectionManager;
 
 /**
  * 
@@ -28,9 +29,9 @@
  */
 public class RedissonQueryRegion extends BaseRegion implements QueryResultsRegion {
 
-    public RedissonQueryRegion(RMapCache<Object, Object> mapCache, 
+    public RedissonQueryRegion(RMapCache<Object, Object> mapCache, ConnectionManager connectionManager,
             RegionFactory regionFactory, Properties properties, String defaultKey) {
-        super(mapCache, regionFactory, null, properties, defaultKey);
+        super(mapCache, connectionManager, regionFactory, null, properties, defaultKey);
     }
 
 }

File: redisson-hibernate/redisson-hibernate-5/src/main/java/org/redisson/hibernate/region/RedissonTimestampsRegion.java
Patch:
@@ -20,6 +20,7 @@
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.cache.spi.TimestampsRegion;
 import org.redisson.api.RMapCache;
+import org.redisson.connection.ConnectionManager;
 
 /**
  * 
@@ -28,9 +29,9 @@
  */
 public class RedissonTimestampsRegion extends BaseRegion implements TimestampsRegion {
 
-    public RedissonTimestampsRegion(RMapCache<Object, Object> mapCache, 
+    public RedissonTimestampsRegion(RMapCache<Object, Object> mapCache, ConnectionManager connectionManager,
             RegionFactory regionFactory, Properties properties, String defaultKey) {
-        super(mapCache, regionFactory, null, properties, defaultKey);
+        super(mapCache, connectionManager, regionFactory, null, properties, defaultKey);
     }
 
 }

File: redisson-hibernate/redisson-hibernate-52/src/main/java/org/redisson/hibernate/region/RedissonQueryRegion.java
Patch:
@@ -20,6 +20,7 @@
 import org.hibernate.cache.spi.QueryResultsRegion;
 import org.hibernate.cache.spi.RegionFactory;
 import org.redisson.api.RMapCache;
+import org.redisson.connection.ConnectionManager;
 
 /**
  * 
@@ -28,9 +29,9 @@
  */
 public class RedissonQueryRegion extends BaseRegion implements QueryResultsRegion {
 
-    public RedissonQueryRegion(RMapCache<Object, Object> mapCache, 
+    public RedissonQueryRegion(RMapCache<Object, Object> mapCache, ConnectionManager connectionManager,
             RegionFactory regionFactory, Properties properties, String defaultKey) {
-        super(mapCache, regionFactory, null, properties, defaultKey);
+        super(mapCache, connectionManager, regionFactory, null, properties, defaultKey);
     }
 
 }

File: redisson-hibernate/redisson-hibernate-52/src/main/java/org/redisson/hibernate/region/RedissonTimestampsRegion.java
Patch:
@@ -20,6 +20,7 @@
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.cache.spi.TimestampsRegion;
 import org.redisson.api.RMapCache;
+import org.redisson.connection.ConnectionManager;
 
 /**
  * 
@@ -28,9 +29,9 @@
  */
 public class RedissonTimestampsRegion extends BaseRegion implements TimestampsRegion {
 
-    public RedissonTimestampsRegion(RMapCache<Object, Object> mapCache, 
+    public RedissonTimestampsRegion(RMapCache<Object, Object> mapCache, ConnectionManager connectionManager,
             RegionFactory regionFactory, Properties properties, String defaultKey) {
-        super(mapCache, regionFactory, null, properties, defaultKey);
+        super(mapCache, connectionManager, regionFactory, null, properties, defaultKey);
     }
 
 }

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -159,8 +159,7 @@ public SentinelConnectionManager(SentinelServersConfig cfg, Config config, UUID
                     connectionFutures.add(future);
                 }
 
-                RedisURI currentAddr = toURI(client.getAddr().getAddress().getHostAddress(), "" + client.getAddr().getPort());
-                RFuture<Void> f = registerSentinel(currentAddr, this.config, null);
+                RFuture<Void> f = registerSentinel(addr, this.config, null);
                 connectionFutures.add(f);
 
                 for (RFuture<Void> future : connectionFutures) {

File: redisson/src/main/java/org/redisson/RedissonBloomFilter.java
Patch:
@@ -130,7 +130,7 @@ public boolean add(T object) {
                 }
                 return false;
             } catch (RedisException e) {
-                if (!e.getMessage().contains("Bloom filter config has been changed")) {
+                if (e.getMessage() == null || !e.getMessage().contains("Bloom filter config has been changed")) {
                     throw e;
                 }
             }
@@ -182,7 +182,7 @@ public boolean contains(T object) {
 
                 return true;
             } catch (RedisException e) {
-                if (!e.getMessage().contains("Bloom filter config has been changed")) {
+                if (e.getMessage() == null || !e.getMessage().contains("Bloom filter config has been changed")) {
                     throw e;
                 }
             }
@@ -278,7 +278,7 @@ public boolean tryInit(long expectedInsertions, double falseProbability) {
         try {
             executorService.execute();
         } catch (RedisException e) {
-            if (!e.getMessage().contains("Bloom filter config has been changed")) {
+            if (e.getMessage() == null || !e.getMessage().contains("Bloom filter config has been changed")) {
                 throw e;
             }
             readConfig();

File: redisson/src/main/java/org/redisson/RedissonAtomicDouble.java
Patch:
@@ -126,7 +126,7 @@ public double getAndSet(double newValue) {
 
     @Override
     public RFuture<Double> getAndSetAsync(double newValue) {
-        return commandExecutor.writeAsync(getName(), DoubleCodec.INSTANCE, RedisCommands.GETSET, getName(), BigDecimal.valueOf(newValue).toPlainString());
+        return commandExecutor.writeAsync(getName(), DoubleCodec.INSTANCE, RedisCommands.GETSET_DOUBLE, getName(), BigDecimal.valueOf(newValue).toPlainString());
     }
 
     @Override

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -298,6 +298,7 @@ public interface RedisCommands {
     RedisStrictCommand<Double> GET_DOUBLE = new RedisStrictCommand<Double>("GET", new DoubleNullSafeReplayConvertor());
     RedisCommand<Object> GETSET = new RedisCommand<Object>("GETSET");
     RedisCommand<Long> GETSET_LONG = new RedisCommand<>("GETSET", new LongReplayConvertor());
+    RedisCommand<Double> GETSET_DOUBLE = new RedisCommand<>("GETSET", new DoubleReplayConvertor(0D));
     RedisCommand<Void> SET = new RedisCommand<Void>("SET", new VoidReplayConvertor());
     RedisCommand<Void> APPEND = new RedisCommand<Void>("APPEND", new VoidReplayConvertor());
     RedisCommand<Boolean> SET_BOOLEAN = new RedisCommand<Boolean>("SET", new BooleanNotNullReplayConvertor());

File: redisson/src/main/java/org/redisson/RedissonAtomicLong.java
Patch:
@@ -124,7 +124,7 @@ public long getAndSet(long newValue) {
 
     @Override
     public RFuture<Long> getAndSetAsync(long newValue) {
-        return commandExecutor.writeAsync(getName(), LongCodec.INSTANCE, RedisCommands.GETSET, getName(), newValue);
+        return commandExecutor.writeAsync(getName(), LongCodec.INSTANCE, RedisCommands.GETSET_LONG, getName(), newValue);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -297,6 +297,7 @@ public interface RedisCommands {
     RedisStrictCommand<Integer> GET_INTEGER = new RedisStrictCommand<Integer>("GET", new IntegerReplayConvertor(0));
     RedisStrictCommand<Double> GET_DOUBLE = new RedisStrictCommand<Double>("GET", new DoubleNullSafeReplayConvertor());
     RedisCommand<Object> GETSET = new RedisCommand<Object>("GETSET");
+    RedisCommand<Long> GETSET_LONG = new RedisCommand<>("GETSET", new LongReplayConvertor());
     RedisCommand<Void> SET = new RedisCommand<Void>("SET", new VoidReplayConvertor());
     RedisCommand<Void> APPEND = new RedisCommand<Void>("APPEND", new VoidReplayConvertor());
     RedisCommand<Boolean> SET_BOOLEAN = new RedisCommand<Boolean>("SET", new BooleanNotNullReplayConvertor());

File: redisson/src/main/java/org/redisson/api/RMapCache.java
Patch:
@@ -42,7 +42,7 @@
 public interface RMapCache<K, V> extends RMap<K, V>, RMapCacheAsync<K, V>, RDestroyable {
 
     /**
-     * Sets max size of the map.
+     * Sets max size of the map and overrides current value.
      * Superfluous elements are evicted using LRU algorithm.
      * 
      * @param maxSize - max size

File: redisson/src/main/java/org/redisson/api/RMapCacheAsync.java
Patch:
@@ -38,7 +38,7 @@
 public interface RMapCacheAsync<K, V> extends RMapAsync<K, V> {
 
     /**
-     * Sets max size of the map.
+     * Sets max size of the map and overrides current value.
      * Superfluous elements are evicted using LRU algorithm.
      * 
      * @param maxSize - max size

File: redisson/src/main/java/org/redisson/RedissonListMultimap.java
Patch:
@@ -226,7 +226,8 @@ public RFuture<Boolean> removeAllAsync(Collection<?> c) {
             @Override
             public RFuture<Boolean> deleteAsync() {
                 ByteBuf keyState = encodeMapKey(key);
-                return RedissonListMultimap.this.fastRemoveAsync(Arrays.<Object>asList(keyState), Arrays.<Object>asList(setName), RedisCommands.EVAL_BOOLEAN_AMOUNT);
+                return RedissonListMultimap.this.fastRemoveAsync(Arrays.asList(keyState),
+                        Arrays.asList(RedissonListMultimap.this.getName(), setName), RedisCommands.EVAL_BOOLEAN_AMOUNT);
             }
             
             @Override

File: redisson/src/main/java/org/redisson/RedissonSetMultimap.java
Patch:
@@ -205,7 +205,8 @@ public RFuture<Boolean> removeAllAsync(Collection<?> c) {
             @Override
             public RFuture<Boolean> deleteAsync() {
                 ByteBuf keyState = encodeMapKey(key);
-                return RedissonSetMultimap.this.fastRemoveAsync(Arrays.<Object>asList(keyState), Arrays.<Object>asList(setName), RedisCommands.EVAL_BOOLEAN_AMOUNT);
+                return RedissonSetMultimap.this.fastRemoveAsync(Arrays.asList(keyState),
+                        Arrays.asList(RedissonSetMultimap.this.getName(), setName), RedisCommands.EVAL_BOOLEAN_AMOUNT);
             }
             
             @Override

File: redisson/src/main/java/org/redisson/client/RedisConnection.java
Patch:
@@ -249,7 +249,8 @@ public void clearFastReconnect() {
     private void close() {
         CommandData<?, ?> command = getCurrentCommand();
         if (!isActive()
-                || (command != null && command.isBlockingCommand())) {
+                || (command != null && command.isBlockingCommand())
+                    || !connectionPromise.isDone()) {
             channel.close();
         } else {
             RFuture<Void> f = async(RedisCommands.QUIT);

File: redisson/src/main/java/org/redisson/client/handler/RedisChannelInitializer.java
Patch:
@@ -201,6 +201,7 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exc
                         ctx.fireChannelActive();
                     } else {
                         RedisConnection connection = RedisConnection.getFrom(ctx.channel());
+                        connection.closeAsync();
                         connection.getConnectionPromise().tryFailure(e.cause());
                     }
                 }

File: redisson/src/main/java/org/redisson/client/RedisOutOfMemoryException.java
Patch:
@@ -16,7 +16,7 @@
 package org.redisson.client;
 
 /**
- * This error occurs in case when Redis server free memory has been exhausted. 
+ * This error occurs in case when Redis server free memory exhausted.
  * 
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/client/WriteRedisConnectionException.java
Patch:
@@ -16,6 +16,7 @@
 package org.redisson.client;
 
 /**
+ * This error occurs when write operation over Redis connection can't be executed.
  * 
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -357,6 +357,9 @@ protected void decode(ByteBuf in, CommandData<Object, Object> data, List<Object>
             } else if (error.startsWith("NOAUTH")) {
                 data.tryFailure(new RedisAuthRequiredException(error
                         + ". channel: " + channel + " data: " + data));
+            } else if (error.startsWith("CLUSTERDOWN")) {
+                data.tryFailure(new RedisClusterDownException(error
+                        + ". channel: " + channel + " data: " + data));
             } else {
                 if (data != null) {
                     data.tryFailure(new RedisException(error + ". channel: " + channel + " command: " + LogHelper.toString(data)));

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -426,7 +426,8 @@ protected void checkAttemptPromise(RPromise<R> attemptFuture, RFuture<RedisConne
             }
             
             if (attemptFuture.cause() instanceof RedisLoadingException
-                    || attemptFuture.cause() instanceof RedisTryAgainException) {
+                    || attemptFuture.cause() instanceof RedisTryAgainException
+                        || attemptFuture.cause() instanceof RedisClusterDownException) {
                 if (attempt < attempts) {
                     onException();
                     connectionManager.newTimeout(new TimerTask() {

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -570,8 +570,8 @@ protected final void addEntry(Integer slot, MasterSlaveEntry entry) {
         MasterSlaveEntry oldEntry = slot2entry.getAndSet(slot, entry);
         if (oldEntry != entry) {
             entry.incReference();
+            shutdownEntry(oldEntry);
         }
-        shutdownEntry(oldEntry);
         client2entry.put(entry.getClient(), entry);
     }
 
@@ -583,6 +583,8 @@ protected final void removeEntry(Integer slot) {
     private void shutdownEntry(MasterSlaveEntry entry) {
         if (entry != null && entry.decReference() == 0) {
             client2entry.remove(entry.getClient());
+            entry.getAllEntries().forEach(e -> entry.nodeDown(e));
+            entry.masterDown();
             entry.shutdownAsync();
             String slaves = entry.getAllEntries().stream()
                     .filter(e -> !e.getClient().getAddr().equals(entry.getClient().getAddr()))

File: redisson/src/main/java/org/redisson/spring/cache/RedissonCacheStatisticsAutoConfiguration.java
Patch:
@@ -35,8 +35,8 @@
  */
 @Configuration
 @AutoConfigureAfter(CacheAutoConfiguration.class)
-@ConditionalOnBean({CacheManager.class, RedissonCache.class})
-@ConditionalOnClass(CacheMeterBinderProvider.class)
+@ConditionalOnBean(CacheManager.class)
+@ConditionalOnClass({CacheMeterBinderProvider.class, RedissonCache.class})
 public class RedissonCacheStatisticsAutoConfiguration {
     
     @Bean

File: redisson/src/main/java/org/redisson/RedissonTimeSeries.java
Patch:
@@ -41,11 +41,12 @@
  */
 public class RedissonTimeSeries<V> extends RedissonExpirable implements RTimeSeries<V> {
 
-    private EvictionScheduler evictionScheduler;
+    private final EvictionScheduler evictionScheduler;
 
     public RedissonTimeSeries(EvictionScheduler evictionScheduler, CommandAsyncExecutor connectionManager, String name) {
         super(connectionManager, name);
 
+        this.evictionScheduler = evictionScheduler;
         if (evictionScheduler != null) {
             evictionScheduler.scheduleTimeSeries(getName(), getTimeoutSetName());
         }
@@ -54,6 +55,7 @@ public RedissonTimeSeries(EvictionScheduler evictionScheduler, CommandAsyncExecu
     public RedissonTimeSeries(Codec codec, EvictionScheduler evictionScheduler, CommandAsyncExecutor connectionManager, String name) {
         super(codec, connectionManager, name);
 
+        this.evictionScheduler = evictionScheduler;
         if (evictionScheduler != null) {
             evictionScheduler.scheduleTimeSeries(getName(), getTimeoutSetName());
         }

File: redisson/src/main/java/org/redisson/api/RQueueReactive.java
Patch:
@@ -15,11 +15,10 @@
  */
 package org.redisson.api;
 
-import java.util.List;
-
-import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 
+import java.util.List;
+
 /**
  * Reactive interface for Queue object
  *

File: redisson/src/main/java/org/redisson/api/RQueueRx.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.redisson.api;
 
-import io.reactivex.Flowable;
 import io.reactivex.Maybe;
 import io.reactivex.Single;
 

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -28,6 +28,7 @@
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.RedisStrictCommand;
+import org.redisson.client.protocol.convertor.BooleanNullSafeReplayConvertor;
 import org.redisson.client.protocol.convertor.BooleanReplayConvertor;
 import org.redisson.client.protocol.convertor.DoubleReplayConvertor;
 import org.redisson.client.protocol.convertor.VoidReplayConvertor;
@@ -477,7 +478,7 @@ public List<byte[]> mGet(byte[]... keys) {
         return read(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
     }
 
-    private static final RedisCommand<Boolean> SET = new RedisCommand<Boolean>("SET", new BooleanReplayConvertor());
+    private static final RedisCommand<Boolean> SET = new RedisCommand<>("SET", new BooleanNullSafeReplayConvertor());
     
     @Override
     public Boolean set(byte[] key, byte[] value) {

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -54,6 +54,7 @@
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.RedisStrictCommand;
+import org.redisson.client.protocol.convertor.BooleanNullSafeReplayConvertor;
 import org.redisson.client.protocol.convertor.BooleanReplayConvertor;
 import org.redisson.client.protocol.convertor.DoubleReplayConvertor;
 import org.redisson.client.protocol.convertor.VoidReplayConvertor;
@@ -512,7 +513,7 @@ public List<byte[]> mGet(byte[]... keys) {
         return read(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
     }
 
-    private static final RedisCommand<Boolean> SET = new RedisCommand<Boolean>("SET", new BooleanReplayConvertor());
+    private static final RedisCommand<Boolean> SET = new RedisCommand<>("SET", new BooleanNullSafeReplayConvertor());
     
     @Override
     public Boolean set(byte[] key, byte[] value) {

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -54,6 +54,7 @@
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.RedisStrictCommand;
+import org.redisson.client.protocol.convertor.BooleanNullSafeReplayConvertor;
 import org.redisson.client.protocol.convertor.BooleanReplayConvertor;
 import org.redisson.client.protocol.convertor.DoubleReplayConvertor;
 import org.redisson.client.protocol.convertor.VoidReplayConvertor;
@@ -504,7 +505,7 @@ public List<byte[]> mGet(byte[]... keys) {
         return read(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
     }
 
-    private static final RedisCommand<Boolean> SET = new RedisCommand<Boolean>("SET", new BooleanReplayConvertor());
+    private static final RedisCommand<Boolean> SET = new RedisCommand<>("SET", new BooleanNullSafeReplayConvertor());
     
     @Override
     public Boolean set(byte[] key, byte[] value) {

File: redisson-spring-data/redisson-spring-data-23/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -54,6 +54,7 @@
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.RedisStrictCommand;
+import org.redisson.client.protocol.convertor.BooleanNullSafeReplayConvertor;
 import org.redisson.client.protocol.convertor.BooleanReplayConvertor;
 import org.redisson.client.protocol.convertor.DoubleReplayConvertor;
 import org.redisson.client.protocol.convertor.VoidReplayConvertor;
@@ -504,7 +505,7 @@ public List<byte[]> mGet(byte[]... keys) {
         return read(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
     }
 
-    private static final RedisCommand<Boolean> SET = new RedisCommand<Boolean>("SET", new BooleanReplayConvertor());
+    private static final RedisCommand<Boolean> SET = new RedisCommand<>("SET", new BooleanNullSafeReplayConvertor());
     
     @Override
     public Boolean set(byte[] key, byte[] value) {

File: redisson/src/main/java/org/redisson/api/RQueueReactive.java
Patch:
@@ -49,7 +49,7 @@ public interface RQueueReactive<V> extends RCollectionReactive<V> {
      *
      * @return list of head elements
      */
-    Flux<V> poll(int limit);
+    Mono<List<V>> poll(int limit);
 
     /**
      * Inserts the specified element into this queue.

File: redisson/src/main/java/org/redisson/api/RQueueRx.java
Patch:
@@ -50,7 +50,7 @@ public interface RQueueRx<V> extends RCollectionRx<V> {
      *
      * @return list of head elements
      */
-    Flowable<V> poll(int limit);
+    Single<List<V>> poll(int limit);
 
     /**
      * Inserts the specified element into this queue.

File: redisson/src/main/java/org/redisson/connection/NodeSource.java
Patch:
@@ -37,8 +37,7 @@ public NodeSource(MasterSlaveEntry entry) {
         this.entry = entry;
     }
 
-    public NodeSource(MasterSlaveEntry entry, Integer slot) {
-        this.entry = entry;
+    public NodeSource(Integer slot) {
         this.slot = slot;
     }
 

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -90,6 +90,7 @@ public SentinelConnectionManager(SentinelServersConfig cfg, Config config, UUID
         Throwable lastException = null;
         for (String address : cfg.getSentinelAddresses()) {
             RedisURI addr = new RedisURI(address);
+            addr = applyNatMap(addr);
             if (NetUtil.createByteArrayFromIpAddressString(addr.getHost()) == null && !addr.getHost().equals("localhost")) {
                 sentinelHosts.add(addr);
             }
@@ -202,6 +203,7 @@ private void checkAuth(SentinelServersConfig cfg) {
         for (String address : cfg.getSentinelAddresses()) {
             RedisURI addr = new RedisURI(address);
             scheme = addr.getScheme();
+            addr = applyNatMap(addr);
             RedisClient client = createClient(NodeType.SENTINEL, addr, this.config.getConnectTimeout(), this.config.getTimeout(), null);
             try {
                 RedisConnection c = client.connect();

File: redisson/src/main/java/org/redisson/command/RedisCommonBatchExecutor.java
Patch:
@@ -112,7 +112,7 @@ protected void sendCommand(RPromise<Void> attemptPromise, RedisConnection connec
             return;
         }
         
-        writeFuture = connection.send(new CommandsData(attemptPromise, list, options.isSkipResult(), isAtomic, isQueued));
+        writeFuture = connection.send(new CommandsData(attemptPromise, list, options.isSkipResult(), isAtomic, isQueued, options.getSyncSlaves() > 0));
     }
     
     protected boolean isWaitCommand(CommandData<?, ?> c) {

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -281,7 +281,7 @@ private void checkWriteFuture(ChannelFuture future, RPromise<R> attemptPromise,
 
     private void scheduleResponseTimeout(RPromise<R> attemptPromise, RedisConnection connection) {
         long timeoutTime = responseTimeout;
-        if (command != null 
+        if (command != null
                 && (RedisCommands.BLOCKING_COMMAND_NAMES.contains(command.getName())
                         || RedisCommands.BLOCKING_COMMANDS.contains(command))) {
             Long popTimeout = null;
@@ -606,7 +606,7 @@ protected void sendCommand(RPromise<R> attemptPromise, RedisConnection connectio
             list.add(new CommandData<Void, Void>(promise, codec, RedisCommands.ASKING, new Object[]{}));
             list.add(new CommandData<V, R>(attemptPromise, codec, command, params));
             RPromise<Void> main = new RedissonPromise<Void>();
-            writeFuture = connection.send(new CommandsData(main, list, false));
+            writeFuture = connection.send(new CommandsData(main, list, false, false));
         } else {
             if (log.isDebugEnabled()) {
                 log.debug("acquired connection for command {} and params {} from slot {} using node {}... {}",

File: redisson/src/test/java/org/redisson/RedisClientTest.java
Patch:
@@ -153,7 +153,7 @@ public void testPipeline() throws InterruptedException, ExecutionException {
         commands.add(cmd4);
 
         RPromise<Void> p = new RedissonPromise<Void>();
-        conn.send(new CommandsData(p, commands, false));
+        conn.send(new CommandsData(p, commands, false, false));
 
         assertThat(cmd1.getPromise().get()).isEqualTo("PONG");
         assertThat(cmd2.getPromise().get()).isEqualTo(1);
@@ -188,7 +188,7 @@ public void testPipelineBigResponse() throws InterruptedException, ExecutionExce
         }
 
         RPromise<Void> p = new RedissonPromise<Void>();
-        conn.send(new CommandsData(p, commands, false));
+        conn.send(new CommandsData(p, commands, false, false));
 
         for (CommandData<?, ?> commandData : commands) {
             commandData.getPromise().get();

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -68,7 +68,7 @@ public class CommandAsyncService implements CommandAsyncExecutor {
     static final Logger log = LoggerFactory.getLogger(CommandAsyncService.class);
 
     final ConnectionManager connectionManager;
-    RedissonObjectBuilder objectBuilder;
+    protected RedissonObjectBuilder objectBuilder;
 
     public CommandAsyncService(ConnectionManager connectionManager) {
         this.connectionManager = connectionManager;

File: redisson/src/main/java/org/redisson/api/RLiveObjectService.java
Patch:
@@ -96,7 +96,7 @@ public interface RLiveObjectService {
      * RId, and the object should hold a non null value in that field.
      * 
      * If this object is not in redis then a new hash key will be created to
-     * store it.
+     * store it. Otherwise overrides current object state in Redis with the given object state.
      *
      * @param <T> Entity type
      * @param detachedObject - not proxied object

File: redisson/src/main/java/org/redisson/client/handler/PingConnectionHandler.java
Patch:
@@ -75,6 +75,9 @@ public void run(Timeout timeout) throws Exception {
                 if (future != null
                         && (future.cancel(false) || !future.isSuccess())) {
                     ctx.channel().close();
+                    if (future.cause() != null) {
+                        log.error("Unable to send PING command over channel: " + ctx.channel(), future.cause());
+                    }
                     log.debug("channel: {} closed due to PING response timeout set in {} ms", ctx.channel(), config.getPingConnectionInterval());
                 } else {
                     sendPing(ctx);

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -259,7 +259,7 @@ public void setPrincipal(Principal principal) {
     public void setAuthType(String authType) {
         super.setAuthType(authType);
 
-        if (map != null) {
+        if (map != null && authType != null) {
             fastPut(AUTHTYPE_ATTR, authType);
         }
     }

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -259,7 +259,7 @@ public void setPrincipal(Principal principal) {
     public void setAuthType(String authType) {
         super.setAuthType(authType);
 
-        if (map != null) {
+        if (map != null && authType != null) {
             fastPut(AUTHTYPE_ATTR, authType);
         }
     }

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -259,7 +259,7 @@ public void setPrincipal(Principal principal) {
     public void setAuthType(String authType) {
         super.setAuthType(authType);
 
-        if (map != null) {
+        if (map != null && authType != null) {
             fastPut(AUTHTYPE_ATTR, authType);
         }
     }

File: redisson/src/test/java/org/redisson/RedissonBucketTest.java
Patch:
@@ -119,7 +119,7 @@ public void testSizeInMemory() {
         Assume.assumeTrue(RedisRunner.getDefaultRedisServerInstance().getRedisVersion().compareTo("4.0.0") > 0);
         RBucket<Integer> al = redisson.getBucket("test");
         al.set(1234);
-        assertThat(al.sizeInMemory()).isEqualTo(56);
+        assertThat(al.sizeInMemory()).isEqualTo(54);
     }
     
     @Test

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -880,7 +880,7 @@ public RFuture<V> putAsync(K key, V value, long ttl, TimeUnit ttlUnit, long maxI
         long ttlTimeout = 0;
         long ttlTimeoutDelta = 0;
         if (ttl > 0) {
-            ttlTimeoutDelta = ttlUnit.toMillis(ttl);;
+            ttlTimeoutDelta = ttlUnit.toMillis(ttl);
             ttlTimeout = System.currentTimeMillis() + ttlTimeoutDelta;
         }
 

File: redisson/src/main/java/org/redisson/transaction/BaseTransactionalMapCache.java
Patch:
@@ -50,10 +50,10 @@ public RFuture<Boolean> fastPutOperationAsync(K key, V value, long ttl, TimeUnit
         return fastPutOperationAsync(key, value, new MapCacheFastPutOperation(map, key, value, ttl, ttlUnit, maxIdleTime, maxIdleUnit, transactionId, threadId));
     }
     
-    public RFuture<V> putOperationAsync(K key, V value, long ttlTimeout, long maxIdleTimeout, long maxIdleDelta) {
+    public RFuture<V> putOperationAsync(K key, V value, long ttlTimeout, long maxIdleTimeout, long maxIdleDelta, long ttlTimeoutDelta) {
         long threadId = Thread.currentThread().getId();
-        return putOperationAsync(key, value, new MapCachePutOperation(map, key, value, 
-                ttlTimeout, TimeUnit.MILLISECONDS, maxIdleTimeout, TimeUnit.MILLISECONDS, transactionId, threadId));
+        return putOperationAsync(key, value, new MapCachePutOperation(map, key, value,
+                ttlTimeoutDelta, TimeUnit.MILLISECONDS, maxIdleDelta, TimeUnit.MILLISECONDS, transactionId, threadId));
     }
     
     public RFuture<Boolean> fastPutIfAbsentAsync(K key, V value, long ttl, TimeUnit ttlUnit, long maxIdleTime, TimeUnit maxIdleUnit) {

File: redisson/src/main/java/org/redisson/transaction/RedissonTransactionalMapCache.java
Patch:
@@ -129,8 +129,8 @@ public RFuture<Boolean> fastPutOperationAsync(K key, V value, long ttl, TimeUnit
     }
     
     @Override
-    public RFuture<V> putOperationAsync(K key, V value, long ttlTimeout, long maxIdleTimeout, long maxIdleDelta) {
-        return transactionalMap.putOperationAsync(key, value, ttlTimeout, maxIdleTimeout, maxIdleDelta);
+    public RFuture<V> putOperationAsync(K key, V value, long ttlTimeout, long maxIdleTimeout, long maxIdleDelta, long ttlTimeoutDelta) {
+        return transactionalMap.putOperationAsync(key, value, ttlTimeout, maxIdleTimeout, maxIdleDelta, ttlTimeoutDelta);
     }
     
     public RFuture<Boolean> fastPutIfAbsentAsync(final K key, final V value, long ttl, TimeUnit ttlUnit, long maxIdleTime, TimeUnit maxIdleUnit) {

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ClusterNodesDecoder.java
Patch:
@@ -55,9 +55,8 @@ public List<ClusterNodeInfo> decode(ByteBuf buf, State state) throws IOException
 
             String flags = params[2];
             for (String flag : flags.split(",")) {
-                String flagValue = flag.toUpperCase().replaceAll("\\?", "");
                 for (Flag nodeInfoFlag : ClusterNodeInfo.Flag.values()) {
-                    if (nodeInfoFlag.name().equals(flagValue)) {
+                    if (nodeInfoFlag.getValue().equalsIgnoreCase(flag)) {
                         node.addFlag(nodeInfoFlag);
                         break;
                     }

File: redisson/src/main/java/org/redisson/client/RedisClient.java
Patch:
@@ -23,7 +23,6 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.redisson.RedissonShutdownException;
 import org.redisson.api.RFuture;
 import org.redisson.client.handler.RedisChannelInitializer;
 import org.redisson.client.handler.RedisChannelInitializer.Type;

File: redisson/src/main/java/org/redisson/codec/LZ4Codec.java
Patch:
@@ -50,15 +50,15 @@ public class LZ4Codec extends BaseCodec {
     private final Codec innerCodec;
 
     public LZ4Codec() {
-        this(new Kryo5Codec());
+        this(new MarshallingCodec());
     }
 
     public LZ4Codec(Codec innerCodec) {
         this.innerCodec = innerCodec;
     }
     
     public LZ4Codec(ClassLoader classLoader) {
-        this(new FstCodec(classLoader));
+        this(new MarshallingCodec(classLoader));
     }
 
     public LZ4Codec(ClassLoader classLoader, LZ4Codec codec) throws ReflectiveOperationException {

File: redisson/src/main/java/org/redisson/codec/SnappyCodec.java
Patch:
@@ -54,15 +54,15 @@ protected Snappy initialValue() {
     private final Codec innerCodec;
 
     public SnappyCodec() {
-        this(new Kryo5Codec());
+        this(new MarshallingCodec());
     }
 
     public SnappyCodec(Codec innerCodec) {
         this.innerCodec = innerCodec;
     }
 
     public SnappyCodec(ClassLoader classLoader) {
-        this(new FstCodec(classLoader));
+        this(new MarshallingCodec(classLoader));
     }
     
     public SnappyCodec(ClassLoader classLoader, SnappyCodec codec) throws ReflectiveOperationException {

File: redisson/src/main/java/org/redisson/codec/SnappyCodecV2.java
Patch:
@@ -43,15 +43,15 @@ public class SnappyCodecV2 extends BaseCodec {
     private final Codec innerCodec;
 
     public SnappyCodecV2() {
-        this(new Kryo5Codec());
+        this(new MarshallingCodec());
     }
 
     public SnappyCodecV2(Codec innerCodec) {
         this.innerCodec = innerCodec;
     }
 
     public SnappyCodecV2(ClassLoader classLoader) {
-        this(new FstCodec(classLoader));
+        this(new MarshallingCodec(classLoader));
     }
     
     public SnappyCodecV2(ClassLoader classLoader, SnappyCodecV2 codec) throws ReflectiveOperationException {

File: redisson/src/main/java/org/redisson/config/Config.java
Patch:
@@ -19,7 +19,7 @@
 import org.redisson.client.DefaultNettyHook;
 import org.redisson.client.NettyHook;
 import org.redisson.client.codec.Codec;
-import org.redisson.codec.FstCodec;
+import org.redisson.codec.MarshallingCodec;
 import org.redisson.connection.AddressResolverGroupFactory;
 import org.redisson.connection.ConnectionManager;
 import org.redisson.connection.DnsAddressResolverGroupFactory;
@@ -108,7 +108,7 @@ public Config(Config oldConf) {
 
         if (oldConf.getCodec() == null) {
             // use it by default
-            oldConf.setCodec(new FstCodec());
+            oldConf.setCodec(new MarshallingCodec());
         }
 
         setUseThreadClassLoader(oldConf.isUseThreadClassLoader());

File: redisson/src/test/java/org/redisson/BaseMapTest.java
Patch:
@@ -889,7 +889,7 @@ public void testValueSize() {
         Assume.assumeTrue(!(map instanceof RMapCache));
         map.put("1", "1234");
         assertThat(map.valueSize("4")).isZero();
-        assertThat(map.valueSize("1")).isEqualTo(6);
+        assertThat(map.valueSize("1")).isEqualTo(7);
         destroy(map);
     }
     

File: redisson/src/test/java/org/redisson/RedissonBucketTest.java
Patch:
@@ -119,7 +119,7 @@ public void testSizeInMemory() {
         Assume.assumeTrue(RedisRunner.getDefaultRedisServerInstance().getRedisVersion().compareTo("4.0.0") > 0);
         RBucket<Integer> al = redisson.getBucket("test");
         al.set(1234);
-        assertThat(al.sizeInMemory()).isEqualTo(54);
+        assertThat(al.sizeInMemory()).isEqualTo(56);
     }
     
     @Test
@@ -172,7 +172,7 @@ public void testSize() {
         assertThat(bucket.size()).isZero();
         bucket.set("1234");
         // json adds quotes
-        assertThat(bucket.size()).isEqualTo(6);
+        assertThat(bucket.size()).isEqualTo(7);
     }
     
     @Test

File: redisson/src/test/java/org/redisson/transaction/RedissonTransactionalBucketReactiveTest.java
Patch:
@@ -113,7 +113,7 @@ public void testGetAndRemove() {
         RTransactionReactive transaction = redisson.createTransaction(TransactionOptions.defaults());
         RBucketReactive<String> set = transaction.getBucket("test");
         assertThat(sync(set.get())).isEqualTo("123");
-        assertThat(sync(set.size())).isEqualTo(5);
+        assertThat(sync(set.size())).isEqualTo(6);
         assertThat(sync(set.getAndDelete())).isEqualTo("123");
         assertThat(sync(set.size())).isEqualTo(0);
         assertThat(sync(set.get())).isNull();

File: redisson/src/test/java/org/redisson/transaction/RedissonTransactionalBucketTest.java
Patch:
@@ -113,7 +113,7 @@ public void testGetAndRemove() {
         RTransaction transaction = redisson.createTransaction(TransactionOptions.defaults());
         RBucket<String> set = transaction.getBucket("test");
         assertThat(set.get()).isEqualTo("123");
-        assertThat(set.size()).isEqualTo(5);
+        assertThat(set.size()).isEqualTo(6);
         assertThat(set.getAndDelete()).isEqualTo("123");
         assertThat(set.size()).isEqualTo(0);
         assertThat(set.get()).isNull();

File: redisson-hibernate/redisson-hibernate-5/src/main/java/org/redisson/hibernate/strategy/NonStrictReadWriteCollectionRegionAccessStrategy.java
Patch:
@@ -25,6 +25,7 @@
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.persister.collection.CollectionPersister;
+import org.redisson.hibernate.region.RedissonCollectionRegion;
 
 /**
  * 
@@ -76,12 +77,12 @@ public void remove(SessionImplementor session, Object key) throws CacheException
     @Override
     public Object generateCacheKey(Object id, CollectionPersister persister, SessionFactoryImplementor factory,
             String tenantIdentifier) {
-        return DefaultCacheKeysFactory.staticCreateCollectionKey( id, persister, factory, tenantIdentifier );
+        return ((RedissonCollectionRegion)region).getCacheKeysFactory().createCollectionKey( id, persister, factory, tenantIdentifier );
     }
 
     @Override
     public Object getCacheKeyId(Object cacheKey) {
-        return DefaultCacheKeysFactory.staticGetCollectionId( cacheKey );
+        return ((RedissonCollectionRegion)region).getCacheKeysFactory().getCollectionId( cacheKey );
     }
 
 }

File: redisson-hibernate/redisson-hibernate-5/src/main/java/org/redisson/hibernate/strategy/NonStrictReadWriteEntityRegionAccessStrategy.java
Patch:
@@ -25,6 +25,7 @@
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.persister.entity.EntityPersister;
+import org.redisson.hibernate.region.RedissonEntityRegion;
 
 /**
  * 
@@ -99,12 +100,12 @@ public void remove(SessionImplementor session, Object key) throws CacheException
 
     @Override
     public Object generateCacheKey(Object id, EntityPersister persister, SessionFactoryImplementor factory, String tenantIdentifier) {
-        return DefaultCacheKeysFactory.staticCreateEntityKey( id, persister, factory, tenantIdentifier );
+        return ((RedissonEntityRegion)region).getCacheKeysFactory().createEntityKey( id, persister, factory, tenantIdentifier );
     }
 
     @Override
     public Object getCacheKeyId(Object cacheKey) {
-        return DefaultCacheKeysFactory.staticGetEntityId( cacheKey );
+        return ((RedissonEntityRegion)region).getCacheKeysFactory().getEntityId( cacheKey );
     }
 
 }

File: redisson-hibernate/redisson-hibernate-5/src/main/java/org/redisson/hibernate/strategy/NonStrictReadWriteNaturalIdRegionAccessStrategy.java
Patch:
@@ -24,6 +24,7 @@
 import org.hibernate.cfg.Settings;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.persister.entity.EntityPersister;
+import org.redisson.hibernate.region.RedissonNaturalIdRegion;
 
 /**
  * 
@@ -96,12 +97,12 @@ public void remove(SessionImplementor session, Object key) throws CacheException
 
     @Override
     public Object generateCacheKey(Object[] naturalIdValues, EntityPersister persister, SessionImplementor session) {
-        return DefaultCacheKeysFactory.staticCreateNaturalIdKey(naturalIdValues, persister, session);
+        return ((RedissonNaturalIdRegion)region).getCacheKeysFactory().createNaturalIdKey(naturalIdValues, persister, session);
     }
 
     @Override
     public Object[] getNaturalIdValues(Object cacheKey) {
-        return DefaultCacheKeysFactory.staticGetNaturalIdValues(cacheKey);
+        return ((RedissonNaturalIdRegion)region).getCacheKeysFactory().getNaturalIdValues(cacheKey);
     }
 
 }

File: redisson-hibernate/redisson-hibernate-5/src/main/java/org/redisson/hibernate/strategy/ReadOnlyCollectionRegionAccessStrategy.java
Patch:
@@ -25,6 +25,7 @@
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.persister.collection.CollectionPersister;
+import org.redisson.hibernate.region.RedissonCollectionRegion;
 
 /**
  * 
@@ -69,12 +70,12 @@ public void unlockItem(SessionImplementor session, Object key, SoftLock lock) th
 
     @Override
     public Object generateCacheKey(Object id, CollectionPersister persister, SessionFactoryImplementor factory, String tenantIdentifier) {
-        return DefaultCacheKeysFactory.staticCreateCollectionKey( id, persister, factory, tenantIdentifier );
+        return ((RedissonCollectionRegion)region).getCacheKeysFactory().createCollectionKey(id, persister, factory, tenantIdentifier);
     }
 
     @Override
     public Object getCacheKeyId(Object cacheKey) {
-        return DefaultCacheKeysFactory.staticGetCollectionId(cacheKey);
+        return ((RedissonCollectionRegion)region).getCacheKeysFactory().getCollectionId(cacheKey);
     }
 
 }

File: redisson-hibernate/redisson-hibernate-5/src/main/java/org/redisson/hibernate/strategy/ReadOnlyEntityRegionAccessStrategy.java
Patch:
@@ -25,6 +25,7 @@
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.persister.entity.EntityPersister;
+import org.redisson.hibernate.region.RedissonEntityRegion;
 
 /**
  * 
@@ -93,12 +94,12 @@ public boolean afterUpdate(SessionImplementor session, Object key, Object value,
 
     @Override
     public Object generateCacheKey(Object id, EntityPersister persister, SessionFactoryImplementor factory, String tenantIdentifier) {
-        return DefaultCacheKeysFactory.staticCreateEntityKey( id, persister, factory, tenantIdentifier );
+        return ((RedissonEntityRegion)region).getCacheKeysFactory().createEntityKey( id, persister, factory, tenantIdentifier );
     }
 
     @Override
     public Object getCacheKeyId(Object cacheKey) {
-        return DefaultCacheKeysFactory.staticGetEntityId(cacheKey);
+        return ((RedissonEntityRegion)region).getCacheKeysFactory().getEntityId(cacheKey);
     }
 
 }

File: redisson-hibernate/redisson-hibernate-5/src/main/java/org/redisson/hibernate/strategy/ReadOnlyNaturalIdRegionAccessStrategy.java
Patch:
@@ -24,6 +24,7 @@
 import org.hibernate.cfg.Settings;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.persister.entity.EntityPersister;
+import org.redisson.hibernate.region.RedissonNaturalIdRegion;
 
 /**
  * 
@@ -90,12 +91,12 @@ public boolean afterUpdate(SessionImplementor session, Object key, Object value,
 
     @Override
     public Object generateCacheKey(Object[] naturalIdValues, EntityPersister persister, SessionImplementor session) {
-        return DefaultCacheKeysFactory.staticCreateNaturalIdKey(naturalIdValues, persister, session);
+        return ((RedissonNaturalIdRegion)region).getCacheKeysFactory().createNaturalIdKey(naturalIdValues, persister, session);
     }
 
     @Override
     public Object[] getNaturalIdValues(Object cacheKey) {
-        return DefaultCacheKeysFactory.staticGetNaturalIdValues(cacheKey);
+        return ((RedissonNaturalIdRegion)region).getCacheKeysFactory().getNaturalIdValues(cacheKey);
     }
 
 }

File: redisson-hibernate/redisson-hibernate-5/src/main/java/org/redisson/hibernate/strategy/ReadWriteCollectionRegionAccessStrategy.java
Patch:
@@ -23,6 +23,7 @@
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.redisson.api.RMapCache;
+import org.redisson.hibernate.region.RedissonCollectionRegion;
 
 /**
  * 
@@ -43,12 +44,12 @@ public CollectionRegion getRegion() {
 
     @Override
     public Object generateCacheKey(Object id, CollectionPersister persister, SessionFactoryImplementor factory, String tenantIdentifier) {
-        return DefaultCacheKeysFactory.staticCreateCollectionKey( id, persister, factory, tenantIdentifier );
+        return ((RedissonCollectionRegion)region).getCacheKeysFactory().createCollectionKey( id, persister, factory, tenantIdentifier );
     }
 
     @Override
     public Object getCacheKeyId(Object cacheKey) {
-        return DefaultCacheKeysFactory.staticGetCollectionId(cacheKey);
+        return ((RedissonCollectionRegion)region).getCacheKeysFactory().getCollectionId(cacheKey);
     }
 
 }

File: redisson-hibernate/redisson-hibernate-5/src/main/java/org/redisson/hibernate/strategy/ReadWriteEntityRegionAccessStrategy.java
Patch:
@@ -26,6 +26,7 @@
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.persister.entity.EntityPersister;
 import org.redisson.api.RMapCache;
+import org.redisson.hibernate.region.RedissonEntityRegion;
 
 /**
  * 
@@ -69,12 +70,12 @@ public boolean afterUpdate(SessionImplementor session, Object key, Object value,
 
     @Override
     public Object generateCacheKey(Object id, EntityPersister persister, SessionFactoryImplementor factory, String tenantIdentifier) {
-        return DefaultCacheKeysFactory.staticCreateEntityKey(id, persister, factory, tenantIdentifier);
+        return ((RedissonEntityRegion)region).getCacheKeysFactory().createEntityKey(id, persister, factory, tenantIdentifier);
     }
 
     @Override
     public Object getCacheKeyId(Object cacheKey) {
-        return DefaultCacheKeysFactory.staticGetEntityId(cacheKey);
+        return ((RedissonEntityRegion)region).getCacheKeysFactory().getEntityId(cacheKey);
     }
 
 }

File: redisson-hibernate/redisson-hibernate-5/src/main/java/org/redisson/hibernate/strategy/ReadWriteNaturalIdRegionAccessStrategy.java
Patch:
@@ -25,6 +25,7 @@
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.persister.entity.EntityPersister;
 import org.redisson.api.RMapCache;
+import org.redisson.hibernate.region.RedissonNaturalIdRegion;
 
 /**
  * 
@@ -67,12 +68,12 @@ public boolean afterUpdate(SessionImplementor session, Object key, Object value,
 
     @Override
     public Object generateCacheKey(Object[] naturalIdValues, EntityPersister persister, SessionImplementor session) {
-        return DefaultCacheKeysFactory.staticCreateNaturalIdKey(naturalIdValues, persister, session);
+        return ((RedissonNaturalIdRegion)region).getCacheKeysFactory().createNaturalIdKey(naturalIdValues, persister, session);
     }
 
     @Override
     public Object[] getNaturalIdValues(Object cacheKey) {
-        return DefaultCacheKeysFactory.staticGetNaturalIdValues(cacheKey);
+        return ((RedissonNaturalIdRegion)region).getCacheKeysFactory().getNaturalIdValues(cacheKey);
     }
 
 }

File: redisson-hibernate/redisson-hibernate-5/src/main/java/org/redisson/hibernate/strategy/TransactionalCollectionRegionAccessStrategy.java
Patch:
@@ -25,6 +25,7 @@
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.persister.collection.CollectionPersister;
+import org.redisson.hibernate.region.RedissonCollectionRegion;
 
 /**
  * 
@@ -74,12 +75,12 @@ public void remove(SessionImplementor session, Object key) throws CacheException
 
     @Override
     public Object generateCacheKey(Object id, CollectionPersister persister, SessionFactoryImplementor factory, String tenantIdentifier) {
-        return DefaultCacheKeysFactory.staticCreateCollectionKey( id, persister, factory, tenantIdentifier );
+        return ((RedissonCollectionRegion)region).getCacheKeysFactory().createCollectionKey( id, persister, factory, tenantIdentifier );
     }
 
     @Override
     public Object getCacheKeyId(Object cacheKey) {
-        return DefaultCacheKeysFactory.staticGetCollectionId(cacheKey);
+        return ((RedissonCollectionRegion)region).getCacheKeysFactory().getCollectionId(cacheKey);
     }
 
 }

File: redisson-hibernate/redisson-hibernate-5/src/main/java/org/redisson/hibernate/strategy/TransactionalEntityRegionAccessStrategy.java
Patch:
@@ -25,6 +25,7 @@
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.persister.entity.EntityPersister;
+import org.redisson.hibernate.region.RedissonEntityRegion;
 
 /**
  * 
@@ -97,12 +98,12 @@ public boolean afterUpdate(SessionImplementor session, Object key, Object value,
 
     @Override
     public Object generateCacheKey(Object id, EntityPersister persister, SessionFactoryImplementor factory, String tenantIdentifier) {
-        return DefaultCacheKeysFactory.staticCreateEntityKey(id, persister, factory, tenantIdentifier);
+        return ((RedissonEntityRegion)region).getCacheKeysFactory().createEntityKey(id, persister, factory, tenantIdentifier);
     }
 
     @Override
     public Object getCacheKeyId(Object cacheKey) {
-        return DefaultCacheKeysFactory.staticGetEntityId(cacheKey);
+        return ((RedissonEntityRegion)region).getCacheKeysFactory().getEntityId(cacheKey);
     }
 
 }

File: redisson-hibernate/redisson-hibernate-5/src/main/java/org/redisson/hibernate/strategy/TransactionalNaturalIdRegionAccessStrategy.java
Patch:
@@ -24,6 +24,7 @@
 import org.hibernate.cfg.Settings;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.persister.entity.EntityPersister;
+import org.redisson.hibernate.region.RedissonNaturalIdRegion;
 
 /**
  * 
@@ -94,12 +95,12 @@ public boolean afterUpdate(SessionImplementor session, Object key, Object value,
 
     @Override
     public Object generateCacheKey(Object[] naturalIdValues, EntityPersister persister, SessionImplementor session) {
-        return DefaultCacheKeysFactory.staticCreateNaturalIdKey(naturalIdValues, persister, session);
+        return ((RedissonNaturalIdRegion)region).getCacheKeysFactory().createNaturalIdKey(naturalIdValues, persister, session);
     }
 
     @Override
     public Object[] getNaturalIdValues(Object cacheKey) {
-        return DefaultCacheKeysFactory.staticGetNaturalIdValues(cacheKey);
+        return ((RedissonNaturalIdRegion)region).getCacheKeysFactory().getNaturalIdValues(cacheKey);
     }
 
 }

File: redisson-hibernate/redisson-hibernate-5/src/test/java/org/redisson/hibernate/ReadWriteTest.java
Patch:
@@ -31,7 +31,7 @@ protected Class<?>[] getAnnotatedClasses() {
     protected void configure(Configuration cfg) {
         super.configure(cfg);
         cfg.setProperty(Environment.DRIVER, org.h2.Driver.class.getName());
-        cfg.setProperty(Environment.URL, "jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;MVCC=TRUE");
+        cfg.setProperty(Environment.URL, "jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;");
         cfg.setProperty(Environment.USER, "sa");
         cfg.setProperty(Environment.PASS, "");
         cfg.setProperty(Environment.CACHE_REGION_PREFIX, "");

File: redisson-hibernate/redisson-hibernate-5/src/test/java/org/redisson/hibernate/TransactionalTest.java
Patch:
@@ -31,7 +31,7 @@ protected Class<?>[] getAnnotatedClasses() {
     protected void configure(Configuration cfg) {
         super.configure(cfg);
         cfg.setProperty(Environment.DRIVER, org.h2.Driver.class.getName());
-        cfg.setProperty(Environment.URL, "jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;MVCC=TRUE");
+        cfg.setProperty(Environment.URL, "jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;");
         cfg.setProperty(Environment.USER, "sa");
         cfg.setProperty(Environment.PASS, "");
         cfg.setProperty(Environment.CACHE_REGION_PREFIX, "");

File: redisson-hibernate/redisson-hibernate-52/src/test/java/org/redisson/hibernate/ReadWriteTest.java
Patch:
@@ -31,7 +31,7 @@ protected Class<?>[] getAnnotatedClasses() {
     protected void configure(Configuration cfg) {
         super.configure(cfg);
         cfg.setProperty(Environment.DRIVER, org.h2.Driver.class.getName());
-        cfg.setProperty(Environment.URL, "jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;MVCC=TRUE");
+        cfg.setProperty(Environment.URL, "jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;");
         cfg.setProperty(Environment.USER, "sa");
         cfg.setProperty(Environment.PASS, "");
         cfg.setProperty(Environment.CACHE_REGION_PREFIX, "");

File: redisson-hibernate/redisson-hibernate-52/src/test/java/org/redisson/hibernate/TransactionalTest.java
Patch:
@@ -41,7 +41,7 @@ protected void buildSessionFactory(Consumer<Configuration> configurationAdapter)
     protected void configure(Configuration cfg) {
         super.configure(cfg);
         cfg.setProperty(Environment.DRIVER, org.h2.Driver.class.getName());
-        cfg.setProperty(Environment.URL, "jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;MVCC=TRUE");
+        cfg.setProperty(Environment.URL, "jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;");
         cfg.setProperty(Environment.USER, "sa");
         cfg.setProperty(Environment.PASS, "");
         cfg.setProperty(Environment.CACHE_REGION_PREFIX, "");

File: redisson-hibernate/redisson-hibernate-53/src/test/java/org/redisson/hibernate/ReadWriteTest.java
Patch:
@@ -31,7 +31,7 @@ protected Class<?>[] getAnnotatedClasses() {
     protected void configure(Configuration cfg) {
         super.configure(cfg);
         cfg.setProperty(Environment.DRIVER, org.h2.Driver.class.getName());
-        cfg.setProperty(Environment.URL, "jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;MVCC=TRUE");
+        cfg.setProperty(Environment.URL, "jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;");
         cfg.setProperty(Environment.USER, "sa");
         cfg.setProperty(Environment.PASS, "");
         cfg.setProperty(Environment.CACHE_REGION_PREFIX, "");

File: redisson-hibernate/redisson-hibernate-53/src/test/java/org/redisson/hibernate/TransactionalTest.java
Patch:
@@ -31,7 +31,7 @@ protected Class<?>[] getAnnotatedClasses() {
     protected void configure(Configuration cfg) {
         super.configure(cfg);
         cfg.setProperty(Environment.DRIVER, org.h2.Driver.class.getName());
-        cfg.setProperty(Environment.URL, "jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;MVCC=TRUE");
+        cfg.setProperty(Environment.URL, "jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;");
         cfg.setProperty(Environment.USER, "sa");
         cfg.setProperty(Environment.PASS, "");
         cfg.setProperty(Environment.CACHE_REGION_PREFIX, "");

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStringCommands.java
Patch:
@@ -89,15 +89,15 @@ public Flux<BooleanResponse<SetCommand>> set(Publisher<SetCommand> commands) {
                 }
             } else {
                 if (!command.getOption().isPresent() || command.getOption().get() == SetOption.UPSERT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds());
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds());
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
                 if (command.getOption().get() == SetOption.SET_IF_ABSENT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "NX");
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "NX");
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
                 if (command.getOption().get() == SetOption.SET_IF_PRESENT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "XX");
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "XX");
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
             }

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStringCommands.java
Patch:
@@ -89,15 +89,15 @@ public Flux<BooleanResponse<SetCommand>> set(Publisher<SetCommand> commands) {
                 }
             } else {
                 if (!command.getOption().isPresent() || command.getOption().get() == SetOption.UPSERT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds());
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds());
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
                 if (command.getOption().get() == SetOption.SET_IF_ABSENT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "NX");
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "NX");
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
                 if (command.getOption().get() == SetOption.SET_IF_PRESENT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "XX");
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "XX");
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
             }

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStringCommands.java
Patch:
@@ -89,15 +89,15 @@ public Flux<BooleanResponse<SetCommand>> set(Publisher<SetCommand> commands) {
                 }
             } else {
                 if (!command.getOption().isPresent() || command.getOption().get() == SetOption.UPSERT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds());
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds());
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
                 if (command.getOption().get() == SetOption.SET_IF_ABSENT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "NX");
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "NX");
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
                 if (command.getOption().get() == SetOption.SET_IF_PRESENT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "XX");
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "XX");
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
             }

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStringCommands.java
Patch:
@@ -89,15 +89,15 @@ public Flux<BooleanResponse<SetCommand>> set(Publisher<SetCommand> commands) {
                 }
             } else {
                 if (!command.getOption().isPresent() || command.getOption().get() == SetOption.UPSERT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds());
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds());
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
                 if (command.getOption().get() == SetOption.SET_IF_ABSENT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "NX");
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "NX");
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
                 if (command.getOption().get() == SetOption.SET_IF_PRESENT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "XX");
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "XX");
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
             }

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStringCommands.java
Patch:
@@ -89,15 +89,15 @@ public Flux<BooleanResponse<SetCommand>> set(Publisher<SetCommand> commands) {
                 }
             } else {
                 if (!command.getOption().isPresent() || command.getOption().get() == SetOption.UPSERT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds());
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds());
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
                 if (command.getOption().get() == SetOption.SET_IF_ABSENT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "NX");
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "NX");
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
                 if (command.getOption().get() == SetOption.SET_IF_PRESENT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "XX");
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "XX");
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
             }

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonReactiveStringCommands.java
Patch:
@@ -89,15 +89,15 @@ public Flux<BooleanResponse<SetCommand>> set(Publisher<SetCommand> commands) {
                 }
             } else {
                 if (!command.getOption().isPresent() || command.getOption().get() == SetOption.UPSERT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds());
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds());
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
                 if (command.getOption().get() == SetOption.SET_IF_ABSENT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "NX");
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "NX");
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
                 if (command.getOption().get() == SetOption.SET_IF_PRESENT) {
-                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "XX");
+                    Mono<Boolean> m = write(key, StringCodec.INSTANCE, SET, key, value, "PX", command.getExpiration().get().getExpirationTimeInMilliseconds(), "XX");
                     return m.map(v -> new BooleanResponse<>(command, v));
                 }
             }

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -492,7 +492,7 @@ private void updateSentinels(Set<RedisURI> newUris) {
             if (sentinel != null) {
                 disconnectNode(sentinel);
                 sentinel.shutdownAsync();
-                log.warn("sentinel: {} has down", uri);
+                log.warn("sentinel: {} was down", uri);
             }
         }
     }
@@ -581,11 +581,11 @@ private RFuture<Void> addSlave(RedisURI uri) {
 
     private void slaveDown(RedisURI uri) {
         if (config.checkSkipSlavesInit()) {
-            log.warn("slave: {} has down", uri);
+            log.warn("slave: {} was down", uri);
         } else {
             MasterSlaveEntry entry = getEntry(singleSlotRange.getStartSlot());
             if (entry.slaveDown(uri, FreezeReason.MANAGER)) {
-                log.warn("slave: {} has down", uri);
+                log.warn("slave: {} was down", uri);
             }
         }
     }

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -51,7 +51,8 @@ public class RedissonSession extends StandardSession {
     public static final Set<String> ATTRS = new HashSet<String>(Arrays.asList(
             IS_NEW_ATTR, IS_VALID_ATTR, 
             THIS_ACCESSED_TIME_ATTR, MAX_INACTIVE_INTERVAL_ATTR, 
-            LAST_ACCESSED_TIME_ATTR, CREATION_TIME_ATTR, IS_EXPIRATION_LOCKED
+            LAST_ACCESSED_TIME_ATTR, CREATION_TIME_ATTR, IS_EXPIRATION_LOCKED,
+            PRINCIPAL_ATTR, AUTHTYPE_ATTR
             ));
     
     private boolean isExpirationLocked;

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -51,7 +51,8 @@ public class RedissonSession extends StandardSession {
     public static final Set<String> ATTRS = new HashSet<String>(Arrays.asList(
             IS_NEW_ATTR, IS_VALID_ATTR, 
             THIS_ACCESSED_TIME_ATTR, MAX_INACTIVE_INTERVAL_ATTR, 
-            LAST_ACCESSED_TIME_ATTR, CREATION_TIME_ATTR, IS_EXPIRATION_LOCKED
+            LAST_ACCESSED_TIME_ATTR, CREATION_TIME_ATTR, IS_EXPIRATION_LOCKED,
+            PRINCIPAL_ATTR, AUTHTYPE_ATTR
             ));
     
     private boolean isExpirationLocked;

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -51,7 +51,8 @@ public class RedissonSession extends StandardSession {
     public static final Set<String> ATTRS = new HashSet<String>(Arrays.asList(
             IS_NEW_ATTR, IS_VALID_ATTR, 
             THIS_ACCESSED_TIME_ATTR, MAX_INACTIVE_INTERVAL_ATTR, 
-            LAST_ACCESSED_TIME_ATTR, CREATION_TIME_ATTR, IS_EXPIRATION_LOCKED
+            LAST_ACCESSED_TIME_ATTR, CREATION_TIME_ATTR, IS_EXPIRATION_LOCKED,
+            PRINCIPAL_ATTR, AUTHTYPE_ATTR
             ));
     
     private boolean isExpirationLocked;

File: redisson/src/main/java/org/redisson/command/CommandBatchService.java
Patch:
@@ -102,7 +102,7 @@ public void clearErrors() {
     private ConcurrentMap<MasterSlaveEntry, Entry> commands = new ConcurrentHashMap<>();
     private ConcurrentMap<MasterSlaveEntry, ConnectionEntry> connections = new ConcurrentHashMap<>();
     
-    private BatchOptions options;
+    private BatchOptions options = BatchOptions.defaults();
     
     private Map<RFuture<?>, List<CommandBatchService>> nestedServices = new ConcurrentHashMap<>();
 

File: redisson/src/main/java/org/redisson/liveobject/LiveObjectSearch.java
Patch:
@@ -120,6 +120,9 @@ private Set<Object> traverseAnd(ANDCondition condition, NamingScheme namingSchem
             } else {
                 allIds.addAll(intersect);
             }
+            if (allIds.isEmpty()) {
+                return allIds;
+            }
         }
 
         if (!checkValueRange(allIds, eqNumericNames, (r, v) -> {

File: redisson/src/main/java/org/redisson/RedissonTopic.java
Patch:
@@ -261,7 +261,7 @@ public void removeListener(Integer... listenerIds) {
     public int countListeners() {
         PubSubConnectionEntry entry = subscribeService.getPubSubEntry(channelName);
         if (entry != null) {
-            return entry.countListeners();
+            return entry.countListeners(channelName);
         }
         return 0;
     }

File: redisson/src/main/java/org/redisson/RedissonBloomFilter.java
Patch:
@@ -121,7 +121,7 @@ public boolean add(T object) {
                 bs.setAsync(indexes[i]);
             }
             try {
-                List<Boolean> result = (List<Boolean>) executorService.execute();
+                List<Boolean> result = (List<Boolean>) executorService.execute().getResponses();
 
                 for (Boolean val : result.subList(1, result.size()-1)) {
                     if (!val) {
@@ -172,7 +172,7 @@ public boolean contains(T object) {
                 bs.getAsync(indexes[i]);
             }
             try {
-                List<Boolean> result = (List<Boolean>) executorService.execute();
+                List<Boolean> result = (List<Boolean>) executorService.execute().getResponses();
 
                 for (Boolean val : result.subList(1, result.size()-1)) {
                     if (!val) {

File: redisson/src/main/java/org/redisson/RedissonStream.java
Patch:
@@ -239,9 +239,9 @@ public RFuture<Map<StreamMessageId, Map<K, V>>> readGroupAsync(String groupName,
         }
 
         if (timeout > 0) {
-            return commandExecutor.readAsync(getName(), codec, RedisCommands.XREADGROUP_BLOCKING_SINGLE, params.toArray());
+            return commandExecutor.writeAsync(getName(), codec, RedisCommands.XREADGROUP_BLOCKING_SINGLE, params.toArray());
         }
-        return commandExecutor.readAsync(getName(), codec, RedisCommands.XREADGROUP_SINGLE, params.toArray());
+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.XREADGROUP_SINGLE, params.toArray());
     }
     
     @Override

File: redisson/src/main/java/org/redisson/codec/FstCodec.java
Patch:
@@ -191,7 +191,7 @@ public FstCodec(ClassLoader classLoader, FstCodec codec) {
     }
 
     private static FSTConfiguration copy(ClassLoader classLoader, FstCodec codec) {
-        FSTConfiguration def = FSTConfiguration.createDefaultConfiguration();
+        FSTConfiguration def = codec.config.deriveConfiguration();
         def.setClassLoader(classLoader);
         def.setCoderSpecific(codec.config.getCoderSpecific());
         def.setCrossPlatform(codec.config.isCrossPlatform());

File: redisson/src/main/java/org/redisson/codec/FstCodec.java
Patch:
@@ -191,7 +191,7 @@ public FstCodec(ClassLoader classLoader, FstCodec codec) {
     }
 
     private static FSTConfiguration copy(ClassLoader classLoader, FstCodec codec) {
-        FSTConfiguration def = FSTConfiguration.createDefaultConfiguration();
+        FSTConfiguration def = codec.config.deriveConfiguration();
         def.setClassLoader(classLoader);
         def.setCoderSpecific(codec.config.getCoderSpecific());
         def.setCrossPlatform(codec.config.isCrossPlatform());

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -530,7 +530,7 @@ public byte[] getSet(byte[] key, byte[] value) {
     
     @Override
     public List<byte[]> mGet(byte[]... keys) {
-        return write(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
+        return read(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -560,7 +560,7 @@ public byte[] getSet(byte[] key, byte[] value) {
     
     @Override
     public List<byte[]> mGet(byte[]... keys) {
-        return write(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
+        return read(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -576,7 +576,7 @@ public byte[] getSet(byte[] key, byte[] value) {
     
     @Override
     public List<byte[]> mGet(byte[]... keys) {
-        return write(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
+        return read(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -543,7 +543,7 @@ public byte[] getSet(byte[] key, byte[] value) {
     
     @Override
     public List<byte[]> mGet(byte[]... keys) {
-        return write(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
+        return read(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
     }
 
     private static final RedisCommand<Boolean> SET = new RedisCommand<Boolean>("SET", new BooleanReplayConvertor());

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -573,7 +573,7 @@ public byte[] getSet(byte[] key, byte[] value) {
     
     @Override
     public List<byte[]> mGet(byte[]... keys) {
-        return write(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
+        return read(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
     }
 
     private static final RedisCommand<Boolean> SET = new RedisCommand<Boolean>("SET", new BooleanReplayConvertor());

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -565,7 +565,7 @@ public byte[] getSet(byte[] key, byte[] value) {
     
     @Override
     public List<byte[]> mGet(byte[]... keys) {
-        return write(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
+        return read(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
     }
 
     private static final RedisCommand<Boolean> SET = new RedisCommand<Boolean>("SET", new BooleanReplayConvertor());

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -530,7 +530,7 @@ public byte[] getSet(byte[] key, byte[] value) {
     
     @Override
     public List<byte[]> mGet(byte[]... keys) {
-        return write(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
+        return read(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -560,7 +560,7 @@ public byte[] getSet(byte[] key, byte[] value) {
     
     @Override
     public List<byte[]> mGet(byte[]... keys) {
-        return write(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
+        return read(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -576,7 +576,7 @@ public byte[] getSet(byte[] key, byte[] value) {
     
     @Override
     public List<byte[]> mGet(byte[]... keys) {
-        return write(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
+        return read(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -543,7 +543,7 @@ public byte[] getSet(byte[] key, byte[] value) {
     
     @Override
     public List<byte[]> mGet(byte[]... keys) {
-        return write(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
+        return read(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
     }
 
     private static final RedisCommand<Boolean> SET = new RedisCommand<Boolean>("SET", new BooleanReplayConvertor());

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -573,7 +573,7 @@ public byte[] getSet(byte[] key, byte[] value) {
     
     @Override
     public List<byte[]> mGet(byte[]... keys) {
-        return write(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
+        return read(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
     }
 
     private static final RedisCommand<Boolean> SET = new RedisCommand<Boolean>("SET", new BooleanReplayConvertor());

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -565,7 +565,7 @@ public byte[] getSet(byte[] key, byte[] value) {
     
     @Override
     public List<byte[]> mGet(byte[]... keys) {
-        return write(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
+        return read(keys[0], ByteArrayCodec.INSTANCE, MGET, Arrays.asList(keys).toArray());
     }
 
     private static final RedisCommand<Boolean> SET = new RedisCommand<Boolean>("SET", new BooleanReplayConvertor());

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -344,7 +344,7 @@ public void save() {
             
             if (updateMode == UpdateMode.AFTER_REQUEST) {
                 if (!removedAttributes.isEmpty()) {
-                    topic.publish(new AttributeRemoveMessage(redissonManager.getNodeId(), getId(), removedAttributes));
+                    topic.publish(new AttributeRemoveMessage(redissonManager.getNodeId(), getId(), new HashSet<>(removedAttributes)));
                 }
             }
         }

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -344,7 +344,7 @@ public void save() {
             
             if (updateMode == UpdateMode.AFTER_REQUEST) {
                 if (!removedAttributes.isEmpty()) {
-                    topic.publish(new AttributeRemoveMessage(redissonManager.getNodeId(), getId(), removedAttributes));
+                    topic.publish(new AttributeRemoveMessage(redissonManager.getNodeId(), getId(), new HashSet<>(removedAttributes)));
                 }
             }
         }

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -350,7 +350,7 @@ public void save() {
             
             if (updateMode == UpdateMode.AFTER_REQUEST) {
                 if (!removedAttributes.isEmpty()) {
-                    topic.publish(new AttributeRemoveMessage(redissonManager.getNodeId(), getId(), removedAttributes));
+                    topic.publish(new AttributeRemoveMessage(redissonManager.getNodeId(), getId(), new HashSet<>(removedAttributes)));
                 }
             }
         }

File: redisson/src/main/java/org/redisson/cache/LocalCacheListener.java
Patch:
@@ -255,6 +255,7 @@ public RFuture<Void> clearLocalCacheAsync() {
             }
 
             RSemaphore semaphore = getClearSemaphore(id);
+            semaphore.expireAsync(60, TimeUnit.SECONDS);
             semaphore.acquireAsync(res.intValue()).onComplete((r, ex) -> {
                 if (ex != null) {
                     result.tryFailure(ex);
@@ -346,7 +347,7 @@ private void loadAfterReconnection() {
         });
     }
 
-    protected RSemaphore getClearSemaphore(byte[] requestId) {
+    private RSemaphore getClearSemaphore(byte[] requestId) {
         String id = ByteBufUtil.hexDump(requestId);
         RSemaphore semaphore = new RedissonSemaphore(commandExecutor, name + ":clear:" + id);
         return semaphore;

File: redisson/src/main/java/org/redisson/config/Config.java
Patch:
@@ -18,7 +18,6 @@
 import io.netty.channel.EventLoopGroup;
 import org.redisson.client.codec.Codec;
 import org.redisson.codec.FstCodec;
-import org.redisson.codec.MarshallingCodec;
 import org.redisson.connection.AddressResolverGroupFactory;
 import org.redisson.connection.ConnectionManager;
 import org.redisson.connection.DnsAddressResolverGroupFactory;

File: redisson/src/main/java/org/redisson/RedissonPatternTopic.java
Patch:
@@ -90,7 +90,7 @@ public <T> RFuture<Integer> addListenerAsync(Class<T> type, PatternMessageListen
     }
     
     private RFuture<Integer> addListenerAsync(RedisPubSubListener<?> pubSubListener) {
-        RFuture<PubSubConnectionEntry> future = subscribeService.subscribe(codec, channelName, pubSubListener);
+        RFuture<PubSubConnectionEntry> future = subscribeService.psubscribe(channelName, codec, pubSubListener);
         RPromise<Integer> result = new RedissonPromise<Integer>();
         future.onComplete((res, e) -> {
             if (e != null) {

File: redisson/src/test/java/org/redisson/ClusterRunner.java
Patch:
@@ -79,6 +79,8 @@ public synchronized ClusterProcesses run() throws IOException, InterruptedExcept
         if (!allAlive) {
             throw new RedisRunner.FailedToStartRedisException();
         }
+        Thread.sleep(1000);
+
         return new ClusterProcesses(processes);
     }
     

File: redisson/src/main/java/org/redisson/misc/RedisURI.java
Patch:
@@ -31,7 +31,7 @@ public class RedisURI {
     private final int port;
 
     public RedisURI(String scheme, String host, int port) {
-        this.ssl = scheme.equals("rediss");
+        this.ssl = "rediss".equals(scheme);
         this.host = host;
         this.port = port;
     }

File: redisson/src/test/java/org/redisson/rx/RedissonBatchRxTest.java
Patch:
@@ -110,7 +110,7 @@ public void testConvertor() throws InterruptedException, ExecutionException {
         assertThat(sync(b2f2)).isEqualTo(2d);
     }
     
-    @Test(timeout = 15000)
+    @Test(timeout = 20000)
     public void testPerformance() {
         RMapRx<String, String> map = redisson.getMap("map");
         Map<String, String> m = new HashMap<String, String>();

File: redisson/src/main/java/org/redisson/misc/RedisURI.java
Patch:
@@ -31,7 +31,9 @@ public class RedisURI {
     private final int port;
 
     public RedisURI(String scheme, String host, int port) {
-        this(scheme + "://" + host + ":" + port);
+        this.ssl = scheme.equals("rediss");
+        this.host = host;
+        this.port = port;
     }
 
     public RedisURI(String uri) {

File: redisson/src/test/java/org/redisson/rx/RedissonBlockingDequeRxTest.java
Patch:
@@ -51,7 +51,7 @@ public void testPollLastAndOfferFirstTo() throws InterruptedException {
         RBlockingDequeRx<String> blockingDeque = redisson.getBlockingDeque("blocking_deque");
         long start = System.currentTimeMillis();
         String redisTask = sync(blockingDeque.pollLastAndOfferFirstTo("deque", 1, TimeUnit.SECONDS));
-        assertThat(System.currentTimeMillis() - start).isBetween(950L, 1100L);
+        assertThat(System.currentTimeMillis() - start).isBetween(950L, 1110L);
         assertThat(redisTask).isNull();
     }
     

File: redisson/src/test/java/org/redisson/RedissonGeoTest.java
Patch:
@@ -509,8 +509,8 @@ public void testRadiusMemberWithPositionOrderCount() {
         RGeo<String> geo2 = redisson.getGeo("test2");
         geo2.add(new GeoEntry(13.361389, 38.115556, "Palermo"), new GeoEntry(13.361390, 38.115557, "Catania"));
         Map<String, GeoPosition> ascExpected2 = new LinkedHashMap<String, GeoPosition>();
-        ascExpected2.put("Catania", new GeoPosition(13.361389338970184, 38.115556395496299));
         ascExpected2.put("Palermo", new GeoPosition(13.361389338970184, 38.115556395496299));
+        ascExpected2.put("Catania", new GeoPosition(13.361389338970184, 38.115556395496299));
         assertThat(geo2.radiusWithPosition("Palermo", 200, GeoUnit.KILOMETERS, GeoOrder.DESC, 2).entrySet()).containsExactlyElementsOf(ascExpected2.entrySet());
     }
 

File: redisson/src/test/java/org/redisson/RedissonPermitExpirableSemaphoreTest.java
Patch:
@@ -62,7 +62,7 @@ public void testExpiration() throws InterruptedException {
         semaphore.trySetPermits(1);
         semaphore.expire(3, TimeUnit.SECONDS);
         semaphore.tryAcquire(1, 1, TimeUnit.SECONDS);
-        Thread.sleep(4000);
+        Thread.sleep(4100);
         assertThat(redisson.getKeys().count()).isZero();
     }
 

File: redisson/src/test/java/org/redisson/RedissonTransferQueueTest.java
Patch:
@@ -63,7 +63,7 @@ public void testTransfer() throws InterruptedException, ExecutionException {
                 long time = System.currentTimeMillis();
                 queue.transfer(3);
                 assertThat(takeExecuted.get()).isTrue();
-                assertThat(System.currentTimeMillis() - time).isGreaterThan(3000);
+                assertThat(System.currentTimeMillis() - time).isGreaterThan(2950);
             } catch (InterruptedException e) {
                 Thread.currentThread().interrupt();
             }

File: redisson/src/test/java/org/redisson/transaction/RedissonTransactionalBucketTest.java
Patch:
@@ -22,7 +22,7 @@ public void testTimeout() throws InterruptedException {
         RBucket<String> bucket = transaction.getBucket("test");
         bucket.set("234");
         
-        Thread.sleep(3000);
+        Thread.sleep(4000);
         
         try {
             transaction.commit();

File: redisson/src/test/java/org/redisson/RedissonBucketTest.java
Patch:
@@ -119,7 +119,7 @@ public void testSizeInMemory() {
         Assume.assumeTrue(RedisRunner.getDefaultRedisServerInstance().getRedisVersion().compareTo("4.0.0") > 0);
         RBucket<Integer> al = redisson.getBucket("test");
         al.set(1234);
-        assertThat(al.sizeInMemory()).isEqualTo(55);
+        assertThat(al.sizeInMemory()).isEqualTo(54);
     }
     
     @Test

File: redisson/src/test/java/org/redisson/RedissonRateLimiterTest.java
Patch:
@@ -152,7 +152,7 @@ public void run() {
         for (Long value : queue) {
             if (count % 10 == 0) {
                 if (start > 0) {
-                    assertThat(value - start).isGreaterThan(999);
+                    assertThat(value - start).isGreaterThan(990);
                 }
                 start = value;
             }

File: redisson/src/test/java/org/redisson/RedissonRemoteServiceTest.java
Patch:
@@ -282,6 +282,7 @@ public void testConcurrentInvocations() {
                         service.methodOverload();
                     }
                 } catch (Exception e) {
+                    e.printStackTrace();
                     bool.set(true);
                 }
             }));

File: redisson/src/test/java/org/redisson/RedisRunner.java
Patch:
@@ -475,7 +475,7 @@ public RedisRunner randomDir() {
         makeRandomDefaultDir();
         
         
-        addConfigOption(REDIS_OPTIONS.DIR, "\"" + defaultDir + "\"");
+        addConfigOption(REDIS_OPTIONS.DIR, defaultDir);
         return this;
     }
 

File: redisson/src/main/java/org/redisson/api/LocalCachedMapOptions.java
Patch:
@@ -221,7 +221,7 @@ public LocalCachedMapOptions<K, V> syncStrategy(SyncStrategy syncStrategy) {
     }
     
     /**
-     * Defines eviction policy.
+     * Defines local cache eviction policy.
      * 
      * @param evictionPolicy
      *         <p><code>LRU</code> - uses local cache with LRU (least recently used) eviction policy.

File: redisson/src/test/java/org/redisson/transaction/RedissonTransactionalBucketReactiveTest.java
Patch:
@@ -113,7 +113,7 @@ public void testGetAndRemove() {
         RTransactionReactive transaction = redisson.createTransaction(TransactionOptions.defaults());
         RBucketReactive<String> set = transaction.getBucket("test");
         assertThat(sync(set.get())).isEqualTo("123");
-        assertThat(sync(set.size())).isEqualTo(10);
+        assertThat(sync(set.size())).isEqualTo(5);
         assertThat(sync(set.getAndDelete())).isEqualTo("123");
         assertThat(sync(set.size())).isEqualTo(0);
         assertThat(sync(set.get())).isNull();

File: redisson/src/test/java/org/redisson/transaction/RedissonTransactionalBucketTest.java
Patch:
@@ -113,7 +113,7 @@ public void testGetAndRemove() {
         RTransaction transaction = redisson.createTransaction(TransactionOptions.defaults());
         RBucket<String> set = transaction.getBucket("test");
         assertThat(set.get()).isEqualTo("123");
-        assertThat(set.size()).isEqualTo(10);
+        assertThat(set.size()).isEqualTo(5);
         assertThat(set.getAndDelete()).isEqualTo("123");
         assertThat(set.size()).isEqualTo(0);
         assertThat(set.get()).isNull();

File: redisson/src/test/java/org/redisson/executor/RedissonExecutorServiceTest.java
Patch:
@@ -268,7 +268,6 @@ private void finish(Invocation invocation, String requestId, boolean removeTask)
         Thread.sleep(16000);
         assertThat(redisson.getAtomicLong("counter").get()).isEqualTo(2);
         
-        executor.delete();
         redisson.getKeys().delete("counter");
         assertThat(redisson.getKeys().count()).isEqualTo(1);
     }

File: redisson/src/test/java/org/redisson/executor/RedissonScheduledExecutorServiceTest.java
Patch:
@@ -237,7 +237,7 @@ public void testLoad() {
     public void testCronExpression() throws InterruptedException, ExecutionException {
         RScheduledExecutorService executor = redisson.getExecutorService("test");
         executor.schedule(new ScheduledRunnableTask("executed"), CronSchedule.of("0/2 * * * * ?"));
-        Thread.sleep(4200);
+        Thread.sleep(4000);
         assertThat(redisson.getAtomicLong("executed").get()).isEqualTo(2);
     }
 

File: redisson/src/test/java/org/redisson/executor/RedissonExecutorServiceTest.java
Patch:
@@ -237,7 +237,7 @@ public void testNodeFailover() throws Exception {
         AtomicInteger counter = new AtomicInteger();
         new MockUp<TasksRunnerService>() {
             @Mock
-            private void finish(Invocation invocation, String requestId) {
+            private void finish(Invocation invocation, String requestId, boolean removeTask) {
                 if (counter.incrementAndGet() > 1) {
                     invocation.proceed();
                 }

File: redisson/src/test/java/org/redisson/executor/RedissonScheduledExecutorServiceTest.java
Patch:
@@ -190,7 +190,7 @@ private void finish(Invocation invocation, String requestId, boolean removeTask)
         assertThat(redisson.getAtomicLong("counter").get()).isEqualTo(2);
         
         redisson.getKeys().delete("counter");
-        assertThat(redisson.getKeys().count()).isEqualTo(2);
+        assertThat(redisson.getKeys().count()).isEqualTo(1);
     }
 
     @Test(timeout = 7000)

File: redisson/src/main/java/org/redisson/api/RPriorityQueue.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.util.Comparator;
 import java.util.List;
-import java.util.Queue;
 
 /**
  * 

File: redisson/src/main/java/org/redisson/api/RPriorityDeque.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.redisson.api;
 
-import java.util.Deque;
 import java.util.stream.Stream;
 
 /**

File: redisson/src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -344,7 +344,7 @@ <T> RFuture<T> tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, R
 
         return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,
                   "if (redis.call('exists', KEYS[1]) == 0) then " +
-                      "redis.call('hset', KEYS[1], ARGV[2], 1); " +
+                      "redis.call('hincrby', KEYS[1], ARGV[2], 1); " +
                       "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                       "return nil; " +
                   "end; " +

File: redisson/src/main/java/org/redisson/codec/LZ4Codec.java
Patch:
@@ -50,7 +50,7 @@ public class LZ4Codec extends BaseCodec {
     private final Codec innerCodec;
 
     public LZ4Codec() {
-        this(new FstCodec());
+        this(new Kryo5Codec());
     }
 
     public LZ4Codec(Codec innerCodec) {

File: redisson/src/main/java/org/redisson/eviction/MapCacheEvictionTask.java
Patch:
@@ -74,7 +74,7 @@ RFuture<Integer> execute() {
                     + "end;"  
                 + "end;" 
               + "if #expiredKeys1 > 0 then "
-                  + "redis.call('zrem', KEYS[4], unpack(expiredKeys1)); "
+                  + "redis.call('zrem', KEYS[5], unpack(expiredKeys1)); "
                   + "redis.call('zrem', KEYS[3], unpack(expiredKeys1)); "
                   + "redis.call('zrem', KEYS[2], unpack(expiredKeys1)); "
                   + "redis.call('hdel', KEYS[1], unpack(expiredKeys1)); "
@@ -92,7 +92,7 @@ RFuture<Integer> execute() {
                   + "end;"  
               + "end;" 
               + "if #expiredKeys2 > 0 then "
-                  + "redis.call('zrem', KEYS[4], unpack(expiredKeys2)); "
+                  + "redis.call('zrem', KEYS[5], unpack(expiredKeys2)); "
                   + "redis.call('zrem', KEYS[3], unpack(expiredKeys2)); "
                   + "redis.call('zrem', KEYS[2], unpack(expiredKeys2)); "
                   + "redis.call('hdel', KEYS[1], unpack(expiredKeys2)); "

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -50,8 +50,8 @@
 import org.redisson.client.protocol.decoder.MapCacheScanResultReplayDecoder;
 import org.redisson.client.protocol.decoder.MapScanResult;
 import org.redisson.client.protocol.decoder.ObjectMapDecoder;
+import org.redisson.codec.BaseEventCodec;
 import org.redisson.codec.MapCacheEventCodec;
-import org.redisson.codec.MapCacheEventCodec.OSType;
 import org.redisson.command.CommandAsyncExecutor;
 import org.redisson.connection.decoder.MapGetAllDecoder;
 import org.redisson.eviction.EvictionScheduler;
@@ -1882,9 +1882,9 @@ public int addListener(MapEntryListener listener) {
             serverFuture.syncUninterruptibly();
             String os = serverFuture.getNow().get("os");
             if (os.contains("Windows")) {
-                osType = OSType.WINDOWS;
+                osType = BaseEventCodec.OSType.WINDOWS;
             } else if (os.contains("NONSTOP")) {
-                osType = OSType.HPNONSTOP;
+                osType = BaseEventCodec.OSType.HPNONSTOP;
             }
         }
 

File: redisson/src/test/java/org/redisson/RedissonBloomFilterTest.java
Patch:
@@ -43,6 +43,7 @@ public void testInit() {
 
         filter.delete();
 
+        assertThat(redisson.getKeys().count()).isZero();
         assertThat(filter.tryInit(55000001L, 0.03)).isTrue();
     }
 

File: redisson/src/test/java/org/redisson/RedissonTopicTest.java
Patch:
@@ -798,6 +798,8 @@ public void testResubscriptionAfterFailover() throws Exception {
 
         Assert.assertFalse(exceptionDetected.get());
 
+        executor1.shutdownNow();
+
         redisson.shutdown();
         sentinel1.stop();
         sentinel2.stop();

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -657,7 +657,7 @@ protected RFuture<RedisConnection> getConnection() {
         return connectionFuture;
     }
     
-    private static final Map<ClassLoader, Map<Codec, Codec>> CODECS = ReferenceCacheMap.soft(0, 0);
+    private static final Map<ClassLoader, Map<Codec, Codec>> CODECS = ReferenceCacheMap.soft(0, 60*60*1000);
 
     protected Codec getCodec(Codec codec) {
         if (codec == null) {

File: redisson/src/main/java/org/redisson/config/ClusterServersConfig.java
Patch:
@@ -96,7 +96,7 @@ public boolean isCheckSlotsCoverage() {
     /**
      * Enables cluster slots check during Redisson startup.
      * <p>
-     * Default is <code>false</code>
+     * Default is <code>true</code>
      *
      * @param checkSlotsCoverage - boolean value
      * @return config

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -155,9 +155,9 @@ public ClusterConnectionManager(ClusterServersConfig cfg, Config config, UUID id
         if (cfg.isCheckSlotsCoverage() && lastPartitions.size() != MAX_SLOT) {
             stopThreads();
             if (failedMasters.isEmpty()) {
-                throw new RedisConnectionException("Not all slots covered! Only " + lastPartitions.size() + " slots are available", lastException);
+                throw new RedisConnectionException("Not all slots covered! Only " + lastPartitions.size() + " slots are available. Set checkSlotsCoverage = false to avoid this check.", lastException);
             } else {
-                throw new RedisConnectionException("Not all slots covered! Only " + lastPartitions.size() + " slots are available. Failed masters according to cluster status: " + failedMasters, lastException);
+                throw new RedisConnectionException("Not all slots covered! Only " + lastPartitions.size() + " slots are available. Set checkSlotsCoverage = false to avoid this check. Failed masters according to cluster status: " + failedMasters, lastException);
             }
         }
         

File: redisson/src/main/java/org/redisson/config/ClusterServersConfig.java
Patch:
@@ -43,7 +43,7 @@ public class ClusterServersConfig extends BaseMasterSlaveServersConfig<ClusterSe
      */
     private int scanInterval = 5000;
 
-    private boolean checkSlotsCoverage;
+    private boolean checkSlotsCoverage = true;
 
     public ClusterServersConfig() {
     }

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -474,6 +474,7 @@ private void updateSentinels(Set<RedisURI> newUris) {
         for (RedisURI uri : currentUris) {
             RedisClient sentinel = SentinelConnectionManager.this.sentinels.remove(uri);
             if (sentinel != null) {
+                disconnectNode(sentinel);
                 sentinel.shutdownAsync();
                 log.warn("sentinel: {} has down", uri);
             }

File: redisson/src/main/java/org/redisson/misc/RedisURI.java
Patch:
@@ -124,7 +124,7 @@ public boolean equals(Object obj) {
 
     @Override
     public String toString() {
-        return getScheme() + "://" + host + ":" + port;
+        return getScheme() + "://" + trimIpv6Brackets(host) + ":" + port;
     }
     
 }

File: redisson/src/main/java/org/redisson/config/BaseConfig.java
Patch:
@@ -180,7 +180,6 @@ public int getRetryAttempts() {
      * <p>
      * Default is <code>1500</code> milliseconds
      *
-     * @see {@link #setRetryInterval(int)}
      * @param retryInterval - time in milliseconds
      * @return config
      */

File: redisson/src/main/java/org/redisson/config/BaseConfig.java
Patch:
@@ -180,7 +180,7 @@ public int getRetryAttempts() {
      * <p>
      * Default is <code>1500</code> milliseconds
      *
-     * @see retryAttempts
+     * @see {@link #setRetryInterval(int)}
      * @param retryInterval - time in milliseconds
      * @return config
      */
@@ -257,6 +257,8 @@ public int getConnectTimeout() {
      * If pooled connection not used for a <code>timeout</code> time
      * and current connections amount bigger than minimum idle connections pool size,
      * then it will closed and removed from pool.
+     * <p>
+     * Default is <code>10000</code> milliseconds.
      *
      * @param idleConnectionTimeout - timeout in milliseconds
      * @return config

File: redisson/src/main/java/org/redisson/config/BaseMasterSlaveServersConfig.java
Patch:
@@ -224,7 +224,7 @@ public int getSubscriptionConnectionPoolSize() {
     /**
      * Minimum idle connection pool size for subscription (pub/sub) channels
      * <p>
-     * Default is <code>10</code>
+     * Default is <code>24</code>
      * <p>
      * @see #setSlaveConnectionPoolSize(int)
      * 
@@ -242,7 +242,7 @@ public int getSlaveConnectionMinimumIdleSize() {
     /**
      * Redis 'master' node minimum idle connection amount for <b>each</b> slave node
      * <p>
-     * Default is <code>10</code>
+     * Default is <code>24</code>
      * <p>
      * @see #setMasterConnectionPoolSize(int)
      * 

File: redisson/src/main/java/org/redisson/config/Config.java
Patch:
@@ -138,7 +138,7 @@ public Config(Config oldConf) {
     }
 
     /**
-     * Redis key/value codec. Default is json-codec
+     * Redis key/value codec. Default is FST codec
      *
      * @see org.redisson.client.codec.Codec
      * 

File: redisson/src/main/java/org/redisson/config/SentinelServersConfig.java
Patch:
@@ -108,6 +108,8 @@ public int getScanInterval() {
     }
     /**
      * Sentinel scan interval in milliseconds
+     * <p>
+     * Default is <code>1000</code>
      *
      * @param scanInterval in milliseconds
      * @return config

File: redisson/src/main/java/org/redisson/config/SingleServerConfig.java
Patch:
@@ -92,7 +92,7 @@ public int getConnectionPoolSize() {
     /**
      * Redis subscription-connection pool size limit
      * <p>
-     * Default is 50
+     * Default is <code>50</code>
      *
      * @param subscriptionConnectionPoolSize - pool size
      * @return config
@@ -142,7 +142,7 @@ public long getDnsMonitoringInterval() {
     /**
      * Minimum idle subscription connection amount.
      * <p>
-     * Default is 1
+     * Default is <code>1</code>
      * 
      * @param subscriptionConnectionMinimumIdleSize - connections amount
      * @return config
@@ -159,7 +159,7 @@ public int getSubscriptionConnectionMinimumIdleSize() {
     /**
      * Minimum idle Redis connection amount.
      * <p>
-     * Default is <code>10</code>
+     * Default is <code>24</code>
      *
      * @param connectionMinimumIdleSize - connections amount
      * @return config

File: redisson/src/main/java/org/redisson/RedissonPriorityQueue.java
Patch:
@@ -64,7 +64,7 @@ public int compare(V c1, V c2) {
     public static class BinarySearchResult<V> {
 
         private V value;
-        private Integer index;
+        private int index = -1;
 
         public BinarySearchResult(V value) {
             super();
@@ -74,10 +74,10 @@ public BinarySearchResult(V value) {
         public BinarySearchResult() {
         }
 
-        public void setIndex(Integer index) {
+        public void setIndex(int index) {
             this.index = index;
         }
-        public Integer getIndex() {
+        public int getIndex() {
             return index;
         }
 

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -206,13 +206,13 @@ private void checkAuth(SentinelServersConfig cfg) {
         
         for (String address : cfg.getSentinelAddresses()) {
             RedisURI addr = new RedisURI(address);
+            scheme = addr.getScheme();
             RedisClient client = createClient(NodeType.SENTINEL, addr, this.config.getConnectTimeout(), this.config.getTimeout(), null);
             try {
                 RedisConnection c = client.connect();
                 connected = true;
                 try {
                     c.sync(RedisCommands.PING);
-                    scheme = addr.getScheme();
                 } catch (RedisAuthRequiredException e) {
                     usePassword = true;
                 }

File: redisson/src/main/java/org/redisson/spring/cache/RedissonCacheStatisticsAutoConfiguration.java
Patch:
@@ -35,7 +35,7 @@
  */
 @Configuration
 @AutoConfigureAfter(CacheAutoConfiguration.class)
-@ConditionalOnBean(CacheManager.class)
+@ConditionalOnBean({CacheManager.class, RedissonCache.class})
 @ConditionalOnClass(CacheMeterBinderProvider.class)
 public class RedissonCacheStatisticsAutoConfiguration {
     

File: redisson/src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -570,8 +570,9 @@ public RFuture<Void> unlockAsync(long threadId) {
         RFuture<Boolean> future = unlockInnerAsync(threadId);
 
         future.onComplete((opStatus, e) -> {
+            cancelExpirationRenewal(threadId);
+
             if (e != null) {
-                cancelExpirationRenewal(threadId);
                 result.tryFailure(e);
                 return;
             }
@@ -582,8 +583,7 @@ public RFuture<Void> unlockAsync(long threadId) {
                 result.tryFailure(cause);
                 return;
             }
-            
-            cancelExpirationRenewal(threadId);
+
             result.trySuccess(null);
         });
 

File: redisson/src/main/java/org/redisson/api/RBatch.java
Patch:
@@ -15,8 +15,6 @@
  */
 package org.redisson.api;
 
-import java.util.concurrent.TimeUnit;
-
 import org.redisson.client.RedisException;
 import org.redisson.client.codec.Codec;
 

File: redisson/src/main/java/org/redisson/api/RKeysRx.java
Patch:
@@ -15,14 +15,13 @@
  */
 package org.redisson.api;
 
-import java.util.Collection;
-import java.util.concurrent.TimeUnit;
-
 import io.reactivex.Completable;
 import io.reactivex.Flowable;
 import io.reactivex.Maybe;
 import io.reactivex.Single;
 
+import java.util.concurrent.TimeUnit;
+
 /**
  * 
  * @author Nikita Koksharov

File: redisson/src/main/java/org/redisson/executor/RedissonExecutorRemoteService.java
Patch:
@@ -84,7 +84,7 @@ protected RFuture<RemoteServiceRequest> getTask(String requestId, RMap<String, R
     protected <T> void invokeMethod(Class<T> remoteInterface, RBlockingQueue<String> requestQueue, RemoteServiceRequest request, RemoteServiceMethod method, String responseName, ExecutorService executor, RFuture<RemoteServiceCancelRequest> cancelRequestFuture, AtomicReference<RRemoteServiceResponse> responseHolder) {
         if (taskTimeout > 0) {
             commandExecutor.getConnectionManager().getGroup().schedule(() -> {
-                ((RPromise)cancelRequestFuture).trySuccess(new RemoteServiceCancelRequest(true, false));
+                ((RPromise) cancelRequestFuture).trySuccess(new RemoteServiceCancelRequest(true, false));
             }, taskTimeout, TimeUnit.MILLISECONDS);
         }
         super.invokeMethod(remoteInterface, requestQueue, request, method, responseName, executor, cancelRequestFuture, responseHolder);

File: redisson/src/main/java/org/redisson/api/WorkerOptions.java
Patch:
@@ -28,7 +28,7 @@
  */
 public final class WorkerOptions {
 
-    private int workers;
+    private int workers = 1;
     private ExecutorService executorService;
     private BeanFactory beanFactory;
     
@@ -45,6 +45,7 @@ public int getWorkers() {
 
     /**
      * Defines workers amount used to execute tasks.
+     * Default is <code>1</code>.
      * 
      * @param workers - workers amount
      * @return self instance

File: redisson/src/main/java/org/redisson/spring/transaction/RedissonTransactionManager.java
Patch:
@@ -104,7 +104,7 @@ protected void doRollback(DefaultTransactionStatus status) throws TransactionExc
         try {
             to.getTransactionHolder().getTransaction().rollback();
         } catch (org.redisson.transaction.TransactionException e) {
-            throw new TransactionSystemException("Unable to commit transaction", e);
+            throw new TransactionSystemException("Unable to rollback transaction", e);
         }
     }
 

File: redisson/src/test/java/org/redisson/transaction/RedissonTransactionalBucketReactiveTest.java
Patch:
@@ -113,7 +113,7 @@ public void testGetAndRemove() {
         RTransactionReactive transaction = redisson.createTransaction(TransactionOptions.defaults());
         RBucketReactive<String> set = transaction.getBucket("test");
         assertThat(sync(set.get())).isEqualTo("123");
-        assertThat(sync(set.size())).isEqualTo(5);
+        assertThat(sync(set.size())).isEqualTo(10);
         assertThat(sync(set.getAndDelete())).isEqualTo("123");
         assertThat(sync(set.size())).isEqualTo(0);
         assertThat(sync(set.get())).isNull();

File: redisson/src/test/java/org/redisson/transaction/RedissonTransactionalBucketTest.java
Patch:
@@ -113,7 +113,7 @@ public void testGetAndRemove() {
         RTransaction transaction = redisson.createTransaction(TransactionOptions.defaults());
         RBucket<String> set = transaction.getBucket("test");
         assertThat(set.get()).isEqualTo("123");
-        assertThat(set.size()).isEqualTo(5);
+        assertThat(set.size()).isEqualTo(10);
         assertThat(set.getAndDelete()).isEqualTo("123");
         assertThat(set.size()).isEqualTo(0);
         assertThat(set.get()).isNull();

File: redisson/src/main/java/org/redisson/transaction/RedissonTransactionalBuckets.java
Patch:
@@ -141,6 +141,7 @@ public RFuture<Void> setAsync(Map<String, ?> buckets) {
     public RFuture<Long> deleteAsync(String... keys) {
         checkState();
         RPromise<Long> result = new RedissonPromise<>();
+        long threadId = Thread.currentThread().getId();
         executeLocked(result, new Runnable() {
             @Override
             public void run() {
@@ -149,7 +150,7 @@ public void run() {
                 for (String key : keys) {
                     Object st = state.get(key);
                     if (st != null) {
-                        operations.add(new DeleteOperation(key, getLockName(key), transactionId));
+                        operations.add(new DeleteOperation(key, getLockName(key), transactionId, threadId));
                         if (st != NULL) {
                             state.put(key, NULL);
                             counter.incrementAndGet();
@@ -168,7 +169,7 @@ public void run() {
                         }
                         
                         if (res > 0) {
-                            operations.add(new DeleteOperation(key, getLockName(key), transactionId));
+                            operations.add(new DeleteOperation(key, getLockName(key), transactionId, threadId));
                             state.put(key, NULL);
                             counter.incrementAndGet();
                         }

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapAddAndGetOperation.java
Patch:
@@ -27,8 +27,8 @@ public class MapAddAndGetOperation extends MapOperation {
     public MapAddAndGetOperation() {
     }
     
-    public MapAddAndGetOperation(RMap<?, ?> map, Object key, Object value, String transactionId) {
-        super(map, key, value, transactionId);
+    public MapAddAndGetOperation(RMap<?, ?> map, Object key, Object value, String transactionId, long threadId) {
+        super(map, key, value, transactionId, threadId);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapCacheFastPutIfAbsentOperation.java
Patch:
@@ -33,8 +33,8 @@ public class MapCacheFastPutIfAbsentOperation extends MapOperation {
     private TimeUnit maxIdleUnit;
 
     public MapCacheFastPutIfAbsentOperation(RMap<?, ?> map, Object key, Object value, long ttl, TimeUnit ttlUnit,
-            long maxIdleTime, TimeUnit maxIdleUnit, String transactionId) {
-        super(map, key, value, transactionId);
+            long maxIdleTime, TimeUnit maxIdleUnit, String transactionId, long threadId) {
+        super(map, key, value, transactionId, threadId);
         this.ttl = ttl;
         this.ttlUnit = ttlUnit;
         this.maxIdleTime = maxIdleTime;

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapCacheFastPutOperation.java
Patch:
@@ -35,8 +35,8 @@ public class MapCacheFastPutOperation extends MapOperation {
     public MapCacheFastPutOperation() {
     }
     
-    public MapCacheFastPutOperation(RMap<?, ?> map, Object key, Object value, long ttl, TimeUnit ttlUnit, long maxIdleTime, TimeUnit maxIdleUnit, String transactionId) {
-        super(map, key, value, transactionId);
+    public MapCacheFastPutOperation(RMap<?, ?> map, Object key, Object value, long ttl, TimeUnit ttlUnit, long maxIdleTime, TimeUnit maxIdleUnit, String transactionId, long threadId) {
+        super(map, key, value, transactionId, threadId);
         this.ttl = ttl;
         this.ttlUnit = ttlUnit;
         this.maxIdleTime = maxIdleTime;

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapCachePutOperation.java
Patch:
@@ -35,8 +35,8 @@ public class MapCachePutOperation extends MapOperation {
     public MapCachePutOperation() {
     }
     
-    public MapCachePutOperation(RMap<?, ?> map, Object key, Object value, long ttlTimeout, TimeUnit ttlUnit, long maxIdleTimeout, TimeUnit maxIdleUnit, String transactionId) {
-        super(map, key, value, transactionId);
+    public MapCachePutOperation(RMap<?, ?> map, Object key, Object value, long ttlTimeout, TimeUnit ttlUnit, long maxIdleTimeout, TimeUnit maxIdleUnit, String transactionId, long threadId) {
+        super(map, key, value, transactionId, threadId);
         this.ttlTimeout = ttlTimeout;
         this.ttlUnit = ttlUnit;
         this.maxIdleTimeout = maxIdleTimeout;

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapFastPutIfAbsentOperation.java
Patch:
@@ -27,8 +27,8 @@ public class MapFastPutIfAbsentOperation extends MapOperation {
     public MapFastPutIfAbsentOperation() {
     }
     
-    public MapFastPutIfAbsentOperation(RMap<?, ?> map, Object key, Object value, String transactionId) {
-        super(map, key, value, transactionId);
+    public MapFastPutIfAbsentOperation(RMap<?, ?> map, Object key, Object value, String transactionId, long threadId) {
+        super(map, key, value, transactionId, threadId);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapFastPutOperation.java
Patch:
@@ -27,8 +27,8 @@ public class MapFastPutOperation extends MapOperation {
     public MapFastPutOperation() {
     }
     
-    public MapFastPutOperation(RMap<?, ?> map, Object key, Object value, String transactionId) {
-        super(map, key, value, transactionId);
+    public MapFastPutOperation(RMap<?, ?> map, Object key, Object value, String transactionId, long threadId) {
+        super(map, key, value, transactionId, threadId);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapFastRemoveOperation.java
Patch:
@@ -27,8 +27,8 @@ public class MapFastRemoveOperation extends MapOperation {
     public MapFastRemoveOperation() {
     }
     
-    public MapFastRemoveOperation(RMap<?, ?> map, Object key, String transactionId) {
-        super(map, key, null, transactionId);
+    public MapFastRemoveOperation(RMap<?, ?> map, Object key, String transactionId, long threadId) {
+        super(map, key, null, transactionId, threadId);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapPutIfAbsentOperation.java
Patch:
@@ -27,8 +27,8 @@ public class MapPutIfAbsentOperation extends MapOperation {
     public MapPutIfAbsentOperation() {
     }
     
-    public MapPutIfAbsentOperation(RMap<?, ?> map, Object key, Object value, String transactionId) {
-        super(map, key, value, transactionId);
+    public MapPutIfAbsentOperation(RMap<?, ?> map, Object key, Object value, String transactionId, long threadId) {
+        super(map, key, value, transactionId, threadId);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapPutOperation.java
Patch:
@@ -27,8 +27,8 @@ public class MapPutOperation extends MapOperation {
     public MapPutOperation() {
     }
     
-    public MapPutOperation(RMap<?, ?> map, Object key, Object value, String transactionId) {
-        super(map, key, value, transactionId);
+    public MapPutOperation(RMap<?, ?> map, Object key, Object value, String transactionId, long threadId) {
+        super(map, key, value, transactionId, threadId);
     }
 
     @Override

File: redisson/src/test/java/org/redisson/RedissonBucketsTest.java
Patch:
@@ -4,6 +4,7 @@
 
 import java.io.IOException;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
@@ -48,7 +49,7 @@ public void testGetInCluster() throws FailedToStartRedisException, IOException,
             redisson.getBucket("test" + i).set(i);
         }
         
-        Set<String> queryKeys = map.keySet();
+        Set<String> queryKeys = new HashSet<>(map.keySet());
         queryKeys.add("test_invalid");
         Map<String, Integer> buckets = redisson.getBuckets().get(queryKeys.toArray(new String[map.size()]));
         

File: redisson/src/main/java/org/redisson/spring/cache/RedissonCacheStatisticsAutoConfiguration.java
Patch:
@@ -25,8 +25,6 @@
 import org.springframework.context.annotation.Bean;
 import org.springframework.context.annotation.Configuration;
 
-import io.micrometer.core.instrument.binder.MeterBinder;
-
 /**
  *
  * @author Craig Andrews

File: redisson/src/main/java/org/redisson/api/RMultimapCache.java
Patch:
@@ -18,7 +18,8 @@
 import java.util.concurrent.TimeUnit;
 
 /**
- * 
+ * Base Multimap interface. Allows to map multiple values per key and define expiration per key.
+ *
  * @author Nikita Koksharov
  *
  * @param <K> key type

File: redisson/src/main/java/org/redisson/api/RMultimapCacheAsync.java
Patch:
@@ -18,7 +18,8 @@
 import java.util.concurrent.TimeUnit;
 
 /**
- * 
+ * Base asynchronous Multimap interface. Allows to map multiple values per key and define expiration per key.
+ *
  * @author Nikita Koksharov
  *
  * @param <K> key type

File: redisson/src/main/java/org/redisson/api/RMultimapReactive.java
Patch:
@@ -20,7 +20,7 @@
 import reactor.core.publisher.Mono;
 
 /**
- * Reactive interface for Multimap object
+ * Base Reactive interface for Multimap object
  * 
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/api/RObjectAsync.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.concurrent.TimeUnit;
 
 /**
- * Base interface for all Redisson objects
+ * Base asynchronous interface for all Redisson objects
  *
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/api/RObjectReactive.java
Patch:
@@ -22,7 +22,7 @@
 import reactor.core.publisher.Mono;
 
 /**
- * Base interface for all Redisson objects
+ * Base Reactive interface for all Redisson objects
  *
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/api/RObjectRx.java
Patch:
@@ -23,7 +23,7 @@
 import io.reactivex.Single;
 
 /**
- * Base interface for all Redisson objects
+ * Base RxJava2 interface for all Redisson objects
  *
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/api/RPermitExpirableSemaphoreAsync.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.concurrent.TimeUnit;
 
 /**
- * Semaphore object with support of lease time parameter for each acquired permit.
+ * Asynchronous interface for Semaphore object with lease time parameter support for each acquired permit.
  * 
  * <p>Each permit identified by own id and could be released only using its id.
  * Permit id is a 128-bits unique random identifier generated each time during acquiring.

File: redisson/src/main/java/org/redisson/api/RPermitExpirableSemaphoreReactive.java
Patch:
@@ -20,7 +20,7 @@
 import reactor.core.publisher.Mono;
 
 /**
- * Semaphore object with support of lease time parameter for each acquired permit.
+ * Reactive interface for Semaphore object with lease time parameter support for each acquired permit.
  * 
  * <p>Each permit identified by own id and could be released only using its id.
  * Permit id is a 128-bits unique random identifier generated each time during acquiring.

File: redisson/src/main/java/org/redisson/api/RPermitExpirableSemaphoreRx.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.Single;
 
 /**
- * RxJava2 interface for Semaphore object with support of lease time parameter for each acquired permit.
+ * RxJava2 interface for Semaphore object with lease time parameter support for each acquired permit.
  * 
  * <p>Each permit identified by own id and could be released only using its id.
  * Permit id is a 128-bits unique random identifier generated each time during acquiring.

File: redisson/src/main/java/org/redisson/api/RPriorityQueue.java
Patch:
@@ -21,7 +21,7 @@
 
 /**
  * 
- * Redis based priority queue.
+ * Redis based priority deque.
  * 
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/api/RRateLimiter.java
Patch:
@@ -18,7 +18,8 @@
 import java.util.concurrent.TimeUnit;
 
 /**
- * 
+ * Redis based Rate Limiter object.
+ *
  * @author Nikita Koksharov
  *
  */

File: redisson/src/main/java/org/redisson/api/RRateLimiterAsync.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.concurrent.TimeUnit;
 
 /**
+ * Asynchronous interface for Redis based Rate Limiter object.
  * 
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/api/RRateLimiterReactive.java
Patch:
@@ -20,7 +20,7 @@
 import reactor.core.publisher.Mono;
 
 /**
- * Reactive interface for Rate Limiter object
+ * Reactive interface for Redis based Rate Limiter object.
  * 
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/api/RRateLimiterRx.java
Patch:
@@ -21,7 +21,7 @@
 import io.reactivex.Single;
 
 /**
- * RxJava2 interface for Rate Limiter object
+ * Reactive interface for Redis based Rate Limiter object.
  * 
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/RedissonCountDownLatch.java
Patch:
@@ -61,7 +61,7 @@ public void await() throws InterruptedException {
 
         RFuture<RedissonCountDownLatchEntry> future = subscribe();
         try {
-            commandExecutor.syncSubscription(future);
+            commandExecutor.syncSubscriptionInterrupted(future);
 
             while (getCount() > 0) {
                 // waiting for open state

File: redisson/src/main/java/org/redisson/RedissonPermitExpirableSemaphore.java
Patch:
@@ -83,15 +83,14 @@ public RFuture<String> acquireAsync(long leaseTime, TimeUnit timeUnit) {
         return acquireAsync(1, leaseTime, timeUnit);
     }
 
-    
     private String acquire(int permits, long ttl, TimeUnit timeUnit) throws InterruptedException {
         String permitId = tryAcquire(permits, ttl, timeUnit);
         if (permitId != null && !permitId.startsWith(":")) {
             return permitId;
         }
 
         RFuture<RedissonLockEntry> future = subscribe();
-        commandExecutor.syncSubscription(future);
+        commandExecutor.syncSubscriptionInterrupted(future);
         try {
             while (true) {
                 Long nearestTimeout;

File: redisson/src/main/java/org/redisson/RedissonSemaphore.java
Patch:
@@ -78,7 +78,7 @@ public void acquire(int permits) throws InterruptedException {
         }
 
         RFuture<RedissonLockEntry> future = subscribe();
-        commandExecutor.syncSubscription(future);
+        commandExecutor.syncSubscriptionInterrupted(future);
         try {
             while (true) {
                 if (tryAcquire(permits)) {

File: redisson/src/main/java/org/redisson/command/CommandAsyncExecutor.java
Patch:
@@ -53,7 +53,9 @@ public interface CommandAsyncExecutor {
     <V> RedisException convertException(RFuture<V> future);
 
     void syncSubscription(RFuture<?> future);
-    
+
+    void syncSubscriptionInterrupted(RFuture<?> future) throws InterruptedException;
+
     <V> V get(RFuture<V> future);
     
     <V> V getInterrupted(RFuture<V> future) throws InterruptedException;

File: redisson/src/test/java/org/redisson/RedissonFairLockTest.java
Patch:
@@ -347,7 +347,7 @@ public void testLockAcquiredBooleanTimeoutDrift_Descrete() throws Exception {
         locked = lock.tryLockInnerAsync(leaseTime, TimeUnit.MILLISECONDS, threadThirdWaiter, RedisCommands.EVAL_NULL_BOOLEAN).await().get();
         Assert.assertFalse(locked);
         
-        Thread.sleep(490);
+        Thread.sleep(500);
 
         locked = lock.tryLockInnerAsync(leaseTime, TimeUnit.MILLISECONDS, threadThirdWaiter, RedisCommands.EVAL_NULL_BOOLEAN).await().get();
         Assert.assertTrue(locked);

File: redisson/src/main/java/org/redisson/command/RedisExecutor.java
Patch:
@@ -372,7 +372,9 @@ public void run(Timeout timeout) throws Exception {
             }
 
             // handling cancel operation for blocking commands
-            if (mainPromise.isCancelled() && !attemptPromise.isDone()) {
+            if ((mainPromise.isCancelled()
+                    || mainPromise.cause() instanceof  InterruptedException)
+                        && !attemptPromise.isDone()) {
                 log.debug("Canceled blocking operation {} used {}", command, connection);
                 connection.forceFastReconnectAsync().onComplete((r, ex) -> {
                     attemptPromise.cancel(true);

File: redisson/src/main/java/org/redisson/pubsub/AsyncSemaphore.java
Patch:
@@ -76,7 +76,7 @@ public boolean equals(Object obj) {
         
     }
     
-    private int counter;
+    private volatile int counter;
     private final Set<Entry> listeners = new LinkedHashSet<Entry>();
 
     public AsyncSemaphore(int permits) {

File: redisson-spring-data/redisson-spring-data-22/src/test/java/org/redisson/spring/data/connection/RedissonConnectionTest.java
Patch:
@@ -17,7 +17,7 @@ public void testZSet() {
         connection.zAdd(new byte[] {1}, 2, new byte[] {2});
         connection.zAdd(new byte[] {1}, 10, new byte[] {3});
 
-        assertThat(connection.zRangeByScore(new byte[] {1}, Double.NEGATIVE_INFINITY, 100))
+        assertThat(connection.zRangeByScore(new byte[] {1}, Double.NEGATIVE_INFINITY, 5))
                 .containsOnly(new byte[] {1}, new byte[] {2});
     }
 

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1001,8 +1001,9 @@ private String value(Object score, boolean inclusive, String defaultValue) {
         if (score instanceof Double) {
             if (Double.isInfinite((Double) score)) {
                 element.append((Double)score > 0 ? "+inf" : "-inf");
+            } else {
+                element.append(BigDecimal.valueOf((Double)score).toPlainString());
             }
-            element.append(BigDecimal.valueOf((Double)score).toPlainString());
         } else {
             element.append(score);
         }

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1058,8 +1058,9 @@ private String value(Object score, boolean inclusive, String defaultValue) {
         if (score instanceof Double) {
             if (Double.isInfinite((Double) score)) {
                 element.append((Double)score > 0 ? "+inf" : "-inf");
+            } else {
+                element.append(BigDecimal.valueOf((Double)score).toPlainString());
             }
-            element.append(BigDecimal.valueOf((Double)score).toPlainString());
         } else {
             element.append(score);
         }

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1074,8 +1074,9 @@ private String value(Object score, boolean inclusive, String defaultValue) {
         if (score instanceof Double) {
             if (Double.isInfinite((Double) score)) {
                 element.append((Double)score > 0 ? "+inf" : "-inf");
+            } else {
+                element.append(BigDecimal.valueOf((Double)score).toPlainString());
             }
-            element.append(BigDecimal.valueOf((Double)score).toPlainString());
         } else {
             element.append(score);
         }

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1055,8 +1055,9 @@ private String value(Object score, boolean inclusive, String defaultValue) {
         if (score instanceof Double) {
             if (Double.isInfinite((Double) score)) {
                 element.append((Double)score > 0 ? "+inf" : "-inf");
+            } else {
+                element.append(BigDecimal.valueOf((Double)score).toPlainString());
             }
-            element.append(BigDecimal.valueOf((Double)score).toPlainString());
         } else {
             element.append(score);
         }

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1085,8 +1085,9 @@ private String value(Object score, boolean inclusive, String defaultValue) {
         if (score instanceof Double) {
             if (Double.isInfinite((Double) score)) {
                 element.append((Double)score > 0 ? "+inf" : "-inf");
+            } else {
+                element.append(BigDecimal.valueOf((Double)score).toPlainString());
             }
-            element.append(BigDecimal.valueOf((Double)score).toPlainString());
         } else {
             element.append(score);
         }

File: redisson-spring-data/redisson-spring-data-22/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1077,8 +1077,9 @@ private String value(Object score, boolean inclusive, String defaultValue) {
         if (score instanceof Double) {
             if (Double.isInfinite((Double) score)) {
                 element.append((Double)score > 0 ? "+inf" : "-inf");
+            } else {
+                element.append(BigDecimal.valueOf((Double)score).toPlainString());
             }
-            element.append(BigDecimal.valueOf((Double)score).toPlainString());
         } else {
             element.append(score);
         }

File: redisson/src/main/java/org/redisson/api/RExecutorService.java
Patch:
@@ -124,9 +124,9 @@ public interface RExecutorService extends ExecutorService, RExecutorServiceAsync
     void registerWorkers(WorkerOptions options);
     
     /**
-     * Returns active worker groups
+     * Returns active workers amount available for tasks execution.
      * 
-     * @return active worker groups count
+     * @return workers amount
      */
     int countActiveWorkers();
     

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -499,7 +499,7 @@ public MasterSlaveEntry getEntry(InetSocketAddress address) {
         return null;
     }
     
-    private MasterSlaveEntry getEntry(RedisURI addr) {
+    protected MasterSlaveEntry getEntry(RedisURI addr) {
         for (MasterSlaveEntry entry : client2entry.values()) {
             if (RedisURI.compare(entry.getClient().getAddr(), addr)) {
                 return entry;

File: redisson/src/main/java/org/redisson/misc/RedisURI.java
Patch:
@@ -38,6 +38,9 @@ public RedisURI(String uri) {
         
         String urlHost = uri.replaceFirst("redis://", "http://").replaceFirst("rediss://", "http://");
         String ipV6Host = uri.substring(uri.indexOf("://")+3, uri.lastIndexOf(":"));
+        if (ipV6Host.contains("@")) {
+            ipV6Host = ipV6Host.split("@")[1];
+        }
         if (ipV6Host.contains(":")) {
             urlHost = urlHost.replace(ipV6Host, "[" + ipV6Host + "]");
         }

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -613,9 +613,9 @@ public <T, R> RFuture<R> writeBatchedAsync(Codec codec, RedisCommand<T> command,
     private <T, R> RFuture<R> executeBatchedAsync(boolean readOnly, Codec codec, RedisCommand<T> command, SlotCallback<T, R> callback, String... keys) {
         if (!connectionManager.isClusterMode()) {
             if (readOnly) {
-                return readAsync(null, command, keys);
+                return readAsync((String) null, codec, command, keys);
             }
-            return writeAsync(null, command, keys);
+            return writeAsync((String) null, codec, command, keys);
         }
 
         Map<MasterSlaveEntry, List<String>> range2key = new HashMap<MasterSlaveEntry, List<String>>();

File: redisson/src/main/java/org/redisson/RedissonStream.java
Patch:
@@ -905,12 +905,12 @@ public long remove(StreamMessageId... ids) {
 
     @Override
     public RFuture<Long> trimAsync(int count) {
-        return commandExecutor.writeAsync(getName(), StringCodec.INSTANCE, RedisCommands.XTRIM, "MAXLEN", count);
+        return commandExecutor.writeAsync(getName(), StringCodec.INSTANCE, RedisCommands.XTRIM, getName(), "MAXLEN", count);
     }
 
     @Override
     public RFuture<Long> trimNonStrictAsync(int count) {
-        return commandExecutor.writeAsync(getName(), StringCodec.INSTANCE, RedisCommands.XTRIM, "MAXLEN", "~", count);
+        return commandExecutor.writeAsync(getName(), StringCodec.INSTANCE, RedisCommands.XTRIM, getName(), "MAXLEN", "~", count);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/api/NodesGroup.java
Patch:
@@ -29,7 +29,7 @@ public interface NodesGroup<N extends Node> {
 
     /**
      * Adds connection listener which will be triggered
-     * when Redisson has just been connected to or disconnected from redis server
+     * when Redisson connected to or disconnected from Redis server
      *
      * @param connectionListener - connection listener
      * @return id of listener

File: redisson/src/main/java/org/redisson/client/handler/CommandsQueue.java
Patch:
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import java.util.List;
 import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.regex.Pattern;
 
 import org.redisson.client.ChannelName;
@@ -53,7 +54,7 @@ public class CommandsQueue extends ChannelDuplexHandler {
     
     public static final AttributeKey<QueueCommand> CURRENT_COMMAND = AttributeKey.valueOf("promise");
 
-    private final Queue<QueueCommandHolder> queue = PlatformDependent.newMpscQueue();
+    private final Queue<QueueCommandHolder> queue = new ConcurrentLinkedQueue<>();
 
     private final ChannelFutureListener listener = new ChannelFutureListener() {
         @Override

File: redisson/src/main/java/org/redisson/api/RTopicReactive.java
Patch:
@@ -85,7 +85,7 @@ public interface RTopicReactive {
     Mono<Void> removeListener(MessageListener<?> listener);
 
     /**
-     * Returns stream of messages.
+     * Returns continues stream of messages.
      * 
      * @param <M> type of message 
      * @param type - type of message to listen

File: redisson/src/main/java/org/redisson/api/RTopicRx.java
Patch:
@@ -86,7 +86,7 @@ public interface RTopicRx {
     Completable removeListener(MessageListener<?> listener);
     
     /**
-     * Returns stream of messages.
+     * Returns continues stream of messages.
      * 
      * @param <M> - type of message
      * @param type - type of message to listen

File: redisson/src/main/java/org/redisson/RedissonObject.java
Patch:
@@ -54,7 +54,7 @@
 public abstract class RedissonObject implements RObject {
 
     protected final CommandAsyncExecutor commandExecutor;
-    private String name;
+    protected String name;
     protected final Codec codec;
 
     public RedissonObject(Codec codec, CommandAsyncExecutor commandExecutor, String name) {

File: redisson/src/main/java/org/redisson/command/CommandAsyncExecutor.java
Patch:
@@ -58,6 +58,8 @@ public interface CommandAsyncExecutor {
     void syncSubscription(RFuture<?> future);
     
     <V> V get(RFuture<V> future);
+    
+    <V> V getInterrupted(RFuture<V> future) throws InterruptedException;
 
     <T, R> RFuture<R> writeAsync(MasterSlaveEntry entry, Codec codec, RedisCommand<T> command, Object... params);
     

File: redisson/src/main/java/org/redisson/config/Config.java
Patch:
@@ -59,7 +59,7 @@ public class Config {
     private int nettyThreads = 32;
 
     /**
-     * Redis key/value codec. JsonJacksonCodec used by default
+     * Redis key/value codec. FST codec is used by default
      */
     private Codec codec;
 

File: redisson-spring-boot-starter/src/main/java/org/redisson/spring/starter/RedissonAutoConfiguration.java
Patch:
@@ -95,7 +95,7 @@ public RedissonClient redisson() throws IOException {
         Object timeoutValue = ReflectionUtils.invokeMethod(timeoutMethod, redisProperties);
         int timeout;
         if(null == timeoutValue){
-            timeout = 0;
+            timeout = 10000;
         }else if (!(timeoutValue instanceof Integer)) {
             Method millisMethod = ReflectionUtils.findMethod(timeoutValue.getClass(), "toMillis");
             timeout = ((Long) ReflectionUtils.invokeMethod(millisMethod, timeoutValue)).intValue();

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -501,7 +501,7 @@ private String createAddress(String host, Object port) {
         if (host.contains(":")){
             String pureHost = host.replaceAll("[\\[\\]]", "");
             host = applyNatMap(pureHost);
-            if (host.contains(":")) {
+            if (host.contains(":") && !host.startsWith("[")) {
                 host = "[" + host + "]";
             }
         } else {

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -1012,7 +1012,7 @@ public RFuture<Long> remainTimeToLiveAsync(K key) {
                             + "return -1; "
                         + "end;"
                         + "if expireDate > tonumber(ARGV[1]) then "
-                            + "return ARGV[1] - expireDate; "
+                            + "return expireDate - ARGV[1]; "
                         + "else "
                             + "return -2; "
                         + "end; "

File: redisson/src/test/java/org/redisson/RedissonMapCacheTest.java
Patch:
@@ -97,7 +97,7 @@ public void testSizeInMemory() {
     public void testRemainTimeToLive() {
         RMapCache<String, String> map = redisson.getMapCache("test");
         map.put("1", "2", 2, TimeUnit.SECONDS);
-        assertThat(map.remainTimeToLive("1")).isLessThan(1900);
+        assertThat(map.remainTimeToLive("1")).isBetween(1900L, 2000L);
         map.put("3", "4");
         assertThat(map.remainTimeToLive("3")).isEqualTo(-1);
         assertThat(map.remainTimeToLive("0")).isEqualTo(-2);

File: redisson/src/test/java/org/redisson/RedissonDequeReactiveTest.java
Patch:
@@ -121,7 +121,7 @@ public void testDescendingIterator() {
         final RDequeReactive<Integer> queue = redisson.getDeque("deque");
         sync(queue.addAll(Arrays.asList(1, 2, 3)));
 
-        assertThat(toIterator(queue.descendingIterator())).containsExactly(3, 2, 1);
+        assertThat(toIterator(queue.descendingIterator())).toIterable().containsExactly(3, 2, 1);
     }
 
 }

File: redisson/src/test/java/org/redisson/RedissonDequeTest.java
Patch:
@@ -165,15 +165,15 @@ public void testDescendingIteratorOrigin() {
         final Deque<Integer> queue = new ArrayDeque<Integer>();
         queue.addAll(Arrays.asList(1, 2, 3));
 
-        assertThat(queue.descendingIterator()).containsExactly(3, 2, 1);
+        assertThat(queue.descendingIterator()).toIterable().containsExactly(3, 2, 1);
     }
 
     @Test
     public void testDescendingIterator() {
         final RDeque<Integer> queue = redisson.getDeque("deque");
         queue.addAll(Arrays.asList(1, 2, 3));
 
-        assertThat(queue.descendingIterator()).containsExactly(3, 2, 1);
+        assertThat(queue.descendingIterator()).toIterable().containsExactly(3, 2, 1);
     }
 
 }

File: redisson/src/test/java/org/redisson/RedissonMapCacheReactiveTest.java
Patch:
@@ -170,7 +170,7 @@ public void testExpiredIterator() throws InterruptedException {
 
         Thread.sleep(1000);
 
-        assertThat(toIterator(cache.keyIterator())).containsOnly("0", "2", "3");
+        assertThat(toIterator(cache.keyIterator())).toIterable().containsOnly("0", "2", "3");
     }
 
     @Test

File: redisson/src/test/java/org/redisson/rx/RedissonDequeReactiveTest.java
Patch:
@@ -121,7 +121,7 @@ public void testDescendingIterator() {
         final RDequeRx<Integer> queue = redisson.getDeque("deque");
         sync(queue.addAll(Arrays.asList(1, 2, 3)));
 
-        assertThat(toIterator(queue.descendingIterator())).containsExactly(3, 2, 1);
+        assertThat(toIterator(queue.descendingIterator())).toIterable().containsExactly(3, 2, 1);
     }
 
 }

File: redisson/src/test/java/org/redisson/rx/RedissonMapCacheRxTest.java
Patch:
@@ -171,7 +171,7 @@ public void testExpiredIterator() throws InterruptedException {
 
         Thread.sleep(1000);
 
-        assertThat(toIterator(cache.keyIterator())).containsOnly("0", "2", "3");
+        assertThat(toIterator(cache.keyIterator())).toIterable().containsOnly("0", "2", "3");
     }
 
     @Test
@@ -238,7 +238,7 @@ public void testPutAll() {
         joinMap.put(6, "6");
         sync(map.putAll(joinMap));
 
-        assertThat(toIterator(map.keyIterator())).containsOnly(1, 2, 3, 4, 5, 6);
+        assertThat(toIterator(map.keyIterator())).toIterable().containsOnly(1, 2, 3, 4, 5, 6);
     }
 
     @Test

File: redisson/src/test/java/org/redisson/rx/RedissonMapRxTest.java
Patch:
@@ -245,7 +245,7 @@ public void testPutAll() {
         joinMap.put(6, "6");
         sync(map.putAll(joinMap));
 
-        assertThat(toIterator(map.keyIterator())).contains(1, 2, 3, 4, 5, 6);
+        assertThat(toIterator(map.keyIterator())).toIterable().contains(1, 2, 3, 4, 5, 6);
     }
 
     @Test

File: redisson/src/test/java/org/redisson/RedissonLocalCachedMapTest.java
Patch:
@@ -314,7 +314,10 @@ public void testLocalCacheClear() throws InterruptedException {
         assertThat(cache1.size()).isEqualTo(2);
         assertThat(cache2.size()).isEqualTo(2);
 
+        
         map1.clearLocalCache();
+        
+        assertThat(redisson.getKeys().count()).isEqualTo(1);
 
         assertThat(cache1.size()).isZero();
         assertThat(cache2.size()).isZero();

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -721,7 +721,7 @@ public void run(Timeout t) throws Exception {
                             details.incAttempt();
 
                             Timeout timeout;
-                            if (connectionManager.getConfig().getRetryInterval() > 0) {
+                            if (connectionManager.getConfig().getRetryInterval() > 0 && connectionManager.getConfig().getRetryAttempts() > 0) {
                                 timeout = connectionManager.newTimeout(this, connectionManager.getConfig().getRetryInterval(), TimeUnit.MILLISECONDS);
                             } else {
                                 timeout = MasterSlaveConnectionManager.DUMMY_TIMEOUT;            
@@ -770,7 +770,7 @@ public void run(Timeout t) throws Exception {
         };
 
         Timeout timeout;
-        if (connectionManager.getConfig().getRetryInterval() > 0) {
+        if (connectionManager.getConfig().getRetryInterval() > 0 && connectionManager.getConfig().getRetryAttempts() > 0) {
             timeout = connectionManager.newTimeout(retryTimerTask, connectionManager.getConfig().getRetryInterval(), TimeUnit.MILLISECONDS);
         } else {
             timeout = MasterSlaveConnectionManager.DUMMY_TIMEOUT;            

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -103,7 +103,7 @@ public SentinelConnectionManager(SentinelServersConfig cfg, Config config, UUID
         
         for (String address : cfg.getSentinelAddresses()) {
             RedisURI addr = new RedisURI(address);
-            RedisClient client = createClient(NodeType.SENTINEL, addr, this.config.getConnectTimeout(), this.config.getRetryInterval() * this.config.getRetryAttempts(), null);
+            RedisClient client = createClient(NodeType.SENTINEL, addr, this.config.getConnectTimeout(), this.config.getTimeout(), null);
             try {
                 RedisConnection c = client.connect();
                 try {
@@ -125,7 +125,7 @@ public SentinelConnectionManager(SentinelServersConfig cfg, Config config, UUID
                 sentinelHosts.add(addr);
             }
             
-            RedisClient client = createClient(NodeType.SENTINEL, addr, this.config.getConnectTimeout(), this.config.getRetryInterval() * this.config.getRetryAttempts(), null);
+            RedisClient client = createClient(NodeType.SENTINEL, addr, this.config.getConnectTimeout(), this.config.getTimeout(), null);
             try {
                 RedisConnection connection = client.connect();
                 if (!connection.isActive()) {
@@ -505,7 +505,7 @@ private RFuture<Void> registerSentinel(RedisURI addr, MasterSlaveServersConfig c
             return RedissonPromise.newSucceededFuture(null);
         }
         
-        RedisClient client = createClient(NodeType.SENTINEL, addr, c.getConnectTimeout(), c.getRetryInterval() * c.getRetryAttempts(), null);
+        RedisClient client = createClient(NodeType.SENTINEL, addr, c.getConnectTimeout(), c.getTimeout(), null);
         RPromise<Void> result = new RedissonPromise<Void>();
         RFuture<InetSocketAddress> future = client.resolveAddr();
         future.onComplete((res, e) -> {

File: redisson/src/test/java/org/redisson/RedissonRingBufferTest.java
Patch:
@@ -13,7 +13,6 @@ public class RedissonRingBufferTest extends BaseTest {
     @Test
     public void testAdd() {
         RRingBuffer<Integer> buffer = redisson.getRingBuffer("test");
-        assertThat(buffer.remainingCapacity()).isZero();
         assertThat(buffer.capacity()).isZero();
         buffer.trySetCapacity(10);
         assertThat(buffer.capacity()).isEqualTo(10);
@@ -47,7 +46,6 @@ public void testAdd() {
     @Test
     public void testAddAll() {
         RRingBuffer<Integer> buffer = redisson.getRingBuffer("test");
-        assertThat(buffer.remainingCapacity()).isZero();
         assertThat(buffer.capacity()).isZero();
         buffer.trySetCapacity(10);
         assertThat(buffer.capacity()).isEqualTo(10);

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -86,7 +86,7 @@
  */
 public class MasterSlaveConnectionManager implements ConnectionManager {
 
-    private final Timeout dummyTimeout = new Timeout() {
+    public static final Timeout DUMMY_TIMEOUT = new Timeout() {
         @Override
         public Timer timer() {
             return null;
@@ -109,7 +109,7 @@ public boolean isCancelled() {
 
         @Override
         public boolean cancel() {
-            return false;
+            return true;
         }
     };
 
@@ -685,7 +685,7 @@ public Timeout newTimeout(TimerTask task, long delay, TimeUnit unit) {
             return timer.newTimeout(task, delay, unit);
         } catch (IllegalStateException e) {
             // timer is shutdown
-            return dummyTimeout;
+            return DUMMY_TIMEOUT;
         }
     }
 

File: redisson/src/main/java/org/redisson/api/RSetReactive.java
Patch:
@@ -146,7 +146,7 @@ public interface RSetReactive<V> extends RCollectionReactive<V>, RSortableReacti
      * @param names - name of sets
      * @return size of union
      */
-    Mono<Long> union(String... names);
+    Mono<Integer> union(String... names);
 
     /**
      * Union sets specified by name with current set.
@@ -164,7 +164,7 @@ public interface RSetReactive<V> extends RCollectionReactive<V>, RSortableReacti
      * @param names - name of sets
      * @return size of diff
      */
-    Mono<Long> diff(String... names);
+    Mono<Integer> diff(String... names);
     
     /**
      * Diff sets specified by name with current set.
@@ -182,7 +182,7 @@ public interface RSetReactive<V> extends RCollectionReactive<V>, RSortableReacti
      * @param names - name of sets
      * @return size of intersection
      */
-    Mono<Long> intersection(String... names);
+    Mono<Integer> intersection(String... names);
 
     /**
      * Intersection sets specified by name with current set.

File: redisson/src/main/java/org/redisson/api/RSetRx.java
Patch:
@@ -147,7 +147,7 @@ public interface RSetRx<V> extends RCollectionRx<V>, RSortableRx<Set<V>> {
      * @param names - name of sets
      * @return size of union
      */
-    Single<Long> union(String... names);
+    Single<Integer> union(String... names);
 
     /**
      * Union sets specified by name with current set.
@@ -165,7 +165,7 @@ public interface RSetRx<V> extends RCollectionRx<V>, RSortableRx<Set<V>> {
      * @param names - name of sets
      * @return size of diff
      */
-    Single<Long> diff(String... names);
+    Single<Integer> diff(String... names);
     
     /**
      * Diff sets specified by name with current set.
@@ -183,7 +183,7 @@ public interface RSetRx<V> extends RCollectionRx<V>, RSortableRx<Set<V>> {
      * @param names - name of sets
      * @return size of intersection
      */
-    Single<Long> intersection(String... names);
+    Single<Integer> intersection(String... names);
 
     /**
      * Intersection sets specified by name with current set.

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -800,7 +800,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
         });
     }
     
-    private static final Map<ClassLoader, Map<Codec, Codec>> CODECS = ReferenceCacheMap.weak(0, 0);
+    private static final Map<ClassLoader, Map<Codec, Codec>> CODECS = ReferenceCacheMap.soft(0, 0);
 
     protected Codec getCodec(Codec codec) {
         if (codec == null) {

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -403,13 +403,13 @@ public <V> RedisException convertException(RFuture<V> future) {
     private NodeSource getNodeSource(String key) {
         int slot = connectionManager.calcSlot(key);
         MasterSlaveEntry entry = connectionManager.getEntry(slot);
-        return new NodeSource(entry);
+        return new NodeSource(entry, slot);
     }
 
     private NodeSource getNodeSource(byte[] key) {
         int slot = connectionManager.calcSlot(key);
         MasterSlaveEntry entry = connectionManager.getEntry(slot);
-        return new NodeSource(entry);
+        return new NodeSource(entry, slot);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/liveobject/resolver/RequiredIdResolver.java
Patch:
@@ -29,7 +29,7 @@ public class RequiredIdResolver implements RIdResolver<Object> {
 
     @Override
     public Object resolve(Class<?> cls, RId annotation, String idFieldName, RedissonClient redisson) {
-        throw new IllegalArgumentException("id value not defined for instance of " + cls);
+        throw new IllegalArgumentException("id value is not defined for instance of " + cls);
     }
 
 }

File: redisson/src/main/java/org/redisson/RedissonScript.java
Patch:
@@ -143,7 +143,7 @@ public <R> R evalSha(Mode mode, Codec codec, String shaDigest, ReturnType return
 
     @Override
     public <R> RFuture<R> evalShaAsync(Mode mode, String shaDigest, ReturnType returnType, List<Object> keys, Object... values) {
-        return evalShaAsync(null, mode, commandExecutor.getConnectionManager().getCodec(), shaDigest, returnType, keys, values);
+        return evalShaAsync(null, mode, codec, shaDigest, returnType, keys, values);
     }
 
     @Override
@@ -228,7 +228,7 @@ public RFuture<Void> scriptFlushAsync(String key) {
 
     @Override
     public <R> RFuture<R> evalShaAsync(Mode mode, String shaDigest, ReturnType returnType) {
-        return evalShaAsync(null, mode, commandExecutor.getConnectionManager().getCodec(), shaDigest, returnType, Collections.emptyList());
+        return evalShaAsync(null, mode, codec, shaDigest, returnType, Collections.emptyList());
     }
 
     @Override
@@ -238,7 +238,7 @@ public <R> RFuture<R> evalShaAsync(Mode mode, Codec codec, String shaDigest, Ret
 
     @Override
     public <R> RFuture<R> evalAsync(Mode mode, String luaScript, ReturnType returnType) {
-        return evalAsync(null, mode, commandExecutor.getConnectionManager().getCodec(), luaScript, returnType, Collections.emptyList());
+        return evalAsync(null, mode, codec, luaScript, returnType, Collections.emptyList());
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -609,13 +609,13 @@ public Boolean set(byte[] key, byte[] value, Expiration expiration, SetOption op
             }
         } else {
             if (option == null || option == SetOption.UPSERT) {
-                return write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", expiration.getExpirationTimeInMilliseconds());
+                return write(key, StringCodec.INSTANCE, SET, key, value, "PX", expiration.getExpirationTimeInMilliseconds());
             }
             if (option == SetOption.SET_IF_ABSENT) {
-                return write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", expiration.getExpirationTimeInMilliseconds(), "NX");
+                return write(key, StringCodec.INSTANCE, SET, key, value, "PX", expiration.getExpirationTimeInMilliseconds(), "NX");
             }
             if (option == SetOption.SET_IF_PRESENT) {
-                return write(key, StringCodec.INSTANCE, RedisCommands.SET, key, value, "PX", expiration.getExpirationTimeInMilliseconds(), "XX");
+                return write(key, StringCodec.INSTANCE, SET, key, value, "PX", expiration.getExpirationTimeInMilliseconds(), "XX");
             }
         }
         throw new IllegalArgumentException();

File: redisson/src/main/java/org/redisson/connection/pool/ConnectionPool.java
Patch:
@@ -107,7 +107,7 @@ private void createConnection(boolean checkFreezed, AtomicInteger requests, Clie
         if ((checkFreezed && entry.isFreezed()) || !tryAcquireConnection(entry)) {
             int totalInitializedConnections = minimumIdleSize - initializedConnections.get();
             Throwable cause = new RedisConnectionException(
-                    "Unable to init enough connections amount! Only " + totalInitializedConnections + " from " + minimumIdleSize + " were initialized. Server: "
+                    "Unable to init enough connections amount! Only " + totalInitializedConnections + " of " + minimumIdleSize + " were initialized. Server: "
                                         + entry.getClient().getAddr());
             initPromise.tryFailure(cause);
             return;
@@ -155,7 +155,7 @@ public void run() {
                                 errorMsg = "Unable to connect to Redis server: " + entry.getClient().getAddr();
                             } else {
                                 errorMsg = "Unable to init enough connections amount! Only " + totalInitializedConnections 
-                                        + " from " + minimumIdleSize + " were initialized. Redis server: " + entry.getClient().getAddr();
+                                        + " of " + minimumIdleSize + " were initialized. Redis server: " + entry.getClient().getAddr();
                             }
                             Throwable cause = new RedisConnectionException(errorMsg, e);
                             initPromise.tryFailure(cause);

File: redisson/src/main/java/org/redisson/config/ConfigSupport.java
Patch:
@@ -101,7 +101,7 @@ private String resolveEnvParams(Readable in) {
     }
     
     private String resolveEnvParams(String content) {
-        Pattern pattern = Pattern.compile("\\$\\{(\\w+(:-.+)?)\\}");
+        Pattern pattern = Pattern.compile("\\$\\{(\\w+(:-.+?)?)\\}");
         Matcher m = pattern.matcher(content);
         while (m.find()) {
             String[] parts = m.group(1).split(":-");

File: redisson/src/main/java/org/redisson/config/ConfigSupport.java
Patch:
@@ -101,7 +101,7 @@ private String resolveEnvParams(Readable in) {
     }
     
     private String resolveEnvParams(String content) {
-        Pattern pattern = Pattern.compile("\\$\\{(\\w+(:-.+)?)\\}");
+        Pattern pattern = Pattern.compile("\\$\\{(\\w+(:-.+?)?)\\}");
         Matcher m = pattern.matcher(content);
         while (m.find()) {
             String[] parts = m.group(1).split(":-");

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -110,7 +110,7 @@ protected void updateCache(ByteBuf keyBuf, ByteBuf valueBuf) throws IOException
             
         };
         cache = listener.createCache(options);
-        instanceId = listener.generateId();
+        instanceId = listener.getInstanceId();
         listener.add(cache);
         localCacheView = new LocalCacheView(cache, this);
 
@@ -446,7 +446,7 @@ public RFuture<Long> sizeInMemoryAsync() {
     @Override
     public RFuture<Boolean> deleteAsync() {
         cache.clear();
-        ByteBuf msgEncoded = encode(new LocalCachedMapClear());
+        ByteBuf msgEncoded = encode(new LocalCachedMapClear(listener.generateId()));
         return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 "if redis.call('del', KEYS[1], KEYS[3]) > 0 and ARGV[2] ~= '0' then "
                 + "redis.call('publish', KEYS[2], ARGV[1]); "

File: redisson/src/main/java/org/redisson/cache/LocalCachedMapDisable.java
Patch:
@@ -27,6 +27,9 @@ public class LocalCachedMapDisable implements Serializable {
     private byte[][] keyHashes;
     private long timeout;
     private String requestId;
+    
+    public LocalCachedMapDisable() {
+    }
 
     public LocalCachedMapDisable(String requestId, byte[][] keyHashes, long timeout) {
         super();

File: redisson/src/main/java/org/redisson/cache/LocalCachedMapEnable.java
Patch:
@@ -26,6 +26,9 @@ public class LocalCachedMapEnable implements Serializable {
 
     private byte[][] keyHashes;
     private String requestId;
+    
+    public LocalCachedMapEnable() {
+    }
 
     public LocalCachedMapEnable(String requestId, byte[][] keyHashes) {
         super();

File: redisson/src/test/java/org/redisson/RedissonLocalCachedMapTest.java
Patch:
@@ -315,8 +315,6 @@ public void testLocalCacheClear() throws InterruptedException {
         assertThat(cache2.size()).isEqualTo(2);
 
         map1.clearLocalCache();
-        
-        Thread.sleep(50);
 
         assertThat(cache1.size()).isZero();
         assertThat(cache2.size()).isZero();

File: redisson/src/test/java/org/redisson/RedissonLiveObjectServiceTest.java
Patch:
@@ -1385,7 +1385,7 @@ public void testCollectionRewrite() {
         
         assertThat(c.getOrders().size()).isEqualTo(2);
 
-        assertThat(redisson.getKeys().count()).isEqualTo(5);
+        assertThat(redisson.getKeys().count()).isEqualTo(7);
         
         List<Order> list = new ArrayList<>();
         Order o3 = new Order(c);

File: redisson/src/test/java/org/redisson/RedissonRemoteServiceTest.java
Patch:
@@ -313,6 +313,8 @@ public void testPendingInvocations() throws InterruptedException, ExecutionExcep
 
         executor.shutdown();
         executor.awaitTermination(1, TimeUnit.MINUTES);
+        
+        rs.deregister(RemoteInterface.class);
     }
     
     @Test

File: redisson/src/main/java/org/redisson/spring/session/config/EnableRedissonHttpSession.java
Patch:
@@ -23,10 +23,11 @@
 import org.springframework.context.annotation.Configuration;
 import org.springframework.context.annotation.Import;
 import org.springframework.session.MapSession;
+import org.springframework.session.web.http.SessionRepositoryFilter;
 
 /**
  * Enables Redisson's Spring Session implementation backed by Redis and
- * exposes SessionRepositoryFilter as a bean named "springSessionRepositoryFilter".
+ * exposes {@link SessionRepositoryFilter} as a bean named "springSessionRepositoryFilter".
  * <p>
  * Redisson instance should be registered as bean in application context.
  * Usage example:

File: redisson/src/main/java/org/redisson/spring/session/config/RedissonHttpSessionConfiguration.java
Patch:
@@ -26,9 +26,10 @@
 import org.springframework.core.annotation.AnnotationAttributes;
 import org.springframework.core.type.AnnotationMetadata;
 import org.springframework.session.config.annotation.web.http.SpringHttpSessionConfiguration;
+import org.springframework.session.web.http.SessionRepositoryFilter;
 
 /**
- * Exposes the SessionRepositoryFilter as the bean
+ * Exposes the {@link SessionRepositoryFilter} as the bean
  * named "springSessionRepositoryFilter".
  * <p>
  * Redisson instance should be registered as bean 

File: redisson/src/main/java/org/redisson/spring/session/RedissonSessionRepository.java
Patch:
@@ -83,6 +83,7 @@ final class RedissonSession implements Session {
         private void updateExpiration() {
             if (delegate.getMaxInactiveInterval().getSeconds() > 0) {
                 redisson.getBucket(getExpiredKey(delegate.getId())).set("", delegate.getMaxInactiveInterval().getSeconds(), TimeUnit.SECONDS);
+                map.expire(delegate.getMaxInactiveInterval().getSeconds() + 60, TimeUnit.SECONDS);
             }
         }
         

File: redisson/src/main/java/org/redisson/spring/session/config/RedissonHttpSessionConfiguration.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.util.Map;
 
-import net.bytebuddy.build.ToStringPlugin;
 import org.redisson.api.RedissonClient;
 import org.redisson.spring.session.RedissonSessionRepository;
 import org.springframework.context.ApplicationEventPublisher;
@@ -27,7 +26,6 @@
 import org.springframework.core.annotation.AnnotationAttributes;
 import org.springframework.core.type.AnnotationMetadata;
 import org.springframework.session.config.annotation.web.http.SpringHttpSessionConfiguration;
-import org.springframework.util.StringUtils;
 
 /**
  * Exposes the SessionRepositoryFilter as the bean

File: redisson/src/test/java/org/redisson/RedissonMapCacheTest.java
Patch:
@@ -84,7 +84,7 @@ protected <K, V> RMap<K, V> getLoaderTestMap(String name, Map<K, V> map) {
     
     @Test
     public void testSizeInMemory() {
-        //Assume.assumeTrue(RedisRunner.getDefaultRedisServerInstance().getRedisVersion().compareTo("4.0.0") > 0);
+        Assume.assumeTrue(RedisRunner.getDefaultRedisServerInstance().getRedisVersion().compareTo("4.0.0") > 0);
         
         RMapCache<Integer, Integer> map = redisson.getMapCache("test");
         for (int i = 0; i < 10; i++) {

File: redisson/src/main/java/org/redisson/RedissonRateLimiter.java
Patch:
@@ -126,7 +126,7 @@ public boolean tryAcquire(long permits, long timeout, TimeUnit unit) {
     public RFuture<Boolean> tryAcquireAsync(long permits, long timeout, TimeUnit unit) {
         RPromise<Boolean> promise = new RedissonPromise<Boolean>();
         long timeoutInMillis = -1;
-        if (timeout > 0) {
+        if (timeout >= 0) {
             timeoutInMillis = unit.toMillis(timeout);
         }
         tryAcquireAsync(permits, promise, timeoutInMillis);

File: redisson/src/main/java/org/redisson/RedissonReadLock.java
Patch:
@@ -72,7 +72,8 @@ <T> RFuture<T> tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, R
                                   "local key = KEYS[2] .. ':' .. ind;" +
                                   "redis.call('set', key, 1); " +
                                   "redis.call('pexpire', key, ARGV[1]); " +
-                                  "redis.call('pexpire', KEYS[1], ARGV[1]); " +
+                                  "local remainTime = redis.call('pttl', KEYS[1]); " +
+                                  "redis.call('pexpire', KEYS[1], math.max(remainTime, ARGV[1])); " +
                                   "return nil; " +
                                 "end;" +
                                 "return redis.call('pttl', KEYS[1]);",

File: redisson/src/main/java/org/redisson/RedissonRemoteService.java
Patch:
@@ -136,7 +136,7 @@ public <T> void deregister(Class<T> remoteInterface) {
     
     @Override
     public int getFreeWorkers(Class<?> remoteInterface) {
-        Entry entry = remoteMap.remove(remoteInterface);
+        Entry entry = remoteMap.get(remoteInterface);
         if (entry == null) {
             return 0;
         }

File: redisson/src/main/java/org/redisson/client/RedisClient.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
-import java.net.URI;
 import java.net.UnknownHostException;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -28,6 +27,7 @@
 import org.redisson.client.handler.RedisChannelInitializer;
 import org.redisson.client.handler.RedisChannelInitializer.Type;
 import org.redisson.misc.RPromise;
+import org.redisson.misc.RedisURI;
 import org.redisson.misc.RedissonPromise;
 
 import io.netty.bootstrap.Bootstrap;
@@ -63,7 +63,7 @@ public final class RedisClient {
     private final AtomicReference<RFuture<InetSocketAddress>> resolvedAddrFuture = new AtomicReference<RFuture<InetSocketAddress>>();
     private final Bootstrap bootstrap;
     private final Bootstrap pubSubBootstrap;
-    private final URI uri;
+    private final RedisURI uri;
     private InetSocketAddress resolvedAddr;
     private final ChannelGroup channels;
 

File: redisson/src/main/java/org/redisson/client/handler/ConnectionWatchdog.java
Patch:
@@ -177,14 +177,12 @@ private void reattachBlockingQueue(RedisConnection connection, CommandData<?, ?>
             return;
         }
 
-        log.debug("blocking queue sent " + connection);
         ChannelFuture future = connection.send(currentCommand);
-        final CommandData<?, ?> cd = currentCommand;
         future.addListener(new ChannelFutureListener() {
             @Override
             public void operationComplete(ChannelFuture future) throws Exception {
                 if (!future.isSuccess()) {
-                    log.error("Can't reconnect blocking queue to new connection. {}", cd);
+                    log.error("Can't reconnect blocking queue by command: {} using connection: {}", currentCommand, connection);
                 }
             }
         });

File: redisson/src/main/java/org/redisson/connection/SingleEntry.java
Patch:
@@ -15,12 +15,11 @@
  */
 package org.redisson.connection;
 
-import java.net.URI;
-
 import org.redisson.api.RFuture;
 import org.redisson.client.RedisConnection;
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.config.MasterSlaveServersConfig;
+import org.redisson.misc.RedisURI;
 
 /**
  * 
@@ -34,7 +33,7 @@ public SingleEntry(ConnectionManager connectionManager, MasterSlaveServersConfig
     }
 
     @Override
-    public RFuture<RedisConnection> connectionReadOp(RedisCommand<?> command, URI addr) {
+    public RFuture<RedisConnection> connectionReadOp(RedisCommand<?> command, RedisURI addr) {
         return super.connectionWriteOp(command);
     }
 

File: redisson/src/main/java/org/redisson/connection/balancer/WeightedRoundRobinBalancer.java
Patch:
@@ -16,7 +16,6 @@
 package org.redisson.connection.balancer;
 
 import java.net.InetSocketAddress;
-import java.net.URI;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -29,7 +28,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.redisson.connection.ClientConnectionsEntry;
-import org.redisson.misc.URIBuilder;
+import org.redisson.misc.RedisURI;
 
 /**
  * Weighted Round Robin balancer.
@@ -77,7 +76,7 @@ public void resetWeightCounter() {
      */
     public WeightedRoundRobinBalancer(Map<String, Integer> weights, int defaultWeight) {
         for (Entry<String, Integer> entry : weights.entrySet()) {
-            URI uri = URIBuilder.create(entry.getKey());
+            RedisURI uri = new RedisURI(entry.getKey());
             InetSocketAddress addr = new InetSocketAddress(uri.getHost(), uri.getPort());
             if (entry.getValue() <= 0) {
                 throw new IllegalArgumentException("Weight can't be less than or equal zero");

File: redisson/src/main/java/org/redisson/client/RedisClient.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
-import java.net.URI;
 import java.net.UnknownHostException;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -28,6 +27,7 @@
 import org.redisson.client.handler.RedisChannelInitializer;
 import org.redisson.client.handler.RedisChannelInitializer.Type;
 import org.redisson.misc.RPromise;
+import org.redisson.misc.RedisURI;
 import org.redisson.misc.RedissonPromise;
 
 import io.netty.bootstrap.Bootstrap;
@@ -63,7 +63,7 @@ public final class RedisClient {
     private final AtomicReference<RFuture<InetSocketAddress>> resolvedAddrFuture = new AtomicReference<RFuture<InetSocketAddress>>();
     private final Bootstrap bootstrap;
     private final Bootstrap pubSubBootstrap;
-    private final URI uri;
+    private final RedisURI uri;
     private InetSocketAddress resolvedAddr;
     private final ChannelGroup channels;
 

File: redisson/src/main/java/org/redisson/connection/SingleEntry.java
Patch:
@@ -15,12 +15,11 @@
  */
 package org.redisson.connection;
 
-import java.net.URI;
-
 import org.redisson.api.RFuture;
 import org.redisson.client.RedisConnection;
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.config.MasterSlaveServersConfig;
+import org.redisson.misc.RedisURI;
 
 /**
  * 
@@ -34,7 +33,7 @@ public SingleEntry(ConnectionManager connectionManager, MasterSlaveServersConfig
     }
 
     @Override
-    public RFuture<RedisConnection> connectionReadOp(RedisCommand<?> command, URI addr) {
+    public RFuture<RedisConnection> connectionReadOp(RedisCommand<?> command, RedisURI addr) {
         return super.connectionWriteOp(command);
     }
 

File: redisson/src/main/java/org/redisson/connection/balancer/WeightedRoundRobinBalancer.java
Patch:
@@ -16,7 +16,6 @@
 package org.redisson.connection.balancer;
 
 import java.net.InetSocketAddress;
-import java.net.URI;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -29,7 +28,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.redisson.connection.ClientConnectionsEntry;
-import org.redisson.misc.URIBuilder;
+import org.redisson.misc.RedisURI;
 
 /**
  * Weighted Round Robin balancer.
@@ -77,7 +76,7 @@ public void resetWeightCounter() {
      */
     public WeightedRoundRobinBalancer(Map<String, Integer> weights, int defaultWeight) {
         for (Entry<String, Integer> entry : weights.entrySet()) {
-            URI uri = URIBuilder.create(entry.getKey());
+            RedisURI uri = new RedisURI(entry.getKey());
             InetSocketAddress addr = new InetSocketAddress(uri.getHost(), uri.getPort());
             if (entry.getValue() <= 0) {
                 throw new IllegalArgumentException("Weight can't be less than or equal zero");

File: redisson/src/main/java/org/redisson/RedissonRemoteService.java
Patch:
@@ -136,7 +136,7 @@ public <T> void deregister(Class<T> remoteInterface) {
     
     @Override
     public int getFreeWorkers(Class<?> remoteInterface) {
-        Entry entry = remoteMap.remove(remoteInterface);
+        Entry entry = remoteMap.get(remoteInterface);
         if (entry == null) {
             return 0;
         }

File: redisson/src/main/java/org/redisson/RedissonRateLimiter.java
Patch:
@@ -126,7 +126,7 @@ public boolean tryAcquire(long permits, long timeout, TimeUnit unit) {
     public RFuture<Boolean> tryAcquireAsync(long permits, long timeout, TimeUnit unit) {
         RPromise<Boolean> promise = new RedissonPromise<Boolean>();
         long timeoutInMillis = -1;
-        if (timeout > 0) {
+        if (timeout >= 0) {
             timeoutInMillis = unit.toMillis(timeout);
         }
         tryAcquireAsync(permits, promise, timeoutInMillis);

File: redisson/src/main/java/org/redisson/RedissonReadLock.java
Patch:
@@ -72,7 +72,8 @@ <T> RFuture<T> tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, R
                                   "local key = KEYS[2] .. ':' .. ind;" +
                                   "redis.call('set', key, 1); " +
                                   "redis.call('pexpire', key, ARGV[1]); " +
-                                  "redis.call('pexpire', KEYS[1], ARGV[1]); " +
+                                  "local remainTime = redis.call('pttl', KEYS[1]); " +
+                                  "redis.call('pexpire', KEYS[1], math.max(remainTime, ARGV[1])); " +
                                   "return nil; " +
                                 "end;" +
                                 "return redis.call('pttl', KEYS[1]);",

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonReactiveSubscription.java
Patch:
@@ -132,7 +132,7 @@ public Set<ByteBuffer> getPatterns() {
 
     @Override
     public Flux<Message<ByteBuffer, ByteBuffer>> receive() {
-        if (flux.get() == null) {
+        if (flux.get() != null) {
             return flux.get();
         }
         

File: redisson/src/main/java/org/redisson/command/CommandBatchService.java
Patch:
@@ -304,7 +304,7 @@ protected <R, V> void sendCommand(AsyncDetails<V, R> details, RedisConnection co
                     }
 
                     RPromise<Void> main = new RedissonPromise<Void>();
-                    ChannelFuture future = connection.send(new CommandsData(main, list, new ArrayList(entry.getCommands())));
+                    ChannelFuture future = connection.send(new CommandsData(main, list, new ArrayList(entry.getCommands()), options.isSkipResult(), false, true));
                     details.setWriteFuture(future);
                 } else {
                     RPromise<Void> main = new RedissonPromise<Void>();

File: redisson/src/main/java/org/redisson/config/RedissonNodeConfig.java
Patch:
@@ -46,6 +46,7 @@ public RedissonNodeConfig(RedissonNodeConfig oldConf) {
         super(oldConf);
         this.executorServiceWorkers = new HashMap<String, Integer>(oldConf.executorServiceWorkers);
         this.redissonNodeInitializer = oldConf.redissonNodeInitializer;
+        this.mapReduceWorkers = oldConf.mapReduceWorkers;
     }
     
     /**

File: redisson/src/main/java/org/redisson/spring/session/RedissonSessionRepository.java
Patch:
@@ -136,10 +136,9 @@ public void setAttribute(String attributeName, Object attributeValue) {
             if (map != null) {
                 map.fastPut(attributeName, attributeValue);
                 
-                String principalSessionAttr = getSessionAttrNameKey(PRINCIPAL_NAME_INDEX_NAME);
                 String securityPrincipalSessionAttr = getSessionAttrNameKey(SPRING_SECURITY_CONTEXT);
                 
-                if (attributeName.equals(principalSessionAttr)
+                if (attributeName.equals(PRINCIPAL_NAME_INDEX_NAME)
                         || attributeName.equals(securityPrincipalSessionAttr)) {
                     // remove old
                     if (principalName != null) {

File: redisson/src/main/java/org/redisson/pubsub/AsyncSemaphore.java
Patch:
@@ -162,7 +162,7 @@ public void release() {
             Iterator<Entry> iter = listeners.iterator();
             if (iter.hasNext()) {
                 Entry entry = iter.next();
-                if (entry.getPermits() >= counter) {
+                if (entry.getPermits() <= counter) {
                     iter.remove();
                     entryToAcquire = entry;
                 }

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/GeoResultsDecoder.java
Patch:
@@ -64,7 +64,7 @@ public GeoResults<GeoLocation<byte[]>> decode(List<Object> parts, State state) {
                     result.add(new GeoResult<GeoLocation<byte[]>>(location, new Distance((Double)vals.get(1), metric)));
                 } else {
                     GeoLocation<byte[]> location = new GeoLocation<byte[]>((byte[])vals.get(0), (Point)vals.get(1));
-                    result.add(new GeoResult<GeoLocation<byte[]>>(location, null));
+                    result.add(new GeoResult<GeoLocation<byte[]>>(location, new Distance(0)));
                 }
             } else {
                 GeoLocation<byte[]> location = new GeoLocation<byte[]>((byte[])object, null);

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/GeoResultsDecoder.java
Patch:
@@ -64,7 +64,7 @@ public GeoResults<GeoLocation<byte[]>> decode(List<Object> parts, State state) {
                     result.add(new GeoResult<GeoLocation<byte[]>>(location, new Distance((Double)vals.get(1), metric)));
                 } else {
                     GeoLocation<byte[]> location = new GeoLocation<byte[]>((byte[])vals.get(0), (Point)vals.get(1));
-                    result.add(new GeoResult<GeoLocation<byte[]>>(location, null));
+                    result.add(new GeoResult<GeoLocation<byte[]>>(location, new Distance(0)));
                 }
             } else {
                 GeoLocation<byte[]> location = new GeoLocation<byte[]>((byte[])object, null);

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/GeoResultsDecoder.java
Patch:
@@ -64,7 +64,7 @@ public GeoResults<GeoLocation<byte[]>> decode(List<Object> parts, State state) {
                     result.add(new GeoResult<GeoLocation<byte[]>>(location, new Distance((Double)vals.get(1), metric)));
                 } else {
                     GeoLocation<byte[]> location = new GeoLocation<byte[]>((byte[])vals.get(0), (Point)vals.get(1));
-                    result.add(new GeoResult<GeoLocation<byte[]>>(location, null));
+                    result.add(new GeoResult<GeoLocation<byte[]>>(location, new Distance(0)));
                 }
             } else {
                 GeoLocation<byte[]> location = new GeoLocation<byte[]>((byte[])object, null);

File: redisson/src/main/java/org/redisson/config/RedissonNodeConfig.java
Patch:
@@ -46,6 +46,7 @@ public RedissonNodeConfig(RedissonNodeConfig oldConf) {
         super(oldConf);
         this.executorServiceWorkers = new HashMap<String, Integer>(oldConf.executorServiceWorkers);
         this.redissonNodeInitializer = oldConf.redissonNodeInitializer;
+        this.mapReduceWorkers = oldConf.mapReduceWorkers;
     }
     
     /**

File: redisson/src/main/java/org/redisson/Redisson.java
Patch:
@@ -480,7 +480,7 @@ public RRemoteService getRemoteService(String name, Codec codec) {
         } else {
             executorId = connectionManager.getId() + ":" + name;
         }
-        return new RedissonRemoteService(codec, this, name, connectionManager.getCommandExecutor(), executorId, responses);
+        return new RedissonRemoteService(codec, name, connectionManager.getCommandExecutor(), executorId, responses);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonLiveObjectService.java
Patch:
@@ -326,7 +326,7 @@ && checkCascade(detachedObject, type, field.getName())) {
                     }
                 } else if (rObject instanceof Map) {
                     Map<Object, Object> rMap = (Map<Object, Object>) rObject;
-                    Map<?, ?> map = (Map<?, ?>) rObject;
+                    Map<?, ?> map = (Map<?, ?>) object;
                     for (Entry<?, ?> entry : map.entrySet()) {
                         Object key = entry.getKey();
                         Object value = entry.getValue();

File: redisson/src/main/java/org/redisson/RedissonRateLimiter.java
Patch:
@@ -200,6 +200,7 @@ private <T> RFuture<T> tryAcquireAsync(RedisCommand<T> command, Long value) {
                          + "return nil; "
                      + "end; "
               + "else "
+                     + "assert(tonumber(rate) >= tonumber(ARGV[1]), 'Requested permits amount could not exceed defined rate'); "
                      + "redis.call('set', valueName, rate, 'px', interval); "
                      + "redis.call('decrby', valueName, ARGV[1]); "
                      + "return nil; "

File: redisson/src/main/java/org/redisson/api/annotation/RRemoteAsync.java
Patch:
@@ -25,11 +25,13 @@
  * client interface for remote service interface. 
  * <p>
  * All method signatures must match with remote service interface,
- * but return type must be <code>io.netty.util.concurrent.Future</code>.
+ * but return type must be <code>org.redisson.api.RFuture</code>.
  * <p>
  * It's not necessary to add all methods from remote service.
  * Add only those which are needed. 
  * 
+ * @see org.redisson.api.RFuture
+ * 
  * @author Nikita Koksharov
  *
  */

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -376,7 +376,7 @@ private void updateClusterState(ClusterServersConfig cfg, RedisConnection connec
                     for (ClusterNodeInfo clusterNodeInfo : nodes) {
                         nodesValue.append(clusterNodeInfo.getNodeInfo()).append("\n");
                     }
-                    log.debug("cluster nodes state from {}:\n{}", connection.getRedisClient().getAddr(), nodesValue);
+                    log.debug("cluster nodes state got from {}:\n{}", connection.getRedisClient().getAddr(), nodesValue);
                 }
 
                 Collection<ClusterPartition> newPartitions = parsePartitions(nodes);

File: redisson/src/main/java/org/redisson/codec/CompositeCodec.java
Patch:
@@ -51,7 +51,7 @@ public CompositeCodec(ClassLoader classLoader, CompositeCodec codec) throws Refl
     
     @Override
     public Decoder<Object> getMapValueDecoder() {
-        return mapValueCodec.getMapKeyDecoder();
+        return mapValueCodec.getMapValueDecoder();
     }
 
     @Override

File: redisson/src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -37,6 +37,7 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.util.Timeout;
 import io.netty.util.TimerTask;
+import io.netty.util.concurrent.Future;
 
 /**
  *
@@ -109,6 +110,6 @@ public interface ConnectionManager {
 
     InfinitySemaphoreLatch getShutdownLatch();
     
-    RFuture<Boolean> getShutdownPromise();
+    Future<Void> getShutdownPromise();
 
 }

File: redisson/src/main/java/org/redisson/executor/ScheduledTasksService.java
Patch:
@@ -21,7 +21,6 @@
 
 import org.redisson.RedissonExecutorService;
 import org.redisson.api.RFuture;
-import org.redisson.api.RedissonClient;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.codec.LongCodec;
 import org.redisson.client.codec.StringCodec;
@@ -41,8 +40,8 @@ public class ScheduledTasksService extends TasksService {
 
     private RequestId requestId;
     
-    public ScheduledTasksService(Codec codec, RedissonClient redisson, String name, CommandExecutor commandExecutor, String redissonId, ConcurrentMap<String, ResponseEntry> responses) {
-        super(codec, redisson, name, commandExecutor, redissonId, responses);
+    public ScheduledTasksService(Codec codec, String name, CommandExecutor commandExecutor, String redissonId, ConcurrentMap<String, ResponseEntry> responses) {
+        super(codec, name, commandExecutor, redissonId, responses);
     }
     
     public void setRequestId(RequestId requestId) {

File: redisson/src/main/java/org/redisson/executor/TasksBatchService.java
Patch:
@@ -19,7 +19,6 @@
 import java.util.concurrent.ConcurrentMap;
 
 import org.redisson.api.RFuture;
-import org.redisson.api.RedissonClient;
 import org.redisson.client.codec.Codec;
 import org.redisson.command.CommandAsyncExecutor;
 import org.redisson.command.CommandBatchService;
@@ -35,8 +34,8 @@ public class TasksBatchService extends TasksService {
 
     private CommandBatchService batchCommandService;
     
-    public TasksBatchService(Codec codec, RedissonClient redisson, String name, CommandExecutor commandExecutor, String executorId, ConcurrentMap<String, ResponseEntry> responses) {
-        super(codec, redisson, name, commandExecutor, executorId, responses);
+    public TasksBatchService(Codec codec, String name, CommandExecutor commandExecutor, String executorId, ConcurrentMap<String, ResponseEntry> responses) {
+        super(codec, name, commandExecutor, executorId, responses);
         batchCommandService = new CommandBatchService(commandExecutor.getConnectionManager());
     }
     

File: redisson/src/main/java/org/redisson/executor/TasksRunnerService.java
Patch:
@@ -161,7 +161,7 @@ public void schedule(ScheduledCronExpressionParameters params) {
      * @return
      */
     private RemoteExecutorServiceAsync asyncScheduledServiceAtFixed(String executorId, String requestId) {
-        ScheduledTasksService scheduledRemoteService = new ScheduledTasksService(codec, redisson, name, commandExecutor, executorId, responses);
+        ScheduledTasksService scheduledRemoteService = new ScheduledTasksService(codec, name, commandExecutor, executorId, responses);
         scheduledRemoteService.setTerminationTopicName(terminationTopicName);
         scheduledRemoteService.setTasksCounterName(tasksCounterName);
         scheduledRemoteService.setStatusName(statusName);

File: redisson/src/test/java/org/redisson/executor/RedissonScheduledExecutorServiceTest.java
Patch:
@@ -13,6 +13,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.joor.Reflect;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
@@ -105,7 +106,8 @@ public void testDelay() throws InterruptedException {
         assertThat(f.isSuccess()).isTrue();
         assertThat(System.currentTimeMillis() - start).isBetween(11000L, 11500L);
         
-        Deencapsulation.setField(RedissonExecutorService.class, "RESULT_OPTIONS", RemoteInvocationOptions.defaults().noAck().expectResultWithin(3, TimeUnit.SECONDS));
+        Reflect.onClass(RedissonExecutorService.class).set("RESULT_OPTIONS", RemoteInvocationOptions.defaults().noAck().expectResultWithin(3, TimeUnit.SECONDS));
+    
         executor = redisson.getExecutorService("test", ExecutorOptions.defaults().taskRetryInterval(5, TimeUnit.SECONDS));
         start = System.currentTimeMillis();
         RScheduledFuture<?> f1 = executor.schedule(new ScheduledCallableTask(), 5, TimeUnit.SECONDS);

File: redisson/src/main/java/org/redisson/jcache/JCache.java
Patch:
@@ -869,6 +869,7 @@ public boolean containsKey(K key) {
     }
 
     @Override
+    @SuppressWarnings("NestedTryDepth")
     public void loadAll(final Set<? extends K> keys, final boolean replaceExistingValues, final CompletionListener completionListener) {
         checkNotClosed();
         if (keys == null) {

File: redisson/src/main/java/org/redisson/RedissonLiveObjectService.java
Patch:
@@ -326,7 +326,7 @@ && checkCascade(detachedObject, type, field.getName())) {
                     }
                 } else if (rObject instanceof Map) {
                     Map<Object, Object> rMap = (Map<Object, Object>) rObject;
-                    Map<?, ?> map = (Map<?, ?>) rObject;
+                    Map<?, ?> map = (Map<?, ?>) object;
                     for (Entry<?, ?> entry : map.entrySet()) {
                         Object key = entry.getKey();
                         Object value = entry.getValue();

File: redisson/src/main/java/org/redisson/RedissonRateLimiter.java
Patch:
@@ -200,6 +200,7 @@ private <T> RFuture<T> tryAcquireAsync(RedisCommand<T> command, Long value) {
                          + "return nil; "
                      + "end; "
               + "else "
+                     + "assert(tonumber(rate) >= tonumber(ARGV[1]), 'Requested permits amount could not exceed defined rate'); "
                      + "redis.call('set', valueName, rate, 'px', interval); "
                      + "redis.call('decrby', valueName, ARGV[1]); "
                      + "return nil; "

File: redisson/src/main/java/org/redisson/codec/CompositeCodec.java
Patch:
@@ -51,7 +51,7 @@ public CompositeCodec(ClassLoader classLoader, CompositeCodec codec) throws Refl
     
     @Override
     public Decoder<Object> getMapValueDecoder() {
-        return mapValueCodec.getMapKeyDecoder();
+        return mapValueCodec.getMapValueDecoder();
     }
 
     @Override

File: redisson/src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -37,6 +37,7 @@
 import io.netty.channel.EventLoopGroup;
 import io.netty.util.Timeout;
 import io.netty.util.TimerTask;
+import io.netty.util.concurrent.Future;
 
 /**
  *
@@ -109,6 +110,6 @@ public interface ConnectionManager {
 
     InfinitySemaphoreLatch getShutdownLatch();
     
-    RFuture<Boolean> getShutdownPromise();
+    Future<Void> getShutdownPromise();
 
 }

File: redisson-tomcat/redisson-tomcat-6/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -280,9 +280,8 @@ public void onMessage(CharSequence channel, AttributeMessage msg) {
                             
                             if (msg instanceof AttributesPutAllMessage) {
                                 AttributesPutAllMessage m = (AttributesPutAllMessage) msg;
-                                for (Entry<String, Object> entry : m.getAttrs(codecToUse.getMapValueDecoder()).entrySet()) {
-                                    session.superSetAttribute(entry.getKey(), entry.getValue(), true);
-                                }
+                                Map<String, Object> attrs = m.getAttrs(codecToUse.getMapValueDecoder());
+                                session.load(attrs);
                             }
                             
                             if (msg instanceof AttributeUpdateMessage) {

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -260,9 +260,8 @@ public void onMessage(CharSequence channel, AttributeMessage msg) {
                             
                             if (msg instanceof AttributesPutAllMessage) {
                                 AttributesPutAllMessage m = (AttributesPutAllMessage) msg;
-                                for (Entry<String, Object> entry : m.getAttrs(codecToUse.getMapValueDecoder()).entrySet()) {
-                                    session.superSetAttribute(entry.getKey(), entry.getValue(), true);
-                                }
+                                Map<String, Object> attrs = m.getAttrs(codecToUse.getMapValueDecoder());
+                                session.load(attrs);
                             }
                             
                             if (msg instanceof AttributeUpdateMessage) {

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -259,9 +259,8 @@ public void onMessage(CharSequence channel, AttributeMessage msg) {
                             
                             if (msg instanceof AttributesPutAllMessage) {
                                 AttributesPutAllMessage m = (AttributesPutAllMessage) msg;
-                                for (Entry<String, Object> entry : m.getAttrs(codecToUse.getMapValueDecoder()).entrySet()) {
-                                    session.superSetAttribute(entry.getKey(), entry.getValue(), true);
-                                }
+                                Map<String, Object> attrs = m.getAttrs(codecToUse.getMapValueDecoder());
+                                session.load(attrs);
                             }
                             
                             if (msg instanceof AttributeUpdateMessage) {

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -259,9 +259,8 @@ public void onMessage(CharSequence channel, AttributeMessage msg) {
                             
                             if (msg instanceof AttributesPutAllMessage) {
                                 AttributesPutAllMessage m = (AttributesPutAllMessage) msg;
-                                for (Entry<String, Object> entry : m.getAttrs(codecToUse.getMapValueDecoder()).entrySet()) {
-                                    session.superSetAttribute(entry.getKey(), entry.getValue(), true);
-                                }
+                                Map<String, Object> attrs = m.getAttrs(codecToUse.getMapValueDecoder());
+                                session.load(attrs);
                             }
                             
                             if (msg instanceof AttributeUpdateMessage) {

File: redisson-tomcat/redisson-tomcat-6/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -60,7 +60,7 @@ public class RedissonSession extends StandardSession {
     private final RedissonSessionManager.ReadMode readMode;
     private final UpdateMode updateMode;
     
-    private Set<String> removedAttributes;
+    private Set<String> removedAttributes = Collections.emptySet();
     
     public RedissonSession(RedissonSessionManager manager, ReadMode readMode, UpdateMode updateMode) {
         super(manager);

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -60,7 +60,7 @@ public class RedissonSession extends StandardSession {
     private final RedissonSessionManager.ReadMode readMode;
     private final UpdateMode updateMode;
     
-    private Set<String> removedAttributes;
+    private Set<String> removedAttributes = Collections.emptySet();
     
     public RedissonSession(RedissonSessionManager manager, RedissonSessionManager.ReadMode readMode, UpdateMode updateMode) {
         super(manager);

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -60,7 +60,7 @@ public class RedissonSession extends StandardSession {
     private final RedissonSessionManager.ReadMode readMode;
     private final UpdateMode updateMode;
     
-    private Set<String> removedAttributes;
+    private Set<String> removedAttributes = Collections.emptySet();
     
     public RedissonSession(RedissonSessionManager manager, RedissonSessionManager.ReadMode readMode, UpdateMode updateMode) {
         super(manager);

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -60,7 +60,7 @@ public class RedissonSession extends StandardSession {
     private final RedissonSessionManager.ReadMode readMode;
     private final UpdateMode updateMode;
     
-    private Set<String> removedAttributes;
+    private Set<String> removedAttributes = Collections.emptySet();
     
     public RedissonSession(RedissonSessionManager manager, RedissonSessionManager.ReadMode readMode, UpdateMode updateMode) {
         super(manager);

File: redisson/src/main/java/org/redisson/spring/cache/RedissonCache.java
Patch:
@@ -173,7 +173,7 @@ public <T> T get(Object key, Callable<T> valueLoader) {
 
     private <T> Object putValue(Object key, Callable<T> valueLoader, Object value) {
         try {
-            value = toStoreValue(valueLoader.call());
+            value = valueLoader.call();
         } catch (Exception ex) {
             RuntimeException exception;
             try {

File: redisson/src/main/java/org/redisson/api/RObjectReactive.java
Patch:
@@ -171,6 +171,7 @@ public interface RObjectReactive {
      * Removes object event listener
      * 
      * @param listenerId - listener id
+     * @return void
      */
     Mono<Void> removeListener(int listenerId);
     

File: redisson-hibernate/redisson-hibernate-52/src/main/java/org/redisson/hibernate/RedissonRegionFactory.java
Patch:
@@ -94,7 +94,7 @@ public void start(SessionFactoryOptions settings, Properties properties) throws
         
         StrategySelector selector = settings.getServiceRegistry().getService(StrategySelector.class);
         cacheKeysFactory = selector.resolveDefaultableStrategy(CacheKeysFactory.class, 
-                                properties.get(Environment.CACHE_KEYS_FACTORY), DefaultCacheKeysFactory.INSTANCE);
+                                properties.get(Environment.CACHE_KEYS_FACTORY), new DefaultCacheKeysFactory());
     }
 
     protected RedissonClient createRedissonClient(Properties properties) {

File: redisson/src/main/java/org/redisson/command/CommandBatchService.java
Patch:
@@ -188,7 +188,7 @@ public <V, R> void async(boolean readOnlyMode, NodeSource nodeSource,
     AsyncSemaphore semaphore = new AsyncSemaphore(0);
     
     @Override
-    protected <R> RPromise<R> createPromise() {
+    public <R> RPromise<R> createPromise() {
         if (isRedisBasedQueue()) {
             return new BatchPromise<R>(executed);
         }

File: redisson/src/main/java/org/redisson/rx/RedissonBatchRx.java
Patch:
@@ -92,7 +92,7 @@ public class RedissonBatchRx implements RBatchRx {
     
     public RedissonBatchRx(EvictionScheduler evictionScheduler, ConnectionManager connectionManager, CommandRxExecutor commandExecutor, BatchOptions options) {
         this.evictionScheduler = evictionScheduler;
-        this.executorService = new CommandRxBatchService(connectionManager);
+        this.executorService = new CommandRxBatchService(connectionManager, options);
         this.commandExecutor = commandExecutor;
         this.options = options;
     }

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -456,11 +456,11 @@ protected RedisClientConfig createRedisConfig(NodeType type, URI address, int ti
               .setKeepPubSubOrder(cfg.isKeepPubSubOrder())
               .setPingConnectionInterval(config.getPingConnectionInterval())
               .setKeepAlive(config.isKeepAlive())
-              .setTcpNoDelay(config.isTcpNoDelay());
+              .setTcpNoDelay(config.isTcpNoDelay())
+              .setPassword(config.getPassword());
         
         if (type != NodeType.SENTINEL) {
             redisConfig.setDatabase(config.getDatabase());
-            redisConfig.setPassword(config.getPassword());
         }
         
         return redisConfig;

File: redisson/src/main/java/org/redisson/codec/MapCacheEventCodec.java
Patch:
@@ -107,7 +107,7 @@ private Object decode(ByteBuf buf, State state, Decoder<?> decoder) throws IOExc
         int keyLen;
         if (osType == OSType.WINDOWS) {
             keyLen = buf.readIntLE();
-        } else if (osType == OSType.WINDOWS) {
+        } else if (osType == OSType.HPNONSTOP) {
             keyLen = (int) buf.readLong();
         } else {
             keyLen = (int) buf.readLongLE();

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ObjectDecoder.java
Patch:
@@ -41,7 +41,8 @@ public Decoder<Object> getDecoder(int paramNum, State state) {
 
     @Override
     public Object decode(List<Object> parts, State state) {
-        throw new IllegalStateException();
+        parts.clear();
+        return parts;
     }
 
 }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/StreamIdDecoder.java
Patch:
@@ -35,6 +35,9 @@ public class StreamIdDecoder implements Decoder<Object> {
     public Object decode(ByteBuf buf, State state) throws IOException {
         String id = (String) StringCodec.INSTANCE.getValueDecoder().decode(buf, state);
         String[] parts = id.toString().split("-");
+        if (parts.length == 1) {
+            return null;
+        }
         return new StreamMessageId(Long.valueOf(parts[0]), Long.valueOf(parts[1]));
     }
 

File: redisson/src/main/java/org/redisson/client/RedisConnection.java
Patch:
@@ -206,7 +206,7 @@ public <T, R> RFuture<R> async(long timeout, Codec encoder, RedisCommand<T> comm
             @Override
             public void run() {
                 RedisTimeoutException ex = new RedisTimeoutException("Command execution timeout for command: "
-                        + command + ", command params: " + LogHelper.toString(params) 
+                        + LogHelper.toString(command, params)
                         + ", Redis client: " + redisClient);
                 promise.tryFailure(ex);
             }

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -333,6 +333,7 @@ protected RFuture<Boolean> fastPutOperationAsync(K key, V value) {
     
     @Override
     public void destroy() {
+        cache.clear();
         listener.remove();
     }
 

File: redisson-tomcat/redisson-tomcat-6/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -187,7 +187,7 @@ protected AttributesPutAllMessage createPutAllMessage(Map<String, Object> newMap
             map.put(entry.getKey(), entry.getValue());
         }
         try {
-            return new AttributesPutAllMessage(redissonManager.getNodeId(), getId(), map);
+            return new AttributesPutAllMessage(redissonManager.getNodeId(), getId(), map, this.map.getCodec().getMapValueEncoder());
         } catch (IOException e) {
             throw new IllegalStateException(e);
         }
@@ -207,7 +207,7 @@ private void fastPut(String name, Object value) {
         map.fastPut(name, value);
         if (readMode == ReadMode.MEMORY) {
             try {
-                topic.publish(new AttributeUpdateMessage(redissonManager.getNodeId(), getId(), name, value));
+                topic.publish(new AttributeUpdateMessage(redissonManager.getNodeId(), getId(), name, value, this.map.getCodec().getMapValueEncoder()));
             } catch (IOException e) {
                 throw new IllegalStateException(e);
             }

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -187,7 +187,7 @@ protected AttributesPutAllMessage createPutAllMessage(Map<String, Object> newMap
             map.put(entry.getKey(), entry.getValue());
         }
         try {
-            return new AttributesPutAllMessage(redissonManager.getNodeId(), getId(), map);
+            return new AttributesPutAllMessage(redissonManager.getNodeId(), getId(), map, this.map.getCodec().getMapValueEncoder());
         } catch (IOException e) {
             throw new IllegalStateException(e);
         }
@@ -207,7 +207,7 @@ private void fastPut(String name, Object value) {
         map.fastPut(name, value);
         if (readMode == ReadMode.MEMORY) {
             try {
-                topic.publish(new AttributeUpdateMessage(redissonManager.getNodeId(), getId(), name, value));
+                topic.publish(new AttributeUpdateMessage(redissonManager.getNodeId(), getId(), name, value, this.map.getCodec().getMapValueEncoder()));
             } catch (IOException e) {
                 throw new IllegalStateException(e);
             }

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -187,7 +187,7 @@ protected AttributesPutAllMessage createPutAllMessage(Map<String, Object> newMap
             map.put(entry.getKey(), entry.getValue());
         }
         try {
-            return new AttributesPutAllMessage(redissonManager.getNodeId(), getId(), map);
+            return new AttributesPutAllMessage(redissonManager.getNodeId(), getId(), map, this.map.getCodec().getMapValueEncoder());
         } catch (IOException e) {
             throw new IllegalStateException(e);
         }
@@ -207,7 +207,7 @@ private void fastPut(String name, Object value) {
         map.fastPut(name, value);
         if (readMode == ReadMode.MEMORY) {
             try {
-                topic.publish(new AttributeUpdateMessage(redissonManager.getNodeId(), getId(), name, value));
+                topic.publish(new AttributeUpdateMessage(redissonManager.getNodeId(), getId(), name, value, this.map.getCodec().getMapValueEncoder()));
             } catch (IOException e) {
                 throw new IllegalStateException(e);
             }

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -187,7 +187,7 @@ protected AttributesPutAllMessage createPutAllMessage(Map<String, Object> newMap
             map.put(entry.getKey(), entry.getValue());
         }
         try {
-            return new AttributesPutAllMessage(redissonManager.getNodeId(), getId(), map);
+            return new AttributesPutAllMessage(redissonManager.getNodeId(), getId(), map, this.map.getCodec().getMapValueEncoder());
         } catch (IOException e) {
             throw new IllegalStateException(e);
         }
@@ -207,7 +207,7 @@ private void fastPut(String name, Object value) {
         map.fastPut(name, value);
         if (readMode == ReadMode.MEMORY) {
             try {
-                topic.publish(new AttributeUpdateMessage(redissonManager.getNodeId(), getId(), name, value));
+                topic.publish(new AttributeUpdateMessage(redissonManager.getNodeId(), getId(), name, value, this.map.getCodec().getMapValueEncoder()));
             } catch (IOException e) {
                 throw new IllegalStateException(e);
             }

File: redisson/src/main/java/org/redisson/eviction/EvictionTask.java
Patch:
@@ -80,7 +80,7 @@ public void run() {
 
                 if (sizeHistory.peekFirst().intValue() == sizeHistory.peekLast()
                         && sizeHistory.peekLast().intValue() == size) {
-                    if (size == keysLimit) {
+                    if (size >= keysLimit) {
                         delay = Math.max(minDelay, delay/4);
                     }
                     if (size == 0) {

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -408,7 +408,7 @@ public interface RedisCommands {
     RedisStrictCommand<Long> XDEL = new RedisStrictCommand<Long>("XDEL");
     RedisStrictCommand<Long> XTRIM = new RedisStrictCommand<Long>("XTRIM");
     RedisCommand<Object> XPENDING = new RedisCommand<Object>("XPENDING", 
-            new ListMultiDecoder(new ObjectListReplayDecoder(), new ObjectListReplayDecoder(ListMultiDecoder.RESET), new PendingResultDecoder()));
+            new ListMultiDecoder(0, new ObjectListReplayDecoder(), new ObjectListReplayDecoder(ListMultiDecoder.RESET), new PendingResultDecoder()));
     RedisCommand<Object> XPENDING_ENTRIES = new RedisCommand<Object>("XPENDING", 
             new PendingEntryDecoder());
     

File: redisson/src/main/java/org/redisson/codec/FstCodec.java
Patch:
@@ -152,7 +152,6 @@ private static FSTConfiguration createConfig(ClassLoader classLoader) {
 
     public FstCodec(FSTConfiguration fstConfiguration) {
         config = fstConfiguration;
-        config.setShareReferences(false);
         config.setStreamCoderFactory(new FSTDefaultStreamCoderFactory(config));
     }
 

File: redisson/src/main/java/org/redisson/command/CommandBatchService.java
Patch:
@@ -287,7 +287,7 @@ protected <R, V> void sendCommand(AsyncDetails<V, R> details, RedisConnection co
                 if (RedisCommands.EXEC.getName().equals(details.getCommand().getName())) {
                     Entry entry = commands.get(details.getSource().getEntry());
 
-                    List<CommandData<?, ?>> list = new LinkedList<CommandData<?, ?>>();
+                    List<CommandData<?, ?>> list = new ArrayList<>();
 
                     if (options.isSkipResult()) {
                         list.add(new CommandData<Void, Void>(new RedissonPromise<Void>(), details.getCodec(), RedisCommands.CLIENT_REPLY, new Object[]{ "OFF" }));
@@ -310,7 +310,7 @@ protected <R, V> void sendCommand(AsyncDetails<V, R> details, RedisConnection co
                     details.setWriteFuture(future);
                 } else {
                     RPromise<Void> main = new RedissonPromise<Void>();
-                    List<CommandData<?, ?>> list = new LinkedList<CommandData<?, ?>>();
+                    List<CommandData<?, ?>> list = new ArrayList<>();
                     list.add(new CommandData<V, R>(details.getAttemptPromise(), details.getCodec(), details.getCommand(), details.getParams()));
                     ChannelFuture future = connection.send(new CommandsData(main, list, true));
                     details.setWriteFuture(future);
@@ -847,7 +847,7 @@ private void checkConnectionFuture(Entry entry, NodeSource source,
         boolean isAtomic = executionMode != ExecutionMode.IN_MEMORY;
         boolean isQueued = executionMode == ExecutionMode.REDIS_READ_ATOMIC || executionMode == ExecutionMode.REDIS_WRITE_ATOMIC;
 
-        List<CommandData<?, ?>> list = new LinkedList<CommandData<?, ?>>();
+        List<CommandData<?, ?>> list = new ArrayList<>(entry.getCommands().size());
         if (source.getRedirect() == Redirect.ASK) {
             RPromise<Void> promise = new RedissonPromise<Void>();
             list.add(new CommandData<Void, Void>(promise, StringCodec.INSTANCE, RedisCommands.ASKING, new Object[] {}));

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -716,7 +716,7 @@ public void run(Timeout t) throws Exception {
 
                 if (details.getConnectionFuture().cancel(false)) {
                     if (details.getException() == null) {
-                        details.setException(new RedisTimeoutException("Unable to get connection! "
+                        details.setException(new RedisTimeoutException("Unable to get connection! Try to increase 'nettyThreads' and 'connection pool' settings or set decodeInExecutor = true and increase 'threads' setting"
                                     + "Node source: " + source
                                     + ", command: " + command + ", command params: " + LogHelper.toString(details.getParams()) 
                                     + " after " + details.getAttempt() + " retry attempts"));

File: redisson/src/main/java/org/redisson/command/CommandBatchService.java
Patch:
@@ -689,7 +689,7 @@ public void run(Timeout t) throws Exception {
 
                 if (connectionFuture.cancel(false)) {
                     if (details.getException() == null) {
-                        details.setException(new RedisTimeoutException("Unable to get connection! "
+                        details.setException(new RedisTimeoutException("Unable to get connection! Try to increase 'nettyThreads' and 'connection pool' settings or set decodeInExecutor = true and increase 'threads' setting"
                                     + "Node source: " + source + " after " + attempts + " retry attempts"));
                     }
                 } else {

File: redisson/src/main/java/org/redisson/connection/balancer/LoadBalancerManager.java
Patch:
@@ -126,7 +126,6 @@ public boolean unfreeze(InetSocketAddress address, FreezeReason freezeReason) {
         return unfreeze(entry, freezeReason);
     }
 
-    
     public boolean unfreeze(ClientConnectionsEntry entry, FreezeReason freezeReason) {
         synchronized (entry) {
             if (!entry.isFreezed()) {
@@ -138,6 +137,9 @@ public boolean unfreeze(ClientConnectionsEntry entry, FreezeReason freezeReason)
                 entry.resetFirstFail();
                 entry.setFreezed(false);
                 entry.setFreezeReason(null);
+                
+                slaveConnectionPool.initConnections(entry);
+                pubSubConnectionPool.initConnections(entry);
                 return true;
             }
         }

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -917,7 +917,7 @@ private <V, R> void checkWriteFuture(final AsyncDetails<V, R> details, final boo
                         popTimeout = Long.valueOf(param.toString()) / 1000;
                         break;
                     }
-                    if (param instanceof String) {
+                    if ("BLOCK".equals(param)) {
                         found = true; 
                     }
                 }

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -437,7 +437,7 @@ public void operationComplete(Future<List<Map<String, String>>> future) throws E
     }
 
     private String createAddress(String host, Object port) {
-        if (host.contains(":")) {
+        if (host.contains(":") && !host.startsWith("[")) {
             host = "[" + host + "]";
         }
         return "redis://" + host + ":" + port;

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -131,7 +131,7 @@ protected void decodeCommand(ChannelHandlerContext ctx, ByteBuf in, QueueCommand
                 }
                 sendNext(ctx, data);
             } catch (Exception e) {
-                log.error("Unable to decode data. reply: {}, channel: {}, command: {}", in.toString(0, in.writerIndex(), CharsetUtil.UTF_8), ctx.channel(), data, e);
+                log.error("Unable to decode data. reply: {}, channel: {}, command: {}", LogHelper.toString(in), ctx.channel(), data, e);
                 cmd.tryFailure(e);
                 sendNext(ctx);
                 throw e;
@@ -152,7 +152,7 @@ protected void decodeCommand(ChannelHandlerContext ctx, ByteBuf in, QueueCommand
                 }
                 sendNext(ctx);
             } catch (Exception e) {
-                log.error("Unable to decode data. channel: {} message: {}", ctx.channel(), in.toString(0, in.writerIndex(), CharsetUtil.UTF_8), e);
+                log.error("Unable to decode data. channel: {} message: {}", ctx.channel(), LogHelper.toString(in), e);
                 sendNext(ctx);
                 throw e;
             }

File: redisson/src/main/java/org/redisson/client/handler/CommandPubSubDecoder.java
Patch:
@@ -37,6 +37,7 @@
 import org.redisson.client.protocol.pubsub.PubSubMessage;
 import org.redisson.client.protocol.pubsub.PubSubPatternMessage;
 import org.redisson.client.protocol.pubsub.PubSubStatusMessage;
+import org.redisson.misc.LogHelper;
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.ChannelHandlerContext;
@@ -78,7 +79,7 @@ protected void decodeCommand(ChannelHandlerContext ctx, ByteBuf in, QueueCommand
                 }
                 sendNext(ctx);
             } catch (Exception e) {
-                log.error("Unable to decode data. channel: {} message: {}", ctx.channel(), in.toString(0, in.writerIndex(), CharsetUtil.UTF_8), e);
+                log.error("Unable to decode data. channel: {} message: {}", ctx.channel(), LogHelper.toString(in), e);
                 sendNext(ctx);
                 throw e;
             }
@@ -94,7 +95,7 @@ protected void decodeCommand(ChannelHandlerContext ctx, ByteBuf in, QueueCommand
                 }
                 sendNext(ctx, data);
             } catch (Exception e) {
-                log.error("Unable to decode data. channel: {} message: {}", ctx.channel(), in.toString(0, in.writerIndex(), CharsetUtil.UTF_8), e);
+                log.error("Unable to decode data. channel: {} message: {}", ctx.channel(), LogHelper.toString(in), e);
                 cmd.tryFailure(e);
                 sendNext(ctx);
                 throw e;

File: redisson/src/main/java/org/redisson/api/RTopic.java
Patch:
@@ -75,7 +75,7 @@ public interface RTopic extends RTopicAsync {
     /**
      * Removes the listener by <code>id</code> for listening this topic
      *
-     * @param listenerId - listener id
+     * @param listenerIds - listener ids
      */
     void removeListener(Integer... listenerIds);
 

File: redisson/src/main/java/org/redisson/api/RTopicAsync.java
Patch:
@@ -59,7 +59,7 @@ public interface RTopicAsync {
     /**
      * Removes the listener by <code>id</code> for listening this topic
      *
-     * @param listenerId - listener id
+     * @param listenerIds - listener ids
      * @return void
      */
     RFuture<Void> removeListenerAsync(Integer... listenerIds);

File: redisson/src/main/java/org/redisson/command/CommandBatchService.java
Patch:
@@ -438,7 +438,7 @@ public void run() {
                     listener.setCounter(connections.size());
                     for (final Map.Entry<MasterSlaveEntry, Entry> entry : commands.entrySet()) {
                         final RPromise<List<Object>> execPromise = new RedissonPromise<List<Object>>();
-                        async(false, new NodeSource(entry.getKey()), connectionManager.getCodec(), RedisCommands.EXEC, 
+                        async(entry.getValue().isReadOnlyMode(), new NodeSource(entry.getKey()), connectionManager.getCodec(), RedisCommands.EXEC, 
                                 new Object[] {}, execPromise, 0, false);
                         execPromise.addListener(new FutureListener<List<Object>>() {
                             @Override

File: redisson/src/main/java/org/redisson/RedissonRateLimiter.java
Patch:
@@ -197,7 +197,7 @@ private <T> RFuture<T> tryAcquireAsync(RedisCommand<T> command, Long value) {
               + "assert(rate ~= false and interval ~= false and type ~= false, 'RateLimiter is not initialized')"
               
               + "local valueName = KEYS[2];"
-              + "if type == 1 then "
+              + "if type == '1' then "
                   + "valueName = KEYS[3];"
               + "end;"
               

File: redisson/src/main/java/org/redisson/client/handler/PingConnectionHandler.java
Patch:
@@ -61,7 +61,7 @@ public void operationComplete(Future<RedisConnection> future) throws Exception {
     }
 
     protected void sendPing(final ChannelHandlerContext ctx) {
-        RedisConnection connection = RedisConnection.getFrom(ctx.channel());
+        final RedisConnection connection = RedisConnection.getFrom(ctx.channel());
         final RFuture<String> future = connection.async(StringCodec.INSTANCE, RedisCommands.PING);
         
         config.getTimer().newTimeout(new TimerTask() {

File: redisson/src/main/java/org/redisson/RedissonBitSet.java
Patch:
@@ -147,7 +147,7 @@ private RFuture<Void> opAsync(String op, String... bitSetNames) {
         params.add(getName());
         params.add(getName());
         params.addAll(Arrays.asList(bitSetNames));
-        return commandExecutor.writeAsync(getName(), codec, RedisCommands.BITOP, params.toArray());
+        return commandExecutor.writeAsync(getName(), StringCodec.INSTANCE, RedisCommands.BITOP, params.toArray());
     }
 
     @Override
@@ -185,7 +185,7 @@ public String toString() {
 
     @Override
     public RFuture<Long> lengthAsync() {
-        return commandExecutor.evalReadAsync(getName(), codec, RedisCommands.EVAL_LONG,
+        return commandExecutor.evalReadAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_LONG,
                 "local fromBit = redis.call('bitpos', KEYS[1], 1, -1);"
                 + "local toBit = 8*(fromBit/8 + 1) - fromBit % 8;"
                         + "for i = toBit, fromBit, -1 do "

File: redisson/src/main/java/org/redisson/command/CommandBatchService.java
Patch:
@@ -172,7 +172,8 @@ public <V, R> void async(boolean readOnlyMode, NodeSource nodeSource,
             if (!isRedisBasedQueue()) {
                 batchParams = params;
             }
-            BatchCommandData<V, R> commandData = new BatchCommandData<V, R>(mainPromise, codec, command, batchParams, index.incrementAndGet());
+            Codec codecToUse = getCodec(codec);
+            BatchCommandData<V, R> commandData = new BatchCommandData<V, R>(mainPromise, codecToUse, command, batchParams, index.incrementAndGet());
             entry.getCommands().add(commandData);
         }
         

File: redisson/src/test/java/org/redisson/RedissonLocalCachedMapTest.java
Patch:
@@ -281,10 +281,10 @@ public void testLocalCacheState() throws InterruptedException {
         RLocalCachedMap<String, String> map = redisson.getLocalCachedMap("test", options);
         map.put("1", "11");
         map.put("2", "22");
-        assertThat(map.cachedKeySet()).containsExactly("1", "2");
+        assertThat(map.cachedKeySet()).containsExactlyInAnyOrder("1", "2");
         assertThat(map.cachedValues()).containsExactlyInAnyOrder("11", "22");
-        assertThat(map.getCachedMap().keySet()).containsExactly("1", "2");
-        assertThat(map.getCachedMap().values()).containsExactly("11", "22");
+        assertThat(map.getCachedMap().keySet()).containsExactlyInAnyOrder("1", "2");
+        assertThat(map.getCachedMap().values()).containsExactlyInAnyOrder("11", "22");
     }
 
     

File: redisson/src/main/java/org/redisson/cache/LocalCacheView.java
Patch:
@@ -185,7 +185,7 @@ public boolean remove(Object o) {
             if (o instanceof Map.Entry) {
                 Map.Entry<?,?> e = (Map.Entry<?,?>) o;
                 CacheKey cacheKey = toCacheKey(e.getKey());
-                return cache.remove(cacheKey, new CacheValue(e.getKey(), e.getValue()));
+                return cache.remove(cacheKey) != null;
             }
             return false;
         }

File: redisson/src/main/java/org/redisson/RedissonBlockingQueue.java
Patch:
@@ -150,7 +150,7 @@ public RFuture<Integer> drainToAsync(Collection<? super V> c) {
 
         return commandExecutor.evalWriteAsync(getName(), codec, new RedisCommand<Object>("EVAL", new ListDrainToDecoder(c)),
               "local vals = redis.call('lrange', KEYS[1], 0, -1); " +
-              "redis.call('ltrim', KEYS[1], -1, 0); " +
+              "redis.call('del', KEYS[1]); " +
               "return vals", Collections.<Object>singletonList(getName()));
     }
 

File: redisson/src/main/java/org/redisson/client/handler/ConnectionWatchdog.java
Patch:
@@ -133,9 +133,9 @@ public void operationComplete(Future<RedisConnection> future) throws Exception {
                                         refresh(connection, channel);
                                         log.debug("{} connected to {}, command: {}", connection, connection.getRedisClient().getAddr(), connection.getCurrentCommand());
                                     } else {
-                                        log.warn("Can't connect " + connection + " to " + connection.getRedisClient().getAddr(), future.cause());
+                                        channel.close();
+                                        reconnect(connection, nextAttempt);
                                     }
-                                    
                                 }
                             });
                             return;

File: redisson/src/main/java/org/redisson/connection/SingleConnectionManager.java
Patch:
@@ -64,6 +64,8 @@ private static MasterSlaveServersConfig create(SingleServerConfig cfg) {
         newconfig.setSubscriptionConnectionMinimumIdleSize(cfg.getSubscriptionConnectionMinimumIdleSize());
         newconfig.setReadMode(ReadMode.MASTER);
         newconfig.setSubscriptionMode(SubscriptionMode.MASTER);
+        newconfig.setKeepAlive(cfg.isKeepAlive());
+        
         return newconfig;
     }
 

File: redisson/src/main/java/org/redisson/command/CommandAsyncExecutor.java
Patch:
@@ -112,5 +112,7 @@ public interface CommandAsyncExecutor {
     <T, R> RFuture<R> readRandomAsync(Codec codec, RedisCommand<T> command, Object ... params);
     
     <T, R> RFuture<R> readRandomAsync(MasterSlaveEntry entry, Codec codec, RedisCommand<T> command, Object... params);
+    
+    <V> RFuture<V> pollFromAnyAsync(String name, Codec codec, RedisCommand<Object> command, long secondsTimeout, String ... queueNames);
 
 }

File: redisson/src/main/java/org/redisson/cache/LRUCacheMap.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.redisson.cache;
 
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
@@ -36,7 +37,7 @@ public class LRUCacheMap<K, V> extends AbstractCacheMap<K, V> {
 
     private final AtomicLong index = new AtomicLong();
     private final List<Collection<CachedValue<K, V>>> queues = 
-                        new CopyOnWriteArrayList<Collection<CachedValue<K, V>>>();
+                        new ArrayList<Collection<CachedValue<K, V>>>();
     
     public LRUCacheMap(int size, long timeToLiveInMillis, long maxIdleInMillis) {
         super(size, timeToLiveInMillis, maxIdleInMillis);
@@ -54,7 +55,7 @@ protected void onValueCreate(CachedValue<K, V> value) {
     }
 
     private Collection<CachedValue<K, V>> getQueue(CachedValue<K, V> value) {
-        return queues.get(value.hashCode() % queues.size());
+        return queues.get(Math.abs(value.hashCode() % queues.size()));
     }
     
     @Override

File: redisson/src/main/java/org/redisson/cache/LRUCacheMap.java
Patch:
@@ -15,13 +15,13 @@
  */
 package org.redisson.cache;
 
-import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.atomic.AtomicLong;
 
 /**
@@ -36,7 +36,7 @@ public class LRUCacheMap<K, V> extends AbstractCacheMap<K, V> {
 
     private final AtomicLong index = new AtomicLong();
     private final List<Collection<CachedValue<K, V>>> queues = 
-            new ArrayList<Collection<CachedValue<K, V>>>(Runtime.getRuntime().availableProcessors()*2);
+                        new CopyOnWriteArrayList<Collection<CachedValue<K, V>>>();
     
     public LRUCacheMap(int size, long timeToLiveInMillis, long maxIdleInMillis) {
         super(size, timeToLiveInMillis, maxIdleInMillis);

File: redisson/src/main/java/org/redisson/transaction/BaseTransactionalMap.java
Patch:
@@ -699,7 +699,7 @@ protected RFuture<Map<K, V>> getAllOperationAsync(Set<K> keys) {
             }
         }
 
-        RFuture<Map<K, V>> future = ((RedissonMap<K, V>)map).getAllOperationAsync(keysToLoad);
+        RFuture<Map<K, V>> future = ((RedissonMap<K, V>)this.map).getAllOperationAsync(keysToLoad);
         future.addListener(new FutureListener<Map<K, V>>() {
             @Override
             public void operationComplete(Future<Map<K, V>> future) throws Exception {

File: redisson/src/main/java/org/redisson/config/Config.java
Patch:
@@ -111,8 +111,7 @@ public Config(Config oldConf) {
 
         if (oldConf.getCodec() == null) {
             // use it by default
-            oldConf.setCodec(new JsonJacksonCodec());
-//            oldConf.setCodec(new FstCodec());
+            oldConf.setCodec(new FstCodec());
         }
 
         setUseScriptCache(oldConf.isUseScriptCache());
@@ -583,6 +582,8 @@ public EventLoopGroup getEventLoopGroup() {
      * <p>  
      * This prevents against infinity locked locks due to Redisson client crush or 
      * any other reason when lock can't be released in proper way.
+     * <p>
+     * Default is 30000 milliseconds
      * 
      * @param lockWatchdogTimeout timeout in milliseconds
      * @return config

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1099,7 +1099,7 @@ public Set<byte[]> zRevRange(byte[] key, long start, long end) {
         return read(key, ByteArrayCodec.INSTANCE, ZREVRANGE, key, start, end);
     }
 
-    private static final RedisCommand<Set<Tuple>> ZREVRANGE_ENTRY = new RedisCommand<Set<Tuple>>("ZRANGE", new ScoredSortedSetReplayDecoder());
+    private static final RedisCommand<Set<Tuple>> ZREVRANGE_ENTRY = new RedisCommand<Set<Tuple>>("ZREVRANGE", new ScoredSortedSetReplayDecoder());
     
     @Override
     public Set<Tuple> zRevRangeWithScores(byte[] key, long start, long end) {

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1128,7 +1128,7 @@ public Set<byte[]> zRevRange(byte[] key, long start, long end) {
         return read(key, ByteArrayCodec.INSTANCE, ZREVRANGE, key, start, end);
     }
 
-    private static final RedisCommand<Set<Tuple>> ZREVRANGE_ENTRY = new RedisCommand<Set<Tuple>>("ZRANGE", new ScoredSortedSetReplayDecoder());
+    private static final RedisCommand<Set<Tuple>> ZREVRANGE_ENTRY = new RedisCommand<Set<Tuple>>("ZREVRANGE", new ScoredSortedSetReplayDecoder());
     
     @Override
     public Set<Tuple> zRevRangeWithScores(byte[] key, long start, long end) {

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1147,7 +1147,7 @@ public Set<byte[]> zRevRange(byte[] key, long start, long end) {
         return read(key, ByteArrayCodec.INSTANCE, ZREVRANGE, key, start, end);
     }
 
-    private static final RedisCommand<Set<Tuple>> ZREVRANGE_ENTRY = new RedisCommand<Set<Tuple>>("ZRANGE", new ScoredSortedSetReplayDecoder());
+    private static final RedisCommand<Set<Tuple>> ZREVRANGE_ENTRY = new RedisCommand<Set<Tuple>>("ZREVRANGE", new ScoredSortedSetReplayDecoder());
     
     @Override
     public Set<Tuple> zRevRangeWithScores(byte[] key, long start, long end) {

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonConnection.java
Patch:
@@ -1162,7 +1162,7 @@ public Set<byte[]> zRevRange(byte[] key, long start, long end) {
         return read(key, ByteArrayCodec.INSTANCE, ZREVRANGE, key, start, end);
     }
 
-    private static final RedisCommand<Set<Tuple>> ZREVRANGE_ENTRY = new RedisCommand<Set<Tuple>>("ZRANGE", new ScoredSortedSetReplayDecoder());
+    private static final RedisCommand<Set<Tuple>> ZREVRANGE_ENTRY = new RedisCommand<Set<Tuple>>("ZREVRANGE", new ScoredSortedSetReplayDecoder());
     
     @Override
     public Set<Tuple> zRevRangeWithScores(byte[] key, long start, long end) {

File: redisson/src/main/java/org/redisson/client/RedisPubSubConnection.java
Patch:
@@ -34,6 +34,7 @@
 import org.redisson.client.protocol.pubsub.PubSubStatusMessage;
 import org.redisson.client.protocol.pubsub.PubSubType;
 import org.redisson.misc.RPromise;
+import org.redisson.misc.RedissonPromise;
 
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
@@ -166,7 +167,8 @@ public void operationComplete(Future<Void> future) throws Exception {
     }
 
     private <T, R> ChannelFuture async(MultiDecoder<Object> messageDecoder, RedisCommand<T> command, Object ... params) {
-        return channel.writeAndFlush(new CommandData<T, R>(null, messageDecoder, null, command, params));
+        RPromise<R> promise = new RedissonPromise<R>();
+        return channel.writeAndFlush(new CommandData<T, R>(promise, messageDecoder, null, command, params));
     }
 
     public Map<ChannelName, Codec> getChannels() {

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -487,6 +487,9 @@ protected Decoder<Object> selectDecoder(CommandData<Object, Object> data, List<O
 
         Decoder<Object> decoder = data.getCommand().getReplayDecoder();
         if (decoder == null) {
+            if (data.getCodec() == null) {
+                return StringCodec.INSTANCE.getValueDecoder();
+            }
             if (data.getCommand().getOutParamType() == ValueType.MAP) {
                 if (parts != null && parts.size() % 2 != 0) {
                     return data.getCodec().getMapValueDecoder();

File: redisson/src/main/java/org/redisson/RedissonBitSet.java
Patch:
@@ -38,7 +38,7 @@
 public class RedissonBitSet extends RedissonExpirable implements RBitSet {
 
     public RedissonBitSet(CommandAsyncExecutor connectionManager, String name) {
-        super(connectionManager, name);
+        super(null, connectionManager, name);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/liveobject/core/RedissonObjectBuilder.java
Patch:
@@ -84,7 +84,9 @@ public RedissonObjectBuilder(RedissonClient redisson) {
 
     public void store(RObject ar, String fieldName, RMap<String, Object> liveMap) {
         Codec codec = ar.getCodec();
-        codecProvider.registerCodec((Class) codec.getClass(), codec);
+        if (codec != null) {
+            codecProvider.registerCodec((Class) codec.getClass(), codec);
+        }
         liveMap.fastPut(fieldName,
                 new RedissonReference(ar.getClass(), ar.getName(), codec));
     }

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -135,7 +135,9 @@ public RMap<String, Object> getMap(String sessionId) {
     }
 
     public RTopic getTopic() {
-        return redisson.getTopic("redisson:tomcat_session_updates:" + getContext().getName());
+        String separator = keyPrefix == null || keyPrefix.isEmpty() ? "" : ":";
+        final String name = keyPrefix + separator + "redisson:tomcat_session_updates:" + getContext().getName();
+        return redisson.getTopic(name);
     }
     
     @Override

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -135,7 +135,9 @@ public RMap<String, Object> getMap(String sessionId) {
     }
 
     public RTopic getTopic() {
-        return redisson.getTopic("redisson:tomcat_session_updates:" + getContext().getName());
+        String separator = keyPrefix == null || keyPrefix.isEmpty() ? "" : ":";
+        final String name = keyPrefix + separator + "redisson:tomcat_session_updates:" + getContext().getName();
+        return redisson.getTopic(name);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/connection/DNSMonitor.java
Patch:
@@ -31,6 +31,7 @@
 import org.slf4j.LoggerFactory;
 
 import io.netty.resolver.AddressResolver;
+import io.netty.resolver.AddressResolverGroup;
 import io.netty.resolver.dns.DnsAddressResolverGroup;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.FutureListener;
@@ -54,7 +55,7 @@ public class DNSMonitor {
     private ScheduledFuture<?> dnsMonitorFuture;
     private long dnsMonitoringInterval;
 
-    public DNSMonitor(ConnectionManager connectionManager, RedisClient masterHost, Collection<URI> slaveHosts, long dnsMonitoringInterval, DnsAddressResolverGroup resolverGroup) {
+    public DNSMonitor(ConnectionManager connectionManager, RedisClient masterHost, Collection<URI> slaveHosts, long dnsMonitoringInterval, AddressResolverGroup<InetSocketAddress> resolverGroup) {
         this.resolver = resolverGroup.getResolver(connectionManager.getGroup().next());
         
         masterHost.resolveAddr().syncUninterruptibly();

File: redisson/src/main/java/org/redisson/misc/URIBuilder.java
Patch:
@@ -64,6 +64,8 @@ private static void patchUriField(Long maskValue, String fieldName)
             
             field.setAccessible(true);
             field.setLong(null, maskValue);
+        } catch (NoSuchFieldException e) {
+            // skip for Android platform
         } catch (Exception e) {
             throw new IOException(e);
         }

File: redisson/src/test/java/org/redisson/RedissonBucketTest.java
Patch:
@@ -21,7 +21,7 @@ public class RedissonBucketTest extends BaseTest {
     public void testSizeInMemory() {
         RBucket<Integer> al = redisson.getBucket("test");
         al.set(1234);
-        assertThat(al.sizeInMemory()).isEqualTo(49);
+        assertThat(al.sizeInMemory()).isEqualTo(55);
     }
     
     @Test

File: redisson/src/test/java/org/redisson/RedissonFairLockTest.java
Patch:
@@ -19,6 +19,7 @@
 import org.junit.Test;
 import org.redisson.api.RLock;
 import org.redisson.api.RScript;
+import org.redisson.client.codec.LongCodec;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -96,7 +97,7 @@ public void testTimeoutDrift() throws Exception {
             Assert.fail("Lock should have been unlocked by now");
         }
         //check the timeout scores - they should all be within a reasonable amount of time from now
-        List<Long> queue = redisson.getScript().eval(RScript.Mode.READ_ONLY,
+        List<Long> queue = redisson.getScript(LongCodec.INSTANCE).eval(RScript.Mode.READ_ONLY,
                 "local result = {}; " +
                         "local timeouts = redis.call('zrange', KEYS[1], 0, 99, 'WITHSCORES'); " +
                         "for i=1,#timeouts,2 do " +

File: redisson/src/test/java/org/redisson/executor/CallableTask.java
Patch:
@@ -1,8 +1,9 @@
 package org.redisson.executor;
 
+import java.io.Serializable;
 import java.util.concurrent.Callable;
 
-public class CallableTask implements Callable<String> {
+public class CallableTask implements Callable<String>, Serializable {
 
     public static final String RESULT = "callable";
     

File: redisson/src/test/java/org/redisson/executor/DelayedTask.java
Patch:
@@ -1,12 +1,13 @@
 package org.redisson.executor;
 
+import java.io.Serializable;
 import java.util.concurrent.Callable;
 
 import org.redisson.api.RAtomicLong;
 import org.redisson.api.RedissonClient;
 import org.redisson.api.annotation.RInject;
 
-public class DelayedTask implements Callable<Object> {
+public class DelayedTask implements Callable<Object>, Serializable {
 
     @RInject
     private RedissonClient redisson;

File: redisson/src/test/java/org/redisson/executor/IncrementCallableTask.java
Patch:
@@ -1,11 +1,12 @@
 package org.redisson.executor;
 
+import java.io.Serializable;
 import java.util.concurrent.Callable;
 
 import org.redisson.api.RedissonClient;
 import org.redisson.api.annotation.RInject;
 
-public class IncrementCallableTask implements Callable<String> {
+public class IncrementCallableTask implements Callable<String>, Serializable {
 
     private String counterName;
     

File: redisson/src/test/java/org/redisson/executor/IncrementRunnableTask.java
Patch:
@@ -1,9 +1,11 @@
 package org.redisson.executor;
 
+import java.io.Serializable;
+
 import org.redisson.api.RedissonClient;
 import org.redisson.api.annotation.RInject;
 
-public class IncrementRunnableTask implements Runnable {
+public class IncrementRunnableTask implements Runnable, Serializable {
 
     private String counterName;
     

File: redisson/src/test/java/org/redisson/executor/ParameterizedTask.java
Patch:
@@ -1,8 +1,9 @@
 package org.redisson.executor;
 
+import java.io.Serializable;
 import java.util.concurrent.Callable;
 
-public class ParameterizedTask implements Callable<String> {
+public class ParameterizedTask implements Callable<String>, Serializable {
 
     private String param;
     

File: redisson/src/test/java/org/redisson/executor/RunnableRedissonTask.java
Patch:
@@ -1,9 +1,11 @@
 package org.redisson.executor;
 
+import java.io.Serializable;
+
 import org.redisson.api.RedissonClient;
 import org.redisson.api.annotation.RInject;
 
-public class RunnableRedissonTask implements Runnable {
+public class RunnableRedissonTask implements Runnable, Serializable {
 
     @RInject
     private RedissonClient redissonClient;

File: redisson/src/test/java/org/redisson/executor/RunnableTask.java
Patch:
@@ -1,6 +1,8 @@
 package org.redisson.executor;
 
-public class RunnableTask implements Runnable {
+import java.io.Serializable;
+
+public class RunnableTask implements Runnable, Serializable {
 
     @Override
     public void run() {

File: redisson/src/test/java/org/redisson/executor/RunnableTask2.java
Patch:
@@ -2,7 +2,7 @@
 
 import java.io.Serializable;
 
-public class RunnableTask2 implements Runnable {
+public class RunnableTask2 implements Runnable, Serializable {
 
     private static final long serialVersionUID = 2105094575950438867L;
     

File: redisson/src/test/java/org/redisson/executor/ScheduledLongRunnableTask.java
Patch:
@@ -1,9 +1,11 @@
 package org.redisson.executor;
 
+import java.io.Serializable;
+
 import org.redisson.api.RedissonClient;
 import org.redisson.api.annotation.RInject;
 
-public class ScheduledLongRunnableTask implements Runnable {
+public class ScheduledLongRunnableTask implements Runnable, Serializable {
 
     @RInject
     private RedissonClient redisson;

File: redisson/src/main/java/org/redisson/spring/session/RedissonSessionRepository.java
Patch:
@@ -253,7 +253,7 @@ public void onMessage(CharSequence pattern, CharSequence channel, String body) {
             }
             
             String id = body.split(":")[1];
-            RedissonSession session = new RedissonSession(id);
+            RedissonSession session = new RedissonSession(keyPrefix, id);
             if (session.load()) {
                 session.clearPrincipal();
                 publishEvent(new SessionDeletedEvent(this, session));
@@ -266,7 +266,7 @@ public void onMessage(CharSequence pattern, CharSequence channel, String body) {
             }
 
             String id = body.split(":")[1];
-            RedissonSession session = new RedissonSession(id);
+            RedissonSession session = new RedissonSession(keyPrefix, id);
             if (session.load()) {
                 session.clearPrincipal();
                 publishEvent(new SessionExpiredEvent(this, session));
@@ -304,7 +304,7 @@ public void save(RedissonSession session) {
 
     @Override
     public RedissonSession getSession(String id) {
-        RedissonSession session = new RedissonSession(id);
+        RedissonSession session = new RedissonSession(keyPrefix, id);
         if (!session.load() || session.isExpired()) {
             return null;
         }

File: redisson/src/main/java/org/redisson/api/RMap.java
Patch:
@@ -129,7 +129,7 @@ public interface RMap<K, V> extends ConcurrentMap<K, V>, RExpirable, RMapAsync<K
     RSemaphore getSemaphore(K key);
     
     /**
-     * Returns <code>RReadWriteLock</code> instance associated with key
+     * Returns <code>RLock</code> instance associated with key
      * 
      * @param key - map key
      * @return fairlock

File: redisson/src/main/java/org/redisson/api/RMapReactive.java
Patch:
@@ -454,7 +454,7 @@ public interface RMapReactive<K, V> extends RExpirableReactive {
     RSemaphoreReactive getSemaphore(K key);
     
     /**
-     * Returns <code>RReadWriteLock</code> instance associated with key
+     * Returns <code>RLock</code> instance associated with key
      * 
      * @param key - map key
      * @return fairLock

File: redisson/src/main/java/org/redisson/api/RMapRx.java
Patch:
@@ -455,7 +455,7 @@ public interface RMapRx<K, V> extends RExpirableRx {
     RSemaphoreRx getSemaphore(K key);
     
     /**
-     * Returns <code>RReadWriteLock</code> instance associated with key
+     * Returns <code>RLock</code> instance associated with key
      * 
      * @param key - map key
      * @return fairLock

File: redisson/src/main/java/org/redisson/api/RSet.java
Patch:
@@ -54,7 +54,7 @@ public interface RSet<V> extends Set<V>, RExpirable, RSetAsync<V>, RSortable<Set
     RSemaphore getSemaphore(V value);
     
     /**
-     * Returns <code>RReadWriteLock</code> instance associated with <code>value</code>
+     * Returns <code>RLock</code> instance associated with <code>value</code>
      * 
      * @param value - set value
      * @return RLock object

File: redisson/src/main/java/org/redisson/api/RSetCache.java
Patch:
@@ -65,7 +65,7 @@ public interface RSetCache<V> extends Set<V>, RExpirable, RSetCacheAsync<V>, RDe
     RSemaphore getSemaphore(V value);
     
     /**
-     * Returns <code>RReadWriteLock</code> instance associated with <code>value</code>
+     * Returns <code>RLock</code> instance associated with <code>value</code>
      * 
      * @param value - set value
      * @return RLock object

File: redisson/src/main/java/org/redisson/api/RMapReactive.java
Patch:
@@ -441,23 +441,23 @@ public interface RMapReactive<K, V> extends RExpirableReactive {
      * Returns <code>RPermitExpirableSemaphore</code> instance associated with key
      * 
      * @param key - map key
-     * @return readWriteLock
+     * @return permitExpirableSemaphore
      */
     RPermitExpirableSemaphoreReactive getPermitExpirableSemaphore(K key);
 
     /**
      * Returns <code>RSemaphore</code> instance associated with key
      * 
      * @param key - map key
-     * @return readWriteLock
+     * @return semaphore
      */
     RSemaphoreReactive getSemaphore(K key);
     
     /**
      * Returns <code>RReadWriteLock</code> instance associated with key
      * 
      * @param key - map key
-     * @return readWriteLock
+     * @return fairLock
      */
     RLockReactive getFairLock(K key);
     

File: redisson/src/main/java/org/redisson/connection/pool/ConnectionPool.java
Patch:
@@ -452,7 +452,7 @@ private void ping(RedisConnection c, final FutureListener<String> pingListener)
     }
 
     public void returnConnection(ClientConnectionsEntry entry, T connection) {
-        if (entry.isFreezed() && !entry.isMasterForRead()) {
+        if (entry.isFreezed() && entry.getFreezeReason() != FreezeReason.SYSTEM) {
             connection.closeAsync();
             entry.getAllConnections().remove(connection);
         } else {

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -754,7 +754,7 @@ public void run(Timeout t) throws Exception {
                 int count = details.getAttempt() + 1;
                 if (log.isDebugEnabled()) {
                     log.debug("attempt {} for command {} and params {}",
-                            count, details.getCommand(), Arrays.toString(details.getParams()));
+                            count, details.getCommand(), LogHelper.toString(details.getParams()));
                 }
                 details.removeMainPromiseListener();
                 async(details.isReadOnlyMode(), details.getSource(), details.getCodec(), details.getCommand(), details.getParams(), details.getMainPromise(), count, ignoreRedirect, connFuture);
@@ -973,7 +973,7 @@ public void operationComplete(Future<R> future) throws Exception {
 
                 if (log.isDebugEnabled()) {
                     log.debug("connection released for command {} and params {} from slot {} using connection {}",
-                            details.getCommand(), Arrays.toString(details.getParams()), details.getSource(), connection);
+                            details.getCommand(), LogHelper.toString(details.getParams()), details.getSource(), connection);
                 }
             }
         });
@@ -1207,7 +1207,7 @@ protected <R, V> void sendCommand(final AsyncDetails<V, R> details, final RedisC
         } else {
             if (log.isDebugEnabled()) {
                 log.debug("acquired connection for command {} and params {} from slot {} using node {}... {}",
-                        details.getCommand(), Arrays.toString(details.getParams()), details.getSource(), connection.getRedisClient().getAddr(), connection);
+                        details.getCommand(), LogHelper.toString(details.getParams()), details.getSource(), connection.getRedisClient().getAddr(), connection);
             }
             ChannelFuture future = connection.send(new CommandData<V, R>(details.getAttemptPromise(), details.getCodec(), details.getCommand(), details.getParams()));
             details.setWriteFuture(future);

File: redisson/src/main/java/org/redisson/command/CommandBatchService.java
Patch:
@@ -16,7 +16,6 @@
 package org.redisson.command;
 
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.Deque;
 import java.util.Iterator;
@@ -55,6 +54,7 @@
 import org.redisson.connection.NodeSource;
 import org.redisson.connection.NodeSource.Redirect;
 import org.redisson.misc.CountableListener;
+import org.redisson.misc.LogHelper;
 import org.redisson.misc.RPromise;
 import org.redisson.misc.RedissonPromise;
 import org.redisson.pubsub.AsyncSemaphore;
@@ -281,7 +281,7 @@ protected <R, V> void sendCommand(AsyncDetails<V, R> details, RedisConnection co
         } else {
             if (log.isDebugEnabled()) {
                 log.debug("acquired connection for command {} and params {} from slot {} using node {}... {}",
-                        details.getCommand(), Arrays.toString(details.getParams()), details.getSource(), connection.getRedisClient().getAddr(), connection);
+                        details.getCommand(), LogHelper.toString(details.getParams()), details.getSource(), connection.getRedisClient().getAddr(), connection);
             }
             
             if (connectionEntry.isFirstCommand()) {

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -78,6 +78,9 @@ public SentinelConnectionManager(SentinelServersConfig cfg, Config config, UUID
         if (cfg.getMasterName() == null) {
             throw new IllegalArgumentException("masterName parameter is not defined!");
         }
+        if (cfg.getSentinelAddresses().isEmpty()) {
+            throw new IllegalArgumentException("At least one sentinel node should be defined!");
+        }
 
         this.config = create(cfg);
         initTimer(this.config);

File: redisson-spring-data/redisson-spring-data-21/src/main/java/org/redisson/spring/data/connection/RedissonConnectionFactory.java
Patch:
@@ -83,7 +83,6 @@ public DataAccessException translateExceptionIfPossible(RuntimeException ex) {
 
     @Override
     public void destroy() throws Exception {
-        redisson.shutdown();
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-16/src/main/java/org/redisson/spring/data/connection/RedissonConnectionFactory.java
Patch:
@@ -82,7 +82,6 @@ public DataAccessException translateExceptionIfPossible(RuntimeException ex) {
 
     @Override
     public void destroy() throws Exception {
-        redisson.shutdown();
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-17/src/main/java/org/redisson/spring/data/connection/RedissonConnectionFactory.java
Patch:
@@ -83,7 +83,6 @@ public DataAccessException translateExceptionIfPossible(RuntimeException ex) {
 
     @Override
     public void destroy() throws Exception {
-        redisson.shutdown();
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-18/src/main/java/org/redisson/spring/data/connection/RedissonConnectionFactory.java
Patch:
@@ -83,7 +83,6 @@ public DataAccessException translateExceptionIfPossible(RuntimeException ex) {
 
     @Override
     public void destroy() throws Exception {
-        redisson.shutdown();
     }
 
     @Override

File: redisson-spring-data/redisson-spring-data-20/src/main/java/org/redisson/spring/data/connection/RedissonConnectionFactory.java
Patch:
@@ -83,7 +83,6 @@ public DataAccessException translateExceptionIfPossible(RuntimeException ex) {
 
     @Override
     public void destroy() throws Exception {
-        redisson.shutdown();
     }
 
     @Override

File: redisson/src/main/java/org/redisson/client/codec/JsonJacksonMapCodec.java
Patch:
@@ -33,7 +33,7 @@
 import io.netty.buffer.ByteBufOutputStream;
 
 /**
- * Type based codec for RMap objects
+ * @deprecated Use org.redisson.codec.TypedJsonJacksonCodec instead
  * 
  * @author Nikita Koksharov
  * @author Andrej Kazakov

File: redisson/src/main/java/org/redisson/connection/ClientConnectionsEntry.java
Patch:
@@ -76,7 +76,7 @@ public ClientConnectionsEntry(RedisClient client, int poolMinSize, int poolMaxSi
     }
     
     public boolean isMasterForRead() {
-        return getFreezeReason() == FreezeReason.SYSTEM && getConfig().getReadMode() == ReadMode.MASTER_SLAVE;
+        return getFreezeReason() == FreezeReason.SYSTEM && getConfig().getReadMode() == ReadMode.MASTER_SLAVE && getNodeType() == NodeType.MASTER;
     }
     
     public void setNodeType(NodeType nodeType) {

File: redisson/src/main/java/org/redisson/config/Config.java
Patch:
@@ -28,6 +28,7 @@
 import org.redisson.codec.ReferenceCodecProvider;
 import org.redisson.connection.ConnectionManager;
 import org.redisson.connection.DnsAddressResolverGroupFactory;
+import org.redisson.connection.MultiDnsAddressResolverGroupFactory;
 import org.redisson.connection.AddressResolverGroupFactory;
 import org.redisson.connection.ReplicatedConnectionManager;
 import org.redisson.misc.URIBuilder;
@@ -94,7 +95,7 @@ public class Config {
     /**
      * AddressResolverGroupFactory switch between default and round robin
      */
-    private AddressResolverGroupFactory addressResolverGroupFactory = new DnsAddressResolverGroupFactory();
+    private AddressResolverGroupFactory addressResolverGroupFactory = new MultiDnsAddressResolverGroupFactory();
 
     public Config() {
     }

File: redisson-hibernate/redisson-hibernate-4/src/main/java/org/redisson/hibernate/region/BaseRegion.java
Patch:
@@ -93,7 +93,6 @@ public String getName() {
     @Override
     public void destroy() throws CacheException {
         try {
-            mapCache.clear();
             mapCache.destroy();
         } catch (Exception e) {
             throw new CacheException(e);

File: redisson-hibernate/redisson-hibernate-5/src/main/java/org/redisson/hibernate/region/BaseRegion.java
Patch:
@@ -94,7 +94,6 @@ public String getName() {
     @Override
     public void destroy() throws CacheException {
         try {
-            mapCache.clear();
             mapCache.destroy();
         } catch (Exception e) {
             throw new CacheException(e);

File: redisson-hibernate/redisson-hibernate-52/src/main/java/org/redisson/hibernate/region/BaseRegion.java
Patch:
@@ -25,7 +25,6 @@
 import org.hibernate.cache.spi.GeneralDataRegion;
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.cache.spi.TransactionalDataRegion;
-import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.SharedSessionContractImplementor;
 import org.redisson.api.RMapCache;
 import org.redisson.hibernate.RedissonRegionFactory;
@@ -95,7 +94,6 @@ public String getName() {
     @Override
     public void destroy() throws CacheException {
         try {
-            mapCache.clear();
             mapCache.destroy();
         } catch (Exception e) {
             throw new CacheException(e);

File: redisson/src/main/java/org/redisson/client/RedisRedirectException.java
Patch:
@@ -33,7 +33,7 @@ public class RedisRedirectException extends RedisException {
 
     public RedisRedirectException(int slot, String url) {
         this.slot = slot;
-        this.url = URIBuilder.create("//" + url);
+        this.url = URIBuilder.create("redis://" + url);
     }
 
     public int getSlot() {

File: redisson/src/main/java/org/redisson/api/RBlockingQueueRx.java
Patch:
@@ -155,10 +155,10 @@ public interface RBlockingQueueRx<V> extends RQueueRx<V> {
     Flowable<Void> put(V e);
 
     /**
-     * Retrieves and removes stream of elements from the head of this queue.
-     * Waits for an element become available.
+     * Retrieves and removes continues stream of elements from the head of this queue.
+     * Waits for next element become available.
      * 
-     * @return stream of messages
+     * @return stream of elements
      */
     Flowable<V> takeElements();
 

File: redisson/src/main/java/org/redisson/api/RTopicRx.java
Patch:
@@ -77,6 +77,7 @@ public interface RTopicRx {
     /**
      * Returns stream of messages.
      * 
+     * @param <M> - type of message
      * @param type - type of message to listen
      * @return stream of messages
      */

File: redisson/src/main/java/org/redisson/client/protocol/CommandData.java
Patch:
@@ -97,9 +97,8 @@ public List<CommandData<Object, Object>> getPubSubOperations() {
     }
     
     public boolean isBlockingCommand() {
-        return RedisCommands.BLOCKING_COMMANDS.contains(command.getName()) 
-                || RedisCommands.XREAD_BLOCKING_SINGLE == command
-                    || RedisCommands.XREAD_BLOCKING == command;
+        return RedisCommands.BLOCKING_COMMAND_NAMES.contains(command.getName()) 
+                || RedisCommands.BLOCKING_COMMANDS.contains(command);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonTopic.java
Patch:
@@ -156,7 +156,7 @@ public void removeAllListeners() {
         }
 
         if (entry.removeAllListeners(channelName)) {
-            subscribeService.unsubscribe(channelName, semaphore);
+            subscribeService.unsubscribe(channelName, semaphore).syncUninterruptibly();
         } else {
             semaphore.release();
         }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/PendingResultDecoder.java
Patch:
@@ -45,7 +45,7 @@ public Object decode(List<Object> parts, State state) {
         for (List<String> mapping : customerParts) {
             consumerNames.put(mapping.get(0), Long.valueOf(mapping.get(1)));
         }
-        return new PendingResult((long)parts.get(0), convertor.convert(parts.get(1)), convertor.convert(parts.get(2)), consumerNames);
+        return new PendingResult((Long)parts.get(0), convertor.convert(parts.get(1)), convertor.convert(parts.get(2)), consumerNames);
     }
 
 }

File: redisson/src/main/java/org/redisson/cache/CachedValueSoftReference.java
Patch:
@@ -24,7 +24,7 @@
  *
  * @param <V> value type
  */
-public class CachedValueSoftReference<V> extends SoftReference<V> {
+public class CachedValueSoftReference<V> extends SoftReference<V> implements CachedValueReference {
 
     private final CachedValue<?, ?> owner;
     
@@ -33,6 +33,7 @@ public CachedValueSoftReference(CachedValue<?, ?> owner, V referent, ReferenceQu
         this.owner = owner;
     }
     
+    @Override
     public CachedValue<?, ?> getOwner() {
         return owner;
     }

File: redisson/src/main/java/org/redisson/cache/CachedValueWeakReference.java
Patch:
@@ -24,7 +24,7 @@
  *
  * @param <V> value type
  */
-public class CachedValueWeakReference<V> extends WeakReference<V> {
+public class CachedValueWeakReference<V> extends WeakReference<V> implements CachedValueReference {
 
     private final CachedValue<?, ?> owner;
     
@@ -33,6 +33,7 @@ public CachedValueWeakReference(CachedValue<?, ?> owner, V referent, ReferenceQu
         this.owner = owner;
     }
     
+    @Override
     public CachedValue<?, ?> getOwner() {
         return owner;
     }

File: redisson/src/main/java/org/redisson/rx/RedissonTopicRx.java
Patch:
@@ -61,6 +61,7 @@ public void onMessage(CharSequence channel, M msg) {
                     @Override
                     public void operationComplete(Future<Integer> future) throws Exception {
                         if (!future.isSuccess()) {
+                            p.onError(future.cause());
                             return;
                         }
                         

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -151,7 +151,7 @@ public interface RedisCommands {
 
     RedisCommand<ListScanResult<String>> SCAN = new RedisCommand<ListScanResult<String>>("SCAN", new ListMultiDecoder(new LongMultiDecoder(), new ObjectListReplayDecoder<String>(), new ListScanResultReplayDecoder()));
     RedisStrictCommand<String> RANDOM_KEY = new RedisStrictCommand<String>("RANDOMKEY");
-    RedisCommand<String> PING = new RedisCommand<String>("PING", new ListObjectDecoder<String>(0));
+    RedisCommand<String> PING = new RedisCommand<String>("PING");
     RedisStrictCommand<Boolean> PING_BOOL = new RedisStrictCommand<Boolean>("PING", new BooleanNotNullReplayConvertor());
 
     RedisStrictCommand<Void> SHUTDOWN = new RedisStrictCommand<Void>("SHUTDOWN", new VoidReplayConvertor());

File: redisson/src/main/java/org/redisson/RedissonPatternTopic.java
Patch:
@@ -147,8 +147,7 @@ public void removeAllListeners() {
             return;
         }
 
-        entry.removeAllListeners(channelName);
-        if (!entry.hasListeners(channelName)) {
+        if (entry.removeAllListeners(channelName)) {
             subscribeService.punsubscribe(channelName, semaphore);
         } else {
             semaphore.release();

File: redisson/src/main/java/org/redisson/pubsub/PubSubConnectionEntry.java
Patch:
@@ -100,7 +100,7 @@ public boolean removeAllListeners(ChannelName channelName) {
         for (RedisPubSubListener<?> listener : listeners) {
             removeListener(channelName, listener);
         }
-        return !listeners.isEmpty();
+        return listeners.isEmpty();
     }
     
     // TODO optimize

File: redisson/src/main/java/org/redisson/reactive/CommandReactiveBatchService.java
Patch:
@@ -34,6 +34,7 @@
 import org.redisson.misc.RPromise;
 
 import reactor.core.publisher.Flux;
+import reactor.core.publisher.Mono;
 
 /**
  * 
@@ -51,8 +52,8 @@ public CommandReactiveBatchService(ConnectionManager connectionManager) {
     }
 
     @Override
-    public <R> Publisher<R> reactive(Supplier<RFuture<R>> supplier) {
-        Publisher<R> publisher = super.reactive(supplier);
+    public <R> Mono<R> reactive(Supplier<RFuture<R>> supplier) {
+        Mono<R> publisher = super.reactive(supplier);
         publishers.add(publisher);
         return publisher;
     }

File: redisson/src/main/java/org/redisson/reactive/CommandReactiveExecutor.java
Patch:
@@ -15,20 +15,20 @@
  */
 package org.redisson.reactive;
 
-import java.util.List;
 import java.util.function.Supplier;
 
-import org.reactivestreams.Publisher;
 import org.redisson.api.RFuture;
 import org.redisson.command.CommandAsyncExecutor;
 
+import reactor.core.publisher.Mono;
+
 /**
  *
  * @author Nikita Koksharov
  *
  */
 public interface CommandReactiveExecutor extends CommandAsyncExecutor {
 
-    <R> Publisher<R> reactive(Supplier<RFuture<R>> supplier);
+    <R> Mono<R> reactive(Supplier<RFuture<R>> supplier);
 
 }

File: redisson/src/main/java/org/redisson/reactive/RedissonBatchReactive.java
Patch:
@@ -18,7 +18,6 @@
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
 
-import org.reactivestreams.Publisher;
 import org.redisson.RedissonAtomicDouble;
 import org.redisson.RedissonAtomicLong;
 import org.redisson.RedissonBitSet;
@@ -76,6 +75,8 @@
 import org.redisson.connection.ConnectionManager;
 import org.redisson.eviction.EvictionScheduler;
 
+import reactor.core.publisher.Mono;
+
 /**
  * 
  * @author Nikita Koksharov
@@ -285,7 +286,7 @@ public RKeysReactive getKeys() {
     }
 
     @Override
-    public Publisher<BatchResult<?>> execute() {
+    public Mono<BatchResult<?>> execute() {
         return commandExecutor.reactive(new Supplier<RFuture<BatchResult<?>>>() {
             @Override
             public RFuture<BatchResult<?>> get() {

File: redisson/src/main/java/org/redisson/Redisson.java
Patch:
@@ -171,10 +171,10 @@ public static RedissonClient create(Config config) {
      *
      * @return Redisson instance
      */
-    public static RedissonReactiveClient createRx() {
+    public static RedissonRxClient createRx() {
         Config config = new Config();
         config.useSingleServer().setAddress("redis://127.0.0.1:6379");
-        return createReactive(config);
+        return createRx(config);
     }
 
     /**

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -391,6 +391,7 @@ protected MasterSlaveServersConfig create(BaseMasterSlaveServersConfig<?> cfg) {
         c.setReadMode(cfg.getReadMode());
         c.setSubscriptionMode(cfg.getSubscriptionMode());
         c.setDnsMonitoringInterval(cfg.getDnsMonitoringInterval());
+        c.setKeepAlive(cfg.isKeepAlive());
 
         return c;
     }

File: redisson/src/test/java/org/redisson/RedisVersion.java
Patch:
@@ -16,7 +16,7 @@ public class RedisVersion implements Comparable<RedisVersion>{
 
     public RedisVersion(String fullVersion) {
         this.fullVersion = fullVersion;
-        Matcher matcher = Pattern.compile("^([\\d]+)\\.([\\d]+)\\.([\\d]+)$").matcher(fullVersion);
+        Matcher matcher = Pattern.compile("^([\\d]+)\\.([\\d]+)\\.([\\d]+)").matcher(fullVersion);
         matcher.find();
         majorVersion = Integer.parseInt(matcher.group(1));
         minorVersion = Integer.parseInt(matcher.group(2));

File: redisson/src/test/java/org/redisson/RedissonBatchTest.java
Patch:
@@ -150,7 +150,7 @@ public void testConnectionLeakAfterError() throws InterruptedException {
         
         BatchOptions batchOptions = BatchOptions.defaults().executionMode(ExecutionMode.REDIS_WRITE_ATOMIC);
         RBatch batch = redisson.createBatch(batchOptions);
-        for (int i = 0; i < 200000; i++) {
+        for (int i = 0; i < 300000; i++) {
             batch.getBucket("test").setAsync(123);
         }
         

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -84,7 +84,7 @@ protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) t
         QueueCommand data = ctx.channel().attr(CommandsQueue.CURRENT_COMMAND).get();
 
         if (log.isTraceEnabled()) {
-            log.trace("channel: {} message: {}", ctx.channel(), in.toString(0, in.writerIndex(), CharsetUtil.UTF_8));
+            log.trace("reply: {}, channel: {}, command: {}", in.toString(0, in.writerIndex(), CharsetUtil.UTF_8), ctx.channel(), data);
         }
         if (state() == null) {
             boolean makeCheckpoint = data != null;
@@ -129,7 +129,7 @@ protected void decodeCommand(ChannelHandlerContext ctx, ByteBuf in, QueueCommand
                 }
                 sendNext(ctx, data);
             } catch (Exception e) {
-                log.error("Unable to decode data. channel: {} message: {}", ctx.channel(), in.toString(0, in.writerIndex(), CharsetUtil.UTF_8), e);
+                log.error("Unable to decode data. reply: {}, channel: {}, command: {}", in.toString(0, in.writerIndex(), CharsetUtil.UTF_8), ctx.channel(), data, e);
                 cmd.tryFailure(e);
                 sendNext(ctx);
                 throw e;
@@ -195,7 +195,7 @@ protected void decodeFromCheckpoint(ChannelHandlerContext ctx, ByteBuf in, Queue
                     }
                     decodeList(in, cmd, null, ctx.channel(), 0, firstLevel.getParts(), false);
                 } else {
-                    if (in.isReadable()) {
+                    while (firstLevel.getSize() == firstLevel.getParts().size() && in.isReadable()) {
                         decode(in, cmd, firstLevel.getParts(), ctx.channel(), false);
                     }
                     decodeList(in, cmd, null, ctx.channel(), firstLevel.getSize(), firstLevel.getParts(), false);

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -195,8 +195,10 @@ protected void decodeFromCheckpoint(ChannelHandlerContext ctx, ByteBuf in, Queue
                     }
                     decodeList(in, cmd, null, ctx.channel(), 0, firstLevel.getParts(), false);
                 } else {
+                    if (in.isReadable()) {
+                        decode(in, cmd, firstLevel.getParts(), ctx.channel(), false);
+                    }
                     decodeList(in, cmd, null, ctx.channel(), firstLevel.getSize(), firstLevel.getParts(), false);
-                    decode(in, cmd, null, ctx.channel(), false);
                 }
             }
         }

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -155,7 +155,7 @@ protected void decodeFromCheckpoint(ChannelHandlerContext ctx, ByteBuf in, Queue
             CommandData<Object, Object> cmd) throws IOException {
         if (state().getLevels().size() == 2) {
             StateLevel secondLevel = state().getLevels().get(1);
-            
+
             if (secondLevel.getParts().isEmpty()) {
                 state().getLevels().remove(1);
             }
@@ -189,13 +189,14 @@ protected void decodeFromCheckpoint(ChannelHandlerContext ctx, ByteBuf in, Queue
                     }
                     firstLevel.setLastList(null);
                     firstLevel.setLastListSize(0);
-                    
+
                     while (in.isReadable() && firstLevel.getParts().size() < firstLevel.getSize()) {
                         decode(in, cmd, firstLevel.getParts(), ctx.channel(), false);
                     }
                     decodeList(in, cmd, null, ctx.channel(), 0, firstLevel.getParts(), false);
                 } else {
                     decodeList(in, cmd, null, ctx.channel(), firstLevel.getSize(), firstLevel.getParts(), false);
+                    decode(in, cmd, null, ctx.channel(), false);
                 }
             }
         }

File: redisson/src/main/java/org/redisson/client/handler/CommandsQueue.java
Patch:
@@ -83,7 +83,7 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
                     new WriteRedisConnectionException("Channel has been closed! Can't write command: " 
                                 + LogHelper.toString(command.getCommand()) + " to channel: " + ctx.channel()));
             
-            if (command.getChannelPromise().isSuccess()) {
+            if (command.getChannelPromise().isSuccess() && !command.getCommand().isBlockingCommand()) {
                 command.getCommand().tryFailure(new RedisConnectionClosedException("Command " 
                                 + LogHelper.toString(command.getCommand()) + " succesfully sent, but channel " + ctx.channel() + " has been closed!"));
             }

File: redisson/src/main/java/org/redisson/client/protocol/QueueCommand.java
Patch:
@@ -29,5 +29,7 @@ public interface QueueCommand {
     boolean tryFailure(Throwable cause);
     
     boolean isExecuted();
+
+    boolean isBlockingCommand();
     
 }

File: redisson-tomcat/redisson-tomcat-6/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -51,7 +51,7 @@ public class RedissonSession extends StandardSession {
     private final RedissonSessionManager redissonManager;
     private final Map<String, Object> attrs;
     private RMap<String, Object> map;
-    private RTopic<AttributeMessage> topic;
+    private RTopic topic;
     private final RedissonSessionManager.ReadMode readMode;
     private final UpdateMode updateMode;
     

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -51,7 +51,7 @@ public class RedissonSession extends StandardSession {
     private final RedissonSessionManager redissonManager;
     private final Map<String, Object> attrs;
     private RMap<String, Object> map;
-    private RTopic<AttributeMessage> topic;
+    private RTopic topic;
     private final RedissonSessionManager.ReadMode readMode;
     private final UpdateMode updateMode;
     

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -135,7 +135,7 @@ public RMap<String, Object> getMap(String sessionId) {
         return redisson.getMap(name);
     }
 
-    public RTopic<AttributeMessage> getTopic() {
+    public RTopic getTopic() {
         return redisson.getTopic("redisson:tomcat_session_updates:" + container.getName());
     }
     
@@ -202,8 +202,8 @@ protected void startInternal() throws LifecycleException {
         }
         
         if (readMode == ReadMode.MEMORY) {
-            RTopic<AttributeMessage> updatesTopic = getTopic();
-            updatesTopic.addListener(new MessageListener<AttributeMessage>() {
+            RTopic updatesTopic = getTopic();
+            updatesTopic.addListener(AttributeMessage.class, new MessageListener<AttributeMessage>() {
                 
                 @Override
                 public void onMessage(CharSequence channel, AttributeMessage msg) {

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -51,7 +51,7 @@ public class RedissonSession extends StandardSession {
     private final RedissonSessionManager redissonManager;
     private final Map<String, Object> attrs;
     private RMap<String, Object> map;
-    private RTopic<AttributeMessage> topic;
+    private RTopic topic;
     private final RedissonSessionManager.ReadMode readMode;
     private final UpdateMode updateMode;
     

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -134,7 +134,7 @@ public RMap<String, Object> getMap(String sessionId) {
         return redisson.getMap(name);
     }
 
-    public RTopic<AttributeMessage> getTopic() {
+    public RTopic getTopic() {
         return redisson.getTopic("redisson:tomcat_session_updates:" + getContext().getName());
     }
     
@@ -201,8 +201,8 @@ protected void startInternal() throws LifecycleException {
         }
         
         if (readMode == ReadMode.MEMORY) {
-            RTopic<AttributeMessage> updatesTopic = getTopic();
-            updatesTopic.addListener(new MessageListener<AttributeMessage>() {
+            RTopic updatesTopic = getTopic();
+            updatesTopic.addListener(AttributeMessage.class, new MessageListener<AttributeMessage>() {
                 
                 @Override
                 public void onMessage(CharSequence channel, AttributeMessage msg) {

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -51,7 +51,7 @@ public class RedissonSession extends StandardSession {
     private final RedissonSessionManager redissonManager;
     private final Map<String, Object> attrs;
     private RMap<String, Object> map;
-    private RTopic<AttributeMessage> topic;
+    private RTopic topic;
     private final RedissonSessionManager.ReadMode readMode;
     private final UpdateMode updateMode;
     

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -134,7 +134,7 @@ public RMap<String, Object> getMap(String sessionId) {
         return redisson.getMap(name);
     }
 
-    public RTopic<AttributeMessage> getTopic() {
+    public RTopic getTopic() {
         return redisson.getTopic("redisson:tomcat_session_updates:" + getContext().getName());
     }
     
@@ -201,8 +201,8 @@ protected void startInternal() throws LifecycleException {
         }
         
         if (readMode == ReadMode.MEMORY) {
-            RTopic<AttributeMessage> updatesTopic = getTopic();
-            updatesTopic.addListener(new MessageListener<AttributeMessage>() {
+            RTopic updatesTopic = getTopic();
+            updatesTopic.addListener(AttributeMessage.class, new MessageListener<AttributeMessage>() {
                 
                 @Override
                 public void onMessage(CharSequence channel, AttributeMessage msg) {

File: redisson/src/main/java/org/redisson/PubSubPatternMessageListener.java
Patch:
@@ -78,7 +78,7 @@ public void onMessage(CharSequence channel, V message) {
     @Override
     public void onPatternMessage(CharSequence pattern, CharSequence channel, V message) {
         // could be subscribed to multiple channels
-        if (name.equals(pattern.toString()) && message.getClass() == type) {
+        if (name.equals(pattern.toString()) && type.isInstance(message)) {
             listener.onMessage(pattern, channel, message);
         }
     }

File: redisson/src/main/java/org/redisson/RedissonBaseAdder.java
Patch:
@@ -124,15 +124,15 @@ protected RFuture<Void> acquireAsync(int value) {
     private static final long SUM_MSG = 1;
 
     private final RSemaphore semaphore;
-    private final RTopic<Long> topic;
+    private final RTopic topic;
     private final int listenerId;
     
     public RedissonBaseAdder(CommandAsyncExecutor connectionManager, String name, RedissonClient redisson) {
         super(connectionManager, name);
         
         topic = redisson.getTopic(suffixName(getName(), "topic"), LongCodec.INSTANCE);
         semaphore = redisson.getSemaphore(suffixName(getName(), "semaphore"));
-        listenerId = topic.addListener(new MessageListener<Long>() {
+        listenerId = topic.addListener(Long.class, new MessageListener<Long>() {
             
             @Override
             public void onMessage(CharSequence channel, Long msg) {

File: redisson/src/main/java/org/redisson/RedissonDelayedQueue.java
Patch:
@@ -78,8 +78,8 @@ protected RFuture<Long> pushTaskAsync() {
             }
             
             @Override
-            protected RTopic<Long> getTopic() {
-                return new RedissonTopic<Long>(LongCodec.INSTANCE, commandExecutor, channelName);
+            protected RTopic getTopic() {
+                return new RedissonTopic(LongCodec.INSTANCE, commandExecutor, channelName);
             }
         };
         

File: redisson/src/main/java/org/redisson/RedissonRemoteService.java
Patch:
@@ -189,7 +189,8 @@ public void operationComplete(Future<String> future) throws Exception {
                 }
                 
                 if (!future.isSuccess()) {
-                    if (future.cause() instanceof RedissonShutdownException) {
+                    if (future.cause() instanceof RedissonShutdownException
+                            || redisson.isShuttingDown()) {
                         return;
                     }
                     log.error("Can't process the remote service request.", future.cause());

File: redisson/src/main/java/org/redisson/api/RBatch.java
Patch:
@@ -290,13 +290,12 @@ public interface RBatch {
     /**
      * Returns topic instance by name.
      *
-     * @param <M> type of message
      * @param name - name of object
      * @return Topic object
      */
-    <M> RTopicAsync<M> getTopic(String name);
+    RTopicAsync getTopic(String name);
 
-    <M> RTopicAsync<M> getTopic(String name, Codec codec);
+    RTopicAsync getTopic(String name, Codec codec);
 
     /**
      * Returns queue instance by name.

File: redisson/src/main/java/org/redisson/api/RBatchReactive.java
Patch:
@@ -238,13 +238,12 @@ public interface RBatchReactive {
     /**
      * Returns topic instance by name.
      *
-     * @param <M> type of message
      * @param name - name of object
      * @return Topic object
      */
-    <M> RTopicReactive<M> getTopic(String name);
+    RTopicReactive getTopic(String name);
 
-    <M> RTopicReactive<M> getTopic(String name, Codec codec);
+    RTopicReactive getTopic(String name, Codec codec);
 
     /**
      * Returns queue instance by name.

File: redisson/src/main/java/org/redisson/api/RBatchRx.java
Patch:
@@ -239,13 +239,12 @@ public interface RBatchRx {
     /**
      * Returns topic instance by name.
      *
-     * @param <M> type of message
      * @param name - name of object
      * @return Topic object
      */
-    <M> RTopicRx<M> getTopic(String name);
+    RTopicRx getTopic(String name);
 
-    <M> RTopicRx<M> getTopic(String name, Codec codec);
+    RTopicRx getTopic(String name, Codec codec);
 
     /**
      * Returns queue instance by name.

File: redisson/src/main/java/org/redisson/api/RStream.java
Patch:
@@ -106,7 +106,7 @@ public interface RStream<K, V> extends RStreamAsync<K, V>, RExpirable {
      * @param idleTime - minimum idle time of messages
      * @param idleTimeUnit - idle time unit
      * @param ids - stream ids
-     * @return
+     * @return stream data mapped by Stream ID
      */
     Map<StreamId, Map<K, V>> claimPending(String groupName, String consumerName, long idleTime, TimeUnit idleTimeUnit, StreamId ... ids);
     

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -610,6 +610,8 @@ public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {
         if (dnsMonitor != null) {
             dnsMonitor.stop();
         }
+        
+        connectionWatcher.stop();
 
         if (cfg.getExecutor() == null) {
             executor.shutdown();

File: redisson/src/main/java/org/redisson/spring/session/RedissonSessionRepository.java
Patch:
@@ -71,7 +71,7 @@ public RedissonSession() {
             updateExpiration();
             
             String channelName = getEventsChannelName(delegate.getId());
-            RTopic<String> topic = redisson.getTopic(channelName, StringCodec.INSTANCE);
+            RTopic topic = redisson.getTopic(channelName, StringCodec.INSTANCE);
             topic.publish(delegate.getId());
         }
 

File: redisson/src/test/java/org/redisson/TimeoutTest.java
Patch:
@@ -27,8 +27,8 @@ public void testBrokenSlave() throws InterruptedException {
 
 //    @Test
     public void testPubSub() throws InterruptedException, ExecutionException {
-        RTopic<String> topic = redisson.getTopic("simple");
-        topic.addListener(new MessageListener<String>() {
+        RTopic topic = redisson.getTopic("simple");
+        topic.addListener(String.class, new MessageListener<String>() {
             @Override
             public void onMessage(CharSequence channel, String msg) {
                 System.out.println("msg: " + msg);

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -473,7 +473,7 @@ protected Decoder<Object> selectDecoder(CommandData<Object, Object> data, List<O
         }
         if (decoder == null) {
             if (data.getCommand().getOutParamType() == ValueType.MAP) {
-                if (parts.size() % 2 != 0) {
+                if (parts != null && parts.size() % 2 != 0) {
                     decoder = data.getCodec().getMapValueDecoder();
                 } else {
                     decoder = data.getCodec().getMapKeyDecoder();

File: redisson/src/main/java/org/redisson/api/listener/PatternMessageListener.java
Patch:
@@ -17,8 +17,6 @@
 
 import java.util.EventListener;
 
-import org.redisson.client.ChannelName;
-
 /**
  * Listener for Redis messages published via RTopic Redisson object
  *

File: redisson/src/test/java/org/redisson/RedissonTopicTest.java
Patch:
@@ -26,6 +26,7 @@
 import org.junit.Test;
 import org.redisson.ClusterRunner.ClusterProcesses;
 import org.redisson.RedisRunner.RedisProcess;
+import org.redisson.RedissonTopicPatternTest.Message;
 import org.redisson.api.RFuture;
 import org.redisson.api.RPatternTopic;
 import org.redisson.api.RSet;
@@ -205,8 +206,8 @@ public void onMessage(CharSequence channel, String msg) {
                     stringMessageReceived.incrementAndGet();
                 }
             });
-            RPatternTopic<String> patternTopic = redisson.getPatternTopic("test*", StringCodec.INSTANCE);
-            int patternListenerId = patternTopic.addListener(new PatternMessageListener<String>() {
+            RPatternTopic patternTopic = redisson.getPatternTopic("test*", StringCodec.INSTANCE);
+            int patternListenerId = patternTopic.addListener(String.class, new PatternMessageListener<String>() {
                 @Override
                 public void onMessage(CharSequence pattern, CharSequence channel, String msg) {
                     assertThat(msg).isEqualTo("testmsg");

File: redisson/src/main/java/org/redisson/codec/SnappyCodecV2.java
Patch:
@@ -62,9 +62,10 @@ public SnappyCodecV2(ClassLoader classLoader) {
         
         @Override
         public Object decode(ByteBuf buf, State state) throws IOException {
+            int size = buf.readableBytes();
             SnappyInputStream input = new SnappyInputStream(new ByteBufInputStream(buf));
-            ByteBuf bf = ByteBufAllocator.DEFAULT.buffer(buf.readableBytes());
-            bf.writeBytes(input, buf.readableBytes());
+            ByteBuf bf = ByteBufAllocator.DEFAULT.buffer(size);
+            bf.writeBytes(input, size);
             try {
                 return innerCodec.getValueDecoder().decode(bf, state);
             } finally {

File: redisson/src/main/java/org/redisson/client/handler/CommandsQueue.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.regex.Pattern;
 
 import org.redisson.client.ChannelName;
+import org.redisson.client.RedisConnectionClosedException;
 import org.redisson.client.RedisConnectionException;
 import org.redisson.client.WriteRedisConnectionException;
 import org.redisson.client.protocol.CommandData;
@@ -82,7 +83,7 @@ public void channelInactive(ChannelHandlerContext ctx) throws Exception {
                     new WriteRedisConnectionException("Channel has been closed! Can't write command: " + command.getCommand() + " to channel: " + ctx.channel()));
             
             if (command.getChannelPromise().isSuccess()) {
-                command.getCommand().tryFailure(new RedisConnectionException("Command succesfully sent, but channel " + ctx.channel() + " has been closed!"));
+                command.getCommand().tryFailure(new RedisConnectionClosedException("Command succesfully sent, but channel " + ctx.channel() + " has been closed!"));
             }
         }
         

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -44,6 +44,7 @@
 import org.redisson.client.RedisLoadingException;
 import org.redisson.client.RedisMovedException;
 import org.redisson.client.RedisRedirectException;
+import org.redisson.client.RedisResponseTimeoutException;
 import org.redisson.client.RedisTimeoutException;
 import org.redisson.client.RedisTryAgainException;
 import org.redisson.client.WriteRedisConnectionException;
@@ -755,7 +756,7 @@ public void run(Timeout timeout) throws Exception {
                 }
                 
                 details.getAttemptPromise().tryFailure(
-                        new RedisTimeoutException("Redis server response timeout (" + timeoutAmount + " ms) occured for command: " + details.getCommand()
+                        new RedisResponseTimeoutException("Redis server response timeout (" + timeoutAmount + " ms) occured for command: " + details.getCommand()
                                 + " with params: " + LogHelper.toString(details.getParams()) + " channel: " + connection.getChannel()));
             }
         };

File: redisson/src/main/java/org/redisson/command/CommandBatchService.java
Patch:
@@ -39,6 +39,7 @@
 import org.redisson.client.RedisConnection;
 import org.redisson.client.RedisLoadingException;
 import org.redisson.client.RedisMovedException;
+import org.redisson.client.RedisResponseTimeoutException;
 import org.redisson.client.RedisTimeoutException;
 import org.redisson.client.RedisTryAgainException;
 import org.redisson.client.WriteRedisConnectionException;
@@ -827,7 +828,7 @@ private void checkWriteFuture(Entry entry, final RPromise<Void> attemptPromise,
             @Override
             public void run(Timeout timeout) throws Exception {
                 attemptPromise.tryFailure(
-                        new RedisTimeoutException("Redis server response timeout during command batch execution. Channel: " + connection.getChannel()));
+                        new RedisResponseTimeoutException("Redis server response timeout during command batch execution. Channel: " + connection.getChannel()));
             }
         };
         

File: redisson/src/main/java/org/redisson/RedissonRateLimiter.java
Patch:
@@ -169,7 +169,7 @@ public void run() {
                         public void run() {
                             promise.trySuccess(false);
                         }
-                    }, remains, TimeUnit.SECONDS);
+                    }, remains, TimeUnit.MILLISECONDS);
                 } else {
                     final long start = System.currentTimeMillis();
                     commandExecutor.getConnectionManager().getGroup().schedule(new Runnable() {
@@ -183,7 +183,7 @@ public void run() {
                             
                             tryAcquireAsync(permits, promise, remains - elapsed);
                         }
-                    }, delay, TimeUnit.SECONDS);
+                    }, delay, TimeUnit.MILLISECONDS);
                 }
             }
         });

File: redisson/src/main/java/org/redisson/config/ClusterServersConfig.java
Patch:
@@ -35,7 +35,7 @@ public class ClusterServersConfig extends BaseMasterSlaveServersConfig<ClusterSe
     /**
      * Redis cluster scan interval in milliseconds
      */
-    private int scanInterval = 1000;
+    private int scanInterval = 5000;
 
     public ClusterServersConfig() {
     }
@@ -70,6 +70,8 @@ public int getScanInterval() {
     }
     /**
      * Redis cluster scan interval in milliseconds
+     * <p>
+     * Default is <code>5000</code>
      *
      * @param scanInterval in milliseconds
      * @return config

File: redisson/src/main/java/org/redisson/reactive/ReactiveProxyBuilder.java
Patch:
@@ -80,7 +80,8 @@ public RFuture<Object> get() {
                     });
                 }
                 
-                if (instanceMethod.getDeclaringClass() == implementation.getClass()) {
+                if (implementation != null 
+                        && instanceMethod.getDeclaringClass() == implementation.getClass()) {
                     return instanceMethod.invoke(implementation, args);
                 }
                 

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -82,6 +82,8 @@
  */
 public interface RedisCommands {
 
+    RedisStrictCommand<Void> DEBUG = new RedisStrictCommand<Void>("DEBUG");
+    
     RedisStrictCommand<Long> GEOADD = new RedisStrictCommand<Long>("GEOADD");
     RedisCommand<Double> GEODIST = new RedisCommand<Double>("GEODIST", new DoubleReplayConvertor());
     RedisCommand<List<Object>> GEORADIUS = new RedisCommand<List<Object>>("GEORADIUS", new ObjectListReplayDecoder<Object>());

File: redisson/src/main/java/org/redisson/api/RCollectionAsync.java
Patch:
@@ -31,7 +31,7 @@ public interface RCollectionAsync<V> extends RExpirableAsync {
      * specified collection (optional operation).
      *
      * @param c collection containing elements to be retained in this collection
-     * @return <tt>true</tt> if this collection changed as a result of the call
+     * @return <code>true</code> if this collection changed as a result of the call
      */
     RFuture<Boolean> retainAllAsync(Collection<?> c);
 

File: redisson/src/main/java/org/redisson/api/RCollectionReactive.java
Patch:
@@ -40,7 +40,7 @@ public interface RCollectionReactive<V> extends RExpirableReactive {
      * specified collection (optional operation).
      *
      * @param c collection containing elements to be retained in this collection
-     * @return <tt>true</tt> if this collection changed as a result of the call
+     * @return <code>true</code> if this collection changed as a result of the call
      */
     Publisher<Boolean> retainAll(Collection<?> c);
 

File: redisson/src/main/java/org/redisson/api/RList.java
Patch:
@@ -85,7 +85,7 @@ public interface RList<V> extends List<V>, RExpirable, RListAsync<V>, RSortable<
 
     /**
      * Trim list and remains elements only in specified range
-     * <tt>fromIndex</tt>, inclusive, and <tt>toIndex</tt>, inclusive.
+     * <code>fromIndex</code>, inclusive, and <code>toIndex</code>, inclusive.
      *
      * @param fromIndex - from index
      * @param toIndex - to index

File: redisson/src/main/java/org/redisson/api/RListAsync.java
Patch:
@@ -84,7 +84,7 @@ public interface RListAsync<V> extends RCollectionAsync<V>, RSortableAsync<List<
 
     /**
      * Trim list and remains elements only in specified range
-     * <tt>fromIndex</tt>, inclusive, and <tt>toIndex</tt>, inclusive.
+     * <code>fromIndex</code>, inclusive, and <code>toIndex</code>, inclusive.
      *
      * @param fromIndex - from index
      * @param toIndex - to index

File: redisson/src/main/java/org/redisson/api/RListReactive.java
Patch:
@@ -87,7 +87,7 @@ public interface RListReactive<V> extends RCollectionReactive<V>, RSortableReact
 
     /**
      * Trim list and remains elements only in specified range
-     * <tt>fromIndex</tt>, inclusive, and <tt>toIndex</tt>, inclusive.
+     * <code>fromIndex</code>, inclusive, and <code>toIndex</code>, inclusive.
      *
      * @param fromIndex - from index
      * @param toIndex - to index

File: redisson/src/main/java/org/redisson/RedissonWriteLock.java
Patch:
@@ -107,7 +107,7 @@ protected RFuture<Boolean> unlockInnerAsync(long threadId) {
                 "end; "
                 + "return nil;",
         Arrays.<Object>asList(getName(), getChannelName()), 
-        LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));
+        LockPubSub.readUnlockMessage, internalLockLeaseTime, getLockName(threadId));
     }
     
     @Override
@@ -125,7 +125,7 @@ public RFuture<Boolean> forceUnlockAsync() {
                   "return 1; " +
               "end; " +
               "return 0; ",
-              Arrays.<Object>asList(getName(), getChannelName()), LockPubSub.unlockMessage);
+              Arrays.<Object>asList(getName(), getChannelName()), LockPubSub.readUnlockMessage);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/api/RExpirableAsync.java
Patch:
@@ -50,7 +50,7 @@ public interface RExpirableAsync extends RObjectAsync {
      * Set an expire date for object in async mode. When expire date comes
      * the key will automatically be deleted.
      *
-     * @param timestamp - expire date in seconds (Unix timestamp)
+     * @param timestamp - expire date in milliseconds (Unix timestamp)
      * @return <code>true</code> if the timeout was set and <code>false</code> if not
      */
     RFuture<Boolean> expireAtAsync(long timestamp);

File: redisson/src/main/java/org/redisson/reactive/RedissonStreamReactive.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
 
 import org.reactivestreams.Publisher;
 import org.redisson.RedissonStream;
@@ -31,8 +32,6 @@
 import org.redisson.client.codec.Codec;
 import org.redisson.command.CommandReactiveExecutor;
 
-import reactor.fn.Supplier;
-
 /**
  * 
  * @author Nikita Koksharov

File: redisson/src/main/java/org/redisson/connection/balancer/LoadBalancerManager.java
Patch:
@@ -155,7 +155,9 @@ public ClientConnectionsEntry freeze(InetSocketAddress address, FreezeReason fre
     }
 
     public ClientConnectionsEntry freeze(ClientConnectionsEntry connectionEntry, FreezeReason freezeReason) {
-        if (connectionEntry == null) {
+        if (connectionEntry == null || (connectionEntry.isFailed() 
+                && connectionEntry.getFreezeReason() == FreezeReason.RECONNECT
+                    && freezeReason == FreezeReason.RECONNECT)) {
             return null;
         }
 

File: redisson/src/main/java/org/redisson/client/handler/PingConnectionHandler.java
Patch:
@@ -46,7 +46,7 @@ public PingConnectionHandler(RedisClientConfig config) {
     }
 
     @Override
-    public void channelActive(ChannelHandlerContext ctx) throws Exception {
+    public void channelActive(final ChannelHandlerContext ctx) throws Exception {
         RedisConnection connection = RedisConnection.getFrom(ctx.channel());
         connection.getConnectionPromise().addListener(new FutureListener<RedisConnection>() {
             @Override

File: redisson/src/main/java/org/redisson/RedissonFairLock.java
Patch:
@@ -262,7 +262,7 @@ public RFuture<Boolean> clearExpireAsync() {
     
     @Override
     public RFuture<Boolean> forceUnlockAsync() {
-        cancelExpirationRenewal();
+        cancelExpirationRenewal(null);
         return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 // remove stale threads
                 "while true do "

File: redisson/src/main/java/org/redisson/cache/LocalCacheListener.java
Patch:
@@ -19,9 +19,9 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashSet;
-import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.TimeUnit;
 
 import org.redisson.RedissonListMultimapCache;
@@ -38,7 +38,6 @@
 import org.redisson.api.RTopic;
 import org.redisson.api.listener.BaseStatusListener;
 import org.redisson.api.listener.MessageListener;
-import org.redisson.client.ChannelName;
 import org.redisson.client.codec.ByteArrayCodec;
 import org.redisson.client.codec.Codec;
 import org.redisson.command.CommandAsyncExecutor;
@@ -64,7 +63,7 @@ public abstract class LocalCacheListener {
     public static final String DISABLED_KEYS_SUFFIX = "disabled-keys";
     public static final String DISABLED_ACK_SUFFIX = ":topic";
     
-    private Map<CacheKey, String> disabledKeys = new ConcurrentHashMap<CacheKey, String>();
+    private ConcurrentMap<CacheKey, String> disabledKeys = new ConcurrentHashMap<CacheKey, String>();
     
     private static final Logger log = LoggerFactory.getLogger(LocalCacheListener.class);
     

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -45,6 +45,7 @@
 import org.redisson.client.protocol.decoder.ClusterNodesDecoder;
 import org.redisson.client.protocol.decoder.ListFirstObjectDecoder;
 import org.redisson.client.protocol.decoder.ListMultiDecoder;
+import org.redisson.client.protocol.decoder.ListObjectDecoder;
 import org.redisson.client.protocol.decoder.ListResultReplayDecoder;
 import org.redisson.client.protocol.decoder.ListScanResult;
 import org.redisson.client.protocol.decoder.ListScanResultReplayDecoder;
@@ -58,7 +59,6 @@
 import org.redisson.client.protocol.decoder.ObjectMapJoinDecoder;
 import org.redisson.client.protocol.decoder.ObjectMapReplayDecoder;
 import org.redisson.client.protocol.decoder.ObjectSetReplayDecoder;
-import org.redisson.client.protocol.decoder.ListObjectDecoder;
 import org.redisson.client.protocol.decoder.ScoredSortedSetPolledObjectDecoder;
 import org.redisson.client.protocol.decoder.ScoredSortedSetReplayDecoder;
 import org.redisson.client.protocol.decoder.ScoredSortedSetScanDecoder;
@@ -261,7 +261,7 @@ public interface RedisCommands {
 
     RedisStrictCommand<Void> AUTH = new RedisStrictCommand<Void>("AUTH", new VoidReplayConvertor());
     RedisStrictCommand<Void> SELECT = new RedisStrictCommand<Void>("SELECT", new VoidReplayConvertor());
-    RedisStrictCommand<Boolean> CLIENT_SETNAME = new RedisStrictCommand<Boolean>("CLIENT", "SETNAME", new BooleanReplayConvertor());
+    RedisStrictCommand<Void> CLIENT_SETNAME = new RedisStrictCommand<Void>("CLIENT", "SETNAME", new VoidReplayConvertor());
     RedisStrictCommand<String> CLIENT_GETNAME = new RedisStrictCommand<String>("CLIENT", "GETNAME", new StringDataDecoder());
     RedisStrictCommand<Void> FLUSHDB = new RedisStrictCommand<Void>("FLUSHDB", new VoidReplayConvertor());
     RedisStrictCommand<Void> FLUSHALL = new RedisStrictCommand<Void>("FLUSHALL", new VoidReplayConvertor());

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -99,7 +99,7 @@ public class RedissonExecutorService implements RScheduledExecutorService {
 
     private static final Logger LOGGER = LoggerFactory.getLogger(RedissonExecutorService.class);
     
-    private static final RemoteInvocationOptions RESULT_OPTIONS = RemoteInvocationOptions.defaults().noAck().expectResultWithin(1, TimeUnit.HOURS);
+    private static RemoteInvocationOptions RESULT_OPTIONS = RemoteInvocationOptions.defaults().noAck().expectResultWithin(1, TimeUnit.HOURS);
     
     public static final int SHUTDOWN_STATE = 1;
     public static final int TERMINATED_STATE = 2;

File: redisson/src/main/java/org/redisson/misc/LogHelper.java
Patch:
@@ -43,8 +43,6 @@ public static <T> String toString(T object) {
             return toArrayString(object);
         } else if (object instanceof Collection) {
             return toCollectionString((Collection<?>) object);
-        } else if (object instanceof ByteBuf) {
-            return ((ByteBuf) object).toString(CharsetUtil.UTF_8);
         } else if (object instanceof CommandData) {
             CommandData cd = (CommandData)object;
             return cd.getCommand() + ", params: " + LogHelper.toString(cd.getParams());

File: redisson/src/main/java/org/redisson/api/RMapCache.java
Patch:
@@ -37,7 +37,7 @@
  * @param <K> key
  * @param <V> value
  */
-public interface RMapCache<K, V> extends RMap<K, V>, RMapCacheAsync<K, V> {
+public interface RMapCache<K, V> extends RMap<K, V>, RMapCacheAsync<K, V>, RDestroyable {
 
     /**
      * Sets max size of the map.

File: redisson/src/main/java/org/redisson/api/RSetCache.java
Patch:
@@ -38,7 +38,7 @@
  *
  * @param <V> value
  */
-public interface RSetCache<V> extends Set<V>, RExpirable, RSetCacheAsync<V> {
+public interface RSetCache<V> extends Set<V>, RExpirable, RSetCacheAsync<V>, RDestroyable {
 
     /**
      * Returns lock instance associated with <code>value</code>

File: redisson/src/main/java/org/redisson/RedissonBucket.java
Patch:
@@ -148,7 +148,7 @@ public void set(V value, long timeToLive, TimeUnit timeUnit) {
     @Override
     public RFuture<Void> setAsync(V value, long timeToLive, TimeUnit timeUnit) {
         if (value == null) {
-            throw new IllegalArgumentException("Value can't be null");
+            return commandExecutor.writeAsync(getName(), RedisCommands.DEL_VOID, getName());
         }
 
         return commandExecutor.writeAsync(getName(), codec, RedisCommands.PSETEX, getName(), timeUnit.toMillis(timeToLive), encode(value));

File: redisson/src/main/java/org/redisson/misc/RedissonObjectFactory.java
Patch:
@@ -25,7 +25,6 @@
 import org.redisson.RedissonLiveObjectService;
 import org.redisson.RedissonReference;
 import org.redisson.api.RLiveObject;
-import org.redisson.api.RLiveObjectService;
 import org.redisson.api.RObject;
 import org.redisson.api.RObjectReactive;
 import org.redisson.api.RedissonClient;

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -582,7 +582,7 @@ public void run(Timeout t) throws Exception {
                         details.setException(new RedisTimeoutException("Unable to get connection! "
                                     + "Node source: " + source
                                     + ", command: " + command + ", command params: " + LogHelper.toString(details.getParams()) 
-                                    + " after " + connectionManager.getConfig().getRetryAttempts() + " retry attempts"));
+                                    + " after " + details.getAttempt() + " retry attempts"));
                     }
                     connectionManager.getShutdownLatch().release();
                 } else {

File: redisson/src/main/java/org/redisson/executor/RemoteExecutorService.java
Patch:
@@ -33,7 +33,7 @@ public interface RemoteExecutorService {
     void scheduleAtFixedRate(String className, byte[] classBody, byte[] state, long startTime, long period, String executorId, String requestId);
     
     void scheduleWithFixedDelay(String className, byte[] classBody, byte[] state, long startTime, long delay, String executorId, String requestId);
-    
-    void schedule(String className, byte[] classBody, byte[] state, long startTime, String cronExpression, String executorId, String requestId);
+
+    void schedule(String className, byte[] classBody, byte[] state, long startTime, String cronExpression, String timezone, String executorId, String requestId);
     
 }

File: redisson/src/main/java/org/redisson/executor/RemoteExecutorServiceAsync.java
Patch:
@@ -37,7 +37,7 @@ public interface RemoteExecutorServiceAsync {
     RFuture<Void> scheduleAtFixedRate(String className, byte[] classBody, byte[] state, long startTime, long period, String executorId, String requestId);
     
     RFuture<Void> scheduleWithFixedDelay(String className, byte[] classBody, byte[] state, long startTime, long delay, String executorId, String requestId);
-    
-    RFuture<Void> schedule(String className, byte[] classBody, byte[] state, long startTime, String cronExpression, String executorId, String requestId);
+
+    RFuture<Void> schedule(String className, byte[] classBody, byte[] state, long startTime, String cronExpression, String timezone, String executorId, String requestId);
     
 }

File: redisson/src/main/java/org/redisson/api/RScheduledExecutorService.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.util.concurrent.Callable;
 import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -121,7 +120,7 @@ RScheduledFuture<?> scheduleWithFixedDelay(Runnable command,
      * @param cronSchedule- cron schedule object
      * @return future object
      */
-    ScheduledFuture<?> schedule(Runnable task, CronSchedule cronSchedule);
+    RScheduledFuture<?> schedule(Runnable task, CronSchedule cronSchedule);
 
     /**
      * Use {@link #cancelTask(String)}

File: redisson/src/main/java/org/redisson/config/ConfigSupport.java
Patch:
@@ -96,7 +96,7 @@ public abstract static class MasterSlaveServersConfigMixIn {
 
     }
 
-    @JsonIgnoreProperties("clusterConfig")
+    @JsonIgnoreProperties({"clusterConfig", "sentinelConfig"})
     public static class ConfigMixIn {
 
         @JsonProperty

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -242,7 +242,7 @@ protected RFuture<RedisConnection> connectToNode(BaseMasterSlaveServersConfig<?>
         }
 
         if (addr != null) {
-            client = createClient(NodeType.MASTER, addr, cfg.getConnectTimeout(), cfg.getRetryInterval() * cfg.getRetryAttempts(), sslHostname);
+            client = createClient(NodeType.MASTER, addr, cfg.getConnectTimeout(), cfg.getTimeout(), sslHostname);
         }
         final RPromise<RedisConnection> result = new RedissonPromise<RedisConnection>();
         RFuture<RedisConnection> future = client.connectAsync();

File: redisson/src/test/java/org/redisson/executor/RedissonExecutorServiceTest.java
Patch:
@@ -297,7 +297,7 @@ public void testPerformance() throws InterruptedException {
             e.execute(new RunnableTask());        
         }
         e.shutdown();
-        assertThat(e.awaitTermination(900, TimeUnit.MILLISECONDS)).isTrue();
+        assertThat(e.awaitTermination(1000, TimeUnit.MILLISECONDS)).isTrue();
     }
     
     @Test

File: redisson/src/main/java/org/redisson/api/RScheduledExecutorService.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.util.concurrent.Callable;
 import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 
 /**
@@ -121,7 +120,7 @@ RScheduledFuture<?> scheduleWithFixedDelay(Runnable command,
      * @param cronSchedule- cron schedule object
      * @return future object
      */
-    ScheduledFuture<?> schedule(Runnable task, CronSchedule cronSchedule);
+    RScheduledFuture<?> schedule(Runnable task, CronSchedule cronSchedule);
 
     /**
      * Use {@link #cancelTask(String)}

File: redisson/src/main/java/org/redisson/config/ConfigSupport.java
Patch:
@@ -96,7 +96,7 @@ public abstract static class MasterSlaveServersConfigMixIn {
 
     }
 
-    @JsonIgnoreProperties("clusterConfig")
+    @JsonIgnoreProperties({"clusterConfig", "sentinelConfig"})
     public static class ConfigMixIn {
 
         @JsonProperty

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -242,7 +242,7 @@ protected RFuture<RedisConnection> connectToNode(BaseMasterSlaveServersConfig<?>
         }
 
         if (addr != null) {
-            client = createClient(NodeType.MASTER, addr, cfg.getConnectTimeout(), cfg.getRetryInterval() * cfg.getRetryAttempts(), sslHostname);
+            client = createClient(NodeType.MASTER, addr, cfg.getConnectTimeout(), cfg.getTimeout(), sslHostname);
         }
         final RPromise<RedisConnection> result = new RedissonPromise<RedisConnection>();
         RFuture<RedisConnection> future = client.connectAsync();

File: redisson/src/test/java/org/redisson/executor/RedissonExecutorServiceTest.java
Patch:
@@ -297,7 +297,7 @@ public void testPerformance() throws InterruptedException {
             e.execute(new RunnableTask());        
         }
         e.shutdown();
-        assertThat(e.awaitTermination(900, TimeUnit.MILLISECONDS)).isTrue();
+        assertThat(e.awaitTermination(1000, TimeUnit.MILLISECONDS)).isTrue();
     }
     
     @Test

File: redisson/src/test/java/org/redisson/executor/RedissonExecutorServiceTest.java
Patch:
@@ -297,7 +297,7 @@ public void testPerformance() throws InterruptedException {
             e.execute(new RunnableTask());        
         }
         e.shutdown();
-        assertThat(e.awaitTermination(900, TimeUnit.MILLISECONDS)).isTrue();
+        assertThat(e.awaitTermination(1000, TimeUnit.MILLISECONDS)).isTrue();
     }
     
     @Test

File: redisson/src/main/java/org/redisson/jcache/JCache.java
Patch:
@@ -58,7 +58,6 @@
 import org.redisson.api.RSemaphore;
 import org.redisson.api.RTopic;
 import org.redisson.api.listener.MessageListener;
-import org.redisson.client.ChannelName;
 import org.redisson.client.RedisClient;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.protocol.RedisCommand;
@@ -826,7 +825,7 @@ private long removeValues(Object... keys) {
         return evalWrite(getName(), codec, RedisCommands.EVAL_LONG,
                   "redis.call('zrem', KEYS[2], unpack(ARGV)); "
                 + "return redis.call('hdel', KEYS[1], unpack(ARGV)); ",
-                Arrays.<Object>asList(getName(), getTimeoutSetName()), params);
+                Arrays.<Object>asList(getName(), getTimeoutSetName()), params.toArray());
     }
 
     private List<Object> getAndPutValueLocked(K key, V value) {

File: redisson/src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -114,7 +114,7 @@ public RReadWriteLock getReadWriteLock(K key) {
         return new RedissonReadWriteLock(commandExecutor, lockName);
     }
     
-    private String getLockName(Object key, String suffix) {
+    public String getLockName(Object key, String suffix) {
         ByteBuf keyState = encodeMapKey(key);
         try {
             return suffixName(getName(key), Hash.hash128toBase64(keyState) + ":" + suffix);

File: redisson/src/main/java/org/redisson/RedissonSet.java
Patch:
@@ -553,7 +553,7 @@ public RFuture<Integer> sortToAsync(String destName, String byPattern, List<Stri
         return commandExecutor.writeAsync(getName(), codec, RedisCommands.SORT_TO, params.toArray());
     }
 
-    private String getLockName(Object value) {
+    public String getLockName(Object value) {
         ByteBuf state = encode(value);
         try {
             return suffixName(getName(value), Hash.hash128toBase64(state) + ":lock");

File: redisson/src/main/java/org/redisson/RedissonSetCache.java
Patch:
@@ -363,7 +363,7 @@ public void clear() {
         delete();
     }
 
-    private String getLockName(Object value) {
+    public String getLockName(Object value) {
         ByteBuf state = encode(value);
         try {
             return suffixName(getName(value), Hash.hash128toBase64(state) + ":lock");

File: redisson/src/main/java/org/redisson/RedissonWriteLock.java
Patch:
@@ -49,7 +49,7 @@ String getChannelName() {
     }
 
     @Override
-    String getLockName(long threadId) {
+    protected String getLockName(long threadId) {
         return super.getLockName(threadId) + ":write";
     }
     

File: redisson/src/main/java/org/redisson/api/RLock.java
Patch:
@@ -87,8 +87,9 @@ public interface RLock extends Lock, RExpirable, RLockAsync {
     /**
      * Unlocks lock independently of state
      *
+     * @return <code>true</code> if unlocked otherwise <code>false</code>
      */
-    void forceUnlock();
+    boolean forceUnlock();
 
     /**
      * Checks if this lock locked by any thread

File: redisson/src/main/java/org/redisson/transaction/RedissonTransactionalLocalCachedMap.java
Patch:
@@ -33,8 +33,8 @@
 public class RedissonTransactionalLocalCachedMap<K, V> extends RedissonTransactionalMap<K, V> implements RLocalCachedMap<K, V> {
 
     public RedissonTransactionalLocalCachedMap(CommandAsyncExecutor commandExecutor,  
-            List<TransactionalOperation> operations, long timeout, AtomicBoolean executed, RLocalCachedMap<K, V> innerMap) {
-        super(commandExecutor, operations, timeout, executed, innerMap);
+            List<TransactionalOperation> operations, long timeout, AtomicBoolean executed, RLocalCachedMap<K, V> innerMap, String transactionId) {
+        super(commandExecutor, operations, timeout, executed, innerMap, transactionId);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapAddAndGetOperation.java
Patch:
@@ -27,8 +27,8 @@ public class MapAddAndGetOperation extends MapOperation {
     public MapAddAndGetOperation() {
     }
     
-    public MapAddAndGetOperation(RMap<?, ?> map, Object key, Object value) {
-        super(map, key, value);
+    public MapAddAndGetOperation(RMap<?, ?> map, Object key, Object value, String transactionId) {
+        super(map, key, value, transactionId);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapCacheFastPutIfAbsentOperation.java
Patch:
@@ -33,8 +33,8 @@ public class MapCacheFastPutIfAbsentOperation extends MapOperation {
     private TimeUnit maxIdleUnit;
 
     public MapCacheFastPutIfAbsentOperation(RMap<?, ?> map, Object key, Object value, long ttl, TimeUnit ttlUnit,
-            long maxIdleTime, TimeUnit maxIdleUnit) {
-        super(map, key, value);
+            long maxIdleTime, TimeUnit maxIdleUnit, String transactionId) {
+        super(map, key, value, transactionId);
         this.ttl = ttl;
         this.ttlUnit = ttlUnit;
         this.maxIdleTime = maxIdleTime;

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapCacheFastPutOperation.java
Patch:
@@ -35,8 +35,8 @@ public class MapCacheFastPutOperation extends MapOperation {
     public MapCacheFastPutOperation() {
     }
     
-    public MapCacheFastPutOperation(RMap<?, ?> map, Object key, Object value, long ttl, TimeUnit ttlUnit, long maxIdleTime, TimeUnit maxIdleUnit) {
-        super(map, key, value);
+    public MapCacheFastPutOperation(RMap<?, ?> map, Object key, Object value, long ttl, TimeUnit ttlUnit, long maxIdleTime, TimeUnit maxIdleUnit, String transactionId) {
+        super(map, key, value, transactionId);
         this.ttl = ttl;
         this.ttlUnit = ttlUnit;
         this.maxIdleTime = maxIdleTime;

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapCachePutOperation.java
Patch:
@@ -35,8 +35,8 @@ public class MapCachePutOperation extends MapOperation {
     public MapCachePutOperation() {
     }
     
-    public MapCachePutOperation(RMap<?, ?> map, Object key, Object value, long ttlTimeout, TimeUnit ttlUnit, long maxIdleTimeout, TimeUnit maxIdleUnit) {
-        super(map, key, value);
+    public MapCachePutOperation(RMap<?, ?> map, Object key, Object value, long ttlTimeout, TimeUnit ttlUnit, long maxIdleTimeout, TimeUnit maxIdleUnit, String transactionId) {
+        super(map, key, value, transactionId);
         this.ttlTimeout = ttlTimeout;
         this.ttlUnit = ttlUnit;
         this.maxIdleTimeout = maxIdleTimeout;

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapFastPutIfAbsentOperation.java
Patch:
@@ -27,8 +27,8 @@ public class MapFastPutIfAbsentOperation extends MapOperation {
     public MapFastPutIfAbsentOperation() {
     }
     
-    public MapFastPutIfAbsentOperation(RMap<?, ?> map, Object key, Object value) {
-        super(map, key, value);
+    public MapFastPutIfAbsentOperation(RMap<?, ?> map, Object key, Object value, String transactionId) {
+        super(map, key, value, transactionId);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapFastPutOperation.java
Patch:
@@ -27,8 +27,8 @@ public class MapFastPutOperation extends MapOperation {
     public MapFastPutOperation() {
     }
     
-    public MapFastPutOperation(RMap<?, ?> map, Object key, Object value) {
-        super(map, key, value);
+    public MapFastPutOperation(RMap<?, ?> map, Object key, Object value, String transactionId) {
+        super(map, key, value, transactionId);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapFastRemoveOperation.java
Patch:
@@ -27,8 +27,8 @@ public class MapFastRemoveOperation extends MapOperation {
     public MapFastRemoveOperation() {
     }
     
-    public MapFastRemoveOperation(RMap<?, ?> map, Object key) {
-        super(map, key, null);
+    public MapFastRemoveOperation(RMap<?, ?> map, Object key, String transactionId) {
+        super(map, key, null, transactionId);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapPutIfAbsentOperation.java
Patch:
@@ -27,8 +27,8 @@ public class MapPutIfAbsentOperation extends MapOperation {
     public MapPutIfAbsentOperation() {
     }
     
-    public MapPutIfAbsentOperation(RMap<?, ?> map, Object key, Object value) {
-        super(map, key, value);
+    public MapPutIfAbsentOperation(RMap<?, ?> map, Object key, Object value, String transactionId) {
+        super(map, key, value, transactionId);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/transaction/operation/map/MapPutOperation.java
Patch:
@@ -27,8 +27,8 @@ public class MapPutOperation extends MapOperation {
     public MapPutOperation() {
     }
     
-    public MapPutOperation(RMap<?, ?> map, Object key, Object value) {
-        super(map, key, value);
+    public MapPutOperation(RMap<?, ?> map, Object key, Object value, String transactionId) {
+        super(map, key, value, transactionId);
     }
 
     @Override

File: redisson-tomcat/redisson-tomcat-6/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -212,7 +212,7 @@ public void start() throws LifecycleException {
             updatesTopic.addListener(new MessageListener<AttributeMessage>() {
                 
                 @Override
-                public void onMessage(String channel, AttributeMessage msg) {
+                public void onMessage(CharSequence channel, AttributeMessage msg) {
                     try {
                         // TODO make it thread-safe
                         RedissonSession session = (RedissonSession) RedissonSessionManager.super.findSession(msg.getSessionId());

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -192,7 +192,7 @@ protected void startInternal() throws LifecycleException {
             updatesTopic.addListener(new MessageListener<AttributeMessage>() {
                 
                 @Override
-                public void onMessage(String channel, AttributeMessage msg) {
+                public void onMessage(CharSequence channel, AttributeMessage msg) {
                     try {
                         // TODO make it thread-safe
                         RedissonSession session = (RedissonSession) RedissonSessionManager.super.findSession(msg.getSessionId());

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -203,7 +203,7 @@ protected void startInternal() throws LifecycleException {
             updatesTopic.addListener(new MessageListener<AttributeMessage>() {
                 
                 @Override
-                public void onMessage(String channel, AttributeMessage msg) {
+                public void onMessage(CharSequence channel, AttributeMessage msg) {
                     try {
                         // TODO make it thread-safe
                         RedissonSession session = (RedissonSession) RedissonSessionManager.super.findSession(msg.getSessionId());

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -203,7 +203,7 @@ protected void startInternal() throws LifecycleException {
             updatesTopic.addListener(new MessageListener<AttributeMessage>() {
                 
                 @Override
-                public void onMessage(String channel, AttributeMessage msg) {
+                public void onMessage(CharSequence channel, AttributeMessage msg) {
                     try {
                         // TODO make it thread-safe
                         RedissonSession session = (RedissonSession) RedissonSessionManager.super.findSession(msg.getSessionId());

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -128,8 +128,7 @@ private void enableRedissonReferenceSupport(Config config) {
 
     @Override
     public boolean isRedissonReferenceSupportEnabled() {
-        return false;
-//        return redisson != null || redissonReactive != null;
+        return redisson != null || redissonReactive != null;
     }
 
     @Override

File: redisson/src/main/java/org/redisson/connection/MasterSlaveEntry.java
Patch:
@@ -343,7 +343,7 @@ private RFuture<Void> addSlave(InetSocketAddress address, URI uri, final boolean
     }
     
     private RFuture<Void> addSlave(URI address, final boolean freezed, final NodeType nodeType) {
-        RedisClient client = connectionManager.createClient(NodeType.SLAVE, address, sslHostname);
+        RedisClient client = connectionManager.createClient(nodeType, address, sslHostname);
         return addSlave(client, freezed, nodeType);
     }
 

File: redisson/src/main/java/org/redisson/RedissonLiveObjectService.java
Patch:
@@ -699,7 +699,7 @@ private <T> void registerClassInternal(Class<T> entityClass) {
                 .intercept(MethodDelegation.to(
                                 new AccessorInterceptor(redisson, objectBuilder)))
                 
-                .make().load(getClass().getClassLoader(),
+                .make().load(entityClass.getClassLoader(),
                         ClassLoadingStrategy.Default.WRAPPER)
                 .getLoaded();
         classCache.putIfAbsent(entityClass, proxied);

File: redisson/src/main/java/org/redisson/executor/RemoteExecutorService.java
Patch:
@@ -33,7 +33,7 @@ public interface RemoteExecutorService {
     void scheduleAtFixedRate(String className, byte[] classBody, byte[] state, long startTime, long period, String executorId, String requestId);
     
     void scheduleWithFixedDelay(String className, byte[] classBody, byte[] state, long startTime, long delay, String executorId, String requestId);
-    
-    void schedule(String className, byte[] classBody, byte[] state, long startTime, String cronExpression, String executorId, String requestId);
+
+    void schedule(String className, byte[] classBody, byte[] state, long startTime, CronExpression cronExpression, String executorId, String requestId);
     
 }

File: redisson/src/main/java/org/redisson/executor/RemoteExecutorServiceAsync.java
Patch:
@@ -37,7 +37,7 @@ public interface RemoteExecutorServiceAsync {
     RFuture<Void> scheduleAtFixedRate(String className, byte[] classBody, byte[] state, long startTime, long period, String executorId, String requestId);
     
     RFuture<Void> scheduleWithFixedDelay(String className, byte[] classBody, byte[] state, long startTime, long delay, String executorId, String requestId);
-    
-    RFuture<Void> schedule(String className, byte[] classBody, byte[] state, long startTime, String cronExpression, String executorId, String requestId);
+
+    RFuture<Void> schedule(String className, byte[] classBody, byte[] state, long startTime, CronExpression cronExpression, String executorId, String requestId);
     
 }

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -448,6 +448,7 @@ public void operationComplete(Future<InetSocketAddress> future) throws Exception
                 }
 
                 sentinels.putIfAbsent(key, client);
+                result.trySuccess(null);
             }
         });
         return result;

File: redisson/src/main/java/org/redisson/RedissonHyperLogLog.java
Patch:
@@ -77,7 +77,7 @@ public RFuture<Boolean> addAllAsync(Collection<V> objects) {
         List<Object> args = new ArrayList<Object>(objects.size() + 1);
         args.add(getName());
         encode(args, objects);
-        return commandExecutor.writeAsync(getName(), codec, RedisCommands.PFADD, getName(), args.toArray());
+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.PFADD, args.toArray());
     }
 
     @Override

File: redisson-tomcat/redisson-tomcat-6/src/main/java/org/redisson/tomcat/AttributeUpdateMessage.java
Patch:
@@ -23,12 +23,12 @@
 public class AttributeUpdateMessage extends AttributeMessage {
 
     private String name;
-    private byte[] value;
+    private Object value;
 
     public AttributeUpdateMessage() {
     }
     
-    public AttributeUpdateMessage(String sessionId, String name, byte[] value) {
+    public AttributeUpdateMessage(String sessionId, String name, Object value) {
         super(sessionId);
         this.name = name;
         this.value = value;
@@ -38,7 +38,7 @@ public String getName() {
         return name;
     }
     
-    public byte[] getValue() {
+    public Object getValue() {
         return value;
     }
     

File: redisson-tomcat/redisson-tomcat-6/src/main/java/org/redisson/tomcat/AttributesPutAllMessage.java
Patch:
@@ -24,17 +24,17 @@
  */
 public class AttributesPutAllMessage extends AttributeMessage {
 
-    private Map<String, byte[]> attrs;
+    private Map<String, Object> attrs;
     
     public AttributesPutAllMessage() {
     }
 
-    public AttributesPutAllMessage(String sessionId, Map<String, byte[]> attrs) {
+    public AttributesPutAllMessage(String sessionId, Map<String, Object> attrs) {
         super(sessionId);
         this.attrs = attrs;
     }
     
-    public Map<String, byte[]> getAttrs() {
+    public Map<String, Object> getAttrs() {
         return attrs;
     }
 

File: redisson-tomcat/redisson-tomcat-6/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -117,9 +117,9 @@ public void access() {
     }
     
     protected AttributesPutAllMessage createPutAllMessage(Map<String, Object> newMap) {
-        Map<String, byte[]> map = new HashMap<String, byte[]>();
+        Map<String, Object> map = new HashMap<String, Object>();
         for (Entry<String, Object> entry : newMap.entrySet()) {
-            map.put(entry.getKey(), redissonManager.encode(entry.getValue()));
+            map.put(entry.getKey(), entry.getValue());
         }
         return new AttributesPutAllMessage(getId(), map);
     }
@@ -139,7 +139,7 @@ public void setMaxInactiveInterval(int interval) {
     private void fastPut(String name, Object value) {
         map.fastPut(name, value);
         if (readMode == ReadMode.MEMORY) {
-            topic.publish(new AttributeUpdateMessage(getId(), name, redissonManager.encode(value)));
+            topic.publish(new AttributeUpdateMessage(getId(), name, value));
         }
     }
     

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/AttributeUpdateMessage.java
Patch:
@@ -23,12 +23,12 @@
 public class AttributeUpdateMessage extends AttributeMessage {
 
     private String name;
-    private byte[] value;
+    private Object value;
 
     public AttributeUpdateMessage() {
     }
     
-    public AttributeUpdateMessage(String sessionId, String name, byte[] value) {
+    public AttributeUpdateMessage(String sessionId, String name, Object value) {
         super(sessionId);
         this.name = name;
         this.value = value;
@@ -38,7 +38,7 @@ public String getName() {
         return name;
     }
     
-    public byte[] getValue() {
+    public Object getValue() {
         return value;
     }
     

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/AttributesPutAllMessage.java
Patch:
@@ -24,17 +24,17 @@
  */
 public class AttributesPutAllMessage extends AttributeMessage {
 
-    private Map<String, byte[]> attrs;
+    private Map<String, Object> attrs;
     
     public AttributesPutAllMessage() {
     }
 
-    public AttributesPutAllMessage(String sessionId, Map<String, byte[]> attrs) {
+    public AttributesPutAllMessage(String sessionId, Map<String, Object> attrs) {
         super(sessionId);
         this.attrs = attrs;
     }
     
-    public Map<String, byte[]> getAttrs() {
+    public Map<String, Object> getAttrs() {
         return attrs;
     }
 

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -117,9 +117,9 @@ public void access() {
     }
 
     protected AttributesPutAllMessage createPutAllMessage(Map<String, Object> newMap) {
-        Map<String, byte[]> map = new HashMap<String, byte[]>();
+        Map<String, Object> map = new HashMap<String, Object>();
         for (Entry<String, Object> entry : newMap.entrySet()) {
-            map.put(entry.getKey(), redissonManager.encode(entry.getValue()));
+            map.put(entry.getKey(), entry.getValue());
         }
         return new AttributesPutAllMessage(getId(), map);
     }
@@ -139,7 +139,7 @@ public void setMaxInactiveInterval(int interval) {
     private void fastPut(String name, Object value) {
         map.fastPut(name, value);
         if (readMode == ReadMode.MEMORY) {
-            topic.publish(new AttributeUpdateMessage(getId(), name, redissonManager.encode(value)));
+            topic.publish(new AttributeUpdateMessage(getId(), name, value));
         }
     }
     

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/AttributeUpdateMessage.java
Patch:
@@ -23,12 +23,12 @@
 public class AttributeUpdateMessage extends AttributeMessage {
 
     private String name;
-    private byte[] value;
+    private Object value;
 
     public AttributeUpdateMessage() {
     }
     
-    public AttributeUpdateMessage(String sessionId, String name, byte[] value) {
+    public AttributeUpdateMessage(String sessionId, String name, Object value) {
         super(sessionId);
         this.name = name;
         this.value = value;
@@ -38,7 +38,7 @@ public String getName() {
         return name;
     }
     
-    public byte[] getValue() {
+    public Object getValue() {
         return value;
     }
     

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/AttributesPutAllMessage.java
Patch:
@@ -24,17 +24,17 @@
  */
 public class AttributesPutAllMessage extends AttributeMessage {
 
-    private Map<String, byte[]> attrs;
+    private Map<String, Object> attrs;
     
     public AttributesPutAllMessage() {
     }
 
-    public AttributesPutAllMessage(String sessionId, Map<String, byte[]> attrs) {
+    public AttributesPutAllMessage(String sessionId, Map<String, Object> attrs) {
         super(sessionId);
         this.attrs = attrs;
     }
     
-    public Map<String, byte[]> getAttrs() {
+    public Map<String, Object> getAttrs() {
         return attrs;
     }
 

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -117,9 +117,9 @@ public void access() {
     }
     
     protected AttributesPutAllMessage createPutAllMessage(Map<String, Object> newMap) {
-        Map<String, byte[]> map = new HashMap<String, byte[]>();
+        Map<String, Object> map = new HashMap<String, Object>();
         for (Entry<String, Object> entry : newMap.entrySet()) {
-            map.put(entry.getKey(), redissonManager.encode(entry.getValue()));
+            map.put(entry.getKey(), entry.getValue());
         }
         return new AttributesPutAllMessage(getId(), map);
     }
@@ -139,7 +139,7 @@ public void setMaxInactiveInterval(int interval) {
     private void fastPut(String name, Object value) {
         map.fastPut(name, value);
         if (readMode == ReadMode.MEMORY) {
-            topic.publish(new AttributeUpdateMessage(getId(), name, redissonManager.encode(value)));
+            topic.publish(new AttributeUpdateMessage(getId(), name, value));
         }
     }
     

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/AttributeUpdateMessage.java
Patch:
@@ -23,12 +23,12 @@
 public class AttributeUpdateMessage extends AttributeMessage {
 
     private String name;
-    private byte[] value;
+    private Object value;
 
     public AttributeUpdateMessage() {
     }
     
-    public AttributeUpdateMessage(String sessionId, String name, byte[] value) {
+    public AttributeUpdateMessage(String sessionId, String name, Object value) {
         super(sessionId);
         this.name = name;
         this.value = value;
@@ -38,7 +38,7 @@ public String getName() {
         return name;
     }
     
-    public byte[] getValue() {
+    public Object getValue() {
         return value;
     }
     

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/AttributesPutAllMessage.java
Patch:
@@ -24,17 +24,17 @@
  */
 public class AttributesPutAllMessage extends AttributeMessage {
 
-    private Map<String, byte[]> attrs;
+    private Map<String, Object> attrs;
     
     public AttributesPutAllMessage() {
     }
 
-    public AttributesPutAllMessage(String sessionId, Map<String, byte[]> attrs) {
+    public AttributesPutAllMessage(String sessionId, Map<String, Object> attrs) {
         super(sessionId);
         this.attrs = attrs;
     }
     
-    public Map<String, byte[]> getAttrs() {
+    public Map<String, Object> getAttrs() {
         return attrs;
     }
 

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSession.java
Patch:
@@ -117,9 +117,9 @@ public void access() {
     }
     
     protected AttributesPutAllMessage createPutAllMessage(Map<String, Object> newMap) {
-        Map<String, byte[]> map = new HashMap<String, byte[]>();
+        Map<String, Object> map = new HashMap<String, Object>();
         for (Entry<String, Object> entry : newMap.entrySet()) {
-            map.put(entry.getKey(), redissonManager.encode(entry.getValue()));
+            map.put(entry.getKey(), entry.getValue());
         }
         return new AttributesPutAllMessage(getId(), map);
     }
@@ -139,7 +139,7 @@ public void setMaxInactiveInterval(int interval) {
     private void fastPut(String name, Object value) {
         map.fastPut(name, value);
         if (readMode == ReadMode.MEMORY) {
-            topic.publish(new AttributeUpdateMessage(getId(), name, redissonManager.encode(value)));
+            topic.publish(new AttributeUpdateMessage(getId(), name, value));
         }
     }
     

File: redisson/src/main/java/org/redisson/client/protocol/QueueCommand.java
Patch:
@@ -28,4 +28,6 @@ public interface QueueCommand {
 
     boolean tryFailure(Throwable cause);
     
+    boolean isExecuted();
+    
 }

File: redisson/src/main/java/org/redisson/client/RedisClient.java
Patch:
@@ -326,12 +326,12 @@ public RFuture<Void> shutdownAsync() {
         for (Channel channel : channels) {
             RedisConnection connection = RedisConnection.getFrom(channel);
             if (connection != null) {
-                connection.setClosed(true);
+                connection.closeAsync();
             }
         }
-        ChannelGroupFuture channelsFuture = channels.close();
-        
+
         final RPromise<Void> result = new RedissonPromise<Void>();
+        ChannelGroupFuture channelsFuture = channels.newCloseFuture();
         channelsFuture.addListener(new FutureListener<Void>() {
             @Override
             public void operationComplete(Future<Void> future) throws Exception {

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -343,6 +343,7 @@ public interface RedisCommands {
     RedisStrictCommand<Void> RENAME = new RedisStrictCommand<Void>("RENAME", new VoidReplayConvertor());
     RedisStrictCommand<Boolean> MOVE = new RedisStrictCommand<Boolean>("MOVE", new BooleanReplayConvertor());
     RedisStrictCommand<Void> MIGRATE = new RedisStrictCommand<Void>("MIGRATE", new VoidReplayConvertor());
+    RedisStrictCommand<Void> QUIT = new RedisStrictCommand<Void>("QUIT", new VoidReplayConvertor());
 
     RedisStrictCommand<Long> PUBLISH = new RedisStrictCommand<Long>("PUBLISH");
 

File: redisson/src/main/java/org/redisson/RedissonRateLimiter.java
Patch:
@@ -153,7 +153,7 @@ public void operationComplete(Future<Long> future) throws Exception {
                         public void run() {
                             tryAcquireAsync(permits, promise, timeoutInMillis);
                         }
-                    }, delay, TimeUnit.SECONDS);
+                    }, delay, TimeUnit.MILLISECONDS);
                     return;
                 }
                 

File: redisson-tomcat/redisson-tomcat-6/src/main/java/org/redisson/tomcat/AttributeUpdateMessage.java
Patch:
@@ -23,12 +23,12 @@
 public class AttributeUpdateMessage extends AttributeMessage {
 
     private String name;
-    private Object value;
+    private byte[] value;
 
     public AttributeUpdateMessage() {
     }
     
-    public AttributeUpdateMessage(String sessionId, String name, Object value) {
+    public AttributeUpdateMessage(String sessionId, String name, byte[] value) {
         super(sessionId);
         this.name = name;
         this.value = value;
@@ -38,7 +38,7 @@ public String getName() {
         return name;
     }
     
-    public Object getValue() {
+    public byte[] getValue() {
         return value;
     }
     

File: redisson-tomcat/redisson-tomcat-6/src/main/java/org/redisson/tomcat/AttributesPutAllMessage.java
Patch:
@@ -24,17 +24,17 @@
  */
 public class AttributesPutAllMessage extends AttributeMessage {
 
-    private Map<String, Object> attrs;
+    private Map<String, byte[]> attrs;
     
     public AttributesPutAllMessage() {
     }
 
-    public AttributesPutAllMessage(String sessionId, Map<String, Object> attrs) {
+    public AttributesPutAllMessage(String sessionId, Map<String, byte[]> attrs) {
         super(sessionId);
         this.attrs = attrs;
     }
     
-    public Map<String, Object> getAttrs() {
+    public Map<String, byte[]> getAttrs() {
         return attrs;
     }
 

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/AttributeUpdateMessage.java
Patch:
@@ -23,12 +23,12 @@
 public class AttributeUpdateMessage extends AttributeMessage {
 
     private String name;
-    private Object value;
+    private byte[] value;
 
     public AttributeUpdateMessage() {
     }
     
-    public AttributeUpdateMessage(String sessionId, String name, Object value) {
+    public AttributeUpdateMessage(String sessionId, String name, byte[] value) {
         super(sessionId);
         this.name = name;
         this.value = value;
@@ -38,7 +38,7 @@ public String getName() {
         return name;
     }
     
-    public Object getValue() {
+    public byte[] getValue() {
         return value;
     }
     

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/AttributesPutAllMessage.java
Patch:
@@ -24,17 +24,17 @@
  */
 public class AttributesPutAllMessage extends AttributeMessage {
 
-    private Map<String, Object> attrs;
+    private Map<String, byte[]> attrs;
     
     public AttributesPutAllMessage() {
     }
 
-    public AttributesPutAllMessage(String sessionId, Map<String, Object> attrs) {
+    public AttributesPutAllMessage(String sessionId, Map<String, byte[]> attrs) {
         super(sessionId);
         this.attrs = attrs;
     }
     
-    public Map<String, Object> getAttrs() {
+    public Map<String, byte[]> getAttrs() {
         return attrs;
     }
 

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/AttributeUpdateMessage.java
Patch:
@@ -23,12 +23,12 @@
 public class AttributeUpdateMessage extends AttributeMessage {
 
     private String name;
-    private Object value;
+    private byte[] value;
 
     public AttributeUpdateMessage() {
     }
     
-    public AttributeUpdateMessage(String sessionId, String name, Object value) {
+    public AttributeUpdateMessage(String sessionId, String name, byte[] value) {
         super(sessionId);
         this.name = name;
         this.value = value;
@@ -38,7 +38,7 @@ public String getName() {
         return name;
     }
     
-    public Object getValue() {
+    public byte[] getValue() {
         return value;
     }
     

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/AttributesPutAllMessage.java
Patch:
@@ -24,17 +24,17 @@
  */
 public class AttributesPutAllMessage extends AttributeMessage {
 
-    private Map<String, Object> attrs;
+    private Map<String, byte[]> attrs;
     
     public AttributesPutAllMessage() {
     }
 
-    public AttributesPutAllMessage(String sessionId, Map<String, Object> attrs) {
+    public AttributesPutAllMessage(String sessionId, Map<String, byte[]> attrs) {
         super(sessionId);
         this.attrs = attrs;
     }
     
-    public Map<String, Object> getAttrs() {
+    public Map<String, byte[]> getAttrs() {
         return attrs;
     }
 

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/AttributeUpdateMessage.java
Patch:
@@ -23,12 +23,12 @@
 public class AttributeUpdateMessage extends AttributeMessage {
 
     private String name;
-    private Object value;
+    private byte[] value;
 
     public AttributeUpdateMessage() {
     }
     
-    public AttributeUpdateMessage(String sessionId, String name, Object value) {
+    public AttributeUpdateMessage(String sessionId, String name, byte[] value) {
         super(sessionId);
         this.name = name;
         this.value = value;
@@ -38,7 +38,7 @@ public String getName() {
         return name;
     }
     
-    public Object getValue() {
+    public byte[] getValue() {
         return value;
     }
     

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/AttributesPutAllMessage.java
Patch:
@@ -24,17 +24,17 @@
  */
 public class AttributesPutAllMessage extends AttributeMessage {
 
-    private Map<String, Object> attrs;
+    private Map<String, byte[]> attrs;
     
     public AttributesPutAllMessage() {
     }
 
-    public AttributesPutAllMessage(String sessionId, Map<String, Object> attrs) {
+    public AttributesPutAllMessage(String sessionId, Map<String, byte[]> attrs) {
         super(sessionId);
         this.attrs = attrs;
     }
     
-    public Map<String, Object> getAttrs() {
+    public Map<String, byte[]> getAttrs() {
         return attrs;
     }
 

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -850,6 +850,9 @@ public RScheduledFuture<?> scheduleAsync(Runnable task, CronSchedule cronSchedul
         byte[] classBody = getClassBody(task);
         byte[] state = encode(task);
         final Date startDate = cronSchedule.getExpression().getNextValidTimeAfter(new Date());
+        if (startDate == null) {
+            throw new IllegalArgumentException("Wrong cron expression! Unable to calculate start date");
+        }
         long startTime = startDate.getTime();
         RemotePromise<Void> result = (RemotePromise<Void>) asyncScheduledServiceAtFixed.schedule(task.getClass().getName(), classBody, state, startTime, cronSchedule.getExpression().getCronExpression(), executorId, null);
         addListener(result);

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -854,10 +854,10 @@ public RScheduledFuture<?> scheduleAsync(Runnable task, CronSchedule cronSchedul
         byte[] classBody = getClassBody(task);
         byte[] state = encode(task);
         final Date startDate = cronSchedule.getExpression().getNextValidTimeAfter(new Date());
-        long startTime = startDate.getTime();
         if (startDate == null) {
             return null;
         }
+        long startTime = startDate.getTime();
         RemotePromise<Void> result = (RemotePromise<Void>) asyncScheduledServiceAtFixed.schedule(task.getClass().getName(), classBody, state, startTime, cronSchedule.getExpression().getCronExpression(), executorId, null);
         addListener(result);
         RedissonScheduledFuture<Void> f = new RedissonScheduledFuture<Void>(result, startTime) {

File: redisson/src/main/java/org/redisson/client/RedisConnection.java
Patch:
@@ -165,7 +165,7 @@ public void operationComplete(Future<R> future) throws Exception {
         }
     }
 
-    public <T> T sync(RedisStrictCommand<T> command, Object ... params) {
+    public <T> T sync(RedisCommand<T> command, Object ... params) {
         return sync(null, command, params);
     }
 

File: redisson/src/main/java/org/redisson/client/handler/CommandPubSubDecoder.java
Patch:
@@ -18,8 +18,10 @@
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ExecutorService;
 
 import org.redisson.client.RedisPubSubConnection;
@@ -43,7 +45,7 @@
  */
 public class CommandPubSubDecoder extends CommandDecoder {
 
-    private static final List<String> MESSAGES = Arrays.asList("subscribe", "psubscribe", "punsubscribe", "unsubscribe");
+    private static final Set<String> MESSAGES = new HashSet<String>(Arrays.asList("subscribe", "psubscribe", "punsubscribe", "unsubscribe"));
     // It is not needed to use concurrent map because responses are coming consecutive
     private final Map<String, PubSubEntry> entries = new HashMap<String, PubSubEntry>();
     private final Map<PubSubKey, CommandData<Object, Object>> commands = PlatformDependent.newConcurrentHashMap();

File: redisson/src/main/java/org/redisson/client/handler/PingConnectionHandler.java
Patch:
@@ -57,6 +57,7 @@ protected void sendPing(final ChannelHandlerContext ctx) {
             @Override
             public void run(Timeout timeout) throws Exception {
                 if (future.cancel(false) || !future.isSuccess()) {
+                    System.out.println("closed!!! " + future + " " + connection.getChannel());
                     ctx.channel().close();
                 } else {
                     sendPing(ctx);

File: redisson/src/main/java/org/redisson/jcache/JCacheManager.java
Patch:
@@ -38,7 +38,6 @@
 import javax.management.ObjectName;
 
 import org.redisson.Redisson;
-import org.redisson.api.RedissonClient;
 import org.redisson.jcache.bean.EmptyStatisticsMXBean;
 import org.redisson.jcache.bean.JCacheManagementMXBean;
 import org.redisson.jcache.bean.JCacheStatisticsMXBean;
@@ -365,7 +364,9 @@ public void close() {
                         // skip
                     }
                 }
-                redisson.shutdown();
+                if (redisson != null) {
+                    redisson.shutdown();
+                }
                 closed = true;
             }
         }

File: redisson/src/main/java/org/redisson/client/handler/CommandPubSubDecoder.java
Patch:
@@ -174,6 +174,8 @@ protected MultiDecoder<Object> messageDecoder(CommandData<Object, Object> data,
             } else if (command.equals("pmessage")) {
                 String patternName = (String) parts.get(1);
                 return entries.get(patternName).getDecoder();
+            } else if (command.equals("pong")) {
+                return null;
             }
         }
 

File: redisson/src/main/java/org/redisson/cache/LocalCachedMapDisabledKey.java
Patch:
@@ -15,12 +15,14 @@
  */
 package org.redisson.cache;
 
+import java.io.Serializable;
+
 /**
  * 
  * @author Nikita Koksharov
  *
  */
-public class LocalCachedMapDisabledKey {
+public class LocalCachedMapDisabledKey implements Serializable {
 
     private String requestId;
     private long timeout;

File: redisson/src/main/java/org/redisson/cache/LocalCachedMapEnable.java
Patch:
@@ -15,12 +15,14 @@
  */
 package org.redisson.cache;
 
+import java.io.Serializable;
+
 /**
  * 
  * @author Nikita Koksharov
  *
  */
-public class LocalCachedMapEnable {
+public class LocalCachedMapEnable implements Serializable {
 
     private byte[][] keyHashes;
     private String requestId;

File: redisson/src/main/java/org/redisson/transaction/RedissonTransaction.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -79,7 +80,7 @@ public class RedissonTransaction implements RTransaction {
     private final AtomicBoolean executed = new AtomicBoolean();
     
     private final TransactionOptions options;
-    private List<TransactionalOperation> operations = new ArrayList<TransactionalOperation>();
+    private List<TransactionalOperation> operations = new CopyOnWriteArrayList<TransactionalOperation>();
     private Set<String> localCaches = new HashSet<String>();
     private final long startTime = System.currentTimeMillis();
     
@@ -287,6 +288,7 @@ public void commit(Set<String> localCaches, List<TransactionalOperation> operati
 
     private void checkTimeout() {
         if (options.getTimeout() != -1 && System.currentTimeMillis() - startTime > options.getTimeout()) {
+            rollbackAsync();
             throw new TransactionTimeoutException("Transaction was discarded due to timeout " + options.getTimeout() + " milliseconds");
         }
     }

File: redisson/src/test/java/org/redisson/transaction/RedissonBaseTransactionalMapTest.java
Patch:
@@ -22,7 +22,7 @@ public abstract class RedissonBaseTransactionalMapTest extends BaseTest {
     
     @Test
     public void testFastPut() throws InterruptedException {
-        ExecutorService executor = Executors.newFixedThreadPool(200);
+        ExecutorService executor = Executors.newFixedThreadPool(2000);
         for (int i = 0; i < 2000; i++) {
             executor.submit(() -> {
                 for (int j = 0; j < 100; j++) {

File: redisson/src/main/java/org/redisson/codec/FstCodec.java
Patch:
@@ -90,6 +90,9 @@ public ByteBuf encode(Object in) throws IOException {
             } catch (IOException e) {
                 out.release();
                 throw e;
+            } catch (Exception e) {
+                out.release();
+                throw new IOException(e);
             }
         }
     };

File: redisson/src/main/java/org/redisson/codec/JsonJacksonCodec.java
Patch:
@@ -79,6 +79,9 @@ public ByteBuf encode(Object in) throws IOException {
             } catch (IOException e) {
                 out.release();
                 throw e;
+            } catch (Exception e) {
+                out.release();
+                throw new IOException(e);
             }
         }
     };

File: redisson/src/main/java/org/redisson/RedissonScoredSortedSet.java
Patch:
@@ -37,6 +37,7 @@
 import org.redisson.client.codec.DoubleCodec;
 import org.redisson.client.codec.LongCodec;
 import org.redisson.client.codec.ScanCodec;
+import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.ScoredEntry;
@@ -370,7 +371,7 @@ public boolean contains(Object object) {
 
     @Override
     public RFuture<Boolean> containsAsync(Object o) {
-        return commandExecutor.readAsync(getName(), codec, RedisCommands.ZSCORE_CONTAINS, getName(), encode(o));
+        return commandExecutor.readAsync(getName(), StringCodec.INSTANCE, RedisCommands.ZSCORE_CONTAINS, getName(), encode(o));
     }
 
     @Override
@@ -380,7 +381,7 @@ public Double getScore(V o) {
 
     @Override
     public RFuture<Double> getScoreAsync(V o) {
-        return commandExecutor.readAsync(getName(), codec, RedisCommands.ZSCORE, getName(), encode(o));
+        return commandExecutor.readAsync(getName(), StringCodec.INSTANCE, RedisCommands.ZSCORE, getName(), encode(o));
     }
 
     @Override

File: redisson/src/test/java/org/redisson/transaction/RedissonBaseTransactionalMapTest.java
Patch:
@@ -22,8 +22,8 @@ public abstract class RedissonBaseTransactionalMapTest extends BaseTest {
     
     @Test
     public void testFastPut() throws InterruptedException {
-        ExecutorService executor = Executors.newFixedThreadPool(16);
-        for (int i = 0; i < 500; i++) {
+        ExecutorService executor = Executors.newFixedThreadPool(200);
+        for (int i = 0; i < 2000; i++) {
             executor.submit(() -> {
                 for (int j = 0; j < 100; j++) {
                     RTransaction t = redisson.createTransaction(TransactionOptions.defaults());
@@ -35,7 +35,7 @@ public void testFastPut() throws InterruptedException {
         }
         
         executor.shutdown();
-        assertThat(executor.awaitTermination(1, TimeUnit.MINUTES)).isTrue();
+        assertThat(executor.awaitTermination(2, TimeUnit.MINUTES)).isTrue();
     }
     
     

File: redisson/src/main/java/org/redisson/cluster/ClusterNodeInfo.java
Patch:
@@ -16,6 +16,7 @@
 package org.redisson.cluster;
 
 import java.net.URI;
+import java.util.EnumSet;
 import java.util.HashSet;
 import java.util.Set;
 import org.redisson.misc.URIBuilder;
@@ -33,7 +34,7 @@ public enum Flag {NOFLAGS, SLAVE, MASTER, MYSELF, FAIL, HANDSHAKE, NOADDR};
     
     private String nodeId;
     private URI address;
-    private final Set<Flag> flags = new HashSet<Flag>();
+    private final Set<Flag> flags = EnumSet.noneOf(Flag.class);
     private String slaveOf;
 
     private final Set<ClusterSlotRange> slotRanges = new HashSet<ClusterSlotRange>();

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -288,7 +288,7 @@ private void scheduleClusterChangeCheck(final ClusterServersConfig cfg, final It
             public void run() {
                 if (isConfigEndpoint) {
                     final URI uri = cfg.getNodeAddresses().iterator().next();
-                    final AddressResolver<InetSocketAddress> resolver = createResolverGroup().getResolver(getGroup().next());
+                    final AddressResolver<InetSocketAddress> resolver = resolverGroup.getResolver(getGroup().next());
                     Future<List<InetSocketAddress>> allNodes = resolver.resolveAll(InetSocketAddress.createUnresolved(uri.getHost(), uri.getPort()));
                     allNodes.addListener(new FutureListener<List<InetSocketAddress>>() {
                         @Override

File: redisson/src/test/java/org/redisson/RedissonRateLimiterTest.java
Patch:
@@ -35,7 +35,7 @@ public void test() throws InterruptedException {
     }
     
     @Test
-    public void test3() throws InterruptedException {
+    public void testConcurrency() throws InterruptedException {
         RRateLimiter rr = redisson.getRateLimiter("test");
         assertThat(rr.trySetRate(RateType.OVERALL, 10, 1, RateIntervalUnit.SECONDS)).isTrue();
         assertThat(rr.trySetRate(RateType.OVERALL, 20, 1, RateIntervalUnit.SECONDS)).isFalse();
@@ -55,7 +55,8 @@ public void run() {
                             }
                         }
                         try {
-                            Thread.sleep(ThreadLocalRandom.current().nextInt(10));                        } catch (InterruptedException e) {
+                            Thread.sleep(ThreadLocalRandom.current().nextInt(10));
+                        } catch (InterruptedException e) {
                             e.printStackTrace();
                         }
                         

File: redisson/src/main/java/org/redisson/connection/SingleConnectionManager.java
Patch:
@@ -37,6 +37,7 @@ public SingleConnectionManager(SingleServerConfig cfg, Config config, UUID id) {
     private static MasterSlaveServersConfig create(SingleServerConfig cfg) {
         MasterSlaveServersConfig newconfig = new MasterSlaveServersConfig();
         
+        newconfig.setPingConnectionInterval(cfg.getPingConnectionInterval());
         newconfig.setSslEnableEndpointIdentification(cfg.isSslEnableEndpointIdentification());
         newconfig.setSslProvider(cfg.getSslProvider());
         newconfig.setSslTruststore(cfg.getSslTruststore());

File: redisson/src/test/java/org/redisson/RedissonBlockingDequeTest.java
Patch:
@@ -16,7 +16,7 @@ public void testPollLastAndOfferFirstTo() throws InterruptedException {
         RBlockingDeque<String> blockingDeque = redisson.getBlockingDeque("blocking_deque");
         long start = System.currentTimeMillis();
         String redisTask = blockingDeque.pollLastAndOfferFirstTo("deque", 1, TimeUnit.SECONDS);
-        assertThat(System.currentTimeMillis() - start).isBetween(950L, 1050L);
+        assertThat(System.currentTimeMillis() - start).isBetween(950L, 1100L);
         assertThat(redisTask).isNull();
     }
     

File: redisson/src/main/java/org/redisson/RedissonBloomFilter.java
Patch:
@@ -124,7 +124,7 @@ public boolean add(T object) {
                 List<Boolean> result = (List<Boolean>) executorService.execute();
 
                 for (Boolean val : result.subList(1, result.size()-1)) {
-                    if (val) {
+                    if (!val) {
                         return true;
                     }
                 }

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -582,7 +582,7 @@ private void checkSlotsChange(ClusterServersConfig cfg, Collection<ClusterPartit
         for (Integer slot : removedSlots) {
             MasterSlaveEntry entry = removeEntry(slot);
             if (entry.getSlotRanges().isEmpty()) {
-                entry.shutdownMasterAsync();
+                entry.shutdownAsync();
                 log.info("{} master and slaves for it removed", entry.getClient().getAddr());
             }
         }

File: redisson/src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -67,8 +67,6 @@ public interface ConnectionManager {
     
     IdleConnectionWatcher getConnectionWatcher();
 
-    void shutdownAsync(RedisClient client);
-
     int calcSlot(String key);
 
     MasterSlaveServersConfig getConfig();

File: redisson/src/main/java/org/redisson/RedissonRemoteService.java
Patch:
@@ -187,7 +187,7 @@ public void operationComplete(Future<String> future) throws Exception {
 
                 final String requestId = future.getNow();
                 RMap<String, RemoteServiceRequest> tasks = redisson.getMap(requestQueue.getName() + ":tasks", new CompositeCodec(StringCodec.INSTANCE, codec, codec));
-                RFuture<RemoteServiceRequest> taskFuture = tasks.getAsync(requestId);
+                RFuture<RemoteServiceRequest> taskFuture = tasks.removeAsync(requestId);
                 taskFuture.addListener(new FutureListener<RemoteServiceRequest>() {
 
                     @Override

File: redisson/src/test/java/org/redisson/RedissonRemoteServiceTest.java
Patch:
@@ -424,7 +424,7 @@ public void testTimeout() throws InterruptedException {
             r2.shutdown();
         }
     }
-    
+
     @Test
     public void testInvocations() {
         RedissonClient r1 = createInstance();
@@ -451,6 +451,7 @@ public void testInvocations() {
             assertThat(e.getCause().getMessage()).isEqualTo("/ by zero");
         }
         
+        assertThat(r1.getKeys().count()).isZero();
         r1.shutdown();
         r2.shutdown();
     }

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -539,7 +539,7 @@ public void run(Timeout t) throws Exception {
                                 if (details.getWriteFuture() != null && details.getWriteFuture().cancel(false)) {
                                     if (details.getException() == null) {
                                         details.setException(new RedisTimeoutException("Unable to send command! "
-                                                    + "Node source: " + source + ", connection: " + details.getConnectionFuture().getNow().getChannel() 
+                                                    + "Node source: " + source + ", connection: " + details.getConnectionFuture().getNow() 
                                                     + ", command: " + command + ", command params: " + LogHelper.toString(details.getParams()) 
                                                     + " after " + connectionManager.getConfig().getRetryAttempts() + " retry attempts"));
                                     }

File: redisson/src/test/java/org/redisson/RedissonBlockingQueueTest.java
Patch:
@@ -38,7 +38,7 @@ <T> RBlockingQueue<T> getQueue(RedissonClient redisson) {
         return redisson.getBlockingQueue("queue");
     }
     
-//    @Test
+    @Test
     public void testPollWithBrokenConnection() throws IOException, InterruptedException, ExecutionException {
         RedisProcess runner = new RedisRunner()
                 .nosave()

File: redisson/src/main/java/org/redisson/remote/RemoteServiceResponse.java
Patch:
@@ -43,6 +43,7 @@ public RemoteServiceResponse(String id, Throwable error) {
         this.id = id;
     }
     
+    @Override
     public String getId() {
         return id;
     }

File: redisson/src/main/java/org/redisson/spring/cache/RedissonCacheMetrics.java
Patch:
@@ -57,7 +57,7 @@ protected long hitCount() {
     }
 
     @Override
-    protected long missCount() {
+    protected Long missCount() {
         return cache.getCacheMisses();
     }
 

File: redisson/src/main/java/org/redisson/client/RedisClientConfig.java
Patch:
@@ -68,6 +68,7 @@ public RedisClientConfig() {
     
     RedisClientConfig(RedisClientConfig config) {
         super();
+        this.addr = config.addr;
         this.address = config.address;
         this.timer = config.timer;
         this.executor = config.executor;

File: redisson/src/main/java/org/redisson/BaseIterator.java
Patch:
@@ -55,6 +55,9 @@ public boolean hasNext() {
                 
                 client = res.getRedisClient();
                 
+                lastIter = res.getValues().iterator();
+                nextIterPos = res.getPos();
+
                 if (res.getPos() == 0) {
                     finished = true;
                     if (res.getValues().isEmpty()) {
@@ -69,8 +72,6 @@ public boolean hasNext() {
                         return false;
                     }
                 }
-                lastIter = res.getValues().iterator();
-                nextIterPos = res.getPos();
             } while (!lastIter.hasNext());
         }
         return lastIter.hasNext();

File: redisson/src/main/java/org/redisson/RedissonKeys.java
Patch:
@@ -121,13 +121,13 @@ private Iterator<String> createKeysIterator(final MasterSlaveEntry entry, final
         return new RedissonBaseIterator<String>() {
 
             @Override
-            ListScanResult<ScanObjectEntry> iterator(RedisClient client, long nextIterPos) {
+            protected ListScanResult<ScanObjectEntry> iterator(RedisClient client, long nextIterPos) {
                 return RedissonKeys.this.scanIterator(client, entry, nextIterPos, pattern, count);
             }
 
             @Override
-            void remove(String value) {
-                RedissonKeys.this.delete(value);
+            protected void remove(ScanObjectEntry value) {
+                RedissonKeys.this.delete((String)value.getObj());
             }
             
         };

File: redisson/src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -1102,7 +1102,7 @@ public int hashCode() {
     }
 
     protected Iterator<K> keyIterator(String pattern) {
-        return new RedissonMapIterator<K, V, K>(RedissonMap.this, pattern) {
+        return new RedissonMapIterator<K>(RedissonMap.this, pattern) {
             @Override
             protected K getValue(java.util.Map.Entry<ScanObjectEntry, ScanObjectEntry> entry) {
                 return (K) entry.getKey().getObj();
@@ -1153,7 +1153,7 @@ public void clear() {
     }
 
     protected Iterator<V> valueIterator(String pattern) {
-        return new RedissonMapIterator<K, V, V>(RedissonMap.this, pattern) {
+        return new RedissonMapIterator<V>(RedissonMap.this, pattern) {
             @Override
             protected V getValue(java.util.Map.Entry<ScanObjectEntry, ScanObjectEntry> entry) {
                 return (V) entry.getValue().getObj();
@@ -1200,7 +1200,7 @@ public void clear() {
     }
 
     protected Iterator<Map.Entry<K,V>> entryIterator(String pattern) {
-        return new RedissonMapIterator<K, V, Map.Entry<K, V>>(RedissonMap.this, pattern);
+        return new RedissonMapIterator<Map.Entry<K, V>>(RedissonMap.this, pattern);
     }
 
     private void loadValue(final K key, final RPromise<V> result, final boolean replaceValue) {

File: redisson/src/main/java/org/redisson/RedissonMultimap.java
Patch:
@@ -318,7 +318,7 @@ final class KeySet extends AbstractSet<K> {
 
         @Override
         public Iterator<K> iterator() {
-            return new RedissonMultiMapKeysIterator<K, V, K>(RedissonMultimap.this) {
+            return new RedissonMultiMapKeysIterator<K>(RedissonMultimap.this) {
                 @Override
                 protected K getValue(java.util.Map.Entry<ScanObjectEntry, ScanObjectEntry> entry) {
                     return (K) entry.getKey().getObj();

File: redisson/src/main/java/org/redisson/RedissonScoredSortedSet.java
Patch:
@@ -322,13 +322,13 @@ public Iterator<V> iterator() {
         return new RedissonBaseIterator<V>() {
 
             @Override
-            ListScanResult<ScanObjectEntry> iterator(RedisClient client, long nextIterPos) {
+            protected ListScanResult<ScanObjectEntry> iterator(RedisClient client, long nextIterPos) {
                 return scanIterator(client, nextIterPos);
             }
 
             @Override
-            void remove(V value) {
-                RedissonScoredSortedSet.this.remove(value);
+            protected void remove(ScanObjectEntry value) {
+                RedissonScoredSortedSet.this.remove((V)value.getObj());
             }
             
         };

File: redisson/src/main/java/org/redisson/RedissonSet.java
Patch:
@@ -109,13 +109,13 @@ public Iterator<V> iterator(final String pattern) {
         return new RedissonBaseIterator<V>() {
 
             @Override
-            ListScanResult<ScanObjectEntry> iterator(RedisClient client, long nextIterPos) {
+            protected ListScanResult<ScanObjectEntry> iterator(RedisClient client, long nextIterPos) {
                 return scanIterator(getName(), client, nextIterPos, pattern);
             }
 
             @Override
-            void remove(V value) {
-                RedissonSet.this.remove(value);
+            protected void remove(ScanObjectEntry value) {
+                RedissonSet.this.remove((V)value.getObj());
             }
             
         };

File: redisson/src/main/java/org/redisson/RedissonSetCache.java
Patch:
@@ -161,13 +161,13 @@ public Iterator<V> iterator(final String pattern) {
         return new RedissonBaseIterator<V>() {
 
             @Override
-            ListScanResult<ScanObjectEntry> iterator(RedisClient client, long nextIterPos) {
+            protected ListScanResult<ScanObjectEntry> iterator(RedisClient client, long nextIterPos) {
                 return scanIterator(getName(), client, nextIterPos, pattern);
             }
 
             @Override
-            void remove(V value) {
-                RedissonSetCache.this.remove(value);
+            protected void remove(ScanObjectEntry value) {
+                RedissonSetCache.this.remove((V)value.getObj());
             }
             
         };

File: redisson/src/main/java/org/redisson/RedissonSetMultimapValues.java
Patch:
@@ -203,13 +203,13 @@ public Iterator<V> iterator(final String pattern) {
         return new RedissonBaseIterator<V>() {
 
             @Override
-            ListScanResult<ScanObjectEntry> iterator(RedisClient client, long nextIterPos) {
+            protected ListScanResult<ScanObjectEntry> iterator(RedisClient client, long nextIterPos) {
                 return scanIterator(client, nextIterPos, pattern);
             }
 
             @Override
-            void remove(V value) {
-                RedissonSetMultimapValues.this.remove(value);
+            protected void remove(ScanObjectEntry value) {
+                RedissonSetMultimapValues.this.remove((V)value.getObj());
             }
             
         };

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -29,7 +29,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.redisson.RedisClientResult;
+import org.redisson.ScanResult;
 import org.redisson.RedissonReference;
 import org.redisson.RedissonShutdownException;
 import org.redisson.SlotCallback;
@@ -856,8 +856,8 @@ public void run(Timeout timeout) throws Exception {
             
             if (future.isSuccess()) {
                 R res = future.getNow();
-                if (res instanceof RedisClientResult) {
-                    ((RedisClientResult) res).setRedisClient(details.getConnectionFuture().getNow().getRedisClient());
+                if (res instanceof ScanResult) {
+                    ((ScanResult) res).setRedisClient(details.getConnectionFuture().getNow().getRedisClient());
                 }
                 
                 if (isRedissonReferenceSupportEnabled()) {

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -389,6 +389,7 @@ protected MasterSlaveEntry createMasterSlaveEntry(MasterSlaveServersConfig confi
     protected MasterSlaveServersConfig create(BaseMasterSlaveServersConfig<?> cfg) {
         MasterSlaveServersConfig c = new MasterSlaveServersConfig();
         
+        c.setPingConnectionInterval(cfg.getPingConnectionInterval());
         c.setSslEnableEndpointIdentification(cfg.isSslEnableEndpointIdentification());
         c.setSslProvider(cfg.getSslProvider());
         c.setSslTruststore(cfg.getSslTruststore());

File: redisson/src/main/java/org/redisson/config/BaseMasterSlaveServersConfig.java
Patch:
@@ -132,7 +132,7 @@ public int getFailedSlaveReconnectionInterval() {
 
     
     /**
-     * Redis Slave node is excluded from the internal list of available nodes
+     * Redis Slave node failing to execute commands is excluded from the internal list of available nodes
      * when the time interval from the moment of first Redis command execution failure
      * on this server reaches <code>slaveFailsInterval</code> value.
      * <p>

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -438,7 +438,7 @@ private void upDownSlaves(final MasterSlaveEntry entry, final ClusterPartition c
         aliveSlaves.removeAll(newPart.getFailedSlaveAddresses());
         for (URI uri : aliveSlaves) {
             currentPart.removeFailedSlaveAddress(uri);
-            if (entry.slaveUp(uri, FreezeReason.MANAGER)) {
+            if (entry.hasSlave(uri) && entry.slaveUp(uri, FreezeReason.MANAGER)) {
                 log.info("slave: {} has up for slot ranges: {}", uri, currentPart.getSlotRanges());
             }
         }
@@ -453,7 +453,7 @@ private void upDownSlaves(final MasterSlaveEntry entry, final ClusterPartition c
         }
     }
 
-    private Set<URI> addRemoveSlaves(final MasterSlaveEntry entry, final ClusterPartition currentPart, final ClusterPartition newPart) {
+    private Set<URI> addRemoveSlaves(final MasterSlaveEntry entry, final ClusterPartition currentPart, ClusterPartition newPart) {
         Set<URI> removedSlaves = new HashSet<URI>(currentPart.getSlaveAddresses());
         removedSlaves.removeAll(newPart.getSlaveAddresses());
 

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -347,7 +347,9 @@ public void operationComplete(Future<List<InetSocketAddress>> future) throws Exc
 
     private void checkClusterState(final ClusterServersConfig cfg, final Iterator<URI> iterator, final AtomicReference<Throwable> lastException) {
         if (!iterator.hasNext()) {
-            log.error("Can't update cluster state", lastException.get());
+            if (lastException.get() != null) {
+                log.error("Can't update cluster state", lastException.get());
+            }
             scheduleClusterChangeCheck(cfg, null);
             return;
         }

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -248,7 +248,9 @@ public void run() {
 
     private void checkState(final SentinelServersConfig cfg, final Iterator<RedisClient> iterator, final AtomicReference<Throwable> lastException) {
         if (!iterator.hasNext()) {
-            log.error("Can't update cluster state", lastException.get());
+            if (lastException.get() != null) {
+                log.error("Can't update cluster state", lastException.get());
+            }
             scheduleChangeCheck(cfg, null);
             return;
         }

File: redisson/src/main/java/org/redisson/api/RObject.java
Patch:
@@ -38,8 +38,9 @@ public interface RObject extends RObjectAsync {
      * @param host - destination host
      * @param port - destination port
      * @param database - destination database
+     * @param timeout - maximum idle time in any moment of the communication with the destination instance in milliseconds
      */
-    void migrate(String host, int port, int database);
+    void migrate(String host, int port, int database, long timeout);
 
     /**
      * Move object to another database

File: redisson/src/main/java/org/redisson/api/RObjectAsync.java
Patch:
@@ -37,9 +37,10 @@ public interface RObjectAsync {
      * @param host - destination host
      * @param port - destination port
      * @param database - destination database
+     * @param timeout - maximum idle time in any moment of the communication with the destination instance in milliseconds
      * @return void
      */
-    RFuture<Void> migrateAsync(String host, int port, int database);
+    RFuture<Void> migrateAsync(String host, int port, int database, long timeout);
 
     /**
      * Move object to another database in async mode

File: redisson/src/main/java/org/redisson/RedissonRemoteService.java
Patch:
@@ -92,7 +92,7 @@ protected RFuture<Boolean> addAsync(String requestQueueName, RemoteServiceReques
     protected RFuture<Boolean> removeAsync(String requestQueueName, RequestId taskId) {
         return commandExecutor.evalWriteAsync(name, LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 "redis.call('lrem', KEYS[1], 1, ARGV[1]); "
-              + "redis.call('hset', KEYS[2], ARGV[1]);"
+              + "redis.call('hdel', KEYS[2], ARGV[1]);"
               + "return 1;",
               Arrays.<Object>asList(requestQueueName, requestQueueName + ":tasks"),
               taskId.toString());

File: redisson/src/main/java/org/redisson/config/BaseMasterSlaveServersConfig.java
Patch:
@@ -57,7 +57,7 @@ public class BaseMasterSlaveServersConfig<T extends BaseMasterSlaveServersConfig
 
     private ReadMode readMode = ReadMode.SLAVE;
     
-    private SubscriptionMode subscriptionMode = SubscriptionMode.SLAVE;
+    private SubscriptionMode subscriptionMode = SubscriptionMode.MASTER;
     
     /**
      * Redis 'slave' node minimum idle subscription (pub/sub) connection amount for <b>each</b> slave node
@@ -314,7 +314,7 @@ public boolean checkSkipSlavesInit() {
     /**
      * Set node type used for subscription operation.
      * <p>
-     * Default is <code>SLAVE</code>
+     * Default is <code>MASTER</code>
      *
      * @param subscriptionMode param
      * @return config

File: redisson/src/test/java/org/redisson/RedissonTopicTest.java
Patch:
@@ -37,6 +37,7 @@
 import org.redisson.client.codec.LongCodec;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.config.Config;
+import org.redisson.config.SubscriptionMode;
 import org.redisson.connection.balancer.RandomLoadBalancer;
 
 public class RedissonTopicTest {
@@ -684,7 +685,7 @@ public void run() {
                 for (int i = 0; i < 100; i++) {
                     RFuture<?> f1 = redisson.getBucket("i" + i).getAsync();
                     RFuture<?> f2 = redisson.getBucket("i" + i).setAsync("");
-                    RFuture<?> f3 = redisson.getTopic("topic").publishAsync("testmsg");
+                    RFuture<?> f3 = redisson.getTopic("topic").publishAsync(1);
                     futures.add(f1);
                     futures.add(f2);
                     futures.add(f3);
@@ -716,6 +717,7 @@ public void testReattachInCluster() throws Exception {
         
         Config config = new Config();
         config.useClusterServers()
+        .setSubscriptionMode(SubscriptionMode.SLAVE)
         .setLoadBalancer(new RandomLoadBalancer())
         .addNodeAddress(process.getNodes().stream().findAny().get().getRedisServerAddressAndPort());
         RedissonClient redisson = Redisson.create(config);

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -351,7 +351,7 @@ public void operationComplete(Future<List<Map<String, String>>> future) throws E
                             slaveDown(ip, port);
                             continue;
                         }
-                        if (!isUseSameMaster(ip, port, masterHost, masterPort)) {
+                        if (masterHost.equals("?") || !isUseSameMaster(ip, port, masterHost, masterPort)) {
                             continue;
                         }
                         
@@ -367,7 +367,6 @@ protected void onSuccess(Void value) {
                             Set<String> removedSlaves = new HashSet<String>(slaves);
                             removedSlaves.removeAll(currentSlaves);
                             for (String slave : removedSlaves) {
-                                slaves.remove(slave);
                                 String[] parts = slave.replace("redis://", "").split(":");
                                 slaveDown(parts[0], parts[1]);
                             }

File: redisson/src/main/java/org/redisson/jcache/JCache.java
Patch:
@@ -598,7 +598,7 @@ public Map<K, V> getAll(Set<? extends K> keys) {
         args.add(System.currentTimeMillis());
         encode(args, keys);
 
-        Map<K, V> res = evalWrite(getName(), codec, new RedisCommand<Map<Object, Object>>("EVAL", new MapGetAllDecoder(args, 2, true), ValueType.MAP_VALUE),
+        Map<K, V> res = evalWrite(getName(), codec, new RedisCommand<Map<Object, Object>>("EVAL", new MapGetAllDecoder(new ArrayList<Object>(keys), 0), ValueType.MAP_VALUE),
                         "local expireHead = redis.call('zrange', KEYS[2], 0, 0, 'withscores');"
                       + "local accessTimeout = ARGV[1]; "
                       + "local currentTime = tonumber(ARGV[2]); "

File: redisson/src/main/java/org/redisson/api/RedissonClient.java
Patch:
@@ -972,7 +972,7 @@ public interface RedissonClient {
     /**
      * Returns {@code true} if this Redisson instance has been shut down.
      *
-     * @return code true} if this Redisson instance has been shut down overwise <code>false</code>
+     * @return {@code true} if this Redisson instance has been shut down overwise <code>false</code>
      */
     boolean isShutdown();
 

File: redisson/src/main/java/org/redisson/api/RedissonClient.java
Patch:
@@ -972,7 +972,7 @@ public interface RedissonClient {
     /**
      * Returns {@code true} if this Redisson instance has been shut down.
      *
-     * @return code true} if this Redisson instance has been shut down overwise <code>false</code>
+     * @return {@code true} if this Redisson instance has been shut down overwise <code>false</code>
      */
     boolean isShutdown();
 

File: redisson/src/main/java/org/redisson/RedissonSortedSet.java
Patch:
@@ -119,7 +119,7 @@ public RedissonSortedSet(Codec codec, CommandExecutor commandExecutor, String na
 
         comparatorHolder = redisson.getBucket(getComparatorKeyName(), StringCodec.INSTANCE);
         lock = redisson.getLock("redisson_sortedset_lock:{" + getName() + "}");
-        list = (RedissonList<V>) redisson.getList(getName());
+        list = (RedissonList<V>) redisson.getList(getName(), codec);
 
         loadComparator();
     }

File: redisson/src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -67,8 +67,6 @@ public interface ConnectionManager {
     
     IdleConnectionWatcher getConnectionWatcher();
 
-    Collection<RedisClientEntry> getClients();
-
     void shutdownAsync(RedisClient client);
 
     int calcSlot(String key);

File: redisson/src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -97,11 +97,11 @@ public interface ConnectionManager {
 
     RFuture<RedisConnection> connectionWriteOp(NodeSource source, RedisCommand<?> command);
 
-    RedisClient createClient(NodeType type, URI address, int timeout, int commandTimeout);
+    RedisClient createClient(NodeType type, URI address, int timeout, int commandTimeout, String sslHostname);
 
-    RedisClient createClient(NodeType type, InetSocketAddress address, URI uri);
+    RedisClient createClient(NodeType type, InetSocketAddress address, URI uri, String sslHostname);
     
-    RedisClient createClient(NodeType type, URI address);
+    RedisClient createClient(NodeType type, URI address, String sslHostname);
 
     MasterSlaveEntry getEntry(RedisClient redisClient);
     

File: redisson/src/main/java/org/redisson/connection/ReplicatedConnectionManager.java
Patch:
@@ -67,7 +67,7 @@ public ReplicatedConnectionManager(ReplicatedServersConfig cfg, Config config) {
         initTimer(this.config);
 
         for (URI addr : cfg.getNodeAddresses()) {
-            RFuture<RedisConnection> connectionFuture = connectToNode(cfg, addr, null);
+            RFuture<RedisConnection> connectionFuture = connectToNode(cfg, addr, null, addr.getHost());
             connectionFuture.awaitUninterruptibly();
             RedisConnection connection = connectionFuture.getNow();
             if (connection == null) {
@@ -119,7 +119,7 @@ public void run() {
                         return;
                     }
 
-                    RFuture<RedisConnection> connectionFuture = connectToNode(cfg, addr, null);
+                    RFuture<RedisConnection> connectionFuture = connectToNode(cfg, addr, null, addr.getHost());
                     connectionFuture.addListener(new FutureListener<RedisConnection>() {
                         @Override
                         public void operationComplete(Future<RedisConnection> future) throws Exception {

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -90,7 +90,7 @@ public SentinelConnectionManager(SentinelServersConfig cfg, Config config) {
         this.sentinelResolver = resolverGroup.getResolver(getGroup().next());
         
         for (URI addr : cfg.getSentinelAddresses()) {
-            RedisClient client = createClient(NodeType.SENTINEL, addr, this.config.getConnectTimeout(), this.config.getRetryInterval() * this.config.getRetryAttempts());
+            RedisClient client = createClient(NodeType.SENTINEL, addr, this.config.getConnectTimeout(), this.config.getRetryInterval() * this.config.getRetryAttempts(), null);
             try {
                 RedisConnection connection = client.connect();
                 if (!connection.isActive()) {
@@ -261,7 +261,7 @@ protected void checkState(final SentinelServersConfig cfg, final Iterator<RedisC
         }
 
         RedisClient client = iterator.next();
-        RFuture<RedisConnection> connectionFuture = connectToNode(null, null, client);
+        RFuture<RedisConnection> connectionFuture = connectToNode(null, null, client, null);
         connectionFuture.addListener(new FutureListener<RedisConnection>() {
             @Override
             public void operationComplete(Future<RedisConnection> future) throws Exception {
@@ -433,7 +433,7 @@ private RFuture<Void> registerSentinel(final URI addr, final MasterSlaveServersC
             return RedissonPromise.newSucceededFuture(null);
         }
         
-        client = createClient(NodeType.SENTINEL, addr, c.getConnectTimeout(), c.getRetryInterval() * c.getRetryAttempts());
+        client = createClient(NodeType.SENTINEL, addr, c.getConnectTimeout(), c.getRetryInterval() * c.getRetryAttempts(), null);
         RedisClient oldClient = sentinels.putIfAbsent(key, client);
         if (oldClient != null) {
             return RedissonPromise.newSucceededFuture(null);

File: redisson-tomcat/redisson-tomcat-6/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -140,7 +140,8 @@ public Session createSession(String sessionId) {
     }
 
     public RMap<String, Object> getMap(String sessionId) {
-        return redisson.getMap(keyPrefix + "redisson_tomcat_session:" + sessionId);
+        String separator = keyPrefix == null || keyPrefix.isEmpty() ? "" : ":";
+        return redisson.getMap(keyPrefix + separator + "redisson_tomcat_session:" + sessionId);
     }
     
     @Override

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -120,7 +120,8 @@ public Session createSession(String sessionId) {
     }
 
     public RMap<String, Object> getMap(String sessionId) {
-        return redisson.getMap(keyPrefix + "redisson_tomcat_session:" + sessionId);
+        String separator = keyPrefix == null || keyPrefix.isEmpty() ? "" : ":";
+        return redisson.getMap(keyPrefix + separator + "redisson_tomcat_session:" + sessionId);
     }
     
     @Override

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -119,7 +119,8 @@ public Session createSession(String sessionId) {
     }
 
     public RMap<String, Object> getMap(String sessionId) {
-        return redisson.getMap(keyPrefix + "redisson_tomcat_session:" + sessionId);
+        String separator = keyPrefix == null || keyPrefix.isEmpty() ? "" : ":";
+        return redisson.getMap(keyPrefix + separator + "redisson_tomcat_session:" + sessionId);
     }
     
     @Override

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -119,7 +119,8 @@ public Session createSession(String sessionId) {
     }
 
     public RMap<String, Object> getMap(String sessionId) {
-        return redisson.getMap(keyPrefix + "redisson_tomcat_session:" + sessionId);
+        String separator = keyPrefix == null || keyPrefix.isEmpty() ? "" : ":";
+        return redisson.getMap(keyPrefix + separator + "redisson_tomcat_session:" + sessionId);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -29,6 +29,7 @@
 import org.redisson.client.RedisPubSubListener;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.protocol.RedisCommand;
+import org.redisson.client.protocol.pubsub.PubSubType;
 import org.redisson.command.CommandSyncService;
 import org.redisson.config.Config;
 import org.redisson.config.MasterSlaveServersConfig;
@@ -112,9 +113,7 @@ public interface ConnectionManager {
 
     void unsubscribe(String channelName, AsyncSemaphore lock);
     
-    RFuture<Codec> unsubscribe(String channelName, boolean temporaryDown);
-
-    RFuture<Codec> punsubscribe(String channelName, boolean temporaryDown);
+    RFuture<Codec> unsubscribe(String channelName, PubSubType topicType);
 
     void punsubscribe(String channelName, AsyncSemaphore lock);
     

File: redisson/src/main/java/org/redisson/connection/SingleConnectionManager.java
Patch:
@@ -55,8 +55,6 @@ private static MasterSlaveServersConfig create(SingleServerConfig cfg) {
         newconfig.setSubscriptionConnectionPoolSize(cfg.getSubscriptionConnectionPoolSize());
         newconfig.setConnectTimeout(cfg.getConnectTimeout());
         newconfig.setIdleConnectionTimeout(cfg.getIdleConnectionTimeout());
-        newconfig.setFailedAttempts(cfg.getFailedAttempts());
-        newconfig.setReconnectionTimeout(cfg.getReconnectionTimeout());
         if (cfg.isDnsMonitoring()) {
             newconfig.setDnsMonitoringInterval(cfg.getDnsMonitoringInterval());
         } else {

File: redisson/src/main/java/org/redisson/connection/balancer/RandomLoadBalancer.java
Patch:
@@ -28,6 +28,7 @@
  */
 public class RandomLoadBalancer implements LoadBalancer {
 
+    @Override
     public ClientConnectionsEntry getEntry(List<ClientConnectionsEntry> clientsCopy) {
         int ind = PlatformDependent.threadLocalRandom().nextInt(clientsCopy.size());
         return clientsCopy.get(ind);

File: redisson/src/test/java/org/redisson/RedissonBlockingQueueTest.java
Patch:
@@ -38,7 +38,7 @@ <T> RBlockingQueue<T> getQueue(RedissonClient redisson) {
         return redisson.getBlockingQueue("queue");
     }
     
-    @Test
+//    @Test
     public void testPollWithBrokenConnection() throws IOException, InterruptedException, ExecutionException {
         RedisProcess runner = new RedisRunner()
                 .nosave()
@@ -285,7 +285,7 @@ public void testPoll() throws InterruptedException {
 
         long s = System.currentTimeMillis();
         Assert.assertNull(queue1.poll(5, TimeUnit.SECONDS));
-        Assert.assertTrue(System.currentTimeMillis() - s > 5000);
+        Assert.assertTrue(System.currentTimeMillis() - s > 4900);
     }
     @Test
     public void testAwait() throws InterruptedException {

File: redisson/src/test/java/org/redisson/spring/support/SpringNamespaceWikiTest.java
Patch:
@@ -135,8 +135,6 @@ public void testSingleWithPlaceholder() throws Exception {
             assertEquals(40000, single.getTimeout());
             assertEquals(5, single.getRetryAttempts());
             assertEquals(60000, single.getRetryInterval());
-            assertEquals(70000, single.getReconnectionTimeout());
-            assertEquals(8, single.getFailedAttempts());
             assertEquals("do_not_use_if_it_is_not_set", single.getPassword());
             assertEquals(10, single.getSubscriptionsPerConnection());
             assertEquals("client_name", single.getClientName());

File: redisson-tomcat/redisson-tomcat-6/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -140,7 +140,8 @@ public Session createSession(String sessionId) {
     }
 
     public RMap<String, Object> getMap(String sessionId) {
-        return redisson.getMap(keyPrefix + "redisson_tomcat_session:" + sessionId);
+        String separator = keyPrefix == null || keyPrefix.isEmpty() ? "" : ":";
+        return redisson.getMap(keyPrefix + separator + "redisson_tomcat_session:" + sessionId);
     }
     
     @Override

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -120,7 +120,8 @@ public Session createSession(String sessionId) {
     }
 
     public RMap<String, Object> getMap(String sessionId) {
-        return redisson.getMap(keyPrefix + "redisson_tomcat_session:" + sessionId);
+        String separator = keyPrefix == null || keyPrefix.isEmpty() ? "" : ":";
+        return redisson.getMap(keyPrefix + separator + "redisson_tomcat_session:" + sessionId);
     }
     
     @Override

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -119,7 +119,8 @@ public Session createSession(String sessionId) {
     }
 
     public RMap<String, Object> getMap(String sessionId) {
-        return redisson.getMap(keyPrefix + "redisson_tomcat_session:" + sessionId);
+        String separator = keyPrefix == null || keyPrefix.isEmpty() ? "" : ":";
+        return redisson.getMap(keyPrefix + separator + "redisson_tomcat_session:" + sessionId);
     }
     
     @Override

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -119,7 +119,8 @@ public Session createSession(String sessionId) {
     }
 
     public RMap<String, Object> getMap(String sessionId) {
-        return redisson.getMap(keyPrefix + "redisson_tomcat_session:" + sessionId);
+        String separator = keyPrefix == null || keyPrefix.isEmpty() ? "" : ":";
+        return redisson.getMap(keyPrefix + separator + "redisson_tomcat_session:" + sessionId);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/RedissonRedLock.java
Patch:
@@ -51,7 +51,7 @@ protected int minLocksAmount(final List<RLock> locks) {
 
     @Override
     protected long calcLockWaitTime(long remainTime) {
-        return Math.max(remainTime / locks.size(), 1000);
+        return Math.max(remainTime / locks.size(), 1);
     }
     
     @Override

File: redisson/src/main/java/org/redisson/jcache/JCache.java
Patch:
@@ -1442,7 +1442,7 @@ public boolean remove(K key, V value) {
 
     private V getAndRemoveValue(K key) {
         double syncId = PlatformDependent.threadLocalRandom().nextDouble();
-        List<Object> result = evalWrite(getName(), codec, RedisCommands.EVAL_MAP_VALUE,
+        List<Object> result = evalWrite(getName(), codec, RedisCommands.EVAL_MAP_VALUE_LIST,
                 "local value = redis.call('hget', KEYS[1], ARGV[2]); "
               + "if value == false then "
                   + "return {nil}; "

File: redisson/src/main/java/org/redisson/api/RedissonClient.java
Patch:
@@ -928,12 +928,12 @@ public interface RedissonClient {
     /**
      * Shutdown Redisson instance but <b>NOT</b> Redis server
      * 
-     * This equates to invoke shutdown(2, 15, TimeUnit.SECONDS);
+     * This equates to invoke shutdown(0, 2, TimeUnit.SECONDS);
      */
     void shutdown();
     
     /**
-     * Shuts down Redisson instance <b>NOT</b> Redis server
+     * Shuts down Redisson instance but <b>NOT</b> Redis server
      * 
      * Shutdown ensures that no tasks are submitted for <i>'the quiet period'</i>
      * (usually a couple seconds) before it shuts itself down.  If a task is submitted during the quiet period,

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -923,7 +923,7 @@ public void releaseRead(NodeSource source, RedisConnection connection) {
 
     @Override
     public void shutdown() {
-        shutdown(2, 15, TimeUnit.SECONDS);//default netty value
+        shutdown(0, 2, TimeUnit.SECONDS);//default netty value
     }
 
     @Override

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -269,13 +269,13 @@ public void operationComplete(Future<List<Map<String, String>>> future) throws E
                         String masterHost = map.get("master-host");
                         String masterPort = map.get("master-port");
                         
-                        if (!isUseSameMaster(ip, port, masterHost, masterPort)) {
-                            continue;
-                        }
                         if (flags.contains("s_down") || flags.contains("disconnected")) {
                             slaveDown(ip, port);
                             continue;
                         }
+                        if (!isUseSameMaster(ip, port, masterHost, masterPort)) {
+                            continue;
+                        }
                         
                         String slaveAddr = createAddress(ip, port);
                         currentSlaves.add(slaveAddr);

File: redisson/src/main/java/org/redisson/config/Config.java
Patch:
@@ -27,6 +27,7 @@
 import org.redisson.codec.JsonJacksonCodec;
 import org.redisson.codec.ReferenceCodecProvider;
 import org.redisson.connection.ConnectionManager;
+import org.redisson.connection.DnsAddressResolverGroupFactory;
 import org.redisson.connection.AddressResolverGroupFactory;
 import org.redisson.connection.ReplicatedConnectionManager;
 
@@ -90,7 +91,7 @@ public class Config {
     /**
      * AddressResolverGroupFactory switch between default and round robin
      */
-    private AddressResolverGroupFactory addressResolverGroupFactory = AddressResolverGroupFactory.DNS_ADDRESS_RESOLVER_GROUP;
+    private AddressResolverGroupFactory addressResolverGroupFactory = new DnsAddressResolverGroupFactory();
 
     public Config() {
     }
@@ -601,6 +602,7 @@ public boolean isKeepPubSubOrder() {
     /**
      * Used to switch between {@link io.netty.resolver.dns.DnsAddressResolverGroup} implementations.
      * Switch to round robin {@link io.netty.resolver.dns.RoundRobinDnsAddressResolverGroup} when you need to optimize the url resolving.
+     * 
      * @param addressResolverGroupFactory
      */
     public void setAddressResolverGroupFactory(AddressResolverGroupFactory addressResolverGroupFactory) {

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -1190,7 +1190,7 @@ public void operationComplete(Future<V> future) throws Exception {
     }
 
     @Override
-    protected ByteBuf encode(Object value) {
+    public ByteBuf encode(Object value) {
         try {
             return topicCodec.getValueEncoder().encode(value);
         } catch (IOException e) {

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -1190,7 +1190,7 @@ public void operationComplete(Future<V> future) throws Exception {
     }
 
     @Override
-    protected ByteBuf encode(Object value) {
+    public ByteBuf encode(Object value) {
         try {
             return topicCodec.getValueEncoder().encode(value);
         } catch (IOException e) {

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -672,7 +672,9 @@ private <V, R> void checkWriteFuture(final AsyncDetails<V, R> details, final Red
                     "Unable to send command! Node source: " + details.getSource() + ", connection: " + future.channel() + 
                     ", command: " + details.getCommand() + ", params: " + LogHelper.toString(details.getParams()), future.cause()));
             if (details.getAttempt() == connectionManager.getConfig().getRetryAttempts()) {
-                details.getAttemptPromise().tryFailure(details.getException());
+                if (!details.getAttemptPromise().tryFailure(details.getException())) {
+                    log.error(details.getException().getMessage());
+                }
             }
             return;
         }

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -668,9 +668,9 @@ private <V, R> void checkWriteFuture(final AsyncDetails<V, R> details, final Red
         }
 
         if (!future.isSuccess()) {
-            log.trace("Can't write {} to {}", details.getCommand(), connection);
             details.setException(new WriteRedisConnectionException(
-                    "Can't write command: " + details.getCommand() + ", params: " + LogHelper.toString(details.getParams()) + " to channel: " + future.channel(), future.cause()));
+                    "Unable to send command! Node source: " + details.getSource() + ", connection: " + future.channel() + 
+                    ", command: " + details.getCommand() + ", params: " + LogHelper.toString(details.getParams()), future.cause()));
             if (details.getAttempt() == connectionManager.getConfig().getRetryAttempts()) {
                 details.getAttemptPromise().tryFailure(details.getException());
             }

File: redisson-tomcat/redisson-tomcat-6/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -152,6 +152,9 @@ public Session findSession(String id) throws IOException {
             session.endAccess();
             return session;
         }
+
+        result.access();
+        result.endAccess();
         
         return result;
     }

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -132,6 +132,9 @@ public Session findSession(String id) throws IOException {
             return session;
         }
         
+        result.access();
+        result.endAccess();
+        
         return result;
     }
     

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -131,6 +131,9 @@ public Session findSession(String id) throws IOException {
             session.endAccess();
             return session;
         }
+
+        result.access();
+        result.endAccess();
         
         return result;
     }

File: redisson-tomcat/redisson-tomcat-9/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -132,6 +132,9 @@ public Session findSession(String id) throws IOException {
             return session;
         }
         
+        result.access();
+        result.endAccess();
+        
         return result;
     }
     

File: redisson/src/main/java/org/redisson/api/RExpirable.java
Patch:
@@ -64,7 +64,7 @@ public interface RExpirable extends RObject, RExpirableAsync {
     boolean clearExpire();
 
     /**
-     * Remaining time to live of Redisson object that has a timeout
+     * Remaining time to live of Redisson object that has a timeout 
      *
      * @return time in milliseconds
      *          -2 if the key does not exist.

File: redisson/src/main/java/org/redisson/api/LocalCachedMapOptions.java
Patch:
@@ -65,12 +65,12 @@ public enum SyncStrategy {
         NONE,
         
         /**
-         * Invalidate cache entry across all LocalCachedMap instances on map entry change.
+         * Invalidate cache entry across all LocalCachedMap instances on map entry change. Broadcasts map entry hash (16 bytes) to all instances.
          */
         INVALIDATE,
         
         /**
-         * Update cache entry across all LocalCachedMap instances on map entry change.
+         * Update cache entry across all LocalCachedMap instances on map entry change. Broadcasts full map entry state (Key and Value objects) to all instances.
          */
         UPDATE
         

File: redisson/src/main/java/org/redisson/config/ReplicatedServersConfig.java
Patch:
@@ -77,7 +77,7 @@ public int getScanInterval() {
         return scanInterval;
     }
     /**
-     * Elasticache node scan interval in milliseconds
+     * Replication group scan interval in milliseconds
      *
      * @param scanInterval in milliseconds
      * @return config

File: redisson/src/main/java/org/redisson/client/protocol/BatchCommandData.java
Patch:
@@ -19,6 +19,7 @@
 
 import org.redisson.client.RedisRedirectException;
 import org.redisson.client.codec.Codec;
+import org.redisson.client.codec.StringCodec;
 import org.redisson.misc.RPromise;
 import org.redisson.misc.RedissonPromise;
 
@@ -35,7 +36,7 @@ public class BatchCommandData<T, R> extends CommandData<T, R> implements Compara
     private final AtomicReference<RedisRedirectException> redirectError = new AtomicReference<RedisRedirectException>();
     
     public BatchCommandData(RedisCommand<T> command, Object[] params, int index) {
-        this(new RedissonPromise<R>(), null, command, params, index);
+        this(new RedissonPromise<R>(), StringCodec.INSTANCE, command, params, index);
     }
     
     public BatchCommandData(RPromise<R> promise, Codec codec, RedisCommand<T> command, Object[] params, int index) {

File: redisson/src/main/java/org/redisson/client/codec/JsonJacksonMapCodec.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.OutputStream;
 
 import org.redisson.client.handler.State;
 import org.redisson.client.protocol.Decoder;
@@ -52,7 +53,7 @@ public ByteBuf encode(Object in) throws IOException {
             ByteBuf out = ByteBufAllocator.DEFAULT.buffer();
             try {
                 ByteBufOutputStream os = new ByteBufOutputStream(out);
-                mapper.writeValue(os, in);
+                mapper.writeValue((OutputStream)os, in);
                 return os.buffer();
             } catch (IOException e) {
                 out.release();

File: redisson/src/main/java/org/redisson/codec/JsonJacksonCodec.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.OutputStream;
 
 import javax.xml.datatype.XMLGregorianCalendar;
 
@@ -72,7 +73,7 @@ public ByteBuf encode(Object in) throws IOException {
             ByteBuf out = ByteBufAllocator.DEFAULT.buffer();
             try {
                 ByteBufOutputStream os = new ByteBufOutputStream(out);
-                mapObjectMapper.writeValue(os, in);
+                mapObjectMapper.writeValue((OutputStream)os, in);
                 return os.buffer();
             } catch (IOException e) {
                 out.release();

File: redisson/src/main/java/org/redisson/liveobject/core/AccessorInterceptor.java
Patch:
@@ -83,6 +83,9 @@ public Object intercept(@Origin Method method, @SuperCall Callable<?> superMetho
                 }
             }
             
+            if (result != null && fieldType.isEnum()) {
+                return Enum.valueOf((Class)fieldType, (String)result);
+            }
             if (result instanceof RedissonReference) {
                 return RedissonObjectFactory.fromReference(redisson, (RedissonReference) result);
             }

File: redisson/src/test/java/org/redisson/RedissonListMultimapTest.java
Patch:
@@ -161,7 +161,7 @@ public void testKeySize() {
 
     @Test
     public void testPut() {
-        RListMultimap<SimpleKey, SimpleValue> map = redisson.getListMultimap("test1");
+        RListMultimap<SimpleKey, SimpleValue> map = redisson.getListMultimap("{multi.map}.some.key");
         map.put(new SimpleKey("0"), new SimpleValue("1"));
         map.put(new SimpleKey("0"), new SimpleValue("2"));
         map.put(new SimpleKey("0"), new SimpleValue("3"));
@@ -219,7 +219,7 @@ public void testContainsKey() {
 
     @Test
     public void testContainsValue() {
-        RListMultimap<SimpleKey, SimpleValue> map = redisson.getListMultimap("test1");
+        RListMultimap<SimpleKey, SimpleValue> map = redisson.getListMultimap("{1}test1");
         map.put(new SimpleKey("0"), new SimpleValue("1"));
 
         assertThat(map.containsValue(new SimpleValue("1"))).isTrue();

File: redisson/src/main/java/org/redisson/api/annotation/RCascade.java
Patch:
@@ -34,6 +34,8 @@
 
     /**
      * List of applied cascade types.
+     * 
+     * @return value
      */
     RCascadeType[] value();
     

File: redisson/src/main/java/org/redisson/api/annotation/RFieldAccessor.java
Patch:
@@ -25,11 +25,11 @@
  * Example:
  * <pre>
  *       &#064;RFieldAccessor
- *       public <T> void set(String field, T value) {
+ *       public void set(String field, T value) {
  *       }
  *       
  *       &#064;RFieldAccessor
- *       public <T> T get(String field) {
+ *       public Object get(String field) {
  *           return null;
  *       }
  * </pre>

File: redisson/src/main/java/org/redisson/codec/JsonJacksonCodec.java
Patch:
@@ -103,9 +103,9 @@ protected static ObjectMapper createObjectMapper(ClassLoader classLoader, Object
     }
 
     public JsonJacksonCodec(ObjectMapper mapObjectMapper) {
-        this.mapObjectMapper = mapObjectMapper;
-        init(mapObjectMapper);
-        initTypeInclusion(mapObjectMapper);
+        this.mapObjectMapper = mapObjectMapper.copy();
+        init(this.mapObjectMapper);
+        initTypeInclusion(this.mapObjectMapper);
     }
 
     protected void initTypeInclusion(ObjectMapper mapObjectMapper) {

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -294,7 +294,7 @@ public <R, T> RFuture<R> readAllAsync(RedisCommand<T> command, SlotCallback<T, R
         return allAsync(true, command, callback, params);
     }
 
-    private <T, R> RFuture<R> allAsync(boolean readOnlyMode, RedisCommand<T> command, final SlotCallback<T, R> callback, Object... params) {
+    private <T, R> RFuture<R> allAsync(boolean readOnlyMode, final RedisCommand<T> command, final SlotCallback<T, R> callback, Object... params) {
         final RPromise<R> mainPromise = new RedissonPromise<R>();
         final Collection<MasterSlaveEntry> nodes = connectionManager.getEntrySet();
         final AtomicInteger counter = new AtomicInteger(nodes.size());
@@ -788,7 +788,7 @@ public void operationComplete(Future<R> future) throws Exception {
     }
 
     private <R, V> void checkAttemptFuture(final NodeSource source, final AsyncDetails<V, R> details,
-            Future<R> future, boolean ignoreRedirect) {
+            Future<R> future, final boolean ignoreRedirect) {
         details.getTimeout().cancel();
         if (future.isCancelled()) {
             return;

File: redisson/src/main/java/org/redisson/RedissonDoubleAdder.java
Patch:
@@ -15,12 +15,13 @@
  */
 package org.redisson;
 
+import java.util.concurrent.atomic.DoubleAdder;
+
 import org.redisson.api.RAtomicDouble;
 import org.redisson.api.RDoubleAdder;
 import org.redisson.api.RFuture;
 import org.redisson.api.RedissonClient;
 import org.redisson.command.CommandAsyncExecutor;
-import org.redisson.misc.DoubleAdder;
 
 /**
  * 

File: redisson/src/main/java/org/redisson/RedissonObject.java
Patch:
@@ -57,14 +57,14 @@ protected boolean await(RFuture<?> future, long timeout, TimeUnit timeoutUnit) t
         return commandExecutor.await(future, timeout, timeoutUnit);
     }
     
-    protected String prefixName(String prefix, String name) {
+    protected static String prefixName(String prefix, String name) {
         if (name.contains("{")) {
             return prefix + ":" + name;
         }
         return prefix + ":{" + name + "}";
     }
     
-    protected String suffixName(String name, String suffix) {
+    protected static String suffixName(String name, String suffix) {
         if (name.contains("{")) {
             return name + ":" + suffix;
         }

File: redisson/src/main/java/org/redisson/RedissonDoubleAdder.java
Patch:
@@ -15,13 +15,12 @@
  */
 package org.redisson;
 
-import java.util.concurrent.atomic.DoubleAdder;
-
 import org.redisson.api.RAtomicDouble;
 import org.redisson.api.RDoubleAdder;
 import org.redisson.api.RFuture;
 import org.redisson.api.RedissonClient;
 import org.redisson.command.CommandAsyncExecutor;
+import org.redisson.misc.DoubleAdder;
 
 /**
  * 

File: redisson/src/main/java/org/redisson/RedissonReadLock.java
Patch:
@@ -87,6 +87,8 @@ <T> RFuture<T> tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, R
     @Override
     protected RFuture<Boolean> unlockInnerAsync(long threadId) {
         String timeoutPrefix = getReadWriteTimeoutNamePrefix(threadId);
+        String keyPrefix = timeoutPrefix.split(":" + getLockName(threadId))[0];
+
         return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 "local mode = redis.call('hget', KEYS[1], 'mode'); " +
                 "if (mode == false) then " +
@@ -129,7 +131,7 @@ protected RFuture<Boolean> unlockInnerAsync(long threadId) {
                 "redis.call('del', KEYS[1]); " +
                 "redis.call('publish', KEYS[2], ARGV[1]); " +
                 "return 1; ",
-                Arrays.<Object>asList(getName(), getChannelName(), timeoutPrefix, timeoutPrefix.split(":")[0]), 
+                Arrays.<Object>asList(getName(), getChannelName(), timeoutPrefix, keyPrefix), 
                 LockPubSub.unlockMessage, getLockName(threadId));
     }
     

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -294,9 +294,9 @@ public interface RedisCommands {
     RedisCommand<Boolean> SETNX = new RedisCommand<Boolean>("SETNX", new BooleanReplayConvertor());
     RedisCommand<Void> PSETEX = new RedisCommand<Void>("PSETEX", new VoidReplayConvertor());
     
-    RedisStrictCommand<Long> TOUCH_LONG = new RedisStrictCommand<Long>("TOUCH");
+    RedisStrictCommand<Long> TOUCH_LONG = new RedisStrictCommand<Long>("TOUCH", new LongReplayConvertor());
     RedisStrictCommand<Boolean> TOUCH = new RedisStrictCommand<Boolean>("TOUCH", new BooleanReplayConvertor());
-    RedisStrictCommand<Long> EXISTS_LONG = new RedisStrictCommand<Long>("EXISTS");
+    RedisStrictCommand<Long> EXISTS_LONG = new RedisStrictCommand<Long>("EXISTS", new LongReplayConvertor());
     RedisStrictCommand<Boolean> EXISTS = new RedisStrictCommand<Boolean>("EXISTS", new BooleanReplayConvertor());
     RedisStrictCommand<Boolean> NOT_EXISTS = new RedisStrictCommand<Boolean>("EXISTS", new BooleanNumberReplayConvertor(1L));
 

File: redisson/src/main/java/org/redisson/command/CommandBatchService.java
Patch:
@@ -111,7 +111,7 @@ public void add(RFuture<?> future, List<CommandBatchService> services) {
     
     @Override
     protected <V, R> void async(boolean readOnlyMode, NodeSource nodeSource,
-            Codec codec, RedisCommand<V> command, Object[] params, RPromise<R> mainPromise, int attempt) {
+            Codec codec, RedisCommand<V> command, Object[] params, RPromise<R> mainPromise, int attempt, boolean ignoreRedirect) {
         if (executed) {
             throw new IllegalStateException("Batch already has been executed!");
         }

File: redisson/src/main/java/org/redisson/command/CommandReactiveBatchService.java
Patch:
@@ -57,8 +57,8 @@ public <R> Publisher<R> reactive(Supplier<RFuture<R>> supplier) {
     
     @Override
     protected <V, R> void async(boolean readOnlyMode, NodeSource nodeSource,
-            Codec codec, RedisCommand<V> command, Object[] params, RPromise<R> mainPromise, int attempt) {
-        batchService.async(readOnlyMode, nodeSource, codec, command, params, mainPromise, attempt);
+            Codec codec, RedisCommand<V> command, Object[] params, RPromise<R> mainPromise, int attempt, boolean ignoreRedirect) {
+        batchService.async(readOnlyMode, nodeSource, codec, command, params, mainPromise, attempt, ignoreRedirect);
     }
 
     public RFuture<BatchResult<?>> executeAsync(int syncSlaves, long syncTimeout, boolean skipResult, long responseTimeout, int retryAttempts, long retryInterval, boolean atomic) {

File: redisson/src/main/java/org/redisson/RedissonObject.java
Patch:
@@ -57,14 +57,14 @@ protected boolean await(RFuture<?> future, long timeout, TimeUnit timeoutUnit) t
         return commandExecutor.await(future, timeout, timeoutUnit);
     }
     
-    protected String prefixName(String prefix, String name) {
+    protected static String prefixName(String prefix, String name) {
         if (name.contains("{")) {
             return prefix + ":" + name;
         }
         return prefix + ":{" + name + "}";
     }
     
-    protected String suffixName(String name, String suffix) {
+    protected static String suffixName(String name, String suffix) {
         if (name.contains("{")) {
             return name + ":" + suffix;
         }

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -428,7 +428,7 @@ protected static byte[] generateLogEntryId(byte[] keyHash) {
     @Override
     protected RFuture<V> putOperationAsync(K key, V value) {
         ByteBuf mapKey = encodeMapKey(key);
-        ByteBuf mapValue = encodeMapKey(value);
+        ByteBuf mapValue = encodeMapValue(value);
         CacheKey cacheKey = toCacheKey(mapKey);
         byte[] entryId = generateLogEntryId(cacheKey.getKeyHash());
         ByteBuf msg = createSyncMessage(mapKey, mapValue, cacheKey);
@@ -446,7 +446,7 @@ protected RFuture<V> putOperationAsync(K key, V value) {
                 + "end;"
                 + "return v; ",
                 Arrays.<Object>asList(getName(), invalidationTopic.getChannelNames().get(0), getUpdatesLogName()), 
-                mapKey, encodeMapValue(value), msg, invalidateEntryOnChange, System.currentTimeMillis(), entryId);
+                mapKey, mapValue, msg, invalidateEntryOnChange, System.currentTimeMillis(), entryId);
     }
 
     protected ByteBuf createSyncMessage(ByteBuf mapKey, ByteBuf mapValue, CacheKey cacheKey) {

File: redisson/src/main/java/org/redisson/api/RMapAsync.java
Patch:
@@ -35,7 +35,7 @@
 public interface RMapAsync<K, V> extends RExpirableAsync {
 
     /**
-     * Loads all map entries to this Redis map.
+     * Loads all map entries to this Redis map using {@link org.redisson.api.map.MapLoader}.
      * 
      * @param replaceExistingValues - <code>true</code> if existed values should be replaced, <code>false</code> otherwise.  
      * @param parallelism - parallelism level, used to increase speed of process execution
@@ -44,7 +44,7 @@ public interface RMapAsync<K, V> extends RExpirableAsync {
     RFuture<Void> loadAllAsync(boolean replaceExistingValues, int parallelism);
     
     /**
-     * Loads map entries whose keys are listed in defined <code>keys</code> parameter.
+     * Loads map entries using {@link org.redisson.api.map.MapLoader} whose keys are listed in defined <code>keys</code> parameter.
      * 
      * @param keys - map keys
      * @param replaceExistingValues - <code>true</code> if existed values should be replaced, <code>false</code> otherwise.

File: redisson/src/main/java/org/redisson/api/RMapReactive.java
Patch:
@@ -35,7 +35,7 @@
 public interface RMapReactive<K, V> extends RExpirableReactive {
 
     /**
-     * Loads all map entries to this Redis map.
+     * Loads all map entries to this Redis map using {@link org.redisson.api.map.MapLoader}.
      * 
      * @param replaceExistingValues - <code>true</code> if existed values should be replaced, <code>false</code> otherwise.  
      * @param parallelism - parallelism level, used to increase speed of process execution
@@ -44,7 +44,7 @@ public interface RMapReactive<K, V> extends RExpirableReactive {
     Publisher<Void> loadAll(boolean replaceExistingValues, int parallelism);
     
     /**
-     * Loads map entries whose keys are listed in defined <code>keys</code> parameter.
+     * Loads map entries using {@link org.redisson.api.map.MapLoader} whose keys are listed in defined <code>keys</code> parameter.
      * 
      * @param keys - map keys
      * @param replaceExistingValues - <code>true</code> if existed values should be replaced, <code>false</code> otherwise.

File: redisson/src/main/java/org/redisson/api/RLiveObjectService.java
Patch:
@@ -162,7 +162,7 @@ public interface RLiveObjectService {
     <T> boolean isLiveObject(T instance);
     
     /**
-     * Returns true if the RLiveObject does not yet exist in redis. Also true if
+     * Returns true if the RLiveObject already exists in redis. It will return false if
      * the passed object is not a RLiveObject.
      * 
      * @param <T> type of instance

File: redisson/src/main/java/org/redisson/BaseRemoteService.java
Patch:
@@ -77,7 +77,7 @@ public abstract class BaseRemoteService {
     private static final Logger log = LoggerFactory.getLogger(BaseRemoteService.class);
 
     private final Map<Class<?>, String> requestQueueNameCache = PlatformDependent.newConcurrentHashMap();
-    private final Map<Method, List<String>> methodSignaturesCache = PlatformDependent.newConcurrentHashMap();
+    private final ConcurrentMap<Method, List<String>> methodSignaturesCache = PlatformDependent.newConcurrentHashMap();
 
     protected final Codec codec;
     protected final RedissonClient redisson;

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -375,6 +375,7 @@ public void operationComplete(Future<List<InetSocketAddress>> future) throws Exc
                     
                     checkClusterState(cfg, nodesIterator, lastException);
                 }
+            }
 
         }, cfg.getScanInterval(), TimeUnit.MILLISECONDS);
     }

File: redisson-tomcat/redisson-tomcat-8/src/test/java/org/redisson/tomcat/TomcatServer.java
Patch:
@@ -28,7 +28,7 @@ public TomcatServer(String contextPath, int port, String appBase) throws Malform
 
         tomcat.setBaseDir("."); // location where temp dir is created
         tomcat.setPort(port);
-        tomcat.getHost().setAppBase(appBase);
+        tomcat.getHost().setAppBase(".");
 
         tomcat.addWebapp(contextPath, appBase + "webapp");
     }

File: redisson/src/main/java/org/redisson/connection/pool/ConnectionPool.java
Patch:
@@ -325,7 +325,7 @@ private void promiseFailure(ClientConnectionsEntry entry, RPromise<T> promise, T
 
     private void checkForReconnect(ClientConnectionsEntry entry, Throwable cause) {
         if (entry.getNodeType() == NodeType.SLAVE) {
-            masterSlaveEntry.slaveDown(entry.getClient().getConfig().getAddress(), FreezeReason.RECONNECT);
+            masterSlaveEntry.slaveDown(entry, FreezeReason.RECONNECT);
             log.error("slave " + entry.getClient().getAddr() + " disconnected due to failedAttempts=" + config.getFailedAttempts() + " limit reached", cause);
             scheduleCheck(entry);
         } else {
@@ -392,7 +392,7 @@ public void operationComplete(Future<String> future) throws Exception {
                                             public void operationComplete(Future<Void> future)
                                                 throws Exception {
                                                 if (entry.getNodeType() == NodeType.SLAVE) {
-                                                    masterSlaveEntry.slaveUp(entry.getClient().getConfig().getAddress(), FreezeReason.RECONNECT);
+                                                    masterSlaveEntry.slaveUp(entry, FreezeReason.RECONNECT);
                                                     log.info("slave {} has been successfully reconnected", entry.getClient().getAddr());
                                                 } else {
                                                     synchronized (entry) {

File: redisson/src/main/java/org/redisson/RedissonBaseIterator.java
Patch:
@@ -15,12 +15,12 @@
  */
 package org.redisson;
 
-import java.net.InetSocketAddress;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
 
+import org.redisson.client.RedisClient;
 import org.redisson.client.protocol.decoder.ListScanResult;
 import org.redisson.client.protocol.decoder.ScanObjectEntry;
 
@@ -38,7 +38,7 @@ abstract class RedissonBaseIterator<V> implements Iterator<V> {
     private List<ByteBuf> lastValues;
     private Iterator<ScanObjectEntry> lastIter;
     protected long nextIterPos;
-    protected InetSocketAddress client;
+    protected RedisClient client;
 
     private boolean finished;
     private boolean currentElementRemoved;
@@ -145,7 +145,7 @@ protected boolean tryAgain() {
         return false;
     }
 
-    abstract ListScanResult<ScanObjectEntry> iterator(InetSocketAddress client, long nextIterPos);
+    abstract ListScanResult<ScanObjectEntry> iterator(RedisClient client, long nextIterPos);
 
     @Override
     public V next() {

File: redisson/src/main/java/org/redisson/RedissonBaseMapIterator.java
Patch:
@@ -15,14 +15,14 @@
  */
 package org.redisson;
 
-import java.net.InetSocketAddress;
 import java.util.AbstractMap;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.NoSuchElementException;
 
+import org.redisson.client.RedisClient;
 import org.redisson.client.protocol.decoder.MapScanResult;
 import org.redisson.client.protocol.decoder.ScanObjectEntry;
 
@@ -42,7 +42,7 @@ public abstract class RedissonBaseMapIterator<K, V, M> implements Iterator<M> {
     private Map<ByteBuf, ByteBuf> lastValues;
     private Iterator<Map.Entry<ScanObjectEntry, ScanObjectEntry>> lastIter;
     protected long nextIterPos;
-    protected InetSocketAddress client;
+    protected RedisClient client;
 
     private boolean finished;
     private boolean currentElementRemoved;

File: redisson/src/main/java/org/redisson/RedissonKeys.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.redisson;
 
-import java.net.InetSocketAddress;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
@@ -31,6 +30,7 @@
 import org.redisson.api.RKeys;
 import org.redisson.api.RObject;
 import org.redisson.api.RType;
+import org.redisson.client.RedisClient;
 import org.redisson.client.RedisException;
 import org.redisson.client.codec.ScanCodec;
 import org.redisson.client.codec.StringCodec;
@@ -107,7 +107,7 @@ public Iterable<String> getKeys() {
         return getKeysByPattern(null);
     }
 
-    private ListScanResult<ScanObjectEntry> scanIterator(InetSocketAddress client, MasterSlaveEntry entry, long startPos, String pattern, int count) {
+    private ListScanResult<ScanObjectEntry> scanIterator(RedisClient client, MasterSlaveEntry entry, long startPos, String pattern, int count) {
         if (pattern == null) {
             RFuture<ListScanResult<ScanObjectEntry>> f = commandExecutor.readAsync(client, entry, new ScanCodec(StringCodec.INSTANCE), RedisCommands.SCAN, startPos, "COUNT", count);
             return commandExecutor.get(f);
@@ -120,7 +120,7 @@ private Iterator<String> createKeysIterator(final MasterSlaveEntry entry, final
         return new RedissonBaseIterator<String>() {
 
             @Override
-            ListScanResult<ScanObjectEntry> iterator(InetSocketAddress client, long nextIterPos) {
+            ListScanResult<ScanObjectEntry> iterator(RedisClient client, long nextIterPos) {
                 return RedissonKeys.this.scanIterator(client, entry, nextIterPos, pattern, count);
             }
 

File: redisson/src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -16,7 +16,6 @@
 package org.redisson;
 
 import java.math.BigDecimal;
-import java.net.InetSocketAddress;
 import java.util.AbstractCollection;
 import java.util.AbstractSet;
 import java.util.ArrayList;
@@ -40,6 +39,7 @@
 import org.redisson.api.RReadWriteLock;
 import org.redisson.api.RedissonClient;
 import org.redisson.api.mapreduce.RMapReduce;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.codec.LongCodec;
 import org.redisson.client.codec.MapScanCodec;
@@ -949,7 +949,7 @@ public long fastRemove(K ... keys) {
         return get(fastRemoveAsync(keys));
     }
 
-    MapScanResult<ScanObjectEntry, ScanObjectEntry> scanIterator(String name, InetSocketAddress client, long startPos, String pattern) {
+    MapScanResult<ScanObjectEntry, ScanObjectEntry> scanIterator(String name, RedisClient client, long startPos, String pattern) {
         if (pattern == null) {
             RFuture<MapScanResult<ScanObjectEntry, ScanObjectEntry>> f 
                                     = commandExecutor.readAsync(client, name, new MapScanCodec(codec), RedisCommands.HSCAN, name, startPos);

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -37,6 +37,7 @@
 import org.redisson.api.map.event.EntryRemovedListener;
 import org.redisson.api.map.event.EntryUpdatedListener;
 import org.redisson.api.map.event.MapEntryListener;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.codec.LongCodec;
 import org.redisson.client.codec.MapScanCodec;
@@ -1169,11 +1170,11 @@ protected RFuture<Long> fastRemoveOperationAsync(K ... keys) {
     }
 
     @Override
-    MapScanResult<ScanObjectEntry, ScanObjectEntry> scanIterator(String name, InetSocketAddress client, long startPos, String pattern) {
+    MapScanResult<ScanObjectEntry, ScanObjectEntry> scanIterator(String name, RedisClient client, long startPos, String pattern) {
         return get(scanIteratorAsync(name, client, startPos, pattern));
     }
 
-    public RFuture<MapScanResult<ScanObjectEntry, ScanObjectEntry>> scanIteratorAsync(final String name, InetSocketAddress client, long startPos, String pattern) {
+    public RFuture<MapScanResult<ScanObjectEntry, ScanObjectEntry>> scanIteratorAsync(final String name, RedisClient client, long startPos, String pattern) {
         List<Object> params = new ArrayList<Object>();
         params.add(System.currentTimeMillis());
         params.add(startPos);

File: redisson/src/main/java/org/redisson/RedissonMultiMapIterator.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.Map.Entry;
 import java.util.NoSuchElementException;
 
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.protocol.decoder.MapScanResult;
 import org.redisson.client.protocol.decoder.ScanObjectEntry;
@@ -40,7 +41,7 @@ abstract class RedissonMultiMapIterator<K, V, M> implements Iterator<M> {
     private Iterator<V> valuesIter;
     protected long valuesIterPos = 0;
 
-    protected InetSocketAddress client;
+    protected RedisClient client;
 
     private boolean finished;
     private boolean removeExecuted;

File: redisson/src/main/java/org/redisson/RedissonMultimap.java
Patch:
@@ -33,6 +33,7 @@
 import org.redisson.api.RLock;
 import org.redisson.api.RMultimap;
 import org.redisson.api.RReadWriteLock;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.codec.LongCodec;
 import org.redisson.client.codec.MapScanCodec;
@@ -298,7 +299,7 @@ public RFuture<Integer> keySizeAsync() {
     }
     
     
-    MapScanResult<ScanObjectEntry, ScanObjectEntry> scanIterator(InetSocketAddress client, long startPos) {
+    MapScanResult<ScanObjectEntry, ScanObjectEntry> scanIterator(RedisClient client, long startPos) {
         RFuture<MapScanResult<ScanObjectEntry, ScanObjectEntry>> f = commandExecutor.readAsync(client, getName(), new MapScanCodec(codec, StringCodec.INSTANCE), RedisCommands.HSCAN, getName(), startPos);
         return get(f);
     }

File: redisson/src/main/java/org/redisson/RedissonSet.java
Patch:
@@ -29,6 +29,7 @@
 import org.redisson.api.RedissonClient;
 import org.redisson.api.SortOrder;
 import org.redisson.api.mapreduce.RCollectionMapReduce;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.codec.ScanCodec;
 import org.redisson.client.protocol.RedisCommands;
@@ -89,7 +90,7 @@ public RFuture<Boolean> containsAsync(Object o) {
     }
 
     @Override
-    public ListScanResult<ScanObjectEntry> scanIterator(String name, InetSocketAddress client, long startPos, String pattern) {
+    public ListScanResult<ScanObjectEntry> scanIterator(String name, RedisClient client, long startPos, String pattern) {
         if (pattern == null) {
             RFuture<ListScanResult<ScanObjectEntry>> f = commandExecutor.readAsync(client, name, new ScanCodec(codec), RedisCommands.SSCAN, name, startPos);
             return get(f);
@@ -104,7 +105,7 @@ public Iterator<V> iterator(final String pattern) {
         return new RedissonBaseIterator<V>() {
 
             @Override
-            ListScanResult<ScanObjectEntry> iterator(InetSocketAddress client, long nextIterPos) {
+            ListScanResult<ScanObjectEntry> iterator(RedisClient client, long nextIterPos) {
                 return scanIterator(getName(), client, nextIterPos, pattern);
             }
 

File: redisson/src/main/java/org/redisson/RedissonSetMultimapValues.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.redisson;
 
-import java.net.InetSocketAddress;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -28,6 +27,7 @@
 import org.redisson.api.RSet;
 import org.redisson.api.SortOrder;
 import org.redisson.api.mapreduce.RCollectionMapReduce;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.codec.MapScanCodec;
 import org.redisson.client.protocol.RedisCommand;
@@ -165,7 +165,7 @@ public RFuture<Boolean> containsAsync(Object o) {
          System.currentTimeMillis(), encodeMapKey(key), encodeMapValue(o));
     }
 
-    private ListScanResult<ScanObjectEntry> scanIterator(InetSocketAddress client, long startPos, String pattern) {
+    private ListScanResult<ScanObjectEntry> scanIterator(RedisClient client, long startPos, String pattern) {
         List<Object> params = new ArrayList<Object>();
         params.add(System.currentTimeMillis());
         params.add(startPos);
@@ -201,7 +201,7 @@ public Iterator<V> iterator(final String pattern) {
         return new RedissonBaseIterator<V>() {
 
             @Override
-            ListScanResult<ScanObjectEntry> iterator(InetSocketAddress client, long nextIterPos) {
+            ListScanResult<ScanObjectEntry> iterator(RedisClient client, long nextIterPos) {
                 return scanIterator(client, nextIterPos, pattern);
             }
 

File: redisson/src/main/java/org/redisson/ScanIterator.java
Patch:
@@ -15,8 +15,7 @@
  */
 package org.redisson;
 
-import java.net.InetSocketAddress;
-
+import org.redisson.client.RedisClient;
 import org.redisson.client.protocol.decoder.ListScanResult;
 import org.redisson.client.protocol.decoder.ScanObjectEntry;
 
@@ -27,7 +26,7 @@
  */
 public interface ScanIterator {
 
-    ListScanResult<ScanObjectEntry> scanIterator(String name, InetSocketAddress client, long startPos, String pattern);
+    ListScanResult<ScanObjectEntry> scanIterator(String name, RedisClient client, long startPos, String pattern);
 
     boolean remove(Object value);
     

File: redisson/src/main/java/org/redisson/client/handler/ConnectionWatchdog.java
Patch:
@@ -15,6 +15,7 @@
  */
 package org.redisson.client.handler;
 
+import java.net.SocketAddress;
 import java.util.Map.Entry;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.TimeUnit;
@@ -109,7 +110,7 @@ private void tryReconnect(final RedisConnection connection, final int nextAttemp
         log.debug("reconnecting {} to {} ", connection, connection.getRedisClient().getAddr(), connection);
 
         try {
-            bootstrap.connect().addListener(new ChannelFutureListener() {
+            bootstrap.connect(connection.getRedisClient().getAddr()).addListener(new ChannelFutureListener() {
 
                 @Override
                 public void operationComplete(final ChannelFuture future) throws Exception {

File: redisson/src/main/java/org/redisson/command/CommandBatchService.java
Patch:
@@ -371,14 +371,14 @@ public void operationComplete(Future<Void> future) throws Exception {
                 if (future.cause() instanceof RedisMovedException) {
                     RedisMovedException ex = (RedisMovedException)future.cause();
                     entry.clearErrors();
-                    NodeSource nodeSource = new NodeSource(ex.getSlot(), ex.getAddr(), Redirect.MOVED);
+                    NodeSource nodeSource = new NodeSource(ex.getSlot(), ex.getUrl(), Redirect.MOVED);
                     execute(entry, nodeSource, mainPromise, slots, attempt, noResult, responseTimeout, retryAttempts, retryInterval);
                     return;
                 }
                 if (future.cause() instanceof RedisAskException) {
                     RedisAskException ex = (RedisAskException)future.cause();
                     entry.clearErrors();
-                    NodeSource nodeSource = new NodeSource(ex.getSlot(), ex.getAddr(), Redirect.ASK);
+                    NodeSource nodeSource = new NodeSource(ex.getSlot(), ex.getUrl(), Redirect.ASK);
                     execute(entry, nodeSource, mainPromise, slots, attempt, noResult, responseTimeout, retryAttempts, retryInterval);
                     return;
                 }

File: redisson/src/main/java/org/redisson/connection/ConnectionEventsHub.java
Patch:
@@ -53,7 +53,7 @@ public void fireConnect(InetSocketAddress addr) {
     }
 
     public void fireDisconnect(InetSocketAddress addr) {
-        if (maps.get(addr) == Status.DISCONNECTED) {
+        if (addr == null || maps.get(addr) == Status.DISCONNECTED) {
             return;
         }
 

File: redisson/src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -102,8 +102,8 @@ public interface ConnectionManager {
 
     RedisClient createClient(NodeType type, URI address);
 
-    MasterSlaveEntry getEntry(InetSocketAddress addr);
-
+    MasterSlaveEntry getEntry(RedisClient redisClient);
+    
     PubSubConnectionEntry getPubSubEntry(String channelName);
 
     RFuture<PubSubConnectionEntry> psubscribe(String pattern, Codec codec, RedisPubSubListener<?>... listeners);

File: redisson/src/main/java/org/redisson/connection/SingleEntry.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.redisson.connection;
 
-import java.net.InetSocketAddress;
+import java.net.URI;
 import java.util.Set;
 
 import org.redisson.api.RFuture;
@@ -36,7 +36,7 @@ public SingleEntry(Set<ClusterSlotRange> slotRanges, ConnectionManager connectio
     }
 
     @Override
-    public RFuture<RedisConnection> connectionReadOp(RedisCommand<?> command, InetSocketAddress addr) {
+    public RFuture<RedisConnection> connectionReadOp(RedisCommand<?> command, URI addr) {
         return super.connectionWriteOp(command);
     }
 

File: redisson/src/main/java/org/redisson/jcache/JCache.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.redisson.jcache;
 
-import java.net.InetSocketAddress;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -58,6 +57,7 @@
 import org.redisson.api.RSemaphore;
 import org.redisson.api.RTopic;
 import org.redisson.api.listener.MessageListener;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.codec.MapScanCodec;
 import org.redisson.client.protocol.RedisCommand;
@@ -2082,7 +2082,7 @@ public void removeAll(Set<? extends K> keys) {
         cacheManager.getStatBean(this).addRemoveTime(currentNanoTime() - startTime);
     }
     
-    MapScanResult<ScanObjectEntry, ScanObjectEntry> scanIterator(String name, InetSocketAddress client, long startPos) {
+    MapScanResult<ScanObjectEntry, ScanObjectEntry> scanIterator(String name, RedisClient client, long startPos) {
         RFuture<MapScanResult<ScanObjectEntry, ScanObjectEntry>> f 
             = commandExecutor.readAsync(client, name, new MapScanCodec(codec), RedisCommands.HSCAN, name, startPos);
         try {

File: redisson/src/main/java/org/redisson/reactive/ReactiveIterator.java
Patch:
@@ -18,6 +18,7 @@
 import java.net.InetSocketAddress;
 
 import org.reactivestreams.Publisher;
+import org.redisson.client.RedisClient;
 import org.redisson.client.protocol.decoder.MapScanResult;
 import org.redisson.client.protocol.decoder.ScanObjectEntry;
 
@@ -30,7 +31,7 @@
  */
 interface MapReactive<K, V> {
 
-    Publisher<MapScanResult<ScanObjectEntry, ScanObjectEntry>> scanIteratorReactive(InetSocketAddress client, long startPos);
+    Publisher<MapScanResult<ScanObjectEntry, ScanObjectEntry>> scanIteratorReactive(RedisClient client, long startPos);
     
     Publisher<V> put(K key, V value);
     

File: redisson/src/main/java/org/redisson/reactive/RedissonMapCacheReactive.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.redisson.reactive;
 
-import java.net.InetSocketAddress;
 import java.util.Collection;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -29,6 +28,7 @@
 import org.redisson.api.RMapCacheAsync;
 import org.redisson.api.RMapCacheReactive;
 import org.redisson.api.RMapReactive;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.protocol.decoder.MapScanResult;
 import org.redisson.client.protocol.decoder.ScanObjectEntry;
@@ -164,7 +164,7 @@ public RFuture<Long> get() {
     }
 
     @Override
-    public Publisher<MapScanResult<ScanObjectEntry, ScanObjectEntry>> scanIteratorReactive(final InetSocketAddress client, final long startPos) {
+    public Publisher<MapScanResult<ScanObjectEntry, ScanObjectEntry>> scanIteratorReactive(final RedisClient client, final long startPos) {
         return reactive(new Supplier<RFuture<MapScanResult<ScanObjectEntry, ScanObjectEntry>>>() {
             @Override
             public RFuture<MapScanResult<ScanObjectEntry, ScanObjectEntry>> get() {

File: redisson/src/main/java/org/redisson/reactive/RedissonMapReactive.java
Patch:
@@ -27,6 +27,7 @@
 import org.redisson.api.RFuture;
 import org.redisson.api.RMapAsync;
 import org.redisson.api.RMapReactive;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.codec.MapScanCodec;
 import org.redisson.client.protocol.RedisCommands;
@@ -284,7 +285,7 @@ public RFuture<Long> get() {
         });
     }
 
-    public Publisher<MapScanResult<ScanObjectEntry, ScanObjectEntry>> scanIteratorReactive(InetSocketAddress client, long startPos) {
+    public Publisher<MapScanResult<ScanObjectEntry, ScanObjectEntry>> scanIteratorReactive(RedisClient client, long startPos) {
         return commandExecutor.readReactive(client, getName(), new MapScanCodec(codec), RedisCommands.HSCAN, getName(), startPos);
     }
 

File: redisson/src/main/java/org/redisson/reactive/RedissonMapReactiveIterator.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.redisson.reactive;
 
-import java.net.InetSocketAddress;
 import java.util.AbstractMap;
 import java.util.HashMap;
 import java.util.Map;
@@ -24,6 +23,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import org.redisson.client.RedisClient;
 import org.redisson.client.protocol.decoder.MapScanResult;
 import org.redisson.client.protocol.decoder.ScanObjectEntry;
 
@@ -56,7 +56,7 @@ public void subscribe(final Subscriber<? super M> t) {
 
                     private Map<ByteBuf, ByteBuf> firstValues;
                     private long iterPos = 0;
-                    private InetSocketAddress client;
+                    private RedisClient client;
 
                     private long currentIndex;
 

File: redisson/src/main/java/org/redisson/reactive/RedissonScoredSortedSetReactive.java
Patch:
@@ -25,6 +25,7 @@
 import org.redisson.api.RScoredSortedSet.Aggregate;
 import org.redisson.api.RScoredSortedSetAsync;
 import org.redisson.api.RScoredSortedSetReactive;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.codec.ScanCodec;
 import org.redisson.client.protocol.RedisCommands;
@@ -175,15 +176,15 @@ public RFuture<Integer> get() {
         });
     }
 
-    private Publisher<ListScanResult<ScanObjectEntry>> scanIteratorReactive(InetSocketAddress client, long startPos) {
+    private Publisher<ListScanResult<ScanObjectEntry>> scanIteratorReactive(RedisClient client, long startPos) {
         return commandExecutor.readReactive(client, getName(), new ScanCodec(codec), RedisCommands.ZSCAN, getName(), startPos);
     }
 
     @Override
     public Publisher<V> iterator() {
         return new SetReactiveIterator<V>() {
             @Override
-            protected Publisher<ListScanResult<ScanObjectEntry>> scanIteratorReactive(InetSocketAddress client, long nextIterPos) {
+            protected Publisher<ListScanResult<ScanObjectEntry>> scanIteratorReactive(RedisClient client, long nextIterPos) {
                 return RedissonScoredSortedSetReactive.this.scanIteratorReactive(client, nextIterPos);
             }
         };

File: redisson/src/main/java/org/redisson/reactive/RedissonSetCacheReactive.java
Patch:
@@ -26,6 +26,7 @@
 import org.redisson.RedissonSetCache;
 import org.redisson.api.RFuture;
 import org.redisson.api.RSetCacheReactive;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.decoder.ListScanResult;
@@ -85,7 +86,7 @@ public RFuture<Boolean> get() {
         });
     }
 
-    Publisher<ListScanResult<ScanObjectEntry>> scanIterator(final InetSocketAddress client, final long startPos) {
+    Publisher<ListScanResult<ScanObjectEntry>> scanIterator(final RedisClient client, final long startPos) {
         return reactive(new Supplier<RFuture<ListScanResult<ScanObjectEntry>>>() {
             @Override
             public RFuture<ListScanResult<ScanObjectEntry>> get() {
@@ -98,7 +99,7 @@ public RFuture<ListScanResult<ScanObjectEntry>> get() {
     public Publisher<V> iterator() {
         return new SetReactiveIterator<V>() {
             @Override
-            protected Publisher<ListScanResult<ScanObjectEntry>> scanIteratorReactive(InetSocketAddress client, long nextIterPos) {
+            protected Publisher<ListScanResult<ScanObjectEntry>> scanIteratorReactive(RedisClient client, long nextIterPos) {
                 return RedissonSetCacheReactive.this.scanIterator(client, nextIterPos);
             }
         };

File: redisson/src/main/java/org/redisson/reactive/RedissonSetReactive.java
Patch:
@@ -26,6 +26,7 @@
 import org.redisson.RedissonSet;
 import org.redisson.api.RFuture;
 import org.redisson.api.RSetReactive;
+import org.redisson.client.RedisClient;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.codec.ScanCodec;
 import org.redisson.client.protocol.RedisCommands;
@@ -76,7 +77,7 @@ public RFuture<Boolean> get() {
         });
     }
 
-    private Publisher<ListScanResult<ScanObjectEntry>> scanIteratorReactive(InetSocketAddress client, long startPos) {
+    private Publisher<ListScanResult<ScanObjectEntry>> scanIteratorReactive(RedisClient client, long startPos) {
         return commandExecutor.readReactive(client, getName(), new ScanCodec(codec), RedisCommands.SSCAN, getName(), startPos);
     }
 
@@ -211,7 +212,7 @@ public RFuture<Set<V>> get() {
     public Publisher<V> iterator() {
         return new SetReactiveIterator<V>() {
             @Override
-            protected Publisher<ListScanResult<ScanObjectEntry>> scanIteratorReactive(InetSocketAddress client, long nextIterPos) {
+            protected Publisher<ListScanResult<ScanObjectEntry>> scanIteratorReactive(RedisClient client, long nextIterPos) {
                 return RedissonSetReactive.this.scanIteratorReactive(client, nextIterPos);
             }
         };

File: redisson/src/main/java/org/redisson/reactive/SetReactiveIterator.java
Patch:
@@ -22,6 +22,7 @@
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
+import org.redisson.client.RedisClient;
 import org.redisson.client.protocol.decoder.ListScanResult;
 import org.redisson.client.protocol.decoder.ScanObjectEntry;
 
@@ -44,7 +45,7 @@ public void subscribe(final Subscriber<? super V> t) {
             private List<ByteBuf> firstValues;
             private List<ByteBuf> lastValues;
             private long nextIterPos;
-            private InetSocketAddress client;
+            private RedisClient client;
 
             private boolean finished;
 
@@ -168,6 +169,6 @@ private List<ByteBuf> convert(List<ScanObjectEntry> list) {
         return result;
     }
 
-    protected abstract Publisher<ListScanResult<ScanObjectEntry>> scanIteratorReactive(InetSocketAddress client, long nextIterPos);
+    protected abstract Publisher<ListScanResult<ScanObjectEntry>> scanIteratorReactive(RedisClient client, long nextIterPos);
 
 }

File: redisson/src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -31,6 +31,7 @@
 import org.redisson.api.NodesGroup;
 import org.redisson.api.RMap;
 import org.redisson.api.RedissonClient;
+import org.redisson.client.RedisClient;
 import org.redisson.client.RedisConnectionException;
 import org.redisson.client.RedisOutOfMemoryException;
 import org.redisson.client.protocol.decoder.ListScanResult;
@@ -84,7 +85,7 @@ public void testIteratorNotLooped() {
         RedissonBaseIterator iter = new RedissonBaseIterator() {
             int i;
             @Override
-            ListScanResult iterator(InetSocketAddress client, long nextIterPos) {
+            ListScanResult iterator(RedisClient client, long nextIterPos) {
                 i++;
                 if (i == 1) {
                     return new ListScanResult(13L, Collections.emptyList());
@@ -110,7 +111,7 @@ public void testIteratorNotLooped2() {
         RedissonBaseIterator<Integer> iter = new RedissonBaseIterator<Integer>() {
             int i;
             @Override
-            ListScanResult<ScanObjectEntry> iterator(InetSocketAddress client, long nextIterPos) {
+            ListScanResult<ScanObjectEntry> iterator(RedisClient client, long nextIterPos) {
                 i++;
                 if (i == 1) {
                     return new ListScanResult<ScanObjectEntry>(14L, Arrays.asList(new ScanObjectEntry(Unpooled.wrappedBuffer(new byte[] {1}), 1)));

File: redisson/src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -536,7 +536,7 @@ public void run(Timeout t) throws Exception {
                     if (details.getConnectionFuture().isSuccess()) {
                         if (details.getWriteFuture() == null || !details.getWriteFuture().isDone()) {
                             if (details.getAttempt() == connectionManager.getConfig().getRetryAttempts()) {
-                                if (details.getWriteFuture().cancel(false)) {
+                                if (details.getWriteFuture() != null && details.getWriteFuture().cancel(false)) {
                                     if (details.getException() == null) {
                                         details.setException(new RedisTimeoutException("Unable to send command: " + command + " with params: " + LogHelper.toString(details.getParams()) + " after " + connectionManager.getConfig().getRetryAttempts() + " retry attempts"));
                                     }

File: redisson/src/main/java/org/redisson/reactive/RedissonBaseMultimapReactive.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.util.List;
 import java.util.Set;
+import java.util.function.Supplier;
 
 import org.reactivestreams.Publisher;
 import org.redisson.api.RFuture;
@@ -28,7 +29,6 @@
 import org.redisson.misc.Hash;
 
 import io.netty.buffer.ByteBuf;
-import reactor.fn.Supplier;
 
 /**
  * 

File: redisson/src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -1185,7 +1185,7 @@ private void loadValue(final K key, final RPromise<V> result, final RLock lock,
             public void run() {
                 final V value = options.getLoader().load(key);
                 if (value == null) {
-                    result.trySuccess(value);
+                    unlock(result, lock, threadId, value);
                     return;
                 }
                     

File: redisson/src/main/java/org/redisson/api/RBatch.java
Patch:
@@ -398,13 +398,13 @@ public interface RBatch {
      */
     RFuture<BatchResult<?>> executeAsync();
 
-    /**
+    /*
      * Use {@link #skipResult()}
      */
     @Deprecated
     void executeSkipResult();
 
-    /**
+    /*
      * Use {@link #skipResult()}
      */
     @Deprecated

File: redisson/src/main/java/org/redisson/BaseRemoteService.java
Patch:
@@ -528,8 +528,8 @@ private RemoteServiceAck tryPollAckAgain(RemoteInvocationOptions optionsCopy,
         return null;
     }
 
-    private RFuture<RemoteServiceAck> tryPollAckAgainAsync(RemoteInvocationOptions optionsCopy,
-            String ackName, String requestId, final String responseName)
+    private RFuture<RemoteServiceAck> tryPollAckAgainAsync(final RemoteInvocationOptions optionsCopy,
+            String ackName, final String requestId, final String responseName)
             throws InterruptedException {
         final RPromise<RemoteServiceAck> promise = new RedissonPromise<RemoteServiceAck>();
         RFuture<Boolean> ackClientsFuture = commandExecutor.evalWriteAsync(ackName, LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,

File: redisson/src/main/java/org/redisson/codec/SnappyCodec.java
Patch:
@@ -25,7 +25,6 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufAllocator;
 import io.netty.handler.codec.compression.Snappy;
-import net.bytebuddy.utility.RandomString;
 
 /**
  * Snappy compression codec.

File: redisson/src/test/java/org/redisson/client/protocol/decoder/ClusterNodesDecoderTest.java
Patch:
@@ -14,7 +14,7 @@ public class ClusterNodesDecoderTest {
 
     @Test
     public void test() throws IOException {
-        ClusterNodesDecoder decoder = new ClusterNodesDecoder();
+        ClusterNodesDecoder decoder = new ClusterNodesDecoder(false);
         ByteBuf buf = Unpooled.buffer();
         
         String info = "7af253f8c20a3b3fbd481801bd361ec6643c6f0b 192.168.234.129:7001@17001 master - 0 1478865073260 8 connected 5461-10922\n" +

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -309,7 +309,8 @@ public interface RedisCommands {
     Set<String> PUBSUB_COMMANDS = new HashSet<String>(
             Arrays.asList(PSUBSCRIBE.getName(), SUBSCRIBE.getName(), PUNSUBSCRIBE.getName(), UNSUBSCRIBE.getName()));
 
-    RedisStrictCommand<List<ClusterNodeInfo>> CLUSTER_NODES = new RedisStrictCommand<List<ClusterNodeInfo>>("CLUSTER", "NODES", new ClusterNodesDecoder());
+    RedisStrictCommand<List<ClusterNodeInfo>> CLUSTER_NODES = new RedisStrictCommand<List<ClusterNodeInfo>>("CLUSTER", "NODES", new ClusterNodesDecoder(false));
+    RedisStrictCommand<List<ClusterNodeInfo>> CLUSTER_NODES_SSL = new RedisStrictCommand<List<ClusterNodeInfo>>("CLUSTER", "NODES", new ClusterNodesDecoder(true));
     RedisCommand<Object> TIME = new RedisCommand<Object>("TIME", new LongListObjectDecoder());
     RedisStrictCommand<Map<String, String>> CLUSTER_INFO = new RedisStrictCommand<Map<String, String>>("CLUSTER", "INFO", new StringMapDataDecoder());
 

File: redisson/src/main/java/org/redisson/connection/DNSMonitor.java
Patch:
@@ -142,7 +142,7 @@ public void operationComplete(Future<InetSocketAddress> future) throws Exception
                             if (!updatedSlave.getHostAddress().equals(slave.getHostAddress())) {
                                 log.info("Detected DNS change. {} has changed from {} to {}", entry.getKey().getHost(), slave.getHostAddress(), updatedSlave.getHostAddress());
                                 for (MasterSlaveEntry masterSlaveEntry : connectionManager.getEntrySet()) {
-                                    URI uri = URIBuilder.create("redis://" + slave.getHostAddress() + ":" + entry.getKey().getPort());
+                                    URI uri = URIBuilder.create(slave.getHostAddress() + ":" + entry.getKey().getPort());
                                     if (masterSlaveEntry.slaveDown(uri, FreezeReason.MANAGER)) {
                                         masterSlaveEntry.slaveUp(entry.getKey(), FreezeReason.MANAGER);
                                     }

File: redisson/src/main/java/org/redisson/connection/pool/ConnectionPool.java
Patch:
@@ -169,8 +169,8 @@ protected ClientConnectionsEntry getEntry() {
     public RFuture<T> get(RedisCommand<?> command) {
         for (int j = entries.size() - 1; j >= 0; j--) {
             final ClientConnectionsEntry entry = getEntry();
-            if (!entry.isFreezed() 
-                    && tryAcquireConnection(entry)) {
+            if ((!entry.isFreezed() || entry.getFreezeReason() == FreezeReason.SYSTEM) && 
+        		    tryAcquireConnection(entry)) {
                 return acquireConnection(command, entry);
             }
         }

File: redisson/src/main/java/org/redisson/BaseRemoteService.java
Patch:
@@ -393,7 +393,7 @@ private <T extends RRemoteServiceResponse> RPromise<T> poll(final long timeout,
             }
         }
         
-        final Map<String, RPromise<? extends RRemoteServiceResponse>> responses = entry.getResponses();
+        final ConcurrentMap<String, RPromise<? extends RRemoteServiceResponse>> responses = entry.getResponses();
         
         commandExecutor.getConnectionManager().getGroup().schedule(new Runnable() {
             @Override

File: redisson/src/main/java/org/redisson/client/RedisClient.java
Patch:
@@ -317,7 +317,7 @@ public RFuture<Void> shutdownAsync() {
         }
         ChannelGroupFuture channelsFuture = channels.close();
         
-        RPromise<Void> result = new RedissonPromise<Void>();
+        final RPromise<Void> result = new RedissonPromise<Void>();
         channelsFuture.addListener(new FutureListener<Void>() {
             @Override
             public void operationComplete(Future<Void> future) throws Exception {

File: redisson/src/main/java/org/redisson/executor/RemotePromise.java
Patch:
@@ -28,9 +28,11 @@ public class RemotePromise<T> extends RedissonPromise<T> {
     private String requestId;
     private RFuture<Boolean> addFuture;
     
-    public void setRequestId(String requestId) {
+    public RemotePromise(String requestId) {
+        super();
         this.requestId = requestId;
     }
+    
     public String getRequestId() {
         return requestId;
     }

File: redisson/src/main/java/org/redisson/remote/RRemoteServiceResponse.java
Patch:
@@ -24,4 +24,6 @@
  */
 public interface RRemoteServiceResponse extends Serializable {
 
+    String getId();
+    
 }

File: redisson/src/test/java/org/redisson/executor/ScheduledLongRepeatableTask.java
Patch:
@@ -23,7 +23,7 @@ public ScheduledLongRepeatableTask(String counterName, String objectName) {
     @Override
     public void run() {
         if (redisson.getAtomicLong(counterName).incrementAndGet() == 3) {
-            for (int i = 0; i < Long.MAX_VALUE; i++) {
+            for (long i = 0; i < Long.MAX_VALUE; i++) {
                 if (Thread.currentThread().isInterrupted()) {
                     System.out.println("interrupted " + i);
                     redisson.getBucket(objectName).set(i);

File: redisson/src/main/java/org/redisson/client/RedisClient.java
Patch:
@@ -79,9 +79,9 @@ private RedisClient(RedisClientConfig config) {
         
         addr = new InetSocketAddress(config.getAddress().getHost(), config.getAddress().getPort());
         
+        channels = new DefaultChannelGroup(config.getGroup().next()); 
         bootstrap = createBootstrap(config, Type.PLAIN);
         pubSubBootstrap = createBootstrap(config, Type.PUBSUB);
-        channels = new DefaultChannelGroup(config.getGroup().next()); 
         
         this.commandTimeout = config.getCommandTimeout();
     }
@@ -172,9 +172,9 @@ public RedisClient(final Timer timer, ExecutorService executor, EventLoopGroup g
         
         addr = new InetSocketAddress(config.getAddress().getHost(), config.getAddress().getPort());
         
+        channels = new DefaultChannelGroup(config.getGroup().next());
         bootstrap = createBootstrap(config, Type.PLAIN);
         pubSubBootstrap = createBootstrap(config, Type.PUBSUB);
-        channels = new DefaultChannelGroup(config.getGroup().next());
         
         this.commandTimeout = config.getCommandTimeout();
     }

File: redisson/src/test/java/org/redisson/executor/RedissonExecutorServiceTest.java
Patch:
@@ -130,12 +130,12 @@ public void testCancelAndInterrupt() throws InterruptedException, ExecutionExcep
         RExecutorFuture<?> future = executor.submit(new ScheduledLongRunnableTask("executed1"));
         Thread.sleep(2000);
         cancel(future);
-        assertThat(redisson.<Integer>getBucket("executed1").get()).isBetween(1000, Integer.MAX_VALUE);
+        assertThat(redisson.<Long>getBucket("executed1").get()).isBetween(1000L, Long.MAX_VALUE);
         
         RExecutorFuture<?> futureAsync = executor.submitAsync(new ScheduledLongRunnableTask("executed2"));
         Thread.sleep(2000);
         assertThat(executor.cancelTask(futureAsync.getTaskId())).isTrue();
-        assertThat(redisson.<Integer>getBucket("executed2").get()).isBetween(1000, Integer.MAX_VALUE);
+        assertThat(redisson.<Long>getBucket("executed2").get()).isBetween(1000L, Long.MAX_VALUE);
     }
     
     @Test

File: redisson/src/test/java/org/redisson/executor/ScheduledLongRunnableTask.java
Patch:
@@ -19,7 +19,7 @@ public ScheduledLongRunnableTask(String objectName) {
 
     @Override
     public void run() {
-        for (int i = 0; i < Long.MAX_VALUE; i++) {
+        for (long i = 0; i < Long.MAX_VALUE; i++) {
             if (Thread.currentThread().isInterrupted()) {
                 System.out.println("interrupted " + i);
                 redisson.getBucket(objectName).set(i);

File: redisson/src/main/java/org/redisson/api/RBatch.java
Patch:
@@ -448,7 +448,7 @@ public interface RBatch {
     RBatch timeout(long timeout, TimeUnit unit);
 
     /**
-     * Defines time interval for another one attempt send Redis commands batch 
+     * Defines time interval for each attempt to send Redis commands batch 
      * if it hasn't been sent already.
      * <p>
      * <code>0</code> value means use <code>Config.setRetryInterval</code> value instead.

File: redisson/src/main/java/org/redisson/api/RBatch.java
Patch:
@@ -421,7 +421,8 @@ public interface RBatch {
     RBatch skipResult();
     
     /**
-     * Synchronize write operations execution across defined amount of Redis slave nodes.
+     * Synchronize write operations execution across defined amount 
+     * of Redis slave nodes within defined timeout.
      * <p>
      * NOTE: Redis 3.0+ required
      * 

File: redisson-tomcat/redisson-tomcat-6/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -127,7 +127,7 @@ public Session findSession(String id) throws IOException {
         Session result = super.findSession(id);
         if (result == null && id != null) {
             Map<String, Object> attrs = getMap(id).readAllMap();
-            if (attrs.isEmpty()) {
+            if (attrs.isEmpty() || !Boolean.valueOf(String.valueOf(attrs.get("session:isValid")))) {
                 log.info("Session " + id + " can't be found");
                 return null;
             }

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -105,7 +105,7 @@ public Session findSession(String id) throws IOException {
         Session result = super.findSession(id);
         if (result == null && id != null) {
             Map<String, Object> attrs = getMap(id).readAllMap();
-            if (attrs.isEmpty()) {
+            if (attrs.isEmpty() || !Boolean.valueOf(String.valueOf(attrs.get("session:isValid")))) {
                 log.info("Session " + id + " can't be found");
                 return null;
             }

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -105,7 +105,8 @@ public Session findSession(String id) throws IOException {
         Session result = super.findSession(id);
         if (result == null && id != null) {
             Map<String, Object> attrs = getMap(id).readAllMap();
-            if (attrs.isEmpty()) {
+            
+            if (attrs.isEmpty() || !Boolean.valueOf(String.valueOf(attrs.get("session:isValid")))) {
                 log.info("Session " + id + " can't be found");
                 return null;
             }

File: redisson/src/main/java/org/redisson/spring/cache/RedissonSpringCacheManager.java
Patch:
@@ -212,8 +212,6 @@ public Cache getCache(String name) {
         if (config == null) {
             config = createDefaultConfig();
             configMap.put(name, config);
-
-            return createMap(name, config);
         }
         
         if (config.getMaxIdleTime() == 0 && config.getTTL() == 0 && config.getMaxSize() == 0) {

File: redisson/src/main/java/org/redisson/liveobject/core/AccessorInterceptor.java
Patch:
@@ -148,7 +148,9 @@ public Object intercept(@Origin Method method, @SuperCall Callable<?> superMetho
     }
 
     private String getFieldName(Method method) {
-        return method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4);
+        String name = method.getName();
+        int i = name.startsWith("is") ? 3 : 4;
+        return name.substring(i - 1, i).toLowerCase() + name.substring(i);
     }
 
     private boolean isGetter(Method method, String fieldName) {

File: redisson/src/main/java/org/redisson/liveobject/core/AccessorInterceptor.java
Patch:
@@ -148,7 +148,9 @@ public Object intercept(@Origin Method method, @SuperCall Callable<?> superMetho
     }
 
     private String getFieldName(Method method) {
-        return method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4);
+        String name = method.getName();
+        int i = name.startsWith("is") ? 3 : 4;
+        return name.substring(i - 1, i).toLowerCase() + name.substring(i);
     }
 
     private boolean isGetter(Method method, String fieldName) {

File: redisson/src/main/java/org/redisson/liveobject/misc/ClassUtils.java
Patch:
@@ -129,9 +129,9 @@ public static boolean isAnnotationPresent(Class<?> clazz, Class<? extends Annota
     private static Iterable<Class<?>> getClassHierarchy(Class<?> clazz) {
         // Don't descend into hierarchy for RObjects
         if (Arrays.asList(clazz.getInterfaces()).contains(RObject.class)) {
-            return Collections.singleton(clazz);
+            return Collections.<Class<?>>singleton(clazz);
         }
-        List<Class<?>> classes = new ArrayList<>();
+        List<Class<?>> classes = new ArrayList<Class<?>>();
         for (Class c = clazz; c != null; c = c.getSuperclass()) {
             classes.add(c);
         }

File: redisson/src/main/java/org/redisson/liveobject/misc/Introspectior.java
Patch:
@@ -69,7 +69,7 @@ public static FieldList<FieldDescription.InDefinedShape> getFieldsWithAnnotation
     }
 
     public static FieldList<FieldDescription.InDefinedShape> getAllFields(Class<?> cls) {
-        List<Field> fields = new ArrayList<>();
+        List<Field> fields = new ArrayList<Field>();
         for (Class<?> c = cls; c != null; c = c.getSuperclass()) {
             Collections.addAll(fields, c.getDeclaredFields());
         }

File: redisson/src/main/java/org/redisson/RedissonKeys.java
Patch:
@@ -321,7 +321,9 @@ public void operationComplete(Future<List<?>> future) throws Exception {
                 if (future.isSuccess()) {
                     List<Long> result = (List<Long>) future.get();
                     for (Long res : result) {
-                        count.addAndGet(res);
+                        if (res != null) {
+                            count.addAndGet(res);
+                        }
                     }
                 } else {
                     failed.set(future.cause());

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -102,7 +102,7 @@ public boolean trySetMaxSize(int maxSize) {
     
     @Override
     public RFuture<Boolean> trySetMaxSizeAsync(int maxSize) {
-        if (maxSize <= 0) {
+        if (maxSize < 0) {
             throw new IllegalArgumentException("maxSize should be greater than zero");
         }
         
@@ -116,7 +116,7 @@ public void setMaxSize(int maxSize) {
     
     @Override
     public RFuture<Void> setMaxSizeAsync(int maxSize) {
-        if (maxSize <= 0) {
+        if (maxSize < 0) {
             throw new IllegalArgumentException("maxSize should be greater than zero");
         }
         

File: redisson/src/main/java/org/redisson/api/RMapCache.java
Patch:
@@ -44,6 +44,7 @@ public interface RMapCache<K, V> extends RMap<K, V>, RMapCacheAsync<K, V> {
      * Superfluous elements are evicted using LRU algorithm.
      * 
      * @param maxSize - max size
+     *                  If <code>0</code> the cache is unbounded (default).
      */
     void setMaxSize(int maxSize);
     
@@ -53,6 +54,7 @@ public interface RMapCache<K, V> extends RMap<K, V>, RMapCacheAsync<K, V> {
      *
      * @param maxSize - max size
      * @return <code>true</code> if max size has been successfully set, otherwise <code>false</code>.
+     *         If <code>0</code> the cache is unbounded (default).
      */
     boolean trySetMaxSize(int maxSize);
     

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -240,9 +240,9 @@ protected void decode(ByteBuf in, CommandData<Object, Object> data, List<Object>
                             + ". channel: " + channel + " data: " + data));
                 } else {
                     if (data != null) {
-                        data.tryFailure(new RedisException(error + ". channel: " + channel + " command: " + data));
+                        data.tryFailure(new RedisException(error + ". channel: " + channel + " command: " + LogHelper.toString(data)));
                     } else {
-                        log.error("Error: {} channel: {} data: {}", error, channel, data);
+                        log.error("Error: {} channel: {} data: {}", error, channel, LogHelper.toString(data));
                     }
                 }
             } finally {
@@ -320,7 +320,7 @@ private void handleResult(CommandData<Object, Object> data, List<Object> parts,
             parts.add(result);
         } else {
             if (data != null && !data.getPromise().trySuccess(result) && data.cause() instanceof RedisTimeoutException) {
-                log.warn("response has been skipped due to timeout! channel: {}, command: {}, result: {}", channel, data, result);
+                log.warn("response has been skipped due to timeout! channel: {}, command: {}, result: {}", channel, LogHelper.toString(data), LogHelper.toString(result));
             }
         }
     }

File: redisson/src/main/java/org/redisson/eviction/EvictionScheduler.java
Patch:
@@ -63,8 +63,8 @@ public void schedule(String name, long shiftInMilliseconds) {
         }
     }
 
-    public void schedule(String name, String timeoutSetName, String maxIdleSetName, String expiredChannelName) {
-        EvictionTask task = new MapCacheEvictionTask(name, timeoutSetName, maxIdleSetName, expiredChannelName, executor);
+    public void schedule(String name, String timeoutSetName, String maxIdleSetName, String expiredChannelName, String lastAccessTimeSetName) {
+        EvictionTask task = new MapCacheEvictionTask(name, timeoutSetName, maxIdleSetName, expiredChannelName, lastAccessTimeSetName, executor);
         EvictionTask prevTask = tasks.putIfAbsent(name, task);
         if (prevTask == null) {
             task.schedule();

File: redisson/src/main/java/org/redisson/api/RScoredSortedSet.java
Patch:
@@ -104,7 +104,7 @@ public enum Aggregate {
      * Finally return the reverse rank of the item
      * @param score - object score
      * @param object - object itself
-     * @return rank
+     * @return reverse rank
      */
     Integer addAndGetRevRank(double score, V object);
 

File: redisson/src/main/java/org/redisson/api/RScoredSortedSetAsync.java
Patch:
@@ -77,7 +77,7 @@ public interface RScoredSortedSetAsync<V> extends RExpirableAsync, RSortableAsyn
      * Finally return the reverse rank of the item
      * @param score - object score
      * @param object - object itself
-     * @return rank
+     * @return reverse rank
      */
     RFuture<Integer> addAndGetRevRankAsync(double score, V object);
 

File: redisson/src/main/java/org/redisson/connection/balancer/LoadBalancerManager.java
Patch:
@@ -205,12 +205,12 @@ public RFuture<RedisConnection> nextConnection(RedisCommand<?> command) {
     }
 
     public void returnPubSubConnection(RedisPubSubConnection connection) {
-        ClientConnectionsEntry entry = ip2Entry.get(contains(connection.getRedisClient().getAddr()));
+        ClientConnectionsEntry entry = ip2Entry.get(convert(connection.getRedisClient().getAddr()));
         pubSubConnectionPool.returnConnection(entry, connection);
     }
 
     public void returnConnection(RedisConnection connection) {
-        ClientConnectionsEntry entry = ip2Entry.get(contains(connection.getRedisClient().getAddr()));
+        ClientConnectionsEntry entry = ip2Entry.get(convert(connection.getRedisClient().getAddr()));
         slaveConnectionPool.returnConnection(entry, connection);
     }
 

File: redisson/src/main/java/org/redisson/liveobject/resolver/DefaultNamingScheme.java
Patch:
@@ -72,9 +72,9 @@ public String resolveIdFieldName(String name) {
     public Object resolveId(String name) {
         String decode = name.substring(name.indexOf("{") + 1, name.indexOf("}"));
         
-        ByteBuf b = ByteBufAllocator.DEFAULT.buffer(decode.length()*2); 
-        b.writeBytes(ByteBufUtil.decodeHexDump(decode));
+        ByteBuf b = ByteBufAllocator.DEFAULT.buffer(decode.length()/2); 
         try {
+            b.writeBytes(ByteBufUtil.decodeHexDump(decode));
             return codec.getMapKeyDecoder().decode(b, new State(false));
         } catch (IOException ex) {
             throw new IllegalStateException("Unable to decode [" + decode + "] into object", ex);

File: redisson/src/main/java/org/redisson/command/CommandBatchService.java
Patch:
@@ -440,7 +440,7 @@ public void run(Timeout timeout) throws Exception {
 
     private void checkConnectionFuture(final Entry entry, final NodeSource source,
             final RPromise<Void> mainPromise, final RPromise<Void> attemptPromise, final AsyncDetails details,
-            RFuture<RedisConnection> connFuture, final boolean noResult, final long responseTimeout, int attempts) {
+            RFuture<RedisConnection> connFuture, final boolean noResult, final long responseTimeout, final int attempts) {
         if (attemptPromise.isDone() || mainPromise.isCancelled() || connFuture.isCancelled()) {
             return;
         }

File: redisson/src/main/java/org/redisson/RedissonTopic.java
Patch:
@@ -108,7 +108,7 @@ private int addListener(RedisPubSubListener<?> pubSubListener) {
     
     public RFuture<Integer> addListenerAsync(final RedisPubSubListener<?> pubSubListener) {
         RFuture<PubSubConnectionEntry> future = commandExecutor.getConnectionManager().subscribe(codec, name, pubSubListener);
-        RPromise<Integer> result = new RedissonPromise<Integer>();
+        final RPromise<Integer> result = new RedissonPromise<Integer>();
         future.addListener(new FutureListener<PubSubConnectionEntry>() {
             @Override
             public void operationComplete(Future<PubSubConnectionEntry> future) throws Exception {

File: redisson/src/main/java/org/redisson/RedissonAtomicDouble.java
Patch:
@@ -75,7 +75,7 @@ public double decrementAndGet() {
 
     @Override
     public RFuture<Double> decrementAndGetAsync() {
-        return commandExecutor.writeAsync(getName(), StringCodec.INSTANCE, RedisCommands.DECR, getName());
+        return commandExecutor.writeAsync(getName(), StringCodec.INSTANCE, RedisCommands.INCRBYFLOAT, getName(), -1);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonListMultimap.java
Patch:
@@ -182,7 +182,7 @@ public RFuture<Boolean> putAllAsync(K key, Iterable<? extends V> values) {
 
 
     @Override
-    public RList<V> get(K key) {
+    public RList<V> get(final K key) {
         final ByteBuf keyState = encodeMapKey(key);
         final String keyHash = hashAndRelease(keyState);
         final String setName = getValuesName(keyHash);

File: redisson/src/main/java/org/redisson/RedissonSetMultimap.java
Patch:
@@ -159,7 +159,7 @@ public RFuture<Boolean> putAllAsync(K key, Iterable<? extends V> values) {
     }
 
     @Override
-    public RSet<V> get(K key) {
+    public RSet<V> get(final K key) {
         final ByteBuf keyState = encodeMapKey(key);
         final String keyHash = hashAndRelease(keyState);
         final String setName = getValuesName(keyHash);

File: redisson/src/main/java/org/redisson/api/RKeys.java
Patch:
@@ -236,7 +236,7 @@ public interface RKeys extends RKeysAsync {
      * <p>
      * Requires Redis 4.0+
      * 
-     * @param keys
+     * @param keys of objects
      * @return number of removed keys
      */
     long unlink(String ... keys);

File: redisson/src/main/java/org/redisson/config/BaseMasterSlaveServersConfig.java
Patch:
@@ -281,7 +281,7 @@ public SubscriptionMode getSubscriptionMode() {
     }
 
     /**
-     * Interval in milliseconds to check the endpoint DNS if {@link #isDnsMonitoring()} is true.<p>
+     * Interval in milliseconds to check the endpoint's DNS<p>
      * Applications must ensure the JVM DNS cache TTL is low enough to support this.<p>
      * Set <code>-1</code> to disable.
      * <p>

File: redisson/src/main/java/org/redisson/connection/pool/ConnectionPool.java
Patch:
@@ -204,7 +204,7 @@ && tryAcquireConnection(entry)) {
         }
 
         RedisConnectionException exception = new RedisConnectionException(
-                "Can't aquire connection to " + entry.getClient().getAddr());
+                "Can't aquire connection to " + entry);
         return connectionManager.newFailedFuture(exception);
     }
 

File: redisson/src/main/java/org/redisson/executor/TasksRunnerService.java
Patch:
@@ -67,7 +67,7 @@ public TasksRunnerService(CommandExecutor commandExecutor, RedissonClient rediss
         try {
             this.codec = codec.getClass().getConstructor(ClassLoader.class).newInstance(classLoader);
         } catch (Exception e) {
-            throw new IllegalStateException(e);
+            throw new IllegalStateException("Unable to initialize codec with ClassLoader parameter", e);
         }
     }
     

File: redisson-tomcat/redisson-tomcat-8/src/test/java/org/redisson/tomcat/TomcatServer.java
Patch:
@@ -28,7 +28,7 @@ public TomcatServer(String contextPath, int port, String appBase) throws Malform
 
         tomcat.setBaseDir("."); // location where temp dir is created
         tomcat.setPort(port);
-        tomcat.getHost().setAppBase(".");
+        tomcat.getHost().setAppBase(appBase);
 
         tomcat.addWebapp(contextPath, appBase + "webapp");
     }

File: redisson/src/main/java/org/redisson/connection/ReplicatedConnectionManager.java
Patch:
@@ -84,6 +84,7 @@ public ReplicatedConnectionManager(ReplicatedServersConfig cfg, Config config) {
             Role role = Role.valueOf(connection.sync(RedisCommands.INFO_REPLICATION).get(ROLE_KEY));
             if (Role.master.equals(role)) {
                 if (currentMaster.get() != null) {
+                    stopThreads();
                     throw new RedisException("Multiple masters detected");
                 }
                 currentMaster.set(addr);
@@ -96,6 +97,7 @@ public ReplicatedConnectionManager(ReplicatedServersConfig cfg, Config config) {
         }
 
         if (currentMaster.get() == null) {
+            stopThreads();
             throw new RedisConnectionException("Can't connect to servers!");
         }
 

File: redisson/src/main/java/org/redisson/api/RBitSet.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.BitSet;
 
 /**
+ * Vector of bits that grows as needed.
  *
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/api/RBitSetAsync.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.BitSet;
 
 /**
+ * Vector of bits that grows as needed. Asynchronous interface.
  *
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/api/RGeo.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.Map;
 
 /**
- * Geospatial items holder 
+ * Geospatial items holder. 
  * 
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/api/RGeoAsync.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.Map;
 
 /**
+ * Geospatial items holder. Asynchronous interface.
  * 
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/api/RHyperLogLog.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.Collection;
 
 /**
+ * Probabilistic data structure that lets you maintain counts of millions of items with extreme space efficiency.
  * 
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/api/RHyperLogLogAsync.java
Patch:
@@ -18,6 +18,8 @@
 import java.util.Collection;
 
 /**
+ * Probabilistic data structure that lets you maintain counts of millions of items with extreme space efficiency.
+ * Asynchronous interface.
  * 
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/api/RKeys.java
Patch:
@@ -187,7 +187,7 @@ public interface RKeys extends RKeysAsync {
     String randomKey();
 
     /**
-     * Find keys by key search pattern
+     * Find keys by key search pattern at once
      *
      *  Supported glob-style patterns:
      *    h?llo subscribes to hello, hallo and hxllo

File: redisson/src/main/java/org/redisson/client/codec/JsonJacksonMapCodec.java
Patch:
@@ -35,8 +35,6 @@
  * @author Nikita Koksharov
  * @author Andrej Kazakov
  *
- * @param <K>
- * @param <V>
  */
 public class JsonJacksonMapCodec extends JsonJacksonCodec {
     

File: redisson/src/main/java/org/redisson/config/Config.java
Patch:
@@ -565,7 +565,7 @@ public EventLoopGroup getEventLoopGroup() {
     }
 
     /**
-     * Works only if lock has been acquired without leaseTimeout parameter definition. 
+     * This parameter is only used if lock has been acquired without leaseTimeout parameter definition. 
      * Lock will be expired after <code>lockWatchdogTimeout</code> if watchdog 
      * didn't extend it to next <code>lockWatchdogTimeout</code> time interval.
      * <p>  
@@ -584,10 +584,10 @@ public long getLockWatchdogTimeout() {
     }
 
     /**
-     * Define whether keep PubSub messages handling in arrival order 
+     * Defines whether keep PubSub messages handling in arrival order 
      * or handle messages concurrently. 
      * <p>
-     * This setting applied only for PubSub messages published to single channel.
+     * This setting applied only for PubSub messages per channel.
      * <p>
      * Default is <code>true</code>.
      * 

File: redisson/src/test/java/org/redisson/RedissonBinaryStreamTest.java
Patch:
@@ -115,7 +115,7 @@ public void testSet1024() {
         stream.set(bytes);
         
         assertThat(stream.size()).isEqualTo(bytes.length);
-        assertThat(redisson.getBucket("test:parts").isExists()).isTrue();
+        assertThat(redisson.getBucket("{test}:parts").isExists()).isTrue();
         assertThat(redisson.getBucket("test").size()).isEqualTo(512*1024*1024);
         assertThat(redisson.getBucket("test:1").size()).isEqualTo(bytes.length - 512*1024*1024);
     }

File: redisson/src/main/java/org/redisson/RedissonBinaryStream.java
Patch:
@@ -282,7 +282,7 @@ public void operationComplete(Future<Void> future) throws Exception {
     }
     
     private String getPartsName() {
-        return getName() + ":parts";
+        return suffixName(getName(), "parts");
     }
     
     @Override

File: redisson/src/main/java/org/redisson/misc/RedissonPromise.java
Patch:
@@ -213,6 +213,9 @@ public boolean awaitUninterruptibly(long timeoutMillis) {
 
     @Override
     public T getNow() {
+        if (isCompletedExceptionally()) {
+            return null;
+        }
         return getNow(null);
     }
 

File: redisson/src/main/java/org/redisson/api/RMapAsync.java
Patch:
@@ -39,6 +39,7 @@ public interface RMapAsync<K, V> extends RExpirableAsync {
      * 
      * @param replaceExistingValues - <code>true</code> if existed values should be replaced, <code>false</code> otherwise.  
      * @param parallelism - parallelism level, used to increase speed of process execution
+     * @return void
      */
     RFuture<Void> loadAllAsync(boolean replaceExistingValues, int parallelism);
     
@@ -48,6 +49,7 @@ public interface RMapAsync<K, V> extends RExpirableAsync {
      * @param keys - map keys
      * @param replaceExistingValues - <code>true</code> if existed values should be replaced, <code>false</code> otherwise.
      * @param parallelism - parallelism level, used to increase speed of process execution
+     * @return void
      */
     RFuture<Void> loadAllAsync(Set<? extends K> keys, boolean replaceExistingValues, int parallelism);
     

File: redisson/src/main/java/org/redisson/client/handler/CommandsQueue.java
Patch:
@@ -91,7 +91,7 @@ private void sendData(Channel ch) {
             if (!pubSubOps.isEmpty()) {
                 for (CommandData<Object, Object> cd : pubSubOps) {
                     for (Object channel : cd.getParams()) {
-                        ch.pipeline().get(CommandDecoder.class).addPubSubCommand(channel.toString(), cd);
+                        ch.pipeline().get(CommandPubSubDecoder.class).addPubSubCommand(channel.toString(), cd);
                     }
                 }
             } else {

File: redisson/src/main/java/org/redisson/client/handler/ConnectionWatchdog.java
Patch:
@@ -16,15 +16,13 @@
 package org.redisson.client.handler;
 
 import java.util.Map.Entry;
-import java.util.Queue;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.TimeUnit;
 
 import org.redisson.client.RedisConnection;
 import org.redisson.client.RedisPubSubConnection;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.protocol.CommandData;
-import org.redisson.client.protocol.QueueCommandHolder;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -66,7 +64,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
     public void channelInactive(ChannelHandlerContext ctx) throws Exception {
         RedisConnection connection = RedisConnection.getFrom(ctx.channel());
         if (connection != null) {
-            connection.onDisconnect();
+            connection.fireDisconnected();
             if (!connection.isClosed()) {
                 if (connection.isFastReconnect()) {
                     tryReconnect(connection, 1);
@@ -152,6 +150,7 @@ private void reattachPubSub(RedisConnection connection) {
 
     private void refresh(RedisConnection connection, Channel channel) {
         CommandData<?, ?> currentCommand = connection.getCurrentCommand();
+        connection.fireConnected();
         connection.updateChannel(channel);
         
         reattachBlockingQueue(connection, currentCommand);            

File: redisson/src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -290,7 +290,7 @@ public void onConnect(InetSocketAddress addr) {
         Assert.assertEquals(0, pp.stop());
 
         await().atMost(2, TimeUnit.SECONDS).until(() -> assertThat(connectCounter.get()).isEqualTo(1));
-        await().until(() -> assertThat(disconnectCounter.get()).isEqualTo(1));
+        await().atMost(2, TimeUnit.SECONDS).until(() -> assertThat(disconnectCounter.get()).isEqualTo(1));
     }
 
     @Test

File: redisson/src/test/java/org/redisson/RedissonRemoteServiceTest.java
Patch:
@@ -1,5 +1,7 @@
 package org.redisson;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import java.io.IOException;
 import java.io.NotSerializableException;
 import java.io.Serializable;
@@ -10,12 +12,9 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
-import static org.assertj.core.api.Assertions.assertThat;
 
 import org.junit.Assert;
 import org.junit.Test;
-import static org.redisson.BaseTest.createConfig;
-import static org.redisson.BaseTest.createInstance;
 import org.redisson.api.RFuture;
 import org.redisson.api.RedissonClient;
 import org.redisson.api.RemoteInvocationOptions;

File: redisson/src/main/java/org/redisson/RedissonBoundedBlockingQueue.java
Patch:
@@ -216,7 +216,7 @@ public V take() throws InterruptedException {
 
     @Override
     public RFuture<V> pollAsync(long timeout, TimeUnit unit) {
-        RFuture<V> takeFuture = commandExecutor.writeAsync(getName(), codec, RedisCommands.BLPOP_VALUE, getName(), unit.toSeconds(timeout));
+        RFuture<V> takeFuture = commandExecutor.writeAsync(getName(), codec, RedisCommands.BLPOP_VALUE, getName(), toSeconds(timeout, unit));
         return wrapTakeFuture(takeFuture);
     }
 

File: redisson/src/main/java/org/redisson/config/ConfigSupport.java
Patch:
@@ -134,7 +134,7 @@ private void patchUriField(String methodName, String fieldName)
         try {
             Method lowMask = URI.class.getDeclaredMethod(methodName, String.class);
             lowMask.setAccessible(true);
-            long lowMaskValue = (long) lowMask.invoke(null, "-_");
+            Long lowMaskValue = (Long) lowMask.invoke(null, "-_");
             
             Field lowDash = URI.class.getDeclaredField(fieldName);
             

File: redisson/src/test/java/org/redisson/RedissonKeysTest.java
Patch:
@@ -66,6 +66,7 @@ public void testKeysIterable() throws InterruptedException {
         for (int i = 0; i < 115; i++) {
             String key = "key" + Math.random();
             RBucket<String> bucket = redisson.getBucket(key);
+            keys.add(key);
             bucket.set("someValue");
         }
 

File: redisson/src/main/java/org/redisson/RedissonKeys.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;

File: redisson/src/main/java/org/redisson/Redisson.java
Patch:
@@ -137,7 +137,7 @@ public ConnectionManager getConnectionManager() {
      */
     public static RedissonClient create() {
         Config config = new Config();
-        config.useSingleServer().setAddress("127.0.0.1:6379");
+        config.useSingleServer().setAddress("redis://127.0.0.1:6379");
 //        config.useMasterSlaveConnection().setMasterAddress("127.0.0.1:6379").addSlaveAddress("127.0.0.1:6389").addSlaveAddress("127.0.0.1:6399");
 //        config.useSentinelConnection().setMasterName("mymaster").addSentinelAddress("127.0.0.1:26389", "127.0.0.1:26379");
 //        config.useClusterServers().addNodeAddress("127.0.0.1:7000");
@@ -165,7 +165,7 @@ public static RedissonClient create(Config config) {
      */
     public static RedissonReactiveClient createReactive() {
         Config config = new Config();
-        config.useSingleServer().setAddress("127.0.0.1:6379");
+        config.useSingleServer().setAddress("redis://127.0.0.1:6379");
 //        config.useMasterSlaveConnection().setMasterAddress("127.0.0.1:6379").addSlaveAddress("127.0.0.1:6389").addSlaveAddress("127.0.0.1:6399");
 //        config.useSentinelConnection().setMasterName("mymaster").addSentinelAddress("127.0.0.1:26389", "127.0.0.1:26379");
 //        config.useClusterServers().addNodeAddress("127.0.0.1:7000");

File: redisson/src/main/java/org/redisson/RedissonBloomFilter.java
Patch:
@@ -113,7 +113,7 @@ public boolean add(T object) {
     }
 
     private long[] hash(byte[] state, int iterations, long size) {
-        long hash1 = LongHashFunction.xx_r39().hashBytes(state);
+        long hash1 = LongHashFunction.xx().hashBytes(state);
         long hash2 = LongHashFunction.farmUo().hashBytes(state);
 
         long[] indexes = new long[iterations];

File: redisson/src/main/java/org/redisson/api/Node.java
Patch:
@@ -26,7 +26,7 @@
  */
 public interface Node extends NodeAsync {
 
-    enum InfoSection {ALL, DEFAULT, SERVER, CLIENTS, MEMORY, PERSISTENCE, STATS, REPLICATION, CPU, COMMANDSTATS, CLUSTER, KEYSPACE}
+    public enum InfoSection {ALL, DEFAULT, SERVER, CLIENTS, MEMORY, PERSISTENCE, STATS, REPLICATION, CPU, COMMANDSTATS, CLUSTER, KEYSPACE}
     
     Map<String, String> info(InfoSection section);
     

File: redisson/src/main/java/org/redisson/api/NodesGroup.java
Patch:
@@ -43,7 +43,7 @@ public interface NodesGroup<N extends Node> {
     void removeConnectionListener(int listenerId);
 
     /**
-     * Get Redis node by address in format: <code>host:port</code>
+     * Get Redis node by address in format: <code>redis://host:port</code>
      * 
      * @param address of node
      * @return node

File: redisson/src/main/java/org/redisson/api/RKeysAsync.java
Patch:
@@ -41,6 +41,7 @@ public interface RKeysAsync {
      * @param host - destination host
      * @param port - destination port
      * @param database - destination database
+     * @return void 
      */
     RFuture<Void> migrateAsync(String name, String host, int port, int database);
     
@@ -89,6 +90,7 @@ public interface RKeysAsync {
      *
      * @param currentName - current name of object
      * @param newName - new name of object
+     * @return void
      */
     RFuture<Void> renameAsync(String currentName, String newName);
     

File: redisson/src/main/java/org/redisson/api/mapreduce/RCollectionMapReduce.java
Patch:
@@ -93,8 +93,8 @@ public interface RCollectionMapReduce<VIn, KOut, VOut> extends RMapReduceExecuto
     /**
      * Defines timeout for MapReduce process
      * 
-     * @param timeout
-     * @param unit
+     * @param timeout for process
+     * @param unit of timeout
      * @return self instance
      */
     RCollectionMapReduce<VIn, KOut, VOut> timeout(long timeout, TimeUnit unit);

File: redisson/src/main/java/org/redisson/api/mapreduce/RMapReduce.java
Patch:
@@ -88,8 +88,8 @@ public interface RMapReduce<KIn, VIn, KOut, VOut> extends RMapReduceExecutor<VIn
      * Defines timeout for MapReduce process.
      * <code>0</code> means infinity timeout.
      * 
-     * @param timeout
-     * @param unit
+     * @param timeout for process
+     * @param unit of timeout
      * @return self instance
      */
     RMapReduce<KIn, VIn, KOut, VOut> timeout(long timeout, TimeUnit unit);

File: redisson/src/main/java/org/redisson/client/RedisPubSubConnection.java
Patch:
@@ -33,6 +33,7 @@
 import org.redisson.client.protocol.pubsub.PubSubPatternMessageDecoder;
 import org.redisson.client.protocol.pubsub.PubSubStatusMessage;
 import org.redisson.client.protocol.pubsub.PubSubType;
+import org.redisson.misc.RPromise;
 
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
@@ -53,8 +54,8 @@ public class RedisPubSubConnection extends RedisConnection {
     final Set<String> unsubscibedChannels = new HashSet<String>();
     final Set<String> punsubscibedChannels = new HashSet<String>();
 
-    public RedisPubSubConnection(RedisClient redisClient, Channel channel) {
-        super(redisClient, channel);
+    public RedisPubSubConnection(RedisClient redisClient, Channel channel, RPromise<RedisPubSubConnection> connectionPromise) {
+        super(redisClient, channel, connectionPromise);
     }
 
     public void addListener(RedisPubSubListener listener) {

File: redisson/src/main/java/org/redisson/client/protocol/CommandData.java
Patch:
@@ -97,7 +97,7 @@ public List<CommandData<Object, Object>> getPubSubOperations() {
     }
     
     public boolean isBlockingCommand() {
-        return RedisCommands.BLOCKING_COMMANDS.contains(command.getName()) && !promise.isDone();
+        return RedisCommands.BLOCKING_COMMANDS.contains(command.getName());
     }
 
 }

File: redisson/src/main/java/org/redisson/client/protocol/decoder/ClusterNodesDecoder.java
Patch:
@@ -46,7 +46,7 @@ public List<ClusterNodeInfo> decode(ByteBuf buf, State state) throws IOException
             String nodeId = params[0];
             node.setNodeId(nodeId);
 
-            String addr = params[1];
+            String addr = "redis://" + params[1].split("@")[0];
             node.setAddress(addr);
 
             String flags = params[2];

File: redisson/src/main/java/org/redisson/mapreduce/Collector.java
Patch:
@@ -56,7 +56,7 @@ public Collector(Codec codec, RedissonClient client, String name, int parts, lon
     public void emit(K key, V value) {
         try {
             byte[] encodedKey = codec.getValueEncoder().encode(key);
-            long hash = LongHashFunction.xx_r39().hashBytes(encodedKey);
+            long hash = LongHashFunction.xx().hashBytes(encodedKey);
             int part = (int) Math.abs(hash % parts);
             String partName = name + ":" + part;
             

File: redisson/src/main/java/org/redisson/misc/Hash.java
Patch:
@@ -28,7 +28,7 @@ private Hash() {
 
     public static byte[] hash(byte[] objectState) {
         long h1 = LongHashFunction.farmUo().hashBytes(objectState);
-        long h2 = LongHashFunction.xx_r39().hashBytes(objectState);
+        long h2 = LongHashFunction.xx().hashBytes(objectState);
 
         ByteBuf buf = Unpooled.buffer((2 * Long.SIZE) / Byte.SIZE).writeLong(h1).writeLong(h2);
         try {
@@ -41,7 +41,7 @@ public static byte[] hash(byte[] objectState) {
     
     public static String hashToBase64(byte[] objectState) {
         long h1 = LongHashFunction.farmUo().hashBytes(objectState);
-        long h2 = LongHashFunction.xx_r39().hashBytes(objectState);
+        long h2 = LongHashFunction.xx().hashBytes(objectState);
 
         ByteBuf buf = Unpooled.buffer((2 * Long.SIZE) / Byte.SIZE).writeLong(h1).writeLong(h2);
 

File: redisson/src/main/java/org/redisson/spring/cache/RedissonSpringCacheManager.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Map;
+import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.redisson.api.RMap;
@@ -49,7 +50,7 @@ public class RedissonSpringCacheManager implements CacheManager, ResourceLoaderA
     private RedissonClient redisson;
 
     private Map<String, CacheConfig> configMap = new ConcurrentHashMap<String, CacheConfig>();
-    private Map<String, Cache> instanceMap = new ConcurrentHashMap<String, Cache>();
+    private ConcurrentMap<String, Cache> instanceMap = new ConcurrentHashMap<String, Cache>();
 
     private String configLocation;
 

File: redisson/src/main/java/org/redisson/spring/support/RedissonDefinitionParser.java
Patch:
@@ -15,10 +15,11 @@
  */
 package org.redisson.spring.support;
 
+import java.net.URI;
 import java.util.List;
+
 import org.redisson.Redisson;
 import org.redisson.config.Config;
-import org.redisson.misc.URLBuilder;
 import org.springframework.beans.factory.config.BeanDefinition;
 import org.springframework.beans.factory.parsing.BeanComponentDefinition;
 import org.springframework.beans.factory.parsing.CompositeComponentDefinition;
@@ -166,7 +167,7 @@ private void parseAttributes(Element element, ParserContext parserContext, BeanD
                             && ConfigType.masterSlaveServers.name()
                                     .equals(localName)) {
                         try {
-                            value = URLBuilder.create((String) value);
+                            value = URI.create((String) value);
                         } catch (Exception e) {
                             //value may be a placeholder
                             value = "redis://" + value;

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -853,7 +853,8 @@ public RFuture<Map<K, V>> getAllAsync(Set<K> keys) {
         Set<K> mapKeys = new HashSet<K>(keys);
         for (Iterator<K> iterator = mapKeys.iterator(); iterator.hasNext();) {
             K key = iterator.next();
-            CacheValue value = cache.get(key);
+            final CacheKey cacheKey = toCacheKey(key);
+            CacheValue value = cache.get(cacheKey);
             if (value != null) {
                 result.put(key, (V)value.getValue());
                 iterator.remove();

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -853,7 +853,8 @@ public RFuture<Map<K, V>> getAllAsync(Set<K> keys) {
         Set<K> mapKeys = new HashSet<K>(keys);
         for (Iterator<K> iterator = mapKeys.iterator(); iterator.hasNext();) {
             K key = iterator.next();
-            CacheValue value = cache.get(key);
+            final CacheKey cacheKey = toCacheKey(key);
+            CacheValue value = cache.get(cacheKey);
             if (value != null) {
                 result.put(key, (V)value.getValue());
                 iterator.remove();

File: redisson/src/main/java/org/redisson/spring/cache/RedissonSpringCacheManager.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Map;
+import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.redisson.api.RMap;
@@ -49,7 +50,7 @@ public class RedissonSpringCacheManager implements CacheManager, ResourceLoaderA
     private RedissonClient redisson;
 
     private Map<String, CacheConfig> configMap = new ConcurrentHashMap<String, CacheConfig>();
-    private Map<String, Cache> instanceMap = new ConcurrentHashMap<String, Cache>();
+    private ConcurrentMap<String, Cache> instanceMap = new ConcurrentHashMap<String, Cache>();
 
     private String configLocation;
 

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -235,7 +235,7 @@ private void init(UUID id, String name, LocalCachedMapOptions options, RedissonC
         addListeners(name, options, redisson);
     }
 
-    private void addListeners(String name, LocalCachedMapOptions options, RedissonClient redisson) {
+    private void addListeners(String name, final LocalCachedMapOptions options, final RedissonClient redisson) {
         invalidationTopic = new RedissonTopic<Object>(commandExecutor, suffixName(name, "topic"));
 
         if (options.getInvalidationPolicy() == InvalidationPolicy.NONE) {

File: redisson/src/main/java/org/redisson/RedissonGeo.java
Patch:
@@ -443,7 +443,7 @@ public int radiusStore(String fromKey, V member, double radius, GeoUnit geoUnit)
 
 	@Override
 	public RFuture<Integer> radiusStoreAsync(String fromKey, V member, double radius, GeoUnit geoUnit) {
-        return commandExecutor.writeAsync(fromKey, LongCodec.INSTANCE, RedisCommands.GEORADIUSBYMEMBER_STORE_INT, fromKey, member, radius, geoUnit, "STORE", getName());
+        return commandExecutor.writeAsync(fromKey, codec, RedisCommands.GEORADIUSBYMEMBER_STORE_INT, fromKey, member, radius, geoUnit, "STORE", getName());
 	}
 
 	@Override
@@ -453,7 +453,7 @@ public int radiusStore(String fromKey, V member, double radius, GeoUnit geoUnit,
 
 	@Override
 	public RFuture<Integer> radiusStoreAsync(String fromKey, V member, double radius, GeoUnit geoUnit, int count) {
-        return commandExecutor.writeAsync(fromKey, LongCodec.INSTANCE, RedisCommands.GEORADIUSBYMEMBER_STORE_INT, fromKey, member, radius, geoUnit, "COUNT", count, "STORE", getName());
+        return commandExecutor.writeAsync(fromKey, codec, RedisCommands.GEORADIUSBYMEMBER_STORE_INT, fromKey, member, radius, geoUnit, "COUNT", count, "STORE", getName());
 	}
 
 	@Override
@@ -463,7 +463,7 @@ public int radiusStore(String fromKey, V member, double radius, GeoUnit geoUnit,
 
 	@Override
 	public RFuture<Integer> radiusStoreAsync(String fromKey, V member, double radius, GeoUnit geoUnit, GeoOrder geoOrder, int count) {
-        return commandExecutor.writeAsync(fromKey, LongCodec.INSTANCE, RedisCommands.GEORADIUSBYMEMBER_STORE_INT, fromKey, member, radius, geoUnit, geoOrder, "COUNT", count, "STORE", getName());
+        return commandExecutor.writeAsync(fromKey, codec, RedisCommands.GEORADIUSBYMEMBER_STORE_INT, fromKey, member, radius, geoUnit, geoOrder, "COUNT", count, "STORE", getName());
 	}
 
 }

File: redisson/src/main/java/org/redisson/api/listener/StatusListener.java
Patch:
@@ -28,7 +28,7 @@ public interface StatusListener extends EventListener {
 
     /**
      * Executes then Redisson successfully subscribed to channel.
-     * Invoked during re-connection
+     * Invoked during re-connection or failover process
      * 
      * @param channel to subscribe
      */

File: redisson/src/main/java/org/redisson/connection/PubSubConnectionEntry.java
Patch:
@@ -26,7 +26,6 @@
 
 import org.redisson.PubSubMessageListener;
 import org.redisson.PubSubPatternMessageListener;
-import org.redisson.api.listener.MessageListener;
 import org.redisson.client.BaseRedisPubSubListener;
 import org.redisson.client.RedisPubSubConnection;
 import org.redisson.client.RedisPubSubListener;

File: redisson/src/main/java/org/redisson/pubsub/PublishSubscribe.java
Patch:
@@ -98,7 +98,7 @@ public void run() {
                 }
                 
                 RedisPubSubListener<Object> listener = createListener(channelName, value);
-                connectionManager.subscribe(LongCodec.INSTANCE, channelName, listener, semaphore);
+                connectionManager.subscribe(LongCodec.INSTANCE, channelName, semaphore, listener);
             }
         };
         semaphore.acquire(listener);

File: redisson/src/test/java/org/redisson/ClusterRunner.java
Patch:
@@ -86,7 +86,7 @@ private List<String> getClusterConfig(RedisRunner runner) {
             sb.append(me.equals(nodeAddr)
                     ? "myself,"
                     : "");
-            boolean isMaster = !masters.containsKey(nodeId);
+            boolean isMaster = !slaveMasters.containsKey(nodeId);
             if (isMaster) {
                  sb.append("master -");
             } else {

File: redisson/src/test/java/org/redisson/RedisRunner.java
Patch:
@@ -828,7 +828,7 @@ public String defaultDir() {
     }
     
     public String dir() {
-        return this.path;
+        return isRandomDir() ? defaultDir() : this.path;
     }
 
     public String getInitialBindAddr() {

File: redisson/src/main/java/org/redisson/spring/cache/RedissonCache.java
Patch:
@@ -155,7 +155,7 @@ public <T> T get(Object key, Callable<T> valueLoader) {
                             throw new IllegalStateException(e);
                         }
                     }
-                    map.put(key, value);
+                    put(key, value);
                 }
             } finally {
                 lock.unlock();

File: redisson/src/main/java/org/redisson/command/CommandBatchService.java
Patch:
@@ -208,7 +208,7 @@ public void operationComplete(Future<Void> future) throws Exception {
                     return;
                 }
 
-                List<BatchCommandData<?, ?>> entries = new ArrayList<BatchCommandData<?, ?>>();
+                List<BatchCommandData> entries = new ArrayList<BatchCommandData>();
                 for (Entry e : commands.values()) {
                     entries.addAll(e.getCommands());
                 }

File: redisson/src/test/java/org/redisson/RedissonMapCacheTest.java
Patch:
@@ -860,7 +860,7 @@ public void testIssue827() {
         Assert.assertEquals("1", map.get("4"));
         RMapCache<String, Object> mapCache1 = redisson.getMapCache("test_put_if_absent_3");
         Object currValue = mapCache1.putIfAbsent("4", 1.23, 10000L, TimeUnit.SECONDS);
-        Object updatedValue = mapCache1.addAndGet("4", 1L);
+        Object updatedValue = mapCache1.addAndGet("4", 1D);
         System.out.println("updatedValue: " + updatedValue);
     }
 

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -419,7 +419,7 @@ public RFuture<V> addAndGetAsync(K key, Number value) {
                      + "end; "
                  + "end; "
                  + "local newValue = tonumber(ARGV[3]); "
-                 + "if expireDate <= tonumber(ARGV[1]) then "
+                 + "if expireDate >= tonumber(ARGV[1]) then "
                      + "newValue = tonumber(val) + newValue; "
                  + "end; "
                  + "local newValuePack = struct.pack('dLc0', t + tonumber(ARGV[1]), string.len(newValue), newValue); "

File: redisson/src/main/java/org/redisson/RedissonRemoteService.java
Patch:
@@ -183,10 +183,10 @@ Arrays.<Object> asList(ackName, responseName),
                         @Override
                         public void operationComplete(Future<Boolean> future) throws Exception {
                             if (!future.isSuccess()) {
-                                log.error("Can't send ack for request: " + request, future.cause());
                                 if (future.cause() instanceof RedissonShutdownException) {
                                     return;
                                 }
+                                log.error("Can't send ack for request: " + request, future.cause());
                                 // re-subscribe after a failed send (ack)
                                 subscribe(remoteInterface, requestQueue, executor);
                                 return;
@@ -287,11 +287,11 @@ private <T> void invokeMethod(final Class<T> remoteInterface,
                 @Override
                 public void operationComplete(Future<List<?>> future) throws Exception {
                     if (!future.isSuccess()) {
-                        log.error("Can't send response: " + responseHolder.get() + " for request: " + request,
-                                future.cause());
                         if (future.cause() instanceof RedissonShutdownException) {
                             return;
                         }
+                        log.error("Can't send response: " + responseHolder.get() + " for request: " + request,
+                                future.cause());
                     }
                     
                     // re-subscribe anyways (fail or success) after the send

File: redisson/src/main/java/org/redisson/RedissonShutdownException.java
Patch:
@@ -15,7 +15,9 @@
  */
 package org.redisson;
 
-public class RedissonShutdownException extends RuntimeException {
+import org.redisson.client.RedisException;
+
+public class RedissonShutdownException extends RedisException {
 
     private static final long serialVersionUID = -2694051226420789395L;
 

File: redisson/src/main/java/org/redisson/command/CommandBatchService.java
Patch:
@@ -25,6 +25,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.redisson.RedissonReference;
+import org.redisson.RedissonShutdownException;
 import org.redisson.api.RFuture;
 import org.redisson.client.RedisAskException;
 import org.redisson.client.RedisConnection;
@@ -233,7 +234,7 @@ private void execute(final Entry entry, final NodeSource source, final RPromise<
         }
 
         if (!connectionManager.getShutdownLatch().acquire()) {
-            mainPromise.tryFailure(new IllegalStateException("Redisson is shutdown"));
+            mainPromise.tryFailure(new RedissonShutdownException("Redisson is shutdown"));
             return;
         }
 

File: redisson/src/main/java/org/redisson/spring/cache/RedissonCacheStatisticsAutoConfiguration.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2017 Craig Andrews
+ * Copyright 2016 Nikita Koksharov
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: redisson/src/main/java/org/redisson/spring/cache/RedissonCacheStatisticsProvider.java
Patch:
@@ -1,5 +1,5 @@
 /**
- * Copyright 2017 Craig Andrews
+ * Copyright 2016 Nikita Koksharov
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: redisson/src/main/java/org/redisson/api/RedissonClient.java
Patch:
@@ -385,7 +385,7 @@ public interface RedissonClient {
      * 
      * @param <V> type of value
      * @param name - name of object
-     * @return Lock object
+     * @return Set object
      */
     <V> RSet<V> getSet(String name);
 

File: redisson/src/main/java/org/redisson/api/RedissonClient.java
Patch:
@@ -385,7 +385,7 @@ public interface RedissonClient {
      * 
      * @param <V> type of value
      * @param name - name of object
-     * @return Lock object
+     * @return Set object
      */
     <V> RSet<V> getSet(String name);
 

File: redisson/src/test/java/org/redisson/RedissonDelayedQueueTest.java
Patch:
@@ -25,7 +25,7 @@ public void testRemove() throws InterruptedException {
 
         Thread.sleep(9000);
         
-        assertThat(blockingFairQueue.isEmpty()).isTrue();
+        assertThat(blockingFairQueue).containsOnly("1_1_2");
     }
     
     @Test

File: redisson/src/main/java/org/redisson/RedissonRemoteService.java
Patch:
@@ -113,10 +113,10 @@ private <T> void subscribe(final Class<T> remoteInterface, final RBlockingQueue<
             @Override
             public void operationComplete(Future<RemoteServiceRequest> future) throws Exception {
                 if (!future.isSuccess()) {
-                    log.error("Can't process the remote service request.", future.cause());
                     if (future.cause() instanceof RedissonShutdownException) {
                         return;
                     }
+                    log.error("Can't process the remote service request.", future.cause());
                     // re-subscribe after a failed takeAsync
                     subscribe(remoteInterface, requestQueue, executor);
                     return;

File: redisson/src/test/java/org/redisson/RedissonCodecTest.java
Patch:
@@ -14,6 +14,7 @@
 import org.redisson.codec.LZ4Codec;
 import org.redisson.codec.MsgPackJacksonCodec;
 import org.redisson.codec.SerializationCodec;
+import org.redisson.codec.AvroJacksonCodec;
 import org.redisson.codec.SmileJacksonCodec;
 import org.redisson.codec.SnappyCodec;
 import org.redisson.config.Config;
@@ -28,7 +29,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class RedissonCodecTest extends BaseTest {
-    private Codec avroCodec = new SmileJacksonCodec();
+    private Codec avroCodec = new AvroJacksonCodec();
     private Codec smileCodec = new SmileJacksonCodec();
     private Codec codec = new SerializationCodec();
     private Codec kryoCodec = new KryoCodec();

File: redisson/src/test/java/org/redisson/RedisRunner.java
Patch:
@@ -68,7 +68,7 @@ public enum REDIS_OPTIONS {
         SLAVE_PRIORITY,
         MIN_SLAVES_TO_WRITE,
         MIN_SLAVES_MAX_LAG,
-        REQUREPASS,
+        REQUIREPASS,
         RENAME_COMMAND(true),
         MAXCLIENTS,
         MAXMEMORY,
@@ -552,7 +552,7 @@ public RedisRunner minSlaveMaxLag(long minSlaveMaxLag) {
     }
 
     public RedisRunner requirepass(String requirepass) {
-        addConfigOption(REDIS_OPTIONS.REQUREPASS, requirepass);
+        addConfigOption(REDIS_OPTIONS.REQUIREPASS, requirepass);
         return this;
     }
 

File: redisson-tomcat/redisson-tomcat-6/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -143,11 +143,11 @@ public RedissonClient getRedisson() {
     public void start() throws LifecycleException {
         Config config = null;
         try {
-            config = Config.fromJSON(new File(configPath));
+            config = Config.fromJSON(new File(configPath), getClass().getClassLoader());
         } catch (IOException e) {
             // trying next format
             try {
-                config = Config.fromYAML(new File(configPath));
+                config = Config.fromYAML(new File(configPath), getClass().getClassLoader());
             } catch (IOException e1) {
                 log.error("Can't parse json config " + configPath, e);
                 throw new LifecycleException("Can't parse yaml config " + configPath, e1);

File: redisson-tomcat/redisson-tomcat-7/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -146,11 +146,11 @@ protected void startInternal() throws LifecycleException {
         super.startInternal();
         Config config = null;
         try {
-            config = Config.fromJSON(new File(configPath));
+            config = Config.fromJSON(new File(configPath), getClass().getClassLoader());
         } catch (IOException e) {
             // trying next format
             try {
-                config = Config.fromYAML(new File(configPath));
+                config = Config.fromYAML(new File(configPath), getClass().getClassLoader());
             } catch (IOException e1) {
                 log.error("Can't parse json config " + configPath, e);
                 throw new LifecycleException("Can't parse yaml config " + configPath, e1);

File: redisson-tomcat/redisson-tomcat-8/src/main/java/org/redisson/tomcat/RedissonSessionManager.java
Patch:
@@ -146,11 +146,11 @@ protected void startInternal() throws LifecycleException {
         super.startInternal();
         Config config = null;
         try {
-            config = Config.fromJSON(new File(configPath));
+            config = Config.fromJSON(new File(configPath), getClass().getClassLoader());
         } catch (IOException e) {
             // trying next format
             try {
-                config = Config.fromYAML(new File(configPath));
+                config = Config.fromYAML(new File(configPath), getClass().getClassLoader());
             } catch (IOException e1) {
                 log.error("Can't parse json config " + configPath, e);
                 throw new LifecycleException("Can't parse yaml config " + configPath, e1);

File: redisson/src/main/java/org/redisson/api/LocalCachedMapOptions.java
Patch:
@@ -25,7 +25,7 @@
  */
 public class LocalCachedMapOptions {
     
-    public enum EvictionPolicy {NONE, LRU, LFU};
+    public enum EvictionPolicy {NONE, LRU, LFU, SOFT};
     
     private boolean invalidateEntryOnChange;
     private EvictionPolicy evictionPolicy;
@@ -115,6 +115,7 @@ public LocalCachedMapOptions invalidateEntryOnChange(boolean value) {
      * @param evictionPolicy
      *         <p><code>LRU</code> - uses cache with LRU (least recently used) eviction policy.
      *         <p><code>LFU</code> - uses cache with LFU (least frequently used) eviction policy.
+     *         <p><code>SOFT</code> - uses cache with soft references. The garbage collector will evict items from the cache when the JVM is running out of memory.
      *         <p><code>NONE</code> - doesn't use eviction policy, but timeToLive and maxIdleTime params are still working.
      * @return LocalCachedMapOptions instance
      */

File: redisson/src/main/java/org/redisson/cache/Cache.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.redisson.misc;
+package org.redisson.cache;
 
 import java.util.Map;
 import java.util.concurrent.TimeUnit;

File: redisson/src/main/java/org/redisson/cache/LFUCacheMap.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.redisson.misc;
+package org.redisson.cache;
 
 import java.util.Map;
 import java.util.concurrent.ConcurrentNavigableMap;
@@ -57,7 +57,7 @@ public String toString() {
         
     }
     
-    public static class LFUCachedValue extends CachedValue {
+    public static class LFUCachedValue extends StdCachedValue {
 
         Long id;
         long accessCount;

File: redisson/src/main/java/org/redisson/cache/LRUCacheMap.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.redisson.misc;
+package org.redisson.cache;
 
 import java.util.Queue;
 import java.util.concurrent.ConcurrentLinkedQueue;

File: redisson/src/main/java/org/redisson/cache/NoneCacheMap.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.redisson.misc;
+package org.redisson.cache;
 
 /**
  * 

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -671,7 +671,7 @@ public int calcSlot(String key) {
     private Collection<ClusterPartition> parsePartitions(List<ClusterNodeInfo> nodes) {
         Map<String, ClusterPartition> partitions = new HashMap<String, ClusterPartition>();
         for (ClusterNodeInfo clusterNodeInfo : nodes) {
-            if (clusterNodeInfo.containsFlag(Flag.NOADDR)) {
+            if (clusterNodeInfo.containsFlag(Flag.NOADDR) || clusterNodeInfo.containsFlag(Flag.HANDSHAKE)) {
                 // skip it
                 continue;
             }

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -320,7 +320,7 @@ protected MasterSlaveServersConfig create(BaseMasterSlaveServersConfig<?> cfg) {
         c.setClientName(cfg.getClientName());
         c.setMasterConnectionPoolSize(cfg.getMasterConnectionPoolSize());
         c.setSlaveConnectionPoolSize(cfg.getSlaveConnectionPoolSize());
-        c.setSlaveSubscriptionConnectionPoolSize(cfg.getSlaveSubscriptionConnectionPoolSize());
+        c.setSubscriptionConnectionPoolSize(cfg.getSubscriptionConnectionPoolSize());
         c.setSubscriptionsPerConnection(cfg.getSubscriptionsPerConnection());
         c.setConnectTimeout(cfg.getConnectTimeout());
         c.setIdleConnectionTimeout(cfg.getIdleConnectionTimeout());
@@ -329,8 +329,9 @@ protected MasterSlaveServersConfig create(BaseMasterSlaveServersConfig<?> cfg) {
         c.setReconnectionTimeout(cfg.getReconnectionTimeout());
         c.setMasterConnectionMinimumIdleSize(cfg.getMasterConnectionMinimumIdleSize());
         c.setSlaveConnectionMinimumIdleSize(cfg.getSlaveConnectionMinimumIdleSize());
-        c.setSlaveSubscriptionConnectionMinimumIdleSize(cfg.getSlaveSubscriptionConnectionMinimumIdleSize());
+        c.setSubscriptionConnectionMinimumIdleSize(cfg.getSubscriptionConnectionMinimumIdleSize());
         c.setReadMode(cfg.getReadMode());
+        c.setSubscriptionMode(cfg.getSubscriptionMode());
 
         return c;
     }

File: redisson/src/main/java/org/redisson/connection/pool/PubSubConnectionPool.java
Patch:
@@ -47,7 +47,7 @@ protected RedisPubSubConnection poll(ClientConnectionsEntry entry) {
 
     @Override
     protected int getMinimumIdleSize(ClientConnectionsEntry entry) {
-        return config.getSlaveSubscriptionConnectionMinimumIdleSize();
+        return config.getSubscriptionConnectionMinimumIdleSize();
     }
 
     @Override

File: redisson/src/main/java/org/redisson/pubsub/PublishSubscribe.java
Patch:
@@ -34,7 +34,6 @@
  * 
  * @author Nikita Koksharov
  *
- * @param <E>
  */
 abstract class PublishSubscribe<E extends PubSubEntry<E>> {
 

File: redisson/src/test/java/org/redisson/RedissonLocalCachedMapTest.java
Patch:
@@ -18,10 +18,10 @@
 import org.redisson.RedissonMapTest.SimpleValue;
 import org.redisson.api.LocalCachedMapOptions;
 import org.redisson.api.LocalCachedMapOptions.EvictionPolicy;
+import org.redisson.cache.Cache;
 import org.redisson.api.RLocalCachedMap;
 import org.redisson.api.RMap;
 import org.redisson.api.RedissonClient;
-import org.redisson.misc.Cache;
 
 import mockit.Deencapsulation;
 

File: redisson/src/test/java/org/redisson/misc/LFUCacheMapTest.java
Patch:
@@ -5,6 +5,8 @@
 import java.util.concurrent.TimeUnit;
 
 import org.junit.Test;
+import org.redisson.cache.Cache;
+import org.redisson.cache.LFUCacheMap;
 
 public class LFUCacheMapTest {
 

File: redisson/src/test/java/org/redisson/misc/LRUCacheMapTest.java
Patch:
@@ -5,6 +5,8 @@
 import java.util.concurrent.TimeUnit;
 
 import org.junit.Test;
+import org.redisson.cache.Cache;
+import org.redisson.cache.LRUCacheMap;
 
 public class LRUCacheMapTest {
 

File: redisson/src/main/java/org/redisson/config/Config.java
Patch:
@@ -573,7 +573,7 @@ public static Config fromJSON(File file, ClassLoader classLoader) throws IOExcep
      * @throws IOException error
      */
     public static Config fromJSON(File file) throws IOException {
-        return fromJSON(file);
+        return fromJSON(file, null);
     }
 
     /**
@@ -643,8 +643,7 @@ public static Config fromYAML(InputStream inputStream) throws IOException {
      * @throws IOException error
      */
     public static Config fromYAML(File file) throws IOException {
-        ConfigSupport support = new ConfigSupport();
-        return support.fromYAML(file, Config.class);
+        return fromYAML(file, null);
     }
     
     public static Config fromYAML(File file, ClassLoader classLoader) throws IOException {

File: redisson/src/main/java/org/redisson/config/BaseMasterSlaveServersConfig.java
Patch:
@@ -159,7 +159,7 @@ public int getSlaveSubscriptionConnectionPoolSize() {
      * <p>
      * @see #setSubscriptionConnectionMinimumIdleSize(int)
      * 
-     * @param slaveSubscriptionConnectionPoolSize - pool size
+     * @param subscriptionConnectionPoolSize - pool size
      * @return config
      */
     public T setSubscriptionConnectionPoolSize(int subscriptionConnectionPoolSize) {
@@ -229,7 +229,7 @@ public int getSlaveSubscriptionConnectionMinimumIdleSize() {
      * <p>
      * @see #setSubscriptionConnectionPoolSize(int)
      * 
-     * @param slaveSubscriptionConnectionMinimumIdleSize - pool size
+     * @param subscriptionConnectionMinimumIdleSize - pool size
      * @return config
      */
     public T setSubscriptionConnectionMinimumIdleSize(int subscriptionConnectionMinimumIdleSize) {

File: redisson/src/main/java/org/redisson/pubsub/PublishSubscribe.java
Patch:
@@ -34,7 +34,6 @@
  * 
  * @author Nikita Koksharov
  *
- * @param <E>
  */
 abstract class PublishSubscribe<E extends PubSubEntry<E>> {
 

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -671,7 +671,7 @@ public int calcSlot(String key) {
     private Collection<ClusterPartition> parsePartitions(List<ClusterNodeInfo> nodes) {
         Map<String, ClusterPartition> partitions = new HashMap<String, ClusterPartition>();
         for (ClusterNodeInfo clusterNodeInfo : nodes) {
-            if (clusterNodeInfo.containsFlag(Flag.NOADDR)) {
+            if (clusterNodeInfo.containsFlag(Flag.NOADDR) || clusterNodeInfo.containsFlag(Flag.HANDSHAKE)) {
                 // skip it
                 continue;
             }

File: redisson/src/main/java/org/redisson/misc/URLBuilder.java
Patch:
@@ -83,6 +83,8 @@ public static void replaceURLFactory() {
             
             if (currentFactory != newFactory) {
                 URL.setURLStreamHandlerFactory(newFactory);
+            } else {
+                currentFactory = null;
             }
         } catch (Exception e) {
             throw new IllegalStateException(e);

File: redisson/src/main/java/org/redisson/misc/URLBuilder.java
Patch:
@@ -77,7 +77,7 @@ public static void replaceURLFactory() {
             Field field = URL.class.getDeclaredField("factory");
             field.setAccessible(true);
             currentFactory = (URLStreamHandlerFactory) field.get(null);
-            if (currentFactory != null) {
+            if (currentFactory != null && currentFactory != newFactory) {
                 field.set(null, null);
             }
             

File: redisson/src/main/java/org/redisson/RedissonPriorityQueue.java
Patch:
@@ -35,7 +35,6 @@
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.command.CommandExecutor;
-import org.redisson.misc.RPromise;
 
 /**
  *

File: redisson/src/main/java/org/redisson/api/RLockAsync.java
Patch:
@@ -19,8 +19,6 @@
 
 /**
  * Distributed implementation of {@link java.util.concurrent.locks.Lock}
- * Implements reentrant lock.
- * Use {@link RLockAsync#getHoldCount()} to get a holds count.
  *
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/config/Config.java
Patch:
@@ -238,6 +238,8 @@ void setClusterServersConfig(ClusterServersConfig clusterServersConfig) {
     /**
      *
      * Use {@link #useReplicatedServers()}
+     * 
+     * @return config object
      */
     @Deprecated
     public ElasticacheServersConfig useElasticacheServers() {

File: redisson/src/main/java/org/redisson/RedissonRemoteService.java
Patch:
@@ -113,6 +113,7 @@ private <T> void subscribe(final Class<T> remoteInterface, final RBlockingQueue<
             @Override
             public void operationComplete(Future<RemoteServiceRequest> future) throws Exception {
                 if (!future.isSuccess()) {
+                    log.error("Can't process the remote service request.", future.cause());
                     if (future.cause() instanceof RedissonShutdownException) {
                         return;
                     }

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -216,7 +216,7 @@ private void init(UUID id, String name, LocalCachedMapOptions options) {
             cache = new LFUCacheMap<CacheKey, CacheValue>(options.getCacheSize(), options.getTimeToLiveInMillis(), options.getMaxIdleInMillis());
         }
 
-        invalidationTopic = new RedissonTopic<Object>(commandExecutor, name + ":topic");
+        invalidationTopic = new RedissonTopic<Object>(commandExecutor, suffixName(name, "topic"));
         if (options.isInvalidateEntryOnChange()) {
             invalidationListenerId = invalidationTopic.addListener(new MessageListener<Object>() {
                 @Override

File: redisson/src/main/java/org/redisson/RedissonPermitExpirableSemaphore.java
Patch:
@@ -672,7 +672,8 @@ public RFuture<Integer> availablePermitsAsync() {
                     "end;" + 
                     "return value; " +
                 "end; " +
-                "return redis.call('get', KEYS[1]); ",
+                "local ret = redis.call('get', KEYS[1]); " + 
+                "return ret == false and 0 or ret;",
                 Arrays.<Object>asList(getName(), timeoutName, getChannelName()), System.currentTimeMillis());
     }
 

File: redisson/src/test/java/org/redisson/RedissonLocalCachedMapTest.java
Patch:
@@ -27,7 +27,7 @@
 
 public class RedissonLocalCachedMapTest extends BaseTest {
 
-//    @Test
+    //    @Test
     public void testPerf() {
         LocalCachedMapOptions options = LocalCachedMapOptions.defaults().evictionPolicy(EvictionPolicy.LFU).cacheSize(100000).invalidateEntryOnChange(true);
         Map<String, Integer> map = redisson.getLocalCachedMap("test", options);

File: redisson/src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -34,7 +34,7 @@
 import org.redisson.api.RMap;
 import org.redisson.api.RedissonClient;
 import org.redisson.client.codec.Codec;
-import org.redisson.client.codec.ScanCodec;
+import org.redisson.client.codec.MapScanCodec;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.client.protocol.RedisCommand.ValueType;
@@ -454,7 +454,7 @@ public long fastRemove(K ... keys) {
 
     MapScanResult<ScanObjectEntry, ScanObjectEntry> scanIterator(String name, InetSocketAddress client, long startPos) {
         RFuture<MapScanResult<ScanObjectEntry, ScanObjectEntry>> f 
-            = commandExecutor.readAsync(client, name, new ScanCodec(codec), RedisCommands.HSCAN, name, startPos);
+            = commandExecutor.readAsync(client, name, new MapScanCodec(codec), RedisCommands.HSCAN, name, startPos);
         return get(f);
     }
 

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -30,7 +30,7 @@
 import org.redisson.api.RedissonClient;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.codec.LongCodec;
-import org.redisson.client.codec.ScanCodec;
+import org.redisson.client.codec.MapScanCodec;
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.client.protocol.RedisCommand.ValueType;
 import org.redisson.client.protocol.RedisCommands;
@@ -531,7 +531,7 @@ public RFuture<Long> fastRemoveAsync(K ... keys) {
     @Override
     MapScanResult<ScanObjectEntry, ScanObjectEntry> scanIterator(String name, InetSocketAddress client, long startPos) {
         RedisCommand<MapCacheScanResult<Object, Object>> EVAL_HSCAN = new RedisCommand<MapCacheScanResult<Object, Object>>("EVAL", 
-                new ListMultiDecoder(new LongMultiDecoder(), new ObjectMapDecoder(new ScanCodec(codec)), new ObjectListDecoder(codec), new MapCacheScanResultReplayDecoder()), ValueType.MAP);
+                new ListMultiDecoder(new LongMultiDecoder(), new ObjectMapDecoder(new MapScanCodec(codec)), new ObjectListDecoder(codec), new MapCacheScanResultReplayDecoder()), ValueType.MAP);
         RFuture<MapCacheScanResult<ScanObjectEntry, ScanObjectEntry>> f = commandExecutor.evalReadAsync(client, getName(), codec, EVAL_HSCAN,
                 "local result = {}; "
                 + "local idleKeys = {}; "

File: redisson/src/main/java/org/redisson/RedissonMultimap.java
Patch:
@@ -35,7 +35,7 @@
 import org.redisson.api.RedissonClient;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.codec.LongCodec;
-import org.redisson.client.codec.ScanCodec;
+import org.redisson.client.codec.MapScanCodec;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.client.protocol.RedisCommands;
@@ -271,7 +271,7 @@ public RFuture<Integer> keySizeAsync() {
     
     
     MapScanResult<ScanObjectEntry, ScanObjectEntry> scanIterator(InetSocketAddress client, long startPos) {
-        RFuture<MapScanResult<ScanObjectEntry, ScanObjectEntry>> f = commandExecutor.readAsync(client, getName(), new ScanCodec(codec, StringCodec.INSTANCE), RedisCommands.HSCAN, getName(), startPos);
+        RFuture<MapScanResult<ScanObjectEntry, ScanObjectEntry>> f = commandExecutor.readAsync(client, getName(), new MapScanCodec(codec, StringCodec.INSTANCE), RedisCommands.HSCAN, getName(), startPos);
         return get(f);
     }
 

File: redisson/src/main/java/org/redisson/jcache/JCache.java
Patch:
@@ -58,7 +58,7 @@
 import org.redisson.api.RSemaphore;
 import org.redisson.api.RTopic;
 import org.redisson.api.listener.MessageListener;
-import org.redisson.client.codec.ScanCodec;
+import org.redisson.client.codec.MapScanCodec;
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.client.protocol.RedisCommand.ValueType;
 import org.redisson.client.protocol.RedisCommands;
@@ -2089,7 +2089,7 @@ public void removeAll(Set<? extends K> keys) {
     
     MapScanResult<ScanObjectEntry, ScanObjectEntry> scanIterator(String name, InetSocketAddress client, long startPos) {
         RFuture<MapScanResult<ScanObjectEntry, ScanObjectEntry>> f 
-            = commandExecutor.readAsync(client, name, new ScanCodec(codec), RedisCommands.HSCAN, name, startPos);
+            = commandExecutor.readAsync(client, name, new MapScanCodec(codec), RedisCommands.HSCAN, name, startPos);
         return get(f);
     }
 

File: redisson/src/main/java/org/redisson/reactive/RedissonMapCacheReactive.java
Patch:
@@ -30,7 +30,7 @@
 import org.redisson.api.RMapCacheReactive;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.codec.LongCodec;
-import org.redisson.client.codec.ScanCodec;
+import org.redisson.client.codec.MapScanCodec;
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.client.protocol.RedisCommand.ValueType;
 import org.redisson.client.protocol.RedisCommands;
@@ -342,7 +342,7 @@ public Publisher<Long> fastRemove(K ... keys) {
 
     @Override
     Publisher<MapScanResult<ScanObjectEntry, ScanObjectEntry>> scanIteratorReactive(InetSocketAddress client, long startPos) {
-        return commandExecutor.evalReadReactive(client, getName(), new ScanCodec(codec), EVAL_HSCAN,
+        return commandExecutor.evalReadReactive(client, getName(), new MapScanCodec(codec), EVAL_HSCAN,
                 "local result = {}; "
                 + "local res = redis.call('hscan', KEYS[1], ARGV[1]); "
                 + "for i, value in ipairs(res[2]) do "

File: redisson/src/main/java/org/redisson/reactive/RedissonMapReactive.java
Patch:
@@ -24,7 +24,7 @@
 import org.redisson.RedissonMap;
 import org.redisson.api.RMapReactive;
 import org.redisson.client.codec.Codec;
-import org.redisson.client.codec.ScanCodec;
+import org.redisson.client.codec.MapScanCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.decoder.MapScanResult;
 import org.redisson.client.protocol.decoder.ScanObjectEntry;
@@ -130,7 +130,7 @@ public Publisher<Long> fastRemove(K ... keys) {
     }
 
     Publisher<MapScanResult<ScanObjectEntry, ScanObjectEntry>> scanIteratorReactive(InetSocketAddress client, long startPos) {
-        return commandExecutor.readReactive(client, getName(), new ScanCodec(codec), RedisCommands.HSCAN, getName(), startPos);
+        return commandExecutor.readReactive(client, getName(), new MapScanCodec(codec), RedisCommands.HSCAN, getName(), startPos);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/reactive/RedissonSetCacheReactive.java
Patch:
@@ -30,6 +30,7 @@
 import org.redisson.client.codec.Codec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.decoder.ListScanResult;
+import org.redisson.client.protocol.decoder.ScanObjectEntry;
 import org.redisson.command.CommandReactiveExecutor;
 
 /**
@@ -76,15 +77,15 @@ public Publisher<Boolean> contains(Object o) {
         return reactive(instance.containsAsync(o));
     }
 
-    Publisher<ListScanResult<V>> scanIterator(InetSocketAddress client, long startPos) {
+    Publisher<ListScanResult<ScanObjectEntry>> scanIterator(InetSocketAddress client, long startPos) {
         return reactive(instance.scanIteratorAsync(client, startPos));
     }
 
     @Override
     public Publisher<V> iterator() {
         return new SetReactiveIterator<V>() {
             @Override
-            protected Publisher<ListScanResult<V>> scanIteratorReactive(InetSocketAddress client, long nextIterPos) {
+            protected Publisher<ListScanResult<ScanObjectEntry>> scanIteratorReactive(InetSocketAddress client, long nextIterPos) {
                 return RedissonSetCacheReactive.this.scanIterator(client, nextIterPos);
             }
         };

File: redisson/src/test/java/org/redisson/RedissonScoredSortedSetReactiveTest.java
Patch:
@@ -86,9 +86,9 @@ public void testAddAsync() throws InterruptedException, ExecutionException {
     @Test
     public void testRemoveAsync() throws InterruptedException, ExecutionException {
         RScoredSortedSetReactive<Integer> set = redisson.getScoredSortedSet("simple");
-        set.add(0.11, 1);
-        set.add(0.22, 3);
-        set.add(0.33, 7);
+        sync(set.add(0.11, 1));
+        sync(set.add(0.22, 3));
+        sync(set.add(0.33, 7));
 
         Assert.assertTrue(sync(set.remove(1)));
         Assert.assertFalse(sync(set.contains(1)));

File: redisson/src/main/java/org/redisson/connection/pool/ConnectionPool.java
Patch:
@@ -201,7 +201,7 @@ && tryAcquireConnection(entry)) {
         return connectionManager.newFailedFuture(exception);
     }
 
-    private RFuture<T> acquireConnection(RedisCommand<?> command, ClientConnectionsEntry entry) {
+    private RFuture<T> acquireConnection(RedisCommand<?> command, final ClientConnectionsEntry entry) {
         final RPromise<T> result = connectionManager.newPromise();
         acquireConnection(entry, new Runnable() {
             @Override

File: redisson/src/main/java/org/redisson/api/NodesGroup.java
Patch:
@@ -45,7 +45,7 @@ public interface NodesGroup<N extends Node> {
     /**
      * Get Redis node by address in format: <code>host:port</code>
      * 
-     * @param address
+     * @param address of node
      * @return node
      */
     N getNode(String address);

File: redisson/src/main/java/org/redisson/api/RBloomFilter.java
Patch:
@@ -18,8 +18,6 @@
 /**
  * Bloom filter based on 64-bit hash derived from 128-bit hash (xxHash + FarmHash).
  *
- * Code parts from Guava BloomFilter
- *
  * @author Nikita Koksharov
  *
  * @param <T> - type of object

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -300,7 +300,8 @@ private void decode(ByteBuf in, CommandData<Object, Object> data, List<Object> p
             
             decodeList(in, data, parts, channel, size, respParts);
         } else {
-            throw new IllegalStateException("Can't decode replay " + (char)code);
+            String dataStr = in.toString(0, in.writerIndex(), CharsetUtil.UTF_8);
+            throw new IllegalStateException("Can't decode replay: " + dataStr);
         }
     }
 

File: redisson/src/main/java/org/redisson/api/NodesGroup.java
Patch:
@@ -46,7 +46,7 @@ public interface NodesGroup<N extends Node> {
      * Get Redis node by address in format: <code>host:port</code>
      * 
      * @param address
-     * @return
+     * @return node
      */
     N getNode(String address);
     

File: redisson/src/main/java/org/redisson/api/RDelayedQueue.java
Patch:
@@ -42,6 +42,7 @@ public interface RDelayedQueue<V> extends RQueue<V>, RDestroyable {
      * @param e the element to add
      * @param delay for transition
      * @param timeUnit for delay
+     * @return void
      */
     RFuture<Void> offerAsync(V e, long delay, TimeUnit timeUnit);
     

File: redisson/src/main/java/org/redisson/api/RMapCacheAsync.java
Patch:
@@ -19,7 +19,7 @@
 
 /**
  * <p>Map-based cache with ability to set TTL for each entry via
- * {@link #put(Object, Object, long, TimeUnit)} or {@link #putIfAbsent(Object, Object, long, TimeUnit)}
+ * {@link RMapCache#put(Object, Object, long, TimeUnit)} or {@link RMapCache#putIfAbsent(Object, Object, long, TimeUnit)}
  * And therefore has an complex lua-scripts inside.</p>
  *
  * <p>Current redis implementation doesnt have map entry eviction functionality.

File: redisson/src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -16,7 +16,7 @@
 package org.redisson.connection;
 
 import java.net.InetSocketAddress;
-import java.net.URI;
+import java.net.URL;
 import java.util.Collection;
 import java.util.Set;
 import java.util.concurrent.ExecutorService;
@@ -47,7 +47,7 @@ public interface ConnectionManager {
     
     ExecutorService getExecutor();
     
-    URI getLastClusterNode();
+    URL getLastClusterNode();
 
     boolean isClusterMode();
 

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -16,7 +16,7 @@
 package org.redisson.connection;
 
 import java.net.InetSocketAddress;
-import java.net.URI;
+import java.net.URL;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
@@ -280,7 +280,7 @@ protected void initEntry(MasterSlaveServersConfig config) {
     protected MasterSlaveEntry createMasterSlaveEntry(MasterSlaveServersConfig config,
             HashSet<ClusterSlotRange> slots) {
         MasterSlaveEntry entry = new MasterSlaveEntry(slots, this, config);
-        List<RFuture<Void>> fs = entry.initSlaveBalancer(java.util.Collections.<URI>emptySet());
+        List<RFuture<Void>> fs = entry.initSlaveBalancer(java.util.Collections.<URL>emptySet());
         for (RFuture<Void> future : fs) {
             future.syncUninterruptibly();
         }
@@ -835,7 +835,7 @@ public ExecutorService getExecutor() {
         return executor;
     }
     
-    public URI getLastClusterNode() {
+    public URL getLastClusterNode() {
         return null;
     }
 }

File: redisson/src/main/java/org/redisson/connection/balancer/WeightedRoundRobinBalancer.java
Patch:
@@ -16,7 +16,7 @@
 package org.redisson.connection.balancer;
 
 import java.net.InetSocketAddress;
-import java.net.URI;
+import java.net.URL;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -28,7 +28,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.redisson.connection.ClientConnectionsEntry;
-import org.redisson.misc.URIBuilder;
+import org.redisson.misc.URLBuilder;
 
 import io.netty.util.internal.PlatformDependent;
 
@@ -78,7 +78,7 @@ public void resetWeightCounter() {
      */
     public WeightedRoundRobinBalancer(Map<String, Integer> weights, int defaultWeight) {
         for (Entry<String, Integer> entry : weights.entrySet()) {
-            URI uri = URIBuilder.create(entry.getKey());
+            URL uri = URLBuilder.create(entry.getKey());
             InetSocketAddress addr = new InetSocketAddress(uri.getHost(), uri.getPort());
             if (entry.getValue() <= 0) {
                 throw new IllegalArgumentException("Weight can't be less than or equal zero");

File: redisson/src/test/java/org/redisson/client/protocol/decoder/ClusterNodesDecoderTest.java
Patch:
@@ -28,6 +28,7 @@ public void test() throws IOException {
         buf.writeBytes(src);
         List<ClusterNodeInfo> nodes = decoder.decode(buf, null);
         ClusterNodeInfo node = nodes.get(0);
+        Assert.assertEquals("192.168.234.129", node.getAddress().getHost());
         Assert.assertEquals(7001, node.getAddress().getPort());
     }
     

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -389,6 +389,9 @@ private void handleResult(CommandData<Object, Object> data, List<Object> parts,
 
     private MultiDecoder<Object> messageDecoder(CommandData<Object, Object> data, List<Object> parts, Channel channel) {
         if (data == null) {
+            if (parts.isEmpty()) {
+                return null;
+            }
             String command = parts.get(0).toString();
             if (Arrays.asList("subscribe", "psubscribe", "punsubscribe", "unsubscribe").contains(command)) {
                 String channelName = parts.get(1).toString();

File: redisson/src/main/java/org/redisson/api/RedissonClient.java
Patch:
@@ -507,6 +507,7 @@ public interface RedissonClient {
     /**
      * Returns unbounded fair queue instance by name.
      * 
+     * @param <V> type of value
      * @param name of queue
      * @return queue
      */
@@ -529,6 +530,7 @@ public interface RedissonClient {
      * Could be attached to destination queue only.
      * All elements are inserted with transfer delay to destination queue.
      * 
+     * @param <V> type of value
      * @param destinationQueue - destination queue
      * @return delayed queue
      */

File: redisson/src/main/java/org/redisson/jcache/JMutableEntry.java
Patch:
@@ -21,8 +21,8 @@
  * 
  * @author Nikita Koksharov
  *
- * @param <K>
- * @param <V>
+ * @param <K> key
+ * @param <V> value
  */
 public class JMutableEntry<K, V> implements MutableEntry<K, V> {
 

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -744,7 +744,6 @@ public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {
         for (MasterSlaveEntry entry : entries.values()) {
             entry.shutdown();
         }
-        timer.stop();
         
         if (!sharedExecutor) {
             executor.shutdown();
@@ -758,6 +757,7 @@ public void shutdown(long quietPeriod, long timeout, TimeUnit unit) {
         if (!sharedEventLoopGroup) {
             group.shutdownGracefully(quietPeriod, timeout, unit).syncUninterruptibly();
         }
+        timer.stop();
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonBlockingDeque.java
Patch:
@@ -231,7 +231,7 @@ public RFuture<V> pollLastFromAnyAsync(long timeout, TimeUnit unit, String ... q
         for (Object name : queueNames) {
             params.add(name);
         }
-        params.add(unit.toSeconds(timeout));
+        params.add(toSeconds(timeout, unit));
         return commandExecutor.writeAsync(getName(), codec, RedisCommands.BRPOP_VALUE, params.toArray());
     }
 
@@ -243,7 +243,7 @@ public V pollFirst(long timeout, TimeUnit unit) throws InterruptedException {
 
     @Override
     public RFuture<V> pollLastAsync(long timeout, TimeUnit unit) {
-        return commandExecutor.writeAsync(getName(), codec, RedisCommands.BRPOP_VALUE, getName(), unit.toSeconds(timeout));
+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.BRPOP_VALUE, getName(), toSeconds(timeout, unit));
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonBlockingQueue.java
Patch:
@@ -84,7 +84,7 @@ public V take() throws InterruptedException {
 
     @Override
     public RFuture<V> pollAsync(long timeout, TimeUnit unit) {
-        return commandExecutor.writeAsync(getName(), codec, RedisCommands.BLPOP_VALUE, getName(), unit.toSeconds(timeout));
+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.BLPOP_VALUE, getName(), toSeconds(timeout, unit));
     }
 
     /*
@@ -118,13 +118,13 @@ public RFuture<V> pollFromAnyAsync(long timeout, TimeUnit unit, String ... queue
         for (Object name : queueNames) {
             params.add(name);
         }
-        params.add(unit.toSeconds(timeout));
+        params.add(toSeconds(timeout, unit));
         return commandExecutor.writeAsync(getName(), codec, RedisCommands.BLPOP_VALUE, params.toArray());
     }
 
     @Override
     public RFuture<V> pollLastAndOfferFirstToAsync(String queueName, long timeout, TimeUnit unit) {
-        return commandExecutor.writeAsync(getName(), codec, RedisCommands.BRPOPLPUSH, getName(), queueName, unit.toSeconds(timeout));
+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.BRPOPLPUSH, getName(), queueName, toSeconds(timeout, unit));
     }
 
     @Override

File: redisson/src/test/java/org/redisson/BaseTest.java
Patch:
@@ -60,9 +60,7 @@ public static Config createConfig() {
 //        config.useSentinelServers().setMasterName("mymaster").addSentinelAddress("127.0.0.1:26379", "127.0.0.1:26389");
 //        config.useClusterServers().addNodeAddress("127.0.0.1:7004", "127.0.0.1:7001", "127.0.0.1:7000");
         config.useSingleServer()
-                .setAddress(RedisRunner.getDefaultRedisServerBindAddressAndPort())
-                .setConnectTimeout(1000000)
-                .setTimeout(1000000);
+                .setAddress(RedisRunner.getDefaultRedisServerBindAddressAndPort());
 //        .setPassword("mypass1");
 //        config.useMasterSlaveConnection()
 //        .setMasterAddress("127.0.0.1:6379")

File: redisson/src/test/java/org/redisson/RedissonTopicPatternTest.java
Patch:
@@ -305,6 +305,7 @@ public void onMessage(String pattern, String channel, Integer msg) {
         
         await().atMost(5, TimeUnit.SECONDS).untilTrue(executed);
         
+        redisson.shutdown();
         runner.stop();
     }
     

File: redisson/src/test/java/org/redisson/RedissonTopicTest.java
Patch:
@@ -463,6 +463,7 @@ public void onMessage(String channel, Integer msg) {
         
         await().atMost(5, TimeUnit.SECONDS).untilTrue(executed);
         
+        redisson.shutdown();
         runner.stop();
     }
 

File: redisson/src/main/java/org/redisson/connection/decoder/MapGetAllDecoder.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.io.IOException;
 import java.util.Collections;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -57,7 +57,7 @@ public Map<Object, Object> decode(List<Object> parts, State state) {
         if (parts.isEmpty()) {
             return Collections.emptyMap();
         }
-        Map<Object, Object> result = new HashMap<Object, Object>(parts.size());
+        Map<Object, Object> result = new LinkedHashMap<Object, Object>(parts.size());
         for (int index = 0; index < args.size()-shiftIndex; index++) {
             Object value = parts.get(index);
             if (!allowNulls && value == null) {

File: redisson-tomcat/redisson-tomcat-7/src/test/java/org/redisson/tomcat/TomcatServer.java
Patch:
@@ -54,6 +54,7 @@ public void stop() throws LifecycleException {
 
         tomcat.stop();
         tomcat.destroy();
+        tomcat.getServer().await();
         isRunning = false;
     }
 

File: redisson-tomcat/redisson-tomcat-8/src/test/java/org/redisson/tomcat/TomcatServer.java
Patch:
@@ -54,6 +54,7 @@ public void stop() throws LifecycleException {
 
         tomcat.stop();
         tomcat.destroy();
+        tomcat.getServer().await();
         isRunning = false;
     }
 

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -381,7 +381,7 @@ private void handleResult(CommandData<Object, Object> data, List<Object> parts,
         if (parts != null) {
             parts.add(result);
         } else {
-            if (!data.getPromise().trySuccess(result) && data.cause() instanceof RedisTimeoutException) {
+            if (data != null && !data.getPromise().trySuccess(result) && data.cause() instanceof RedisTimeoutException) {
                 log.warn("response has been skipped due to timeout! channel: {}, command: {}, result: {}", channel, data, result);
             }
         }

File: redisson/src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -674,14 +674,14 @@ private MasterSlaveEntry getEntry(NodeSource source) {
         if (source.getRedirect() != null) {
             MasterSlaveEntry e = getEntry(source.getAddr());
             if (e == null) {
-                throw new RedisNodeNotFoundException("No node for slot: " + source.getAddr());
+                throw new RedisNodeNotFoundException("Node: " + source.getAddr() + " for slot: " + source.getSlot() + " hasn't been discovered yet");
             }
             return e;
         }
         
         MasterSlaveEntry e = getEntry(source.getSlot());
         if (e == null) {
-            throw new RedisNodeNotFoundException("No node with slot: " + source.getSlot());
+            throw new RedisNodeNotFoundException("Node: " + source.getAddr() + " for slot: " + source.getSlot() + " hasn't been discovered yet");
         }
         return e;
     }

File: redisson/src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -45,6 +45,7 @@
 import org.redisson.client.protocol.pubsub.PubSubMessage;
 import org.redisson.client.protocol.pubsub.PubSubPatternMessage;
 import org.redisson.client.protocol.pubsub.PubSubStatusMessage;
+import org.redisson.misc.LogHelper;
 import org.redisson.misc.RPromise;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -203,11 +204,11 @@ private void decodeCommandBatch(ChannelHandlerContext ctx, ByteBuf in, QueueComm
             RPromise<Void> promise = commandBatch.getPromise();
             if (error != null) {
                 if (!promise.tryFailure(error) && promise.cause() instanceof RedisTimeoutException) {
-                    log.warn("response has been skipped due to timeout! channel: {}, command: {}", ctx.channel(), data);
+                    log.warn("response has been skipped due to timeout! channel: {}, command: {}",ctx.channel(), LogHelper.toString(data));
                 }
             } else {
                 if (!promise.trySuccess(null) && promise.cause() instanceof RedisTimeoutException) {
-                    log.warn("response has been skipped due to timeout! channel: {}, command: {}", ctx.channel(), data);
+                    log.warn("response has been skipped due to timeout! channel: {}, command: {}", ctx.channel(), LogHelper.toString(data));
                 }
             }
             

File: redisson/src/main/java/org/redisson/client/protocol/CommandData.java
Patch:
@@ -21,6 +21,7 @@
 
 import org.redisson.client.codec.Codec;
 import org.redisson.client.protocol.decoder.MultiDecoder;
+import org.redisson.misc.LogHelper;
 import org.redisson.misc.RPromise;
 
 /**
@@ -85,7 +86,7 @@ public Codec getCodec() {
     @Override
     public String toString() {
         return "CommandData [promise=" + promise + ", command=" + command + ", params="
-                + Arrays.toString(params) + ", codec=" + codec + "]";
+                + LogHelper.toString(params) + ", codec=" + codec + "]";
     }
 
     @Override

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -63,6 +63,7 @@ public SentinelConnectionManager(SentinelServersConfig cfg, Config config) {
         super(config);
 
         final MasterSlaveServersConfig c = create(cfg);
+        initTimer(c);
 
         for (URI addr : cfg.getSentinelAddresses()) {
             RedisClient client = createClient(addr.getHost(), addr.getPort(), c.getConnectTimeout(), c.getRetryInterval() * c.getRetryAttempts());
@@ -114,7 +115,6 @@ public SentinelConnectionManager(SentinelServersConfig cfg, Config config) {
         if (currentMaster.get() == null) {
             throw new RedisConnectionException("Can't connect to servers!");
         }
-        initTimer(c);
         init(c);
 
         List<RFuture<RedisPubSubConnection>> connectionFutures = new ArrayList<RFuture<RedisPubSubConnection>>(cfg.getSentinelAddresses().size());

File: redisson/src/main/java/org/redisson/api/LocalCachedMapOptions.java
Patch:
@@ -86,7 +86,7 @@ public long getMaxIdleInMillis() {
     }
 
     /**
-     * Sets cache size. If size is <code>0</code> then cache is unbounded.
+     * Sets cache size. If size is <code>0</code> then local cache is unbounded.
      * 
      * @param cacheSize - size of cache
      * @return LocalCachedMapOptions instance

File: redisson/src/main/java/org/redisson/api/RDestroyable.java
Patch:
@@ -23,7 +23,7 @@
 public interface RDestroyable {
 
     /**
-     * Allows to destroy object then it's not necessary anymore.
+     * Destroys object when it's not necessary anymore.
      */
     void destroy();
     

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -74,6 +74,7 @@ public ClusterConnectionManager(ClusterServersConfig cfg, Config config) {
         connectListener = new ClusterConnectionListener(cfg.getReadMode() != ReadMode.MASTER);
 
         this.config = create(cfg);
+        initTimer(this.config);
         init(this.config);
 
         Throwable lastException = null;

File: redisson/src/main/java/org/redisson/connection/ElasticacheConnectionManager.java
Patch:
@@ -65,6 +65,7 @@ public ElasticacheConnectionManager(ElasticacheServersConfig cfg, Config config)
         super(config);
 
         this.config = create(cfg);
+        initTimer(this.config);
 
         for (URI addr : cfg.getNodeAddresses()) {
             RedisConnection connection = connect(cfg, addr);

File: redisson/src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -114,6 +114,7 @@ public SentinelConnectionManager(SentinelServersConfig cfg, Config config) {
         if (currentMaster.get() == null) {
             throw new RedisConnectionException("Can't connect to servers!");
         }
+        initTimer(c);
         init(c);
 
         List<RFuture<RedisPubSubConnection>> connectionFutures = new ArrayList<RFuture<RedisPubSubConnection>>(cfg.getSentinelAddresses().size());

File: redisson/src/main/java/org/redisson/RedissonLiveObjectService.java
Patch:
@@ -588,7 +588,7 @@ private <T, K> T instantiateDetachedObject(Class<T> cls, K id) throws Exception
 
     private <T, K> T instantiate(Class<T> cls, K id) throws Exception {
         for (Constructor<?> constructor : cls.getDeclaredConstructors()) {
-            if (constructor.getParameterCount() == 0) {
+            if (constructor.getParameterTypes().length == 0) {
                 constructor.setAccessible(true);
                 return (T) constructor.newInstance();
             }

File: redisson/src/test/java/org/redisson/ConcurrentRedissonSortedSetTest.java
Patch:
@@ -40,7 +40,7 @@ public void testAdd_SingleInstance() throws InterruptedException {
 
         Collections.sort(elements);
         Integer[] p = elements.toArray(new Integer[elements.size()]);
-        assertThat(map).contains(p);
+        assertThat(map).containsExactly(p);
 
         map.clear();
         r.shutdown();

File: redisson/src/main/java/org/redisson/api/RGeoAsync.java
Patch:
@@ -377,6 +377,7 @@ public interface RGeoAsync<V> extends RScoredSortedSetAsync<V> {
      * @param radius - radius in geo units
      * @param geoUnit - geo unit
      * @param geoOrder - geo
+     * @param count - result limit
      * @return distance mapped by object
      */
     RFuture<Map<V, Double>> radiusWithDistanceAsync(V member, double radius, GeoUnit geoUnit, GeoOrder geoOrder, int count);

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -252,7 +252,7 @@ public void registerWorkers(int workers, ExecutorService executor) {
         service.setSchedulerChannelName(schedulerChannelName);
         service.setSchedulerQueueName(schedulerQueueName);
         
-        redisson.getRemoteSerivce(name, codec).register(RemoteExecutorService.class, service, workers, executor);
+        redisson.getRemoteService(name, codec).register(RemoteExecutorService.class, service, workers, executor);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -252,7 +252,7 @@ public void registerWorkers(int workers, ExecutorService executor) {
         service.setSchedulerChannelName(schedulerChannelName);
         service.setSchedulerQueueName(schedulerQueueName);
         
-        redisson.getRemoteSerivce(name, codec).register(RemoteExecutorService.class, service, workers, executor);
+        redisson.getRemoteService(name, codec).register(RemoteExecutorService.class, service, workers, executor);
     }
 
     @Override

File: redisson/src/main/java/org/redisson/RedissonLocalCachedMap.java
Patch:
@@ -840,7 +840,7 @@ public RFuture<Collection<V>> readAllValuesAsync() {
                 "local entries = redis.call('hgetall', KEYS[1]); "
               + "local result = {};"
               + "for j, v in ipairs(entries) do "
-                  + "if j % 2 == 0 then "
+                  + "if j % 2 ~= 0 then "
                       + "local founded = false;"
                       + "for i = 1, #ARGV, 1 do "
                           + "if ARGV[i] == entries[j] then "
@@ -887,7 +887,7 @@ public RFuture<Set<Entry<K, V>>> readAllEntrySetAsync() {
                 "local entries = redis.call('hgetall', KEYS[1]); "
               + "local result = {};"
               + "for j, v in ipairs(entries) do "
-              + "if j % 2 == 0 then "
+              + "if j % 2 ~= 0 then "
                       + "local founded = false;"
                       + "for i = 1, #ARGV, 1 do "
                           + "if ARGV[i] == entries[j] then "

File: redisson/src/main/java/org/redisson/liveobject/core/AccessorInterceptor.java
Patch:
@@ -151,7 +151,7 @@ private String getFieldName(Method method) {
     }
 
     private boolean isGetter(Method method, String fieldName) {
-        return method.getName().startsWith("get")
+        return (method.getName().startsWith("get") || method.getName().startsWith("is"))
                 && method.getName().endsWith(getFieldNameSuffix(fieldName));
     }
 

File: redisson/src/main/java/org/redisson/misc/RedissonObjectFactory.java
Patch:
@@ -124,7 +124,7 @@ public static <T> T fromReference(RedissonClient redisson, RedissonReference rr)
         throw new ClassNotFoundException("No RObject is found to match class type of " + rr.getTypeName() + " with codec type of " + rr.getCodecName());
     }
     
-    public static boolean isDefaultCodec(RedissonReference rr) {
+    private static boolean isDefaultCodec(RedissonReference rr) {
         return rr.getCodec() == null;
     }
 

File: redisson/src/test/java/org/redisson/RedissonSetCacheTest.java
Patch:
@@ -151,9 +151,9 @@ public void testExpireOverwrite() throws InterruptedException, ExecutionExceptio
         Thread.sleep(100);
         assertThat(set.contains("123")).isTrue();
 
-        Thread.sleep(100);
+        Thread.sleep(300);
 
-        assertThat(set.contains("123")).isFalse();
+        assertThat(set.contains("123")).isTrue();
     }
 
     @Test

File: redisson/src/main/java/org/redisson/RedissonLexSortedSet.java
Patch:
@@ -199,11 +199,12 @@ public RFuture<Boolean> addAllAsync(Collection<? extends String> c) {
             return newSucceededFuture(false);
         }
         List<Object> params = new ArrayList<Object>(2*c.size());
+        params.add(getName());
         for (Object param : c) {
             params.add(0);
             params.add(param);
         }
-        return commandExecutor.writeAsync(getName(), StringCodec.INSTANCE, RedisCommands.ZADD_BOOL_RAW, getName(), params.toArray());
+        return commandExecutor.writeAsync(getName(), StringCodec.INSTANCE, RedisCommands.ZADD_BOOL_RAW, params.toArray());
     }
 
     @Override

File: redisson/src/test/java/org/redisson/BaseTest.java
Patch:
@@ -63,7 +63,6 @@ public static Config createConfig() {
                 .setAddress(RedisRunner.getDefaultRedisServerBindAddressAndPort())
                 .setConnectTimeout(1000000)
                 .setTimeout(1000000);
-        config.setThreads(10);
 //        .setPassword("mypass1");
 //        config.useMasterSlaveConnection()
 //        .setMasterAddress("127.0.0.1:6379")

File: redisson/src/test/java/org/redisson/RedissonRuntimeEnvironment.java
Patch:
@@ -9,7 +9,7 @@
 public class RedissonRuntimeEnvironment {
 
     public static final boolean isTravis = "true".equalsIgnoreCase(System.getProperty("travisEnv"));
-    public static final String redisBinaryPath = System.getProperty("redisBinary", "C:\\Devel\\projects\\redis\\Redis-x64-3.0.500\\redis-server.exe");
+    public static final String redisBinaryPath = System.getProperty("redisBinary", "C:\\Devel\\projects\\redis\\Redis-x64-3.2.100\\redis-server.exe");
     public static final String tempDir = System.getProperty("java.io.tmpdir");
     public static final String OS;
     public static final boolean isWindows;

File: redisson/src/main/java/org/redisson/PubSubMessageListener.java
Patch:
@@ -23,8 +23,7 @@
  *
  * @author Nikita Koksharov
  *
- * @param <K>
- * @param <V>
+ * @param <V> value
  */
 public class PubSubMessageListener<V> implements RedisPubSubListener<Object> {
 

File: redisson/src/main/java/org/redisson/PubSubPatternMessageListener.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.redisson;
 
-import org.redisson.api.listener.MessageListener;
 import org.redisson.api.listener.PatternMessageListener;
 import org.redisson.client.RedisPubSubListener;
 import org.redisson.client.protocol.pubsub.PubSubType;
@@ -24,8 +23,7 @@
  *
  * @author Nikita Koksharov
  *
- * @param <K>
- * @param <V>
+ * @param <V> value
  */
 public class PubSubPatternMessageListener<V> implements RedisPubSubListener<V> {
 

File: redisson/src/main/java/org/redisson/PubSubPatternStatusListener.java
Patch:
@@ -23,8 +23,7 @@
  *
  * @author Nikita Koksharov
  *
- * @param <K>
- * @param <V>
+ * @param <V> value
  */
 public class PubSubPatternStatusListener<V> implements RedisPubSubListener<V> {
 

File: redisson/src/main/java/org/redisson/PubSubStatusListener.java
Patch:
@@ -23,8 +23,7 @@
  *
  * @author Nikita Koksharov
  *
- * @param <K>
- * @param <V>
+ * @param <V> value
  */
 public class PubSubStatusListener<V> implements RedisPubSubListener<V> {
 

File: redisson/src/main/java/org/redisson/Redisson.java
Patch:
@@ -135,7 +135,7 @@ public static RedissonClient create() {
     /**
      * Create sync/async Redisson instance with provided config
      *
-     * @param config
+     * @param config for Redisson
      * @return Redisson instance
      */
     public static RedissonClient create(Config config) {
@@ -163,6 +163,7 @@ public static RedissonReactiveClient createReactive() {
     /**
      * Create reactive Redisson instance with provided config
      *
+     * @param config for Redisson
      * @return Redisson instance
      */
     public static RedissonReactiveClient createReactive(Config config) {

File: redisson/src/main/java/org/redisson/RedissonBloomFilter.java
Patch:
@@ -45,7 +45,7 @@
  *
  * @author Nikita Koksharov
  *
- * @param <T>
+ * @param <T> type of object
  */
 public class RedissonBloomFilter<T> extends RedissonExpirable implements RBloomFilter<T> {
 

File: redisson/src/main/java/org/redisson/RedissonGeo.java
Patch:
@@ -47,7 +47,7 @@
  * 
  * @author Nikita Koksharov
  *
- * @param <V>
+ * @param <V> value
  */
 public class RedissonGeo<V> extends RedissonExpirable implements RGeo<V> {
 

File: redisson/src/main/java/org/redisson/RedissonHyperLogLog.java
Patch:
@@ -30,7 +30,7 @@
  * 
  * @author Nikita Koksharov
  *
- * @param <V>
+ * @param <V> value
  */
 public class RedissonHyperLogLog<V> extends RedissonExpirable implements RHyperLogLog<V> {
 

File: redisson/src/main/java/org/redisson/RedissonMultiLock.java
Patch:
@@ -46,7 +46,7 @@ public class RedissonMultiLock implements Lock {
      * Creates instance with multiple {@link RLock} objects.
      * Each RLock object could be created by own Redisson instance.
      *
-     * @param locks
+     * @param locks - array of locks
      */
     public RedissonMultiLock(RLock... locks) {
         if (locks.length == 0) {

File: redisson/src/main/java/org/redisson/RedissonNode.java
Patch:
@@ -170,7 +170,7 @@ private void retrieveAdresses() {
     /**
      * Create Redisson node instance with provided config
      *
-     * @param config
+     * @param config of RedissonNode
      * @return RedissonNode instance
      */
     public static RedissonNode create(RedissonNodeConfig config) {
@@ -180,8 +180,8 @@ public static RedissonNode create(RedissonNodeConfig config) {
     /**
      * Create Redisson node instance with provided config and Redisson instance
      *
-     * @param config
-     * @param redisson
+     * @param config of RedissonNode
+     * @param redisson instance
      * @return RedissonNode instance
      */
     public static RedissonNode create(RedissonNodeConfig config, Redisson redisson) {

File: redisson/src/main/java/org/redisson/RedissonRedLock.java
Patch:
@@ -38,7 +38,7 @@ public class RedissonRedLock extends RedissonMultiLock {
      * Creates instance with multiple {@link RLock} objects.
      * Each RLock object could be created by own Redisson instance.
      *
-     * @param locks
+     * @param locks - array of locks
      */
     public RedissonRedLock(RLock... locks) {
         super(locks);

File: redisson/src/main/java/org/redisson/RedissonSortedSet.java
Patch:
@@ -44,7 +44,7 @@
  *
  * @author Nikita Koksharov
  *
- * @param <V>
+ * @param <V> value
  */
 public class RedissonSortedSet<V> extends RedissonObject implements RSortedSet<V> {
 

File: redisson/src/main/java/org/redisson/api/RSortedSet.java
Patch:
@@ -27,7 +27,7 @@ public interface RSortedSet<V> extends SortedSet<V>, RObject {
     /**
      * Sets new comparator only if current set is empty
      *
-     * @param comparator
+     * @param comparator for values
      * @return <code>true</code> if new comparator setted
      *         <code>false</code> otherwise
      */

File: redisson/src/main/java/org/redisson/api/RTopicAsync.java
Patch:
@@ -27,7 +27,7 @@ public interface RTopicAsync<M> {
     /**
      * Publish the message to all subscribers of this topic asynchronously
      *
-     * @param message
+     * @param message to send
      * @return the <code>RFuture</code> object with number of clients that received the message
      */
     RFuture<Long> publishAsync(M message);

File: redisson/src/main/java/org/redisson/api/RTopicReactive.java
Patch:
@@ -35,7 +35,7 @@ public interface RTopicReactive<M> {
     /**
      * Publish the message to all subscribers of this topic asynchronously
      *
-     * @param message
+     * @param message to send
      * @return the <code>Future</code> object with number of clients that received the message
      */
     Publisher<Long> publish(M message);

File: redisson/src/main/java/org/redisson/api/listener/MessageListener.java
Patch:
@@ -31,6 +31,7 @@ public interface MessageListener<M> extends EventListener {
     /**
      * Invokes on every message in topic
      *
+     * @param channel of topic
      * @param msg topic message
      */
     void onMessage(String channel, M msg);

File: redisson/src/main/java/org/redisson/api/listener/PatternMessageListener.java
Patch:
@@ -31,6 +31,8 @@ public interface PatternMessageListener<M> extends EventListener {
     /**
      * Invokes on every message in topic
      *
+     * @param pattern of channel name
+     * @param channel of topic
      * @param msg topic message
      */
     void onMessage(String pattern, String channel, M msg);

File: redisson/src/main/java/org/redisson/api/listener/StatusListener.java
Patch:
@@ -30,14 +30,14 @@ public interface StatusListener extends EventListener {
      * Executes then Redisson successfully subscribed to channel.
      * Invoked during re-connection
      * 
-     * @param channel
+     * @param channel to subscribe
      */
     void onSubscribe(String channel);
 
     /**
      * Executes then Redisson successfully unsubscribed from channel.
      * 
-     * @param channel
+     * @param channel to unsubscribe
      */
     void onUnsubscribe(String channel);
 

File: redisson/src/main/java/org/redisson/client/RedisConnection.java
Patch:
@@ -223,7 +223,8 @@ public ChannelFuture forceFastReconnectAsync() {
     /**
      * Access to Netty channel.
      * This method is provided to use in debug info only.
-     *
+     * 
+     * @return channel
      */
     public Channel getChannel() {
         return channel;

File: redisson/src/main/java/org/redisson/codec/CborJacksonCodec.java
Patch:
@@ -21,7 +21,7 @@
 /**
  *
  * @author Faye Li
- * @date 2015-10-16
+ * 
  */
 public class CborJacksonCodec extends JsonJacksonCodec {
     

File: redisson/src/main/java/org/redisson/codec/LZ4Codec.java
Patch:
@@ -30,8 +30,8 @@
 
 /**
  * LZ4 compression codec.
- * Uses inner <code>Codec</codec> to convert object to binary stream.
- * <codec>FstCodec</codec> used by default.
+ * Uses inner <code>Codec</code> to convert object to binary stream.
+ * <code>FstCodec</code> used by default.
  *
  * https://github.com/jpountz/lz4-java
  *

File: redisson/src/main/java/org/redisson/codec/SnappyCodec.java
Patch:
@@ -28,8 +28,8 @@
 
 /**
  * Snappy compression codec.
- * Uses inner <code>Codec</codec> to convert object to binary stream.
- * <codec>FstCodec</codec> used by default.
+ * Uses inner <code>Codec</code> to convert object to binary stream.
+ * <code>FstCodec</code> used by default.
  *
  * https://github.com/xerial/snappy-java
  *

File: redisson/src/main/java/org/redisson/config/ClusterServersConfig.java
Patch:
@@ -46,7 +46,7 @@ public ClusterServersConfig() {
      * Add Redis cluster node address. Use follow format -- <code>host:port</code>
      *
      * @param addresses in <code>host:port</code> format
-     * @return
+     * @return config
      */
     public ClusterServersConfig addNodeAddress(String ... addresses) {
         for (String address : addresses) {
@@ -68,7 +68,7 @@ public int getScanInterval() {
      * Redis cluster scan interval in milliseconds
      *
      * @param scanInterval in milliseconds
-     * @return
+     * @return config
      */
     public ClusterServersConfig setScanInterval(int scanInterval) {
         this.scanInterval = scanInterval;

File: redisson/src/main/java/org/redisson/connection/MasterSlaveEntry.java
Patch:
@@ -312,7 +312,9 @@ public boolean slaveUp(String host, int port, FreezeReason freezeReason) {
      * Freeze slave with <code>host:port</code> from slaves list.
      * Re-attach pub/sub listeners from it to other slave.
      * Shutdown old master client.
-     *
+     * 
+     * @param host of Redis
+     * @param port of Redis
      */
     public void changeMaster(String host, int port) {
         ClientConnectionsEntry oldMaster = masterEntry;

File: redisson/src/main/java/org/redisson/executor/RedissonScheduledFuture.java
Patch:
@@ -25,7 +25,7 @@
  * 
  * @author Nikita Koksharov
  *
- * @param <V>
+ * @param <V> value
  */
 public class RedissonScheduledFuture<V> extends PromiseDelegator<V> implements RScheduledFuture<V> {
 

File: redisson/src/main/java/org/redisson/liveobject/provider/ResolverProvider.java
Patch:
@@ -40,9 +40,9 @@ public interface ResolverProvider {
      * To register a resolver based on the the class it can provide value to,
      * the resolver type, the resolver instance to be cached.
      * 
-     * @param cls
-     * @param resolverClass
-     * @param resolver
+     * @param cls object
+     * @param resolverClass object
+     * @param resolver object
      */
     void registerResolver(Class<?> cls, Class<? extends Resolver> resolverClass, Resolver resolver);
     

File: redisson/src/main/java/org/redisson/liveobject/resolver/RIdResolver.java
Patch:
@@ -32,7 +32,7 @@ public interface RIdResolver<A extends RId, V> extends Resolver<Class, A, V>{
      * 
      * @param cls the class of the LiveObject.
      * @param annotation the RId annotation used in the class.
-     * @param redisson
+     * @param redisson instance
      * @return resolved RId field value.
      */
     public V resolve(Class cls, A annotation, String idFieldName, RedissonClient redisson);

File: redisson/src/main/java/org/redisson/misc/AbstractCacheMap.java
Patch:
@@ -32,8 +32,8 @@
  * 
  * @author Nikita Koksharov
  *
- * @param <K>
- * @param <V>
+ * @param <K> key
+ * @param <V> value
  */
 public abstract class AbstractCacheMap<K, V> implements Cache<K, V> {
 

File: redisson/src/main/java/org/redisson/misc/BiHashMap.java
Patch:
@@ -25,8 +25,8 @@
  * This is not a concurrent map.
  * 
  * @author Rui Gu (https://github.com/jackygurui)
- * @param <K>
- * @param <V>
+ * @param <K> key
+ * @param <V> value
  */
 public class BiHashMap<K, V> implements Map<K, V> {
 

File: redisson/src/main/java/org/redisson/misc/Cache.java
Patch:
@@ -22,8 +22,8 @@
  * 
  * @author Nikita Koksharov
  *
- * @param <K>
- * @param <V>
+ * @param <K> key
+ * @param <V> valu
  */
 public interface Cache<K, V> extends Map<K, V> {
     

File: redisson/src/main/java/org/redisson/misc/LFUCacheMap.java
Patch:
@@ -25,8 +25,8 @@
  * 
  * @author Nikita Koksharov
  *
- * @param <K>
- * @param <V>
+ * @param <K> key
+ * @param <V> value
  */
 public class LFUCacheMap<K, V> extends AbstractCacheMap<K, V> {
 

File: redisson/src/main/java/org/redisson/misc/LRUCacheMap.java
Patch:
@@ -23,8 +23,8 @@
  * 
  * @author Nikita Koksharov
  *
- * @param <K>
- * @param <V>
+ * @param <K> key
+ * @param <V> value
  */
 public class LRUCacheMap<K, V> extends AbstractCacheMap<K, V> {
 

File: redisson/src/main/java/org/redisson/misc/NoneCacheMap.java
Patch:
@@ -19,8 +19,8 @@
  * 
  * @author Nikita Koksharov
  *
- * @param <K>
- * @param <V>
+ * @param <K> key
+ * @param <V> value
  */
 public class NoneCacheMap<K, V> extends AbstractCacheMap<K, V> {
 

File: redisson/src/main/java/org/redisson/misc/RedissonPromise.java
Patch:
@@ -29,7 +29,7 @@
  * 
  * @author Nikita Koksharov
  *
- * @param <T>
+ * @param <T> type of object
  */
 public class RedissonPromise<T> implements RPromise<T> {
 

File: redisson/src/main/java/org/redisson/pubsub/TransferListener.java
Patch:
@@ -24,7 +24,7 @@
  * 
  * @author Nikita Koksharov
  *
- * @param <T>
+ * @param <T> type
  */
 public class TransferListener<T> implements FutureListener<T> {
 

File: redisson/src/main/java/org/redisson/reactive/RedissonSetCacheReactive.java
Patch:
@@ -34,7 +34,7 @@
 
 /**
  * <p>Set-based cache with ability to set TTL for each entry via
- * {@link #put(Object, Object, long, TimeUnit)} method.
+ * {@link #add(Object, long, TimeUnit)} method.
  * And therefore has an complex lua-scripts inside.
  * Uses map(value_hash, value) to tie with sorted set which contains expiration record for every value with TTL.
  * </p>
@@ -46,11 +46,10 @@
  * In addition there is {@link org.redisson.EvictionScheduler}. This scheduler
  * deletes expired entries in time interval between 5 seconds to 2 hours.</p>
  *
- * <p>If eviction is not required then it's better to use {@link org.redisson.reactive.RedissonSet}.</p>
+ * <p>If eviction is not required then it's better to use {@link org.redisson.api.RSet}.</p>
  *
  * @author Nikita Koksharov
  *
- * @param <K> key
  * @param <V> value
  */
 public class RedissonSetCacheReactive<V> extends RedissonExpirableReactive implements RSetCacheReactive<V> {

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -281,7 +281,7 @@ public interface RedisCommands {
 
     RedisStrictCommand<List<String>> SENTINEL_GET_MASTER_ADDR_BY_NAME = new RedisStrictCommand<List<String>>("SENTINEL", "GET-MASTER-ADDR-BY-NAME", new StringListReplayDecoder());
     RedisCommand<List<Map<String, String>>> SENTINEL_SLAVES = new RedisCommand<List<Map<String, String>>>("SENTINEL", "SLAVES",
-            new FlatNestedMultiDecoder(new ObjectMapReplayDecoder(), new ListResultReplayDecoder()), ValueType.OBJECT
+            new NestedMultiDecoder(new ObjectMapReplayDecoder(), new ListResultReplayDecoder(), true), ValueType.OBJECT
             );
 
     RedisStrictCommand<Void> CLUSTER_ADDSLOTS = new RedisStrictCommand<Void>("CLUSTER", "ADDSLOTS");

File: redisson/src/main/java/org/redisson/RedissonLiveObjectService.java
Patch:
@@ -185,7 +185,7 @@ public <T> RExpirable asRExpirable(T instance) {
     }
 
     @Override
-    public <T> RMap asRMap(T instance) {
+    public <T, K, V> RMap<K, V> asRMap(T instance) {
         return (RMap) instance;
     }
 

File: redisson/src/main/java/org/redisson/api/Node.java
Patch:
@@ -28,7 +28,7 @@ public interface Node {
     /**
      * Returns current Redis server time in seconds
      * 
-     * @return
+     * @return time in seconds
      */
     long time();
     

File: redisson/src/main/java/org/redisson/api/RBatch.java
Patch:
@@ -405,7 +405,6 @@ public interface RBatch {
      * If cluster configuration used then operations are grouped by slot ids
      * and may be executed on different servers. Thus command execution order could be changed
      *
-     * @return List with result object for each command
      * @throws RedisException in case of any error
      *
      */
@@ -417,8 +416,8 @@ public interface RBatch {
      * <p>
      * If cluster configuration used then operations are grouped by slot ids
      * and may be executed on different servers. Thus command execution order could be changed
-     *
-     * @return List with result object for each command
+     * 
+     * @return void
      * @throws RedisException in case of any error
      *
      */

File: redisson/src/main/java/org/redisson/api/RBucket.java
Patch:
@@ -29,7 +29,7 @@ public interface RBucket<V> extends RExpirable, RBucketAsync<V> {
     /**
      * Returns size of object in bytes
      * 
-     * @return
+     * @return object size
      */
     int size();
     

File: redisson/src/main/java/org/redisson/api/RBucketAsync.java
Patch:
@@ -29,7 +29,7 @@ public interface RBucketAsync<V> extends RExpirableAsync {
     /**
      * Returns size of object in bytes
      * 
-     * @return
+     * @return object size
      */
     RFuture<Integer> sizeAsync();
     

File: redisson/src/main/java/org/redisson/api/RExecutorService.java
Patch:
@@ -43,7 +43,6 @@ public interface RExecutorService extends ExecutorService, RExecutorServiceAsync
      * Register workers
      * 
      * @param workers - workers amount
-     * @param executor - executor instance
      */
     void registerWorkers(int workers);
     

File: redisson/src/main/java/org/redisson/api/RLocalCachedMap.java
Patch:
@@ -23,8 +23,8 @@
  * 
  * @author Nikita Koksharov
  *
- * @param <K>
- * @param <V>
+ * @param <K> map key
+ * @param <V> map value
  */
 public interface RLocalCachedMap<K, V> extends RMap<K, V>, RDestroyable {
 

File: redisson/src/main/java/org/redisson/api/RMapReactive.java
Patch:
@@ -48,7 +48,7 @@ public interface RMapReactive<K, V> extends RExpirableReactive {
      * Works faster than <code>RMap.remove</code> but not returning
      * the value associated with <code>key</code>
      *
-     * @param keys
+     * @param keys - map keys
      * @return the number of keys that were removed from the hash, not including specified but non existing keys
      */
     Publisher<Long> fastRemove(K ... keys);
@@ -60,8 +60,8 @@ public interface RMapReactive<K, V> extends RExpirableReactive {
      * Works faster than <code>RMap.put</code> but not returning
      * the previous value associated with <code>key</code>
      *
-     * @param key
-     * @param value
+     * @param key - map key
+     * @param value - map value
      * @return <code>true</code> if key is a new key in the hash and value was set.
      *         <code>false</code> if key already exists in the hash and the value was updated.
      */

File: redisson/src/main/java/org/redisson/api/RMultimapCache.java
Patch:
@@ -23,7 +23,7 @@ public interface RMultimapCache<K, V> extends RMultimap<K, V>, RMultimapCacheAsy
      * Set a timeout for key. After the timeout has expired,
      * the key and its values will automatically be deleted.
      * 
-     * @param key
+     * @param key - map key
      * @param timeToLive - timeout before key will be deleted
      * @param timeUnit - timeout time unit
      * @return <code>true</code> if key exists and the timeout was set and <code>false</code> if key not exists

File: redisson/src/main/java/org/redisson/api/RMultimapCacheAsync.java
Patch:
@@ -23,7 +23,7 @@ public interface RMultimapCacheAsync<K, V> extends RMultimapAsync<K, V> {
      * Set a timeout for key in async mode. After the timeout has expired,
      * the key and its values will automatically be deleted.
      * 
-     * @param key
+     * @param key - map key
      * @param timeToLive - timeout before key will be deleted
      * @param timeUnit - timeout time unit
      * @return <code>true</code> if key exists and the timeout was set and <code>false</code> if key not exists

File: redisson/src/main/java/org/redisson/api/RScheduledFuture.java
Patch:
@@ -21,7 +21,7 @@
  * 
  * @author Nikita Koksharov
  *
- * @param <V>
+ * @param <V> value
  */
 public interface RScheduledFuture<V> extends RFuture<V>, ScheduledFuture<V> {
 
@@ -31,7 +31,7 @@ public interface RScheduledFuture<V> extends RFuture<V>, ScheduledFuture<V> {
      *  
      * @see RScheduledExecutorService#cancelScheduledTask(String)
      * 
-     * @return
+     * @return task id
      */
     String getTaskId();
     

File: redisson/src/test/java/org/redisson/RedissonSemaphoreTest.java
Patch:
@@ -131,7 +131,7 @@ public void run() {
         t.join(1);
 
         long startTime = System.currentTimeMillis();
-        assertThat(s.tryAcquire(4, 1, TimeUnit.SECONDS)).isTrue();
+        assertThat(s.tryAcquire(4, 2, TimeUnit.SECONDS)).isTrue();
         assertThat(System.currentTimeMillis() - startTime).isBetween(900L, 1020L);
         assertThat(s.availablePermits()).isEqualTo(0);
     }

File: redisson/src/test/java/org/redisson/RedissonBoundedBlockingQueueTest.java
Patch:
@@ -44,7 +44,7 @@ public void testOfferTimeout() throws InterruptedException {
 
         long start = System.currentTimeMillis();
         assertThat(queue.offer(6, 2, TimeUnit.SECONDS)).isFalse();
-        assertThat(System.currentTimeMillis() - start).isGreaterThan(2000);
+        assertThat(System.currentTimeMillis() - start).isGreaterThan(1900);
         
         ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
         final AtomicBoolean executed = new AtomicBoolean();

File: redisson/src/main/java/org/redisson/api/RBucket.java
Patch:
@@ -27,7 +27,7 @@
 public interface RBucket<V> extends RExpirable, RBucketAsync<V> {
 
     /**
-     * Returns size of objects in bytes
+     * Returns size of object in bytes
      * 
      * @return
      */

File: redisson/src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -114,7 +114,7 @@ public ClusterConnectionManager(ClusterServersConfig cfg, Config config) {
                     for (RFuture<Void> future : masterFuture.getNow()) {
                         future.awaitUninterruptibly();
                         if (!future.isSuccess()) {
-                            continue;
+                            lastException = masterFuture.cause();
                         }
                     }
                 }

File: redisson/src/main/java/org/redisson/RedissonMultiLock.java
Patch:
@@ -221,7 +221,7 @@ public boolean tryLock(long waitTime, TimeUnit unit) throws InterruptedException
     }
     
     protected int failedLocksLimit() {
-        return 1;
+        return 0;
     }
 
     public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException {
@@ -249,14 +249,15 @@ public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws Inte
             if (lockAcquired) {
                 lockedLocks.add(lock);
             } else {
-                failedLocksLimit--;
                 if (failedLocksLimit == 0) {
                     unlockInner(lockedLocks);
                     if (waitTime == -1 && leaseTime == -1) {
                         return false;
                     }
                     failedLocksLimit = failedLocksLimit();
                     lockedLocks.clear();
+                } else {
+                    failedLocksLimit--;
                 }
             }
             

File: redisson/src/test/java/org/redisson/RedissonMapTest.java
Patch:
@@ -366,7 +366,7 @@ public void testOrdering() {
         map.put("ar_kills", "0");
         map.put("ar_deaths", "0");
 
-        RMap<String, String> rmap = redisson.getMap("123", StringCodec.INSTANCE);
+        RMap<String, String> rmap = redisson.getMap("123");
         rmap.putAll(map);
 
         assertThat(rmap.keySet()).containsExactlyElementsOf(map.keySet());

File: redisson/src/main/java/org/redisson/client/RedisClient.java
Patch:
@@ -92,7 +92,7 @@ public RedisClient(Timer timer, ExecutorService executor, EventLoopGroup group,
     }
     
     public RedisClient(String host, int port, int connectTimeout, int commandTimeout) {
-        this(new HashedWheelTimer(), new NioEventLoopGroup(), NioSocketChannel.class, host, port, connectTimeout, commandTimeout);
+        this(new HashedWheelTimer(), Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2), new NioEventLoopGroup(), NioSocketChannel.class, host, port, connectTimeout, commandTimeout);
     }
 
     public RedisClient(final Timer timer, ExecutorService executor, EventLoopGroup group, Class<? extends SocketChannel> socketChannelClass, String host, int port, 

File: redisson/src/test/java/org/redisson/RedissonPermitExpirableSemaphoreTest.java
Patch:
@@ -154,7 +154,7 @@ public void run() {
         long startTime = System.currentTimeMillis();
         String permitId2 = s.tryAcquire(1, TimeUnit.SECONDS);
         assertThat(permitId2).hasSize(32);
-        assertThat(System.currentTimeMillis() - startTime).isBetween(500L, 600L);
+        assertThat(System.currentTimeMillis() - startTime).isBetween(450L, 600L);
         assertThat(s.availablePermits()).isEqualTo(0);
     }
 

File: redisson/src/test/java/org/redisson/BaseTest.java
Patch:
@@ -73,6 +73,7 @@ public static Config createConfig() {
                 .setAddress(RedisRunner.getDefaultRedisServerBindAddressAndPort())
                 .setConnectTimeout(1000000)
                 .setTimeout(1000000);
+        config.setThreads(10);
 //        .setPassword("mypass1");
 //        config.useMasterSlaveConnection()
 //        .setMasterAddress("127.0.0.1:6379")

File: redisson/src/main/java/org/redisson/client/handler/ConnectionWatchdog.java
Patch:
@@ -40,7 +40,6 @@
 import io.netty.util.TimerTask;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.FutureListener;
-import io.netty.util.concurrent.ImmediateEventExecutor;
 
 public class ConnectionWatchdog extends ChannelInboundHandlerAdapter {
 
@@ -156,6 +155,7 @@ private void reattachPubSub(RedisConnection connection) {
     @Override
     public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
         ctx.channel().close();
+        super.exceptionCaught(ctx, cause);
     }
 
     private void refresh(RedisConnection connection, Channel channel) {

File: redisson/src/test/java/org/redisson/RedissonMapCacheReactiveTest.java
Patch:
@@ -373,9 +373,9 @@ public void testSize() {
     @Test
     public void testEmptyRemove() {
         RMapCacheReactive<Integer, Integer> map = redisson.getMapCache("simple");
-        assertThat(sync(map.remove(1, 3))).isEqualTo(0);
+        assertThat(sync(map.remove(1, 3))).isEqualTo(Boolean.FALSE);
         sync(map.put(4, 5));
-        assertThat(sync(map.remove(4, 5))).isEqualTo(1);
+        assertThat(sync(map.remove(4, 5))).isEqualTo(Boolean.TRUE);
     }
 
     @Test

File: redisson/src/main/java/org/redisson/liveobject/provider/ResolverProvider.java
Patch:
@@ -34,7 +34,7 @@ public interface ResolverProvider {
      * @param anno annotation with configurations
      * @return a Resolver instance
      */
-    Resolver getResolver(Class<?> cls, Class<? extends Resolver> resolverClass, Annotation anno);
+    Resolver<?, ?, ?> getResolver(Class<?> cls, Class<? extends Resolver> resolverClass, Annotation anno);
 
     /**
      * To register a resolver based on the the class it can provide value to,

File: redisson/src/main/java/org/redisson/codec/DefaultCodecProvider.java
Patch:
@@ -28,7 +28,7 @@
  */
 public class DefaultCodecProvider implements CodecProvider {
 
-    public final ConcurrentMap<Class<? extends Codec>, Codec> codecCache = PlatformDependent.newConcurrentHashMap();
+    public transient final ConcurrentMap<Class<? extends Codec>, Codec> codecCache = PlatformDependent.newConcurrentHashMap();
 
     @Override
     public <T extends Codec> T getCodec(Class<T> codecClass) {

File: redisson/src/main/java/org/redisson/config/ConfigSupport.java
Patch:
@@ -203,8 +203,8 @@ private ObjectMapper createMapper(JsonFactory mapping) {
         mapper.addMixIn(MasterSlaveServersConfig.class, MasterSlaveServersConfigMixIn.class);
         mapper.addMixIn(SingleServerConfig.class, SingleSeverConfigMixIn.class);
         mapper.addMixIn(Config.class, ConfigMixIn.class);
-        mapper.addMixIn(CodecProvider.class, ConfigMixIn.class);
-        mapper.addMixIn(ResolverProvider.class, ConfigMixIn.class);
+        mapper.addMixIn(CodecProvider.class, ClassMixIn.class);
+        mapper.addMixIn(ResolverProvider.class, ClassMixIn.class);
         mapper.addMixIn(Codec.class, ClassMixIn.class);
         mapper.addMixIn(RedissonNodeInitializer.class, ClassMixIn.class);
         mapper.addMixIn(LoadBalancer.class, ClassMixIn.class);

File: redisson/src/main/java/org/redisson/liveobject/provider/DefaultResolverProvider.java
Patch:
@@ -25,10 +25,11 @@
  * @author Rui Gu (https://github.com/jackygurui)
  */
 public class DefaultResolverProvider implements ResolverProvider {
-    public final ConcurrentMap<Class<? extends Resolver>, Resolver> providerCache = PlatformDependent.newConcurrentHashMap();
+    
+    public transient final ConcurrentMap<Class<? extends Resolver>, Resolver<?, ?, ?>> providerCache = PlatformDependent.newConcurrentHashMap();
 
     @Override
-    public Resolver getResolver(Class<?> cls, Class<? extends Resolver> resolverClass, Annotation anno) {
+    public Resolver<?, ?, ?> getResolver(Class<?> cls, Class<? extends Resolver> resolverClass, Annotation anno) {
         if (!providerCache.containsKey(resolverClass)) {
             try {
                 providerCache.putIfAbsent(resolverClass, resolverClass.newInstance());

File: redisson/src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -64,7 +64,7 @@
  * In addition there is {@link org.redisson.EvictionScheduler}. This scheduler
  * deletes expired entries in time interval between 5 seconds to 2 hours.</p>
  *
- * <p>If eviction is not required then it's better to use {@link org.redisson.reactive.RedissonMapReactive}.</p>
+ * <p>If eviction is not required then it's better to use {@link org.redisson.RedissonMap} object.</p>
  *
  * @author Nikita Koksharov
  *

File: redisson/src/main/java/org/redisson/api/RLexSortedSet.java
Patch:
@@ -31,15 +31,15 @@ public interface RLexSortedSet extends RLexSortedSetAsync, Set<String>, RExpirab
     /**
      * Returns rank of value, with the scores ordered from high to low.
      * 
-     * @param o
+     * @param o - object
      * @return rank or <code>null</code> if value does not exist
      */
     Integer revRank(String o);
     
     /**
      * Read all values at once.
      * 
-     * @return
+     * @return collection of values
      */
     Collection<String> readAll();
     

File: redisson/src/main/java/org/redisson/api/RLexSortedSetAsync.java
Patch:
@@ -30,7 +30,7 @@ public interface RLexSortedSetAsync extends RCollectionAsync<String> {
     /**
      * Read all values at once.
      * 
-     * @return
+     * @return collection of values
      */
     RFuture<Collection<String>> readAllAsync();
     
@@ -65,7 +65,7 @@ public interface RLexSortedSetAsync extends RCollectionAsync<String> {
     /**
      * Returns rank of value, with the scores ordered from high to low.
      * 
-     * @param o
+     * @param o - value
      * @return rank or <code>null</code> if value does not exist
      */
     RFuture<Integer> revRankAsync(String o);

File: redisson/src/main/java/org/redisson/RedissonFairLock.java
Patch:
@@ -32,7 +32,7 @@
  * Distributed implementation of {@link java.util.concurrent.locks.Lock}
  * Implements reentrant lock.<br>
  * Lock will be removed automatically if client disconnects.
- * <p/>
+ * <p>
  * Implements a <b>fair</b> locking so it guarantees an acquire order by threads.
  *
  * @author Nikita Koksharov

File: redisson/src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -46,7 +46,7 @@
  * Distributed implementation of {@link java.util.concurrent.locks.Lock}
  * Implements reentrant lock.<br>
  * Lock will be removed automatically if client disconnects.
- * <p/>
+ * <p>
  * Implements a <b>non-fair</b> locking so doesn't guarantees an acquire order.
  *
  * @author Nikita Koksharov

File: redisson/src/main/java/org/redisson/RedissonSemaphore.java
Patch:
@@ -38,7 +38,7 @@
 
 /**
  * Distributed and concurrent implementation of {@link java.util.concurrent.Semaphore}.
- * <p/>
+ * <p>
  * Works in non-fair mode. Therefore order of acquiring is unpredictable.
  *
  * @author Nikita Koksharov

File: redisson/src/main/java/org/redisson/api/RBlockingDequeAsync.java
Patch:
@@ -31,28 +31,28 @@ public interface RBlockingDequeAsync<V> extends RDequeAsync<V>, RBlockingQueueAs
      * waiting up to the specified wait time if necessary for an element to become available
      * in any of defined queues <b>including</b> queue own.
      *
+     * @param queueNames - names of queue
      * @param timeout how long to wait before giving up, in units of
      *        {@code unit}
      * @param unit a {@code TimeUnit} determining how to interpret the
      *        {@code timeout} parameter
      * @return the head of this queue, or {@code null} if the
      *         specified waiting time elapses before an element is available
-     * @throws InterruptedException if interrupted while waiting
      */
     RFuture<V> pollFirstFromAnyAsync(long timeout, TimeUnit unit, String ... queueNames);
 
     /**
      * Retrieves and removes first available tail element of <b>any</b> queue in async mode,
      * waiting up to the specified wait time if necessary for an element to become available
      * in any of defined queues <b>including</b> queue own.
-     *
+     * 
+     * @param queueNames - names of queue
      * @param timeout how long to wait before giving up, in units of
      *        {@code unit}
      * @param unit a {@code TimeUnit} determining how to interpret the
      *        {@code timeout} parameter
      * @return the head of this queue, or {@code null} if the
      *         specified waiting time elapses before an element is available
-     * @throws InterruptedException if interrupted while waiting
      */
     RFuture<V> pollLastFromAnyAsync(long timeout, TimeUnit unit, String ... queueNames);
 

File: redisson/src/main/java/org/redisson/api/RBlockingQueue.java
Patch:
@@ -31,6 +31,7 @@ public interface RBlockingQueue<V> extends BlockingQueue<V>, RQueue<V>, RBlockin
      * waiting up to the specified wait time if necessary for an element to become available
      * in any of defined queues <b>including</b> queue own.
      *
+     * @param queueNames - names of queue
      * @param timeout how long to wait before giving up, in units of
      *        {@code unit}
      * @param unit a {@code TimeUnit} determining how to interpret the

File: redisson/src/main/java/org/redisson/api/RBlockingQueueReactive.java
Patch:
@@ -34,13 +34,13 @@ public interface RBlockingQueueReactive<V> extends RQueueReactive<V> {
      * waiting up to the specified wait time if necessary for an element to become available
      * in any of defined queues <b>including</b> queue own.
      *
+     * @param queueNames - names of queue
      * @param timeout how long to wait before giving up, in units of
      *        {@code unit}
      * @param unit a {@code TimeUnit} determining how to interpret the
      *        {@code timeout} parameter
      * @return Publisher object with the head of this queue, or {@code null} if the
      *         specified waiting time elapses before an element is available
-     * @throws InterruptedException if interrupted while waiting
      */
     Publisher<V> pollFromAny(long timeout, TimeUnit unit, String ... queueNames);
 

File: redisson/src/main/java/org/redisson/api/RBoundedBlockingQueueAsync.java
Patch:
@@ -46,7 +46,6 @@ public interface RBoundedBlockingQueueAsync<V> extends RBlockingQueueAsync<V> {
      *        {@code timeout} parameter
      * @return {@code true} if successful, or {@code false} if
      *         the specified waiting time elapses before space is available
-     * @throws InterruptedException if interrupted while waiting
      * @throws ClassCastException if the class of the specified element
      *         prevents it from being added to this queue
      * @throws NullPointerException if the specified element is null

File: redisson/src/main/java/org/redisson/api/RCollectionAsync.java
Patch:
@@ -81,7 +81,7 @@ public interface RCollectionAsync<V> extends RExpirableAsync {
     /**
      * Returns the number of elements in this collection.
      *
-     * @return
+     * @return size of collection
      */
     RFuture<Integer> sizeAsync();
 

File: redisson/src/main/java/org/redisson/api/RExecutorService.java
Patch:
@@ -28,7 +28,7 @@ public interface RExecutorService extends ExecutorService, RExecutorServiceAsync
     /**
      * Returns executor name
      * 
-     * @return
+     * @return name of service
      */
     String getName();
     
@@ -43,6 +43,7 @@ public interface RExecutorService extends ExecutorService, RExecutorServiceAsync
      * Register workers using custom executor to execute each task
      * 
      * @param workers - workers amount
+     * @param executor - executor instance
      */
     void registerWorkers(int workers, ExecutorService executor);
 

File: redisson/src/main/java/org/redisson/api/RKeysAsync.java
Patch:
@@ -58,9 +58,9 @@ public interface RKeysAsync {
 
     /**
      * Delete multiple objects by a key pattern.
-     * <p/>
+     * <p>
      * Method executes in <b>NON atomic way</b> in cluster mode due to lua script limitations.
-     * <p/>
+     * <p>
      *  Supported glob-style patterns:
      *    h?llo subscribes to hello, hallo and hxllo
      *    h*llo subscribes to hllo and heeeello

File: redisson/src/main/java/org/redisson/api/RScoredSortedSet.java
Patch:
@@ -65,7 +65,7 @@ public interface RScoredSortedSet<V> extends RScoredSortedSetAsync<V>, Iterable<
 
     /**
      * Adds element to this set only if has not been added before.
-     * <p/>
+     * <p>
      * Works only with <b>Redis 3.0.2 and higher.</b>
      *
      * @param score

File: redisson/src/main/java/org/redisson/api/RScoredSortedSetAsync.java
Patch:
@@ -53,7 +53,7 @@ public interface RScoredSortedSetAsync<V> extends RExpirableAsync {
 
     /**
      * Adds element to this set only if has not been added before.
-     * <p/>
+     * <p>
      * Works only with <b>Redis 3.0.2 and higher.</b>
      *
      * @param score

File: redisson/src/main/java/org/redisson/api/RSemaphoreAsync.java
Patch:
@@ -19,7 +19,7 @@
 
 /**
  * Distributed and concurrent implementation of {@link java.util.concurrent.Semaphore}.
- * <p/>
+ * <p>
  * Works in non-fair mode. Therefore order of acquiring is unpredictable.
  * 
  * @author Nikita Koksharov

File: redisson/src/main/java/org/redisson/api/RedissonNodeInitializer.java
Patch:
@@ -27,7 +27,7 @@ public interface RedissonNodeInitializer {
     /**
      * Invoked during Redisson Node startup
      * 
-     * @param redissonNode
+     * @param redissonNode - Redisson Node instance
      */
     void onStartup(RedissonNode redissonNode);
     

File: redisson/src/main/java/org/redisson/api/annotation/RRemoteAsync.java
Patch:
@@ -23,10 +23,10 @@
 /**
  * Annotation used to mark interface as asynchronous 
  * client interface for remote service interface. 
- * <p/>
+ * <p>
  * All method signatures must match with remote service interface,
  * but return type must be <code>io.netty.util.concurrent.Future</code>.
- * <p/>
+ * <p>
  * It's not necessary to add all methods from remote service.
  * Add only those which are needed. 
  * 
@@ -40,7 +40,7 @@
     /**
      * Remote interface class used to register
      * 
-     * @return
+     * @return class used to register
      */
     Class<?> value();
     

File: redisson/src/main/java/org/redisson/config/Config.java
Patch:
@@ -353,9 +353,9 @@ public int getThreads() {
 
     /**
      * Threads amount shared between all redis node clients.
-     * <p/>
+     * <p>
      * Default is <code>0</code>.
-     * <p/>
+     * <p>
      * <code>0</code> means <code>current_processors_amount * 2</code>
      *
      * @param threads
@@ -419,7 +419,7 @@ public boolean isUseLinuxNativeEpoll() {
      * own threads and each Redisson client creates own EventLoopGroup by default.
      * So if there are multiple Redisson instances in same JVM
      * it would be useful to share one EventLoopGroup among them.
-     * <p/>
+     * <p>
      * Only {@link io.netty.channel.epoll.EpollEventLoopGroup} or
      * {@link io.netty.channel.nio.NioEventLoopGroup} can be used.
      *

File: redisson/src/main/java/org/redisson/misc/ReclosableLatch.java
Patch:
@@ -20,7 +20,7 @@
 
 /**
  * A thread gate, that uses an {@link java.util.concurrent.locks.AbstractQueuedSynchronizer}.
- * <p/>
+ * <p>
  * This implementation allows you to create a latch with a default state (open or closed), and repeatedly open or close
  * the latch.
  *

File: redisson/src/main/java/org/redisson/remote/RemoteServiceAckTimeoutException.java
Patch:
@@ -18,7 +18,7 @@
 /**
  * Rises when remote method executor has not answered 
  * within Ack timeout.
- * <p/>
+ * <p>
  * Method invocation has not been started in this case. 
  * So a new invocation attempt can be made. 
  * 

File: redisson/src/main/java/org/redisson/spring/cache/CacheConfig.java
Patch:
@@ -51,7 +51,7 @@ public CacheConfig() {
      * @param maxIdleTime - max idle time for key\value entry in milliseconds.
      *              If <code>0</code> then max idle time doesn't affect entry expiration.
      * @param maxIdleUnit
-     * <p/>
+     * <p>
      * if <code>maxIdleTime</code> and <code>ttl</code> params are equal to <code>0</code>
      * then entry stores infinitely.
      */

File: redisson/src/main/java/org/redisson/misc/RedissonObjectFactory.java
Patch:
@@ -153,7 +153,7 @@ public static <T> T fromReference(RedissonReactiveClient redisson, RedissonRefer
     }
 
     public static RedissonReference toReference(RedissonClient redisson, Object object) {
-        if (object instanceof RObject) {
+        if (object instanceof RObject && !(object instanceof RLiveObject)) {
             RObject rObject = ((RObject) object);
             redisson.getCodecProvider().registerCodec((Class) rObject.getCodec().getClass(), (Class) rObject.getClass(), rObject.getName(), rObject.getCodec());
             return new RedissonReference(object.getClass(), ((RObject) object).getName(), ((RObject) object).getCodec());
@@ -179,7 +179,7 @@ public static RedissonReference toReference(RedissonClient redisson, Object obje
     }
 
     public static RedissonReference toReference(RedissonReactiveClient redissonReactive, Object object) {
-        if (object instanceof RObjectReactive) {
+        if (object instanceof RObjectReactive && !(object instanceof RLiveObject)) {
             RObjectReactive rObject = ((RObjectReactive) object);
             redissonReactive.getCodecProvider().registerCodec((Class) rObject.getCodec().getClass(), (Class) rObject.getClass(), rObject.getName(), rObject.getCodec());
             return new RedissonReference(object.getClass(), ((RObjectReactive) object).getName(), ((RObjectReactive) object).getCodec());

File: redisson/src/main/java/org/redisson/liveobject/core/AccessorInterceptor.java
Patch:
@@ -146,7 +146,7 @@ public Object intercept(@Origin Method method, @SuperCall Callable<?> superMetho
                                             fieldName,
                                             arg),
                                     entry.getValue());
-                    } else if (obj instanceof Collection) {
+                    if (obj instanceof Collection) {
                         ((Collection) obj).addAll((Collection) arg);
                     } else {
                         ((Map) obj).putAll((Map) arg);

File: redisson/src/test/java/org/redisson/RedisClientTest.java
Patch:
@@ -75,7 +75,7 @@ public void testConnectAsync() throws InterruptedException {
             assertThat(conn.sync(RedisCommands.PING)).isEqualTo("PONG");
             l.countDown();
         });
-        l.await(10, TimeUnit.SECONDS);
+        assertThat(l.await(10, TimeUnit.SECONDS)).isTrue();
     }
 
     @Test

File: redisson/src/main/java/org/redisson/codec/JsonJacksonCodec.java
Patch:
@@ -16,6 +16,7 @@
 package org.redisson.codec;
 
 import java.io.IOException;
+import java.io.InputStream;
 
 import org.redisson.client.codec.Codec;
 import org.redisson.client.handler.State;
@@ -71,7 +72,7 @@ public byte[] encode(Object in) throws IOException {
     private final Decoder<Object> decoder = new Decoder<Object>() {
         @Override
         public Object decode(ByteBuf buf, State state) throws IOException {
-            return mapObjectMapper.readValue(new ByteBufInputStream(buf), Object.class);
+            return mapObjectMapper.readValue((InputStream)new ByteBufInputStream(buf), Object.class);
         }
     };
     

File: redisson/src/main/java/org/redisson/EvictionScheduler.java
Patch:
@@ -43,7 +43,7 @@
  */
 public class EvictionScheduler {
 
-    private static final Logger log = LoggerFactory.getLogger(RedissonSetCache.class);
+    private static final Logger log = LoggerFactory.getLogger(EvictionScheduler.class);
 
     public class RedissonCacheTask implements Runnable {
 

File: redisson/src/main/java/org/redisson/RedissonScoredSortedSet.java
Patch:
@@ -30,8 +30,8 @@
 import org.redisson.api.RFuture;
 import org.redisson.api.RScoredSortedSet;
 import org.redisson.client.codec.Codec;
+import org.redisson.client.codec.DoubleCodec;
 import org.redisson.client.codec.ScoredCodec;
-import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.client.protocol.RedisCommand.ValueType;
 import org.redisson.client.protocol.RedisCommands;
@@ -357,8 +357,8 @@ public Double addScore(V object, Number value) {
 
     @Override
     public RFuture<Double> addScoreAsync(V object, Number value) {
-        return commandExecutor.writeAsync(getName(), StringCodec.INSTANCE, RedisCommands.ZINCRBY,
-                                   getName(), new BigDecimal(value.toString()).toPlainString(), object);
+        return commandExecutor.writeAsync(getName(), DoubleCodec.INSTANCE, RedisCommands.ZINCRBY,
+                                   getName(), new BigDecimal(value.toString()).toPlainString(), encode(object));
     }
 
     @Override

File: redisson/src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -113,7 +113,7 @@ public interface RedisCommands {
     RedisCommand<List<ScoredEntry<Object>>> ZRANGE_ENTRY = new RedisCommand<List<ScoredEntry<Object>>>("ZRANGE", new ScoredSortedSetReplayDecoder<Object>());
     RedisCommand<List<ScoredEntry<Object>>> ZRANGEBYSCORE_ENTRY = new RedisCommand<List<ScoredEntry<Object>>>("ZRANGEBYSCORE", new ScoredSortedSetReplayDecoder<Object>());
     RedisCommand<ListScanResult<Object>> ZSCAN = new RedisCommand<ListScanResult<Object>>("ZSCAN", new NestedMultiDecoder(new ScoredSortedSetScanDecoder<Object>(), new ScoredSortedSetScanReplayDecoder()), ValueType.OBJECT);
-    RedisStrictCommand<Double> ZINCRBY = new RedisStrictCommand<Double>("ZINCRBY", new DoubleReplayConvertor(), 4);
+    RedisStrictCommand<Double> ZINCRBY = new RedisStrictCommand<Double>("ZINCRBY", new DoubleReplayConvertor());
 
     RedisCommand<ListScanResult<String>> SCAN = new RedisCommand<ListScanResult<String>>("SCAN", new NestedMultiDecoder(new ObjectListReplayDecoder<String>(), new ListScanResultReplayDecoder()), ValueType.OBJECT);
     RedisStrictCommand<String> RANDOM_KEY = new RedisStrictCommand<String>("RANDOMKEY", new StringDataDecoder());

File: redisson/src/test/java/org/redisson/connection/balancer/WeightedRoundRobinBalancerTest.java
Patch:
@@ -46,7 +46,7 @@ public void testUseMasterForReadsIfNoConnectionsToSlaves() throws IOException, I
             slave.stop();
 
             RedissonClient clientCopy = client;
-            await().atMost(5, TimeUnit.SECONDS).until(() -> assertThat(clientCopy.getBucket("key").get()).isNull());
+            assertThat(clientCopy.getBucket("key").get()).isNull();
         } finally {
             if (master != null) {
                 master.stop();

File: redisson/src/main/java/org/redisson/config/ConfigSupport.java
Patch:
@@ -23,6 +23,7 @@
 import java.net.URL;
 import java.util.List;
 
+import org.redisson.api.RedissonNodeInitializer;
 import org.redisson.client.codec.Codec;
 import org.redisson.cluster.ClusterConnectionManager;
 import org.redisson.connection.ConnectionManager;
@@ -201,6 +202,7 @@ private ObjectMapper createMapper(JsonFactory mapping) {
         mapper.addMixIn(SingleServerConfig.class, SingleSeverConfigMixIn.class);
         mapper.addMixIn(Config.class, ConfigMixIn.class);
         mapper.addMixIn(Codec.class, ClassMixIn.class);
+        mapper.addMixIn(RedissonNodeInitializer.class, ClassMixIn.class);
         mapper.addMixIn(LoadBalancer.class, ClassMixIn.class);
         FilterProvider filterProvider = new SimpleFilterProvider()
                 .addFilter("classFilter", SimpleBeanPropertyFilter.filterOutAllExcept());

File: redisson/src/main/java/org/redisson/config/RedissonNodeConfig.java
Patch:
@@ -28,7 +28,7 @@
  *
  */
 public class RedissonNodeConfig extends Config {
-
+    
     private RedissonNodeInitializer redissonNodeInitializer;
     private int executorServiceThreads = 0;
     private Map<String, Integer> executorServiceWorkers = new HashMap<String, Integer>();
@@ -49,7 +49,7 @@ public RedissonNodeConfig(RedissonNodeConfig oldConf) {
     }
 
     /**
-     * Executor service threads amount between all workers.
+     * Executor service threads amount shared between all workers.
      * <p>
      * <code>0</code> - create separate thread executor with <code>(current_processors_amount * 2)</code> threads
      * <p>

File: src/main/java/org/redisson/api/RLiveObjectService.java
Patch:
@@ -197,7 +197,7 @@ public interface RLiveObjectService {
     /**
      * Pre register the class with the service, registering all the classes on
      * startup can speed up the instance creation. This is <b>NOT</b> mandatory
-     * since the class will also be registered lazyly when it first is used.
+     * since the class will also be registered lazily when it is first used.
      * 
      * All classed registered with the service is stored in a class cache.
      * 

File: redisson/src/main/java/org/redisson/RedissonExecutorService.java
Patch:
@@ -280,7 +280,7 @@ public <T> RFuture<T> submitAsync(Callable<T> task) {
         return result;
     }
 
-    private <T> void addListener(RemotePromise<T> result) {
+    private <T> void addListener(final RemotePromise<T> result) {
         result.getAddFuture().addListener(new FutureListener<Boolean>() {
 
             @Override

File: redisson/src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -21,6 +21,7 @@
 import org.redisson.api.Node;
 import org.redisson.api.NodesGroup;
 import org.redisson.client.RedisConnectionException;
+import org.redisson.client.RedisException;
 import org.redisson.client.RedisOutOfMemoryException;
 import org.redisson.client.WriteRedisConnectionException;
 import org.redisson.client.protocol.decoder.ListScanResult;
@@ -104,7 +105,7 @@ public static class Dummy {
         private String field;
     }
 
-    @Test(expected = WriteRedisConnectionException.class)
+    @Test(expected = RedisException.class)
     public void testSer() {
         Config config = new Config();
         config.useSingleServer().setAddress("127.0.0.1:6379");

File: src/test/java/org/redisson/executor/RedissonExecutorServiceTest.java
Patch:
@@ -29,7 +29,7 @@ public static void beforeClass() throws IOException, InterruptedException {
         
         Config config = createConfig();
         RedissonNodeConfig nodeConfig = new RedissonNodeConfig(config);
-        nodeConfig.setExecutors(Collections.singletonMap("test", 1));
+        nodeConfig.setExecutorServiceWorkers(Collections.singletonMap("test", 1));
         RedissonNode.start(nodeConfig);
     }
     

File: src/main/java/org/redisson/executor/RemoteExecutorServiceImpl.java
Patch:
@@ -24,7 +24,6 @@
 import org.redisson.RedissonExecutorService;
 import org.redisson.api.annotation.RInject;
 import org.redisson.client.codec.Codec;
-import org.redisson.client.codec.LongCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.command.CommandExecutor;
 
@@ -133,7 +132,7 @@ public void executeVoid(String className, byte[] classBody, byte[] state) {
     private void finish() {
         classLoader.clearCurrentClassLoader();
 
-        commandExecutor.evalWrite(name, LongCodec.INSTANCE, RedisCommands.EVAL_VOID, 
+        commandExecutor.evalWrite(name, codec, RedisCommands.EVAL_VOID_WITH_VALUES_6, 
                 "if redis.call('decr', KEYS[1]) == 0 and redis.call('get', KEYS[2]) == ARGV[1] then "
                     + "redis.call('set', KEYS[2], ARGV[2]);"
                     + "redis.call('publish', KEYS[3], ARGV[2]);"

File: src/main/java/org/redisson/pubsub/PublishSubscribe.java
Patch:
@@ -61,7 +61,7 @@ public E getEntry(String entryName) {
     public Future<E> subscribe(final String entryName, final String channelName, final ConnectionManager connectionManager) {
         final AtomicReference<Runnable> listenerHolder = new AtomicReference<Runnable>();
         final AsyncSemaphore semaphore = connectionManager.getSemaphore(channelName);
-        final Promise<E> newPromise = new PromiseDelegator<E>(connectionManager.newPromise()) {
+        final Promise<E> newPromise = new PromiseDelegator<E>(connectionManager.<E>newPromise()) {
             @Override
             public boolean cancel(boolean mayInterruptIfRunning) {
                 return semaphore.remove(listenerHolder.get());

File: src/main/java/org/redisson/Redisson.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.TimeUnit;
 
 import org.redisson.api.ClusterNodesGroup;
@@ -95,8 +96,7 @@ public class Redisson implements RedissonClient {
     protected final CommandExecutor commandExecutor;
     protected final ConnectionManager connectionManager;
     
-    protected final Map<Class, Class> liveObjectClassCache
-            = PlatformDependent.<Class, Class>newConcurrentHashMap();
+    protected final ConcurrentMap<Class<?>, Class<?>> liveObjectClassCache = PlatformDependent.newConcurrentHashMap();
     protected final CodecProvider liveObjectDefaultCodecProvider = new DefaultCodecProvider();
     protected final ResolverProvider liveObjectDefaultResolverProvider = new DefaultResolverProvider();
     protected final Config config;

File: src/test/java/org/redisson/CommandHandlersTest.java
Patch:
@@ -2,7 +2,7 @@
 
 import org.junit.Test;
 import org.redisson.client.RedisException;
-import org.redisson.Config;
+import org.redisson.config.Config;
 
 public class CommandHandlersTest extends BaseTest {
 

File: src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -511,6 +511,9 @@ private <V, R> void checkWriteFuture(final AsyncDetails<V, R> details, final Red
 
         int timeoutTime = connectionManager.getConfig().getTimeout();
         if (QueueCommand.TIMEOUTLESS_COMMANDS.contains(details.getCommand().getName())) {
+            // add 1.5 second due to issue https://github.com/antirez/redis/issues/874
+            timeoutTime += Math.max(0, 1500 - timeoutTime);
+
             Integer popTimeout = Integer.valueOf(details.getParams()[details.getParams().length - 1].toString());
             handleBlockingOperations(details, connection, popTimeout);
             if (popTimeout == 0) {

File: src/test/java/org/redisson/RedissonTopicPatternTest.java
Patch:
@@ -225,7 +225,6 @@ public void onPUnsubscribe(String pattern) {
     @Test
     public void testConcurrentTopic() throws Exception {
         Config config = BaseTest.createConfig();
-        config.useSingleServer().setSubscriptionConnectionPoolSize(100);
         RedissonClient redisson = Redisson.create(config);
         
         int threads = 30;

File: src/test/java/org/redisson/RedissonLockHeavyTest.java
Patch:
@@ -56,7 +56,6 @@ public void run() {
                             } catch (InterruptedException e) {
                                 e.printStackTrace();
                             }
-                            semaphore.expire(30, TimeUnit.SECONDS);
                         } finally {
                             lock.unlock();
                         }

File: src/main/java/org/redisson/connection/balancer/LoadBalancerManagerImpl.java
Patch:
@@ -52,7 +52,7 @@ public LoadBalancerManagerImpl(MasterSlaveServersConfig config, ConnectionManage
         pubSubConnectionPool = new PubSubConnectionPool(config, connectionManager, entry);
     }
 
-    public Future<Void> add(ClientConnectionsEntry entry) {
+    public Future<Void> add(final ClientConnectionsEntry entry) {
         final Promise<Void> result = connectionManager.newPromise();
         FutureListener<Void> listener = new FutureListener<Void>() {
             AtomicInteger counter = new AtomicInteger(2);

File: src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -70,7 +70,7 @@ public class ClusterConnectionManager extends MasterSlaveConnectionManager {
 
     public ClusterConnectionManager(ClusterServersConfig cfg, Config config) {
         super(config);
-        connectListener = new ClusterConnectionListener(cfg.getReadMode() == ReadMode.SLAVE);
+        connectListener = new ClusterConnectionListener(cfg.getReadMode() != ReadMode.MASTER);
 
         this.config = create(cfg);
         init(this.config);

File: src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -26,6 +26,7 @@
 import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
@@ -61,7 +62,7 @@ public class ClusterConnectionManager extends MasterSlaveConnectionManager {
 
     private final Map<URI, RedisConnection> nodeConnections = PlatformDependent.newConcurrentHashMap();
 
-    private final Map<Integer, ClusterPartition> lastPartitions = PlatformDependent.newConcurrentHashMap();
+    private final ConcurrentMap<Integer, ClusterPartition> lastPartitions = PlatformDependent.newConcurrentHashMap();
 
     private ScheduledFuture<?> monitorFuture;
     

File: src/main/java/org/redisson/client/handler/ConnectionWatchdog.java
Patch:
@@ -61,6 +61,7 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {
     @Override
     public void channelInactive(ChannelHandlerContext ctx) throws Exception {
         RedisConnection connection = RedisConnection.getFrom(ctx.channel());
+        connection.onDisconnect();
         if (!connection.isClosed()) {
             EventLoopGroup group = ctx.channel().eventLoop().parent();
             reconnect(group, connection);

File: src/main/java/org/redisson/connection/PubSubConnectionEntry.java
Patch:
@@ -171,7 +171,8 @@ public boolean onStatus(PubSubType type, String ch) {
         conn.unsubscribe(channel);
     }
 
-    public void removeListeners(String channel) {
+    private void removeListeners(String channel) {
+        conn.removeDisconnectListener(channel);
         SubscribeListener s = subscribeChannelListeners.remove(channel);
         conn.removeListener(s);
         Queue<RedisPubSubListener> queue = channelListeners.get(channel);

File: src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -588,14 +588,14 @@ private void checkSlotsMigration(Collection<ClusterPartition> newPartitions, Str
                 currentPartition.addSlots(addedSlots);
                 
                 MasterSlaveEntry entry = getEntry(currentPartition.getMasterAddr());
-                
+
                 for (Integer slot : addedSlots) {
                     entry.addSlotRange(slot);
                     addEntry(slot, entry);
                     lastPartitions.put(slot, currentPartition);
                 }
                 if (!addedSlots.isEmpty()) {
-                    log.info("{} slots added to {}", addedSlots.size(), entry.getClient().getAddr());
+                    log.info("{} slots added to {}", addedSlots.size(), currentPartition.getMasterAddr());
                 }
 
                 Set<Integer> removedSlots = new HashSet<Integer>(currentPartition.getSlots());
@@ -609,7 +609,7 @@ private void checkSlotsMigration(Collection<ClusterPartition> newPartitions, Str
                 currentPartition.removeSlots(removedSlots);
 
                 if (!removedSlots.isEmpty()) {
-                    log.info("{} slots removed from {}", removedSlots.size(), entry.getClient().getAddr());
+                    log.info("{} slots removed from {}", removedSlots.size(), currentPartition.getMasterAddr());
                 }
                 break;
             }

File: src/main/java/org/redisson/liveobject/core/LiveObjectInterceptor.java
Patch:
@@ -51,6 +51,7 @@ public interface Setter {
     private final CodecProvider codecProvider;
     private final Class originalClass;
     private final String idFieldName;
+    private final Class idFieldType;
     private final NamingScheme namingScheme;
     private final Class<? extends Codec> codecClass;
 
@@ -63,6 +64,7 @@ public LiveObjectInterceptor(RedissonClient redisson, CodecProvider codecProvide
         this.codecClass = anno.codec();
         try {
             this.namingScheme = anno.namingScheme().getDeclaredConstructor(Codec.class).newInstance(codecProvider.getCodec(anno, originalClass));
+            this.idFieldType = originalClass.getDeclaredField(idFieldName).getType();
         } catch (Exception e) {
             throw new IllegalArgumentException(e);
         }
@@ -129,7 +131,7 @@ public Object intercept(
     }
 
     private String getMapKey(Object id) {
-        return namingScheme.getName(originalClass, idFieldName, id);
+        return namingScheme.getName(originalClass, idFieldType, idFieldName, id);
     }
 
 }

File: src/main/java/org/redisson/liveobject/resolver/NamingScheme.java
Patch:
@@ -21,7 +21,9 @@
  */
 public interface NamingScheme {
 
-    public String getName(Class cls, String fieldName, Object fieldValue);
+    public String getName(Class entityClass, Class idFieldClass, String idFieldName, Object idValue);
+    
+    public String getFieldReferenceName(Class entityClass, Class idFieldClass, String idFieldName, Object idValue, Class cls, String fieldName, Object fieldValue);
 
     public String resolveClassName(String name);
 

File: src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -267,9 +267,11 @@ public interface RedisCommands {
 
     RedisStrictCommand<Void> CLUSTER_REPLICATE = new RedisStrictCommand<Void>("CLUSTER", "REPLICATE");
     RedisStrictCommand<Void> CLUSTER_FORGET = new RedisStrictCommand<Void>("CLUSTER", "FORGET");
+    RedisStrictCommand<Void> CLUSTER_RESET = new RedisStrictCommand<Void>("CLUSTER", "RESET");
     RedisStrictCommand<List<String>> CLUSTER_GETKEYSINSLOT = new RedisStrictCommand<List<String>>("CLUSTER", "GETKEYSINSLOT", new StringListReplayDecoder());
     RedisStrictCommand<Void> CLUSTER_SETSLOT = new RedisStrictCommand<Void>("CLUSTER", "SETSLOT");
     RedisStrictCommand<Void> CLUSTER_MEET = new RedisStrictCommand<Void>("CLUSTER", "MEET");
+    RedisStrictCommand<Map<String, String>> INFO_KEYSPACE = new RedisStrictCommand<Map<String, String>>("INFO", "KEYSPACE", new StringMapDataDecoder());
     RedisStrictCommand<Map<String, String>> INFO_CLUSTER = new RedisStrictCommand<Map<String, String>>("INFO", "CLUSTER", new StringMapDataDecoder());
     RedisStrictCommand<String> INFO_REPLICATION = new RedisStrictCommand<String>("INFO", "replication", new StringDataDecoder());
     RedisStrictCommand<Map<String, String>> INFO_PERSISTENCE = new RedisStrictCommand<Map<String, String>>("INFO", "persistence", new StringMapDataDecoder());

File: src/main/java/org/redisson/command/CommandReactiveExecutor.java
Patch:
@@ -24,6 +24,7 @@
 import org.redisson.client.codec.Codec;
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.connection.ConnectionManager;
+import org.redisson.connection.MasterSlaveEntry;
 
 import io.netty.util.concurrent.Future;
 
@@ -47,7 +48,7 @@ <T, R> Publisher<R> evalReadReactive(InetSocketAddress client, String key, Codec
 
     <T, R> Publisher<R> readRandomReactive(RedisCommand<T> command, Object ... params);
 
-    <T, R> Publisher<R> writeReactive(Integer slot, Codec codec, RedisCommand<T> command, Object ... params);
+    <T, R> Publisher<R> writeReactive(MasterSlaveEntry entry, Codec codec, RedisCommand<T> command, Object ... params);
 
     <T> Publisher<Void> writeAllReactive(RedisCommand<T> command, Object ... params);
 

File: src/main/java/org/redisson/command/CommandReactiveService.java
Patch:
@@ -24,6 +24,7 @@
 import org.redisson.client.codec.Codec;
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.connection.ConnectionManager;
+import org.redisson.connection.MasterSlaveEntry;
 import org.redisson.reactive.NettyFuturePublisher;
 
 import io.netty.util.concurrent.Future;
@@ -79,8 +80,8 @@ public <T, R> Publisher<R> writeReactive(String key, Codec codec, RedisCommand<T
     }
 
     @Override
-    public <T, R> Publisher<R> writeReactive(Integer slot, Codec codec, RedisCommand<T> command, Object ... params) {
-        Future<R> f = writeAsync(slot, codec, command, params);
+    public <T, R> Publisher<R> writeReactive(MasterSlaveEntry entry, Codec codec, RedisCommand<T> command, Object ... params) {
+        Future<R> f = writeAsync(entry, codec, command, params);
         return new NettyFuturePublisher<R>(f);
     }
 

File: src/main/java/org/redisson/connection/ElasticacheConnectionManager.java
Patch:
@@ -141,7 +141,7 @@ public void run() {
                             log.debug("Current master {} unchanged", master);
                         } else if (Role.master.equals(role) && !master.equals(addr) && currentMaster.compareAndSet(master, addr)) {
                             log.info("Master has changed from {} to {}", master, addr);
-                            changeMaster(singleSlotRange, addr.getHost(), addr.getPort());
+                            changeMaster(singleSlotRange.getStartSlot(), addr.getHost(), addr.getPort());
                             break;
                         }
                     }

File: src/main/java/org/redisson/connection/SingleConnectionManager.java
Patch:
@@ -88,7 +88,7 @@ public void run() {
                     if (!now.getHostAddress().equals(master.getHostAddress())) {
                         log.info("Detected DNS change. {} has changed from {} to {}", cfg.getAddress().getHost(), master.getHostAddress(), now.getHostAddress());
                         if (currentMaster.compareAndSet(master, now)) {
-                            changeMaster(singleSlotRange, cfg.getAddress().getHost(), cfg.getAddress().getPort());
+                            changeMaster(singleSlotRange.getStartSlot(), cfg.getAddress().getHost(), cfg.getAddress().getPort());
                             log.info("Master has been changed");
                         }
                     }

File: src/test/java/org/redisson/RedissonSetTest.java
Patch:
@@ -53,9 +53,9 @@ public void testRandom() {
         set.add(2);
         set.add(3);
 
-        assertThat(set.removeRandom()).isIn(1, 2, 3);
-        assertThat(set.removeRandom()).isIn(1, 2, 3);
-        assertThat(set.removeRandom()).isIn(1, 2, 3);
+        assertThat(set.random()).isIn(1, 2, 3);
+        assertThat(set.random()).isIn(1, 2, 3);
+        assertThat(set.random()).isIn(1, 2, 3);
         assertThat(set).containsOnly(1, 2, 3);
     }
 

File: src/test/java/org/redisson/RedissonSetReactiveTest.java
Patch:
@@ -64,9 +64,9 @@ public void testRandom() {
         sync(set.add(2));
         sync(set.add(3));
 
-        MatcherAssert.assertThat(sync(set.removeRandom()), Matchers.isOneOf(1, 2, 3));
-        MatcherAssert.assertThat(sync(set.removeRandom()), Matchers.isOneOf(1, 2, 3));
-        MatcherAssert.assertThat(sync(set.removeRandom()), Matchers.isOneOf(1, 2, 3));
+        MatcherAssert.assertThat(sync(set.random()), Matchers.isOneOf(1, 2, 3));
+        MatcherAssert.assertThat(sync(set.random()), Matchers.isOneOf(1, 2, 3));
+        MatcherAssert.assertThat(sync(set.random()), Matchers.isOneOf(1, 2, 3));
         Assert.assertThat(sync(set), Matchers.containsInAnyOrder(1, 2, 3));
     }
 

File: src/main/java/org/redisson/RedissonReference.java
Patch:
@@ -56,7 +56,7 @@ public boolean isDefaultCodec() {
      *     ExceptionInInitializerError - if the initialization provoked by this method fails
      *     ClassNotFoundException - if the class cannot be located
      */
-    public Class getType() throws Exception {
+    public Class<?> getType() throws Exception {
         return Class.forName(type);
     }
 
@@ -70,7 +70,7 @@ public String getTypeName() {
     /**
      * @param type the type to set
      */
-    public void setType(Class type) {
+    public void setType(Class<?> type) {
         if (!type.isAnnotationPresent(REntity.class) && !RObject.class.isAssignableFrom(type)) {
             throw new IllegalArgumentException("Class reference has to be a type of either RObject or RLiveObject");
         }

File: src/main/java/org/redisson/liveobject/resolver/NamingScheme.java
Patch:
@@ -21,7 +21,7 @@
  */
 public interface NamingScheme {
 
-    public String getName(Class cls, String idFieldName, Object id);
+    public String getName(Class cls, String fieldName, Object fieldValue);
 
     public String resolveClassName(String name);
 

File: src/main/java/org/redisson/liveobject/provider/DefaultResolverProvider.java
Patch:
@@ -28,7 +28,7 @@ public class DefaultResolverProvider implements ResolverProvider {
     public final ConcurrentMap<Class<? extends Resolver>, Resolver> providerCache = PlatformDependent.newConcurrentHashMap();
 
     @Override
-    public Resolver getResolver(Class cls, Class<? extends Resolver> resolverClass, Annotation anno) {
+    public Resolver getResolver(Class<?> cls, Class<? extends Resolver> resolverClass, Annotation anno) {
         if (!providerCache.containsKey(resolverClass)) {
             try {
                 providerCache.putIfAbsent(resolverClass, resolverClass.newInstance());
@@ -40,7 +40,7 @@ public Resolver getResolver(Class cls, Class<? extends Resolver> resolverClass,
     }
 
     @Override
-    public void registerResolver(Class cls, Class<? extends Resolver> resolverClass, Resolver resolver) {
+    public void registerResolver(Class<?> cls, Class<? extends Resolver> resolverClass, Resolver resolver) {
         providerCache.putIfAbsent(resolverClass, resolver);
     }
     

File: src/main/java/org/redisson/liveobject/provider/ResolverProvider.java
Patch:
@@ -24,7 +24,7 @@
  */
 public interface ResolverProvider {
 
-    Resolver getResolver(Class cls, Class<? extends Resolver> resolverClass, Annotation anno);
-    void registerResolver(Class cls, Class<? extends Resolver> resolverClass, Resolver resolver);
+    Resolver getResolver(Class<?> cls, Class<? extends Resolver> resolverClass, Annotation anno);
+    void registerResolver(Class<?> cls, Class<? extends Resolver> resolverClass, Resolver resolver);
     
 }

File: src/main/java/org/redisson/Redisson.java
Patch:
@@ -76,7 +76,7 @@
 import org.redisson.core.RTopic;
 import org.redisson.liveobject.provider.CodecProvider;
 import org.redisson.liveobject.provider.DefaultCodecProvider;
-import org.redisson.liveobject.RLiveObjectService;
+import org.redisson.api.RLiveObjectService;
 
 import io.netty.util.concurrent.Future;
 import io.netty.util.internal.PlatformDependent;

File: src/main/java/org/redisson/RedissonClient.java
Patch:
@@ -60,7 +60,7 @@
 import org.redisson.core.RSortedSet;
 import org.redisson.core.RTopic;
 import org.redisson.liveobject.provider.CodecProvider;
-import org.redisson.liveobject.RLiveObjectService;
+import org.redisson.api.RLiveObjectService;
 import org.redisson.liveobject.provider.ResolverProvider;
 
 /**

File: src/main/java/org/redisson/RedissonLiveObjectService.java
Patch:
@@ -36,8 +36,8 @@
 //import org.redisson.core.RObjectAsync;
 import org.redisson.liveobject.provider.CodecProvider;
 import org.redisson.liveobject.LiveObjectTemplate;
-import org.redisson.liveobject.RLiveObjectService;
-import org.redisson.liveobject.RLiveObject;
+import org.redisson.api.RLiveObjectService;
+import org.redisson.api.RLiveObject;
 import org.redisson.liveobject.provider.ResolverProvider;
 import org.redisson.liveobject.annotation.REntity;
 import org.redisson.liveobject.annotation.RId;

File: src/main/java/org/redisson/api/RLiveObject.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.redisson.liveobject;
+package org.redisson.api;
 
 //import org.redisson.core.RMap;
 

File: src/main/java/org/redisson/core/RedissonRedLock.java
Patch:
@@ -60,7 +60,7 @@ protected boolean sync(Map<RLock, Future<Boolean>> tryLockFutures) {
         }
         
         if (lockedLocks.size() < minLocksAmount(locks)) {
-            unlock();
+            unlockInner(lockedLocks);
             lockedLocks.clear();
             if (latestException != null) {
                 throw latestException;

File: src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -703,7 +703,7 @@ public Future<Void> putAllAsync(Map<? extends K, ? extends V> map) {
 
     @Override
     public Future<Boolean> deleteAsync() {
-        return commandExecutor.writeAsync(getName(), RedisCommands.DEL_OBJECTS, getName(), getTimeoutSetName());
+        return commandExecutor.writeAsync(getName(), RedisCommands.DEL_OBJECTS, getName(), getTimeoutSetName(), getIdleSetName());
     }
 
     @Override

File: src/main/java/org/redisson/RedissonClient.java
Patch:
@@ -59,9 +59,9 @@
 import org.redisson.core.RSetMultimapCache;
 import org.redisson.core.RSortedSet;
 import org.redisson.core.RTopic;
-import org.redisson.liveobject.CodecProvider;
+import org.redisson.liveobject.provider.CodecProvider;
 import org.redisson.liveobject.RLiveObjectService;
-import org.redisson.liveobject.ResolverProvider;
+import org.redisson.liveobject.provider.ResolverProvider;
 
 /**
  * Main Redisson interface for access

File: src/main/java/org/redisson/RedissonLiveObjectService.java
Patch:
@@ -34,11 +34,11 @@
 //import org.redisson.core.RMap;
 import org.redisson.core.RObject;
 //import org.redisson.core.RObjectAsync;
-import org.redisson.liveobject.CodecProvider;
+import org.redisson.liveobject.provider.CodecProvider;
 import org.redisson.liveobject.LiveObjectTemplate;
 import org.redisson.liveobject.RLiveObjectService;
 import org.redisson.liveobject.RLiveObject;
-import org.redisson.liveobject.ResolverProvider;
+import org.redisson.liveobject.provider.ResolverProvider;
 import org.redisson.liveobject.annotation.REntity;
 import org.redisson.liveobject.annotation.RId;
 import org.redisson.liveobject.core.AccessorInterceptor;

File: src/main/java/org/redisson/liveobject/core/LiveObjectInterceptor.java
Patch:
@@ -27,7 +27,8 @@
 import org.redisson.client.RedisException;
 import org.redisson.client.codec.Codec;
 import org.redisson.core.RMap;
-import org.redisson.liveobject.CodecProvider;
+import org.redisson.liveobject.provider.CodecProvider;
+import org.redisson.liveobject.resolver.NamingScheme;
 import org.redisson.liveobject.annotation.REntity;
 
 /**
@@ -50,7 +51,7 @@ public interface Setter {
     private final CodecProvider codecProvider;
     private final Class originalClass;
     private final String idFieldName;
-    private final REntity.NamingScheme namingScheme;
+    private final NamingScheme namingScheme;
     private final Class<? extends Codec> codecClass;
 
     public LiveObjectInterceptor(RedissonClient redisson, CodecProvider codecProvider, Class entityClass, String idFieldName) {

File: src/main/java/org/redisson/liveobject/provider/CodecProvider.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.redisson.liveobject;
+package org.redisson.liveobject.provider;
 
 import org.redisson.client.codec.Codec;
 import org.redisson.core.RObject;

File: src/main/java/org/redisson/liveobject/provider/DefaultCodecProvider.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.redisson.liveobject;
+package org.redisson.liveobject.provider;
 
 import io.netty.util.internal.PlatformDependent;
 import java.util.concurrent.ConcurrentMap;

File: src/main/java/org/redisson/liveobject/provider/DefaultResolverProvider.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.redisson.liveobject;
+package org.redisson.liveobject.provider;
 
 import io.netty.util.internal.PlatformDependent;
 import java.lang.annotation.Annotation;

File: src/main/java/org/redisson/liveobject/provider/ResolverProvider.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.redisson.liveobject;
+package org.redisson.liveobject.provider;
 
 import java.lang.annotation.Annotation;
 import org.redisson.liveobject.resolver.Resolver;

File: src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -34,6 +34,7 @@
 import org.redisson.client.protocol.convertor.KeyValueConvertor;
 import org.redisson.client.protocol.convertor.LongReplayConvertor;
 import org.redisson.client.protocol.convertor.TrueReplayConvertor;
+import org.redisson.client.protocol.convertor.TypeConvertor;
 import org.redisson.client.protocol.convertor.VoidReplayConvertor;
 import org.redisson.client.protocol.decoder.KeyValueObjectDecoder;
 import org.redisson.client.protocol.decoder.ListResultReplayDecoder;
@@ -56,6 +57,7 @@
 import org.redisson.client.protocol.decoder.StringMapDataDecoder;
 import org.redisson.client.protocol.decoder.StringReplayDecoder;
 import org.redisson.client.protocol.pubsub.PubSubStatusDecoder;
+import org.redisson.core.RType;
 
 public interface RedisCommands {
 
@@ -66,6 +68,7 @@ public interface RedisCommands {
     RedisCommand<List<Object>> GEORADIUSBYMEMBER = new RedisCommand<List<Object>>("GEORADIUSBYMEMBER", new ObjectListReplayDecoder<Object>(), 2);
     
     RedisStrictCommand<Integer> KEYSLOT = new RedisStrictCommand<Integer>("CLUSTER", "KEYSLOT", new IntegerReplayConvertor());
+    RedisStrictCommand<RType> TYPE = new RedisStrictCommand<RType>("TYPE", new TypeConvertor());
 
     RedisStrictCommand<Boolean> GETBIT = new RedisStrictCommand<Boolean>("GETBIT", new BooleanReplayConvertor());
     RedisStrictCommand<Integer> BITS_SIZE = new RedisStrictCommand<Integer>("STRLEN", new BitsSizeReplayConvertor());

File: src/main/java/org/redisson/liveobject/misc/RedissonObjectFactory.java
Patch:
@@ -36,7 +36,7 @@ public static <T> T create(RedissonClient redisson, CodecProvider codecProvider,
                 REntity.NamingScheme ns = anno.namingScheme()
                         .getDeclaredConstructor(Codec.class)
                         .newInstance(codecProvider.getCodec(anno, rr.getType()));
-                return (T) redisson.getLiveObjectService(codecProvider).get(type, ns.resolveId(rr.getKeyName()));
+                return (T) redisson.getLiveObjectService(codecProvider).getOrCreate(type, ns.resolveId(rr.getKeyName()));
             }
             for (Method method : RedissonClient.class.getDeclaredMethods()) {
                 if (method.getName().startsWith("get")

File: src/main/java/org/redisson/client/BaseRedisPubSubListener.java
Patch:
@@ -17,19 +17,19 @@
 
 import org.redisson.client.protocol.pubsub.PubSubType;
 
-public class BaseRedisPubSubListener<V> implements RedisPubSubListener<V> {
+public class BaseRedisPubSubListener implements RedisPubSubListener<Object> {
 
     @Override
     public boolean onStatus(PubSubType type, String channel) {
         return false;
     }
 
     @Override
-    public void onMessage(String channel, V message) {
+    public void onMessage(String channel, Object message) {
     }
 
     @Override
-    public void onPatternMessage(String pattern, String channel, V message) {
+    public void onPatternMessage(String pattern, String channel, Object message) {
     }
 
 }

File: src/main/java/org/redisson/client/protocol/pubsub/PubSubMessageDecoder.java
Patch:
@@ -39,8 +39,8 @@ public Object decode(ByteBuf buf, State state) throws IOException {
     }
 
     @Override
-    public PubSubMessage<Object> decode(List<Object> parts, State state) {
-        return new PubSubMessage<Object>(parts.get(1).toString(), parts.get(2));
+    public PubSubMessage decode(List<Object> parts, State state) {
+        return new PubSubMessage(parts.get(1).toString(), parts.get(2));
     }
 
     @Override

File: src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -91,9 +91,9 @@ public interface ConnectionManager {
 
     PubSubConnectionEntry getPubSubEntry(String channelName);
 
-    Future<PubSubConnectionEntry> psubscribe(String pattern, Codec codec);
+    Future<PubSubConnectionEntry> psubscribe(String pattern, Codec codec, RedisPubSubListener<?> listener);
 
-    Future<Codec> unsubscribe(String channelName);
+    Codec unsubscribe(String channelName);
 
     Codec punsubscribe(String channelName);
 

File: src/main/java/org/redisson/BaseMasterSlaveServersConfig.java
Patch:
@@ -33,7 +33,7 @@ public class BaseMasterSlaveServersConfig<T extends BaseMasterSlaveServersConfig
     /**
      * Redis 'slave' node maximum subscription (pub/sub) connection pool size for <b>each</b> slave node
      */
-    private int slaveSubscriptionConnectionPoolSize = 25;
+    private int slaveSubscriptionConnectionPoolSize = 50;
 
     /**
      * Redis 'slave' node minimum idle connection amount for <b>each</b> slave node
@@ -127,7 +127,7 @@ public LoadBalancer getLoadBalancer() {
     /**
      * Redis 'slave' node maximum subscription (pub/sub) connection pool size for <b>each</b> slave node
      * <p/>
-     * Default is <code>25</code>
+     * Default is <code>50</code>
      * <p/>
      * @see #setSlaveSubscriptionConnectionMinimumIdleSize(int)
      *

File: src/main/java/org/redisson/SingleServerConfig.java
Patch:
@@ -38,7 +38,7 @@ public class SingleServerConfig extends BaseConfig<SingleServerConfig> {
      * Redis subscription connection maximum pool size
      *
      */
-    private int subscriptionConnectionPoolSize = 25;
+    private int subscriptionConnectionPoolSize = 50;
 
     /**
      * Minimum idle Redis connection amount
@@ -100,7 +100,7 @@ public int getConnectionPoolSize() {
 
     /**
      * Redis subscription-connection pool size limit
-     * Default is 25
+     * Default is 50
      *
      * @param connectionPoolSize
      * @return

File: src/test/java/org/redisson/RedissonSetMultimapTest.java
Patch:
@@ -139,13 +139,14 @@ public void testKeySize() {
         map.put(new SimpleKey("0"), new SimpleValue("2"));
         map.put(new SimpleKey("1"), new SimpleValue("3"));
 
-        assertThat(map.size()).isEqualTo(2);
+        assertThat(map.keySize()).isEqualTo(2);
+        assertThat(map.keySet().size()).isEqualTo(2);
 
         map.fastRemove(new SimpleKey("0"));
 
         Set<SimpleValue> s = map.get(new SimpleKey("0"));
         assertThat(s).isEmpty();
-        assertThat(map.size()).isEqualTo(1);
+        assertThat(map.keySize()).isEqualTo(1);
     }
 
     @Test

File: src/main/java/org/redisson/RedissonMultimap.java
Patch:
@@ -281,7 +281,7 @@ public boolean remove(Object o) {
 
         @Override
         public int size() {
-            return RedissonMultimap.this.size();
+            return RedissonMultimap.this.keySize();
         }
 
         @Override

File: src/main/java/org/redisson/Redisson.java
Patch:
@@ -556,8 +556,8 @@ public RLiveObjectService getLiveObjectService() {
     }
     
     @Override
-    public RLiveObjectService getLiveObjectService(CodecProvider ProviderCodec) {
-        return new RedissonLiveObjectService(this, liveObjectClassCache, new DefaultCodecProvider());
+    public RLiveObjectService getLiveObjectService(CodecProvider codecProvider) {
+        return new RedissonLiveObjectService(this, liveObjectClassCache, codecProvider);
     }
     
     @Override

File: src/main/java/org/redisson/spring/cache/RedissonCache.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.Map;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
@@ -39,6 +40,8 @@
  */
 public class RedissonCache implements Cache {
 
+    private final ConcurrentMap<Object, Lock> valueLoaderLocks = new ConcurrentHashMap<Object, Lock>();
+    
     private RMapCache<Object, Object> mapCache;
 
     private final RMap<Object, Object> map;
@@ -127,8 +130,6 @@ private ValueWrapper toValueWrapper(Object value) {
         return new SimpleValueWrapper(value);
     }
 
-    final Map<Object, Lock> valueLoaderLocks = new ConcurrentHashMap<Object, Lock>();
-    
     public Lock getLock(Object key) {
         Lock lock = valueLoaderLocks.get(key);
         if (lock == null) {

File: src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -226,9 +226,9 @@ public void operationComplete(Future<Map<String, String>> future) throws Excepti
 
                             e = new MasterSlaveEntry(partition.getSlotRanges(), ClusterConnectionManager.this, config);
 
+                            List<Future<Void>> fs = e.initSlaveBalancer(partition.getFailedSlaveAddresses());
+                            futures.addAll(fs);
                             if (!partition.getSlaveAddresses().isEmpty()) {
-                                List<Future<Void>> fs = e.initSlaveBalancer(partition.getFailedSlaveAddresses());
-                                futures.addAll(fs);
                                 log.info("slaves: {} added for slot ranges: {}", partition.getSlaveAddresses(), partition.getSlotRanges());
                                 if (!partition.getFailedSlaveAddresses().isEmpty()) {
                                     log.warn("slaves: {} is down for slot ranges: {}", partition.getFailedSlaveAddresses(), partition.getSlotRanges());
@@ -403,7 +403,7 @@ public void operationComplete(Future<Void> future) throws Exception {
 
                     currentPart.addSlaveAddress(uri);
                     entry.slaveUp(uri.getHost(), uri.getPort(), FreezeReason.MANAGER);
-                    log.info("slave {} added for slot ranges: {}", uri, currentPart.getSlotRanges());
+                    log.info("slave: {} added for slot ranges: {}", uri, currentPart.getSlotRanges());
                 }
             });
         }

File: src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -470,8 +470,8 @@ public Future<Codec> unsubscribe(final String channelName) {
             return null;
         }
 
-        Promise<Codec> result = newPromise();
-        Codec entryCodec = entry.getConnection().getChannels().get(channelName);
+        final Promise<Codec> result = newPromise();
+        final Codec entryCodec = entry.getConnection().getChannels().get(channelName);
         entry.unsubscribe(channelName, new BaseRedisPubSubListener() {
 
             @Override

File: src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -93,7 +93,7 @@ public interface ConnectionManager {
 
     Future<PubSubConnectionEntry> psubscribe(String pattern, Codec codec);
 
-    Codec unsubscribe(String channelName);
+    Future<Codec> unsubscribe(String channelName);
 
     Codec punsubscribe(String channelName);
 

File: src/main/java/org/redisson/pubsub/PublishSubscribe.java
Patch:
@@ -38,7 +38,7 @@ public void unsubscribe(E entry, String entryName, String channelName, Connectio
                 // just an assertion
                 boolean removed = entries.remove(entryName) == entry;
                 if (removed) {
-                    connectionManager.unsubscribe(channelName);
+                    connectionManager.unsubscribe(channelName).syncUninterruptibly();
                 }
             }
         }

File: src/main/java/org/redisson/liveobject/core/AccessorInterceptor.java
Patch:
@@ -132,7 +132,7 @@ private RObject createRedissonObject(RedissonReference rr, Class expected) throw
             for (Method method : RedissonClient.class.getDeclaredMethods()) {
                 if (method.getName().startsWith("get")
                         && method.getReturnType().isAssignableFrom(rr.getType())
-                        && method.getReturnType().isAssignableFrom(expected)) {
+                        && expected.isAssignableFrom(method.getReturnType())) {
                     if (rr.isDefaultCodec() && method.getParameterCount() == 1) {
                         return (RObject) method.invoke(redisson, rr.getKeyName());
                     } else if (!rr.isDefaultCodec()

File: src/test/java/org/redisson/RedissonLockTest.java
Patch:
@@ -1,11 +1,11 @@
 package org.redisson;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.locks.Lock;
-import static com.jayway.awaitility.Awaitility.*;
-import static org.assertj.core.api.Assertions.assertThat;
 
 import org.junit.Assert;
 import org.junit.Test;
@@ -28,7 +28,7 @@ public void run() {
         
         long startTime = System.currentTimeMillis();
         lock.tryLock(3, TimeUnit.SECONDS);
-        assertThat(System.currentTimeMillis() - startTime).isGreaterThan(2990);
+        assertThat(System.currentTimeMillis() - startTime).isBetween(2990L, 3020L);
     }
     
     @Test

File: src/main/java/org/redisson/core/NodesGroup.java
Patch:
@@ -27,15 +27,15 @@
 public interface NodesGroup<N extends Node> {
 
     /**
-     * Adds connect listener which will be triggered
+     * Adds connection listener which will be triggered
      * when Redisson has just been connected to or disconnected from redis server
      *
      * @param connectionListener
      */
     int addConnectionListener(ConnectionListener connectionListener);
 
     /**
-     * Removes connect listener by id
+     * Removes connection listener by id
      *
      * @param listenerId
      */

File: src/main/java/org/redisson/RedissonScript.java
Patch:
@@ -103,6 +103,7 @@ public <R> Future<R> evalAsync(Mode mode, Codec codec, String luaScript, ReturnT
         return evalAsync(null, mode, codec, luaScript, returnType, keys, values);
     }
 
+    @Override
     public <R> Future<R> evalAsync(String key, Mode mode, Codec codec, String luaScript, ReturnType returnType, List<Object> keys, Object... values) {
         if (mode == Mode.READ_ONLY) {
             return commandExecutor.evalReadAsync(key, codec, returnType.getCommand(), luaScript, keys, values);

File: src/main/java/org/redisson/core/RScriptAsync.java
Patch:
@@ -39,6 +39,8 @@ public interface RScriptAsync {
 
     <R> Future<R> evalAsync(Mode mode, Codec codec, String luaScript, ReturnType returnType, List<Object> keys, Object... values);
 
+    <R> Future<R> evalAsync(String key, Mode mode, Codec codec, String luaScript, ReturnType returnType, List<Object> keys, Object... values);
+
     <R> Future<R> evalAsync(Mode mode, String luaScript, ReturnType returnType);
 
     <R> Future<R> evalAsync(Mode mode, Codec codec, String luaScript, ReturnType returnType);

File: src/main/java/org/redisson/core/RScriptAsync.java
Patch:
@@ -38,6 +38,8 @@ public interface RScriptAsync {
     <R> Future<R> evalAsync(Mode mode, String luaScript, ReturnType returnType, List<Object> keys, Object... values);
 
     <R> Future<R> evalAsync(Mode mode, Codec codec, String luaScript, ReturnType returnType, List<Object> keys, Object... values);
+    
+    <R> Future<R> evalAsync(String key, Mode mode, Codec codec, String luaScript, ReturnType returnType, List<Object> keys, Object... values);
 
     <R> Future<R> evalAsync(Mode mode, String luaScript, ReturnType returnType);
 

File: src/main/java/org/redisson/core/RScriptAsync.java
Patch:
@@ -39,6 +39,8 @@ public interface RScriptAsync {
 
     <R> Future<R> evalAsync(Mode mode, Codec codec, String luaScript, ReturnType returnType, List<Object> keys, Object... values);
 
+    <R> Future<R> evalAsync(String key, Mode mode, Codec codec, String luaScript, ReturnType returnType, List<Object> keys, Object... values);
+
     <R> Future<R> evalAsync(Mode mode, String luaScript, ReturnType returnType);
 
     <R> Future<R> evalAsync(Mode mode, Codec codec, String luaScript, ReturnType returnType);

File: src/main/java/org/redisson/codec/FstCodec.java
Patch:
@@ -72,6 +72,7 @@ public byte[] encode(Object in) throws IOException {
             ByteArrayOutputStream os = new ByteArrayOutputStream();
             FSTObjectOutput oos = config.getObjectOutput(os);
             oos.writeObject(in);
+            oos.flush();
             return os.toByteArray();
         }
     };

File: src/test/java/org/redisson/BaseReactiveTest.java
Patch:
@@ -31,7 +31,7 @@ public static void beforeClass() throws IOException, InterruptedException {
     @AfterClass
     public static void afterClass() throws IOException, InterruptedException {
         if (!RedissonRuntimeEnvironment.isTravis) {
-            RedisRunner.startDefaultRedisServerInstance();
+            RedisRunner.shutDownDefaultRedisServerInstance();
             defaultRedisson.shutdown();
         }
     }

File: src/test/java/org/redisson/RedissonCountDownLatchConcurrentTest.java
Patch:
@@ -26,7 +26,7 @@ public static void beforeClass() throws IOException, InterruptedException {
     @AfterClass
     public static void afterClass() throws IOException, InterruptedException {
         if (!RedissonRuntimeEnvironment.isTravis) {
-            RedisRunner.startDefaultRedisServerInstance();
+            RedisRunner.shutDownDefaultRedisServerInstance();
         }
     }
 

File: src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -44,7 +44,7 @@ public static void beforeClass() throws IOException, InterruptedException {
     @AfterClass
     public static void afterClass() throws IOException, InterruptedException {
         if (!RedissonRuntimeEnvironment.isTravis) {
-            RedisRunner.startDefaultRedisServerInstance();
+            RedisRunner.shutDownDefaultRedisServerInstance();
             defaultRedisson.shutdown();
         }
     }

File: src/test/java/org/redisson/RedissonTopicPatternTest.java
Patch:
@@ -28,7 +28,7 @@ public static void beforeClass() throws IOException, InterruptedException {
     @AfterClass
     public static void afterClass() throws IOException, InterruptedException {
         if (!RedissonRuntimeEnvironment.isTravis) {
-            RedisRunner.startDefaultRedisServerInstance();
+            RedisRunner.shutDownDefaultRedisServerInstance();
         }
     }
 

File: src/test/java/org/redisson/RedissonTopicTest.java
Patch:
@@ -28,7 +28,7 @@ public static void beforeClass() throws IOException, InterruptedException {
     @AfterClass
     public static void afterClass() throws IOException, InterruptedException {
         if (!RedissonRuntimeEnvironment.isTravis) {
-            RedisRunner.startDefaultRedisServerInstance();
+            RedisRunner.shutDownDefaultRedisServerInstance();
         }
     }
 

File: src/test/java/org/redisson/RedissonTwoLockedThread.java
Patch:
@@ -42,7 +42,7 @@ public static void beforeClass() throws IOException, InterruptedException {
     @AfterClass
     public static void afterClass() throws IOException, InterruptedException {
         if (!RedissonRuntimeEnvironment.isTravis) {
-            RedisRunner.startDefaultRedisServerInstance();
+            RedisRunner.shutDownDefaultRedisServerInstance();
         }
     }
 

File: src/test/java/org/redisson/BaseTest.java
Patch:
@@ -22,7 +22,7 @@ public static void beforeClass() throws IOException, InterruptedException {
     @AfterClass
     public static void afterClass() throws IOException, InterruptedException {
         if (!RedissonRuntimeEnvironment.isTravis) {
-            RedisRunner.startDefaultRedisServerInstance();
+            RedisRunner.shutDownDefaultRedisServerInstance();
             defaultRedisson.shutdown();
         }
     }

File: src/main/java/org/redisson/RedissonList.java
Patch:
@@ -568,12 +568,12 @@ public int hashCode() {
 
     @Override
     public Future<Integer> addAfterAsync(V elementToFind, V element) {
-        return commandExecutor.writeAsync(getName(), codec, RedisCommands.LINSERT, getName(), "AFTER", elementToFind, element);
+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.LINSERT_INT, getName(), "AFTER", elementToFind, element);
     }
 
     @Override
     public Future<Integer> addBeforeAsync(V elementToFind, V element) {
-        return commandExecutor.writeAsync(getName(), codec, RedisCommands.LINSERT, getName(), "BEFORE", elementToFind, element);
+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.LINSERT_INT, getName(), "BEFORE", elementToFind, element);
     }
 
     @Override

File: src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -143,7 +143,8 @@ public interface RedisCommands {
     RedisCommand<Boolean> LREM_SINGLE = new RedisCommand<Boolean>("LREM", new BooleanReplayConvertor(), 3);
     RedisStrictCommand<Long> LREM = new RedisStrictCommand<Long>("LREM", 3);
     RedisCommand<Object> LINDEX = new RedisCommand<Object>("LINDEX");
-    RedisCommand<Integer> LINSERT = new RedisCommand<Integer>("LINSERT", new IntegerReplayConvertor(), 3, ValueType.OBJECTS);
+    RedisCommand<Object> LINSERT = new RedisCommand<Object>("LINSERT", 3, ValueType.OBJECTS);
+    RedisCommand<Integer> LINSERT_INT = new RedisCommand<Integer>("LINSERT", new IntegerReplayConvertor(), 3, ValueType.OBJECTS);
     RedisStrictCommand<Integer> LLEN_INT = new RedisStrictCommand<Integer>("LLEN", new IntegerReplayConvertor());
     RedisStrictCommand<Long> LLEN = new RedisStrictCommand<Long>("LLEN");
     RedisStrictCommand<Void> LTRIM = new RedisStrictCommand<Void>("LTRIM", new VoidReplayConvertor());

File: src/main/java/org/redisson/RedissonList.java
Patch:
@@ -568,12 +568,12 @@ public int hashCode() {
 
     @Override
     public Future<Integer> addAfterAsync(V elementToFind, V element) {
-        return commandExecutor.writeAsync(getName(), codec, RedisCommands.LINSERT, getName(), "AFTER", elementToFind, element);
+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.LINSERT_INT, getName(), "AFTER", elementToFind, element);
     }
 
     @Override
     public Future<Integer> addBeforeAsync(V elementToFind, V element) {
-        return commandExecutor.writeAsync(getName(), codec, RedisCommands.LINSERT, getName(), "BEFORE", elementToFind, element);
+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.LINSERT_INT, getName(), "BEFORE", elementToFind, element);
     }
 
     @Override

File: src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -143,7 +143,8 @@ public interface RedisCommands {
     RedisCommand<Boolean> LREM_SINGLE = new RedisCommand<Boolean>("LREM", new BooleanReplayConvertor(), 3);
     RedisStrictCommand<Long> LREM = new RedisStrictCommand<Long>("LREM", 3);
     RedisCommand<Object> LINDEX = new RedisCommand<Object>("LINDEX");
-    RedisCommand<Integer> LINSERT = new RedisCommand<Integer>("LINSERT", new IntegerReplayConvertor(), 3, ValueType.OBJECTS);
+    RedisCommand<Object> LINSERT = new RedisCommand<Object>("LINSERT", 3, ValueType.OBJECTS);
+    RedisCommand<Integer> LINSERT_INT = new RedisCommand<Integer>("LINSERT", new IntegerReplayConvertor(), 3, ValueType.OBJECTS);
     RedisStrictCommand<Integer> LLEN_INT = new RedisStrictCommand<Integer>("LLEN", new IntegerReplayConvertor());
     RedisStrictCommand<Long> LLEN = new RedisStrictCommand<Long>("LLEN");
     RedisStrictCommand<Void> LTRIM = new RedisStrictCommand<Void>("LTRIM", new VoidReplayConvertor());

File: src/main/java/org/redisson/RedissonList.java
Patch:
@@ -568,12 +568,12 @@ public int hashCode() {
 
     @Override
     public Future<Integer> addAfterAsync(V elementToFind, V element) {
-        return commandExecutor.writeAsync(getName(), codec, RedisCommands.LINSERT, getName(), "AFTER", elementToFind, element);
+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.LINSERT_INT, getName(), "AFTER", elementToFind, element);
     }
 
     @Override
     public Future<Integer> addBeforeAsync(V elementToFind, V element) {
-        return commandExecutor.writeAsync(getName(), codec, RedisCommands.LINSERT, getName(), "BEFORE", elementToFind, element);
+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.LINSERT_INT, getName(), "BEFORE", elementToFind, element);
     }
 
     @Override

File: src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -143,7 +143,8 @@ public interface RedisCommands {
     RedisCommand<Boolean> LREM_SINGLE = new RedisCommand<Boolean>("LREM", new BooleanReplayConvertor(), 3);
     RedisStrictCommand<Long> LREM = new RedisStrictCommand<Long>("LREM", 3);
     RedisCommand<Object> LINDEX = new RedisCommand<Object>("LINDEX");
-    RedisCommand<Integer> LINSERT = new RedisCommand<Integer>("LINSERT", new IntegerReplayConvertor(), 3, ValueType.OBJECTS);
+    RedisCommand<Object> LINSERT = new RedisCommand<Object>("LINSERT", 3, ValueType.OBJECTS);
+    RedisCommand<Integer> LINSERT_INT = new RedisCommand<Integer>("LINSERT", new IntegerReplayConvertor(), 3, ValueType.OBJECTS);
     RedisStrictCommand<Integer> LLEN_INT = new RedisStrictCommand<Integer>("LLEN", new IntegerReplayConvertor());
     RedisStrictCommand<Long> LLEN = new RedisStrictCommand<Long>("LLEN");
     RedisStrictCommand<Void> LTRIM = new RedisStrictCommand<Void>("LTRIM", new VoidReplayConvertor());

File: src/main/java/org/redisson/RedissonExpirable.java
Patch:
@@ -58,12 +58,12 @@ public Future<Boolean> expireAtAsync(long timestamp) {
 
     @Override
     public boolean expireAt(Date timestamp) {
-        return expireAt(timestamp.getTime() / 1000);
+        return expireAt(timestamp.getTime());
     }
 
     @Override
     public Future<Boolean> expireAtAsync(Date timestamp) {
-        return expireAtAsync(timestamp.getTime() / 1000);
+        return expireAtAsync(timestamp.getTime());
     }
 
     @Override

File: src/main/java/org/redisson/client/protocol/decoder/KeyValueObjectDecoder.java
Patch:
@@ -27,7 +27,7 @@ public class KeyValueObjectDecoder implements MultiDecoder<Object> {
     @Override
     public Object decode(ByteBuf buf, State state) {
         String status = buf.toString(CharsetUtil.UTF_8);
-        buf.skipBytes(2);
+        buf.skipBytes(1);
         return status;
     }
 

File: src/main/java/org/redisson/client/protocol/decoder/KeyValueObjectDecoder.java
Patch:
@@ -27,7 +27,7 @@ public class KeyValueObjectDecoder implements MultiDecoder<Object> {
     @Override
     public Object decode(ByteBuf buf, State state) {
         String status = buf.toString(CharsetUtil.UTF_8);
-        buf.skipBytes(2);
+        buf.skipBytes(1);
         return status;
     }
 

File: src/main/java/org/redisson/client/protocol/decoder/KeyValueObjectDecoder.java
Patch:
@@ -27,7 +27,7 @@ public class KeyValueObjectDecoder implements MultiDecoder<Object> {
     @Override
     public Object decode(ByteBuf buf, State state) {
         String status = buf.toString(CharsetUtil.UTF_8);
-        buf.skipBytes(2);
+        buf.skipBytes(1);
         return status;
     }
 

File: src/main/java/org/redisson/RedissonScoredSortedSet.java
Patch:
@@ -353,7 +353,7 @@ public Future<Boolean> retainAllAsync(Collection<?> c) {
         return commandExecutor.evalWriteAsync(getName(), codec, RedisCommands.EVAL_BOOLEAN,
                 "redis.call('zadd', KEYS[2], unpack(ARGV)); "
                  + "local prevSize = redis.call('zcard', KEYS[1]); "
-                 + "local size = redis.call('zinterstore', KEYS[1], #ARGV/2, KEYS[1], KEYS[2], 'aggregate', 'sum');"
+                 + "local size = redis.call('zinterstore', KEYS[1], 2, KEYS[1], KEYS[2], 'aggregate', 'sum');"
                  + "redis.call('del', KEYS[2]); "
                  + "return size ~= prevSize and 1 or 0; ",
              Arrays.<Object>asList(getName(), "redisson_temp__{" + getName() + "}"), params.toArray());

File: src/test/java/org/redisson/RedissonConcurrentMapTest.java
Patch:
@@ -81,8 +81,6 @@ public void test_Multi_Replace_MultiInstance() throws InterruptedException {
         }
         assertMapSize(5, name);
 
-        redisson.getKeys().flushdb();
-        redisson.shutdown();
     }
 
     @Test

File: src/main/java/org/redisson/RedissonSetCache.java
Patch:
@@ -41,8 +41,6 @@
 /**
  * <p>Set-based cache with ability to set TTL for each entry via
  * {@link #put(Object, Object, long, TimeUnit)} method.
- * And therefore has an complex lua-scripts inside.
- * Uses map(value_hash, value) to tie with sorted set which contains expiration record for every value with TTL.
  * </p>
  *
  * <p>Current Redis implementation doesn't have set entry eviction functionality.

File: src/main/java/org/redisson/RedissonSet.java
Patch:
@@ -229,7 +229,7 @@ public Future<Boolean> removeAllAsync(Collection<?> c) {
         args.add(getName());
         args.addAll(c);
         
-        return commandExecutor.writeAsync(getName(), codec, RedisCommands.SREM_SINGLE, c.toArray());
+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.SREM_SINGLE, args.toArray());
     }
 
     @Override

File: src/test/java/org/redisson/RedissonSemaphoreTest.java
Patch:
@@ -234,7 +234,7 @@ public void testConcurrency_MultiInstance_10_permits() throws InterruptedExcepti
 
         final AtomicInteger checkPermits = new AtomicInteger(s.availablePermits());
         final CyclicBarrier barrier = new CyclicBarrier(s.availablePermits());
-        testMultiInstanceConcurrency(iterations, r -> {
+        testMultiInstanceConcurrencySequentiallyLaunched(iterations, r -> {
             RSemaphore s1 = r.getSemaphore("test");
             try {
                 s1.acquire();

File: src/main/java/org/redisson/RedissonSet.java
Patch:
@@ -229,7 +229,7 @@ public Future<Boolean> removeAllAsync(Collection<?> c) {
         args.add(getName());
         args.addAll(c);
         
-        return commandExecutor.writeAsync(getName(), codec, RedisCommands.SREM_SINGLE, c.toArray());
+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.SREM_SINGLE, args.toArray());
     }
 
     @Override

File: src/main/java/org/redisson/RedissonSet.java
Patch:
@@ -229,7 +229,7 @@ public Future<Boolean> removeAllAsync(Collection<?> c) {
         args.add(getName());
         args.addAll(c);
         
-        return commandExecutor.writeAsync(getName(), codec, RedisCommands.SREM_SINGLE, c.toArray());
+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.SREM_SINGLE, args.toArray());
     }
 
     @Override

File: src/main/java/org/redisson/RedissonSet.java
Patch:
@@ -180,7 +180,7 @@ public Future<Boolean> containsAllAsync(Collection<?> c) {
                         + "local size = redis.call('sdiff', KEYS[2], KEYS[1]);"
                         + "redis.call('del', KEYS[2]); "
                         + "return #size == 0 and 1 or 0; ",
-                       Arrays.asList(getName(), "redisson_temp__{" + getName() + "}"), c.toArray());
+                       Arrays.<Object>asList(getName(), "redisson_temp__{" + getName() + "}"), c.toArray());
     }
 
     @Override
@@ -220,7 +220,7 @@ public Future<Boolean> retainAllAsync(Collection<?> c) {
                 + "local size = redis.call('sinterstore', KEYS[1], KEYS[1], KEYS[2]);"
                 + "redis.call('del', KEYS[2]); "
                 + "return size ~= prevSize and 1 or 0; ",
-            Arrays.asList(getName(), "redisson_temp__{" + getName() + "}"), c.toArray());
+            Arrays.<Object>asList(getName(), "redisson_temp__{" + getName() + "}"), c.toArray());
     }
 
     @Override

File: src/main/java/org/redisson/RedissonScoredSortedSet.java
Patch:
@@ -228,7 +228,7 @@ public Future<Double> getScoreAsync(V o) {
     }
 
     @Override
-    public int rank(V o) {
+    public Integer rank(V o) {
         return get(rankAsync(o));
     }
 
@@ -448,7 +448,7 @@ public Future<Integer> revRankAsync(V o) {
     }
 
     @Override
-    public int revRank(V o) {
+    public Integer revRank(V o) {
         return get(revRankAsync(o));
     }
 

File: src/main/java/org/redisson/core/RLexSortedSet.java
Patch:
@@ -116,7 +116,7 @@ public interface RLexSortedSet extends RLexSortedSetAsync, Set<String>, RExpirab
     @Deprecated
     int lexCount(String fromElement, boolean fromInclusive, String toElement, boolean toInclusive);
 
-    int rank(String o);
+    Integer rank(String o);
 
     Collection<String> range(int startIndex, int endIndex);
 

File: src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -315,7 +315,7 @@ public void operationComplete(Future<RedisConnection> future) throws Exception {
         });
     }
 
-    private void updateClusterState(final ClusterServersConfig cfg, final RedisConnection connection, Iterator<URI> iterator) {
+    private void updateClusterState(final ClusterServersConfig cfg, final RedisConnection connection, final Iterator<URI> iterator) {
         Future<String> future = connection.asyncWithTimeout(null, RedisCommands.CLUSTER_NODES);
         future.addListener(new FutureListener<String>() {
             @Override

File: src/main/java/org/redisson/client/RedisConnection.java
Patch:
@@ -222,7 +222,7 @@ public ChannelFuture closeAsync() {
 
     @Override
     public String toString() {
-        return getClass().getSimpleName() + " [redisClient=" + redisClient + ", channel=" + channel + "]";
+        return getClass().getSimpleName() + "@" + System.identityHashCode(this) + " [redisClient=" + redisClient + ", channel=" + channel + "]";
     }
 
     public Future<?> getAcquireFuture() {

File: src/main/java/org/redisson/connection/balancer/LoadBalancerManager.java
Patch:
@@ -36,6 +36,8 @@ public interface LoadBalancerManager {
 
     boolean unfreeze(String host, int port, FreezeReason freezeReason);
 
+    ClientConnectionsEntry freeze(ClientConnectionsEntry connectionEntry, FreezeReason freezeReason);
+    
     ClientConnectionsEntry freeze(String host, int port, FreezeReason freezeReason);
 
     Future<Void> add(ClientConnectionsEntry entry);

File: src/main/java/org/redisson/RedissonGeo.java
Patch:
@@ -62,7 +62,7 @@ public RedissonGeo(Codec codec, CommandAsyncExecutor connectionManager, String n
 
     @Override
     public Future<Long> addAsync(double longitude, double latitude, V member) {
-        return commandExecutor.writeAsync(getName(), RedisCommands.GEOADD, getName(), convert(longitude), convert(latitude), member);
+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.GEOADD, getName(), convert(longitude), convert(latitude), member);
     }
 
     private String convert(double longitude) {

File: src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -179,6 +179,7 @@ public interface RedisCommands {
     RedisCommand<Set<Object>> EVAL_SET = new RedisCommand<Set<Object>>("EVAL", new ObjectSetReplayDecoder());
     RedisCommand<Object> EVAL_OBJECT = new RedisCommand<Object>("EVAL");
     RedisCommand<Object> EVAL_MAP_VALUE = new RedisCommand<Object>("EVAL", ValueType.MAP_VALUE);
+    RedisCommand<Set<Entry<Object, Object>>> EVAL_MAP_ENTRY = new RedisCommand<Set<Entry<Object, Object>>>("EVAL", new ObjectMapEntryReplayDecoder(), ValueType.MAP);
     RedisCommand<List<Object>> EVAL_MAP_VALUE_LIST = new RedisCommand<List<Object>>("EVAL", new ObjectListReplayDecoder<Object>(), ValueType.MAP_VALUE);
 
     RedisStrictCommand<Long> INCR = new RedisStrictCommand<Long>("INCR");

File: src/main/java/org/redisson/client/RedisRedirectException.java
Patch:
@@ -18,7 +18,7 @@
 import java.net.InetSocketAddress;
 import java.net.URI;
 
-class RedisRedirectException extends RedisException {
+public class RedisRedirectException extends RedisException {
 
     private static final long serialVersionUID = 181505625075250011L;
 

File: src/main/java/org/redisson/reactive/RedissonScoredSortedSetReactive.java
Patch:
@@ -167,7 +167,7 @@ public Publisher<Boolean> retainAll(Collection<?> c) {
         return commandExecutor.evalWriteReactive(getName(), codec, new RedisCommand<Boolean>("EVAL", new BooleanReplayConvertor(), 4, ValueType.OBJECTS),
                     "local changed = 0 " +
                     "local s = redis.call('zrange', KEYS[1], 0, -1) "
-                       + "local i = 0 "
+                       + "local i = 1 "
                        + "while i <= table.getn(s) do "
                             + "local element = s[i] "
                             + "local isInAgrs = false "

File: src/main/java/org/redisson/reactive/RedissonScoredSortedSetReactive.java
Patch:
@@ -167,7 +167,7 @@ public Publisher<Boolean> retainAll(Collection<?> c) {
         return commandExecutor.evalWriteReactive(getName(), codec, new RedisCommand<Boolean>("EVAL", new BooleanReplayConvertor(), 4, ValueType.OBJECTS),
                     "local changed = 0 " +
                     "local s = redis.call('zrange', KEYS[1], 0, -1) "
-                       + "local i = 0 "
+                       + "local i = 1 "
                        + "while i <= table.getn(s) do "
                             + "local element = s[i] "
                             + "local isInAgrs = false "

File: src/main/java/org/redisson/reactive/RedissonScoredSortedSetReactive.java
Patch:
@@ -167,7 +167,7 @@ public Publisher<Boolean> retainAll(Collection<?> c) {
         return commandExecutor.evalWriteReactive(getName(), codec, new RedisCommand<Boolean>("EVAL", new BooleanReplayConvertor(), 4, ValueType.OBJECTS),
                     "local changed = 0 " +
                     "local s = redis.call('zrange', KEYS[1], 0, -1) "
-                       + "local i = 0 "
+                       + "local i = 1 "
                        + "while i <= table.getn(s) do "
                             + "local element = s[i] "
                             + "local isInAgrs = false "

File: src/main/java/org/redisson/core/RedissonMultiLock.java
Patch:
@@ -122,8 +122,7 @@ public void operationComplete(Future<Void> future) throws Exception {
                                 if (tryLockRequestsAmount.decrementAndGet() == 0) {
                                     if (failed.get() != null) {
                                         promise.setFailure(failed.get());
-                                    }
-                                    if (lockedLockHolder.get() != null) {
+                                    } else if (lockedLockHolder.get() != null) {
                                         final RedissonLock lockedLock = (RedissonLock) lockedLockHolder.get();
                                         lockedLock.lockAsync(leaseTime, unit, currentThreadId).addListener(new FutureListener<Void>() {
                                             @Override

File: src/main/java/org/redisson/RedissonListMultimapCache.java
Patch:
@@ -131,7 +131,7 @@ public Future<Boolean> containsEntryAsync(Object key, Object value) {
                   + "end; "
                   + "if expireDate > tonumber(ARGV[1]) then " +
                       "local items = redis.call('lrange', KEYS[1], 0, -1); " +
-                      "for i=0, #items do " +
+                      "for i = 1, #items do " +
                           "if items[i] == ARGV[3] then " +
                               "return 1; " +
                           "end; " +

File: src/main/java/org/redisson/RedissonSubList.java
Patch:
@@ -179,7 +179,7 @@ private Future<Boolean> removeAllAsync(Collection<?> c, int count) {
                 "local items = redis.call('lrange', KEYS[1], fromIndex, toIndex); " +
 
                 "for i=1, #items do " +
-                    "for j = 0, #ARGV, 1 do " +
+                    "for j = 1, #ARGV, 1 do " +
                         "if items[i] == ARGV[j] then " +
                             "redis.call('lrem', KEYS[1], count, ARGV[i]); " +
                             "v = 1; " +

File: src/main/java/org/redisson/reactive/RedissonSetCacheReactive.java
Patch:
@@ -224,8 +224,8 @@ public Publisher<Boolean> remove(Object o) {
     public Publisher<Boolean> containsAll(Collection<?> c) {
         return commandExecutor.evalReadReactive(getName(), codec, RedisCommands.EVAL_BOOLEAN_WITH_VALUES,
                 "local s = redis.call('hvals', KEYS[1]);" +
-                        "for i = 0, table.getn(s), 1 do " +
-                            "for j = 0, table.getn(ARGV), 1 do "
+                        "for i = 1, table.getn(s), 1 do " +
+                            "for j = 1, table.getn(ARGV), 1 do "
                             + "if ARGV[j] == s[i] then "
                                 + "table.remove(ARGV, j) "
                             + "end "

File: src/main/java/org/redisson/RedissonBloomFilter.java
Patch:
@@ -200,7 +200,7 @@ public int count() {
 
     @Override
     public Future<Boolean> deleteAsync() {
-        return commandExecutor.writeAsync(getName(), RedisCommands.DEL_BOOL, getName(), getConfigName());
+        return commandExecutor.writeAsync(getName(), RedisCommands.DEL_OBJECTS, getName(), getConfigName());
     }
 
     private void readConfig() {

File: src/main/java/org/redisson/RedissonCountDownLatch.java
Patch:
@@ -53,7 +53,7 @@ protected RedissonCountDownLatch(CommandAsyncExecutor commandExecutor, String na
     public void await() throws InterruptedException {
         Future<RedissonCountDownLatchEntry> promise = subscribe();
         try {
-            promise.await();
+            get(promise);
 
             while (getCount() > 0) {
                 // waiting for open state
@@ -71,7 +71,7 @@ public void await() throws InterruptedException {
     public boolean await(long time, TimeUnit unit) throws InterruptedException {
         Future<RedissonCountDownLatchEntry> promise = subscribe();
         try {
-            if (!promise.await(time, unit)) {
+            if (!await(promise, time, unit)) {
                 return false;
             }
 

File: src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -110,7 +110,7 @@ public void lockInterruptibly(long leaseTime, TimeUnit unit) throws InterruptedE
         }
 
         Future<RedissonLockEntry> future = subscribe();
-        future.sync();
+        get(future);
 
         try {
             while (true) {
@@ -229,7 +229,7 @@ public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws Inte
         }
 
         Future<RedissonLockEntry> future = subscribe();
-        if (!future.await(time, TimeUnit.MILLISECONDS)) {
+        if (!await(future, time, TimeUnit.MILLISECONDS)) {
             future.addListener(new FutureListener<RedissonLockEntry>() {
                 @Override
                 public void operationComplete(Future<RedissonLockEntry> future) throws Exception {

File: src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -107,7 +107,7 @@ public boolean containsValue(Object value) {
     public Future<Boolean> containsValueAsync(Object value) {
         return commandExecutor.evalReadAsync(getName(), codec, new RedisCommand<Boolean>("EVAL", new BooleanReplayConvertor(), 4),
                 "local s = redis.call('hvals', KEYS[1]);" +
-                        "for i = 0, table.getn(s), 1 do "
+                        "for i = 1, #s, 1 do "
                             + "if ARGV[1] == s[i] then "
                                 + "return 1 "
                             + "end "
@@ -130,7 +130,7 @@ public Future<Map<K, V>> getAllAsync(Set<K> keys) {
         List<Object> args = new ArrayList<Object>(keys.size() + 1);
         args.add(getName());
         args.addAll(keys);
-        return commandExecutor.readAsync(getName(), codec, new RedisCommand<Map<Object, Object>>("HMGET", new MapGetAllDecoder(args), 2, ValueType.MAP_KEY, ValueType.MAP_VALUE), args.toArray());
+        return commandExecutor.readAsync(getName(), codec, new RedisCommand<Map<Object, Object>>("HMGET", new MapGetAllDecoder(args, 1), 2, ValueType.MAP_KEY, ValueType.MAP_VALUE), args.toArray());
     }
 
     @Override

File: src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -162,11 +162,11 @@ public Future<Map<K, V>> getAllAsync(Set<K> keys) {
             return newSucceededFuture(Collections.<K, V>emptyMap());
         }
 
-        List<Object> args = new ArrayList<Object>(keys.size() + 2);
+        List<Object> args = new ArrayList<Object>(keys.size() + 1);
         args.add(System.currentTimeMillis());
         args.addAll(keys);
 
-        return commandExecutor.evalWriteAsync(getName(), codec, new RedisCommand<Map<Object, Object>>("EVAL", new MapGetAllDecoder(args), 7, ValueType.MAP_KEY, ValueType.MAP_VALUE),
+        return commandExecutor.evalWriteAsync(getName(), codec, new RedisCommand<Map<Object, Object>>("EVAL", new MapGetAllDecoder(args, 1), 7, ValueType.MAP_KEY, ValueType.MAP_VALUE),
                         "local expireHead = redis.call('zrange', KEYS[2], 0, 0, 'withscores');" +
                         "local expireIdleHead = redis.call('zrange', KEYS[3], 0, 0, 'withscores');" +
                         "local maxDate = table.remove(ARGV, 1); " // index is the first parameter
@@ -655,7 +655,7 @@ public Future<Void> putAllAsync(Map<? extends K, ? extends V> map) {
 
     @Override
     public Future<Boolean> deleteAsync() {
-        return commandExecutor.writeAsync(getName(), RedisCommands.DEL_BOOL, getName(), getTimeoutSetName());
+        return commandExecutor.writeAsync(getName(), RedisCommands.DEL_OBJECTS, getName(), getTimeoutSetName());
     }
 
     @Override

File: src/main/java/org/redisson/RedissonMapIterator.java
Patch:
@@ -29,7 +29,7 @@ public RedissonMapIterator(RedissonMap<K, V> map) {
     }
 
     protected MapScanResult<ScanObjectEntry, ScanObjectEntry> iterator() {
-        return map.scanIterator(client, iterPos);
+        return map.scanIterator(client, nextIterPos);
     }
 
     protected void removeKey() {

File: src/main/java/org/redisson/RedissonMultiMapKeysIterator.java
Patch:
@@ -29,7 +29,7 @@ public RedissonMultiMapKeysIterator(RedissonMultimap<K, V> map) {
     }
 
     protected MapScanResult<ScanObjectEntry, ScanObjectEntry> iterator() {
-        return map.scanIterator(client, iterPos);
+        return map.scanIterator(client, nextIterPos);
     }
 
     protected void removeKey() {

File: src/main/java/org/redisson/RedissonSemaphore.java
Patch:
@@ -70,7 +70,8 @@ public void acquire(int permits) throws InterruptedException {
             return;
         }
 
-        Future<RedissonLockEntry> future = subscribe().sync();
+        Future<RedissonLockEntry> future = subscribe();
+        get(future);
         try {
             while (true) {
                 if (tryAcquire(permits)) {
@@ -113,7 +114,7 @@ public boolean tryAcquire(int permits, long waitTime, TimeUnit unit) throws Inte
 
         long time = unit.toMillis(waitTime);
         Future<RedissonLockEntry> future = subscribe();
-        if (!future.await(time, TimeUnit.MILLISECONDS)) {
+        if (!await(future, time, TimeUnit.MILLISECONDS)) {
             return false;
         }
 

File: src/main/java/org/redisson/client/RedisClient.java
Patch:
@@ -38,6 +38,7 @@
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GlobalEventExecutor;
+import io.netty.util.concurrent.ImmediateEventExecutor;
 import io.netty.util.concurrent.Promise;
 
 public class RedisClient {
@@ -95,7 +96,7 @@ public RedisConnection connect() {
     }
 
     public Future<RedisConnection> connectAsync() {
-        final Promise<RedisConnection> f = bootstrap.group().next().newPromise();
+        final Promise<RedisConnection> f = ImmediateEventExecutor.INSTANCE.newPromise();
         ChannelFuture channelFuture = bootstrap.connect();
         channelFuture.addListener(new ChannelFutureListener() {
             @Override
@@ -122,7 +123,7 @@ public RedisPubSubConnection connectPubSub() {
     }
 
     public Future<RedisPubSubConnection> connectPubSubAsync() {
-        final Promise<RedisPubSubConnection> f = bootstrap.group().next().newPromise();
+        final Promise<RedisPubSubConnection> f = ImmediateEventExecutor.INSTANCE.newPromise();
         ChannelFuture channelFuture = bootstrap.connect();
         channelFuture.addListener(new ChannelFutureListener() {
             @Override

File: src/main/java/org/redisson/client/codec/ScoredCodec.java
Patch:
@@ -19,7 +19,7 @@
 
 public class ScoredCodec extends StringCodec {
 
-    public final Codec delegate;
+    private final Codec delegate;
 
     public ScoredCodec(Codec delegate) {
         super();

File: src/main/java/org/redisson/client/handler/CommandsQueue.java
Patch:
@@ -23,10 +23,10 @@
 import org.redisson.client.protocol.QueueCommandHolder;
 
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelOutboundHandlerAdapter;
 import io.netty.channel.ChannelPromise;
 import io.netty.util.AttributeKey;
 import io.netty.util.internal.PlatformDependent;
@@ -37,7 +37,7 @@
  * @author Nikita Koksharov
  *
  */
-public class CommandsQueue extends ChannelDuplexHandler {
+public class CommandsQueue extends ChannelOutboundHandlerAdapter {
 
     public static final AttributeKey<QueueCommand> CURRENT_COMMAND = AttributeKey.valueOf("promise");
 
@@ -82,7 +82,7 @@ private void sendData(Channel ch) {
             if (!pubSubOps.isEmpty()) {
                 for (CommandData<Object, Object> cd : pubSubOps) {
                     for (Object channel : cd.getParams()) {
-                        ch.pipeline().get(CommandDecoder.class).addChannel(channel.toString(), cd);
+                        ch.pipeline().get(CommandDecoder.class).addPubSubCommand(channel.toString(), cd);
                     }
                 }
             } else {

File: src/main/java/org/redisson/client/handler/State.java
Patch:
@@ -29,11 +29,12 @@ public State() {
         super();
     }
 
-    public void setSizeOnce(long size) {
+    public boolean trySetSize(long size) {
         if (this.size != 0) {
-            return;
+            return false;
         }
         this.size = size;
+        return true;
     }
     public long getSize() {
         return size;

File: src/main/java/org/redisson/client/protocol/QueueCommand.java
Patch:
@@ -23,6 +23,9 @@
 public interface QueueCommand {
 
     Set<String> PUBSUB_COMMANDS = new HashSet<String>(Arrays.asList("PSUBSCRIBE", "SUBSCRIBE", "PUNSUBSCRIBE", "UNSUBSCRIBE"));
+    
+    Set<String> TIMEOUTLESS_COMMANDS = new HashSet<String>(Arrays.asList(RedisCommands.BLPOP_VALUE.getName(),
+            RedisCommands.BRPOP_VALUE.getName(), RedisCommands.BRPOPLPUSH.getName()));
 
     List<CommandData<Object, Object>> getPubSubOperations();
 

File: src/main/java/org/redisson/client/protocol/RedisCommand.java
Patch:
@@ -24,7 +24,7 @@
 
 public class RedisCommand<R> {
 
-    public enum ValueType {OBJECT, OBJECTS, MAP_VALUE, MAP_KEY, MAP, BINARY}
+    public enum ValueType {OBJECT, OBJECTS, MAP_VALUE, MAP_KEY, MAP, BINARY, STRING}
 
     private ValueType outParamType = ValueType.OBJECT;
     private List<ValueType> inParamType = Arrays.asList(ValueType.OBJECT);

File: src/main/java/org/redisson/client/protocol/convertor/DoubleReplayConvertor.java
Patch:
@@ -19,7 +19,7 @@ public class DoubleReplayConvertor extends SingleConvertor<Double> {
 
     @Override
     public Double convert(Object obj) {
-        if (obj == null) {
+        if (obj == null || obj.toString().isEmpty()) {
             return null;
         }
         return Double.valueOf(obj.toString());

File: src/main/java/org/redisson/command/CommandAsyncExecutor.java
Patch:
@@ -18,6 +18,7 @@
 import java.net.InetSocketAddress;
 import java.util.Collection;
 import java.util.List;
+import java.util.concurrent.TimeUnit;
 
 import org.redisson.SlotCallback;
 import org.redisson.client.RedisException;
@@ -38,6 +39,8 @@ public interface CommandAsyncExecutor {
 
     <V> RedisException convertException(Future<V> future);
 
+    boolean await(Future<?> future, long timeout, TimeUnit timeoutUnit) throws InterruptedException;
+    
     <V> V get(Future<V> future);
 
     <T, R> Future<R> writeAsync(Integer slot, Codec codec, RedisCommand<T> command, Object ... params);

File: src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -27,7 +27,6 @@
 import org.redisson.client.codec.Codec;
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.cluster.ClusterSlotRange;
-import org.redisson.connection.ClientConnectionsEntry.FreezeReason;
 import org.redisson.core.NodeType;
 import org.redisson.misc.InfinitySemaphoreLatch;
 
@@ -62,8 +61,6 @@ public interface ConnectionManager {
 
     <R> Future<R> newFailedFuture(Throwable cause);
 
-    void slaveDown(MasterSlaveEntry entry, String host, int port, FreezeReason freezeReason);
-
     Collection<RedisClientEntry> getClients();
 
     void shutdownAsync(RedisClient client);
@@ -107,5 +104,7 @@ public interface ConnectionManager {
     Timeout newTimeout(TimerTask task, long delay, TimeUnit unit);
 
     InfinitySemaphoreLatch getShutdownLatch();
+    
+    Future<Boolean> getShutdownPromise();
 
 }

File: src/main/java/org/redisson/connection/balancer/LoadBalancerManager.java
Patch:
@@ -16,7 +16,6 @@
 package org.redisson.connection.balancer;
 
 import java.net.InetSocketAddress;
-import java.util.Collection;
 
 import org.redisson.client.RedisConnection;
 import org.redisson.client.RedisPubSubConnection;
@@ -37,7 +36,7 @@ public interface LoadBalancerManager {
 
     boolean unfreeze(String host, int port, FreezeReason freezeReason);
 
-    Collection<RedisPubSubConnection> freeze(String host, int port, FreezeReason freezeReason);
+    ClientConnectionsEntry freeze(String host, int port, FreezeReason freezeReason);
 
     Future<Void> add(ClientConnectionsEntry entry);
 

File: src/main/java/org/redisson/connection/pool/ConnectionPool.java
Patch:
@@ -153,7 +153,7 @@ public Future<T> get() {
             }
         }
 
-        StringBuilder errorMsg = new StringBuilder("Publish/Subscribe connection pool exhausted! All connections are busy. Try to increase Publish/Subscribe connection pool size.");
+        StringBuilder errorMsg = new StringBuilder("Connection pool exhausted! All connections are busy. Increase connection pool size.");
 //        if (!freezed.isEmpty()) {
 //            errorMsg.append(" Disconnected hosts: " + freezed);
 //        }
@@ -277,7 +277,7 @@ private Future<T> promiseFailure(ClientConnectionsEntry entry, T conn) {
 
     private void checkForReconnect(ClientConnectionsEntry entry) {
         if (entry.getNodeType() == NodeType.SLAVE) {
-            connectionManager.slaveDown(masterSlaveEntry, entry.getClient().getAddr().getHostName(),
+            masterSlaveEntry.slaveDown(entry.getClient().getAddr().getHostName(),
                     entry.getClient().getAddr().getPort(), FreezeReason.RECONNECT);
             log.warn("slave {} disconnected due to failedAttempts={} limit reached", entry.getClient().getAddr(), config.getFailedAttempts());
             scheduleCheck(entry);

File: src/main/java/org/redisson/reactive/RedissonMapCacheReactive.java
Patch:
@@ -361,7 +361,7 @@ Publisher<MapScanResult<ScanObjectEntry, ScanObjectEntry>> scanIteratorReactive(
 
     @Override
     public Publisher<Boolean> delete() {
-        return commandExecutor.writeReactive(getName(), RedisCommands.DEL_BOOL, getName(), getTimeoutSetName());
+        return commandExecutor.writeReactive(getName(), RedisCommands.DEL_OBJECTS, getName(), getTimeoutSetName());
     }
 
     @Override

File: src/main/java/org/redisson/reactive/RedissonSetCacheReactive.java
Patch:
@@ -305,7 +305,7 @@ public Publisher<Boolean> removeAll(Collection<?> c) {
 
     @Override
     public Publisher<Boolean> delete() {
-        return commandExecutor.writeReactive(getName(), RedisCommands.DEL_BOOL, getName(), getTimeoutSetName());
+        return commandExecutor.writeReactive(getName(), RedisCommands.DEL_OBJECTS, getName(), getTimeoutSetName());
     }
 
     @Override

File: src/test/java/org/redisson/RedissonConcurrentMapTest.java
Patch:
@@ -94,7 +94,7 @@ public void run(RedissonClient redisson) {
         }
         assertMapSize(5, name);
 
-        redisson.flushdb();
+        redisson.getKeys().flushdb();
         redisson.shutdown();
     }
 

File: src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -1,4 +1,5 @@
 /**
+ * Copyright 2014 Nikita Koksharov, Nickolay Borbit
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.

File: src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -107,7 +107,7 @@ public boolean containsValue(Object value) {
     public Future<Boolean> containsValueAsync(Object value) {
         return commandExecutor.evalReadAsync(getName(), codec, new RedisCommand<Boolean>("EVAL", new BooleanReplayConvertor(), 4),
                 "local s = redis.call('hvals', KEYS[1]);" +
-                        "for i = 0, table.getn(s), 1 do "
+                        "for i = 1, #s, 1 do "
                             + "if ARGV[1] == s[i] then "
                                 + "return 1 "
                             + "end "

File: src/main/java/org/redisson/reactive/RedissonScoredSortedSetReactive.java
Patch:
@@ -154,7 +154,7 @@ public Publisher<Boolean> containsAll(Collection<?> c) {
     public Publisher<Boolean> removeAll(Collection<?> c) {
         return commandExecutor.evalWriteReactive(getName(), codec, new RedisCommand<Boolean>("EVAL", new BooleanReplayConvertor(), 4, ValueType.OBJECTS),
                         "local v = 0 " +
-                        "for i = 0, table.getn(ARGV), 1 do "
+                        "for i = 1, table.getn(ARGV), 1 do "
                             + "if redis.call('zrem', KEYS[1], ARGV[i]) == 1 "
                             + "then v = 1 end "
                         +"end "

File: src/main/java/org/redisson/RedissonList.java
Patch:
@@ -222,7 +222,7 @@ public boolean addAll(int index, Collection<? extends V> coll) {
     public Future<Boolean> removeAllAsync(Collection<?> c) {
         return commandExecutor.evalWriteAsync(getName(), codec, RedisCommands.EVAL_BOOLEAN_WITH_VALUES,
                         "local v = 0 " +
-                        "for i = 0, table.getn(ARGV), 1 do "
+                        "for i = 1, table.getn(ARGV), 1 do "
                             + "if redis.call('lrem', KEYS[1], 0, ARGV[i]) == 1 "
                             + "then v = 1 end "
                         +"end "

File: src/main/java/org/redisson/RedissonSet.java
Patch:
@@ -229,7 +229,7 @@ public Future<Boolean> retainAllAsync(Collection<?> c) {
     public Future<Boolean> removeAllAsync(Collection<?> c) {
         return commandExecutor.evalWriteAsync(getName(), codec, RedisCommands.EVAL_BOOLEAN_WITH_VALUES,
                         "local v = 0 " +
-                        "for i = 0, table.getn(ARGV), 1 do "
+                        "for i = 1, table.getn(ARGV), 1 do "
                             + "if redis.call('srem', KEYS[1], ARGV[i]) == 1 "
                             + "then v = 1 end "
                         +"end "

File: src/main/java/org/redisson/RedissonBaseMapIterator.java
Patch:
@@ -64,7 +64,7 @@ public boolean hasNext() {
                     firstValues = convert(res.getMap());
                 } else {
                     Map<ByteBuf, ByteBuf> newValues = convert(res.getMap());
-                    if (newValues.equals(firstValues)) {
+                    if (firstValues.entrySet().containsAll(newValues.entrySet())) {
                         finished = true;
                         free(firstValues);
                         free(newValues);

File: src/test/java/org/redisson/RedisVersion.java
Patch:
@@ -17,7 +17,7 @@ public class RedisVersion implements Comparable<RedisVersion>{
     public RedisVersion(String fullVersion) {
         System.out.println("Construction Redis Version: " + fullVersion);
         this.fullVersion = fullVersion;
-        Matcher matcher = Pattern.compile("^([\\d]{0,2})\\.([\\d]{0,2})\\.([\\d]{0,2})$").matcher(fullVersion);
+        Matcher matcher = Pattern.compile("^([\\d]+)\\.([\\d]+)\\.([\\d]+)$").matcher(fullVersion);
         matcher.find();
         majorVersion = Integer.parseInt(matcher.group(1));
         minorVersion = Integer.parseInt(matcher.group(2));

File: src/main/java/org/redisson/RedissonCountDownLatch.java
Patch:
@@ -53,7 +53,7 @@ protected RedissonCountDownLatch(CommandAsyncExecutor commandExecutor, String na
     public void await() throws InterruptedException {
         Future<RedissonCountDownLatchEntry> promise = subscribe();
         try {
-            promise.await();
+            get(promise);
 
             while (getCount() > 0) {
                 // waiting for open state
@@ -71,7 +71,7 @@ public void await() throws InterruptedException {
     public boolean await(long time, TimeUnit unit) throws InterruptedException {
         Future<RedissonCountDownLatchEntry> promise = subscribe();
         try {
-            if (!promise.await(time, unit)) {
+            if (!await(promise, time, unit)) {
                 return false;
             }
 

File: src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -110,7 +110,7 @@ public void lockInterruptibly(long leaseTime, TimeUnit unit) throws InterruptedE
         }
 
         Future<RedissonLockEntry> future = subscribe();
-        future.sync();
+        get(future);
 
         try {
             while (true) {
@@ -229,7 +229,7 @@ public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws Inte
         }
 
         Future<RedissonLockEntry> future = subscribe();
-        if (!future.await(time, TimeUnit.MILLISECONDS)) {
+        if (!await(future, time, TimeUnit.MILLISECONDS)) {
             future.addListener(new FutureListener<RedissonLockEntry>() {
                 @Override
                 public void operationComplete(Future<RedissonLockEntry> future) throws Exception {

File: src/main/java/org/redisson/RedissonSemaphore.java
Patch:
@@ -70,7 +70,8 @@ public void acquire(int permits) throws InterruptedException {
             return;
         }
 
-        Future<RedissonLockEntry> future = subscribe().sync();
+        Future<RedissonLockEntry> future = subscribe();
+        get(future);
         try {
             while (true) {
                 if (tryAcquire(permits)) {
@@ -113,7 +114,7 @@ public boolean tryAcquire(int permits, long waitTime, TimeUnit unit) throws Inte
 
         long time = unit.toMillis(waitTime);
         Future<RedissonLockEntry> future = subscribe();
-        if (!future.await(time, TimeUnit.MILLISECONDS)) {
+        if (!await(future, time, TimeUnit.MILLISECONDS)) {
             return false;
         }
 

File: src/main/java/org/redisson/client/handler/CommandsQueue.java
Patch:
@@ -23,10 +23,10 @@
 import org.redisson.client.protocol.QueueCommandHolder;
 
 import io.netty.channel.Channel;
-import io.netty.channel.ChannelDuplexHandler;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelOutboundHandlerAdapter;
 import io.netty.channel.ChannelPromise;
 import io.netty.util.AttributeKey;
 import io.netty.util.internal.PlatformDependent;
@@ -37,7 +37,7 @@
  * @author Nikita Koksharov
  *
  */
-public class CommandsQueue extends ChannelDuplexHandler {
+public class CommandsQueue extends ChannelOutboundHandlerAdapter {
 
     public static final AttributeKey<QueueCommand> CURRENT_COMMAND = AttributeKey.valueOf("promise");
 

File: src/main/java/org/redisson/command/CommandAsyncExecutor.java
Patch:
@@ -18,6 +18,7 @@
 import java.net.InetSocketAddress;
 import java.util.Collection;
 import java.util.List;
+import java.util.concurrent.TimeUnit;
 
 import org.redisson.SlotCallback;
 import org.redisson.client.RedisException;
@@ -38,6 +39,8 @@ public interface CommandAsyncExecutor {
 
     <V> RedisException convertException(Future<V> future);
 
+    boolean await(Future<?> future, long timeout, TimeUnit timeoutUnit) throws InterruptedException;
+    
     <V> V get(Future<V> future);
 
     <T, R> Future<R> writeAsync(Integer slot, Codec codec, RedisCommand<T> command, Object ... params);

File: src/main/java/org/redisson/connection/pool/ConnectionPool.java
Patch:
@@ -153,7 +153,7 @@ public Future<T> get() {
             }
         }
 
-        StringBuilder errorMsg = new StringBuilder("Publish/Subscribe connection pool exhausted! All connections are busy. Try to increase Publish/Subscribe connection pool size.");
+        StringBuilder errorMsg = new StringBuilder("Connection pool exhausted! All connections are busy. Increase connection pool size.");
 //        if (!freezed.isEmpty()) {
 //            errorMsg.append(" Disconnected hosts: " + freezed);
 //        }

File: src/test/java/org/redisson/RedissonListMultimapCacheTest.java
Patch:
@@ -105,7 +105,7 @@ public void testValuesExpired() throws InterruptedException {
         Thread.sleep(1000);
         
         assertThat(multimap.get("1").size()).isZero();
-        assertThat(multimap.get("1")).contains();
+        assertThat(multimap.get("1").isEmpty()).isTrue();
         assertThat(multimap.get("1").remove("3")).isFalse();
         assertThat(multimap.get("1").contains("3")).isFalse();
         assertThat(multimap.get("1").retainAll(Arrays.asList("1"))).isFalse();

File: src/test/java/org/redisson/RedissonSetMultimapCacheTest.java
Patch:
@@ -105,7 +105,7 @@ public void testValuesExpired() throws InterruptedException {
         Thread.sleep(1500);
         
         assertThat(multimap.get("1").size()).isZero();
-        assertThat(multimap.get("1")).contains();
+        assertThat(multimap.get("1").isEmpty()).isTrue();
         assertThat(multimap.get("1").remove("3")).isFalse();
         assertThat(multimap.get("1").contains("3")).isFalse();
         assertThat(multimap.get("1").retainAll(Arrays.asList("1"))).isFalse();

File: src/test/java/org/redisson/BaseReactiveTest.java
Patch:
@@ -9,6 +9,7 @@
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.reactivestreams.Publisher;
+import static org.redisson.BaseTest.createInstance;
 import org.redisson.api.RCollectionReactive;
 import org.redisson.api.RScoredSortedSetReactive;
 import org.redisson.api.RedissonReactiveClient;
@@ -42,6 +43,7 @@ public static void afterClass() throws IOException, InterruptedException {
     public void before() throws IOException, InterruptedException {
         if (RedissonRuntimeEnvironment.isTravis) {
             RedisRunner.startDefaultRedisServerInstance();
+            redisson = createInstance();
         } else {
             if (redisson == null) {
                 redisson = defaultRedisson;

File: src/test/java/org/redisson/BaseTest.java
Patch:
@@ -31,6 +31,7 @@ public static void afterClass() throws IOException, InterruptedException {
     public void before() throws IOException, InterruptedException {
         if (RedissonRuntimeEnvironment.isTravis) {
             RedisRunner.startDefaultRedisServerInstance();
+            redisson = createInstance();
         } else {
             if (redisson == null) {
                 redisson = defaultRedisson;

File: src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -33,6 +33,7 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static com.jayway.awaitility.Awaitility.await;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.redisson.BaseTest.createInstance;
 
 public class RedissonTest {
 
@@ -59,6 +60,7 @@ public static void afterClass() throws IOException, InterruptedException {
     public void before() throws IOException, InterruptedException {
         if (RedissonRuntimeEnvironment.isTravis) {
             RedisRunner.startDefaultRedisServerInstance();
+            redisson = createInstance();
         } else {
             if (redisson == null) {
                 redisson = defaultRedisson;

File: src/test/java/org/redisson/RedissonTwoLockedThread.java
Patch:
@@ -17,6 +17,7 @@
 import java.util.concurrent.CountDownLatch;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
+import static org.redisson.BaseTest.createInstance;
 
 @RunWith(Parameterized.class)
 public class RedissonTwoLockedThread {
@@ -49,6 +50,7 @@ public static void afterClass() throws IOException, InterruptedException {
     public void before() throws IOException, InterruptedException {
         if (RedissonRuntimeEnvironment.isTravis) {
             RedisRunner.startDefaultRedisServerInstance();
+            redisson = createInstance();
         }
         Config config = BaseTest.createConfig();
         config.setCodec(codec);

File: src/test/java/org/redisson/RedissonBlockingQueueTest.java
Patch:
@@ -24,6 +24,9 @@
 import org.redisson.core.RBlockingQueue;
 
 import io.netty.util.concurrent.Future;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThat;
 
 public class RedissonBlockingQueueTest extends BaseTest {
 

File: src/test/java/org/redisson/RedisRunner.java
Patch:
@@ -359,7 +359,7 @@ public RedisRunner save(long seconds, long changes) {
     public RedisRunner nosave() {
         this.nosave = true;
         options.remove(REDIS_OPTIONS.SAVE);
-        addConfigOption(REDIS_OPTIONS.SAVE, "");
+        addConfigOption(REDIS_OPTIONS.SAVE, "''");
         return this;
     }
 

File: src/main/java/org/redisson/RedissonMapIterator.java
Patch:
@@ -29,7 +29,7 @@ public RedissonMapIterator(RedissonMap<K, V> map) {
     }
 
     protected MapScanResult<ScanObjectEntry, ScanObjectEntry> iterator() {
-        return map.scanIterator(client, iterPos);
+        return map.scanIterator(client, nextIterPos);
     }
 
     protected void removeKey() {

File: src/main/java/org/redisson/RedissonMultiMapKeysIterator.java
Patch:
@@ -29,7 +29,7 @@ public RedissonMultiMapKeysIterator(RedissonMultimap<K, V> map) {
     }
 
     protected MapScanResult<ScanObjectEntry, ScanObjectEntry> iterator() {
-        return map.scanIterator(client, iterPos);
+        return map.scanIterator(client, nextIterPos);
     }
 
     protected void removeKey() {

File: src/main/java/org/redisson/RedissonBuckets.java
Patch:
@@ -72,7 +72,7 @@ public <V> Map<String, V> get(String... keys) {
             return Collections.emptyMap();
         }
 
-        RedisCommand<Map<Object, Object>> command = new RedisCommand<Map<Object, Object>>("MGET", new MapGetAllDecoder(Arrays.asList(keys), 0), ValueType.OBJECTS);
+        RedisCommand<Map<Object, Object>> command = new RedisCommand<Map<Object, Object>>("MGET", new MapGetAllDecoder(Arrays.<Object>asList(keys), 0), ValueType.OBJECTS);
         Future<Map<String, V>> future = commandExecutor.readAsync(keys[0], new DelegateDecoderCodec(codec), command, keys);
         return commandExecutor.get(future);
     }

File: src/main/java/org/redisson/RedissonBuckets.java
Patch:
@@ -72,7 +72,7 @@ public <V> Map<String, V> get(String... keys) {
             return Collections.emptyMap();
         }
 
-        RedisCommand<Map<Object, Object>> command = new RedisCommand<Map<Object, Object>>("MGET", new MapGetAllDecoder(Arrays.asList(keys), 0), ValueType.OBJECTS);
+        RedisCommand<Map<Object, Object>> command = new RedisCommand<Map<Object, Object>>("MGET", new MapGetAllDecoder(Arrays.<Object>asList(keys), 0), ValueType.OBJECTS);
         Future<Map<String, V>> future = commandExecutor.readAsync(keys[0], new DelegateDecoderCodec(codec), command, keys);
         return commandExecutor.get(future);
     }

File: src/main/java/org/redisson/RedissonBuckets.java
Patch:
@@ -72,7 +72,7 @@ public <V> Map<String, V> get(String... keys) {
             return Collections.emptyMap();
         }
 
-        RedisCommand<Map<Object, Object>> command = new RedisCommand<Map<Object, Object>>("MGET", new MapGetAllDecoder(Arrays.asList(keys), 0), ValueType.OBJECTS);
+        RedisCommand<Map<Object, Object>> command = new RedisCommand<Map<Object, Object>>("MGET", new MapGetAllDecoder(Arrays.<Object>asList(keys), 0), ValueType.OBJECTS);
         Future<Map<String, V>> future = commandExecutor.readAsync(keys[0], new DelegateDecoderCodec(codec), command, keys);
         return commandExecutor.get(future);
     }

File: src/test/java/org/redisson/RedisClientTest.java
Patch:
@@ -34,12 +34,12 @@
 public class RedisClientTest {
 
     @Before
-    public static void before() throws IOException, InterruptedException {
+    public void before() throws IOException, InterruptedException {
         RedisRunner.startDefaultRedisTestInstance();
     }
 
     @After
-    public static void after() throws InterruptedException {
+    public void after() throws InterruptedException {
         RedisRunner.shutDownDefaultRedisTestInstance();
     }
 

File: src/test/java/org/redisson/RedisRunner.java
Patch:
@@ -213,7 +213,7 @@ private static RedisProcess runWithOptions(String... options) throws IOException
                 System.out.println("Exception: " + ex.getLocalizedMessage());
             }
         }).start();
-        Thread.sleep(1000);
+        Thread.sleep(3000);
         return new RedisProcess(p);
     }
 

File: src/main/java/org/redisson/RedissonObject.java
Patch:
@@ -50,11 +50,11 @@ protected <V> V get(Future<V> future) {
     }
 
     protected <V> Promise<V> newPromise() {
-        return commandExecutor.getConnectionManager().getGroup().next().<V>newPromise();
+        return commandExecutor.getConnectionManager().newPromise();
     }
 
     protected <V> Future<V> newSucceededFuture(V result) {
-        return commandExecutor.getConnectionManager().<V>newSucceededFuture(result);
+        return commandExecutor.getConnectionManager().newSucceededFuture(result);
     }
 
     @Override

File: src/main/java/org/redisson/client/RedisClient.java
Patch:
@@ -38,6 +38,7 @@
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GlobalEventExecutor;
+import io.netty.util.concurrent.ImmediateEventExecutor;
 import io.netty.util.concurrent.Promise;
 
 public class RedisClient {
@@ -95,7 +96,7 @@ public RedisConnection connect() {
     }
 
     public Future<RedisConnection> connectAsync() {
-        final Promise<RedisConnection> f = bootstrap.group().next().newPromise();
+        final Promise<RedisConnection> f = ImmediateEventExecutor.INSTANCE.newPromise();
         ChannelFuture channelFuture = bootstrap.connect();
         channelFuture.addListener(new ChannelFutureListener() {
             @Override
@@ -122,7 +123,7 @@ public RedisPubSubConnection connectPubSub() {
     }
 
     public Future<RedisPubSubConnection> connectPubSubAsync() {
-        final Promise<RedisPubSubConnection> f = bootstrap.group().next().newPromise();
+        final Promise<RedisPubSubConnection> f = ImmediateEventExecutor.INSTANCE.newPromise();
         ChannelFuture channelFuture = bootstrap.connect();
         channelFuture.addListener(new ChannelFutureListener() {
             @Override

File: src/main/java/org/redisson/client/handler/ConnectionWatchdog.java
Patch:
@@ -37,6 +37,7 @@
 import io.netty.channel.group.ChannelGroup;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.FutureListener;
+import io.netty.util.concurrent.ImmediateEventExecutor;
 import io.netty.util.concurrent.Promise;
 
 public class ConnectionWatchdog extends ChannelInboundHandlerAdapter {
@@ -117,7 +118,7 @@ private void reconnect(final RedisConnection connection, final Channel channel)
         if (connection.getReconnectListener() != null) {
             // new connection used only for channel init
             RedisConnection rc = new RedisConnection(connection.getRedisClient(), channel);
-            Promise<RedisConnection> connectionFuture = bootstrap.group().next().newPromise();
+            Promise<RedisConnection> connectionFuture = ImmediateEventExecutor.INSTANCE.newPromise();
             connection.getReconnectListener().onReconnect(rc, connectionFuture);
             connectionFuture.addListener(new FutureListener<RedisConnection>() {
                 @Override

File: src/main/java/org/redisson/connection/ClientConnectionsEntry.java
Patch:
@@ -29,6 +29,7 @@
 
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.FutureListener;
+import io.netty.util.concurrent.ImmediateEventExecutor;
 import io.netty.util.concurrent.Promise;
 
 public class ClientConnectionsEntry {
@@ -137,7 +138,7 @@ public void releaseConnection(RedisConnection connection) {
     }
 
     public Future<RedisConnection> connect() {
-        final Promise<RedisConnection> connectionFuture = client.getBootstrap().group().next().newPromise();
+        final Promise<RedisConnection> connectionFuture = ImmediateEventExecutor.INSTANCE.newPromise();
         Future<RedisConnection> future = client.connectAsync();
         future.addListener(new FutureListener<RedisConnection>() {
             @Override
@@ -186,7 +187,7 @@ public void operationComplete(Future<T> future) throws Exception {
     }
 
     public Future<RedisPubSubConnection> connectPubSub() {
-        final Promise<RedisPubSubConnection> connectionFuture = client.getBootstrap().group().next().newPromise();
+        final Promise<RedisPubSubConnection> connectionFuture = ImmediateEventExecutor.INSTANCE.newPromise();
         Future<RedisPubSubConnection> future = client.connectPubSubAsync();
         future.addListener(new FutureListener<RedisPubSubConnection>() {
             @Override

File: src/main/java/org/redisson/RedissonListMultimapCache.java
Patch:
@@ -41,13 +41,13 @@ public class RedissonListMultimapCache<K, V> extends RedissonListMultimap<K, V>
     RedissonListMultimapCache(EvictionScheduler evictionScheduler, CommandAsyncExecutor connectionManager, String name) {
         super(connectionManager, name);
         evictionScheduler.scheduleCleanMultimap(name, getTimeoutSetName());
-        baseCache = new RedissonMultimapCache<>(connectionManager, name, codec, getTimeoutSetName());
+        baseCache = new RedissonMultimapCache<K>(connectionManager, name, codec, getTimeoutSetName());
     }
 
     RedissonListMultimapCache(EvictionScheduler evictionScheduler, Codec codec, CommandAsyncExecutor connectionManager, String name) {
         super(codec, connectionManager, name);
         evictionScheduler.scheduleCleanMultimap(name, getTimeoutSetName());
-        baseCache = new RedissonMultimapCache<>(connectionManager, name, codec, getTimeoutSetName());
+        baseCache = new RedissonMultimapCache<K>(connectionManager, name, codec, getTimeoutSetName());
     }
 
     public Future<Boolean> containsKeyAsync(Object key) {

File: src/main/java/org/redisson/RedissonSetMultimapCache.java
Patch:
@@ -41,13 +41,13 @@ public class RedissonSetMultimapCache<K, V> extends RedissonSetMultimap<K, V> im
     RedissonSetMultimapCache(EvictionScheduler evictionScheduler, CommandAsyncExecutor connectionManager, String name) {
         super(connectionManager, name);
         evictionScheduler.scheduleCleanMultimap(name, getTimeoutSetName());
-        baseCache = new RedissonMultimapCache<>(connectionManager, name, codec, getTimeoutSetName());
+        baseCache = new RedissonMultimapCache<K>(connectionManager, name, codec, getTimeoutSetName());
     }
 
     RedissonSetMultimapCache(EvictionScheduler evictionScheduler, Codec codec, CommandAsyncExecutor connectionManager, String name) {
         super(codec, connectionManager, name);
         evictionScheduler.scheduleCleanMultimap(name, getTimeoutSetName());
-        baseCache = new RedissonMultimapCache<>(connectionManager, name, codec, getTimeoutSetName());
+        baseCache = new RedissonMultimapCache<K>(connectionManager, name, codec, getTimeoutSetName());
     }
 
     public Future<Boolean> containsKeyAsync(Object key) {

File: src/main/java/org/redisson/RedissonBloomFilter.java
Patch:
@@ -200,7 +200,7 @@ public int count() {
 
     @Override
     public Future<Boolean> deleteAsync() {
-        return commandExecutor.writeAsync(getName(), RedisCommands.DEL_BOOL, getName(), getConfigName());
+        return commandExecutor.writeAsync(getName(), RedisCommands.DEL_OBJECTS, getName(), getConfigName());
     }
 
     private void readConfig() {

File: src/main/java/org/redisson/RedissonMapCache.java
Patch:
@@ -655,7 +655,7 @@ public Future<Void> putAllAsync(Map<? extends K, ? extends V> map) {
 
     @Override
     public Future<Boolean> deleteAsync() {
-        return commandExecutor.writeAsync(getName(), RedisCommands.DEL_BOOL, getName(), getTimeoutSetName());
+        return commandExecutor.writeAsync(getName(), RedisCommands.DEL_OBJECTS, getName(), getTimeoutSetName());
     }
 
     @Override

File: src/main/java/org/redisson/RedissonSetCache.java
Patch:
@@ -474,7 +474,7 @@ public void clear() {
 
     @Override
     public Future<Boolean> deleteAsync() {
-        return commandExecutor.writeAsync(getName(), RedisCommands.DEL_BOOL, getName(), getTimeoutSetName());
+        return commandExecutor.writeAsync(getName(), RedisCommands.DEL_OBJECTS, getName(), getTimeoutSetName());
     }
 
     @Override

File: src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -208,6 +208,7 @@ public interface RedisCommands {
     RedisStrictCommand<Long> DEL = new RedisStrictCommand<Long>("DEL");
     RedisStrictCommand<Long> DBSIZE = new RedisStrictCommand<Long>("DBSIZE");
     RedisStrictCommand<Boolean> DEL_BOOL = new RedisStrictCommand<Boolean>("DEL", new BooleanReplayConvertor());
+    RedisStrictCommand<Boolean> DEL_OBJECTS = new RedisStrictCommand<Boolean>("DEL", new BooleanAmountReplayConvertor());
     RedisStrictCommand<Void> DEL_VOID = new RedisStrictCommand<Void>("DEL", new VoidReplayConvertor());
 
     RedisCommand<Object> GET = new RedisCommand<Object>("GET");

File: src/main/java/org/redisson/reactive/RedissonMapCacheReactive.java
Patch:
@@ -361,7 +361,7 @@ Publisher<MapScanResult<ScanObjectEntry, ScanObjectEntry>> scanIteratorReactive(
 
     @Override
     public Publisher<Boolean> delete() {
-        return commandExecutor.writeReactive(getName(), RedisCommands.DEL_BOOL, getName(), getTimeoutSetName());
+        return commandExecutor.writeReactive(getName(), RedisCommands.DEL_OBJECTS, getName(), getTimeoutSetName());
     }
 
     @Override

File: src/main/java/org/redisson/reactive/RedissonSetCacheReactive.java
Patch:
@@ -305,7 +305,7 @@ public Publisher<Boolean> removeAll(Collection<?> c) {
 
     @Override
     public Publisher<Boolean> delete() {
-        return commandExecutor.writeReactive(getName(), RedisCommands.DEL_BOOL, getName(), getTimeoutSetName());
+        return commandExecutor.writeReactive(getName(), RedisCommands.DEL_OBJECTS, getName(), getTimeoutSetName());
     }
 
     @Override

File: src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -493,8 +493,8 @@ public void operationComplete(Future<Boolean> future) throws Exception {
         details.getMainPromise().addListener(new FutureListener<R>() {
             @Override
             public void operationComplete(Future<R> future) throws Exception {
+                connectionManager.getShutdownPromise().removeListener(listener);
                 if (!future.isCancelled()) {
-                    connectionManager.getShutdownPromise().removeListener(listener);
                     return;
                 }
                 // cancel handling for commands from skipTimeout collection

File: src/main/java/org/redisson/core/RRemoteService.java
Patch:
@@ -46,10 +46,10 @@ public interface RRemoteService {
     
     /**
      * Get remote service object for remote invocations 
-     * with specified timeout invocation
+     * with specified invocation timeout
      * 
      * @param remoteInterface
-     * @param timeout - timeout invocation
+     * @param timeout - invocation timeout
      * @param timeUnit
      * @return
      */

File: src/main/java/org/redisson/connection/pool/ConnectionPool.java
Patch:
@@ -153,7 +153,7 @@ public Future<T> get() {
             }
         }
 
-        StringBuilder errorMsg = new StringBuilder("Connection pool exhausted! All connections are busy. Try to increase connection pool size.");
+        StringBuilder errorMsg = new StringBuilder("Publish/Subscribe connection pool exhausted! All connections are busy. Try to increase Publish/Subscribe connection pool size.");
 //        if (!freezed.isEmpty()) {
 //            errorMsg.append(" Disconnected hosts: " + freezed);
 //        }

File: src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -577,7 +577,9 @@ public void operationComplete(Future<RedissonLockEntry> future) throws Exception
                             return;
                         }
 
-                        futureRef.get().cancel(false);
+                        if (futureRef.get() != null) {
+                            futureRef.get().cancel(false);
+                        }
 
                         tryLockAsync(time, leaseTime, unit, subscribeFuture, result, currentThreadId);
                     }

File: src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -577,7 +577,9 @@ public void operationComplete(Future<RedissonLockEntry> future) throws Exception
                             return;
                         }
 
-                        futureRef.get().cancel(false);
+                        if (futureRef.get() != null) {
+                            futureRef.get().cancel(false);
+                        }
 
                         tryLockAsync(time, leaseTime, unit, subscribeFuture, result, currentThreadId);
                     }

File: src/main/java/org/redisson/RedissonBitSet.java
Patch:
@@ -31,7 +31,7 @@
 
 public class RedissonBitSet extends RedissonExpirable implements RBitSet {
 
-    protected RedissonBitSet(CommandAsyncExecutor connectionManager, String name) {
+    public RedissonBitSet(CommandAsyncExecutor connectionManager, String name) {
         super(connectionManager, name);
     }
 

File: src/main/java/org/redisson/Version.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.redisson;
 
-import java.io.IOException;
 import java.net.URL;
 import java.util.Enumeration;
 import java.util.jar.Attributes;
@@ -43,7 +42,7 @@ public static void logVersion() {
                         break;
                     }
             }
-        } catch (IOException E) {
+        } catch (Exception E) {
             // skip it
         }
     }

File: src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -91,6 +91,7 @@ public interface RedisCommands {
     RedisStrictCommand<Integer> ZREMRANGEBYLEX = new RedisStrictCommand<Integer>("ZREMRANGEBYLEX", new IntegerReplayConvertor());
     RedisCommand<List<Object>> ZRANGEBYLEX = new RedisCommand<List<Object>>("ZRANGEBYLEX", new ObjectListReplayDecoder<Object>());
     RedisCommand<List<Object>> ZRANGEBYSCORE = new RedisCommand<List<Object>>("ZRANGEBYSCORE", new ObjectListReplayDecoder<Object>());
+    RedisCommand<List<Object>> ZREVRANGEBYSCORE = new RedisCommand<List<Object>>("ZREVRANGEBYSCORE", new ObjectListReplayDecoder<Object>());
     RedisCommand<List<ScoredEntry<Object>>> ZRANGE_ENTRY = new RedisCommand<List<ScoredEntry<Object>>>("ZRANGE", new ScoredSortedSetReplayDecoder<Object>());
     RedisCommand<List<ScoredEntry<Object>>> ZRANGEBYSCORE_ENTRY = new RedisCommand<List<ScoredEntry<Object>>>("ZRANGEBYSCORE", new ScoredSortedSetReplayDecoder<Object>());
     RedisCommand<ListScanResult<Object>> ZSCAN = new RedisCommand<ListScanResult<Object>>("ZSCAN", new NestedMultiDecoder(new ScoredSortedSetScanDecoder<Object>(), new ScoredSortedSetScanReplayDecoder()), ValueType.OBJECT);
@@ -159,6 +160,7 @@ public interface RedisCommands {
     RedisStrictCommand<Boolean> SCRIPT_FLUSH = new RedisStrictCommand<Boolean>("SCRIPT", "FLUSH", new BooleanReplayConvertor());
     RedisStrictCommand<List<Boolean>> SCRIPT_EXISTS = new RedisStrictCommand<List<Boolean>>("SCRIPT", "EXISTS", new ObjectListReplayDecoder<Boolean>(), new BooleanReplayConvertor());
 
+    RedisStrictCommand<Boolean> EVAL_BOOLEAN_AMOUNT = new RedisStrictCommand<Boolean>("EVAL", new BooleanAmountReplayConvertor());
     RedisStrictCommand<Boolean> EVAL_BOOLEAN = new RedisStrictCommand<Boolean>("EVAL", new BooleanReplayConvertor());
     RedisCommand<Boolean> EVAL_BOOLEAN_WITH_VALUES = new RedisCommand<Boolean>("EVAL", new BooleanReplayConvertor(), 4, ValueType.OBJECTS);
     RedisStrictCommand<String> EVAL_STRING = new RedisStrictCommand<String>("EVAL", new StringReplayDecoder());

File: src/main/java/org/redisson/cluster/ClusterConnectionListener.java
Patch:
@@ -21,7 +21,7 @@
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.connection.DefaultConnectionListener;
 import org.redisson.connection.FutureConnectionListener;
-import org.redisson.connection.ClientConnectionsEntry.NodeType;
+import org.redisson.core.NodeType;
 
 public class ClusterConnectionListener extends DefaultConnectionListener {
 

File: src/main/java/org/redisson/connection/ConnectionInitializer.java
Patch:
@@ -17,7 +17,7 @@
 
 import org.redisson.MasterSlaveServersConfig;
 import org.redisson.client.RedisConnection;
-import org.redisson.connection.ClientConnectionsEntry.NodeType;
+import org.redisson.core.NodeType;
 
 import io.netty.util.concurrent.Promise;
 

File: src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -28,6 +28,7 @@
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.cluster.ClusterSlotRange;
 import org.redisson.connection.ClientConnectionsEntry.FreezeReason;
+import org.redisson.core.NodeType;
 import org.redisson.misc.InfinitySemaphoreLatch;
 
 import io.netty.channel.EventLoopGroup;
@@ -87,7 +88,7 @@ public interface ConnectionManager {
 
     RedisClient createClient(String host, int port, int timeout);
 
-    RedisClient createClient(String host, int port);
+    RedisClient createClient(NodeType type, String host, int port);
 
     MasterSlaveEntry getEntry(InetSocketAddress addr);
 

File: src/main/java/org/redisson/connection/DefaultConnectionListener.java
Patch:
@@ -19,7 +19,7 @@
 import org.redisson.client.RedisConnection;
 import org.redisson.client.RedisException;
 import org.redisson.client.protocol.RedisCommands;
-import org.redisson.connection.ClientConnectionsEntry.NodeType;
+import org.redisson.core.NodeType;
 
 import io.netty.util.concurrent.Promise;
 

File: src/main/java/org/redisson/connection/SingleEntry.java
Patch:
@@ -24,9 +24,9 @@
 import org.redisson.client.RedisConnection;
 import org.redisson.client.RedisPubSubConnection;
 import org.redisson.cluster.ClusterSlotRange;
-import org.redisson.connection.ClientConnectionsEntry.NodeType;
 import org.redisson.connection.pool.PubSubConnectionPool;
 import org.redisson.connection.pool.SinglePubSubConnectionPool;
+import org.redisson.core.NodeType;
 
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.FutureListener;
@@ -43,12 +43,12 @@ public SingleEntry(Set<ClusterSlotRange> slotRanges, ConnectionManager connectio
 
     @Override
     public Future<Void> setupMasterEntry(String host, int port) {
-        RedisClient masterClient = connectionManager.createClient(host, port);
+        RedisClient masterClient = connectionManager.createClient(NodeType.MASTER, host, port);
         masterEntry = new ClientConnectionsEntry(masterClient,
                 config.getMasterConnectionMinimumIdleSize(),
                 config.getMasterConnectionPoolSize(),
                 config.getSlaveConnectionMinimumIdleSize(),
-                config.getSlaveSubscriptionConnectionPoolSize(), connectionManager, NodeType.MASTER, config);
+                config.getSlaveSubscriptionConnectionPoolSize(), connectionManager, NodeType.MASTER);
         final Promise<Void> res = connectionManager.newPromise();
         Future<Void> f = writeConnectionHolder.add(masterEntry);
         Future<Void> s = pubSubConnectionHolder.add(masterEntry);

File: src/main/java/org/redisson/connection/pool/ConnectionPool.java
Patch:
@@ -28,9 +28,9 @@
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.connection.ClientConnectionsEntry;
 import org.redisson.connection.ClientConnectionsEntry.FreezeReason;
-import org.redisson.connection.ClientConnectionsEntry.NodeType;
 import org.redisson.connection.ConnectionManager;
 import org.redisson.connection.MasterSlaveEntry;
+import org.redisson.core.NodeType;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -185,10 +185,10 @@ protected T poll(ClientConnectionsEntry entry) {
     }
 
     protected Future<T> connect(ClientConnectionsEntry entry) {
-        return (Future<T>) entry.connect(config);
+        return (Future<T>) entry.connect();
     }
 
-    private Future<T> connectTo(final ClientConnectionsEntry entry) {
+    private Future<T> connectTo(ClientConnectionsEntry entry) {
         T conn = poll(entry);
         if (conn != null) {
             if (!conn.isActive()) {

File: src/main/java/org/redisson/connection/pool/PubSubConnectionPool.java
Patch:
@@ -41,7 +41,7 @@ protected int getMinimumIdleSize(ClientConnectionsEntry entry) {
 
     @Override
     protected Future<RedisPubSubConnection> connect(ClientConnectionsEntry entry) {
-        return entry.connectPubSub(config);
+        return entry.connectPubSub();
     }
 
     @Override

File: src/test/java/org/redisson/BaseTest.java
Patch:
@@ -26,8 +26,8 @@ public static Config createConfig() {
             redisAddress = "127.0.0.1:6379";
         }
         Config config = new Config();
-        config.setCodec(new MsgPackJacksonCodec());
-//        config.useSentinelConnection().setMasterName("mymaster").addSentinelAddress("127.0.0.1:26379", "127.0.0.1:26389");
+//        config.setCodec(new MsgPackJacksonCodec());
+//        config.useSentinelServers().setMasterName("mymaster").addSentinelAddress("127.0.0.1:26379", "127.0.0.1:26389");
 //        config.useClusterServers().addNodeAddress("127.0.0.1:7004", "127.0.0.1:7001", "127.0.0.1:7000");
         config.useSingleServer().setAddress(redisAddress);
 //        .setPassword("mypass1");

File: src/test/java/org/redisson/RedissonBucketTest.java
Patch:
@@ -157,7 +157,7 @@ public void testSetExist() {
         bucket.set(value);
         Assert.assertEquals(value, bucket.get());
 
-        Assert.assertTrue(bucket.exists());
+        Assert.assertTrue(bucket.isExists());
     }
 
     @Test
@@ -168,11 +168,11 @@ public void testSetDeleteNotExist() {
         bucket.set(value);
         Assert.assertEquals(value, bucket.get());
 
-        Assert.assertTrue(bucket.exists());
+        Assert.assertTrue(bucket.isExists());
 
         bucket.delete();
 
-        Assert.assertFalse(bucket.exists());
+        Assert.assertFalse(bucket.isExists());
     }
 
     @Test

File: src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -201,7 +201,7 @@ protected void init(MasterSlaveServersConfig config) {
 
         try {
             initEntry(config);
-        } catch (Exception e) {
+        } catch (RuntimeException e) {
             try {
                 group.shutdownGracefully().await();
             } catch (Exception e1) {

File: src/main/java/org/redisson/Version.java
Patch:
@@ -15,7 +15,6 @@
  */
 package org.redisson;
 
-import java.io.IOException;
 import java.net.URL;
 import java.util.Enumeration;
 import java.util.jar.Attributes;
@@ -43,7 +42,7 @@ public static void logVersion() {
                         break;
                     }
             }
-        } catch (IOException E) {
+        } catch (Exception E) {
             // skip it
         }
     }

File: src/test/java/org/redisson/RedissonBucketTest.java
Patch:
@@ -157,7 +157,7 @@ public void testSetExist() {
         bucket.set(value);
         Assert.assertEquals(value, bucket.get());
 
-        Assert.assertTrue(bucket.exists());
+        Assert.assertTrue(bucket.isExists());
     }
 
     @Test
@@ -168,11 +168,11 @@ public void testSetDeleteNotExist() {
         bucket.set(value);
         Assert.assertEquals(value, bucket.get());
 
-        Assert.assertTrue(bucket.exists());
+        Assert.assertTrue(bucket.isExists());
 
         bucket.delete();
 
-        Assert.assertFalse(bucket.exists());
+        Assert.assertFalse(bucket.isExists());
     }
 
     @Test

File: src/main/java/org/redisson/cluster/ClusterConnectionListener.java
Patch:
@@ -21,7 +21,7 @@
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.connection.DefaultConnectionListener;
 import org.redisson.connection.FutureConnectionListener;
-import org.redisson.connection.ClientConnectionsEntry.NodeType;
+import org.redisson.core.NodeType;
 
 public class ClusterConnectionListener extends DefaultConnectionListener {
 

File: src/main/java/org/redisson/connection/ClientConnectionsEntry.java
Patch:
@@ -24,6 +24,7 @@
 import org.redisson.client.RedisClient;
 import org.redisson.client.RedisConnection;
 import org.redisson.client.RedisPubSubConnection;
+import org.redisson.core.NodeType;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -48,8 +49,6 @@ public enum FreezeReason {MANAGER, RECONNECT, SYSTEM}
     private FreezeReason freezeReason;
     final RedisClient client;
 
-    public enum NodeType {SLAVE, MASTER, SENTINEL}
-
     private final NodeType nodeType;
     private ConnectionManager connectionManager;
 

File: src/main/java/org/redisson/connection/ConnectionInitializer.java
Patch:
@@ -17,7 +17,7 @@
 
 import org.redisson.MasterSlaveServersConfig;
 import org.redisson.client.RedisConnection;
-import org.redisson.connection.ClientConnectionsEntry.NodeType;
+import org.redisson.core.NodeType;
 
 import io.netty.util.concurrent.Promise;
 

File: src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -28,6 +28,7 @@
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.cluster.ClusterSlotRange;
 import org.redisson.connection.ClientConnectionsEntry.FreezeReason;
+import org.redisson.core.NodeType;
 import org.redisson.misc.InfinitySemaphoreLatch;
 
 import io.netty.channel.EventLoopGroup;
@@ -87,7 +88,7 @@ public interface ConnectionManager {
 
     RedisClient createClient(String host, int port, int timeout);
 
-    RedisClient createClient(String host, int port);
+    RedisClient createClient(NodeType type, String host, int port);
 
     MasterSlaveEntry getEntry(InetSocketAddress addr);
 

File: src/main/java/org/redisson/connection/DefaultConnectionListener.java
Patch:
@@ -19,7 +19,7 @@
 import org.redisson.client.RedisConnection;
 import org.redisson.client.RedisException;
 import org.redisson.client.protocol.RedisCommands;
-import org.redisson.connection.ClientConnectionsEntry.NodeType;
+import org.redisson.core.NodeType;
 
 import io.netty.util.concurrent.Promise;
 

File: src/main/java/org/redisson/connection/MasterSlaveEntry.java
Patch:
@@ -30,10 +30,10 @@
 import org.redisson.client.RedisPubSubConnection;
 import org.redisson.cluster.ClusterSlotRange;
 import org.redisson.connection.ClientConnectionsEntry.FreezeReason;
-import org.redisson.connection.ClientConnectionsEntry.NodeType;
 import org.redisson.connection.balancer.LoadBalancerManager;
 import org.redisson.connection.balancer.LoadBalancerManagerImpl;
 import org.redisson.connection.pool.MasterConnectionPool;
+import org.redisson.core.NodeType;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -84,7 +84,7 @@ public List<Future<Void>> initSlaveBalancer(Collection<URI> disconnectedNodes) {
     }
 
     public Future<Void> setupMasterEntry(String host, int port) {
-        RedisClient client = connectionManager.createClient(host, port);
+        RedisClient client = connectionManager.createClient(NodeType.MASTER, host, port);
         masterEntry = new ClientConnectionsEntry(client, config.getMasterConnectionMinimumIdleSize(), config.getMasterConnectionPoolSize(),
                                                     0, 0, connectionManager, NodeType.MASTER, config);
         return writeConnectionHolder.add(masterEntry);
@@ -108,7 +108,7 @@ public Future<Void> addSlave(String host, int port) {
     }
 
     private Future<Void> addSlave(String host, int port, boolean freezed, NodeType mode) {
-        RedisClient client = connectionManager.createClient(host, port);
+        RedisClient client = connectionManager.createClient(NodeType.SLAVE, host, port);
         ClientConnectionsEntry entry = new ClientConnectionsEntry(client,
                 this.config.getSlaveConnectionMinimumIdleSize(),
                 this.config.getSlaveConnectionPoolSize(),

File: src/main/java/org/redisson/connection/SingleEntry.java
Patch:
@@ -24,9 +24,9 @@
 import org.redisson.client.RedisConnection;
 import org.redisson.client.RedisPubSubConnection;
 import org.redisson.cluster.ClusterSlotRange;
-import org.redisson.connection.ClientConnectionsEntry.NodeType;
 import org.redisson.connection.pool.PubSubConnectionPool;
 import org.redisson.connection.pool.SinglePubSubConnectionPool;
+import org.redisson.core.NodeType;
 
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.FutureListener;
@@ -43,7 +43,7 @@ public SingleEntry(Set<ClusterSlotRange> slotRanges, ConnectionManager connectio
 
     @Override
     public Future<Void> setupMasterEntry(String host, int port) {
-        RedisClient masterClient = connectionManager.createClient(host, port);
+        RedisClient masterClient = connectionManager.createClient(NodeType.MASTER, host, port);
         masterEntry = new ClientConnectionsEntry(masterClient,
                 config.getMasterConnectionMinimumIdleSize(),
                 config.getMasterConnectionPoolSize(),

File: src/main/java/org/redisson/connection/pool/ConnectionPool.java
Patch:
@@ -28,9 +28,9 @@
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.connection.ClientConnectionsEntry;
 import org.redisson.connection.ClientConnectionsEntry.FreezeReason;
-import org.redisson.connection.ClientConnectionsEntry.NodeType;
 import org.redisson.connection.ConnectionManager;
 import org.redisson.connection.MasterSlaveEntry;
+import org.redisson.core.NodeType;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 

File: src/main/java/org/redisson/reactive/RedissonMapReactive.java
Patch:
@@ -50,12 +50,12 @@ public class RedissonMapReactive<K, V> extends RedissonExpirableReactive impleme
 
     public RedissonMapReactive(CommandReactiveExecutor commandExecutor, String name) {
         super(commandExecutor, name);
-        instance = new RedissonMap<>(codec, commandExecutor, name);
+        instance = new RedissonMap<K, V>(codec, commandExecutor, name);
     }
 
     public RedissonMapReactive(Codec codec, CommandReactiveExecutor commandExecutor, String name) {
         super(codec, commandExecutor, name);
-        instance = new RedissonMap<>(codec, commandExecutor, name);
+        instance = new RedissonMap<K, V>(codec, commandExecutor, name);
     }
 
     @Override

File: src/main/java/org/redisson/reactive/RedissonMapReactive.java
Patch:
@@ -50,12 +50,12 @@ public class RedissonMapReactive<K, V> extends RedissonExpirableReactive impleme
 
     public RedissonMapReactive(CommandReactiveExecutor commandExecutor, String name) {
         super(commandExecutor, name);
-        instance = new RedissonMap<>(codec, commandExecutor, name);
+        instance = new RedissonMap<K, V>(codec, commandExecutor, name);
     }
 
     public RedissonMapReactive(Codec codec, CommandReactiveExecutor commandExecutor, String name) {
         super(codec, commandExecutor, name);
-        instance = new RedissonMap<>(codec, commandExecutor, name);
+        instance = new RedissonMap<K, V>(codec, commandExecutor, name);
     }
 
     @Override

File: src/main/java/org/redisson/connection/pool/ConnectionPool.java
Patch:
@@ -137,12 +137,12 @@ public Future<T> get() {
             }
         }
 
-        StringBuilder errorMsg = new StringBuilder("Connection pool exhausted!");
+        StringBuilder errorMsg = new StringBuilder("Connection pool exhausted! All connections are busy. ");
         if (!freezed.isEmpty()) {
             errorMsg.append(" disconnected hosts: " + freezed);
         }
         if (!zeroConnectionsAmount.isEmpty()) {
-            errorMsg.append(" hosts with (available connections amount) = 0 : " + zeroConnectionsAmount);
+            errorMsg.append(" hosts with fully busy connections: " + zeroConnectionsAmount);
         }
         errorMsg.append(" Try to increase connection pool size.");
 

File: src/main/java/org/redisson/RedissonKeys.java
Patch:
@@ -289,7 +289,7 @@ public void operationComplete(Future<List<?>> future) throws Exception {
                 if (executed.decrementAndGet() == 0) {
                     if (failed.get() != null) {
                         if (count.get() > 0) {
-                            RedisException ex = new RedisException("" + count.get() + " keys deleted. But one or more nodes has an error", failed.get());
+                            RedisException ex = new RedisException("" + count.get() + " keys has been deleted. But one or more nodes has an error", failed.get());
                             result.setFailure(ex);
                         } else {
                             result.setFailure(failed.get());

File: src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -127,7 +127,7 @@ public SentinelConnectionManager(SentinelServersConfig cfg, Config config) {
         }
 
         for (Future<RedisPubSubConnection> future : connectionFutures) {
-            future.syncUninterruptibly();
+            future.awaitUninterruptibly();
         }
     }
 

File: src/main/java/org/redisson/cluster/ClusterNodeInfo.java
Patch:
@@ -16,9 +16,7 @@
 package org.redisson.cluster;
 
 import java.net.URI;
-import java.util.ArrayList;
 import java.util.HashSet;
-import java.util.List;
 import java.util.Set;
 
 import org.redisson.misc.URIBuilder;
@@ -29,7 +27,7 @@ public enum Flag {NOFLAGS, SLAVE, MASTER, MYSELF, FAIL, HANDSHAKE, NOADDR};
 
     private String nodeId;
     private URI address;
-    private final List<Flag> flags = new ArrayList<Flag>();
+    private final Set<Flag> flags = new HashSet<Flag>();
     private String slaveOf;
 
     private final Set<ClusterSlotRange> slotRanges = new HashSet<ClusterSlotRange>();

File: src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -16,6 +16,7 @@
 package org.redisson.connection;
 
 import java.net.InetSocketAddress;
+import java.net.URI;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
@@ -213,7 +214,7 @@ protected void initEntry(MasterSlaveServersConfig config) {
     protected MasterSlaveEntry createMasterSlaveEntry(MasterSlaveServersConfig config,
             HashSet<ClusterSlotRange> slots) {
         MasterSlaveEntry entry = new MasterSlaveEntry(slots, this, config);
-        List<Future<Void>> fs = entry.initSlaveBalancer(java.util.Collections.emptyList());
+        List<Future<Void>> fs = entry.initSlaveBalancer(java.util.Collections.<URI>emptySet());
         for (Future<Void> future : fs) {
             future.syncUninterruptibly();
         }

File: src/main/java/org/redisson/connection/MasterSlaveEntry.java
Patch:
@@ -135,6 +135,7 @@ public boolean slaveUp(String host, int port, FreezeReason freezeReason) {
         if (config.getReadMode() == ReadMode.SLAVE
                 && (!addr.getHostName().equals(host) || port != addr.getPort())) {
             connectionManager.slaveDown(this, addr.getHostName(), addr.getPort(), FreezeReason.SYSTEM);
+            log.info("master {}:{} excluded from slaves", addr.getHostName(), addr.getPort());
         }
         return true;
     }

File: src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -217,8 +217,8 @@ protected void onSlaveAdded(URI addr, String msg) {
 
         if (parts.length > 4
                  && "slave".equals(parts[0])) {
-            String ip = parts[2];
-            String port = parts[3];
+            final String ip = parts[2];
+            final String port = parts[3];
 
             final String slaveAddr = ip + ":" + port;
 

File: src/main/java/org/redisson/core/RedissonMultiLock.java
Patch:
@@ -109,7 +109,7 @@ public Promise<Void> setFailure(Throwable cause) {
         }
     }
 
-    private void lock(final Promise<Void> promise, long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException {
+    private void lock(final Promise<Void> promise, final long waitTime, final long leaseTime, final TimeUnit unit) throws InterruptedException {
         final AtomicInteger tryLockRequestsAmount = new AtomicInteger();
         final Map<Future<Boolean>, RLock> tryLockFutures = new HashMap<Future<Boolean>, RLock>(locks.size());
 

File: src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -303,11 +303,11 @@ public void operationComplete(Future<String> future) throws Exception {
 
     private void checkSlaveNodesChange(Collection<ClusterPartition> newPartitions) {
         for (ClusterPartition newPart : newPartitions) {
-            for (ClusterPartition currentPart : lastPartitions.values()) {
+            for (final ClusterPartition currentPart : lastPartitions.values()) {
                 if (!newPart.getMasterAddress().equals(currentPart.getMasterAddress())) {
                     continue;
                 }
-                MasterSlaveEntry entry = getEntry(currentPart.getMasterAddr());
+                final MasterSlaveEntry entry = getEntry(currentPart.getMasterAddr());
 
                 Set<URI> removedSlaves = new HashSet<URI>(currentPart.getSlaveAddresses());
                 removedSlaves.removeAll(newPart.getSlaveAddresses());
@@ -321,7 +321,7 @@ private void checkSlaveNodesChange(Collection<ClusterPartition> newPartitions) {
 
                 Set<URI> addedSlaves = new HashSet<URI>(newPart.getSlaveAddresses());
                 addedSlaves.removeAll(currentPart.getSlaveAddresses());
-                for (URI uri : addedSlaves) {
+                for (final URI uri : addedSlaves) {
                     Future<Void> future = entry.addSlave(uri.getHost(), uri.getPort());
                     future.addListener(new FutureListener<Void>() {
                         @Override

File: src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -203,7 +203,7 @@ protected void onSlaveAdded(URI addr, String msg) {
             String ip = parts[2];
             String port = parts[3];
 
-            String slaveAddr = ip + ":" + port;
+            final String slaveAddr = ip + ":" + port;
 
             // to avoid addition twice
             if (slaves.putIfAbsent(slaveAddr, true) == null && config.getReadMode() == ReadMode.SLAVE) {

File: src/main/java/org/redisson/misc/ConnectionPool.java
Patch:
@@ -76,7 +76,7 @@ private void initConnections(final ClientConnectionsEntry entry, final Promise<V
         for (int i = 0; i < minimumIdleSize; i++) {
             if ((checkFreezed && entry.isFreezed()) || !tryAcquireConnection(entry)) {
                 Throwable cause = new RedisConnectionException(
-                        "Can't init enough connections amount! Only " + initializedConnections.get() + " from " + minimumIdleSize + " were initialized. Server: "
+                        "Can't init enough connections amount! Only " + (minimumIdleSize - initializedConnections.get()) + " from " + minimumIdleSize + " were initialized. Server: "
                                             + entry.getClient().getAddr());
                 initPromise.tryFailure(cause);
                 return;
@@ -93,7 +93,7 @@ public void operationComplete(Future<T> future) throws Exception {
                     releaseConnection(entry);
                     if (!future.isSuccess()) {
                         Throwable cause = new RedisConnectionException(
-                                "Can't init enough connections amount! Only " + initializedConnections.get() + " from " + minimumIdleSize + " were initialized. Server: "
+                                "Can't init enough connections amount! Only " + (minimumIdleSize - initializedConnections.get()) + " from " + minimumIdleSize + " were initialized. Server: "
                                                     + entry.getClient().getAddr(), future.cause());
                         initPromise.tryFailure(cause);
                         return;

File: src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -125,7 +125,7 @@ public void operationComplete(Future<RedisConnection> future) throws Exception {
 
                 RedisConnection connection = future.getNow();
                 Promise<RedisConnection> promise = newPromise();
-                connectListener.onConnect(promise, connection, NodeType.MASTER, config);
+                connectListener.onConnect(promise, connection, null, config);
                 promise.addListener(new FutureListener<RedisConnection>() {
                     @Override
                     public void operationComplete(Future<RedisConnection> future) throws Exception {

File: src/main/java/org/redisson/client/codec/StringCodec.java
Patch:
@@ -38,7 +38,9 @@ public byte[] encode(Object in) throws IOException {
     private final Decoder<Object> decoder = new Decoder<Object>() {
         @Override
         public Object decode(ByteBuf buf, State state) {
-            return buf.toString(CharsetUtil.UTF_8);
+            String str = buf.toString(CharsetUtil.UTF_8);
+            buf.readerIndex(buf.readableBytes());
+            return str;
         }
     };
 

File: src/test/java/org/redisson/RedissonSemaphoreTest.java
Patch:
@@ -207,7 +207,7 @@ public void run(RedissonClient redisson) {
 
     @Test
     public void testConcurrency_MultiInstance_1_permits() throws InterruptedException {
-        int iterations = 100;
+        int iterations = 30;
         final AtomicInteger lockedCounter = new AtomicInteger();
 
         RSemaphore s = redisson.getSemaphore("test");

File: src/test/java/org/redisson/RedissonMapCacheReactiveTest.java
Patch:
@@ -1,5 +1,7 @@
 package org.redisson;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -172,7 +174,7 @@ public void testExpiredIterator() throws InterruptedException {
 
         Thread.sleep(1000);
 
-        MatcherAssert.assertThat(toIterable(cache.keyIterator()), Matchers.contains("0", "2", "3"));
+        assertThat(toIterator(cache.keyIterator())).containsOnly("0", "2", "3");
     }
 
     @Test

File: src/main/java/org/redisson/reactive/RedissonMapCacheReactive.java
Patch:
@@ -30,6 +30,7 @@
 import org.redisson.api.RMapCacheReactive;
 import org.redisson.client.codec.Codec;
 import org.redisson.client.codec.LongCodec;
+import org.redisson.client.codec.ScanCodec;
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.client.protocol.RedisCommand.ValueType;
 import org.redisson.client.protocol.RedisCommands;
@@ -338,7 +339,7 @@ public Publisher<Long> fastRemove(K ... keys) {
 
     @Override
     Publisher<MapScanResult<ScanObjectEntry, ScanObjectEntry>> scanIteratorReactive(InetSocketAddress client, long startPos) {
-        return commandExecutor.evalReadReactive(client, getName(), codec, EVAL_HSCAN,
+        return commandExecutor.evalReadReactive(client, getName(), new ScanCodec(codec), EVAL_HSCAN,
                 "local result = {}; "
                 + "local res = redis.call('hscan', KEYS[1], ARGV[1]); "
                 + "for i, value in ipairs(res[2]) do "

File: src/main/java/org/redisson/RedissonScoredSortedSet.java
Patch:
@@ -28,6 +28,7 @@
 import java.util.NoSuchElementException;
 
 import org.redisson.client.codec.Codec;
+import org.redisson.client.codec.ScoredCodec;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommand;
 import org.redisson.client.protocol.RedisCommands;
@@ -218,7 +219,7 @@ public Double getScore(V o) {
 
     @Override
     public Future<Double> getScoreAsync(V o) {
-        return commandExecutor.readAsync(getName(), codec, RedisCommands.ZSCORE, getName(), o);
+        return commandExecutor.readAsync(getName(), new ScoredCodec(codec), RedisCommands.ZSCORE, getName(), o);
     }
 
     @Override

File: src/main/java/org/redisson/client/codec/ScanCodec.java
Patch:
@@ -26,7 +26,7 @@
 
 public class ScanCodec implements Codec {
 
-    public Codec delegate;
+    public final Codec delegate;
 
     public ScanCodec(Codec delegate) {
         super();

File: src/main/java/org/redisson/core/RAtomicDouble.java
Patch:
@@ -16,7 +16,7 @@
 package org.redisson.core;
 
 /**
- * Distributed alternative to the {@link java.util.concurrent.atomic.AtomicLong}
+ * Distributed alternative to the AtomicDouble
  *
  * @author Nikita Koksharov
  *

File: src/main/java/org/redisson/core/RBloomFilter.java
Patch:
@@ -51,7 +51,7 @@ public interface RBloomFilter<T> extends RExpirable {
     int getHashIterations();
 
     /**
-     * Calculates number of elements already added to Bloom filter.
+     * Calculates probabilistic number of elements already added to Bloom filter.
      *
      * @return
      */

File: src/main/java/org/redisson/reactive/RedissonMapCacheReactive.java
Patch:
@@ -41,6 +41,7 @@
 import org.redisson.client.protocol.decoder.NestedMultiDecoder;
 import org.redisson.client.protocol.decoder.ObjectListReplayDecoder;
 import org.redisson.client.protocol.decoder.ObjectMapReplayDecoder;
+import org.redisson.client.protocol.decoder.ScanObjectEntry;
 import org.redisson.client.protocol.decoder.TTLMapValueReplayDecoder;
 import org.redisson.command.CommandReactiveExecutor;
 import org.redisson.connection.decoder.CacheGetAllDecoder;
@@ -336,7 +337,7 @@ public Publisher<Long> fastRemove(K ... keys) {
     }
 
     @Override
-    Publisher<MapScanResult<Object, V>> scanIteratorReactive(InetSocketAddress client, long startPos) {
+    Publisher<MapScanResult<ScanObjectEntry, ScanObjectEntry>> scanIteratorReactive(InetSocketAddress client, long startPos) {
         return commandExecutor.evalReadReactive(client, getName(), codec, EVAL_HSCAN,
                 "local result = {}; "
                 + "local res = redis.call('hscan', KEYS[1], ARGV[1]); "

File: src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -131,7 +131,7 @@ protected void initEntry(MasterSlaveServersConfig config) {
 
     private Collection<Future<Void>> addMasterEntry(final ClusterPartition partition, ClusterServersConfig cfg, boolean skipLogging) {
         if (partition.isMasterFail()) {
-            log.warn("add master: {} for slot ranges: {} failed. Reason - server has FAIL flag", partition.getMasterAddress(), partition.getSlotRanges());
+            log.warn("Failed to add master: {} for slot ranges: {}. Reason - server has FAIL flag", partition.getMasterAddress(), partition.getSlotRanges());
             Future<Void> f = newSucceededFuture(null);
             return Collections.singletonList(f);
         }
@@ -143,7 +143,7 @@ private Collection<Future<Void>> addMasterEntry(final ClusterPartition partition
         }
         Map<String, String> params = connection.sync(RedisCommands.CLUSTER_INFO);
         if ("fail".equals(params.get("cluster_state"))) {
-            log.warn("add master: {} for slot ranges: {} failed. Reason - cluster_state:fail", partition.getMasterAddress(), partition.getSlotRanges());
+            log.warn("Failed to add master: {} for slot ranges: {}. Reason - cluster_state:fail", partition.getMasterAddress(), partition.getSlotRanges());
             Future<Void> f = newSucceededFuture(null);
             return Collections.singletonList(f);
         }

File: src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -176,7 +176,6 @@ public interface RedisCommands {
     RedisStrictCommand<Void> MSET = new RedisStrictCommand<Void>("MSET", new VoidReplayConvertor());
 
     RedisCommand<Boolean> HSET = new RedisCommand<Boolean>("HSET", new BooleanReplayConvertor(), 2, ValueType.MAP);
-    RedisStrictCommand<String> HINCRBYFLOAT = new RedisStrictCommand<String>("HINCRBYFLOAT");
     RedisCommand<MapScanResult<Object, Object>> HSCAN = new RedisCommand<MapScanResult<Object, Object>>("HSCAN", new NestedMultiDecoder(new ObjectMapReplayDecoder(), new MapScanResultReplayDecoder()), ValueType.MAP);
     RedisCommand<Map<Object, Object>> HGETALL = new RedisCommand<Map<Object, Object>>("HGETALL", new ObjectMapReplayDecoder(), ValueType.MAP);
     RedisCommand<List<Object>> HVALS = new RedisCommand<List<Object>>("HVALS", new ObjectListReplayDecoder<Object>(), ValueType.MAP_VALUE);

File: src/main/java/org/redisson/connection/PubSubConnectionEntry.java
Patch:
@@ -97,7 +97,7 @@ public void close() {
     public void removeListener(String channelName, int listenerId) {
         Queue<RedisPubSubListener> listeners = channelListeners.get(channelName);
         for (RedisPubSubListener listener : listeners) {
-            if (listener.hashCode() == listenerId) {
+            if (System.identityHashCode(listener) == listenerId) {
                 removeListener(channelName, listener);
                 break;
             }

File: src/test/java/org/redisson/RedissonTopicTest.java
Patch:
@@ -133,7 +133,7 @@ public void onMessage(String channel, Message msg) {
         topic1 = redisson.getTopic("topic1");
         topic1.publish(new Message("123"));
 
-        messageRecieved.await();
+        Assert.assertTrue(messageRecieved.await(5, TimeUnit.SECONDS));
 
         redisson.shutdown();
     }

File: src/main/java/org/redisson/Redisson.java
Patch:
@@ -437,7 +437,7 @@ public NodesGroup<Node> getNodesGroup() {
 
     public NodesGroup<ClusterNode> getClusterNodesGroup() {
         if (!config.isClusterConfig()) {
-            throw new IllegalStateException("Redisson not in cluster mode!");
+            throw new IllegalStateException("Redisson is not in cluster mode!");
         }
         return new RedisNodes<ClusterNode>(connectionManager);
     }

File: src/main/java/org/redisson/core/RBitSet.java
Patch:
@@ -24,7 +24,7 @@
  */
 public interface RBitSet extends RExpirable, RBitSetAsync {
 
-    int length();
+    long length();
 
     void set(long fromIndex, long toIndex, boolean value);
 
@@ -46,7 +46,7 @@ public interface RBitSet extends RExpirable, RBitSetAsync {
 
     byte[] toByteArray();
 
-    int cardinality();
+    long cardinality();
 
     void clear(long bitIndex);
 

File: src/main/java/org/redisson/core/RBitSetAsync.java
Patch:
@@ -28,7 +28,7 @@ public interface RBitSetAsync extends RExpirableAsync {
 
     Future<byte[]> toByteArrayAsync();
 
-    Future<Integer> lengthAsync();
+    Future<Long> lengthAsync();
 
     Future<Void> setAsync(long fromIndex, long toIndex, boolean value);
 
@@ -48,7 +48,7 @@ public interface RBitSetAsync extends RExpirableAsync {
 
     Future<Void> setAsync(long bitIndex, boolean value);
 
-    Future<Integer> cardinalityAsync();
+    Future<Long> cardinalityAsync();
 
     Future<Void> clearAsync(long bitIndex);
 

File: src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -92,6 +92,7 @@ public SentinelConnectionManager(SentinelServersConfig cfg, Config config) {
                 c.setMasterAddress(masterHost);
                 currentMaster.set(masterHost);
                 log.info("master: {} added", masterHost);
+                slaves.put(masterHost, true);
 
                 List<Map<String, String>> sentinelSlaves = connection.sync(StringCodec.INSTANCE, RedisCommands.SENTINEL_SLAVES, cfg.getMasterName());
                 for (Map<String, String> map : sentinelSlaves) {

File: src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -545,7 +545,6 @@ public void operationComplete(Future<PubSubConnectionEntry> future)
     protected void slaveDown(ClusterSlotRange slotRange, String host, int port, FreezeReason freezeReason) {
         MasterSlaveEntry entry = getEntry(slotRange);
         slaveDown(entry, host, port, freezeReason);
-        log.info("slave: {}:{} has down", host, port);
     }
 
     protected void changeMaster(ClusterSlotRange slotRange, String host, int port) {

File: src/main/java/org/redisson/connection/balancer/LoadBalancerManagerImpl.java
Patch:
@@ -90,6 +90,7 @@ public boolean unfreeze(String host, int port, FreezeReason freezeReason) {
             if ((freezeReason == FreezeReason.RECONNECT
                     && entry.getFreezeReason() == FreezeReason.RECONNECT)
                         || freezeReason != FreezeReason.RECONNECT) {
+                entry.resetFailedAttempts();
                 entry.setFreezed(false);
                 entry.setFreezeReason(null);
                 return true;

File: src/main/java/org/redisson/command/CommandAsyncService.java
Patch:
@@ -505,7 +505,7 @@ public void operationComplete(io.netty.util.concurrent.Future<R> future) throws
     }
 
     private <V, R> void releaseConnection(NodeSource source, AsyncDetails<V, R> details, RedisConnection connection) {
-        if (details.getAttemptPromise().isCancelled()) {
+        if (!details.getConnectionFuture().isSuccess()) {
             return;
         }
 

File: src/main/java/org/redisson/client/RedisClient.java
Patch:
@@ -88,7 +88,7 @@ public RedisConnection connect() {
             future.syncUninterruptibly();
             return new RedisConnection(this, future.channel());
         } catch (Exception e) {
-            throw new RedisConnectionException("Unable to connect to " + addr, e);
+            throw new RedisConnectionException("Unable to connect to: " + addr, e);
         }
     }
 
@@ -115,7 +115,7 @@ public RedisPubSubConnection connectPubSub() {
             future.syncUninterruptibly();
             return new RedisPubSubConnection(this, future.channel());
         } catch (Exception e) {
-            throw new RedisConnectionException("Unable to connect to " + addr, e);
+            throw new RedisConnectionException("Unable to connect to: " + addr, e);
         }
     }
 

File: src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -115,7 +115,7 @@ public SentinelConnectionManager(SentinelServersConfig cfg, Config config) {
                 }
                 break;
             } catch (RedisConnectionException e) {
-                log.warn("can't connect to sentinel", e);
+                log.warn("Can't connect to sentinel. {}", e.getMessage());
             } finally {
                 client.shutdownAsync();
             }

File: src/main/java/org/redisson/connection/SingleConnectionManager.java
Patch:
@@ -48,7 +48,7 @@ public SingleConnectionManager(SingleServerConfig cfg, Config config) {
             try {
                 this.currentMaster.set(InetAddress.getByName(cfg.getAddress().getHost()));
             } catch (UnknownHostException e) {
-                throw new RedisConnectionException("Unknown host", e);
+                throw new RedisConnectionException("Unknown host: " + cfg.getAddress().getHost(), e);
             }
             log.debug("DNS monitoring enabled; Current master set to {}", currentMaster.get());
             monitorDnsChange(cfg);

File: src/main/java/org/redisson/core/RCountDownLatch.java
Patch:
@@ -20,8 +20,8 @@
 /**
  * Distributed alternative to the {@link java.util.concurrent.CountDownLatch}
  *
- * It has a advantage over {@link java.util.concurrent.CountDownLatch} --
- * count can be reset via {@link #trySetCount}.
+ * It has an advantage over {@link java.util.concurrent.CountDownLatch} --
+ * count can be set via {@link #trySetCount} method.
  *
  * @author Nikita Koksharov
  *

File: src/test/java/org/redisson/BaseConcurrentTest.java
Patch:
@@ -11,7 +11,7 @@
 public abstract class BaseConcurrentTest extends BaseTest {
 
     protected void testMultiInstanceConcurrency(int iterations, final RedissonRunnable runnable) throws InterruptedException {
-        ExecutorService executor = Executors.newCachedThreadPool();
+        ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()*2);
 
         final Map<Integer, RedissonClient> instances = new HashMap<Integer, RedissonClient>();
         for (int i = 0; i < iterations; i++) {
@@ -51,7 +51,7 @@ public void run() {
     }
 
     protected void testSingleInstanceConcurrency(int iterations, final RedissonRunnable runnable) throws InterruptedException {
-        ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
+        ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()*2);
 
         final RedissonClient redisson = BaseTest.createInstance();
         long watch = System.currentTimeMillis();

File: src/test/java/org/redisson/RedissonScoredSortedSetReactiveTest.java
Patch:
@@ -326,7 +326,7 @@ public void testAddAndGet() throws InterruptedException {
         Assert.assertEquals(12, (double)score, 0);
 
         RScoredSortedSetReactive<Integer> set2 = redisson.getScoredSortedSet("simple", StringCodec.INSTANCE);
-        set2.add(100.2, 1);
+        sync(set2.add(100.2, 1));
 
         Double res2 = sync(set2.addScore(1, new Double(12.1)));
         Assert.assertTrue(new Double(112.3).compareTo(res2) == 0);

File: src/test/java/org/redisson/RedissonScriptReactiveTest.java
Patch:
@@ -55,7 +55,7 @@ public void testScriptFlush() {
 
     @Test
     public void testScriptLoad() {
-        redisson.getBucket("foo").set("bar");
+        sync(redisson.getBucket("foo").set("bar"));
         String r = sync(redisson.getScript().scriptLoad("return redis.call('get', 'foo')"));
         Assert.assertEquals("282297a0228f48cd3fc6a55de6316f31422f5d17", r);
         String r1 = sync(redisson.getScript().<String>evalSha(RScript.Mode.READ_ONLY, "282297a0228f48cd3fc6a55de6316f31422f5d17", RScript.ReturnType.VALUE, Collections.emptyList()));

File: src/main/java/org/redisson/core/RCountDownLatch.java
Patch:
@@ -123,9 +123,9 @@ public interface RCountDownLatch extends RObject {
 
     /**
      * Sets new count value only if previous count already has reached zero
-     * or not been setted at all.
+     * or is not set at all.
      *
-     * @param count the number of times {@link #countDown} must be invoked
+     * @param count - number of times {@link #countDown} must be invoked
      *        before threads can pass through {@link #await}
      * @return <code>true</code> if new count setted
      *         <code>false</code> if previous count has not reached zero

File: src/main/java/org/redisson/RedissonReadWriteLock.java
Patch:
@@ -37,8 +37,6 @@
  */
 public class RedissonReadWriteLock extends RedissonExpirable implements RReadWriteLock {
 
-    public static final Long unlockMessage = 0L;
-
     private final UUID id;
     private final CommandExecutor commandExecutor;
 

File: src/main/java/org/redisson/misc/ConnectionPool.java
Patch:
@@ -75,7 +75,9 @@ private void initConnections(final ClientConnectionsEntry entry, final Promise<V
         final AtomicInteger initializedConnections = new AtomicInteger(minimumIdleSize);
         for (int i = 0; i < minimumIdleSize; i++) {
             if ((checkFreezed && entry.isFreezed()) || !tryAcquireConnection(entry)) {
-                Throwable cause = new RedisConnectionException("Can't init enough connections amount! from " + entry.getClient().getAddr());
+                Throwable cause = new RedisConnectionException(
+                        "Can't init enough connections amount! " + initializedConnections.get() + " from " + minimumIdleSize + " was initialized. Server: "
+                                            + entry.getClient().getAddr());
                 initPromise.tryFailure(cause);
                 return;
             }

File: src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -140,7 +140,7 @@ public boolean tryLock() {
     }
 
     private Long tryLockInner() {
-        Long ttlRemaining = tryLockInner(LOCK_EXPIRATION_INTERVAL_SECONDS, TimeUnit.MILLISECONDS);
+        Long ttlRemaining = tryLockInner(LOCK_EXPIRATION_INTERVAL_SECONDS, TimeUnit.SECONDS);
         // lock acquired
         if (ttlRemaining == null) {
             scheduleExpirationRenewal();

File: src/main/java/org/redisson/RedissonExpirable.java
Patch:
@@ -43,7 +43,7 @@ public boolean expire(long timeToLive, TimeUnit timeUnit) {
 
     @Override
     public Future<Boolean> expireAsync(long timeToLive, TimeUnit timeUnit) {
-        return commandExecutor.writeAsync(getName(), StringCodec.INSTANCE, RedisCommands.PEXPIRE, getName(), timeUnit.toSeconds(timeToLive));
+        return commandExecutor.writeAsync(getName(), StringCodec.INSTANCE, RedisCommands.PEXPIRE, getName(), timeUnit.toMillis(timeToLive));
     }
 
     @Override

File: src/main/java/org/redisson/EvictionScheduler.java
Patch:
@@ -123,7 +123,7 @@ public void operationComplete(Future<Integer> future) throws Exception {
     private final ConcurrentMap<String, RedissonCacheTask> tasks = PlatformDependent.newConcurrentHashMap();
     private final CommandAsyncExecutor executor;
 
-    private final Map<String, Long> lastExpiredTime = PlatformDependent.newConcurrentHashMap();
+    private final ConcurrentMap<String, Long> lastExpiredTime = PlatformDependent.newConcurrentHashMap();
     private final int expireTaskExecutionDelay = 1000;
     private final int valuesAmountToClean = 100;
 

File: src/main/java/org/redisson/RedissonLexSortedSet.java
Patch:
@@ -187,7 +187,7 @@ private String value(String fromElement, boolean fromInclusive) {
 
     @Override
     public Future<Boolean> addAsync(String e) {
-        return addAsync(0, e);
+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.ZADD_BOOL_RAW, getName(), 0, e);
     }
 
     @Override
@@ -197,7 +197,7 @@ public Future<Boolean> addAllAsync(Collection<? extends String> c) {
             params.add(0);
             params.add(param);
         }
-        return commandExecutor.writeAsync(getName(), codec, RedisCommands.ZADD_BOOL, getName(), params.toArray());
+        return commandExecutor.writeAsync(getName(), codec, RedisCommands.ZADD_BOOL_RAW, getName(), params.toArray());
     }
 
     @Override

File: src/main/java/org/redisson/RedissonSetCache.java
Patch:
@@ -70,7 +70,6 @@ public class RedissonSetCache<V> extends RedissonExpirable implements RSetCache<
 
     private static final RedisCommand<Void> ADD_ALL = new RedisCommand<Void>("HMSET", new VoidReplayConvertor());
     private static final RedisCommand<Boolean> EVAL_ADD = new RedisCommand<Boolean>("EVAL", new BooleanReplayConvertor(), 5);
-    private static final RedisCommand<Boolean> EVAL_OBJECTS = new RedisCommand<Boolean>("EVAL", new BooleanReplayConvertor(), 4);
     private static final RedisCommand<Long> EVAL_REMOVE_EXPIRED = new RedisCommand<Long>("EVAL", 5);
     private static final RedisCommand<List<Object>> EVAL_CONTAINS_KEY = new RedisCommand<List<Object>>("EVAL", new ObjectListReplayDecoder<Object>());
     private static final RedisStrictCommand<Boolean> HDEL = new RedisStrictCommand<Boolean>("HDEL", new BooleanReplayConvertor());
@@ -394,7 +393,7 @@ public boolean containsAll(Collection<?> c) {
 
     @Override
     public Future<Boolean> containsAllAsync(Collection<?> c) {
-        return commandExecutor.evalReadAsync(getName(), codec, EVAL_OBJECTS,
+        return commandExecutor.evalReadAsync(getName(), codec, RedisCommands.EVAL_BOOLEAN_WITH_VALUES,
                 "local s = redis.call('hvals', KEYS[1]);" +
                         "for i = 0, table.getn(s), 1 do " +
                             "for j = 0, table.getn(ARGV), 1 do "

File: src/main/java/org/redisson/reactive/RedissonLexSortedSetReactive.java
Patch:
@@ -144,7 +144,7 @@ private String value(String fromElement, boolean fromInclusive) {
 
     @Override
     public Publisher<Long> add(String e) {
-        return commandExecutor.writeReactive(getName(), codec, RedisCommands.ZADD, getName(), 0, e);
+        return commandExecutor.writeReactive(getName(), codec, RedisCommands.ZADD_RAW, getName(), 0, e);
     }
 
     @Override
@@ -154,7 +154,7 @@ public Publisher<Long> addAll(Collection<? extends String> c) {
             params.add(0);
             params.add(param);
         }
-        return commandExecutor.writeReactive(getName(), codec, RedisCommands.ZADD, getName(), params.toArray());
+        return commandExecutor.writeReactive(getName(), codec, RedisCommands.ZADD_RAW, getName(), params.toArray());
     }
 
 }

File: src/test/java/org/redisson/RedissonBucketReactiveTest.java
Patch:
@@ -89,7 +89,7 @@ public void testSetDeleteNotExist() {
 
         Assert.assertTrue(sync(bucket.isExists()));
 
-        bucket.delete();
+        sync(bucket.delete());
 
         Assert.assertFalse(sync(bucket.isExists()));
     }

File: src/main/java/org/redisson/command/CommandAsyncExecutor.java
Patch:
@@ -37,8 +37,6 @@ public interface CommandAsyncExecutor {
 
     <V> V get(Future<V> future);
 
-    <T, R> Future<R> evalScriptReadAsync(String key, Codec codec, RedisCommand<T> evalCommandType, String script, List<Object> keys, Object ... params);
-
     <T, R> Future<R> writeAsync(Integer slot, Codec codec, RedisCommand<T> command, Object ... params);
 
     <T, R> Future<R> readAsync(InetSocketAddress client, String key, Codec codec, RedisCommand<T> command, Object ... params);

File: src/main/java/org/redisson/api/RMapCacheReactive.java
Patch:
@@ -24,7 +24,7 @@
  * {@link #put(Object, Object, long, TimeUnit)} or {@link #putIfAbsent(Object, Object, long, TimeUnit)}
  * And therefore has an complex lua-scripts inside.</p>
  *
- * <p>Redis doesn't support map entries eviction by design.
+ * <p>Current redis implementation doesnt have eviction functionality.
  * Thus entries are checked for TTL expiration during any key/value/entry read operation.
  * If key/value/entry expired then it doesn't returns and clean task runs asynchronous.
  * Clean task deletes removes 100 expired entries at once.

File: src/main/java/org/redisson/core/RMapCache.java
Patch:
@@ -22,7 +22,7 @@
  * {@link #put(Object, Object, long, TimeUnit)} or {@link #putIfAbsent(Object, Object, long, TimeUnit)}
  * And therefore has an complex lua-scripts inside.</p>
  *
- * <p>Redis doesn't support map entries eviction by design.
+ * <p>Current redis implementation doesnt have eviction functionality.
  * Thus entries are checked for TTL expiration during any key/value/entry read operation.
  * If key/value/entry expired then it doesn't returns and clean task runs asynchronous.
  * Clean task deletes removes 100 expired entries at once.

File: src/main/java/org/redisson/core/RMapCacheAsync.java
Patch:
@@ -24,7 +24,7 @@
  * {@link #put(Object, Object, long, TimeUnit)} or {@link #putIfAbsent(Object, Object, long, TimeUnit)}
  * And therefore has an complex lua-scripts inside.</p>
  *
- * <p>Redis doesn't support map entries eviction by design.
+ * <p>Current redis implementation doesnt have eviction functionality.
  * Thus entries are checked for TTL expiration during any key/value/entry read operation.
  * If key/value/entry expired then it doesn't returns and clean task runs asynchronous.
  * Clean task deletes removes 100 expired entries at once.

File: src/main/java/org/redisson/RedissonAtomicLong.java
Patch:
@@ -56,9 +56,9 @@ public Future<Boolean> compareAndSetAsync(long expect, long update) {
         return commandExecutor.evalWriteAsync(getName(), StringCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 "if redis.call('get', KEYS[1]) == ARGV[1] then "
                      + "redis.call('set', KEYS[1], ARGV[2]); "
-                     + "return true "
+                     + "return 1 "
                    + "else "
-                     + "return false end",
+                     + "return 0 end",
                 Collections.<Object>singletonList(getName()), expect, update);
     }
 

File: src/main/java/org/redisson/client/protocol/convertor/BooleanReplayConvertor.java
Patch:
@@ -19,6 +19,9 @@ public class BooleanReplayConvertor extends SingleConvertor<Boolean> {
 
     @Override
     public Boolean convert(Object obj) {
+        if (obj == null) {
+            return null;
+        }
         return Long.valueOf(1).equals(obj) || "OK".equals(obj);
     }
 

File: src/main/java/org/redisson/reactive/RedissonAtomicLongReactive.java
Patch:
@@ -47,9 +47,9 @@ public Publisher<Boolean> compareAndSet(long expect, long update) {
         return commandExecutor.evalWriteReactive(getName(), StringCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,
                 "if redis.call('get', KEYS[1]) == ARGV[1] then "
                      + "redis.call('set', KEYS[1], ARGV[2]); "
-                     + "return true "
+                     + "return 1 "
                    + "else "
-                     + "return false end",
+                     + "return 0 end",
                 Collections.<Object>singletonList(getName()), expect, update);
     }
 

File: src/main/java/org/redisson/client/protocol/RedisCommand.java
Patch:
@@ -165,7 +165,7 @@ public RedisCommand(String name, MultiDecoder<R> replayMultiDecoder, int objectP
     }
 
     public RedisCommand(String name, MultiDecoder<R> replayMultiDecoder) {
-        this(name, replayMultiDecoder, null, -1);
+        this(name, replayMultiDecoder, -1);
     }
 
     public RedisCommand(String name, MultiDecoder<R> replayMultiDecoder, Convertor<R> convertor) {

File: src/test/java/org/redisson/RedissonBucketReactiveTest.java
Patch:
@@ -76,7 +76,7 @@ public void testSetExist() {
         sync(bucket.set(value));
         Assert.assertEquals(value, sync(bucket.get()));
 
-        Assert.assertTrue(sync(bucket.exists()));
+        Assert.assertTrue(sync(bucket.isExists()));
     }
 
     @Test
@@ -87,11 +87,11 @@ public void testSetDeleteNotExist() {
         sync(bucket.set(value));
         Assert.assertEquals(value, sync(bucket.get()));
 
-        Assert.assertTrue(sync(bucket.exists()));
+        Assert.assertTrue(sync(bucket.isExists()));
 
         bucket.delete();
 
-        Assert.assertFalse(sync(bucket.exists()));
+        Assert.assertFalse(sync(bucket.isExists()));
     }
 
     @Test

File: src/main/java/org/redisson/Redisson.java
Patch:
@@ -122,13 +122,13 @@ public static RedissonClient create(Config config) {
      *
      * @return Redisson instance
      */
-    public static RedissonClient createReactive() {
+    public static RedissonReactiveClient createReactive() {
         Config config = new Config();
         config.useSingleServer().setAddress("127.0.0.1:6379");
 //        config.useMasterSlaveConnection().setMasterAddress("127.0.0.1:6379").addSlaveAddress("127.0.0.1:6389").addSlaveAddress("127.0.0.1:6399");
 //        config.useSentinelConnection().setMasterName("mymaster").addSentinelAddress("127.0.0.1:26389", "127.0.0.1:26379");
 //        config.useClusterServers().addNodeAddress("127.0.0.1:7000");
-        return create(config);
+        return createReactive(config);
     }
 
     /**

File: src/test/java/org/redisson/BaseTest.java
Patch:
@@ -6,7 +6,7 @@
 
 public abstract class BaseTest {
 
-    protected static Redisson redisson;
+    protected static RedissonClient redisson;
 
     @BeforeClass
     public static void beforeClass() {
@@ -35,7 +35,7 @@ public static Config createConfig() {
         return config;
     }
 
-    public static Redisson createInstance() {
+    public static RedissonClient createInstance() {
         Config config = createConfig();
         return Redisson.create(config);
     }

File: src/test/java/org/redisson/RedissonCountDownLatchConcurrentTest.java
Patch:
@@ -15,7 +15,7 @@ public class RedissonCountDownLatchConcurrentTest {
     public void testSingleCountDownAwait_SingleInstance() throws InterruptedException {
         final int iterations = Runtime.getRuntime().availableProcessors()*3;
 
-        Redisson redisson = BaseTest.createInstance();
+        RedissonClient redisson = BaseTest.createInstance();
         final RCountDownLatch latch = redisson.getCountDownLatch("latch");
         latch.trySetCount(iterations);
 

File: src/test/java/org/redisson/RedissonRunnable.java
Patch:
@@ -2,6 +2,6 @@
 
 public interface RedissonRunnable {
 
-    void run(Redisson redisson);
+    void run(RedissonClient redisson);
 
 }

File: src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -22,7 +22,7 @@ public void testSer() {
         Config config = new Config();
         config.useSingleServer().setAddress("127.0.0.1:6379");
         config.setCodec(new SerializationCodec());
-        Redisson r = Redisson.create(config);
+        RedissonClient r = Redisson.create(config);
         r.getMap("test").put("1", new Dummy());
     }
 

File: src/test/java/org/redisson/RedissonTwoLockedThread.java
Patch:
@@ -26,7 +26,7 @@ public static Iterable<Object[]> data() {
     @Parameterized.Parameter(0)
     public Codec codec;
 
-    private Redisson redisson;
+    private RedissonClient redisson;
 
     @Before
     public void before() {

File: src/test/java/org/redisson/RedissonKeysReactiveTest.java
Patch:
@@ -36,7 +36,7 @@ public void testRandomKey() {
         MatcherAssert.assertThat(sync(redisson.getKeys().randomKey()), Matchers.isOneOf("test1", "test2"));
         sync(redisson.getKeys().delete("test1"));
         Assert.assertEquals(sync(redisson.getKeys().randomKey()), "test2");
-        redisson.flushdb();
+        sync(redisson.getKeys().flushdb());
         Assert.assertNull(sync(redisson.getKeys().randomKey()));
     }
 

File: src/main/java/org/redisson/core/RBlockingQueue.java
Patch:
@@ -27,7 +27,7 @@
 public interface RBlockingQueue<V> extends BlockingQueue<V>, RQueue<V>, RBlockingQueueAsync<V> {
 
     /**
-     * Retrieves and removes the head of this queue in async mode, waiting up to the
+     * Retrieves and removes first available head of <b>any</b> queue, waiting up to the
      * specified wait time if necessary for an element to become available
      * in any of defined queues <b>including</b> queue own.
      *

File: src/main/java/org/redisson/core/RBlockingQueueAsync.java
Patch:
@@ -26,10 +26,10 @@
  * @author Nikita Koksharov
  * @param <V> the type of elements held in this collection
  */
-public interface RBlockingQueueAsync<V> extends RQueueAsync<V>, RExpirableAsync {
+public interface RBlockingQueueAsync<V> extends RQueueAsync<V> {
 
     /**
-     * Retrieves and removes the head of this queue in async mode, waiting up to the
+     * Retrieves and removes first available head of <b>any</b> queue in async mode, waiting up to the
      * specified wait time if necessary for an element to become available
      * in any of defined queues <b>including</b> queue own.
      *

File: src/main/java/org/redisson/RedissonList.java
Patch:
@@ -513,6 +513,7 @@ public void add(V e) {
         };
     }
 
+    // TODO use RedissonList with bounds
     @Override
     public List<V> subList(int fromIndex, int toIndex) {
         int size = size();

File: src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -109,7 +109,7 @@ public interface RedisCommands {
     RedisCommand<Object> LINDEX = new RedisCommand<Object>("LINDEX");
     RedisCommand<Object> LINSERT = new RedisCommand<Object>("LINSERT", 3, ValueType.OBJECTS);
     RedisStrictCommand<Integer> LLEN_INT = new RedisStrictCommand<Integer>("LLEN", new IntegerReplayConvertor());
-    RedisStrictCommand<Integer> LLEN = new RedisStrictCommand<Integer>("LLEN", new IntegerReplayConvertor());
+    RedisStrictCommand<Long> LLEN = new RedisStrictCommand<Long>("LLEN");
     RedisStrictCommand<Boolean> LTRIM = new RedisStrictCommand<Boolean>("LTRIM", new BooleanReplayConvertor());
 
     RedisStrictCommand<Boolean> EXPIRE = new RedisStrictCommand<Boolean>("EXPIRE", new BooleanReplayConvertor());

File: src/main/java/org/redisson/core/RCollectionReactive.java
Patch:
@@ -36,7 +36,7 @@ public interface RCollectionReactive<V> extends RExpirableReactive {
 
     Single<Long> size();
 
-    Single<Boolean> add(V e);
+    Single<Long> add(V e);
 
     Single<Long> addAll(Collection<? extends V> c);
 

File: src/main/java/org/redisson/core/RListReactive.java
Patch:
@@ -27,6 +27,7 @@
  *
  * @param <V> the type of elements held in this collection
  */
+// TODO add sublist support
 public interface RListReactive<V> extends RCollectionReactive<V> {
 
     Observable<V> descendingIterator();

File: src/main/java/org/redisson/connection/IdleConnectionWatcher.java
Patch:
@@ -84,7 +84,7 @@ public void operationComplete(Future<Void> future) throws Exception {
     }
 
     private boolean validateAmount(Entry entry) {
-        return entry.maximumAmount - entry.freeConnectionsCounter.get() + entry.connections.size() >= entry.minimumAmount;
+        return entry.maximumAmount - entry.freeConnectionsCounter.get() + entry.connections.size() > entry.minimumAmount;
     }
 
     public void add(int minimumAmount, int maximumAmount, Collection<? extends RedisConnection> connections, AtomicInteger freeConnectionsCounter) {

File: src/main/java/org/redisson/ClusterServersConfig.java
Patch:
@@ -34,7 +34,7 @@ public class ClusterServersConfig extends BaseMasterSlaveServersConfig<ClusterSe
     private int scanInterval = 1000;
 
     /**
-     * Use cluster slave nodes for read-operations
+     * Whether to use cluster slave nodes for read-operations
      */
     private boolean readFromSlaves = true;
 

File: src/main/java/org/redisson/client/handler/CommandsQueue.java
Patch:
@@ -42,7 +42,7 @@ public class CommandsQueue extends ChannelDuplexHandler {
 
     private final Queue<QueueCommandHolder> queue = PlatformDependent.newMpscQueue();
 
-    public void sendNextCommand(ChannelHandlerContext ctx) throws Exception {
+    public void sendNextCommand(ChannelHandlerContext ctx) {
         ctx.channel().attr(CommandsQueue.REPLAY).remove();
         queue.poll();
         sendData(ctx);
@@ -64,7 +64,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
         }
     }
 
-    private void sendData(final ChannelHandlerContext ctx) throws Exception {
+    private void sendData(final ChannelHandlerContext ctx) {
         QueueCommandHolder command = queue.peek();
         if (command != null && command.getSended().compareAndSet(false, true)) {
             QueueCommand data = command.getCommand();

File: src/test/java/org/redisson/RedissonTopicTest.java
Patch:
@@ -68,8 +68,8 @@ public void onMessage(String channel, Message msg) {
                 messageRecieved.countDown();
                 Message m = new Message("test");
                 if (!msg.equals(m)) {
-                    topic1.publishAsync(m);
-                    topic2.publishAsync(m);
+                    topic1.publish(m);
+                    topic2.publish(m);
                 }
             }
         });

File: src/main/java/org/redisson/connection/BaseLoadBalancer.java
Patch:
@@ -118,7 +118,7 @@ public Collection<RedisPubSubConnection> freeze(String host, int port, FreezeRea
 
         // close all pub/sub connections
         while (true) {
-            RedisPubSubConnection connection = connectionEntry.pollFreeSubscribeConnection();
+            RedisPubSubConnection connection = connectionEntry.pollSubscribeConnection();
             if (connection == null) {
                 break;
             }

File: src/main/java/org/redisson/connection/SubscribesConnectionEntry.java
Patch:
@@ -41,7 +41,7 @@ public Queue<RedisPubSubConnection> getAllSubscribeConnections() {
         return allSubscribeConnections;
     }
 
-    public RedisPubSubConnection pollFreeSubscribeConnection() {
+    public RedisPubSubConnection pollSubscribeConnection() {
         return freeSubscribeConnections.poll();
     }
 

File: src/main/java/org/redisson/misc/PubSubConnectionPoll.java
Patch:
@@ -33,7 +33,7 @@ public PubSubConnectionPoll(MasterSlaveServersConfig config,
 
     @Override
     protected RedisPubSubConnection poll(SubscribesConnectionEntry entry) {
-        return entry.pollFreeSubscribeConnection();
+        return entry.pollSubscribeConnection();
     }
 
     @Override

File: src/main/java/org/redisson/connection/ConnectionEntry.java
Patch:
@@ -98,10 +98,10 @@ public int getFreeAmount() {
 
     public boolean tryAcquireConnection() {
         while (true) {
-            if (connectionsCounter.get() == 0) {
+            int value = connectionsCounter.get();
+            if (value == 0) {
                 return false;
             }
-            int value = connectionsCounter.get();
             if (connectionsCounter.compareAndSet(value, value - 1)) {
                 return true;
             }

File: src/main/java/org/redisson/misc/ConnectionPool.java
Patch:
@@ -215,7 +215,7 @@ private void promiseFailure(SubscribesConnectionEntry entry, Promise<T> promise,
             }
         }
 
-        promises.addFirst(promise);
+        promises.add(promise);
 //        promise.tryFailure(cause);
     }
 
@@ -248,7 +248,7 @@ private void promiseFailure(SubscribesConnectionEntry entry, Promise<T> promise,
 
         releaseConnection(entry);
 
-        promises.addFirst(promise);
+        promises.add(promise);
 //        RedisConnectionException cause = new RedisConnectionException(conn + " is not active!");
 //        promise.tryFailure(cause);
     }

File: src/main/java/org/redisson/client/protocol/decoder/StringMapDataDecoder.java
Patch:
@@ -32,7 +32,9 @@ public Map<String, String> decode(ByteBuf buf, State state) {
         Map<String, String> result = new HashMap<String, String>();
         for (String entry : value.split("\r\n|\n")) {
             String[] parts = entry.split(":");
-            result.put(parts[0], parts[1]);
+            if (parts.length == 2) {
+                result.put(parts[0], parts[1]);
+            }
         }
         return result;
     }

File: src/main/java/org/redisson/connection/ConnectionEntry.java
Patch:
@@ -35,7 +35,7 @@ public class ConnectionEntry {
 
     final Logger log = LoggerFactory.getLogger(getClass());
 
-    public enum FreezeReason {MANAGER, RECONNECT}
+    public enum FreezeReason {MANAGER, RECONNECT, SYSTEM}
 
     private volatile boolean freezed;
     private FreezeReason freezeReason;
@@ -127,6 +127,7 @@ public Future<RedisConnection> connect(final MasterSlaveServersConfig config) {
             @Override
             public void operationComplete(Future<RedisConnection> future) throws Exception {
                 if (!future.isSuccess()) {
+                    connectionFuture.tryFailure(future.cause());
                     return;
                 }
                 RedisConnection conn = future.getNow();
@@ -161,6 +162,7 @@ public Future<RedisPubSubConnection> connectPubSub(final MasterSlaveServersConfi
             @Override
             public void operationComplete(Future<RedisPubSubConnection> future) throws Exception {
                 if (!future.isSuccess()) {
+                    connectionFuture.tryFailure(future.cause());
                     return;
                 }
                 RedisPubSubConnection conn = future.getNow();

File: src/main/java/org/redisson/CommandExecutorService.java
Patch:
@@ -438,7 +438,7 @@ public void run(Timeout timeout) throws Exception {
             }
         };
 
-        ex.set(new RedisTimeoutException());
+        ex.set(new RedisTimeoutException("Command execution timeout for " + command + " with params " + Arrays.toString(params)));
         final Timeout timeout = connectionManager.getTimer().newTimeout(retryTimerTask, connectionManager.getConfig().getTimeout(), TimeUnit.MILLISECONDS);
 
         final Future<RedisConnection> connectionFuture;

File: src/main/java/org/redisson/client/protocol/RedisCommand.java
Patch:
@@ -226,7 +226,7 @@ public ValueType getOutParamType() {
 
     @Override
     public String toString() {
-        return "RedisCommand [" + name + " " + subName != null ? subName : "" + "]";
+        return "RedisCommand [" + name + (subName != null ? " " + subName : "") + "]";
     }
 
 }

File: src/test/java/org/redisson/RedissonCodecTest.java
Patch:
@@ -1,5 +1,6 @@
 package org.redisson;
 
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
@@ -92,7 +93,7 @@ public void test() {
         a.put("boolt", true);
         a.put("boolf", false);
         a.put("string", "testString");
-        a.put("array", Arrays.asList(1, 2.0, "adsfasdfsdf"));
+        a.put("array", new ArrayList<Object>(Arrays.asList(1, 2.0, "adsfasdfsdf")));
 
         map.fastPut(1, a);
         Map<String, Object> resa = map.get(1);
@@ -111,7 +112,7 @@ public void test() {
         Assert.assertFalse(set.contains(new TestObject("1", "9")));
     }
 
-//    @Test
+    @Test
     public void testKryo() {
         Config config = createConfig();
         config.setCodec(kryoCodec);

File: src/main/java/org/redisson/cluster/ClusterConnectionManager.java
Patch:
@@ -93,7 +93,7 @@ private RedisConnection connect(ClusterServersConfig cfg, URI addr) {
         } catch (Exception e) {
             log.error(e.getMessage(), e);
         }
-        if (!connection.isActive()) {
+        if (connection != null && !connection.isActive()) {
             log.warn("connection for {} is not active!", connection.getRedisClient().getAddr());
             connection.closeAsync();
             connection = null;

File: src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -113,7 +113,7 @@ public interface RedisCommands {
     RedisStrictCommand<Void> PFMERGE = new RedisStrictCommand<Void>("PFMERGE", new VoidReplayConvertor());
 
     RedisCommand<Long> RPOP = new RedisCommand<Long>("RPOP");
-    RedisCommand<Long> LPUSH = new RedisCommand<Long>("LPUSH");
+    RedisCommand<Long> LPUSH = new RedisCommand<Long>("LPUSH", 2);
     RedisCommand<List<Object>> LRANGE = new RedisCommand<List<Object>>("LRANGE", new ObjectListReplayDecoder<Object>());
     RedisCommand<Long> RPUSH = new RedisCommand<Long>("RPUSH", 2, ValueType.OBJECTS);
     RedisCommand<Boolean> RPUSH_BOOLEAN = new RedisCommand<Boolean>("RPUSH", new TrueReplayConvertor(), 2, ValueType.OBJECTS);

File: src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -30,6 +30,7 @@
 import org.redisson.client.RedisConnection;
 import org.redisson.client.RedisConnectionException;
 import org.redisson.client.RedisPubSubConnection;
+import org.redisson.client.codec.Codec;
 import org.redisson.client.codec.StringCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.pubsub.PubSubType;
@@ -84,7 +85,7 @@ public SentinelConnectionManager(SentinelServersConfig cfg, Config config) {
                 currentMaster.set(masterHost);
                 log.info("master: {} added", masterHost);
 
-                List<Map<String, String>> sentinelSlaves = connection.sync(RedisCommands.SENTINEL_SLAVES, cfg.getMasterName());
+                List<Map<String, String>> sentinelSlaves = connection.sync(StringCodec.INSTANCE, RedisCommands.SENTINEL_SLAVES, cfg.getMasterName());
                 for (Map<String, String> map : sentinelSlaves) {
                     if (map.isEmpty()) {
                         continue;

File: src/main/java/org/redisson/RedissonLexSortedSet.java
Patch:
@@ -45,7 +45,7 @@ public int removeRangeHeadByLex(String toElement, boolean toInclusive) {
     @Override
     public Future<Integer> removeRangeHeadByLexAsync(String toElement, boolean toInclusive) {
         String toValue = value(toElement, toInclusive);
-        return commandExecutor.readAsync(getName(), StringCodec.INSTANCE, RedisCommands.ZREMRANGEBYLEX, getName(), "-", toValue);
+        return commandExecutor.writeAsync(getName(), StringCodec.INSTANCE, RedisCommands.ZREMRANGEBYLEX, getName(), "-", toValue);
     }
 
     @Override
@@ -56,15 +56,15 @@ public int removeRangeTailByLex(String fromElement, boolean fromInclusive) {
     @Override
     public Future<Integer> removeRangeTailByLexAsync(String fromElement, boolean fromInclusive) {
         String fromValue = value(fromElement, fromInclusive);
-        return commandExecutor.readAsync(getName(), StringCodec.INSTANCE, RedisCommands.ZREMRANGEBYLEX, getName(), fromValue, "+");
+        return commandExecutor.writeAsync(getName(), StringCodec.INSTANCE, RedisCommands.ZREMRANGEBYLEX, getName(), fromValue, "+");
     }
 
     @Override
     public Future<Integer> removeRangeByLexAsync(String fromElement, boolean fromInclusive, String toElement, boolean toInclusive) {
         String fromValue = value(fromElement, fromInclusive);
         String toValue = value(toElement, toInclusive);
 
-        return commandExecutor.readAsync(getName(), StringCodec.INSTANCE, RedisCommands.ZREMRANGEBYLEX, getName(), fromValue, toValue);
+        return commandExecutor.writeAsync(getName(), StringCodec.INSTANCE, RedisCommands.ZREMRANGEBYLEX, getName(), fromValue, toValue);
     }
 
     @Override

File: src/main/java/org/redisson/CommandExecutorService.java
Patch:
@@ -26,7 +26,6 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.redisson.CommandBatchExecutorService.CommandEntry;
 import org.redisson.client.RedisAskException;
 import org.redisson.client.RedisClient;
 import org.redisson.client.RedisConnection;

File: src/main/java/org/redisson/connection/BaseLoadBalancer.java
Patch:
@@ -127,7 +127,7 @@ public Future<RedisConnection> getConnection(RedisClient client) {
         if (entry != null) {
             return entries.get(entry);
         }
-        RedisConnectionException exception = new RedisConnectionException("Can't find entry for " + client);
+        RedisConnectionException exception = new RedisConnectionException("Can't find entry for " + client.getAddr());
         return connectionManager.getGroup().next().newFailedFuture(exception);
     }
 

File: src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -102,7 +102,7 @@ public SentinelConnectionManager(SentinelServersConfig cfg, Config config) {
                 }
                 break;
             } catch (RedisConnectionException e) {
-                // skip
+                log.warn("can't connect to sentinel", e);
             } finally {
                 client.shutdownAsync();
             }

File: src/main/java/org/redisson/misc/ConnectionPool.java
Patch:
@@ -85,7 +85,7 @@ public Future<T> get(SubscribesConnectionEntry entry) {
             return promise;
         }
 
-        RedisConnectionException exception = new RedisConnectionException("Can't aquire connection for " + entry.getClient());
+        RedisConnectionException exception = new RedisConnectionException("Can't aquire connection to " + entry.getClient().getAddr());
         return executor.newFailedFuture(exception);
     }
 

File: src/main/java/org/redisson/CommandBatchExecutorService.java
Patch:
@@ -231,7 +231,7 @@ public void operationComplete(Future<RedisConnection> connFuture) throws Excepti
                     public void operationComplete(ChannelFuture future) throws Exception {
                         if (!future.isSuccess()) {
                             timeout.cancel();
-                            ex.set(new WriteRedisConnectionException("channel: " + future.channel() + " has been closed"));
+                            ex.set(new WriteRedisConnectionException("Can't write commands batch to channel: " + future.channel(), future.cause()));
                             connectionManager.getTimer().newTimeout(retryTimerTask, connectionManager.getConfig().getRetryInterval(), TimeUnit.MILLISECONDS);
                         }
                     }

File: src/main/java/org/redisson/CommandBatchExecutorService.java
Patch:
@@ -231,7 +231,7 @@ public void operationComplete(Future<RedisConnection> connFuture) throws Excepti
                     public void operationComplete(ChannelFuture future) throws Exception {
                         if (!future.isSuccess()) {
                             timeout.cancel();
-                            ex.set(new WriteRedisConnectionException("channel: " + future.channel() + " closed"));
+                            ex.set(new WriteRedisConnectionException("channel: " + future.channel() + " has been closed"));
                             connectionManager.getTimer().newTimeout(retryTimerTask, connectionManager.getConfig().getRetryInterval(), TimeUnit.MILLISECONDS);
                         }
                     }

File: src/main/java/org/redisson/CommandExecutorService.java
Patch:
@@ -493,7 +493,7 @@ public void operationComplete(ChannelFuture future) throws Exception {
                                 return;
                             }
                             ex.set(new WriteRedisConnectionException(
-                                    "Can't send command: " + command + ", params: " + params + ", channel: " + future.channel(), future.cause()));
+                                    "Can't write command: " + command + ", params: " + params + " to channel: " + future.channel(), future.cause()));
                             connectionManager.getTimer().newTimeout(retryTimerTask, connectionManager.getConfig().getRetryInterval(), TimeUnit.MILLISECONDS);
                         }
                     }

File: src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -150,7 +150,7 @@ public interface RedisCommands {
     RedisCommand<Boolean> HEXISTS = new RedisCommand<Boolean>("HEXISTS", new BooleanReplayConvertor(), 2, ValueType.MAP_KEY);
     RedisStrictCommand<Integer> HLEN = new RedisStrictCommand<Integer>("HLEN", new IntegerReplayConvertor());
     RedisCommand<Set<Object>> HKEYS = new RedisCommand<Set<Object>>("HKEYS", new ObjectSetReplayDecoder(), ValueType.MAP_KEY);
-    RedisCommand<String> HMSET = new RedisCommand<String>("HMSET", new StringReplayDecoder(), 1, ValueType.MAP);
+    RedisCommand<String> HMSET = new RedisCommand<String>("HMSET", new StringReplayDecoder(), 2, ValueType.MAP);
     RedisCommand<List<Object>> HMGET = new RedisCommand<List<Object>>("HMGET", new ObjectListReplayDecoder<Object>(), 2, ValueType.MAP_KEY, ValueType.MAP_VALUE);
     RedisCommand<Object> HGET = new RedisCommand<Object>("HGET", 2, ValueType.MAP_KEY, ValueType.MAP_VALUE);
     RedisCommand<Long> HDEL = new RedisStrictCommand<Long>("HDEL", 2, ValueType.MAP_KEY);

File: src/main/java/org/redisson/core/RMapAsync.java
Patch:
@@ -16,6 +16,7 @@
 package org.redisson.core;
 
 import java.util.Collection;
+import java.util.Map;
 import java.util.Set;
 
 import io.netty.util.concurrent.Future;
@@ -30,6 +31,8 @@
  */
 public interface RMapAsync<K, V> extends RExpirableAsync {
 
+    Future<Void> putAllAsync(Map<? extends K, ? extends V> map);
+
     Future<V> addAndGetAsync(K key, Number value);
 
     Future<Collection<V>> valuesAsync();

File: src/main/java/org/redisson/RedissonCountDownLatch.java
Patch:
@@ -97,9 +97,9 @@ public void onMessage(String channel, Integer message) {
 
             @Override
             public boolean onStatus(PubSubType type, String channel) {
-                if (channel.equals(getChannelName()) && !value.getPromise().isSuccess()
+                if (channel.equals(getChannelName())
                         && type == PubSubType.SUBSCRIBE) {
-                    value.getPromise().setSuccess(value);
+                    value.getPromise().trySuccess(value);
                     return true;
                 }
                 return false;

File: src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -286,7 +286,7 @@ private MapScanResult<Object, V> scanIterator(RedisClient client, long startPos)
         return commandExecutor.read(client, getName(), codec, RedisCommands.HSCAN, getName(), startPos);
     }
 
-    private Iterator<Map.Entry<K, V>> iterator() {
+    public Iterator<Map.Entry<K, V>> iterator() {
         return new Iterator<Map.Entry<K, V>>() {
 
             private Iterator<Map.Entry<K, V>> iter;

File: src/main/java/org/redisson/RedissonCountDownLatch.java
Patch:
@@ -175,7 +175,7 @@ public void countDown() {
             return;
         }
 
-        commandExecutor.evalWrite(getName(), RedisCommands.EVAL_BOOLEAN,
+        commandExecutor.evalWrite(getName(), RedisCommands.EVAL_BOOLEAN_R1,
                 "local v = redis.call('decr', KEYS[1]);" +
                         "if v <= 0 then redis.call('del', KEYS[1]) end;" +
                         "if v == 0 then redis.call('publish', ARGV[2], ARGV[1]) end;" +
@@ -206,14 +206,14 @@ private long getCountInner() {
 
     @Override
     public boolean trySetCount(long count) {
-        return commandExecutor.evalWrite(getName(), RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWrite(getName(), RedisCommands.EVAL_BOOLEAN_R1,
                 "if redis.call('exists', KEYS[1]) == 0 then redis.call('set', KEYS[1], ARGV[2]); redis.call('publish', ARGV[3], ARGV[1]); return true else return false end",
                  Collections.<Object>singletonList(getName()), newCountMessage, count, getChannelName());
     }
 
     @Override
     public Future<Boolean> deleteAsync() {
-        return commandExecutor.evalWriteAsync(getName(), RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWriteAsync(getName(), RedisCommands.EVAL_BOOLEAN_R1,
                 "if redis.call('del', KEYS[1]) == 1 then redis.call('publish', ARGV[2], ARGV[1]); return true else return false end",
                  Collections.<Object>singletonList(getName()), newCountMessage, getChannelName());
     }

File: src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -312,7 +312,7 @@ public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
 
     @Override
     public void unlock() {
-        Boolean opStatus = commandExecutor.evalWrite(getName(), RedisCommands.EVAL_BOOLEAN,
+        Boolean opStatus = commandExecutor.evalWrite(getName(), RedisCommands.EVAL_BOOLEAN_R2,
                 "local v = redis.call('get', KEYS[1]); " +
                                 "if (v == false) then " +
                                 "  redis.call('publish', ARGV[4], ARGV[2]); " +
@@ -355,7 +355,7 @@ public void forceUnlock() {
 
     private Future<Boolean> forceUnlockAsync() {
         stopRefreshTask();
-        return commandExecutor.evalWriteAsync(getName(), RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWriteAsync(getName(), RedisCommands.EVAL_BOOLEAN_R1,
                 "redis.call('del', KEYS[1]); redis.call('publish', ARGV[2], ARGV[1]); return true",
                         Collections.<Object>singletonList(getName()), unlockMessage, getChannelName());
     }

File: src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -120,6 +120,8 @@ public interface RedisCommands {
     RedisStrictCommand<List<Boolean>> SCRIPT_EXISTS = new RedisStrictCommand<List<Boolean>>("SCRIPT", "EXISTS", new ObjectListReplayDecoder<Boolean>(), new BooleanReplayConvertor());
 
     RedisStrictCommand<Boolean> EVAL_BOOLEAN = new RedisStrictCommand<Boolean>("EVAL", new BooleanReplayConvertor());
+    RedisStrictCommand<Boolean> EVAL_BOOLEAN_R1 = new RedisStrictCommand<Boolean>("EVAL", new BooleanReplayConvertor(), 4);
+    RedisStrictCommand<Boolean> EVAL_BOOLEAN_R2 = new RedisStrictCommand<Boolean>("EVAL", new BooleanReplayConvertor(), 5);
     RedisStrictCommand<String> EVAL_STRING = new RedisStrictCommand<String>("EVAL", new StringReplayDecoder());
     RedisStrictCommand<Long> EVAL_INTEGER = new RedisStrictCommand<Long>("EVAL");
     RedisCommand<List<Object>> EVAL_LIST = new RedisCommand<List<Object>>("EVAL", new ObjectListReplayDecoder<Object>());

File: src/main/java/org/redisson/RedissonCountDownLatch.java
Patch:
@@ -175,7 +175,7 @@ public void countDown() {
             return;
         }
 
-        commandExecutor.evalWrite(getName(), RedisCommands.EVAL_BOOLEAN,
+        commandExecutor.evalWrite(getName(), RedisCommands.EVAL_BOOLEAN_R1,
                 "local v = redis.call('decr', KEYS[1]);" +
                         "if v <= 0 then redis.call('del', KEYS[1]) end;" +
                         "if v == 0 then redis.call('publish', ARGV[2], ARGV[1]) end;" +
@@ -206,14 +206,14 @@ private long getCountInner() {
 
     @Override
     public boolean trySetCount(long count) {
-        return commandExecutor.evalWrite(getName(), RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWrite(getName(), RedisCommands.EVAL_BOOLEAN_R1,
                 "if redis.call('exists', KEYS[1]) == 0 then redis.call('set', KEYS[1], ARGV[2]); redis.call('publish', ARGV[3], ARGV[1]); return true else return false end",
                  Collections.<Object>singletonList(getName()), newCountMessage, count, getChannelName());
     }
 
     @Override
     public Future<Boolean> deleteAsync() {
-        return commandExecutor.evalWriteAsync(getName(), RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWriteAsync(getName(), RedisCommands.EVAL_BOOLEAN_R1,
                 "if redis.call('del', KEYS[1]) == 1 then redis.call('publish', ARGV[2], ARGV[1]); return true else return false end",
                  Collections.<Object>singletonList(getName()), newCountMessage, getChannelName());
     }

File: src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -312,7 +312,7 @@ public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
 
     @Override
     public void unlock() {
-        Boolean opStatus = commandExecutor.evalWrite(getName(), RedisCommands.EVAL_BOOLEAN,
+        Boolean opStatus = commandExecutor.evalWrite(getName(), RedisCommands.EVAL_BOOLEAN_R2,
                 "local v = redis.call('get', KEYS[1]); " +
                                 "if (v == false) then " +
                                 "  redis.call('publish', ARGV[4], ARGV[2]); " +
@@ -355,7 +355,7 @@ public void forceUnlock() {
 
     private Future<Boolean> forceUnlockAsync() {
         stopRefreshTask();
-        return commandExecutor.evalWriteAsync(getName(), RedisCommands.EVAL_BOOLEAN,
+        return commandExecutor.evalWriteAsync(getName(), RedisCommands.EVAL_BOOLEAN_R1,
                 "redis.call('del', KEYS[1]); redis.call('publish', ARGV[2], ARGV[1]); return true",
                         Collections.<Object>singletonList(getName()), unlockMessage, getChannelName());
     }

File: src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -120,6 +120,8 @@ public interface RedisCommands {
     RedisStrictCommand<List<Boolean>> SCRIPT_EXISTS = new RedisStrictCommand<List<Boolean>>("SCRIPT", "EXISTS", new ObjectListReplayDecoder<Boolean>(), new BooleanReplayConvertor());
 
     RedisStrictCommand<Boolean> EVAL_BOOLEAN = new RedisStrictCommand<Boolean>("EVAL", new BooleanReplayConvertor());
+    RedisStrictCommand<Boolean> EVAL_BOOLEAN_R1 = new RedisStrictCommand<Boolean>("EVAL", new BooleanReplayConvertor(), 4);
+    RedisStrictCommand<Boolean> EVAL_BOOLEAN_R2 = new RedisStrictCommand<Boolean>("EVAL", new BooleanReplayConvertor(), 5);
     RedisStrictCommand<String> EVAL_STRING = new RedisStrictCommand<String>("EVAL", new StringReplayDecoder());
     RedisStrictCommand<Long> EVAL_INTEGER = new RedisStrictCommand<Long>("EVAL");
     RedisCommand<List<Object>> EVAL_LIST = new RedisCommand<List<Object>>("EVAL", new ObjectListReplayDecoder<Object>());

File: src/main/java/org/redisson/BaseConfig.java
Patch:
@@ -195,8 +195,9 @@ public int getPingTimeout() {
      *
      * @param failAttemptsAmount
      */
-    public void setCloseConnectionAfterFailAttempts(int failAttemptsAmount) {
+    public T setCloseConnectionAfterFailAttempts(int failAttemptsAmount) {
         this.closeConnectionAfterFailAttempts = failAttemptsAmount;
+        return (T) this;
     }
     public int getCloseConnectionAfterFailAttempts() {
         return closeConnectionAfterFailAttempts;

File: src/main/java/org/redisson/client/RedisConnection.java
Patch:
@@ -42,13 +42,13 @@ public class RedisConnection implements RedisCommands {
     public RedisConnection(RedisClient redisClient, Channel channel) {
         super();
         this.redisClient = redisClient;
-        this.channel = channel;
 
-        channel.attr(CONNECTION).set(this);
+        updateChannel(channel);
     }
 
     public void updateChannel(Channel channel) {
         this.channel = channel;
+        channel.attr(CONNECTION).set(this);
     }
 
     public RedisClient getRedisClient() {

File: src/main/java/org/redisson/CommandBatchExecutorService.java
Patch:
@@ -158,8 +158,10 @@ public void operationComplete(Future<Void> future) throws Exception {
                 commands = null;
             }
         });
+
+        AtomicInteger slots = new AtomicInteger(commands.size());
         for (java.util.Map.Entry<Integer, Entry> e : commands.entrySet()) {
-            execute(e.getValue(), e.getKey(), voidPromise, new AtomicInteger(commands.size()), 0);
+            execute(e.getValue(), e.getKey(), voidPromise, slots, 0);
         }
         return promise;
     }

File: src/main/java/org/redisson/connection/SentinelConnectionManager.java
Patch:
@@ -60,6 +60,7 @@ public SentinelConnectionManager(SentinelServersConfig cfg, Config config) {
         c.setLoadBalancer(cfg.getLoadBalancer());
         c.setPassword(cfg.getPassword());
         c.setDatabase(cfg.getDatabase());
+        c.setClientName(cfg.getClientName());
         c.setMasterConnectionPoolSize(cfg.getMasterConnectionPoolSize());
         c.setSlaveConnectionPoolSize(cfg.getSlaveConnectionPoolSize());
         c.setSlaveSubscriptionConnectionPoolSize(cfg.getSlaveSubscriptionConnectionPoolSize());

File: src/main/java/org/redisson/client/WriteRedisConnectionException.java
Patch:
@@ -15,15 +15,15 @@
  */
 package org.redisson.client;
 
-public class RedisConnectionWriteException extends RedisException {
+public class WriteRedisConnectionException extends RedisException {
 
     private static final long serialVersionUID = -4756928186967834601L;
 
-    public RedisConnectionWriteException(String msg) {
+    public WriteRedisConnectionException(String msg) {
         super(msg);
     }
 
-    public RedisConnectionWriteException(String msg, Throwable e) {
+    public WriteRedisConnectionException(String msg, Throwable e) {
         super(msg, e);
     }
 

File: src/main/java/org/redisson/connection/ClusterConnectionManager.java
Patch:
@@ -105,7 +105,7 @@ private void addMasterEntry(ClusterPartition partition, ClusterServersConfig cfg
         log.info("master: {} for slot range: {}-{} added", partition.getMasterAddress(), partition.getStartSlot(), partition.getEndSlot());
         config.setMasterAddress(partition.getMasterAddress());
 
-        SingleEntry entry = new SingleEntry(this, config);
+        SingleEntry entry = new SingleEntry(partition.getStartSlot(), partition.getEndSlot(), this, config);
         entries.put(partition.getEndSlot(), entry);
         lastPartitions.put(partition.getEndSlot(), partition);
     }

File: src/main/java/org/redisson/connection/SingleConnectionManager.java
Patch:
@@ -41,8 +41,8 @@ public SingleConnectionManager(SingleServerConfig cfg, Config config) {
 
     @Override
     protected void initEntry(MasterSlaveServersConfig config) {
-        SingleEntry entry = new SingleEntry(this, config);
-        entries.put(Integer.MAX_VALUE, entry);
+        SingleEntry entry = new SingleEntry(0, MAX_SLOT, this, config);
+        entries.put(MAX_SLOT, entry);
     }
 
 }

File: src/main/java/org/redisson/connection/SingleEntry.java
Patch:
@@ -24,8 +24,8 @@
 
 public class SingleEntry extends MasterSlaveEntry {
 
-    public SingleEntry(ConnectionManager connectionManager, MasterSlaveServersConfig config) {
-        super(connectionManager, config);
+    public SingleEntry(int startSlot, int endSlot, ConnectionManager connectionManager, MasterSlaveServersConfig config) {
+        super(startSlot, endSlot, connectionManager, config);
     }
 
     @Override

File: src/test/java/org/redisson/RedissonTest.java
Patch:
@@ -5,7 +5,7 @@
 
 import org.junit.Assert;
 import org.junit.Test;
-import org.redisson.client.RedisConnectionWriteException;
+import org.redisson.client.WriteRedisConnectionException;
 import org.redisson.codec.SerializationCodec;
 import org.redisson.core.ClusterNode;
 import org.redisson.core.Node;
@@ -17,7 +17,7 @@ public static class Dummy {
         private String field;
     }
 
-    @Test(expected = RedisConnectionWriteException.class)
+    @Test(expected = WriteRedisConnectionException.class)
     public void testSer() {
         Config config = new Config();
         config.useSingleServer().setAddress("127.0.0.1:6379");

File: src/main/java/org/redisson/CommandBatchExecutorService.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.redisson.client.RedisConnectionClosedException;
+import org.redisson.client.RedisConnectionWriteException;
 import org.redisson.client.RedisConnectionException;
 import org.redisson.client.RedisException;
 import org.redisson.client.RedisMovedException;
@@ -212,7 +212,7 @@ public void run(Timeout timeout) throws Exception {
                 public void operationComplete(ChannelFuture future) throws Exception {
                     if (!future.isSuccess()) {
                         timeout.cancel();
-                        ex.set(new RedisConnectionClosedException("channel: " + future.channel() + " closed"));
+                        ex.set(new RedisConnectionWriteException("channel: " + future.channel() + " closed"));
                         connectionManager.getTimer().newTimeout(retryTimerTask, connectionManager.getConfig().getRetryInterval(), TimeUnit.MILLISECONDS);
                     }
                 }

File: src/main/java/org/redisson/CommandExecutorService.java
Patch:
@@ -27,7 +27,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.redisson.client.RedisConnection;
-import org.redisson.client.RedisConnectionClosedException;
+import org.redisson.client.RedisConnectionWriteException;
 import org.redisson.client.RedisConnectionException;
 import org.redisson.client.RedisException;
 import org.redisson.client.RedisMovedException;
@@ -422,7 +422,8 @@ public void run(Timeout timeout) throws Exception {
                 public void operationComplete(ChannelFuture future) throws Exception {
                     if (!future.isSuccess()) {
                         timeout.cancel();
-                        ex.set(new RedisConnectionClosedException("channel: " + future.channel() + " closed"));
+                        ex.set(new RedisConnectionWriteException(
+                                "Can't send command: " + command + ", params: " + params + ", channel: " + future.channel(), future.cause()));
                         connectionManager.getTimer().newTimeout(retryTimerTask, connectionManager.getConfig().getRetryInterval(), TimeUnit.MILLISECONDS);
                     }
                 }

File: src/main/java/org/redisson/client/RedisConnectionWriteException.java
Patch:
@@ -15,15 +15,15 @@
  */
 package org.redisson.client;
 
-public class RedisConnectionClosedException extends RedisException {
+public class RedisConnectionWriteException extends RedisException {
 
     private static final long serialVersionUID = -4756928186967834601L;
 
-    public RedisConnectionClosedException(String msg) {
+    public RedisConnectionWriteException(String msg) {
         super(msg);
     }
 
-    public RedisConnectionClosedException(String msg, Throwable e) {
+    public RedisConnectionWriteException(String msg, Throwable e) {
         super(msg, e);
     }
 

File: src/main/java/org/redisson/connection/SingleConnectionManager.java
Patch:
@@ -27,6 +27,7 @@ public SingleConnectionManager(SingleServerConfig cfg, Config config) {
         newconfig.setRetryAttempts(cfg.getRetryAttempts());
         newconfig.setRetryInterval(cfg.getRetryInterval());
         newconfig.setTimeout(cfg.getTimeout());
+        newconfig.setPingTimeout(cfg.getPingTimeout());
         newconfig.setPassword(cfg.getPassword());
         newconfig.setDatabase(cfg.getDatabase());
         newconfig.setClientName(cfg.getClientName());

File: src/main/java/org/redisson/CommandExecutor.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.util.Collection;
 import java.util.List;
-import java.util.Queue;
 
 import org.redisson.client.codec.Codec;
 import org.redisson.client.protocol.RedisCommand;
@@ -82,8 +81,8 @@ public interface CommandExecutor {
 
     <V> V get(Future<V> future);
 
-    <T, R> Future<R> readRandomAsync(RedisCommand<T> command, Codec codec, Object ... params);
+    <T, R> Future<R> readRandomAsync(RedisCommand<T> command, Object ... params);
 
-    <T, R> R read(Integer slot, Codec codec, RedisCommand<T> command, Object ... params);
+    <T, R> R write(Integer slot, Codec codec, RedisCommand<T> command, Object ... params);
 
 }

File: src/main/java/org/redisson/RedissonKeys.java
Patch:
@@ -72,9 +72,9 @@ public Iterator<String> iterator() {
 
     private ListScanResult<String> scanIterator(int slot, long startPos, String pattern) {
         if (pattern == null) {
-            return commandExecutor.read(slot, StringCodec.INSTANCE, RedisCommands.SCAN, startPos);
+            return commandExecutor.write(slot, StringCodec.INSTANCE, RedisCommands.SCAN, startPos);
         }
-        return commandExecutor.read(slot, StringCodec.INSTANCE, RedisCommands.SCAN, startPos, "MATCH", pattern);
+        return commandExecutor.write(slot, StringCodec.INSTANCE, RedisCommands.SCAN, startPos, "MATCH", pattern);
     }
 
     private Iterator<String> createKeysIterator(final int slot, final String pattern) {
@@ -132,7 +132,7 @@ public String randomKey() {
 
     @Override
     public Future<String> randomKeyAsync() {
-        return commandExecutor.readRandomAsync(RedisCommands.RANDOM_KEY, StringCodec.INSTANCE);
+        return commandExecutor.readRandomAsync(RedisCommands.RANDOM_KEY);
     }
 
     /**

File: src/test/java/org/redisson/RedissonBucketTest.java
Patch:
@@ -20,7 +20,7 @@ public void testExpire() throws InterruptedException {
         RBucket<String> bucket = redisson.getBucket("test1");
         bucket.set("someValue", 1, TimeUnit.SECONDS);
 
-        Thread.sleep(1000);
+        Thread.sleep(1100);
 
         Assert.assertNull(bucket.get());
     }
@@ -42,10 +42,10 @@ public void testFindKeys() {
         RMap<String, String> map = redisson.getMap("test2");
         map.fastPut("1", "2");
 
-        Queue<String> keys = redisson.findKeysByPattern("test?");
+        Collection<String> keys = redisson.findKeysByPattern("test?");
         MatcherAssert.assertThat(keys, Matchers.containsInAnyOrder("test1", "test2"));
 
-        Queue<String> keys2 = redisson.findKeysByPattern("test");
+        Collection<String> keys2 = redisson.findKeysByPattern("test");
         MatcherAssert.assertThat(keys2, Matchers.empty());
     }
 

File: src/main/java/org/redisson/client/handler/CommandDecoder.java
Patch:
@@ -164,7 +164,7 @@ private void decode(ByteBuf in, CommandData<Object, Object> data, List<Object> p
                 int slot = Integer.valueOf(errorParts[2]);
                 data.getPromise().setFailure(new RedisMovedException(slot));
             } else {
-                data.getPromise().setFailure(new RedisException(error));
+                data.getPromise().setFailure(new RedisException(error + ". channel: " + channel));
             }
         } else if (code == ':') {
             String status = in.readBytes(in.bytesBefore((byte) '\r')).toString(CharsetUtil.UTF_8);

File: src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -113,7 +113,7 @@ protected void init(MasterSlaveServersConfig config) {
 
         int minTimeout = Math.min(config.getRetryInterval(), config.getTimeout());
         if (minTimeout % 100 != 0) {
-            timer = new HashedWheelTimer(minTimeout % 100, TimeUnit.MILLISECONDS);
+            timer = new HashedWheelTimer((minTimeout % 100) / 2, TimeUnit.MILLISECONDS);
         } else {
             timer = new HashedWheelTimer(100, TimeUnit.MILLISECONDS);
         }

File: src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -133,7 +133,7 @@ public interface RedisCommands {
     RedisCommand<Object> GET = new RedisCommand<Object>("GET");
     RedisCommand<Void> SET = new RedisCommand<Void>("SET", new VoidReplayConvertor(), 2);
     RedisCommand<Boolean> SETNX = new RedisCommand<Boolean>("SETNX", new BooleanReplayConvertor(), 2);
-    RedisCommand<Void> SETEX = new RedisCommand<Void>("SETEX", new VoidReplayConvertor(), 2);
+    RedisCommand<Void> SETEX = new RedisCommand<Void>("SETEX", new VoidReplayConvertor(), 3);
     RedisStrictCommand<Boolean> EXISTS = new RedisStrictCommand<Boolean>("EXISTS", new BooleanReplayConvertor());
 
     RedisStrictCommand<Boolean> RENAMENX = new RedisStrictCommand<Boolean>("RENAMENX", new BooleanReplayConvertor());

File: src/main/java/org/redisson/connection/ClusterConnectionManager.java
Patch:
@@ -53,6 +53,8 @@ public class ClusterConnectionManager extends MasterSlaveConnectionManager {
     public ClusterConnectionManager(ClusterServersConfig cfg, Config config) {
         init(config);
 
+        this.config = create(cfg);
+
         for (URI addr : cfg.getNodeAddresses()) {
             RedisClient client = createClient(addr.getHost(), addr.getPort(), cfg.getTimeout());
             try {
@@ -73,8 +75,6 @@ public ClusterConnectionManager(ClusterServersConfig cfg, Config config) {
             }
         }
 
-        this.config = create(cfg);
-
         monitorClusterChange(cfg);
     }
 

File: src/main/java/org/redisson/client/protocol/decoder/ObjectListReplayDecoder.java
Patch:
@@ -21,16 +21,16 @@
 
 import io.netty.buffer.ByteBuf;
 
-public class ObjectListReplayDecoder implements MultiDecoder<List<Object>> {
+public class ObjectListReplayDecoder<T> implements MultiDecoder<List<T>> {
 
     @Override
     public Object decode(ByteBuf buf, State state) {
         throw new UnsupportedOperationException();
     }
 
     @Override
-    public List<Object> decode(List<Object> parts, State state) {
-        return parts;
+    public List<T> decode(List<Object> parts, State state) {
+        return (List<T>) parts;
     }
 
     @Override

File: src/main/java/org/redisson/core/RScript.java
Patch:
@@ -55,6 +55,8 @@ public RedisCommand<?> getCommand() {
 
     String scriptLoad(String luaScript);
 
+    List<Boolean> scriptExists(String ... shaDigests);
+
     void scriptKill();
 
     void scriptFlush();

File: src/main/java/org/redisson/core/RScriptAsync.java
Patch:
@@ -32,6 +32,8 @@ public interface RScriptAsync {
 
     Future<String> scriptLoadAsync(String luaScript);
 
+    Future<List<Boolean>> scriptExistsAsync(String ... shaDigests);
+
     Future<Void> scriptKillAsync();
 
 }

File: src/main/java/org/redisson/CommandExecutor.java
Patch:
@@ -73,7 +73,7 @@ public interface CommandExecutor {
 
     <T, R> Future<Queue<R>> readAllAsync(RedisCommand<T> command, Object ... params);
 
-    <T> Future<Boolean> writeAllAsync(RedisCommand<T> command, Object ... params);
+    <T> Future<Void> writeAllAsync(RedisCommand<T> command, Object ... params);
 
     <T, R> Future<R> writeAsync(String key, RedisCommand<T> command, Object ... params);
 

File: src/main/java/org/redisson/RedisPubSubTopicListenerWrapper.java
Patch:
@@ -80,7 +80,8 @@ public void onPatternMessage(String pattern, String channel, V message) {
     }
 
     @Override
-    public void onStatus(Type type, String channel) {
+    public boolean onStatus(Type type, String channel) {
+        return false;
     }
 
 }

File: src/main/java/org/redisson/RedissonCountDownLatch.java
Patch:
@@ -88,10 +88,12 @@ public void onMessage(String channel, Integer message) {
             }
 
             @Override
-            public void onStatus(Type type, String channel) {
+            public boolean onStatus(Type type, String channel) {
                 if (channel.equals(getChannelName()) && !value.getPromise().isSuccess()) {
                     value.getPromise().setSuccess(true);
+                    return true;
                 }
+                return false;
             }
 
         };

File: src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -129,10 +129,12 @@ public void onMessage(String channel, Integer message) {
             }
 
             @Override
-            public void onStatus(Type type, String channel) {
+            public boolean onStatus(Type type, String channel) {
                 if (channel.equals(getChannelName()) && !value.getPromise().isSuccess()) {
                     value.getPromise().setSuccess(true);
+                    return true;
                 }
+                return false;
             }
 
         };

File: src/main/java/org/redisson/client/BaseRedisPubSubListener.java
Patch:
@@ -20,7 +20,8 @@
 public class BaseRedisPubSubListener<V> implements RedisPubSubListener<V> {
 
     @Override
-    public void onStatus(Type type, String channel) {
+    public boolean onStatus(Type type, String channel) {
+        return false;
     }
 
     @Override

File: src/main/java/org/redisson/client/RedisPubSubConnection.java
Patch:
@@ -44,7 +44,7 @@ public void addListener(RedisPubSubListener listener) {
     }
 
     public void addOneShotListener(RedisPubSubListener listener) {
-        listeners.add(new OnceRedisPubSubListener<Object>(this, listener));
+        listeners.add(new OneShotPubSubListener<Object>(this, listener));
     }
 
     public void removeListener(RedisPubSubListener<?> listener) {

File: src/main/java/org/redisson/client/RedisPubSubListener.java
Patch:
@@ -19,7 +19,7 @@
 
 public interface RedisPubSubListener<V> {
 
-    void onStatus(PubSubStatusMessage.Type type, String channel);
+    boolean onStatus(PubSubStatusMessage.Type type, String channel);
 
     void onMessage(String channel, V message);
 

File: src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -23,14 +23,12 @@
 import org.redisson.client.RedisConnection;
 import org.redisson.client.RedisPubSubListener;
 import org.redisson.client.protocol.Codec;
-import org.redisson.client.protocol.pubsub.PubSubStatusMessage;
 import org.redisson.misc.InfinitySemaphoreLatch;
 
 import io.netty.channel.EventLoopGroup;
 import io.netty.util.HashedWheelTimer;
 import io.netty.util.Timeout;
 import io.netty.util.TimerTask;
-import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.FutureListener;
 import io.netty.util.concurrent.Promise;
 

File: src/test/java/org/redisson/RedisClientTest.java
Patch:
@@ -21,10 +21,8 @@
 import org.redisson.client.protocol.LongCodec;
 import org.redisson.client.protocol.RedisCommands;
 import org.redisson.client.protocol.StringCodec;
-import org.redisson.client.protocol.pubsub.PubSubStatusMessage;
 import org.redisson.client.protocol.pubsub.PubSubStatusMessage.Type;
 
-import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.Promise;
 
 public class RedisClientTest {
@@ -37,10 +35,11 @@ public void testSubscribe() throws InterruptedException {
         pubSubConnection.addListener(new RedisPubSubListener<Object>() {
 
             @Override
-            public void onStatus(Type type, String channel) {
+            public boolean onStatus(Type type, String channel) {
                 Assert.assertEquals(Type.SUBSCRIBE, type);
                 Assert.assertTrue(Arrays.asList("test1", "test2").contains(channel));
                 latch.countDown();
+                return true;
             }
 
             @Override

File: src/main/java/org/redisson/client/handler/CommandsQueue.java
Patch:
@@ -72,7 +72,9 @@ private void sendData(ChannelHandlerContext ctx) throws Exception {
             List<CommandData<Object, Object>> pubSubOps = data.getPubSubOperations();
             if (!pubSubOps.isEmpty()) {
                 for (CommandData<Object, Object> cd : pubSubOps) {
-                    ctx.pipeline().get(CommandDecoder.class).addChannel((String)cd.getParams()[0], cd);
+                    for (Object channel : cd.getParams()) {
+                        ctx.pipeline().get(CommandDecoder.class).addChannel(channel.toString(), cd);
+                    }
                 }
             } else {
                 ctx.channel().attr(REPLAY).set(data);

File: src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -78,11 +78,11 @@ <T> FutureListener<T> createReleaseWriteListener(int slot,
 
     PubSubConnectionEntry psubscribe(String pattern);
 
-    <V> Future<PubSubStatusMessage> subscribe(RedisPubSubListener<V> listener, String channelName);
+    <V> void subscribe(RedisPubSubListener<V> listener, String channelName);
 
-    Future unsubscribe(String channelName);
+    void unsubscribe(String channelName);
 
-    Future punsubscribe(String channelName);
+    void punsubscribe(String channelName);
 
     void shutdown();
 

File: src/main/java/org/redisson/client/protocol/QueueCommand.java
Patch:
@@ -15,10 +15,13 @@
  */
 package org.redisson.client.protocol;
 
+import java.util.List;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 public interface QueueCommand {
 
+    List<CommandData<Object, Object>> getPubSubOperations();
+
     AtomicBoolean getSended();
 
 }

File: src/main/java/org/redisson/client/protocol/pubsub/PubSubMessage.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.redisson.client.protocol.pubsub;
 
-public class PubSubMessage<V> {
+public class PubSubMessage<V> implements Message {
 
     private final String channel;
     private final V value;

File: src/main/java/org/redisson/client/protocol/pubsub/PubSubPatternMessage.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.redisson.client.protocol.pubsub;
 
-public class PubSubPatternMessage {
+public class PubSubPatternMessage implements Message {
 
     private final String pattern;
     private final String channel;

File: src/main/java/org/redisson/client/protocol/pubsub/PubSubStatusMessage.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.redisson.client.protocol.pubsub;
 
-public class PubSubStatusMessage {
+public class PubSubStatusMessage implements Message {
 
     public enum Type {SUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, UNSUBSCRIBE}
 

File: src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -127,10 +127,10 @@ public RedisClient createClient(String host, int port, int timeout) {
 
     public <T> FutureListener<T> createReleaseWriteListener(final int slot,
                                     final RedisConnection conn, final Timeout timeout) {
-        latch.release();
         return new FutureListener<T>() {
             @Override
             public void operationComplete(io.netty.util.concurrent.Future<T> future) throws Exception {
+                latch.release();
                 timeout.cancel();
                 releaseWrite(slot, conn);
             }
@@ -139,10 +139,10 @@ public void operationComplete(io.netty.util.concurrent.Future<T> future) throws
 
     public <T> FutureListener<T> createReleaseReadListener(final int slot,
                                     final RedisConnection conn, final Timeout timeout) {
-        latch.release();
         return new FutureListener<T>() {
             @Override
             public void operationComplete(io.netty.util.concurrent.Future<T> future) throws Exception {
+                latch.release();
                 timeout.cancel();
                 releaseRead(slot, conn);
             }

File: src/main/java/org/redisson/misc/InfinitySemaphoreLatch.java
Patch:
@@ -71,12 +71,13 @@ public boolean isOpened() {
     }
 
     // waiting for an open state
-    public final void closeAndAwaitUninterruptibly() {
+    public final boolean closeAndAwaitUninterruptibly() {
         closed = true;
         try {
-            await();
+            return await(15, TimeUnit.SECONDS);
         } catch (InterruptedException e) {
             Thread.currentThread().interrupt();
+            return false;
         }
     }
 

File: src/main/java/org/redisson/client/protocol/LongCodec.java
Patch:
@@ -27,9 +27,6 @@ public Decoder<Object> getValueDecoder() {
         return new Decoder<Object>() {
             @Override
             public Object decode(ByteBuf buf) {
-                if (buf == null) {
-                    return null;
-                }
                 return Long.valueOf(buf.toString(CharsetUtil.UTF_8));
             }
         };

File: src/main/java/org/redisson/client/protocol/StringCodec.java
Patch:
@@ -29,9 +29,6 @@ public Decoder<Object> getValueDecoder() {
         return new Decoder<Object>() {
             @Override
             public Object decode(ByteBuf buf) {
-                if (buf == null) {
-                    return null;
-                }
                 return buf.toString(CharsetUtil.UTF_8);
             }
         };

File: src/test/java/org/redisson/RedissonCountDownLatchTest.java
Patch:
@@ -134,10 +134,10 @@ public void testDelete() throws Exception {
         Assert.assertTrue(latch.delete());
     }
 
-    @Test(expected = IllegalStateException.class)
+    @Test
     public void testDeleteFailed() throws Exception {
         RCountDownLatch latch = redisson.getCountDownLatch("latch");
-        Assert.assertTrue(latch.delete());
+        Assert.assertFalse(latch.delete());
     }
 
     @Test

File: src/main/java/org/redisson/client/RedisPubSubConnection.java
Patch:
@@ -69,8 +69,8 @@ public Future<PubSubStatusMessage> subscribe(Codec codec, String ... channel) {
         return async(new PubSubMessageDecoder(codec.getValueDecoder()), RedisCommands.SUBSCRIBE, channel);
     }
 
-    public Future<PubSubStatusMessage> psubscribe(String ... channel) {
-        return async(new PubSubPatternMessageDecoder(), RedisCommands.PSUBSCRIBE, channel);
+    public Future<PubSubStatusMessage> psubscribe(Codec codec, String ... channel) {
+        return async(new PubSubPatternMessageDecoder(codec.getValueDecoder()), RedisCommands.PSUBSCRIBE, channel);
     }
 
     public Future<PubSubStatusMessage> unsubscribe(String ... channel) {

File: src/main/java/org/redisson/client/protocol/Encoder.java
Patch:
@@ -2,6 +2,6 @@
 
 public interface Encoder {
 
-    Object encode(Object in);
+    byte[] encode(Object in);
 
 }

File: src/main/java/org/redisson/client/protocol/RedisCommands.java
Patch:
@@ -17,7 +17,7 @@
 
 public interface RedisCommands {
 
-    RedisCommand<Object> GET = new RedisCommand<Object>("GET");
-    RedisCommand<String> SET = new RedisCommand<String>("SET", new StringReplayDecoder());
+    RedisCommand<Object> GET = new RedisCommand<Object>("GET", 0);
+    RedisCommand<String> SET = new RedisCommand<String>("SET", new StringReplayDecoder(), 0, 1);
 
 }

File: src/main/java/com/lambdaworks/redis/protocol/CommandHandler.java
Patch:
@@ -48,7 +48,7 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
         try {
             if (!input.isReadable()) return;
 
-//            System.out.println("in: " + input.toString(CharsetUtil.UTF_8));
+//            System.out.println("in: " + toHexString(input));
 
             buffer.discardReadBytes();
             buffer.writeBytes(input);
@@ -64,7 +64,6 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)
         Command<?, ?, ?> cmd = (Command<?, ?, ?>) msg;
         ByteBuf buf = ctx.alloc().heapBuffer();
         cmd.encode(buf);
-//        System.out.println("out: " + buf.toString(CharsetUtil.UTF_8));
 //        System.out.println("out: " + toHexString(buf));
 
         ctx.write(buf, promise);

File: src/main/java/com/lambdaworks/redis/RedisClient.java
Patch:
@@ -66,7 +66,7 @@ public RedisClient(EventLoopGroup group, String host, int port, int timeout) {
     }
 
     public RedisClient(EventLoopGroup group, Class<? extends SocketChannel> socketChannelClass, String host,
-            int port, int timeout2) {
+            int port, int timeout) {
         addr = new InetSocketAddress(host, port);
 
         bootstrap = new Bootstrap().channel(socketChannelClass).group(group).remoteAddress(addr);

File: src/main/java/org/redisson/connection/ClusterConnectionManager.java
Patch:
@@ -54,7 +54,7 @@ public ClusterConnectionManager(ClusterServersConfig cfg, Config config) {
         init(config);
 
         for (URI addr : cfg.getNodeAddresses()) {
-            RedisClient client = createClient(addr.getHost(), addr.getPort());
+            RedisClient client = createClient(addr.getHost(), addr.getPort(), cfg.getTimeout());
             try {
                 RedisAsyncConnection<String, String> connection = client.connectAsync();
                 String nodesValue = get(connection.clusterNodes());

File: src/main/java/com/lambdaworks/redis/output/ValueSetScanOutput.java
Patch:
@@ -14,7 +14,7 @@ public ValueSetScanOutput(RedisCodec<K, V> codec) {
     @Override
     public void set(ByteBuffer bytes) {
         if (output.getPos() == null) {
-            output.setPos(((Number) codec.decodeMapValue(bytes)).longValue());
+            output.setPos(Long.valueOf(codec.decodeMapValue(bytes).toString()));
         } else {
             output.addValue(codec.decodeMapValue(bytes));
         }

File: src/main/java/com/lambdaworks/redis/protocol/Command.java
Patch:
@@ -67,7 +67,7 @@ public void complete() {
             }
             if (res instanceof RedisException) {
                 promise.setFailure((Exception)res);
-            } if (output.hasError()) {
+            } else if (output.hasError()) {
                 if (output.getError().startsWith("MOVED")) {
                     String[] parts = output.getError().split(" ");
                     int slot = Integer.valueOf(parts[1]);
@@ -79,6 +79,8 @@ public void complete() {
                 } else {
                     promise.setFailure(new RedisException(output.getError()));
                 }
+            } else if (output.hasException()) {
+                promise.setFailure(output.getException());
             } else {
                 promise.setSuccess((T)res);
             }

File: src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -410,7 +410,9 @@ public <V> V get(Future<V> future) {
         if (future.isSuccess()) {
             return future.getNow();
         }
-        throw ((RedisException)future.cause());
+        throw future.cause() instanceof RedisException ?
+                (RedisException) future.cause() :
+                new RedisException("Unexpected exception while processing command", future.cause());
     }
 
     public <V, T> T read(String key, AsyncOperation<V, T> asyncOperation) {

File: src/main/java/org/redisson/RedissonBlockingQueue.java
Patch:
@@ -130,8 +130,8 @@ public List<V> execute(RedisConnection<Object, V> conn) {
                         return Collections.emptyList();
                     }
                     conn.multi();
-                    conn.lrange(getName(), 0, len);
-                    conn.ltrim(getName(), 0, len);
+                    conn.lrange(getName(), 0, len - 1);
+                    conn.ltrim(getName(), len, -1);
                     List<Object> res = conn.exec();
                     if (res.size() == 2) {
                         List<V> items = (List<V>) res.get(0);

File: src/main/java/org/redisson/RedissonBlockingQueue.java
Patch:
@@ -130,8 +130,8 @@ public List<V> execute(RedisConnection<Object, V> conn) {
                         return Collections.emptyList();
                     }
                     conn.multi();
-                    conn.lrange(getName(), 0, len);
-                    conn.ltrim(getName(), 0, len);
+                    conn.lrange(getName(), 0, len - 1);
+                    conn.ltrim(getName(), len, -1);
                     List<Object> res = conn.exec();
                     if (res.size() == 2) {
                         List<V> items = (List<V>) res.get(0);

File: src/main/java/org/redisson/connection/ClusterNodeInfo.java
Patch:
@@ -23,7 +23,7 @@
 
 public class ClusterNodeInfo {
 
-    public enum Flag {SLAVE, MASTER, MYSELF, FAIL};
+    public enum Flag {SLAVE, MASTER, MYSELF, FAIL, HANDSHAKE};
 
     private String nodeId;
     private URI address;

File: src/main/java/com/lambdaworks/redis/RedisAsyncConnection.java
Patch:
@@ -415,7 +415,7 @@ public Future<Long> hlen(K key) {
     }
 
     public Future<List<V>> hmget(K key, K... fields) {
-        CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).addKeys(fields);
+        CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).addMapKeys(fields);
         return dispatch(HMGET, new ValueListOutput<K, V>(codec), args);
     }
 

File: src/main/java/com/lambdaworks/redis/RedisAsyncConnection.java
Patch:
@@ -415,7 +415,7 @@ public Future<Long> hlen(K key) {
     }
 
     public Future<List<V>> hmget(K key, K... fields) {
-        CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).addKeys(fields);
+        CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).addMapKeys(fields);
         return dispatch(HMGET, new ValueListOutput<K, V>(codec), args);
     }
 

File: src/main/java/org/redisson/RedissonBlockingQueue.java
Patch:
@@ -65,7 +65,7 @@ public V execute(RedisConnection<Object, V> conn) {
 
     @Override
     public V poll(final long timeout, final TimeUnit unit) throws InterruptedException {
-        return connectionManager.read(getName(), new SyncOperation<V, V>() {
+        return connectionManager.write(getName(), new SyncOperation<V, V>() {
             @Override
             public V execute(RedisConnection<Object, V> conn) {
                 return conn.blpop(unit.toSeconds(timeout), getName()).value;

File: src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -353,7 +353,7 @@ public boolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws Inte
             return true;
         }
 
-        if (!subscribe().awaitUninterruptibly(time, unit)) {
+        if (!subscribe().awaitUninterruptibly(time, TimeUnit.MILLISECONDS)) {
             return false;
         }
 

File: src/main/java/org/redisson/RedissonMap.java
Patch:
@@ -285,8 +285,8 @@ public V execute(RedisConnection<Object, V> connection) {
                         }
                     } else {
                         connection.unwatch();
+                        return null;
                     }
-                    return null;
                 }
             }
         });

File: src/test/java/org/redisson/RedissonConcurrentMapTest.java
Patch:
@@ -84,7 +84,7 @@ public void test_Multi_Replace_MultiInstance() throws InterruptedException {
             @Override
             public void run(Redisson redisson) {
                 ConcurrentMap<Integer, Integer> map = redisson.getMap(name);
-                map.replace(secureRandom.nextInt(5), 2);
+                Assert.assertNotNull(map.replace(secureRandom.nextInt(5), 2));
             }
         });
 

File: src/main/java/org/redisson/connection/ClusterConnectionManager.java
Patch:
@@ -117,8 +117,8 @@ public void run() {
                                             if (!newMasterPart.getMasterAddress().equals(part.getMasterAddress())) {
                                                 log.debug("changing master from {} to {} for {}",
                                                         part.getMasterAddress(), newMasterPart.getMasterAddress(), newMasterPart.getEndSlot());
-                                                URI newUri = toURI(newMasterPart.getMasterAddress());
-                                                URI oldUri = toURI(part.getMasterAddress());
+                                                URI newUri = newMasterPart.getMasterAddress();
+                                                URI oldUri = part.getMasterAddress();
 
                                                 changeMaster(newMasterPart.getEndSlot(), newUri.getHost(), newUri.getPort());
                                                 slaveDown(newMasterPart.getEndSlot(), oldUri.getHost(), oldUri.getPort());

File: src/main/java/com/lambdaworks/redis/RedisAsyncConnection.java
Patch:
@@ -379,12 +379,12 @@ public Future<V> hget(K key, K field) {
     }
 
     public Future<Long> hincrby(K key, K field, long amount) {
-        CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).addKey(field).add(amount);
+        CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).addMapKey(field).add(amount);
         return dispatch(HINCRBY, new IntegerOutput<K, V>(codec), args);
     }
 
     public Future<String> hincrbyfloat(K key, K field, String amount) {
-        CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).addKey(field).add(amount);
+        CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).addMapKey(field).add(amount);
         return dispatch(HINCRBYFLOAT, new StatusOutput<K, V>(codec), args);
     }
 

File: src/test/java/org/redisson/RedissonMapTest.java
Patch:
@@ -118,14 +118,16 @@ public boolean equals(Object obj) {
         }
 
     }
-
+    
     @Test
     public void testAddAndGet() throws InterruptedException {
         RMap<Integer, Integer> map = redisson.getMap("getAll");
         map.put(1, 100);
 
         Integer res = map.addAndGet(1, 12);
         Assert.assertEquals(112, (int)res);
+        res = map.get(1);
+        Assert.assertEquals(112, (int)res);
     }
 
     @Test

File: src/main/java/org/redisson/codec/KryoCodec.java
Patch:
@@ -18,6 +18,7 @@
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import java.util.Queue;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
@@ -126,12 +127,12 @@ public byte[] encodeValue(Object value) {
 
     @Override
     public byte[] encodeKey(Object key) {
-        return encodeValue(key);
+        return key.toString().getBytes(Charset.forName("ASCII"));
     }
 
     @Override
     public Object decodeKey(ByteBuffer bytes) {
-        return decode(bytes);
+        return new String(bytes.array(), bytes.arrayOffset() + bytes.position(), bytes.limit(), Charset.forName("ASCII"));
     }
 
     @Override

File: src/main/java/org/redisson/codec/JsonJacksonCodec.java
Patch:
@@ -94,7 +94,7 @@ protected void init(ObjectMapper objectMapper) {
 
     @Override
     public Object decodeKey(ByteBuffer bytes) {
-        return new String(bytes.array(), Charset.forName("ASCII"));
+        return new String(bytes.array(), bytes.arrayOffset() + bytes.position(), bytes.limit(), Charset.forName("ASCII"));
     }
 
     @Override

File: src/main/java/org/redisson/codec/KryoCodec.java
Patch:
@@ -18,6 +18,7 @@
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.nio.ByteBuffer;
+import java.nio.charset.Charset;
 import java.util.Queue;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
@@ -126,12 +127,12 @@ public byte[] encodeValue(Object value) {
 
     @Override
     public byte[] encodeKey(Object key) {
-        return encodeValue(key);
+        return key.toString().getBytes(Charset.forName("ASCII"));
     }
 
     @Override
     public Object decodeKey(ByteBuffer bytes) {
-        return decode(bytes);
+        return new String(bytes.array(), bytes.arrayOffset() + bytes.position(), bytes.limit(), Charset.forName("ASCII"));
     }
 
     @Override

File: src/main/java/org/redisson/codec/JsonJacksonCodec.java
Patch:
@@ -94,7 +94,7 @@ protected void init(ObjectMapper objectMapper) {
 
     @Override
     public Object decodeKey(ByteBuffer bytes) {
-        return new String(bytes.array(), Charset.forName("ASCII"));
+        return new String(bytes.array(), bytes.arrayOffset() + bytes.position(), bytes.limit(), Charset.forName("ASCII"));
     }
 
     @Override

File: src/main/java/org/redisson/RedissonCountDownLatch.java
Patch:
@@ -249,7 +249,7 @@ public boolean trySetCount(final long count) {
             @Override
             public Boolean execute(RedisConnection<Object, Object> conn) {
                 conn.watch(getName());
-                Long oldValue = (Long) conn.get(getName());
+                Number oldValue = (Number) conn.get(getName());
                 if (oldValue != null) {
                     conn.unwatch();
                     return false;

File: src/main/java/com/lambdaworks/redis/RedisAsyncConnection.java
Patch:
@@ -76,6 +76,7 @@
 import com.lambdaworks.redis.output.ValueListOutput;
 import com.lambdaworks.redis.output.ValueOutput;
 import com.lambdaworks.redis.output.ValueSetOutput;
+import com.lambdaworks.redis.output.ValueSetScanOutput;
 import com.lambdaworks.redis.protocol.Command;
 import com.lambdaworks.redis.protocol.CommandArgs;
 import com.lambdaworks.redis.protocol.CommandKeyword;
@@ -626,7 +627,7 @@ public Future<Long> rpushx(K key, V value) {
     }
 
     public Future<Long> sadd(K key, V... members) {
-        CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).addValues(members);
+        CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).addMapValues(members);
         return dispatch(SADD, new IntegerOutput<K, V>(codec), args);
     }
 
@@ -1058,7 +1059,7 @@ public Future<List<Map<K, V>>> slaves(K key) {
 
     public Future<ListScanResult<V>> sscan(K key, long startValue) {
         CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).add(startValue);
-        return dispatch(SSCAN, new ListScanOutput<K, V>(codec), args);
+        return dispatch(SSCAN, new ValueSetScanOutput<K, V>(codec), args);
     }
 
     public Future<MapScanResult<K, V>> hscan(K key, long startValue) {

File: src/main/java/com/lambdaworks/redis/RedisAsyncConnection.java
Patch:
@@ -626,7 +626,7 @@ public Future<Long> rpushx(K key, V value) {
     }
 
     public Future<Long> sadd(K key, V... members) {
-        CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).addMapValues(members);
+        CommandArgs<K, V> args = new CommandArgs<K, V>(codec).addKey(key).addValues(members);
         return dispatch(SADD, new IntegerOutput<K, V>(codec), args);
     }
 

File: src/main/java/org/redisson/Redisson.java
Patch:
@@ -69,6 +69,7 @@ public static Redisson create() {
         config.useSingleServer().setAddress("127.0.0.1:6379");
 //        config.useMasterSlaveConnection().setMasterAddress("127.0.0.1:6379").addSlaveAddress("127.0.0.1:6389").addSlaveAddress("127.0.0.1:6399");
 //        config.useSentinelConnection().setMasterName("mymaster").addSentinelAddress("127.0.0.1:26389", "127.0.0.1:26379");
+//        config.useClusterServers().addNodeAddress("127.0.0.1:7000");
         return create(config);
     }
 
@@ -233,12 +234,12 @@ public Config getConfig() {
     }
 
     public void flushdb() {
-        connectionManager.write(new ResultOperation<String, Object>() {
+        connectionManager.writeAllAsync(new ResultOperation<String, Object>() {
             @Override
             protected Future<String> execute(RedisAsyncConnection<Object, Object> conn) {
                 return conn.flushdb();
             }
-        });
+        }).awaitUninterruptibly();
     }
 
 }

File: src/main/java/org/redisson/RedissonCountDownLatch.java
Patch:
@@ -101,7 +101,7 @@ public void message(String channel, Integer message) {
         };
 
         synchronized (ENTRIES) {
-            connectionManager.subscribeOnce(listener, getChannelName());
+            connectionManager.subscribe(listener, getChannelName());
         }
         return newPromise;
     }

File: src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -199,7 +199,7 @@ public void message(String channel, Object message) {
         };
 
         synchronized (ENTRIES) {
-            connectionManager.subscribeOnce(listener, getChannelName());
+            connectionManager.subscribe(listener, getChannelName());
         }
         return newPromise;
     }

File: src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -54,7 +54,7 @@ public interface ConnectionManager {
 
     <K, V> PubSubConnectionEntry subscribe(String channelName);
 
-    <K, V> PubSubConnectionEntry subscribeOnce(RedisPubSubAdapter<V> listener, String channelName);
+    <K, V> PubSubConnectionEntry subscribe(RedisPubSubAdapter<V> listener, String channelName);
 
     Future unsubscribe(String channelName);
 

File: src/main/java/org/redisson/RedissonCountDownLatch.java
Patch:
@@ -101,7 +101,7 @@ public void message(String channel, Integer message) {
         };
 
         synchronized (connectionManager) {
-            connectionManager.subscribe(listener, getChannelName());
+            connectionManager.subscribeOnce(listener, getChannelName());
         }
         return newPromise;
     }

File: src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -54,7 +54,7 @@ public interface ConnectionManager {
 
     <K, V> PubSubConnectionEntry subscribe(String channelName);
 
-    <K, V> PubSubConnectionEntry subscribe(RedisPubSubAdapter<V> listener, String channelName);
+    <K, V> PubSubConnectionEntry subscribeOnce(RedisPubSubAdapter<V> listener, String channelName);
 
     Future unsubscribe(String channelName);
 

File: src/test/java/org/redisson/RedissonLockTest.java
Patch:
@@ -41,7 +41,7 @@ public void run() {
                 RLock lock1 = redisson.getLock("lock");
                 lock1.lock();
                 long spendTime = System.currentTimeMillis() - startTime;
-                Assert.assertTrue(spendTime < 2010);
+                Assert.assertTrue(spendTime < 2020);
                 lock1.unlock();
                 latch.countDown();
             };

File: src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -178,7 +178,8 @@ private Future<Boolean> subscribe() {
 
             @Override
             public void subscribed(String channel, long count) {
-                if (getChannelName().equals(channel)) {
+                if (getChannelName().equals(channel)
+                        && !value.getPromise().isSuccess()) {
                     value.getPromise().setSuccess(true);
                 }
             }

File: src/test/java/org/redisson/RedissonLockTest.java
Patch:
@@ -33,15 +33,15 @@ public void after() {
     public void testExpire() throws InterruptedException {
         RLock lock = redisson.getLock("lock");
         lock.lock(2, TimeUnit.SECONDS);
-        
+
         final long startTime = System.currentTimeMillis();
         final CountDownLatch latch = new CountDownLatch(1);
         new Thread() {
             public void run() {
                 RLock lock1 = redisson.getLock("lock");
                 lock1.lock();
                 long spendTime = System.currentTimeMillis() - startTime;
-                Assert.assertTrue(spendTime < 2005);
+                Assert.assertTrue(spendTime < 2010);
                 lock1.unlock();
                 latch.countDown();
             };
@@ -51,7 +51,7 @@ public void run() {
 
         lock.unlock();
     }
-    
+
     @Test
     public void testGetHoldCount() {
         RLock lock = redisson.getLock("lock");

File: src/main/java/org/redisson/RedissonLockEntry.java
Patch:
@@ -34,7 +34,7 @@ public RedissonLockEntry(RedissonLockEntry source) {
     
     public RedissonLockEntry(Promise<Boolean> promise) {
         super();
-        this.latch = new Semaphore(1);
+        this.latch = new Semaphore(0);
         this.promise = promise;
     }
     

File: src/main/java/org/redisson/RedissonLockEntry.java
Patch:
@@ -34,7 +34,7 @@ public RedissonLockEntry(RedissonLockEntry source) {
     
     public RedissonLockEntry(Promise<Boolean> promise) {
         super();
-        this.latch = new Semaphore(1);
+        this.latch = new Semaphore(0);
         this.promise = promise;
     }
     

File: src/main/java/org/redisson/connection/SingleConnectionManager.java
Patch:
@@ -38,7 +38,8 @@ public SingleConnectionManager(SingleServerConfig cfg, Config config) {
     protected void init(MasterSlaveServersConfig config) {
         this.config = config;
 
-        entry = new SingleEntry(codec, group, config);
+        SingleEntry entry = new SingleEntry(codec, group, config);
+        entries.put(Integer.MAX_VALUE, entry);
     }
 
 

File: src/test/java/org/redisson/RedissonConcurrentMapTest.java
Patch:
@@ -94,6 +94,7 @@ public void run(Redisson redisson) {
         }
         assertMapSize(5, name);
 
+        redisson.flushdb();
         redisson.shutdown();
     }
 

File: src/main/java/org/redisson/RedissonTopic.java
Patch:
@@ -80,7 +80,9 @@ public void removeListener(int listenerId) {
         synchronized (entry) {
             if (entry.isActive()) {
                 entry.removeListener(getName(), listenerId);
-                connectionManager.unsubscribe(getName());
+                if (entry.getListeners(getName()).isEmpty()) {
+                    connectionManager.unsubscribe(getName());
+                }
                 return;
             }
         }

File: src/main/java/org/redisson/RedissonTopic.java
Patch:
@@ -80,7 +80,9 @@ public void removeListener(int listenerId) {
         synchronized (entry) {
             if (entry.isActive()) {
                 entry.removeListener(getName(), listenerId);
-                connectionManager.unsubscribe(getName());
+                if (entry.getListeners(getName()).isEmpty()) {
+                    connectionManager.unsubscribe(getName());
+                }
                 return;
             }
         }

File: src/main/java/com/lambdaworks/redis/protocol/CommandOutput.java
Patch:
@@ -107,6 +107,9 @@ public void complete(int depth) {
     }
 
     protected String decodeAscii(ByteBuffer bytes) {
+        if (bytes == null) {
+            return null;
+        }
         char[] chars = new char[bytes.remaining()];
         for (int i = 0; i < chars.length; i++) {
             chars[i] = (char) bytes.get();

File: src/main/java/org/redisson/connection/BaseLoadBalancer.java
Patch:
@@ -148,6 +148,7 @@ public RedisPubSubConnection nextPubSubConnection() {
                     entry.registerSubscribeConnection(conn);
                     return conn;
                 } catch (RedisConnectionException e) {
+                    entry.getConnectionsSemaphore().release();
                     // TODO connection scoring
                     log.warn("Can't connect to {}, trying next connection!", entry.getClient().getAddr());
                     clientsCopy.remove(index);
@@ -187,6 +188,7 @@ public RedisConnection nextConnection() {
                     }
                     return conn;
                 } catch (RedisConnectionException e) {
+                    entry.getConnectionsSemaphore().release();
                     // TODO connection scoring
                     log.warn("Can't connect to {}, trying next connection!", entry.getClient().getAddr());
                     clientsCopy.remove(index);

File: src/main/java/com/lambdaworks/redis/RedisClient.java
Patch:
@@ -176,7 +176,7 @@ protected void initChannel(Channel ch) throws Exception {
             }
             connect.sync();
 
-            watchdog.setReconnect(true);
+            connection.setReconnect(true);
 
             return connection;
         } catch (Throwable e) {

File: src/test/java/org/redisson/RedissonConcurrentMapTest.java
Patch:
@@ -90,7 +90,7 @@ public void run(Redisson redisson) {
 
         ConcurrentMap<Integer, Integer> testMap = Redisson.create().getMap(name);
         for (Integer value : testMap.values()) {
-            Assert.assertTrue(2 == value);
+            Assert.assertEquals(2, (int)value);
         }
         assertMapSize(5, name);
 

File: src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -455,7 +455,6 @@ public int getHoldCount() {
     @Override
     public void delete() {
         forceUnlock();
-        release();
     }
 
 }

File: src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -39,7 +39,6 @@
 
 import com.lambdaworks.redis.RedisClient;
 import com.lambdaworks.redis.RedisConnection;
-import com.lambdaworks.redis.RedisConnectionClosedException;
 import com.lambdaworks.redis.codec.RedisCodec;
 import com.lambdaworks.redis.pubsub.RedisPubSubAdapter;
 import com.lambdaworks.redis.pubsub.RedisPubSubConnection;

File: src/main/java/org/redisson/connection/PubSubConnectionEntry.java
Patch:
@@ -29,7 +29,6 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.lambdaworks.redis.RedisConnectionClosedException;
 import com.lambdaworks.redis.pubsub.RedisPubSubAdapter;
 import com.lambdaworks.redis.pubsub.RedisPubSubConnection;
 import com.lambdaworks.redis.pubsub.RedisPubSubListener;

File: src/main/java/com/lambdaworks/redis/pubsub/RedisPubSubConnection.java
Patch:
@@ -8,6 +8,7 @@
 import static com.lambdaworks.redis.protocol.CommandType.UNSUBSCRIBE;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.EventLoopGroup;
+import io.netty.util.concurrent.Future;
 
 import java.lang.reflect.Array;
 import java.util.Collection;
@@ -88,8 +89,8 @@ public void subscribe(String... channels) {
         dispatch(SUBSCRIBE, new PubSubOutput<K, V>(codec), args(channels));
     }
 
-    public void unsubscribe(String... channels) {
-        dispatch(UNSUBSCRIBE, new PubSubOutput<K, V>(codec), args(channels));
+    public Future<V> unsubscribe(String... channels) {
+        return dispatch(UNSUBSCRIBE, new PubSubOutput<K, V>(codec), args(channels));
     }
 
     @Override

File: src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -16,6 +16,7 @@
 package org.redisson.connection;
 
 import io.netty.channel.EventLoopGroup;
+import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.FutureListener;
 
 import com.lambdaworks.redis.RedisConnection;
@@ -43,7 +44,7 @@ public interface ConnectionManager {
 
     <K, V> PubSubConnectionEntry subscribe(RedisPubSubAdapter<V> listener, String channelName);
 
-    void unsubscribe(String channelName);
+    Future unsubscribe(String channelName);
 
     void releaseWrite(RedisConnection onnection);
 

File: src/main/java/org/redisson/core/RExpirable.java
Patch:
@@ -41,9 +41,11 @@ public interface RExpirable extends RObject {
     boolean clearExpire();
 
     /**
-     * Remaining time in seconds to live of Redisson object that has a timeout
+     * Remaining time to live of Redisson object that has a timeout
      *
      * @return time in seconds
+     *          -2 if the key does not exist.
+     *          -1 if the key exists but has no associated expire.
      */
     long remainTimeToLive();
 

File: src/main/java/org/redisson/connection/BaseLoadBalancer.java
Patch:
@@ -78,6 +78,7 @@ public RedisPubSubConnection nextPubSubConnection() {
         List<ConnectionEntry> clientsCopy = new ArrayList<ConnectionEntry>(clients);
         if (clientsCopy.isEmpty()) {
             clientsEmpty.awaitUninterruptibly();
+            return nextPubSubConnection();
         }
         while (true) {
             if (clientsCopy.isEmpty()) {
@@ -118,6 +119,7 @@ public RedisConnection nextConnection() {
         List<ConnectionEntry> clientsCopy = new ArrayList<ConnectionEntry>(clients);
         if (clientsCopy.isEmpty()) {
             clientsEmpty.awaitUninterruptibly();
+            return nextConnection();
         }
         while (true) {
             if (clientsCopy.isEmpty()) {

File: src/main/java/org/redisson/connection/SingleConnectionManager.java
Patch:
@@ -38,6 +38,7 @@ public class SingleConnectionManager extends MasterSlaveConnectionManager {
     public SingleConnectionManager(SingleConnectionConfig cfg, Config config) {
         MasterSlaveConnectionConfig newconfig = new MasterSlaveConnectionConfig();
         String addr = cfg.getAddress().getHost() + ":" + cfg.getAddress().getPort();
+        newconfig.setPassword(cfg.getPassword());
         newconfig.setMasterAddress(addr);
         newconfig.setMasterConnectionPoolSize(cfg.getConnectionPoolSize());
         newconfig.setSubscriptionsPerConnection(cfg.getSubscriptionsPerConnection());

File: src/main/java/com/lambdaworks/redis/RedisClient.java
Patch:
@@ -196,7 +196,6 @@ public void shutdown() {
         }
         ChannelGroupFuture future = channels.close();
         future.awaitUninterruptibly();
-        bootstrap.group().shutdownGracefully().syncUninterruptibly();
     }
 
     public InetSocketAddress getAddr() {

File: src/main/java/org/redisson/connection/LoadBalancer.java
Patch:
@@ -15,7 +15,7 @@
  */
 package org.redisson.connection;
 
-import java.util.List;
+import java.util.Queue;
 
 import com.lambdaworks.redis.RedisConnection;
 import com.lambdaworks.redis.codec.RedisCodec;
@@ -27,7 +27,7 @@ public interface LoadBalancer {
 
     void add(ConnectionEntry entry);
 
-    void remove(String host, int port);
+    Queue<RedisPubSubConnection> remove(String host, int port);
 
     RedisConnection nextConnection();
 

File: src/main/java/org/redisson/connection/RoundRobinLoadBalancer.java
Patch:
@@ -24,7 +24,7 @@ public class RoundRobinLoadBalancer extends BaseLoadBalancer {
 
     @Override
     int getIndex(List<ConnectionEntry> clientsCopy) {
-        return Math.abs(index.incrementAndGet() % clients.size());
+        return Math.abs(index.incrementAndGet() % clientsCopy.size());
     }
 
 }

File: src/main/java/org/redisson/RedisPubSubTopicListenerWrapper.java
Patch:
@@ -26,7 +26,7 @@
  * @param <K>
  * @param <V>
  */
-public class RedisPubSubTopicListenerWrapper<V> extends RedisPubSubAdapter<String, V> {
+public class RedisPubSubTopicListenerWrapper<K, V> extends RedisPubSubAdapter<K, V> {
 
     private final MessageListener<V> listener;
     private final String name;
@@ -42,7 +42,7 @@ public RedisPubSubTopicListenerWrapper(MessageListener<V> listener, String name)
     }
 
     @Override
-    public void message(String channel, V message) {
+    public void message(K channel, V message) {
         // could be subscribed to multiple channels
         if (name.equals(channel)) {
             listener.onMessage(message);

File: src/main/java/org/redisson/RedissonTopic.java
Patch:
@@ -50,7 +50,7 @@ public Future<Long> publishAsync(M message) {
 
     @Override
     public int addListener(MessageListener<M> listener) {
-        RedisPubSubTopicListenerWrapper<M> pubSubListener = new RedisPubSubTopicListenerWrapper<M>(listener, getName());
+        RedisPubSubTopicListenerWrapper<String, M> pubSubListener = new RedisPubSubTopicListenerWrapper<String, M>(listener, getName());
         PubSubConnectionEntry entry = connectionManager.subscribe(getName());
         synchronized (entry) {
             entry.addListener(pubSubListener);

File: src/main/java/org/redisson/SingleConnectionConfig.java
Patch:
@@ -40,7 +40,7 @@ public class SingleConnectionConfig extends BaseConfig<SingleConnectionConfig> {
     SingleConnectionConfig() {
     }
 
-    public SingleConnectionConfig(SingleConnectionConfig config) {
+    SingleConnectionConfig(SingleConnectionConfig config) {
         super(config);
         setAddress(config.getAddress());
         setConnectionPoolSize(config.getConnectionPoolSize());

File: src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -110,6 +110,7 @@ public boolean equals(Object obj) {
 
     private final AtomicReference<Promise<Boolean>> promise = new AtomicReference<Promise<Boolean>>();
 
+    // TODO use lazy init map
     private final Semaphore msg = new Semaphore(1);
 
     private PubSubConnectionEntry pubSubEntry;

File: src/main/java/org/redisson/connection/LoadBalancer.java
Patch:
@@ -23,7 +23,7 @@
 
 public interface LoadBalancer {
 
-    void init(List<ConnectionEntry> clients, RedisCodec codec);
+    void init(List<ConnectionEntry> clients, RedisCodec codec, String password);
 
     RedisConnection nextConnection();
 

File: src/main/java/org/redisson/connection/MasterSlaveConnectionManager.java
Patch:
@@ -87,7 +87,7 @@ void init(MasterSlaveConnectionConfig config, Config cfg) {
 
         codec = new RedisCodecWrapper(cfg.getCodec());
         balancer = config.getLoadBalancer();
-        balancer.init(slaveConnections, codec);
+        balancer.init(slaveConnections, codec, config.getPassword());
 
         masterConnectionsSemaphore = new Semaphore(this.config.getMasterConnectionPoolSize());
     }

File: src/main/java/org/redisson/core/RHyperLogLog.java
Patch:
@@ -15,8 +15,9 @@
  */
 package org.redisson.core;
 
+import io.netty.util.concurrent.Future;
+
 import java.util.Collection;
-import java.util.concurrent.Future;
 
 public interface RHyperLogLog<V> extends RObject {
 

File: src/main/java/org/redisson/RedissonCountDownLatch.java
Patch:
@@ -106,7 +106,9 @@ public void await() throws InterruptedException {
 
     @Override
     public boolean await(long time, TimeUnit unit) throws InterruptedException {
-        subscribe().await(time, unit);
+        if (!subscribe().await(time, unit)) {
+            return false;
+        }
 
         time = unit.toMillis(time);
         while (getCount() > 0) {

File: src/main/java/com/lambdaworks/redis/RedisAsyncConnection.java
Patch:
@@ -270,7 +270,7 @@ public Future<V> echo(V msg) {
 
     public <T> Future<T> eval(V script, ScriptOutputType type, K[] keys, V... values) {
         CommandArgs<K, V> args = new CommandArgs<K, V>(codec);
-        args.addValue(script).add(keys.length).addKeys(keys).addValues(values);
+        args.add(script.toString()).add(keys.length).addKeys(keys).addValues(values);
         CommandOutput<K, V, T> output = newScriptOutput(codec, type);
         return dispatch(EVAL, output, args);
     }

File: src/main/java/com/lambdaworks/redis/RedisConnection.java
Patch:
@@ -278,7 +278,7 @@ public Map<K, V> hgetall(K key) {
         return await(c.hgetall(key));
     }
 
-    public List<K> hkeys(K key) {
+    public Set<K> hkeys(K key) {
         return await(c.hkeys(key));
     }
 

File: src/main/java/com/lambdaworks/redis/output/MapOutput.java
Patch:
@@ -27,11 +27,11 @@ public MapOutput(RedisCodec<K, V> codec) {
     @Override
     public void set(ByteBuffer bytes) {
         if (key == null) {
-            key = codec.decodeKey(bytes);
+            key = codec.decodeMapKey(bytes);
             return;
         }
 
-        V value = (bytes == null) ? null : codec.decodeValue(bytes);
+        V value = (bytes == null) ? null : codec.decodeMapValue(bytes);
         output.put(key, value);
         key = null;
     }

File: src/main/java/com/lambdaworks/redis/output/ValueSetOutput.java
Patch:
@@ -23,6 +23,6 @@ public ValueSetOutput(RedisCodec<K, V> codec) {
 
     @Override
     public void set(ByteBuffer bytes) {
-        output.add(bytes == null ? null : codec.decodeValue(bytes));
+        output.add(bytes == null ? null : codec.decodeMapValue(bytes));
     }
 }

File: src/main/java/com/lambdaworks/redis/protocol/CommandHandler.java
Patch:
@@ -44,10 +44,10 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
         ByteBuf input = (ByteBuf) msg;
         try {
             if (!input.isReadable()) return;
-    
+
             buffer.discardReadBytes();
             buffer.writeBytes(input);
-    
+
             decode(ctx, buffer);
         } finally {
             input.release();
@@ -57,7 +57,6 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
     @Override
     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
         Command<?, ?, ?> cmd = (Command<?, ?, ?>) msg;
-        Channel channel = ctx.channel();
         ByteBuf buf = ctx.alloc().heapBuffer();
         cmd.encode(buf);
         ctx.write(buf, promise);

File: src/main/java/org/redisson/RedissonAtomicLong.java
Patch:
@@ -68,7 +68,7 @@ public boolean compareAndSet(long expect, long update) {
                 conn.watch(getName());
                 Long value = ((Number) conn.get(getName())).longValue();
                 if (value != expect) {
-                    conn.discard();
+                    conn.unwatch();
                     return false;
                 }
                 conn.multi();

File: src/main/java/org/redisson/RedissonCountDownLatch.java
Patch:
@@ -167,7 +167,7 @@ public boolean trySetCount(long count) {
             connection.watch(getName());
             Long oldValue = (Long) connection.get(getName());
             if (oldValue != null) {
-                connection.discard();
+                connection.unwatch();
                 return false;
             }
             connection.multi();

File: src/main/java/org/redisson/Redisson.java
Patch:
@@ -249,6 +249,7 @@ public RAtomicLong getAtomicLong(String name) {
             }
         }
 
+        atomicLong.init();
         return atomicLong;
 
     }

File: src/test/java/org/redisson/ConcurrentRedissonSortedSetTest.java
Patch:
@@ -14,7 +14,7 @@ public class ConcurrentRedissonSortedSetTest extends BaseConcurrentTest {
 
     @Test
     public void testAdd_SingleInstance() throws InterruptedException {
-        final String name = "testSingleReplaceOldValue_SingleInstance";
+        final String name = "testAdd_SingleInstance";
 
         Redisson r = Redisson.create();
         RSortedSet<Integer> map = r.getSortedSet(name);
@@ -36,6 +36,8 @@ public void run(Redisson redisson) {
             elements.add(i);
         }
         MatcherAssert.assertThat(map, Matchers.contains(elements.toArray(new Integer[elements.size()])));
+
+        map.clear();
         r.shutdown();
     }
 

File: src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -105,7 +105,7 @@ public boolean equals(Object obj) {
     private final ConnectionManager connectionManager;
 
     private final UUID id;
-    private final String groupName = "redisson_lock_";
+    private final String groupName = "redisson__lock__";
 
     private static final Integer unlockMessage = 0;
 

File: src/main/java/org/redisson/RedissonSubSortedSet.java
Patch:
@@ -50,7 +50,7 @@ public int size() {
 
     private double getTailScore(RedisConnection<Object, V> connection) {
         if (tailValue != null) {
-            return redissonSortedSet.score(tailValue, connection, 0, true);
+            return redissonSortedSet.score(tailValue, connection, 1, true);
         }
         return Double.MAX_VALUE;
     }

File: src/main/java/org/redisson/connection/ConnectionManager.java
Patch:
@@ -162,8 +162,8 @@ public <K> void unsubscribe(PubSubEntry entry, K channel) {
     }
 
     public void release(RedisConnection onnection) {
-        activeConnections.release();
         connections.add(onnection);
+        activeConnections.release();
     }
 
     public void shutdown() {

File: src/main/java/org/redisson/RedissonCountDownLatch.java
Patch:
@@ -123,8 +123,8 @@ public void countDown() {
             RedisConnection<Object, Object> conn = redisson.connect();
             try {
                 conn.multi();
-                conn.publish(getChannelName(), zeroCountMessage);
                 conn.del(name);
+                conn.publish(getChannelName(), zeroCountMessage);
                 conn.exec();
             } finally {
                 conn.close();

File: src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -182,7 +182,7 @@ public boolean tryLock() {
         Boolean res = connection.setnx(getKeyName(), currentLock);
         if (!res) {
             LockValue lock = (LockValue) connection.get(getKeyName());
-            if (lock.equals(currentLock)) {
+            if (lock != null && lock.equals(currentLock)) {
                 lock.incCounter();
                 connection.set(getKeyName(), lock);
                 return true;

File: src/main/java/org/redisson/RedissonCountDownLatch.java
Patch:
@@ -109,14 +109,16 @@ public boolean await(long time, TimeUnit unit) throws InterruptedException {
 
     @Override
     public void countDown() {
-        if (getCount() == 0) {
+        if (getCount() <= 0) {
             return;
         }
 
         Long val = connection.decr(name);
         if (val == 0) {
             connection.publish(getChannelName(), unlockMessage);
             connection.del(name);
+        } else if (val < 0) {
+            connection.del(name);
         }
     }
 

File: src/main/java/org/redisson/misc/internal/ThreadLocalSemaphore.java
Patch:
@@ -15,6 +15,7 @@ public ThreadLocalSemaphore() {
         semaphore = new ThreadLocal<Semaphore>() {
             @Override protected Semaphore initialValue() {
                 Semaphore value = new Semaphore(1);
+                value.acquireUninterruptibly();
                 allValues.add(value);
                 return value;
             }

File: src/test/java/org/redisson/RedissonCountDownLatchConcurrentTest.java
Patch:
@@ -1,7 +1,7 @@
 package org.redisson;
 
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 
 import org.junit.Assert;
@@ -18,7 +18,7 @@ public void testSingleCountDownAwait_SingleInstance() throws InterruptedExceptio
         final RCountDownLatch latch = redisson.getCountDownLatch("latch");
         latch.trySetCount(iterations);
 
-        ScheduledExecutorService executor = Executors.newScheduledThreadPool(iterations);
+        ExecutorService executor = Executors.newFixedThreadPool(iterations);
         for (int i = 0; i < iterations; i++) {
             executor.execute(new Runnable() {
                 @Override

File: src/main/java/org/redisson/core/RCountDownLatch.java
Patch:
@@ -25,8 +25,8 @@ public interface RCountDownLatch {
 
     void countDown();
 
-    int getCount();
+    long getCount();
 
-    boolean trySetCount(int count);
+    boolean trySetCount(long count);
 
 }

File: src/main/java/org/redisson/Redisson.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.concurrent.locks.Lock;
 
 import org.redisson.core.RAtomicLong;
+import org.redisson.core.RCountDownLatch;
 import org.redisson.core.RTopic;
 
 import com.lambdaworks.redis.RedisClient;
@@ -184,7 +185,7 @@ public RAtomicLong getAtomicLong(String name) {
 
     }
 
-    public RedissonCountDownLatch getCountDownLatch(String name) {
+    public RCountDownLatch getCountDownLatch(String name) {
         RedissonCountDownLatch latch = latchesMap.get(name);
         if (latch == null) {
             RedisConnection<Object, Object> connection = connect();

File: src/main/java/org/redisson/RedissonCountDownLatch.java
Patch:
@@ -31,7 +31,8 @@ public class RedissonCountDownLatch implements RCountDownLatch {
     private final CountDownLatch subscribeLatch = new CountDownLatch(1);
     private final RedisPubSubConnection<Object, Object> pubSubConnection;
     private final RedisConnection<Object, Object> connection;
-    private final String groupName = "redisson_countdownlatch";
+
+    private final String groupName = "redisson_countdownlatch_";
     private final String name;
 
     private static final Integer unlockMessage = 0;

File: src/main/java/org/redisson/Redisson.java
Patch:
@@ -151,7 +151,9 @@ public void getExecutorService() {
 
     }
 
-
+    public void shutdown() {
+        redisClient.shutdown();
+    }
 
     RedisConnection<Object, Object> connect() {
         return redisClient.connect(codec);

File: src/main/java/org/redisson/RedissonTopic.java
Patch:
@@ -1,7 +1,7 @@
 package org.redisson;
 
-import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
 
@@ -18,7 +18,7 @@ public class RedissonTopic<M> implements RTopic<M> {
     private final CountDownLatch subscribeLatch = new CountDownLatch(1);
     private final AtomicBoolean subscribeOnce = new AtomicBoolean();
 
-    private final Map<Integer, RedisPubSubTopicListener> listeners = new HashMap<Integer, RedisPubSubTopicListener>();
+    private final Map<Integer, RedisPubSubTopicListener> listeners = new ConcurrentHashMap<Integer, RedisPubSubTopicListener>();
     private final RedisPubSubConnection<Object, Object> pubSubConnection;
     private final RedisConnection<Object, Object> connection;
     private final String name;

File: src/test/java/org/redisson/RedissonRunnable.java
Patch:
@@ -1,6 +1,6 @@
 package org.redisson;
 
-public interface SingleInstanceRunnable {
+public interface RedissonRunnable {
 
     void run(Redisson redisson);
 

File: src/main/java/org/redisson/RedissonSet.java
Patch:
@@ -75,10 +75,10 @@ public boolean addAll(Collection<? extends V> c) {
 
     @Override
     public boolean retainAll(Collection<?> c) {
-        int changed = 0;
         RedisConnection<Object, Object> conn = redisson.connect();
         try {
             while (true) {
+                int changed = 0;
                 conn.watch(name);
                 Iterator<V> iterator = (Iterator<V>) conn.smembers(name).iterator();
                 conn.multi();

File: src/main/java/org/redisson/RedissonLock.java
Patch:
@@ -98,6 +98,9 @@ public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
             msg.tryAcquire(time, TimeUnit.MILLISECONDS);
             long elapsed = System.currentTimeMillis() - current;
             time -= elapsed;
+            if (time <= 0) {
+                return false;
+            }
         }
         return true;
     }

