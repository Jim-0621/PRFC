File: gson/src/main/java/com/google/gson/reflect/TypeToken.java
Patch:
@@ -440,7 +440,8 @@ public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments)
       }
     }
 
-    return new TypeToken<>($Gson$Types.newParameterizedTypeWithOwner(null, rawType, typeArguments));
+    return new TypeToken<>(
+        $Gson$Types.newParameterizedTypeWithOwner(null, rawClass, typeArguments));
   }
 
   /**

File: gson/src/main/java/com/google/gson/internal/$Gson$Types.java
Patch:
@@ -328,8 +328,8 @@ public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawTyp
      * class should extend Hashtable<String, String>, but it's declared to
      * extend Hashtable<Object, Object>.
      */
-    if (context == Properties.class) {
-      return new Type[] {String.class, String.class}; // TODO: test subclasses of Properties!
+    if (Properties.class.isAssignableFrom(contextRawType)) {
+      return new Type[] {String.class, String.class};
     }
 
     Type mapType = getSupertype(context, contextRawType, Map.class);

File: gson/src/main/java/com/google/gson/JsonIOException.java
Patch:
@@ -21,6 +21,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
+@SuppressWarnings("MemberName") // class name is part of the public API
 public final class JsonIOException extends JsonParseException {
   private static final long serialVersionUID = 1L;
 

File: gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java
Patch:
@@ -31,6 +31,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
+@SuppressWarnings("MemberName") // legacy class name
 public final class $Gson$Preconditions {
   private $Gson$Preconditions() {
     throw new UnsupportedOperationException();

File: gson/src/main/java/com/google/gson/internal/$Gson$Types.java
Patch:
@@ -42,6 +42,7 @@
  * @author Bob Lee
  * @author Jesse Wilson
  */
+@SuppressWarnings("MemberName") // legacy class name
 public final class $Gson$Types {
   static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};
 

File: gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
Patch:
@@ -35,6 +35,7 @@
  */
 // Date parsing code from Jackson databind ISO8601Utils.java
 // https://github.com/FasterXML/jackson-databind/blob/2.8/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java
+@SuppressWarnings("MemberName") // legacy class name
 public class ISO8601Utils {
   private ISO8601Utils() {}
 

File: gson/src/test/java/com/google/gson/functional/ReflectionAccessFilterTest.java
Patch:
@@ -18,7 +18,6 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.assertThrows;
-import static org.junit.Assume.assumeNotNull;
 
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
@@ -81,12 +80,12 @@ public void testBlockInaccessibleJava() throws ReflectiveOperationException {
 
     // But serialization should succeed for classes with only public fields.
     // Not many JDK classes have mutable public fields, thank goodness, but java.awt.Point does.
-    Class<?> pointClass = null;
+    Class<?> pointClass;
     try {
       pointClass = Class.forName("java.awt.Point");
     } catch (ClassNotFoundException ignored) {
+      return; // If not found then we don't have AWT and the rest of the test can be skipped.
     }
-    assumeNotNull(pointClass);
     Constructor<?> pointConstructor = pointClass.getConstructor(int.class, int.class);
     Object point = pointConstructor.newInstance(1, 2);
     String json = gson.toJson(point);

File: gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java
Patch:
@@ -222,6 +222,7 @@ static class Manager extends Employee {
     Employee[] minions;
   }
 
+  @SuppressWarnings("MemberName")
   static class CEO extends Manager {
     Employee assistant;
   }

File: gson/src/test/java/com/google/gson/functional/VersioningTest.java
Patch:
@@ -187,11 +187,13 @@ private static class Version1 {
     int b = B;
   }
 
+  @SuppressWarnings("MemberName")
   private static class Version1_1 extends Version1 {
     @Since(1.1)
     int c = C;
   }
 
+  @SuppressWarnings("MemberName")
   @Since(1.2)
   private static class Version1_2 extends Version1_1 {
     @SuppressWarnings("unused")

File: gson/src/test/java/com/google/gson/integration/OSGiManifestIT.java
Patch:
@@ -45,6 +45,7 @@
  * Running Maven's {@code clean} phase is necessary due to a <a
  * href="https://github.com/bndtools/bnd/issues/6221">bnd-maven-plugin bug</a>.
  */
+@SuppressWarnings("MemberName") // class name must end with 'IT' for Maven Failsafe Plugin
 public class OSGiManifestIT {
   private static class ManifestData {
     public final URL url;

File: gson/src/test/java/com/google/gson/internal/bind/util/ISO8601UtilsTest.java
Patch:
@@ -28,6 +28,7 @@
 import java.util.TimeZone;
 import org.junit.Test;
 
+@SuppressWarnings("MemberName") // class name
 public class ISO8601UtilsTest {
 
   private static TimeZone utcTimeZone() {

File: test-shrinker/src/test/java/com/google/gson/it/ShrinkingIT.java
Patch:
@@ -40,6 +40,7 @@
 import org.junit.runners.Parameterized.Parameters;
 
 /** Integration test verifying behavior of shrunken and obfuscated JARs. */
+@SuppressWarnings("MemberName") // class name must end with 'IT' for Maven Failsafe Plugin
 @RunWith(Parameterized.class)
 public class ShrinkingIT {
   // These JAR files are prepared by the Maven build

File: extras/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java
Patch:
@@ -52,7 +52,7 @@ public GraphAdapterBuilder() {
   }
 
   public GraphAdapterBuilder addType(Type type) {
-    final ObjectConstructor<?> objectConstructor = constructorConstructor.get(TypeToken.get(type));
+    ObjectConstructor<?> objectConstructor = constructorConstructor.get(TypeToken.get(type));
     InstanceCreator<Object> instanceCreator =
         new InstanceCreator<Object>() {
           @Override
@@ -95,8 +95,8 @@ public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
         return null;
       }
 
-      final TypeAdapter<T> typeAdapter = gson.getDelegateAdapter(this, type);
-      final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
+      TypeAdapter<T> typeAdapter = gson.getDelegateAdapter(this, type);
+      TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       return new TypeAdapter<T>() {
         @Override
         public void write(JsonWriter out, T value) throws IOException {

File: extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
Patch:
@@ -252,9 +252,9 @@ public <R> TypeAdapter<R> create(Gson gson, TypeToken<R> type) {
       return null;
     }
 
-    final TypeAdapter<JsonElement> jsonElementAdapter = gson.getAdapter(JsonElement.class);
-    final Map<String, TypeAdapter<?>> labelToDelegate = new LinkedHashMap<>();
-    final Map<Class<?>, TypeAdapter<?>> subtypeToDelegate = new LinkedHashMap<>();
+    TypeAdapter<JsonElement> jsonElementAdapter = gson.getAdapter(JsonElement.class);
+    Map<String, TypeAdapter<?>> labelToDelegate = new LinkedHashMap<>();
+    Map<Class<?>, TypeAdapter<?>> subtypeToDelegate = new LinkedHashMap<>();
     for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {
       TypeAdapter<?> delegate = gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));
       labelToDelegate.put(entry.getKey(), delegate);

File: extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
Patch:
@@ -88,7 +88,7 @@ public boolean equals(Object o) {
       if (!(o instanceof Sandwich)) {
         return false;
       }
-      final Sandwich other = (Sandwich) o;
+      Sandwich other = (Sandwich) o;
       if (this.bread == null ? other.bread != null : !this.bread.equals(other.bread)) {
         return false;
       }
@@ -115,7 +115,7 @@ public boolean equals(Object o) {
       if (!(o instanceof MultipleSandwiches)) {
         return false;
       }
-      final MultipleSandwiches other = (MultipleSandwiches) o;
+      MultipleSandwiches other = (MultipleSandwiches) o;
       if (this.sandwiches == null
           ? other.sandwiches != null
           : !this.sandwiches.equals(other.sandwiches)) {

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -538,7 +538,7 @@ public void write(JsonWriter out, Number value) throws IOException {
     };
   }
 
-  private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {
+  private static TypeAdapter<AtomicLong> atomicLongAdapter(TypeAdapter<Number> longAdapter) {
     return new TypeAdapter<AtomicLong>() {
       @Override
       public void write(JsonWriter out, AtomicLong value) throws IOException {
@@ -554,7 +554,7 @@ public AtomicLong read(JsonReader in) throws IOException {
   }
 
   private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(
-      final TypeAdapter<Number> longAdapter) {
+      TypeAdapter<Number> longAdapter) {
     return new TypeAdapter<AtomicLongArray>() {
       @Override
       public void write(JsonWriter out, AtomicLongArray value) throws IOException {
@@ -682,7 +682,7 @@ public <T> TypeAdapter<T> getAdapter(Class<T> type) {
    *   public int numReads = 0;
    *   public int numWrites = 0;
    *   public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
-   *     final TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);
+   *     TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);
    *     return new TypeAdapter<T>() {
    *       public void write(JsonWriter out, T value) throws IOException {
    *         ++numWrites;

File: gson/src/main/java/com/google/gson/TypeAdapterFactory.java
Patch:
@@ -117,7 +117,7 @@
  *   }
  *
  *   private <E> TypeAdapter<Multiset<E>> newMultisetAdapter(
- *       final TypeAdapter<E> elementAdapter) {
+ *       TypeAdapter<E> elementAdapter) {
  *     return new TypeAdapter<Multiset<E>>() {
  *       public void write(JsonWriter out, Multiset<E> value) throws IOException {
  *         if (value == null) {

File: gson/src/main/java/com/google/gson/internal/Excluder.java
Patch:
@@ -108,11 +108,11 @@ public Excluder withExclusionStrategy(
   }
 
   @Override
-  public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {
+  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
     Class<?> rawType = type.getRawType();
 
-    final boolean skipSerialize = excludeClass(rawType, true);
-    final boolean skipDeserialize = excludeClass(rawType, false);
+    boolean skipSerialize = excludeClass(rawType, true);
+    boolean skipDeserialize = excludeClass(rawType, false);
 
     if (!skipSerialize && !skipDeserialize) {
       return null;

File: gson/src/main/java/com/google/gson/internal/NonNullElementWrapperList.java
Patch:
@@ -127,5 +127,6 @@ public int hashCode() {
     return delegate.hashCode();
   }
 
-  // TODO: Once Gson targets Java 8 also override List.sort
+  // Maybe also delegate List#sort and List#spliterator in the future, but that
+  // requires Android API level 24
 }

File: gson/src/main/java/com/google/gson/internal/ReflectionAccessFilterHelper.java
Patch:
@@ -85,7 +85,7 @@ private abstract static class AccessChecker {
       // TODO: Ideally should use Multi-Release JAR for this version specific code
       if (JavaVersion.isJava9OrLater()) {
         try {
-          final Method canAccessMethod =
+          Method canAccessMethod =
               AccessibleObject.class.getDeclaredMethod("canAccess", Object.class);
           accessChecker =
               new AccessChecker() {

File: gson/src/main/java/com/google/gson/internal/bind/EnumTypeAdapter.java
Patch:
@@ -54,7 +54,7 @@ public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
   private final Map<String, T> stringToConstant = new HashMap<>();
   private final Map<T, String> constantToName = new HashMap<>();
 
-  private EnumTypeAdapter(final Class<T> classOfT) {
+  private EnumTypeAdapter(Class<T> classOfT) {
     try {
       // Uses reflection to find enum constants to work around name mismatches for obfuscated
       // classes

File: gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
Patch:
@@ -282,14 +282,14 @@ public int nextInt() throws IOException {
   }
 
   JsonElement nextJsonElement() throws IOException {
-    final JsonToken peeked = peek();
+    JsonToken peeked = peek();
     if (peeked == JsonToken.NAME
         || peeked == JsonToken.END_ARRAY
         || peeked == JsonToken.END_OBJECT
         || peeked == JsonToken.END_DOCUMENT) {
       throw new IllegalStateException("Unexpected " + peeked + " when reading a JsonElement.");
     }
-    final JsonElement element = (JsonElement) peekStack();
+    JsonElement element = (JsonElement) peekStack();
     skipValue();
     return element;
   }

File: gson/src/main/java/com/google/gson/internal/bind/NumberTypeAdapter.java
Patch:
@@ -41,7 +41,7 @@ private NumberTypeAdapter(ToNumberStrategy toNumberStrategy) {
   }
 
   private static TypeAdapterFactory newFactory(ToNumberStrategy toNumberStrategy) {
-    final NumberTypeAdapter adapter = new NumberTypeAdapter(toNumberStrategy);
+    NumberTypeAdapter adapter = new NumberTypeAdapter(toNumberStrategy);
     return new TypeAdapterFactory() {
       @SuppressWarnings("unchecked")
       @Override

File: gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
Patch:
@@ -49,7 +49,7 @@ private ObjectTypeAdapter(Gson gson, ToNumberStrategy toNumberStrategy) {
     this.toNumberStrategy = toNumberStrategy;
   }
 
-  private static TypeAdapterFactory newFactory(final ToNumberStrategy toNumberStrategy) {
+  private static TypeAdapterFactory newFactory(ToNumberStrategy toNumberStrategy) {
     return new TypeAdapterFactory() {
       @SuppressWarnings("unchecked")
       @Override

File: gson/src/main/java/com/google/gson/internal/reflect/ReflectionHelper.java
Patch:
@@ -128,7 +128,8 @@ public static String constructorToString(Constructor<?> constructor) {
     return stringBuilder.toString();
   }
 
-  // Ideally parameter type would be java.lang.reflect.Executable, but that was added in Java 8
+  // Ideally parameter type would be java.lang.reflect.Executable, but that was added
+  // in Android API level 26
   private static void appendExecutableParameters(
       AccessibleObject executable, StringBuilder stringBuilder) {
     stringBuilder.append('(');

File: gson/src/main/java/com/google/gson/internal/sql/SqlTimestampTypeAdapter.java
Patch:
@@ -34,7 +34,7 @@ class SqlTimestampTypeAdapter extends TypeAdapter<Timestamp> {
         @Override
         public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
           if (typeToken.getRawType() == Timestamp.class) {
-            final TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);
+            TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);
             return (TypeAdapter<T>) new SqlTimestampTypeAdapter(dateTypeAdapter);
           } else {
             return null;

File: gson/src/test/java/com/google/gson/TypeAdapterTest.java
Patch:
@@ -78,7 +78,7 @@ public String toString() {
    */
   @Test
   public void testToJson_ThrowingIOException() {
-    final IOException exception = new IOException("test");
+    IOException exception = new IOException("test");
     TypeAdapter<Integer> adapter =
         new TypeAdapter<>() {
           @Override

File: gson/src/test/java/com/google/gson/common/TestTypes.java
Patch:
@@ -144,7 +144,7 @@ public String getExpectedJson() {
 
     @Override
     public int hashCode() {
-      final int prime = 31;
+      int prime = 31;
       int result = 1;
       result = prime * result + (booleanValue ? 1231 : 1237);
       result = prime * result + intValue;

File: gson/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java
Patch:
@@ -77,7 +77,7 @@ private static class StatsTypeAdapterFactory implements TypeAdapterFactory {
 
     @Override
     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
-      final TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);
+      TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);
       return new TypeAdapter<>() {
         @Override
         public void write(JsonWriter out, T value) throws IOException {

File: gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
Patch:
@@ -263,7 +263,7 @@ private static class C {
 
     static final class JsonAdapterFactory implements TypeAdapterFactory {
       @Override
-      public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {
+      public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
         return new TypeAdapter<>() {
           @Override
           public void write(JsonWriter out, T value) throws IOException {

File: gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
Patch:
@@ -146,7 +146,7 @@ public Part read(JsonReader in) throws IOException {
 
   private static class GizmoPartTypeAdapterFactory implements TypeAdapterFactory {
     @Override
-    public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {
+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       return new TypeAdapter<>() {
         @Override
         public void write(JsonWriter out, T value) throws IOException {
@@ -317,7 +317,7 @@ public Long read(JsonReader in) throws IOException {
 
     @SuppressWarnings("unchecked")
     @Override
-    public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {
+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       Class<?> cls = type.getRawType();
       if (Long.class.isAssignableFrom(cls)) {
         return (TypeAdapter<T>) ADAPTER;
@@ -351,7 +351,7 @@ private static final class Gizmo2 {
 
   private static class Gizmo2PartTypeAdapterFactory implements TypeAdapterFactory {
     @Override
-    public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {
+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       return new TypeAdapter<>() {
         @Override
         public void write(JsonWriter out, T value) throws IOException {

File: gson/src/test/java/com/google/gson/functional/MapTest.java
Patch:
@@ -520,7 +520,7 @@ public final void testInterfaceTypeMapWithSerializer() {
 
     Gson tempGson = new Gson();
     String subTypeJson = tempGson.toJson(subType);
-    final JsonElement baseTypeJsonElement = tempGson.toJsonTree(subType, TestTypes.Base.class);
+    JsonElement baseTypeJsonElement = tempGson.toJsonTree(subType, TestTypes.Base.class);
     String baseTypeJson = tempGson.toJson(baseTypeJsonElement);
     String expected =
         "{\"bases\":{\"Test\":" + baseTypeJson + "},\"subs\":{\"Test\":" + subTypeJson + "}}";

File: gson/src/test/java/com/google/gson/functional/ObjectTest.java
Patch:
@@ -488,7 +488,7 @@ public void testInnerClassSerialization() {
 
   @Test
   public void testInnerClassDeserialization() {
-    final Parent p = new Parent();
+    Parent p = new Parent();
     Gson gson =
         new GsonBuilder()
             .registerTypeAdapter(

File: gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java
Patch:
@@ -437,7 +437,7 @@ private MultiParameters() {}
 
     @Override
     public int hashCode() {
-      final int prime = 31;
+      int prime = 31;
       int result = 1;
       result = prime * result + ((a == null) ? 0 : a.hashCode());
       result = prime * result + ((b == null) ? 0 : b.hashCode());

File: gson/src/test/java/com/google/gson/functional/ReflectionAccessTest.java
Patch:
@@ -60,8 +60,8 @@ public void testRestrictiveSecurityManager() throws Exception {
     // Class.getDeclaredFields()
     Class<?> clazz = loadClassWithDifferentClassLoader(ClassWithPrivateMembers.class);
 
-    final Permission accessDeclaredMembers = new RuntimePermission("accessDeclaredMembers");
-    final Permission suppressAccessChecks = new ReflectPermission("suppressAccessChecks");
+    Permission accessDeclaredMembers = new RuntimePermission("accessDeclaredMembers");
+    Permission suppressAccessChecks = new ReflectPermission("suppressAccessChecks");
     SecurityManager original = System.getSecurityManager();
     SecurityManager restrictiveManager =
         new SecurityManager() {
@@ -83,7 +83,7 @@ public void checkPermission(Permission perm) {
       var e = assertThrows(SecurityException.class, () -> gson.getAdapter(clazz));
       assertThat(e).hasMessageThat().isEqualTo("Gson: no-member-access");
 
-      final AtomicBoolean wasReadCalled = new AtomicBoolean(false);
+      AtomicBoolean wasReadCalled = new AtomicBoolean(false);
       Gson gson2 =
           new GsonBuilder()
               .registerTypeAdapter(

File: gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
Patch:
@@ -166,8 +166,8 @@ public <R> TypeAdapter<R> create(Gson gson, TypeToken<R> type) {
         return null;
       }
 
-      final Map<String, TypeAdapter<?>> labelToDelegate = new LinkedHashMap<>();
-      final Map<Class<?>, TypeAdapter<?>> subtypeToDelegate = new LinkedHashMap<>();
+      Map<String, TypeAdapter<?>> labelToDelegate = new LinkedHashMap<>();
+      Map<Class<?>, TypeAdapter<?>> subtypeToDelegate = new LinkedHashMap<>();
       for (Map.Entry<String, Class<?>> entry : labelToSubtype.entrySet()) {
         TypeAdapter<?> delegate = gson.getDelegateAdapter(this, TypeToken.get(entry.getValue()));
         labelToDelegate.put(entry.getKey(), delegate);

File: gson/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java
Patch:
@@ -139,7 +139,7 @@ private Foo(String name) {
     }
   }
 
-  private static JsonSerializer<Foo> newSerializer(final String name) {
+  private static JsonSerializer<Foo> newSerializer(String name) {
     return new JsonSerializer<>() {
       @Override
       public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext context) {
@@ -148,7 +148,7 @@ public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext c
     };
   }
 
-  private static JsonDeserializer<Foo> newDeserializer(final String name) {
+  private static JsonDeserializer<Foo> newDeserializer(String name) {
     return new JsonDeserializer<>() {
       @Override
       public Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {
@@ -157,7 +157,7 @@ public Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContex
     };
   }
 
-  private static TypeAdapter<Foo> newTypeAdapter(final String name) {
+  private static TypeAdapter<Foo> newTypeAdapter(String name) {
     return new TypeAdapter<>() {
       @Override
       public Foo read(JsonReader in) throws IOException {

File: gson/src/test/java/com/google/gson/internal/bind/Java17ReflectiveTypeAdapterFactoryTest.java
Patch:
@@ -87,7 +87,7 @@ public void write(JsonWriter out, T principal) throws IOException {
 
     @Override
     public T read(JsonReader in) throws IOException {
-      final String name = in.nextString();
+      String name = in.nextString();
       // This type adapter is only used for Group and User Principal, both of which are implemented
       // by PrincipalImpl.
       @SuppressWarnings("unchecked")

File: gson/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java
Patch:
@@ -258,7 +258,7 @@ public void testWrongType() throws IOException {
 
   @Test
   public void testNextJsonElement() throws IOException {
-    final JsonElement element = JsonParser.parseString("{\"A\": 1, \"B\" : {}, \"C\" : []}");
+    JsonElement element = JsonParser.parseString("{\"A\": 1, \"B\" : {}, \"C\" : []}");
     JsonTreeReader reader = new JsonTreeReader(element);
     reader.beginObject();
 

File: gson/src/test/java/com/google/gson/internal/bind/util/ISO8601UtilsTest.java
Patch:
@@ -119,7 +119,7 @@ public void testDateParseSpecialTimezone() throws ParseException {
 
   @Test
   public void testDateParseInvalidTime() {
-    final String dateStr = "2018-06-25T61:60:62-03:00";
+    String dateStr = "2018-06-25T61:60:62-03:00";
     assertThrows(ParseException.class, () -> ISO8601Utils.parse(dateStr, new ParsePosition(0)));
   }
 }

File: gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
Patch:
@@ -2171,7 +2171,7 @@ private static void assertDocument(String document, Object... expectations) thro
   }
 
   /** Returns a reader that returns one character at a time. */
-  private static Reader reader(final String s) {
+  private static Reader reader(String s) {
     /* if (true) */ return new StringReader(s);
     /* return new Reader() {
       int position = 0;

File: metrics/src/main/java/com/google/gson/metrics/BagOfPrimitives.java
Patch:
@@ -63,7 +63,7 @@ public String getExpectedJson() {
 
   @Override
   public int hashCode() {
-    final int prime = 31;
+    int prime = 31;
     int result = 1;
     result = prime * result + (booleanValue ? 1231 : 1237);
     result = prime * result + intValue;

File: proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java
Patch:
@@ -252,10 +252,10 @@ private ProtoTypeAdapter(
   @Override
   public JsonElement serialize(Message src, Type typeOfSrc, JsonSerializationContext context) {
     JsonObject ret = new JsonObject();
-    final Map<FieldDescriptor, Object> fields = src.getAllFields();
+    Map<FieldDescriptor, Object> fields = src.getAllFields();
 
     for (Map.Entry<FieldDescriptor, Object> fieldPair : fields.entrySet()) {
-      final FieldDescriptor desc = fieldPair.getKey();
+      FieldDescriptor desc = fieldPair.getKey();
       String name = getCustSerializedName(desc);
 
       if (desc.getType() == ENUM_TYPE) {

File: proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithComplexAndRepeatedFieldsTest.java
Patch:
@@ -85,20 +85,20 @@ public void testDeserializeRepeatedFieldsProto() {
 
   @Test
   public void testSerializeDifferentCaseFormat() {
-    final ProtoWithDifferentCaseFormat proto =
+    ProtoWithDifferentCaseFormat proto =
         ProtoWithDifferentCaseFormat.newBuilder()
             .setAnotherField("foo")
             .addNameThatTestsCaseFormat("bar")
             .build();
-    final JsonObject json = upperCamelGson.toJsonTree(proto).getAsJsonObject();
+    JsonObject json = upperCamelGson.toJsonTree(proto).getAsJsonObject();
     assertThat(json.get("AnotherField").getAsString()).isEqualTo("foo");
     assertThat(json.get("NameThatTestsCaseFormat").getAsJsonArray().get(0).getAsString())
         .isEqualTo("bar");
   }
 
   @Test
   public void testDeserializeDifferentCaseFormat() {
-    final String json = "{NameThatTestsCaseFormat:['bar'],AnotherField:'foo'}";
+    String json = "{NameThatTestsCaseFormat:['bar'],AnotherField:'foo'}";
     ProtoWithDifferentCaseFormat proto =
         upperCamelGson.fromJson(json, ProtoWithDifferentCaseFormat.class);
     assertThat(proto.getAnotherField()).isEqualTo("foo");

File: gson/src/main/java/com/google/gson/internal/Streams.java
Patch:
@@ -21,7 +21,7 @@
 import com.google.gson.JsonNull;
 import com.google.gson.JsonParseException;
 import com.google.gson.JsonSyntaxException;
-import com.google.gson.internal.bind.JsonElementTypeAdapter;
+import com.google.gson.internal.bind.TypeAdapters;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
@@ -43,7 +43,7 @@ public static JsonElement parse(JsonReader reader) throws JsonParseException {
     try {
       JsonToken unused = reader.peek();
       isEmpty = false;
-      return JsonElementTypeAdapter.ADAPTER.read(reader);
+      return TypeAdapters.JSON_ELEMENT.read(reader);
     } catch (EOFException e) {
       /*
        * For compatibility with JSON 1.5 and earlier, we return a JsonNull for
@@ -65,7 +65,7 @@ public static JsonElement parse(JsonReader reader) throws JsonParseException {
 
   /** Writes the JSON element to the writer, recursively. */
   public static void write(JsonElement element, JsonWriter writer) throws IOException {
-    JsonElementTypeAdapter.ADAPTER.write(writer, element);
+    TypeAdapters.JSON_ELEMENT.write(writer, element);
   }
 
   public static Writer writerForAppendable(Appendable appendable) {

File: gson/src/main/java/com/google/gson/internal/bind/EnumTypeAdapter.java
Patch:
@@ -32,8 +32,8 @@
 import java.util.Map;
 
 /** Adapter for enum classes (but not for the base class {@code java.lang.Enum}). */
-public class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {
-  public static final TypeAdapterFactory FACTORY =
+class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {
+  static final TypeAdapterFactory FACTORY =
       new TypeAdapterFactory() {
         @Override
         public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {

File: gson/src/test/java/com/google/gson/regression/OSGiTest.java
Patch:
@@ -34,9 +34,9 @@ public void testComGoogleGsonAnnotationsPackage() throws Exception {
     Manifest mf = findManifest("com.google.gson");
     String importPkg = mf.getMainAttributes().getValue("Import-Package");
     assertWithMessage("Import-Package statement is there").that(importPkg).isNotNull();
-    assertWithMessage("There should be com.google.gson.annotations dependency")
+    assertWithMessage("There should be no com.google.gson.annotations dependency")
         .that(importPkg)
-        .contains("com.google.gson.annotations");
+        .doesNotContain("com.google.gson.annotations");
   }
 
   @Test

File: gson/src/main/java/com/google/gson/internal/Streams.java
Patch:
@@ -21,7 +21,7 @@
 import com.google.gson.JsonNull;
 import com.google.gson.JsonParseException;
 import com.google.gson.JsonSyntaxException;
-import com.google.gson.internal.bind.TypeAdapters;
+import com.google.gson.internal.bind.JsonElementTypeAdapter;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
@@ -43,7 +43,7 @@ public static JsonElement parse(JsonReader reader) throws JsonParseException {
     try {
       JsonToken unused = reader.peek();
       isEmpty = false;
-      return TypeAdapters.JSON_ELEMENT.read(reader);
+      return JsonElementTypeAdapter.ADAPTER.read(reader);
     } catch (EOFException e) {
       /*
        * For compatibility with JSON 1.5 and earlier, we return a JsonNull for
@@ -65,7 +65,7 @@ public static JsonElement parse(JsonReader reader) throws JsonParseException {
 
   /** Writes the JSON element to the writer, recursively. */
   public static void write(JsonElement element, JsonWriter writer) throws IOException {
-    TypeAdapters.JSON_ELEMENT.write(writer, element);
+    JsonElementTypeAdapter.ADAPTER.write(writer, element);
   }
 
   public static Writer writerForAppendable(Appendable appendable) {

File: gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
Patch:
@@ -30,7 +30,7 @@
 import java.lang.reflect.Type;
 import java.util.ArrayList;
 
-/** Adapt an array of objects. */
+/** Adapter for arrays. */
 public final class ArrayTypeAdapter<E> extends TypeAdapter<Object> {
   public static final TypeAdapterFactory FACTORY =
       new TypeAdapterFactory() {

File: gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
Patch:
@@ -282,6 +282,7 @@ public void testParameterizedFactory_Invalid() {
                 + GenericWithMultiBound.class);
 
     class Outer {
+      @SuppressWarnings("ClassCanBeStatic")
       class NonStaticInner<T> {}
     }
 
@@ -344,6 +345,7 @@ private static <M> void createTypeTokenTypeVariable() {
   public void testTypeTokenTypeVariable() throws Exception {
     // Put the test code inside generic class to be able to access `T`
     class Enclosing<T> {
+      @SuppressWarnings("ClassCanBeStatic")
       class Inner {}
 
       void test() {

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -254,7 +254,7 @@ public class JsonReader implements Closeable {
   private Strictness strictness = Strictness.LEGACY_STRICT;
   // Default nesting limit is based on
   // https://github.com/square/moshi/blob/parent-1.15.0/moshi/src/main/java/com/squareup/moshi/JsonReader.java#L228-L230
-  private static final int DEFAULT_NESTING_LIMIT = 255;
+  static final int DEFAULT_NESTING_LIMIT = 255;
   private int nestingLimit = DEFAULT_NESTING_LIMIT;
 
   static final int BUFFER_SIZE = 1024;

File: gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
Patch:
@@ -1753,7 +1753,7 @@ public void testDeeplyNestedObjects() throws IOException {
 
   @Test
   public void testNestingLimitDefault() throws IOException {
-    int defaultLimit = 255;
+    int defaultLimit = JsonReader.DEFAULT_NESTING_LIMIT;
     String json = repeat('[', defaultLimit + 1);
     JsonReader reader = new JsonReader(reader(json));
     assertThat(reader.getNestingLimit()).isEqualTo(defaultLimit);

File: gson/src/test/java/com/google/gson/OverrideCoreTypeAdaptersTest.java
Patch:
@@ -31,7 +31,7 @@
  */
 public class OverrideCoreTypeAdaptersTest {
   private static final TypeAdapter<Boolean> booleanAsIntAdapter =
-      new TypeAdapter<Boolean>() {
+      new TypeAdapter<>() {
         @Override
         public void write(JsonWriter out, Boolean value) throws IOException {
           out.value(value ? 1 : 0);
@@ -45,7 +45,7 @@ public Boolean read(JsonReader in) throws IOException {
       };
 
   private static final TypeAdapter<String> swapCaseStringAdapter =
-      new TypeAdapter<String>() {
+      new TypeAdapter<>() {
         @Override
         public void write(JsonWriter out, String value) throws IOException {
           out.value(value.toUpperCase(Locale.US));

File: gson/src/test/java/com/google/gson/TypeAdapterTest.java
Patch:
@@ -53,7 +53,7 @@ public String read(JsonReader in) {
   public void testToJson_ThrowingIOException() {
     final IOException exception = new IOException("test");
     TypeAdapter<Integer> adapter =
-        new TypeAdapter<Integer>() {
+        new TypeAdapter<>() {
           @Override
           public void write(JsonWriter out, Integer value) throws IOException {
             throw exception;
@@ -73,7 +73,7 @@ public Integer read(JsonReader in) {
   }
 
   private static final TypeAdapter<String> adapter =
-      new TypeAdapter<String>() {
+      new TypeAdapter<>() {
         @Override
         public void write(JsonWriter out, String value) throws IOException {
           out.value(value);

File: gson/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java
Patch:
@@ -78,7 +78,7 @@ private static class StatsTypeAdapterFactory implements TypeAdapterFactory {
     @Override
     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       final TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);
-      return new TypeAdapter<T>() {
+      return new TypeAdapter<>() {
         @Override
         public void write(JsonWriter out, T value) throws IOException {
           ++numWrites;

File: gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
Patch:
@@ -106,7 +106,7 @@ public void testInstanceCreatorForCollectionType() {
     @SuppressWarnings("serial")
     class SubArrayList<T> extends ArrayList<T> {}
     InstanceCreator<List<String>> listCreator =
-        new InstanceCreator<List<String>>() {
+        new InstanceCreator<>() {
           @Override
           public List<String> createInstance(Type type) {
             return new SubArrayList<>();
@@ -124,7 +124,7 @@ public void testInstanceCreatorForParametrizedType() {
     @SuppressWarnings("serial")
     class SubTreeSet<T> extends TreeSet<T> {}
     InstanceCreator<SortedSet<?>> sortedSetCreator =
-        new InstanceCreator<SortedSet<?>>() {
+        new InstanceCreator<>() {
           @Override
           public SortedSet<?> createInstance(Type type) {
             return new SubTreeSet<>();

File: gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
Patch:
@@ -147,7 +147,7 @@ public Part read(JsonReader in) throws IOException {
   private static class GizmoPartTypeAdapterFactory implements TypeAdapterFactory {
     @Override
     public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {
-      return new TypeAdapter<T>() {
+      return new TypeAdapter<>() {
         @Override
         public void write(JsonWriter out, T value) throws IOException {
           out.value("GizmoPartTypeAdapterFactory");
@@ -303,7 +303,7 @@ private GadgetWithPrimitivePart(long part) {
 
   private static final class LongToStringTypeAdapterFactory implements TypeAdapterFactory {
     static final TypeAdapter<Long> ADAPTER =
-        new TypeAdapter<Long>() {
+        new TypeAdapter<>() {
           @Override
           public void write(JsonWriter out, Long value) throws IOException {
             out.value(value.toString());
@@ -352,7 +352,7 @@ private static final class Gizmo2 {
   private static class Gizmo2PartTypeAdapterFactory implements TypeAdapterFactory {
     @Override
     public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {
-      return new TypeAdapter<T>() {
+      return new TypeAdapter<>() {
         @Override
         public void write(JsonWriter out, T value) throws IOException {
           out.value("GizmoPartTypeAdapterFactory");

File: gson/src/test/java/com/google/gson/functional/JsonTreeTest.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.gson.functional;
 
 import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
 
 import com.google.gson.Gson;
 import com.google.gson.JsonElement;
@@ -98,7 +97,7 @@ private static void assertContains(JsonObject json, JsonPrimitive child) {
         }
       }
     }
-    fail();
+    throw new AssertionError("Does not contain " + child);
   }
 
   private static class SubTypeOfBagOfPrimitives extends BagOfPrimitives {

File: gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
Patch:
@@ -174,7 +174,7 @@ public <R> TypeAdapter<R> create(Gson gson, TypeToken<R> type) {
         subtypeToDelegate.put(entry.getValue(), delegate);
       }
 
-      return new TypeAdapter<R>() {
+      return new TypeAdapter<>() {
         @Override
         public R read(JsonReader in) {
           JsonElement jsonElement = Streams.parse(in);

File: gson/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java
Patch:
@@ -141,7 +141,7 @@ private static class Course<T> {
     private final Assignment<T> assignment;
 
     private Course() {
-      this(null, 0, null, new ArrayList<Student>());
+      this(null, 0, null, new ArrayList<>());
     }
 
     public Course(

File: gson/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java
Patch:
@@ -140,7 +140,7 @@ private Foo(String name) {
   }
 
   private static JsonSerializer<Foo> newSerializer(final String name) {
-    return new JsonSerializer<Foo>() {
+    return new JsonSerializer<>() {
       @Override
       public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext context) {
         return new JsonPrimitive(src.name + " via " + name);
@@ -149,7 +149,7 @@ public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext c
   }
 
   private static JsonDeserializer<Foo> newDeserializer(final String name) {
-    return new JsonDeserializer<Foo>() {
+    return new JsonDeserializer<>() {
       @Override
       public Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {
         return new Foo(json.getAsString() + " via " + name);
@@ -158,7 +158,7 @@ public Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContex
   }
 
   private static TypeAdapter<Foo> newTypeAdapter(final String name) {
-    return new TypeAdapter<Foo>() {
+    return new TypeAdapter<>() {
       @Override
       public Foo read(JsonReader in) throws IOException {
         return new Foo(in.nextString() + " via " + name);

File: gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java
Patch:
@@ -201,7 +201,7 @@ public Employee deserialize(JsonElement json, Type typeOfT, JsonDeserializationC
         result = new Employee();
       }
       result.userid = context.deserialize(object.get("userid"), String.class);
-      result.startDate = context.<Long>deserialize(object.get("startDate"), long.class);
+      result.startDate = context.deserialize(object.get("startDate"), long.class);
       return result;
     }
   }

File: gson/src/test/java/com/google/gson/functional/TypeVariableTest.java
Patch:
@@ -43,7 +43,7 @@ public void testAdvancedTypeVariables() {
     arrayList.add(2);
     arrayList.add(3);
     bar1.map.put("key1", arrayList);
-    bar1.map.put("key2", new ArrayList<Integer>());
+    bar1.map.put("key2", new ArrayList<>());
     String json = gson.toJson(bar1);
 
     Bar bar2 = gson.fromJson(json, Bar.class);

File: gson/src/test/java/com/google/gson/internal/GsonTypesTest.java
Patch:
@@ -125,10 +125,10 @@ public void testEqualsOnConstructorParameterTypeVariables() throws Exception {
 
   private static final class TypeVariableTest {
 
-    @SuppressWarnings({"UnusedMethod", "UnusedVariable", "TypeParameterUnusedInFormals"})
+    @SuppressWarnings("unused")
     public <T> TypeVariableTest(T parameter) {}
 
-    @SuppressWarnings({"UnusedMethod", "UnusedVariable", "TypeParameterUnusedInFormals"})
+    @SuppressWarnings({"unused", "TypeParameterUnusedInFormals"})
     public <T> T method() {
       return null;
     }

File: gson/src/test/java/com/google/gson/internal/bind/util/ISO8601UtilsTest.java
Patch:
@@ -50,8 +50,8 @@ public void testDateFormatString() {
     calendar.set(2018, Calendar.JUNE, 25);
     Date date = calendar.getTime();
     String dateStr = ISO8601Utils.format(date);
-    String expectedDate = "2018-06-25";
-    assertThat(dateStr).startsWith(expectedDate);
+    String expectedDate = "2018-06-25T00:00:00Z";
+    assertThat(dateStr).isEqualTo(expectedDate);
   }
 
   @Test

File: gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
Patch:
@@ -328,7 +328,7 @@ class SubSubTypeToken2 extends SubTypeToken<Integer> {}
   }
 
   private static <M> void createTypeTokenTypeVariable() {
-    TypeToken<M> unused = new TypeToken<M>() {};
+    var unused = new TypeToken<M>() {};
   }
 
   /**

File: extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
Patch:
@@ -31,7 +31,8 @@ public class PostConstructAdapterFactoryTest {
   public void test() throws Exception {
     Gson gson =
         new GsonBuilder().registerTypeAdapterFactory(new PostConstructAdapterFactory()).create();
-    gson.fromJson("{\"bread\": \"white\", \"cheese\": \"cheddar\"}", Sandwich.class);
+    Sandwich unused =
+        gson.fromJson("{\"bread\": \"white\", \"cheese\": \"cheddar\"}", Sandwich.class);
     try {
       gson.fromJson("{\"bread\": \"cheesey bread\", \"cheese\": \"swiss\"}", Sandwich.class);
       fail();

File: gson/src/main/java/com/google/gson/annotations/package-info.java
Patch:
@@ -19,4 +19,5 @@
  *
  * @author Inderjeet Singh, Joel Leitch
  */
+@com.google.errorprone.annotations.CheckReturnValue
 package com.google.gson.annotations;

File: gson/src/main/java/com/google/gson/internal/package-info.java
Patch:
@@ -20,4 +20,5 @@
  *
  * @author Inderjeet Singh, Joel Leitch, Jesse Wilson
  */
+@com.google.errorprone.annotations.CheckReturnValue
 package com.google.gson.internal;

File: gson/src/main/java/com/google/gson/package-info.java
Patch:
@@ -24,4 +24,5 @@
  *
  * @author Inderjeet Singh, Joel Leitch
  */
+@com.google.errorprone.annotations.CheckReturnValue
 package com.google.gson;

File: gson/src/main/java/com/google/gson/reflect/package-info.java
Patch:
@@ -19,4 +19,5 @@
  *
  * @author Inderjeet Singh, Joel Leitch
  */
+@com.google.errorprone.annotations.CheckReturnValue
 package com.google.gson.reflect;

File: gson/src/main/java/com/google/gson/stream/package-info.java
Patch:
@@ -15,4 +15,5 @@
  */
 
 /** This package provides classes for processing JSON in an efficient streaming way. */
+@com.google.errorprone.annotations.CheckReturnValue
 package com.google.gson.stream;

File: gson/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java
Patch:
@@ -54,7 +54,8 @@ public void testDelegateInvoked() {
       bags.add(new BagOfPrimitives(i, i, i % 2 == 0, String.valueOf(i)));
     }
     String json = gson.toJson(bags);
-    gson.fromJson(json, new TypeToken<List<BagOfPrimitives>>() {}.getType());
+    List<BagOfPrimitives> unused =
+        gson.fromJson(json, new TypeToken<List<BagOfPrimitives>>() {}.getType());
     // 11: 1 list object, and 10 entries. stats invoked on all 5 fields
     assertThat(stats.numReads).isEqualTo(51);
     assertThat(stats.numWrites).isEqualTo(51);
@@ -64,7 +65,7 @@ public void testDelegateInvoked() {
   public void testDelegateInvokedOnStrings() {
     String[] bags = {"1", "2", "3", "4"};
     String json = gson.toJson(bags);
-    gson.fromJson(json, String[].class);
+    String[] unused = gson.fromJson(json, String[].class);
     // 1 array object with 4 elements.
     assertThat(stats.numReads).isEqualTo(5);
     assertThat(stats.numWrites).isEqualTo(5);

File: gson/src/test/java/com/google/gson/functional/Java17RecordTest.java
Patch:
@@ -333,7 +333,7 @@ public void testStaticFieldSerialization() {
   @Test
   public void testStaticFieldDeserialization() {
     // By default Gson should ignore static fields
-    gson.fromJson("{\"s\":\"custom\"}", RecordWithStaticField.class);
+    RecordWithStaticField unused = gson.fromJson("{\"s\":\"custom\"}", RecordWithStaticField.class);
     assertThat(RecordWithStaticField.s).isEqualTo("initial");
 
     Gson gson =

File: gson/src/test/java/com/google/gson/functional/ReflectionAccessTest.java
Patch:
@@ -118,7 +118,7 @@ public Object read(JsonReader in) throws IOException {
   private static JsonIOException assertInaccessibleException(String json, Class<?> toDeserialize) {
     Gson gson = new Gson();
     try {
-      gson.fromJson(json, toDeserialize);
+      Object unused = gson.fromJson(json, toDeserialize);
       throw new AssertionError(
           "Missing exception; test has to be run with `--illegal-access=deny`");
     } catch (JsonSyntaxException e) {

File: gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
Patch:
@@ -328,7 +328,7 @@ class SubSubTypeToken2 extends SubTypeToken<Integer> {}
   }
 
   private static <M> void createTypeTokenTypeVariable() {
-    new TypeToken<M>() {};
+    TypeToken<M> unused = new TypeToken<M>() {};
   }
 
   /**

File: metrics/src/main/java/com/google/gson/metrics/BagOfPrimitivesDeserializationBenchmark.java
Patch:
@@ -48,7 +48,7 @@ void setUp() throws Exception {
   /** Benchmark to measure Gson performance for deserializing an object */
   public void timeBagOfPrimitivesDefault(int reps) {
     for (int i = 0; i < reps; ++i) {
-      gson.fromJson(json, BagOfPrimitives.class);
+      BagOfPrimitives unused = gson.fromJson(json, BagOfPrimitives.class);
     }
   }
 

File: metrics/src/main/java/com/google/gson/metrics/CollectionsDeserializationBenchmark.java
Patch:
@@ -56,7 +56,7 @@ void setUp() throws Exception {
   /** Benchmark to measure Gson performance for deserializing an object */
   public void timeCollectionsDefault(int reps) {
     for (int i = 0; i < reps; ++i) {
-      gson.fromJson(json, LIST_TYPE_TOKEN);
+      List<BagOfPrimitives> unused = gson.fromJson(json, LIST_TYPE_TOKEN);
     }
   }
 

File: metrics/src/main/java/com/google/gson/metrics/SerializationBenchmark.java
Patch:
@@ -45,7 +45,7 @@ void setUp() throws Exception {
 
   public void timeObjectSerialization(int reps) {
     for (int i = 0; i < reps; ++i) {
-      gson.toJson(bag);
+      String unused = gson.toJson(bag);
     }
   }
 }

File: gson/src/main/java/module-info.java
Patch:
@@ -25,7 +25,7 @@
   exports com.google.gson.reflect;
   exports com.google.gson.stream;
 
-  // Dependency on Error Prone Annotations
+  // Optional dependency on Error Prone Annotations
   requires static com.google.errorprone.annotations;
 
   // Optional dependency on java.sql

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -1177,7 +1177,7 @@ private String nextUnquotedValue() throws IOException {
     }
 
     String result =
-        (null == builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();
+        (builder == null) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();
     pos += i;
     return result;
   }

File: metrics/src/main/java/com/google/gson/metrics/ParseBenchmark.java
Patch:
@@ -247,7 +247,7 @@ public void parse(char[] data, Document document) throws Exception {
             depth--;
             break;
           case FIELD_NAME:
-            jp.getCurrentName();
+            jp.currentName();
             break;
           case VALUE_STRING:
             jp.getText();

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -232,7 +232,7 @@ public final class Gson {
    *       through {@link GsonBuilder#registerTypeAdapter(Type, Object)}.
    *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format
    *       ignores the millisecond portion of the date during serialization. You can change this by
-   *       invoking {@link GsonBuilder#setDateFormat(int)} or {@link
+   *       invoking {@link GsonBuilder#setDateFormat(int, int)} or {@link
    *       GsonBuilder#setDateFormat(String)}.
    *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation. You
    *       can enable Gson to serialize/deserialize only those fields marked with this annotation

File: gson/src/test/java/com/google/gson/GsonBuilderTest.java
Patch:
@@ -358,6 +358,7 @@ public void testSetDateFormatEmptyPattern() {
     assertThat(emptyFormatted).isEqualTo(originalFormatted);
   }
 
+  @SuppressWarnings("deprecation") // for GsonBuilder.setDateFormat(int)
   @Test
   public void testSetDateFormatValidStyle() {
     GsonBuilder builder = new GsonBuilder();
@@ -370,6 +371,7 @@ public void testSetDateFormatValidStyle() {
     }
   }
 
+  @SuppressWarnings("deprecation") // for GsonBuilder.setDateFormat(int)
   @Test
   public void testSetDateFormatInvalidStyle() {
     GsonBuilder builder = new GsonBuilder();

File: gson/src/main/java/com/google/gson/internal/$Gson$Types.java
Patch:
@@ -217,7 +217,7 @@ public static boolean equals(Type a, Type b) {
       }
       TypeVariable<?> va = (TypeVariable<?>) a;
       TypeVariable<?> vb = (TypeVariable<?>) b;
-      return va.getGenericDeclaration() == vb.getGenericDeclaration()
+      return Objects.equals(va.getGenericDeclaration(), vb.getGenericDeclaration())
           && va.getName().equals(vb.getName());
 
     } else {

File: extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 
+@SuppressWarnings({"PrivateConstructorForUtilityClass", "SystemOut"})
 public class RawCollectionsExample {
   static class Event {
     private String name;

File: extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java
Patch:
@@ -30,7 +30,7 @@
 import java.util.TimeZone;
 
 public final class UtcDateTypeAdapter extends TypeAdapter<Date> {
-  private final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone("UTC");
+  private static final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone("UTC");
 
   @Override
   public void write(JsonWriter out, Date date) throws IOException {

File: gson/src/main/java/com/google/gson/internal/Excluder.java
Patch:
@@ -216,17 +216,17 @@ private boolean excludeClassInStrategy(Class<?> clazz, boolean serialize) {
     return false;
   }
 
-  private boolean isAnonymousOrNonStaticLocal(Class<?> clazz) {
+  private static boolean isAnonymousOrNonStaticLocal(Class<?> clazz) {
     return !Enum.class.isAssignableFrom(clazz)
         && !isStatic(clazz)
         && (clazz.isAnonymousClass() || clazz.isLocalClass());
   }
 
-  private boolean isInnerClass(Class<?> clazz) {
+  private static boolean isInnerClass(Class<?> clazz) {
     return clazz.isMemberClass() && !isStatic(clazz);
   }
 
-  private boolean isStatic(Class<?> clazz) {
+  private static boolean isStatic(Class<?> clazz) {
     return (clazz.getModifiers() & Modifier.STATIC) != 0;
   }
 

File: gson/src/main/java/com/google/gson/internal/JavaVersion.java
Patch:
@@ -27,11 +27,11 @@ public final class JavaVersion {
 
   private static int determineMajorJavaVersion() {
     String javaVersion = System.getProperty("java.version");
-    return getMajorJavaVersion(javaVersion);
+    return parseMajorJavaVersion(javaVersion);
   }
 
   // Visible for testing only
-  static int getMajorJavaVersion(String javaVersion) {
+  static int parseMajorJavaVersion(String javaVersion) {
     int version = parseDotted(javaVersion);
     if (version == -1) {
       version = extractBeginningInt(javaVersion);

File: gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java
Patch:
@@ -233,7 +233,7 @@ Node<K, V> findByEntry(Entry<?, ?> entry) {
     return valuesEqual ? mine : null;
   }
 
-  private boolean equal(Object a, Object b) {
+  private static boolean equal(Object a, Object b) {
     return Objects.equals(a, b);
   }
 

File: gson/src/main/java/com/google/gson/internal/NonNullElementWrapperList.java
Patch:
@@ -76,6 +76,7 @@ public void clear() {
     delegate.clear();
   }
 
+  @SuppressWarnings("UngroupedOverloads") // this is intentionally ungrouped, see comment above
   @Override
   public boolean remove(Object o) {
     return delegate.remove(o);

File: gson/src/main/java/com/google/gson/internal/PreJava9DateFormatProvider.java
Patch:
@@ -21,20 +21,21 @@
 
 /** Provides DateFormats for US locale with patterns which were the default ones before Java 9. */
 public class PreJava9DateFormatProvider {
+  private PreJava9DateFormatProvider() {}
 
   /**
    * Returns the same DateFormat as {@code DateFormat.getDateInstance(style, Locale.US)} in Java 8
    * or below.
    */
-  public static DateFormat getUSDateFormat(int style) {
+  public static DateFormat getUsDateFormat(int style) {
     return new SimpleDateFormat(getDateFormatPattern(style), Locale.US);
   }
 
   /**
    * Returns the same DateFormat as {@code DateFormat.getDateTimeInstance(dateStyle, timeStyle,
    * Locale.US)} in Java 8 or below.
    */
-  public static DateFormat getUSDateTimeFormat(int dateStyle, int timeStyle) {
+  public static DateFormat getUsDateTimeFormat(int dateStyle, int timeStyle) {
     String pattern =
         getDatePartOfDateTimePattern(dateStyle) + " " + getTimePartOfDateTimePattern(timeStyle);
     return new SimpleDateFormat(pattern, Locale.US);

File: gson/src/main/java/com/google/gson/internal/Primitives.java
Patch:
@@ -60,7 +60,7 @@ public static boolean isWrapperType(Type type) {
    *     wrap(String.class) == String.class
    * </pre>
    */
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({"unchecked", "MissingBraces"})
   public static <T> Class<T> wrap(Class<T> type) {
     if (type == int.class) return (Class<T>) Integer.class;
     if (type == float.class) return (Class<T>) Float.class;
@@ -84,7 +84,7 @@ public static <T> Class<T> wrap(Class<T> type) {
    *     unwrap(String.class) == String.class
    * </pre>
    */
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({"unchecked", "MissingBraces"})
   public static <T> Class<T> unwrap(Class<T> type) {
     if (type == Integer.class) return (Class<T>) int.class;
     if (type == Float.class) return (Class<T>) float.class;

File: gson/src/main/java/com/google/gson/internal/Streams.java
Patch:
@@ -81,6 +81,7 @@ private static final class AppendableWriter extends Writer {
       this.appendable = appendable;
     }
 
+    @SuppressWarnings("UngroupedOverloads") // this is intentionally ungrouped, see comment below
     @Override
     public void write(char[] chars, int offset, int length) throws IOException {
       currentWrite.setChars(chars);

File: gson/src/main/java/com/google/gson/internal/bind/DefaultDateTypeAdapter.java
Patch:
@@ -141,7 +141,7 @@ private DefaultDateTypeAdapter(DateType<T> dateType, int style) {
       dateFormats.add(DateFormat.getDateInstance(style));
     }
     if (JavaVersion.isJava9OrLater()) {
-      dateFormats.add(PreJava9DateFormatProvider.getUSDateFormat(style));
+      dateFormats.add(PreJava9DateFormatProvider.getUsDateFormat(style));
     }
   }
 
@@ -152,7 +152,7 @@ private DefaultDateTypeAdapter(DateType<T> dateType, int dateStyle, int timeStyl
       dateFormats.add(DateFormat.getDateTimeInstance(dateStyle, timeStyle));
     }
     if (JavaVersion.isJava9OrLater()) {
-      dateFormats.add(PreJava9DateFormatProvider.getUSDateTimeFormat(dateStyle, timeStyle));
+      dateFormats.add(PreJava9DateFormatProvider.getUsDateTimeFormat(dateStyle, timeStyle));
     }
   }
 

File: gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
Patch:
@@ -67,7 +67,7 @@ public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructo
   }
 
   // Separate helper method to make sure callers retrieve annotation in a consistent way
-  private JsonAdapter getAnnotation(Class<?> rawType) {
+  private static JsonAdapter getAnnotation(Class<?> rawType) {
     return rawType.getAnnotation(JsonAdapter.class);
   }
 

File: gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
Patch:
@@ -172,7 +172,9 @@ private BoundField createBoundField(
               constructorConstructor, context, fieldType, annotation, false);
     }
     final boolean jsonAdapterPresent = mapped != null;
-    if (mapped == null) mapped = context.getAdapter(fieldType);
+    if (mapped == null) {
+      mapped = context.getAdapter(fieldType);
+    }
 
     @SuppressWarnings("unchecked")
     final TypeAdapter<Object> typeAdapter = (TypeAdapter<Object>) mapped;

File: gson/src/main/java/com/google/gson/stream/JsonScope.java
Patch:
@@ -23,6 +23,7 @@
  * @since 1.6
  */
 final class JsonScope {
+  private JsonScope() {}
 
   /** An array with no elements requires no separator before the next element. */
   static final int EMPTY_ARRAY = 1;

File: gson/src/test/java/com/google/gson/FieldNamingPolicyTest.java
Patch:
@@ -115,7 +115,7 @@ class Dummy {
   @Test
   public void testLowerCasingLocaleIndependent() throws Exception {
     class Dummy {
-      @SuppressWarnings("unused")
+      @SuppressWarnings({"unused", "ConstantField"})
       int I;
     }
 

File: gson/src/test/java/com/google/gson/GsonTypeAdapterTest.java
Patch:
@@ -151,7 +151,7 @@ public void testDeserializerForAbstractClass() {
     assertSerialized("{\"b\":\"beep\",\"a\":\"android\"}", Concrete.class, false, false, instance);
   }
 
-  private void assertSerialized(
+  private static void assertSerialized(
       String expected,
       Class<?> instanceType,
       boolean registerAbstractDeserializer,

File: gson/src/test/java/com/google/gson/JavaSerializationTest.java
Patch:
@@ -66,7 +66,7 @@ public void testNumberIsSerializable() throws Exception {
   }
 
   @SuppressWarnings("unchecked") // Serialization promises to return the same type.
-  private <T> T serializedCopy(T object) throws IOException, ClassNotFoundException {
+  private static <T> T serializedCopy(T object) throws IOException, ClassNotFoundException {
     ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
     ObjectOutputStream out = new ObjectOutputStream(bytesOut);
     out.writeObject(object);

File: gson/src/test/java/com/google/gson/common/MoreAsserts.java
Patch:
@@ -30,6 +30,7 @@
  * @author Inderjeet Singh
  */
 public class MoreAsserts {
+  private MoreAsserts() {}
 
   /**
    * Asserts that the specified {@code value} is not present in {@code collection}

File: gson/src/test/java/com/google/gson/common/TestTypes.java
Patch:
@@ -36,6 +36,7 @@
  * @author Joel Leitch
  */
 public class TestTypes {
+  private TestTypes() {}
 
   public static class Base {
     public static final String BASE_NAME = Base.class.getSimpleName();

File: gson/src/test/java/com/google/gson/functional/EscapingTest.java
Patch:
@@ -70,8 +70,8 @@ public void testEscapingObjectFields() {
     assertThat(jsonRepresentation).doesNotContain(">");
     assertThat(jsonRepresentation).contains("\\\"");
 
-    BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class);
-    assertThat(objWithPrimitives.getExpectedJson()).isEqualTo(expectedObject.getExpectedJson());
+    BagOfPrimitives deserialized = gson.fromJson(jsonRepresentation, BagOfPrimitives.class);
+    assertThat(deserialized.getExpectedJson()).isEqualTo(objWithPrimitives.getExpectedJson());
   }
 
   @Test

File: gson/src/test/java/com/google/gson/functional/FieldNamingTest.java
Patch:
@@ -91,11 +91,12 @@ public void testLowerCaseWithDashes() {
                 + "'annotatedName':7,'lower-id':8,'_9':9}");
   }
 
-  private Gson getGsonWithNamingPolicy(FieldNamingPolicy fieldNamingPolicy) {
+  private static Gson getGsonWithNamingPolicy(FieldNamingPolicy fieldNamingPolicy) {
     return new GsonBuilder().setFieldNamingPolicy(fieldNamingPolicy).create();
   }
 
-  @SuppressWarnings("unused") // fields are used reflectively
+  // Suppress because fields are used reflectively, and the names are intentionally unconventional
+  @SuppressWarnings({"unused", "MemberName", "ConstantField"})
   private static class TestNames {
     int lowerCamel = 1;
     int UpperCamel = 2;

File: gson/src/test/java/com/google/gson/functional/GsonVersionDiagnosticsTest.java
Patch:
@@ -79,7 +79,7 @@ public void testAssertionErrorInDeserializationPrintsVersion() {
     ensureAssertionErrorPrintsGsonVersion(e);
   }
 
-  private void ensureAssertionErrorPrintsGsonVersion(AssertionError expected) {
+  private static void ensureAssertionErrorPrintsGsonVersion(AssertionError expected) {
     String msg = expected.getMessage();
     // System.err.println(msg);
     int start = msg.indexOf("(GSON");

File: gson/src/test/java/com/google/gson/functional/InheritanceTest.java
Patch:
@@ -275,7 +275,7 @@ public String getExpectedJson() {
     }
 
     @CanIgnoreReturnValue
-    private StringBuilder append(StringBuilder sb, Collection<?> c) {
+    private static StringBuilder append(StringBuilder sb, Collection<?> c) {
       sb.append("[");
       boolean first = true;
       for (Object o : c) {

File: gson/src/test/java/com/google/gson/functional/Java17RecordTest.java
Patch:
@@ -354,6 +354,7 @@ public void testStaticFieldDeserialization() {
   }
 
   private record RecordWithStaticField() {
+    @SuppressWarnings("NonFinalStaticField")
     static String s = "initial";
   }
 

File: gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
Patch:
@@ -44,6 +44,7 @@
 import org.junit.Test;
 
 /** Functional tests for the {@link JsonAdapter} annotation on classes. */
+@SuppressWarnings("ClassNamedLikeTypeParameter") // for dummy classes A, B, ...
 public final class JsonAdapterAnnotationOnClassesTest {
 
   @Test
@@ -305,7 +306,8 @@ private static final class ClassWithIncorrectJsonAdapter {
   // This class is used in JsonAdapter Javadoc as an example
   @JsonAdapter(UserJsonAdapter.class)
   private static class User {
-    final String firstName, lastName;
+    final String firstName;
+    final String lastName;
 
     User(String firstName, String lastName) {
       this.firstName = firstName;

File: gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java
Patch:
@@ -240,6 +240,7 @@ public void write(JsonWriter out, User value) throws IOException {
     assertThat(deserialized.userDN).isNull();
   }
 
+  @SuppressWarnings("MemberName")
   private static final class WithNullSafe {
     // "userS..." uses JsonSerializer
     @JsonAdapter(value = UserSerializer.class, nullSafe = false)

File: gson/src/test/java/com/google/gson/functional/JsonTreeTest.java
Patch:
@@ -89,7 +89,7 @@ public void testJsonTreeNull() {
     assertThat(jsonElement.has("stringValue")).isFalse();
   }
 
-  private void assertContains(JsonObject json, JsonPrimitive child) {
+  private static void assertContains(JsonObject json, JsonPrimitive child) {
     for (Map.Entry<String, JsonElement> entry : json.entrySet()) {
       JsonElement node = entry.getValue();
       if (node.isJsonPrimitive()) {

File: gson/src/test/java/com/google/gson/functional/MapTest.java
Patch:
@@ -641,7 +641,7 @@ public void testDeserializeMapOfMaps() {
     assertThat(gson.fromJson(json, type)).isEqualTo(map);
   }
 
-  private <K, V> Map<K, V> newMap(K key1, V value1, K key2, V value2) {
+  private static <K, V> Map<K, V> newMap(K key1, V value1, K key2, V value2) {
     Map<K, V> result = new LinkedHashMap<>();
     result.put(key1, value1);
     result.put(key2, value2);

File: gson/src/test/java/com/google/gson/functional/MoreSpecificTypeSerializationTest.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import org.junit.Before;
 import org.junit.Test;
@@ -51,7 +52,7 @@ public void testSubclassFields() {
 
   @Test
   public void testListOfSubclassFields() {
-    Collection<Base> list = new ArrayList<>();
+    List<Base> list = new ArrayList<>();
     list.add(new Base(1));
     list.add(new Sub(2, 3));
     ClassWithContainersOfBaseFields target = new ClassWithContainersOfBaseFields(list, null);
@@ -89,7 +90,7 @@ public void testParameterizedSubclassFields() {
    */
   @Test
   public void testListOfParameterizedSubclassFields() {
-    Collection<ParameterizedBase<String>> list = new ArrayList<>();
+    List<ParameterizedBase<String>> list = new ArrayList<>();
     list.add(new ParameterizedBase<>("one"));
     list.add(new ParameterizedSub<>("two", "three"));
     ClassWithContainersOfParameterizedBaseFields target =

File: gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
Patch:
@@ -177,12 +177,13 @@ public void testAbsentJsonElementsAreSetToNull() {
 
   public static class ClassWithInitializedMembers {
     // Using a mix of no-args constructor and field initializers
-    // Also, some fields are intialized and some are not (so initialized per JVM spec)
+    // Also, some fields are initialized and some are not (so initialized per JVM spec)
     public static final String MY_STRING_DEFAULT = "string";
     private static final int MY_INT_DEFAULT = 2;
     private static final boolean MY_BOOLEAN_DEFAULT = true;
     int[] array;
-    String str1, str2;
+    String str1;
+    String str2;
     int int1 = MY_INT_DEFAULT;
     int int2;
     boolean bool1 = MY_BOOLEAN_DEFAULT;

File: gson/src/test/java/com/google/gson/functional/ObjectTest.java
Patch:
@@ -678,10 +678,12 @@ public void testStaticFieldDeserialization() {
     }
   }
 
+  @SuppressWarnings({"PrivateConstructorForUtilityClass", "NonFinalStaticField"})
   static class ClassWithStaticField {
     static String s = "initial";
   }
 
+  @SuppressWarnings("PrivateConstructorForUtilityClass")
   static class ClassWithStaticFinalField {
     static final String s = "initial";
   }

File: gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
Patch:
@@ -526,7 +526,7 @@ public void testMoreSpecificSerialization() {
     assertThat(actualJson).isNotEqualTo(expectedJson);
   }
 
-  private String extractElementFromArray(String json) {
+  private static String extractElementFromArray(String json) {
     return json.substring(json.indexOf('[') + 1, json.indexOf(']'));
   }
 

File: gson/src/test/java/com/google/gson/functional/ReflectionAccessFilterTest.java
Patch:
@@ -152,7 +152,7 @@ public void testBlockAllJavaExtendingJdkClass() {
   }
 
   private static class ClassWithStaticField {
-    @SuppressWarnings("unused")
+    @SuppressWarnings({"unused", "NonFinalStaticField"})
     private static int i = 1;
   }
 

File: gson/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java
Patch:
@@ -139,7 +139,7 @@ private Foo(String name) {
     }
   }
 
-  private JsonSerializer<Foo> newSerializer(final String name) {
+  private static JsonSerializer<Foo> newSerializer(final String name) {
     return new JsonSerializer<Foo>() {
       @Override
       public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext context) {
@@ -148,7 +148,7 @@ public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext c
     };
   }
 
-  private JsonDeserializer<Foo> newDeserializer(final String name) {
+  private static JsonDeserializer<Foo> newDeserializer(final String name) {
     return new JsonDeserializer<Foo>() {
       @Override
       public Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {
@@ -157,7 +157,7 @@ public Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContex
     };
   }
 
-  private TypeAdapter<Foo> newTypeAdapter(final String name) {
+  private static TypeAdapter<Foo> newTypeAdapter(final String name) {
     return new TypeAdapter<Foo>() {
       @Override
       public Foo read(JsonReader in) throws IOException {

File: gson/src/test/java/com/google/gson/internal/LinkedTreeMapTest.java
Patch:
@@ -237,7 +237,7 @@ public void testJavaSerialization() throws IOException, ClassNotFoundException {
 
   @SuppressWarnings("varargs")
   @SafeVarargs
-  private final <T> void assertIterationOrder(Iterable<T> actual, T... expected) {
+  private static final <T> void assertIterationOrder(Iterable<T> actual, T... expected) {
     ArrayList<T> actualList = new ArrayList<>();
     for (T t : actual) {
       actualList.add(t);

File: gson/src/test/java/com/google/gson/internal/bind/DefaultDateTypeAdapterTest.java
Patch:
@@ -52,7 +52,7 @@ public void testFormattingInFr() {
     assertFormattingAlwaysEmitsUsLocale(Locale.FRANCE);
   }
 
-  private void assertFormattingAlwaysEmitsUsLocale(Locale locale) {
+  private static void assertFormattingAlwaysEmitsUsLocale(Locale locale) {
     TimeZone defaultTimeZone = TimeZone.getDefault();
     TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
     Locale defaultLocale = Locale.getDefault();

File: gson/src/test/java/com/google/gson/internal/sql/SqlTypesGsonTest.java
Patch:
@@ -21,7 +21,6 @@
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.functional.DefaultTypeAdaptersTest;
-import java.sql.Date;
 import java.sql.Time;
 import java.sql.Timestamp;
 import java.util.Locale;
@@ -30,6 +29,8 @@
 import org.junit.Before;
 import org.junit.Test;
 
+// Suppression for `java.sql.Date` to make it explicit that this is not `java.util.Date`
+@SuppressWarnings("UnnecessarilyFullyQualified")
 public class SqlTypesGsonTest {
   private Gson gson;
   private TimeZone oldTimeZone;
@@ -52,7 +53,7 @@ public void tearDown() throws Exception {
 
   @Test
   public void testNullSerializationAndDeserialization() {
-    testNullSerializationAndDeserialization(Date.class);
+    testNullSerializationAndDeserialization(java.sql.Date.class);
     testNullSerializationAndDeserialization(Time.class);
     testNullSerializationAndDeserialization(Timestamp.class);
   }

File: gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
Patch:
@@ -37,6 +37,9 @@
  *
  * @author Jesse Wilson
  */
+// Suppress because these classes are only needed for this test, but must be top-level classes
+// to not have an enclosing type
+@SuppressWarnings("MultipleTopLevelClasses")
 public final class TypeTokenTest {
   // These fields are accessed using reflection by the tests below
   List<Integer> listOfInteger = null;

File: metrics/src/main/java/com/google/gson/metrics/NonUploadingCaliperRunner.java
Patch:
@@ -19,6 +19,8 @@
 import com.google.caliper.runner.CaliperMain;
 
 class NonUploadingCaliperRunner {
+  private NonUploadingCaliperRunner() {}
+
   private static String[] concat(String first, String... others) {
     if (others.length == 0) {
       return new String[] {first};

File: shrinker-test/src/main/java/com/example/GenericClasses.java
Patch:
@@ -8,6 +8,8 @@
 import java.io.IOException;
 
 public class GenericClasses {
+  private GenericClasses() {}
+
   static class GenericClass<T> {
     @SerializedName("t")
     T t;

File: shrinker-test/src/main/java/com/example/Main.java
Patch:
@@ -15,6 +15,8 @@
 import java.util.function.Supplier;
 
 public class Main {
+  private Main() {}
+
   /**
    * Main entrypoint, called by {@code ShrinkingIT.test()}.
    *

File: shrinker-test/src/main/java/com/example/NoSerializedNameMain.java
Patch:
@@ -10,6 +10,8 @@
  * therefore not matched by the default {@code gson.pro} rules.
  */
 public class NoSerializedNameMain {
+  private NoSerializedNameMain() {}
+
   static class TestClassNoArgsConstructor {
     // Has a no-args default constructor.
     public String s;

File: shrinker-test/src/main/java/com/example/TestExecutor.java
Patch:
@@ -5,6 +5,8 @@
 import java.util.function.Supplier;
 
 public class TestExecutor {
+  private TestExecutor() {}
+
   /**
    * Helper method for running individual tests. In case of an exception wraps it and includes the
    * {@code name} of the test to make debugging issues with the obfuscated JARs a bit easier.

File: gson/src/main/java/com/google/gson/internal/bind/DefaultDateTypeAdapter.java
Patch:
@@ -187,10 +187,13 @@ private Date deserializeToDate(JsonReader in) throws IOException {
     // Needs to be synchronized since JDK DateFormat classes are not thread-safe
     synchronized (dateFormats) {
       for (DateFormat dateFormat : dateFormats) {
+        TimeZone originalTimeZone = dateFormat.getTimeZone();
         try {
           return dateFormat.parse(s);
         } catch (ParseException ignored) {
           // OK: try the next format
+        } finally {
+          dateFormat.setTimeZone(originalTimeZone);
         }
       }
     }

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -25,7 +25,7 @@
 import com.google.gson.internal.Streams;
 import com.google.gson.internal.bind.ArrayTypeAdapter;
 import com.google.gson.internal.bind.CollectionTypeAdapterFactory;
-import com.google.gson.internal.bind.DateTypeAdapter;
+import com.google.gson.internal.bind.DefaultDateTypeAdapter;
 import com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory;
 import com.google.gson.internal.bind.JsonTreeReader;
 import com.google.gson.internal.bind.JsonTreeWriter;
@@ -369,7 +369,7 @@ public Gson() {
     factories.add(TypeAdapters.LOCALE_FACTORY);
     factories.add(TypeAdapters.INET_ADDRESS_FACTORY);
     factories.add(TypeAdapters.BIT_SET_FACTORY);
-    factories.add(DateTypeAdapter.FACTORY);
+    factories.add(DefaultDateTypeAdapter.DEFAULT_STYLE_FACTORY);
     factories.add(TypeAdapters.CALENDAR_FACTORY);
 
     if (SqlTypesSupport.SUPPORTS_SQL_TYPES) {

File: gson/src/main/java/com/google/gson/stream/JsonWriter.java
Patch:
@@ -356,9 +356,9 @@ public final Strictness getStrictness() {
 
   /**
    * Configures this writer to emit JSON that's safe for direct inclusion in HTML and XML documents.
-   * This escapes the HTML characters {@code <}, {@code >}, {@code &} and {@code =} before writing
-   * them to the stream. Without this setting, your XML/HTML encoder should replace these characters
-   * with the corresponding escape sequences.
+   * This escapes the HTML characters {@code <}, {@code >}, {@code &}, {@code =} and {@code '}
+   * before writing them to the stream. Without this setting, your XML/HTML encoder should replace
+   * these characters with the corresponding escape sequences.
    */
   public final void setHtmlSafe(boolean htmlSafe) {
     this.htmlSafe = htmlSafe;

File: gson/src/test/java/com/google/gson/JsonPrimitiveTest.java
Patch:
@@ -297,7 +297,7 @@ public void testEqualsAcrossTypes() {
         new JsonPrimitive(new BigInteger("0")), new JsonPrimitive(0));
     MoreAsserts.assertEqualsAndHashCode(new JsonPrimitive(0), new JsonPrimitive(0L));
     MoreAsserts.assertEqualsAndHashCode(
-        new JsonPrimitive(new BigInteger("0")), new JsonPrimitive(0));
+        new JsonPrimitive(new BigDecimal("0")), new JsonPrimitive(0));
     MoreAsserts.assertEqualsAndHashCode(
         new JsonPrimitive(Float.NaN), new JsonPrimitive(Double.NaN));
   }

File: gson/src/test/java/com/google/gson/PrimitiveTypeAdapter.java
Patch:
@@ -24,6 +24,8 @@
 /**
  * Handles type conversion from some object to some primitive (or primitive wrapper instance).
  *
+ * <p>Used by {@link ParameterizedTypeFixtures.MyParameterizedTypeAdapter}.
+ *
  * @author Joel Leitch
  */
 final class PrimitiveTypeAdapter {

File: gson/src/test/java/com/google/gson/functional/EscapingTest.java
Patch:
@@ -82,7 +82,7 @@ public void testGsonAcceptsEscapedAndNonEscapedJsonDeserialization() {
     BagOfPrimitives target = new BagOfPrimitives(1L, 1, true, "test' / w'ith\" / \\ <script>");
     String escapedJsonForm = escapeHtmlGson.toJson(target);
     String nonEscapedJsonForm = noEscapeHtmlGson.toJson(target);
-    assertThat(escapedJsonForm.equals(nonEscapedJsonForm)).isFalse();
+    assertThat(escapedJsonForm).isNotEqualTo(nonEscapedJsonForm);
 
     assertThat(noEscapeHtmlGson.fromJson(escapedJsonForm, BagOfPrimitives.class)).isEqualTo(target);
     assertThat(escapeHtmlGson.fromJson(nonEscapedJsonForm, BagOfPrimitives.class))

File: gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
Patch:
@@ -74,10 +74,10 @@ public Base createInstance(Type type) {
 
     String json = "{baseName:'Base',subName:'SubRevised'}";
     Base base = gson.fromJson(json, Base.class);
-    assertThat(base instanceof Sub).isTrue();
+    assertThat(base).isInstanceOf(Sub.class);
 
     Sub sub = (Sub) base;
-    assertThat("SubRevised".equals(sub.subName)).isFalse();
+    assertThat(sub.subName).isNotEqualTo("SubRevised");
     assertThat(sub.subName).isEqualTo(Sub.SUB_NAME);
   }
 
@@ -96,7 +96,7 @@ public Base createInstance(Type type) {
             .create();
     String json = "{base:{baseName:'Base',subName:'SubRevised'}}";
     ClassWithBaseField target = gson.fromJson(json, ClassWithBaseField.class);
-    assertThat(target.base instanceof Sub).isTrue();
+    assertThat(target.base).isInstanceOf(Sub.class);
     assertThat(((Sub) target.base).subName).isEqualTo(Sub.SUB_NAME);
   }
 

File: gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
Patch:
@@ -243,7 +243,7 @@ public JsonElement serialize(
   }
 
   @Test
-  public void testCustomTypeAdapterPassesNullDesrialization() {
+  public void testCustomTypeAdapterPassesNullDeserialization() {
     Gson gson =
         new GsonBuilder()
             .registerTypeAdapter(

File: gson/src/test/java/com/google/gson/functional/NumberLimitsTest.java
Patch:
@@ -39,7 +39,8 @@ private static JsonReader jsonReader(String json) {
    *       large or small numbers (it rounds to 0 or Infinity) (to be verified?; if it had
    *       performance problems with certain numbers, then it would affect other parts of Gson which
    *       parse as float or double as well)
-   *   <li>Enforcing limits only when a JSON number is encountered would be ineffective unless users
+   *   <li>Enforcing limits only when a JSON number is encountered would be ineffective when users
+   *       want to consume a JSON number as string using {@link JsonReader#nextString()} unless they
    *       explicitly call {@link JsonReader#peek()} and check if the value is a JSON number.
    *       Otherwise the limits could be circumvented because {@link JsonReader#nextString()} reads
    *       both strings and numbers, and for JSON strings no restrictions are enforced.

File: gson/src/test/java/com/google/gson/functional/ObjectTest.java
Patch:
@@ -141,9 +141,9 @@ public void testClassWithTransientFieldsDeserialization() {
 
   @Test
   public void testClassWithTransientFieldsDeserializationTransientFieldsPassedInJsonAreIgnored() {
-    String json = "{\"transientLongValue\":1,\"longValue\":[1]}";
+    String json = "{\"transientLongValue\":5,\"longValue\":[1]}";
     ClassWithTransientFields<?> target = gson.fromJson(json, ClassWithTransientFields.class);
-    assertThat(target.transientLongValue != 1).isFalse();
+    assertThat(target.transientLongValue).isEqualTo(1);
   }
 
   @Test

File: gson/src/test/java/com/google/gson/functional/ReadersWritersTest.java
Patch:
@@ -192,7 +192,7 @@ public Appendable append(CharSequence csq, int start, int end) throws IOExceptio
     gson.toJson(Arrays.asList("test", 123, true), appendable);
     // Make sure CharSequence.toString() was called at least two times to verify that
     // CurrentWrite.cachedString is properly overwritten when char array changes
-    assertThat(appendable.toStringCallCount >= 2).isTrue();
+    assertThat(appendable.toStringCallCount).isAtLeast(2);
     assertThat(appendable.stringBuilder.toString()).isEqualTo("[\"test\",123,true]");
   }
 }

File: gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
Patch:
@@ -114,8 +114,8 @@ protected RuntimeTypeAdapterFactory(Class<?> baseType, String typeFieldName) {
     }
 
     /**
-     * Creates a new runtime type adapter using for {@code baseType} using {@code typeFieldName} as
-     * the type field name. Type field names are case sensitive.
+     * Creates a new runtime type adapter for {@code baseType} using {@code typeFieldName} as the
+     * type field name. Type field names are case sensitive.
      */
     public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType, String typeFieldName) {
       return new RuntimeTypeAdapterFactory<>(baseType, typeFieldName);

File: gson/src/test/java/com/google/gson/functional/SecurityTest.java
Patch:
@@ -44,7 +44,7 @@ public void setUp() throws Exception {
   public void testNonExecutableJsonSerialization() {
     Gson gson = gsonBuilder.generateNonExecutableJson().create();
     String json = gson.toJson(new BagOfPrimitives());
-    assertThat(json.startsWith(JSON_NON_EXECUTABLE_PREFIX)).isTrue();
+    assertThat(json).startsWith(JSON_NON_EXECUTABLE_PREFIX);
   }
 
   @Test

File: gson/src/test/java/com/google/gson/internal/GsonTypesTest.java
Patch:
@@ -83,7 +83,7 @@ private static final class C {}
   private final class NonStaticInner<T> {}
 
   /**
-   * Given a parameterized type A&lt;B,C&gt;, returns B. If the specified type is not a generic
+   * Given a parameterized type {@code A<B, C>}, returns B. If the specified type is not a generic
    * type, returns null.
    */
   public static Type getFirstTypeArgument(Type type) throws Exception {

File: gson/src/test/java/com/google/gson/internal/JavaVersionTest.java
Patch:
@@ -31,7 +31,7 @@ public class JavaVersionTest {
   @Test
   public void testGetMajorJavaVersion() {
     // Gson currently requires at least Java 7
-    assertThat(JavaVersion.getMajorJavaVersion() >= 7).isTrue();
+    assertThat(JavaVersion.getMajorJavaVersion()).isAtLeast(7);
   }
 
   @Test

File: gson/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java
Patch:
@@ -48,7 +48,7 @@ public void testLenientNansAndInfinities() throws IOException {
     JsonTreeReader reader = new JsonTreeReader(element);
     reader.setStrictness(Strictness.LENIENT);
     reader.beginArray();
-    assertThat(Double.isNaN(reader.nextDouble())).isTrue();
+    assertThat(reader.nextDouble()).isNaN();
     assertThat(reader.nextDouble()).isEqualTo(Double.NEGATIVE_INFINITY);
     assertThat(reader.nextDouble()).isEqualTo(Double.POSITIVE_INFINITY);
     reader.endArray();

File: gson/src/test/java/com/google/gson/internal/reflect/Java17ReflectionHelperTest.java
Patch:
@@ -54,7 +54,7 @@ public void testJava17RecordAccessors() throws ReflectiveOperationException {
             .newInstance(new PrincipalImpl("user"), new PrincipalImpl("group"));
 
     String[] componentNames = ReflectionHelper.getRecordComponentNames(unixDomainPrincipalClass);
-    assertThat(componentNames.length > 0).isTrue();
+    assertThat(componentNames).isNotEmpty();
 
     for (String componentName : componentNames) {
       Field componentField = unixDomainPrincipalClass.getDeclaredField(componentName);

File: gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
Patch:
@@ -714,7 +714,7 @@ public void testLenientNonFiniteDoubles() throws IOException {
     JsonReader reader = new JsonReader(reader(json));
     reader.setStrictness(Strictness.LENIENT);
     reader.beginArray();
-    assertThat(Double.isNaN(reader.nextDouble())).isTrue();
+    assertThat(reader.nextDouble()).isNaN();
     assertThat(reader.nextDouble()).isEqualTo(Double.NEGATIVE_INFINITY);
     assertThat(reader.nextDouble()).isEqualTo(Double.POSITIVE_INFINITY);
     reader.endArray();
@@ -726,7 +726,7 @@ public void testLenientQuotedNonFiniteDoubles() throws IOException {
     JsonReader reader = new JsonReader(reader(json));
     reader.setStrictness(Strictness.LENIENT);
     reader.beginArray();
-    assertThat(Double.isNaN(reader.nextDouble())).isTrue();
+    assertThat(reader.nextDouble()).isNaN();
     assertThat(reader.nextDouble()).isEqualTo(Double.NEGATIVE_INFINITY);
     assertThat(reader.nextDouble()).isEqualTo(Double.POSITIVE_INFINITY);
     reader.endArray();

File: extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
Patch:
@@ -52,8 +52,8 @@ public void testList() {
     // Throws NullPointerException without the fix in https://github.com/google/gson/pull/1103
     String json = gson.toJson(sandwiches);
     assertEquals(
-        "{\"sandwiches\":[{\"bread\":\"white\",\"cheese\":\"cheddar\"},{\"bread\":\"whole"
-            + " wheat\",\"cheese\":\"swiss\"}]}",
+        "{\"sandwiches\":[{\"bread\":\"white\",\"cheese\":\"cheddar\"},"
+            + "{\"bread\":\"whole wheat\",\"cheese\":\"swiss\"}]}",
         json);
 
     MultipleSandwiches sandwichesFromJson = gson.fromJson(json, MultipleSandwiches.class);

File: graal-native-image-test/src/test/java/com/google/gson/native_test/ReflectionTest.java
Patch:
@@ -90,8 +90,8 @@ void testClassWithoutDefaultConstructor() {
     assertThat(c.i).isEqualTo(1);
 
     c = gson.fromJson("{}", ClassWithoutDefaultConstructor.class);
-    // Class is instantiated with JDK Unsafe, so field keeps its default value instead of assigned
-    // -1
+    // Class is instantiated with JDK Unsafe, therefore field keeps its default value instead of
+    // assigned -1
     assertThat(c.i).isEqualTo(0);
   }
 

File: gson/src/main/java/com/google/gson/JsonArray.java
Patch:
@@ -163,7 +163,8 @@ public boolean remove(JsonElement element) {
 
   /**
    * Removes the element at the specified position in this array. Shifts any subsequent elements to
-   * the left (subtracts one from their indices). Returns the element removed from the array.
+   * the left (subtracts one from their indices). Returns the element that was removed from the
+   * array.
    *
    * @param index index the index of the element to be removed
    * @return the element previously at the specified position

File: gson/src/main/java/com/google/gson/internal/JavaVersion.java
Patch:
@@ -37,7 +37,7 @@ static int getMajorJavaVersion(String javaVersion) {
       version = extractBeginningInt(javaVersion);
     }
     if (version == -1) {
-      return 6; // Choose a minimum supported JDK version as default
+      return 6; // Choose minimum supported JDK version as default
     }
     return version;
   }

File: gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
Patch:
@@ -121,8 +121,8 @@ public <T> T newInstance(Class<T> c) {
         throw new UnsupportedOperationException(
             "Cannot allocate "
                 + c
-                + ". Usage of JDK sun.misc.Unsafe is enabled, "
-                + "but it could not be used. Make sure your runtime is configured correctly.");
+                + ". Usage of JDK sun.misc.Unsafe is enabled, but it could not be used."
+                + " Make sure your runtime is configured correctly.");
       }
     };
   }

File: gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
Patch:
@@ -71,7 +71,7 @@ private JsonAdapter getAnnotation(Class<?> rawType) {
     return rawType.getAnnotation(JsonAdapter.class);
   }
 
-  // this is not safe; requires that user has specified correct adapter class for  @JsonAdapter
+  // this is not safe; requires that user has specified correct adapter class for @JsonAdapter
   @SuppressWarnings("unchecked")
   @Override
   public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {

File: gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
Patch:
@@ -45,8 +45,8 @@ public void write(JsonWriter out, T value) throws IOException {
     // Order of preference for choosing type adapters
     // First preference: a type adapter registered for the runtime type
     // Second preference: a type adapter registered for the declared type
-    // Third preference: reflective type adapter for the runtime type (if it is a subclass of the
-    // declared type)
+    // Third preference: reflective type adapter for the runtime type
+    //                   (if it is a subclass of the declared type)
     // Fourth preference: reflective type adapter for the declared type
 
     TypeAdapter<T> chosen = delegate;

File: gson/src/main/java/com/google/gson/internal/reflect/ReflectionHelper.java
Patch:
@@ -159,10 +159,9 @@ public static String tryMakeAccessible(Constructor<?> constructor) {
     } catch (Exception exception) {
       return "Failed making constructor '"
           + constructorToString(constructor)
-          + "' accessible;"
-          + " either increase its visibility or write a custom InstanceCreator or TypeAdapter for"
+          + "' accessible; either increase its visibility or write a custom InstanceCreator or"
+          + " TypeAdapter for its declaring type: "
           // Include the message since it might contain more detailed information
-          + " its declaring type: "
           + exception.getMessage()
           + getInaccessibleTroubleshootingSuffix(exception);
     }

File: gson/src/main/java/com/google/gson/stream/JsonWriter.java
Patch:
@@ -306,9 +306,9 @@ public final FormattingStyle getFormattingStyle() {
    * @see #setStrictness(Strictness)
    */
   @Deprecated
-  @SuppressWarnings(
-      "InlineMeSuggester") // Don't specify @InlineMe, so caller with `setLenient(false)` becomes
-  // aware of new Strictness.STRICT
+  // Don't specify @InlineMe, so caller with `setLenient(false)` becomes aware of new
+  // Strictness.STRICT
+  @SuppressWarnings("InlineMeSuggester")
   public final void setLenient(boolean lenient) {
     setStrictness(lenient ? Strictness.LENIENT : Strictness.LEGACY_STRICT);
   }

File: gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
Patch:
@@ -648,8 +648,8 @@ public void testJsonElementTypeMismatch() {
       assertThat(expected)
           .hasMessageThat()
           .isEqualTo(
-              "Expected a com.google.gson.JsonObject but was com.google.gson.JsonPrimitive; at path"
-                  + " $");
+              "Expected a com.google.gson.JsonObject but was com.google.gson.JsonPrimitive;"
+                  + " at path $");
     }
   }
 

File: gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
Patch:
@@ -474,9 +474,8 @@ static class Factory implements TypeAdapterFactory {
       @Override
       public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
         return new TypeAdapter<T>() {
-          @SuppressWarnings(
-              "SameNameButDifferent") // suppress Error Prone warning; should be clear that
-          // `Factory` refers to enclosing class
+          // suppress Error Prone warning; should be clear that `Factory` refers to enclosing class
+          @SuppressWarnings("SameNameButDifferent")
           private TypeAdapter<T> delegate() {
             return gson.getDelegateAdapter(Factory.this, type);
           }

File: gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java
Patch:
@@ -604,8 +604,7 @@ public void testDelegatingAdapterFactory_Delayed() {
     assertThat(new Gson().toJson(serialized)).isEqualTo("{\"f\":\"value-custom\"}");
   }
 
-  // suppress Error Prone warning; should be clear that `Factory` refers to nested class to nested
-  // class
+  // suppress Error Prone warning; should be clear that `Factory` refers to nested class
   @SuppressWarnings("SameNameButDifferent")
   private static class WithDelayedDelegatingFactory {
     @JsonAdapter(Factory.class)

File: gson/src/test/java/com/google/gson/functional/LeniencyTest.java
Patch:
@@ -40,7 +40,9 @@ public void setUp() throws Exception {
   public void testLenientFromJson() {
     List<String> json =
         gson.fromJson(
-            "" + "[ # One!\n" + "  'Hi' #Element!\n" + "] # Array!",
+            "[ # One!\n" //
+                + "  'Hi' #Element!\n" //
+                + "] # Array!",
             new TypeToken<List<String>>() {}.getType());
     assertThat(json).isEqualTo(singletonList("Hi"));
   }

File: gson/src/test/java/com/google/gson/functional/MapTest.java
Patch:
@@ -500,7 +500,7 @@ public final void testInterfaceTypeMap() {
 
     String subTypeJson = new Gson().toJson(subType);
     String expected =
-        "{\"bases\":{\"Test\":" + subTypeJson + "}," + "\"subs\":{\"Test\":" + subTypeJson + "}}";
+        "{\"bases\":{\"Test\":" + subTypeJson + "},\"subs\":{\"Test\":" + subTypeJson + "}}";
 
     Gson gsonWithComplexKeys = new GsonBuilder().enableComplexMapKeySerialization().create();
     String json = gsonWithComplexKeys.toJson(element);
@@ -523,7 +523,7 @@ public final void testInterfaceTypeMapWithSerializer() {
     final JsonElement baseTypeJsonElement = tempGson.toJsonTree(subType, TestTypes.Base.class);
     String baseTypeJson = tempGson.toJson(baseTypeJsonElement);
     String expected =
-        "{\"bases\":{\"Test\":" + baseTypeJson + "}," + "\"subs\":{\"Test\":" + subTypeJson + "}}";
+        "{\"bases\":{\"Test\":" + baseTypeJson + "},\"subs\":{\"Test\":" + subTypeJson + "}}";
 
     JsonSerializer<TestTypes.Base> baseTypeAdapter =
         new JsonSerializer<TestTypes.Base>() {

File: gson/src/test/java/com/google/gson/functional/ReflectionAccessFilterTest.java
Patch:
@@ -447,7 +447,7 @@ public JsonElement serialize(
   }
 
   /**
-   * Should not fail when deserializing collection interface (Even though this goes through {@link
+   * Should not fail when deserializing collection interface (even though this goes through {@link
    * ConstructorConstructor} as well)
    */
   @Test
@@ -467,7 +467,7 @@ public FilterResult check(Class<?> rawClass) {
   }
 
   /**
-   * Should not fail when deserializing specific collection implementation (Even though this goes
+   * Should not fail when deserializing specific collection implementation (even though this goes
    * through {@link ConstructorConstructor} as well)
    */
   @Test

File: gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Patch:
@@ -29,8 +29,8 @@
  * #440</a> and similar issues.
  *
  * <p>These tests originally caused {@link StackOverflowError} because of infinite recursion on
- * attempts to resolve generics on types, with an intermediate types like 'Foo2&lt;? extends ? super
- * ? extends ... ? extends A&gt;'
+ * attempts to resolve generics on types, with intermediate types like {@code Foo2<? extends ? super
+ * ? extends ... ? extends A>}
  */
 public class RecursiveTypesResolveTest {
 
@@ -52,7 +52,7 @@ public void testRecursiveResolveSimple() {
     assertThat(adapter).isNotNull();
   }
 
-  /** Tests belows check the behaviour of the methods changed for the fix. */
+  /** Tests below check the behavior of the methods changed for the fix. */
   @Test
   public void testDoubleSupertype() {
     assertThat($Gson$Types.supertypeOf($Gson$Types.supertypeOf(Number.class)))

File: gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
Patch:
@@ -207,8 +207,7 @@ public void testParameterizedFactory_Invalid() {
     assertThat(e)
         .hasMessageThat()
         .isEqualTo(
-            "Type argument int does not satisfy bounds"
-                + " for type variable E declared by "
+            "Type argument int does not satisfy bounds for type variable E declared by "
                 + List.class);
 
     e =

File: gson/src/test/java/com/google/gson/GsonTest.java
Patch:
@@ -93,7 +93,7 @@ public void testClonedTypeAdapterFactoryListsAreIndependent() {
         Collections.<ReflectionAccessFilter>emptyList());
 
     Gson clone = original.newBuilder()
-        .registerTypeAdapter(Object.class, new TestTypeAdapter())
+        .registerTypeAdapter(int.class, new TestTypeAdapter())
         .create();
 
     assertThat(clone.factories).hasSize(original.factories.size() + 1);

File: graal-native-image-test/src/test/java/com/google/gson/native_test/Java17RecordReflectionTest.java
Patch:
@@ -27,7 +27,6 @@
 import java.io.IOException;
 import org.junit.jupiter.api.Test;
 
-@SuppressWarnings("UnusedVariable") // workaround for https://github.com/google/error-prone/issues/2713
 class Java17RecordReflectionTest {
   public record PublicRecord(int i) {
   }

File: gson/src/main/java/com/google/gson/JsonPrimitive.java
Patch:
@@ -285,7 +285,7 @@ public boolean equals(Object obj) {
       return other.value == null;
     }
     if (isIntegral(this) && isIntegral(other)) {
-      return this.value instanceof BigInteger || other.value instanceof BigInteger
+      return (this.value instanceof BigInteger || other.value instanceof BigInteger)
           ? this.getAsBigInteger().equals(other.getAsBigInteger())
           : this.getAsNumber().longValue() == other.getAsNumber().longValue();
     }

File: gson/src/main/java/com/google/gson/JsonArray.java
Patch:
@@ -225,7 +225,7 @@ public Iterator<JsonElement> iterator() {
    *
    * @param i the index of the element that is being sought.
    * @return the element present at the i-th index.
-   * @throws IndexOutOfBoundsException if i is negative or greater than or equal to the
+   * @throws IndexOutOfBoundsException if {@code i} is negative or greater than or equal to the
    * {@link #size()} of the array.
    */
   public JsonElement get(int i) {

File: gson/src/main/java/com/google/gson/annotations/Until.java
Patch:
@@ -63,7 +63,7 @@
 public @interface Until {
 
   /**
-   * The value indicating a version number until this member or type should be be included.
+   * The value indicating a version number until this member or type should be included.
    * The number is exclusive; annotated elements will be included if {@code gsonVersion < value}.
    */
   double value();

File: gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
Patch:
@@ -36,7 +36,7 @@
 /**
  * Adapts a Gson 1.x tree-style adapter as a streaming TypeAdapter. Since the
  * tree adapter may be serialization-only or deserialization-only, this class
- * has a facility to lookup a delegate type adapter on demand.
+ * has a facility to look up a delegate type adapter on demand.
  */
 public final class TreeTypeAdapter<T> extends SerializationDelegatingTypeAdapter<T> {
   private final JsonSerializer<T> serializer;

File: gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
Patch:
@@ -45,7 +45,7 @@ public void write(JsonWriter out, T value) throws IOException {
     // Order of preference for choosing type adapters
     // First preference: a type adapter registered for the runtime type
     // Second preference: a type adapter registered for the declared type
-    // Third preference: reflective type adapter for the runtime type (if it is a sub class of the declared type)
+    // Third preference: reflective type adapter for the runtime type (if it is a subclass of the declared type)
     // Fourth preference: reflective type adapter for the declared type
 
     TypeAdapter<T> chosen = delegate;

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -686,7 +686,7 @@ private int peekKeyword() throws IOException {
       return PEEKED_NONE;
     }
 
-    // Upper cased keywords are not allowed in STRICT mode
+    // Uppercased keywords are not allowed in STRICT mode
     boolean allowsUpperCased = strictness != Strictness.STRICT;
 
     // Confirm that chars [0..length) match the keyword.
@@ -1745,7 +1745,7 @@ private IllegalStateException unexpectedTokenError(String expected) throws IOExc
    * Consumes the non-execute prefix if it exists.
    */
   private void consumeNonExecutePrefix() throws IOException {
-    // fast forward through the leading whitespace
+    // fast-forward through the leading whitespace
     int unused = nextNonWhitespace(true);
     pos--;
 

File: gson/src/test/java/com/google/gson/functional/EnumTest.java
Patch:
@@ -176,7 +176,7 @@ public void testEnumSet() {
     Type type = new TypeToken<EnumSet<Roshambo>>() {}.getType();
     EnumSet<Roshambo> bar = gson.fromJson(json, type);
     assertThat(bar).containsExactly(Roshambo.ROCK, Roshambo.PAPER).inOrder();
-    assertThat(bar).doesNotContain(Roshambo.SCISSORS);;
+    assertThat(bar).doesNotContain(Roshambo.SCISSORS);
   }
 
   @Test

File: metrics/src/main/java/com/google/gson/metrics/ParseBenchmark.java
Patch:
@@ -270,7 +270,7 @@ public void parse(char[] data, Document document) throws Exception {
   }
 
   private static class GsonBindParser implements Parser {
-    private static Gson gson = new GsonBuilder()
+    private static final Gson gson = new GsonBuilder()
         .setDateFormat("EEE MMM dd HH:mm:ss Z yyyy")
         .create();
 

File: shrinker-test/src/main/java/com/example/ClassWithHasArgsConstructor.java
Patch:
@@ -3,15 +3,15 @@
 import com.google.gson.annotations.SerializedName;
 
 /**
- * Class without no-args default constructor, but with field annotated with
+ * Class without no-args constructor, but with field annotated with
  * {@link SerializedName}.
  */
-public class ClassWithoutDefaultConstructor {
+public class ClassWithHasArgsConstructor {
   @SerializedName("myField")
   public int i;
 
   // Specify explicit constructor with args to remove implicit no-args default constructor
-  public ClassWithoutDefaultConstructor(int i) {
+  public ClassWithHasArgsConstructor(int i) {
     this.i = i;
   }
 }

File: shrinker-test/src/main/java/com/example/ClassWithNoArgsConstructor.java
Patch:
@@ -3,14 +3,14 @@
 import com.google.gson.annotations.SerializedName;
 
 /**
- * Class with no-args default constructor and with field annotated with
+ * Class with no-args constructor and with field annotated with
  * {@link SerializedName}.
  */
-public class ClassWithDefaultConstructor {
+public class ClassWithNoArgsConstructor {
   @SerializedName("myField")
   public int i;
 
-  public ClassWithDefaultConstructor() {
+  public ClassWithNoArgsConstructor() {
     i = -3;
   }
 }

File: gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java
Patch:
@@ -139,14 +139,14 @@ private void put(JsonElement value) {
   @Override public JsonWriter name(String name) throws IOException {
     Objects.requireNonNull(name, "name == null");
     if (stack.isEmpty() || pendingName != null) {
-      throw new IllegalStateException();
+      throw new IllegalStateException("Did not expect a name");
     }
     JsonElement element = peek();
     if (element instanceof JsonObject) {
       pendingName = name;
       return this;
     }
-    throw new IllegalStateException();
+    throw new IllegalStateException("Please begin an object before writing a name.");
   }
 
   @CanIgnoreReturnValue

File: gson/src/main/java/com/google/gson/InstanceCreator.java
Patch:
@@ -63,7 +63,7 @@
  * </pre>
  *
  * <p>Note that it does not matter what the fields of the created instance contain since Gson will
- * overwrite them with the deserialized values specified in Json. You should also ensure that a
+ * overwrite them with the deserialized values specified in JSON. You should also ensure that a
  * <i>new</i> object is returned, not a common object since its fields will be overwritten.
  * The developer will need to register {@code IdInstanceCreator} with Gson as follows:</p>
  *
@@ -81,7 +81,7 @@ public interface InstanceCreator<T> {
   /**
    * Gson invokes this call-back method during deserialization to create an instance of the
    * specified type. The fields of the returned instance are overwritten with the data present
-   * in the Json. Since the prior contents of the object are destroyed and overwritten, do not
+   * in the JSON. Since the prior contents of the object are destroyed and overwritten, do not
    * return an instance that is useful elsewhere. In particular, do not return a common instance,
    * always use {@code new} to create a new instance.
    *

File: gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
Patch:
@@ -156,7 +156,7 @@ private BoundField createBoundField(
     if (annotation != null) {
       // This is not safe; requires that user has specified correct adapter class for @JsonAdapter
       mapped = jsonAdapterFactory.getTypeAdapter(
-          constructorConstructor, context, fieldType, annotation);
+          constructorConstructor, context, fieldType, annotation, false);
     }
     final boolean jsonAdapterPresent = mapped != null;
     if (mapped == null) mapped = context.getAdapter(fieldType);

File: gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
Patch:
@@ -33,7 +33,7 @@
 import org.junit.Test;
 
 /**
- * Functional Test exercising custom serialization only. When test applies to both
+ * Functional Test exercising custom deserialization only. When test applies to both
  * serialization and deserialization then add it to CustomTypeAdapterTest.
  *
  * @author Inderjeet Singh

File: metrics/src/main/java/com/google/gson/metrics/ParseBenchmark.java
Patch:
@@ -351,7 +351,7 @@ static class User {
     @JsonProperty boolean geo_enabled;
     @JsonProperty boolean verified;
     @JsonProperty String profile_background_image_url;
-    @JsonProperty boolean defalut_profile_image;
+    @JsonProperty boolean default_profile_image;
     @JsonProperty int friends_count;
     @JsonProperty int statuses_count;
     @JsonProperty String screen_name;

File: shrinker-test/src/main/java/com/example/ClassWithJsonAdapterAnnotation.java
Patch:
@@ -78,7 +78,7 @@ public void write(JsonWriter out, DummyClass value) throws IOException {
   static class Factory implements TypeAdapterFactory {
     @Override
     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
-      @SuppressWarnings("unchecked") // the code below is not type safe, but does not matter for this test
+      @SuppressWarnings("unchecked") // the code below is not type-safe, but does not matter for this test
       TypeAdapter<T> r = (TypeAdapter<T>) new TypeAdapter<DummyClass>() {
         @Override
         public DummyClass read(JsonReader in) throws IOException {

File: gson/src/test/java/com/google/gson/DefaultInetAddressTypeAdapterTest.java
Patch:
@@ -37,6 +37,7 @@ public void setUp() throws Exception {
   
   @Test
   public void testInetAddressSerializationAndDeserialization() throws Exception {
+    @SuppressWarnings("AddressSelection") // we really do want this method
     InetAddress address = InetAddress.getByName("8.8.8.8");
     String jsonAddress = gson.toJson(address);
     assertThat(jsonAddress).isEqualTo("\"8.8.8.8\"");

File: gson/src/main/java/com/google/gson/JsonElement.java
Patch:
@@ -321,7 +321,8 @@ public String toString() {
     try {
       StringWriter stringWriter = new StringWriter();
       JsonWriter jsonWriter = new JsonWriter(stringWriter);
-      jsonWriter.setLenient(true);
+      // Make writer lenient because toString() must not fail, even if for example JsonPrimitive contains NaN
+      jsonWriter.setStrictness(Strictness.LENIENT);
       Streams.write(this, jsonWriter);
       return stringWriter.toString();
     } catch (IOException e) {

File: gson/src/main/java/com/google/gson/JsonStreamParser.java
Patch:
@@ -28,7 +28,7 @@
 /**
  * A streaming parser that allows reading of multiple {@link JsonElement}s from the specified reader
  * asynchronously. The JSON data is parsed in lenient mode, see also
- * {@link JsonReader#setLenient(boolean)}.
+ * {@link JsonReader#setStrictness(Strictness)}.
  *
  * <p>This class is conditionally thread-safe (see Item 70, Effective Java second edition). To
  * properly use this class across multiple threads, you will need to add some external
@@ -66,7 +66,7 @@ public JsonStreamParser(String json) {
    */
   public JsonStreamParser(Reader reader) {
     parser = new JsonReader(reader);
-    parser.setLenient(true);
+    parser.setStrictness(Strictness.LENIENT);
     lock = new Object();
   }
 

File: gson/src/main/java/com/google/gson/stream/MalformedJsonException.java
Patch:
@@ -16,11 +16,12 @@
 
 package com.google.gson.stream;
 
+import com.google.gson.Strictness;
 import java.io.IOException;
 
 /**
  * Thrown when a reader encounters malformed JSON. Some syntax errors can be
- * ignored by calling {@link JsonReader#setLenient(boolean)}.
+ * ignored by using {@link Strictness#LENIENT} for {@link JsonReader#setStrictness(Strictness)}.
  */
 public final class MalformedJsonException extends IOException {
   private static final long serialVersionUID = 1L;

File: gson/src/test/java/com/google/gson/MixedStreamTest.java
Patch:
@@ -81,6 +81,7 @@ public void testReadMixedStreamed() throws IOException {
     jsonReader.endArray();
   }
 
+  @SuppressWarnings("deprecation") // for JsonReader.setLenient
   @Test
   public void testReaderDoesNotMutateState() throws IOException {
     Gson gson = new Gson();
@@ -96,6 +97,7 @@ public void testReaderDoesNotMutateState() throws IOException {
     assertThat(jsonReader.isLenient()).isTrue();
   }
 
+  @SuppressWarnings("deprecation") // for JsonWriter.setLenient
   @Test
   public void testWriteDoesNotMutateState() throws IOException {
     Gson gson = new Gson();

File: gson/src/test/java/com/google/gson/functional/ArrayTest.java
Patch:
@@ -28,7 +28,6 @@
 import java.lang.reflect.Type;
 import java.math.BigDecimal;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
 import org.junit.Before;
 import org.junit.Test;

File: gson/src/test/java/com/google/gson/functional/LeniencyTest.java
Patch:
@@ -32,6 +32,7 @@ public class LeniencyTest {
 
   private Gson gson;
 
+  @SuppressWarnings({"deprecation", "InlineMeInliner"}) // for GsonBuilder.setLenient
   @Before
   public void setUp() throws Exception {
     gson = new GsonBuilder().setLenient().create();

File: gson/src/test/java/com/google/gson/functional/PrettyPrintingTest.java
Patch:
@@ -26,7 +26,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import org.junit.Before;
@@ -92,7 +91,7 @@ public void testPrettyPrintListOfPrimitiveArrays() {
     assertThat(json).isEqualTo("[\n  [\n    1,\n    2\n  ],\n  [\n    3,\n    4\n  ],\n  [\n    5,\n    6\n  ],"
         + "\n  [\n    7,\n    8\n  ],\n  [\n    9,\n    0\n  ],\n  [\n    10\n  ]\n]");
   }
-  
+
   @Test
   public void testMap() {
     Map<String, Integer> map = new LinkedHashMap<>();

File: gson/src/test/java/com/google/gson/functional/UncategorizedTest.java
Patch:
@@ -28,7 +28,6 @@
 import com.google.gson.common.TestTypes.ClassOverridingEquals;
 import com.google.gson.reflect.TypeToken;
 import java.lang.reflect.Type;
-import java.util.Arrays;
 import java.util.List;
 import org.junit.Before;
 import org.junit.Test;

File: gson/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java
Patch:
@@ -22,6 +22,7 @@
 import com.google.gson.JsonElement;
 import com.google.gson.JsonParser;
 import com.google.gson.JsonPrimitive;
+import com.google.gson.Strictness;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.MalformedJsonException;
 import java.io.IOException;
@@ -45,7 +46,7 @@ public void testNumbers() throws IOException {
   public void testLenientNansAndInfinities() throws IOException {
     JsonElement element = JsonParser.parseString("[NaN, -Infinity, Infinity]");
     JsonTreeReader reader = new JsonTreeReader(element);
-    reader.setLenient(true);
+    reader.setStrictness(Strictness.LENIENT);
     reader.beginArray();
     assertThat(Double.isNaN(reader.nextDouble())).isTrue();
     assertThat(reader.nextDouble()).isEqualTo(Double.NEGATIVE_INFINITY);
@@ -57,7 +58,7 @@ public void testLenientNansAndInfinities() throws IOException {
   public void testStrictNansAndInfinities() throws IOException {
     JsonElement element = JsonParser.parseString("[NaN, -Infinity, Infinity]");
     JsonTreeReader reader = new JsonTreeReader(element);
-    reader.setLenient(false);
+    reader.setStrictness(Strictness.LEGACY_STRICT);
     reader.beginArray();
     try {
       reader.nextDouble();

File: gson/src/test/java/com/google/gson/internal/bind/JsonTreeReaderTest.java
Patch:
@@ -144,7 +144,7 @@ public JsonElement deepCopy() {
    */
   @Test
   public void testOverrides() {
-    List<String> ignoredMethods = Arrays.asList("setLenient(boolean)", "isLenient()");
+    List<String> ignoredMethods = Arrays.asList("setLenient(boolean)", "isLenient()", "setStrictness(com.google.gson.Strictness)", "getStrictness()");
     MoreAsserts.assertOverridesMethods(JsonReader.class, JsonTreeReader.class, ignoredMethods);
   }
 }

File: gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java
Patch:
@@ -20,6 +20,7 @@
 import static org.junit.Assume.assumeTrue;
 
 import com.google.gson.JsonElement;
+import com.google.gson.Strictness;
 import com.google.gson.internal.Streams;
 import com.google.gson.internal.bind.JsonTreeReader;
 import java.io.IOException;
@@ -201,7 +202,7 @@ public static List<Object[]> parameters() {
     assumeTrue(factory == Factory.STRING_READER);
 
     JsonReader reader = factory.create("[][]");
-    reader.setLenient(true);
+    reader.setStrictness(Strictness.LENIENT);
     reader.beginArray();
     reader.endArray();
     assertThat(reader.getPreviousPath()).isEqualTo("$");

File: shrinker-test/src/main/java/com/example/ClassWithJsonAdapterAnnotation.java
Patch:
@@ -23,6 +23,7 @@
  */
 public class ClassWithJsonAdapterAnnotation {
   // For this field don't use @SerializedName and ignore it for deserialization
+  // Has custom ProGuard rule to keep the field name
   @JsonAdapter(value = Adapter.class, nullSafe = false)
   DummyClass f;
 

File: gson/src/main/java/com/google/gson/internal/NonNullElementWrapperList.java
Patch:
@@ -33,6 +33,7 @@ public class NonNullElementWrapperList<E> extends AbstractList<E> implements Ran
   // Explicitly specify ArrayList as type to guarantee that delegate implements RandomAccess
   private final ArrayList<E> delegate;
 
+  @SuppressWarnings("NonApiType")
   public NonNullElementWrapperList(ArrayList<E> delegate) {
     this.delegate = Objects.requireNonNull(delegate);
   }

File: gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
Patch:
@@ -691,6 +691,7 @@ public void testTreeSetDeserialization() {
     assertThat(treeSet).contains("Value1");
   }
 
+  @SuppressWarnings("UnnecessaryStringBuilder") // TODO: b/287969247 - remove when EP bug fixed
   @Test
   public void testStringBuilderSerialization() {
     StringBuilder sb = new StringBuilder("abc");

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -141,7 +141,7 @@
 public final class Gson {
   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;
   static final boolean DEFAULT_LENIENT = false;
-  static final FormattingStyle DEFAULT_FORMATTING_STYLE = null;
+  static final FormattingStyle DEFAULT_FORMATTING_STYLE = FormattingStyle.COMPACT;
   static final boolean DEFAULT_ESCAPE_HTML = true;
   static final boolean DEFAULT_SERIALIZE_NULLS = false;
   static final boolean DEFAULT_COMPLEX_MAP_KEYS = false;
@@ -205,7 +205,7 @@ public final class Gson {
    *   means that all the unneeded white-space is removed. You can change this behavior with
    *   {@link GsonBuilder#setPrettyPrinting()}.</li>
    *   <li>When the JSON generated contains more than one line, the kind of newline and indent to
-   *   use can be configured with {@link GsonBuilder#setPrettyPrinting(FormattingStyle)}.</li>
+   *   use can be configured with {@link GsonBuilder#setFormattingStyle(FormattingStyle)}.</li>
    *   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are
    *   kept as is since an array is an ordered list. Moreover, if a field is not null, but its
    *   generated JSON is empty, the field is kept. You can configure Gson to serialize null values
@@ -894,7 +894,7 @@ public void toJson(JsonElement jsonElement, Appendable writer) throws JsonIOExce
    *   <li>{@link GsonBuilder#serializeNulls()}</li>
    *   <li>{@link GsonBuilder#setLenient()}</li>
    *   <li>{@link GsonBuilder#setPrettyPrinting()}</li>
-   *   <li>{@link GsonBuilder#setPrettyPrinting(FormattingStyle)}</li>
+   *   <li>{@link GsonBuilder#setFormattingStyle(FormattingStyle)}</li>
    * </ul>
    */
   public JsonWriter newJsonWriter(Writer writer) throws IOException {

File: gson/src/test/java/com/google/gson/GsonTest.java
Patch:
@@ -63,7 +63,7 @@ public final class GsonTest {
   public void testOverridesDefaultExcluder() {
     Gson gson = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
         new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
-        FormattingStyle.DEFAULT, true, false, true,
+        FormattingStyle.PRETTY, true, false, true,
         LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
         DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
         new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>(),
@@ -80,7 +80,7 @@ public void testOverridesDefaultExcluder() {
   public void testClonedTypeAdapterFactoryListsAreIndependent() {
     Gson original = new Gson(CUSTOM_EXCLUDER, CUSTOM_FIELD_NAMING_STRATEGY,
         new HashMap<Type, InstanceCreator<?>>(), true, false, true, false,
-        FormattingStyle.DEFAULT, true, false, true,
+        FormattingStyle.PRETTY, true, false, true,
         LongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT,
         DateFormat.DEFAULT, new ArrayList<TypeAdapterFactory>(),
         new ArrayList<TypeAdapterFactory>(), new ArrayList<TypeAdapterFactory>(),

File: gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
Patch:
@@ -51,6 +51,8 @@ public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {
 
   TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,
       TypeToken<?> type, JsonAdapter annotation) {
+    // TODO: The exception messages created by ConstructorConstructor are currently written in the context of
+    // deserialization and for example suggest usage of TypeAdapter, which would not work for @JsonAdapter usage
     Object instance = constructorConstructor.get(TypeToken.get(annotation.value())).construct();
 
     TypeAdapter<?> typeAdapter;

File: gson/src/test/java/com/google/gson/FieldNamingPolicyTest.java
Patch:
@@ -99,7 +99,7 @@ class Dummy {
     try {
       // Verify that default Locale has different case conversion rules
       assertWithMessage("Test setup is broken")
-          .that(name.toUpperCase()).doesNotMatch(expected);
+          .that(name.toUpperCase(Locale.getDefault())).doesNotMatch(expected);
 
       for (FieldNamingPolicy policy : policies) {
         // Should ignore default Locale
@@ -138,7 +138,7 @@ class Dummy {
     try {
       // Verify that default Locale has different case conversion rules
       assertWithMessage("Test setup is broken")
-          .that(name.toLowerCase()).doesNotMatch(expected);
+          .that(name.toLowerCase(Locale.getDefault())).doesNotMatch(expected);
 
       for (FieldNamingPolicy policy : policies) {
         // Should ignore default Locale

File: extras/src/test/java/com/google/gson/graph/GraphAdapterBuilderTest.java
Patch:
@@ -129,8 +129,8 @@ public void testDeserializeListOfLists() {
   @Test
   public void testSerializationWithMultipleTypes() {
     Company google = new Company("Google");
-    new Employee("Jesse", google);
-    new Employee("Joel", google);
+    Employee unused1 = new Employee("Jesse", google);
+    Employee unused2 = new Employee("Joel", google);
 
     GsonBuilder gsonBuilder = new GsonBuilder();
     new GraphAdapterBuilder()

File: extras/src/test/java/com/google/gson/interceptors/InterceptorTest.java
Patch:
@@ -110,9 +110,9 @@ public void testCustomTypeAdapter() {
 
           @Override public User read(JsonReader in) throws IOException {
             in.beginObject();
-            in.nextName();
+            String unused1 = in.nextName();
             String name = in.nextString();
-            in.nextName();
+            String unused2 = in.nextName();
             String password = in.nextString();
             in.endObject();
             return new User(name, password);

File: extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java
Patch:
@@ -64,7 +64,7 @@ public void testUtcDatesOnJdkBefore1_7() {
     Gson gson = new GsonBuilder()
       .registerTypeAdapter(Date.class, new UtcDateTypeAdapter())
       .create();
-    gson.fromJson("'2014-12-05T04:00:00.000Z'", Date.class);
+    Date unused = gson.fromJson("'2014-12-05T04:00:00.000Z'", Date.class);
   }
 
   @Test

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -1223,7 +1223,7 @@ public <T> T fromJson(JsonReader reader, TypeToken<T> typeOfT) throws JsonIOExce
     boolean oldLenient = reader.isLenient();
     reader.setLenient(true);
     try {
-      reader.peek();
+      JsonToken unused = reader.peek();
       isEmpty = false;
       TypeAdapter<T> typeAdapter = getAdapter(typeOfT);
       return typeAdapter.read(reader);

File: gson/src/main/java/com/google/gson/JsonElement.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.gson;
 
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.gson.internal.Streams;
 import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
@@ -143,6 +144,7 @@ public JsonPrimitive getAsJsonPrimitive() {
    * @throws IllegalStateException if this element is of another type.
    * @since 1.2
    */
+  @CanIgnoreReturnValue
   public JsonNull getAsJsonNull() {
     if (isJsonNull()) {
       return (JsonNull) this;

File: gson/src/main/java/com/google/gson/JsonObject.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.gson;
 
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.gson.internal.LinkedTreeMap;
 import java.util.Map;
 import java.util.Set;
@@ -77,6 +78,7 @@ public void add(String property, JsonElement value) {
    *   member with this name exists.
    * @since 1.3
    */
+  @CanIgnoreReturnValue
   public JsonElement remove(String property) {
     return members.remove(property);
   }

File: gson/src/main/java/com/google/gson/JsonStreamParser.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.google.gson;
 
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.gson.internal.Streams;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
@@ -33,7 +34,7 @@
  * <p>This class is conditionally thread-safe (see Item 70, Effective Java second edition). To
  * properly use this class across multiple threads, you will need to add some external
  * synchronization. For example:
- * 
+ *
  * <pre>
  * JsonStreamParser parser = new JsonStreamParser("['first'] {'second':10} 'third'");
  * JsonElement element;

File: gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java
Patch:
@@ -17,6 +17,7 @@
 
 package com.google.gson.internal;
 
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import java.io.IOException;
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
@@ -107,6 +108,7 @@ public LinkedTreeMap(Comparator<? super K> comparator, boolean allowNullValues)
     return findByObject(key) != null;
   }
 
+  @CanIgnoreReturnValue
   @Override public V put(K key, V value) {
     if (key == null) {
       throw new NullPointerException("key == null");

File: gson/src/main/java/com/google/gson/internal/Streams.java
Patch:
@@ -23,6 +23,7 @@
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.internal.bind.TypeAdapters;
 import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
 import com.google.gson.stream.MalformedJsonException;
 import java.io.EOFException;
@@ -44,7 +45,7 @@ private Streams() {
   public static JsonElement parse(JsonReader reader) throws JsonParseException {
     boolean isEmpty = true;
     try {
-      reader.peek();
+      JsonToken unused = reader.peek();
       isEmpty = false;
       return TypeAdapters.JSON_ELEMENT.read(reader);
     } catch (EOFException e) {

File: gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.gson.internal.bind;
 
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.gson.JsonArray;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonNull;
@@ -153,6 +154,7 @@ private Object peekStack() {
     return stack[stackSize - 1];
   }
 
+  @CanIgnoreReturnValue
   private Object popStack() {
     Object result = stack[--stackSize];
     stack[stackSize] = null;

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -1119,7 +1119,7 @@ private void skipQuotedValue(char quote) throws IOException {
           return;
         } else if (c == '\\') {
           pos = p;
-          readEscapeCharacter();
+          char unused = readEscapeCharacter();
           p = pos;
           l = limit;
         } else if (c == '\n') {
@@ -1664,7 +1664,7 @@ private IOException syntaxError(String message) throws IOException {
    */
   private void consumeNonExecutePrefix() throws IOException {
     // fast forward through the leading whitespace
-    nextNonWhitespace(true);
+    int unused = nextNonWhitespace(true);
     pos--;
 
     if (pos + 5 > limit && !fillBuffer(5)) {

File: gson/src/test/java/com/google/gson/JsonStreamParserTest.java
Patch:
@@ -70,8 +70,8 @@ public void testNoSideEffectForHasNext() {
 
   @Test
   public void testCallingNextBeyondAvailableInput() {
-    parser.next();
-    parser.next();
+    JsonElement unused1 = parser.next();
+    JsonElement unused2 = parser.next();
     try {
       parser.next();
       fail("Parser should not go beyond available input");

File: gson/src/test/java/com/google/gson/MixedStreamTest.java
Patch:
@@ -88,11 +88,11 @@ public void testReaderDoesNotMutateState() throws IOException {
     jsonReader.beginArray();
 
     jsonReader.setLenient(false);
-    gson.fromJson(jsonReader, Car.class);
+    Car unused1 = gson.fromJson(jsonReader, Car.class);
     assertThat(jsonReader.isLenient()).isFalse();
 
     jsonReader.setLenient(true);
-    gson.fromJson(jsonReader, Car.class);
+    Car unused2 = gson.fromJson(jsonReader, Car.class);
     assertThat(jsonReader.isLenient()).isTrue();
   }
 

File: gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
Patch:
@@ -127,7 +127,7 @@ public void testUrlDeserialization() {
     URL target = gson.fromJson(json, URL.class);
     assertThat(target.toExternalForm()).isEqualTo(urlValue);
 
-    gson.fromJson('"' + urlValue + '"', URL.class);
+    URL unused = gson.fromJson('"' + urlValue + '"', URL.class);
     assertThat(target.toExternalForm()).isEqualTo(urlValue);
   }
 

File: gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.gson.Gson;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
@@ -124,6 +125,7 @@ public static <T> RuntimeTypeAdapterFactory<T> of(Class<T> baseType) {
      * @throws IllegalArgumentException if either {@code type} or {@code label}
      *     have already been registered on this type adapter.
      */
+    @CanIgnoreReturnValue
     public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type, String label) {
       if (type == null || label == null) {
         throw new NullPointerException();
@@ -143,6 +145,7 @@ public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type, Str
      * @throws IllegalArgumentException if either {@code type} or its simple name
      *     have already been registered on this type adapter.
      */
+    @CanIgnoreReturnValue
     public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type) {
       return registerSubtype(type, type.getSimpleName());
     }

File: gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java
Patch:
@@ -136,7 +136,7 @@ public void testRegisterSuperTypeFirst() {
   /** This behaviour changed in Gson 2.1; it used to throw. */
   @Test
   public void testRegisterSubTypeFirstAllowed() {
-    new GsonBuilder()
+    Gson unused = new GsonBuilder()
         .registerTypeHierarchyAdapter(Manager.class, new ManagerAdapter())
         .registerTypeHierarchyAdapter(Employee.class, new EmployeeAdapter())
         .create();

File: gson/src/test/java/com/google/gson/internal/bind/JsonElementReaderTest.java
Patch:
@@ -332,17 +332,17 @@ public void testNextJsonElement() throws IOException {
       fail();
     } catch (IllegalStateException expected) {
     }
-    reader.nextName();
+    String unused1 = reader.nextName();
     assertThat(new JsonPrimitive(1)).isEqualTo(reader.nextJsonElement());
-    reader.nextName();
+    String unused2 = reader.nextName();
     reader.beginObject();
     try {
       reader.nextJsonElement();
       fail();
     } catch (IllegalStateException expected) {
     }
     reader.endObject();
-    reader.nextName();
+    String unused3 = reader.nextName();
     reader.beginArray();
     try {
       reader.nextJsonElement();

File: gson/src/test/java/com/google/gson/regression/JsonAdapterNullSafeTest.java
Patch:
@@ -30,7 +30,7 @@ public class JsonAdapterNullSafeTest {
   @Test
   public void testNullSafeBugSerialize() {
     Device device = new Device("ec57803e");
-    gson.toJson(device);
+    String unused = gson.toJson(device);
   }
 
   @Test

File: extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java
Patch:
@@ -62,7 +62,7 @@ public Date read(JsonReader in) throws IOException {
   }
 
   // Date parsing code from Jackson databind ISO8601Utils.java
-  // https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java
+  // https://github.com/FasterXML/jackson-databind/blob/2.8/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java
   private static final String GMT_ID = "GMT";
 
   /**

File: gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
Patch:
@@ -25,15 +25,15 @@
 import java.util.TimeZone;
 
 /**
- * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than using SimpleDateFormat so
+ * Utilities methods for manipulating dates in iso8601 format. This is much faster and GC friendly than using SimpleDateFormat so
  * highly suitable if you (un)serialize lots of date objects.
  * 
  * Supported parse format: [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:]mm]]
  * 
  * @see <a href="http://www.w3.org/TR/NOTE-datetime">this specification</a>
  */
-//Date parsing code from Jackson databind ISO8601Utils.java
-// https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java
+// Date parsing code from Jackson databind ISO8601Utils.java
+// https://github.com/FasterXML/jackson-databind/blob/2.8/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java
 public class ISO8601Utils
 {
     /**

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -1587,7 +1587,7 @@ public String getPath() {
    * been read. This supports both unicode escapes "u000A" and two-character
    * escapes "\n".
    *
-   * @throws NumberFormatException if any unicode escape sequences are
+   * @throws MalformedJsonException if any unicode escape sequences are
    *     malformed.
    */
   @SuppressWarnings("fallthrough")
@@ -1614,7 +1614,7 @@ private char readEscapeCharacter() throws IOException {
         } else if (c >= 'A' && c <= 'F') {
           result += (c - 'A' + 10);
         } else {
-          throw new NumberFormatException("\\u" + new String(buffer, pos, 4));
+          throw new MalformedJsonException("\\u" + new String(buffer, pos, 4));
         }
       }
       pos += 4;

File: gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
Patch:
@@ -355,7 +355,7 @@ public void testUnescapingInvalidCharacters() throws IOException {
     try {
       reader.nextString();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (MalformedJsonException expected) {
     }
   }
 

File: extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java
Patch:
@@ -29,6 +29,7 @@
 import java.util.TimeZone;
 import org.junit.Test;
 
+@SuppressWarnings("JavaUtilDate")
 public final class UtcDateTypeAdapterTest {
   private final Gson gson = new GsonBuilder()
     .registerTypeAdapter(Date.class, new UtcDateTypeAdapter())

File: gson/src/main/java/com/google/gson/JsonDeserializationContext.java
Patch:
@@ -40,5 +40,6 @@ public interface JsonDeserializationContext {
    * @return An object of type typeOfT.
    * @throws JsonParseException if the parse tree does not contain expected data.
    */
+  @SuppressWarnings("TypeParameterUnusedInFormals")
   public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException;
 }
\ No newline at end of file

File: gson/src/main/java/com/google/gson/internal/JavaVersion.java
Patch:
@@ -45,7 +45,7 @@ static int getMajorJavaVersion(String javaVersion) {
   // Parses both legacy 1.8 style and newer 9.0.4 style 
   private static int parseDotted(String javaVersion) {
     try {
-      String[] parts = javaVersion.split("[._]");
+      String[] parts = javaVersion.split("[._]", 3);
       int firstVer = Integer.parseInt(parts[0]);
       if (firstVer == 1 && parts.length > 1) {
         return Integer.parseInt(parts[1]);

File: gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
Patch:
@@ -81,6 +81,7 @@ private boolean includeField(Field f, boolean serialize) {
   }
 
   /** first element holds the default name */
+  @SuppressWarnings("MixedMutabilityReturnType")
   private List<String> getFieldNames(Field f) {
     SerializedName annotation = f.getAnnotation(SerializedName.class);
     if (annotation == null) {

File: gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
Patch:
@@ -174,8 +174,9 @@ private final class GsonContextImpl implements JsonSerializationContext, JsonDes
     @Override public JsonElement serialize(Object src, Type typeOfSrc) {
       return gson.toJsonTree(src, typeOfSrc);
     }
-    @SuppressWarnings("unchecked")
-    @Override public <R> R deserialize(JsonElement json, Type typeOfT) throws JsonParseException {
+    @Override
+    @SuppressWarnings({"unchecked", "TypeParameterUnusedInFormals"})
+    public <R> R deserialize(JsonElement json, Type typeOfT) throws JsonParseException {
       return gson.fromJson(json, typeOfT);
     }
   }

File: gson/src/main/java/com/google/gson/internal/sql/SqlDateTypeAdapter.java
Patch:
@@ -36,6 +36,7 @@
  * this class state. DateFormat isn't thread safe either, so this class has
  * to synchronize its read and write methods.
  */
+@SuppressWarnings("JavaUtilDate")
 final class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {
   static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
     @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal

File: gson/src/main/java/com/google/gson/internal/sql/SqlTimeTypeAdapter.java
Patch:
@@ -37,6 +37,7 @@
  * this class state. DateFormat isn't thread safe either, so this class has
  * to synchronize its read and write methods.
  */
+@SuppressWarnings("JavaUtilDate")
 final class SqlTimeTypeAdapter extends TypeAdapter<Time> {
   static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
     @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal

File: gson/src/main/java/com/google/gson/internal/sql/SqlTimestampTypeAdapter.java
Patch:
@@ -27,6 +27,7 @@
 import java.sql.Timestamp;
 import java.util.Date;
 
+@SuppressWarnings("JavaUtilDate")
 class SqlTimestampTypeAdapter extends TypeAdapter<Timestamp> {
   static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
     @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal

File: gson/src/main/java/com/google/gson/internal/sql/SqlTypesSupport.java
Patch:
@@ -33,6 +33,7 @@
  * it is {@code false} all other constants will be {@code null} and
  * there will be no support for {@code java.sql} types.
  */
+@SuppressWarnings("JavaUtilDate")
 public final class SqlTypesSupport {
   /**
    * {@code true} if {@code java.sql} types are supported,

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -1603,7 +1603,7 @@ private char readEscapeCharacter() throws IOException {
         throw syntaxError("Unterminated escape sequence");
       }
       // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);
-      char result = 0;
+      int result = 0;
       for (int i = pos, end = i + 4; i < end; i++) {
         char c = buffer[i];
         result <<= 4;
@@ -1618,7 +1618,7 @@ private char readEscapeCharacter() throws IOException {
         }
       }
       pos += 4;
-      return result;
+      return (char) result;
 
     case 't':
       return '\t';

File: gson/src/main/java/module-info.java
Patch:
@@ -24,6 +24,9 @@
   exports com.google.gson.reflect;
   exports com.google.gson.stream;
 
+  // Dependency on Error Prone Annotations
+  requires static com.google.errorprone.annotations;
+
   // Optional dependency on java.sql
   requires static java.sql;
 

File: gson/src/test/java/com/google/gson/CommentsTest.java
Patch:
@@ -23,6 +23,8 @@
 import org.junit.Test;
 
 /**
+ * Tests that by default Gson accepts several forms of comments.
+ *
  * @author Jesse Wilson
  */
 public final class CommentsTest {

File: gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java
Patch:
@@ -56,6 +56,7 @@ public void testIncludeStaticNestedClassField() throws Exception {
     assertThat(excluder.excludeField(f, true)).isFalse();
   }
 
+  @SuppressWarnings("ClassCanBeStatic")
   class InnerClass {
   }
 

File: gson/src/test/java/com/google/gson/JsonArrayTest.java
Patch:
@@ -26,6 +26,8 @@
 import org.junit.Test;
 
 /**
+ * Tests handling of JSON arrays.
+ *
  * @author Jesse Wilson
  */
 public final class JsonArrayTest {

File: gson/src/test/java/com/google/gson/JsonNullTest.java
Patch:
@@ -22,6 +22,8 @@
 import org.junit.Test;
 
 /**
+ * Tests handling of JSON nulls.
+ *
  * @author Jesse Wilson
  */
 public final class JsonNullTest {

File: gson/src/test/java/com/google/gson/ObjectTypeAdapterTest.java
Patch:
@@ -111,7 +111,7 @@ public void testDeserializeDeeplyNestedObjects() throws IOException {
     assertThat(actualTimes).isEqualTo(times);
   }
 
-  @SuppressWarnings("unused")
+  @SuppressWarnings({"unused", "ClassCanBeStatic"})
   private class RuntimeType {
     Object a = 5;
     Object b = Arrays.asList(1, 2, null);

File: gson/src/test/java/com/google/gson/OverrideCoreTypeAdaptersTest.java
Patch:
@@ -25,6 +25,8 @@
 import org.junit.Test;
 
 /**
+ * Tests handling of Core Type Adapters
+ *
  * @author Jesse Wilson
  */
 public class OverrideCoreTypeAdaptersTest {

File: gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java
Patch:
@@ -130,6 +130,7 @@ private static class MyBase {
     static final String TYPE_ACCESS = "__type__";
   }
 
+  @SuppressWarnings("ImmutableEnumChecker")
   private enum SubTypes {
     SUB_TYPE1(SubType1.class),
     SUB_TYPE2(SubType2.class);

File: gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
Patch:
@@ -68,6 +68,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
+@SuppressWarnings("JavaUtilDate")
 public class DefaultTypeAdaptersTest {
   private Gson gson;
   private TimeZone oldTimeZone;
@@ -700,6 +701,7 @@ public void testStringBuilderDeserialization() {
   }
 
   @Test
+  @SuppressWarnings("JdkObsolete")
   public void testStringBufferSerialization() {
     StringBuffer sb = new StringBuffer("abc");
     String json = gson.toJson(sb);

File: gson/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java
Patch:
@@ -56,7 +56,7 @@ public void testDelegateInvoked() {
       bags.add(new BagOfPrimitives(i, i, i % 2 == 0, String.valueOf(i)));
     }
     String json = gson.toJson(bags);
-    bags = gson.fromJson(json, new TypeToken<List<BagOfPrimitives>>(){}.getType());
+    gson.fromJson(json, new TypeToken<List<BagOfPrimitives>>(){}.getType());
     // 11: 1 list object, and 10 entries. stats invoked on all 5 fields
     assertThat(stats.numReads).isEqualTo(51);
     assertThat(stats.numWrites).isEqualTo(51);
@@ -66,7 +66,7 @@ public void testDelegateInvoked() {
   public void testDelegateInvokedOnStrings() {
     String[] bags = {"1", "2", "3", "4"};
     String json = gson.toJson(bags);
-    bags = gson.fromJson(json, String[].class);
+    gson.fromJson(json, String[].class);
     // 1 array object with 4 elements.
     assertThat(stats.numReads).isEqualTo(5);
     assertThat(stats.numWrites).isEqualTo(5);

File: gson/src/test/java/com/google/gson/functional/EscapingTest.java
Patch:
@@ -70,7 +70,7 @@ public void testEscapingObjectFields() {
     assertThat(jsonRepresentation).contains("\\\"");
 
     BagOfPrimitives expectedObject = gson.fromJson(jsonRepresentation, BagOfPrimitives.class);
-    assertThat(expectedObject.getExpectedJson()).isEqualTo(objWithPrimitives.getExpectedJson());
+    assertThat(objWithPrimitives.getExpectedJson()).isEqualTo(expectedObject.getExpectedJson());
   }
   
   @Test

File: gson/src/test/java/com/google/gson/functional/FieldExclusionTest.java
Patch:
@@ -75,6 +75,8 @@ public void testDefaultNestedStaticClassIncluded() {
   }
 
   private static class Outer {
+
+    @SuppressWarnings("ClassCanBeStatic")
     private class Inner extends NestedClass {
       public Inner(String value) {
         super(value);

File: gson/src/test/java/com/google/gson/functional/InheritanceTest.java
Patch:
@@ -162,6 +162,7 @@ public void appendFields(StringBuilder sb) {
   }
 
   @Test
+  @SuppressWarnings("JdkObsolete")
   public void testSubInterfacesOfCollectionSerialization() {
     List<Integer> list = new LinkedList<>();
     list.add(0);

File: gson/src/test/java/com/google/gson/functional/PrettyPrintingTest.java
Patch:
@@ -23,6 +23,7 @@
 import com.google.gson.common.TestTypes.BagOfPrimitives;
 import com.google.gson.reflect.TypeToken;
 import java.lang.reflect.Type;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.LinkedList;
@@ -51,7 +52,7 @@ public void setUp() throws Exception {
   @Test
   public void testPrettyPrintList() {
     BagOfPrimitives b = new BagOfPrimitives();
-    List<BagOfPrimitives> listOfB = new LinkedList<>();
+    List<BagOfPrimitives> listOfB = new ArrayList<>();
     for (int i = 0; i < 15; ++i) {
       listOfB.add(b);
     }

File: gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
Patch:
@@ -192,7 +192,7 @@ public void testFloatSerialization() {
     // Should perform widening conversion
     assertThat(gson.toJson((byte) 1, Float.class)).isEqualTo("1.0");
     // (This widening conversion is actually lossy)
-    assertThat(gson.toJson(Long.MAX_VALUE - 10L, Float.class)).isEqualTo(Float.toString(Long.MAX_VALUE - 10L));
+    assertThat(gson.toJson(Long.MAX_VALUE - 10L, Float.class)).isEqualTo(Float.toString((float) (Long.MAX_VALUE - 10L)));
     // Should perform narrowing conversion
     gson = new GsonBuilder().serializeSpecialFloatingPointValues().create();
     assertThat(gson.toJson(Double.MAX_VALUE, Float.class)).isEqualTo("Infinity");
@@ -207,7 +207,7 @@ public void testDoubleSerialization() {
     // Should perform widening conversion
     assertThat(gson.toJson((byte) 1, Double.class)).isEqualTo("1.0");
     // (This widening conversion is actually lossy)
-    assertThat(gson.toJson(Long.MAX_VALUE - 10L, Double.class)).isEqualTo(Double.toString(Long.MAX_VALUE - 10L));
+    assertThat(gson.toJson(Long.MAX_VALUE - 10L, Double.class)).isEqualTo(Double.toString((double) (Long.MAX_VALUE - 10L)));
   }
 
   @Test

File: gson/src/test/java/com/google/gson/functional/PrintFormattingTest.java
Patch:
@@ -78,6 +78,7 @@ public void testJsonObjectWithNullValuesSerialized() {
     assertThat(json).contains("field2");
   }
 
+  @SuppressWarnings("LoopOverCharArray")
   private static void assertContainsNoWhiteSpace(String str) {
     for (char c : str.toCharArray()) {
       assertThat(Character.isWhitespace(c)).isFalse();

File: gson/src/test/java/com/google/gson/functional/ReflectionAccessTest.java
Patch:
@@ -130,7 +130,7 @@ public void testSerializeInternalImplementationObject() {
       gson.fromJson("[]", internalClass);
       fail("Missing exception; test has to be run with `--illegal-access=deny`");
     } catch (JsonSyntaxException e) {
-      fail("Unexpected exception; test has to be run with `--illegal-access=deny`");
+      throw new AssertionError("Unexpected exception; test has to be run with `--illegal-access=deny`", e);
     } catch (JsonIOException expected) {
       assertThat(expected).hasMessageThat().startsWith("Failed making constructor 'java.util.Collections$EmptyList()' accessible;"
           + " either increase its visibility or write a custom InstanceCreator or TypeAdapter for its declaring type: ");

File: gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
Patch:
@@ -20,6 +20,7 @@
 import static com.google.common.truth.Truth.assertWithMessage;
 import static org.junit.Assert.fail;
 
+import com.google.common.base.Splitter;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonArray;
@@ -172,8 +173,8 @@ public void testDeserialize2dArray() throws IOException {
   public void testNullSafe() {
     TypeAdapter<Person> typeAdapter = new TypeAdapter<Person>() {
       @Override public Person read(JsonReader in) throws IOException {
-        String[] values = in.nextString().split(",");
-        return new Person(values[0], Integer.parseInt(values[1]));
+        List<String> values = Splitter.on(',').splitToList(in.nextString());
+        return new Person(values.get(0), Integer.parseInt(values.get(1)));
       }
       @Override public void write(JsonWriter out, Person person) throws IOException {
         out.value(person.name + "," + person.age);

File: gson/src/test/java/com/google/gson/functional/StringTest.java
Patch:
@@ -154,7 +154,7 @@ public void testAssignmentCharDeserialization() {
     String value = gson.fromJson(json, String.class);
     assertThat(value).isEqualTo("abc=");
 
-    json = "'abc\u003d'";
+    json = "'abc\\u003d'";
     value = gson.fromJson(json, String.class);
     assertThat(value).isEqualTo("abc=");
   }

File: gson/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java
Patch:
@@ -79,6 +79,7 @@ public void testDeserializeId() {
     assertThat(target.getId().getValue()).isEqualTo("1");
   }
 
+  @SuppressWarnings("UnusedTypeParameter")
   private static final class Id<R> {
     final String value;
     @SuppressWarnings("unused")

File: gson/src/test/java/com/google/gson/internal/bind/DefaultDateTypeAdapterTest.java
Patch:
@@ -39,6 +39,7 @@
  *
  * @author Joel Leitch
  */
+@SuppressWarnings("JavaUtilDate")
 public class DefaultDateTypeAdapterTest {
 
   @Test
@@ -226,6 +227,7 @@ private static void assertFormatted(String formatted, TypeAdapterFactory adapter
     assertThat(adapter.toJson(new Date(0))).isEqualTo(toLiteral(formatted));
   }
 
+  @SuppressWarnings("UndefinedEquals")
   private static void assertParsed(String date, TypeAdapterFactory adapterFactory) throws IOException {
     TypeAdapter<Date> adapter = dateAdapter(adapterFactory);
     assertWithMessage(date).that(adapter.fromJson(toLiteral(date))).isEqualTo(new Date(0));

File: gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
Patch:
@@ -29,6 +29,8 @@
 import org.junit.Test;
 
 /**
+ * Tests for {@link TypeToken}.
+ *
  * @author Jesse Wilson
  */
 public final class TypeTokenTest {

File: gson/src/test/java/com/google/gson/regression/OSGiTest.java
Patch:
@@ -18,6 +18,7 @@
 import static com.google.common.truth.Truth.assertWithMessage;
 import static org.junit.Assert.fail;
 
+import com.google.common.base.Splitter;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
@@ -41,7 +42,7 @@ public void testSunMiscImportPackage() throws Exception {
         Manifest mf = findManifest("com.google.gson");
         String importPkg = mf.getMainAttributes().getValue("Import-Package");
     assertWithMessage("Import-Package statement is there").that(importPkg).isNotNull();
-        for (String dep : importPkg.split(",")) {
+        for (String dep : Splitter.on(',').split(importPkg)) {
             if (dep.contains("sun.misc")) {
                 assertSubstring("sun.misc import is optional", dep, "resolution:=optional");
                 return;

File: metrics/src/main/java/com/google/gson/metrics/CollectionsDeserializationBenchmark.java
Patch:
@@ -64,6 +64,7 @@ public void timeCollectionsDefault(int reps) {
   /**
    * Benchmark to measure deserializing objects by hand
    */
+  @SuppressWarnings("ModifiedButNotUsed")
   public void timeCollectionsStreaming(int reps) throws IOException {
     for (int i=0; i<reps; ++i) {
       StringReader reader = new StringReader(json);
@@ -102,6 +103,7 @@ public void timeCollectionsStreaming(int reps) throws IOException {
    * setting object values by reflection. We should strive to reduce the discrepancy between this
    * and {@link #timeCollectionsDefault(int)} .
    */
+  @SuppressWarnings("ModifiedButNotUsed")
   public void timeCollectionsReflectionStreaming(int reps) throws Exception {
     for (int i=0; i<reps; ++i) {
       StringReader reader = new StringReader(json);

File: metrics/src/main/java/com/google/gson/metrics/ParseBenchmark.java
Patch:
@@ -38,7 +38,6 @@
 import java.io.InputStreamReader;
 import java.io.Reader;
 import java.io.StringWriter;
-import java.lang.reflect.Type;
 import java.net.URL;
 import java.nio.charset.StandardCharsets;
 import java.text.SimpleDateFormat;
@@ -64,7 +63,9 @@ private enum Document {
     READER_SHORT(new TypeToken<Feed>() {}, new TypeReference<Feed>() {}),
     READER_LONG(new TypeToken<Feed>() {}, new TypeReference<Feed>() {});
 
+    @SuppressWarnings("ImmutableEnumChecker")
     private final TypeToken<?> gsonType;
+    @SuppressWarnings("ImmutableEnumChecker")
     private final TypeReference<?> jacksonType;
 
     private Document(TypeToken<?> typeToken, TypeReference<?> typeReference) {

File: proto/src/test/java/com/google/gson/protobuf/functional/ProtosWithPrimitiveTypesTest.java
Patch:
@@ -57,7 +57,6 @@ public void testDeserializeEmptyProto() {
 
   @Test
   public void testSerializeProto() {
-    Descriptor descriptor = SimpleProto.getDescriptor();
     SimpleProto proto = SimpleProto.newBuilder()
       .setCount(3)
       .setMsg("foo")

File: gson/src/main/java/com/google/gson/JsonDeserializer.java
Patch:
@@ -89,7 +89,7 @@ public interface JsonDeserializer<T> {
    * @param json The Json data being deserialized
    * @param typeOfT The type of the Object to deserialize to
    * @return a deserialized object of the specified type typeOfT which is a subclass of {@code T}
-   * @throws JsonParseException if json is not in the expected format of {@code typeofT}
+   * @throws JsonParseException if json is not in the expected format of {@code typeOfT}
    */
   public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
       throws JsonParseException;

File: gson/src/main/java/com/google/gson/internal/ReflectionAccessFilterHelper.java
Patch:
@@ -98,6 +98,7 @@ private static abstract class AccessChecker {
             }
           };
         } catch (NoSuchMethodException ignored) {
+          // OK: will assume everything is accessible
         }
       }
 

File: gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
Patch:
@@ -64,6 +64,7 @@ public <T> T newInstance(Class<T> c) throws Exception {
         }
       };
     } catch (Exception ignored) {
+      // OK: try the next way
     }
 
     // try dalvikvm, post-gingerbread
@@ -88,6 +89,7 @@ public <T> T newInstance(Class<T> c) throws Exception {
         }
       };
     } catch (Exception ignored) {
+      // OK: try the next way
     }
 
     // try dalvikvm, pre-gingerbread
@@ -108,6 +110,7 @@ public <T> T newInstance(Class<T> c) throws Exception {
         }
       };
     } catch (Exception ignored) {
+      // OK: try the next way
     }
 
     // give up

File: gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
Patch:
@@ -81,7 +81,9 @@ private Date deserializeToDate(JsonReader in) throws IOException {
       for (DateFormat dateFormat : dateFormats) {
         try {
           return dateFormat.parse(s);
-        } catch (ParseException ignored) {}
+        } catch (ParseException ignored) {
+          // OK: try the next format
+        }
       }
     }
     try {

File: gson/src/main/java/com/google/gson/internal/bind/DefaultDateTypeAdapter.java
Patch:
@@ -154,7 +154,9 @@ private Date deserializeToDate(JsonReader in) throws IOException {
       for (DateFormat dateFormat : dateFormats) {
         try {
           return dateFormat.parse(s);
-        } catch (ParseException ignored) {}
+        } catch (ParseException ignored) {
+          // OK: try the next format
+        }
       }
     }
 

File: metrics/src/main/java/com/google/gson/metrics/ParseBenchmark.java
Patch:
@@ -40,6 +40,7 @@
 import java.io.StringWriter;
 import java.lang.reflect.Type;
 import java.net.URL;
+import java.nio.charset.StandardCharsets;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.List;
@@ -137,7 +138,7 @@ private static String resourceToString(String fileName) throws Exception {
     ZipFile zipFile = new ZipFile(getResourceFile("/ParseBenchmarkData.zip"));
     try {
       ZipEntry zipEntry = zipFile.getEntry(fileName);
-      Reader reader = new InputStreamReader(zipFile.getInputStream(zipEntry));
+      Reader reader = new InputStreamReader(zipFile.getInputStream(zipEntry), StandardCharsets.UTF_8);
       char[] buffer = new char[8192];
       StringWriter writer = new StringWriter();
       int count;

File: gson/src/test/java/com/google/gson/functional/MapTest.java
Patch:
@@ -301,7 +301,7 @@ public void testMapSubclassSerialization() {
   public void testMapStandardSubclassDeserialization() {
     String json = "{a:'1',b:'2'}";
     Type type = new TypeToken<LinkedHashMap<String, String>>() {}.getType();
-    LinkedHashMap<String, Integer> map = gson.fromJson(json, type);
+    LinkedHashMap<String, String> map = gson.fromJson(json, type);
     assertThat(map).containsEntry("a", "1");
     assertThat(map).containsEntry("b", "2");
   }

File: gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java
Patch:
@@ -161,7 +161,7 @@ public void testParameterizedTypeWithReaderDeserialization() {
         .create();
 
     Reader json = new StringReader(expected.getExpectedJson());
-    MyParameterizedType<Integer> actual = gson.fromJson(json, expectedType);
+    MyParameterizedType<BagOfPrimitives> actual = gson.fromJson(json, expectedType);
     assertThat(actual).isEqualTo(expected);
   }
 

File: extras/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java
Patch:
@@ -31,10 +31,10 @@
 import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
 import java.lang.reflect.Type;
+import java.util.ArrayDeque;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.IdentityHashMap;
-import java.util.LinkedList;
 import java.util.Map;
 import java.util.Queue;
 
@@ -79,6 +79,7 @@ public void registerOn(GsonBuilder gsonBuilder) {
 
   static class Factory implements TypeAdapterFactory, InstanceCreator<Object> {
     private final Map<Type, InstanceCreator<?>> instanceCreators;
+    @SuppressWarnings("ThreadLocalUsage")
     private final ThreadLocal<Graph> graphThreadLocal = new ThreadLocal<>();
 
     Factory(Map<Type, InstanceCreator<?>> instanceCreators) {
@@ -240,7 +241,7 @@ static class Graph {
      * The queue of elements to write during serialization. Unused during
      * deserialization.
      */
-    private final Queue<Element<?>> queue = new LinkedList<>();
+    private final Queue<Element<?>> queue = new ArrayDeque<>();
 
     /**
      * The instance currently being deserialized. Used as a backdoor between

File: extras/src/main/java/com/google/gson/interceptors/InterceptorFactory.java
Patch:
@@ -46,7 +46,7 @@ static class InterceptorAdapter<T> extends TypeAdapter<T> {
     public InterceptorAdapter(TypeAdapter<T> delegate, Intercept intercept) {
       try {
         this.delegate = delegate;
-        this.postDeserializer = intercept.postDeserialize().newInstance();
+        this.postDeserializer = intercept.postDeserialize().getDeclaredConstructor().newInstance();
       } catch (Exception e) {
         throw new RuntimeException(e);
       }

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -166,6 +166,7 @@ public final class Gson {
    * with the type token provided to {@code getAdapter} as key and either
    * {@code FutureTypeAdapter} or a regular {@code TypeAdapter} as value.
    */
+  @SuppressWarnings("ThreadLocalUsage")
   private final ThreadLocal<Map<TypeToken<?>, TypeAdapter<?>>> threadLocalAdapterResults = new ThreadLocal<>();
 
   private final ConcurrentMap<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<>();

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -19,11 +19,11 @@
 import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;
 import static com.google.gson.Gson.DEFAULT_DATE_PATTERN;
 import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;
+import static com.google.gson.Gson.DEFAULT_FORMATTING_STYLE;
 import static com.google.gson.Gson.DEFAULT_JSON_NON_EXECUTABLE;
 import static com.google.gson.Gson.DEFAULT_LENIENT;
 import static com.google.gson.Gson.DEFAULT_NUMBER_TO_NUMBER_STRATEGY;
 import static com.google.gson.Gson.DEFAULT_OBJECT_TO_NUMBER_STRATEGY;
-import static com.google.gson.Gson.DEFAULT_FORMATTING_STYLE;
 import static com.google.gson.Gson.DEFAULT_SERIALIZE_NULLS;
 import static com.google.gson.Gson.DEFAULT_SPECIALIZE_FLOAT_VALUES;
 import static com.google.gson.Gson.DEFAULT_USE_JDK_UNSAFE;
@@ -41,11 +41,11 @@
 import com.google.gson.stream.JsonWriter;
 import java.lang.reflect.Type;
 import java.text.DateFormat;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
@@ -104,7 +104,7 @@ public final class GsonBuilder {
   private boolean useJdkUnsafe = DEFAULT_USE_JDK_UNSAFE;
   private ToNumberStrategy objectToNumberStrategy = DEFAULT_OBJECT_TO_NUMBER_STRATEGY;
   private ToNumberStrategy numberToNumberStrategy = DEFAULT_NUMBER_TO_NUMBER_STRATEGY;
-  private final LinkedList<ReflectionAccessFilter> reflectionFilters = new LinkedList<>();
+  private final ArrayDeque<ReflectionAccessFilter> reflectionFilters = new ArrayDeque<>();
 
   /**
    * Creates a GsonBuilder instance that can be used to build Gson with various configuration

File: gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
Patch:
@@ -342,8 +342,8 @@ private static <T> ObjectConstructor<T> newDefaultImplementationConstructor(
             return (T) new TreeMap<>();
           }
         };
-      } else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(
-          TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {
+      } else if (type instanceof ParameterizedType && !String.class.isAssignableFrom(
+          TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType())) {
         return new ObjectConstructor<T>() {
           @Override public T construct() {
             return (T) new LinkedHashMap<>();

File: gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java
Patch:
@@ -98,7 +98,7 @@ public boolean equals(Object obj) {
     }
     if (obj instanceof LazilyParsedNumber) {
       LazilyParsedNumber other = (LazilyParsedNumber) obj;
-      return value == other.value || value.equals(other.value);
+      return value.equals(other.value);
     }
     return false;
   }

File: gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
Patch:
@@ -37,7 +37,7 @@ public final class ArrayTypeAdapter<E> extends TypeAdapter<Object> {
   public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
     @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
       Type type = typeToken.getType();
-      if (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {
+      if (!(type instanceof GenericArrayType || (type instanceof Class && ((Class<?>) type).isArray()))) {
         return null;
       }
 

File: gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
Patch:
@@ -158,7 +158,7 @@ private static final class SingleTypeFactory implements TypeAdapterFactory {
     @Override
     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       boolean matches = exactType != null
-          ? exactType.equals(type) || matchRawType && exactType.getType() == type.getRawType()
+          ? exactType.equals(type) || (matchRawType && exactType.getType() == type.getRawType())
           : hierarchyType.isAssignableFrom(type.getRawType());
       return matches
           ? new TreeTypeAdapter<>((JsonSerializer<T>) serializer,

File: gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
Patch:
@@ -123,7 +123,7 @@ public Class read(JsonReader in) throws IOException {
     @Override public void write(JsonWriter out, BitSet src) throws IOException {
       out.beginArray();
       for (int i = 0, length = src.length(); i < length; i++) {
-        int value = (src.get(i)) ? 1 : 0;
+        int value = src.get(i) ? 1 : 0;
         out.value(value);
       }
       out.endArray();
@@ -883,7 +883,7 @@ public EnumTypeAdapter(final Class<T> classOfT) {
         });
         for (Field constantField : constantFields) {
           @SuppressWarnings("unchecked")
-          T constant = (T)(constantField.get(null));
+          T constant = (T) constantField.get(null);
           String name = constant.name();
           String toStringVal = constant.toString();
 

File: gson/src/main/java/com/google/gson/stream/JsonWriter.java
Patch:
@@ -637,7 +637,7 @@ public JsonWriter value(Number value) throws IOException {
     out.close();
 
     int size = stackSize;
-    if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {
+    if (size > 1 || (size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT)) {
       throw new IOException("Incomplete document");
     }
     stackSize = 0;

File: gson/src/test/java/com/google/gson/JsonArrayTest.java
Patch:
@@ -20,6 +20,7 @@
 import static com.google.common.truth.Truth.assertWithMessage;
 import static org.junit.Assert.fail;
 
+import com.google.common.testing.EqualsTester;
 import com.google.gson.common.MoreAsserts;
 import java.math.BigInteger;
 import org.junit.Test;
@@ -35,12 +36,11 @@ public void testEqualsOnEmptyArray() {
   }
 
   @Test
-  @SuppressWarnings("TruthSelfEquals")
   public void testEqualsNonEmptyArray() {
     JsonArray a = new JsonArray();
     JsonArray b = new JsonArray();
 
-    assertThat(a).isEqualTo(a);
+    new EqualsTester().addEqualityGroup(a).testEquals();
 
     a.add(new JsonObject());
     assertThat(a.equals(b)).isFalse();

File: gson/src/test/java/com/google/gson/JsonObjectTest.java
Patch:
@@ -19,6 +19,7 @@
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
+import com.google.common.testing.EqualsTester;
 import com.google.gson.common.MoreAsserts;
 import java.util.AbstractMap.SimpleEntry;
 import java.util.ArrayDeque;
@@ -163,12 +164,11 @@ public void testEqualsOnEmptyObject() {
   }
 
   @Test
-  @SuppressWarnings("TruthSelfEquals")
   public void testEqualsNonEmptyObject() {
     JsonObject a = new JsonObject();
     JsonObject b = new JsonObject();
 
-    assertThat(a).isEqualTo(a);
+    new EqualsTester().addEqualityGroup(a).testEquals();
 
     a.add("foo", new JsonObject());
     assertThat(a.equals(b)).isFalse();

File: gson/src/main/java/com/google/gson/JsonPrimitive.java
Patch:
@@ -106,7 +106,7 @@ public boolean getAsBoolean() {
     if (isBoolean()) {
       return (Boolean) value;
     }
-	// Check to see if the value as a String is "true" in any case.
+    // Check to see if the value as a String is "true" in any case.
     return Boolean.parseBoolean(getAsString());
   }
 

File: extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
Patch:
@@ -57,8 +57,8 @@ public void testList() {
         assertEquals(sandwiches, sandwichesFromJson);
     }
 
-    @SuppressWarnings("overrides") // for missing hashCode() override
-    static class Sandwich {
+  @SuppressWarnings({"overrides", "EqualsHashCode"}) // for missing hashCode() override
+  static class Sandwich {
         public String bread;
         public String cheese;
 
@@ -92,7 +92,7 @@ public boolean equals(Object o) {
         }
     }
 
-    @SuppressWarnings("overrides") // for missing hashCode() override
+    @SuppressWarnings({"overrides", "EqualsHashCode"}) // for missing hashCode() override
     static class MultipleSandwiches {
         public List<Sandwich> sandwiches;
 

File: gson/src/test/java/com/google/gson/JsonArrayTest.java
Patch:
@@ -35,6 +35,7 @@ public void testEqualsOnEmptyArray() {
   }
 
   @Test
+  @SuppressWarnings("TruthSelfEquals")
   public void testEqualsNonEmptyArray() {
     JsonArray a = new JsonArray();
     JsonArray b = new JsonArray();

File: gson/src/test/java/com/google/gson/JsonObjectTest.java
Patch:
@@ -163,6 +163,7 @@ public void testEqualsOnEmptyObject() {
   }
 
   @Test
+  @SuppressWarnings("TruthSelfEquals")
   public void testEqualsNonEmptyObject() {
     JsonObject a = new JsonObject();
     JsonObject b = new JsonObject();

File: gson/src/test/java/com/google/gson/common/TestTypes.java
Patch:
@@ -227,7 +227,8 @@ public String getExpectedJson() {
     }
   }
 
-  @SuppressWarnings("overrides") // for missing hashCode() override
+  // for missing hashCode() override
+  @SuppressWarnings({"overrides", "EqualsHashCode"})
   public static class ClassWithNoFields {
     // Nothing here..
     @Override

File: gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
Patch:
@@ -103,7 +103,7 @@ public void testClassSerialization() {
   @Test
   public void testClassDeserialization() {
     try {
-      gson.fromJson("String.class", String.class.getClass());
+      gson.fromJson("String.class", Class.class);
       fail();
     } catch (UnsupportedOperationException expected) {
     }

File: gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
Patch:
@@ -122,11 +122,11 @@ class SubTreeSet<T> extends TreeSet<T> {}
 
     Type sortedSetType = new TypeToken<SortedSet<String>>() {}.getType();
     SortedSet<String> set = gson.fromJson("[\"a\"]", sortedSetType);
-    assertThat("a").isEqualTo(set.first());
+    assertThat(set.first()).isEqualTo("a");
     assertThat(set.getClass()).isEqualTo(SubTreeSet.class);
 
     set = gson.fromJson("[\"b\"]", SortedSet.class);
-    assertThat("b").isEqualTo(set.first());
+    assertThat(set.first()).isEqualTo("b");
     assertThat(set.getClass()).isEqualTo(SubTreeSet.class);
   }
 }

File: gson/src/test/java/com/google/gson/functional/ReflectionAccessFilterTest.java
Patch:
@@ -18,7 +18,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeNotNull;;
+import static org.junit.Assume.assumeNotNull;
 
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;

File: gson/src/test/java/com/google/gson/functional/TypeVariableTest.java
Patch:
@@ -73,7 +73,8 @@ public void testBasicTypeVariables() {
     assertThat(blue2).isEqualTo(blue1);
   }
 
-  @SuppressWarnings("overrides") // for missing hashCode() override
+  // for missing hashCode() override
+  @SuppressWarnings({"overrides", "EqualsHashCode"})
   public static class Blue extends Red<Boolean> {
     public Blue() {
       super(false);
@@ -103,7 +104,7 @@ public Red(S redField) {
     }
   }
 
-  @SuppressWarnings("overrides") // for missing hashCode() override
+  @SuppressWarnings({"overrides", "EqualsHashCode"}) // for missing hashCode() override
   public static class Foo<S, T> extends Red<Boolean> {
     private S someSField;
     private T someTField;

File: gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
Patch:
@@ -1698,7 +1698,8 @@ public void testDeeplyNestedObjects() throws IOException {
       reader.beginObject();
       assertThat(reader.nextName()).isEqualTo("a");
     }
-    assertThat(reader.getPath());
+    assertThat(reader.getPath()).isEqualTo("$.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a"
+        + ".a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a");
     assertThat(reader.nextBoolean()).isTrue();
     for (int i = 0; i < 40; i++) {
       reader.endObject();

File: gson/src/test/java/com/google/gson/JsonArrayAsListTest.java
Patch:
@@ -202,9 +202,9 @@ public void testContains() {
     a.add(1);
 
     List<JsonElement> list = a.asList();
-    assertThat(list.contains(new JsonPrimitive(1))).isTrue();
-    assertThat(list.contains(new JsonPrimitive(2))).isFalse();
-    assertThat(list.contains(null)).isFalse();
+    assertThat(list).contains(new JsonPrimitive(1));
+    assertThat(list).doesNotContain(new JsonPrimitive(2));
+    assertThat(list).doesNotContain(null);
 
     @SuppressWarnings({"unlikely-arg-type", "CollectionIncompatibleType"})
     boolean containsInt = list.contains(1); // should only contain JsonPrimitive(1)

File: gson/src/test/java/com/google/gson/JsonArrayTest.java
Patch:
@@ -67,12 +67,12 @@ public void testRemove() {
     JsonPrimitive a = new JsonPrimitive("a");
     array.add(a);
     assertThat(array.remove(a)).isTrue();
-    assertThat(array.contains(a)).isFalse();
+    assertThat(array).doesNotContain(a);
     array.add(a);
     array.add(new JsonPrimitive("b"));
     assertThat(array.remove(1).getAsString()).isEqualTo("b");
     assertThat(array).hasSize(1);
-    assertThat(array.contains(a)).isTrue();
+    assertThat(array).contains(a);
   }
 
   @Test

File: gson/src/test/java/com/google/gson/JsonObjectTest.java
Patch:
@@ -255,8 +255,7 @@ public void testKeySet() {
 
     assertThat(a.size()).isEqualTo(2);
     assertThat(a.keySet()).hasSize(2);
-    assertThat(a.keySet().contains("foo")).isTrue();
-    assertThat(a.keySet().contains("bar")).isTrue();
+    assertThat(a.keySet()).containsExactly("foo", "bar").inOrder();
 
     a.addProperty("1", true);
     a.addProperty("2", false);

File: gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.google.gson.functional;
 
-import static org.junit.Assert.assertFalse;
+import static com.google.common.truth.Truth.assertThat;
 
 import com.google.gson.Gson;
 import java.util.concurrent.CountDownLatch;
@@ -91,7 +91,7 @@ public void testMultiThreadSerialization() throws InterruptedException {
     }
     startLatch.countDown();
     finishedLatch.await();
-    assertFalse(failed.get());
+    assertThat(failed.get()).isFalse();
   }
 
   /**
@@ -122,7 +122,7 @@ public void testMultiThreadDeserialization() throws InterruptedException {
     }
     startLatch.countDown();
     finishedLatch.await();
-    assertFalse(failed.get());
+    assertThat(failed.get()).isFalse();
   }
   
   @SuppressWarnings("unused")

File: gson/src/test/java/com/google/gson/functional/EnumWithObfuscatedTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson.functional;
 
-import static org.junit.Assert.assertEquals;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
 import com.google.gson.Gson;
@@ -55,7 +55,7 @@ public void testEnumClassWithObfuscated() {
       }
     }
 
-    assertEquals(Gender.MALE, gson.fromJson("\"MAIL\"", Gender.class));
-    assertEquals("\"MAIL\"", gson.toJson(Gender.MALE, Gender.class));
+    assertThat(gson.fromJson("\"MAIL\"", Gender.class)).isEqualTo(Gender.MALE);
+    assertThat(gson.toJson(Gender.MALE, Gender.class)).isEqualTo("\"MAIL\"");
   }
 }

File: gson/src/test/java/com/google/gson/functional/LeniencyTest.java
Patch:
@@ -15,8 +15,8 @@
  */
 package com.google.gson.functional;
 
+import static com.google.common.truth.Truth.assertThat;
 import static java.util.Collections.singletonList;
-import static org.junit.Assert.assertEquals;
 
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
@@ -43,6 +43,6 @@ public void testLenientFromJson() {
         + "[ # One!\n"
         + "  'Hi' #Element!\n"
         + "] # Array!", new TypeToken<List<String>>() {}.getType());
-    assertEquals(singletonList("Hi"), json);
+    assertThat(json).isEqualTo(singletonList("Hi"));
   }
 }

File: gson/src/test/java/com/google/gson/internal/GsonBuildConfigTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.google.gson.internal;
 
-import static org.junit.Assert.assertFalse;
+import static com.google.common.truth.Truth.assertThat;
 
 import org.junit.Test;
 
@@ -28,6 +28,6 @@ public class GsonBuildConfigTest {
 
   @Test
   public void testEnsureGsonBuildConfigGetsUpdatedToMavenVersion() {
-    assertFalse("${project.version}".equals(GsonBuildConfig.VERSION));
+    assertThat("${project.version}").isNotEqualTo(GsonBuildConfig.VERSION);
   }
 }

File: gson/src/test/java/com/google/gson/internal/StreamsTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.google.gson.internal;
 
-import static org.junit.Assert.assertEquals;
+import static com.google.common.truth.Truth.assertThat;
 import static org.junit.Assert.fail;
 
 import java.io.IOException;
@@ -57,12 +57,12 @@ public void testWriterForAppendable() throws IOException {
     }
 
     String actualOutput = stringBuilder.toString();
-    assertEquals("a\u1234testnullcdul,a\u1234\u1234,charsha,stringtr", actualOutput);
+    assertThat(actualOutput).isEqualTo("a\u1234testnullcdul,a\u1234\u1234,charsha,stringtr");
 
     writer.flush();
     writer.close();
 
     // flush() and close() calls should have had no effect
-    assertEquals(actualOutput, stringBuilder.toString());
+    assertThat(stringBuilder.toString()).isEqualTo(actualOutput);
   }
 }

File: gson/src/test/java/com/google/gson/regression/OSGiTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.google.gson.regression;
 
-import static org.junit.Assert.assertNotNull;
+import static com.google.common.truth.Truth.assertWithMessage;
 import static org.junit.Assert.fail;
 
 import java.io.IOException;
@@ -32,15 +32,15 @@ public class OSGiTest {
   public void testComGoogleGsonAnnotationsPackage() throws Exception {
         Manifest mf = findManifest("com.google.gson");
         String importPkg = mf.getMainAttributes().getValue("Import-Package");
-        assertNotNull("Import-Package statement is there", importPkg);
+        assertWithMessage("Import-Package statement is there").that(importPkg).isNotNull();
         assertSubstring("There should be com.google.gson.annotations dependency", importPkg, "com.google.gson.annotations");
     }
 
   @Test
   public void testSunMiscImportPackage() throws Exception {
         Manifest mf = findManifest("com.google.gson");
         String importPkg = mf.getMainAttributes().getValue("Import-Package");
-        assertNotNull("Import-Package statement is there", importPkg);
+    assertWithMessage("Import-Package statement is there").that(importPkg).isNotNull();
         for (String dep : importPkg.split(",")) {
             if (dep.contains("sun.misc")) {
                 assertSubstring("sun.misc import is optional", dep, "resolution:=optional");

File: gson/src/test/java/com/google/gson/CommentsTest.java
Patch:
@@ -16,10 +16,9 @@
 
 package com.google.gson;
 
-import static org.junit.Assert.assertEquals;
+import static com.google.common.truth.Truth.assertThat;
 
 import com.google.gson.reflect.TypeToken;
-import java.util.Arrays;
 import java.util.List;
 import org.junit.Test;
 
@@ -43,6 +42,6 @@ public void testParseComments() {
         + "]";
 
     List<String> abc = new Gson().fromJson(json, new TypeToken<List<String>>() {}.getType());
-    assertEquals(Arrays.asList("a", "b", "c"), abc);
+    assertThat(abc).containsExactly("a", "b", "c").inOrder();
   }
 }

File: gson/src/test/java/com/google/gson/JsonNullTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import static org.junit.Assert.assertSame;
+import static com.google.common.truth.Truth.assertThat;
 
 import com.google.gson.common.MoreAsserts;
 import org.junit.Test;
@@ -38,7 +38,7 @@ public void testEqualsAndHashcode() {
   public void testDeepCopy() {
     @SuppressWarnings("deprecation")
     JsonNull a = new JsonNull();
-    assertSame(JsonNull.INSTANCE, a.deepCopy());
-    assertSame(JsonNull.INSTANCE, JsonNull.INSTANCE.deepCopy());
+    assertThat(a.deepCopy()).isSameInstanceAs(JsonNull.INSTANCE);
+    assertThat(JsonNull.INSTANCE.deepCopy()).isSameInstanceAs(JsonNull.INSTANCE);
   }
 }

File: gson/src/test/java/com/google/gson/ObjectTypeAdapterParameterizedTest.java
Patch:
@@ -1,6 +1,6 @@
 package com.google.gson;
 
-import static org.junit.Assert.assertEquals;
+import static com.google.common.truth.Truth.assertThat;
 
 import java.io.IOException;
 import java.util.Arrays;
@@ -36,6 +36,6 @@ public void testReadWrite() throws IOException {
     String actualSerialized = adapter.toJson(deserialized);
 
     // Serialized Object should be the same as original JSON
-    assertEquals(json, actualSerialized);
+    assertThat(actualSerialized).isEqualTo(json);
   }
 }

File: extras/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java
Patch:
@@ -298,7 +298,7 @@ void write(JsonWriter out) throws IOException {
     }
 
     @SuppressWarnings("unchecked")
-    void read(Graph graph) throws IOException {
+    void read(Graph graph) {
       if (graph.nextCreate != null) {
         throw new IllegalStateException("Unexpected recursive call to read() for " + id);
       }

File: gson/src/main/java/com/google/gson/internal/$Gson$Types.java
Patch:
@@ -34,6 +34,7 @@
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.Properties;
+import java.util.Objects;
 
 /**
  * Static methods for working with types.
@@ -167,7 +168,7 @@ public static Class<?> getRawType(Type type) {
   }
 
   private static boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
+    return Objects.equals(a, b);
   }
 
   /**

File: gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java
Patch:
@@ -30,6 +30,7 @@
 import java.util.LinkedHashMap;
 import java.util.NoSuchElementException;
 import java.util.Set;
+import java.util.Objects;
 
 /**
  * A map of comparable keys to values. Unlike {@code TreeMap}, this class uses
@@ -227,7 +228,7 @@ Node<K, V> findByEntry(Entry<?, ?> entry) {
   }
 
   private boolean equal(Object a, Object b) {
-    return a == b || (a != null && a.equals(b));
+    return Objects.equals(a, b);
   }
 
   /**

File: gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
Patch:
@@ -38,10 +38,10 @@
  */
 public final class JsonTreeReader extends JsonReader {
   private static final Reader UNREADABLE_READER = new Reader() {
-    @Override public int read(char[] buffer, int offset, int count) throws IOException {
+    @Override public int read(char[] buffer, int offset, int count) {
       throw new AssertionError();
     }
-    @Override public void close() throws IOException {
+    @Override public void close() {
       throw new AssertionError();
     }
   };

File: gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java
Patch:
@@ -36,10 +36,10 @@ public final class JsonTreeWriter extends JsonWriter {
     @Override public void write(char[] buffer, int offset, int counter) {
       throw new AssertionError();
     }
-    @Override public void flush() throws IOException {
+    @Override public void flush() {
       throw new AssertionError();
     }
-    @Override public void close() throws IOException {
+    @Override public void close() {
       throw new AssertionError();
     }
   };

File: gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
Patch:
@@ -176,7 +176,7 @@ private final class GsonContextImpl implements JsonSerializationContext, JsonDes
     }
     @SuppressWarnings("unchecked")
     @Override public <R> R deserialize(JsonElement json, Type typeOfT) throws JsonParseException {
-      return (R) gson.fromJson(json, typeOfT);
+      return gson.fromJson(json, typeOfT);
     }
   }
 }

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -737,7 +737,9 @@ private int peekNumber() throws IOException {
     }
 
     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.
-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {
+    // Don't store -0 as long; user might want to read it as double -0.0
+    // Don't try to convert Long.MIN_VALUE to positive long; it would overflow MAX_VALUE
+    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || !negative)) {
       peekedLong = negative ? value : -value;
       pos += i;
       return peeked = PEEKED_LONG;

File: gson/src/main/java/com/google/gson/JsonDeserializer.java
Patch:
@@ -83,7 +83,7 @@ public interface JsonDeserializer<T> {
    * <p>In the implementation of this call-back method, you should consider invoking
    * {@link JsonDeserializationContext#deserialize(JsonElement, Type)} method to create objects
    * for any non-trivial field of the returned object. However, you should never invoke it on the
-   * the same type passing {@code json} since that will cause an infinite loop (Gson will call your
+   * same type passing {@code json} since that will cause an infinite loop (Gson will call your
    * call-back method again).
    *
    * @param json The Json data being deserialized

File: gson/src/main/java/com/google/gson/JsonDeserializer.java
Patch:
@@ -63,6 +63,9 @@
  * Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdDeserializer()).create();
  * </pre>
  *
+ * <p>Deserializers should be stateless and thread-safe, otherwise the thread-safety
+ * guarantees of {@link Gson} might not apply.
+ *
  * <p>New applications should prefer {@link TypeAdapter}, whose streaming API
  * is more efficient than this interface's tree API.
  *

File: gson/src/main/java/com/google/gson/JsonSerializer.java
Patch:
@@ -60,6 +60,9 @@
  * Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdSerializer()).create();
  * </pre>
  *
+ * <p>Serializers should be stateless and thread-safe, otherwise the thread-safety
+ * guarantees of {@link Gson} might not apply.
+ *
  * <p>New applications should prefer {@link TypeAdapter}, whose streaming API
  * is more efficient than this interface's tree API.
  *

File: gson/src/main/java/com/google/gson/TypeAdapter.java
Patch:
@@ -81,6 +81,9 @@
  * when writing to a JSON object) will be omitted automatically. In either case
  * your type adapter must handle null.
  *
+ * <p>Type adapters should be stateless and thread-safe, otherwise the thread-safety
+ * guarantees of {@link Gson} might not apply.
+ *
  * <p>To use a custom type adapter with Gson, you must <i>register</i> it with a
  * {@link GsonBuilder}: <pre>   {@code
  *

File: gson/src/test/java/com/google/gson/functional/GsonVersionDiagnosticsTest.java
Patch:
@@ -35,7 +35,9 @@
  * @author Inderjeet Singh
  */
 public class GsonVersionDiagnosticsTest extends TestCase {
-  private static final Pattern GSON_VERSION_PATTERN = Pattern.compile("(\\(GSON \\d\\.\\d+(\\.\\d)?)(?:[-.][A-Z]+)?\\)$");
+  // We require a patch number, even if it is .0, consistent with https://semver.org/#spec-item-2.
+  private static final Pattern GSON_VERSION_PATTERN =
+      Pattern.compile("(\\(GSON \\d\\.\\d+\\.\\d)(?:[-.][A-Z]+)?\\)$");
 
   private Gson gson;
 

File: gson/src/test/java/com/google/gson/metrics/PerformanceTest.java
Patch:
@@ -162,7 +162,7 @@ public void disabled_testByteArraySerialization() {
    * Created in response to http://code.google.com/p/google-gson/issues/detail?id=96
    */
   // Last I tested, Gson was able to deserialize a byte array of 11MB
-  public void disable_testByteArrayDeserialization() {
+  public void disabled_testByteArrayDeserialization() {
     for (int numElements = 10639296; true; numElements += 16384) {
       StringBuilder sb = new StringBuilder(numElements*2);
       sb.append("[");
@@ -218,7 +218,7 @@ public void disabled_testDeserializeClasses() {
     System.out.printf("Deserialize classes avg time: %d ms\n", avg);
   }
   
-  public void disable_testLargeObjectSerializationAndDeserialization() {
+  public void disabled_testLargeObjectSerializationAndDeserialization() {
     Map<String, Long> largeObject = new HashMap<>();
     for (long l = 0; l < 100000; l++) {
       largeObject.put("field" + l, l);
@@ -343,4 +343,4 @@ private static final class ClassWithExposedField {
       this.field = field; 
     } 
   }
-}
\ No newline at end of file
+}

File: gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
Patch:
@@ -277,7 +277,7 @@ JsonElement nextJsonElement() throws IOException {
     JsonToken peeked = peek();
     switch (peeked) {
       case NAME:
-        nextName(true);
+        String unused = nextName(true);
         break;
       case END_ARRAY:
         endArray();

File: gson/src/test/java/com/google/gson/JsonArrayAsListTest.java
Patch:
@@ -210,7 +210,7 @@ public void testContains() {
     assertFalse(list.contains(new JsonPrimitive(2)));
     assertFalse(list.contains(null));
 
-    @SuppressWarnings("unlikely-arg-type")
+    @SuppressWarnings({"unlikely-arg-type", "CollectionIncompatibleType"})
     boolean containsInt = list.contains(1); // should only contain JsonPrimitive(1)
     assertFalse(containsInt);
   }
@@ -227,7 +227,7 @@ public void testIndexOf() {
     assertEquals(-1, list.indexOf(new JsonPrimitive(2)));
     assertEquals(-1, list.indexOf(null));
 
-    @SuppressWarnings("unlikely-arg-type")
+    @SuppressWarnings({"unlikely-arg-type", "CollectionIncompatibleType"})
     int indexOfInt = list.indexOf(1); // should only contain JsonPrimitive(1)
     assertEquals(-1, indexOfInt);
 

File: gson/src/test/java/com/google/gson/JsonObjectAsMapTest.java
Patch:
@@ -59,7 +59,7 @@ public void testContainsValue() {
     assertFalse(map.containsValue(new JsonPrimitive(2)));
     assertFalse(map.containsValue(null));
 
-    @SuppressWarnings("unlikely-arg-type")
+    @SuppressWarnings({"unlikely-arg-type", "CollectionIncompatibleType"})
     boolean containsInt = map.containsValue(1); // should only contain JsonPrimitive(1)
     assertFalse(containsInt);
   }

File: gson/src/test/java/com/google/gson/functional/ReflectionAccessTest.java
Patch:
@@ -119,8 +119,8 @@ public void testSerializeInternalImplementationObject() {
       fail("Unexpected exception; test has to be run with `--illegal-access=deny`");
     } catch (JsonIOException expected) {
       assertTrue(expected.getMessage().startsWith(
-          "Failed making constructor 'java.util.Collections$EmptyList#EmptyList()' accessible; "
-          + "either change its visibility or write a custom InstanceCreator or TypeAdapter for its declaring type"
+          "Failed making constructor 'java.util.Collections$EmptyList()' accessible;"
+          + " either increase its visibility or write a custom InstanceCreator or TypeAdapter for its declaring type: "
       ));
     }
   }

File: gson/src/test/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactoryTest.java
Patch:
@@ -1,6 +1,7 @@
 package com.google.gson.internal.bind;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
 
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -252,7 +252,7 @@ public GsonBuilder serializeNulls() {
    * <p>For this case, assume that a type adapter was NOT registered for some
    * {@code Point} class, but rather the default Gson serialization is applied.
    * In this case, some {@code new Point(2,3)} would serialize as {@code
-   * {"x":2,"y":5}}.
+   * {"x":2,"y":3}}.
    *
    * <p>Given the assumption above, a {@code Map<Point, String>} will be
    * serialize as an array of arrays (can be viewed as an entry set of pairs).

File: gson/src/test/java/com/google/gson/functional/ReflectionAccessTest.java
Patch:
@@ -37,6 +37,7 @@ private static Class<?> loadClassWithDifferentClassLoader(Class<?> c) throws Exc
   }
 
   @Test
+  @SuppressWarnings("removal") // java.lang.SecurityManager
   public void testRestrictiveSecurityManager() throws Exception {
     // Must use separate class loader, otherwise permission is not checked, see Class.getDeclaredFields()
     Class<?> clazz = loadClassWithDifferentClassLoader(ClassWithPrivateMembers.class);

File: gson/src/main/java/com/google/gson/TypeAdapter.java
Patch:
@@ -96,7 +96,7 @@
  */
 // non-Javadoc:
 //
-// <h3>JSON Conversion</h3>
+// <h2>JSON Conversion</h2>
 // <p>A type adapter registered with Gson is automatically invoked while serializing
 // or deserializing JSON. However, you can also use type adapters directly to serialize
 // and deserialize JSON. Here is an example for deserialization: <pre>   {@code

File: gson/src/main/java/com/google/gson/TypeAdapterFactory.java
Patch:
@@ -22,7 +22,8 @@
  * Creates type adapters for set of related types. Type adapter factories are
  * most useful when several types share similar structure in their JSON form.
  *
- * <h2>Example: Converting enums to lowercase</h2>
+ * <h2>Examples</h2>
+ * <h3>Example: Converting enums to lowercase</h3>
  * In this example, we implement a factory that creates type adapters for all
  * enums. The type adapters will write enums in lowercase, despite the fact
  * that they're defined in {@code CONSTANT_CASE} in the corresponding Java
@@ -90,7 +91,7 @@
  * If multiple factories support the same type, the factory registered earlier
  * takes precedence.
  *
- * <h3>Example: composing other type adapters</h3>
+ * <h3>Example: Composing other type adapters</h3>
  * In this example we implement a factory for Guava's {@code Multiset}
  * collection type. The factory can be used to create type adapters for
  * multisets of any element type: the type adapter for {@code

File: gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
Patch:
@@ -40,7 +40,7 @@
 /**
  * Adapts maps to either JSON objects or JSON arrays.
  *
- * <h3>Maps as JSON objects</h3>
+ * <h2>Maps as JSON objects</h2>
  * For primitive keys or when complex map key serialization is not enabled, this
  * converts Java {@link Map Maps} to JSON Objects. This requires that map keys
  * can be serialized as strings; this is insufficient for some key types. For
@@ -65,7 +65,7 @@
  *   at com.google.gson.ObjectNavigator.navigateClassFields
  *   ...</pre>
  *
- * <h3>Maps as JSON arrays</h3>
+ * <h2>Maps as JSON arrays</h2>
  * An alternative approach taken by this type adapter when it is required and
  * complex map key serialization is enabled is to encode maps as arrays of map
  * entries. Each map entry is a two element array containing a key and a value.

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -62,7 +62,7 @@
  * Null literals can be consumed using either {@link #nextNull()} or {@link
  * #skipValue()}.
  *
- * <h3>Example</h3>
+ * <h2>Example</h2>
  * Suppose we'd like to parse a stream of messages such as the following: <pre> {@code
  * [
  *   {
@@ -161,7 +161,7 @@
  *     return new User(username, followersCount);
  *   }}</pre>
  *
- * <h3>Number Handling</h3>
+ * <h2>Number Handling</h2>
  * This reader permits numeric values to be read as strings and string values to
  * be read as numbers. For example, both elements of the JSON array {@code
  * [1, "1"]} may be read using either {@link #nextInt} or {@link #nextString}.
@@ -171,7 +171,7 @@
  * precision loss, extremely large values should be written and read as strings
  * in JSON.
  *
- * <h3 id="nonexecuteprefix">Non-Execute Prefix</h3>
+ * <h2 id="nonexecuteprefix">Non-Execute Prefix</h2>
  * Web servers that serve private data using JSON may be vulnerable to <a
  * href="http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery">Cross-site
  * request forgery</a> attacks. In such an attack, a malicious site gains access

File: gson/src/main/java/com/google/gson/stream/JsonWriter.java
Patch:
@@ -58,7 +58,7 @@
  *       Finally close the object using {@link #endObject()}.
  * </ul>
  *
- * <h3>Example</h3>
+ * <h2>Example</h2>
  * Suppose we'd like to encode a stream of messages such as the following: <pre> {@code
  * [
  *   {

File: extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
Patch:
@@ -91,7 +91,7 @@
  * Both the type field name ({@code "type"}) and the type labels ({@code
  * "Rectangle"}) are configurable.
  *
- * <h3>Registering Types</h3>
+ * <h2>Registering Types</h2>
  * Create a {@code RuntimeTypeAdapterFactory} by passing the base type and type field
  * name to the {@link #of} factory method. If you don't supply an explicit type
  * field name, {@code "type"} will be used. <pre>   {@code

File: gson/src/main/java/com/google/gson/TypeAdapter.java
Patch:
@@ -30,7 +30,7 @@
 /**
  * Converts Java objects to and from JSON.
  *
- * <h3>Defining a type's JSON form</h3>
+ * <h2>Defining a type's JSON form</h2>
  * By default Gson converts application classes to JSON using its built-in type
  * adapters. If Gson's default JSON conversion isn't appropriate for a type,
  * extend this class to customize the conversion. Here's an example of a type

File: gson/src/main/java/com/google/gson/TypeAdapterFactory.java
Patch:
@@ -22,7 +22,7 @@
  * Creates type adapters for set of related types. Type adapter factories are
  * most useful when several types share similar structure in their JSON form.
  *
- * <h3>Example: Converting enums to lowercase</h3>
+ * <h2>Example: Converting enums to lowercase</h2>
  * In this example, we implement a factory that creates type adapters for all
  * enums. The type adapters will write enums in lowercase, despite the fact
  * that they're defined in {@code CONSTANT_CASE} in the corresponding Java

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -33,7 +33,7 @@
  * depth-first order, the same order that they appear in the JSON document.
  * Within JSON objects, name/value pairs are represented by a single token.
  *
- * <h3>Parsing JSON</h3>
+ * <h2>Parsing JSON</h2>
  * To create a recursive descent parser for your own JSON streams, first create
  * an entry point method that creates a {@code JsonReader}.
  *

File: gson/src/main/java/com/google/gson/stream/JsonWriter.java
Patch:
@@ -42,7 +42,7 @@
  * literal values (strings, numbers, booleans and nulls) as well as the begin
  * and end delimiters of objects and arrays.
  *
- * <h3>Encoding JSON</h3>
+ * <h2>Encoding JSON</h2>
  * To encode your data as JSON, create a new {@code JsonWriter}. Call methods
  * on the writer as you walk the structure's contents, nesting arrays and objects
  * as necessary:

File: proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java
Patch:
@@ -64,7 +64,6 @@
  *   string os_build_id = 1 [(serialized_name) = "osBuildID"];
  * }
  * </pre>
- * <p>
  *
  * @author Inderjeet Singh
  * @author Emmanuel Cron

File: gson/src/test/java/com/google/gson/MixedStreamTest.java
Patch:
@@ -174,7 +174,7 @@ public void testReadNulls() {
     } catch (NullPointerException expected) {
     }
     try {
-      gson.fromJson(new JsonReader(new StringReader("true")), null);
+      gson.fromJson(new JsonReader(new StringReader("true")), (Type) null);
       fail();
     } catch (NullPointerException expected) {
     }

File: metrics/src/main/java/com/google/gson/metrics/ParseBenchmark.java
Patch:
@@ -63,11 +63,11 @@ private enum Document {
     READER_SHORT(new TypeToken<Feed>() {}, new TypeReference<Feed>() {}),
     READER_LONG(new TypeToken<Feed>() {}, new TypeReference<Feed>() {});
 
-    private final Type gsonType;
+    private final TypeToken<?> gsonType;
     private final TypeReference<?> jacksonType;
 
     private Document(TypeToken<?> typeToken, TypeReference<?> typeReference) {
-      this.gsonType = typeToken.getType();
+      this.gsonType = typeToken;
       this.jacksonType = typeReference;
     }
   }

File: gson/src/main/java/com/google/gson/JsonSerializer.java
Patch:
@@ -48,7 +48,7 @@
  * serializer:</p>
  *
  * <pre>
- * class IdSerializer implements JsonSerializer&lt;Id&gt;() {
+ * class IdSerializer implements JsonSerializer&lt;Id&gt; {
  *   public JsonElement serialize(Id id, Type typeOfId, JsonSerializationContext context) {
  *     return new JsonPrimitive(id.getValue());
  *   }

File: gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java
Patch:
@@ -26,6 +26,7 @@
  *
  * @author Inderjeet Singh
  */
+@SuppressWarnings("serial") // ignore warning about missing serialVersionUID
 public final class LazilyParsedNumber extends Number {
   private final String value;
 

File: gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java
Patch:
@@ -38,6 +38,7 @@
  *
  * <p>This implementation was derived from Android 4.1's TreeMap class.
  */
+@SuppressWarnings("serial") // ignore warning about missing serialVersionUID
 public final class LinkedTreeMap<K, V> extends AbstractMap<K, V> implements Serializable {
   @SuppressWarnings({ "unchecked", "rawtypes" }) // to avoid Comparable<Comparable<Comparable<...>>>
   private static final Comparator<Comparable> NATURAL_ORDER = new Comparator<Comparable>() {
@@ -504,10 +505,9 @@ static final class Node<K, V> implements Entry<K, V> {
       return oldValue;
     }
 
-    @SuppressWarnings("rawtypes")
     @Override public boolean equals(Object o) {
       if (o instanceof Entry) {
-        Entry other = (Entry) o;
+        Entry<?, ?> other = (Entry<?, ?>) o;
         return (key == null ? other.getKey() == null : key.equals(other.getKey()))
             && (value == null ? other.getValue() == null : value.equals(other.getValue()));
       }

File: gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
Patch:
@@ -166,13 +166,13 @@ private Object readTerminal(JsonReader in, JsonToken peeked) throws IOException
     }
   }
 
-  @SuppressWarnings("unchecked")
   @Override public void write(JsonWriter out, Object value) throws IOException {
     if (value == null) {
       out.nullValue();
       return;
     }
 
+    @SuppressWarnings("unchecked")
     TypeAdapter<Object> typeAdapter = (TypeAdapter<Object>) gson.getAdapter(value.getClass());
     if (typeAdapter instanceof ObjectTypeAdapter) {
       out.beginObject();

File: gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
Patch:
@@ -891,7 +891,6 @@ public EnumTypeAdapter(final Class<T> classOfT) {
   }
 
   public static final TypeAdapterFactory ENUM_FACTORY = new TypeAdapterFactory() {
-    @SuppressWarnings({"rawtypes", "unchecked"})
     @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
       Class<? super T> rawType = typeToken.getRawType();
       if (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {
@@ -900,7 +899,9 @@ public EnumTypeAdapter(final Class<T> classOfT) {
       if (!rawType.isEnum()) {
         rawType = rawType.getSuperclass(); // handle anonymous subclasses
       }
-      return (TypeAdapter<T>) new EnumTypeAdapter(rawType);
+      @SuppressWarnings({"rawtypes", "unchecked"})
+      TypeAdapter<T> adapter = (TypeAdapter<T>) new EnumTypeAdapter(rawType);
+      return adapter;
     }
   };
 

File: gson/src/main/java/com/google/gson/stream/JsonWriter.java
Patch:
@@ -153,7 +153,7 @@ public class JsonWriter implements Closeable, Flushable {
   static {
     REPLACEMENT_CHARS = new String[128];
     for (int i = 0; i <= 0x1f; i++) {
-      REPLACEMENT_CHARS[i] = String.format("\\u%04x", (int) i);
+      REPLACEMENT_CHARS[i] = String.format("\\u%04x", i);
     }
     REPLACEMENT_CHARS['"'] = "\\\"";
     REPLACEMENT_CHARS['\\'] = "\\\\";

File: gson/src/test/java/com/google/gson/functional/ArrayTest.java
Patch:
@@ -141,12 +141,12 @@ public void testSingleStringArrayDeserialization() throws Exception {
     assertEquals("hello", arrayType[0]);
   }
 
-  @SuppressWarnings("unchecked")
   public void testArrayOfCollectionSerialization() throws Exception {
     StringBuilder sb = new StringBuilder("[");
     int arraySize = 3;
 
     Type typeToSerialize = new TypeToken<Collection<Integer>[]>() {}.getType();
+    @SuppressWarnings({"rawtypes", "unchecked"})
     Collection<Integer>[] arrayOfCollection = new ArrayList[arraySize];
     for (int i = 0; i < arraySize; ++i) {
       int startValue = (3 * i) + 1;

File: gson/src/test/java/com/google/gson/functional/JsonArrayTest.java
Patch:
@@ -17,9 +17,8 @@
 package com.google.gson.functional;
 
 import com.google.gson.JsonArray;
-import junit.framework.TestCase;
-
 import java.math.BigInteger;
+import junit.framework.TestCase;
 
 /**
  * Functional tests for adding primitives to a JsonArray.

File: gson/src/test/java/com/google/gson/internal/JavaVersionTest.java
Patch:
@@ -15,7 +15,8 @@
  */
 package com.google.gson.internal;
 
-import static org.junit.Assert.*;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 
 import org.junit.Test;
 
@@ -29,7 +30,7 @@ public class JavaVersionTest {
 
   @Test
   public void testGetMajorJavaVersion() {
-    JavaVersion.getMajorJavaVersion();
+    assertTrue(JavaVersion.getMajorJavaVersion() >= 7); // Gson currently requires at least Java 7
   }
 
   @Test

File: gson/src/test/java/com/google/gson/internal/LinkedTreeMapTest.java
Patch:
@@ -213,6 +213,7 @@ public void testJavaSerialization() throws IOException, ClassNotFoundException {
     assertEquals(Collections.singletonMap("a", 1), deserialized);
   }
 
+  @SuppressWarnings("varargs")
   @SafeVarargs
   private final <T> void assertIterationOrder(Iterable<T> actual, T... expected) {
     ArrayList<T> actualList = new ArrayList<>();

File: gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
Patch:
@@ -213,7 +213,7 @@ private void expect(JsonToken expected) throws IOException {
     }
     double result = ((JsonPrimitive) peekStack()).getAsDouble();
     if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {
-      throw new NumberFormatException("JSON forbids NaN and infinities: " + result);
+      throw new MalformedJsonException("JSON forbids NaN and infinities: " + result);
     }
     popStack();
     if (stackSize > 0) {

File: gson/src/main/java/com/google/gson/stream/JsonScope.java
Patch:
@@ -31,7 +31,7 @@ final class JsonScope {
     static final int EMPTY_ARRAY = 1;
 
     /**
-     * A array with at least one value requires a comma and newline before
+     * An array with at least one value requires a comma and newline before
      * the next element.
      */
     static final int NONEMPTY_ARRAY = 2;

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -368,6 +368,8 @@ public GsonBuilder setNumberToNumberStrategy(ToNumberStrategy numberToNumberStra
    * deserialization. Each of the {@code strategies} will be applied as a disjunction rule.
    * This means that if one of the {@code strategies} suggests that a field (or class) should be
    * skipped then that field (or object) is skipped during serialization/deserialization.
+   * The strategies are added to the existing strategies (if any); the existing strategies
+   * are not replaced.
    *
    * @param strategies the set of strategy object to apply during object (de)serialization.
    * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern

File: gson/src/main/java/com/google/gson/JsonElement.java
Patch:
@@ -268,7 +268,7 @@ public char getAsCharacter() {
    *
    * @return get this element as a {@link BigDecimal}.
    * @throws ClassCastException if the element is of not a {@link JsonPrimitive}.
-   * * @throws NumberFormatException if the element is not a valid {@link BigDecimal}.
+   * @throws NumberFormatException if the element is not a valid {@link BigDecimal}.
    * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains
    * more than a single element.
    * @since 1.2

File: extras/src/test/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactoryTest.java
Patch:
@@ -34,7 +34,9 @@ public void testRuntimeTypeAdapter() {
 
     CreditCard original = new CreditCard("Jesse", 234);
     assertEquals("{\"type\":\"CreditCard\",\"cvv\":234,\"ownerName\":\"Jesse\"}",
-        gson.toJson(original, BillingInstrument.class));
+        //do not give the explicit typeOfSrc, because if this would be in a list
+        //or an attribute, there would also be no hint. See #712
+        gson.toJson(original));
     BillingInstrument deserialized = gson.fromJson(
         "{type:'CreditCard',cvv:234,ownerName:'Jesse'}", BillingInstrument.class);
     assertEquals("Jesse", deserialized.ownerName);

File: gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
Patch:
@@ -120,8 +120,7 @@ public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,
       return null;
     }
 
-    Class<?> rawTypeOfSrc = $Gson$Types.getRawType(type);
-    Type[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);
+    Type[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawType);
     TypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);
     TypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));
     ObjectConstructor<T> constructor = constructorConstructor.get(typeToken);

File: extras/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.gson.GsonBuilder;
 import com.google.gson.InstanceCreator;
 import com.google.gson.JsonElement;
+import com.google.gson.ReflectionAccessFilter;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.internal.ConstructorConstructor;
@@ -30,6 +31,7 @@
 import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
 import java.lang.reflect.Type;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.IdentityHashMap;
 import java.util.LinkedList;
@@ -47,7 +49,7 @@ public final class GraphAdapterBuilder {
 
   public GraphAdapterBuilder() {
       this.instanceCreators = new HashMap<Type, InstanceCreator<?>>();
-      this.constructorConstructor = new ConstructorConstructor(instanceCreators, true);
+      this.constructorConstructor = new ConstructorConstructor(instanceCreators, true, Collections.<ReflectionAccessFilter>emptyList());
   }
   public GraphAdapterBuilder addType(Type type) {
     final ObjectConstructor<?> objectConstructor = constructorConstructor.get(TypeToken.get(type));

File: extras/src/main/java/com/google/gson/interceptors/InterceptorFactory.java
Patch:
@@ -12,7 +12,7 @@
  * A type adapter factory that implements {@code @Intercept}.
  */
 public final class InterceptorFactory implements TypeAdapterFactory {
-  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+  @Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
     Intercept intercept = type.getRawType().getAnnotation(Intercept.class);
     if (intercept == null) {
       return null;

File: extras/src/test/java/com/google/gson/interceptors/InterceptorTest.java
Patch:
@@ -141,7 +141,7 @@ public User(String name, String password) {
   }
 
   public static final class UserValidator implements JsonPostDeserializer<User> {
-    public void postDeserialize(User user) {
+    @Override public void postDeserialize(User user) {
       if (user.name == null || user.password == null) {
         throw new JsonSyntaxException("name and password are required fields.");
       }
@@ -161,7 +161,7 @@ private static final class Address {
   }
 
   public static final class AddressValidator implements JsonPostDeserializer<Address> {
-    public void postDeserialize(Address address) {
+    @Override public void postDeserialize(Address address) {
       if (address.city == null || address.state == null || address.zip == null) {
         throw new JsonSyntaxException("Address city, state and zip are required fields.");
       }

File: extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
Patch:
@@ -70,6 +70,7 @@ public Sandwich(String bread, String cheese) {
             }
         }
 
+        @Override
         public boolean equals(Object o) {
             if (o == this) {
                 return true;
@@ -95,6 +96,7 @@ public MultipleSandwiches(List<Sandwich> sandwiches) {
             this.sandwiches = sandwiches;
         }
 
+        @Override
         public boolean equals(Object o) {
             if (o == this) {
                 return true;

File: gson/src/main/java/com/google/gson/JsonArray.java
Patch:
@@ -187,6 +187,7 @@ public boolean isEmpty() {
    *
    * @return an iterator to navigate the elements of the array.
    */
+  @Override
   public Iterator<JsonElement> iterator() {
     return elements.iterator();
   }
@@ -341,13 +342,12 @@ public byte getAsByte() {
     throw new IllegalStateException();
   }
 
+  @Deprecated
   @Override
   public char getAsCharacter() {
     if (elements.size() == 1) {
       JsonElement element = elements.get(0);
-      @SuppressWarnings("deprecation")
-      char result = element.getAsCharacter();
-      return result;
+      return element.getAsCharacter();
     }
     throw new IllegalStateException();
   }

File: gson/src/main/java/com/google/gson/internal/Excluder.java
Patch:
@@ -108,7 +108,7 @@ public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy,
     return result;
   }
 
-  public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {
+  @Override public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {
     Class<?> rawType = type.getRawType();
     boolean excludeClass = excludeClassChecks(rawType);
 

File: gson/src/main/java/com/google/gson/internal/Streams.java
Patch:
@@ -105,13 +105,13 @@ private static final class AppendableWriter extends Writer {
      */
     static class CurrentWrite implements CharSequence {
       char[] chars;
-      public int length() {
+      @Override public int length() {
         return chars.length;
       }
-      public char charAt(int i) {
+      @Override public char charAt(int i) {
         return chars[i];
       }
-      public CharSequence subSequence(int start, int end) {
+      @Override public CharSequence subSequence(int start, int end) {
         return new String(chars, start, end - start);
       }
     }

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -1212,7 +1212,7 @@ public int nextInt() throws IOException {
   /**
    * Closes this JSON reader and the underlying {@link java.io.Reader}.
    */
-  public void close() throws IOException {
+  @Override public void close() throws IOException {
     peeked = PEEKED_NONE;
     stack[0] = JsonScope.CLOSED;
     stackSize = 1;

File: gson/src/main/java/com/google/gson/stream/JsonWriter.java
Patch:
@@ -571,7 +571,7 @@ public JsonWriter value(Number value) throws IOException {
    * Ensures all buffered data is written to the underlying {@link Writer}
    * and flushes that writer.
    */
-  public void flush() throws IOException {
+  @Override public void flush() throws IOException {
     if (stackSize == 0) {
       throw new IllegalStateException("JsonWriter is closed.");
     }
@@ -583,7 +583,7 @@ public void flush() throws IOException {
    *
    * @throws IOException if the JSON document is incomplete.
    */
-  public void close() throws IOException {
+  @Override public void close() throws IOException {
     out.close();
 
     int size = stackSize;

File: gson/src/test/java/com/google/gson/GsonTypeAdapterTest.java
Patch:
@@ -130,7 +130,7 @@ public void testDeserializerForAbstractClass() {
   private void assertSerialized(String expected, Class<?> instanceType, boolean registerAbstractDeserializer,
       boolean registerAbstractHierarchyDeserializer, Object instance) {
     JsonDeserializer<Abstract> deserializer = new JsonDeserializer<Abstract>() {
-      public Abstract deserialize(JsonElement json, Type typeOfT,
+      @Override public Abstract deserialize(JsonElement json, Type typeOfT,
           JsonDeserializationContext context) throws JsonParseException {
         throw new AssertionError();
       }

File: gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java
Patch:
@@ -79,7 +79,7 @@ public void testSelfReferenceCustomHandlerSerialization() throws Exception {
     ClassWithSelfReference obj = new ClassWithSelfReference();
     obj.child = obj;
     Gson gson = new GsonBuilder().registerTypeAdapter(ClassWithSelfReference.class, new JsonSerializer<ClassWithSelfReference>() {
-      public JsonElement serialize(ClassWithSelfReference src, Type typeOfSrc,
+      @Override public JsonElement serialize(ClassWithSelfReference src, Type typeOfSrc,
           JsonSerializationContext context) {
         JsonObject obj = new JsonObject();
         obj.addProperty("property", "value");

File: gson/src/test/java/com/google/gson/functional/CollectionTest.java
Patch:
@@ -328,7 +328,7 @@ public void testFieldIsArrayList() {
   public void testUserCollectionTypeAdapter() {
     Type listOfString = new TypeToken<List<String>>() {}.getType();
     Object stringListSerializer = new JsonSerializer<List<String>>() {
-      public JsonElement serialize(List<String> src, Type typeOfSrc,
+      @Override public JsonElement serialize(List<String> src, Type typeOfSrc,
           JsonSerializationContext context) {
         return new JsonPrimitive(src.get(0) + ";" + src.get(1));
       }

File: gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java
Patch:
@@ -71,7 +71,7 @@ public void testMultiThreadSerialization() throws InterruptedException {
     ExecutorService executor = Executors.newFixedThreadPool(10);
     for (int taskCount = 0; taskCount < 10; taskCount++) {
       executor.execute(new Runnable() {
-        public void run() {
+        @Override public void run() {
           MyObject myObj = new MyObject();
           try {
             startLatch.await();
@@ -102,7 +102,7 @@ public void testMultiThreadDeserialization() throws InterruptedException {
     ExecutorService executor = Executors.newFixedThreadPool(10);
     for (int taskCount = 0; taskCount < 10; taskCount++) {
       executor.execute(new Runnable() {
-        public void run() {
+        @Override public void run() {
           try {
             startLatch.await();
             for (int i = 0; i < 10; i++) {

File: gson/src/test/java/com/google/gson/functional/CustomSerializerTest.java
Patch:
@@ -91,7 +91,7 @@ public void testBaseClassSerializerInvokedForBaseClassFieldsHoldingSubClassInsta
    public void testSerializerReturnsNull() {
      Gson gson = new GsonBuilder()
        .registerTypeAdapter(Base.class, new JsonSerializer<Base>() {
-         public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {
+         @Override public JsonElement serialize(Base src, Type typeOfSrc, JsonSerializationContext context) {
            return null;
          }
        })

File: gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
Patch:
@@ -470,7 +470,7 @@ public void testDateSerializationWithPatternNotOverridenByTypeAdapter() throws E
     Gson gson = new GsonBuilder()
         .setDateFormat(pattern)
         .registerTypeAdapter(Date.class, new JsonDeserializer<Date>() {
-          public Date deserialize(JsonElement json, Type typeOfT,
+          @Override public Date deserialize(JsonElement json, Type typeOfT,
               JsonDeserializationContext context)
               throws JsonParseException {
             return new Date(1315806903103L);

File: gson/src/test/java/com/google/gson/functional/GsonVersionDiagnosticsTest.java
Patch:
@@ -40,6 +40,7 @@ public class GsonVersionDiagnosticsTest extends TestCase {
   private Gson gson;
 
   @Before
+  @Override
   public void setUp() {
     gson = new GsonBuilder().registerTypeAdapter(TestType.class, new TypeAdapter<TestType>() {
       @Override public void write(JsonWriter out, TestType value) {

File: gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java
Patch:
@@ -88,7 +88,7 @@ public void testRegisteredAdapterOverridesJsonAdapter() {
    */
   public void testRegisteredSerializerOverridesJsonAdapter() {
     JsonSerializer<A> serializer = new JsonSerializer<A>() {
-      public JsonElement serialize(A src, Type typeOfSrc,
+      @Override public JsonElement serialize(A src, Type typeOfSrc,
           JsonSerializationContext context) {
         return new JsonPrimitive("registeredSerializer");
       }
@@ -107,7 +107,7 @@ public JsonElement serialize(A src, Type typeOfSrc,
    */
   public void testRegisteredDeserializerOverridesJsonAdapter() {
     JsonDeserializer<A> deserializer = new JsonDeserializer<A>() {
-      public A deserialize(JsonElement json, Type typeOfT,
+      @Override public A deserialize(JsonElement json, Type typeOfT,
           JsonDeserializationContext context) throws JsonParseException {
         return new A("registeredDeserializer");
       }

File: gson/src/test/java/com/google/gson/functional/MapTest.java
Patch:
@@ -284,7 +284,7 @@ public void testMapStandardSubclassDeserialization() {
 
   public void testMapSubclassDeserialization() {
     Gson gson = new GsonBuilder().registerTypeAdapter(MyMap.class, new InstanceCreator<MyMap>() {
-      public MyMap createInstance(Type type) {
+      @Override public MyMap createInstance(Type type) {
         return new MyMap();
       }
     }).create();
@@ -299,7 +299,7 @@ public void testCustomSerializerForSpecificMapType() {
         null, Map.class, String.class, Long.class);
     Gson gson = new GsonBuilder()
         .registerTypeAdapter(type, new JsonSerializer<Map<String, Long>>() {
-          public JsonElement serialize(Map<String, Long> src, Type typeOfSrc,
+          @Override public JsonElement serialize(Map<String, Long> src, Type typeOfSrc,
               JsonSerializationContext context) {
             JsonArray array = new JsonArray();
             for (long value : src.values()) {
@@ -493,7 +493,7 @@ public final void testInterfaceTypeMapWithSerializer() {
         + "\"subs\":{\"Test\":" + subTypeJson + "}}";
 
     JsonSerializer<TestTypes.Base> baseTypeAdapter = new JsonSerializer<TestTypes.Base>() {
-      public JsonElement serialize(TestTypes.Base src, Type typeOfSrc,
+      @Override public JsonElement serialize(TestTypes.Base src, Type typeOfSrc,
           JsonSerializationContext context) {
         return baseTypeJsonElement;
       }

File: gson/src/test/java/com/google/gson/functional/ObjectTest.java
Patch:
@@ -298,7 +298,7 @@ public void testAnonymousLocalClassesCustomSerialization() throws Exception {
     gson = new GsonBuilder()
         .registerTypeHierarchyAdapter(ClassWithNoFields.class,
             new JsonSerializer<ClassWithNoFields>() {
-              public JsonElement serialize(
+              @Override public JsonElement serialize(
                   ClassWithNoFields src, Type typeOfSrc, JsonSerializationContext context) {
                 return new JsonObject();
               }
@@ -342,7 +342,7 @@ public void testInnerClassDeserialization() {
     final Parent p = new Parent();
     Gson gson = new GsonBuilder().registerTypeAdapter(
         Parent.Child.class, new InstanceCreator<Parent.Child>() {
-      public Parent.Child createInstance(Type type) {
+      @Override public Parent.Child createInstance(Type type) {
         return p.new Child();
       }
     }).create();

File: gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
Patch:
@@ -155,7 +155,7 @@ public void testNullSafe() {
         String[] values = in.nextString().split(",");
         return new Person(values[0], Integer.parseInt(values[1]));
       }
-      public void write(JsonWriter out, Person person) throws IOException {
+      @Override public void write(JsonWriter out, Person person) throws IOException {
         out.value(person.name + "," + person.age);
       }
     };

File: gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
Patch:
@@ -21,9 +21,6 @@
 import com.google.gson.internal.$Gson$Types;
 import junit.framework.TestCase;
 
-import java.io.PrintStream;
-import java.lang.ref.WeakReference;
-
 /**
  * Test fixes for infinite recursion on {@link $Gson$Types#resolve(java.lang.reflect.Type, Class,
  * java.lang.reflect.Type)}, described at <a href="https://github.com/google/gson/issues/440">Issue #440</a>

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -38,6 +38,7 @@
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.GsonBuildConfig;
+import com.google.gson.internal.LazilyParsedNumber;
 import com.google.gson.internal.Primitives;
 import com.google.gson.internal.Streams;
 import com.google.gson.internal.bind.ArrayTypeAdapter;
@@ -267,6 +268,8 @@ public Gson() {
     factories.add(TypeAdapters.STRING_BUFFER_FACTORY);
     factories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));
     factories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));
+    // Add adapter for LazilyParsedNumber because user can obtain it from Gson and then try to serialize it again
+    factories.add(TypeAdapters.newFactory(LazilyParsedNumber.class, TypeAdapters.LAZILY_PARSED_NUMBER));
     factories.add(TypeAdapters.URL_FACTORY);
     factories.add(TypeAdapters.URI_FACTORY);
     factories.add(TypeAdapters.UUID_FACTORY);

File: gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
Patch:
@@ -101,7 +101,7 @@ public JsonTreeReader(JsonElement element) {
 
   @Override public boolean hasNext() throws IOException {
     JsonToken token = peek();
-    return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;
+    return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY && token != JsonToken.END_DOCUMENT;
   }
 
   @Override public JsonToken peek() throws IOException {

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -413,7 +413,7 @@ public boolean hasNext() throws IOException {
     if (p == PEEKED_NONE) {
       p = doPeek();
     }
-    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
+    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY && p != PEEKED_EOF;
   }
 
   /**

File: gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
Patch:
@@ -1734,7 +1734,7 @@ public void testUnterminatedStringFailure() throws IOException {
    * Regression test for an issue with buffer filling and consumeNonExecutePrefix.
    */
   public void testReadAcrossBuffers() throws IOException {
-    StringBuilder sb = new StringBuilder('#');
+    StringBuilder sb = new StringBuilder("#");
     for (int i = 0; i < JsonReader.BUFFER_SIZE - 3; i++) {
       sb.append(' ');
     }

File: extras/src/main/java/com/google/gson/interceptors/Intercept.java
Patch:
@@ -28,8 +28,8 @@
  * after it has been deserialized from Json.
  * Here is an example of how this annotation is used:
  * <p>Here is an example of how this annotation is used:
- * <p><pre>
- * &#64Intercept(postDeserialize=UserValidator.class)
+ * <pre>
+ * &#64;Intercept(postDeserialize=UserValidator.class)
  * public class User {
  *   String name;
  *   String password;
@@ -47,7 +47,7 @@
  *     }
  *   }
  * }
- * </pre></p>
+ * </pre>
  *
  * @author Inderjeet Singh
  */

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -76,7 +76,7 @@
  * MyType target = new MyType();
  * String json = gson.toJson(target); // serializes target to Json
  * MyType target2 = gson.fromJson(json, MyType.class); // deserializes json into target2
- * </pre></p>
+ * </pre>
  *
  * <p>If the object that your are serializing/deserializing is a {@code ParameterizedType}
  * (i.e. contains at least one type parameter and may be an array) then you must use the
@@ -91,7 +91,7 @@
  * Gson gson = new Gson();
  * String json = gson.toJson(target, listType);
  * List&lt;String&gt; target2 = gson.fromJson(json, listType);
- * </pre></p>
+ * </pre>
  *
  * <p>See the <a href="https://sites.google.com/site/gson/gson-user-guide">Gson User Guide</a>
  * for a more complete set of examples.</p>
@@ -548,7 +548,7 @@ public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {
    *  read or written.
    * @param skipPast The type adapter factory that needs to be skipped while searching for
    *   a matching type adapter. In most cases, you should just pass <i>this</i> (the type adapter
-   *   factory from where {@link #getDelegateAdapter} method is being invoked).
+   *   factory from where {@code getDelegateAdapter} method is being invoked).
    * @param type Type for which the delegate adapter is being searched for.
    *
    * @since 2.2

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -61,16 +61,15 @@
  *     .setPrettyPrinting()
  *     .setVersion(1.0)
  *     .create();
- * </pre></p>
+ * </pre>
  *
  * <p>NOTES:
  * <ul>
  * <li> the order of invocation of configuration methods does not matter.</li>
  * <li> The default serialization of {@link Date} and its subclasses in Gson does
  *  not contain time-zone information. So, if you are using date/time instances,
  *  use {@code GsonBuilder} and its {@code setDateFormat} methods.</li>
- *  </ul>
- * </p>
+ * </ul>
  *
  * @author Inderjeet Singh
  * @author Joel Leitch
@@ -251,6 +250,7 @@ public GsonBuilder serializeNulls() {
    *   original.put(new Point(8, 8), "b");
    *   System.out.println(gson.toJson(original, type));
    * }
+   * </pre>
    *
    * The JSON output would look as follows:
    * <pre>   {@code

File: gson/src/main/java/com/google/gson/ToNumberStrategy.java
Patch:
@@ -65,7 +65,6 @@ public interface ToNumberStrategy {
    *
    * @param in JSON reader to read a number from
    * @return number read from the JSON reader.
-   * @throws IOException
    */
   public Number readNumber(JsonReader in) throws IOException;
 }

File: gson/src/main/java/com/google/gson/annotations/Expose.java
Patch:
@@ -32,14 +32,14 @@
  * method.</p>
  *
  * <p>Here is an example of how this annotation is meant to be used:
- * <p><pre>
+ * <pre>
  * public class User {
  *   &#64;Expose private String firstName;
  *   &#64;Expose(serialize = false) private String lastName;
  *   &#64;Expose (serialize = false, deserialize = false) private String emailAddress;
  *   private String password;
  * }
- * </pre></p>
+ * </pre>
  * If you created Gson with {@code new Gson()}, the {@code toJson()} and {@code fromJson()}
  * methods will use the {@code password} field along-with {@code firstName}, {@code lastName},
  * and {@code emailAddress} for serialization and deserialization. However, if you created Gson

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -170,7 +170,7 @@
  * precision loss, extremely large values should be written and read as strings
  * in JSON.
  *
- * <a id="nonexecuteprefix"/><h3>Non-Execute Prefix</h3>
+ * <h3 id="nonexecuteprefix">Non-Execute Prefix</h3>
  * Web servers that serve private data using JSON may be vulnerable to <a
  * href="http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery">Cross-site
  * request forgery</a> attacks. In such an attack, a malicious site gains access

File: proto/src/main/java/com/google/gson/protobuf/ProtoTypeAdapter.java
Patch:
@@ -389,7 +389,7 @@ private EnumValueDescriptor findValueByNameAndExtension(EnumDescriptor desc,
       EnumValueDescriptor fieldValue = desc.findValueByNumber(jsonElement.getAsInt());
       if (fieldValue == null) {
         throw new IllegalArgumentException(
-            String.format("Unrecognized enum value: %s", jsonElement.getAsInt()));
+            String.format("Unrecognized enum value: %d", jsonElement.getAsInt()));
       }
       return fieldValue;
     }

File: gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
Patch:
@@ -28,7 +28,7 @@
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.ObjectConstructor;
 import com.google.gson.internal.Primitives;
-import com.google.gson.internal.reflect.ReflectionAccessor;
+import com.google.gson.internal.reflect.ReflectionHelper;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
@@ -50,7 +50,6 @@ public final class ReflectiveTypeAdapterFactory implements TypeAdapterFactory {
   private final FieldNamingStrategy fieldNamingPolicy;
   private final Excluder excluder;
   private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
-  private final ReflectionAccessor accessor = ReflectionAccessor.getInstance();
 
   public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,
       FieldNamingStrategy fieldNamingPolicy, Excluder excluder,
@@ -156,7 +155,7 @@ private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type,
         if (!serialize && !deserialize) {
           continue;
         }
-        accessor.makeAccessible(field);
+        ReflectionHelper.makeAccessible(field);
         Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());
         List<String> fieldNames = getFieldNames(field);
         BoundField previous = null;

File: gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
Patch:
@@ -180,7 +180,6 @@ public void testNullSerialization() throws Exception {
     testNullSerializationAndDeserialization(Date.class);
     testNullSerializationAndDeserialization(GregorianCalendar.class);
     testNullSerializationAndDeserialization(Calendar.class);
-    testNullSerializationAndDeserialization(Enum.class);
     testNullSerializationAndDeserialization(Class.class);
   }
 

File: gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
Patch:
@@ -39,7 +39,6 @@
 import java.net.InetAddress;
 import java.net.URI;
 import java.net.URL;
-import java.sql.Timestamp;
 import java.text.DateFormat;
 import java.util.ArrayList;
 import java.util.Arrays;

File: gson/src/test/java/com/google/gson/internal/JavaVersionTest.java
Patch:
@@ -19,8 +19,6 @@
 
 import org.junit.Test;
 
-import com.google.gson.internal.JavaVersion;
-
 /**
  * Unit and functional tests for {@link JavaVersion}
  *

File: gson/src/test/java/com/google/gson/internal/bind/DefaultDateTypeAdapterTest.java
Patch:
@@ -27,7 +27,6 @@
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.internal.JavaVersion;
-import com.google.gson.internal.bind.DefaultDateTypeAdapter;
 import com.google.gson.internal.bind.DefaultDateTypeAdapter.DateType;
 import com.google.gson.reflect.TypeToken;
 

File: gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java
Patch:
@@ -307,7 +307,7 @@ public static List<Object[]> parameters() {
     assertEquals("$", reader.getPath());
   }
 
-  enum Factory {
+  public enum Factory {
     STRING_READER {
       @Override public JsonReader create(String data) {
         return new JsonReader(new StringReader(data));

File: gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
Patch:
@@ -47,7 +47,7 @@ public final class TreeTypeAdapter<T> extends TypeAdapter<T> {
   private final GsonContextImpl context = new GsonContextImpl();
 
   /** The delegate is lazily created because it may not be needed, and creating it may fail. */
-  private TypeAdapter<T> delegate;
+  private volatile TypeAdapter<T> delegate;
 
   public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,
       Gson gson, TypeToken<T> typeToken, TypeAdapterFactory skipPast) {
@@ -83,6 +83,7 @@ public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deseria
   }
 
   private TypeAdapter<T> delegate() {
+    // A race might lead to `delegate` being assigned by multiple threads but the last assignment will stick
     TypeAdapter<T> d = delegate;
     return d != null
         ? d

File: gson/src/main/java/com/google/gson/ToNumberPolicy.java
Patch:
@@ -71,11 +71,11 @@ public enum ToNumberPolicy implements ToNumberStrategy {
         try {
           Double d = Double.valueOf(value);
           if ((d.isInfinite() || d.isNaN()) && !in.isLenient()) {
-            throw new MalformedJsonException("JSON forbids NaN and infinities: " + d + "; at path " + in.getPath());
+            throw new MalformedJsonException("JSON forbids NaN and infinities: " + d + "; at path " + in.getPreviousPath());
           }
           return d;
         } catch (NumberFormatException doubleE) {
-          throw new JsonParseException("Cannot parse " + value + "; at path " + in.getPath(), doubleE);
+          throw new JsonParseException("Cannot parse " + value + "; at path " + in.getPreviousPath(), doubleE);
         }
       }
     }
@@ -91,7 +91,7 @@ public enum ToNumberPolicy implements ToNumberStrategy {
       try {
         return new BigDecimal(value);
       } catch (NumberFormatException e) {
-        throw new JsonParseException("Cannot parse " + value + "; at path " + in.getPath(), e);
+        throw new JsonParseException("Cannot parse " + value + "; at path " + in.getPreviousPath(), e);
       }
     }
   }

File: gson/src/main/java/com/google/gson/internal/bind/NumberTypeAdapter.java
Patch:
@@ -72,7 +72,7 @@ public static TypeAdapterFactory getFactory(ToNumberStrategy toNumberStrategy) {
     case STRING:
       return toNumberStrategy.readNumber(in);
     default:
-      throw new JsonSyntaxException("Expecting number, got: " + jsonToken);
+      throw new JsonSyntaxException("Expecting number, got: " + jsonToken + "; at path " + in.getPath());
     }
   }
 

File: gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
Patch:
@@ -308,11 +308,11 @@ private void push(Object newTop) {
     StringBuilder result = new StringBuilder().append('$');
     for (int i = 0; i < stackSize; i++) {
       if (stack[i] instanceof JsonArray) {
-        if (stack[++i] instanceof Iterator) {
+        if (++i < stackSize && stack[i] instanceof Iterator) {
           result.append('[').append(pathIndices[i]).append(']');
         }
       } else if (stack[i] instanceof JsonObject) {
-        if (stack[++i] instanceof Iterator) {
+        if (++i < stackSize && stack[i] instanceof Iterator) {
           result.append('.');
           if (pathNames[i] != null) {
             result.append(pathNames[i]);

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -130,6 +130,8 @@ public GsonBuilder() {
     this.timeStyle = gson.timeStyle;
     this.factories.addAll(gson.builderFactories);
     this.hierarchyFactories.addAll(gson.builderHierarchyFactories);
+    this.objectToNumberStrategy = gson.objectToNumberStrategy;
+    this.numberToNumberStrategy = gson.numberToNumberStrategy;
   }
 
   /**

File: gson/src/main/java/com/google/gson/ToNumberPolicy.java
Patch:
@@ -71,11 +71,11 @@ public enum ToNumberPolicy implements ToNumberStrategy {
         try {
           Double d = Double.valueOf(value);
           if ((d.isInfinite() || d.isNaN()) && !in.isLenient()) {
-            throw new MalformedJsonException("JSON forbids NaN and infinities: " + d + in);
+            throw new MalformedJsonException("JSON forbids NaN and infinities: " + d + "; at path " + in.getPath());
           }
           return d;
         } catch (NumberFormatException doubleE) {
-          throw new JsonParseException("Cannot parse " + value, doubleE);
+          throw new JsonParseException("Cannot parse " + value + "; at path " + in.getPath(), doubleE);
         }
       }
     }
@@ -91,7 +91,7 @@ public enum ToNumberPolicy implements ToNumberStrategy {
       try {
         return new BigDecimal(value);
       } catch (NumberFormatException e) {
-        throw new JsonParseException("Cannot parse " + value, e);
+        throw new JsonParseException("Cannot parse " + value + "; at path " + in.getPath(), e);
       }
     }
   }

File: gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
Patch:
@@ -283,7 +283,7 @@ JsonElement nextJsonElement() throws IOException {
   }
 
   @Override public String toString() {
-    return getClass().getSimpleName();
+    return getClass().getSimpleName() + locationString();
   }
 
   public void promoteNameToValue() throws IOException {

File: gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
Patch:
@@ -782,6 +782,7 @@ public EnumTypeAdapter(Class<T> classOfT) {
             continue;
           }
           field.setAccessible(true);
+          @SuppressWarnings("unchecked")
           T constant = (T)(field.get(null));
           String name = constant.name();
           SerializedName annotation = field.getAnnotation(SerializedName.class);

File: gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java
Patch:
@@ -79,7 +79,7 @@ private static Object getUnsafeInstance() {
   private static Field getOverrideField() {
     try {
       return AccessibleObject.class.getDeclaredField("override");
-    } catch (NoSuchFieldException e) {
+    } catch (Exception e) {
       return null;
     }
   }

File: gson/src/main/java/com/google/gson/internal/$Gson$Types.java
Patch:
@@ -339,13 +339,13 @@ public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawTyp
   }
 
   public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
-    return resolve(context, contextRawType, toResolve, new HashMap<TypeVariable, Type>());
+    return resolve(context, contextRawType, toResolve, new HashMap<TypeVariable<?>, Type>());
   }
 
   private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,
-                              Map<TypeVariable, Type> visitedTypeVariables) {
+                              Map<TypeVariable<?>, Type> visitedTypeVariables) {
     // this implementation is made a little more complicated in an attempt to avoid object-creation
-    TypeVariable resolving = null;
+    TypeVariable<?> resolving = null;
     while (true) {
       if (toResolve instanceof TypeVariable) {
         TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;

File: gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java
Patch:
@@ -79,7 +79,7 @@ private static Object getUnsafeInstance() {
   private static Field getOverrideField() {
     try {
       return AccessibleObject.class.getDeclaredField("override");
-    } catch (NoSuchFieldException e) {
+    } catch (Exception e) {
       return null;
     }
   }

File: gson/src/main/java/com/google/gson/internal/$Gson$Types.java
Patch:
@@ -334,11 +334,11 @@ public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawTyp
   }
 
   public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
-    return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());
+    return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable<?>>());
   }
 
   private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,
-                              Collection<TypeVariable> visitedTypeVariables) {
+                              Collection<TypeVariable<?>> visitedTypeVariables) {
     // this implementation is made a little more complicated in an attempt to avoid object-creation
     while (true) {
       if (toResolve instanceof TypeVariable) {

File: gson/src/test/java/com/google/gson/functional/CollectionTest.java
Patch:
@@ -37,7 +37,6 @@
 import com.google.gson.JsonPrimitive;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
-import com.google.gson.common.MoreAsserts;
 import com.google.gson.common.TestTypes.BagOfPrimitives;
 import com.google.gson.reflect.TypeToken;
 

File: gson/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java
Patch:
@@ -172,6 +172,7 @@ private static class HistoryCourse {
     int numClasses;
   }
 
+  @SafeVarargs
   private static <T> List<T> createList(T ...items) {
     return Arrays.asList(items);
   }

File: gson/src/test/java/com/google/gson/internal/LinkedHashTreeMapTest.java
Patch:
@@ -280,6 +280,7 @@ private String toString(Node<?, ?> root) {
     }
   }
 
+  @SafeVarargs
   private <T> void assertIterationOrder(Iterable<T> actual, T... expected) {
     ArrayList<T> actualList = new ArrayList<T>();
     for (T t : actual) {

File: gson/src/test/java/com/google/gson/internal/LinkedTreeMapTest.java
Patch:
@@ -140,6 +140,7 @@ public void testEqualsAndHashCode() throws Exception {
     MoreAsserts.assertEqualsAndHashCode(map1, map2);
   }
 
+  @SafeVarargs
   private <T> void assertIterationOrder(Iterable<T> actual, T... expected) {
     ArrayList<T> actualList = new ArrayList<T>();
     for (T t : actual) {

File: gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java
Patch:
@@ -130,6 +130,9 @@ private void put(JsonElement value) {
   }
 
   @Override public JsonWriter name(String name) throws IOException {
+    if (name == null) {
+      throw new NullPointerException("name == null");
+    }
     if (stack.isEmpty() || pendingName != null) {
       throw new IllegalStateException();
     }

File: gson/src/main/java/com/google/gson/ExclusionStrategy.java
Patch:
@@ -46,11 +46,11 @@
  *
  * <p><strong>Excludes fields and objects based on a particular annotation:</strong>
  * <pre class="code">
- * public &#64interface FooAnnotation {
+ * public &#64;interface FooAnnotation {
  *   // some implementation here
  * }
  *
- * // Excludes any field (or class) that is tagged with an "&#64FooAnnotation"
+ * // Excludes any field (or class) that is tagged with an "&#64;FooAnnotation"
  * private static class FooAnnotationExclusionStrategy implements ExclusionStrategy {
  *   public boolean shouldSkipClass(Class&lt;?&gt; clazz) {
  *     return clazz.getAnnotation(FooAnnotation.class) != null;

File: gson/src/main/java/com/google/gson/annotations/Expose.java
Patch:
@@ -34,9 +34,9 @@
  * <p>Here is an example of how this annotation is meant to be used:
  * <p><pre>
  * public class User {
- *   &#64Expose private String firstName;
- *   &#64Expose(serialize = false) private String lastName;
- *   &#64Expose (serialize = false, deserialize = false) private String emailAddress;
+ *   &#64;Expose private String firstName;
+ *   &#64;Expose(serialize = false) private String lastName;
+ *   &#64;Expose (serialize = false, deserialize = false) private String emailAddress;
  *   private String password;
  * }
  * </pre></p>

File: gson/src/main/java/com/google/gson/annotations/SerializedName.java
Patch:
@@ -35,8 +35,8 @@
  * <p>Here is an example of how this annotation is meant to be used:</p>
  * <pre>
  * public class MyClass {
- *   &#64SerializedName("name") String a;
- *   &#64SerializedName(value="name1", alternate={"name2", "name3"}) String b;
+ *   &#64;SerializedName("name") String a;
+ *   &#64;SerializedName(value="name1", alternate={"name2", "name3"}) String b;
  *   String c;
  *
  *   public MyClass(String a, String b, String c) {

File: gson/src/main/java/com/google/gson/annotations/Since.java
Patch:
@@ -36,9 +36,9 @@
  * public class User {
  *   private String firstName;
  *   private String lastName;
- *   &#64Since(1.0) private String emailAddress;
- *   &#64Since(1.0) private String password;
- *   &#64Since(1.1) private Address address;
+ *   &#64;Since(1.0) private String emailAddress;
+ *   &#64;Since(1.0) private String password;
+ *   &#64;Since(1.1) private Address address;
  * }
  * </pre>
  *

File: gson/src/main/java/com/google/gson/annotations/Until.java
Patch:
@@ -38,8 +38,8 @@
  * public class User {
  *   private String firstName;
  *   private String lastName;
- *   &#64Until(1.1) private String emailAddress;
- *   &#64Until(1.1) private String password;
+ *   &#64;Until(1.1) private String emailAddress;
+ *   &#64;Until(1.1) private String password;
  * }
  * </pre>
  *

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -170,7 +170,7 @@
  * precision loss, extremely large values should be written and read as strings
  * in JSON.
  *
- * <a name="nonexecuteprefix"/><h3>Non-Execute Prefix</h3>
+ * <a id="nonexecuteprefix"/><h3>Non-Execute Prefix</h3>
  * Web servers that serve private data using JSON may be vulnerable to <a
  * href="http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery">Cross-site
  * request forgery</a> attacks. In such an attack, a malicious site gains access

File: gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
Patch:
@@ -88,8 +88,9 @@ public void testParsingDatesFormattedWithSystemLocale() throws Exception {
           new DefaultDateTypeAdapter(DateFormat.MEDIUM, DateFormat.MEDIUM));
       assertParsed(String.format("1 janvier 1970%s00:00:00 UTC", afterYearSep),
           new DefaultDateTypeAdapter(DateFormat.LONG, DateFormat.LONG));
-      assertParsed(JavaVersion.isJava9OrLater() ?
+      assertParsed(JavaVersion.isJava9OrLater() ? (JavaVersion.getMajorJavaVersion() <11 ?
                       "jeudi 1 janvier 1970  00:00:00 Coordinated Universal Time" :
+                      "jeudi 1 janvier 1970  00:00:00 Temps universel coordonn") :
                       "jeudi 1 janvier 1970 00 h 00 UTC",
           new DefaultDateTypeAdapter(DateFormat.FULL, DateFormat.FULL));
     } finally {

File: gson/src/test/java/com/google/gson/JsonObjectTest.java
Patch:
@@ -128,7 +128,7 @@ public void testWritePropertyWithEmptyStringName() {
   }
 
   public void testReadPropertyWithEmptyStringName() {
-    JsonObject jsonObj = new JsonParser().parse("{\"\":true}").getAsJsonObject();
+    JsonObject jsonObj = JsonParser.parseString("{\"\":true}").getAsJsonObject();
     assertEquals(true, jsonObj.get("").getAsBoolean());
   }
 

File: gson/src/test/java/com/google/gson/functional/JsonParserTest.java
Patch:
@@ -112,7 +112,7 @@ public void testBadFieldTypeForDeserializingCustomTree() {
   public void testChangingCustomTreeAndDeserializing() {
     StringReader json =
       new StringReader("{'stringValue':'no message','intValue':10,'longValue':20}");
-    JsonObject obj = (JsonObject) new JsonParser().parse(json);
+    JsonObject obj = (JsonObject) JsonParser.parseReader(json);
     obj.remove("stringValue");
     obj.addProperty("stringValue", "fooBar");
     BagOfPrimitives target = gson.fromJson(obj, BagOfPrimitives.class);

File: gson/src/test/java/com/google/gson/functional/MapTest.java
Patch:
@@ -608,7 +608,7 @@ public void testMapNamePromotionWithJsonElementReader() {
     String json = "{'2.3':'a'}";
     Map<Double, String> map = new LinkedHashMap<Double, String>();
     map.put(2.3, "a");
-    JsonElement tree = new JsonParser().parse(json);
+    JsonElement tree = JsonParser.parseString(json);
     assertEquals(map, gson.fromJson(tree, new TypeToken<Map<Double, String>>() {}.getType()));
   }
 

File: gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
Patch:
@@ -20,13 +20,13 @@
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
+import com.google.gson.internal.JavaVersion;
 import com.google.gson.internal.PreJava9DateFormatProvider;
 import com.google.gson.internal.bind.util.ISO8601Utils;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
-import com.google.gson.util.VersionUtils;
 
 import java.io.IOException;
 import java.text.DateFormat;
@@ -62,7 +62,7 @@ public DateTypeAdapter() {
     if (!Locale.getDefault().equals(Locale.US)) {
       dateFormats.add(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));
     }
-    if (VersionUtils.isJava9OrLater()) {
+    if (JavaVersion.isJava9OrLater()) {
       dateFormats.add(PreJava9DateFormatProvider.getUSDateTimeFormat(DateFormat.DEFAULT, DateFormat.DEFAULT));
     }
   }

File: gson/src/main/java/com/google/gson/internal/reflect/ReflectionAccessor.java
Patch:
@@ -15,10 +15,10 @@
  */
 package com.google.gson.internal.reflect;
 
-import com.google.gson.util.VersionUtils;
-
 import java.lang.reflect.AccessibleObject;
 
+import com.google.gson.internal.JavaVersion;
+
 /**
  * Provides a replacement for {@link AccessibleObject#setAccessible(boolean)}, which may be used to
  * avoid reflective access issues appeared in Java 9, like {@link java.lang.reflect.InaccessibleObjectException}
@@ -33,7 +33,7 @@
 public abstract class ReflectionAccessor {
 
   // the singleton instance, use getInstance() to obtain
-  private static final ReflectionAccessor instance = VersionUtils.getMajorJavaVersion() < 9 ? new PreJava9ReflectionAccessor() : new UnsafeReflectionAccessor();
+  private static final ReflectionAccessor instance = JavaVersion.getMajorJavaVersion() < 9 ? new PreJava9ReflectionAccessor() : new UnsafeReflectionAccessor();
 
   /**
    * Does the same as {@code ao.setAccessible(true)}, but never throws

File: gson/src/test/java/com/google/gson/functional/ObjectTest.java
Patch:
@@ -33,6 +33,7 @@
 import com.google.gson.common.TestTypes.ClassWithTransientFields;
 import com.google.gson.common.TestTypes.Nested;
 import com.google.gson.common.TestTypes.PrimitiveArray;
+import com.google.gson.internal.JavaVersion;
 import com.google.gson.reflect.TypeToken;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -44,7 +45,6 @@
 import java.util.Map;
 import java.util.TimeZone;
 
-import com.google.gson.util.VersionUtils;
 import junit.framework.TestCase;
 
 /**
@@ -484,7 +484,7 @@ public void testSingletonLists() {
   public void testDateAsMapObjectField() {
     HasObjectMap a = new HasObjectMap();
     a.map.put("date", new Date(0));
-    if (VersionUtils.isJava9OrLater()) {
+    if (JavaVersion.isJava9OrLater()) {
       assertEquals("{\"map\":{\"date\":\"Dec 31, 1969, 4:00:00 PM\"}}", gson.toJson(a));
     } else {
       assertEquals("{\"map\":{\"date\":\"Dec 31, 1969 4:00:00 PM\"}}", gson.toJson(a));

File: gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
Patch:
@@ -40,13 +40,15 @@
 
 import com.google.gson.InstanceCreator;
 import com.google.gson.JsonIOException;
+import com.google.gson.internal.reflect.ReflectionAccessor;
 import com.google.gson.reflect.TypeToken;
 
 /**
  * Returns a function that can construct an instance of a requested type.
  */
 public final class ConstructorConstructor {
   private final Map<Type, InstanceCreator<?>> instanceCreators;
+  private final ReflectionAccessor accessor = ReflectionAccessor.getInstance();
 
   public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {
     this.instanceCreators = instanceCreators;
@@ -98,7 +100,7 @@ private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType)
     try {
       final Constructor<? super T> constructor = rawType.getDeclaredConstructor();
       if (!constructor.isAccessible()) {
-        constructor.setAccessible(true);
+        accessor.makeAccessible(constructor);
       }
       return new ObjectConstructor<T>() {
         @SuppressWarnings("unchecked") // T is the same raw type as is requested

File: gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
Patch:
@@ -28,6 +28,7 @@
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.ObjectConstructor;
 import com.google.gson.internal.Primitives;
+import com.google.gson.internal.reflect.ReflectionAccessor;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
@@ -49,6 +50,7 @@ public final class ReflectiveTypeAdapterFactory implements TypeAdapterFactory {
   private final FieldNamingStrategy fieldNamingPolicy;
   private final Excluder excluder;
   private final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;
+  private final ReflectionAccessor accessor = ReflectionAccessor.getInstance();
 
   public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,
       FieldNamingStrategy fieldNamingPolicy, Excluder excluder,
@@ -154,7 +156,7 @@ private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type,
         if (!serialize && !deserialize) {
           continue;
         }
-        field.setAccessible(true);
+        accessor.makeAccessible(field);
         Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());
         List<String> fieldNames = getFieldNames(field);
         BoundField previous = null;

File: gson/src/main/java/com/google/gson/reflect/package-info.java
Patch:
@@ -1,6 +1,6 @@
 /**
  * This package provides utility classes for finding type information for generic types.
- *  
+ *
  * @author Inderjeet Singh, Joel Leitch
  */
 package com.google.gson.reflect;
\ No newline at end of file

File: gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
Patch:
@@ -133,10 +133,11 @@ public Class read(JsonReader in) throws IOException {
   public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {
     @Override
     public Boolean read(JsonReader in) throws IOException {
-      if (in.peek() == JsonToken.NULL) {
+      JsonToken peek = in.peek();
+      if (peek == JsonToken.NULL) {
         in.nextNull();
         return null;
-      } else if (in.peek() == JsonToken.STRING) {
+      } else if (peek == JsonToken.STRING) {
         // support strings for compatibility with GSON 1.7
         return Boolean.parseBoolean(in.nextString());
       }

File: gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
Patch:
@@ -266,7 +266,7 @@ public static Date parse(String date, ParsePosition pos) throws ParseException {
         } catch (IllegalArgumentException e) {
             fail = e;
         }
-        String input = (date == null) ? null : ('"' + date + "'");
+        String input = (date == null) ? null : ('"' + date + '"');
         String msg = fail.getMessage();
         if (msg == null || msg.isEmpty()) {
             msg = "("+fail.getClass().getName()+")";

File: gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
Patch:
@@ -224,7 +224,7 @@ private <T> ObjectConstructor<T> newUnsafeAllocator(
           return (T) newInstance;
         } catch (Exception e) {
           throw new RuntimeException(("Unable to invoke no-args constructor for " + type + ". "
-              + "Register an InstanceCreator with Gson for this type may fix this problem."), e);
+              + "Registering an InstanceCreator with Gson for this type may fix this problem."), e);
         }
       }
     };

File: gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
Patch:
@@ -224,7 +224,7 @@ private <T> ObjectConstructor<T> newUnsafeAllocator(
           return (T) newInstance;
         } catch (Exception e) {
           throw new RuntimeException(("Unable to invoke no-args constructor for " + type + ". "
-              + "Register an InstanceCreator with Gson for this type may fix this problem."), e);
+              + "Registering an InstanceCreator with Gson for this type may fix this problem."), e);
         }
       }
     };

File: extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java
Patch:
@@ -229,7 +229,7 @@ private static Date parse(String date, ParsePosition pos) throws ParseException
     } catch (IllegalArgumentException e) {
       fail = e;
     }
-    String input = (date == null) ? null : ('"' + date + "'");
+    String input = (date == null) ? null : ("'" + date + "'");
     throw new ParseException("Failed to parse date [" + input + "]: " + fail.getMessage(), pos.getIndex());
   }
 

File: extras/src/test/java/com/google/gson/typeadapters/PostConstructAdapterFactoryTest.java
Patch:
@@ -22,7 +22,6 @@
 import com.google.gson.GsonBuilder;
 
 import junit.framework.TestCase;
-import org.junit.Assert;
 
 import java.util.Arrays;
 import java.util.List;
@@ -50,10 +49,10 @@ public void testList() {
 
         // Throws NullPointerException without the fix in https://github.com/google/gson/pull/1103
         String json = gson.toJson(sandwiches);
-        Assert.assertEquals("{\"sandwiches\":[{\"bread\":\"white\",\"cheese\":\"cheddar\"},{\"bread\":\"whole wheat\",\"cheese\":\"swiss\"}]}", json);
+        assertEquals("{\"sandwiches\":[{\"bread\":\"white\",\"cheese\":\"cheddar\"},{\"bread\":\"whole wheat\",\"cheese\":\"swiss\"}]}", json);
 
         MultipleSandwiches sandwichesFromJson = gson.fromJson(json, MultipleSandwiches.class);
-        Assert.assertEquals(sandwiches, sandwichesFromJson);
+        assertEquals(sandwiches, sandwichesFromJson);
     }
 
     static class Sandwich {

File: extras/src/main/java/com/google/gson/typeadapters/PostConstructAdapterFactory.java
Patch:
@@ -33,7 +33,7 @@ public class PostConstructAdapterFactory implements TypeAdapterFactory {
     // copied from https://gist.github.com/swankjesse/20df26adaf639ed7fd160f145a0b661a
     @Override
     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
-        for (Class<?> t = type.getRawType(); t != Object.class; t = t.getSuperclass()) {
+        for (Class<?> t = type.getRawType(); (t != Object.class) && (t.getSuperclass() != null); t = t.getSuperclass()) {
             for (Method m : t.getDeclaredMethods()) {
                 if (m.isAnnotationPresent(PostConstruct.class)) {
                     m.setAccessible(true);
@@ -73,4 +73,4 @@ public PostConstructAdapter(TypeAdapter<T> delegate, Method method) {
             delegate.write(out, value);
         }
     }
-}
\ No newline at end of file
+}

File: gson/src/main/java/com/google/gson/stream/JsonWriter.java
Patch:
@@ -491,10 +491,10 @@ public JsonWriter value(Boolean value) throws IOException {
    * @return this writer.
    */
   public JsonWriter value(double value) throws IOException {
-    if (Double.isNaN(value) || Double.isInfinite(value)) {
+    writeDeferredName();
+    if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {
       throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
     }
-    writeDeferredName();
     beforeValue();
     out.append(Double.toString(value));
     return this;

File: gson/src/main/java/com/google/gson/JsonObject.java
Patch:
@@ -136,6 +136,7 @@ public Set<Map.Entry<String, JsonElement>> entrySet() {
    * Returns a set of members key values.
    *
    * @return a set of member keys as Strings
+   * @since 2.8.1
    */
   public Set<String> keySet() {
     return members.keySet();

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -728,7 +728,7 @@ private int peekNumber() throws IOException {
     }
 
     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.
-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {
+    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {
       peekedLong = negative ? value : -value;
       pos += i;
       return peeked = PEEKED_LONG;

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -109,7 +109,7 @@ public final class Gson {
   static final boolean DEFAULT_COMPLEX_MAP_KEYS = false;
   static final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;
 
-  private static final TypeToken<?> NULL_KEY_SURROGATE = new TypeToken<Object>() {};
+  private static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);
   private static final String JSON_NON_EXECUTABLE_PREFIX = ")]}'\n";
 
   /**

File: gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
Patch:
@@ -158,7 +158,7 @@ private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type,
         Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());
         List<String> fieldNames = getFieldNames(field);
         BoundField previous = null;
-        for (int i = 0; i < fieldNames.size(); ++i) {
+        for (int i = 0, size = fieldNames.size(); i < size; ++i) {
           String name = fieldNames.get(i);
           if (i != 0) serialize = false; // only serialize the default name
           BoundField boundField = createBoundField(context, field, name,

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -981,7 +981,7 @@ public void setDelegate(TypeAdapter<T> typeAdapter) {
   public String toString() {
     return new StringBuilder("{serializeNulls:")
         .append(serializeNulls)
-        .append("factories:").append(factories)
+        .append(",factories:").append(factories)
         .append(",instanceCreators:").append(constructorConstructor)
         .append("}")
         .toString();

File: gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
Patch:
@@ -45,7 +45,7 @@ public final class RuntimeTypeAdapterFactoryFunctionalTest extends TestCase {
    * This test also ensures that {@link TypeAdapterFactory} registered through {@link JsonAdapter}
    * work correctly for {@link Gson#getDelegateAdapter(TypeAdapterFactory, TypeToken)}.
    */
-  public void testSubclassesAutomaticallySerialzed() throws Exception {
+  public void testSubclassesAutomaticallySerialized() throws Exception {
     Shape shape = new Circle(25);
     String json = gson.toJson(shape);
     shape = gson.fromJson(json, Shape.class);

File: extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
Patch:
@@ -111,7 +111,7 @@
  * Finally, register the type adapter factory in your application's GSON builder:
  * <pre>   {@code
  *   Gson gson = new GsonBuilder()
- *       .registerTypeAdapterFactory(Shape.class, shapeAdapterFactory)
+ *       .registerTypeAdapterFactory(shapeAdapterFactory)
  *       .create();
  * }</pre>
  * Like {@code GsonBuilder}, this API supports chaining: <pre>   {@code

File: extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
Patch:
@@ -111,7 +111,7 @@
  * Finally, register the type adapter factory in your application's GSON builder:
  * <pre>   {@code
  *   Gson gson = new GsonBuilder()
- *       .registerTypeAdapterFactory(Shape.class, shapeAdapterFactory)
+ *       .registerTypeAdapterFactory(shapeAdapterFactory)
  *       .create();
  * }</pre>
  * Like {@code GsonBuilder}, this API supports chaining: <pre>   {@code

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -719,7 +719,7 @@ public JsonWriter newJsonWriter(Writer writer) throws IOException {
   }
 
   /**
-   * Returns a new JSON writer configured for the settings on this Gson instance.
+   * Returns a new JSON reader configured for the settings on this Gson instance.
    */
   public JsonReader newJsonReader(Reader reader) {
     JsonReader jsonReader = new JsonReader(reader);

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -719,7 +719,7 @@ public JsonWriter newJsonWriter(Writer writer) throws IOException {
   }
 
   /**
-   * Returns a new JSON writer configured for the settings on this Gson instance.
+   * Returns a new JSON reader configured for the settings on this Gson instance.
    */
   public JsonReader newJsonReader(Reader reader) {
     JsonReader jsonReader = new JsonReader(reader);

File: gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
Patch:
@@ -20,12 +20,12 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.EnumSet;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
-import java.util.LinkedList;
 import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
@@ -163,7 +163,7 @@ private <T> ObjectConstructor<T> newDefaultImplementationConstructor(
       } else if (Queue.class.isAssignableFrom(rawType)) {
         return new ObjectConstructor<T>() {
           @Override public T construct() {
-            return (T) new LinkedList<Object>();
+            return (T) new ArrayDeque<Object>();
           }
         };
       } else {

File: gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
Patch:
@@ -20,12 +20,12 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.EnumSet;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
-import java.util.LinkedList;
 import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
@@ -163,7 +163,7 @@ private <T> ObjectConstructor<T> newDefaultImplementationConstructor(
       } else if (Queue.class.isAssignableFrom(rawType)) {
         return new ObjectConstructor<T>() {
           @Override public T construct() {
-            return (T) new LinkedList<Object>();
+            return (T) new ArrayDeque<Object>();
           }
         };
       } else {

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -679,7 +679,7 @@ public void toJson(JsonElement jsonElement, Appendable writer) throws JsonIOExce
       JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));
       toJson(jsonElement, jsonWriter);
     } catch (IOException e) {
-      throw new RuntimeException(e);
+      throw new JsonIOException(e);
     }
   }
 

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -679,7 +679,7 @@ public void toJson(JsonElement jsonElement, Appendable writer) throws JsonIOExce
       JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));
       toJson(jsonElement, jsonWriter);
     } catch (IOException e) {
-      throw new RuntimeException(e);
+      throw new JsonIOException(e);
     }
   }
 

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -428,9 +428,9 @@ public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {
    *  class StatsTypeAdapterFactory implements TypeAdapterFactory {
    *    public int numReads = 0;
    *    public int numWrites = 0;
-   *    public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; type) {
-   *      final TypeAdapter&lt;T&gt; delegate = gson.getDelegateAdapter(this, type);
-   *      return new TypeAdapter&lt;T&gt;() {
+   *    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
+   *      final TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);
+   *      return new TypeAdapter<T>() {
    *        public void write(JsonWriter out, T value) throws IOException {
    *          ++numWrites;
    *          delegate.write(out, value);

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -29,6 +29,7 @@
 
 import com.google.gson.internal.$Gson$Preconditions;
 import com.google.gson.internal.Excluder;
+import com.google.gson.internal.bind.TreeTypeAdapter;
 import com.google.gson.internal.bind.TypeAdapters;
 import com.google.gson.reflect.TypeToken;
 

File: gson/src/test/java/com/google/gson/stream/JsonReaderTest.java
Patch:
@@ -501,7 +501,7 @@ public void testPeekingUnquotedStringsPrefixedWithIntegers() throws IOException
     try {
       reader.nextInt();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (NumberFormatException expected) {
     }
     assertEquals("12.34e5x", reader.nextString());
   }

File: gson/src/main/java/com/google/gson/FieldAttributes.java
Patch:
@@ -68,7 +68,7 @@ public String getName() {
    *   private List&lt;String&gt; red;
    * }
    *
-   * Type listParmeterizedType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();
+   * Type listParameterizedType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();
    * </pre>
    *
    * <p>This method would return {@code String.class} for the {@code bar} field and

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -78,7 +78,7 @@
  * <p>If the object that your are serializing/deserializing is a {@code ParameterizedType}
  * (i.e. contains at least one type parameter and may be an array) then you must use the
  * {@link #toJson(Object, Type)} or {@link #fromJson(String, Type)} method.  Here is an
- * example for serializing and deserialing a {@code ParameterizedType}:
+ * example for serializing and deserializing a {@code ParameterizedType}:
  *
  * <pre>
  * Type listType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -303,7 +303,7 @@ public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrateg
    * Configures Gson to apply a set of exclusion strategies during both serialization and
    * deserialization. Each of the {@code strategies} will be applied as a disjunction rule.
    * This means that if one of the {@code strategies} suggests that a field (or class) should be
-   * skipped then that field (or object) is skipped during serializaiton/deserialization.
+   * skipped then that field (or object) is skipped during serialization/deserialization.
    *
    * @param strategies the set of strategy object to apply during object (de)serialization.
    * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern

File: gson/src/test/java/com/google/gson/ParameterizedTypeTest.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.List;
 
 /**
- * Unit tests for {@code ParamterizedType}s created by the {@link $Gson$Types} class.
+ * Unit tests for {@code ParameterizedType}s created by the {@link $Gson$Types} class.
  *
  * @author Inderjeet Singh
  * @author Joel Leitch

File: gson/src/test/java/com/google/gson/functional/SerializedNameTest.java
Patch:
@@ -25,7 +25,7 @@ public final class SerializedNameTest extends TestCase {
 
   public void testFirstNameIsChosenForSerialization() {
     MyClass target = new MyClass("v1", "v2");
-    // Ensure name1 occurs exactly once, and name2 and name3 dont appear
+    // Ensure name1 occurs exactly once, and name2 and name3 don't appear
     assertEquals("{\"name\":\"v1\",\"name1\":\"v2\"}", gson.toJson(target));
   }
 

File: gson/src/main/java/com/google/gson/FieldAttributes.java
Patch:
@@ -68,7 +68,7 @@ public String getName() {
    *   private List&lt;String&gt; red;
    * }
    *
-   * Type listParmeterizedType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();
+   * Type listParameterizedType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();
    * </pre>
    *
    * <p>This method would return {@code String.class} for the {@code bar} field and

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -78,7 +78,7 @@
  * <p>If the object that your are serializing/deserializing is a {@code ParameterizedType}
  * (i.e. contains at least one type parameter and may be an array) then you must use the
  * {@link #toJson(Object, Type)} or {@link #fromJson(String, Type)} method.  Here is an
- * example for serializing and deserialing a {@code ParameterizedType}:
+ * example for serializing and deserializing a {@code ParameterizedType}:
  *
  * <pre>
  * Type listType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -303,7 +303,7 @@ public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrateg
    * Configures Gson to apply a set of exclusion strategies during both serialization and
    * deserialization. Each of the {@code strategies} will be applied as a disjunction rule.
    * This means that if one of the {@code strategies} suggests that a field (or class) should be
-   * skipped then that field (or object) is skipped during serializaiton/deserialization.
+   * skipped then that field (or object) is skipped during serialization/deserialization.
    *
    * @param strategies the set of strategy object to apply during object (de)serialization.
    * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern

File: gson/src/test/java/com/google/gson/ParameterizedTypeTest.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.List;
 
 /**
- * Unit tests for {@code ParamterizedType}s created by the {@link $Gson$Types} class.
+ * Unit tests for {@code ParameterizedType}s created by the {@link $Gson$Types} class.
  *
  * @author Inderjeet Singh
  * @author Joel Leitch

File: gson/src/test/java/com/google/gson/functional/SerializedNameTest.java
Patch:
@@ -25,7 +25,7 @@ public final class SerializedNameTest extends TestCase {
 
   public void testFirstNameIsChosenForSerialization() {
     MyClass target = new MyClass("v1", "v2");
-    // Ensure name1 occurs exactly once, and name2 and name3 dont appear
+    // Ensure name1 occurs exactly once, and name2 and name3 don't appear
     assertEquals("{\"name\":\"v1\",\"name1\":\"v2\"}", gson.toJson(target));
   }
 

File: examples/android-proguard-example/src/com/google/gson/examples/android/model/LineItem.java
Patch:
@@ -52,6 +52,6 @@ public String getCurrencyCode() {
   @Override
   public String toString() {
     return String.format("(item: %s, qty: %s, price: %.2f %s)",
-        name, quantity, priceInMicros/(double)1000000, currencyCode);
+        name, quantity, priceInMicros / 1000000d, currencyCode);
   }
 }

File: examples/android-proguard-example/src/com/google/gson/examples/android/model/LineItem.java
Patch:
@@ -52,6 +52,6 @@ public String getCurrencyCode() {
   @Override
   public String toString() {
     return String.format("(item: %s, qty: %s, price: %.2f %s)",
-        name, quantity, priceInMicros/(double)1000000, currencyCode);
+        name, quantity, priceInMicros / 1000000d, currencyCode);
   }
 }

File: gson/src/main/java/com/google/gson/JsonArray.java
Patch:
@@ -162,7 +162,7 @@ public int size() {
   }
 
   /**
-   * Returns an iterator to navigate the elemetns of the array. Since the array is an ordered list,
+   * Returns an iterator to navigate the elements of the array. Since the array is an ordered list,
    * the iterator navigates the elements in the order they were inserted.
    *
    * @return an iterator to navigate the elements of the array.

File: gson/src/main/java/com/google/gson/JsonArray.java
Patch:
@@ -162,7 +162,7 @@ public int size() {
   }
 
   /**
-   * Returns an iterator to navigate the elemetns of the array. Since the array is an ordered list,
+   * Returns an iterator to navigate the elements of the array. Since the array is an ordered list,
    * the iterator navigates the elements in the order they were inserted.
    *
    * @return an iterator to navigate the elements of the array.

File: gson/src/main/java/com/google/gson/internal/Excluder.java
Patch:
@@ -62,7 +62,7 @@ public final class Excluder implements TypeAdapterFactory, Cloneable {
     try {
       return (Excluder) super.clone();
     } catch (CloneNotSupportedException e) {
-      throw new AssertionError();
+      throw new AssertionError(e);
     }
   }
 

File: gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
Patch:
@@ -241,7 +241,7 @@ private Adapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundF
           }
         }
       } catch (IllegalAccessException e) {
-        throw new AssertionError();
+        throw new AssertionError(e);
       }
       out.endObject();
     }

File: gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
Patch:
@@ -796,7 +796,7 @@ public EnumTypeAdapter(Class<T> classOfT) {
           constantToName.put(constant, name);
         }
       } catch (NoSuchFieldException e) {
-        throw new AssertionError();
+        throw new AssertionError("Missing field in " + classOfT.getName(), e);
       }
     }
     @Override public T read(JsonReader in) throws IOException {

File: gson/src/test/java/com/google/gson/functional/JavaUtilConcurrentAtomicTest.java
Patch:
@@ -31,7 +31,7 @@
 /**
  * Functional test for Json serialization and deserialization for classes in java.util.concurrent.atomic
  */
-public class JavaUtilConcurrentLocksTest extends TestCase {
+public class JavaUtilConcurrentAtomicTest extends TestCase {
   private Gson gson;
 
   @Override

File: gson/src/test/java/com/google/gson/functional/JavaUtilConcurrentLocksTest.java
Patch:
@@ -29,7 +29,7 @@
 import junit.framework.TestCase;
 
 /**
- * Functional test for Json serialization and deserialization for java.util.concurrent.locks classes
+ * Functional test for Json serialization and deserialization for classes in java.util.concurrent.atomic
  */
 public class JavaUtilConcurrentLocksTest extends TestCase {
   private Gson gson;

File: gson/src/main/java/com/google/gson/stream/JsonWriter.java
Patch:
@@ -77,7 +77,7 @@
  * This code encodes the above structure: <pre>   {@code
  *   public void writeJsonStream(OutputStream out, List<Message> messages) throws IOException {
  *     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, "UTF-8"));
- *     writer.setIndentSpaces(4);
+ *     writer.setIndent("    ");
  *     writeMessagesArray(writer, messages);
  *     writer.close();
  *   }

File: gson/src/main/java/com/google/gson/stream/JsonWriter.java
Patch:
@@ -77,7 +77,7 @@
  * This code encodes the above structure: <pre>   {@code
  *   public void writeJsonStream(OutputStream out, List<Message> messages) throws IOException {
  *     JsonWriter writer = new JsonWriter(new OutputStreamWriter(out, "UTF-8"));
- *     writer.setIndentSpaces(4);
+ *     writer.setIndent("    ");
  *     writeMessagesArray(writer, messages);
  *     writer.close();
  *   }

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -31,8 +31,6 @@
 import java.util.List;
 import java.util.Map;
 
-import javax.annotation.concurrent.ThreadSafe;
-
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.Primitives;
@@ -98,7 +96,6 @@
  * @author Joel Leitch
  * @author Jesse Wilson
  */
-@ThreadSafe
 public final class Gson {
   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;
 

File: gson/src/main/java/com/google/gson/FieldNamingPolicy.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.gson;
 
 import java.lang.reflect.Field;
+import java.util.Locale;
 
 /**
  * An enumeration that defines a few standard naming conventions for JSON field names.
@@ -88,7 +89,7 @@ public String translateName(Field f) {
    */
   LOWER_CASE_WITH_UNDERSCORES() {
     public String translateName(Field f) {
-      return separateCamelCase(f.getName(), "_").toLowerCase();
+      return separateCamelCase(f.getName(), "_").toLowerCase(Locale.ENGLISH);
     }
   },
 
@@ -111,7 +112,7 @@ public String translateName(Field f) {
    */
   LOWER_CASE_WITH_DASHES() {
     public String translateName(Field f) {
-      return separateCamelCase(f.getName(), "-").toLowerCase();
+      return separateCamelCase(f.getName(), "-").toLowerCase(Locale.ENGLISH);
     }
   };
 

File: extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
Patch:
@@ -235,6 +235,6 @@ public <R> TypeAdapter<R> create(Gson gson, TypeToken<R> type) {
         }
         Streams.write(clone, out);
       }
-    };
+    }.nullSafe();
   }
 }

File: extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
Patch:
@@ -235,6 +235,6 @@ public <R> TypeAdapter<R> create(Gson gson, TypeToken<R> type) {
         }
         Streams.write(clone, out);
       }
-    };
+    }.nullSafe();
   }
 }

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -31,6 +31,8 @@
 import java.util.List;
 import java.util.Map;
 
+import javax.annotation.concurrent.ThreadSafe;
+
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.Primitives;
@@ -96,6 +98,7 @@
  * @author Joel Leitch
  * @author Jesse Wilson
  */
+@ThreadSafe
 public final class Gson {
   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;
 

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -31,6 +31,8 @@
 import java.util.List;
 import java.util.Map;
 
+import javax.annotation.concurrent.ThreadSafe;
+
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.Excluder;
 import com.google.gson.internal.Primitives;
@@ -96,6 +98,7 @@
  * @author Joel Leitch
  * @author Jesse Wilson
  */
+@ThreadSafe
 public final class Gson {
   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;
 

File: gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java
Patch:
@@ -55,6 +55,7 @@ public void testSubclassesAutomaticallySerialzed() throws Exception {
     json = gson.toJson(shape);
     shape = gson.fromJson(json, Shape.class);
     assertEquals(15, ((Square)shape).side);
+    assertEquals(ShapeType.SQUARE, shape.type);
   }
 
   @JsonAdapter(Shape.JsonAdapterFactory.class)
@@ -163,7 +164,7 @@ public <R> TypeAdapter<R> create(Gson gson, TypeToken<R> type) {
       return new TypeAdapter<R>() {
         @Override public R read(JsonReader in) throws IOException {
           JsonElement jsonElement = Streams.parse(in);
-          JsonElement labelJsonElement = jsonElement.getAsJsonObject().remove(typeFieldName);
+          JsonElement labelJsonElement = jsonElement.getAsJsonObject().get(typeFieldName);
           if (labelJsonElement == null) {
             throw new JsonParseException("cannot deserialize " + baseType
                 + " because it does not define a field named " + typeFieldName);

File: gson/src/test/java/com/google/gson/functional/ThrowableFunctionalTest.java
Patch:
@@ -24,7 +24,7 @@ public void testExceptionWithoutCause() {
   public void testExceptionWithCause() {
     Exception e = new Exception("top level", new IOException("io error"));
     String json = gson.toJson(e);
-    assertEquals("{\"detailMessage\":\"top level\",\"cause\":{\"detailMessage\":\"io error\"}}", json);
+    assertTrue(json.contains("{\"detailMessage\":\"top level\",\"cause\":{\"detailMessage\":\"io error\""));
 
     e = gson.fromJson("{'detailMessage':'top level','cause':{'detailMessage':'io error'}}", Exception.class);
     assertEquals("top level", e.getMessage());
@@ -35,7 +35,7 @@ public void testExceptionWithCause() {
   public void testSerializedNameOnExceptionFields() {
     MyException e = new MyException();
     String json = gson.toJson(e);
-    assertEquals("{\"my_custom_name\":\"myCustomMessageValue\"}", json);
+    assertTrue(json.contains("{\"my_custom_name\":\"myCustomMessageValue\""));
   }
 
   public void testErrorWithoutCause() {

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -23,6 +23,7 @@
 import com.google.gson.internal.bind.ArrayTypeAdapter;
 import com.google.gson.internal.bind.CollectionTypeAdapterFactory;
 import com.google.gson.internal.bind.DateTypeAdapter;
+import com.google.gson.internal.bind.ThrowableTypeAdapterFactory;
 import com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory;
 import com.google.gson.internal.bind.JsonTreeReader;
 import com.google.gson.internal.bind.JsonTreeWriter;
@@ -239,6 +240,7 @@ public Gson() {
     factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));
     factories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));
     factories.add(TypeAdapters.ENUM_FACTORY);
+    factories.add(new ThrowableTypeAdapterFactory(fieldNamingPolicy, excluder));
     factories.add(new ReflectiveTypeAdapterFactory(
         constructorConstructor, fieldNamingPolicy, excluder));
 

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -363,6 +363,7 @@ public void endArray() throws IOException {
     }
     if (p == PEEKED_END_ARRAY) {
       stackSize--;
+      pathIndices[stackSize - 1]++;
       peeked = PEEKED_NONE;
     } else {
       throw new IllegalStateException("Expected END_ARRAY but was " + peek()
@@ -400,6 +401,7 @@ public void endObject() throws IOException {
     if (p == PEEKED_END_OBJECT) {
       stackSize--;
       pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!
+      pathIndices[stackSize - 1]++;
       peeked = PEEKED_NONE;
     } else {
       throw new IllegalStateException("Expected END_OBJECT but was " + peek()

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -232,13 +232,13 @@ public Gson() {
     factories.add(SqlDateTypeAdapter.FACTORY);
     factories.add(TypeAdapters.TIMESTAMP_FACTORY);
     factories.add(ArrayTypeAdapter.FACTORY);
-    factories.add(TypeAdapters.ENUM_FACTORY);
     factories.add(TypeAdapters.CLASS_FACTORY);
 
     // type adapters for composite and user-defined types
     factories.add(new CollectionTypeAdapterFactory(constructorConstructor));
     factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));
     factories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));
+    factories.add(TypeAdapters.ENUM_FACTORY);
     factories.add(new ReflectiveTypeAdapterFactory(
         constructorConstructor, fieldNamingPolicy, excluder));
 
@@ -410,7 +410,7 @@ public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {
    *  }</pre>
    *  Note that since you can not override type adapter factories for String and Java primitive
    *  types, our stats factory will not count the number of String or primitives that will be
-   *  read or written. 
+   *  read or written.
    * @param skipPast The type adapter factory that needs to be skipped while searching for
    *   a matching type adapter. In most cases, you should just pass <i>this</i> (the type adapter
    *   factory from where {@link #getDelegateAdapter} method is being invoked).

File: gson/src/main/java/com/google/gson/TypeAdapterFactory.java
Patch:
@@ -28,7 +28,7 @@
  * that they're defined in {@code CONSTANT_CASE} in the corresponding Java
  * model: <pre>   {@code
  *
- *   public class LowercaseEnumTypeAdapterFactory implements TypeAdapter.Factory {
+ *   public class LowercaseEnumTypeAdapterFactory implements TypeAdapterFactory {
  *     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
  *       Class<T> rawType = (Class<T>) type.getRawType();
  *       if (!rawType.isEnum()) {
@@ -102,7 +102,7 @@
  * multiset's type token. A {@code Gson} is passed in to {@code create} for
  * just this purpose: <pre>   {@code
  *
- *   public class MultisetTypeAdapterFactory implements TypeAdapter.Factory {
+ *   public class MultisetTypeAdapterFactory implements TypeAdapterFactory {
  *     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
  *       Type type = typeToken.getType();
  *       if (typeToken.getRawType() != Multiset.class

File: gson/src/main/java/com/google/gson/ExclusionStrategy.java
Patch:
@@ -19,9 +19,9 @@
 /**
  * A strategy (or policy) definition that is used to decide whether or not a field or top-level
  * class should be serialized or deserialized as part of the JSON output/input. For serialization,
- * if the {@link #shouldSkipClass(Class)} method returns false then that class or field type
+ * if the {@link #shouldSkipClass(Class)} method returns true then that class or field type
  * will not be part of the JSON output.  For deserialization, if {@link #shouldSkipClass(Class)}
- * returns false, then it will not be set as part of the Java object structure.
+ * returns true, then it will not be set as part of the Java object structure.
  *
  * <p>The following are a few examples that shows how you can use this exclusion mechanism.
  *

File: gson/src/main/java/com/google/gson/internal/LinkedHashTreeMap.java
Patch:
@@ -788,7 +788,7 @@ public final void remove() {
     }
   }
 
-  class EntrySet extends AbstractSet<Entry<K, V>> {
+  final class EntrySet extends AbstractSet<Entry<K, V>> {
     @Override public int size() {
       return size;
     }
@@ -823,7 +823,7 @@ public Entry<K, V> next() {
     }
   }
 
-  class KeySet extends AbstractSet<K> {
+  final class KeySet extends AbstractSet<K> {
     @Override public int size() {
       return size;
     }

File: gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java
Patch:
@@ -589,7 +589,7 @@ public Entry<K, V> next() {
     }
   }
 
-  class KeySet extends AbstractSet<K> {
+  final class KeySet extends AbstractSet<K> {
     @Override public int size() {
       return size;
     }

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -174,7 +174,7 @@ public JsonElement serialize(Object src, Type typeOfSrc) {
    *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You
    *   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>
    *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class
-   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber@quot;</code> in
+   *   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in
    *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can
    *   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>
    *   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -23,7 +23,6 @@
 import com.google.gson.internal.bind.ArrayTypeAdapter;
 import com.google.gson.internal.bind.CollectionTypeAdapterFactory;
 import com.google.gson.internal.bind.DateTypeAdapter;
-import com.google.gson.internal.bind.FieldTypeAdapterFactory;
 import com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory;
 import com.google.gson.internal.bind.JsonTreeReader;
 import com.google.gson.internal.bind.JsonTreeWriter;
@@ -240,7 +239,6 @@ public Gson() {
     factories.add(new CollectionTypeAdapterFactory(constructorConstructor));
     factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));
     factories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));
-    factories.add(new FieldTypeAdapterFactory());
     factories.add(new ReflectiveTypeAdapterFactory(
         constructorConstructor, fieldNamingPolicy, excluder));
 

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -24,6 +24,7 @@
 import com.google.gson.internal.bind.CollectionTypeAdapterFactory;
 import com.google.gson.internal.bind.DateTypeAdapter;
 import com.google.gson.internal.bind.FieldTypeAdapterFactory;
+import com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory;
 import com.google.gson.internal.bind.JsonTreeReader;
 import com.google.gson.internal.bind.JsonTreeWriter;
 import com.google.gson.internal.bind.MapTypeAdapterFactory;
@@ -238,6 +239,7 @@ public Gson() {
     // type adapters for composite and user-defined types
     factories.add(new CollectionTypeAdapterFactory(constructorConstructor));
     factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));
+    factories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));
     factories.add(new FieldTypeAdapterFactory());
     factories.add(new ReflectiveTypeAdapterFactory(
         constructorConstructor, fieldNamingPolicy, excluder));

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -23,6 +23,7 @@
 import com.google.gson.internal.bind.ArrayTypeAdapter;
 import com.google.gson.internal.bind.CollectionTypeAdapterFactory;
 import com.google.gson.internal.bind.DateTypeAdapter;
+import com.google.gson.internal.bind.FieldTypeAdapterFactory;
 import com.google.gson.internal.bind.JsonTreeReader;
 import com.google.gson.internal.bind.JsonTreeWriter;
 import com.google.gson.internal.bind.MapTypeAdapterFactory;
@@ -237,6 +238,7 @@ public Gson() {
     // type adapters for composite and user-defined types
     factories.add(new CollectionTypeAdapterFactory(constructorConstructor));
     factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));
+    factories.add(new FieldTypeAdapterFactory());
     factories.add(new ReflectiveTypeAdapterFactory(
         constructorConstructor, fieldNamingPolicy, excluder));
 

File: gson/src/test/java/com/google/gson/internal/LinkedHashTreeMapTest.java
Patch:
@@ -65,6 +65,7 @@ public void testPutNonComparableKeyFails() {
     LinkedHashTreeMap<Object, String> map = new LinkedHashTreeMap<Object, String>();
     try {
       map.put(new Object(), "android");
+      fail();
     } catch (ClassCastException expected) {}
   }
 

File: gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
Patch:
@@ -85,8 +85,9 @@ private ObjectTypeAdapter(Gson gson) {
       in.nextNull();
       return null;
 
+    default:
+      throw new IllegalStateException();
     }
-    throw new IllegalStateException();
   }
 
   @SuppressWarnings("unchecked")

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -295,7 +295,7 @@ private void checkValidFloatingPoint(double value) {
     if (Double.isNaN(value) || Double.isInfinite(value)) {
       throw new IllegalArgumentException(value
           + " is not a valid double value as per JSON specification. To override this"
-          + " behavior, use GsonBuilder.serializeSpecialDoubleValues() method.");
+          + " behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.");
     }
   }
 

File: gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
Patch:
@@ -703,7 +703,7 @@ public void write(JsonWriter out, Locale value) throws IOException {
   };
 
   public static final TypeAdapterFactory JSON_ELEMENT_FACTORY
-      = newFactory(JsonElement.class, JSON_ELEMENT);
+      = newTypeHierarchyFactory(JsonElement.class, JSON_ELEMENT);
 
   private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {
     private final Map<String, T> nameToConstant = new HashMap<String, T>();

File: extras/src/main/java/com/google/gson/interceptors/Intercept.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson.internal.alpha;
+package com.google.gson.interceptors;
 
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;

File: extras/src/main/java/com/google/gson/interceptors/JsonPostDeserializer.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.internal.alpha;
+package com.google.gson.interceptors;
 
 import com.google.gson.InstanceCreator;
 

File: gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
Patch:
@@ -72,7 +72,6 @@ public Object read(JsonReader in) throws IOException {
     in.beginArray();
     while (in.hasNext()) {
       E instance = componentTypeAdapter.read(in);
-      Gson.$Internal$Access.invokeInterceptor(context, instance, componentType);
       list.add(instance);
     }
     in.endArray();

File: gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
Patch:
@@ -83,7 +83,6 @@ public Collection<E> read(JsonReader in) throws IOException {
       in.beginArray();
       while (in.hasNext()) {
         E instance = elementTypeAdapter.read(in);
-        Gson.$Internal$Access.invokeInterceptor(context, instance, elementType);
         collection.add(instance);
       }
       in.endArray();

File: gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
Patch:
@@ -91,7 +91,6 @@ private ReflectiveTypeAdapterFactory.BoundField createBoundField(
       @Override void read(JsonReader reader, Object value)
           throws IOException, IllegalAccessException {
         Object fieldValue = typeAdapter.read(reader);
-        Gson.$Internal$Access.invokeInterceptor(context, fieldValue, fieldType.getRawType());
         if (fieldValue != null || !isPrimitive) {
           field.set(value, fieldValue);
         }

File: gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
Patch:
@@ -91,6 +91,7 @@ private ReflectiveTypeAdapterFactory.BoundField createBoundField(
       @Override void read(JsonReader reader, Object value)
           throws IOException, IllegalAccessException {
         Object fieldValue = typeAdapter.read(reader);
+        Gson.$Internal$Access.invokeInterceptor(context, fieldValue, fieldType.getRawType());
         if (fieldValue != null || !isPrimitive) {
           field.set(value, fieldValue);
         }

File: gson/src/main/java/com/google/gson/stream/JsonToken.java
Patch:
@@ -25,8 +25,8 @@
 public enum JsonToken {
 
   /**
-   * The opening of a JSON array. Written using {@link JsonWriter#beginObject}
-   * and read using {@link JsonReader#beginObject}.
+   * The opening of a JSON array. Written using {@link JsonWriter#beginArray}
+   * and read using {@link JsonReader#beginArray}.
    */
   BEGIN_ARRAY,
 

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -1253,6 +1253,7 @@ private boolean fillBuffer(int minimum) throws IOException {
       if (bufferStartLine == 1 && bufferStartColumn == 1 && limit > 0 && buffer[0] == '\ufeff') {
         pos++;
         bufferStartColumn--;
+        minimum++;
       }
 
       if (limit >= minimum) {

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -648,7 +648,7 @@ private int peekNumber() throws IOException {
       c = get(++i);
       while (c >= '0' && c <= '9') {
         long newInteger = integer * 10 - (c - '0');
-        fitsInLong = integer > MIN_INCOMPLETE_INTEGER
+        fitsInLong &= integer > MIN_INCOMPLETE_INTEGER
             || (integer == MIN_INCOMPLETE_INTEGER && newInteger < integer);
         integer = newInteger;
         c = get(++i);

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -190,6 +190,7 @@
 public class JsonReader implements Closeable {
   /** The only non-execute prefix this parser permits */
   private static final char[] NON_EXECUTE_PREFIX = ")]}'\n".toCharArray();
+  private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;
 
   private static final int PEEKED_NONE = 0;
   private static final int PEEKED_BEGIN_OBJECT = 1;
@@ -647,7 +648,8 @@ private int peekNumber() throws IOException {
       c = get(++i);
       while (c >= '0' && c <= '9') {
         long newInteger = integer * 10 - (c - '0');
-        fitsInLong &= newInteger < integer;
+        fitsInLong = integer > MIN_INCOMPLETE_INTEGER
+            || (integer == MIN_INCOMPLETE_INTEGER && newInteger < integer);
         integer = newInteger;
         c = get(++i);
       }

File: extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java
Patch:
@@ -36,7 +36,7 @@ public String toString() {
     }
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({ "unchecked", "rawtypes" })
   public static void main(String[] args) {
     Gson gson = new Gson();
     Collection collection = new ArrayList();

File: extras/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java
Patch:
@@ -40,6 +40,7 @@
  * Writes a graph of objects as a list of named nodes.
  */
 // TODO: proper documentation
+@SuppressWarnings("rawtypes")
 public final class GraphAdapterBuilder {
   private final ConstructorConstructor constructorConstructor = new ConstructorConstructor();
   private final Map<Type, InstanceCreator<?>> instanceCreators
@@ -207,6 +208,7 @@ public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
      * <p>Gson should only ever call this method when we're expecting it to;
      * that is only when we've called back into Gson to deserialize a tree.
      */
+    @SuppressWarnings("unchecked")
     public Object createInstance(Type type) {
       Graph graph = graphThreadLocal.get();
       if (graph == null || graph.nextCreate == null) {

File: gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
Patch:
@@ -216,6 +216,7 @@ public JsonElement serialize(Boolean s, Type t, JsonSerializationContext c) {
     assertEquals("true", gson.toJson(true, Boolean.class));
   }
 
+  @SuppressWarnings("rawtypes")
   public void testCustomDeserializerInvokedForPrimitives() {
     Gson gson = new GsonBuilder()
         .registerTypeAdapter(boolean.class, new JsonDeserializer() {

File: gson/src/main/java/com/google/gson/internal/Streams.java
Patch:
@@ -50,6 +50,9 @@ public static JsonElement parse(JsonReader reader) throws JsonParseException {
       if (isEmpty) {
         return JsonNull.INSTANCE;
       }
+      // We could possibly throw JsonSyntaxException since the stream prematurely ended.
+      // However, it seems safe to throw JsonIOException since the source is an IOException.
+      // Another reason is to maintain backward compatibility.
       throw new JsonIOException(e);
     } catch (MalformedJsonException e) {
       throw new JsonSyntaxException(e);

File: gson/src/main/java/com/google/gson/TreeTypeAdapter.java
Patch:
@@ -75,7 +75,7 @@ private TypeAdapter<T> delegate() {
     TypeAdapter<T> d = delegate;
     return d != null
         ? d
-        : (delegate = gson.getNextAdapter(skipPast, typeToken));
+        : (delegate = gson.getDelegateAdapter(skipPast, typeToken));
   }
 
   /**

File: gson/src/main/java/com/google/gson/internal/Excluder.java
Patch:
@@ -141,7 +141,7 @@ private TypeAdapter<T> delegate() {
         TypeAdapter<T> d = delegate;
         return d != null
             ? d
-            : (delegate = gson.getNextAdapter(Excluder.this, type));
+            : (delegate = gson.getDelegateAdapter(Excluder.this, type));
       }
     };
   }

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -446,7 +446,7 @@ public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {
         || typeAdapter instanceof JsonDeserializer<?>
         || typeAdapter instanceof InstanceCreator<?>
         || typeAdapter instanceof TypeAdapter<?>);
-    if (Primitives.isPrimitive(type) || Primitives.isWrapperType(type)) {
+    if (Primitives.isPrimitive(type) || Primitives.isWrapperType(type) || type == String.class) {
       throw new IllegalArgumentException(
           "Cannot register type adapters for " + type);
     }
@@ -485,7 +485,7 @@ public GsonBuilder registerTypeAdapterFactory(TypeAdapterFactory factory) {
    *
    * @param baseType the class definition for the type adapter being registered for the base class
    *        or interface
-   * @param typeAdapter This object must implement at least one of {@link TypeAdapter}, 
+   * @param typeAdapter This object must implement at least one of {@link TypeAdapter},
    *        {@link JsonSerializer} or {@link JsonDeserializer} interfaces.
    * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
    * @since 1.7

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -324,7 +324,7 @@ public void beginObject() throws IOException {
 
   /**
    * Consumes the next token from the JSON stream and asserts that it is the
-   * end of the current array.
+   * end of the current object.
    */
   public void endObject() throws IOException {
     expect(JsonToken.END_OBJECT);

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -211,15 +211,15 @@ public Gson() {
     factories.add(TypeAdapters.CHARACTER_FACTORY);
     factories.add(TypeAdapters.STRING_BUILDER_FACTORY);
     factories.add(TypeAdapters.STRING_BUFFER_FACTORY);
-    factories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));
-    factories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));
     factories.add(TypeAdapters.JSON_ELEMENT_FACTORY);
     factories.add(ObjectTypeAdapter.FACTORY);
 
     // user's type adapters
     factories.addAll(typeAdapterFactories);
 
     // built-in type adapters that can be overridden
+    factories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));
+    factories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));
     factories.add(new CollectionTypeAdapterFactory(constructorConstructor));
     factories.add(TypeAdapters.URL_FACTORY);
     factories.add(TypeAdapters.URI_FACTORY);

File: gson/src/main/java/com/google/gson/internal/StringMap.java
Patch:
@@ -59,6 +59,7 @@ public final class StringMap<V> extends AbstractMap<String, V> {
    * is set to half the minimum, so that the first resize will create a
    * minimum-sized table.
    */
+  @SuppressWarnings("rawtypes")
   private static final Entry[] EMPTY_TABLE = new LinkedEntry[MINIMUM_CAPACITY >>> 1];
 
   /**

File: gson/src/test/java/com/google/gson/GsonBuilderTest.java
Patch:
@@ -39,6 +39,7 @@ public void testExcludeFieldsWithModifiers() {
     assertEquals("{\"d\":\"d\"}", gson.toJson(new HasModifiers()));
   }
 
+  @SuppressWarnings("unused")
   static class HasModifiers {
     private String a = "a";
     volatile String b = "b";

File: gson/src/test/java/com/google/gson/functional/InstanceCreatorTest.java
Patch:
@@ -85,6 +85,7 @@ public Base createInstance(Type type) {
 
   // This regressed in Gson 2.0 and 2.1
   public void testInstanceCreatorForCollectionType() {
+    @SuppressWarnings("serial")
     class SubArrayList<T> extends ArrayList<T> {}
     InstanceCreator<List<String>> listCreator = new InstanceCreator<List<String>>() {
       public List<String> createInstance(Type type) {

File: gson/src/main/java/com/google/gson/TypeAdapter.java
Patch:
@@ -227,7 +227,6 @@ public final String toJson(T value) throws IOException {
   public final JsonElement toJsonTree(T value) {
     try {
       JsonTreeWriter jsonWriter = new JsonTreeWriter();
-      jsonWriter.setLenient(true);
       write(jsonWriter, value);
       return jsonWriter.get();
     } catch (IOException e) {
@@ -254,7 +253,6 @@ public final JsonElement toJsonTree(T value) {
    */
   public final T fromJson(Reader in) throws IOException {
     JsonReader reader = new JsonReader(in);
-    reader.setLenient(true); // TODO: non-lenient?
     return read(reader);
   }
 
@@ -280,7 +278,6 @@ public final T fromJson(String json) throws IOException {
   public final T fromJsonTree(JsonElement jsonTree) {
     try {
       JsonReader jsonReader = new JsonTreeReader(jsonTree);
-      jsonReader.setLenient(true);
       return read(jsonReader);
     } catch (IOException e) {
       throw new JsonIOException(e);

File: gson/src/test/java/com/google/gson/ObjectTypeAdapterTest.java
Patch:
@@ -26,7 +26,7 @@ public final class ObjectTypeAdapterTest extends TestCase {
   private final TypeAdapter<Object> adapter = gson.getAdapter(Object.class);
 
   public void testDeserialize() throws Exception {
-    Map<?, ?> map = (Map<?, ?>) adapter.fromJson("{a: 5, b: [1, 2, null], c: {x: y}}");
+    Map<?, ?> map = (Map<?, ?>) adapter.fromJson("{\"a\":5,\"b\":[1,2,null],\"c\":{\"x\":\"y\"}}");
     assertEquals(5.0, map.get("a"));
     assertEquals(Arrays.asList(1.0, 2.0, null), map.get("b"));
     assertEquals(Collections.singletonMap("x", "y"), map.get("c"));

File: gson/src/main/java/com/google/gson/TreeTypeAdapter.java
Patch:
@@ -76,7 +76,7 @@ private TypeAdapter<T> delegate() {
     TypeAdapter<T> d = delegate;
     return d != null
         ? d
-        : (delegate = GsonInternalAccess.INSTANCE.getNextAdapter(gson, skipPast, typeToken));
+        : (delegate = gson.getNextAdapter(skipPast, typeToken));
   }
 
   /**

File: extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
Patch:
@@ -25,7 +25,7 @@
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
 import com.google.gson.internal.Streams;
-import com.google.gson.internal.bind.JsonElementWriter;
+import com.google.gson.internal.bind.JsonTreeWriter;
 import com.google.gson.internal.bind.JsonTreeReader;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
@@ -252,7 +252,7 @@ private T fromJsonTree(TypeAdapter<T> delegate, JsonElement jsonTree) {
       // TODO: remove this when TypeAdapter.toJsonTree() is public
       private JsonElement toJsonTree(TypeAdapter<T> delegate, T value) {
         try {
-          JsonElementWriter jsonWriter = new JsonElementWriter();
+          JsonTreeWriter jsonWriter = new JsonTreeWriter();
           jsonWriter.setLenient(true);
           delegate.write(jsonWriter, value);
           return jsonWriter.get();

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -26,7 +26,7 @@
 import com.google.gson.internal.bind.CollectionTypeAdapterFactory;
 import com.google.gson.internal.bind.DateTypeAdapter;
 import com.google.gson.internal.bind.JsonTreeReader;
-import com.google.gson.internal.bind.JsonElementWriter;
+import com.google.gson.internal.bind.JsonTreeWriter;
 import com.google.gson.internal.bind.MapTypeAdapterFactory;
 import com.google.gson.internal.bind.ObjectTypeAdapter;
 import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;
@@ -437,7 +437,7 @@ public JsonElement toJsonTree(Object src) {
    * @since 1.4
    */
   public JsonElement toJsonTree(Object src, Type typeOfSrc) {
-    JsonElementWriter writer = new JsonElementWriter();
+    JsonTreeWriter writer = new JsonTreeWriter();
     toJson(src, typeOfSrc, writer);
     return writer.get();
   }

File: gson/src/main/java/com/google/gson/TypeAdapter.java
Patch:
@@ -16,9 +16,8 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.bind.JsonElementWriter;
+import com.google.gson.internal.bind.JsonTreeWriter;
 import com.google.gson.internal.bind.JsonTreeReader;
-import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
@@ -224,7 +223,7 @@ public final TypeAdapter<T> nullSafe() {
    */
   /*public*/ final JsonElement toJsonTree(T value) {
     try {
-      JsonElementWriter jsonWriter = new JsonElementWriter();
+      JsonTreeWriter jsonWriter = new JsonTreeWriter();
       jsonWriter.setLenient(true);
       write(jsonWriter, value);
       return jsonWriter.get();

File: gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java
Patch:
@@ -30,7 +30,7 @@
 /**
  * This writer creates a JsonElement.
  */
-public final class JsonElementWriter extends JsonWriter {
+public final class JsonTreeWriter extends JsonWriter {
   private static final Writer UNWRITABLE_WRITER = new Writer() {
     @Override public void write(char[] buffer, int offset, int counter) {
       throw new AssertionError();
@@ -54,7 +54,7 @@ public final class JsonElementWriter extends JsonWriter {
   /** the JSON element constructed by this writer. */
   private JsonElement product = JsonNull.INSTANCE; // TODO: is this really what we want?;
 
-  public JsonElementWriter() {
+  public JsonTreeWriter() {
     super(UNWRITABLE_WRITER);
   }
 

File: gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
Patch:
@@ -266,7 +266,7 @@ private String keyToString(JsonElement keyElement) {
   // TODO: remove this when TypeAdapter.toJsonTree() is public
   private static <T> JsonElement toJsonTree(TypeAdapter<T> typeAdapter, T value) {
     try {
-      JsonElementWriter jsonWriter = new JsonElementWriter();
+      JsonTreeWriter jsonWriter = new JsonTreeWriter();
       jsonWriter.setLenient(true);
       typeAdapter.write(jsonWriter, value);
       return jsonWriter.get();

File: gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
Patch:
@@ -32,7 +32,6 @@
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
-import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Field;
 import java.lang.reflect.Type;
 import java.util.LinkedHashMap;

File: gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
Patch:
@@ -108,13 +108,13 @@ private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type,
     Type declaredType = type.getType();
     while (raw != Object.class) {
       Field[] fields = raw.getDeclaredFields();
-      AccessibleObject.setAccessible(fields, true);
       for (Field field : fields) {
         boolean serialize = excludeField(field, true);
         boolean deserialize = excludeField(field, false);
         if (!serialize && !deserialize) {
           continue;
         }
+        field.setAccessible(true);
         Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());
         BoundField boundField = createBoundField(context, field, getFieldName(field),
             TypeToken.get(fieldType), serialize, deserialize);

File: gson/src/main/java/com/google/gson/internal/Excluder.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.gson.FieldAttributes;
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
 import com.google.gson.annotations.Expose;
 import com.google.gson.annotations.Since;
 import com.google.gson.annotations.Until;
@@ -46,7 +47,7 @@
  * @author Joel Leitch
  * @author Jesse Wilson
  */
-public final class Excluder implements TypeAdapter.Factory, Cloneable {
+public final class Excluder implements TypeAdapterFactory, Cloneable {
   private static final double IGNORE_VERSIONS = -1.0d;
   public static final Excluder DEFAULT = new Excluder();
 

File: gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
 import java.io.IOException;
 import java.lang.reflect.Array;
 import java.lang.reflect.GenericArrayType;
@@ -35,7 +36,7 @@
  * Adapt an array of objects.
  */
 public final class ArrayTypeAdapter<E> extends TypeAdapter<Object> {
-  public static final Factory FACTORY = new Factory() {
+  public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
     @SuppressWarnings({"unchecked", "rawtypes"})
     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
       Type type = typeToken.getType();

File: gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
 import com.google.gson.internal.$Gson$Types;
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.ObjectConstructor;
@@ -32,7 +33,7 @@
 /**
  * Adapt a homogeneous collection of objects.
  */
-public final class CollectionTypeAdapterFactory implements TypeAdapter.Factory {
+public final class CollectionTypeAdapterFactory implements TypeAdapterFactory {
   private final ConstructorConstructor constructorConstructor;
 
   public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {

File: gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
Patch:
@@ -19,6 +19,7 @@
 import com.google.gson.Gson;
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
@@ -38,7 +39,7 @@
  * to synchronize its read and write methods.
  */
 public final class DateTypeAdapter extends TypeAdapter<Date> {
-  public static final Factory FACTORY = new Factory() {
+  public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
     @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
       return typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;

File: gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
Patch:
@@ -22,6 +22,7 @@
 import com.google.gson.JsonPrimitive;
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
 import com.google.gson.internal.$Gson$Types;
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.JsonReaderInternalAccess;
@@ -102,7 +103,7 @@
  * This format will serialize and deserialize just fine as long as this adapter
  * is registered.
  */
-public final class MapTypeAdapterFactory implements TypeAdapter.Factory {
+public final class MapTypeAdapterFactory implements TypeAdapterFactory {
   private final ConstructorConstructor constructorConstructor;
   private final boolean complexMapKeySerialization;
 

File: gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
@@ -33,7 +34,7 @@
  * serialization and a primitive/Map/List on deserialization.
  */
 public final class ObjectTypeAdapter extends TypeAdapter<Object> {
-  public static final Factory FACTORY = new Factory() {
+  public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
     @SuppressWarnings("unchecked")
     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (type.getRawType() == Object.class) {

File: gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.gson.Gson;
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
 import com.google.gson.annotations.SerializedName;
 import com.google.gson.internal.$Gson$Types;
 import com.google.gson.internal.ConstructorConstructor;
@@ -40,7 +41,7 @@
 /**
  * Type adapter that reflects over the fields and methods of a class.
  */
-public final class ReflectiveTypeAdapterFactory implements TypeAdapter.Factory {
+public final class ReflectiveTypeAdapterFactory implements TypeAdapterFactory {
   private final ConstructorConstructor constructorConstructor;
   private final FieldNamingStrategy fieldNamingPolicy;
   private final Excluder excluder;

File: gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java
Patch:
@@ -19,6 +19,7 @@
 import com.google.gson.Gson;
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
@@ -35,7 +36,7 @@
  * to synchronize its read and write methods.
  */
 public final class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {
-  public static final Factory FACTORY = new Factory() {
+  public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
     @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
       return typeToken.getRawType() == java.sql.Date.class

File: gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java
Patch:
@@ -19,6 +19,7 @@
 import com.google.gson.Gson;
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
@@ -37,7 +38,7 @@
  * to synchronize its read and write methods.
  */
 public final class TimeTypeAdapter extends TypeAdapter<Time> {
-  public static final Factory FACTORY = new Factory() {
+  public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {
     @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
       return typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -241,6 +241,7 @@ public Gson() {
     factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));
     factories.add(ArrayTypeAdapter.FACTORY);
     factories.add(TypeAdapters.ENUM_FACTORY);
+    factories.add(TypeAdapters.CLASS_FACTORY);
     factories.add(reflectiveTypeAdapterFactory);
 
     this.factories = Collections.unmodifiableList(factories);

File: gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
Patch:
@@ -416,6 +416,7 @@ public InetAddress read(JsonReader in) throws IOException {
         in.nextNull();
         return null;
       }
+      // regrettably, this should have included both the host name and the host address
       return InetAddress.getByName(in.nextString());
     }
     @Override

File: gson/src/main/java/com/google/gson/TypeAdapter.java
Patch:
@@ -103,7 +103,7 @@
  *   TypeAdapter<Graph> graphAdapter = gson.getAdapter(Graph.class);
  *   Graph graph = graphAdapter.fromJson(json);
  * }</pre>
- * ...or serialize a Java object to a JSON document: <pre>   {@code
+ * And an example for serialization: <pre>   {@code
  *
  *   Graph graph = new Graph(...);
  *   TypeAdapter<Graph> graphAdapter = gson.getAdapter(Graph.class);

File: gson/src/main/java/com/google/gson/TypeAdapter.java
Patch:
@@ -166,7 +166,7 @@ public final void toJson(Writer out, T value) throws IOException {
    *   }).create();
    * }</pre>
    * You can avoid this boilerplate handling of nulls by wrapping your type adapter with
-   * {@link #nullSafe(TypeAdapter)} method. Here is how we will rewrite the above example:
+   * this method. Here is how we will rewrite the above example:
    * <pre>   {@code
    *
    * Gson gson = new GsonBuilder().registerTypeAdapter(Foo.class,

File: gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
Patch:
@@ -127,7 +127,7 @@ public void testFormatUsesDefaultTimezone() {
   public void testDateSerialization() throws Exception {
     int dateStyle = DateFormat.LONG;
     DefaultDateTypeAdapter dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle);
-    DateFormat formatter = DateFormat.getDateInstance(dateStyle);
+    DateFormat formatter = DateFormat.getDateInstance(dateStyle, Locale.US);
     Date currentDate = new Date();
 
     String dateString = dateTypeAdapter.serialize(currentDate, Date.class, null).getAsString();

File: gson/src/main/java/com/google/gson/TypeAdapter.java
Patch:
@@ -179,23 +179,23 @@ public final void toJson(Writer out, T value) throws IOException {
    *     }
    *   }.nullSafe()).create();
    * }</pre>
-   * Note that we didn't need to check for nulls in our type adapter after we used nullSafe. 
+   * Note that we didn't need to check for nulls in our type adapter after we used nullSafe.
    */
   public TypeAdapter<T> nullSafe() {
     return new TypeAdapter<T>() {
       @Override public void write(JsonWriter out, T value) throws IOException {
         if (value == null) {
           out.nullValue();
         } else {
-          write(out, value);
+          TypeAdapter.this.write(out, value);
         }
       }
       @Override public T read(JsonReader reader) throws IOException {
         if (reader.peek() == JsonToken.NULL) {
           reader.nextNull();
           return null;
         }
-        return read(reader);
+        return TypeAdapter.this.read(reader);
       }
     };
   }

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -541,9 +541,9 @@ public GsonBuilder serializeSpecialFloatingPointValues() {
    */
   public Gson create() {
     List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();
-    factories.addAll(this.hierarchyFactories);
     factories.addAll(this.factories);
     Collections.reverse(factories);
+    factories.addAll(this.hierarchyFactories);
     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, factories);
 
     return new Gson(excluder, fieldNamingPolicy, instanceCreators,

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -20,6 +20,7 @@
 import java.sql.Timestamp;
 import java.text.DateFormat;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.List;
@@ -540,8 +541,9 @@ public GsonBuilder serializeSpecialFloatingPointValues() {
    */
   public Gson create() {
     List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();
-    factories.addAll(this.factories);
     factories.addAll(this.hierarchyFactories);
+    factories.addAll(this.factories);
+    Collections.reverse(factories);
     addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, factories);
 
     return new Gson(excluder, fieldNamingPolicy, instanceCreators,

File: gson/src/main/java/com/google/gson/JsonDeserializer.java
Patch:
@@ -61,6 +61,9 @@
  * Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdDeserializer()).create();
  * </pre>
  *
+ * <p>New applications should prefer {@link TypeAdapter}, whose streaming API
+ * is more efficient than this interface's tree API.
+ *
  * @author Inderjeet Singh
  * @author Joel Leitch
  *

File: gson/src/main/java/com/google/gson/JsonSerializer.java
Patch:
@@ -60,6 +60,9 @@
  * Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdSerializer()).create();
  * </pre>
  *
+ * <p>New applications should prefer {@link TypeAdapter}, whose streaming API
+ * is more efficient than this interface's tree API.
+ *
  * @author Inderjeet Singh
  * @author Joel Leitch
  *

File: gson/src/main/java/com/google/gson/TreeTypeAdapter.java
Patch:
@@ -125,13 +125,13 @@ private SingleTypeFactory(Object typeAdapter, TypeToken<?> exactType, boolean ma
     }
 
     @SuppressWarnings("unchecked") // guarded by typeToken.equals() call
-    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> type) {
+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       boolean matches = exactType != null
           ? exactType.equals(type) || matchRawType && exactType.getType() == type.getRawType()
           : hierarchyType.isAssignableFrom(type.getRawType());
       return matches
           ? new TreeTypeAdapter<T>((JsonSerializer<T>) serializer,
-              (JsonDeserializer<T>) deserializer, context, type, this)
+              (JsonDeserializer<T>) deserializer, gson, type, this)
           : null;
     }
   }

File: gson/src/main/java/com/google/gson/internal/Excluder.java
Patch:
@@ -107,7 +107,7 @@ public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy,
     return result;
   }
 
-  public <T> TypeAdapter<T> create(final Gson context, final TypeToken<T> type) {
+  public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {
     Class<?> rawType = type.getRawType();
     final boolean skipSerialize = excludeClass(rawType, true);
     final boolean skipDeserialize = excludeClass(rawType, false);
@@ -140,7 +140,7 @@ private TypeAdapter<T> delegate() {
         TypeAdapter<T> d = delegate;
         return d != null
             ? d
-            : (delegate = context.getNextAdapter(Excluder.this, type));
+            : (delegate = gson.getNextAdapter(Excluder.this, type));
       }
     };
   }

File: gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
Patch:
@@ -37,16 +37,16 @@
 public final class ArrayTypeAdapter<E> extends TypeAdapter<Object> {
   public static final Factory FACTORY = new Factory() {
     @SuppressWarnings({"unchecked", "rawtypes"})
-    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {
+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
       Type type = typeToken.getType();
       if (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {
         return null;
       }
 
       Type componentType = $Gson$Types.getArrayComponentType(type);
-      TypeAdapter<?> componentTypeAdapter = context.getAdapter(TypeToken.get(componentType));
+      TypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));
       return new ArrayTypeAdapter(
-          context, componentTypeAdapter, $Gson$Types.getRawType(componentType));
+              gson, componentTypeAdapter, $Gson$Types.getRawType(componentType));
     }
   };
 

File: gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
Patch:
@@ -39,7 +39,7 @@ public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructo
     this.constructorConstructor = constructorConstructor;
   }
 
-  public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {
+  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
     Type type = typeToken.getType();
 
     Class<? super T> rawType = typeToken.getRawType();
@@ -48,11 +48,11 @@ public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {
     }
 
     Type elementType = $Gson$Types.getCollectionElementType(type, rawType);
-    TypeAdapter<?> elementTypeAdapter = context.getAdapter(TypeToken.get(elementType));
+    TypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));
     ObjectConstructor<T> constructor = constructorConstructor.getConstructor(typeToken);
 
     @SuppressWarnings({"unchecked", "rawtypes"}) // create() doesn't define a type parameter
-    TypeAdapter<T> result = new Adapter(context, elementType, elementTypeAdapter, constructor);
+    TypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);
     return result;
   }
 

File: gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
Patch:
@@ -40,7 +40,7 @@
 public final class DateTypeAdapter extends TypeAdapter<Date> {
   public static final Factory FACTORY = new Factory() {
     @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {
+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
       return typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;
     }
   };

File: gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
Patch:
@@ -35,9 +35,9 @@
 public final class ObjectTypeAdapter extends TypeAdapter<Object> {
   public static final Factory FACTORY = new Factory() {
     @SuppressWarnings("unchecked")
-    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> type) {
+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (type.getRawType() == Object.class) {
-        return (TypeAdapter<T>) new ObjectTypeAdapter(context);
+        return (TypeAdapter<T>) new ObjectTypeAdapter(gson);
       }
       return null;
     }

File: gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
Patch:
@@ -61,15 +61,15 @@ private String getFieldName(Field f) {
     return serializedName == null ? fieldNamingPolicy.translateName(f) : serializedName.value();
   }
 
-  public <T> TypeAdapter<T> create(Gson context, final TypeToken<T> type) {
+  public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {
     Class<? super T> raw = type.getRawType();
 
     if (!Object.class.isAssignableFrom(raw)) {
       return null; // it's a primitive!
     }
 
     ObjectConstructor<T> constructor = constructorConstructor.getConstructor(type);
-    return new Adapter<T>(constructor, getBoundFields(context, type, raw));
+    return new Adapter<T>(constructor, getBoundFields(gson, type, raw));
   }
 
   private ReflectiveTypeAdapterFactory.BoundField createBoundField(

File: gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java
Patch:
@@ -37,7 +37,7 @@
 public final class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {
   public static final Factory FACTORY = new Factory() {
     @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {
+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
       return typeToken.getRawType() == java.sql.Date.class
           ? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;
     }

File: gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java
Patch:
@@ -39,7 +39,7 @@
 public final class TimeTypeAdapter extends TypeAdapter<Time> {
   public static final Factory FACTORY = new Factory() {
     @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {
+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {
       return typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;
     }
   };

File: gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
Patch:
@@ -23,6 +23,7 @@
 import com.google.gson.TypeAdapter;
 import com.google.gson.internal.$Gson$Types;
 import com.google.gson.internal.ConstructorConstructor;
+import com.google.gson.internal.JsonReaderInternalAccess;
 import com.google.gson.internal.ObjectConstructor;
 import com.google.gson.internal.Streams;
 import com.google.gson.reflect.TypeToken;
@@ -180,8 +181,8 @@ public Map<K, V> read(JsonReader reader) throws IOException {
       } else {
         reader.beginObject();
         while (reader.hasNext()) {
-          String keyString = reader.nextName();
-          K key = keyTypeAdapter.fromJsonElement(new JsonPrimitive(keyString));
+          JsonReaderInternalAccess.INSTANCE.promoteNameToValue(reader);
+          K key = keyTypeAdapter.read(reader);
           V value = valueTypeAdapter.read(reader);
           V replaced = map.put(key, value);
           if (replaced != null) {

File: gson/src/main/java/com/google/gson/TypeAdapter.java
Patch:
@@ -76,6 +76,6 @@ public T fromJsonElement(JsonElement json) {
   }
 
   public interface Factory {
-    <T> TypeAdapter<T> create(Gson context, TypeToken<T> type);
+    <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type);
   }
 }

File: gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java
Patch:
@@ -102,7 +102,7 @@ private void usePersonNameAdapter() {
         writer.value(value.name);
       }
     };
-    miniGson = new GsonBuilder().typeAdapter(Person.class, personNameAdapter).create();
+    miniGson = new GsonBuilder().registerTypeAdapter(Person.class, personNameAdapter).create();
     truckAdapter = miniGson.getAdapter(Truck.class);
   }
 

File: gson/src/main/java/com/google/gson/TreeTypeAdapter.java
Patch:
@@ -30,7 +30,7 @@
  * tree adapter may be serialization-only or deserialization-only, this class
  * has a facility to lookup a delegate type adapter on demand.
  */
-public final class TreeTypeAdapter<T> extends TypeAdapter<T> {
+final class TreeTypeAdapter<T> extends TypeAdapter<T> {
   private final JsonSerializer<T> serializer;
   private final JsonDeserializer<T> deserializer;
   private final Gson gson;

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.gson;
 
-import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;
 import com.google.gson.annotations.Expose;
 import com.google.gson.internal.$Gson$Preconditions;
 import com.google.gson.internal.Primitives;

File: gson/src/test/java/com/google/gson/DefaultDateTypeAdapterTest.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.gson;
 
-import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.Date;

File: gson/src/test/java/com/google/gson/JsonDeserializerExceptionWrapperTest.java
Patch:
@@ -16,8 +16,6 @@
 
 package com.google.gson;
 
-import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;
-
 import junit.framework.TestCase;
 
 import java.lang.reflect.Type;

File: gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java
Patch:
@@ -35,7 +35,7 @@ public class FunctionWithInternalDependenciesTest extends TestCase {
   @SuppressWarnings("unchecked")
   public void testAnonymousLocalClassesSerialization() throws Exception {
     LinkedList<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();
-    strategies.add(new SyntheticFieldExclusionStrategy(true));
+    strategies.add(GsonBuilder.EXCLUDE_SYNTHETIC_FIELDS);
     strategies.add(new ModifierBasedExclusionStrategy(Modifier.TRANSIENT, Modifier.STATIC));
     ExclusionStrategy exclusionStrategy = new DisjunctionExclusionStrategy(strategies);
     Gson gson = new Gson(exclusionStrategy, exclusionStrategy, FieldNamingPolicy.IDENTITY,

File: gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java
Patch:
@@ -21,22 +21,22 @@
 import java.lang.reflect.Field;
 
 /**
- * Unit test for the {@link InnerClassExclusionStrategy} class.
+ * Unit test for GsonBuilder.EXCLUDE_INNER_CLASSES.
  *
  * @author Joel Leitch
  */
 public class InnerClassExclusionStrategyTest extends TestCase {
   public InnerClass innerClass;
   public StaticNestedClass staticNestedClass;
 
-  private InnerClassExclusionStrategy strategy;
+  private ExclusionStrategy strategy;
 
   @Override
   protected void setUp() throws Exception {
     super.setUp();
     innerClass = new InnerClass();
     staticNestedClass = new StaticNestedClass();
-    strategy = new InnerClassExclusionStrategy();
+    strategy = GsonBuilder.EXCLUDE_INNER_CLASSES;
   }
 
   public void testExcludeInnerClassObject() throws Exception {

File: gson/src/test/java/com/google/gson/FieldAttributesTest.java
Patch:
@@ -36,12 +36,12 @@ public class FieldAttributesTest extends TestCase {
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    fieldAttributes = new FieldAttributes(Foo.class, Foo.class.getField("bar"));
+    fieldAttributes = new FieldAttributes(Foo.class.getField("bar"));
   }
 
   public void testNullField() throws Exception {
     try {
-      new FieldAttributes(Foo.class, null);
+      new FieldAttributes(null);
       fail("Field parameter can not be null");
     } catch (NullPointerException expected) { }
   }

File: gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java
Patch:
@@ -46,7 +46,7 @@ public void testExcludeInnerClassObject() throws Exception {
 
   public void testExcludeInnerClassField() throws Exception {
     Field f = getClass().getField("innerClass");
-    assertTrue(strategy.shouldSkipField(new FieldAttributes(getClass(), f)));
+    assertTrue(strategy.shouldSkipField(new FieldAttributes(f)));
   }
 
   public void testIncludeStaticNestedClassObject() throws Exception {
@@ -56,7 +56,7 @@ public void testIncludeStaticNestedClassObject() throws Exception {
 
   public void testIncludeStaticNestedClassField() throws Exception {
     Field f = getClass().getField("staticNestedClass");
-    assertFalse(strategy.shouldSkipField(new FieldAttributes(getClass(), f)));
+    assertFalse(strategy.shouldSkipField(new FieldAttributes(f)));
   }
 
   class InnerClass {

File: gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
Patch:
@@ -33,7 +33,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
-public class ParamterizedTypeFixtures {
+public class ParameterizedTypeFixtures {
 
   public static class MyParameterizedType<T> {
     public final T value;

File: gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java
Patch:
@@ -18,9 +18,9 @@
 
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
-import com.google.gson.ParamterizedTypeFixtures.MyParameterizedType;
-import com.google.gson.ParamterizedTypeFixtures.MyParameterizedTypeAdapter;
-import com.google.gson.ParamterizedTypeFixtures.MyParameterizedTypeInstanceCreator;
+import com.google.gson.ParameterizedTypeFixtures.MyParameterizedType;
+import com.google.gson.ParameterizedTypeFixtures.MyParameterizedTypeAdapter;
+import com.google.gson.ParameterizedTypeFixtures.MyParameterizedTypeInstanceCreator;
 import com.google.gson.common.TestTypes.BagOfPrimitives;
 import com.google.gson.reflect.TypeToken;
 

File: gson/src/main/java/com/google/gson/GsonToMiniGsonTypeAdapterFactory.java
Patch:
@@ -17,8 +17,6 @@
 
 import com.google.gson.internal.ParameterizedTypeHandlerMap;
 import com.google.gson.internal.Streams;
-import com.google.gson.internal.bind.MiniGson;
-import com.google.gson.internal.bind.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
@@ -53,7 +51,7 @@ public JsonElement serialize(Object src, Type typeOfSrc) {
     };
   }
 
-  public <T> TypeAdapter<T> create(final MiniGson context, final TypeToken<T> typeToken) {
+  public <T> TypeAdapter<T> create(final Gson context, final TypeToken<T> typeToken) {
     final Type type = typeToken.getType();
 
     @SuppressWarnings("unchecked") // guaranteed to match typeOfT

File: gson/src/main/java/com/google/gson/internal/bind/BigDecimalTypeAdapter.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.gson.internal.bind;
 
 import com.google.gson.JsonSyntaxException;
+import com.google.gson.TypeAdapter;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;

File: gson/src/main/java/com/google/gson/internal/bind/BigIntegerTypeAdapter.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.gson.internal.bind;
 
 import com.google.gson.JsonSyntaxException;
+import com.google.gson.TypeAdapter;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;

File: gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
Patch:
@@ -16,7 +16,9 @@
 
 package com.google.gson.internal.bind;
 
+import com.google.gson.Gson;
 import com.google.gson.JsonSyntaxException;
+import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
@@ -38,7 +40,7 @@
 public final class DateTypeAdapter extends TypeAdapter<Date> {
   public static final Factory FACTORY = new Factory() {
     @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {
+    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {
       return typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;
     }
   };

File: gson/src/main/java/com/google/gson/internal/bind/ExcludedTypeAdapterFactory.java
Patch:
@@ -17,6 +17,8 @@
 package com.google.gson.internal.bind;
 
 import com.google.gson.ExclusionStrategy;
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
@@ -36,7 +38,7 @@ public ExcludedTypeAdapterFactory(ExclusionStrategy serializationExclusionStrate
     this.deserializationExclusionStrategy = deserializationExclusionStrategy;
   }
 
-  public <T> TypeAdapter<T> create(final MiniGson context, final TypeToken<T> type) {
+  public <T> TypeAdapter<T> create(final Gson context, final TypeToken<T> type) {
     Class<?> rawType = type.getRawType();
     final boolean skipSerialize = serializationExclusionStrategy.shouldSkipClass(rawType);
     final boolean skipDeserialize = deserializationExclusionStrategy.shouldSkipClass(rawType);

File: gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java
Patch:
@@ -16,7 +16,9 @@
 
 package com.google.gson.internal.bind;
 
+import com.google.gson.Gson;
 import com.google.gson.JsonSyntaxException;
+import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
@@ -35,7 +37,7 @@
 public final class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {
   public static final Factory FACTORY = new Factory() {
     @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {
+    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {
       return typeToken.getRawType() == java.sql.Date.class
           ? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;
     }

File: gson/src/main/java/com/google/gson/internal/bind/StringToValueMapTypeAdapterFactory.java
Patch:
@@ -16,6 +16,8 @@
 
 package com.google.gson.internal.bind;
 
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
 import com.google.gson.internal.$Gson$Types;
 import com.google.gson.internal.ConstructorConstructor;
 import com.google.gson.internal.ObjectConstructor;
@@ -38,7 +40,7 @@ public StringToValueMapTypeAdapterFactory(ConstructorConstructor constructorCons
     this.constructorConstructor = constructorConstructor;
   }
 
-  public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {
+  public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {
     Type type = typeToken.getType();
     if (!(type instanceof ParameterizedType)) {
       return null;

File: gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java
Patch:
@@ -16,7 +16,9 @@
 
 package com.google.gson.internal.bind;
 
+import com.google.gson.Gson;
 import com.google.gson.JsonSyntaxException;
+import com.google.gson.TypeAdapter;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
@@ -37,7 +39,7 @@
 public final class TimeTypeAdapter extends TypeAdapter<Time> {
   public static final Factory FACTORY = new Factory() {
     @SuppressWarnings("unchecked") // we use a runtime check to make sure the 'T's equal
-    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {
+    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {
       return typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;
     }
   };

File: gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.gson;
 
 import com.google.gson.common.TestTypes.ClassWithNoFields;
-import com.google.gson.internal.bind.TypeAdapter;
 import java.lang.reflect.Modifier;
 import java.util.Collections;
 import java.util.LinkedList;

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -683,7 +683,7 @@ public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException
    */
   public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {
     JsonReader jsonReader = new JsonReader(json);
-    T object = fromJson(jsonReader, typeOfT);
+    T object = (T) fromJson(jsonReader, typeOfT);
     assertFullConsumption(object, jsonReader);
     return object;
   }
@@ -780,7 +780,7 @@ public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException
     if (json == null) {
       return null;
     }
-    return fromJson(new JsonElementReader(json), typeOfT);
+    return (T) fromJson(new JsonElementReader(json), typeOfT);
   }
 
   @Override

File: gson/src/main/java/com/google/gson/GsonToMiniGsonTypeAdapterFactory.java
Patch:
@@ -39,7 +39,7 @@ public GsonToMiniGsonTypeAdapterFactory(final Gson gson,
 
     this.deserializationContext = new JsonDeserializationContext() {
       public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException {
-        return gson.fromJson(json, typeOfT);
+        return (T) gson.fromJson(json, typeOfT);
       }
     };
 

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -637,7 +637,6 @@ public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
       T target = (T) fromJson(reader, typeOfT);
       return target;
     } catch (IllegalStateException e) {
-      // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException
       throw new JsonSyntaxException(e);
     }
   }
@@ -732,6 +731,8 @@ public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, J
         return null;
       }
       throw new JsonSyntaxException(e);
+    } catch (IllegalStateException e) {
+      throw new JsonSyntaxException(e);
     } catch (IOException e) {
       // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException
       throw new JsonSyntaxException(e);

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -228,10 +228,11 @@ public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredT
 
     MiniGson.Builder builder = new MiniGson.Builder()
         .withoutDefaultFactories()
+        .factory(TypeAdapters.STRING_FACTORY)
+        .factory(TypeAdapters.INTEGER_FACTORY)
         .factory(TypeAdapters.BOOLEAN_FACTORY)
         .factory(TypeAdapters.BYTE_FACTORY)
         .factory(TypeAdapters.SHORT_FACTORY)
-        .factory(TypeAdapters.INTEGER_FACTORY)
         .factory(TypeAdapters.newFactory(long.class, Long.class,
             longAdapter(longSerializationPolicy)))
         .factory(TypeAdapters.newFactory(double.class, Double.class,
@@ -242,7 +243,6 @@ public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredT
             serializationExclusionStrategy, deserializationExclusionStrategy))
         .factory(TypeAdapters.NUMBER_FACTORY)
         .factory(TypeAdapters.CHARACTER_FACTORY)
-        .factory(TypeAdapters.STRING_FACTORY)
         .factory(TypeAdapters.STRING_BUILDER_FACTORY)
         .factory(TypeAdapters.STRING_BUFFER_FACTORY)
         .typeAdapter(BigDecimal.class, new BigDecimalTypeAdapter())

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -99,7 +99,7 @@
  * @author Joel Leitch
  */
 public final class Gson {
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings("rawtypes")
   static final ParameterizedTypeHandlerMap EMPTY_MAP =
     new ParameterizedTypeHandlerMap().makeUnmodifiable();
 
@@ -397,7 +397,7 @@ public JsonElement toJsonTree(Object src) {
    * @return Json representation of {@code src}
    * @since 1.4
    */
-  @SuppressWarnings("unchecked") // the caller is required to make src and typeOfSrc consistent
+  @SuppressWarnings({"unchecked", "rawtypes"}) // the caller is required to make src and typeOfSrc consistent
   public JsonElement toJsonTree(Object src, Type typeOfSrc) {
     // Serialize 'src' to JSON, then deserialize that to a JSON tree.
     TypeAdapter adapter = miniGson.getAdapter(TypeToken.get(typeOfSrc));

File: gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
Patch:
@@ -34,7 +34,7 @@
  */
 public final class ArrayTypeAdapter<E> extends TypeAdapter<Object> {
   public static final Factory FACTORY = new Factory() {
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "rawtypes"})
     public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {
       Type type = typeToken.getType();
       if (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {

File: gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java
Patch:
@@ -49,7 +49,7 @@ public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {
     TypeAdapter<?> elementTypeAdapter = context.getAdapter(TypeToken.get(elementType));
     ObjectConstructor<T> constructor = constructorConstructor.getConstructor(typeToken);
 
-    @SuppressWarnings("unchecked") // create() doesn't define a type parameter
+    @SuppressWarnings({"unchecked", "rawtypes"}) // create() doesn't define a type parameter
     TypeAdapter<T> result = new Adapter(context, elementType, elementTypeAdapter, constructor);
     return result;
   }

File: gson/src/main/java/com/google/gson/internal/bind/JsonElementReader.java
Patch:
@@ -81,7 +81,6 @@ public JsonElementReader(JsonElement element) {
     return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;
   }
 
-  @SuppressWarnings("unchecked")
   @Override public JsonToken peek() throws IOException {
     if (stack.isEmpty()) {
       return JsonToken.END_DOCUMENT;
@@ -139,10 +138,9 @@ private void expect(JsonToken expected) throws IOException {
     }
   }
 
-  @SuppressWarnings("unchecked")
   @Override public String nextName() throws IOException {
     expect(JsonToken.NAME);
-    Iterator<?> i = (Iterator) peekStack();
+    Iterator<?> i = (Iterator<?>) peekStack();
     Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();
     stack.add(entry.getValue());
     return (String) entry.getKey();

File: gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java
Patch:
@@ -122,7 +122,8 @@ public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {
     TypeAdapter<?> valueAdapter = context.getAdapter(TypeToken.get(keyAndValueTypes[1]));
     ObjectConstructor<T> constructor = constructorConstructor.getConstructor(typeToken);
 
-    @SuppressWarnings("unchecked") // we don't define a type parameter for the key or value types
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    // we don't define a type parameter for the key or value types
     TypeAdapter<T> result = new Adapter(context, keyAndValueTypes[0], keyAdapter,
         keyAndValueTypes[1], valueAdapter, constructor);
     return result;

File: gson/src/main/java/com/google/gson/internal/bind/Reflection.java
Patch:
@@ -22,10 +22,9 @@ final class Reflection {
   /**
    * Finds a compatible runtime type if it is more specific
    */
-  @SuppressWarnings("unchecked")
   public static Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {
     if (value != null
-        && (type == Object.class || type instanceof TypeVariable || type instanceof Class<?>)) {
+        && (type == Object.class || type instanceof TypeVariable<?> || type instanceof Class<?>)) {
       type = value.getClass();
     }
     return type;

File: gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
Patch:
@@ -73,7 +73,7 @@ private ReflectiveTypeAdapterFactory.BoundField createBoundField(
     // special casing primitives here saves ~5% on Android...
     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {
       final TypeAdapter<?> typeAdapter = context.getAdapter(fieldType);
-      @SuppressWarnings("unchecked") // the type adapter and field type always agree
+      @SuppressWarnings({"unchecked", "rawtypes"}) // the type adapter and field type always agree
       @Override void write(JsonWriter writer, Object value)
           throws IOException, IllegalAccessException {
         Object fieldValue = field.get(value);

File: gson/src/main/java/com/google/gson/internal/bind/StringToValueMapTypeAdapterFactory.java
Patch:
@@ -57,7 +57,8 @@ public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {
 
     ObjectConstructor<?> constructor = constructorConstructor.getConstructor(typeToken);
 
-    @SuppressWarnings("unchecked") // we don't define a type parameter for the key or value types
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    // we don't define a type parameter for the key or value types
     TypeAdapter<T> result = new Adapter(valueAdapter, constructor);
     return result;
   }

File: gson/src/main/java/com/google/gson/internal/bind/TypeAdapterRuntimeTypeWrapper.java
Patch:
@@ -38,7 +38,7 @@ public T read(JsonReader reader) throws IOException {
     return delegate.read(reader);
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({"rawtypes", "unchecked"})
   @Override
   public void write(JsonWriter writer, T value) throws IOException {
     // Order of preference for choosing type adapters

File: gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
Patch:
@@ -670,7 +670,7 @@ public void write(JsonWriter writer, T value) throws IOException {
 
   public static <TT> TypeAdapter.Factory newEnumTypeHierarchyFactory(final Class<TT> clazz) {
     return new TypeAdapter.Factory() {
-      @SuppressWarnings("unchecked")
+      @SuppressWarnings({"rawtypes", "unchecked"})
       public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {
         Class<? super T> rawType = typeToken.getRawType();
         return clazz.isAssignableFrom(rawType)

File: gson/src/main/java/com/google/gson/reflect/TypeToken.java
Patch:
@@ -79,7 +79,6 @@ protected TypeToken() {
    * Returns the type from super class's type parameter in {@link $Gson$Types#canonicalize
    * canonical form}.
    */
-  @SuppressWarnings("unchecked")
   static Type getSuperclassTypeParameter(Class<?> subclass) {
     Type superclass = subclass.getGenericSuperclass();
     if (superclass instanceof Class) {
@@ -271,7 +270,6 @@ private static AssertionError buildUnexpectedTypeError(
    * Checks if two types are the same or are equivalent under a variable mapping
    * given in the type map that was provided.
    */
-  @SuppressWarnings("unchecked")
   private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {
     return to.equals(from)
         || (from instanceof TypeVariable

File: gson/src/test/java/com/google/gson/ObjectTypeAdapterTest.java
Patch:
@@ -27,9 +27,8 @@ public final class ObjectTypeAdapterTest extends TestCase {
   private final MiniGson gson = new MiniGson.Builder().build();
   private final TypeAdapter<Object> adapter = gson.getAdapter(Object.class);
 
-  @SuppressWarnings("unchecked")
   public void testDeserialize() throws Exception {
-    Map<?, ?> map = (Map) adapter.fromJson("{a: 5, b: [1, 2, null], c: {x: y}}");
+    Map<?, ?> map = (Map<?, ?>) adapter.fromJson("{a: 5, b: [1, 2, null], c: {x: y}}");
     assertEquals(5.0, map.get("a"));
     assertEquals(Arrays.asList(1.0, 2.0, null), map.get("b"));
     assertEquals(Collections.singletonMap("x", "y"), map.get("c"));

File: gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java
Patch:
@@ -79,6 +79,7 @@ private String getExpectedJson(Object obj) {
     public int hashCode() {
       return value == null ? 0 : value.hashCode();
     }
+
     @SuppressWarnings("unchecked")
     @Override
     public boolean equals(Object obj) {
@@ -91,7 +92,7 @@ public boolean equals(Object obj) {
       if (getClass() != obj.getClass()) {
         return false;
       }
-      MyParameterizedType other = (MyParameterizedType) obj;
+      MyParameterizedType<T> other = (MyParameterizedType<T>) obj;
       if (value == null) {
         if (other.value != null) {
           return false;

File: gson/src/test/java/com/google/gson/functional/MapTest.java
Patch:
@@ -69,7 +69,7 @@ public void testMapDeserialization() {
     assertEquals(2, target.get("b").intValue());
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({"unchecked", "rawtypes"})
   public void testRawMapSerialization() {
     Map map = new LinkedHashMap();
     map.put("a", 1);
@@ -514,8 +514,8 @@ public final void addSub(String name, TestTypes.Sub value) {
     }
   }
 
-  @SuppressWarnings("unchecked")
   static final class MapWithGeneralMapParameters {
+    @SuppressWarnings({"rawtypes", "unchecked"})
     final Map<String, Object> map = new LinkedHashMap();
   }
 }

File: gson/src/test/java/com/google/gson/functional/ObjectTest.java
Patch:
@@ -111,14 +111,14 @@ public void testClassWithTransientFieldsSerialization() throws Exception {
     assertEquals(target.getExpectedJson(), gson.toJson(target));
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings("rawtypes")
   public void testClassWithTransientFieldsDeserialization() throws Exception {
     String json = "{\"longValue\":[1]}";
     ClassWithTransientFields target = gson.fromJson(json, ClassWithTransientFields.class);
     assertEquals(json, target.getExpectedJson());
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings("rawtypes")
   public void testClassWithTransientFieldsDeserializationTransientFieldsPassedInJsonAreIgnored()
       throws Exception {
     String json = "{\"transientLongValue\":1,\"longValue\":[1]}";

File: gson/src/test/java/com/google/gson/functional/PrintFormattingTest.java
Patch:
@@ -45,7 +45,7 @@ protected void setUp() throws Exception {
     gson = new Gson();
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({"unchecked", "rawtypes"})
   public void testCompactFormattingLeavesNoWhiteSpace() {
     List list = new ArrayList();
     list.add(new BagOfPrimitives());

File: extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java
Patch:
@@ -179,7 +179,7 @@ public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type) {
     return registerSubtype(type, type.getSimpleName());
   }
 
-  @Override public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {
+  public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {
     if (type.getRawType() != baseType) {
       return null;
     }
@@ -231,7 +231,7 @@ public RuntimeTypeAdapterFactory<T> registerSubtype(Class<? extends T> type) {
         for (Map.Entry<String, JsonElement> e : jsonObject.entrySet()) {
           clone.add(e.getKey(), e.getValue());
         }
-        Streams.write(clone, true, writer);
+        Streams.write(clone, writer);
       }
     };
   }

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -248,6 +248,7 @@ public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredT
         .typeAdapter(BigDecimal.class, new BigDecimalTypeAdapter())
         .typeAdapter(BigInteger.class, new BigIntegerTypeAdapter())
         .factory(new CollectionTypeAdapterFactory(constructorConstructor))
+        .factory(TypeAdapters.JSON_ELEMENT_FACTORY)
         .factory(ObjectTypeAdapter.FACTORY);
 
     for (TypeAdapter.Factory factory : typeAdapterFactories) {

File: gson/src/main/java/com/google/gson/JsonDeserializer.java
Patch:
@@ -49,7 +49,7 @@
  *
  * <pre>
  * class IdDeserializer implements JsonDeserializer&lt;Id&gt;() {
- *   public Id fromJson(JsonElement json, Type typeOfT, JsonDeserializationContext context)
+ *   public Id deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
  *       throws JsonParseException {
  *     return (Id) new Id((Class)typeOfT, id.getValue());
  *   }

File: gson/src/main/java/com/google/gson/JsonSerializer.java
Patch:
@@ -49,7 +49,7 @@
  *
  * <p><pre>
  * class IdSerializer implements JsonSerializer&lt;Id&gt;() {
- *   public JsonElement toJson(Id id, Type typeOfId, JsonSerializationContext context) {
+ *   public JsonElement serialize(Id id, Type typeOfId, JsonSerializationContext context) {
  *     return new JsonPrimitive(id.getValue());
  *   }
  * }

File: gson/src/main/java/com/google/gson/internal/ParameterizedTypeHandlerMap.java
Patch:
@@ -34,6 +34,7 @@
  * @param <T> The handler that will be looked up by type
  */
 public final class ParameterizedTypeHandlerMap<T> {
+
   private static final Logger logger =
       Logger.getLogger(ParameterizedTypeHandlerMap.class.getName());
   /**
@@ -158,8 +159,9 @@ public synchronized void registerIfAbsent(Type typeOfT, T value) {
     }
   }
 
-  public synchronized void makeUnmodifiable() {
+  public synchronized ParameterizedTypeHandlerMap<T> makeUnmodifiable() {
     modifiable = false;
+    return this;
   }
 
   public synchronized T getHandlerFor(Type type, boolean systemOnly) {

File: gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java
Patch:
@@ -33,15 +33,15 @@
  */
 public class FunctionWithInternalDependenciesTest extends TestCase {
 
+  @SuppressWarnings("unchecked")
   public void testAnonymousLocalClassesSerialization() throws Exception {
     LinkedList<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();
     strategies.add(new SyntheticFieldExclusionStrategy(true));
     strategies.add(new ModifierBasedExclusionStrategy(Modifier.TRANSIENT, Modifier.STATIC));
     ExclusionStrategy exclusionStrategy = new DisjunctionExclusionStrategy(strategies);
     Gson gson = new Gson(exclusionStrategy, exclusionStrategy, Gson.DEFAULT_NAMING_POLICY,
-        DefaultTypeAdapters.DEFAULT_INSTANCE_CREATORS,
-        false, DefaultTypeAdapters.DEFAULT_SERIALIZERS,
-        DefaultTypeAdapters.DEFAULT_DESERIALIZERS, false, Gson.DEFAULT_JSON_NON_EXECUTABLE,
+        Gson.EMPTY_MAP, false, Gson.EMPTY_MAP, Gson.EMPTY_MAP, false,
+        Gson.DEFAULT_JSON_NON_EXECUTABLE,
         true, false, false, LongSerializationPolicy.DEFAULT,
         Collections.<TypeAdapter.Factory>emptyList());
     assertEquals("{}", gson.toJson(new ClassWithNoFields() {

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -500,6 +500,7 @@ public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOE
    * {@code writer}.
    * @throws JsonIOException if there was a problem writing to the writer
    */
+  @SuppressWarnings("unchecked")
   public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {
     TypeAdapter<?> adapter = miniGson.getAdapter(TypeToken.get(typeOfSrc));
     boolean oldLenient = writer.isLenient();

File: gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
Patch:
@@ -43,7 +43,7 @@ public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {
 
       Type componentType = $Gson$Types.getArrayComponentType(type);
       TypeAdapter<?> componentTypeAdapter = context.getAdapter(TypeToken.get(componentType));
-      @SuppressWarnings("unchecked") // create() doesn't define a type parameter
+      // create() doesn't define a type parameter
       TypeAdapter<T> result = new ArrayTypeAdapter(
           context, componentTypeAdapter, $Gson$Types.getRawType(componentType));
       return result;

File: gson/src/main/java/com/google/gson/internal/bind/JsonElementReader.java
Patch:
@@ -81,6 +81,7 @@ public JsonElementReader(JsonElement element) {
     return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY;
   }
 
+  @SuppressWarnings("unchecked")
   @Override public JsonToken peek() throws IOException {
     if (stack.isEmpty()) {
       return JsonToken.END_DOCUMENT;
@@ -138,6 +139,7 @@ private void expect(JsonToken expected) throws IOException {
     }
   }
 
+  @SuppressWarnings("unchecked")
   @Override public String nextName() throws IOException {
     expect(JsonToken.NAME);
     Iterator<?> i = (Iterator) peekStack();

File: gson/src/test/java/com/google/gson/functional/VersioningTest.java
Patch:
@@ -156,6 +156,7 @@ private static class Version1_1 extends Version1 {
 
   @Since(1.2)
   private static class Version1_2 extends Version1_1 {
+    @SuppressWarnings("unused")
     int d = D;
   }
 

File: gson/src/main/java/com/google/gson/internal/bind/JsonElementReader.java
Patch:
@@ -170,6 +170,9 @@ private void expect(JsonToken expected) throws IOException {
       throw new IllegalStateException("Expected " + JsonToken.NUMBER + " but was " + token);
     }
     double result = ((JsonPrimitive) peekStack()).getAsDouble();
+    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {
+      throw new NumberFormatException("JSON forbids NaN and infinities: " + result);
+    }
     popStack();
     return result;
   }

File: gson/src/main/java/com/google/gson/internal/bind/TypeAdapter.java
Patch:
@@ -70,7 +70,7 @@ public JsonElement toJsonElement(T src) {
 
   public T fromJsonElement(JsonElement json) {
     try {
-      JsonReader jsonReader = new JsonReader(new StringReader(json.toString()));
+      JsonReader jsonReader = new JsonElementReader(json);
       jsonReader.setLenient(true);
       return read(jsonReader);
     } catch (IOException e) {

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -30,6 +30,7 @@
 import com.google.gson.internal.bind.MiniGson;
 import com.google.gson.internal.bind.ObjectTypeAdapter;
 import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;
+import com.google.gson.internal.bind.SqlDateTypeAdapter;
 import com.google.gson.internal.bind.TimeTypeAdapter;
 import com.google.gson.internal.bind.TypeAdapter;
 import com.google.gson.internal.bind.TypeAdapters;
@@ -259,8 +260,8 @@ public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredT
         .factory(DateTypeAdapter.FACTORY)
         .factory(TypeAdapters.CALENDAR_FACTORY)
         .factory(TimeTypeAdapter.FACTORY)
-        .factory(TypeAdapters.SQL_DATE_FACTORY)
-        .factory(TypeAdapters.SQL_TIMESTAMP_FACTORY)
+        .factory(SqlDateTypeAdapter.FACTORY)
+        .factory(TypeAdapters.TIMESTAMP_FACTORY)
         .factory(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization))
         .factory(ArrayTypeAdapter.FACTORY)
         .factory(TypeAdapters.ENUM_FACTORY)

File: gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java
Patch:
@@ -29,7 +29,7 @@
 import java.util.TimeZone;
 
 /**
- * Adapter for Time. Although this class appears stateless, it is not.
+ * Adapter for Date. Although this class appears stateless, it is not.
  * DateFormat captures its time zone and locale when it is created, which gives
  * this class state. DateFormat isn't thread safe either, so this class has
  * to synchronize its read and write methods.

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -257,6 +257,7 @@ public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredT
         .factory(TypeAdapters.CALENDAR_FACTORY)
         .factory(TypeAdapters.SQL_TIME_FACTORY)
         .factory(TypeAdapters.SQL_DATE_FACTORY)
+        .factory(TypeAdapters.SQL_TIMESTAMP_FACTORY)
         .factory(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization))
         .factory(ArrayTypeAdapter.FACTORY)
         .factory(TypeAdapters.ENUM_FACTORY)

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -255,6 +255,7 @@ public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredT
         .factory(TypeAdapters.INET_ADDRESS_FACTORY)
         .factory(TypeAdapters.BIT_SET_FACTORY)
         .factory(TypeAdapters.CALENDAR_FACTORY)
+        .factory(TypeAdapters.SQL_TIME_FACTORY)
         .factory(TypeAdapters.SQL_DATE_FACTORY)
         .factory(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization))
         .factory(ArrayTypeAdapter.FACTORY)

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -255,6 +255,7 @@ public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredT
         .factory(new GsonToMiniGsonTypeAdapterFactory(serializers, deserializers,
             new JsonDeserializationContext(this), new JsonSerializationContext(this), serializeNulls
         ))
+        .factory(TypeAdapters.SQL_DATE_FACTORY)
         .factory(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization))
         .factory(ArrayTypeAdapter.FACTORY)
         .factory(TypeAdapters.ENUM_FACTORY)

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -247,6 +247,7 @@ public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredT
         .factory(TypeAdapters.LOCALE_FACTORY)
         .factory(TypeAdapters.INET_ADDRESS_FACTORY)
         .factory(TypeAdapters.BIT_SET_FACTORY)
+        .factory(TypeAdapters.CALENDAR_FACTORY)
         .typeAdapter(BigDecimal.class, new BigDecimalTypeAdapter())
         .typeAdapter(BigInteger.class, new BigIntegerTypeAdapter())
         .factory(new CollectionTypeAdapterFactory(constructorConstructor))

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -236,6 +236,7 @@ public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredT
             floatAdapter(serializeSpecialFloatingPointValues)))
         .factory(new ExcludedTypeAdapterFactory(
             serializationExclusionStrategy, deserializationExclusionStrategy))
+        .factory(TypeAdapters.NUMBER_FACTORY)
         .factory(TypeAdapters.CHARACTER_FACTORY)
         .factory(TypeAdapters.STRING_FACTORY)
         .factory(TypeAdapters.STRING_BUILDER_FACTORY)

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -730,7 +730,6 @@ public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxExce
    * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
    * @since 1.3
    */
-  @SuppressWarnings("unchecked")
   public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException {
     if (json == null) {
       return null;

File: gson/src/main/java/com/google/gson/JsonDeserializationContext.java
Patch:
@@ -36,7 +36,7 @@ public class JsonDeserializationContext {
   /**
    * TODO: remove this from the public API
    */
-  @SuppressWarnings("unchecked") @Deprecated
+  @Deprecated
   public <T> T construct(Type type) {
     throw new UnsupportedOperationException();
   }
@@ -57,12 +57,10 @@ public Object constructArray(Type type, int length) {
    * @return An object of type typeOfT.
    * @throws JsonParseException if the parse tree does not contain expected data.
    */
-  @SuppressWarnings("unchecked")
   public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException {
     return gson.fromJson(json, typeOfT);
   }
 
-  @SuppressWarnings("unchecked")
   public <T> T deserializeDefault(JsonElement json, Type typeOfT) throws JsonParseException {
     throw new UnsupportedOperationException();
   }

File: gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
Patch:
@@ -156,9 +156,11 @@ private <T> ObjectConstructor<T> newUnsafeAllocator(
       final Type type, final Class<? super T> rawType) {
     return new ObjectConstructor<T>() {
       private final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();
+      @SuppressWarnings("unchecked")
       public T construct() {
         try {
-          return (T) unsafeAllocator.newInstance(rawType);
+          Object newInstance = unsafeAllocator.newInstance(rawType);
+          return (T) newInstance;
         } catch (Exception e) {
           throw new RuntimeException(("Unable to invoke no-args constructor for " + type + ". "
               + "Register an InstanceCreator with Gson for this type may fix this problem."), e);

File: gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
Patch:
@@ -34,6 +34,7 @@
  */
 public final class ArrayTypeAdapter<E> extends TypeAdapter<Object> {
   public static final Factory FACTORY = new Factory() {
+    @SuppressWarnings("unchecked")
     public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {
       Type type = typeToken.getType();
       if (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {
@@ -78,6 +79,7 @@ public Object read(JsonReader reader) throws IOException {
     return array;
   }
 
+  @SuppressWarnings("unchecked")
   @Override public void write(JsonWriter writer, Object array) throws IOException {
     if (array == null) {
       writer.nullValue(); // TODO: better policy here?

File: gson/src/main/java/com/google/gson/internal/bind/Reflection.java
Patch:
@@ -22,6 +22,7 @@ final class Reflection {
   /**
    * Finds a compatible runtime type if it is more specific
    */
+  @SuppressWarnings("unchecked")
   public static Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {
     if (value != null
         && (type == Object.class || type instanceof TypeVariable || type instanceof Class<?>)) {

File: gson/src/test/java/com/google/gson/ObjectTypeAdapterTest.java
Patch:
@@ -27,6 +27,7 @@ public final class ObjectTypeAdapterTest extends TestCase {
   private final MiniGson gson = new MiniGson.Builder().build();
   private final TypeAdapter<Object> adapter = gson.getAdapter(Object.class);
 
+  @SuppressWarnings("unchecked")
   public void testDeserialize() throws Exception {
     Map<?, ?> map = (Map) adapter.fromJson("{a: 5, b: [1, 2, null], c: {x: y}}");
     assertEquals(5.0, map.get("a"));
@@ -35,6 +36,7 @@ public void testDeserialize() throws Exception {
     assertEquals(3, map.size());
   }
 
+  @SuppressWarnings("unused")
   public void testSerialize() throws Exception {
     Object object = new Object() {
       Object a = 5;

File: gson/src/test/java/com/google/gson/functional/CollectionTest.java
Patch:
@@ -208,6 +208,7 @@ public void testRawCollectionSerialization() {
     assertTrue(json.contains(bag1.getExpectedJson()));
   }
 
+  @SuppressWarnings("unchecked")
   public void testRawCollectionDeserializationNotAlllowed() {
     String json = "[0,1,2,3,4,5,6,7,8,9]";
     Collection integers = gson.fromJson(json, Collection.class);

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -236,6 +236,7 @@ public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredT
             floatAdapter(serializeSpecialFloatingPointValues)))
         .factory(new ExcludedTypeAdapterFactory(
             serializationExclusionStrategy, deserializationExclusionStrategy))
+        .factory(TypeAdapters.CHARACTER_FACTORY)
         .factory(TypeAdapters.STRING_FACTORY)
         .factory(TypeAdapters.STRING_BUILDER_FACTORY)
         .factory(TypeAdapters.STRING_BUFFER_FACTORY)

File: gson/src/main/java/com/google/gson/DefaultTypeAdapters.java
Patch:
@@ -75,6 +75,7 @@ private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSeria
     map.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER, true);
 
     // Add primitive serializers
+    map.register(char.class, CHARACTER_TYPE_ADAPTER, true);
     map.register(Character.class, CHARACTER_TYPE_ADAPTER, true);
     map.register(Number.class, NUMBER_TYPE_ADAPTER, true);
 
@@ -93,6 +94,7 @@ private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDes
     map.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER, true);
 
     // Add primitive deserializers
+    map.register(char.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER), true);
     map.register(Character.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER), true);
     map.register(Number.class, NUMBER_TYPE_ADAPTER, true);
 

File: gson/src/main/java/com/google/gson/internal/bind/MiniGson.java
Patch:
@@ -95,7 +95,7 @@ public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {
           return candidate;
         }
       }
-      throw new IllegalArgumentException("This MiniGSON cannot serialize " + type);
+      throw new IllegalArgumentException("This MiniGSON cannot handle " + type);
     } finally {
       threadCalls.remove(type);
     }

File: gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java
Patch:
@@ -37,9 +37,9 @@ public void testAnonymousLocalClassesSerialization() throws Exception {
     strategies.add(new ModifierBasedExclusionStrategy(Modifier.TRANSIENT, Modifier.STATIC));
     ExclusionStrategy exclusionStrategy = new DisjunctionExclusionStrategy(strategies);
     Gson gson = new Gson(exclusionStrategy, exclusionStrategy, Gson.DEFAULT_NAMING_POLICY,
-        DefaultTypeAdapters.getDefaultInstanceCreators(),
-        false, DefaultTypeAdapters.getDefaultSerializers(),
-        DefaultTypeAdapters.getDefaultDeserializers(), false, Gson.DEFAULT_JSON_NON_EXECUTABLE,
+        DefaultTypeAdapters.DEFAULT_INSTANCE_CREATORS,
+        false, DefaultTypeAdapters.DEFAULT_SERIALIZERS,
+        DefaultTypeAdapters.DEFAULT_DESERIALIZERS, false, Gson.DEFAULT_JSON_NON_EXECUTABLE,
         true, false, false, LongSerializationPolicy.DEFAULT);
     assertEquals("{}", gson.toJson(new ClassWithNoFields() {
       // empty anonymous class

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -244,6 +244,7 @@ public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredT
         .factory(TypeAdapters.UUID_FACTORY)
         .factory(TypeAdapters.LOCALE_FACTORY)
         .factory(TypeAdapters.INET_ADDRESS_FACTORY)
+        .factory(TypeAdapters.BIT_SET_FACTORY)
         .typeAdapter(BigDecimal.class, new BigDecimalTypeAdapter())
         .typeAdapter(BigInteger.class, new BigIntegerTypeAdapter())
         .factory(new CollectionTypeAdapterFactory(constructorConstructor))

File: gson/src/main/java/com/google/gson/DefaultTypeAdapters.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.gson;
 
 import com.google.gson.internal.ParameterizedTypeHandlerMap;
+
 import java.lang.reflect.Type;
 import java.sql.Time;
 import java.sql.Timestamp;
@@ -126,7 +127,6 @@ private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultHie
     return map;
   }
 
-  @SuppressWarnings("unchecked")
   private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators() {
     ParameterizedTypeHandlerMap<InstanceCreator<?>> map
         = new ParameterizedTypeHandlerMap<InstanceCreator<?>>();

File: gson/src/test/java/com/google/gson/functional/ArrayTest.java
Patch:
@@ -22,7 +22,6 @@
 import com.google.gson.common.MoreAsserts;
 import com.google.gson.common.TestTypes.BagOfPrimitives;
 import com.google.gson.common.TestTypes.ClassWithObjects;
-import com.google.gson.common.TestTypes.CrazyLongTypeAdapter;
 import com.google.gson.reflect.TypeToken;
 
 import junit.framework.TestCase;

File: gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
Patch:
@@ -34,9 +34,6 @@
  * @author Joel Leitch
  */
 public class PrimitiveTest extends TestCase {
-  private static final BigInteger MAX_INT_VALUE = new BigInteger("2147483647");
-  private static final BigInteger MAX_LONG_VALUE = new BigInteger("9223372036854775807");
-
   private Gson gson;
 
   @Override

File: gson/src/test/java/com/google/gson/FunctionWithInternalDependenciesTest.java
Patch:
@@ -39,8 +39,8 @@ public void testAnonymousLocalClassesSerialization() throws Exception {
     Gson gson = new Gson(exclusionStrategy, exclusionStrategy, Gson.DEFAULT_NAMING_POLICY,
         DefaultTypeAdapters.getDefaultInstanceCreators(),
         false, DefaultTypeAdapters.getDefaultSerializers(),
-        DefaultTypeAdapters.getDefaultDeserializers(), Gson.DEFAULT_JSON_NON_EXECUTABLE, true,
-        false, false, LongSerializationPolicy.DEFAULT);
+        DefaultTypeAdapters.getDefaultDeserializers(), false, Gson.DEFAULT_JSON_NON_EXECUTABLE,
+        true, false, false, LongSerializationPolicy.DEFAULT);
     assertEquals("{}", gson.toJson(new ClassWithNoFields() {
       // empty anonymous class
     }));

File: gson/src/test/java/com/google/gson/functional/MapAsArrayTypeAdapterTest.java
Patch:
@@ -53,7 +53,7 @@ public void testSerializeComplexMapWithTypeAdapter() {
         new TypeToken<Map<String, Boolean>>() {}.getType()));
   }
 
-  public void testTwoTypesCollapseToOneSerialize() {
+  public void disabled_testTwoTypesCollapseToOneSerialize() {
     Gson gson = new GsonBuilder()
         .enableComplexMapKeySerialization()
         .create();
@@ -63,7 +63,7 @@ public void testTwoTypesCollapseToOneSerialize() {
     original.put(new Float(1.0), "b");
     try {
       gson.toJson(original, new TypeToken<Map<Number, String>>() {}.getType());
-      fail();
+      fail(); // we no longer hash keys at serialization time
     } catch (JsonSyntaxException expected) {
     }
   }

File: gson/src/main/java/com/google/gson/FieldAttributes.java
Patch:
@@ -19,6 +19,7 @@
 import com.google.gson.internal.$Gson$Preconditions;
 import com.google.gson.internal.$Gson$Types;
 
+import com.google.gson.internal.Pair;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
 import java.lang.reflect.Type;

File: gson/src/main/java/com/google/gson/internal/Pair.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.gson.internal;
 
 /**
  * A simple object that holds onto a pair of object references, first and second.
@@ -25,7 +25,7 @@
  * @param <FIRST>
  * @param <SECOND>
  */
-final class Pair<FIRST, SECOND> {
+public final class Pair<FIRST, SECOND> {
   public final FIRST first;
   public final SECOND second;
 

File: gson/src/main/java/com/google/gson/internal/Primitives.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.gson.internal;
 
 
 import com.google.gson.internal.$Gson$Preconditions;
@@ -29,7 +29,7 @@
  *
  * @author Kevin Bourrillion
  */
-final class Primitives {
+public final class Primitives {
   private Primitives() {}
 
   /** A map from primitive types to their corresponding wrapper types. */

File: gson/src/main/java/com/google/gson/internal/bind/BigDecimalTypeAdapter.java
Patch:
@@ -28,7 +28,7 @@
  *
  * @author Joel Leitch
  */
-public class BigDecimalTypeAdapter extends TypeAdapter<BigDecimal> {
+public final class BigDecimalTypeAdapter extends TypeAdapter<BigDecimal> {
 
   @Override
   public BigDecimal read(JsonReader reader) throws IOException {

File: gson/src/main/java/com/google/gson/internal/bind/BigIntegerTypeAdapter.java
Patch:
@@ -28,7 +28,7 @@
  *
  * @author Joel Leitch
  */
-public class BigIntegerTypeAdapter extends TypeAdapter<BigInteger> {
+public final class BigIntegerTypeAdapter extends TypeAdapter<BigInteger> {
 
   @Override
   public BigInteger read(JsonReader reader) throws IOException {

File: gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.gson.internal.$Gson$Types;
 
+import com.google.gson.internal.Primitives;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;

File: gson/src/test/java/com/google/gson/PrimitiveTypeAdapter.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.gson;
 
+import com.google.gson.internal.Primitives;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;

File: gson/src/test/java/com/google/gson/internal/ParameterizedTypeHandlerMapTest.java
Patch:
@@ -14,10 +14,11 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.gson.internal;
 
 import com.google.gson.common.TestTypes.Base;
 import com.google.gson.common.TestTypes.Sub;
+import com.google.gson.internal.ParameterizedTypeHandlerMap;
 import com.google.gson.reflect.TypeToken;
 
 import junit.framework.TestCase;
@@ -26,7 +27,7 @@
 import java.util.List;
 
 /**
- * Unit tests for the {@link ParameterizedTypeHandlerMap} class.
+ * Unit tests for the {@link com.google.gson.internal.ParameterizedTypeHandlerMap} class.
  *
  * @author Joel Leitch
  */

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -251,9 +251,9 @@ public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {
         .factory(excludedTypeFactory)
         .factory(GsonCompatibleMapTypeAdapter.FACTORY)
         .factory(CollectionTypeAdapter.FACTORY)
-        .factory(ArrayTypeAdapter.FACTORY)
         .factory(ObjectTypeAdapter.FACTORY)
         .factory(new GsonToMiniGsonTypeAdapter(serializers, deserializers, serializeNulls))
+        .factory(ArrayTypeAdapter.FACTORY)
         .factory(reflectiveTypeAdapterFactory);
 
     this.miniGson = builder.build();

File: gson/src/main/java/com/google/gson/Primitives.java
Patch:
@@ -17,13 +17,12 @@
 package com.google.gson;
 
 
+import com.google.gson.internal.$Gson$Preconditions;
 import java.lang.reflect.Type;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 
-import com.google.gson.internal.$Gson$Preconditions;
-
 /**
  * Contains static utility methods pertaining to primitive types and their
  * corresponding wrapper types.
@@ -78,7 +77,7 @@ public static boolean isPrimitive(Type type) {
    *
    * @see Class#isPrimitive
    */
-  public static boolean isWrapperType(Class<?> type) {
+  public static boolean isWrapperType(Type type) {
     return WRAPPER_TO_PRIMITIVE_TYPE.containsKey(
         $Gson$Preconditions.checkNotNull(type));
   }

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -243,6 +243,7 @@ public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {
         .factory(TypeAdapters.URI_FACTORY)
         .factory(TypeAdapters.UUID_FACTORY)
         .factory(TypeAdapters.LOCALE_FACTORY)
+        .factory(TypeAdapters.INET_ADDRESS_FACTORY)
         .typeAdapter(BigDecimal.class, new BigDecimalTypeAdapter())
         .typeAdapter(BigInteger.class, new BigIntegerTypeAdapter())
         .factory(excludedTypeFactory)

File: gson/src/main/java/com/google/gson/internal/bind/MiniGson.java
Patch:
@@ -166,8 +166,8 @@ public <T> Builder typeAdapter(TypeToken<T> type, TypeAdapter<T> typeAdapter) {
       return this;
     }
 
-    public <T> Builder typeHierarchyAdapter(TypeToken<T> type, TypeAdapter<T> typeAdapter) {
-      factories.add(TypeAdapters.newTypeHierarchyFactory(type, typeAdapter));
+    public <T> Builder typeHierarchyAdapter(Class<T> clazz, TypeAdapter<T> typeAdapter) {
+      factories.add(TypeAdapters.newTypeHierarchyFactory(clazz, typeAdapter));
       return this;
     }
 

File: gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java
Patch:
@@ -33,7 +33,7 @@
 public final class ObjectTypeAdapter extends TypeAdapter<Object> {
   public static final Factory FACTORY = new Factory() {
     @SuppressWarnings("unchecked")
-    @Override public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {
+    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {
       if (type.getRawType() == Object.class) {
         return (TypeAdapter<T>) new ObjectTypeAdapter(context);
       }

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -242,6 +242,7 @@ public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {
         .factory(TypeAdapters.URL_FACTORY)
         .factory(TypeAdapters.URI_FACTORY)
         .factory(TypeAdapters.UUID_FACTORY)
+        .factory(TypeAdapters.LOCALE_FACTORY)
         .typeAdapter(BigDecimal.class, new BigDecimalTypeAdapter())
         .typeAdapter(BigInteger.class, new BigIntegerTypeAdapter())
         .factory(excludedTypeFactory)

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -209,7 +209,7 @@ public boolean deserializeField(Class<?> declaringClazz, Field f, Type declaredT
     };
 
     TypeAdapter.Factory excludedTypeFactory = new TypeAdapter.Factory() {
-      @Override public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {
+      public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {
         Class<?> rawType = type.getRawType();
         if (serializationExclusionStrategy.shouldSkipClass(rawType)
             || deserializationExclusionStrategy.shouldSkipClass(rawType)) {

File: gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java
Patch:
@@ -88,7 +88,7 @@ public Object read(JsonReader reader) throws IOException {
     writer.beginArray();
     for (int i = 0, length = Array.getLength(array); i < length; i++) {
       final E value = (E) Array.get(array, i);
-      Type runtimeType = Reflection.getRuntimeTypeIfMoreSpecific(componentType, array, value);
+      Type runtimeType = Reflection.getRuntimeTypeIfMoreSpecific(componentType, value);
       TypeAdapter t = runtimeType != componentType ?
           context.getAdapter(TypeToken.get(runtimeType)) : componentTypeAdapter;
       t.write(writer, value);

File: gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java
Patch:
@@ -107,7 +107,7 @@ public void write(JsonWriter writer, Collection<E> collection) throws IOExceptio
 
     writer.beginArray();
     for (E element : collection) {
-      Type runtimeType = Reflection.getRuntimeTypeIfMoreSpecific(elementType, collection, element);
+      Type runtimeType = Reflection.getRuntimeTypeIfMoreSpecific(elementType, element);
       TypeAdapter t = runtimeType != elementType ?
           context.getAdapter(TypeToken.get(runtimeType)) : elementTypeAdapter;
       t.write(writer, element);

File: gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java
Patch:
@@ -122,7 +122,7 @@ static BoundField createBoundField(
           throws IOException, IllegalAccessException {
         Object fieldValue = field.get(value);
         Type declaredTypeOfField = fieldType.getType();
-        Type resolvedTypeOfField = Reflection.getRuntimeTypeIfMoreSpecific(declaredTypeOfField, value, fieldValue);
+        Type resolvedTypeOfField = Reflection.getRuntimeTypeIfMoreSpecific(declaredTypeOfField, fieldValue);
         TypeAdapter t = resolvedTypeOfField != declaredTypeOfField ?
             context.getAdapter(TypeToken.get(resolvedTypeOfField)) : this.typeAdapter;
         t.write(writer, fieldValue);

File: gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java
Patch:
@@ -89,7 +89,7 @@ public Collection<E> read(JsonReader reader) throws IOException {
       return null;
     }
 
-    Collection<E> collection = MiniGson.newInstance(constructor);
+    Collection<E> collection = Reflection.newInstance(constructor);
     reader.beginArray();
     while (reader.hasNext()) {
       E instance = elementTypeAdapter.read(reader);

File: gson/src/main/java/com/google/gson/internal/bind/StringToValueMapTypeAdapter.java
Patch:
@@ -79,7 +79,7 @@ public Map<String, V> read(JsonReader reader) throws IOException {
       return null;
     }
 
-    Map<String, V> map = MiniGson.newInstance(constructor);
+    Map<String, V> map = Reflection.newInstance(constructor);
     reader.beginObject();
     while (reader.hasNext()) {
       String key = reader.nextName();

File: gson/src/main/java/com/google/gson/ReflectingFieldNavigator.java
Patch:
@@ -74,7 +74,7 @@ void visitFieldsReflectively(ObjectTypePair objTypePair, Visitor visitor) {
   }
 
   @SuppressWarnings("unchecked")
-  private Type getMoreSpecificType(Type type, Object obj, FieldAttributes fieldAttributes) {
+  private static Type getMoreSpecificType(Type type, Object obj, FieldAttributes fieldAttributes) {
     try {
       if (obj != null && (Object.class == type || type instanceof TypeVariable)) {
         Object fieldValue = fieldAttributes.get(obj);

File: gson/src/main/java/com/google/gson/JsonElement.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.gson;
 
+import com.google.gson.internal.Streams;
 import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
 import java.io.StringWriter;

File: gson/src/main/java/com/google/gson/JsonParser.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.google.gson;
 
+import com.google.gson.internal.Streams;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.MalformedJsonException;

File: gson/src/main/java/com/google/gson/JsonPrimitive.java
Patch:
@@ -17,6 +17,8 @@
 package com.google.gson;
 
 import com.google.gson.internal.$Gson$Preconditions;
+import com.google.gson.internal.LazilyParsedNumber;
+
 import java.math.BigDecimal;
 import java.math.BigInteger;
 

File: gson/src/main/java/com/google/gson/JsonStreamParser.java
Patch:
@@ -22,6 +22,7 @@
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 
+import com.google.gson.internal.Streams;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.MalformedJsonException;

File: gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson;
+package com.google.gson.internal;
 
 import java.math.BigInteger;
 
@@ -23,10 +23,10 @@
  * @author Inderjeet Singh
  */
 @SuppressWarnings("serial")
-final class LazilyParsedNumber extends Number {
+public final class LazilyParsedNumber extends Number {
   private final String value;
 
-  LazilyParsedNumber(String value) {
+  public LazilyParsedNumber(String value) {
     this.value = value;
   }
 

File: gson/src/test/java/com/google/gson/JsonParserTest.java
Patch:
@@ -17,6 +17,7 @@
 package com.google.gson;
 
 import com.google.gson.common.TestTypes.BagOfPrimitives;
+import com.google.gson.internal.Streams;
 import com.google.gson.stream.JsonReader;
 import java.io.CharArrayReader;
 import java.io.CharArrayWriter;

File: gson/src/main/java/com/google/gson/MappedObjectConstructor.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.gson.internal.$Gson$Types;
 
+import com.google.gson.internal.UnsafeAllocator;
 import java.lang.reflect.Array;
 import java.lang.reflect.Type;
 

File: gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.google.gson;
+package com.google.gson.internal;
 
 import java.io.ObjectInputStream;
 import java.io.ObjectStreamClass;
@@ -27,7 +27,7 @@
  * @author Joel Leitch
  * @author Jesse Wilson
  */
-abstract class UnsafeAllocator {
+public abstract class UnsafeAllocator {
   public abstract <T> T newInstance(Class<T> c) throws Exception;
 
   public static UnsafeAllocator create() {

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -846,7 +846,7 @@ private boolean fillBuffer(int minimum) throws IOException {
       limit += total;
 
       // if this is the first read, consume an optional byte order mark (BOM) if it exists
-      if (bufferStartLine == 1 && bufferStartColumn == 1 && limit > 1 && buffer[0] == '\ufeff') {
+      if (bufferStartLine == 1 && bufferStartColumn == 1 && limit > 0 && buffer[0] == '\ufeff') {
         pos++;
         bufferStartColumn--;
       }
@@ -956,7 +956,7 @@ private void skipToEndOfLine() throws IOException {
 
   private boolean skipTo(String toFind) throws IOException {
     outer:
-    for (; pos + toFind.length() < limit || fillBuffer(toFind.length()); pos++) {
+    for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {
       for (int c = 0; c < toFind.length(); c++) {
         if (buffer[pos + c] != toFind.charAt(c)) {
           continue outer;

File: extras/src/test/java/com/google/gson/mini/MiniGsonTest.java
Patch:
@@ -28,7 +28,6 @@
 import junit.framework.TestCase;
 
 public final class MiniGsonTest extends TestCase {
-
   private MiniGson miniGson = new MiniGson.Builder().build();
   private TypeAdapter<Truck> truckAdapter = miniGson.getAdapter(Truck.class);
   private TypeAdapter<Map<String, Double>> mapAdapter

File: extras/src/main/java/com/google/gson/mini/MiniGson.java
Patch:
@@ -56,10 +56,10 @@ private MiniGson(Builder builder) {
     factories.add(TypeAdapters.DOUBLE_FACTORY);
     factories.add(TypeAdapters.LONG_FACTORY);
     factories.add(TypeAdapters.STRING_FACTORY);
-    factories.add(ReflectiveTypeAdapter.FACTORY);
     factories.add(CollectionTypeAdapter.FACTORY);
     factories.add(StringToValueMapTypeAdapter.FACTORY);
     factories.add(ArrayTypeAdapter.FACTORY);
+    factories.add(ReflectiveTypeAdapter.FACTORY);
     this.factories = Collections.unmodifiableList(factories);
   }
 

File: extras/src/main/java/com/google/gson/mini/ReflectiveTypeAdapter.java
Patch:
@@ -56,6 +56,7 @@ private Map<String, BoundField<?>> getBoundFields(
       Map<String, BoundField<?>> result = new LinkedHashMap<String, BoundField<?>>();
       while (raw != Object.class) {
         for (Field field : raw.getDeclaredFields()) {
+          field.setAccessible(true); // TODO: don't call setAccessible unless necessary
           Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());
           BoundField<?> boundField = BoundField.create(context, field, TypeToken.get(fieldType));
           result.put(boundField.name, boundField);

File: gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
Patch:
@@ -63,7 +63,8 @@ public class DefaultTypeAdaptersTest extends TestCase {
   protected void setUp() throws Exception {
     super.setUp();
     this.oldTimeZone = TimeZone.getDefault();
-    TimeZone.setDefault(TimeZone.getTimeZone("PST"));
+    TimeZone.setDefault(TimeZone.getTimeZone("America/Los_Angeles"));
+    Locale.setDefault(Locale.US);
     gson = new Gson();
   }
 

File: extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapter.java
Patch:
@@ -184,7 +184,7 @@ public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext con
       throw new JsonParseException("cannot serialize " + srcType.getName()
           + "; did you forget to register a subtype?");
     }
-    JsonElement serialized = context.serialize(src, srcType);
+    JsonElement serialized = context.serializeDefault(src, srcType);
     final JsonObject jsonObject = serialized.getAsJsonObject();
     if (jsonObject.has(typeFieldName)) {
       throw new JsonParseException("cannot serialize " + srcType.getName()
@@ -212,7 +212,7 @@ public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext
           + label + "; did you forget to register a subtype?");
     }
     @SuppressWarnings("unchecked") // registration requires that subtype extends T
-    T result = (T) context.deserialize(json, subtype);
+    T result = (T) context.deserializeDefault(json, subtype);
     return result;
   }
 }

File: extras/src/test/java/com/google/gson/typeadapters/RuntimeTypeAdapterTest.java
Patch:
@@ -50,7 +50,7 @@ public void testRuntimeTypeIsBaseType() {
     assertEquals("{\"type\":\"BillingInstrument\",\"ownerName\":\"Jesse\"}",
         gson.toJson(original, BillingInstrument.class));
     BillingInstrument deserialized = gson.fromJson(
-        "{type:'CreditCard',ownerName:'Jesse'}", BillingInstrument.class);
+        "{type:'BillingInstrument',ownerName:'Jesse'}", BillingInstrument.class);
     assertEquals("Jesse", deserialized.ownerName);
   }
 

File: gson/src/main/java/com/google/gson/BaseMapTypeAdapter.java
Patch:
@@ -30,7 +30,7 @@ abstract class BaseMapTypeAdapter
 
   protected static final JsonElement serialize(JsonSerializationContext context,
       Object src, Type srcType) {
-    return context.serialize(src, srcType, false);
+    return context.serialize(src, srcType, false, false);
   }
 
   protected static final Map<Object, Object> constructMapType(

File: gson/src/main/java/com/google/gson/DefaultTypeAdapters.java
Patch:
@@ -677,7 +677,7 @@ public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationCo
         } else {
           Type childType = (childGenericType == null || childGenericType == Object.class)
               ? child.getClass() : childGenericType;
-          JsonElement element = context.serialize(child, childType, false);
+          JsonElement element = context.serialize(child, childType, false, false);
           array.add(element);
         }
       }

File: gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java
Patch:
@@ -107,7 +107,7 @@ final Object visitChildAsArray(Type childType, JsonArray jsonChild) {
   }
 
   private Object visitChild(Type type, JsonDeserializationVisitor<?> childVisitor) {
-    objectNavigator.accept(new ObjectTypePair(null, type, false), childVisitor);
+    objectNavigator.accept(new ObjectTypePair(null, type, false, false), childVisitor);
     // the underlying object may have changed during the construction phase
     // This happens primarily because of custom deserializers
     return childVisitor.getTarget();

File: gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java
Patch:
@@ -109,7 +109,7 @@ public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredType
         }
         return true;
       }
-      ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false);
+      ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false, false);
       Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers);
       if (pair == null) {
         return false;

File: gson/src/main/java/com/google/gson/MappedObjectConstructor.java
Patch:
@@ -45,7 +45,7 @@ public MappedObjectConstructor(
 
   @SuppressWarnings("unchecked")
   public <T> T construct(Type typeOfT) {
-    InstanceCreator<T> creator = (InstanceCreator<T>) instanceCreatorMap.getHandlerFor(typeOfT);
+    InstanceCreator<T> creator = (InstanceCreator<T>) instanceCreatorMap.getHandlerFor(typeOfT, false);
     if (creator != null) {
       return creator.createInstance(typeOfT);
     }

File: gson/src/test/java/com/google/gson/MappedObjectConstructorTest.java
Patch:
@@ -37,7 +37,7 @@ protected void setUp() throws Exception {
   }
 
   public void testInstanceCreatorTakesTopPrecedence() throws Exception {
-    creatorMap.register(ObjectWithDefaultConstructor.class, new MyInstanceCreator());
+    creatorMap.register(ObjectWithDefaultConstructor.class, new MyInstanceCreator(), false);
     ObjectWithDefaultConstructor obj =
         constructor.construct(ObjectWithDefaultConstructor.class);
     assertEquals("instanceCreator", obj.stringValue);

File: gson/src/main/java/com/google/gson/UnsafeAllocator.java
Patch:
@@ -70,7 +70,7 @@ public <T> T newInstance(Class<T> c) throws Exception {
     } catch (Exception ignored) {
     }
 
-    // try dalvivkm, post-gingerbread
+    // try dalvikvm, post-gingerbread
     // public class ObjectStreamClass {
     //   private static native int getConstructorId(Class<?> c);
     //   private static native Object newInstance(Class<?> instantiationClass, int methodId);

File: gson/src/main/java/com/google/gson/FieldAttributes.java
Patch:
@@ -104,7 +104,7 @@ public String getName() {
    *   private List&lt;String&gt; red;
    * }
    *
-   * Type listParmeterizedType = new TypeToken<List<String>>() {}.getType();
+   * Type listParmeterizedType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();
    * </pre>
    *
    * <p>This method would return {@code String.class} for the {@code bar} field and

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -20,6 +20,7 @@
 import com.google.gson.stream.JsonToken;
 import com.google.gson.stream.JsonWriter;
 import com.google.gson.stream.MalformedJsonException;
+
 import java.io.IOException;
 import java.io.Reader;
 import java.io.StringReader;
@@ -214,7 +215,7 @@ public JsonElement toJsonTree(Object src) {
    * @since 1.4
    */
   public JsonElement toJsonTree(Object src, Type typeOfSrc) {
-    JsonSerializationContextDefault context = new JsonSerializationContextDefault(
+    JsonSerializationContext context = new JsonSerializationContext(
         new ObjectNavigator(serializationExclusionStrategy), fieldNamingPolicy,
         serializeNulls, serializers);
     return context.serialize(src, typeOfSrc);
@@ -545,7 +546,7 @@ public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException
     if (json == null) {
       return null;
     }
-    JsonDeserializationContext context = new JsonDeserializationContextDefault(
+    JsonDeserializationContext context = new JsonDeserializationContext(
         new ObjectNavigator(deserializationExclusionStrategy), fieldNamingPolicy,
         deserializers, objectConstructor);
     T target = (T) context.deserialize(json, typeOfT);

File: gson/src/main/java/com/google/gson/JsonPrimitive.java
Patch:
@@ -213,7 +213,8 @@ public BigDecimal getAsBigDecimal() {
    */
   @Override
   public BigInteger getAsBigInteger() {
-    return value instanceof BigInteger ? (BigInteger) value : new BigInteger(value.toString());
+    return value instanceof BigInteger ?
+        (BigInteger) value : new BigInteger(value.toString());
   }
 
   /**

File: gson/src/test/java/com/google/gson/functional/ArrayTest.java
Patch:
@@ -278,8 +278,8 @@ public void testMultiDimenstionalObjectArraysSerialization() {
    * Regression test for Issue 205
    */
   public void testMixingTypesInObjectArraySerialization() {
-    Object[] array = new Object[] { 1, 2, new Object[] { "one", "two" } };
-    assertEquals("[1,2,[\"one\",\"two\"]]", gson.toJson(array));
+    Object[] array = new Object[] { 1, 2, new Object[] { "one", "two", 3 } };
+    assertEquals("[1,2,[\"one\",\"two\",3]]", gson.toJson(array));
   }
 
   /**

File: gson/src/main/java/com/google/gson/DefaultTypeAdapters.java
Patch:
@@ -677,7 +677,8 @@ public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationCo
         } else {
           Type childType = (childGenericType == null || childGenericType == Object.class)
               ? child.getClass() : childGenericType;
-          JsonElement element = context.serialize(child, childType);
+          JsonSerializationContextDefault contextImpl = (JsonSerializationContextDefault) context;
+          JsonElement element = contextImpl.serialize(child, childType, false);
           array.add(element);
         }
       }

File: gson/src/main/java/com/google/gson/JsonSerializationContextDefault.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.gson;
 
-
 import java.lang.reflect.Type;
 
 /**
@@ -59,7 +58,8 @@ JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType) {
     }
     JsonSerializationVisitor visitor = new JsonSerializationVisitor(
         objectNavigator, fieldNamingPolicy, serializeNulls, serializers, this, ancestors);
-    objectNavigator.accept(new ObjectTypePair(src, typeOfSrc, preserveType), visitor);
+    ObjectTypePair objTypePair = new ObjectTypePair(src, typeOfSrc, preserveType);
+    objectNavigator.accept(objTypePair, visitor);
     return visitor.getJsonElement();
   }
-}
+}
\ No newline at end of file

File: gson/src/main/java/com/google/gson/ObjectNavigator.java
Patch:
@@ -100,6 +100,7 @@ public void accept(ObjectTypePair objTypePair, Visitor visitor) {
     }
     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair);
     if (!visitedWithCustomHandler) {
+      objTypePair = objTypePair.toMoreSpecificType();
       Object obj = objTypePair.getObject();
       Object objectToVisit = (obj == null) ? visitor.getTarget() : obj;
       if (objectToVisit == null) {
@@ -108,7 +109,7 @@ public void accept(ObjectTypePair objTypePair, Visitor visitor) {
       objTypePair.setObject(objectToVisit);
       visitor.start(objTypePair);
       try {
-        if ($Gson$Types.isArray(objTypePair.type)) {
+        if ($Gson$Types.isArray(objTypePair.getMoreSpecificType())) {
           visitor.visitArray(objectToVisit, objTypePair.type);
         } else if (objTypePair.type == Object.class && isPrimitiveOrString(objectToVisit)) {
           // TODO(Joel): this is only used for deserialization of "primitives"

File: gson/src/main/java/com/google/gson/ObjectTypePair.java
Patch:
@@ -75,7 +75,7 @@ ObjectTypePair toMoreSpecificType() {
     if (actualType == type) {
       return this;
     }
-    return new ObjectTypePair(obj, actualType, preserveType);
+    return new ObjectTypePair(obj, actualType, true);
   }
 
   Type getMoreSpecificType() {

File: gson/src/test/java/com/google/gson/functional/MoreSpecificTypeSerializationTest.java
Patch:
@@ -48,14 +48,14 @@ public void testSubclassFields() {
     assertTrue(json.contains("\"s\":2"));
   }
 
-  public void disabled_testListOfSubclassFields() {
+  public void testListOfSubclassFields() {
     Collection<Base> list = new ArrayList<Base>();
     list.add(new Base(1));
     list.add(new Sub(2, 3));
     ClassWithContainersOfBaseFields target = new ClassWithContainersOfBaseFields(list, null);
     String json = gson.toJson(target);
     assertTrue(json, json.contains("{\"b\":1}"));
-    assertTrue(json, json.contains("{\"b\":2,\"s\":3}"));
+    assertTrue(json, json.contains("{\"s\":3,\"b\":2}"));
   }
 
   public void testMapOfSubclassFields() {

File: gson/src/main/java/com/google/gson/JsonDeserializerExceptionWrapper.java
Patch:
@@ -57,7 +57,7 @@ public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext
       StringBuilder errorMsg = new StringBuilder()
           .append("The JsonDeserializer ")
           .append(delegate)
-          .append(" failed to deserialized json object ")
+          .append(" failed to deserialize json object ")
           .append(json)
           .append(" given the type ")
           .append(typeOfT);

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -355,7 +355,7 @@ public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies) {
   }
 
   /**
-   * Configures Gson to apply the passed exclusion strategies during serialization.
+   * Configures Gson to apply the passed in exclusion strategy during serialization.
    * If this method is invoked numerous times with different exclusion strategy objects
    * then the exclusion strategies that were added will be applied as a disjunction rule.
    * This means that if one of the added exclusion strategies suggests that a field (or
@@ -372,7 +372,7 @@ public GsonBuilder addSerializationExclusionStrategy(ExclusionStrategy strategy)
   }
 
   /**
-   * Configures Gson to apply the passed exclusion strategies during deserialization.
+   * Configures Gson to apply the passed in exclusion strategy during deserialization.
    * If this method is invoked numerous times with different exclusion strategy objects
    * then the exclusion strategies that were added will be applied as a disjunction rule.
    * This means that if one of the added exclusion strategies suggests that a field (or

File: gson/src/main/java/com/google/gson/ExclusionStrategy.java
Patch:
@@ -75,7 +75,7 @@
  * <p>For certain model classes, you may only want to serialize a field, but exclude it for
  * deserialization. To do that, you can write an {@code ExclusionStrategy} as per normal;
  * however, you would register it with the
- * {@link GsonBuilder#addDeserializationExclusionStrategies(ExclusionStrategy...)} method.
+ * {@link GsonBuilder#addDeserializationExclusionStrategy(ExclusionStrategy...)} method.
  * For example:
  * <pre class="code">
  * ExclusionStrategy excludeStrings = new UserDefinedExclusionStrategy(String.class);

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -364,7 +364,7 @@ public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies) {
    * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
    * @since 1.7
    */
-  public GsonBuilder addSerializationExclusionStrategies(ExclusionStrategy strategy) {
+  public GsonBuilder addSerializationExclusionStrategy(ExclusionStrategy strategy) {
     serializeExclusionStrategies.add(strategy);
     return this;
   }
@@ -379,7 +379,7 @@ public GsonBuilder addSerializationExclusionStrategies(ExclusionStrategy strateg
    * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
    * @since 1.7
    */
-  public GsonBuilder addDeserializationExclusionStrategies(ExclusionStrategy strategy) {
+  public GsonBuilder addDeserializationExclusionStrategy(ExclusionStrategy strategy) {
     deserializeExclusionStrategies.add(strategy);
     return this;
   }

File: gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java
Patch:
@@ -91,9 +91,9 @@ public void testExclusionStrategyWithMode() throws Exception {
   private static Gson createGson(ExclusionStrategy exclusionStrategy, boolean serialization) {
     GsonBuilder gsonBuilder = new GsonBuilder();
     if (serialization) {
-      gsonBuilder.addSerializationExclusionStrategies(exclusionStrategy);
+      gsonBuilder.addSerializationExclusionStrategy(exclusionStrategy);
     } else {
-      gsonBuilder.addDeserializationExclusionStrategies(exclusionStrategy);
+      gsonBuilder.addDeserializationExclusionStrategy(exclusionStrategy);
     }
     return gsonBuilder
         .serializeNulls()

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -256,7 +256,7 @@ public GsonBuilder serializeNulls() {
    *         "x": 5,
    *         "y": 6
    *       },
-   *       "a",
+   *       "a"
    *     ],
    *     [
    *       {

File: gson/src/main/java/com/google/gson/ModifyFirstLetterNamingPolicy.java
Patch:
@@ -101,8 +101,8 @@ protected String translateName(String target, Type fieldType,
   }
 
   private String modifyString(char firstCharacter, String srcString, int indexOfSubstring) {
-    return indexOfSubstring < srcString.length() ?
-        firstCharacter + srcString.substring(indexOfSubstring)
+    return (indexOfSubstring < srcString.length())
+        ? firstCharacter + srcString.substring(indexOfSubstring)
         : String.valueOf(firstCharacter);
   }
 }

File: gson/src/main/java/com/google/gson/CamelCaseSeparatorNamingPolicy.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Preconditions;
+import com.google.gson.internal.$Gson$Preconditions;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
@@ -53,8 +53,8 @@ final class CamelCaseSeparatorNamingPolicy extends RecursiveFieldNamingPolicy {
    *         is null or empty.
    */
   public CamelCaseSeparatorNamingPolicy(String separatorString) {
-    $Preconditions.checkNotNull(separatorString);
-    $Preconditions.checkArgument(!"".equals(separatorString));
+    $Gson$Preconditions.checkNotNull(separatorString);
+    $Gson$Preconditions.checkArgument(!"".equals(separatorString));
     this.separatorString = separatorString;
   }
 

File: gson/src/main/java/com/google/gson/DelegatingJsonElementVisitor.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Preconditions;
+import com.google.gson.internal.$Gson$Preconditions;
 
 import java.io.IOException;
 
@@ -50,7 +50,7 @@ class DelegatingJsonElementVisitor implements JsonElementVisitor {
   private final JsonElementVisitor delegate;
 
   protected DelegatingJsonElementVisitor(JsonElementVisitor delegate) {
-    this.delegate = $Preconditions.checkNotNull(delegate);
+    this.delegate = $Gson$Preconditions.checkNotNull(delegate);
   }
 
   public void endArray(JsonArray array) throws IOException {

File: gson/src/main/java/com/google/gson/DisjunctionExclusionStrategy.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Preconditions;
+import com.google.gson.internal.$Gson$Preconditions;
 
 import java.util.Collection;
 
@@ -30,7 +30,7 @@ final class DisjunctionExclusionStrategy implements ExclusionStrategy {
   private final Collection<ExclusionStrategy> strategies;
 
   DisjunctionExclusionStrategy(Collection<ExclusionStrategy> strategies) {
-    this.strategies = $Preconditions.checkNotNull(strategies);
+    this.strategies = $Gson$Preconditions.checkNotNull(strategies);
   }
 
   public boolean shouldSkipField(FieldAttributes f) {

File: gson/src/main/java/com/google/gson/FieldNamingStrategy2Adapter.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Preconditions;
+import com.google.gson.internal.$Gson$Preconditions;
 
 /**
  * Adapts the old "deprecated" FieldNamingStrategy to the new {@link FieldNamingStrategy2}
@@ -30,7 +30,7 @@ final class FieldNamingStrategy2Adapter implements FieldNamingStrategy2 {
   private final FieldNamingStrategy adaptee;
 
   public FieldNamingStrategy2Adapter(FieldNamingStrategy adaptee) {
-    this.adaptee = $Preconditions.checkNotNull(adaptee);
+    this.adaptee = $Gson$Preconditions.checkNotNull(adaptee);
   }
 
   public String translateName(FieldAttributes f) {

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -17,7 +17,7 @@
 package com.google.gson;
 
 import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;
-import com.google.gson.internal.$Preconditions;
+import com.google.gson.internal.$Gson$Preconditions;
 
 import java.lang.reflect.Type;
 import java.sql.Timestamp;
@@ -482,7 +482,7 @@ public GsonBuilder setDateFormat(int dateStyle, int timeStyle) {
    * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
    */
   public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {
-    $Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>
+    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>
             || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);
     if (typeAdapter instanceof InstanceCreator<?>) {
       registerInstanceCreator(type, (InstanceCreator<?>) typeAdapter);
@@ -561,7 +561,7 @@ private <T> GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> d
    * @since 1.7
    */
   public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {
-    $Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>
+    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>
             || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);
     if (typeAdapter instanceof InstanceCreator<?>) {
       registerInstanceCreatorForTypeHierarchy(baseType, (InstanceCreator<?>) typeAdapter);

File: gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Preconditions;
+import com.google.gson.internal.$Gson$Preconditions;
 
 import java.lang.reflect.Type;
 
@@ -50,7 +50,7 @@ public JsonDeserializationVisitor(JsonElement json, Type targetType,
     this.fieldNamingPolicy = fieldNamingPolicy;
     this.objectConstructor = objectConstructor;
     this.deserializers = deserializers;
-    this.json = $Preconditions.checkNotNull(json);
+    this.json = $Gson$Preconditions.checkNotNull(json);
     this.context = context;
     this.constructed = false;
   }

File: gson/src/main/java/com/google/gson/JsonDeserializerExceptionWrapper.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Preconditions;
+import com.google.gson.internal.$Gson$Preconditions;
 
 import java.lang.reflect.Type;
 
@@ -42,7 +42,7 @@ class JsonDeserializerExceptionWrapper<T> implements JsonDeserializer<T> {
    * @throws IllegalArgumentException if {@code delegate} is {@code null}.
    */
   JsonDeserializerExceptionWrapper(JsonDeserializer<T> delegate) {
-    this.delegate = $Preconditions.checkNotNull(delegate);
+    this.delegate = $Gson$Preconditions.checkNotNull(delegate);
   }
 
   public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)

File: gson/src/main/java/com/google/gson/JsonFieldNameValidator.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Preconditions;
+import com.google.gson.internal.$Gson$Preconditions;
 
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -46,8 +46,8 @@ class JsonFieldNameValidator {
    * @throws IllegalArgumentException if the field name is an invalid JSON field name
    */
   public String validate(String fieldName) {
-    $Preconditions.checkNotNull(fieldName);
-    $Preconditions.checkArgument(!"".equals(fieldName.trim()));
+    $Gson$Preconditions.checkNotNull(fieldName);
+    $Gson$Preconditions.checkArgument(!"".equals(fieldName.trim()));
 
     Matcher matcher = JSON_FIELD_NAME_PATTERN.matcher(fieldName);
     if (!matcher.matches()) {

File: gson/src/main/java/com/google/gson/JsonObject.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Preconditions;
+import com.google.gson.internal.$Gson$Preconditions;
 
 import java.io.IOException;
 import java.util.LinkedHashMap;
@@ -57,7 +57,7 @@ public void add(String property, JsonElement value) {
     if (value == null) {
       value = JsonNull.createJsonNull();
     }
-    members.put($Preconditions.checkNotNull(property), value);
+    members.put($Gson$Preconditions.checkNotNull(property), value);
   }
 
   /**

File: gson/src/main/java/com/google/gson/JsonPrimitive.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Preconditions;
+import com.google.gson.internal.$Gson$Preconditions;
 
 import java.io.IOException;
 import java.math.BigDecimal;
@@ -94,7 +94,7 @@ void setValue(Object primitive) {
       char c = ((Character) primitive).charValue();
       this.value = String.valueOf(c);
     } else {
-      $Preconditions.checkArgument(primitive instanceof Number
+      $Gson$Preconditions.checkArgument(primitive instanceof Number
               || isPrimitiveOrString(primitive));
       this.value = primitive;
     }

File: gson/src/main/java/com/google/gson/MappedObjectConstructor.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Types;
+import com.google.gson.internal.$Gson$Types;
 
 import java.lang.reflect.Array;
 import java.lang.reflect.Type;
@@ -53,13 +53,13 @@ public <T> T construct(Type typeOfT) {
   }
 
   public Object constructArray(Type type, int length) {
-    return Array.newInstance($Types.getRawType(type), length);
+    return Array.newInstance($Gson$Types.getRawType(type), length);
   }
 
   @SuppressWarnings({"unchecked", "cast"})
   private <T> T constructWithAllocators(Type typeOfT) {
     try {
-      Class<T> clazz = (Class<T>) $Types.getRawType(typeOfT);
+      Class<T> clazz = (Class<T>) $Gson$Types.getRawType(typeOfT);
       T obj = defaultConstructorAllocator.newInstance(clazz);
       return (obj == null)
           ? unsafeAllocator.newInstance(clazz)

File: gson/src/main/java/com/google/gson/MemoryRefStack.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Preconditions;
+import com.google.gson.internal.$Gson$Preconditions;
 
 import java.util.Stack;
 
@@ -37,7 +37,7 @@ final class MemoryRefStack {
    * @return the object that was added
    */
   public ObjectTypePair push(ObjectTypePair obj) {
-    $Preconditions.checkNotNull(obj);
+    $Gson$Preconditions.checkNotNull(obj);
     return stack.push(obj);
   }
 

File: gson/src/main/java/com/google/gson/ModifyFirstLetterNamingPolicy.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Preconditions;
+import com.google.gson.internal.$Gson$Preconditions;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
@@ -65,7 +65,7 @@ public enum LetterModifier {
    * @throws IllegalArgumentException if {@code modifier} is null
    */
   ModifyFirstLetterNamingPolicy(LetterModifier modifier) {
-    this.letterModifier = $Preconditions.checkNotNull(modifier);
+    this.letterModifier = $Gson$Preconditions.checkNotNull(modifier);
   }
 
   @Override

File: gson/src/main/java/com/google/gson/ObjectNavigator.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Types;
+import com.google.gson.internal.$Gson$Types;
 
 import java.lang.reflect.Type;
 
@@ -95,7 +95,7 @@ public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type actualTypeOf
    * @param objTypePair The object,type (fully genericized) being navigated
    */
   public void accept(ObjectTypePair objTypePair, Visitor visitor) {
-    if (exclusionStrategy.shouldSkipClass($Types.getRawType(objTypePair.type))) {
+    if (exclusionStrategy.shouldSkipClass($Gson$Types.getRawType(objTypePair.type))) {
       return;
     }
     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair);
@@ -108,7 +108,7 @@ public void accept(ObjectTypePair objTypePair, Visitor visitor) {
       objTypePair.setObject(objectToVisit);
       visitor.start(objTypePair);
       try {
-        if ($Types.isArray(objTypePair.type)) {
+        if ($Gson$Types.isArray(objTypePair.type)) {
           visitor.visitArray(objectToVisit, objTypePair.type);
         } else if (objTypePair.type == Object.class && isPrimitiveOrString(objectToVisit)) {
           // TODO(Joel): this is only used for deserialization of "primitives"

File: gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Types;
+import com.google.gson.internal.$Gson$Types;
 
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -138,7 +138,7 @@ public synchronized void makeUnmodifiable() {
   public synchronized T getHandlerFor(Type type) {
     T handler = map.get(type);
     if (handler == null) {
-      Class<?> rawClass = $Types.getRawType(type);
+      Class<?> rawClass = $Gson$Types.getRawType(type);
       if (rawClass != type) {
         handler = getHandlerFor(rawClass);
       }
@@ -210,6 +210,6 @@ public String toString() {
   }
 
   private String typeToString(Type type) {
-    return $Types.getRawType(type).getSimpleName();
+    return $Gson$Types.getRawType(type).getSimpleName();
   }
 }

File: gson/src/main/java/com/google/gson/VersionExclusionStrategy.java
Patch:
@@ -18,7 +18,7 @@
 
 import com.google.gson.annotations.Since;
 import com.google.gson.annotations.Until;
-import com.google.gson.internal.$Preconditions;
+import com.google.gson.internal.$Gson$Preconditions;
 
 /**
  * This strategy will exclude any files and/or class that are passed the
@@ -30,7 +30,7 @@ final class VersionExclusionStrategy implements ExclusionStrategy {
   private final double version;
 
   VersionExclusionStrategy(double version) {
-    $Preconditions.checkArgument(version >= 0.0D);
+    $Gson$Preconditions.checkArgument(version >= 0.0D);
     this.version = version;
   }
 

File: gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java
Patch:
@@ -29,7 +29,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
-public final class $Preconditions {
+public final class $Gson$Preconditions {
   public static <T> T checkNotNull(T obj) {
     if (obj == null) {
       throw new NullPointerException();

File: gson/src/test/java/com/google/gson/GenericArrayTypeTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Types;
+import com.google.gson.internal.$Gson$Types;
 import com.google.gson.reflect.TypeToken;
 
 import junit.framework.TestCase;
@@ -26,7 +26,7 @@
 import java.util.List;
 
 /**
- * Unit tests for the {@code GenericArrayType}s created by the {@link $Types} class.
+ * Unit tests for the {@code GenericArrayType}s created by the {@link $Gson$Types} class.
  *
  * @author Inderjeet Singh
  * @author Joel Leitch
@@ -37,7 +37,7 @@ public class GenericArrayTypeTest extends TestCase {
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    ourType = $Types.arrayOf($Types.newParameterizedTypeWithOwner(null, List.class, String.class));
+    ourType = $Gson$Types.arrayOf($Gson$Types.newParameterizedTypeWithOwner(null, List.class, String.class));
   }
 
   public void testOurTypeFunctionality() throws Exception {

File: gson/src/test/java/com/google/gson/ParameterizedTypeTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Types;
+import com.google.gson.internal.$Gson$Types;
 import com.google.gson.reflect.TypeToken;
 
 import junit.framework.TestCase;
@@ -26,7 +26,7 @@
 import java.util.List;
 
 /**
- * Unit tests for {@code ParamterizedType}s created by the {@link $Types} class.
+ * Unit tests for {@code ParamterizedType}s created by the {@link $Gson$Types} class.
  *
  * @author Inderjeet Singh
  * @author Joel Leitch
@@ -37,7 +37,7 @@ public class ParameterizedTypeTest extends TestCase {
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    ourType = $Types.newParameterizedTypeWithOwner(null, List.class, String.class);
+    ourType = $Gson$Types.newParameterizedTypeWithOwner(null, List.class, String.class);
   }
 
   public void testOurTypeFunctionality() throws Exception {

File: gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Types;
+import com.google.gson.internal.$Gson$Types;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -152,7 +152,7 @@ public JsonElement serialize(MyParameterizedType<T> src, Type classOfSrc,
     public MyParameterizedType<T> deserialize(JsonElement json, Type typeOfT,
         JsonDeserializationContext context) throws JsonParseException {
       Type genericClass = ((ParameterizedType) typeOfT).getActualTypeArguments()[0];
-      Class<?> rawType = $Types.getRawType(genericClass);
+      Class<?> rawType = $Gson$Types.getRawType(genericClass);
       String className = rawType.getSimpleName();
       T value = (T) json.getAsJsonObject().get(className).getAsObject();
       if (Primitives.isPrimitive(genericClass)) {

File: gson/src/main/java/com/google/gson/FieldAttributes.java
Patch:
@@ -254,7 +254,7 @@ private static <T extends Annotation> T getAnnotationFromArray(
    * @param typeDefiningF the type that contains the field {@code f}
    * @return the type information for the field
    */
-  public static Type getTypeInfoForField(Field f, Type typeDefiningF) {
+  static Type getTypeInfoForField(Field f, Type typeDefiningF) {
     Class<?> rawType = $Types.getRawType(typeDefiningF);
     if (!f.getDeclaringClass().isAssignableFrom(rawType)) {
       // this field is unrelated to the type; the user probably omitted type information

File: gson/src/test/java/com/google/gson/DefaultConstructorAllocatorTest.java
Patch:
@@ -54,7 +54,7 @@ public void testMissingDefaultConstructor() throws Exception {
   }
 
   private void assertInCache(Class<?> clazz) {
-    assertNotNull(allocator.constructorCache.getElement(clazz));
+    assertNotNull(allocator.getConstructorCache().getElement(clazz));
   }
 
   private static class NoDefaultConstructor {

File: gson/src/main/java/com/google/gson/CamelCaseSeparatorNamingPolicy.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.Preconditions;
+import com.google.gson.internal.$Preconditions;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
@@ -53,8 +53,8 @@ final class CamelCaseSeparatorNamingPolicy extends RecursiveFieldNamingPolicy {
    *         is null or empty.
    */
   public CamelCaseSeparatorNamingPolicy(String separatorString) {
-    Preconditions.checkNotNull(separatorString);
-    Preconditions.checkArgument(!"".equals(separatorString));
+    $Preconditions.checkNotNull(separatorString);
+    $Preconditions.checkArgument(!"".equals(separatorString));
     this.separatorString = separatorString;
   }
 

File: gson/src/main/java/com/google/gson/DisjunctionExclusionStrategy.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.Preconditions;
+import com.google.gson.internal.$Preconditions;
 
 import java.util.Collection;
 
@@ -30,7 +30,7 @@ final class DisjunctionExclusionStrategy implements ExclusionStrategy {
   private final Collection<ExclusionStrategy> strategies;
 
   DisjunctionExclusionStrategy(Collection<ExclusionStrategy> strategies) {
-    this.strategies = Preconditions.checkNotNull(strategies);
+    this.strategies = $Preconditions.checkNotNull(strategies);
   }
 
   public boolean shouldSkipField(FieldAttributes f) {

File: gson/src/main/java/com/google/gson/JsonDeserializerExceptionWrapper.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.Preconditions;
+import com.google.gson.internal.$Preconditions;
 
 import java.lang.reflect.Type;
 
@@ -42,7 +42,7 @@ class JsonDeserializerExceptionWrapper<T> implements JsonDeserializer<T> {
    * @throws IllegalArgumentException if {@code delegate} is {@code null}.
    */
   JsonDeserializerExceptionWrapper(JsonDeserializer<T> delegate) {
-    this.delegate = Preconditions.checkNotNull(delegate);
+    this.delegate = $Preconditions.checkNotNull(delegate);
   }
 
   public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)
@@ -64,7 +64,7 @@ public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext
       throw new JsonParseException(errorMsg.toString(), e);
     }
   }
-  
+
   @Override
   public String toString() {
     return delegate.toString();

File: gson/src/main/java/com/google/gson/JsonObject.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.Preconditions;
+import com.google.gson.internal.$Preconditions;
 
 import java.io.IOException;
 import java.util.LinkedHashMap;
@@ -57,7 +57,7 @@ public void add(String property, JsonElement value) {
     if (value == null) {
       value = JsonNull.createJsonNull();
     }
-    members.put(Preconditions.checkNotNull(property), value);
+    members.put($Preconditions.checkNotNull(property), value);
   }
 
   /**

File: gson/src/main/java/com/google/gson/JsonPrimitive.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.Preconditions;
+import com.google.gson.internal.$Preconditions;
 
 import java.io.IOException;
 import java.math.BigDecimal;
@@ -94,8 +94,8 @@ void setValue(Object primitive) {
       char c = ((Character) primitive).charValue();
       this.value = String.valueOf(c);
     } else {
-      Preconditions.checkArgument(primitive instanceof Number
-          || isPrimitiveOrString(primitive));
+      $Preconditions.checkArgument(primitive instanceof Number
+              || isPrimitiveOrString(primitive));
       this.value = primitive;
     }
   }

File: gson/src/main/java/com/google/gson/MemoryRefStack.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.Preconditions;
+import com.google.gson.internal.$Preconditions;
 
 import java.util.Stack;
 
@@ -37,7 +37,7 @@ final class MemoryRefStack {
    * @return the object that was added
    */
   public ObjectTypePair push(ObjectTypePair obj) {
-    Preconditions.checkNotNull(obj);
+    $Preconditions.checkNotNull(obj);
     return stack.push(obj);
   }
 

File: gson/src/main/java/com/google/gson/ModifyFirstLetterNamingPolicy.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.Preconditions;
+import com.google.gson.internal.$Preconditions;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
@@ -65,7 +65,7 @@ public enum LetterModifier {
    * @throws IllegalArgumentException if {@code modifier} is null
    */
   ModifyFirstLetterNamingPolicy(LetterModifier modifier) {
-    this.letterModifier = Preconditions.checkNotNull(modifier);
+    this.letterModifier = $Preconditions.checkNotNull(modifier);
   }
 
   @Override

File: gson/src/main/java/com/google/gson/VersionExclusionStrategy.java
Patch:
@@ -18,7 +18,7 @@
 
 import com.google.gson.annotations.Since;
 import com.google.gson.annotations.Until;
-import com.google.gson.internal.Preconditions;
+import com.google.gson.internal.$Preconditions;
 
 /**
  * This strategy will exclude any files and/or class that are passed the
@@ -30,7 +30,7 @@ final class VersionExclusionStrategy implements ExclusionStrategy {
   private final double version;
 
   VersionExclusionStrategy(double version) {
-    Preconditions.checkArgument(version >= 0.0D);
+    $Preconditions.checkArgument(version >= 0.0D);
     this.version = version;
   }
 

File: gson/src/main/java/com/google/gson/internal/$Preconditions.java
Patch:
@@ -29,7 +29,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
-public final class Preconditions {
+public final class $Preconditions {
   public static <T> T checkNotNull(T obj) {
     if (obj == null) {
       throw new NullPointerException();
@@ -42,7 +42,7 @@ public static void checkArgument(boolean condition) {
       throw new IllegalArgumentException();
     }
   }
-  
+
   public static void checkState(boolean condition) {
     if (!condition) {
       throw new IllegalStateException();

File: gson/src/test/java/com/google/gson/ParameterizedTypeTest.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.Types;
+import com.google.gson.internal.$Types;
 import com.google.gson.reflect.TypeToken;
 
 import junit.framework.TestCase;
@@ -26,7 +26,7 @@
 import java.util.List;
 
 /**
- * Unit tests for {@code ParamterizedType}s created by the {@link Types} class.
+ * Unit tests for {@code ParamterizedType}s created by the {@link $Types} class.
  *
  * @author Inderjeet Singh
  * @author Joel Leitch
@@ -37,7 +37,7 @@ public class ParameterizedTypeTest extends TestCase {
   @Override
   protected void setUp() throws Exception {
     super.setUp();
-    ourType = Types.newParameterizedTypeWithOwner(null, List.class, String.class);
+    ourType = $Types.newParameterizedTypeWithOwner(null, List.class, String.class);
   }
 
   public void testOurTypeFunctionality() throws Exception {

File: gson/src/main/java/com/google/gson/ReflectingFieldNavigator.java
Patch:
@@ -54,9 +54,7 @@ final class ReflectingFieldNavigator {
    * @param visitor the visitor to visit each field with
    */
   void visitFieldsReflectively(ObjectTypePair objTypePair, Visitor visitor) {
-    ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType();
-    Class<?> topLevelClass = Types.getRawType(currObjTypePair.type);
-    for (Class<?> curr : getInheritanceHierarchy(currObjTypePair.type)) {
+    for (Class<?> curr : getInheritanceHierarchy(objTypePair.getMoreSpecificType())) {
       navigateClassFields(objTypePair.getObject(), objTypePair.type, curr, visitor);
     }
   }

File: gson/src/main/java/com/google/gson/DefaultTypeAdapters.java
Patch:
@@ -65,7 +65,7 @@ final class DefaultTypeAdapters {
   private static final DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER =
     new DefaultTimestampDeserializer();
 
-  @SuppressWarnings("rawtypes")
+  @SuppressWarnings({ "rawtypes", "unchecked" })
   private static final EnumTypeAdapter ENUM_TYPE_ADAPTER = new EnumTypeAdapter();
   private static final UrlTypeAdapter URL_TYPE_ADAPTER = new UrlTypeAdapter();
   private static final UriTypeAdapter URI_TYPE_ADAPTER = new UriTypeAdapter();

File: gson/src/main/java/com/google/gson/FieldNamingStrategy2Adapter.java
Patch:
@@ -17,12 +17,13 @@
 package com.google.gson;
 
 /**
- * Adapts the old "deprecated" {@link FieldNamingStrategy} to the new {@link FieldNamingStrategy2}
+ * Adapts the old "deprecated" FieldNamingStrategy to the new {@link FieldNamingStrategy2}
  * type. 
  * 
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
+@SuppressWarnings("deprecation")
 final class FieldNamingStrategy2Adapter implements FieldNamingStrategy2 {
   private final FieldNamingStrategy adaptee;
 

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -273,7 +273,7 @@ public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies) {
    * depending on the {@code mode} that is passed into this method.
    *
    * @param strategies the set of strategy object to apply during the {@code mode}.
-   * @param the mode of Gson (either serialization or deserialization) as to when the
+   * @param mode the mode of Gson (either serialization or deserialization) as to when the
    *   {@code strategies} should be applied.
    * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
    * @since 1.7

File: gson/src/main/java/com/google/gson/NullExclusionStrategy.java
Patch:
@@ -17,7 +17,7 @@
 package com.google.gson;
 
 /**
- * This acts as a "Null Object" pattern for the {@link ExclusionStrategy2}.
+ * This acts as a "Null Object" pattern for the {@link ExclusionStrategy}.
  * Passing an instance of this class into the {@link ObjectNavigator} will
  * make the {@link ObjectNavigator} parse/visit every field of the object
  * being navigated.

File: gson/src/main/java/com/google/gson/ObjectNavigatorFactory.java
Patch:
@@ -18,7 +18,7 @@
 
 /**
  * A factory class used to simplify {@link ObjectNavigator} creation.
- * This object holds on to a reference of the {@link ExclusionStrategy2}
+ * This object holds on to a reference of the {@link ExclusionStrategy}
  * that you'd like to use with the {@link ObjectNavigator}.
  *
  * @author Joel Leitch

File: gson/src/main/java/com/google/gson/reflect/TypeToken.java
Patch:
@@ -93,6 +93,7 @@ protected TypeToken() {
    * Returns the type from super class's type parameter in {@link Types#canonicalize(java.lang.reflect.Type)
    * canonical form}.
    */
+  @SuppressWarnings("unchecked")
   static Type getSuperclassTypeParameter(Class<?> subclass) {
     Type superclass = subclass.getGenericSuperclass();
     if (superclass instanceof Class) {
@@ -284,6 +285,7 @@ private static AssertionError buildUnexpectedTypeError(
    * Checks if two types are the same or are equivalent under a variable mapping
    * given in the type map that was provided.
    */
+  @SuppressWarnings("unchecked")
   private static boolean matches(Type from, Type to, Map<String, Type> typeMap) {
     return to.equals(from)
         || (from instanceof TypeVariable

File: gson/src/test/java/com/google/gson/DefaultMapJsonSerializerTest.java
Patch:
@@ -32,7 +32,7 @@
  */
 public class DefaultMapJsonSerializerTest extends TestCase {
 
-  @SuppressWarnings("rawtypes")
+  @SuppressWarnings("unchecked")
   private JsonSerializer<Map> mapSerializer;
 
   @Override

File: gson/src/test/java/com/google/gson/FieldNamingStrategy2AdapterTest.java
Patch:
@@ -37,6 +37,7 @@ public void testSimpleAdapter() throws Exception {
         new FieldAttributes(String.class, field)));
   }
   
+  @SuppressWarnings("deprecation")
   private static class UpperCaseNamingStrategy implements FieldNamingStrategy {
     public String translateName(Field f) {
       return f.getName().toUpperCase();

File: gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java
Patch:
@@ -76,7 +76,7 @@ private String getExpectedJson(Object obj) {
     public int hashCode() {
       return value == null ? 0 : value.hashCode();
     }
-    @SuppressWarnings("rawtypes")
+    @SuppressWarnings("unchecked")
     @Override
     public boolean equals(Object obj) {
       if (this == obj) {

File: gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java
Patch:
@@ -33,7 +33,7 @@
 
 /**
  * Performs some functional tests when Gson is instantiated with some common user defined
- * {@link ExclusionStrategy} and {@link ExclusionStrategy2} objects.
+ * {@link ExclusionStrategy} objects.
  *
  * @author Inderjeet Singh
  * @author Joel Leitch

File: gson/src/test/java/com/google/gson/functional/MapTest.java
Patch:
@@ -154,7 +154,7 @@ public void testParameterizedMapSubclassSerialization() {
     assertTrue(json.contains("\"a\":\"b\""));
   }
 
-  @SuppressWarnings("rawtypes")
+  @SuppressWarnings("unchecked")
   public void testParameterizedMapSubclassDeserialization() {
     Type type = new TypeToken<MyParameterizedMap<String, Integer>>() {}.getType();
     Gson gson = new GsonBuilder().registerTypeAdapter(type, 

File: gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
Patch:
@@ -33,6 +33,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
+@SuppressWarnings("deprecation")
 public class NamingPolicyTest extends TestCase {
 
   private GsonBuilder builder;

File: gson/src/test/java/com/google/gson/functional/ObjectTest.java
Patch:
@@ -99,14 +99,14 @@ public void testClassWithTransientFieldsSerialization() throws Exception {
     assertEquals(target.getExpectedJson(), gson.toJson(target));
   }
 
-  @SuppressWarnings("rawtypes")
+  @SuppressWarnings("unchecked")
   public void testClassWithTransientFieldsDeserialization() throws Exception {
     String json = "{\"longValue\":[1]}";
     ClassWithTransientFields target = gson.fromJson(json, ClassWithTransientFields.class);
     assertEquals(json, target.getExpectedJson());
   }
 
-  @SuppressWarnings("rawtypes")
+  @SuppressWarnings("unchecked")
   public void testClassWithTransientFieldsDeserializationTransientFieldsPassedInJsonAreIgnored()
       throws Exception {
     String json = "{\"transientLongValue\":1,\"longValue\":[1]}";

File: gson/src/main/java/com/google/gson/JsonPrimitive.java
Patch:
@@ -356,7 +356,9 @@ public boolean equals(Object obj) {
       return getAsNumber().longValue() == other.getAsNumber().longValue();
     }
     if (isFloatingPoint(this) && isFloatingPoint(other)) {
-      return getAsNumber().doubleValue() == other.getAsNumber().doubleValue();
+      double a = getAsNumber().doubleValue();
+      double b = other.getAsNumber().doubleValue();
+      return a == b || (Double.isNaN(a) && Double.isNaN(b));
     }
     return value.equals(other.value);
   }

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -1097,7 +1097,8 @@ private void decodeLiteral() throws IOException {
         token = JsonToken.NUMBER;
       } catch (NumberFormatException ignored) {
         // this must be an unquoted string
-        throw syntaxError("invalid number or unquoted string");
+        checkLenient();
+        token = JsonToken.STRING;
       }
     }
   }

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -152,8 +152,8 @@ public final class Gson {
   public Gson() {
     this(DEFAULT_EXCLUSION_STRATEGY, DEFAULT_EXCLUSION_STRATEGY, DEFAULT_NAMING_POLICY,
     new MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()),
-    false, DefaultTypeAdapters.getDefaultSerializers(),
-    DefaultTypeAdapters.getDefaultDeserializers(), DEFAULT_JSON_NON_EXECUTABLE, true, false);
+    false, DefaultTypeAdapters.getAllDefaultSerializers(),
+    DefaultTypeAdapters.getAllDefaultDeserializers(), DEFAULT_JSON_NON_EXECUTABLE, true, false);
   }
 
   Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy,

File: gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java
Patch:
@@ -16,7 +16,6 @@
 
 package com.google.gson;
 
-import com.google.gson.reflect.TypeToken;
 import java.lang.reflect.Type;
 
 /**
@@ -100,7 +99,7 @@ public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredType
         throw new JsonParseException("Expecting object found: " + json); 
       }
       JsonElement child = json.getAsJsonObject().get(fName);
-      boolean isPrimitive = TypeToken.get(declaredTypeOfField).isPrimitive();
+      boolean isPrimitive = Primitives.isPrimitive(declaredTypeOfField);
       if (child == null) { // Child will be null if the field wasn't present in Json
         return true;
       } else if (child.isJsonNull()) {

File: gson/src/main/java/com/google/gson/JsonSerializationVisitor.java
Patch:
@@ -72,7 +72,7 @@ public void startVisitingObject(Object node) {
   public void visitArray(Object array, Type arrayType) {
     assignToRoot(new JsonArray());
     int length = Array.getLength(array);
-    Type componentType = TypeToken.get(arrayType).getArrayComponentType();
+    Type componentType = Types.getArrayComponentType(arrayType);
     for (int i = 0; i < length; ++i) {
       Object child = Array.get(array, i);
       // we should not get more specific component type yet since it is possible

File: gson/src/main/java/com/google/gson/MappedObjectConstructor.java
Patch:
@@ -55,7 +55,7 @@ public <T> T construct(Type typeOfT) {
   }
 
   public Object constructArray(Type type, int length) {
-    return Array.newInstance(TypeToken.get(type).getRawType(), length);
+    return Array.newInstance(Types.getRawType(type), length);
   }
 
   private <T> T constructWithNoArgConstructor(Type typeOfT) {
@@ -80,7 +80,7 @@ private <T> T constructWithNoArgConstructor(Type typeOfT) {
 
   @SuppressWarnings({"unchecked", "cast"})
   private <T> Constructor<T> getNoArgsConstructor(Type typeOfT) {
-    Class<?> clazz = TypeToken.get(typeOfT).getRawType();
+    Class<?> clazz = Types.getRawType(typeOfT);
     Constructor<T>[] declaredConstructors = (Constructor<T>[]) clazz.getDeclaredConstructors();
     AccessibleObject.setAccessible(declaredConstructors, true);
     for (Constructor<T> constructor : declaredConstructors) {

File: gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java
Patch:
@@ -122,7 +122,7 @@ public synchronized void makeUnmodifiable() {
   public synchronized T getHandlerFor(Type type) {
     T handler = map.get(type);
     if (handler == null) {
-      Class<?> rawClass = TypeToken.get(type).getRawType();
+      Class<?> rawClass = Types.getRawType(type);
       if (rawClass != type) {
         handler = getHandlerFor(rawClass);
       }
@@ -196,6 +196,6 @@ public String toString() {
   }
 
   private String typeToString(Type type) {
-    return TypeToken.get(type).getRawType().getSimpleName();
+    return Types.getRawType(type).getSimpleName();
   }
 }

File: gson/src/main/java/com/google/gson/MappedObjectConstructor.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.gson;
 
+import com.google.gson.reflect.TypeToken;
 import java.lang.reflect.AccessibleObject;
 import java.lang.reflect.Array;
 import java.lang.reflect.Constructor;
@@ -54,7 +55,7 @@ public <T> T construct(Type typeOfT) {
   }
 
   public Object constructArray(Type type, int length) {
-    return Array.newInstance(TypeUtils.toRawClass(type), length);
+    return Array.newInstance(TypeToken.get(type).getRawType(), length);
   }
 
   private <T> T constructWithNoArgConstructor(Type typeOfT) {
@@ -79,8 +80,7 @@ private <T> T constructWithNoArgConstructor(Type typeOfT) {
 
   @SuppressWarnings({"unchecked", "cast"})
   private <T> Constructor<T> getNoArgsConstructor(Type typeOfT) {
-    TypeInfo typeInfo = new TypeInfo(typeOfT);
-    Class<T> clazz = (Class<T>) typeInfo.getRawClass();
+    Class<?> clazz = TypeToken.get(typeOfT).getRawType();
     Constructor<T>[] declaredConstructors = (Constructor<T>[]) clazz.getDeclaredConstructors();
     AccessibleObject.setAccessible(declaredConstructors, true);
     for (Constructor<T> constructor : declaredConstructors) {

File: gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.gson;
 
+import com.google.gson.reflect.TypeToken;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -121,7 +122,7 @@ public synchronized void makeUnmodifiable() {
   public synchronized T getHandlerFor(Type type) {
     T handler = map.get(type);
     if (handler == null) {
-      Class<?> rawClass = TypeUtils.toRawClass(type);
+      Class<?> rawClass = TypeToken.get(type).getRawType();
       if (rawClass != type) {
         handler = getHandlerFor(rawClass);
       }
@@ -195,6 +196,6 @@ public String toString() {
   }
 
   private String typeToString(Type type) {
-    return TypeUtils.toRawClass(type).getSimpleName();
+    return TypeToken.get(type).getRawType().getSimpleName();
   }
 }

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -431,7 +431,7 @@ private <T> GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> d
    * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
    * @since 1.7
    */
-  GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {
+  public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {
     Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>
     || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);
     if (typeAdapter instanceof InstanceCreator<?>) {

File: gson/src/test/java/com/google/gson/functional/EnumTest.java
Patch:
@@ -125,7 +125,7 @@ public void testEnumSubclass() {
 
   public void disabled_testEnumSubclassWithRegisteredTypeAdapter() {
     gson = new GsonBuilder()
-        .registerTypeHierarchyAdapter(Roshambo.class, new MyEnumTypeAdapter())
+//        .registerTypeHierarchyAdapter(Roshambo.class, new MyEnumTypeAdapter())
         .create();
     assertRoshambo();
   }

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -429,9 +429,9 @@ private <T> GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> d
    * @param typeAdapter This object must implement at least one of the {@link InstanceCreator},
    * {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.
    * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   * @since 1.6
+   * @since 1.7
    */
-  public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {
+  GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {
     Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>
     || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);
     if (typeAdapter instanceof InstanceCreator<?>) {

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -482,7 +482,7 @@ public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException
    */
   public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {
     JsonReader jsonReader = new JsonReader(json);
-    T object = fromJson(jsonReader, typeOfT);
+    T object = this.<T>fromJson(jsonReader, typeOfT);
     assertFullConsumption(object, jsonReader);
     return object;
   }

File: gson/src/main/java/com/google/gson/JsonSerializationVisitor.java
Patch:
@@ -171,7 +171,7 @@ public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {
   /**
    * objTypePair.getObject() must not be null
    */
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({"unchecked", "rawtypes"})
   private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) {
     Pair<JsonSerializer<?>,ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers);
     if (pair == null) {

File: gson/src/main/java/com/google/gson/Streams.java
Patch:
@@ -45,9 +45,8 @@ static JsonElement parse(JsonReader reader) throws JsonParseException {
        */
       if (isEmpty) {
         return JsonNull.createJsonNull();
-      } else {
-        throw new JsonIOException(e);
       }
+      throw new JsonIOException(e);
     } catch (MalformedJsonException e) {
       throw new JsonSyntaxException(e);
     } catch (IOException e) {

File: gson/src/main/java/com/google/gson/JsonSerializationVisitor.java
Patch:
@@ -171,7 +171,7 @@ public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {
   /**
    * objTypePair.getObject() must not be null
    */
-  @SuppressWarnings({ "unchecked", "rawtypes" })
+  @SuppressWarnings("unchecked")
   private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) {
     Pair<JsonSerializer<?>,ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers);
     if (pair == null) {

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -395,7 +395,6 @@ public void toJson(JsonElement jsonElement, JsonWriter writer) {
    * @throws JsonParseException if json is not a valid representation for an object of type
    * classOfT
    */
-  @SuppressWarnings("unchecked")
   public <T> T fromJson(String json, Class<T> classOfT) throws JsonParseException {
     Object object = fromJson(json, (Type) classOfT);
     return Primitives.wrap(classOfT).cast(object);

File: gson/src/main/java/com/google/gson/stream/MalformedJsonException.java
Patch:
@@ -23,6 +23,8 @@
  * ignored by calling {@link JsonReader#setLenient(boolean)}.
  */
 public final class MalformedJsonException extends IOException {
+  private static final long serialVersionUID = 1L;
+
   public MalformedJsonException(String s) {
     super(s);
   }

File: gson/src/test/java/com/google/gson/functional/PrettyPrintingTest.java
Patch:
@@ -37,8 +37,6 @@
  * @author Joel Leitch
  */
 public class PrettyPrintingTest extends TestCase {
-  private static int PRINT_MARGIN = 80;
-  private static int RIGHT_MARGIN = 4;
 
   private static final boolean DEBUG = false;
 

File: wsclient/src/main/java/com/google/gson/webservice/client/RequestSender.java
Patch:
@@ -28,6 +28,7 @@
 import com.google.gson.webservice.definition.WebServiceSystemException;
 import com.google.gson.webservice.definition.procedural.RequestBody;
 import com.google.gson.webservice.definition.procedural.WebServiceRequest;
+import com.google.gson.wsclient.internal.utils.Streams;
 
 /**
  * Class to send Web service requests on a {@link HttpURLConnection}.

File: wsclient/src/main/java/com/google/gson/webservice/client/ResponseReceiver.java
Patch:
@@ -33,6 +33,7 @@
 import com.google.gson.webservice.definition.procedural.ResponseBodySpec;
 import com.google.gson.webservice.definition.procedural.ResponseSpec;
 import com.google.gson.webservice.definition.procedural.WebServiceResponse;
+import com.google.gson.wsclient.internal.utils.ConnectionPreconditions;
 
 /**
  * Receives a response coming on an {@link HttpURLConnection}.
@@ -91,7 +92,7 @@ private ResponseBody readResponseBody(HttpURLConnection conn, ResponseBodySpec b
       return new ResponseBody.Builder(bodySpec).build();
     }
     String connContentType = conn.getContentType();
-    Preconditions.checkArgument(connContentType.contains(bodySpec.getContentType()), conn);
+    ConnectionPreconditions.checkArgument(connContentType.contains(bodySpec.getContentType()), conn);
     Reader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
     ResponseBody body = gson.fromJson(reader, ResponseBody.class);
     return body;

File: wsclient/src/main/java/com/google/gson/webservice/client/ServerConfig.java
Patch:
@@ -20,10 +20,10 @@
  * 
  * @author inder
  */
-public final class WebServiceConfig {
+public final class ServerConfig {
   private final String serviceBaseUrl;
 
-  public WebServiceConfig(String serviceBaseUrl) {
+  public ServerConfig(String serviceBaseUrl) {
     this.serviceBaseUrl = serviceBaseUrl;
   }
 

File: wsclient/src/main/java/com/google/gson/webservice/client/WebServiceClientAsync.java
Patch:
@@ -36,10 +36,10 @@ public class WebServiceClientAsync {
   private final boolean threadPerTask;
   private final TaskExecutor executor;
 
-  public WebServiceClientAsync(WebServiceConfig serverConfig) {
+  public WebServiceClientAsync(ServerConfig serverConfig) {
     this(serverConfig, null);
   }
-  public WebServiceClientAsync(WebServiceConfig serverConfig, Level logLevel) {
+  public WebServiceClientAsync(ServerConfig serverConfig, Level logLevel) {
     this(new WebServiceClient(serverConfig, logLevel));
   }
 

File: wsdef/src/main/java/com/google/gson/rest/definition/HasId.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.definition.rest;
+package com.google.gson.rest.definition;
 
 /**
  * An interface to indicate that an object has an Id

File: wsdef/src/main/java/com/google/gson/rest/definition/Id.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.definition.rest;
+package com.google.gson.rest.definition;
 
 import com.google.gson.JsonDeserializationContext;
 import com.google.gson.JsonDeserializer;

File: wsdef/src/main/java/com/google/gson/rest/definition/MetaData.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.definition.rest;
+package com.google.gson.rest.definition;
 
 import java.lang.reflect.Type;
 import java.util.HashMap;

File: wsdef/src/main/java/com/google/gson/rest/definition/ResourceMap.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.definition.rest;
+package com.google.gson.rest.definition;
 
 import com.google.gson.webservice.definition.CallPath;
 import com.google.gson.webservice.definition.internal.utils.Preconditions;

File: wsdef/src/main/java/com/google/gson/rest/definition/RestCall.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.definition.rest;
+package com.google.gson.rest.definition;
 
 /**
  * The data associated with a Rest Web service call. This includes http request header parameters

File: wsdef/src/main/java/com/google/gson/rest/definition/RestRequest.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.definition.rest;
+package com.google.gson.rest.definition;
 
 import com.google.gson.webservice.definition.HeaderMap;
 import com.google.gson.webservice.definition.HttpMethod;

File: wsdef/src/main/java/com/google/gson/rest/definition/RestRequestSpec.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.definition.rest;
+package com.google.gson.rest.definition;
 
 import java.lang.reflect.Type;
 

File: wsdef/src/main/java/com/google/gson/rest/definition/RestResource.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.definition.rest;
+package com.google.gson.rest.definition;
 
 /**
  * An interface implemented by an object that is intended to be a rest resource

File: wsdef/src/main/java/com/google/gson/rest/definition/RestResponse.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.definition.rest;
+package com.google.gson.rest.definition;
 
 import java.lang.reflect.Type;
 

File: wsdef/src/main/java/com/google/gson/rest/definition/RestResponseSpec.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.definition.rest;
+package com.google.gson.rest.definition;
 
 import java.lang.reflect.Type;
 

File: wsdef/src/test/java/com/google/gson/rest/definition/IdTest.java
Patch:
@@ -13,13 +13,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.definition.rest;
+package com.google.gson.rest.definition;
 
 import java.lang.reflect.ParameterizedType;
 
 import junit.framework.TestCase;
 
 import com.google.gson.reflect.TypeToken;
+import com.google.gson.rest.definition.Id;
 
 /**
  * Unit test for {@link Id}

File: wsdef/src/test/java/com/google/gson/rest/definition/IdTypeAdapterTest.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.definition.rest;
+package com.google.gson.rest.definition;
 
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -25,7 +25,7 @@
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.reflect.TypeToken;
-import com.google.gson.webservice.definition.rest.Id;
+import com.google.gson.rest.definition.Id;
 
 /**
  * Unit tests for {@link IdTypeAdapter}

File: wsf/src/main/java/com/google/gson/rest/server/IdMap.java
Patch:
@@ -13,16 +13,16 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.wsf.server.rest;
+package com.google.gson.rest.server;
 
 import java.lang.reflect.Type;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import com.google.gson.webservice.definition.rest.HasId;
-import com.google.gson.webservice.definition.rest.Id;
+import com.google.gson.rest.definition.HasId;
+import com.google.gson.rest.definition.Id;
 
 /**
  * This class provides a type-safe map to access values associated with Ids

File: wsf/src/main/java/com/google/gson/rest/server/Repository.java
Patch:
@@ -13,10 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.wsf.server.rest;
+package com.google.gson.rest.server;
 
-import com.google.gson.webservice.definition.rest.HasId;
-import com.google.gson.webservice.definition.rest.Id;
+import com.google.gson.rest.definition.HasId;
+import com.google.gson.rest.definition.Id;
 
 /**
  * An interface for a repository of rest resources. Meant for abstracting the server-side

File: wsf/src/main/java/com/google/gson/rest/server/RestResponseSender.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.wsf.server.rest;
+package com.google.gson.rest.server;
 
 import java.io.IOException;
 import java.lang.reflect.Type;
@@ -23,11 +23,11 @@
 import javax.servlet.http.HttpServletResponse;
 
 import com.google.gson.Gson;
+import com.google.gson.rest.definition.RestResource;
+import com.google.gson.rest.definition.RestResponse;
 import com.google.gson.webservice.definition.ContentBodySpec;
 import com.google.gson.webservice.definition.HeaderMap;
 import com.google.gson.webservice.definition.HeaderMapSpec;
-import com.google.gson.webservice.definition.rest.RestResource;
-import com.google.gson.webservice.definition.rest.RestResponse;
 
 /**
  * Sends a JSON web service response on {@link HttpServletResponse}.

File: wsf/src/main/java/com/google/gson/wsf/inject/server/procedural/RequestBodySpecProvider.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.wsf.inject;
+package com.google.gson.wsf.inject.server.procedural;
 
 import com.google.gson.webservice.definition.procedural.RequestBodySpec;
 import com.google.gson.webservice.definition.procedural.RequestSpec;

File: wsf/src/main/java/com/google/gson/wsf/inject/server/procedural/RequestSpecProvider.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.wsf.inject;
+package com.google.gson.wsf.inject.server.procedural;
 
 import com.google.gson.webservice.definition.procedural.RequestSpec;
 import com.google.gson.webservice.definition.procedural.WebServiceCallSpec;

File: wsdef/src/main/java/com/google/gson/webservice/definition/WebServiceSystemException.java
Patch:
@@ -23,7 +23,7 @@
  */
 public class WebServiceSystemException extends RuntimeException {
 
-  private static final long serialVersionUID = -2511829073381716183L;
+  private static final long serialVersionUID = 1L;
 
   public WebServiceSystemException(Exception cause) {
     super(cause);

File: wsdef/src/test/java/com/google/gson/webservice/definition/rest/IdTypeAdapterTest.java
Patch:
@@ -55,7 +55,6 @@ protected void setUp() {
 
   public void testSerializeId() {
     String json = gson.toJson(course, TYPE_COURSE_HISTORY);
-    System.out.println(json);
     assertTrue(json.contains(String.valueOf(COURSE_ID.getValue())));
     assertTrue(json.contains(String.valueOf(STUDENT1_ID.getValue())));
     assertTrue(json.contains(String.valueOf(STUDENT2_ID.getValue())));

File: wsclient/src/main/java/com/google/gson/webservice/client/QueueConsumer.java
Patch:
@@ -17,9 +17,9 @@
 
 import java.util.concurrent.BlockingQueue;
 
-import com.google.gson.webservice.definition.WebServiceCall;
-import com.google.gson.webservice.definition.WebServiceResponse;
 import com.google.gson.webservice.definition.WebServiceSystemException;
+import com.google.gson.webservice.definition.procedural.WebServiceCall;
+import com.google.gson.webservice.definition.procedural.WebServiceResponse;
 
 /**
  * A consumer that executes in its own thread consuming queue entries and invoking web-service calls

File: wsclient/src/main/java/com/google/gson/webservice/client/QueueEntry.java
Patch:
@@ -15,8 +15,8 @@
  */
 package com.google.gson.webservice.client;
 
-import com.google.gson.webservice.definition.WebServiceCallSpec;
-import com.google.gson.webservice.definition.WebServiceRequest;
+import com.google.gson.webservice.definition.procedural.WebServiceCallSpec;
+import com.google.gson.webservice.definition.procedural.WebServiceRequest;
 
 /**
  * A holder class for an entry stored in queue. It contains references to the request, callspec,

File: wsclient/src/main/java/com/google/gson/webservice/client/RequestSender.java
Patch:
@@ -25,9 +25,9 @@
 import com.google.gson.Gson;
 import com.google.gson.webservice.definition.HeaderMap;
 import com.google.gson.webservice.definition.HeaderMapSpec;
-import com.google.gson.webservice.definition.RequestBody;
-import com.google.gson.webservice.definition.WebServiceRequest;
 import com.google.gson.webservice.definition.WebServiceSystemException;
+import com.google.gson.webservice.definition.procedural.RequestBody;
+import com.google.gson.webservice.definition.procedural.WebServiceRequest;
 
 /**
  * Class to send Web service requests on a {@link HttpURLConnection}.

File: wsclient/src/main/java/com/google/gson/webservice/client/ResponseCallback.java
Patch:
@@ -15,10 +15,10 @@
  */
 package com.google.gson.webservice.client;
 
-import com.google.gson.webservice.definition.WebServiceCall;
-import com.google.gson.webservice.definition.WebServiceCallSpec;
-import com.google.gson.webservice.definition.WebServiceRequest;
 import com.google.gson.webservice.definition.WebServiceSystemException;
+import com.google.gson.webservice.definition.procedural.WebServiceCall;
+import com.google.gson.webservice.definition.procedural.WebServiceCallSpec;
+import com.google.gson.webservice.definition.procedural.WebServiceRequest;
 
 /**
  * A client-supplied callback to be used with {@link WebServiceClientAsync}. When a web-service

File: wsclient/src/main/java/com/google/gson/webservice/client/WebServiceClientAsync.java
Patch:
@@ -19,9 +19,9 @@
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.logging.Level;
 
-import com.google.gson.webservice.definition.WebServiceCallSpec;
-import com.google.gson.webservice.definition.WebServiceRequest;
 import com.google.gson.webservice.definition.WebServiceSystemException;
+import com.google.gson.webservice.definition.procedural.WebServiceCallSpec;
+import com.google.gson.webservice.definition.procedural.WebServiceRequest;
 
 /**
  * A client for invoking a JSON-based Web-service in an asynchronous manner. The call is queued,

File: wsdef/src/main/java/com/google/gson/webservice/definition/ContentBody.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.google.gson.webservice.definition;
 
+
 import java.util.Map;
 
 /**
@@ -24,9 +25,9 @@
  * 
  * @author inder
  */
-class ContentBody extends ParamMap {
+public class ContentBody extends ParamMap {
   
-  ContentBody(ContentBodySpec spec, Map<String, Object> contents) {
+  public ContentBody(ContentBodySpec spec, Map<String, Object> contents) {
     super(spec, contents);
   }
   

File: wsdef/src/main/java/com/google/gson/webservice/definition/ContentBodySpec.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.google.gson.webservice.definition;
 
+
 import java.lang.reflect.Type;
 import java.util.Collections;
 import java.util.Map;

File: wsdef/src/main/java/com/google/gson/webservice/definition/HeaderMap.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.google.gson.webservice.definition;
 
+
 import java.lang.reflect.Type;
 import java.util.Map;
 

File: wsdef/src/main/java/com/google/gson/webservice/definition/HeaderMapSpec.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.google.gson.webservice.definition;
 
+
 import java.lang.reflect.Type;
 import java.util.LinkedHashMap;
 import java.util.Map;

File: wsdef/src/main/java/com/google/gson/webservice/definition/ParamMap.java
Patch:
@@ -15,12 +15,14 @@
  */
 package com.google.gson.webservice.definition;
 
+import com.google.gson.webservice.definition.internal.utils.Preconditions;
+
 import java.lang.reflect.Type;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
 
-class ParamMap {
+public class ParamMap {
 
   public static class Builder<T extends ParamMapSpec> {    
     protected final Map<String, Object> contents = new LinkedHashMap<String, Object>();

File: wsdef/src/main/java/com/google/gson/webservice/definition/ParamMapSpec.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.google.gson.webservice.definition;
 
+
 import java.lang.reflect.Type;
 import java.util.Map;
 import java.util.Set;

File: wsdef/src/main/java/com/google/gson/webservice/definition/TypedKey.java
Patch:
@@ -15,6 +15,8 @@
  */
 package com.google.gson.webservice.definition;
 
+import com.google.gson.webservice.definition.internal.utils.Preconditions;
+
 /**
  * A typed key for use in a {@link ParamMap} or a {@link ParamMapSpec}.
  *

File: wsdef/src/main/java/com/google/gson/webservice/definition/WebServiceSystemException.java
Patch:
@@ -17,9 +17,8 @@
 
 /**
  * Base class for all exceptions thrown by the Web service to indicate a system error condition. 
- * This should never be thrown to indicate bad user input. For that purpose, use 
- * {@link WebServiceAppException}.
- * 
+ * This should never be thrown to indicate bad user input.
+ *
  * @author inder
  */
 public class WebServiceSystemException extends RuntimeException {

File: wsdef/src/main/java/com/google/gson/webservice/definition/internal/utils/Preconditions.java
Patch:
@@ -13,9 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.definition;
+package com.google.gson.webservice.definition.internal.utils;
 
-final class Preconditions {
+public final class Preconditions {
 
   public static void checkArgument(boolean condition) {
     if (!condition) {

File: wsdef/src/main/java/com/google/gson/webservice/definition/procedural/RequestBodyGsonConverter.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.typeadapters;
+package com.google.gson.webservice.definition.procedural;
 
 import java.lang.reflect.Type;
 import java.util.Map;
@@ -26,8 +26,6 @@
 import com.google.gson.JsonParseException;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
-import com.google.gson.webservice.definition.RequestBody;
-import com.google.gson.webservice.definition.RequestBodySpec;
 
 /**
  * Gson type adapter for {@link RequestBody}. 

File: wsdef/src/main/java/com/google/gson/webservice/definition/procedural/ResponseBodyGsonConverter.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.typeadapters;
+package com.google.gson.webservice.definition.procedural;
 
 import java.lang.reflect.Type;
 import java.util.Map;
@@ -26,8 +26,6 @@
 import com.google.gson.JsonParseException;
 import com.google.gson.JsonSerializationContext;
 import com.google.gson.JsonSerializer;
-import com.google.gson.webservice.definition.ResponseBody;
-import com.google.gson.webservice.definition.ResponseBodySpec;
 
 /**
  * Gson type adapter for {@link ResponseBody}. 

File: wsdef/src/main/java/com/google/gson/webservice/definition/procedural/ResponseBodySpec.java
Patch:
@@ -13,7 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.definition;
+package com.google.gson.webservice.definition.procedural;
+
+import com.google.gson.webservice.definition.ContentBodySpec;
 
 import java.lang.reflect.Type;
 import java.util.LinkedHashMap;

File: wsdef/src/main/java/com/google/gson/webservice/definition/procedural/WebServiceCall.java
Patch:
@@ -13,7 +13,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.definition;
+package com.google.gson.webservice.definition.procedural;
+
 
 /**
  * The data associated with a Web service call. This includes http request header parameters (form 

File: wsdef/src/main/java/com/google/gson/webservice/definition/procedural/WebServiceSpec.java
Patch:
@@ -13,7 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.definition;
+package com.google.gson.webservice.definition.procedural;
+
+import com.google.gson.webservice.definition.CallPathMap;
 
 /**
  * Specification of the Web service. This contains a specification of all the 

File: wsdef/src/main/java/com/google/gson/webservice/definition/rest/ResourceMap.java
Patch:
@@ -15,11 +15,12 @@
  */
 package com.google.gson.webservice.definition.rest;
 
+import com.google.gson.webservice.definition.CallPath;
+import com.google.gson.webservice.definition.internal.utils.Preconditions;
+
 import java.util.HashMap;
 import java.util.Map;
 
-import com.google.gson.webservice.definition.CallPath;
-
 /**
  * A {@link Map} of {@link CallPath} to {@link RestCallSpec}
  *

File: wsdef/src/test/java/com/google/gson/webservice/definition/rest/IdTypeAdapterTest.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.google.gson.webservice.typeadapters;
+package com.google.gson.webservice.definition.rest;
 
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -47,7 +47,7 @@ public class IdTypeAdapterTest extends TestCase {
   @Override
   protected void setUp() {
     gson = new GsonBuilder()
-        .registerTypeAdapter(Id.class, new IdTypeAdapter())
+        .registerTypeAdapter(Id.class, new Id.GsonTypeAdapter())
         .create();
     course = new Course<HistoryCourse>(COURSE_ID, 4,
         new Assignment<HistoryCourse>(null, null), createList(STUDENT1, STUDENT2));

File: wsexample/definition/src/main/java/com/google/gson/example/service/SampleJsonService.java
Patch:
@@ -17,7 +17,7 @@
 import com.google.gson.example.model.TypedKeys;
 import com.google.gson.webservice.definition.CallPath;
 import com.google.gson.webservice.definition.HttpMethod;
-import com.google.gson.webservice.definition.WebServiceCallSpec;
+import com.google.gson.webservice.definition.procedural.WebServiceCallSpec;
 
 /**
  * An example of a web-service definition

File: wsf/src/main/java/com/google/gson/wsf/inject/RequestBodySpecProvider.java
Patch:
@@ -15,8 +15,8 @@
  */
 package com.google.gson.wsf.inject;
 
-import com.google.gson.webservice.definition.RequestBodySpec;
-import com.google.gson.webservice.definition.RequestSpec;
+import com.google.gson.webservice.definition.procedural.RequestBodySpec;
+import com.google.gson.webservice.definition.procedural.RequestSpec;
 import com.google.inject.Inject;
 import com.google.inject.Provider;
 

File: wsf/src/main/java/com/google/gson/wsf/inject/RequestSpecProvider.java
Patch:
@@ -15,8 +15,8 @@
  */
 package com.google.gson.wsf.inject;
 
-import com.google.gson.webservice.definition.RequestSpec;
-import com.google.gson.webservice.definition.WebServiceCallSpec;
+import com.google.gson.webservice.definition.procedural.RequestSpec;
+import com.google.gson.webservice.definition.procedural.WebServiceCallSpec;
 import com.google.inject.Inject;
 import com.google.inject.Provider;
 

File: wsf/src/main/java/com/google/gson/wsf/inject/WebServiceCallSpecProvider.java
Patch:
@@ -16,8 +16,8 @@
 package com.google.gson.wsf.inject;
 
 import com.google.gson.webservice.definition.CallPath;
-import com.google.gson.webservice.definition.WebServiceCallSpec;
-import com.google.gson.webservice.definition.WebServiceSpec;
+import com.google.gson.webservice.definition.procedural.WebServiceCallSpec;
+import com.google.gson.webservice.definition.procedural.WebServiceSpec;
 import com.google.inject.Inject;
 import com.google.inject.Provider;
 

File: wsf/src/main/java/com/google/gson/wsf/server/ResponseBuilder.java
Patch:
@@ -15,9 +15,9 @@
  */
 package com.google.gson.wsf.server;
 
-import com.google.gson.webservice.definition.WebServiceCallSpec;
-import com.google.gson.webservice.definition.WebServiceRequest;
-import com.google.gson.webservice.definition.WebServiceResponse;
+import com.google.gson.webservice.definition.procedural.WebServiceCallSpec;
+import com.google.gson.webservice.definition.procedural.WebServiceRequest;
+import com.google.gson.webservice.definition.procedural.WebServiceResponse;
 
 /**
  * An interface describing a class that can build a response

File: wsf/src/main/java/com/google/gson/wsf/server/ResponseSender.java
Patch:
@@ -25,8 +25,8 @@
 import com.google.gson.Gson;
 import com.google.gson.webservice.definition.HeaderMap;
 import com.google.gson.webservice.definition.HeaderMapSpec;
-import com.google.gson.webservice.definition.ResponseBody;
-import com.google.gson.webservice.definition.WebServiceResponse;
+import com.google.gson.webservice.definition.procedural.ResponseBody;
+import com.google.gson.webservice.definition.procedural.WebServiceResponse;
 
 /**
  * Sends a JSON web service response on {@link HttpServletResponse}.

File: wsf/src/main/java/com/google/gson/wsf/server/WebServiceCallServerBuilder.java
Patch:
@@ -15,9 +15,9 @@
  */
 package com.google.gson.wsf.server;
 
-import com.google.gson.webservice.definition.WebServiceCallSpec;
-import com.google.gson.webservice.definition.WebServiceRequest;
-import com.google.gson.webservice.definition.WebServiceResponse.Builder;
+import com.google.gson.webservice.definition.procedural.WebServiceCallSpec;
+import com.google.gson.webservice.definition.procedural.WebServiceRequest;
+import com.google.gson.webservice.definition.procedural.WebServiceResponse.Builder;
 
 public class WebServiceCallServerBuilder {
 

File: wsclient/src/main/java/com/google/gson/webservice/client/TaskExecutor.java
Patch:
@@ -19,7 +19,7 @@
 
 /**
  * An {@link Executor} with an additional method for shutdown. We could have just used
- * {@link java.util.concurent.ExecutorService}, however, that requires too many methods to be
+ * {@link java.util.concurrent.ExecutorService}, however, that requires too many methods to be
  * implemented.
  *  
  * @author inder

File: wsdef/src/main/java/com/google/gson/webservice/definition/HeaderMapSpec.java
Patch:
@@ -44,10 +44,12 @@ private HeaderMapSpec(Map<String, Type> map) {
     this.map = map;
   }  
   
+  @Override
   public Type getTypeFor(String headerName) {
     return map.get(headerName);
   }
   
+  @Override
   public Set<Map.Entry<String, Type>> entrySet() {
     return map.entrySet();
   }
@@ -63,6 +65,7 @@ public boolean checkIfCompatible(String headerName, Type targetType) {
     return rawClassOfHeader.isAssignableFrom(rawClassOfTargetType);
   }
 
+  @Override
   public boolean checkIfCompatible(String headerName, Object headerValue) {
     return checkIfCompatible(headerName, headerValue.getClass());
   }

File: wsdef/src/main/java/com/google/gson/webservice/definition/rest/HasId.java
Patch:
@@ -20,7 +20,7 @@
  *
  * @author inder
  *
- * @param <T> type of object
+ * @param <R> type of object
  */
 public interface HasId<R> {
   public Id<R> getId();

File: wsdef/src/main/java/com/google/gson/webservice/definition/rest/MetaData.java
Patch:
@@ -62,7 +62,7 @@ private MetaData(Map<String, String> values) {
   }
 
   public String getString(String key) {
-    return (String) map.get(key);
+    return map.get(key);
   }
 
   public void putString(String key, String value) {
@@ -83,7 +83,7 @@ public void remove(String key) {
   }
 
   public Object getFromTransient(Object key) {
-    return (String) mapTransient.get(key);
+    return mapTransient.get(key);
   }
 
   public void putInTransient(Object key, Object value) {

File: wsdef/src/main/java/com/google/gson/webservice/definition/rest/ResourceMap.java
Patch:
@@ -49,6 +49,6 @@ public ResourceMap(Map<CallPath, RestCallSpec> resources) {
   }
 
   public RestCallSpec get(CallPath callPath) {
-    return (RestCallSpec)resources.get(callPath);
+    return resources.get(callPath);
   }
 }

File: wsf/src/main/java/com/google/gson/wsf/server/rest/IdMap.java
Patch:
@@ -38,7 +38,7 @@ public class IdMap<T extends HasId<T>> {
   private final Type typeOfId;
 
   /**
-   * Use {@link #create(Class)} instead of constructor
+   * Use {@link #create(Type)} instead of constructor
    */
   protected IdMap(Type typeOfId) {
     this.typeOfId = typeOfId;

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -1104,7 +1104,7 @@ private void decodeLiteral() throws IOException {
    * with this reader's content.
    */
   private IOException syntaxError(String message) throws IOException {
-    throw new JsonSyntaxException(message + " near " + getSnippet());
+    throw new MalformedJsonException(message + " near " + getSnippet());
   }
 
   private CharSequence getSnippet() {

File: gson/src/main/java/com/google/gson/stream/MalformedJsonException.java
Patch:
@@ -22,8 +22,8 @@
  * Thrown when a reader encounters malformed JSON. Some syntax errors can be
  * ignored by calling {@link JsonReader#setLenient(boolean)}.
  */
-public final class JsonSyntaxException extends IOException {
-  public JsonSyntaxException(String s) {
+public final class MalformedJsonException extends IOException {
+  public MalformedJsonException(String s) {
     super(s);
   }
 }

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -429,9 +429,9 @@ private <T> GsonBuilder registerDeserializer(Type typeOfT, JsonDeserializer<T> d
    * @param typeAdapter This object must implement at least one of the {@link InstanceCreator},
    * {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.
    * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
-   * @since 1.5
+   * @since 1.6
    */
-  GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {
+  public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {
     Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>
     || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);
     if (typeAdapter instanceof InstanceCreator<?>) {

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -179,8 +179,9 @@
  *
  * <p>Each {@code JsonReader} may be used to read a single JSON stream. Instances
  * of this class are not thread safe.
- * 
+ *
  * @author Jesse Wilson
+ * @since 1.6
  */
 public final class JsonReader implements Closeable {
 

File: gson/src/main/java/com/google/gson/stream/JsonScope.java
Patch:
@@ -20,6 +20,7 @@
  * Lexical scoping elements within a JSON reader or writer.
  *
  * @author Jesse Wilson
+ * @since 1.6
  */
 enum JsonScope {
 

File: gson/src/main/java/com/google/gson/stream/JsonToken.java
Patch:
@@ -20,6 +20,7 @@
  * A structure, name or value type in a JSON-encoded string.
  *
  * @author Jesse Wilson
+ * @since 1.6
  */
 public enum JsonToken {
 

File: gson/src/main/java/com/google/gson/stream/JsonWriter.java
Patch:
@@ -116,8 +116,9 @@
  * <p>Each {@code JsonWriter} may be used to write a single JSON stream.
  * Instances of this class are not thread safe. Calls that would result in a
  * malformed JSON string will fail with an {@link IllegalStateException}.
- * 
+ *
  * @author Jesse Wilson
+ * @since 1.6
  */
 public final class JsonWriter implements Closeable {
 

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -415,6 +415,9 @@ public <T> T fromJson(String json, Class<T> classOfT) throws JsonParseException
    */
   @SuppressWarnings("unchecked")
   public <T> T fromJson(String json, Type typeOfT) throws JsonParseException {
+    if (json == null) {
+      return null;
+    }
     StringReader reader = new StringReader(json);
     T target = (T) fromJson(reader, typeOfT);
     return target;

File: gson/src/main/java/com/google/gson/JsonParseException.java
Patch:
@@ -29,7 +29,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
-public final class JsonParseException extends RuntimeException {
+public class JsonParseException extends RuntimeException {
   static final long serialVersionUID = -4086729973971783390L;
 
   /**

File: gson/src/main/java/com/google/gson/Streams.java
Patch:
@@ -18,6 +18,7 @@
 
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
+
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.Writer;
@@ -71,7 +72,7 @@ static JsonElement parse(JsonReader reader) throws JsonParseException {
       if (e instanceof EOFException) {
         return JsonNull.createJsonNull();
       }
-      throw new JsonParseException(e);
+      throw new JsonIOException(e);
     } catch (NumberFormatException e) {
       throw new JsonParseException(e);
     }

File: wsdef/src/main/java/com/google/gson/webservice/definition/rest/RestResource.java
Patch:
@@ -23,5 +23,4 @@
  * @param <R> the rest resource type
  */
 public interface RestResource<R> extends HasId<R> {
-
 }

File: wsclient/src/main/java/com/google/gson/webservice/client/RestRequestSender.java
Patch:
@@ -27,6 +27,7 @@
 import com.google.gson.webservice.definition.HeaderMapSpec;
 import com.google.gson.webservice.definition.WebServiceSystemException;
 import com.google.gson.webservice.definition.rest.RestRequest;
+import com.google.gson.webservice.definition.rest.RestResource;
 
 /**
  * Class to send Web service requests on a {@link HttpURLConnection}.
@@ -48,7 +49,7 @@ public RestRequestSender(Gson gson, Level logLevel) {
     this.logLevel = logLevel;
   }
   
-  public <R> void send(HttpURLConnection conn, RestRequest<R> request) {    
+  public <R extends RestResource<R>> void send(HttpURLConnection conn, RestRequest<R> request) {    
     try {
       conn.setRequestMethod(request.getHttpMethod().toString());
       setHeader(conn, "Content-Type", request.getContentType(), true);
@@ -63,7 +64,7 @@ public <R> void send(HttpURLConnection conn, RestRequest<R> request) {
       // Android Java VM ignore Content-Length if setDoOutput is not set
       conn.setDoOutput(true);
       if (requestBody != null) {
-        requestBodyContents = gson.toJson(requestBody);
+        requestBodyContents = gson.toJson(requestBody, request.getSpec().getResourceType());
       }
       String contentLength = String.valueOf(requestBodyContents.length());
       setHeader(conn, "Content-Length", contentLength, true);

File: wsf/src/main/java/com/google/gson/wsf/server/rest/RestResponseSender.java
Patch:
@@ -26,14 +26,15 @@
 import com.google.gson.webservice.definition.ContentBodySpec;
 import com.google.gson.webservice.definition.HeaderMap;
 import com.google.gson.webservice.definition.HeaderMapSpec;
+import com.google.gson.webservice.definition.rest.RestResource;
 import com.google.gson.webservice.definition.rest.RestResponse;
 
 /**
  * Sends a JSON web service response on {@link HttpServletResponse}.
  * 
  * @author inder
  */
-public final class RestResponseSender<R> {
+public final class RestResponseSender<R extends RestResource<R>> {
   private static final Logger logger = Logger.getLogger(RestResponseSender.class.getCanonicalName());
 
   private Gson gson;

File: wsclient/src/main/java/com/google/gson/webservice/client/RequestSender.java
Patch:
@@ -69,9 +69,7 @@ public void send(HttpURLConnection conn, WebServiceRequest request) {
       String contentLength = String.valueOf(requestBodyContents.length());
       setHeader(conn, "Content-Length", contentLength, true);
       addRequestParams(conn, request.getHeaders());
-      if (requestBodyContents != null) {
-        Streams.copy(requestBodyContents, conn.getOutputStream(), false);
-      }
+      Streams.copy(requestBodyContents, conn.getOutputStream(), false);
       
       // Initiate the sending of the request.
       conn.connect();

File: wsclient/src/main/java/com/google/gson/webservice/client/Streams.java
Patch:
@@ -37,8 +37,8 @@ static void copy(InputStream src, OutputStream dst, boolean closeInput, boolean
         dst.write(buf, 0, count);
       }
     } finally {
-      src.close();
-      dst.close();
+      if (closeInput) src.close();
+      if (closeOutput) dst.close();
     }
   }
 }

File: wsclient/src/main/java/com/google/gson/webservice/client/RestClient.java
Patch:
@@ -34,7 +34,7 @@
  * 
  * @author inder
  */
-public final class RestClient {
+public class RestClient {
   private final WebServiceConfig config;
   private final Logger logger;
   private final Level logLevel;

File: wsdef/src/main/java/com/google/gson/webservice/definition/TypeUtils.java
Patch:
@@ -40,7 +40,6 @@ final class TypeUtils {
    * </pre>
    * <code>TypeUtils.getActualTypeForFirstTypeVariable(fooType)</code> will return Integer.class.
    */
-  @SuppressWarnings("unchecked")
   static Type getActualTypeForFirstTypeVariable(Type type) {
     if (type instanceof Class) {
       return Object.class;
@@ -54,7 +53,6 @@ static Type getActualTypeForFirstTypeVariable(Type type) {
     }
   }
 
-  @SuppressWarnings("unchecked")
   static boolean isArray(Type type) {
     if (type instanceof Class) {
       return ((Class<?>)type).isArray();
@@ -68,7 +66,6 @@ static boolean isArray(Type type) {
   /**
    * This method returns the actual raw class associated with the specified type.
    */
-  @SuppressWarnings("unchecked")
   static Class<?> toRawClass(Type type) {
     if (type instanceof Class) {
       return (Class<?>) type;

File: wsexample/server/src/main/java/com/google/gson/wsexample/server/MainServlet.java
Patch:
@@ -43,6 +43,7 @@
  *
  * @author inder
  */
+@SuppressWarnings("serial")
 public class MainServlet extends HttpServlet {
   @Override
   public void service(HttpServletRequest req, HttpServletResponse res) {

File: gson/src/main/java/com/google/gson/stream/JsonReader.java
Patch:
@@ -748,7 +748,7 @@ private JsonToken nextInObject(boolean firstElement) throws IOException {
       checkLenient();
       pos--;
       name = nextLiteral();
-      if (name.isEmpty()) {
+      if (name.length() == 0) {
         throw syntaxError("Expected name");
       }
     }
@@ -1071,7 +1071,7 @@ private char readEscapeCharacter() throws IOException {
    */
   private JsonToken readLiteral() throws IOException {
     String literal = nextLiteral();
-    if (literal.isEmpty()) {
+    if (literal.length() == 0) {
       throw syntaxError("Expected literal value");
     }
     value = literal;

File: gson/src/main/java/com/google/gson/stream/JsonWriter.java
Patch:
@@ -165,7 +165,7 @@ public JsonWriter(Writer out) {
    * @param indent a string containing only whitespace.
    */
   public void setIndent(String indent) {
-    if (indent.isEmpty()) {
+    if (indent.length() == 0) {
       this.indent = null;
       this.separator = ":";
     } else {

File: gson/src/test/java/com/google/gson/stream/JsonWriterTest.java
Patch:
@@ -178,7 +178,7 @@ public void testDoubles() throws IOException {
     jsonWriter.value(Double.MIN_VALUE);
     jsonWriter.value(0.0);
     jsonWriter.value(-0.5);
-    jsonWriter.value(Double.MIN_NORMAL);
+    jsonWriter.value(2.2250738585072014E-308);
     jsonWriter.value(Math.PI);
     jsonWriter.value(Math.E);
     jsonWriter.endArray();

File: gson/src/main/java/com/google/gson/JsonObject.java
Patch:
@@ -52,7 +52,7 @@ public JsonObject() {
    * @param value the member object.
    */
   public void add(String property, JsonElement value) {
-    Preconditions.checkArgument(property != null && !"".equals(property.trim()));
+    Preconditions.checkArgument(property != null);
     if (value == null) {
       value = JsonNull.createJsonNull();
     }

File: gson/src/main/java/com/google/gson/AnonymousAndLocalClassExclusionStrategy.java
Patch:
@@ -33,6 +33,7 @@ public boolean shouldSkipClass(Class<?> clazz) {
   }
 
   private boolean isAnonymousOrLocal(Class<?> clazz) {
-    return clazz.isAnonymousClass() || clazz.isLocalClass();
+    return !Enum.class.isAssignableFrom(clazz)
+        && (clazz.isAnonymousClass() || clazz.isLocalClass());
   }
 }

File: gson/src/main/java/com/google/gson/JsonObject.java
Patch:
@@ -53,7 +53,6 @@ public JsonObject() {
    */
   public void add(String property, JsonElement value) {
     Preconditions.checkArgument(property != null && !"".equals(property.trim()));
-
     if (value == null) {
       value = JsonNull.createJsonNull();
     }
@@ -205,7 +204,7 @@ protected void toString(Appendable sb, Escaper escaper) throws IOException {
         sb.append(',');
       }
       sb.append('\"');
-      sb.append(entry.getKey());
+      sb.append(escaper.escapeJsonString(entry.getKey()));
       sb.append("\":");
       entry.getValue().toString(sb, escaper);
     }

File: gson/src/main/java/com/google/gson/DefaultTypeAdapters.java
Patch:
@@ -196,7 +196,7 @@ private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInst
     return map;
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({ "unchecked", "rawtypes" })
   private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer) {
     return new JsonDeserializerExceptionWrapper(deserializer);
   }
@@ -569,7 +569,7 @@ public Properties createInstance(Type type) {
     }    
   }
   
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({ "unchecked", "rawtypes" })
   static class MapTypeAdapter implements JsonSerializer<Map>, JsonDeserializer<Map>,
       InstanceCreator<Map> {
     

File: gson/src/main/java/com/google/gson/FieldNamingStrategy2Adapter.java
Patch:
@@ -31,6 +31,7 @@ public FieldNamingStrategy2Adapter(FieldNamingStrategy adaptee) {
     this.adaptee = adaptee;
   }
   
+  @SuppressWarnings("deprecation")
   public String translateName(FieldAttributes f) {
     return adaptee.translateName(f.getFieldObject());
   }

File: gson/src/main/java/com/google/gson/JsonSerializationVisitor.java
Patch:
@@ -172,7 +172,7 @@ public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {
   /**
    * objTypePair.getObject() must not be null
    */
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({ "unchecked", "rawtypes" })
   private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) {
     Pair<JsonSerializer<?>,ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers);
     if (pair == null) {

File: gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java
Patch:
@@ -133,7 +133,6 @@ public synchronized T getHandlerFor(Type type) {
     return handler;
   }
 
-  @SuppressWarnings("unchecked")
   private T getHandlerForTypeHierarchy(Class<?> type) {
     for (Pair<Class<?>, T> entry : typeHierarchyList) {
       if (entry.first.isAssignableFrom(type)) {

File: gson/src/test/java/com/google/gson/DefaultMapJsonSerializerTest.java
Patch:
@@ -32,7 +32,7 @@
  */
 public class DefaultMapJsonSerializerTest extends TestCase {
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings("rawtypes")
   private JsonSerializer<Map> mapSerializer;
 
   @Override

File: gson/src/test/java/com/google/gson/JsonObjectTest.java
Patch:
@@ -18,9 +18,6 @@
 
 import junit.framework.TestCase;
 
-import java.util.HashMap;
-import java.util.Map;
-
 /**
  * Unit test for the {@link JsonObject} class.
  *

File: gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java
Patch:
@@ -75,7 +75,7 @@ private String getExpectedJson(Object obj) {
     public int hashCode() {
       return value == null ? 0 : value.hashCode();
     }
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings("rawtypes")
     @Override
     public boolean equals(Object obj) {
       if (this == obj) {

File: gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
Patch:
@@ -357,7 +357,6 @@ public void testDateDeserializationWithPattern() throws Exception {
     assertEquals(now.getDay(), extracted.getDay());
   }
 
-  @SuppressWarnings("deprecation")
   public void testDateSerializationWithPatternNotOverridenByTypeAdapter() throws Exception {
     String pattern = "yyyy-MM-dd";
     DateFormat formatter = new SimpleDateFormat(pattern);

File: gson/src/test/java/com/google/gson/functional/MapTest.java
Patch:
@@ -63,7 +63,7 @@ public void testMapDeserialization() {
     assertEquals(2, target.get("b").intValue());
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({ "unchecked", "rawtypes" })
   public void testRawMapSerialization() {
     Map map = new LinkedHashMap();
     map.put("a", 1);
@@ -154,7 +154,7 @@ public void testParameterizedMapSubclassSerialization() {
     assertTrue(json.contains("\"a\":\"b\""));
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings("rawtypes")
   public void testParameterizedMapSubclassDeserialization() {
     Type type = new TypeToken<MyParameterizedMap<String, Integer>>() {}.getType();
     Gson gson = new GsonBuilder().registerTypeAdapter(type, 

File: gson/src/test/java/com/google/gson/functional/ObjectTest.java
Patch:
@@ -96,14 +96,14 @@ public void testClassWithTransientFieldsSerialization() throws Exception {
     assertEquals(target.getExpectedJson(), gson.toJson(target));
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings("rawtypes")
   public void testClassWithTransientFieldsDeserialization() throws Exception {
     String json = "{\"longValue\":[1]}";
     ClassWithTransientFields target = gson.fromJson(json, ClassWithTransientFields.class);
     assertEquals(json, target.getExpectedJson());
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings("rawtypes")
   public void testClassWithTransientFieldsDeserializationTransientFieldsPassedInJsonAreIgnored()
       throws Exception {
     String json = "{\"transientLongValue\":1,\"longValue\":[1]}";

File: gson/src/main/java/com/google/gson/DefaultTypeAdapters.java
Patch:
@@ -62,7 +62,7 @@ final class DefaultTypeAdapters {
   private static final DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER =
     new DefaultTimestampDeserializer();
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({ "rawtypes" })
   private static final EnumTypeAdapter ENUM_TYPE_ADAPTER = new EnumTypeAdapter();
   private static final UrlTypeAdapter URL_TYPE_ADAPTER = new UrlTypeAdapter();
   private static final UriTypeAdapter URI_TYPE_ADAPTER = new UriTypeAdapter();
@@ -506,7 +506,7 @@ public String toString() {
     }
   }
 
-  @SuppressWarnings({ "unchecked" })
+  @SuppressWarnings({ "unchecked", "rawtypes" })
   private static class CollectionTypeAdapter implements JsonSerializer<Collection>, 
       JsonDeserializer<Collection>, InstanceCreator<Collection> {
     public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context) {

File: gson/src/test/java/com/google/gson/functional/CollectionTest.java
Patch:
@@ -201,7 +201,7 @@ public void testRawCollectionOfIntegersSerialization() {
     assertEquals("[1,2,3,4,5,6,7,8,9]", gson.toJson(target));
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({ "rawtypes" })
   public void testRawCollectionSerialization() {
     BagOfPrimitives bag1 = new BagOfPrimitives();
     Collection target = Arrays.asList(bag1, bag1);
@@ -223,7 +223,7 @@ public void testRawCollectionDeserializationNotAlllowed() {
     } catch (JsonParseException expected) { }
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({ "unchecked", "rawtypes" })
   public void testRawCollectionOfBagOfPrimitivesNotAllowed() {
     try {
       BagOfPrimitives bag = new BagOfPrimitives(10, 20, false, "stringValue");
@@ -276,7 +276,7 @@ public void testWildcardCollectionField() throws Exception {
     assertTrue(deserializedCollection.contains(objB));
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({ "rawtypes" })
   private static int[] toIntArray(Collection collection) {
     int[] ints = new int[collection.size()];
     int i = 0;

File: gson/src/test/java/com/google/gson/functional/PrintFormattingTest.java
Patch:
@@ -45,7 +45,7 @@ protected void setUp() throws Exception {
     gson = new Gson();
   }
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({ "unchecked", "rawtypes" })
   public void testCompactFormattingLeavesNoWhiteSpace() {
     List list = new ArrayList();
     list.add(new BagOfPrimitives());

File: gson/src/main/java/com/google/gson/FieldNamingStrategy.java
Patch:
@@ -26,9 +26,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  * @since 1.3
- * @deprecated use {@link FieldNamingStrategy2} instead
  */
-@Deprecated
 public interface FieldNamingStrategy {
 
   /**

File: gson/src/main/java/com/google/gson/FieldNamingStrategy2.java
Patch:
@@ -24,9 +24,9 @@
  *
  * @author Inderjeet Singh
  * @author Joel Leitch
- * @since 1.4
+ * @since 1.5
  */
-public interface FieldNamingStrategy2 {
+interface FieldNamingStrategy2 {
 
   /**
    * Translates the field name into its JSON field name representation.

File: gson/src/main/java/com/google/gson/FieldNamingStrategy2Adapter.java
Patch:
@@ -23,7 +23,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
-class FieldNamingStrategy2Adapter implements FieldNamingStrategy2 {
+final class FieldNamingStrategy2Adapter implements FieldNamingStrategy2 {
   private final FieldNamingStrategy adaptee;
 
   public FieldNamingStrategy2Adapter(FieldNamingStrategy adaptee) {

File: gson/src/main/java/com/google/gson/JavaFieldNamingPolicy.java
Patch:
@@ -42,7 +42,7 @@
  *
  * @author Joel Leitch
  */
-class JavaFieldNamingPolicy extends RecursiveFieldNamingPolicy {
+final class JavaFieldNamingPolicy extends RecursiveFieldNamingPolicy {
 
   @Override
   protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) {

File: gson/src/main/java/com/google/gson/JsonParserJavaccTokenManager.java
Patch:
@@ -2,7 +2,8 @@
 package com.google.gson;
 
 /** Token Manager. */
-class JsonParserJavaccTokenManager implements JsonParserJavaccConstants
+@SuppressWarnings("all")
+final class JsonParserJavaccTokenManager implements JsonParserJavaccConstants
 {
 
   /** Debug output. */

File: gson/src/main/java/com/google/gson/LowerCamelCaseSeparatorNamingPolicy.java
Patch:
@@ -35,7 +35,7 @@
  *
  * @author Joel Leitch
  */
-class LowerCamelCaseSeparatorNamingPolicy extends CompositionFieldNamingPolicy {
+final class LowerCamelCaseSeparatorNamingPolicy extends CompositionFieldNamingPolicy {
 
   public LowerCamelCaseSeparatorNamingPolicy(String separatorString) {
     super(new CamelCaseSeparatorNamingPolicy(separatorString), new LowerCaseNamingPolicy());

File: gson/src/main/java/com/google/gson/LowerCaseNamingPolicy.java
Patch:
@@ -40,7 +40,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
-class LowerCaseNamingPolicy extends RecursiveFieldNamingPolicy {
+final class LowerCaseNamingPolicy extends RecursiveFieldNamingPolicy {
 
   @Override
   protected String translateName(String target, Type fieldType,

File: gson/src/main/java/com/google/gson/LruCache.java
Patch:
@@ -27,7 +27,7 @@
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
-class LruCache<K, V> extends LinkedHashMap<K, V> implements Cache<K, V> {
+final class LruCache<K, V> extends LinkedHashMap<K, V> implements Cache<K, V> {
   private static final long serialVersionUID = 1L;
 
   private final int maxCapacity;

File: gson/src/main/java/com/google/gson/ModifyFirstLetterNamingPolicy.java
Patch:
@@ -46,7 +46,7 @@
  *
  * @author Joel Leitch
  */
-class ModifyFirstLetterNamingPolicy extends RecursiveFieldNamingPolicy {
+final class ModifyFirstLetterNamingPolicy extends RecursiveFieldNamingPolicy {
 
   public enum LetterModifier {
     UPPER,

File: gson/src/main/java/com/google/gson/UpperCamelCaseSeparatorNamingPolicy.java
Patch:
@@ -36,7 +36,7 @@
  *
  * @author Joel Leitch
  */
-class UpperCamelCaseSeparatorNamingPolicy extends CompositionFieldNamingPolicy {
+final class UpperCamelCaseSeparatorNamingPolicy extends CompositionFieldNamingPolicy {
 
   public UpperCamelCaseSeparatorNamingPolicy(String separatorString) {
     super(new CamelCaseSeparatorNamingPolicy(separatorString),

File: gson/src/main/java/com/google/gson/UpperCaseNamingPolicy.java
Patch:
@@ -39,7 +39,7 @@
  *
  * @author Joel Leitch
  */
-class UpperCaseNamingPolicy extends RecursiveFieldNamingPolicy {
+final class UpperCaseNamingPolicy extends RecursiveFieldNamingPolicy {
 
   @Override
   protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) {

File: wsdef/src/main/java/com/google/gson/webservice/definition/WebServiceRequest.java
Patch:
@@ -58,9 +58,8 @@ public String getContentType() {
     return ContentBodySpec.JSON_CONTENT_TYPE;
   }
   
-  @SuppressWarnings("unchecked")
-  public <T> T getHeader(String headerName) {
-    return (T) headers.get(headerName);
+  public <T> T getHeader(TypedKey<T> headerKey) {
+    return headers.get(headerKey);
   }
   
   @Override

File: wsdef/src/main/java/com/google/gson/webservice/definition/ContentBody.java
Patch:
@@ -30,6 +30,7 @@ class ContentBody extends ParamMap {
     super(spec, contents);
   }
   
+  @Override
   public ContentBodySpec getSpec() {
     return (ContentBodySpec) spec;
   }

File: wsdef/src/main/java/com/google/gson/webservice/definition/HeaderMap.java
Patch:
@@ -31,6 +31,7 @@ public Builder(HeaderMapSpec spec) {
       super(spec);
     }
 
+    @Override
     public <T> Builder put(TypedKey<T> paramKey, T content) {
       return put(paramKey.getName(), content);
     }

File: wsdef/src/main/java/com/google/gson/webservice/definition/ParamMap.java
Patch:
@@ -63,8 +63,9 @@ public Object get(String paramName) {
     return contents.get(paramName);
   }
 
+  @SuppressWarnings("unchecked")
   public <T> T get(TypedKey<T> key) {
-    return get(key.getName(), key.getClassOfT());
+    return (T) get(key.getName(), key.getClassOfT());
   }
 
   @SuppressWarnings("unchecked")

File: wsclient/src/main/java/com/google/gson/webservice/client/ResponseReceiver.java
Patch:
@@ -32,6 +32,7 @@
 import com.google.gson.webservice.definition.ResponseBodySpec;
 import com.google.gson.webservice.definition.ResponseSpec;
 import com.google.gson.webservice.definition.WebServiceResponse;
+import com.google.gson.webservice.definition.WebServiceSystemException;
 
 /**
  * Receives a response coming on an {@link HttpURLConnection}.
@@ -63,7 +64,7 @@ public WebServiceResponse receive(HttpURLConnection conn) {
       ResponseBody responseBody = readResponseBody(conn, bodySpec);
       return new WebServiceResponse(responseParams, responseBody);
     } catch (IOException e) {
-      throw new RuntimeException(e);
+      throw new WebServiceSystemException(e);
     }
   }
 

File: wsdef/src/main/java/com/google/gson/webservice/definition/ContentBodySpec.java
Patch:
@@ -25,10 +25,10 @@
  * 
  * @author inder
  */
-class ContentBodySpec implements ParamMapSpec {
+public class ContentBodySpec implements ParamMapSpec {
 
   public static final String JSON_CONTENT_TYPE = "application/json";
-  private static final String JSON_CHARACTER_ENCODING = "utf-8";
+  public static final String JSON_CHARACTER_ENCODING = "utf-8";
   
   private final Map<String, Type> paramsSpec;
 

File: wsf/src/main/java/com/google/gson/wsf/server/ResponseSender.java
Patch:
@@ -26,7 +26,6 @@
 import com.google.gson.webservice.definition.HeaderMap;
 import com.google.gson.webservice.definition.HeaderMapSpec;
 import com.google.gson.webservice.definition.ResponseBody;
-import com.google.gson.webservice.definition.ResponseBodySpec;
 import com.google.gson.webservice.definition.WebServiceResponse;
 
 /**
@@ -45,7 +44,6 @@ public ResponseSender(Gson gson) {
   
   public void send(HttpServletResponse conn, WebServiceResponse response) {
     try {
-      conn.setContentType(ResponseBodySpec.JSON_CONTENT_TYPE);
       sendHeaders(conn, response.getHeaders());
       sendBody(conn, response.getBody());
     } catch (IOException e) {

File: wsclient/src/main/java/com/google/gson/webservice/client/Preconditions.java
Patch:
@@ -70,7 +70,7 @@ public static void checkNotNull(Object obj) {
   private static byte[] readInByteArray(InputStream src) {
     ByteArrayOutputStream dst = new ByteArrayOutputStream();
     try {
-      Streams.copy(src, dst);
+      Streams.copy(src, dst, true, true);
     } catch (IOException e) {
       // ignore
     }

File: wsclient/src/main/java/com/google/gson/webservice/client/Streams.java
Patch:
@@ -22,14 +22,14 @@
 
 final class Streams {
 
-  static void copy(String str, OutputStream dst) throws IOException {
+  static void copy(String str, OutputStream dst, boolean closeOutput) throws IOException {
     byte[] bytes = str.getBytes("UTF-8");
-    copy(new ByteArrayInputStream(bytes), dst);    
+    copy(new ByteArrayInputStream(bytes), dst, true, closeOutput);    
   }
   /**
    * Copy contents of src to dst. Exhausts src completely, and closes both streams.
    */
-  static void copy(InputStream src, OutputStream dst) throws IOException {
+  static void copy(InputStream src, OutputStream dst, boolean closeInput, boolean closeOutput) throws IOException {
     try {
       final byte[] buf = new byte[2048];
       int count;

File: wsclient/src/main/java/com/google/gson/webservice/client/WebServiceClient.java
Patch:
@@ -71,7 +71,7 @@ public WebServiceResponse getResponse(WebServiceCallSpec callSpec, WebServiceReq
         .registerTypeAdapter(ResponseBody.class,
             new ResponseBodyGsonConverter(callSpec.getResponseSpec().getBodySpec()))
         .create();
-      RequestSender requestSender = new RequestSender(gson);
+      RequestSender requestSender = new RequestSender(gson, logLevel);
       requestSender.send(conn, request);
       ResponseReceiver responseReceiver =
         new ResponseReceiver(gson, callSpec.getResponseSpec(), logLevel);

File: wsf/src/main/java/com/google/gson/wsf/server/ResponseSender.java
Patch:
@@ -26,6 +26,7 @@
 import com.google.gson.webservice.definition.HeaderMap;
 import com.google.gson.webservice.definition.HeaderMapSpec;
 import com.google.gson.webservice.definition.ResponseBody;
+import com.google.gson.webservice.definition.ResponseBodySpec;
 import com.google.gson.webservice.definition.WebServiceResponse;
 
 /**
@@ -44,6 +45,7 @@ public ResponseSender(Gson gson) {
   
   public void send(HttpServletResponse conn, WebServiceResponse response) {
     try {
+      conn.setContentType(ResponseBodySpec.JSON_CONTENT_TYPE);
       sendHeaders(conn, response.getHeaders());
       sendBody(conn, response.getBody());
     } catch (IOException e) {

File: wsdef/src/main/java/com/google/gson/webservice/definition/ParamMap.java
Patch:
@@ -41,7 +41,7 @@ public Builder<T> put(String paramName, Object content) {
     }
 
     public Builder<T> put(String paramName, Object content, Type typeOfContent) {
-      spec.checkIfCompatible(paramName, typeOfContent);
+      Preconditions.checkArgument(spec.checkIfCompatible(paramName, typeOfContent));
       contents.put(paramName, content);
       return this;
     }

File: wsdef/src/main/java/com/google/gson/webservice/definition/RequestBody.java
Patch:
@@ -23,6 +23,8 @@
  * in the output stream of the request (for example, with 
  * {@link java.net.HttpURLConnection#getOutputStream()}) , and is read by the 
  * {@link javax.servlet.http.HttpServletRequest#getInputStream()}.
+ * This class omits the default constructor for use by Gson. Instead the user must use
+ * {@link com.google.gson.webservice.typeadapters.RequestBodyGsonConverter}
  * 
  * @author inder
  */

File: wsdef/src/main/java/com/google/gson/webservice/definition/ResponseBody.java
Patch:
@@ -20,7 +20,9 @@
 
 /**
  * body of the response. This is written out as JSON to be sent out to the client. 
- * 
+ * This class omits the default constructor for use by Gson. Instead the user must use
+ * {@link com.google.gson.webservice.typeadapters.ResponseBodyGsonConverter}
+ *
  * @author inder
  */
 public final class ResponseBody extends ContentBody {
@@ -46,7 +48,6 @@ public ResponseBody build() {
     }    
   }
 
-
   private ResponseBody(ResponseBodySpec spec, Map<String, Object> contents) {
     super(spec, contents);
   }

File: gson/src/main/java/com/google/gson/DefaultTypeAdapters.java
Patch:
@@ -195,6 +195,7 @@ private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInst
 
     map.register(Set.class, HASH_SET_CREATOR);
     map.register(SortedSet.class, TREE_SET_CREATOR);
+    map.register(TreeSet.class, TREE_SET_CREATOR);
     map.register(Properties.class, PROPERTIES_CREATOR);
     map.makeUnmodifiable();
     return map;

File: gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
Patch:
@@ -200,7 +200,7 @@ public ObjectWithField deserialize(JsonElement json, Type type,
         }).create();
     String json = "{value:'value1'}";
     ObjectWithField target = gson.fromJson(json, ObjectWithField.class);
-    assertFalse("value1".equals(target.value));
+    assertNull(target);
   }
 
   private static class ObjectWithField {

File: gson/src/main/java/com/google/gson/JsonDeserializationContextDefault.java
Patch:
@@ -79,7 +79,8 @@ private <T> T fromJsonPrimitive(Type typeOfT, JsonPrimitive json,
       JsonDeserializationContext context) throws JsonParseException {
     JsonObjectDeserializationVisitor<T> visitor = new JsonObjectDeserializationVisitor<T>(
         json, typeOfT, navigatorFactory, objectConstructor, deserializers, context);
-    ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(json.getAsObject(), typeOfT, true));
+    ObjectNavigator on = 
+      navigatorFactory.create(new ObjectTypePair(json.getAsObject(), typeOfT, true));
     on.accept(visitor);
     Object target = visitor.getTarget();
     return (T) target;

File: gson/src/main/java/com/google/gson/JsonSerializationVisitor.java
Patch:
@@ -149,7 +149,6 @@ private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair) {
     return childVisitor.getJsonElement();
   }
 
-  @SuppressWarnings("unchecked")
   public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {
     try {
       Object obj = objTypePair.getObject();
@@ -176,7 +175,7 @@ public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {
    */
   @SuppressWarnings("unchecked")
   private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) {
-    Pair<JsonSerializer, ObjectTypePair> pair = objTypePair.getMatchingSerializer(serializers);
+    Pair<JsonSerializer<?>,ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers);
     if (pair == null) {
       return null;
     }
@@ -192,7 +191,6 @@ private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) {
     }
   }
 
-  @SuppressWarnings("unchecked")
   public boolean visitFieldUsingCustomHandler(Field f, Type declaredTypeOfField, Object parent) {
     try {
       Preconditions.checkState(root.isJsonObject());

File: gson/src/main/java/com/google/gson/ObjectNavigator.java
Patch:
@@ -102,14 +102,14 @@ public void accept(Visitor visitor) {
       if (objectToVisit == null) {
         return;
       }
-
+      objTypePair.setObject(objectToVisit);
       visitor.start(objTypePair);
       try {
         if (objTypeInfo.isArray()) {
           visitor.visitArray(objectToVisit, objTypePair.getType());
         } else if (objTypeInfo.getActualType() == Object.class
             && isPrimitiveOrString(objectToVisit)) {
-          // TODO(Joel): this is only used for deserialization of "primitves"
+          // TODO(Joel): this is only used for deserialization of "primitives"
           //             we should rethink this!!!
           visitor.visitPrimitive(objectToVisit);
           objectToVisit = visitor.getTarget();

File: gson/src/main/java/com/google/gson/JsonSerializationVisitor.java
Patch:
@@ -22,7 +22,7 @@
 
 /**
  * A visitor that adds JSON elements corresponding to each field of an object
- * 
+ *
  * @author Inderjeet Singh
  * @author Joel Leitch
  */
@@ -184,8 +184,8 @@ private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) {
     objTypePair = pair.getSecond();
     start(objTypePair);
     try {
-      JsonElement element = 
-        serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context);
+      JsonElement element =
+          serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context);
       return element == null ? JsonNull.createJsonNull() : element;
     } finally {
       end(objTypePair);

File: gson/src/main/java/com/google/gson/JsonSerializationVisitor.java
Patch:
@@ -184,7 +184,9 @@ private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) {
     objTypePair = pair.getSecond();
     start(objTypePair);
     try {
-      return serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context);
+      JsonElement element = 
+        serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context);
+      return element == null ? JsonNull.createJsonNull() : element;
     } finally {
       end(objTypePair);
     }

File: gson/src/main/java/com/google/gson/JsonObject.java
Patch:
@@ -54,7 +54,6 @@ public JsonObject() {
    */
   public void add(String property, JsonElement value) {
     Preconditions.checkArgument(property != null && !"".equals(property.trim()));
-    Preconditions.checkNotNull(property);
 
     if (value == null) {
       value = JsonNull.createJsonNull();

File: gson/src/main/java/com/google/gson/JsonDeserializationContextDefault.java
Patch:
@@ -60,7 +60,7 @@ private <T> T fromJsonArray(Type arrayType, JsonArray jsonArray,
       JsonDeserializationContext context) throws JsonParseException {
     JsonArrayDeserializationVisitor<T> visitor = new JsonArrayDeserializationVisitor<T>(
         jsonArray, arrayType, navigatorFactory, objectConstructor, deserializers, context);
-    ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, arrayType));
+    ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, arrayType, true));
     on.accept(visitor);
     return visitor.getTarget();
   }
@@ -69,7 +69,7 @@ private <T> T fromJsonObject(Type typeOfT, JsonObject jsonObject,
       JsonDeserializationContext context) throws JsonParseException {
     JsonObjectDeserializationVisitor<T> visitor = new JsonObjectDeserializationVisitor<T>(
         jsonObject, typeOfT, navigatorFactory, objectConstructor, deserializers, context);
-    ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, typeOfT));
+    ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, typeOfT, true));
     on.accept(visitor);
     return visitor.getTarget();
   }
@@ -79,7 +79,7 @@ private <T> T fromJsonPrimitive(Type typeOfT, JsonPrimitive json,
       JsonDeserializationContext context) throws JsonParseException {
     JsonObjectDeserializationVisitor<T> visitor = new JsonObjectDeserializationVisitor<T>(
         json, typeOfT, navigatorFactory, objectConstructor, deserializers, context);
-    ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(json.getAsObject(), typeOfT));
+    ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(json.getAsObject(), typeOfT, true));
     on.accept(visitor);
     Object target = visitor.getTarget();
     return (T) target;

File: gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
Patch:
@@ -473,5 +473,4 @@ public DataHolder deserialize(JsonElement json, Type typeOfT, JsonDeserializatio
       return new DataHolder(jsonElement.getAsString());
     }
   }
-
 }

File: gson/src/main/java/com/google/gson/JsonDeserializationContextDefault.java
Patch:
@@ -43,14 +43,14 @@ ObjectConstructor getObjectConstructor() {
 
   @SuppressWarnings("unchecked")
   public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException {
-    if (json.isJsonArray()) {
+    if (json == null || json.isJsonNull()) {
+      return null;
+    } else if (json.isJsonArray()) {
       return (T) fromJsonArray(typeOfT, json.getAsJsonArray(), this);
     } else if (json.isJsonObject()) {
       return (T) fromJsonObject(typeOfT, json.getAsJsonObject(), this);
     } else if (json.isJsonPrimitive()) {
       return (T) fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this);
-    } else if (json.isJsonNull()) {
-      return null;
     } else {
       throw new JsonParseException("Failed parsing JSON source: " + json + " to Json");
     }

File: gson/src/main/java/com/google/gson/JsonSerializationContextDefault.java
Patch:
@@ -39,6 +39,9 @@ final class JsonSerializationContextDefault implements JsonSerializationContext
   }
 
   public JsonElement serialize(Object src) {
+    if (src == null) {
+      return JsonNull.createJsonNull();
+    }
     return serialize(src, src.getClass());
   }
 

File: gson/src/test/java/com/google/gson/EscaperTest.java
Patch:
@@ -65,7 +65,7 @@ public void testDoubleQuoteEscaping() throws Exception {
     assertEquals("123\\\"456", escapedString);
   }
   
-  public void testSingleQuoteEscaping() throws Exception {
+  public void disable_testSingleQuoteEscaping() throws Exception {
     String containsQuote = "123'456";
     String escapedString = escapeHtmlChar.escapeJsonString(containsQuote);
     assertEquals("123\\'456", escapedString);

File: gson/src/main/java/com/google/gson/JsonSerializationVisitor.java
Patch:
@@ -150,7 +150,7 @@ private void addChildAsElement(Field f, JsonElement childElement) {
   }
 
   private void addAsArrayElement(ObjectTypePair elementTypePair) {
-    if (elementTypePair.getObj() == null) {
+    if (elementTypePair.getObject() == null) {
       root.getAsJsonArray().add(JsonNull.createJsonNull());
     } else {
       JsonElement childElement = getJsonElementForChild(elementTypePair);
@@ -169,7 +169,7 @@ private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair) {
   @SuppressWarnings("unchecked")
   public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {
     try {
-      Object obj = objTypePair.getObj();
+      Object obj = objTypePair.getObject();
       Type objType = objTypePair.getType();
       JsonSerializer serializer = serializers.getHandlerFor(objType);
       if (serializer == null && obj != null) {
@@ -194,7 +194,7 @@ public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {
   private JsonElement invokeCustomHandler(ObjectTypePair objTypePair, JsonSerializer serializer) {
     start(objTypePair);
     try {
-      return serializer.serialize(objTypePair.getObj(), objTypePair.getType(), context);
+      return serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context);
     } finally {
       end(objTypePair);
     }

File: gson/src/main/java/com/google/gson/MemoryRefStack.java
Patch:
@@ -77,7 +77,8 @@ public boolean contains(ObjectTypePair obj) {
     }
 
     for (ObjectTypePair stackObject : stack) {
-      if (stackObject.getObj() == obj.getObj() && stackObject.getType().equals(obj.getType()) ) {
+      if (stackObject.getObject() == obj.getObject()
+          && stackObject.getType().equals(obj.getType()) ) {
         return true;
       }
     }

File: gson/src/main/java/com/google/gson/ObjectNavigator.java
Patch:
@@ -93,7 +93,7 @@ public interface Visitor {
   public void accept(Visitor visitor) {
     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair);
     if (!visitedWithCustomHandler) {
-      Object obj = objTypePair.getObj();
+      Object obj = objTypePair.getObject();
       Object objectToVisit = (obj == null) ? visitor.getTarget() : obj;
       if (objectToVisit == null) {
         return;

File: gson/src/main/java/com/google/gson/JsonDeserializationContextDefault.java
Patch:
@@ -60,7 +60,7 @@ private <T> T fromJsonArray(Type arrayType, JsonArray jsonArray,
       JsonDeserializationContext context) throws JsonParseException {
     JsonArrayDeserializationVisitor<T> visitor = new JsonArrayDeserializationVisitor<T>(
         jsonArray, arrayType, navigatorFactory, objectConstructor, deserializers, context);
-    ObjectNavigator on = navigatorFactory.create(null, arrayType);
+    ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, arrayType));
     on.accept(visitor);
     return visitor.getTarget();
   }
@@ -69,7 +69,7 @@ private <T> T fromJsonObject(Type typeOfT, JsonObject jsonObject,
       JsonDeserializationContext context) throws JsonParseException {
     JsonObjectDeserializationVisitor<T> visitor = new JsonObjectDeserializationVisitor<T>(
         jsonObject, typeOfT, navigatorFactory, objectConstructor, deserializers, context);
-    ObjectNavigator on = navigatorFactory.create(null, typeOfT);
+    ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, typeOfT));
     on.accept(visitor);
     return visitor.getTarget();
   }
@@ -79,7 +79,7 @@ private <T> T fromJsonPrimitive(Type typeOfT, JsonPrimitive json,
       JsonDeserializationContext context) throws JsonParseException {
     JsonObjectDeserializationVisitor<T> visitor = new JsonObjectDeserializationVisitor<T>(
         json, typeOfT, navigatorFactory, objectConstructor, deserializers, context);
-    ObjectNavigator on = navigatorFactory.create(json.getAsObject(), typeOfT);
+    ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(json.getAsObject(), typeOfT));
     on.accept(visitor);
     Object target = visitor.getTarget();
     return (T) target;

File: gson/src/main/java/com/google/gson/JsonSerializationContextDefault.java
Patch:
@@ -28,22 +28,22 @@ final class JsonSerializationContextDefault implements JsonSerializationContext
   private final ObjectNavigatorFactory factory;
   private final ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers;
   private final boolean serializeNulls;
-  private final MemoryRefStack<Object> ancestors;
+  private final MemoryRefStack ancestors;
 
   JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls,
       ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers) {
     this.factory = factory;
     this.serializeNulls = serializeNulls;
     this.serializers = serializers;
-    this.ancestors = new MemoryRefStack<Object>();
+    this.ancestors = new MemoryRefStack();
   }
 
   public JsonElement serialize(Object src) {
     return serialize(src, src.getClass());
   }
 
   public JsonElement serialize(Object src, Type typeOfSrc) {
-    ObjectNavigator on = factory.create(src, typeOfSrc);
+    ObjectNavigator on = factory.create(new ObjectTypePair(src, typeOfSrc));
     JsonSerializationVisitor visitor =
         new JsonSerializationVisitor(factory, serializeNulls, serializers, this, ancestors);
     on.accept(visitor);

File: gson/src/test/java/com/google/gson/functional/InterfaceTest.java
Patch:
@@ -32,6 +32,7 @@ public class InterfaceTest extends TestCase {
   private Gson gson;
   private TestObject obj;
 
+  @Override
   protected void setUp() throws Exception {
     super.setUp();
     gson = new Gson();

File: gson/src/test/java/com/google/gson/ExposeAnnotationBasedExclusionStrategyTest.java
Patch:
@@ -54,7 +54,7 @@ public void testNeverSkipExposedAnnotatedFields() throws Exception {
   @SuppressWarnings("unused")
   private static class MockObject {
     @Expose
-    public final int exposedField = 0;
-    public final int hiddenField = 0;
+    private final int exposedField = 0;
+    private final int hiddenField = 0;
   }
 }

File: gson/src/test/java/com/google/gson/SerializedNameAnnotationInterceptingNamingPolicyTest.java
Patch:
@@ -56,6 +56,6 @@ public void testFieldWithoutAnnotation() throws Exception {
   @SuppressWarnings("unused")
   private static class SomeObject {
     @SerializedName(ANNOTATED_FIELD_NAME) public final int fieldWithAnnotation = 1;
-    public final int fieldWithoutAnnotation = 1;
+    private final int fieldWithoutAnnotation = 1;
   }
 }

File: gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java
Patch:
@@ -69,6 +69,6 @@ private static class MockObject {
 
     @SuppressWarnings("unused")
     @Since(VERSION)
-    public final int someField = 0;
+    private final int someField = 0;
   }
 }

File: gson/src/test/java/com/google/gson/functional/CollectionTest.java
Patch:
@@ -285,7 +285,7 @@ private static class ObjectWithWildcardCollection {
 
     // For use by Gson
     @SuppressWarnings({ "unchecked", "unused" })
-    public ObjectWithWildcardCollection() {
+    private ObjectWithWildcardCollection() {
       this(Collections.EMPTY_LIST);
     }
     

File: gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java
Patch:
@@ -123,9 +123,9 @@ public void run() {
   
   @SuppressWarnings("unused")
   private static class MyObject {
-    String a;
-    String b;
-    int i;
+    private String a;
+    private String b;
+    private int i;
 
     MyObject() {
       this("hello", "world", 42);

File: gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
Patch:
@@ -170,7 +170,7 @@ private static class Base {
   
   private static class Derived extends Base {
     @SuppressWarnings("unused")
-    int derivedValue = 3;
+    private int derivedValue = 3;
   }
   
   

File: gson/src/test/java/com/google/gson/functional/JsonTreeTest.java
Patch:
@@ -76,7 +76,7 @@ private void assertContains(JsonObject json, JsonPrimitive child) {
   
   private static class SubTypeOfBagOfPrimitives extends BagOfPrimitives {
     @SuppressWarnings("unused")
-    float f = 1.2F;
+    private float f = 1.2F;
     public SubTypeOfBagOfPrimitives(long l, int i, boolean b, String string, float f) {
       super(l, i, b, string);
       this.f = f;

File: gson/src/test/java/com/google/gson/functional/MapTest.java
Patch:
@@ -173,7 +173,7 @@ private static class MyParameterizedMap<K, V> extends LinkedHashMap<K, V> {
     private static final long serialVersionUID = 1L;
 
     @SuppressWarnings("unused")
-    int foo = 10;
+    private int foo = 10;
   }
   
   public void testMapSubclassSerialization() {
@@ -250,7 +250,7 @@ private static class MyMap extends LinkedHashMap<String, String> {
     private static final long serialVersionUID = 1L;
 
     @SuppressWarnings("unused")
-    int foo = 10;
+    private int foo = 10;
   }
   
   /**

File: gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
Patch:
@@ -84,8 +84,8 @@ public void testGsonDuplicateNameUsingSerializedNameFieldNamingPolicySerializati
 
   @SuppressWarnings("unused")
   private static class ClassWithDuplicateFields {
-    public Integer a;
-    @SerializedName("a") public Double b;
+    private Integer a;
+    @SerializedName("a") private Double b;
     
     public ClassWithDuplicateFields(Integer a) {
       this(a, null);

File: gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
Patch:
@@ -153,9 +153,9 @@ private static class ClassWithNullWrappedPrimitive {
 
   @SuppressWarnings("unused")
   private static class ClassWithMembers {
-    String str;
-    int[] array;
-    Collection<String> col;
+    private String str;
+    private int[] array;
+    private Collection<String> col;
   }
   
   private static class ClassWithObjectsSerializer implements JsonSerializer<ClassWithObjects> {

File: gson/src/test/java/com/google/gson/functional/ObjectTest.java
Patch:
@@ -367,7 +367,7 @@ public void testClassWithObjectFieldSerialization() {
 
   private static class ClassWithObjectField {
     @SuppressWarnings("unused")
-    Object member;
+    private Object member;
   }
   
   public void testInnerClassSerialization() {    
@@ -393,7 +393,7 @@ public Parent.Child createInstance(Type type) {
    
   private static class Parent {
     @SuppressWarnings("unused")
-    int value1 = 1;
+    private int value1 = 1;
     private class Child {
       int value2 = 2;
     }

File: gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java
Patch:
@@ -466,11 +466,11 @@ public boolean equals(Object obj) {
   // Begin: tests to reproduce issue 103
   private static class Quantity {
     @SuppressWarnings("unused")
-    int q = 10;
+    private int q = 10;
   }
   private static class MyQuantity extends Quantity {
     @SuppressWarnings("unused")
-    int q2 = 20;
+    private int q2 = 20;
   }
   private interface Measurable<T> {    
   }

File: gson/src/main/java/com/google/gson/TypeInfoFactory.java
Patch:
@@ -57,7 +57,7 @@ public static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF) {
 
   private static Type getActualType(
       Type typeToEvaluate, Type parentType, Class<?> rawParentClass) {
-    if (typeToEvaluate instanceof Class) {
+    if (typeToEvaluate instanceof Class<?>) {
       return typeToEvaluate;
     } else if (typeToEvaluate instanceof ParameterizedType) {
       ParameterizedType castedType = (ParameterizedType) typeToEvaluate;
@@ -73,13 +73,13 @@ private static Type getActualType(
       if (componentType.equals(actualType)) {
         return castedType;
       } else {
-        if (actualType instanceof Class) {
+        if (actualType instanceof Class<?>) {
           return TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType));
         } else {
           return new GenericArrayTypeImpl(actualType);
         }
       }
-    } else if (typeToEvaluate instanceof TypeVariable) {
+    } else if (typeToEvaluate instanceof TypeVariable<?>) {
       if (parentType instanceof ParameterizedType) {
         // The class definition has the actual types used for the type variables.
         // Find the matching actual type for the Type Variable used for the field.

File: gson/src/main/java/com/google/gson/TypeInfoMap.java
Patch:
@@ -32,7 +32,7 @@ final class TypeInfoMap {
   private final Type valueType;
   
   public TypeInfoMap(Type mapType) {
-    if (mapType instanceof Class && Properties.class.isAssignableFrom((Class<?>) mapType)) {
+    if (mapType instanceof Class<?> && Properties.class.isAssignableFrom((Class<?>) mapType)) {
       keyType = String.class;
       valueType = String.class;
     } else if (mapType instanceof ParameterizedType) {

File: gson/src/main/java/com/google/gson/TypeUtils.java
Patch:
@@ -41,7 +41,7 @@ final class TypeUtils {
    * <code>TypeUtils.getActualTypeForFirstTypeVariable(fooType)</code> will return Integer.class.
    */
   static Type getActualTypeForFirstTypeVariable(Type type) {
-    if (type instanceof Class) {
+    if (type instanceof Class<?>) {
       return Object.class;
     } else if (type instanceof ParameterizedType) {
       return ((ParameterizedType)type).getActualTypeArguments()[0];
@@ -54,7 +54,7 @@ static Type getActualTypeForFirstTypeVariable(Type type) {
   }
 
   static boolean isArray(Type type) {
-    if (type instanceof Class) {
+    if (type instanceof Class<?>) {
       return ((Class<?>)type).isArray();
     } else if (type instanceof GenericArrayType) {
       return true;
@@ -67,7 +67,7 @@ static boolean isArray(Type type) {
    * This method returns the actual raw class associated with the specified type.
    */
   static Class<?> toRawClass(Type type) {
-    if (type instanceof Class) {
+    if (type instanceof Class<?>) {
       return (Class<?>) type;
     } else if (type instanceof ParameterizedType) {
       ParameterizedType actualType = (ParameterizedType)type;

File: gson/src/test/java/com/google/gson/ExposeAnnotationBasedExclusionStrategyTest.java
Patch:
@@ -51,6 +51,7 @@ public void testNeverSkipExposedAnnotatedFields() throws Exception {
     assertFalse(strategy.shouldSkipField(f));
   }
 
+  @SuppressWarnings("unused")
   private static class MockObject {
     @Expose
     public final int exposedField = 0;

File: gson/src/test/java/com/google/gson/SerializedNameAnnotationInterceptingNamingPolicyTest.java
Patch:
@@ -53,6 +53,7 @@ public void testFieldWithoutAnnotation() throws Exception {
     assertEquals(fieldName, policy.translateName(f));
   }
 
+  @SuppressWarnings("unused")
   private static class SomeObject {
     @SerializedName(ANNOTATED_FIELD_NAME) public final int fieldWithAnnotation = 1;
     public final int fieldWithoutAnnotation = 1;

File: gson/src/test/java/com/google/gson/TypeInfoFactoryTest.java
Patch:
@@ -223,6 +223,7 @@ public void testArrayOfListTypeVariableWildcardField() throws Exception {
     assertEquals(List[].class, typeInfo.getRawClass());
   }
 
+  @SuppressWarnings("unused")
   private static class ObjectWithDifferentFields<T> {
     public static enum TestEnum {
       TEST_1, TEST_2;

File: gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java
Patch:
@@ -67,6 +67,7 @@ public void testClassAndFieldAreAheadInVersion() throws Exception {
   @Since(VERSION)
   private static class MockObject {
 
+    @SuppressWarnings("unused")
     @Since(VERSION)
     public final int someField = 0;
   }

File: gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java
Patch:
@@ -120,7 +120,8 @@ public void run() {
     finishedLatch.await();
     assertFalse(failed.get());
   }
-
+  
+  @SuppressWarnings("unused")
   private static class MyObject {
     String a;
     String b;

File: gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
Patch:
@@ -169,6 +169,7 @@ private static class Base {
   }
   
   private static class Derived extends Base {
+    @SuppressWarnings("unused")
     int derivedValue = 3;
   }
   

File: gson/src/test/java/com/google/gson/functional/JsonTreeTest.java
Patch:
@@ -75,6 +75,7 @@ private void assertContains(JsonObject json, JsonPrimitive child) {
   }
   
   private static class SubTypeOfBagOfPrimitives extends BagOfPrimitives {
+    @SuppressWarnings("unused")
     float f = 1.2F;
     public SubTypeOfBagOfPrimitives(long l, int i, boolean b, String string, float f) {
       super(l, i, b, string);

File: gson/src/test/java/com/google/gson/functional/MapTest.java
Patch:
@@ -172,6 +172,7 @@ public MyParameterizedMap createInstance(Type type) {
   private static class MyParameterizedMap<K, V> extends LinkedHashMap<K, V> {
     private static final long serialVersionUID = 1L;
 
+    @SuppressWarnings("unused")
     int foo = 10;
   }
   
@@ -248,6 +249,7 @@ public void testMapDeserializationWithWildcardValues() {
   private static class MyMap extends LinkedHashMap<String, String> {
     private static final long serialVersionUID = 1L;
 
+    @SuppressWarnings("unused")
     int foo = 10;
   }
   

File: gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
Patch:
@@ -82,6 +82,7 @@ public void testGsonDuplicateNameUsingSerializedNameFieldNamingPolicySerializati
     assertEquals("{\"a\":3.0}", actual);
   }
 
+  @SuppressWarnings("unused")
   private static class ClassWithDuplicateFields {
     public Integer a;
     @SerializedName("a") public Double b;

File: gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
Patch:
@@ -151,6 +151,7 @@ private static class ClassWithNullWrappedPrimitive {
     private Long value;
   }
 
+  @SuppressWarnings("unused")
   private static class ClassWithMembers {
     String str;
     int[] array;

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -441,9 +441,10 @@ public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonParseException
    * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
    * @since 1.2
    */
+  @SuppressWarnings("unchecked")
   public <T> T fromJson(Reader json, Type typeOfT) throws JsonParseException {
     JsonElement root = new JsonParser().parse(json);
-    T target = fromJson(root, typeOfT);
+    T target = (T) fromJson(root, typeOfT);
     return target;
   }
 

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -52,13 +52,13 @@
  * example for serializing and deserialing a {@code ParameterizedType}:
  *
  * <pre>
- * Type listType = new TypeToken<List<String>>() {}.getType();
- * List<String> target = new LinkedList<String>();
+ * Type listType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();
+ * List&lt;String&gt; target = new LinkedList&lt;String&gt;();
  * target.add("blah");
  *
  * Gson gson = new Gson();
  * String json = gson.toJson(target, listType);
- * List<String> target2 = gson.fromJson(json, listType);
+ * List&lt;String&gt; target2 = gson.fromJson(json, listType);
  * </pre></p>
  *
  * <p>See the <a href="https://sites.google.com/site/gson/gson-user-guide">Gson User Guide</a>

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -319,7 +319,6 @@ public GsonBuilder setDateFormat(int dateStyle, int timeStyle) {
    * {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.
    * @return a reference to this {@code GsonBuilder} object to fulfill the "Builder" pattern
    */
-  @SuppressWarnings("unchecked")
   public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {
     Preconditions.checkArgument(typeAdapter instanceof JsonSerializer
         || typeAdapter instanceof JsonDeserializer || typeAdapter instanceof InstanceCreator);

File: gson/src/main/java/com/google/gson/TypeInfoFactory.java
Patch:
@@ -55,7 +55,6 @@ public static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF) {
     return new TypeInfo(actualType);
   }
 
-  @SuppressWarnings("unchecked")
   private static Type getActualType(
       Type typeToEvaluate, Type parentType, Class<?> rawParentClass) {
     if (typeToEvaluate instanceof Class) {

File: gson/src/main/java/com/google/gson/TypeInfoMap.java
Patch:
@@ -31,7 +31,6 @@ final class TypeInfoMap {
   private final Type keyType;
   private final Type valueType;
   
-  @SuppressWarnings("unchecked")
   public TypeInfoMap(Type mapType) {
     if (mapType instanceof Class && Properties.class.isAssignableFrom((Class<?>) mapType)) {
       keyType = String.class;

File: gson/src/main/java/com/google/gson/TypeUtils.java
Patch:
@@ -40,7 +40,6 @@ final class TypeUtils {
    * </pre>
    * <code>TypeUtils.getActualTypeForFirstTypeVariable(fooType)</code> will return Integer.class.
    */
-  @SuppressWarnings("unchecked")
   static Type getActualTypeForFirstTypeVariable(Type type) {
     if (type instanceof Class) {
       return Object.class;
@@ -54,7 +53,6 @@ static Type getActualTypeForFirstTypeVariable(Type type) {
     }
   }
 
-  @SuppressWarnings("unchecked")
   static boolean isArray(Type type) {
     if (type instanceof Class) {
       return ((Class<?>)type).isArray();
@@ -68,7 +66,6 @@ static boolean isArray(Type type) {
   /**
    * This method returns the actual raw class associated with the specified type.
    */
-  @SuppressWarnings("unchecked")
   static Class<?> toRawClass(Type type) {
     if (type instanceof Class) {
       return (Class<?>) type;

File: gson/src/test/java/com/google/gson/ExposeAnnotationBasedExclusionStrategyTest.java
Patch:
@@ -51,7 +51,6 @@ public void testNeverSkipExposedAnnotatedFields() throws Exception {
     assertFalse(strategy.shouldSkipField(f));
   }
 
-  @SuppressWarnings("unused")
   private static class MockObject {
     @Expose
     public final int exposedField = 0;

File: gson/src/test/java/com/google/gson/SerializedNameAnnotationInterceptingNamingPolicyTest.java
Patch:
@@ -53,7 +53,6 @@ public void testFieldWithoutAnnotation() throws Exception {
     assertEquals(fieldName, policy.translateName(f));
   }
 
-  @SuppressWarnings("unused")
   private static class SomeObject {
     @SerializedName(ANNOTATED_FIELD_NAME) public final int fieldWithAnnotation = 1;
     public final int fieldWithoutAnnotation = 1;

File: gson/src/test/java/com/google/gson/TypeInfoFactoryTest.java
Patch:
@@ -223,7 +223,6 @@ public void testArrayOfListTypeVariableWildcardField() throws Exception {
     assertEquals(List[].class, typeInfo.getRawClass());
   }
 
-  @SuppressWarnings("unused")
   private static class ObjectWithDifferentFields<T> {
     public static enum TestEnum {
       TEST_1, TEST_2;

File: gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java
Patch:
@@ -66,7 +66,7 @@ public void testClassAndFieldAreAheadInVersion() throws Exception {
 
   @Since(VERSION)
   private static class MockObject {
-    @SuppressWarnings("unused")
+
     @Since(VERSION)
     public final int someField = 0;
   }

File: gson/src/test/java/com/google/gson/functional/CollectionTest.java
Patch:
@@ -283,7 +283,7 @@ private static int[] toIntArray(Collection collection) {
   private static class ObjectWithWildcardCollection {
     private final Collection<? extends BagOfPrimitives> collection;
 
-    @SuppressWarnings({ "unchecked", "unused" })
+    @SuppressWarnings("unchecked")
     public ObjectWithWildcardCollection() {
       this(Collections.EMPTY_LIST);
     }
@@ -300,7 +300,6 @@ public Collection<? extends BagOfPrimitives> getCollection() {
   private static class Entry {
     int value;
     // For use by Gson
-    @SuppressWarnings("unused")
     Entry() {
       this(10);
     }

File: gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java
Patch:
@@ -120,8 +120,7 @@ public void run() {
     finishedLatch.await();
     assertFalse(failed.get());
   }
-  
-  @SuppressWarnings("unused")
+
   private static class MyObject {
     String a;
     String b;

File: gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java
Patch:
@@ -65,7 +65,6 @@ public void testDefaultConstructorNotCalledOnField() throws Exception {
   private static class DataHolder {
     private final String data;
 
-    @SuppressWarnings("unused")
     public DataHolder() {
       throw new IllegalStateException();
     }
@@ -82,7 +81,6 @@ public String getData() {
   private static class DataHolderWrapper {
     private final DataHolder wrappedData;
     
-    @SuppressWarnings("unused")
     public DataHolderWrapper() {
       this(new DataHolder(DEFAULT_VALUE));
     }

File: gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
Patch:
@@ -289,7 +289,6 @@ public void testDateDeserializationWithPattern() throws Exception {
   
   private static class ClassWithBigDecimal {
     BigDecimal value;
-    @SuppressWarnings("unused")
     ClassWithBigDecimal() { }
     ClassWithBigDecimal(String value) {
       this.value = new BigDecimal(value);
@@ -301,7 +300,6 @@ String getExpectedJson() {
 
   private static class ClassWithBigInteger {
     BigInteger value;
-    @SuppressWarnings("unused")
     ClassWithBigInteger() { }
     ClassWithBigInteger(String value) {
       this.value = new BigInteger(value);

File: gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java
Patch:
@@ -117,7 +117,6 @@ private static class ClassWithExposedFields {
     @Expose(deserialize = false) final double d;
     @Expose(serialize = false, deserialize = false) final char e;
 
-    @SuppressWarnings("unused")
     ClassWithExposedFields() {
       this(null, null);
     }
@@ -166,8 +165,7 @@ public SomeInterface createInstance(Type type) {
   private static class ClassWithInterfaceField {
     @Expose
     private final SomeInterface interfaceField;
-    
-    @SuppressWarnings("unused")
+
     public ClassWithInterfaceField() {
       this(null);
     }

File: gson/src/test/java/com/google/gson/functional/JsonTreeTest.java
Patch:
@@ -75,7 +75,6 @@ private void assertContains(JsonObject json, JsonPrimitive child) {
   }
   
   private static class SubTypeOfBagOfPrimitives extends BagOfPrimitives {
-    @SuppressWarnings("unused")
     float f = 1.2F;
     public SubTypeOfBagOfPrimitives(long l, int i, boolean b, String string, float f) {
       super(l, i, b, string);

File: gson/src/test/java/com/google/gson/functional/MapTest.java
Patch:
@@ -172,7 +172,6 @@ public MyParameterizedMap createInstance(Type type) {
   private static class MyParameterizedMap<K, V> extends LinkedHashMap<K, V> {
     private static final long serialVersionUID = 1L;
 
-    @SuppressWarnings("unused")
     int foo = 10;
   }
   
@@ -249,7 +248,6 @@ public void testMapDeserializationWithWildcardValues() {
   private static class MyMap extends LinkedHashMap<String, String> {
     private static final long serialVersionUID = 1L;
 
-    @SuppressWarnings("unused")
     int foo = 10;
   }
   

File: gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java
Patch:
@@ -81,8 +81,7 @@ public void testGsonDuplicateNameUsingSerializedNameFieldNamingPolicySerializati
     actual = gson.toJson(target);
     assertEquals("{\"a\":3.0}", actual);
   }
-  
-  @SuppressWarnings("unused")
+
   private static class ClassWithDuplicateFields {
     public Integer a;
     @SerializedName("a") public Double b;

File: gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
Patch:
@@ -151,7 +151,6 @@ private static class ClassWithNullWrappedPrimitive {
     private Long value;
   }
 
-  @SuppressWarnings("unused")
   private static class ClassWithMembers {
     String str;
     int[] array;

File: gson/src/main/java/com/google/gson/ObjectNavigator.java
Patch:
@@ -133,11 +133,11 @@ private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) {
     Field[] fields = clazz.getDeclaredFields();
     AccessibleObject.setAccessible(fields, true);
     for (Field f : fields) {
-      TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objType);
-      Type actualTypeOfField = fieldTypeInfo.getActualType();
       if (exclusionStrategy.shouldSkipField(f)) {
         continue; // skip
       } else {
+        TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objType);
+        Type actualTypeOfField = fieldTypeInfo.getActualType();
         boolean visitedWithCustomHandler = 
           visitor.visitFieldUsingCustomHandler(f, actualTypeOfField, obj);
         if (!visitedWithCustomHandler) {

File: gson/src/test/java/com/google/gson/common/TestTypes.java
Patch:
@@ -219,7 +219,8 @@ public void appendFields(StringBuilder sb) {
     }
   }
 
-  public static class ClassWithTransientFields {
+  public static class ClassWithTransientFields<T> {
+    public transient T transientT; 
     public final transient long transientLongValue;
     private final long[] longValue;
 

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -408,10 +408,10 @@ public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonParseException
    * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
    * @since 1.2
    */
-  @SuppressWarnings("unchecked")
   public <T> T fromJson(Reader json, Type typeOfT) throws JsonParseException {
     JsonElement root = new JsonParser().parse(json);
-    return fromJson(root, typeOfT);
+    T target = fromJson(root, typeOfT);
+    return target;
   }
 
   /**

File: gson/src/test/java/com/google/gson/functional/ObjectTest.java
Patch:
@@ -19,7 +19,6 @@
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.InstanceCreator;
-import com.google.gson.JsonParseException;
 import com.google.gson.common.TestTypes.ArrayOfObjects;
 import com.google.gson.common.TestTypes.BagOfPrimitiveWrappers;
 import com.google.gson.common.TestTypes.BagOfPrimitives;

File: gson/src/test/java/com/google/gson/functional/PrettyPrintingTest.java
Patch:
@@ -40,7 +40,7 @@ public class PrettyPrintingTest extends TestCase {
   private static int PRINT_MARGIN = 80;
   private static int RIGHT_MARGIN = 4;
 
-  private static boolean DEBUG = false;
+  private static final boolean DEBUG = false;
 
   private Gson gson;
 

File: gson/src/main/java/com/google/gson/JsonElement.java
Patch:
@@ -308,7 +308,7 @@ Object getAsObject() {
   /**
    * Returns a String representation of this element.
    *
-   * @return String the string representation of this element. The output is valid Json.
+   * @return String the string representation of this element.
    */
   @Override
   public String toString() {

File: gson/src/main/java/com/google/gson/JsonParserImplConstants.java
Patch:
@@ -1,7 +1,6 @@
 /* Generated By:JavaCC: Do not edit this line. JsonParserImplConstants.java */
 package com.google.gson;
 
-
 /**
  * Token literal values and constants.
  * Generated by org.javacc.parser.OtherFilesGen#start()
@@ -87,6 +86,7 @@ interface JsonParserImplConstants {
     "\"u\"",
     "<HEX>",
     "<HEX_ESC>",
+    "\")]}\\\'\\n<data>\"",
     "\"{\"",
     "\"}\"",
     "\",\"",

File: gson/src/main/java/com/google/gson/FieldNamingStrategy.java
Patch:
@@ -24,14 +24,16 @@
  * declaration rules.  For example, Java does not support "-" characters in a field name.
  *
  * @author Joel Leitch
+ * @since 1.3
  */
-interface FieldNamingStrategy {
+public interface FieldNamingStrategy {
 
   /**
    * Translates the field name into its JSON field name representation.
    *
    * @param f the field object that we are translating
    * @return the translated field name.
+   * @since 1.3
    */
   public String translateName(Field f);
 }

File: gson/src/test/java/com/google/gson/metrics/PerformanceTest.java
Patch:
@@ -98,7 +98,7 @@ private static class CollectionEntry {
   /**
    * Created in response to http://code.google.com/p/google-gson/issues/detail?id=96
    */
-  public void disable_testLargeCollectionSerialization() {
+  public void disabled_testLargeCollectionSerialization() {
     int count = 1400000;
     List<CollectionEntry> list = new ArrayList<CollectionEntry>(count);
     for (int i = 0; i < count; ++i) {
@@ -110,7 +110,7 @@ public void disable_testLargeCollectionSerialization() {
   /**
    * Created in response to http://code.google.com/p/google-gson/issues/detail?id=96
    */
-  public void disable_testLargeCollectionDeserialization() {
+  public void disabled_testLargeCollectionDeserialization() {
     StringBuilder sb = new StringBuilder();
     int count = 87000;
     boolean first = true;

File: gson/src/main/java/com/google/gson/DefaultTypeAdapters.java
Patch:
@@ -429,7 +429,7 @@ public Collection createInstance(Type type) {
       return new LinkedList();
     }    
   }
-  
+
   private static class PropertiesCreator implements InstanceCreator<Properties> {
     public Properties createInstance(Type type) {
       return new Properties();

File: gson/src/main/java/com/google/gson/JsonTreeNavigator.java
Patch:
@@ -96,7 +96,7 @@ private void visitChild(JsonArray parent, JsonElement child, boolean isFirst) th
     if (child.isJsonNull()) {
       visitor.visitNullArrayMember(parent, isFirst);
       navigate(child);
-	} else if (child.isJsonArray()) {
+	  } else if (child.isJsonArray()) {
       JsonArray childAsArray = child.getAsJsonArray();
       visitor.visitArrayMember(parent, childAsArray, isFirst);
       navigate(childAsArray);

File: gson/src/main/java/com/google/gson/DefaultTypeAdapters.java
Patch:
@@ -454,8 +454,8 @@ public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext c
         if (value == null) {
           valueElement = JsonNull.createJsonNull();
         } else {
-          Type childType = (childGenericType == null) ? 
-              childType = value.getClass() : childGenericType;
+          Type childType = (childGenericType == null)
+              ? value.getClass() : childGenericType;
           valueElement = context.serialize(value, childType);
         }
         map.add(String.valueOf(entry.getKey()), valueElement);

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -436,8 +436,8 @@ private static void addTypeAdaptersForDate(String datePattern, int dateStyle, in
       dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle);
     }
     if (dateTypeAdapter != null
-        && !serializers.hasAnyHandlerFor(Date.class)
-        && !deserializers.hasAnyHandlerFor(Date.class)) {
+        && !serializers.hasSpecificHandlerFor(Date.class)
+        && !deserializers.hasSpecificHandlerFor(Date.class)) {
       serializers.register(Date.class, dateTypeAdapter);
       deserializers.register(Date.class, dateTypeAdapter);
     }

File: gson/src/main/java/com/google/gson/JsonArray.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.gson;
 
+import java.io.IOException;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Collections;
@@ -291,7 +292,7 @@ Object getAsObject() {
   }
 
   @Override
-  protected void toString(StringBuilder sb) {
+  protected void toString(Appendable sb) throws IOException {
     sb.append('[');
     boolean first = true;
     for (JsonElement element : elements) {

File: gson/src/main/java/com/google/gson/JsonCompactFormatter.java
Patch:
@@ -35,7 +35,7 @@ private static class FormattingVisitor implements JsonElementVisitor {
     }
 
     public void visitPrimitive(JsonPrimitive primitive) throws IOException {
-      writer.append(primitive.toString());
+      primitive.toString(writer);
     }
 
     public void visitNull() throws IOException {
@@ -51,7 +51,7 @@ public void visitArrayMember(JsonArray parent, JsonPrimitive member,
       if (!isFirst) {
         writer.append(',');
       }
-      writer.append(member.toString());
+      member.toString(writer);
     }
 
     public void visitArrayMember(JsonArray parent, JsonArray member, 
@@ -90,7 +90,7 @@ public void visitObjectMember(JsonObject parent, String memberName, JsonPrimitiv
       writer.append('"');
       writer.append(memberName);
       writer.append("\":");
-      writer.append(member.toString());
+      member.toString(writer);
     }
 
     public void visitObjectMember(JsonObject parent, String memberName, JsonArray member,

File: gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java
Patch:
@@ -17,7 +17,6 @@
 package com.google.gson;
 
 import java.lang.reflect.Type;
-import java.util.logging.Logger;
 
 /**
  * Abstract data value container for the {@link ObjectNavigator.Visitor}
@@ -29,8 +28,6 @@
  */
 abstract class JsonDeserializationVisitor<T> implements ObjectNavigator.Visitor {
 
-  protected static Logger logger = Logger.getLogger(JsonDeserializationVisitor.class.getName());
-
   protected final ObjectNavigatorFactory factory;
   protected final ObjectConstructor objectConstructor;
   protected final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers;

File: gson/src/main/java/com/google/gson/JsonNull.java
Patch:
@@ -16,6 +16,8 @@
 
 package com.google.gson;
 
+import java.io.IOException;
+
 /**
  * A class representing a Json {@code null} value.
  *
@@ -34,7 +36,7 @@ public JsonNull() {
   }
   
   @Override
-  protected void toString(StringBuilder sb) {
+  protected void toString(Appendable sb) throws IOException {
     sb.append("null");
   }
   

File: gson/src/main/java/com/google/gson/JsonObject.java
Patch:
@@ -16,6 +16,7 @@
 
 package com.google.gson;
 
+import java.io.IOException;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
@@ -189,7 +190,7 @@ public JsonObject getAsJsonObject(String memberName) {
   }
 
   @Override
-  protected void toString(StringBuilder sb) {
+  protected void toString(Appendable sb) throws IOException {
     sb.append('{');
     boolean first = true;
     for (Map.Entry<String, JsonElement> entry : members.entrySet()) {

File: gson/src/test/java/com/google/gson/functional/PrettyPrintingTest.java
Patch:
@@ -40,7 +40,7 @@ public class PrettyPrintingTest extends TestCase {
   private static int PRINT_MARGIN = 80;
   private static int RIGHT_MARGIN = 4;
 
-  private static boolean DEBUG = true;
+  private static boolean DEBUG = false;
 
   private Gson gson;
 

File: gson/src/test/java/com/google/gson/functional/PrimitiveTest.java
Patch:
@@ -24,6 +24,7 @@
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonParseException;
+import com.google.gson.LongSerializationPolicy;
 import com.google.gson.common.TestTypes.CrazyLongTypeAdapter;
 
 /**
@@ -530,7 +531,7 @@ public void testBigDecimalNegativeInfinityDeserializationNotSupported() {
   }  
   
   public void testLongAsStringSerialization() throws Exception {
-    gson = new GsonBuilder().serializeLongFieldsAsString(true).create();
+    gson = new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();
     String result = gson.toJson(15L);
     assertEquals("\"15\"", result);
     
@@ -543,7 +544,7 @@ public void testLongAsStringDeserialization() throws Exception {
     long value = gson.fromJson("\"15\"", long.class);
     assertEquals(15, value);
 
-    gson = new GsonBuilder().serializeLongFieldsAsString(true).create();
+    gson = new GsonBuilder().setLongSerializationPolicy(LongSerializationPolicy.STRING).create();
     value = gson.fromJson("\"25\"", long.class);
     assertEquals(25, value);
   }

File: gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java
Patch:
@@ -262,14 +262,14 @@ String getExpectedJson() {
   
   public void testPropertiesSerialization() {
     Properties props = new Properties();
-    props.put("foo", "bar");
+    props.setProperty("foo", "bar");
     String json = gson.toJson(props);
     System.out.println(json);
   }
   
   public void testPropertiesDeserialization() {
     String json = "{foo:'bar'}";
     Properties props = gson.fromJson(json, Properties.class);
-    assertEquals("bar", props.get("foo"));
+    assertEquals("bar", props.getProperty("foo"));
   }
 }

File: gson/src/main/java/com/google/gson/JsonDeserializationContextDefault.java
Patch:
@@ -60,8 +60,7 @@ private <T> T fromJsonArray(Type arrayType, JsonArray jsonArray,
       JsonDeserializationContext context) throws JsonParseException {
     JsonArrayDeserializationVisitor<T> visitor = new JsonArrayDeserializationVisitor<T>(
         jsonArray, arrayType, navigatorFactory, objectConstructor, deserializers, context);
-    Object target = visitor.getTarget();
-    ObjectNavigator on = navigatorFactory.create(target, arrayType);
+    ObjectNavigator on = navigatorFactory.create(null, arrayType);
     on.accept(visitor);
     return visitor.getTarget();
   }

File: gson/src/test/java/com/google/gson/functional/InternationalizationTest.java
Patch:
@@ -53,7 +53,7 @@ public void testStringsWithRawChineseCharactersDeserialization() throws Exceptio
   public void testStringsWithUnicodeChineseCharactersSerialization() throws Exception {
     String target = "\u597d\u597d\u597d";
     String json = gson.toJson(target);
-    String expected = "\"\\u597d\\u597d\\u597d\"";
+    String expected = "\"\u597d\u597d\u597d\"";
     assertEquals(expected, json);
   }
 

File: gson/src/test/java/com/google/gson/functional/NullObjectAndFieldTest.java
Patch:
@@ -139,7 +139,7 @@ private static class ClassWithObjectsSerializer implements JsonSerializer<ClassW
     public JsonElement serialize(ClassWithObjects src, Type typeOfSrc,
         JsonSerializationContext context) {
       JsonObject obj = new JsonObject();
-      obj.add("bag", new JsonNull());
+      obj.add("bag", JsonNull.createJsonNull());
       return obj;
     }
   }

File: gson/src/main/java/com/google/gson/JsonFormatter.java
Patch:
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import java.io.PrintWriter;
+import java.io.IOException;
 
 /**
  * Common interface for a formatter for Json. 
@@ -33,5 +33,6 @@ interface JsonFormatter {
    * @param writer the writer to output the formatter JSON to.
    * @param serializeNulls serialize null values in the output.
    */
-  public void format(JsonElement root, PrintWriter writer, boolean serializeNulls);
+  public void format(JsonElement root, Appendable writer, 
+      boolean serializeNulls) throws IOException;
 }

File: gson/src/main/java/com/google/gson/JsonDeserializationContextDefault.java
Patch:
@@ -70,8 +70,7 @@ private <T> T fromJsonObject(Type typeOfT, JsonObject jsonObject,
       JsonDeserializationContext context) throws JsonParseException {
     JsonObjectDeserializationVisitor<T> visitor = new JsonObjectDeserializationVisitor<T>(
         jsonObject, typeOfT, navigatorFactory, objectConstructor, deserializers, context);
-    Object target = visitor.getTarget();
-    ObjectNavigator on = navigatorFactory.create(target, typeOfT);
+    ObjectNavigator on = navigatorFactory.create(null, typeOfT);
     on.accept(visitor);
     return visitor.getTarget();
   }

File: gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java
Patch:
@@ -52,7 +52,7 @@ public JsonDeserializationVisitor(JsonElement json, Type targetType,
     this.context = context;
   }
 
-  T getTarget() {
+  public T getTarget() {
     if (target == null) {
       target = constructTarget();
     }

File: gson/src/main/java/com/google/gson/DefaultTypeAdapters.java
Patch:
@@ -382,8 +382,8 @@ public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationCo
         childGenericType = new TypeInfoCollection(typeOfSrc).getElementType();        
       }
       for (Object child : src) {
-        Type childType = (childGenericType == null) ? 
-            childType = child.getClass() : childGenericType;
+        Type childType = (childGenericType == null || childGenericType == Object.class)
+            ? child.getClass() : childGenericType;
         JsonElement element = context.serialize(child, childType);
         array.add(element);
       }

File: gson/src/main/java/com/google/gson/JsonParser.java
Patch:
@@ -208,6 +208,7 @@ final private JsonPrimitive JsonNumber() throws ParseException {
     }
     Number n;
     if (exppart != null) {
+      fracpart = (fracpart == null) ? "" : fracpart;
       n = new java.math.BigDecimal(intpart + fracpart + exppart);
     } else if (fracpart != null) {
       n = new Double(intpart + fracpart);

File: gson/src/test/java/com/google/gson/PrimitiveTypeAdapter.java
Patch:
@@ -31,7 +31,7 @@
  */
 final class PrimitiveTypeAdapter {
 
-  @SuppressWarnings( { "unchecked" })
+  @SuppressWarnings("unchecked")
   public <T> T adaptType(Object from, Class<T> to) {
     Class<?> aClass = Primitives.wrap(to);
     if (Primitives.isWrapperType(aClass)) {

File: gson/src/main/java/com/google/gson/GsonBuilder.java
Patch:
@@ -55,7 +55,6 @@ public final class GsonBuilder {
   private ModifierBasedExclusionStrategy modifierBasedExclusionStrategy;
   private final InnerClassExclusionStrategy innerClassExclusionStrategy;
   private boolean excludeFieldsWithoutExposeAnnotation;
-  private final TypeAdapter typeAdapter;
   private JsonFormatter formatter;
   private FieldNamingStrategy fieldNamingPolicy;
   private final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators;
@@ -78,7 +77,6 @@ public GsonBuilder() {
     innerClassExclusionStrategy = new InnerClassExclusionStrategy();
     modifierBasedExclusionStrategy = Gson.DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY;
     excludeFieldsWithoutExposeAnnotation = false;
-    typeAdapter = Gson.DEFAULT_TYPE_ADAPTER;
     formatter = Gson.DEFAULT_JSON_FORMATTER;
     fieldNamingPolicy = Gson.DEFAULT_NAMING_POLICY;
     instanceCreators = new ParameterizedTypeHandlerMap<InstanceCreator<?>>();
@@ -355,7 +353,7 @@ public Gson create() {
     customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.DEFAULT_INSTANCE_CREATORS);
     MappedObjectConstructor objConstructor = Gson.createObjectConstructor(customInstanceCreators);
 
-    Gson gson = new Gson(exclusionStrategy, fieldNamingPolicy, objConstructor, typeAdapter, 
+    Gson gson = new Gson(exclusionStrategy, fieldNamingPolicy, objConstructor, 
         formatter, serializeNulls, customSerializers, customDeserializers);
     return gson;
   }

File: gson/src/main/java/com/google/gson/JsonArrayDeserializationVisitor.java
Patch:
@@ -31,9 +31,9 @@ final class JsonArrayDeserializationVisitor<T> extends JsonDeserializationVisito
 
   JsonArrayDeserializationVisitor(JsonArray jsonArray, Type arrayType,
       ObjectNavigatorFactory factory, ObjectConstructor objectConstructor,
-      TypeAdapter typeAdapter, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,
+      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,
       JsonDeserializationContext context) {
-    super(jsonArray, arrayType, factory, objectConstructor, typeAdapter, deserializers, context);
+    super(jsonArray, arrayType, factory, objectConstructor, deserializers, context);
   }
 
   @Override

File: gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java
Patch:
@@ -30,9 +30,9 @@ final class JsonObjectDeserializationVisitor<T> extends JsonDeserializationVisit
 
   JsonObjectDeserializationVisitor(JsonElement json, Type type,
       ObjectNavigatorFactory factory, ObjectConstructor objectConstructor,
-      TypeAdapter typeAdapter, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,
+      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,
       JsonDeserializationContext context) {
-    super(json, type, factory, objectConstructor, typeAdapter, deserializers, context);
+    super(json, type, factory, objectConstructor, deserializers, context);
   }
 
   @Override

File: gson/src/main/java/com/google/gson/MappedObjectConstructor.java
Patch:
@@ -49,7 +49,7 @@ public <T> T construct(Type typeOfT) {
     TypeInfo typeInfo = new TypeInfo(typeOfT);
     if (typeInfo.isEnum()) {
       InstanceCreator<T> creator =
-        (InstanceCreator<T>) instanceCreatorMap.getHandlerFor(Enum.class);
+          (InstanceCreator<T>) instanceCreatorMap.getHandlerFor(Enum.class);
       return creator.createInstance(typeOfT);
     }
     return (T) constructWithNoArgConstructor(typeOfT);

File: gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java
Patch:
@@ -20,6 +20,7 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
 
+
 /**
  * This class contains some test fixtures for Parameterized types. These classes should ideally
  * belong either in the common or functional package, but they are placed here because they need

File: gson/src/test/java/com/google/gson/TypeInfoArrayTest.java
Patch:
@@ -80,8 +80,8 @@ public void testPrimitiveArray() throws Exception {
     TypeInfoArray arrayTypeInfo = new TypeInfoArray(int[].class);
 
     assertTrue(arrayTypeInfo.isArray());
+    assertFalse(arrayTypeInfo.isPrimitive());
     assertEquals(int.class, arrayTypeInfo.getSecondLevelType());
-    assertFalse(arrayTypeInfo.isPrimitiveOrStringAndNotAnArray());
   }
 
   public void testStringArray() throws Exception {

File: gson/src/test/java/com/google/gson/functional/ObjectTest.java
Patch:
@@ -271,7 +271,6 @@ public void testSubInterfacesOfCollectionSerialization() throws Exception {
   public void testSubInterfacesOfCollectionDeserialization() throws Exception {
     String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4],"
         + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]"
-//        + ",\"navigableSet\":[\"abc\",\"def\",\"ghi\",\"jkl\"]"
         + "}";
     ClassWithSubInterfacesOfCollection target = gson.fromJson(
         json, ClassWithSubInterfacesOfCollection.class);

File: gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java
Patch:
@@ -67,7 +67,7 @@ public void testParameterizedTypeDeserialization() throws Exception {
         .create();
 
     String json = expected.getExpectedJson();
-    MyParameterizedType<Integer> actual = gson.fromJson(json, expectedType);
+    MyParameterizedType<BagOfPrimitives> actual = gson.fromJson(json, expectedType);
     assertEquals(expected, actual);
   }
 

File: gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
Patch:
@@ -203,13 +203,13 @@ public void testCustomSerializerForLong() {
     Gson gson = new GsonBuilder().registerTypeAdapter(Long.class, new JsonSerializer<Long>() {
       public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context) {
         customSerializerInvoked.value = true;
-        return src == null ? new JsonNull() : new JsonPrimitive(src);
+        return new JsonPrimitive(src);
       }      
     }).serializeNulls().create();
     ClassWithWrapperLongField src = new ClassWithWrapperLongField();
     String json = gson.toJson(src);
     assertTrue(json.contains("\"value\":null"));
-    assertTrue(customSerializerInvoked.value);
+    assertFalse(customSerializerInvoked.value);
     
     customSerializerInvoked.value = false;
     src.value = 10L;
@@ -236,7 +236,7 @@ public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationConte
     String json = "{'value':null}";
     ClassWithWrapperLongField target = gson.fromJson(json, ClassWithWrapperLongField.class);
     assertNull(target.value);
-    assertTrue(customDeserializerInvoked.value);
+    assertFalse(customDeserializerInvoked.value);
     
     customDeserializerInvoked.value = false;
     json = "{'value':10}";

File: gson/src/test/java/com/google/gson/functional/MapTest.java
Patch:
@@ -110,7 +110,7 @@ public void testMapSubclassSerialization() {
     assertTrue(json.contains("\"a\":\"b\""));
   }
   
-  public void testMapSubclassDeserialization() {
+  public void disable_testMapSubclassDeserialization() {
     Gson gson = new GsonBuilder().registerTypeAdapter(MyMap.class, new InstanceCreator<MyMap>(){
       public MyMap createInstance(Type type) {
         return new MyMap();

File: gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java
Patch:
@@ -78,6 +78,8 @@ public synchronized T getHandlerFor(Type type) {
           handler = map.get(Map.class);
         } else if (Collection.class.isAssignableFrom(rawClass)) {
           handler = map.get(Collection.class);
+        } else if (Enum.class.isAssignableFrom(rawClass)) {
+          handler = map.get(Enum.class);
         }
       }
     }

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -143,9 +143,6 @@ public Gson() {
   /**
    * Constructs a Gson object with the specified version and the mode of operation while
    * encountering inner class references.
-   *
-   * @param factory the object navigator factory to use when creating a new {@link ObjectNavigator}
-   * instance
    */
   Gson(ExclusionStrategy strategy, FieldNamingStrategy fieldNamingPolicy) {
     this(strategy, fieldNamingPolicy, createObjectConstructor(DefaultTypeAdapters.DEFAULT_INSTANCE_CREATORS),

File: gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java
Patch:
@@ -38,7 +38,7 @@ abstract class JsonDeserializationVisitor<T> implements ObjectNavigator.Visitor
   protected T target;
   protected final JsonElement json;
   protected final Type targetType;
-  private final JsonDeserializationContext context;
+  protected final JsonDeserializationContext context;
 
   public JsonDeserializationVisitor(JsonElement json, Type targetType,
       ObjectNavigatorFactory factory, ObjectConstructor objectConstructor, TypeAdapter typeAdapter,

File: gson/src/main/java/com/google/gson/StringUnmarshaller.java
Patch:
@@ -63,6 +63,9 @@ private static char getEscapedChar(String str, char c) {
       case '\\':
         ch = '\\';
         break;
+      case '/':
+        ch = '/';
+        break;
       default:
         throw new IllegalStateException("Unexpected character: " + c + " in " + str);
     }

File: gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java
Patch:
@@ -122,9 +122,9 @@ public void run() {
   }
   
   private static class MyObject {
-    private String a;
-    private String b;
-    private int i;
+    String a;
+    String b;
+    int i;
 
     MyObject() {
       this("hello", "world", 42);

File: gson/src/test/java/com/google/gson/FunctionalWithInternalDependenciesTest.java
Patch:
@@ -52,8 +52,8 @@ protected void setUp() throws Exception {
   }
 
   public void testAnonymousLocalClassesSerialization() {
-    Gson gson = new Gson(new ObjectNavigatorFactory(new ModifierBasedExclusionStrategy(
-        true, Modifier.TRANSIENT, Modifier.STATIC), Gson.DEFAULT_NAMING_POLICY));
+    Gson gson = new Gson(new ModifierBasedExclusionStrategy(
+        true, Modifier.TRANSIENT, Modifier.STATIC), Gson.DEFAULT_NAMING_POLICY);
     assertEquals("{}", gson.toJson(new ClassWithNoFields() {
       // empty anonymous class
     }));

File: gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java
Patch:
@@ -78,7 +78,7 @@ public ClassWithCustomTypeConverter deserialize(JsonElement json, Type typeOfT,
     assertEquals(5, target.getBag().getIntValue());
   }
   
-  public void testCustomSerializersOfSelf() {
+  public void disable_testCustomSerializersOfSelf() {
     Gson gson = createGsonObjectWithFooTypeAdapter();
     Gson basicGson = new Gson();
     Foo newFooObject = new Foo(1, 2L);
@@ -88,7 +88,7 @@ public void testCustomSerializersOfSelf() {
     assertEquals(jsonFromGson, jsonFromCustomSerializer);
   }
 
-  public void testCustomDeserializersOfSelf() {
+  public void disable_testCustomDeserializersOfSelf() {
     Gson gson = createGsonObjectWithFooTypeAdapter();
     Gson basicGson = new Gson();
     Foo expectedFoo = new Foo(1, 2L);

File: gson/src/main/java/com/google/gson/Gson.java
Patch:
@@ -117,7 +117,8 @@ public final class Gson {
    *   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer
    *   to change the default representation, you can do so by registering a type adapter through
    *   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>
-   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. You can change
+   *   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format 
+   *   ignores the millisecond portion of the date during serialization. You can change
    *   this by invoking {@link GsonBuilder#setDateFormat(int)} or
    *   {@link GsonBuilder#setDateFormat(String)}. </li>
    *   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.

File: gson/src/main/java/com/google/gson/MappedObjectConstructor.java
Patch:
@@ -21,7 +21,6 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Type;
-import java.util.Map;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 

