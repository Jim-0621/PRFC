File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterWriteTest.java
Patch:
@@ -51,6 +51,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Listener;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Loader;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Population;
+import com.github.benmanes.caffeine.cache.testing.CacheSpec.StartTime;
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
 import com.github.benmanes.caffeine.cache.testing.CheckMaxLogLevel;
 import com.github.benmanes.caffeine.cache.testing.CheckNoStats;
@@ -218,7 +219,8 @@ public void getIfPresent(AsyncCache<Int, Int> cache, CacheContext context) {
   @Test(dataProvider = "caches")
   @CacheSpec(population = Population.FULL,
       mustExpireWithAnyOf = { AFTER_WRITE, VARIABLE }, expireAfterWrite = Expire.ONE_MINUTE,
-      expiry = { CacheExpiry.DISABLED, CacheExpiry.WRITE }, expiryTime = Expire.ONE_MINUTE)
+      expiry = { CacheExpiry.DISABLED, CacheExpiry.WRITE }, expiryTime = Expire.ONE_MINUTE,
+      startTime = {StartTime.RANDOM, StartTime.ONE_MINUTE_FROM_MAX})
   public void putIfAbsent(Map<Int, Int> map, CacheContext context) {
     context.ticker().advance(Duration.ofSeconds(30));
     assertThat(map.putIfAbsent(context.firstKey(), context.absentValue())).isNotNull();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheGenerator.java
Patch:
@@ -217,6 +217,8 @@ private static <K, V> Cache<K, V> newCache(CacheContext context) {
   @SuppressWarnings("unchecked")
   private static void populate(CacheContext context, Cache<Int, Int> cache) {
     if (context.population.size() == 0) {
+      // timeWhel clock initialization
+      cache.cleanUp();
       return;
     }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1056,7 +1056,7 @@ boolean evictEntry(Node<K, V> node, RemovalCause cause, long now) {
             expired |= ((now - n.getWriteTime()) >= expiresAfterWriteNanos());
           }
           if (expiresVariable()) {
-            expired |= (n.getVariableTime() <= now);
+            expired |= ((now - node.getVariableTime()) >= 0);
           }
           if (!expired) {
             resurrect[0] = true;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheGenerator.java
Patch:
@@ -170,7 +170,7 @@ private CacheContext newCacheContext(List<Object> combination) {
         (Compute) combination.get(index++),
         (Loader) combination.get(index++),
         (Implementation) combination.get(index++),
-        cacheSpec);
+        cacheSpec.expiryTime());
   }
 
   /** Returns if the context is a viable configuration. */

File: guava/src/test/java/com/github/benmanes/caffeine/guava/MapTestFactory.java
Patch:
@@ -57,7 +57,7 @@ public static Test suite(String name, TestMapGenerator<?, ?> generator) {
   }
 
   /** Returns a map generator for synchronous values. */
-  public static TestStringMapGenerator synchronousGenerator(
+  public static TestStringMapGenerator generator(
       Supplier<Map<String, String>> supplier) {
     return new TestStringMapGenerator() {
       @Override protected Map<String, String> create(Map.Entry<String, String>[] entries) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/PolicyStats.java
Patch:
@@ -97,7 +97,7 @@ public PolicyStats(String format, Object... args) {
         .type(PERCENT).addCharacteristic(WEIGHTED));
     addPercentMetric("Adaption", this::percentAdaption);
     addMetric("Average Miss Penalty", this::averageMissPenalty);
-    addMetric("Average Penalty", this::avergePenalty);
+    addMetric("Average Penalty", this::averagePenalty);
     addMetric("Steps", this::operationCount);
     addMetric("Time", this::stopwatch);
   }
@@ -283,12 +283,12 @@ public double complexity() {
     return (requestCount == 0) ? 0.0 : (double) operationCount / requestCount;
   }
 
-  public double avergePenalty() {
+  public double averagePenalty() {
     long requestCount = requestCount();
     return (requestCount == 0) ? 0.0 : totalPenalty() / requestCount;
   }
 
-  public double avergeHitPenalty() {
+  public double averageHitPenalty() {
     return (hitCount == 0) ? 0.0 : hitPenalty / hitCount;
   }
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheFactory.java
Patch:
@@ -218,6 +218,8 @@ private CacheProxy<K, V> newLoadingCacheProxy() {
       CacheLoader<K, V> cacheLoader = config.getCacheLoaderFactory().create();
       var adapter = new JCacheLoaderAdapter<>(
           cacheLoader, dispatcher, expiryPolicy, ticker, statistics);
+      // NullAway appears not to understand `V1 extends @Nullable V` in Caffeine.build.
+      @SuppressWarnings("NullAway")
       var cache = new LoadingCacheProxy<>(cacheName, executor, cacheManager, config,
           caffeine.build(adapter), dispatcher, cacheLoader, expiryPolicy, ticker, statistics);
       adapter.setCache(cache);

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/LoadingCacheProxy.java
Patch:
@@ -48,11 +48,11 @@
  */
 @SuppressWarnings("OvershadowingSubclassFields")
 public final class LoadingCacheProxy<K, V> extends CacheProxy<K, V> {
-  private final LoadingCache<K, Expirable<V>> cache;
+  private final LoadingCache<K, @Nullable Expirable<V>> cache;
 
   @SuppressWarnings({"PMD.ExcessiveParameterList", "TooManyParameters"})
   public LoadingCacheProxy(String name, Executor executor, CacheManager cacheManager,
-      CaffeineConfiguration<K, V> configuration, LoadingCache<K, Expirable<V>> cache,
+      CaffeineConfiguration<K, V> configuration, LoadingCache<K, @Nullable Expirable<V>> cache,
       EventDispatcher<K, V> dispatcher, CacheLoader<K, V> cacheLoader,
       ExpiryPolicy expiry, Ticker ticker, JCacheStatisticsMXBean statistics) {
     super(name, executor, cacheManager, configuration, cache, dispatcher,

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/integration/JCacheLoaderAdapter.java
Patch:
@@ -43,7 +43,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 public final class JCacheLoaderAdapter<K, V>
-    implements com.github.benmanes.caffeine.cache.CacheLoader<K, Expirable<V>> {
+    implements com.github.benmanes.caffeine.cache.CacheLoader<K, @Nullable Expirable<V>> {
   private static final Logger logger = System.getLogger(JCacheLoaderAdapter.class.getName());
 
   private final JCacheStatisticsMXBean statistics;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncCacheLoader.java
Patch:
@@ -25,6 +25,7 @@
 import java.util.function.Function;
 
 import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Computes or retrieves values asynchronously based on a key, for use in populating a
@@ -62,7 +63,7 @@ public interface AsyncCacheLoader<K, V> {
    *         treated like any other {@code Exception} in all respects except that, when it is
    *         caught, the thread's interrupt status is set
    */
-  CompletableFuture<? extends V> asyncLoad(K key, Executor executor) throws Exception;
+  CompletableFuture<? extends @Nullable V> asyncLoad(K key, Executor executor) throws Exception;
 
   /**
    * Asynchronously computes or retrieves the values corresponding to {@code keys}. This method is
@@ -114,7 +115,7 @@ public interface AsyncCacheLoader<K, V> {
    *         treated like any other {@code Exception} in all respects except that, when it is
    *         caught, the thread's interrupt status is set
    */
-  default CompletableFuture<? extends V> asyncReload(
+  default CompletableFuture<? extends @Nullable V> asyncReload(
       K key, V oldValue, Executor executor) throws Exception {
     return asyncLoad(key, executor);
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheLoader.java
Patch:
@@ -101,7 +101,7 @@ public interface CacheLoader<K, V> extends AsyncCacheLoader<K, V> {
    * @return the future value associated with {@code key}
    */
   @Override
-  default CompletableFuture<? extends V> asyncLoad(K key, Executor executor) throws Exception {
+  default CompletableFuture<? extends @Nullable V> asyncLoad(K key, Executor executor) throws Exception {
     requireNonNull(key);
     requireNonNull(executor);
     return CompletableFuture.supplyAsync(() -> {
@@ -193,7 +193,7 @@ default CompletableFuture<? extends V> asyncLoad(K key, Executor executor) throw
    *         {@code null} if the mapping is to be removed
    */
   @Override
-  default CompletableFuture<? extends V> asyncReload(
+  default CompletableFuture<? extends @Nullable V> asyncReload(
       K key, V oldValue, Executor executor) throws Exception {
     requireNonNull(key);
     requireNonNull(executor);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncCache.java
Patch:
@@ -198,7 +198,8 @@ CompletableFuture<Map<K, V>> getAll(Iterable<? extends K> keys,
    *
    * @return a thread-safe view of this cache supporting all of the optional {@link Map} operations
    */
-  ConcurrentMap<K, CompletableFuture<V>> asMap();
+  @NullUnmarked
+  @NonNull ConcurrentMap<@NonNull K, @NonNull CompletableFuture<V>> asMap();
 
   /**
    * Returns a view of the entries stored in this cache as a synchronous {@link Cache}. A mapping is

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Cache.java
Patch:
@@ -80,7 +80,7 @@ public interface Cache<K, V> {
    *     left unestablished
    */
   @NullUnmarked
-  V get(@NonNull K key, Function<? super @NonNull K, ? extends V> mappingFunction);
+  V get(@NonNull K key, Function<? super @NonNull K, ? extends @Nullable V> mappingFunction);
 
   /**
    * Returns a map of the values associated with the {@code keys} in this cache. The returned map

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/Specifications.java
Patch:
@@ -20,7 +20,7 @@
 import java.lang.ref.Reference;
 import java.lang.ref.ReferenceQueue;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.ParameterSpec;

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/local/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.local;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.node;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/DelegationBenchmark.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ThreadLocalRandom;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.Scope;
 import org.openjdk.jmh.annotations.Setup;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/BasicCache.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 /**
  * A facade for benchmark implementations.

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/TimerWheelBenchmark.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.TimeUnit;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.Scope;
 import org.openjdk.jmh.annotations.Setup;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.impl;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/sketch/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.sketch;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/profiler/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.profiler;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AbstractLinkedDeque.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.ConcurrentModificationException;
 import java.util.NoSuchElementException;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.google.errorprone.annotations.Var;
 
@@ -192,12 +192,12 @@ public void clear() {
   public abstract boolean contains(Object o);
 
   @Override
-  public boolean isFirst(E e) {
+  public boolean isFirst(@Nullable E e) {
     return (e != null) && (e == first);
   }
 
   @Override
-  public boolean isLast(E e) {
+  public boolean isLast(@Nullable E e) {
     return (e != null) && (e == last);
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AccessOrderDeque.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.Deque;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.AccessOrderDeque.AccessOrder;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Async.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.Executor;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Static utility methods and classes pertaining to asynchronous operations.

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncCache.java
Patch:
@@ -23,7 +23,8 @@
 import java.util.function.BiFunction;
 import java.util.function.Function;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
 
 /**
  * A semi-persistent mapping from keys to values. Cache entries are manually added using
@@ -37,6 +38,7 @@
  * @param <K> the type of keys maintained by this cache
  * @param <V> the type of mapped values
  */
+@NullMarked
 public interface AsyncCache<K, V> {
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncCacheLoader.java
Patch:
@@ -24,6 +24,8 @@
 import java.util.function.BiFunction;
 import java.util.function.Function;
 
+import org.jspecify.annotations.NullMarked;
+
 /**
  * Computes or retrieves values asynchronously based on a key, for use in populating a
  * {@link AsyncLoadingCache}.
@@ -42,6 +44,7 @@
  * @param <V> the type of values
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@NullMarked
 @FunctionalInterface
 @SuppressWarnings("PMD.SignatureDeclareThrowsException")
 public interface AsyncCacheLoader<K, V> {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncLoadingCache.java
Patch:
@@ -18,6 +18,8 @@
 import java.util.Map;
 import java.util.concurrent.CompletableFuture;
 
+import org.jspecify.annotations.NullMarked;
+
 /**
  * A semi-persistent mapping from keys to values. Values are automatically loaded by the cache
  * asynchronously and are stored in the cache until either evicted or manually invalidated.
@@ -29,6 +31,7 @@
  * @param <K> the type of keys maintained by this cache
  * @param <V> the type of mapped values
  */
+@NullMarked
 public interface AsyncLoadingCache<K, V> extends AsyncCache<K, V> {
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheLoader.java
Patch:
@@ -24,7 +24,8 @@
 import java.util.concurrent.Executor;
 import java.util.function.Function;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Computes or retrieves values, based on a key, for use in populating a {@link LoadingCache} or
@@ -43,6 +44,7 @@
  * @param <V> the type of values
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@NullMarked
 @FunctionalInterface
 @SuppressWarnings({"FunctionalInterfaceMethodChanged", "PMD.SignatureDeclareThrowsException"})
 public interface CacheLoader<K, V> extends AsyncCacheLoader<K, V> {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CaffeineSpec.java
Patch:
@@ -25,7 +25,8 @@
 import java.util.Objects;
 import java.util.concurrent.TimeUnit;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.Caffeine.Strength;
 
@@ -70,6 +71,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@NullMarked
 public final class CaffeineSpec {
   static final String SPLIT_OPTIONS = ",";
   static final String SPLIT_KEY_VALUE = "=";

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Interner.java
Patch:
@@ -21,6 +21,8 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.github.benmanes.caffeine.cache.References.LookupKeyEqualsReference;
 import com.github.benmanes.caffeine.cache.References.WeakKeyEqualsReference;
 
@@ -34,6 +36,7 @@
  * @param <E> the type of elements
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@NullMarked
 @FunctionalInterface
 public interface Interner<E> {
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LinkedDeque.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 /**
  * A linked list extension of the {@link Deque} interface where the link pointers are tightly

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LoadingCache.java
Patch:
@@ -19,6 +19,8 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 /**
@@ -32,6 +34,7 @@
  * @param <K> the type of keys maintained by this cache
  * @param <V> the type of mapped values
  */
+@NullMarked
 public interface LoadingCache<K, V> extends Cache<K, V> {
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncLoadingCache.java
Patch:
@@ -33,7 +33,7 @@
 import java.util.function.BiFunction;
 import java.util.function.Function;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.google.errorprone.annotations.Var;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalCache.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.function.BiFunction;
 import java.util.function.Function;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.stats.StatsCounter;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalCacheFactory.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.google.errorprone.annotations.Var;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalLoadingCache.java
Patch:
@@ -32,7 +32,7 @@
 import java.util.concurrent.TimeoutException;
 import java.util.function.Function;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.google.errorprone.annotations.Var;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalManualCache.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.function.Function;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.stats.CacheStats;
 import com.google.errorprone.annotations.Var;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Pacer.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 /**
  * A pacing scheduler that prevents executions from happening too frequently. Only one task may be

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/RemovalCause.java
Patch:
@@ -15,11 +15,14 @@
  */
 package com.github.benmanes.caffeine.cache;
 
+import org.jspecify.annotations.NullMarked;
+
 /**
  * The reason why a cached entry was removed.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@NullMarked
 public enum RemovalCause {
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/RemovalListener.java
Patch:
@@ -15,7 +15,8 @@
  */
 package com.github.benmanes.caffeine.cache;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
 
 /**
  * An object that can receive a notification when an entry is removed from a cache. The removal
@@ -32,6 +33,7 @@
  * @param <V> the most general type of values this listener can listen for; for example
  *        {@code Object} if any value is acceptable
  */
+@NullMarked
 @FunctionalInterface
 public interface RemovalListener<K, V> {
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/SerializationProxy.java
Patch:
@@ -20,7 +20,7 @@
 import java.io.Serializable;
 import java.time.Duration;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 /**
  * Serializes the configuration of the cache, reconstituting it as a {@link Cache},

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/SnapshotEntry.java
Patch:
@@ -19,6 +19,8 @@
 
 import java.util.Map;
 
+import org.jspecify.annotations.Nullable;
+
 import com.github.benmanes.caffeine.cache.Policy.CacheEntry;
 import com.google.errorprone.annotations.Immutable;
 
@@ -59,7 +61,7 @@ class SnapshotEntry<K, V> implements CacheEntry<K, V> {
   @Override public long snapshotAt() {
     return snapshot;
   }
-  @Override public boolean equals(Object o) {
+  @Override public boolean equals(@Nullable Object o) {
     if (o == this) {
       return true;
     } else if (!(o instanceof Map.Entry)) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/StripedBuffer.java
Patch:
@@ -27,7 +27,7 @@
 import java.util.Arrays;
 import java.util.function.Consumer;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.google.errorprone.annotations.Var;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Ticker.java
Patch:
@@ -15,12 +15,15 @@
  */
 package com.github.benmanes.caffeine.cache;
 
+import org.jspecify.annotations.NullMarked;
+
 /**
  * A time source that returns a time value representing the number of nanoseconds elapsed since some
  * fixed but arbitrary point in time.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@NullMarked
 @FunctionalInterface
 public interface Ticker {
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/TimerWheel.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.NoSuchElementException;
 import java.util.concurrent.TimeUnit;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.google.errorprone.annotations.Var;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Weigher.java
Patch:
@@ -20,7 +20,7 @@
 
 import java.io.Serializable;
 
-import org.checkerframework.checker.index.qual.NonNegative;
+import org.jspecify.annotations.NullMarked;
 
 /**
  * Calculates the weights of cache entries. The total weight threshold is used to determine when an
@@ -30,6 +30,7 @@
  * @param <V> the type of values
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@NullMarked
 @FunctionalInterface
 public interface Weigher<K, V> {
 
@@ -41,7 +42,6 @@ public interface Weigher<K, V> {
    * @param value the value to weigh
    * @return the weight of the entry; must be non-negative
    */
-  @NonNegative
   int weigh(K key, V value);
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/WriteOrderDeque.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.Deque;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.WriteOrderDeque.WriteOrder;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/ConcurrentStatsCounter.java
Patch:
@@ -19,6 +19,8 @@
 
 import java.util.concurrent.atomic.LongAdder;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.github.benmanes.caffeine.cache.Cache;
 import com.github.benmanes.caffeine.cache.RemovalCause;
 
@@ -27,6 +29,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@NullMarked
 public final class ConcurrentStatsCounter implements StatsCounter {
   private final LongAdder hitCount;
   private final LongAdder missCount;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/DisabledStatsCounter.java
Patch:
@@ -17,8 +17,6 @@
 
 import static java.util.Objects.requireNonNull;
 
-import org.checkerframework.checker.index.qual.NonNegative;
-
 import com.github.benmanes.caffeine.cache.RemovalCause;
 
 /**
@@ -42,7 +40,7 @@ public void recordLoadSuccess(long loadTime) {}
   public void recordLoadFailure(long loadTime) {}
 
   @Override
-  public void recordEviction(@NonNegative int weight, RemovalCause cause) {
+  public void recordEviction(int weight, RemovalCause cause) {
     requireNonNull(cause);
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/apache/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.apache;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CacheTest.java
Patch:
@@ -55,7 +55,7 @@
 import java.util.stream.IntStream;
 
 import org.apache.commons.lang3.tuple.Triple;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 import org.mockito.Mockito;
 import org.mockito.stubbing.Answer;
 import org.testng.annotations.Listeners;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LinkedDequeTests.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.Queue;
 import java.util.function.Supplier;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.AccessOrderDeque.AccessOrder;
 import com.github.benmanes.caffeine.cache.WriteOrderDeque.WriteOrder;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/TimerWheelTest.java
Patch:
@@ -44,7 +44,7 @@
 import java.util.stream.IntStream;
 import java.util.stream.LongStream;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Captor;
 import org.mockito.Mock;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.buffer;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.issues;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/stats/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.stats;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContext.java
Patch:
@@ -30,7 +30,7 @@
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.function.Function;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.AsyncCache;
 import com.github.benmanes.caffeine.cache.AsyncCacheLoader;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/RemovalNotification.java
Patch:
@@ -19,7 +19,7 @@
 
 import java.util.AbstractMap.SimpleImmutableEntry;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.RemovalCause;
 import com.google.errorprone.annotations.Immutable;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.testing;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/acceptance/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.eclipse.acceptance;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/mutable/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.eclipse.mutable;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.eclipse;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/test/java/com/github/benmanes/caffeine/google/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.google;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/JSR166TestCase.java
Patch:
@@ -99,7 +99,7 @@
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.regex.Pattern;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import junit.framework.Test;
 import junit.framework.TestCase;

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.jsr166;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/test/java/com/github/benmanes/caffeine/lincheck/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.lincheck;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/test/java/com/github/benmanes/caffeine/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.testing;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuava.java
Patch:
@@ -17,6 +17,8 @@
 
 import java.lang.reflect.Method;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.guava.CaffeinatedGuavaLoadingCache.ExternalBulkLoader;
 import com.github.benmanes.caffeine.guava.CaffeinatedGuavaLoadingCache.ExternalSingleLoader;
@@ -31,6 +33,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@NullMarked
 public final class CaffeinatedGuava {
 
   private CaffeinatedGuava() {}

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaCache.java
Patch:
@@ -29,7 +29,7 @@
 import java.util.function.Function;
 import java.util.function.Predicate;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheLoader.InvalidCacheLoadException;

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaLoadingCache.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.CacheLoader;
 import com.google.common.cache.CacheLoader.InvalidCacheLoadException;

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/TestingCacheLoaders.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.guava.compatibility;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: guava/src/test/java/com/github/benmanes/caffeine/guava/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.guava;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheFactory.java
Patch:
@@ -30,7 +30,7 @@
 import javax.cache.expiry.ExpiryPolicy;
 import javax.cache.integration.CacheLoader;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.cache.Expiry;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheManagerImpl.java
Patch:
@@ -33,7 +33,7 @@
 import javax.cache.configuration.Configuration;
 import javax.cache.spi.CachingProvider;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 /**
  * An implementation of JSR-107 {@link CacheManager} that manages Caffeine-based caches.

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/LoadingCacheProxy.java
Patch:
@@ -32,7 +32,7 @@
 import javax.cache.integration.CacheLoader;
 import javax.cache.integration.CompletionListener;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.LoadingCache;
 import com.github.benmanes.caffeine.cache.Ticker;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/ConfigSource.java
Patch:
@@ -17,13 +17,16 @@
 
 import java.net.URI;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.typesafe.config.Config;
 
 /**
  * A provider for the external configuration.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@NullMarked
 @FunctionalInterface
 public interface ConfigSource {
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/FactoryCreator.java
Patch:
@@ -17,11 +17,14 @@
 
 import javax.cache.configuration.Factory;
 
+import org.jspecify.annotations.NullMarked;
+
 /**
  * An object capable of providing factories that produce an instance for a given class name.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@NullMarked
 @FunctionalInterface
 public interface FactoryCreator {
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurator.java
Patch:
@@ -41,7 +41,8 @@
 import javax.cache.expiry.EternalExpiryPolicy;
 import javax.cache.expiry.ExpiryPolicy;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.jcache.expiry.JCacheExpiryPolicy;
 import com.google.errorprone.annotations.Var;
@@ -59,6 +60,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@NullMarked
 @SuppressWarnings({"PMD.AvoidDuplicateLiterals", "PMD.MutableStaticState"})
 public final class TypesafeConfigurator {
   static final Logger logger = System.getLogger(TypesafeConfigurator.class.getName());

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/copy/AbstractCopier.java
Patch:
@@ -38,13 +38,16 @@
 import java.util.function.Function;
 import java.util.regex.Pattern;
 
+import org.jspecify.annotations.NullMarked;
+
 /**
  * A skeleton implementation where subclasses provide the serialization strategy. Serialization is
  * not performed if the type is a known immutable, an array of known immutable types, or specially
  * handled by a known cloning strategy.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@NullMarked
 @SuppressWarnings({"ImmutableMemberCollection", "JavaUtilDate", "JdkObsolete"})
 public abstract class AbstractCopier<A> implements Copier {
   private static final Map<Class<?>, Function<Object, Object>> JAVA_DEEP_COPY = Map.of(Date.class,

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/copy/Copier.java
Patch:
@@ -15,12 +15,15 @@
  */
 package com.github.benmanes.caffeine.jcache.copy;
 
+import org.jspecify.annotations.NullMarked;
+
 /**
  * An object is copied when the cache is configured with <code>storeByValue</code> to guard against
  * mutations of the key or value.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@NullMarked
 @FunctionalInterface
 public interface Copier {
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/copy/JavaSerializationCopier.java
Patch:
@@ -31,6 +31,8 @@
 
 import javax.cache.CacheException;
 
+import org.jspecify.annotations.NullMarked;
+
 /**
  * A strategy that uses Java serialization if a fast path approach is not applicable.
  * <p>
@@ -40,6 +42,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@NullMarked
 public class JavaSerializationCopier extends AbstractCopier<byte[]> {
 
   public JavaSerializationCopier() {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/EventTypeFilter.java
Patch:
@@ -28,6 +28,8 @@
 import javax.cache.event.CacheEntryRemovedListener;
 import javax.cache.event.CacheEntryUpdatedListener;
 
+import org.jspecify.annotations.Nullable;
+
 /**
  * A filter that determines if the listener can process the event type before delegating to the
  * decorated filter.
@@ -64,7 +66,7 @@ private boolean isCompatible(CacheEntryEvent<? extends K, ? extends V> event) {
   }
 
   @Override
-  public boolean equals(Object o) {
+  public boolean equals(@Nullable Object o) {
     if (o == this) {
       return true;
     } else if (!(o instanceof EventTypeFilter<?, ?>)) {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/JCacheEntryEvent.java
Patch:
@@ -24,7 +24,7 @@
 import javax.cache.event.CacheEntryEvent;
 import javax.cache.event.EventType;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 /**
  * A cache event dispatched to a listener.

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/JCacheEvictionListener.java
Patch:
@@ -19,7 +19,7 @@
 
 import javax.cache.Cache;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.RemovalCause;
 import com.github.benmanes.caffeine.cache.RemovalListener;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/Registration.java
Patch:
@@ -22,6 +22,8 @@
 import javax.cache.event.CacheEntryEventFilter;
 import javax.cache.event.CacheEntryListener;
 
+import org.jspecify.annotations.Nullable;
+
 /**
  * The registration of a {@link CacheEntryListener} for event dispatching.
  *
@@ -61,7 +63,7 @@ public boolean isSynchronous() {
   }
 
   @Override
-  public boolean equals(Object o) {
+  public boolean equals(@Nullable Object o) {
     if (o == this) {
       return true;
     } else if (!(o instanceof Registration)) {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/expiry/JCacheExpiryPolicy.java
Patch:
@@ -23,7 +23,7 @@
 import javax.cache.expiry.Duration;
 import javax.cache.expiry.ExpiryPolicy;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 /**
  * A customized expiration policy.
@@ -60,7 +60,7 @@ public Duration getExpiryForCreation() {
   }
 
   @Override
-  public boolean equals(Object o) {
+  public boolean equals(@Nullable Object o) {
     if (o == this) {
       return true;
     } else if (!(o instanceof ExpiryPolicy)) {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/integration/JCacheLoaderAdapter.java
Patch:
@@ -29,7 +29,7 @@
 import javax.cache.integration.CacheLoader;
 import javax.cache.integration.CacheLoaderException;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.Ticker;
 import com.github.benmanes.caffeine.jcache.CacheProxy;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/processor/EntryProcessorEntry.java
Patch:
@@ -23,7 +23,7 @@
 import javax.cache.processor.EntryProcessor;
 import javax.cache.processor.MutableEntry;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 /**
  * An entry that is consumed by an {@link EntryProcessor}. The updates to the entry are replayed

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/spi/CaffeineCachingProvider.java
Patch:
@@ -33,7 +33,8 @@
 import javax.cache.configuration.OptionalFeature;
 import javax.cache.spi.CachingProvider;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
 import org.osgi.service.component.annotations.Activate;
 import org.osgi.service.component.annotations.Component;
 
@@ -54,6 +55,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @Component
+@NullMarked
 public final class CaffeineCachingProvider implements CachingProvider {
   private static final ClassLoader DEFAULT_CLASS_LOADER = new JCacheClassLoader();
 

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/AbstractJCacheTest.java
Patch:
@@ -24,7 +24,7 @@
 import javax.cache.integration.CacheLoader;
 import javax.cache.spi.CachingProvider;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 import org.testng.annotations.AfterClass;
 import org.testng.annotations.AfterMethod;
 import org.testng.annotations.BeforeClass;

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/configuration/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.jcache.configuration;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/copy/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.jcache.copy;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/event/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.jcache.event;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.jcache.expiry;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/integration/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.jcache.integration;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/management/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.jcache.management;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.jcache;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/processor/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.jcache.processor;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/size/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.jcache.size;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/spi/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.jcache.spi;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/BasicSettings.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.function.Function;
 import java.util.regex.Pattern;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.admission.Admission;
 import com.github.benmanes.caffeine.cache.simulator.membership.FilterType;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.admission.countmin4;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin64/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.admission.countmin64;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.admission;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/perfect/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.admission.perfect;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/table/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.admission.table;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.admission.tinycache;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/membership/bloom/BloomFilter.java
Patch:
@@ -19,8 +19,6 @@
 
 import java.util.Arrays;
 
-import org.checkerframework.checker.index.qual.NonNegative;
-
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.membership.Membership;
 import com.google.errorprone.annotations.Var;
@@ -68,7 +66,7 @@ public BloomFilter(Config config) {
    * @param fpp the false positive probability, where {@literal 0.0 > fpp < 1.0}
    */
   @SuppressWarnings("Varifier")
-  public void ensureCapacity(@NonNegative long expectedInsertions, @NonNegative double fpp) {
+  public void ensureCapacity(long expectedInsertions, double fpp) {
     checkArgument(expectedInsertions >= 0);
     checkArgument(fpp > 0 && fpp < 1);
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/membership/bloom/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.membership.bloom;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/membership/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.membership;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/AbstractTraceReader.java
Patch:
@@ -34,7 +34,7 @@
 import org.apache.commons.compress.compressors.CompressorException;
 import org.apache.commons.compress.compressors.CompressorStreamFactory;
 import org.apache.commons.io.input.CloseShieldInputStream;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 import org.tukaani.xz.XZInputStream;
 
 import com.google.common.base.Throwables;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/adapt_size/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.adapt_size;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/address/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.address;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/address/penalties/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.address.penalties;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/arc/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.arc;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/baleen/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.baleen;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/cache2k/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.cache2k;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/cachelib/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.cachelib;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/camelab/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.camelab;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/cloud_physics/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.cloud_physics;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/corda/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.corda;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/glcache/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.glcache;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/gradle/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.gradle;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/kaggle/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.kaggle;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/libcachesim/csv/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.libcachesim.csv;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/libcachesim/twitter/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.libcachesim.twitter;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/lirs/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.lirs;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/lrb/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.lrb;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/scarab/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.scarab;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/snia/cambridge/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.snia.cambridge;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/snia/enterprise/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.snia.enterprise;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/snia/keyvalue/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.snia.keyvalue;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/snia/parallel/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.snia.parallel;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/snia/systor/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.snia.systor;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/tragen/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.tragen;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/twitter/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.twitter;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/umass/network/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.umass.network;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/umass/storage/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.umass.storage;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/wikipedia/WikipediaTraceReader.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.stream.LongStream;
 
 import org.apache.commons.lang3.StringUtils;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.parser.TraceReader.KeyOnlyTraceReader;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/wikipedia/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.parser.wikipedia;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/AccessEvent.java
Patch:
@@ -19,6 +19,8 @@
 
 import java.util.Objects;
 
+import org.jspecify.annotations.Nullable;
+
 import com.google.common.base.MoreObjects;
 import com.google.errorprone.annotations.Immutable;
 
@@ -61,7 +63,7 @@ public boolean isPenaltyAware() {
   }
 
   @Override
-  public boolean equals(Object o) {
+  public boolean equals(@Nullable Object o) {
     if (o == this) {
       return true;
     } else if (!(o instanceof AccessEvent)) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/adaptive/ArcPolicy.java
Patch:
@@ -17,7 +17,7 @@
 
 import static com.google.common.base.Preconditions.checkState;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/adaptive/CarPolicy.java
Patch:
@@ -17,7 +17,7 @@
 
 import static com.google.common.base.Preconditions.checkState;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/adaptive/CartPolicy.java
Patch:
@@ -17,7 +17,7 @@
 
 import static com.google.common.base.Preconditions.checkState;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/adaptive/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy.adaptive;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/greedy_dual/CampPolicy.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.Objects;
 import java.util.TreeSet;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.AccessEvent;
@@ -218,7 +218,7 @@ public int compareTo(Sentinel sentinel) {
     }
 
     @Override
-    public boolean equals(Object o) {
+    public boolean equals(@Nullable Object o) {
       if (this == o) {
         return true;
       } else if (!(o instanceof Sentinel)) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/greedy_dual/GDWheelPolicy.java
Patch:
@@ -18,7 +18,7 @@
 import static com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic.WEIGHTED;
 import static com.google.common.base.Preconditions.checkState;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.AccessEvent;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/greedy_dual/GdsfPolicy.java
Patch:
@@ -23,6 +23,8 @@
 import java.util.Set;
 import java.util.TreeSet;
 
+import org.jspecify.annotations.Nullable;
+
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.AccessEvent;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
@@ -204,7 +206,7 @@ public int compareTo(Node node) {
     }
 
     @Override
-    public boolean equals(Object o) {
+    public boolean equals(@Nullable Object o) {
       if (o == this) {
         return true;
       } else if (!(o instanceof Node)) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/greedy_dual/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy.greedy_dual;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/ClockProPlusPolicy.java
Patch:
@@ -17,7 +17,7 @@
 
 import static com.google.common.base.Preconditions.checkState;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/ClockProPolicy.java
Patch:
@@ -17,7 +17,7 @@
 
 import static com.google.common.base.Preconditions.checkState;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/DClockPolicy.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.List;
 import java.util.Set;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/FrdPolicy.java
Patch:
@@ -17,7 +17,7 @@
 
 import static com.google.common.base.Preconditions.checkState;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/HillClimberFrdPolicy.java
Patch:
@@ -17,7 +17,7 @@
 
 import static com.google.common.base.Preconditions.checkState;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/IndicatorFrdPolicy.java
Patch:
@@ -17,7 +17,7 @@
 
 import static com.google.common.base.Preconditions.checkState;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/LirsPolicy.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy.irr;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/FrequentlyUsedPolicy.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.Set;
 
 import org.apache.commons.lang3.StringUtils;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.Admission;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/LinkedPolicy.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.Set;
 
 import org.apache.commons.lang3.StringUtils;
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.Admission;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/MultiQueuePolicy.java
Patch:
@@ -19,7 +19,7 @@
 
 import java.util.Arrays;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/S4LruPolicy.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.Arrays;
 import java.util.Set;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.Admission;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy.linked;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/opt/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy.opt;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy.product;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sampled/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy.sampled;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/WindowTinyLfuPolicy.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.List;
 import java.util.Set;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.Admission;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/HillClimberWindowTinyLfuPolicy.java
Patch:
@@ -28,7 +28,7 @@
 import java.util.List;
 import java.util.Set;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.Admission;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/gradient/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch.climbing.gradient;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/hill/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch.climbing.hill;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/inference/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch.climbing.inference;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch.climbing;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/sim/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch.climbing.sim;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/feedback/FeedbackTinyLfuPolicy.java
Patch:
@@ -19,7 +19,7 @@
 
 import java.util.Map;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.Admission;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/feedback/FeedbackWindowTinyLfuPolicy.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.Map;
 import java.util.Set;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.Admission;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/feedback/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch.feedback;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/segment/FullySegmentedWindowTinyLfuPolicy.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.List;
 import java.util.Set;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.Admission;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/segment/LruWindowTinyLfuPolicy.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.List;
 import java.util.Set;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.Admission;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/segment/S4WindowTinyLfuPolicy.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.List;
 import java.util.Set;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.Admission;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/segment/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch.segment;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/tinycache/WindowTinyCachePolicy.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch.tinycache;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.tinycache.TinyCache;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/tinycache/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch.tinycache;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/S3FifoPolicy.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.LinkedHashSet;
 import java.util.function.IntConsumer;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.AccessEvent;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/TuQueuePolicy.java
Patch:
@@ -17,7 +17,7 @@
 
 import static com.google.common.base.Preconditions.checkState;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
+import org.jspecify.annotations.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.policy.two_queue;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/csv/CombinedCsvReport.java
Patch:
@@ -26,6 +26,8 @@
 import java.util.TreeMap;
 import java.util.stream.Stream;
 
+import org.jspecify.annotations.Nullable;
+
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSortedMap;
 import com.univocity.parsers.csv.CsvParser;
@@ -113,7 +115,7 @@ private static final class Label implements Comparable<Label> {
       this.size = size;
     }
     @Override
-    public boolean equals(Object o) {
+    public boolean equals(@Nullable Object o) {
       return (o instanceof Label) && (compareTo((Label) o) == 0);
     }
     @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/csv/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.report.csv;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.report;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/table/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.report.table;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: simulator/src/test/java/com/github/benmanes/caffeine/cache/simulator/admission/bloom/package-info.java
Patch:
@@ -1,4 +1,7 @@
+@NullMarked
 @CheckReturnValue
 package com.github.benmanes.caffeine.cache.simulator.admission.bloom;
 
+import org.jspecify.annotations.NullMarked;
+
 import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheFactoryGenerator.java
Patch:
@@ -117,7 +117,7 @@ private void reformat() throws IOException {
           .filter(path -> path.endsWith(".java"))
           .collect(toImmutableList());
       ToolProvider.findFirst("google-java-format").ifPresent(formatter -> {
-        int result = formatter.run(System.err, System.out,
+        int result = formatter.run(System.out, System.err,
             Stream.concat(Stream.of("-i"), files.stream()).toArray(String[]::new));
         checkState(result == 0, "Java formatting failed with %s exit code", result);
       });

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeFactoryGenerator.java
Patch:
@@ -119,7 +119,7 @@ private void reformat() throws IOException {
           .filter(path -> path.endsWith(".java"))
           .collect(toImmutableList());
       ToolProvider.findFirst("google-java-format").ifPresent(formatter -> {
-        int result = formatter.run(System.err, System.out,
+        int result = formatter.run(System.out, System.err,
             Stream.concat(Stream.of("-i"), files.stream()).toArray(String[]::new));
         checkState(result == 0, "Java formatting failed with %s exit code", result);
       });

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncCache.java
Patch:
@@ -200,7 +200,7 @@ default void handleCompletion(K key, CompletableFuture<? extends V> valueFuture,
       long startTime, boolean recordMiss) {
     var completed = new AtomicBoolean();
     valueFuture.whenComplete((value, error) -> {
-      if (!completed.compareAndSet(false, true)) {
+      if (!completed.compareAndSet(/* expectedValue= */ false, /* newValue= */ true)) {
         // Ignore multiple invocations due to ForkJoinPool retrying on delays
         return;
       }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -2562,7 +2562,8 @@ public void cacheFactory_noSuchMethod() {
   public void cacheFactory_brokenConstructor() {
     var builder = Caffeine.newBuilder();
     var factory = LocalCacheFactory.loadFactory("BoundedLocalCacheTest$BadBoundedLocalCache");
-    assertThrows(IllegalStateException.class, () -> factory.newInstance(builder, null, false));
+    assertThrows(IllegalStateException.class, () -> factory.newInstance(builder,
+        /* cacheLoader= */ null, /* isAsync= */ false));
   }
 
   @Test(groups = "isolated")
@@ -2650,7 +2651,7 @@ public void nodeFactory_badConstructor() {
   @Test
   public void nodeFactory_classNotFound() {
     var expected = assertThrows(IllegalStateException.class, () ->
-        NodeFactory.loadFactory(/* className */ ""));
+        NodeFactory.loadFactory(/* className= */ ""));
     assertThat(expected).hasCauseThat().isInstanceOf(ClassNotFoundException.class);
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Solr10141Test.java
Patch:
@@ -67,7 +67,7 @@ public void eviction() {
 
     RemovalListener<Long, Val> listener = (k, v, removalCause) -> {
       assertThat(v.key).isEqualTo(k);
-      if (!v.live.compareAndSet(true, false)) {
+      if (!v.live.compareAndSet(/* expectedValue= */ true, /* newValue= */ false)) {
         throw new RuntimeException(String.format(US,
             "listener called more than once! k=%s, v=%s, removalCause=%s", k, v, removalCause));
       }
@@ -144,7 +144,7 @@ public void clear() {
 
     RemovalListener<Long, Val> listener = (k, v, removalCause) -> {
       assertThat(v.key).isEqualTo(k);
-      if (!v.live.compareAndSet(true, false)) {
+      if (!v.live.compareAndSet(/* expectedValue= */ true, /* newValue= */ false)) {
         throw new RuntimeException(String.format(US,
             "listener called more than once! k=%s, v=%s, removalCause=%s", k, v, removalCause));
       }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheValidationListener.java
Patch:
@@ -97,7 +97,8 @@ public void beforeInvocation(IInvokedMethod method, ITestResult testResult) {
         .forEach(logger -> logger.setEnabledLevels(TRACE_LEVELS));
     TestLoggerFactory.clear();
 
-    if (beforeCleanup.get() || !beforeCleanup.compareAndSet(false, true)) {
+    if (beforeCleanup.get()
+        || !beforeCleanup.compareAndSet(/* expectedValue= */ false, /* newValue= */ true)) {
       return;
     }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/JSR166TestCase.java
Patch:
@@ -1982,7 +1982,7 @@ void checkEmpty(BlockingQueue<?> q) {
             assertNull(q.peek());
             assertNull(q.poll());
             assertNull(q.poll(randomExpiredTimeout(), randomTimeUnit()));
-            assertEquals(q.toString(), "[]");
+            assertEquals("[]" ,q.toString());
             assertTrue(Arrays.equals(q.toArray(), new Object[0]));
             assertFalse(q.iterator().hasNext());
             try {

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/CacheProxyTest.java
Patch:
@@ -128,7 +128,7 @@ public void load_cacheLoaderException() {
     var e = new CacheLoaderException();
     CompletionListener completionListener = Mockito.mock();
     doThrow(e).when(completionListener).onCompletion();
-    jcache.loadAll(keys, true, completionListener);
+    jcache.loadAll(keys, /* replaceExistingValues= */ true, completionListener);
     verify(completionListener).onException(e);
   }
 

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/event/JCacheEvictionListenerTest.java
Patch:
@@ -58,7 +58,8 @@ public void before() throws Exception {
     statistics.enable(true);
 
     dispatcher.register(new MutableCacheEntryListenerConfiguration<>(
-        () -> entryListener, null, false, false));
+        /* listenerFactory= */ () -> entryListener, /* filterFactory= */ null,
+        /* isOldValueRequired= */ false, /* isSynchronous= */ false));
   }
 
   @DataProvider

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/TimerWheelTest.java
Patch:
@@ -294,7 +294,7 @@ public void getExpirationDelay_fuzzy(long clock, long duration, long[] times) {
 
   @DataProvider(name = "clock")
   public Iterator<Object> providesClock() {
-    return LongStream.of(CLOCKS).mapToObj(o -> (Object) o).iterator();
+    return LongStream.of(CLOCKS).mapToObj(Object.class::cast).iterator();
   }
 
   @DataProvider(name = "schedule")

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheReferencesTest.java
Patch:
@@ -28,6 +28,7 @@
 import com.google.common.cache.LoadingCache;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
 
 import junit.framework.TestCase;
 
@@ -49,8 +50,8 @@ public class CacheReferencesTest extends TestCase {
 
   private static CacheBuilderFactory factoryWithAllKeyStrengths() {
     return new CacheBuilderFactory()
-        .withKeyStrengths(ImmutableSet.of(STRONG, Strength.WEAK))
-        .withValueStrengths(ImmutableSet.of(STRONG, Strength.WEAK, Strength.SOFT));
+        .withKeyStrengths(Sets.immutableEnumSet(STRONG, Strength.WEAK))
+        .withValueStrengths(Sets.immutableEnumSet(STRONG, Strength.WEAK, Strength.SOFT));
   }
 
   private static Iterable<LoadingCache<Key, String>> caches() {

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/EmptyCachesTest.java
Patch:
@@ -35,6 +35,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
 import com.google.common.testing.EqualsTester;
 
 import junit.framework.TestCase;
@@ -316,8 +317,8 @@ private static Iterable<LoadingCache<Object, Object>> caches() {
 
   private static CacheBuilderFactory cacheFactory() {
     return new CacheBuilderFactory()
-        .withKeyStrengths(ImmutableSet.of(Strength.STRONG, Strength.WEAK))
-        .withValueStrengths(ImmutableSet.copyOf(Strength.values()))
+        .withKeyStrengths(Sets.immutableEnumSet(Strength.STRONG, Strength.WEAK))
+        .withValueStrengths(Sets.immutableEnumSet(asList(Strength.values())))
         .withConcurrencyLevels(ImmutableSet.of(1, 4, 16, 64))
         .withMaximumSizes(ImmutableSet.of(0, 1, 10, 100, 1000))
         .withInitialCapacities(ImmutableSet.of(0, 1, 10, 100, 1000))

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/AbstractTraceReader.java
Patch:
@@ -24,7 +24,7 @@
 import java.io.SequenceInputStream;
 import java.io.UncheckedIOException;
 import java.nio.file.Files;
-import java.nio.file.Paths;
+import java.nio.file.Path;
 import java.util.Iterator;
 import java.util.List;
 import java.util.function.UnaryOperator;
@@ -138,7 +138,7 @@ protected BufferedInputStream readInput(InputStream input) {
 
   /** Returns the input stream for the raw file. */
   private InputStream openFile() throws IOException {
-    var file = Paths.get(filePath);
+    var file = Path.of(filePath);
     if (Files.exists(file)) {
       return Files.newInputStream(file);
     }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Issue30Test.java
Patch:
@@ -151,7 +151,7 @@ private static FutureSubject assertThat(String message, CompletableFuture<?> act
 
   static final class Loader implements AsyncCacheLoader<String, String> {
     private static final DateTimeFormatter FORMATTER =
-        DateTimeFormatter.ofPattern("hh:MM:ss.SSS", US);
+        DateTimeFormatter.ofPattern("HH:mm:ss.SSS", US);
 
     final ConcurrentMap<String, String> source;
     final ConcurrentMap<String, Instant> lastLoad;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/DelegationBenchmark.java
Patch:
@@ -33,7 +33,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @State(Scope.Benchmark)
-@SuppressWarnings("PMD.MethodNamingConventions")
+@SuppressWarnings({"MemberName", "PMD.MethodNamingConventions"})
 public class DelegationBenchmark {
   private static final int SIZE = (2 << 14);
   private static final int MASK = SIZE - 1;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/FactoryBenchmark.java
Patch:
@@ -36,7 +36,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @State(Scope.Benchmark)
-@SuppressWarnings("PMD.MethodNamingConventions")
+@SuppressWarnings({"MemberName", "PMD.MethodNamingConventions"})
 public class FactoryBenchmark {
   private final ReflectionFactory reflectionFactory = new ReflectionFactory();
   private final MethodHandleFactory methodHandleFactory = new MethodHandleFactory();

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/SlotLookupBenchmark.java
Patch:
@@ -48,7 +48,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @State(Scope.Benchmark)
-@SuppressWarnings("PMD.MethodNamingConventions")
+@SuppressWarnings({"MemberName", "PMD.MethodNamingConventions"})
 public class SlotLookupBenchmark {
   static final int SPARSE_SIZE = 2 << 14;
   static final int ARENA_SIZE = 2 << 6;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/TimeBenchmark.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@SuppressWarnings("PMD.MethodNamingConventions")
+@SuppressWarnings({"MemberName", "PMD.MethodNamingConventions"})
 public class TimeBenchmark {
 
   @Benchmark @Threads(1)

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/BuilderBenchmark.java
Patch:
@@ -37,6 +37,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @State(Scope.Benchmark)
+@SuppressWarnings("MemberName")
 public class BuilderBenchmark {
   @Param BuilderType type;
   Supplier<?> builder;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/CacheType.java
Patch:
@@ -42,6 +42,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("MemberName")
 public enum CacheType {
 
   /* --------------- Unbounded --------------- */

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/ComputeBenchmark.java
Patch:
@@ -37,7 +37,8 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @State(Scope.Benchmark)
-@SuppressWarnings({"LexicographicalAnnotationAttributeListing", "PMD.MethodNamingConventions"})
+@SuppressWarnings({"LexicographicalAnnotationAttributeListing",
+  "MemberName", "PMD.MethodNamingConventions"})
 public class ComputeBenchmark {
   static final int SIZE = (2 << 14);
   static final int MASK = SIZE - 1;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/GetPutBenchmark.java
Patch:
@@ -42,7 +42,7 @@
  */
 @State(Scope.Group)
 @SuppressWarnings({"CanonicalAnnotationSyntax", "LexicographicalAnnotationAttributeListing",
-  "PMD.JUnit4TestShouldUseAfterAnnotation", "PMD.MethodNamingConventions"})
+  "MemberName", "PMD.JUnit4TestShouldUseAfterAnnotation", "PMD.MethodNamingConventions"})
 public class GetPutBenchmark {
   private static final int SIZE = (2 << 14);
   private static final int MASK = SIZE - 1;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/MemoryBenchmark.java
Patch:
@@ -44,7 +44,8 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@SuppressWarnings({"LexicographicalAnnotationAttributeListing", "PMD.MethodNamingConventions"})
+@SuppressWarnings({"LexicographicalAnnotationAttributeListing",
+  "MemberName", "PMD.MethodNamingConventions", "SystemOut"})
 public final class MemoryBenchmark {
   // The number of entries added to minimize skew due to non-entry factors
   static final int FUZZY_SIZE = 25_000;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/SketchType.java
Patch:
@@ -23,6 +23,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("MemberName")
 public enum SketchType {
   Flat {
     @Override public <E> TinyLfuSketch<E> create(long estimatedSize) {

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/profiler/ProfilerHook.java
Patch:
@@ -46,7 +46,7 @@ public final void run() {
 
   protected abstract void profile();
 
-  @SuppressWarnings("FutureReturnValueIgnored")
+  @SuppressWarnings({"FutureReturnValueIgnored", "SystemOut"})
   private void scheduleStatusTask() {
     var stopwatch = Stopwatch.createStarted();
     Executors.newSingleThreadScheduledExecutor().scheduleWithFixedDelay(() -> {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedBuffer.java
Patch:
@@ -121,7 +121,7 @@ public long writes() {
 }
 
 /** The namespace for field padding through inheritance. */
-@SuppressWarnings("MultiVariableDeclaration")
+@SuppressWarnings({"MemberName", "MultiVariableDeclaration"})
 final class BBHeader {
 
   private BBHeader() {}

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -4594,7 +4594,7 @@ private Object writeReplace() {
 }
 
 /** The namespace for field padding through inheritance. */
-@SuppressWarnings("MultiVariableDeclaration")
+@SuppressWarnings({"MemberName", "MultiVariableDeclaration"})
 final class BLCHeader {
 
   private BLCHeader() {}

File: caffeine/src/test/java/com/github/benmanes/caffeine/OSGiTest.java
Patch:
@@ -35,6 +35,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @RunWith(PaxExam.class)
+@SuppressWarnings("MemberName")
 @ExamReactorStrategy(PerMethod.class)
 public final class OSGiTest {
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CaffeineSpecGuavaTest.java
Patch:
@@ -325,6 +325,7 @@ public void testParse_unknownKey() {
   }
 
   // Allowed by Caffeine
+  @SuppressWarnings("MemberName")
   public void disabled_testParse_extraCommaIsInvalid() {
     assertThrows(IllegalArgumentException.class, () -> parse("weakKeys,"));
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/Stresser.java
Patch:
@@ -115,6 +115,7 @@ private void execute() {
     });
   }
 
+  @SuppressWarnings("SystemOut")
   private void status() {
     var evictionLock = local.evictionLock;
     int pendingWrites;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/TimerWheelTest.java
Patch:
@@ -561,6 +561,7 @@ private List<Long> snapshot(boolean ascending) {
     return snapshot;
   }
 
+  @SuppressWarnings("SystemOut")
   private void printTimerWheel() {
     var builder = new StringBuilder();
     for (int i = 0; i < timerWheel.wheel.length; i++) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/BufferType.java
Patch:
@@ -22,7 +22,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@SuppressWarnings("ImmutableEnumChecker")
+@SuppressWarnings({"ImmutableEnumChecker", "MemberName"})
 public enum BufferType {
   Ticket(TicketBuffer::new),
   FastFlow(FastFlowBuffer::new),

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/HashClashTest.java
Patch:
@@ -84,13 +84,15 @@ public void testCache(Cache<Long, Long> cache, CacheContext context) {
     assertThat(cache.stats().hitRate()).isGreaterThan(0.99d);
   }
 
+  @SuppressWarnings("SystemOut")
   static void printStats(Cache<Long, Long> cache) {
     if (debug) {
       System.out.printf("size %,d requests %,d hit ratio %f%n",
           cache.estimatedSize(), cache.stats().requestCount(), cache.stats().hitRate());
     }
   }
 
+  @SuppressWarnings("SystemOut")
   static void printKeys(Cache<Long, Long> cache) {
     if (debug) {
       Set<Long> keys = cache.policy().eviction()

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Issue30Test.java
Patch:
@@ -167,7 +167,7 @@ public CompletableFuture<String> asyncLoad(String key, Executor executor) {
       return CompletableFuture.completedFuture(source.get(key));
     }
 
-    @SuppressWarnings("TimeZoneUsage")
+    @SuppressWarnings({"SystemOut", "TimeZoneUsage"})
     private void reportCacheMiss(String key) {
       Instant now = Instant.now();
       Instant last = lastLoad.get(key);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheSpec.java
Patch:
@@ -67,8 +67,8 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@SuppressWarnings("ImmutableEnumChecker")
 @Target(METHOD) @Retention(RUNTIME)
+@SuppressWarnings({"ImmutableEnumChecker", "MemberName"})
 public @interface CacheSpec {
 
   /* --------------- Compute --------------- */

File: caffeine/src/test/java/com/github/benmanes/caffeine/fuzz/CaffeineSpecFuzzer.java
Patch:
@@ -27,10 +27,10 @@ public final class CaffeineSpecFuzzer {
   // These tests require the environment variable JAZZER_FUZZ=1 to try new input arguments
 
   @FuzzTest(maxDuration = "5m")
-  @SuppressWarnings({"CheckReturnValue", "PMD.EmptyCatchBlock"})
+  @SuppressWarnings("CheckReturnValue")
   public void parse(FuzzedDataProvider data) {
     try {
       CaffeineSpec.parse(data.consumeRemainingAsString());
-    } catch (IllegalArgumentException e) { /* ignored */ }
+    } catch (IllegalArgumentException expected) { /* ignored */ }
   }
 }

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/Collection8Test.java
Patch:
@@ -53,9 +53,9 @@
  */
 @SuppressWarnings({"CatchAndPrintStackTrace", "CollectionAddAllToCollectionBlock",
     "CollectionForEach", "CollectionIsEmpty", "CollectionToArray", "CollectorMutability",
-    "LabelledBreakTarget", "MethodReferenceUsage", "MissingDefault", "MissingFail",
-    "MultiVariableDeclaration", "rawtypes", "ReturnValueIgnored", "try", "unchecked",
-    "UnnecessaryFinal", "UnnecessaryParentheses", "YodaCondition"})
+    "EmptyCatch", "LabelledBreakTarget", "MemberName", "MethodReferenceUsage", "MissingDefault",
+    "MissingFail", "MultiVariableDeclaration", "rawtypes", "ReturnValueIgnored", "SystemOut",
+    "try", "unchecked", "UnnecessaryFinal", "UnnecessaryParentheses", "YodaCondition"})
 public class Collection8Test extends JSR166TestCase {
     final CollectionImplementation impl;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/ConcurrentHashMap8Test.java
Patch:
@@ -30,7 +30,7 @@
 import junit.framework.Test;
 import junit.framework.TestSuite;
 
-@SuppressWarnings({"IdentityConversion", "PreferredInterfaceType",
+@SuppressWarnings({"EmptyCatch", "IdentityConversion", "PreferredInterfaceType",
   "rawtypes", "try", "unchecked", "UnnecessaryFinal"})
 public class ConcurrentHashMap8Test extends JSR166TestCase {
     public static void main(String[] args) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/ConcurrentHashMapTest.java
Patch:
@@ -24,8 +24,9 @@
 
 import junit.framework.Test;
 
-@SuppressWarnings({"ForEachIterable", "ModifyCollectionInEnhancedForLoop", "PreferredInterfaceType",
-  "rawtypes", "ReturnValueIgnored", "unchecked", "UnnecessaryFinal", "UnnecessaryParentheses"})
+@SuppressWarnings({"EmptyCatch", "ForEachIterable", "MemberName",
+  "ModifyCollectionInEnhancedForLoop", "PreferredInterfaceType", "rawtypes",
+  "ReturnValueIgnored", "unchecked", "UnnecessaryFinal", "UnnecessaryParentheses"})
 public class ConcurrentHashMapTest extends JSR166TestCase {
     public static void main(String[] args) {
         main(suite());

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/JSR166TestCase.java
Patch:
@@ -194,10 +194,10 @@
  * </ul>
  */
 @SuppressWarnings({"AnnotateFormatMethod", "ClassEscapesDefinedScope", "CollectionToArray",
-    "ConstantField", "EqualsIncompatibleType", "FunctionalInterfaceClash",
+    "ConstantField", "EmptyCatch", "EqualsIncompatibleType", "FunctionalInterfaceClash",
     "InterruptedExceptionSwallowed", "JavaUtilDate", "JUnit3FloatingPointComparisonWithoutDelta",
-    "NonFinalStaticField", "NumericEquality", "rawtypes", "ReferenceEquality",
-    "RethrowReflectiveOperationExceptionAsLinkageError", "serial", "SwitchDefault",
+    "MemberName", "NonFinalStaticField", "NumericEquality", "rawtypes", "ReferenceEquality",
+    "RethrowReflectiveOperationExceptionAsLinkageError", "serial", "SwitchDefault", "SystemOut",
     "ThreadPriorityCheck", "try", "unchecked", "UndefinedEquals", "UnnecessaryFinal"})
 public class JSR166TestCase extends TestCase {
 //    private static final boolean useSecurityManager =

File: caffeine/src/test/java/com/github/benmanes/caffeine/lincheck/AbstractLincheckCacheTest.java
Patch:
@@ -41,7 +41,7 @@
  */
 @Param(name = "key", gen = IntGen.class, conf = "1:5")
 @Param(name = "value", gen = IntGen.class, conf = "1:10")
-@SuppressWarnings("PMD.AbstractClassWithoutAbstractMethod")
+@SuppressWarnings({"MemberName", "PMD.AbstractClassWithoutAbstractMethod"})
 public abstract class AbstractLincheckCacheTest {
   private final LoadingCache<Integer, Integer> cache;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/Threads.java
Patch:
@@ -68,8 +68,8 @@ public static <A> void runTest(A collection, ImmutableList<BiConsumer<A, Int>> o
   public static void executeWithTimeOut(Queue<String> failures, Callable<Long> task) {
     try {
       var future = executor.submit(task);
-      long timeNS = future.get(TIMEOUT, TimeUnit.SECONDS);
-      logger.debug("\nExecuted in {} second(s)", TimeUnit.NANOSECONDS.toSeconds(timeNS));
+      long nanos = future.get(TIMEOUT, TimeUnit.SECONDS);
+      logger.debug("\nExecuted in {} second(s)", TimeUnit.NANOSECONDS.toSeconds(nanos));
     } catch (ExecutionException e) {
       fail("Exception during test: " + e, e);
     } catch (TimeoutException e) {

File: guava/src/test/java/com/github/benmanes/caffeine/guava/OSGiTest.java
Patch:
@@ -37,6 +37,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @RunWith(PaxExam.class)
+@SuppressWarnings("MemberName")
 @ExamReactorStrategy(PerMethod.class)
 public final class OSGiTest {
 

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheBuilderTest.java
Patch:
@@ -448,7 +448,7 @@ public void testRemovalNotification_clear_basher() throws InterruptedException {
    * (removed because of size limits or expiration) trigger appropriate removal notifications.
    */
   @GwtIncompatible("QueuingRemovalListener")
-  @SuppressWarnings("FutureReturnValueIgnored")
+  @SuppressWarnings({"EmptyCatch", "FutureReturnValueIgnored"})
   public void testRemovalNotification_get_basher() throws InterruptedException {
     int nTasks = 1000;
     int nThreads = 100;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/management/JCacheMXBean.java
Patch:
@@ -26,6 +26,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("MemberName")
 public final class JCacheMXBean implements CacheMXBean {
   private final Cache<?, ?> cache;
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/management/JCacheStatisticsMXBean.java
Patch:
@@ -27,6 +27,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("MemberName")
 public final class JCacheStatisticsMXBean implements CacheStatisticsMXBean {
   private final LongAdder puts = new LongAdder();
   private final LongAdder hits = new LongAdder();

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/OSGiTest.java
Patch:
@@ -41,6 +41,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @RunWith(PaxExam.class)
+@SuppressWarnings("MemberName")
 @ExamReactorStrategy(PerMethod.class)
 public final class OSGiTest {
   private static final String PROVIDER_NAME =

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/management/JCacheStatisticsMXBeanTest.java
Patch:
@@ -22,6 +22,7 @@
 /**
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("MemberName")
 public final class JCacheStatisticsMXBeanTest {
 
   @Test

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/glcache/GLCacheTraceReader.java
Patch:
@@ -31,6 +31,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("MemberName")
 public final class GLCacheTraceReader extends BinaryTraceReader {
 
   public GLCacheTraceReader(String filePath) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/greedy_dual/GDWheelPolicy.java
Patch:
@@ -44,6 +44,7 @@
  * @author himelbrand@gmail.com (Omri Himelbrand)
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("MemberName")
 @PolicySpec(name = "greedy-dual.GDWheel", characteristics = WEIGHTED)
 public final class GDWheelPolicy implements Policy {
   private final Long2ObjectMap<Node> data;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/StatsCounter.java
Patch:
@@ -24,7 +24,7 @@
 
 /**
  * Accumulates statistics during the operation of a {@link Cache} for presentation by
- * {@link Cache#stats}. This is solely intended for consumption by {@code Cache} implementors.
+ * {@link Cache#stats}.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsyncTest.java
Patch:
@@ -30,6 +30,7 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 
 import org.mockito.Mockito;
 import org.testng.annotations.DataProvider;
@@ -80,7 +81,7 @@ public void getWhenSuccessful_success(CompletableFuture<Integer> future) {
   @Test
   public void getWhenSuccessful_success_async() {
     var future = new CompletableFuture<Integer>();
-    var result = new AtomicInteger();
+    var result = new AtomicReference<Integer>();
     ConcurrentTestHarness.execute(() -> {
       result.set(1);
       result.set(Async.getWhenSuccessful(future));

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CacheTest.java
Patch:
@@ -868,7 +868,7 @@ public void invalidateAll_removalListener_writeback(Cache<Int, Int> cache, Cache
   @CacheSpec
   @CheckNoStats
   @Test(dataProvider = "caches")
-  public void cleanup(Cache<Int, Int> cache, CacheContext context) {
+  public void cleanUp(Cache<Int, Int> cache, CacheContext context) {
     cache.cleanUp();
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ReferenceTest.java
Patch:
@@ -39,6 +39,7 @@
 
 import java.util.AbstractMap;
 import java.util.AbstractMap.SimpleEntry;
+import java.util.AbstractMap.SimpleImmutableEntry;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -1300,13 +1301,14 @@ public Object[][] providesReferences() {
     };
   }
 
+  @SuppressWarnings("MapEntry")
   private static List<Map.Entry<Int, Int>> getExpectedAfterGc(
       CacheContext context, Map<Int, Int> original) {
     var expected = new ArrayList<Map.Entry<Int, Int>>();
     original.forEach((key, value) -> {
       key = context.isStrongKeys() ? new Int(key) : null;
       value = context.isStrongValues() ? new Int(value) : null;
-      expected.add(new SimpleEntry<>(key, value));
+      expected.add(new SimpleImmutableEntry<>(key, value));
     });
     return expected;
   }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContextSubject.java
Patch:
@@ -32,7 +32,7 @@
 
 import java.util.AbstractMap.SimpleEntry;
 import java.util.Arrays;
-import java.util.List;
+import java.util.Collection;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.function.BiConsumer;
@@ -366,7 +366,7 @@ public Exclusive contains(Map<Int, Int> map) {
       }
 
       @CanIgnoreReturnValue
-      public Exclusive contains(List<Entry<Int, Int>> entries) {
+      public Exclusive contains(Collection<Entry<Int, Int>> entries) {
         return contains(entries.toArray(Map.Entry[]::new));
       }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheSpec.java
Patch:
@@ -31,7 +31,6 @@
 import java.lang.annotation.Target;
 import java.time.Duration;
 import java.util.Collection;
-import java.util.HashMap;
 import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
@@ -57,6 +56,7 @@
 import com.github.benmanes.caffeine.cache.testing.RemovalListeners.ConsumingRemovalListener;
 import com.github.benmanes.caffeine.testing.ConcurrentTestHarness;
 import com.github.benmanes.caffeine.testing.Int;
+import com.google.common.collect.Maps;
 import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.testing.TestingExecutors;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
@@ -471,7 +471,7 @@ enum Loader implements CacheLoader<Int, Int> {
         throw new UnsupportedOperationException();
       }
       @Override public Map<Int, Int> loadAll(Set<? extends Int> keys) {
-        var result = new HashMap<Int, Int>(keys.size());
+        Map<Int, Int> result = Maps.newHashMapWithExpectedSize(keys.size());
         for (Int key : keys) {
           result.put(key, key);
           intern(key);
@@ -484,7 +484,7 @@ enum Loader implements CacheLoader<Int, Int> {
         throw new UnsupportedOperationException();
       }
       @Override public Map<Int, Int> loadAll(Set<? extends Int> keys) throws Exception {
-        var result = new HashMap<Int, Int>(keys.size());
+        Map<Int, Int> result = Maps.newHashMapWithExpectedSize(keys.size());
         for (Int key : keys) {
           result.put(key, NEGATIVE.load(key));
           intern(key);

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/LoggingEvents.java
Patch:
@@ -46,7 +46,7 @@ public final class LoggingEvents extends ForwardingList<LoggingEvent> {
   private ImmutableList<LoggingEvent> filteredEvents;
   private boolean exclusive;
 
-  private LoggingEvents(List<LoggingEvent> events) {
+  private LoggingEvents(Iterable<LoggingEvent> events) {
     this.events = ImmutableList.copyOf(events);
     this.predicates = new ArrayList<>();
   }

File: guava/src/test/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaTest.java
Patch:
@@ -120,8 +120,7 @@ void cacheLoader_null() {
       @Override public Integer load(Integer key) {
         throw new UnsupportedOperationException();
       }
-      @Override
-      public ListenableFuture<Integer> reload(Integer key, Integer oldValue) {
+      @Override public ListenableFuture<Integer> reload(Integer key, Integer oldValue) {
         return null;
       }
     });

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurationTest.java
Patch:
@@ -29,6 +29,7 @@
 
 import javax.cache.Cache;
 import javax.cache.Caching;
+import javax.cache.configuration.CompleteConfiguration;
 import javax.cache.expiry.Duration;
 import javax.cache.expiry.ExpiryPolicy;
 
@@ -287,7 +288,7 @@ static void checkStoreByValue(CaffeineConfiguration<?, ?> config) {
     assertThat(config.getCopierFactory().create()).isInstanceOf(JavaSerializationCopier.class);
   }
 
-  static void checkListener(CaffeineConfiguration<?, ?> config) {
+  static void checkListener(CompleteConfiguration<?, ?> config) {
     var listener = Iterables.getOnlyElement(config.getCacheEntryListenerConfigurations());
     assertThat(listener.getCacheEntryListenerFactory().create())
         .isInstanceOf(TestCacheEntryListener.class);
@@ -297,7 +298,7 @@ static void checkListener(CaffeineConfiguration<?, ?> config) {
     assertThat(listener.isOldValueRequired()).isTrue();
   }
 
-  static void checkLazyExpiration(CaffeineConfiguration<?, ?> config) {
+  static void checkLazyExpiration(CompleteConfiguration<?, ?> config) {
     ExpiryPolicy expiry = config.getExpiryPolicyFactory().create();
     assertThat(expiry.getExpiryForCreation()).isEqualTo(Duration.ONE_MINUTE);
     assertThat(expiry.getExpiryForUpdate()).isEqualTo(Duration.FIVE_MINUTES);

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/issues/Issue1065Test.java
Patch:
@@ -118,9 +118,10 @@ public void deadlock() throws Exception {
           fail(i, threads);
         }
       }
-    } finally {
       executor.shutdown();
       executor.awaitTermination(1, TimeUnit.MINUTES);
+    } finally {
+      executor.shutdownNow();
     }
   }
 

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheFactoryGenerator.java
Patch:
@@ -95,8 +95,8 @@ private void generate() throws FormatterException, IOException {
   }
 
   private void writeJavaFile() throws IOException {
-    String header = Resources.toString(Resources.getResource("license.txt"), UTF_8).trim();
-    ZoneId timeZone = ZoneId.of("America/Los_Angeles");
+    var header = Resources.toString(Resources.getResource("license.txt"), UTF_8).trim();
+    var timeZone = ZoneId.of("America/Los_Angeles");
     for (TypeSpec typeSpec : factoryTypes) {
       JavaFile.builder(getClass().getPackageName(), typeSpec)
           .addFileComment(header, Year.now(timeZone))

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeFactoryGenerator.java
Patch:
@@ -98,7 +98,7 @@ private void generate() throws FormatterException, IOException {
 
   private void writeJavaFile() throws IOException {
     String header = Resources.toString(Resources.getResource("license.txt"), UTF_8).trim();
-    ZoneId timeZone = ZoneId.of("America/Los_Angeles");
+    var timeZone = ZoneId.of("America/Los_Angeles");
     for (TypeSpec node : nodeTypes) {
       JavaFile.builder(getClass().getPackage().getName(), node)
           .addFileComment(header, Year.now(timeZone))
@@ -185,7 +185,7 @@ private TypeSpec makeNodeSpec(String className, boolean isFinal, ImmutableSet<Fe
     return context.build();
   }
 
-  private Set<List<Object>> combinations() {
+  private static Set<List<Object>> combinations() {
     var keyStrengths = Set.of(Feature.STRONG_KEYS, Feature.WEAK_KEYS);
     var valueStrengths = Set.of(Feature.STRONG_VALUES, Feature.WEAK_VALUES, Feature.SOFT_VALUES);
     var expireAfterAccess = Set.of(false, true);

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/local/AddExpireAfterAccess.java
Patch:
@@ -36,12 +36,11 @@ public boolean applies(LocalCacheContext context) {
 
   @Override
   public void execute(LocalCacheContext context) {
-    context.suppressedWarnings.add("NullAway");
     variableExpiration(context);
     fixedExpiration(context);
   }
 
-  private void fixedExpiration(LocalCacheContext context) {
+  private static void fixedExpiration(LocalCacheContext context) {
     context.constructor.addStatement(
         "this.expiresAfterAccessNanos = builder.getExpiresAfterAccessNanos()");
     context.cache.addField(FieldSpec.builder(long.class, "expiresAfterAccessNanos")
@@ -63,7 +62,7 @@ private void fixedExpiration(LocalCacheContext context) {
         .build());
   }
 
-  private void variableExpiration(LocalCacheContext context) {
+  private static void variableExpiration(LocalCacheContext context) {
     context.cache.addMethod(MethodSpec.methodBuilder("expiresVariable")
         .addModifiers(context.protectedFinalModifiers())
         .addStatement("return (timerWheel != null)")

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/local/AddKeyValueStrength.java
Patch:
@@ -41,20 +41,20 @@ public void execute(LocalCacheContext context) {
     addValueStrength(context);
   }
 
-  private void addKeyStrength(LocalCacheContext context) {
+  private static void addKeyStrength(LocalCacheContext context) {
     if (context.generateFeatures.contains(Feature.WEAK_KEYS)) {
       addStrength(context, "collectKeys", "keyReferenceQueue", kRefQueueType);
     }
   }
 
-  private void addValueStrength(LocalCacheContext context) {
+  private static void addValueStrength(LocalCacheContext context) {
     if (context.generateFeatures.contains(Feature.INFIRM_VALUES)) {
       addStrength(context, "collectValues", "valueReferenceQueue", vRefQueueType);
     }
   }
 
   /** Adds the reference strength methods for the key or value. */
-  private void addStrength(LocalCacheContext context,
+  private static void addStrength(LocalCacheContext context,
       String collectName, String queueName, TypeName type) {
     context.cache.addMethod(MethodSpec.methodBuilder(queueName)
         .addModifiers(context.protectedFinalModifiers())

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/local/AddRemovalListener.java
Patch:
@@ -35,7 +35,6 @@ public boolean applies(LocalCacheContext context) {
 
   @Override
   public void execute(LocalCacheContext context) {
-    context.suppressedWarnings.add("NullAway");
     context.cache.addField(
         FieldSpec.builder(REMOVAL_LISTENER, "removalListener", Modifier.FINAL).build());
     context.constructor.addStatement("this.removalListener = builder.getRemovalListener(async)");

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/local/AddStats.java
Patch:
@@ -41,15 +41,15 @@ public void execute(LocalCacheContext context) {
     addStatsCounter(context);
   }
 
-  private void addIsRecording(LocalCacheContext context) {
+  private static void addIsRecording(LocalCacheContext context) {
     context.cache.addMethod(MethodSpec.methodBuilder("isRecordingStats")
         .addModifiers(context.publicFinalModifiers())
         .addStatement("return true")
         .returns(boolean.class)
         .build());
   }
 
-  private void addStatsCounter(LocalCacheContext context) {
+  private static void addStatsCounter(LocalCacheContext context) {
     context.constructor.addStatement("this.statsCounter = builder.getStatsCounterSupplier().get()");
     context.cache.addField(FieldSpec.builder(
         STATS_COUNTER, "statsCounter", Modifier.FINAL).build());
@@ -60,7 +60,7 @@ private void addStatsCounter(LocalCacheContext context) {
         .build());
   }
 
-  private void addStatsTicker(LocalCacheContext context) {
+  private static void addStatsTicker(LocalCacheContext context) {
     context.cache.addMethod(MethodSpec.methodBuilder("statsTicker")
         .addModifiers(context.publicFinalModifiers())
         .addStatement("return $T.systemTicker()", TICKER)

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/local/AddSubtype.java
Patch:
@@ -37,7 +37,6 @@ public boolean applies(LocalCacheContext context) {
 
   @Override
   public void execute(LocalCacheContext context) {
-    context.suppressedWarnings.add("MissingOverride");
     context.cache.superclass(context.superClass)
         .addJavadoc(getJavaDoc(context))
         .addTypeVariable(kTypeVar)
@@ -47,8 +46,8 @@ public void execute(LocalCacheContext context) {
     }
   }
 
-  private String getJavaDoc(LocalCacheContext context) {
-    StringBuilder doc = new StringBuilder(200);
+  private static String getJavaDoc(LocalCacheContext context) {
+    var doc = new StringBuilder(200);
     doc.append("<em>WARNING: GENERATED CODE</em>\n\n"
         + "A cache that provides the following features:\n<ul>");
     for (Feature feature : context.generateFeatures) {

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddDeques.java
Patch:
@@ -48,7 +48,7 @@ public void execute(NodeContext context) {
   }
 
   /** Adds a simple field, accessor, and mutator for the variable. */
-  private void addFieldAndGetter(NodeContext context, String varName) {
+  private static void addFieldAndGetter(NodeContext context, String varName) {
     context.nodeSubtype.addField(NODE, varName)
         .addMethod(context.newGetter(Strength.STRONG, NODE, varName, Visibility.VOLATILE))
         .addMethod(context.newSetter(NODE, varName, Visibility.VOLATILE));

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddMaximum.java
Patch:
@@ -39,7 +39,7 @@ public void execute(NodeContext context) {
     addWeight(context);
   }
 
-  private void addQueueFlag(NodeContext context) {
+  private static void addQueueFlag(NodeContext context) {
     context.nodeSubtype.addField(int.class, "queueType");
     context.nodeSubtype.addMethod(MethodSpec.methodBuilder("getQueueType")
         .addModifiers(context.publicFinalModifiers())
@@ -53,7 +53,7 @@ private void addQueueFlag(NodeContext context) {
         .build());
   }
 
-  private void addWeight(NodeContext context) {
+  private static void addWeight(NodeContext context) {
     if (!context.generateFeatures.contains(Feature.MAXIMUM_WEIGHT)) {
       return;
     }

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddSubtype.java
Patch:
@@ -39,7 +39,6 @@ public boolean applies(NodeContext context) {
 
   @Override
   public void execute(NodeContext context) {
-    context.suppressedWarnings.add("MissingOverride");
     context.nodeSubtype
         .addJavadoc(getJavaDoc(context))
         .addTypeVariable(kTypeVar)
@@ -56,7 +55,7 @@ public void execute(NodeContext context) {
     }
   }
 
-  private String getJavaDoc(NodeContext context) {
+  private static String getJavaDoc(NodeContext context) {
     var doc = new StringBuilder(200);
     doc.append("<em>WARNING: GENERATED CODE</em>\n\n"
         + "A cache entry that provides the following features:\n<ul>");

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/Finalize.java
Patch:
@@ -52,7 +52,7 @@ public void execute(NodeContext context) {
     addStaticBlock(context);
   }
 
-  private void addStaticBlock(NodeContext context) {
+  private static void addStaticBlock(NodeContext context) {
     if (context.varHandles.isEmpty()) {
       return;
     }

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/SlotLookupBenchmark.java
Patch:
@@ -152,11 +152,11 @@ public long striped64_varHandle(Blackhole blackhole) {
     return array[index];
   }
 
-  private int getProbe_varHandle() {
+  private static int getProbe_varHandle() {
     return (int) PROBE.get(Thread.currentThread());
   }
 
-  private void advanceProbe_varHandle(int probe) {
+  private static void advanceProbe_varHandle(int probe) {
     probe ^= probe << 13; // xorshift
     probe ^= probe >>> 17;
     probe ^= probe << 5;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/CacheType.java
Patch:
@@ -155,7 +155,7 @@ public enum CacheType {
   },
   LinkedHashMap_Lru {
     @Override public <K, V> BasicCache<K, V> create(int maximumSize) {
-      return new LinkedHashMapCache<>(maximumSize, /* accessOrder */ true);
+      return new LinkedHashMapCache<>(maximumSize, /* accessOrder= */ true);
     }
   },
   TCache_Lfu {

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/ComputeBenchmark.java
Patch:
@@ -18,7 +18,6 @@
 import java.util.Arrays;
 import java.util.Random;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
 import java.util.function.Function;
 
 import org.openjdk.jmh.annotations.Benchmark;
@@ -93,7 +92,7 @@ public Boolean compute_spread(ThreadState threadState) {
   }
 
   private void setupConcurrentHashMap() {
-    ConcurrentMap<Integer, Boolean> map = new ConcurrentHashMap<>();
+    var map = new ConcurrentHashMap<Integer, Boolean>();
     benchmarkFunction = key -> map.computeIfAbsent(key, mappingFunction);
   }
 

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/MemoryBenchmark.java
Patch:
@@ -77,7 +77,7 @@ public void run() {
     softValues();
   }
 
-  private Caffeine<Object, Object> builder() {
+  private static Caffeine<Object, Object> builder() {
     // Avoid counting ForkJoinPool in estimates
     return Caffeine.newBuilder().executor(Runnable::run);
   }

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/TimerWheelBenchmark.java
Patch:
@@ -156,7 +156,7 @@ static final class MockCache extends BoundedLocalCache<Integer, Integer> {
 
     @SuppressWarnings({"rawtypes", "unchecked"})
     MockCache() {
-      super((Caffeine) Caffeine.newBuilder(), /* cacheLoader */ null, /* isAsync */ false);
+      super((Caffeine) Caffeine.newBuilder(), /* cacheLoader= */ null, /* isAsync= */ false);
     }
 
     @Override

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/HazelcastCache.java
Patch:
@@ -44,7 +44,7 @@ public HazelcastCache(int maximumSize, EvictionPolicy policy) {
             .setEvictionPolicy(policy)
             .setSize(maximumSize));
     cache = new DefaultNearCache<>("simulation", config, DummySerializationService.INSTANCE,
-        /* TaskScheduler */ null, getClass().getClassLoader(), /* HazelcastProperties */ null);
+        /* scheduler= */ null, getClass().getClassLoader(), /* properties= */ null);
     cache.initialize();
   }
 
@@ -55,7 +55,7 @@ public V get(K key) {
 
   @Override
   public void put(K key, V value) {
-    cache.put(key, /* keyData */ null, value, /* valueDate */ null);
+    cache.put(key, /* keyData= */ null, value, /* valueDate= */ null);
   }
 
   @Override
@@ -88,7 +88,7 @@ enum DummySerializationService implements SerializationService {
       return (T) data;
     }
     @Override public ManagedContext getManagedContext() {
-      return null;
+      throw new UnsupportedOperationException();
     }
     @Override public <B extends Data> B trimSchema(Data data) {
       return (B) data;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/sketch/CountMinSketch.java
Patch:
@@ -82,8 +82,7 @@ public CountMinSketch(@NonNegative long maximumSize) {
    * @return the estimated number of occurrences of the element; possibly zero but never negative
    */
   @Override
-  @NonNegative
-  public int frequency(E e) {
+  public @NonNegative int frequency(E e) {
     int hash = spread(e.hashCode());
     int start = (hash & 3) << 2;
     int frequency = Integer.MAX_VALUE;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/profiler/CacheProfiler.java
Patch:
@@ -90,7 +90,7 @@ private void writes() {
   }
 
   public static void main(String[] args) {
-    CacheProfiler profile = new CacheProfiler();
+    var profile = new CacheProfiler();
     profile.run();
   }
 }

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/profiler/ProfilerHook.java
Patch:
@@ -48,7 +48,7 @@ public final void run() {
 
   @SuppressWarnings("FutureReturnValueIgnored")
   private void scheduleStatusTask() {
-    Stopwatch stopwatch = Stopwatch.createStarted();
+    var stopwatch = Stopwatch.createStarted();
     Executors.newSingleThreadScheduledExecutor().scheduleWithFixedDelay(() -> {
       long count = calls.longValue();
       long rate = count / stopwatch.elapsed(TimeUnit.SECONDS);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Async.java
Patch:
@@ -49,12 +49,12 @@ static boolean isReady(@Nullable CompletableFuture<?> future) {
 
   /** Returns the current value or null if either not done or failed. */
   @SuppressWarnings("NullAway")
-  static @Nullable <V> V getIfReady(@Nullable CompletableFuture<V> future) {
+  static <V> @Nullable V getIfReady(@Nullable CompletableFuture<V> future) {
     return isReady(future) ? future.join() : null;
   }
 
   /** Returns the value when completed successfully or null if failed. */
-  static @Nullable <V> V getWhenSuccessful(@Nullable CompletableFuture<V> future) {
+  static <V> @Nullable V getWhenSuccessful(@Nullable CompletableFuture<V> future) {
     try {
       return (future == null) ? null : future.join();
     } catch (CancellationException | CompletionException e) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CaffeineSpec.java
Patch:
@@ -97,7 +97,7 @@ private CaffeineSpec(String specification) {
    * @return a builder configured to the specification
    */
   Caffeine<Object, Object> toBuilder() {
-    Caffeine<Object, Object> builder = Caffeine.newBuilder();
+    var builder = Caffeine.newBuilder();
     if (initialCapacity != UNSET_INT) {
       builder.initialCapacity(initialCapacity);
     }
@@ -141,7 +141,7 @@ Caffeine<Object, Object> toBuilder() {
    */
   @SuppressWarnings("StringSplitter")
   public static CaffeineSpec parse(String specification) {
-    CaffeineSpec spec = new CaffeineSpec(specification);
+    var spec = new CaffeineSpec(specification);
     for (String option : specification.split(SPLIT_OPTIONS)) {
       spec.parseOption(option.trim());
     }
@@ -336,7 +336,7 @@ public boolean equals(@Nullable Object o) {
     } else if (!(o instanceof CaffeineSpec)) {
       return false;
     }
-    CaffeineSpec spec = (CaffeineSpec) o;
+    var spec = (CaffeineSpec) o;
     return Objects.equals(refreshAfterWrite, spec.refreshAfterWrite)
         && Objects.equals(expireAfterAccess, spec.expireAfterAccess)
         && Objects.equals(expireAfterWrite, spec.expireAfterWrite)

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalCache.java
Patch:
@@ -97,7 +97,7 @@ interface LocalCache<K, V> extends ConcurrentMap<K, V> {
   default @Nullable V compute(K key,
       BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
     return compute(key, remappingFunction, expiry(),
-        /* recordLoad */ true, /* recordLoadFailure */ true);
+        /* recordLoad= */ true, /* recordLoadFailure= */ true);
   }
 
   /**
@@ -109,7 +109,7 @@ interface LocalCache<K, V> extends ConcurrentMap<K, V> {
 
   @Override
   default @Nullable V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {
-    return computeIfAbsent(key, mappingFunction, /* recordStats */ true, /* recordLoad */ true);
+    return computeIfAbsent(key, mappingFunction, /* recordStats= */ true, /* recordLoad= */ true);
   }
 
   /**
@@ -184,7 +184,7 @@ default void notifyOnReplace(K key, V oldValue, V newValue) {
   /** Decorates the remapping function to record statistics if enabled. */
   default <T, U, R> BiFunction<? super T, ? super U, ? extends R> statsAware(
       BiFunction<? super T, ? super U, ? extends R> remappingFunction) {
-    return statsAware(remappingFunction, /* recordLoad */ true, /* recordLoadFailure */ true);
+    return statsAware(remappingFunction, /* recordLoad= */ true, /* recordLoadFailure= */ true);
   }
 
   /** Decorates the remapping function to record statistics if enabled. */

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalManualCache.java
Patch:
@@ -29,6 +29,7 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.cache.stats.CacheStats;
+import com.google.errorprone.annotations.Var;
 
 /**
  * This class provides a skeletal implementation of the {@link Cache} interface to minimize the
@@ -53,7 +54,7 @@ default void cleanUp() {
 
   @Override
   default @Nullable V getIfPresent(K key) {
-    return cache().getIfPresent(key, /* recordStats */ true);
+    return cache().getIfPresent(key, /* recordStats= */ true);
   }
 
   @Override
@@ -97,8 +98,8 @@ default Map<K, V> getAll(Iterable<? extends K> keys,
    */
   default void bulkLoad(Set<K> keysToLoad, Map<K, V> result,
       Function<? super Set<? extends K>, ? extends Map<? extends K, ? extends V>> mappingFunction) {
-    boolean success = false;
     long startTime = cache().statsTicker().read();
+    @Var boolean success = false;
     try {
       var loaded = mappingFunction.apply(Collections.unmodifiableSet(keysToLoad));
       loaded.forEach(cache()::put);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Pacer.java
Patch:
@@ -57,7 +57,7 @@ public void schedule(Executor executor, Runnable command, long now, long delay)
       if (maySkip(scheduleAt)) {
         return;
       }
-      future.cancel(/* mayInterruptIfRunning */ false);
+      future.cancel(/* mayInterruptIfRunning= */ false);
     }
     long actualDelay = calculateSchedule(now, delay, scheduleAt);
     future = scheduler.schedule(executor, command, actualDelay, TimeUnit.NANOSECONDS);
@@ -66,7 +66,7 @@ public void schedule(Executor executor, Runnable command, long now, long delay)
   /** Attempts to cancel execution of the scheduled task, if present. */
   public void cancel() {
     if (future != null) {
-      future.cancel(/* mayInterruptIfRunning */ false);
+      future.cancel(/* mayInterruptIfRunning= */ false);
       nextFireTime = 0L;
       future = null;
     }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Policy.java
Patch:
@@ -76,8 +76,7 @@ public interface Policy<K, V> {
    *         mapping for the key
    * @throws NullPointerException if the specified key is null
    */
-  @Nullable
-  default CacheEntry<K, V> getEntryIfPresentQuietly(K key) {
+  default @Nullable CacheEntry<K, V> getEntryIfPresentQuietly(K key) {
     // This method was added & implemented in version 3.0.6
     throw new UnsupportedOperationException();
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/References.java
Patch:
@@ -69,7 +69,7 @@ default boolean referenceEquals(@Nullable Object object) {
       if (object == this) {
         return true;
       } else if (object instanceof InternalReference<?>) {
-        InternalReference<?> referent = (InternalReference<?>) object;
+        var referent = (InternalReference<?>) object;
         return (get() == referent.get());
       }
       return false;
@@ -87,7 +87,7 @@ default boolean objectEquals(Object object) {
       if (object == this) {
         return true;
       } else if (object instanceof InternalReference<?>) {
-        InternalReference<?> referent = (InternalReference<?>) object;
+        var referent = (InternalReference<?>) object;
         return Objects.equals(get(), referent.get());
       }
       return false;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/SnapshotEntry.java
Patch:
@@ -77,7 +77,7 @@ class SnapshotEntry<K, V> implements CacheEntry<K, V> {
 
   /** Returns a cache entry containing the given key, value, and snapshot. */
   public static <K, V> SnapshotEntry<K, V> forEntry(K key, V value) {
-    return new SnapshotEntry<>(key, value, /* snapshot */ 0);
+    return new SnapshotEntry<>(key, value, /* snapshot= */ 0);
   }
 
   /** Returns a cache entry with the specified metadata. */

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Weigher.java
Patch:
@@ -53,7 +53,7 @@ public interface Weigher<K, V> {
    */
   static <K, V> Weigher<K, V> singletonWeigher() {
     @SuppressWarnings("unchecked")
-    Weigher<K, V> instance = (Weigher<K, V>) SingletonWeigher.INSTANCE;
+    var instance = (Weigher<K, V>) SingletonWeigher.INSTANCE;
     return instance;
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/CacheStats.java
Patch:
@@ -357,7 +357,7 @@ public boolean equals(@Nullable Object o) {
     } else if (!(o instanceof CacheStats)) {
       return false;
     }
-    CacheStats other = (CacheStats) o;
+    var other = (CacheStats) o;
     return hitCount == other.hitCount
         && missCount == other.missCount
         && loadSuccessCount == other.loadSuccessCount

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CaffeineSpecTest.java
Patch:
@@ -110,14 +110,15 @@ public void days(CacheContext context) {
     runScenarios(context, new Epoch(TimeUnit.DAYS, "d"));
   }
 
-  private void runScenarios(CacheContext context, Epoch epoch) {
+  private static void runScenarios(CacheContext context, Epoch epoch) {
     runTest(context, epoch, duration -> epoch.toUnitString(duration).toLowerCase(US));
     runTest(context, epoch, duration -> epoch.toUnitString(duration).toUpperCase(US));
     runTest(context, epoch, duration -> epoch.truncate(duration).toString().toLowerCase(US));
     runTest(context, epoch, duration -> epoch.truncate(duration).toString().toUpperCase(US));
   }
 
-  private void runTest(CacheContext context, Epoch epoch, Function<Duration, String> formatter) {
+  private static void runTest(CacheContext context,
+      Epoch epoch, Function<Duration, String> formatter) {
     CaffeineSpec spec = toSpec(context, formatter);
     Caffeine<Object, Object> builder = Caffeine.from(spec);
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/InternerTest.java
Patch:
@@ -149,7 +149,7 @@ public void factory() {
     var builder = Caffeine.newBuilder();
     builder.interner = true;
 
-    var factory = NodeFactory.newFactory(builder, /* async */ false);
+    var factory = NodeFactory.newFactory(builder, /* isAsync= */ false);
     assertThat(factory).isSameInstanceAs(Interned.FACTORY);
   }
 
@@ -167,7 +167,7 @@ public void interned() {
     assertThat(node.isDead()).isTrue();
   }
 
-  private void checkSize(Interner<Int> interner, int size) {
+  private static void checkSize(Interner<Int> interner, int size) {
     if (interner instanceof StrongInterner) {
       assertThat(((StrongInterner<Int>) interner).map).hasSize(size);
     } else if (interner instanceof WeakInterner) {
@@ -185,7 +185,7 @@ private void checkSize(Interner<Int> interner, int size) {
     }
   }
 
-  private void checkState(Interner<Int> interner) {
+  private static void checkState(Interner<Int> interner) {
     if (interner instanceof WeakInterner) {
       assertAbout(mapLocal()).that(((WeakInterner<Int>) interner).cache).isValid();
     }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LinkedDequeTest.java
Patch:
@@ -115,7 +115,7 @@ public void moveToFront_last(LinkedDeque<LinkedValue> deque) {
     checkMoveToFront(deque, deque.getLast());
   }
 
-  private void checkMoveToFront(LinkedDeque<LinkedValue> deque, LinkedValue element) {
+  private static void checkMoveToFront(LinkedDeque<LinkedValue> deque, LinkedValue element) {
     deque.moveToFront(element);
     assertThat(deque).hasSize(SIZE);
     assertThat(deque.peekFirst()).isEqualTo(element);
@@ -136,7 +136,7 @@ public void moveToBack_last(LinkedDeque<LinkedValue> deque) {
     checkMoveToBack(deque, deque.getLast());
   }
 
-  private void checkMoveToBack(LinkedDeque<LinkedValue> deque, LinkedValue element) {
+  private static void checkMoveToBack(LinkedDeque<LinkedValue> deque, LinkedValue element) {
     deque.moveToBack(element);
     assertThat(deque).hasSize(SIZE);
     assertThat(deque.getLast()).isEqualTo(element);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/MultiThreadedTest.java
Patch:
@@ -42,6 +42,7 @@
 import com.github.benmanes.caffeine.cache.testing.CheckMaxLogLevel;
 import com.github.benmanes.caffeine.testing.Int;
 import com.github.benmanes.caffeine.testing.Threads;
+import com.google.common.collect.ImmutableList;
 import com.google.common.testing.SerializableTester;
 
 /**
@@ -100,7 +101,7 @@ public void async_concurrent_bounded(
 
   @SuppressWarnings({"CollectionToArray", "FutureReturnValueIgnored", "MethodReferenceUsage",
     "rawtypes", "ReturnValueIgnored", "SelfEquals", "SizeGreaterThanOrEqualsZero"})
-  List<BiConsumer<LoadingCache<Int, Int>, Int>> operations = List.of(
+  ImmutableList<BiConsumer<LoadingCache<Int, Int>, Int>> operations = ImmutableList.of(
       // LoadingCache
       (cache, key) -> { cache.get(key); },
       (cache, key) -> { cache.getAll(List.of(key)); },
@@ -160,7 +161,7 @@ public void async_concurrent_bounded(
       });
 
   @SuppressWarnings({"CheckReturnValue", "FutureReturnValueIgnored", "MethodReferenceUsage"})
-  List<BiConsumer<AsyncLoadingCache<Int, Int>, Int>> asyncOperations = List.of(
+  ImmutableList<BiConsumer<AsyncLoadingCache<Int, Int>, Int>> asyncOperations = ImmutableList.of(
       (cache, key) -> { cache.getIfPresent(key); },
       (cache, key) -> { cache.get(key, k -> key); },
       (cache, key) -> { cache.get(key, (k, e) -> CompletableFuture.completedFuture(key)); },

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ReferenceTest.java
Patch:
@@ -1298,7 +1298,7 @@ public Object[][] providesReferences() {
     };
   }
 
-  private List<Map.Entry<Int, Int>> getExpectedAfterGc(
+  private static List<Map.Entry<Int, Int>> getExpectedAfterGc(
       CacheContext context, Map<Int, Int> original) {
     var expected = new ArrayList<Map.Entry<Int, Int>>();
     original.forEach((key, value) -> {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/RefreshAfterWriteTest.java
Patch:
@@ -400,7 +400,7 @@ public void refreshIfNeeded_error_log(CacheContext context) {
       population = Population.EMPTY, refreshAfterWrite = Expire.ONE_MINUTE)
   public void refreshIfNeeded_nullFuture(CacheContext context) {
     var refreshed = new AtomicBoolean();
-    CacheLoader<Int, Int> loader = new CacheLoader<Int, Int>() {
+    var loader = new CacheLoader<Int, Int>() {
       @Override public Int load(Int key) {
         throw new IllegalStateException();
       }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ReserializableSubject.java
Patch:
@@ -220,7 +220,7 @@ private void checkEvictionListener(
     }
   }
 
-  private Weigher<?, ?> unwrapWeigher(Weigher<?, ?> weigher) {
+  private static Weigher<?, ?> unwrapWeigher(Weigher<?, ?> weigher) {
     for (;;) {
       if (weigher instanceof BoundedWeigher<?, ?>) {
         weigher = ((BoundedWeigher<?, ?>) weigher).delegate;
@@ -232,7 +232,7 @@ private void checkEvictionListener(
     }
   }
 
-  private Expiry<?, ?> unwrapExpiry(Expiry<?, ?> expiry) {
+  private static Expiry<?, ?> unwrapExpiry(Expiry<?, ?> expiry) {
     for (;;) {
       if (expiry instanceof AsyncExpiry<?, ?>) {
         expiry = ((AsyncExpiry<?, ?>) expiry).delegate;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/TimerWheelTest.java
Patch:
@@ -332,7 +332,7 @@ private void checkTimerWheel(long duration) {
     }
   }
 
-  private LongArrayList getTimers(Node<?, ?> sentinel) {
+  private static LongArrayList getTimers(Node<?, ?> sentinel) {
     var timers = new LongArrayList();
     for (var node = sentinel.getNextInVariableOrder();
          node != sentinel; node = node.getNextInVariableOrder()) {
@@ -506,11 +506,11 @@ public void iterator_random() {
     var ascending = Streams.stream(timerWheel.iterator())
         .limit(range + 1).map(Node::getKey).collect(toImmutableList());
     assertThat(ascending).containsExactlyElementsIn(input);
-    assertThat(ascending).containsExactlyElementsIn(snapshot(/* ascending */ true)).inOrder();
+    assertThat(ascending).containsExactlyElementsIn(snapshot(/* ascending= */ true)).inOrder();
 
     var descending = Streams.stream(timerWheel.descendingIterator())
         .limit(range + 1).map(Node::getKey).collect(toImmutableList());
-    assertThat(descending).containsExactlyElementsIn(snapshot(/* ascending */ false)).inOrder();
+    assertThat(descending).containsExactlyElementsIn(snapshot(/* ascending= */ false)).inOrder();
     assertThat(descending).containsExactlyElementsIn(input);
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/FastFlowBuffer.java
Patch:
@@ -89,8 +89,11 @@ public long writes() {
 }
 
 /** The namespace for field padding through inheritance. */
+@SuppressWarnings("MultiVariableDeclaration")
 final class FastFlowHeader {
 
+  private FastFlowHeader() {}
+
   abstract static class PadReadCache<E> extends ReadBuffer<E> {
     byte p000, p001, p002, p003, p004, p005, p006, p007;
     byte p008, p009, p010, p011, p012, p013, p014, p015;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/ManyToOneBuffer.java
Patch:
@@ -83,8 +83,11 @@ public long writes() {
 }
 
 /** The namespace for field padding through inheritance. */
+@SuppressWarnings("MultiVariableDeclaration")
 final class ManyToOneHeader {
 
+  private ManyToOneHeader() {}
+
   @SuppressWarnings("PMD.AbstractClassWithoutAbstractMethod")
   abstract static class PadReadCounter<E> extends ReadBuffer<E> {
     byte p000, p001, p002, p003, p004, p005, p006, p007;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/ManyToOneSpacedBuffer.java
Patch:
@@ -89,8 +89,11 @@ public long writes() {
 }
 
 /** The namespace for field padding through inheritance. */
+@SuppressWarnings("MultiVariableDeclaration")
 final class ManyToOneSpacedHeader {
 
+  private ManyToOneSpacedHeader() {}
+
   @SuppressWarnings("PMD.AbstractClassWithoutAbstractMethod")
   abstract static class PadReadCounter<E> extends ReadBuffer<E> {
     byte p000, p001, p002, p003, p004, p005, p006, p007;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/HashClashTest.java
Patch:
@@ -44,6 +44,8 @@ public final class HashClashTest {
   private static final int STEP = 5;
   private static final Long LONG_1 = 1L;
   private static final long ITERS = 200_000;
+  private static final Long CLASH = (ITERS << 32) ^ ITERS ^ 1;
+
   private static final boolean debug = false;
 
   @Test(dataProvider = "caches")
@@ -58,7 +60,6 @@ public void testCache(Cache<Long, Long> cache, CacheContext context) {
     printKeys(cache);
 
     // add a hashcode clash for 1
-    Long CLASH = (ITERS << 32) ^ ITERS ^ 1;
     assertThat(CLASH.hashCode()).isEqualTo(LONG_1.hashCode());
     cache.get(CLASH, identity());
     printKeys(cache);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Issue30Test.java
Patch:
@@ -101,7 +101,7 @@ public void expiration(AsyncLoadingCache<String, String> cache,
     secondUpdate(cache, source);
   }
 
-  private void initialValues(AsyncLoadingCache<String, String> cache,
+  private static void initialValues(AsyncLoadingCache<String, String> cache,
       ConcurrentMap<String, String> source, ConcurrentMap<String, Instant> lastLoad) {
     source.put(A_KEY, A_ORIGINAL);
     source.put(B_KEY, B_ORIGINAL);
@@ -112,7 +112,7 @@ private void initialValues(AsyncLoadingCache<String, String> cache,
   }
 
   @SuppressWarnings("PreferJavaTimeOverload")
-  private void firstUpdate(AsyncLoadingCache<String, String> cache,
+  private static void firstUpdate(AsyncLoadingCache<String, String> cache,
       ConcurrentMap<String, String> source) throws InterruptedException {
     source.put(A_KEY, A_UPDATE_1);
     source.put(B_KEY, B_UPDATE_1);
@@ -132,7 +132,7 @@ private void firstUpdate(AsyncLoadingCache<String, String> cache,
   }
 
   @SuppressWarnings("PreferJavaTimeOverload")
-  private void secondUpdate(AsyncLoadingCache<String, String> cache,
+  private static void secondUpdate(AsyncLoadingCache<String, String> cache,
       ConcurrentMap<String, String> source) throws InterruptedException {
     source.put(A_KEY, A_UPDATE_2);
     source.put(B_KEY, B_UPDATE_2);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Issue859Test.java
Patch:
@@ -56,7 +56,7 @@ public void scheduleIfPendingWrites() {
     }
   }
 
-  private TestRun runTest() {
+  private static TestRun runTest() {
     var latch = new CountDownLatch(NUMBER_OF_KEYS);
     Cache<Integer, Boolean> cache = Caffeine.newBuilder()
         .removalListener((key, value, cause) -> latch.countDown())

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContextSubject.java
Patch:
@@ -49,6 +49,7 @@
 import com.github.benmanes.caffeine.cache.testing.RemovalListeners.ConsumingRemovalListener;
 import com.github.benmanes.caffeine.testing.Int;
 import com.google.common.base.CaseFormat;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableMultiset;
 import com.google.common.collect.Multimaps;
 import com.google.common.truth.FailureMetadata;
@@ -276,11 +277,11 @@ public static final class ListenerSubject extends Subject {
     static final Factory<ListenerSubject, CacheContext> LISTENERS_FACTORY =
         factoryOf(RemovalListenerType.values());
 
-    private final Map<RemovalListenerType, RemovalListener<Int, Int>> actual;
+    private final ImmutableMap<RemovalListenerType, RemovalListener<Int, Int>> actual;
     private final boolean isDirect;
 
     private ListenerSubject(FailureMetadata metadata, CacheContext context,
-        Map<RemovalListenerType, RemovalListener<Int, Int>> subject) {
+        ImmutableMap<RemovalListenerType, RemovalListener<Int, Int>> subject) {
       super(metadata, subject);
       this.actual = subject;
       this.isDirect = (context.executorType() == CacheExecutor.DIRECT);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheGenerator.java
Patch:
@@ -61,7 +61,7 @@ public final class CacheGenerator {
 
   public CacheGenerator(CacheSpec cacheSpec) {
     this(cacheSpec, Options.fromSystemProperties(),
-        /* isLoadingOnly */ false, /* isAsyncOnly */ false, /* isGuavaCompatible */ true);
+        /* isLoadingOnly= */ false, /* isAsyncOnly= */ false, /* isGuavaCompatible= */ true);
   }
 
   CacheGenerator(CacheSpec cacheSpec, Options options,
@@ -250,7 +250,7 @@ private static void populate(CacheContext context, Cache<Int, Int> cache) {
 
   /** Returns a cache of integers and their negation. */
   private static ImmutableList<Map.Entry<Int, Int>> makeInts() {
-    int size = Arrays.stream(CacheSpec.Population.values())
+    int size = Arrays.stream(Population.values())
         .mapToInt(population -> Math.toIntExact(population.size()))
         .max().getAsInt();
     var builder = new ImmutableList.Builder<Map.Entry<Int, Int>>();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CaffeineCacheFromContext.java
Patch:
@@ -42,7 +42,7 @@ interface SerializableTicker extends Ticker, Serializable {}
   private CaffeineCacheFromContext() {}
 
   public static <K, V> Cache<K, V> newCaffeineCache(CacheContext context) {
-    Caffeine<Object, Object> builder = Caffeine.newBuilder();
+    var builder = Caffeine.newBuilder();
     context.caffeine = builder;
 
     if (context.initialCapacity() != InitialCapacity.DEFAULT) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/acceptance/ParallelMapIteratePutAcceptanceTest.java
Patch:
@@ -63,7 +63,7 @@ private static void fullGc() {
   }
 
   @Test
-  public void testMapIteratePut() {
+  public void mapIteratePut() {
     int constSize = 100_000;
     int size = 10_000_000;
     Integer[] contents = new Integer[size];
@@ -84,7 +84,7 @@ private void runAllPutTests(Integer[] contents, Integer[] constContents) {
     ExecutorService executorService = new ThreadPoolExecutor(MAX_THREADS, MAX_THREADS, 0,
         TimeUnit.SECONDS, new LinkedBlockingDeque<>(MAX_THREADS));
     int threads = 10;
-    runPutTest1(threads, contents, constContents, executorService, false);
+    runPutTest1(threads, contents, constContents, executorService, /* warmup= */ false);
     executorService.shutdown();
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/mutable/MutableMapTestCase.java
Patch:
@@ -51,7 +51,7 @@ public void collectKeysAndValues() {
   }
 
   @Test
-  public void testClone() {
+  public void cloneable() {
     MutableMap<Integer, String> map = newMapWithKeysValues(1, "One", 2, "Two");
     MutableMap<Integer, String> clone = map.clone();
     Assert.assertNotSame(map, clone);

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/ConcurrentHashMap8Test.java
Patch:
@@ -30,7 +30,8 @@
 import junit.framework.Test;
 import junit.framework.TestSuite;
 
-@SuppressWarnings({"IdentityConversion", "PreferredInterfaceType", "rawtypes", "try", "unchecked"})
+@SuppressWarnings({"IdentityConversion", "PreferredInterfaceType",
+  "rawtypes", "try", "unchecked", "UnnecessaryFinal"})
 public class ConcurrentHashMap8Test extends JSR166TestCase {
     public static void main(String[] args) {
         main(suite());

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/KeySetTest.java
Patch:
@@ -42,8 +42,8 @@ class Implementation implements CollectionImplementation {
         }
         return newTestSuite(
                 KeySetTest.class,
-                CollectionTest.testSuite(new Implementation(false)),
-                CollectionTest.testSuite(new Implementation(true)));
+                CollectionTest.testSuite(new Implementation(/* bounded= */ false)),
+                CollectionTest.testSuite(new Implementation(/* bounded= */ true)));
     }
 
     private static <E> Set<E> set(boolean bounded) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/MapImplementation.java
Patch:
@@ -23,7 +23,7 @@ public interface MapImplementation {
     default int valueToInt(Object value) { return (Integer) value; }
 
     public boolean isConcurrent();
-    default boolean remappingFunctionCalledAtMostOnce() { return true; };
+    default boolean remappingFunctionCalledAtMostOnce() { return true; }
     public boolean permitsNullKeys();
     public boolean permitsNullValues();
     public boolean supportsSetValue();

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/MapTest.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * Contains tests applicable to all Map implementations.
  */
-@SuppressWarnings({"rawtypes", "unchecked", "UnnecessaryParentheses"})
+@SuppressWarnings({"rawtypes", "unchecked", "UnnecessaryFinal", "UnnecessaryParentheses"})
 public class MapTest extends JSR166TestCase {
     final MapImplementation impl;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/CollectionSubject.java
Patch:
@@ -26,13 +26,14 @@
 import java.util.Set;
 
 import com.google.common.truth.FailureMetadata;
+import com.google.common.truth.IterableSubject;
 
 /**
  * Additional propositions for {@link Collection} subjects.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public class CollectionSubject extends com.google.common.truth.IterableSubject {
+public class CollectionSubject extends IterableSubject {
   private final Collection<?> actual;
 
   public CollectionSubject(FailureMetadata metadata, Collection<?> subject) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/ConcurrentTestHarness.java
Patch:
@@ -77,13 +77,14 @@ public static long timeTasks(int nThreads, Runnable task) {
    * @return the result of each task and the full execution time, in nanoseconds
    */
   @CanIgnoreReturnValue
+  @SuppressWarnings("InterruptedExceptionSwallowed")
   public static <T> TestResult<T> timeTasks(int nThreads, Callable<T> task) {
     var startGate = new CountDownLatch(1);
     var endGate = new CountDownLatch(nThreads);
     var results = new AtomicReferenceArray<T>(nThreads);
 
     for (int i = 0; i < nThreads; i++) {
-      final int index = i;
+      int index = i;
       executor.execute(() -> {
         try {
           startGate.await();

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/LoggingEvents.java
Patch:
@@ -40,13 +40,13 @@
  */
 public final class LoggingEvents extends ForwardingList<LoggingEvent> {
   private final List<Predicate<LoggingEvent>> predicates;
-  private final List<LoggingEvent> events;
+  private final ImmutableList<LoggingEvent> events;
 
   private ImmutableList<LoggingEvent> filteredEvents;
   private boolean exclusive;
 
   private LoggingEvents(List<LoggingEvent> events) {
-    this.events = requireNonNull(events);
+    this.events = ImmutableList.copyOf(events);
     this.predicates = new ArrayList<>();
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/MapSubject.java
Patch:
@@ -33,6 +33,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 public class MapSubject extends com.google.common.truth.MapSubject {
+  @SuppressWarnings("ImmutableMemberCollection")
   private final Map<?, ?> actual;
 
   public MapSubject(FailureMetadata metadata, Map<?, ?> subject) {

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaLoadingCache.java
Patch:
@@ -188,7 +188,7 @@ static final class InternalBulkLoader<K, V> extends InternalSingleLoader<K, V> {
         if (loaded == null) {
           throw new InvalidCacheLoadException("null map");
         }
-        Map<K, V> result = new HashMap<>(loaded.size(), /* load factor */ 1.0f);
+        var result = new HashMap<K, V>(loaded.size(), /* loadFactor= */ 1.0f);
         loaded.forEach((key, value) -> {
           if ((key == null) || (value == null)) {
             nullBulkLoad.set(true);

File: guava/src/test/java/com/github/benmanes/caffeine/guava/GuavaMapTests.java
Patch:
@@ -32,7 +32,7 @@
 public final class GuavaMapTests extends TestCase {
 
   public static Test suite() {
-    TestSuite suite = new TestSuite();
+    var suite = new TestSuite();
     addGuavaViewTests(suite);
     return suite;
   }

File: guava/src/test/java/com/github/benmanes/caffeine/guava/OSGiTest.java
Patch:
@@ -52,7 +52,7 @@ public Option[] config() {
 
   @Test
   public void sanity() {
-    CacheLoader<Integer, Integer> loader = new CacheLoader<Integer, Integer>() {
+    var loader = new CacheLoader<Integer, Integer>() {
       @Override public Integer load(Integer key) {
         return -key;
       }

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheBuilderFactory.java
Patch:
@@ -129,7 +129,7 @@ Iterable<Caffeine<Object, Object>> buildAllPermutations() {
    * Optionals, calls Sets.cartesianProduct with those, then transforms the result to unwrap
    * the Optionals.
    */
-  private Iterable<List<Object>> buildCartesianProduct(Set<?>... sets) {
+  private static Iterable<List<Object>> buildCartesianProduct(Set<?>... sets) {
     List<Set<Optional<?>>> optionalSets = Lists.newArrayListWithExpectedSize(sets.length);
     for (Set<?> set : sets) {
       Set<Optional<?>> optionalSet =
@@ -145,7 +145,7 @@ private Iterable<List<Object>> buildCartesianProduct(Set<?>... sets) {
         });
   }
 
-  private Caffeine<Object, Object> createCacheBuilder(
+  private static Caffeine<Object, Object> createCacheBuilder(
       Integer concurrencyLevel, Integer initialCapacity, Integer maximumSize,
       DurationSpec expireAfterWrite, DurationSpec expireAfterAccess, DurationSpec refresh,
       Strength keyStrength, Strength valueStrength) {

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheManualTest.java
Patch:
@@ -192,8 +192,8 @@ public void testRecursiveLoadWithProxy() throws InterruptedException {
     testLoadThrows(key, cache, proxyLoader);
   }
 
-  private void testLoadThrows(String key, Cache<String, String> cache, Callable<String> loader)
-      throws InterruptedException {
+  private static void testLoadThrows(String key,
+      Cache<String, String> cache, Callable<String> loader) throws InterruptedException {
     CountDownLatch doneSignal = new CountDownLatch(1);
     Thread thread = new Thread(() -> {
       try {

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheReferencesTest.java
Patch:
@@ -47,13 +47,13 @@ public class CacheReferencesTest extends TestCase {
         }
       };
 
-  private CacheBuilderFactory factoryWithAllKeyStrengths() {
+  private static CacheBuilderFactory factoryWithAllKeyStrengths() {
     return new CacheBuilderFactory()
         .withKeyStrengths(ImmutableSet.of(STRONG, Strength.WEAK))
         .withValueStrengths(ImmutableSet.of(STRONG, Strength.WEAK, Strength.SOFT));
   }
 
-  private Iterable<LoadingCache<Key, String>> caches() {
+  private static Iterable<LoadingCache<Key, String>> caches() {
     CacheBuilderFactory factory = factoryWithAllKeyStrengths();
     return Iterables.transform(factory.buildAllPermutations(),
         new Function<Caffeine<Object, Object>, LoadingCache<Key, String>>() {
@@ -124,7 +124,7 @@ public void testInvalidate() {
 
   // A simple type whose .toString() will return the same value each time, but without maintaining
   // a strong reference to that value.
-  static class Key {
+  static final class Key {
     private final int value;
     private WeakReference<String> toString;
 

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheTesting.java
Patch:
@@ -41,6 +41,8 @@
 @SuppressWarnings({"GuardedByChecker", "PreferJavaTimeOverload"})
 class CacheTesting {
 
+  private CacheTesting() {}
+
   static void drainRecencyQueues(Cache<?, ?> cache) {
     cache.cleanUp();
   }

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/TestingRemovalListeners.java
Patch:
@@ -31,6 +31,8 @@
 @GwtCompatible(emulated = true)
 class TestingRemovalListeners {
 
+  private TestingRemovalListeners() {}
+
   /**
    * Returns a new no-op {@code RemovalListener}.
    */

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/TestingWeighers.java
Patch:
@@ -23,6 +23,8 @@
  */
 public class TestingWeighers {
 
+  private TestingWeighers() {}
+
   /**
    * Returns a {@link Weigher} that returns the given {@code constant} for every request.
    */

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheManagerImpl.java
Patch:
@@ -111,15 +111,15 @@ public <K, V, C extends Configuration<K, V>> Cache<K, V> createCache(
       enableStatistics(cache.getName(), config.isStatisticsEnabled());
 
       @SuppressWarnings("unchecked")
-      Cache<K, V> castedCache = (Cache<K, V>) cache;
+      var castedCache = (Cache<K, V>) cache;
       return castedCache;
     } finally {
       Thread.currentThread().setContextClassLoader(old);
     }
   }
 
   @Override
-  public @Nullable <K, V> Cache<K, V> getCache(
+  public <K, V> @Nullable Cache<K, V> getCache(
       String cacheName, Class<K> keyType, Class<V> valueType) {
     ClassLoader old = Thread.currentThread().getContextClassLoader();
     try {
@@ -172,7 +172,7 @@ public <K, V> CacheProxy<K, V> getCache(String cacheName) {
       });
 
       @SuppressWarnings("unchecked")
-      CacheProxy<K, V> castedCache = (CacheProxy<K, V>) cache;
+      var castedCache = (CacheProxy<K, V>) cache;
       return castedCache;
     } finally {
       Thread.currentThread().setContextClassLoader(old);

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/EntryProxy.java
Patch:
@@ -38,7 +38,7 @@ public <T> T unwrap(Class<T> clazz) {
       throw new IllegalArgumentException("Class " + clazz + " is unknown to this implementation");
     }
     @SuppressWarnings("unchecked")
-    T castedEntry = (T) this;
+    var castedEntry = (T) this;
     return castedEntry;
   }
 }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/copy/JavaSerializationCopier.java
Patch:
@@ -100,7 +100,7 @@ protected ClassLoader getClassLoader() {
     protected Class<?> resolveClass(ObjectStreamClass desc)
         throws IOException, ClassNotFoundException {
       try {
-        return Class.forName(desc.getName(), /* initialize */ false, getClassLoader());
+        return Class.forName(desc.getName(), /* initialize= */ false, getClassLoader());
       } catch (ClassNotFoundException ex) {
         return super.resolveClass(desc);
       }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/EventTypeFilter.java
Patch:
@@ -70,7 +70,7 @@ public boolean equals(Object o) {
     } else if (!(o instanceof EventTypeFilter<?, ?>)) {
       return false;
     }
-    EventTypeFilter<?, ?> other = (EventTypeFilter<?, ?>) o;
+    var other = (EventTypeFilter<?, ?>) o;
     return Objects.equals(listener, other.listener)
         && Objects.equals(filter, other.filter);
   }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/JCacheEntryEvent.java
Patch:
@@ -76,7 +76,7 @@ public <T> T unwrap(Class<T> clazz) {
       throw new IllegalArgumentException("Class " + clazz + " is unknown to this implementation");
     }
     @SuppressWarnings("unchecked")
-    T castedEntry = (T) this;
+    var castedEntry = (T) this;
     return castedEntry;
   }
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/integration/JCacheLoaderAdapter.java
Patch:
@@ -90,7 +90,7 @@ public void setCache(CacheProxy<K, V> cache) {
         // Subtracts the load time from the get time
         statistics.recordGetTime(start - ticker.read());
       }
-      return new Expirable<>(value, expireTimeMS());
+      return new Expirable<>(value, expireTimeMillis());
     } catch (CacheLoaderException e) {
       throw e;
     } catch (RuntimeException e) {
@@ -107,7 +107,7 @@ public Map<K, Expirable<V>> loadAll(Set<? extends K> keys) {
       Map<K, Expirable<V>> result = delegate.loadAll(keys).entrySet().stream()
           .filter(entry -> (entry.getKey() != null) && (entry.getValue() != null))
           .collect(toUnmodifiableMap(Map.Entry::getKey,
-              entry -> new Expirable<>(entry.getValue(), expireTimeMS())));
+              entry -> new Expirable<>(entry.getValue(), expireTimeMillis())));
       for (var entry : result.entrySet()) {
         dispatcher.publishCreated(cache, entry.getKey(), entry.getValue().get());
       }
@@ -124,7 +124,7 @@ public Map<K, Expirable<V>> loadAll(Set<? extends K> keys) {
     }
   }
 
-  private long expireTimeMS() {
+  private long expireTimeMillis() {
     try {
       Duration duration = expiry.getExpiryForCreation();
       if (duration.isZero()) {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/processor/EntryProcessorEntry.java
Patch:
@@ -101,7 +101,7 @@ public <T> T unwrap(Class<T> clazz) {
       throw new IllegalArgumentException("Class " + clazz + " is unknown to this implementation");
     }
     @SuppressWarnings("unchecked")
-    T castedEntry = (T) this;
+    var castedEntry = (T) this;
     return castedEntry;
   }
 

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/CacheManagerTest.java
Patch:
@@ -63,7 +63,7 @@ public void jmxBeanIsRegistered_getCache() throws OperationsException {
     checkConfigurationJmx(() -> cacheManager.getCache("test-cache"));
   }
 
-  private void checkConfigurationJmx(Supplier<Cache<?, ?>> cacheSupplier)
+  private static void checkConfigurationJmx(Supplier<Cache<?, ?>> cacheSupplier)
       throws OperationsException {
     Cache<?, ?> cache = cacheSupplier.get();
 

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/JCacheProfiler.java
Patch:
@@ -83,6 +83,7 @@ public void start() {
   }
 
   @CanIgnoreReturnValue
+  @SuppressWarnings("SystemOut")
   private ScheduledFuture<?> scheduleStatusTask() {
     var stopwatch = Stopwatch.createStarted();
     return Executors.newSingleThreadScheduledExecutor().scheduleWithFixedDelay(() -> {

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/OSGiTest.java
Patch:
@@ -75,7 +75,7 @@ public void sanity() {
   }
 
   @Test
-  public void testOSGIDS() {
+  public void declarativeService() {
     assertNotNull("Should have found a registered CachingProvider.", cachingProvider);
     assertEquals(CaffeineCachingProvider.class, cachingProvider.getClass());
   }

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/configuration/JCacheConfigurationTest.java
Patch:
@@ -78,7 +78,7 @@ public void definedCache() {
         cacheManager.getCache("test-cache-2", String.class, Integer.class), 1000L);
   }
 
-  private void checkConfiguration(Supplier<Cache<?, ?>> cacheSupplier, long expectedValue) {
+  private static void checkConfiguration(Supplier<Cache<?, ?>> cacheSupplier, long expectedValue) {
     Cache<?, ?> cache = cacheSupplier.get();
 
     @SuppressWarnings("unchecked")

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurationTest.java
Patch:
@@ -189,7 +189,7 @@ public void defaults() {
 
   @Test
   public void cacheNames() {
-    assertThat(TypesafeConfigurator.cacheNames(ConfigFactory.empty())).isEmpty();;
+    assertThat(TypesafeConfigurator.cacheNames(ConfigFactory.empty())).isEmpty();
 
     var names = TypesafeConfigurator.cacheNames(ConfigFactory.load());
     assertThat(names).containsExactly("default", "listeners", "osgi-cache",

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/copy/JavaSerializationCopierTest.java
Patch:
@@ -123,14 +123,14 @@ public void canDeeplyCopy() {
   @Test(dataProvider = "copier")
   @SuppressWarnings({"JavaUtilDate", "JdkObsolete", "UndefinedEquals"})
   public void deepCopy_date(Copier copier) {
-    Date date = new Date();
+    var date = new Date();
     assertThat(copy(copier, date)).isEqualTo(date);
   }
 
   @Test(dataProvider = "copier")
   @SuppressWarnings({"JavaUtilDate", "JdkObsolete"})
   public void deepCopy_calendar(Copier copier) {
-    Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone("UTC"), US);
+    var calendar = Calendar.getInstance(TimeZone.getTimeZone("UTC"), US);
     calendar.setTime(new Date());
     assertThat(copy(copier, calendar)).isEqualTo(calendar);
   }
@@ -153,7 +153,7 @@ public void array_mutable(Copier copier) {
     assertThat(copy(copier, array)).asList().containsExactlyElementsIn(array).inOrder();
   }
 
-  private <T> T copy(Copier copier, T object) {
+  private static <T> T copy(Copier copier, T object) {
     return copier.copy(object, Thread.currentThread().getContextClassLoader());
   }
 

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/event/EventDispatcherTest.java
Patch:
@@ -331,7 +331,7 @@ public void awaitSynchronous_nested() {
         pendingFutures.addAll(secondary.pending.get());
 
     var configuration = new MutableCacheEntryListenerConfiguration<>(
-        () -> listener, null, /* isOldValueRequired */ false, /* isSynchronous */ true);
+        () -> listener, null, /* isOldValueRequired= */ false, /* isSynchronous= */ true);
     primary.register(configuration);
     int key = 1;
 
@@ -378,7 +378,7 @@ private void registerAll(EventDispatcher<Integer, Integer> dispatcher) {
   private static final class ConsumingCacheListener implements
       CacheEntryCreatedListener<Integer, Integer>,  CacheEntryUpdatedListener<Integer, Integer>,
       CacheEntryRemovedListener<Integer, Integer>, CacheEntryExpiredListener<Integer, Integer> {
-    Queue<CacheEntryEvent<?, ?>> queue = new ConcurrentLinkedQueue<>();
+    final Queue<CacheEntryEvent<?, ?>> queue = new ConcurrentLinkedQueue<>();
 
     @Override
     public void onCreated(Iterable<CacheEntryEvent<? extends Integer, ? extends Integer>> events) {

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/event/EventTypeFilterTest.java
Patch:
@@ -43,7 +43,7 @@ public void equals_wrongType() {
   @Test
   public void equals_false() {
     CacheEntryCreatedListener<Integer, Integer> created = events -> {};
-    EventTypeFilter<Integer, Integer> other = new EventTypeFilter<>(created, event -> false);
+    var other = new EventTypeFilter<>(created, event -> false);
     assertThat(filter).isNotEqualTo(other);
   }
 

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/JCacheCombinedExpiryTest.java
Patch:
@@ -100,7 +100,7 @@ public void put_expired() {
 
     jcache.put(KEY_1, VALUE_2);
     Expirable<Integer> expirable = getExpirable(jcache, KEY_1);
-    assertThat(expirable.getExpireTimeMS())
+    assertThat(expirable.getExpireTimeMillis())
         .isEqualTo(currentTime().plus(EXPIRY_DURATION).toMillis());
   }
 
@@ -114,7 +114,7 @@ public void putIfAbsent_expired() {
     assertThat(jcache.putIfAbsent(KEY_1, VALUE_2)).isTrue();
     Expirable<Integer> expirable = getExpirable(jcache, KEY_1);
     assertThat(expirable.get()).isEqualTo(VALUE_2);
-    assertThat(expirable.getExpireTimeMS())
+    assertThat(expirable.getExpireTimeMillis())
         .isEqualTo(currentTime().plus(EXPIRY_DURATION).toMillis());
   }
 

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/JCacheExpiryAndMaximumSizeTest.java
Patch:
@@ -69,7 +69,7 @@ protected CaffeineConfiguration<Integer, Integer> getConfiguration() {
 
     configuration.setMaximumSize(OptionalLong.of(MAXIMUM));
     var listenerConfiguration = new MutableCacheEntryListenerConfiguration<>(() -> listener,
-        /* filterFactory */ null, /* isOldValueRequired */ false, /* isSynchronous */ true);
+        /* filterFactory= */ null, /* isOldValueRequired= */ false, /* isSynchronous= */ true);
     configuration.addCacheEntryListenerConfiguration(listenerConfiguration);
     configuration.setExecutorFactory(MoreExecutors::directExecutor);
 

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/integration/CacheWriterTest.java
Patch:
@@ -42,7 +42,7 @@
  */
 @Test(singleThreaded = true)
 public final class CacheWriterTest extends AbstractJCacheTest {
-  private CloseableCacheWriter writer = Mockito.mock();
+  private final CloseableCacheWriter writer = Mockito.mock();
 
   @Override
   protected CaffeineConfiguration<Integer, Integer> getConfiguration() {

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/issues/Issue1065Test.java
Patch:
@@ -89,7 +89,7 @@ public void before() {
         new MutableConfiguration<String, String>()
             .addCacheEntryListenerConfiguration(new MutableCacheEntryListenerConfiguration<>(
                 FactoryBuilder.factoryOf(new Listener()), FactoryBuilder.factoryOf(event -> true),
-                /* isOldValueRequired */ true, /* isSynchronous */ true))
+                /* isOldValueRequired= */ true, /* isSynchronous= */ true))
             .setCacheLoaderFactory(new FactoryBuilder.SingletonFactory<>(new Loader()))
             .setReadThrough(true));
     executor = Executors.newWorkStealingPool(NUM_THREADS);

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/management/JCacheStatisticsMXBeanTest.java
Patch:
@@ -26,7 +26,7 @@ public final class JCacheStatisticsMXBeanTest {
 
   @Test
   public void clear() {
-    JCacheStatisticsMXBean stats = new JCacheStatisticsMXBean();
+    var stats = new JCacheStatisticsMXBean();
     stats.recordHits(1);
     stats.recordMisses(1);
     stats.recordPuts(1);

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/processor/EntryProcessorEntryTest.java
Patch:
@@ -29,7 +29,8 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 public final class EntryProcessorEntryTest {
-  EntryProcessorEntry<Integer, Integer> entry = new EntryProcessorEntry<>(1, 2, Optional.empty());
+  final EntryProcessorEntry<Integer, Integer> entry =
+      new EntryProcessorEntry<>(1, 2, Optional.empty());
 
   @Test
   public void unwrap_fail() {

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/size/JCacheMaximumSizeTest.java
Patch:
@@ -47,8 +47,8 @@ protected CaffeineConfiguration<Integer, Integer> getConfiguration() {
     var configuration = new CaffeineConfiguration<Integer, Integer>();
     configuration.setMaximumSize(OptionalLong.of(MAXIMUM));
     var listenerConfiguration = new MutableCacheEntryListenerConfiguration<Integer, Integer>(
-        () -> listener, /* filterFactory */ null,
-        /* isOldValueRequired */ false, /* isSynchronous */ true);
+        () -> listener, /* filterFactory= */ null,
+        /* isOldValueRequired= */ false, /* isSynchronous= */ true);
     configuration.addCacheEntryListenerConfiguration(listenerConfiguration);
     configuration.setExecutorFactory(MoreExecutors::directExecutor);
     return configuration;

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/size/JCacheMaximumWeightTest.java
Patch:
@@ -51,8 +51,8 @@ protected CaffeineConfiguration<Integer, Integer> getConfiguration() {
     configuration.setMaximumWeight(OptionalLong.of(MAXIMUM));
     configuration.setWeigherFactory(Optional.of(() -> (key, value) -> value));
     var listenerConfiguration = new MutableCacheEntryListenerConfiguration<Integer, Integer>(
-        () -> listener, /* filterFactory */ null,
-        /* isOldValueRequired */ true, /* isSynchronous */ true);
+        () -> listener, /* filterFactory= */ null,
+        /* isOldValueRequired= */ true, /* isSynchronous= */ true);
     configuration.addCacheEntryListenerConfiguration(listenerConfiguration);
     configuration.setExecutorFactory(MoreExecutors::directExecutor);
     return configuration;

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/spi/CaffeineCachingProviderTest.java
Patch:
@@ -127,7 +127,7 @@ public void osgi_getCache() {
     }
   }
 
-  private void runWithClassloader(Consumer<CachingProvider> consumer) {
+  private static void runWithClassloader(Consumer<CachingProvider> consumer) {
     var reference = new AtomicReference<CachingProvider>();
     var thread = new Thread(() -> {
       Thread.currentThread().setContextClassLoader(new ClassLoader() {});

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/Simulator.java
Patch:
@@ -119,7 +119,7 @@ private void report(TraceReader trace, List<PolicyActor> policies) {
   }
 
   /** Returns a trace reader for the access events. */
-  private TraceReader getTraceReader(BasicSettings settings) {
+  private static TraceReader getTraceReader(BasicSettings settings) {
     if (settings.trace().isSynthetic()) {
       return Synthetic.generate(settings.trace());
     }
@@ -137,7 +137,7 @@ private ImmutableList<PolicyActor> getPolicyActors(Set<Characteristic> character
   }
 
   /** Throws the underlying cause for the simulation failure. */
-  private void throwError(RuntimeException error, Iterable<PolicyActor> policies) {
+  private static void throwError(RuntimeException error, Iterable<PolicyActor> policies) {
     if (!Thread.currentThread().isInterrupted()) {
       throw error;
     }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/clairvoyant/Clairvoyant.java
Patch:
@@ -24,6 +24,7 @@
 import com.github.benmanes.caffeine.cache.simulator.admission.Admittor.KeyOnlyAdmittor;
 import com.github.benmanes.caffeine.cache.simulator.policy.AccessEvent;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
+import com.google.errorprone.annotations.Var;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.ints.IntArrayFIFOQueue;
@@ -99,7 +100,7 @@ private static Long2ObjectMap<IntList> readAccessTimes(BasicSettings settings) {
     try (Stream<AccessEvent> events = trace.events()) {
       int[] tick = { 0 };
       events.forEach(event -> {
-        var times = accessTimes.get(event.key());
+        @Var var times = accessTimes.get(event.key());
         if (times == null) {
           times = new IntArrayList();
           accessTimes.put(event.key(), times);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/IncrementalResetCountMin4.java
Patch:
@@ -31,7 +31,7 @@ public final class IncrementalResetCountMin4 extends CountMin4 {
 
   public IncrementalResetCountMin4(Config config) {
     super(config);
-    BasicSettings settings = new BasicSettings(config);
+    var settings = new BasicSettings(config);
     interval = settings.tinyLfu().countMin4().incremental().interval();
     cursor = settings.randomSeed();
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/IndicatorResetCountMin4.java
Patch:
@@ -62,7 +62,7 @@ private double getIndicator() {
     return indicator.getIndicator();
   }
 
-  private int hintToStep(double ind) {
+  private static int hintToStep(double ind) {
     return (int) (ind * 30);
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin64/CountMin64TinyLfu.java
Patch:
@@ -42,7 +42,7 @@ public final class CountMin64TinyLfu implements Frequency {
   int size;
 
   public CountMin64TinyLfu(Config config) {
-    BasicSettings settings = new BasicSettings(config);
+    var settings = new BasicSettings(config);
     sketch = new CountMin64(settings.tinyLfu().countMin64().eps(),
         settings.tinyLfu().countMin64().confidence(), settings.randomSeed());
     sampleSize = Math.toIntExact(10 * settings.maximumSize());
@@ -58,7 +58,7 @@ public int frequency(long o) {
   @Override
   public void increment(long o) {
     if (sketch.estimateCount(o) < MAX_COUNT) {
-      sketch.add(conservative, o, 1);
+      sketch.add(o, 1, conservative);
     }
     size += 1;
     resetIfNeeded();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/perfect/PerfectFrequency.java
Patch:
@@ -34,9 +34,9 @@ public final class PerfectFrequency implements Frequency {
   private int size;
 
   public PerfectFrequency(Config config) {
-    BasicSettings settings = new BasicSettings(config);
-    sampleSize = Math.toIntExact(10 * settings.maximumSize());
     counts = new Long2IntOpenHashMap();
+    var settings = new BasicSettings(config);
+    sampleSize = Math.toIntExact(10 * settings.maximumSize());
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinyCacheAdapter.java
Patch:
@@ -37,7 +37,7 @@ public final class TinyCacheAdapter implements Frequency {
    * Note that in this implementation there are always 64 items per set.
    */
   public TinyCacheAdapter(Config config) {
-    BasicSettings settings = new BasicSettings(config);
+    var settings = new BasicSettings(config);
     // number of (independent sets)
     int nrSets = Math.toIntExact(sampleFactor * settings.maximumSize() / 64);
     tcs = new TinyCacheSketch(nrSets, 64,settings.randomSeed());

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/membership/bloom/FastFilter.java
Patch:
@@ -39,7 +39,7 @@ public final class FastFilter implements Membership {
   private Filter filter;
 
   public FastFilter(Config config) {
-    FastFilterSettings settings = new FastFilterSettings(config);
+    var settings = new FastFilterSettings(config);
     keys = new long[(int) settings.membership().expectedInsertions()];
     filterType = settings.filterType();
     bitsPerKey = settings.bitsPerKey();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/BinaryTraceReader.java
Patch:
@@ -48,7 +48,7 @@ protected BinaryTraceReader(String filePath) {
   public Stream<AccessEvent> events() {
     var input = new DataInputStream(readFile());
     var stream = StreamSupport.stream(Spliterators.spliteratorUnknownSize(
-        new TraceIterator(input), ORDERED | NONNULL), /* parallel */ false);
+        new TraceIterator(input), ORDERED | NONNULL), /* parallel= */ false);
     return stream.onClose(() -> Closeables.closeQuietly(input));
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/Rewriter.java
Patch:
@@ -28,6 +28,7 @@
 import com.google.common.base.CaseFormat;
 import com.google.common.base.Stopwatch;
 import com.google.common.collect.Lists;
+import com.google.errorprone.annotations.Var;
 
 import picocli.CommandLine;
 import picocli.CommandLine.Command;
@@ -92,8 +93,8 @@ public void run() {
   private static String[] argumentsWithDefaults(String[] args) {
     var params = Lists.newArrayList(args);
     if (!params.contains("--inputFormat")) {
-      boolean found = false;
-      boolean defaultFormat = true;
+      @Var boolean found = false;
+      @Var boolean defaultFormat = true;
       for (int i = 0; i < args.length - 1; i++) {
         if (Objects.equals(args[i], "--inputFiles")) {
           defaultFormat &= args[i + 1].contains(":");

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/AccessEvent.java
Patch:
@@ -67,7 +67,7 @@ public boolean equals(Object o) {
     } else if (!(o instanceof AccessEvent)) {
       return false;
     }
-    AccessEvent event = (AccessEvent) o;
+    var event = (AccessEvent) o;
     return (key() == event.key())
         && (weight() == event.weight())
         && (hitPenalty() == event.hitPenalty())

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/PolicyActor.java
Patch:
@@ -116,6 +116,7 @@ private final class Finish extends Command {
   }
 
   private abstract class Command implements Runnable {
+    @SuppressWarnings("Interruption")
     @Override public final void run() {
       var name = Thread.currentThread().getName();
       Thread.currentThread().setName(policy.getClass().getSimpleName());

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/Registry.java
Patch:
@@ -140,6 +140,7 @@ private void registerMany(Class<? extends Policy> policyClass,
   }
 
   /** Registers the policy using the specified name. */
+  @SuppressWarnings("InconsistentOverloads")
   private void registerMany(String name, Class<? extends Policy> policyClass,
       Function<Config, Set<Policy>> creator) {
     factories.put(name.trim().toLowerCase(US), Factory.of(policyClass, creator));

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/greedy_dual/GdsfPolicy.java
Patch:
@@ -29,6 +29,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.PolicySpec;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
+import com.google.errorprone.annotations.Var;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
@@ -108,7 +109,7 @@ private void onMiss(AccessEvent event) {
     //  – Fr(f) is set to one.
     //  – Pr(f) is computed using Eq. 1 and f is enqueued accordingly.
     //  – Used is increased by Size(f).
-    Node candidate = new Node(event.key(), event.weight(), priorityOf(event, 1));
+    var candidate = new Node(event.key(), event.weight(), priorityOf(event, 1));
     data.put(candidate.key, candidate);
     priorityQueue.add(candidate);
     size += candidate.weight;
@@ -152,7 +153,7 @@ private void evict(Node candidate) {
   }
 
   private Set<Node> getVictims(long weightDifference) {
-    long weightedSize = 0L;
+    @Var long weightedSize = 0L;
     var victims = new LinkedHashSet<Node>();
     for (Node node : priorityQueue) {
       victims.add(node);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/SegmentedLruPolicy.java
Patch:
@@ -69,8 +69,8 @@ public final class SegmentedLruPolicy implements KeyOnlyPolicy {
   public SegmentedLruPolicy(Admission admission, Config config) {
     this.policyStats = new PolicyStats(admission.format(name()));
     this.admittor = admission.from(config, policyStats);
+    var settings = new SegmentedLruSettings(config);
 
-    SegmentedLruSettings settings = new SegmentedLruSettings(config);
     this.headProtected = new Node();
     this.headProbation = new Node();
     this.data = new Long2ObjectOpenHashMap<>();
@@ -80,7 +80,7 @@ public SegmentedLruPolicy(Admission admission, Config config) {
 
   /** Returns all variations of this policy based on the configuration parameters. */
   public static Set<Policy> policies(Config config) {
-    BasicSettings settings = new BasicSettings(config);
+    var settings = new BasicSettings(config);
     return settings.admission().stream().map(admission ->
       new SegmentedLruPolicy(admission, config)
     ).collect(toUnmodifiableSet());
@@ -118,7 +118,7 @@ private void onHit(Node node) {
   }
 
   private void onMiss(long key) {
-    Node node = new Node(key);
+    var node = new Node(key);
     data.put(key, node);
     policyStats.recordMiss();
     node.appendToTail(headProbation);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/SievePolicy.java
Patch:
@@ -24,6 +24,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.PolicySpec;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
+import com.google.errorprone.annotations.Var;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
@@ -98,7 +99,7 @@ private void onMiss(AccessEvent event) {
   }
 
   private void evict() {
-    var victim = (hand == null) ? tail : hand;
+    @Var var victim = (hand == null) ? tail : hand;
     while ((victim != null) && victim.visited) {
       victim.visited = false;
       victim = (victim.prev == null) ? tail : victim.prev;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/opt/UnboundedPolicy.java
Patch:
@@ -43,7 +43,7 @@ public final class UnboundedPolicy implements Policy {
   private final LongSet data;
 
   public UnboundedPolicy(Config config, Set<Characteristic> characteristics) {
-    BasicSettings settings = new BasicSettings(config);
+    var settings = new BasicSettings(config);
     int initialSize = characteristics.contains(WEIGHTED)
         ? LongOpenHashSet.DEFAULT_INITIAL_SIZE
         : Ints.saturatedCast(settings.maximumSize());

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/Cache2kPolicy.java
Patch:
@@ -48,10 +48,10 @@ public Cache2kPolicy(Config config, Set<Characteristic> characteristics) {
     logger.setLevel(Level.WARNING);
 
     policyStats = new PolicyStats(name());
+    var settings = new BasicSettings(config);
     CacheEntryEvictedListener<Long, AccessEvent> listener =
         (cache, entry) -> policyStats.recordEviction();
-    BasicSettings settings = new BasicSettings(config);
-    Cache2kBuilder<Long, AccessEvent> builder = Cache2kBuilder.of(Long.class, AccessEvent.class)
+    var builder = Cache2kBuilder.of(Long.class, AccessEvent.class)
         .addListener(listener)
         .strictEviction(true);
     if (characteristics.contains(WEIGHTED)) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/CaffeinePolicy.java
Patch:
@@ -42,7 +42,7 @@ public final class CaffeinePolicy implements Policy {
 
   public CaffeinePolicy(Config config, Set<Characteristic> characteristics) {
     policyStats = new PolicyStats(name());
-    BasicSettings settings = new BasicSettings(config);
+    var settings = new BasicSettings(config);
     Caffeine<Long, AccessEvent> builder = Caffeine.newBuilder()
         .removalListener((Long key, AccessEvent value, RemovalCause cause) ->
             policyStats.recordEviction())

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/CoherencePolicy.java
Patch:
@@ -28,6 +28,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.PolicySpec;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.CaseFormat;
+import com.google.errorprone.annotations.Var;
 import com.tangosol.net.cache.ConfigurableCacheMap.UnitCalculator;
 import com.tangosol.net.cache.LocalCache;
 import com.tangosol.util.MapEvent;
@@ -50,8 +51,8 @@ public CoherencePolicy(CoherenceSettings settings, Eviction policy) {
     policyStats = new PolicyStats(name() + " (%s)", policy);
 
     // auto scale units to integer range (from LocalScheme)
-    int factor = 1;
-    long maximum = settings.maximumSize();
+    @Var int factor = 1;
+    @Var long maximum = settings.maximumSize();
     while (maximum >= Integer.MAX_VALUE) {
       maximum /= 1024;
       factor *= 1024;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/GuavaPolicy.java
Patch:
@@ -40,7 +40,7 @@ public final class GuavaPolicy implements Policy {
 
   public GuavaPolicy(Config config, Set<Characteristic> characteristics) {
     policyStats = new PolicyStats(name());
-    BasicSettings settings = new BasicSettings(config);
+    var settings = new BasicSettings(config);
     CacheBuilder<Long, AccessEvent> builder = CacheBuilder.newBuilder()
         .removalListener(notification -> policyStats.recordEviction());
     if (characteristics.contains(WEIGHTED)) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/HazelcastPolicy.java
Patch:
@@ -65,7 +65,7 @@ public HazelcastPolicy(HazelcastSettings settings, EvictionPolicy policy) {
             .setEvictionPolicy(policy)
             .setSize(maximumSize));
     cache = new DefaultNearCache<>("simulation", config, DummySerializationService.INSTANCE,
-        /* TaskScheduler */ null, getClass().getClassLoader(), /* HazelcastProperties */ null);
+        /* scheduler= */ null, getClass().getClassLoader(), /* properties= */ null);
     cache.initialize();
   }
 
@@ -84,7 +84,7 @@ public void record(long key) {
       if (cache.size() == maximumSize) {
         policyStats.recordEviction();
       }
-      cache.put(key, /* keyData */ null, Boolean.TRUE, /* valueDate */ null);
+      cache.put(key, /* keyData= */ null, Boolean.TRUE, /* valueDate= */ null);
       policyStats.recordMiss();
     } else {
       policyStats.recordHit();
@@ -143,7 +143,7 @@ enum DummySerializationService implements SerializationService {
       return (T) data;
     }
     @Override public ManagedContext getManagedContext() {
-      return null;
+      throw new UnsupportedOperationException();
     }
     @Override public <B extends Data> B trimSchema(Data data) {
       return (B) data;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/HillClimber.java
Patch:
@@ -104,8 +104,8 @@ public String toString() {
         case HOLD: return "0";
         case INCREASE_WINDOW: return "+" + amount;
         case DECREASE_WINDOW: return "-" + amount;
-        default: throw new IllegalStateException();
       }
+      throw new IllegalStateException();
     }
   }
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/gradient/Adam.java
Patch:
@@ -39,7 +39,7 @@ public final class Adam extends AbstractClimber {
   private double velocity;
 
   public Adam(Config config) {
-    AdamSettings settings = new AdamSettings(config);
+    var settings = new AdamSettings(config);
     int maximumSize = Math.toIntExact(settings.maximumSize());
     sampleSize = (int) (settings.percentSample() * maximumSize);
     stepSize = (int) (settings.percentPivot() * maximumSize);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/gradient/AmsGrad.java
Patch:
@@ -40,7 +40,7 @@ public final class AmsGrad extends AbstractClimber {
   private double maxVelocity;
 
   public AmsGrad(Config config) {
-    AmsGradSettings settings = new AmsGradSettings(config);
+    var settings = new AmsGradSettings(config);
     int maximumSize = Math.toIntExact(settings.maximumSize());
     sampleSize = (int) (settings.percentSample() * maximumSize);
     stepSize = (int) (settings.percentPivot() * maximumSize);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/gradient/Nadam.java
Patch:
@@ -40,7 +40,7 @@ public final class Nadam extends AbstractClimber {
   private double velocity;
 
   public Nadam(Config config) {
-    NadamSettings settings = new NadamSettings(config);
+    var settings = new NadamSettings(config);
     int maximumSize = Math.toIntExact(settings.maximumSize());
     sampleSize = (int) (settings.percentSample() * maximumSize);
     stepSize = (int) (settings.percentPivot() * maximumSize);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/gradient/Stochastic.java
Patch:
@@ -51,7 +51,7 @@ public final class Stochastic extends AbstractClimber {
   private double velocity;
 
   public Stochastic(Config config) {
-    StochasticSettings settings = new StochasticSettings(config);
+    var settings = new StochasticSettings(config);
     int maximumSize = Math.toIntExact(settings.maximumSize());
     sampleSize = (int) (settings.percentSample() * maximumSize);
     stepSize = (int) (settings.percentPivot() * maximumSize);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/hill/SimpleClimber.java
Patch:
@@ -36,7 +36,7 @@ public final class SimpleClimber extends AbstractClimber {
   private double stepSize;
 
   public SimpleClimber(Config config) {
-    SimpleClimberSettings settings = new SimpleClimberSettings(config);
+    var settings = new SimpleClimberSettings(config);
     int maximumSize = Math.toIntExact(settings.maximumSize());
     this.initialSampleSize = (int) (settings.percentSample() * maximumSize);
     this.initialStepSize = settings.percentPivot() * maximumSize;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/hill/SimulatedAnnealingClimber.java
Patch:
@@ -39,7 +39,7 @@ public final class SimulatedAnnealingClimber extends AbstractClimber {
   private int stepSize;
 
   public SimulatedAnnealingClimber(Config config) {
-    SimulatedAnnealingSettings settings = new SimulatedAnnealingSettings(config);
+    var settings = new SimulatedAnnealingSettings(config);
     int maximumSize = Math.toIntExact(settings.maximumSize());
     this.initialStepSize = (int) (settings.percentPivot() * maximumSize);
     this.sampleSize = (int) (settings.percentSample() * maximumSize);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/inference/IndicatorClimber.java
Patch:
@@ -32,7 +32,7 @@ public final class IndicatorClimber implements HillClimber {
   private double prevPercent;
 
   public IndicatorClimber(Config config) {
-    HillClimberWindowTinyLfuSettings settings = new HillClimberWindowTinyLfuSettings(config);
+    var settings = new HillClimberWindowTinyLfuSettings(config);
     this.cacheSize = Math.toIntExact(settings.maximumSize());
     this.prevPercent = 1 - settings.percentMain().get(0);
     this.indicator = new Indicator(config);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/tinycache/TinyCachePolicy.java
Patch:
@@ -31,8 +31,8 @@ public final class TinyCachePolicy implements KeyOnlyPolicy {
   private final TinyCache tinyCache;
 
   public TinyCachePolicy(Config config) {
+    var settings = new BasicSettings(config);
     this.policyStats = new PolicyStats(name());
-    BasicSettings settings = new BasicSettings(config);
     int maximumSize = Math.toIntExact(settings.maximumSize());
     tinyCache = new TinyCache((int) Math.ceil(maximumSize / 64.0),
         64, settings.randomSeed());

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/tinycache/TinyCacheWithGhostCachePolicy.java
Patch:
@@ -31,8 +31,8 @@ public final class TinyCacheWithGhostCachePolicy implements KeyOnlyPolicy {
   private final PolicyStats policyStats;
 
   public TinyCacheWithGhostCachePolicy(Config config) {
+    var settings = new BasicSettings(config);
     this.policyStats = new PolicyStats(name());
-    BasicSettings settings = new BasicSettings(config);
     int maximumSize = Math.toIntExact(settings.maximumSize());
     tinyCache = new TinyCacheWithGhostCache((int) Math.ceil(maximumSize / 64.0),
         64, settings.randomSeed());

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/TwoQueuePolicy.java
Patch:
@@ -20,6 +20,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.PolicySpec;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
+import com.google.errorprone.annotations.Var;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
@@ -58,7 +59,7 @@ public final class TwoQueuePolicy implements KeyOnlyPolicy {
   final Node headMain;
 
   public TwoQueuePolicy(Config config) {
-    TwoQueueSettings settings = new TwoQueueSettings(config);
+    var settings = new TwoQueueSettings(config);
 
     this.headIn = new Node();
     this.headOut = new Node();
@@ -87,7 +88,7 @@ public void record(long key) {
     //   end if
 
     policyStats.recordOperation();
-    Node node = data.get(key);
+    @Var Node node = data.get(key);
     if (node != null) {
       switch (node.type) {
         case MAIN:

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/Metrics.java
Patch:
@@ -115,7 +115,7 @@ public int compare(PolicyStats p1, PolicyStats p2) {
         Object value2 = ((Supplier<?>) metric2.value()).get();
         if (value1 instanceof Comparable<?>) {
           @SuppressWarnings("unchecked")
-          Comparable<Object> comparator = (Comparable<Object>) value1;
+          var comparator = (Comparable<Object>) value1;
           return comparator.compareTo(value2);
         }
         return objectFormatter().apply(value1)

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/TextReporter.java
Patch:
@@ -63,7 +63,7 @@ public void print(List<PolicyStats> results) {
       return;
     }
     try {
-      Path path = Path.of(output);
+      var path = Path.of(output);
       Files.createDirectories(path.getParent());
       Files.write(path, report.getBytes(UTF_8));
     } catch (IOException e) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/csv/CsvReporter.java
Patch:
@@ -45,8 +45,8 @@ public CsvReporter(Config config, Set<Characteristic> characteristics) {
 
   @Override
   protected String assemble(Set<String> headers, List<PolicyStats> results) {
-    StringWriter output = new StringWriter();
-    CsvWriter writer = new CsvWriter(output, new CsvWriterSettings());
+    var output = new StringWriter();
+    var writer = new CsvWriter(output, new CsvWriterSettings());
     writer.writeHeaders(headers);
     for (PolicyStats policyStats : results) {
       String[] data = headers.stream()

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheValidationListener.java
Patch:
@@ -143,7 +143,7 @@ public void afterInvocation(IInvokedMethod method, ITestResult testResult) {
   private void validate(ITestResult testResult) {
     CacheContext context = Arrays.stream(testResult.getParameters())
         .filter(CacheContext.class::isInstance)
-        .findFirst().map(param -> (CacheContext) param)
+        .findFirst().map(CacheContext.class::cast)
         .orElse(null);
     if (context != null) {
       awaitExecutor(context);

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/MemoryBenchmark.java
Patch:
@@ -40,7 +40,7 @@
  * padding may or may not have a visible effect.
  * <p>
  * This benchmark requires a JavaAgent to evaluate the object sizes and can be executed using
- * <tt>gradle -q memoryOverhead</tt>.
+ * <code>gradle -q memoryOverhead</code>.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AbstractLinkedDeque.java
Patch:
@@ -416,7 +416,7 @@ public E next() {
       return previous;
     }
 
-    /** Retrieves the next element to traverse to or <tt>null</tt> if there are no more elements. */
+    /** Retrieves the next element to traverse to or {@code null} if there are no more elements. */
     abstract @Nullable E computeNext();
 
     @Override

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1838,8 +1838,8 @@ void drainWriteBuffer() {
   }
 
   /**
-   * Atomically transitions the node to the <tt>dead</tt> state and decrements the
-   * <tt>weightedSize</tt>.
+   * Atomically transitions the node to the <code>dead</code> state and decrements the
+   * <code>weightedSize</code>.
    *
    * @param node the entry in the page replacement policy
    */
@@ -2827,7 +2827,7 @@ public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
    * remappingFunction to be statistics aware.
    *
    * @param key key with which the specified value is to be associated
-   * @param keyRef the key to associate with or a lookup only key if not <tt>computeIfAbsent</tt>
+   * @param keyRef the key to associate with or a lookup only key if not {@code computeIfAbsent}
    * @param remappingFunction the function to compute a value
    * @param expiry the calculator for the expiration time
    * @param now the current time, according to the ticker

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/FrequencySketch.java
Patch:
@@ -79,7 +79,7 @@ final class FrequencySketch<E> {
   public FrequencySketch() {}
 
   /**
-   * Initializes and increases the capacity of this <tt>FrequencySketch</tt> instance, if necessary,
+   * Initializes and increases the capacity of this {@code FrequencySketch} instance, if necessary,
    * to ensure that it can accurately estimate the popularity of elements given the maximum size of
    * the cache. This operation forgets all previous counts when resizing.
    *

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/MpscGrowableArrayQueue.java
Patch:
@@ -27,7 +27,7 @@
  * elements are not copied on resize, instead a link to the new buffer is stored in the old buffer
  * for the consumer to follow.<br>
  * <p>
- * This is a shaded copy of <tt>MpscGrowableArrayQueue</tt> provided by
+ * This is a shaded copy of <code>MpscGrowableArrayQueue</code> provided by
  * <a href="https://github.com/JCTools/JCTools">JCTools</a> from version 2.0.
  *
  * @author nitsanw@yahoo.com (Nitsan Wakart)

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Node.java
Patch:
@@ -102,11 +102,11 @@ public void setPolicyWeight(@NonNegative int weight) {}
   @GuardedBy("this")
   public abstract boolean isDead();
 
-  /** Sets the node to the <tt>retired</tt> state. */
+  /** Sets the node to the <code>retired</code> state. */
   @GuardedBy("this")
   public abstract void retire();
 
-  /** Sets the node to the <tt>dead</tt> state. */
+  /** Sets the node to the <code>dead</code> state. */
   @GuardedBy("this")
   public abstract void die();
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/GuardedStatsCounter.java
Patch:
@@ -24,7 +24,7 @@
 
 /**
  * A {@link StatsCounter} implementation that suppresses and logs any exception thrown by the
- * delegate <tt>statsCounter</tt>.
+ * delegate <code>statsCounter</code>.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/ConcurrentTestHarness.java
Patch:
@@ -37,7 +37,7 @@
  * thread. This harness can be used for performance tests, investigations of
  * lock contention, etc.
  * <p/>
- * This code was adapted from <tt>Java Concurrency in Practice</tt>, using an
+ * This code was adapted from <code>Java Concurrency in Practice</code>, using an
  * example of a {@link CountDownLatch} for starting and stopping threads in
  * timing tests.
  *

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/copy/Copier.java
Patch:
@@ -16,7 +16,7 @@
 package com.github.benmanes.caffeine.jcache.copy;
 
 /**
- * An object is copied when the cache is configured with <tt>storeByValue</tt> to guard against
+ * An object is copied when the cache is configured with <code>storeByValue</code> to guard against
  * mutations of the key or value.
  *
  * @author ben.manes@gmail.com (Ben Manes)

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/EventDispatcher.java
Patch:
@@ -55,7 +55,7 @@
  *       listeners to be delayed until the executor is able to process the work.
  * </ul>
  * <p>
- * Some listeners may be configured as <tt>synchronous</tt>, meaning that the publishing thread
+ * Some listeners may be configured as <code>synchronous</code>, meaning that the publishing thread
  * should wait until the listener has processed the event. The calling thread should publish within
  * an atomic block that mutates the entry, and complete the operation by calling
  * {@link #awaitSynchronous()} or {@link #ignoreSynchronous()}.

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/JCacheAccessExpiryTest.java
Patch:
@@ -34,7 +34,7 @@
 import com.google.common.collect.Maps;
 
 /**
- * The test cases that ensure the <tt>expiry for access</tt> time is updated for the accessed
+ * The test cases that ensure the <code>expiry for access</code> time is updated for the accessed
  * entries. The TCK asserts that the {@link ExpiryPolicy#getExpiryForAccess()} is only called for
  * the following methods, but does not check that the expiration time was updated.
  * <ul>

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/JCacheCreationExpiryTest.java
Patch:
@@ -31,9 +31,9 @@
 import com.google.common.util.concurrent.MoreExecutors;
 
 /**
- * The test cases that ensure the <tt>expiry for creation</tt> time is set for the created entries.
- * The TCK asserts that the {@link ExpiryPolicy#getExpiryForCreation()} is only called for
- * the following methods, but does not check that the expiration time was updated.
+ * The test cases that ensure the <code>expiry for creation</code> time is set for the created
+ * entries. The TCK asserts that the {@link ExpiryPolicy#getExpiryForCreation()} is only called
+ * for the following methods, but does not check that the expiration time was updated.
  * <ul>
  *   <li>get (loading)
  *   <li>getAndPut

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/JCacheExpiryAndMaximumSizeTest.java
Patch:
@@ -39,8 +39,8 @@
 import com.google.common.util.concurrent.MoreExecutors;
 
 /**
- * The test cases that ensures the <tt>variable expiry</tt> policy and <tt>maximum size</tt>
- * settings are set simultaneously.
+ * The test cases that ensures the variable expiry policy and maximum size settings are set
+ * simultaneously.
  *
  * @author github.com/kdombeck (Ken Dombeck)
  */

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/JCacheExpiryTest.java
Patch:
@@ -33,7 +33,7 @@
 import com.github.benmanes.caffeine.jcache.configuration.CaffeineConfiguration;
 
 /**
- * The test cases that ensure the <tt>variable expiry</tt> policy is configured.
+ * The test cases that ensure the variable expiry policy is configured.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/JCacheUpdateExpiryTest.java
Patch:
@@ -30,9 +30,9 @@
 import com.github.benmanes.caffeine.jcache.configuration.CaffeineConfiguration;
 
 /**
- * The test cases that ensure the <tt>expiry for update</tt> time is set for the updated entries.
- * The TCK asserts that the {@link ExpiryPolicy#getExpiryForUpdate()} is only called for the
- * following methods, but does not check that the expiration time was set.
+ * The test cases that ensure the expiry for update time is set for the updated entries. The TCK
+ * asserts that the {@link ExpiryPolicy#getExpiryForUpdate()} is only called for the following
+ * methods, but does not check that the expiration time was set.
  * <ul>
  *   <li>getAndPut
  *   <li>getAndReplace

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/size/JCacheMaximumSizeTest.java
Patch:
@@ -30,7 +30,7 @@
 import com.google.common.util.concurrent.MoreExecutors;
 
 /**
- * The test cases that ensure the <tt>maximum size</tt> setting is honored by the cache and removal
+ * The test cases that ensure the maximum size< setting is honored by the cache and removal
  * notifications are published.
  *
  * @author ben.manes@gmail.com (Ben Manes)

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/size/JCacheMaximumWeightTest.java
Patch:
@@ -32,8 +32,8 @@
 import com.google.common.util.concurrent.MoreExecutors;
 
 /**
- * The test cases that ensure the <tt>maximum weight</tt> setting is honored by the cache and
- * removal notifications are published.
+ * The test cases that ensure the maximum weight setting is honored by the cache and removal
+ * notifications are published.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/Simulate.java
Patch:
@@ -44,7 +44,7 @@
  * A command that runs multiple simulations, writes the result to a csv file, and renders a chart.
  * An underscore may be used as a numeric separator and the default configuration may be overridden
  * by using system properties.
- * <p>
+ *
  * <pre>{@code
  *   ./gradlew simulator:simulate -q \
  *     -Dcaffeine.simulator.files.paths.0="lirs:gli.trace.gz" \

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/Simulator.java
Patch:
@@ -41,7 +41,7 @@
 
 /**
  * A simulator that broadcasts the recorded cache events to each policy and generates an aggregated
- * report. See <tt>reference.conf</tt> for details on the configuration.
+ * report. See <code>reference.conf</code> for details on the configuration.
  * <p>
  * The simulator reports the hit rate of each of the policy being evaluated. A miss may occur
  * due to,

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/CountMin4.java
Patch:
@@ -56,8 +56,8 @@ protected CountMin4(Config config) {
   }
 
   /**
-   * Increases the capacity of this <tt>FrequencySketch</tt> instance, if necessary, to ensure that
-   * it can accurately estimate the popularity of elements given the maximum size of the cache. This
+   * Increases the capacity of this {@code CountMin4} instance, if necessary, to ensure that it can
+   * accurately estimate the popularity of elements given the maximum size of the cache. This
    * operation forgets all previous counts when resizing.
    *
    * @param maximumSize the maximum size of the cache

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin64/CountMin64.java
Patch:
@@ -20,8 +20,8 @@
 /**
  * Count-Min Sketch data structure with optional conservative addition.
  * <p>
- * This is a derived from <tt>CountMinSketch</tt> and <tt>ConservativeAddSketch</tt> provided by
- * <a href="https://github.com/addthis/stream-lib">StreamLib</a>.
+ * This is a derived from <code>CountMinSketch</code> and <code>ConservativeAddSketch</code>
+ * provided by <a href="https://github.com/addthis/stream-lib">StreamLib</a>.
  */
 final class CountMin64 {
   static final long PRIME_MODULUS = (1L << 31) - 1;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/membership/bloom/BloomFilter.java
Patch:
@@ -60,7 +60,7 @@ public BloomFilter(Config config) {
   }
 
   /**
-   * Initializes and increases the capacity of this <tt>BloomFilter</tt> instance, if necessary,
+   * Initializes and increases the capacity of this {@code BloomFilter} instance, if necessary,
    * to ensure that it can accurately estimate the membership of elements given the expected
    * number of insertions. This operation forgets all previous memberships when resizing.
    *

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/Rewriter.java
Patch:
@@ -38,7 +38,7 @@
  * A simple utility to rewrite traces into the format used by other simulators. This lets us run
  * multiple simulators in parallel for a quick-and-dirty analysis, rather than port their code into
  * Java.
- * <p>
+ *
  * <pre>{@code
  *   ./gradlew :simulator:rewrite -q \
  *      --inputFormat=? \

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/wikipedia/WikipediaTraceReader.java
Patch:
@@ -29,7 +29,7 @@
 
 /**
  * A reader for the trace files provided by the <a href="http://www.wikibench.eu">wikibench</a>
- * project. The requests are sanitized and filtered using the <tt>TraceBench</tt> optimizations.
+ * project. The requests are sanitized and filtered using the <code>TraceBench</code> optimizations.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/gradient/Nadam.java
Patch:
@@ -25,7 +25,7 @@
  * Nesterov-accelerated Adaptive Moment Estimation (Nadam) optimizer. Nadam modifies the Adam
  * optimizer to replace normal momentum with Nesterov's accelerated gradient. The authors describe
  * it in <a href="https://openreview.net/pdf?id=OM0jvwB8jIp57ZJjtNEZ">Incorporating Nesterov
- * Momentum into Adam<a>.
+ * Momentum into Adam</a>.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/gradient/Stochastic.java
Patch:
@@ -26,7 +26,7 @@
 /**
  * Stochastic gradient descent (SGD) optimizer.
  * <p>
- * <tt>w(t+1) = w(t) - alpha * dL/dw(t)</tt> where,
+ * <code>w(t+1) = w(t) - alpha * dL/dw(t)</code> where,
  * <ul>
  *   <li><b>w(t)</b> is the current window size
  *   <li><b>alpha</b> is the learning rate (step size)

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalCache.java
Patch:
@@ -165,9 +165,9 @@ default void notifyOnReplace(K key, V oldValue, V newValue) {
       long startTime = statsTicker().read();
       try {
         value = mappingFunction.apply(key);
-      } catch (RuntimeException | Error e) {
+      } catch (Throwable t) {
         statsCounter().recordLoadFailure(statsTicker().read() - startTime);
-        throw e;
+        throw t;
       }
       long loadTime = statsTicker().read() - startTime;
       if (recordLoad) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsMapTest.java
Patch:
@@ -2752,7 +2752,7 @@ public void entrySet_removeAll_bySet(Map<Int, Int> map, CacheContext context) {
   @CheckNoStats
   @Test(dataProvider = "caches")
   public void entrySet_remove_null(Map<Int, Int> map, CacheContext context) {
-    assertThat(map.values().remove(null)).isFalse();
+    assertThat(map.entrySet().remove(null)).isFalse();
     assertThat(map).isEqualTo(context.original());
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CaffeineSpecTest.java
Patch:
@@ -118,7 +118,7 @@ private void runScenarios(CacheContext context, Epoch epoch) {
   }
 
   private void runTest(CacheContext context, Epoch epoch, Function<Duration, String> formatter) {
-    CaffeineSpec spec = toSpec(context, epoch, formatter);
+    CaffeineSpec spec = toSpec(context, formatter);
     Caffeine<Object, Object> builder = Caffeine.from(spec);
 
     checkInitialCapacity(spec, context, builder);
@@ -134,8 +134,7 @@ private void runTest(CacheContext context, Epoch epoch, Function<Duration, Strin
     assertThat(spec).isEqualTo(CaffeineSpec.parse(spec.toParsableString().replaceAll(",", ",,")));
   }
 
-  static CaffeineSpec toSpec(CacheContext context,
-      Epoch epoch, Function<Duration, String> formatter) {
+  static CaffeineSpec toSpec(CacheContext context, Function<Duration, String> formatter) {
     var options = new ArrayList<String>();
     if (context.initialCapacity() != InitialCapacity.DEFAULT) {
       options.add("initialCapacity=" + context.initialCapacity().size());

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CaffeineTest.java
Patch:
@@ -205,13 +205,13 @@ public void loading_nullLoader() {
   @Test
   public void async_weakValues() {
     var builder = Caffeine.newBuilder().weakValues();
-    assertThrows(IllegalStateException.class, () -> builder.buildAsync(loader));
+    assertThrows(IllegalStateException.class, () -> builder.buildAsync());
   }
 
   @Test
   public void async_softValues() {
     var builder = Caffeine.newBuilder().softValues();
-    assertThrows(IllegalStateException.class, () -> builder.buildAsync(loader));
+    assertThrows(IllegalStateException.class, () -> builder.buildAsync());
   }
 
   @Test

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpirationTest.java
Patch:
@@ -1557,7 +1557,7 @@ public void entrySet_toArray(Map<Int, Int> map, CacheContext context) {
       expireAfterWrite = {Expire.DISABLED, Expire.ONE_MINUTE}, expiryTime = Expire.ONE_MINUTE)
   public void entrySet_iterator(Map<Int, Int> map, CacheContext context) {
     context.ticker().advance(Duration.ofMinutes(10));
-    assertThat(map.keySet().iterator().hasNext()).isFalse();
+    assertThat(map.entrySet().iterator().hasNext()).isFalse();
     assertThat(map).isExhaustivelyEmpty();
     assertThat(context).notifications().withCause(EXPIRED)
         .contains(context.original()).exclusively();
@@ -1630,10 +1630,10 @@ public void entrySet_hashCode(Map<Int, Int> map, CacheContext context) {
     map.putAll(context.absent());
 
     context.ticker().advance(Duration.ofSeconds(45));
-    assertThat(map.hashCode()).isEqualTo(context.absent().hashCode());
+    assertThat(map.entrySet().hashCode()).isEqualTo(context.absent().entrySet().hashCode());
 
     context.cleanUp();
-    assertThat(map.hashCode()).isEqualTo(context.absent().hashCode());
+    assertThat(map.entrySet().hashCode()).isEqualTo(context.absent().entrySet().hashCode());
   }
 
   @Test(dataProvider = "caches")

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LoadingCacheTest.java
Patch:
@@ -1110,7 +1110,7 @@ public void refreshAll_nullFuture_reload(CacheContext context) {
   /* --------------- CacheLoader --------------- */
 
   @Test
-  public void loadAll() throws Exception {
+  public void loadAll() {
     CacheLoader<Object, ?> loader = key -> key;
     assertThrows(UnsupportedOperationException.class, () -> loader.loadAll(Set.of()));
   }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/QueueSanityTest.java
Patch:
@@ -87,7 +87,6 @@ public void sanity() {
     } else {
       // expect sum of elements is (size - 1) * size / 2 = 0 + 1 + .... + (size - 1)
       int sum = (size - 1) * size / 2;
-      i = 0;
       Integer e;
       while ((e = queue.poll()) != null) {
         assertEquals(--size, queue.size());

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/RefreshAfterWriteTest.java
Patch:
@@ -964,9 +964,10 @@ public void setRefreshAfter_excessive(Cache<Int, Int> cache,
   }
 
   @Test(dataProvider = "caches")
+  @SuppressWarnings("PreferJavaTimeOverload")
   @CacheSpec(refreshAfterWrite = Expire.ONE_MINUTE)
   public void setRefreshesAfter(CacheContext context, FixedRefresh<Int, Int> refreshAfterWrite) {
-    refreshAfterWrite.setRefreshesAfter(Duration.ofMinutes(2));
+    refreshAfterWrite.setRefreshesAfter(2, TimeUnit.MINUTES);
     assertThat(refreshAfterWrite.getRefreshesAfter().toMinutes()).isEqualTo(2);
     assertThat(refreshAfterWrite.getRefreshesAfter(TimeUnit.MINUTES)).isEqualTo(2);
   }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/TimerWheelTest.java
Patch:
@@ -82,7 +82,7 @@ public void beforeMethod() throws Exception {
   }
 
   @AfterMethod
-  public void afterMethod(ITestResult testResult) throws Exception {
+  public void afterMethod(ITestResult testResult) {
     if (!testResult.isSuccess()) {
       printTimerWheel();
     }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/BufferTest.java
Patch:
@@ -42,7 +42,7 @@ public Iterator<Object[]> buffers() {
 
   @Test(dataProvider = "buffers")
   @SuppressWarnings("ThreadPriorityCheck")
-  public void record(ReadBuffer<Boolean> buffer) {
+  public void offer(ReadBuffer<Boolean> buffer) {
     ConcurrentTestHarness.timeTasks(100, () -> {
       for (int i = 0; i < 1000; i++) {
         int added = buffer.offer(Boolean.TRUE);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContextSubject.java
Patch:
@@ -378,8 +378,8 @@ public Exclusive contains(Entry<?, ?>... entries) {
           var notifications = Arrays.stream(entries)
               .map(entry -> new RemovalNotification<>(entry.getKey(), entry.getValue(), cause))
               .collect(toImmutableListMultimap(RemovalNotification::getCause, identity()));
-          var actual = Multimaps.index(listener.removed(), RemovalNotification::getCause);
-          check(type).that(actual).containsAtLeastEntriesIn(notifications);
+          var removed = Multimaps.index(listener.removed(), RemovalNotification::getCause);
+          check(type).that(removed).containsAtLeastEntriesIn(notifications);
         });
         return new Exclusive(entries.length);
       }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java
Patch:
@@ -183,7 +183,7 @@ public V get(K key, Function<? super K, ? extends V> mappingFunction) {
         }
         throw (RuntimeException) e.getCause();
       } catch (ExecutionException e) {
-        throw new CompletionException(e);
+        throw new CompletionException(e.getCause());
       } catch (ExecutionError e) {
         throw (Error) e.getCause();
       }

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/Collection8Test.java
Patch:
@@ -178,7 +178,7 @@ else if (c instanceof Set<?>) {
         }
     }
 
-    public void testNullPointerExceptions() throws InterruptedException {
+    public void testNullPointerExceptions() {
         Collection c = impl.emptyCollection();
         Collection nullCollection = null;
         assertThrows(

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/ConcurrentHashMap8Test.java
Patch:
@@ -33,7 +33,7 @@
 @SuppressWarnings({"IdentityConversion", "PreferredInterfaceType", "rawtypes", "try", "unchecked"})
 public class ConcurrentHashMap8Test extends JSR166TestCase {
     public static void main(String[] args) {
-        main(suite(), args);
+        main(suite());
     }
     public static Test suite() {
         return new TestSuite(ConcurrentHashMap8Test.class);

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/ConcurrentHashMapTest.java
Patch:
@@ -28,7 +28,7 @@
   "rawtypes", "ReturnValueIgnored", "unchecked", "UnnecessaryParentheses"})
 public class ConcurrentHashMapTest extends JSR166TestCase {
     public static void main(String[] args) {
-        main(suite(), args);
+        main(suite());
     }
     public static Test suite() {
         class Implementation implements MapImplementation {

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/JSR166TestCase.java
Patch:
@@ -382,7 +382,7 @@ protected void runTestProfiled() throws Throwable {
      * Runs all JSR166 unit tests using junit.textui.TestRunner.
      */
     public static void main(String[] args) {
-        main(suite(), args);
+        main(suite());
     }
 
     static class PithyResultPrinter extends junit.textui.ResultPrinter {
@@ -420,7 +420,7 @@ static junit.textui.TestRunner newPithyTestRunner() {
      * Runs all unit tests in the given test suite.
      * Actual behavior influenced by jsr166.* system properties.
      */
-    static void main(Test suite, String[] args) {
+    static void main(Test suite) {
 //        if (useSecurityManager) {
 //            System.err.println("Setting a permissive security manager");
 //            Policy.setPolicy(permissivePolicy());

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/KeySetTest.java
Patch:
@@ -18,7 +18,7 @@
 @SuppressWarnings("rawtypes")
 public class KeySetTest extends JSR166TestCase {
     public static void main(String[] args) {
-        main(suite(), args);
+        main(suite());
     }
 
     public static Test suite() {

File: guava/src/test/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaTest.java
Patch:
@@ -96,7 +96,7 @@ public void testReload_throwable() {
     cache.refresh(1);
   }
 
-  public void testCacheLoader_null() throws Exception {
+  public void testCacheLoader_null() {
     assertThrows(NullPointerException.class, () -> CaffeinatedGuava.caffeinate(null));
 
     var caffeine1 = CaffeinatedGuava.caffeinate(CacheLoader.from(key -> null));
@@ -121,13 +121,13 @@ public ListenableFuture<Integer> reload(Integer key, Integer oldValue) {
     assertThat(e2).hasCauseThat().isInstanceOf(InvalidCacheLoadException.class);
   }
 
-  public void testCacheLoader_exception() throws Exception {
+  public void testCacheLoader_exception() {
     runCacheLoaderExceptionTest(new InterruptedException());
     runCacheLoaderExceptionTest(new RuntimeException());
     runCacheLoaderExceptionTest(new Exception());
   }
 
-  public void runCacheLoaderExceptionTest(Exception error) throws Exception {
+  public void runCacheLoaderExceptionTest(Exception error) {
     var guava = new CacheLoader<Integer, Integer>() {
       @Override public Integer load(Integer key) throws Exception {
         throw error;

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheBuilderTest.java
Patch:
@@ -389,7 +389,7 @@ public void testRemovalListener_setTwice() {
         Caffeine.newBuilder().removalListener(testListener);
     try {
       // even to the same instance is not allowed
-      builder = builder.removalListener(testListener);
+      builder.removalListener(testListener);
       fail();
     } catch (IllegalStateException expected) {}
   }
@@ -629,7 +629,7 @@ public void testRemovalNotification_get_basher() throws InterruptedException {
   }
 
   @GwtIncompatible("NullPointerTester")
-  public void testNullParameters() throws Exception {
+  public void testNullParameters() {
     NullPointerTester tester = new NullPointerTester();
     Caffeine<Object, Object> builder = Caffeine.newBuilder();
     tester.testAllPublicInstanceMethods(builder);

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheEvictionTest.java
Patch:
@@ -228,7 +228,7 @@ public void testEviction_overflow() {
     assertEquals(1, removalListener.getCount());
   }
 
-  // FIXME(ben): Caffeine uses W-TinyLfu, not Lru
+  // Caffeine uses W-TinyLfu, not Lru
   public void disabled_testEviction_lru() {
     // test lru within a single segment
     IdentityLoader<Integer> loader = identityLoader();
@@ -261,7 +261,7 @@ public void disabled_testEviction_lru() {
     assertThat(keySet).containsExactly(2, 10, 11, 12, 6, 7, 8, 13, 14, 15);
   }
 
-  // FIXME(ben): Caffeine uses W-TinyLfu, not Lru
+  // Caffeine uses W-TinyLfu, not Lru
   public void disabled_testEviction_weightedLru() {
     // test weighted lru within a single segment
     IdentityLoader<Integer> loader = identityLoader();

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/LocalLoadingCacheTest.java
Patch:
@@ -69,7 +69,7 @@ public Object load(Object from) {
 
   // null parameters test
 
-  public void testNullParameters() throws Exception {
+  public void testNullParameters() {
     NullPointerTester tester = new NullPointerTester();
     CacheLoader<Object, Object> loader = identityLoader();
     tester.testAllPublicInstanceMethods(makeCache(createCacheBuilder(), loader));

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/JCacheProfiler.java
Patch:
@@ -86,9 +86,9 @@ public void start() {
   private ScheduledFuture<?> scheduleStatusTask() {
     var stopwatch = Stopwatch.createStarted();
     return Executors.newSingleThreadScheduledExecutor().scheduleWithFixedDelay(() -> {
-      long count = this.count.longValue();
-      long rate = count / stopwatch.elapsed(TimeUnit.SECONDS);
-      System.out.printf(US, "%s - %,d [%,d / sec]%n", stopwatch, count, rate);
+      long iterations = count.longValue();
+      long rate = iterations / stopwatch.elapsed(TimeUnit.SECONDS);
+      System.out.printf(US, "%s - %,d [%,d / sec]%n", stopwatch, iterations, rate);
     }, 5, 5, TimeUnit.SECONDS);
   }
 

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/OSGiTest.java
Patch:
@@ -67,11 +67,10 @@ public Option[] config() {
 
   @Test
   public void sanity() {
-    var cachingProvider = Caching.getCachingProvider(
+    var provider = Caching.getCachingProvider(
         "com.github.benmanes.caffeine.jcache.spi.CaffeineCachingProvider",
         getClass().getClassLoader());
-    var cache = cachingProvider.getCacheManager()
-        .getCache("osgi-cache", String.class, Integer.class);
+    var cache = provider.getCacheManager().getCache("osgi-cache", String.class, Integer.class);
     assertNull(cache.get("a"));
   }
 

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurationTest.java
Patch:
@@ -65,7 +65,7 @@ public void setConfigSource_supplier() {
 
   @Test
   public void setConfigSource_function() {
-    TypesafeConfigurator.setConfigSource((uri, classloader) -> null);
+    TypesafeConfigurator.setConfigSource((uri, loader) -> null);
     assertThat(configSource()).isNotSameInstanceAs(defaultConfigSource);
 
     assertThrows(NullPointerException.class, () ->

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -860,7 +860,7 @@ public Caffeine<K, V> ticker(Ticker ticker) {
 
   Ticker getTicker() {
     boolean useTicker = expiresVariable() || expiresAfterAccess()
-        || expiresAfterWrite() || refreshAfterWrite() || isRecordingStats();
+        || expiresAfterWrite() || refreshAfterWrite();
     return useTicker
         ? (ticker == null) ? Ticker.systemTicker() : ticker
         : Ticker.disabledTicker();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ReserializableSubject.java
Patch:
@@ -253,7 +253,6 @@ private void checkUnboundedAsyncLocalLoadingCache(
 
   private void checkUnboundedLocalCache(
       UnboundedLocalCache<?, ?> original, UnboundedLocalCache<?, ?> copy) {
-    check("ticker").that(copy.ticker).isEqualTo(original.ticker);
     check("isRecordingStats").that(copy.isRecordingStats).isEqualTo(original.isRecordingStats);
 
     if (original.removalListener == null) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -2208,7 +2208,7 @@ public boolean containsValue(Object value) {
   }
 
   @Override
-  public @Nullable V getIfPresentQuietly(K key) {
+  public @Nullable V getIfPresentQuietly(Object key) {
     V value;
     Node<K, V> node = data.get(nodeFactory.newLookupKey(key));
     if ((node == null) || ((value = node.getValue()) == null)

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalCache.java
Patch:
@@ -82,7 +82,7 @@ interface LocalCache<K, V> extends ConcurrentMap<K, V> {
    * the statistics nor the eviction policy.
    */
   @Nullable
-  V getIfPresentQuietly(K key);
+  V getIfPresentQuietly(Object key);
 
   /** See {@link Cache#getAllPresent}. */
   Map<K, V> getAllPresent(Iterable<? extends K> keys);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/UnboundedLocalCache.java
Patch:
@@ -138,7 +138,8 @@ public boolean isPendingEviction(K key) {
   }
 
   @Override
-  public @Nullable V getIfPresentQuietly(K key) {
+  @SuppressWarnings("SuspiciousMethodCalls")
+  public @Nullable V getIfPresentQuietly(Object key) {
     return data.get(key);
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpirationTest.java
Patch:
@@ -680,10 +680,10 @@ public void containsKey_inFlight(AsyncCache<Int, Int> cache, CacheContext contex
     var future = new CompletableFuture<Int>();
     cache.put(context.absentKey(), future);
     assertThat(cache.asMap().containsKey(context.absentKey())).isTrue();
-    assertThat(cache.synchronous().asMap().containsKey(context.absentKey())).isTrue();
+    assertThat(cache.synchronous().asMap().containsKey(context.absentKey())).isFalse();
     context.ticker().advance(Duration.ofMinutes(5));
     assertThat(cache.asMap().containsKey(context.absentKey())).isTrue();
-    assertThat(cache.synchronous().asMap().containsKey(context.absentKey())).isTrue();
+    assertThat(cache.synchronous().asMap().containsKey(context.absentKey())).isFalse();
     future.complete(null);
   }
 

File: guava/src/main/java/module-info.java
Patch:
@@ -1,4 +1,7 @@
 module com.github.benmanes.caffeine.guava {
   requires transitive com.github.benmanes.caffeine;
   requires transitive com.google.common;
+
+  requires static com.google.errorprone.annotations;
+  requires static org.checkerframework.checker.qual;
 }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -3864,7 +3864,7 @@ static final class PerformCleanupTask extends ForkJoinTask<Void> implements Runn
     final WeakReference<BoundedLocalCache<?, ?>> reference;
 
     PerformCleanupTask(BoundedLocalCache<?, ?> cache) {
-      reference = new WeakReference<BoundedLocalCache<?,?>>(cache);
+      reference = new WeakReference<>(cache);
     }
 
     @Override

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheLoader.java
Patch:
@@ -225,7 +225,7 @@ default CompletableFuture<? extends V> asyncReload(
   static <K, V> CacheLoader<K, V> bulk(Function<? super Set<? extends K>,
       ? extends Map<? extends K, ? extends V>> mappingFunction) {
     requireNonNull(mappingFunction);
-    return new CacheLoader<K, V>() {
+    return new CacheLoader<>() {
       @Override public @Nullable V load(K key) {
         return loadAll(Set.of(key)).get(key);
       }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -1163,8 +1163,8 @@ public <K1 extends K, V1 extends V> AsyncLoadingCache<K1, V1> buildAsync(
     @SuppressWarnings("unchecked")
     Caffeine<K1, V1> self = (Caffeine<K1, V1>) this;
     return isBounded() || refreshAfterWrite()
-        ? new BoundedLocalCache.BoundedLocalAsyncLoadingCache<K1, V1>(self, loader)
-        : new UnboundedLocalCache.UnboundedLocalAsyncLoadingCache<K1, V1>(self, loader);
+        ? new BoundedLocalCache.BoundedLocalAsyncLoadingCache<>(self, loader)
+        : new UnboundedLocalCache.UnboundedLocalAsyncLoadingCache<>(self, loader);
   }
 
   void requireNonLoadingCache() {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Interner.java
Patch:
@@ -153,7 +153,7 @@ final class Interned<K, V> extends Node<K, V> implements NodeFactory<K, V> {
     return new LookupKeyEqualsReference<>(key);
   }
   @Override public Object newReferenceKey(K key, ReferenceQueue<K> referenceQueue) {
-    return new WeakKeyEqualsReference<K>(key, referenceQueue);
+    return new WeakKeyEqualsReference<>(key, referenceQueue);
   }
   @Override public boolean isAlive() {
     Object keyRef = keyReference;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LinkedDeque.java
Patch:
@@ -109,7 +109,7 @@ interface PeekingIterator<E> extends Iterator<E> {
 
     /** Returns an iterator that returns the first iteration followed by the second iteration. */
     static <E> PeekingIterator<E> concat(PeekingIterator<E> first, PeekingIterator<E> second) {
-      return new PeekingIterator<E>() {
+      return new PeekingIterator<>() {
         @Override public boolean hasNext() {
           return first.hasNext() || second.hasNext();
         }
@@ -130,7 +130,7 @@ static <E> PeekingIterator<E> concat(PeekingIterator<E> first, PeekingIterator<E
     /** Returns an iterator that selects the greater element from the backing iterators. */
     static <E> PeekingIterator<E> comparing(PeekingIterator<E> first,
           PeekingIterator<E> second, Comparator<E> comparator) {
-      return new PeekingIterator<E>() {
+      return new PeekingIterator<>() {
         @Override public boolean hasNext() {
           return first.hasNext() || second.hasNext();
         }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncCache.java
Patch:
@@ -1102,7 +1102,7 @@ public void forEach(Consumer<? super V> action) {
 
       @Override
       public Iterator<V> iterator() {
-        return new Iterator<V>() {
+        return new Iterator<>() {
           final Iterator<Entry<K, V>> iterator = entrySet().iterator();
 
           @Override

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Policy.java
Patch:
@@ -835,7 +835,7 @@ default void setRefreshesAfter(Duration duration) {
    * A key-value pair that may include policy metadata for the cached entry. Unless otherwise
    * specified, this is a value-based class, it can be assumed that the implementation is an
    * immutable snapshot of the cached data at the time of this entry's creation, and it will not
-   * reflect changes afterwards.
+   * reflect changes afterward.
    */
   interface CacheEntry<K, V> extends Map.Entry<K, V> {
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/UnboundedLocalCache.java
Patch:
@@ -990,7 +990,7 @@ static final class EntrySpliterator<K, V> implements Spliterator<Entry<K, V>> {
     public void forEachRemaining(Consumer<? super Entry<K, V>> action) {
       requireNonNull(action);
       spliterator.forEachRemaining(entry -> {
-        var e = new WriteThroughEntry<K, V>(cache, entry.getKey(), entry.getValue());
+        var e = new WriteThroughEntry<>(cache, entry.getKey(), entry.getValue());
         action.accept(e);
       });
     }
@@ -999,7 +999,7 @@ public void forEachRemaining(Consumer<? super Entry<K, V>> action) {
     public boolean tryAdvance(Consumer<? super Entry<K, V>> action) {
       requireNonNull(action);
       return spliterator.tryAdvance(entry -> {
-        var e = new WriteThroughEntry<K, V>(cache, entry.getKey(), entry.getValue());
+        var e = new WriteThroughEntry<>(cache, entry.getKey(), entry.getValue());
         action.accept(e);
       });
     }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheProxy.java
Patch:
@@ -212,7 +212,7 @@ public Map<K, V> getAll(Set<? extends K> keys) {
    */
   protected Map<K, Expirable<V>> getAndFilterExpiredEntries(
       Set<? extends K> keys, boolean updateAccessTime) {
-    var result = new HashMap<K, Expirable<V>>(cache.getAllPresent(keys));
+    var result = new HashMap<>(cache.getAllPresent(keys));
 
     int[] expired = { 0 };
     long[] millis = { 0L };
@@ -1238,7 +1238,7 @@ public Cache.Entry<K, V> next() {
       current = cursor;
       cursor = null;
       @SuppressWarnings("NullAway")
-      var entry = new EntryProxy<K, V>(copyOf(current.getKey()), copyValue(current.getValue()));
+      var entry = new EntryProxy<>(copyOf(current.getKey()), copyValue(current.getValue()));
       return entry;
     }
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/CaffeineConfiguration.java
Patch:
@@ -638,7 +638,7 @@ private UnmodifiableIterable(Iterable<E> delegate) {
     }
     @Override public Iterator<E> iterator() {
       var iterator = delegate.iterator();
-      return new Iterator<E>() {
+      return new Iterator<>() {
         @Override public boolean hasNext() {
           return iterator.hasNext();
         }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/EventDispatcher.java
Patch:
@@ -99,7 +99,7 @@ public void register(CacheEntryListenerConfiguration<K, V> configuration) {
           configuration.getCacheEntryEventFilterFactory().create());
     }
 
-    var registration = new Registration<K, V>(configuration, filter, listener);
+    var registration = new Registration<>(configuration, filter, listener);
     dispatchQueues.putIfAbsent(registration, new ConcurrentHashMap<>());
   }
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/JCacheEntryEvent.java
Patch:
@@ -82,7 +82,7 @@ public <T> T unwrap(Class<T> clazz) {
 
   @Override
   public Iterator<CacheEntryEvent<? extends K, ? extends V>> iterator() {
-    return new Iterator<CacheEntryEvent<? extends K, ? extends V>>() {
+    return new Iterator<>() {
       boolean hasNext = true;
 
       @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/IndicatorResetCountMin4.java
Patch:
@@ -30,7 +30,7 @@
 public final class IndicatorResetCountMin4 implements Frequency {
   private final ClimberResetCountMin4 sketch;
 
-  Indicator indicator;
+  final Indicator indicator;
 
   public IndicatorResetCountMin4(Config config) {
     this.sketch = new ClimberResetCountMin4(config);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/table/RandomRemovalFrequencyTable.java
Patch:
@@ -30,7 +30,7 @@
  * maximum frequency of an element. The size of the sample in relation to the cache size can be
  * controlled with a sample factor. Instead of halving the popularity of elements a random element
  * is dropped when table is full.
- *
+ * <p>
  * This class is used to check the feasibility of using TinyTable instead of CountMin Sketch.
  *
  * @author gilg1983@gmail.com (Gil Einziger)
@@ -39,7 +39,7 @@ public final class RandomRemovalFrequencyTable implements Frequency {
   /** controls both the max count and how many items are remembered (the sum) */
   private static final int sampleFactor = 8;
 
-  /** a place holder for TinyTable */
+  /** a placeholder for TinyTable */
   private final Map<Long, Integer> table;
   /** used to dropped items at random */
   private final Random random;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinySetIndexing.java
Patch:
@@ -24,7 +24,7 @@
  * empty) isLastIndex (set bit for last in chain/empty bit for not last in chain). Both indexes are
  * assumed to be 64 bits, (longs) for efficiency and simplicity. The technique update the indexes
  * upon addition/removal.
- *
+ * <p>
  * Paper link:
  * http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-get.cgi/2015/CS/CS-2015-03.pdf
  * Presentation:

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/PolicyActor.java
Patch:
@@ -107,7 +107,7 @@ private final class Execute extends Command {
     }
   }
 
-  /** A command to shutdown the policy and finalize the statistics. */
+  /** A command to shut down the policy and finalize the statistics. */
   private final class Finish extends Command {
     @Override public void execute() {
       policy.finished();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/greedy_dual/GdsfPolicy.java
Patch:
@@ -130,7 +130,7 @@ private void evict(Node candidate) {
       // If f is among {f1, f2, ... fk}, it is simply not cached and removed from the priority
       // queue, while none of the files already in the cache is evicted. This happens when the value
       // of Pr(f) is so low that it would put f (if cached) among the first candidates for
-      // replacement, e.g. when the file size is very large. Thus the proposed procedure will
+      // replacement, e.g. when the file size is very large. Thus, the proposed procedure will
       // automatically limit the cases when such files are cached
       policyStats.recordRejection();
       remove(candidate);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/ClockProPlusPolicy.java
Patch:
@@ -32,7 +32,7 @@
  * with the utility-driven adaption idea borrowed from CAR. The algorithm is explained by the
  * authors in <a href="https://dl.acm.org/doi/10.1145/3319647.3325838">CLOCK-Pro+: improving
  * CLOCK-Pro cache replacement with utility-driven adaptation</a>.
- *
+ * <p>
  * Implementation here differs from ClockProPolicy only in adjusting coldTarget and tracking for
  * demoted status part. Below is a summary of coldTarget adjusting differences between ClockPro
  * and ClockPro+.

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/ClockProPolicy.java
Patch:
@@ -34,7 +34,7 @@
  * scanned.
  * <p>
  * ClockPro uses three hands that scan the queue. The hot hand points to the largest recency, the
- * cold hand to the cold entry furthest from the hot hand, and the test hand to the last cold entry
+ * cold hand to the cold entry farthest from the hot hand, and the test hand to the last cold entry
  * in the test period. This policy is adaptive by adjusting the percentage of hot and cold entries
  * that may reside in the cache. It uses non-resident (ghost) entries to retain additional history,
  * which are removed during the test hand's scan. The algorithm is explained by the authors in

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/ClockProSimplePolicy.java
Patch:
@@ -35,15 +35,15 @@
  * scanned.
  * <p>
  * ClockPro uses three hands that scan the queue. The hot hand points to the largest recency, the
- * cold hand to the cold entry furthest from the hot hand, and the test hand to the last cold entry
+ * cold hand to the cold entry farthest from the hot hand, and the test hand to the last cold entry
  * in the test period. This policy is adaptive by adjusting the percentage of hot and cold entries
  * that may reside in the cache. It uses non-resident (ghost) entries to retain additional history,
  * which are removed during the test hand's scan. The algorithm is explained by the authors in
  * <a href="http://www.ece.eng.wayne.edu/~sjiang/pubs/papers/jiang05_CLOCK-Pro.pdf">CLOCK-Pro: An
  * Effective Improvement of the CLOCK Replacement</a> and
  * <a href="http://www.slideshare.net/huliang64/clockpro">Clock-Pro: An Effective Replacement in OS
  * Kernel</a>.
- *
+ * <p>
  * This implementation works exactly like ClockPro, but pursues the simplicity of the code.
  * It divides a single list of ClockPro into three lists: hot, cold, and non-resident.
  * For maintaining a test period of each entry, it uses epoch.

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/S4LruPolicy.java
Patch:
@@ -40,7 +40,7 @@
  * higher queue (items in queue 3 move to the head of queue 3). Each queue is allocated 1/4 of the
  * total cache size and items are evicted from the tail of a queue to the head of the next lower
  * queue to maintain the size invariants. Items evicted from queue 0 are evicted from the cache."
- *
+ * <p>
  * For more details, see <a href="http://www.cs.cornell.edu/~qhuang/papers/sosp_fbanalysis.pdf">An
  * Analysis of Facebook Photo Caching</a>.
  *

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/Indicator.java
Patch:
@@ -108,15 +108,15 @@ private final class EstSkew {
     StreamSummary<Long> stream;
 
     public EstSkew() {
-      this.stream = new StreamSummary<Long>(ssSize);
+      this.stream = new StreamSummary<>(ssSize);
     }
 
     public void record(long key) {
       stream.offer(key);
     }
 
     public void reset() {
-      this.stream = new StreamSummary<Long>(ssSize);
+      this.stream = new StreamSummary<>(ssSize);
     }
 
     public IntStream getTopK(int k) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncCache.java
Patch:
@@ -144,8 +144,7 @@ default CompletableFuture<Map<K, V>> getAll(Iterable<? extends K> keys,
     try {
       var loader = mappingFunction.apply(
           Collections.unmodifiableSet(proxies.keySet()), cache().executor());
-      loader.whenComplete(completer);
-      return composeResult(futures);
+      return loader.whenComplete(completer).thenCompose(ignored -> composeResult(futures));
     } catch (Throwable t) {
       completer.accept(/* result */ null, t);
       throw t;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsyncLoadingCacheTest.java
Patch:
@@ -319,7 +319,8 @@ public void getAll_present_partial(AsyncLoadingCache<Int, Int> cache, CacheConte
 
   @Test(dataProvider = "caches")
   @CacheSpec(loader = Loader.BULK_NEGATIVE_EXCEEDS,
-      removalListener = { Listener.DISABLED, Listener.REJECTING })
+      removalListener = { Listener.DISABLED, Listener.REJECTING },
+      executor = { CacheExecutor.DIRECT, CacheExecutor.DEFAULT })
   public void getAll_exceeds(AsyncLoadingCache<Int, Int> cache, CacheContext context) {
     var result = cache.getAll(context.absentKeys()).join();
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -19,7 +19,7 @@
 import static com.github.benmanes.caffeine.cache.Caffeine.calculateHashMapCapacity;
 import static com.github.benmanes.caffeine.cache.Caffeine.ceilingPowerOfTwo;
 import static com.github.benmanes.caffeine.cache.Caffeine.requireArgument;
-import static com.github.benmanes.caffeine.cache.Caffeine.saturatedToNanos;
+import static com.github.benmanes.caffeine.cache.Caffeine.toNanosSaturated;
 import static com.github.benmanes.caffeine.cache.LocalLoadingCache.newBulkMappingFunction;
 import static com.github.benmanes.caffeine.cache.LocalLoadingCache.newMappingFunction;
 import static com.github.benmanes.caffeine.cache.Node.PROBATION;
@@ -4338,7 +4338,7 @@ final class BoundedVarExpiration implements VarExpiration<K, V> {
         requireNonNull(remappingFunction);
         requireArgument(!duration.isNegative(), "duration cannot be negative: %s", duration);
         var expiry = new FixedExpireAfterWrite<K, V>(
-            saturatedToNanos(duration), TimeUnit.NANOSECONDS);
+            toNanosSaturated(duration), TimeUnit.NANOSECONDS);
 
         return cache.isAsync
             ? computeAsync(key, remappingFunction, expiry)

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -219,7 +219,7 @@ public void clear_pendingWrites_weakKeys(
           ref.enqueue();
         }
         GcFinalization.awaitFullGc();
-        collected[0] = (invocation.getArgument(2, RemovalCause.class) == COLLECTED);
+        collected[0] = (invocation.<RemovalCause>getArgument(2) == COLLECTED);
       }
       return null;
     };

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpirationTest.java
Patch:
@@ -172,7 +172,7 @@ public void schedule(Cache<Int, Int> cache, CacheContext context) {
       expireAfterWrite = {Expire.DISABLED, Expire.ONE_MINUTE})
   public void schedule_immediate(Cache<Int, Int> cache, CacheContext context) {
     doAnswer(invocation -> {
-      invocation.getArgument(1, Runnable.class).run();
+      invocation.<Runnable>getArgument(1).run();
       return new CompletableFuture<>();
     }).when(context.scheduler()).schedule(any(), any(), anyLong(), any());
 
@@ -192,8 +192,8 @@ public void schedule_delay(Cache<Int, Duration> cache, CacheContext context) {
     var delay = ArgumentCaptor.forClass(long.class);
     var task = ArgumentCaptor.forClass(Runnable.class);
     Answer<Void> onRemoval = invocation -> {
-      var key = invocation.getArgument(0, Int.class);
-      var value = invocation.getArgument(1, Duration.class);
+      Int key = invocation.getArgument(0);
+      Duration value = invocation.getArgument(1);
       actualExpirationPeriods.put(key, Duration.ofNanos(context.ticker().read()).minus(value));
       return null;
     };

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/TimerWheelTest.java
Patch:
@@ -403,7 +403,7 @@ public void deschedule_fuzzy(long clock, long nanos, long[] times) {
   @Test(dataProvider = "clock")
   public void expire_reschedule(long clock) {
     when(cache.evictEntry(captor.capture(), any(), anyLong())).thenAnswer(invocation -> {
-      var timer = (Timer) invocation.getArgument(0);
+      Timer timer = invocation.getArgument(0);
       timer.setVariableTime(timerWheel.nanos + 100);
       return false;
     });

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/AsyncCacheSubject.java
Patch:
@@ -100,7 +100,7 @@ public void containsEntry(Object key, Object value) {
 
   /** Fails if the cache does not contain exactly the given set of entries in the given map. */
   public void containsExactlyEntriesIn(Map<?, ?> expectedMap) {
-    if (expectedMap.values().stream().anyMatch(value -> value instanceof Future<?>)) {
+    if (expectedMap.values().stream().anyMatch(Future.class::isInstance)) {
       check("cache").that(actual.asMap()).containsExactlyEntriesIn(expectedMap);
     } else {
       check("cache").about(cache())

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheValidationListener.java
Patch:
@@ -142,7 +142,7 @@ public void afterInvocation(IInvokedMethod method, ITestResult testResult) {
   /** Validates the internal state of the cache. */
   private void validate(ITestResult testResult) {
     CacheContext context = Arrays.stream(testResult.getParameters())
-        .filter(param -> param instanceof CacheContext)
+        .filter(CacheContext.class::isInstance)
         .findFirst().map(param -> (CacheContext) param)
         .orElse(null);
     if (context != null) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/lincheck/AbstractLincheckCacheTest.java
Patch:
@@ -16,7 +16,6 @@
 package com.github.benmanes.caffeine.lincheck;
 
 import java.util.Map;
-import java.util.concurrent.ForkJoinPool;
 
 import org.jetbrains.kotlinx.lincheck.LinChecker;
 import org.jetbrains.kotlinx.lincheck.annotations.Operation;
@@ -44,8 +43,7 @@ public abstract class AbstractLincheckCacheTest {
   private final LoadingCache<Integer, Integer> cache;
 
   public AbstractLincheckCacheTest(Caffeine<Object, Object> builder) {
-    cache = builder.executor(Runnable::run).build(key -> -key);
-    ForkJoinPool.commonPool(); // force eager initialization
+    cache = builder.build(key -> -key);
   }
 
   /**

File: caffeine/src/test/java/com/github/benmanes/caffeine/lincheck/CaffeineLincheckTest.java
Patch:
@@ -36,8 +36,10 @@ public Object[] factory() {
   }
 
   public static final class BoundedLincheckTest extends AbstractLincheckCacheTest {
+
     public BoundedLincheckTest() {
       super(Caffeine.newBuilder()
+          .executor(Runnable::run)
           .maximumSize(Long.MAX_VALUE)
           .expireAfterWrite(Duration.ofNanos(Long.MAX_VALUE)));
     }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheManagerImpl.java
Patch:
@@ -240,7 +240,7 @@ public boolean isClosed() {
 
   @Override
   public <T> T unwrap(Class<T> clazz) {
-    if (clazz.isAssignableFrom(getClass())) {
+    if (clazz.isInstance(this)) {
       return clazz.cast(this);
     }
     throw new IllegalArgumentException("Unwapping to " + clazz

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheProxy.java
Patch:
@@ -1016,10 +1016,9 @@ public void close() {
 
   @Override
   public <T> T unwrap(Class<T> clazz) {
-    if (clazz.isAssignableFrom(cache.getClass())) {
+    if (clazz.isInstance(cache)) {
       return clazz.cast(cache);
-    }
-    if (clazz.isAssignableFrom(getClass())) {
+    } else if (clazz.isInstance(this)) {
       return clazz.cast(this);
     }
     throw new IllegalArgumentException("Unwrapping to " + clazz

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CaffeineTest.java
Patch:
@@ -16,7 +16,6 @@
 package com.github.benmanes.caffeine.cache;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth8.assertThat;
 import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static org.junit.Assert.assertThrows;
 import static org.mockito.Mockito.verify;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpirationTest.java
Patch:
@@ -28,7 +28,6 @@
 import static com.google.common.base.Functions.identity;
 import static com.google.common.collect.ImmutableList.toImmutableList;
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth8.assertThat;
 import static java.util.Map.entry;
 import static org.junit.Assert.assertThrows;
 import static org.mockito.ArgumentMatchers.any;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterWriteTest.java
Patch:
@@ -58,6 +58,7 @@
 import com.github.benmanes.caffeine.testing.Int;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Maps;
+import com.google.common.truth.Truth8;
 
 /**
  * The test cases for caches that support the expire-after-write (time-to-live) policy.
@@ -324,14 +325,14 @@ public void ageOf_duration(CacheContext context,
     context.ticker().advance(Duration.ofSeconds(30));
     assertThat(expireAfterWrite.ageOf(context.firstKey()).orElseThrow().toSeconds()).isEqualTo(30);
     context.ticker().advance(Duration.ofSeconds(45));
-    assertThat(expireAfterWrite.ageOf(context.firstKey())).isEmpty();
+    Truth8.assertThat(expireAfterWrite.ageOf(context.firstKey())).isEmpty();
   }
 
   @Test(dataProvider = "caches")
   @CacheSpec(expireAfterWrite = Expire.ONE_MINUTE)
   public void ageOf_absent(CacheContext context,
       @ExpireAfterWrite FixedExpiration<Int, Int> expireAfterWrite) {
-    assertThat(expireAfterWrite.ageOf(context.absentKey())).isEmpty();
+    Truth8.assertThat(expireAfterWrite.ageOf(context.absentKey())).isEmpty();
     assertThat(expireAfterWrite.ageOf(context.absentKey(), TimeUnit.SECONDS)).isEmpty();
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/RefreshAfterWriteTest.java
Patch:
@@ -70,6 +70,7 @@
 import com.github.valfirst.slf4jtest.TestLoggerFactory;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
+import com.google.common.truth.Truth8;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 /**
@@ -1005,7 +1006,7 @@ public void ageOf_duration(CacheContext context, FixedRefresh<Int, Int> refreshA
   @Test(dataProvider = "caches")
   @CacheSpec(refreshAfterWrite = Expire.ONE_MINUTE)
   public void ageOf_absent(CacheContext context, FixedRefresh<Int, Int> refreshAfterWrite) {
-    assertThat(refreshAfterWrite.ageOf(context.absentKey())).isEmpty();
+    Truth8.assertThat(refreshAfterWrite.ageOf(context.absentKey())).isEmpty();
     assertThat(refreshAfterWrite.ageOf(context.absentKey(), TimeUnit.SECONDS)).isEmpty();
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/UnboundedLocalCacheTest.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache;
 
-import static com.google.common.truth.Truth8.assertThat;
+import static com.google.common.truth.Truth.assertThat;
 import static org.slf4j.event.Level.TRACE;
 
 import org.testng.annotations.Listeners;

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/event/EventDispatcherTest.java
Patch:
@@ -16,7 +16,6 @@
 package com.github.benmanes.caffeine.jcache.event;
 
 import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth8.assertThat;
 import static javax.cache.event.EventType.CREATED;
 import static javax.cache.event.EventType.EXPIRED;
 import static javax.cache.event.EventType.REMOVED;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/FrequencySketch.java
Patch:
@@ -168,7 +168,7 @@ public void increment(E e) {
     }
   }
 
-  /** Applies a supplemental hash functions to defends against poor quality hash. */
+  /** Applies a supplemental hash function to defend against a poor quality hash. */
   static int spread(int x) {
     x ^= x >>> 17;
     x *= 0xed5ad4bb;

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheFactoryGenerator.java
Patch:
@@ -101,6 +101,7 @@ private void writeJavaFile() throws IOException {
     for (TypeSpec typeSpec : factoryTypes) {
       JavaFile.builder(getClass().getPackageName(), typeSpec)
           .addFileComment(header, Year.now(timeZone))
+          .skipJavaLangImports(true)
           .indent("  ")
           .build()
           .writeTo(directory);

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeFactoryGenerator.java
Patch:
@@ -104,6 +104,7 @@ private void writeJavaFile() throws IOException {
     for (TypeSpec node : nodeTypes) {
       JavaFile.builder(getClass().getPackage().getName(), node)
           .addFileComment(header, Year.now(timeZone))
+          .skipJavaLangImports(true)
           .indent("  ")
           .build()
           .writeTo(directory);

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/JSR166TestCase.java
Patch:
@@ -189,7 +189,7 @@
  */
 @SuppressWarnings({"AnnotateFormatMethod", "CollectionToArray", "EqualsIncompatibleType",
     "FunctionalInterfaceClash", "JavaUtilDate", "JUnit3FloatingPointComparisonWithoutDelta",
-    "NumericEquality", "rawtypes", "ReferenceEquality",
+    "NonFinalStaticField", "NumericEquality", "rawtypes", "ReferenceEquality",
     "RethrowReflectiveOperationExceptionAsLinkageError", "serial", "SwitchDefault",
     "ThreadPriorityCheck", "try", "unchecked", "UndefinedEquals"})
 public class JSR166TestCase extends TestCase {

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaCache.java
Patch:
@@ -200,6 +200,7 @@ final class KeySetView extends ForwardingSet<K> {
     @Override public boolean removeIf(Predicate<? super K> filter) {
       return delegate().removeIf(filter);
     }
+    @SuppressWarnings("NullAway")
     @Override public boolean remove(Object o) {
       return (o != null) && delegate().remove(o);
     }
@@ -221,6 +222,7 @@ final class ValuesView extends ForwardingCollection<V> {
   }
 
   final class EntrySetView extends ForwardingSet<Entry<K, V>> {
+    @SuppressWarnings("NullAway")
     @Override public boolean add(Entry<K, V> entry) {
       throw new UnsupportedOperationException();
     }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurator.java
Patch:
@@ -61,7 +61,9 @@
 public final class TypesafeConfigurator {
   static final Logger logger = System.getLogger(TypesafeConfigurator.class.getName());
 
+  @SuppressWarnings("NonFinalStaticField")
   static ConfigSource configSource = TypesafeConfigurator::resolveConfig;
+  @SuppressWarnings("NonFinalStaticField")
   static FactoryCreator factoryCreator = FactoryBuilder::factoryOf;
 
   private TypesafeConfigurator() {}

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -178,8 +178,8 @@ abstract class BoundedLocalCache<K, V> extends BLCHeader.DrainStatusRef
    * hierarchical timer wheel [5]. The queuing policies allow for peeking at the oldest entry to
    * determine if it has expired. If it has not, then the younger entries must not have expired
    * either. If a maximum size is set, then expiration will share the queues, minimizing the
-   * per-entry footprint is minimized. The timer wheel based policy uses hashing and cascading in a
-   * manner that amortizes the penalty of sorting to achieve a similar algorithmic cost.
+   * per-entry footprint. The timer wheel based policy uses hashing and cascading in a manner that
+   * amortizes the penalty of sorting to achieve a similar algorithmic cost.
    *
    * The expiration updates are applied in a best effort fashion. The reordering of variable or
    * access-order expiration may be discarded by the read buffer if it is full or contended.

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LoadingCacheTest.java
Patch:
@@ -943,6 +943,8 @@ public void refresh_error_log(CacheContext context) {
     cache.refresh(context.absentKey());
     var event = Iterables.getOnlyElement(TestLoggerFactory.getLoggingEvents());
     assertThat(event.getThrowable().orElseThrow()).hasCauseThat().isSameInstanceAs(expected);
+    assertThat(event.getFormattedMessage()).isAnyOf(
+        "Exception thrown during asynchronous load", "Exception thrown during refresh");
     assertThat(event.getLevel()).isEqualTo(WARN);
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/RefreshAfterWriteTest.java
Patch:
@@ -391,6 +391,7 @@ public void refreshIfNeeded_error_log(CacheContext context) {
     assertThat(value).isEqualTo(context.absentValue());
     var event = Iterables.getOnlyElement(TestLoggerFactory.getLoggingEvents());
     assertThat(event.getThrowable().orElseThrow()).hasCauseThat().isSameInstanceAs(expected);
+    assertThat(event.getFormattedMessage()).isEqualTo("Exception thrown during refresh");
     assertThat(event.getLevel()).isEqualTo(WARN);
   }
 
@@ -420,6 +421,8 @@ public void refreshIfNeeded_nullFuture(CacheContext context) {
     assertThat(value).isNotNull();
     var event = Iterables.getOnlyElement(TestLoggerFactory.getLoggingEvents());
     assertThat(event.getThrowable().orElseThrow()).isInstanceOf(NullPointerException.class);
+    assertThat(event.getFormattedMessage()).isEqualTo(
+        "Exception thrown when submitting refresh task");
     assertThat(event.getLevel()).isEqualTo(WARN);
 
     assertThat(refreshed.get()).isTrue();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheValidationListener.java
Patch:
@@ -35,6 +35,7 @@
 import org.apache.commons.lang3.StringUtils;
 import org.joor.Reflect;
 import org.mockito.Mockito;
+import org.slf4j.bridge.SLF4JBridgeHandler;
 import org.slf4j.event.Level;
 import org.testng.Assert;
 import org.testng.IInvokedMethod;
@@ -86,6 +87,8 @@ public void onStart(ISuite suite) {
         resultQueues.add(invokedMethods.get());
       }
     }
+    SLF4JBridgeHandler.removeHandlersForRootLogger();
+    SLF4JBridgeHandler.install();
   }
 
   @Override

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalCacheFactory.java
Patch:
@@ -32,6 +32,7 @@ interface LocalCacheFactory {
   MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
   MethodType FACTORY = MethodType.methodType(
       void.class, Caffeine.class, AsyncCacheLoader.class, boolean.class);
+  MethodType FACTORY_CALL = FACTORY.changeReturnType(BoundedLocalCache.class);
   ConcurrentMap<String, LocalCacheFactory> FACTORIES = new ConcurrentHashMap<>();
 
   /** Returns a cache optimized for this configuration. */
@@ -118,10 +119,9 @@ final class MethodHandleBasedFactory implements LocalCacheFactory {
     final MethodHandle methodHandle;
 
     MethodHandleBasedFactory(Class<?> clazz) throws NoSuchMethodException, IllegalAccessException {
-      var constructor = LOOKUP.findConstructor(clazz, FACTORY);
-      this.methodHandle = constructor.asType(
-          constructor.type().changeReturnType(BoundedLocalCache.class));
+      this.methodHandle = LOOKUP.findConstructor(clazz, FACTORY).asType(FACTORY_CALL);
     }
+    
     @SuppressWarnings("unchecked")
     @Override public <K, V> BoundedLocalCache<K, V> newInstance(Caffeine<K, V> builder,
         @Nullable AsyncCacheLoader<? super K, V> cacheLoader, boolean async) throws Throwable {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/NodeFactory.java
Patch:
@@ -148,8 +148,7 @@ static NodeFactory<Object, Object> newFactory(String className) {
     try {
       var clazz = LOOKUP.findClass(Node.class.getPackageName() + "." + className);
       var constructor = LOOKUP.findConstructor(clazz, FACTORY);
-      return (NodeFactory<Object, Object>) constructor
-          .asType(constructor.type().changeReturnType(NodeFactory.class)).invokeExact();
+      return (NodeFactory<Object, Object>) constructor.invoke();
     } catch (RuntimeException | Error e) {
       throw e;
     } catch (Throwable t) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -3974,6 +3974,7 @@ private Object writeReplace() {
     }
   }
 
+  @SuppressWarnings("NullableOptional")
   static final class BoundedPolicy<K, V> implements Policy<K, V> {
     final BoundedLocalCache<K, V> cache;
     final Function<V, V> transformer;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -94,7 +94,6 @@
 import org.apache.commons.lang3.mutable.MutableInt;
 import org.mockito.Mockito;
 import org.mockito.stubbing.Answer;
-import org.slf4j.event.Level;
 import org.testng.annotations.Listeners;
 import org.testng.annotations.Test;
 
@@ -1892,7 +1891,7 @@ public void put_warnIfEvictionBlocked(BoundedLocalCache<Int, Int> cache, CacheCo
     try {
       ConcurrentTestHarness.execute(() -> {
         var logger = TestLoggerFactory.getTestLogger(BoundedLocalCache.class);
-        logger.setEnabledLevels(Level.WARN, Level.ERROR);
+        logger.setEnabledLevels(WARN, ERROR);
         thread.set(Thread.currentThread());
         testLogger.set(logger);
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Issue30Test.java
Patch:
@@ -46,7 +46,7 @@
 import com.google.common.util.concurrent.MoreExecutors;
 
 /**
- * Issue #30: Unexpected cache misses with <tt>expireAfterWrite</tt> using multiple keys.
+ * Issue #30: Unexpected cache misses with <code>expireAfterWrite</code> using multiple keys.
  * <p>
  * Prior to eviction, the cache must revalidate that the entry has expired. If the entry was updated
  * but the maintenance thread reads a stale value, then the entry may be prematurely expired. The

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Solr10141Test.java
Patch:
@@ -34,7 +34,7 @@
  * SOLR-10141: Removal listener notified with stale value
  * <p>
  * When an entry is chosen for eviction and concurrently updated, the value notified should be the
- * updated one if the <tt>put</tt> was successful.
+ * updated one if the <code>put</code> was successful.
  *
  * @author yseeley@gmail.com (Yonik Seeley)
  * @author ben.manes@gmail.com (Ben Manes)

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/EventDispatcher.java
Patch:
@@ -64,13 +64,13 @@
  */
 public final class EventDispatcher<K, V> {
   static final Logger logger = System.getLogger(EventDispatcher.class.getName());
-  final ThreadLocal<List<CompletableFuture<Void>>> pending =
-      ThreadLocal.withInitial(ArrayList::new);
 
   final ConcurrentMap<Registration<K, V>, ConcurrentMap<K, CompletableFuture<Void>>> dispatchQueues;
+  final ThreadLocal<List<CompletableFuture<Void>>> pending;
   final Executor executor;
 
   public EventDispatcher(Executor executor) {
+    this.pending = ThreadLocal.withInitial(ArrayList::new);
     this.dispatchQueues = new ConcurrentHashMap<>();
     this.executor = requireNonNull(executor);
   }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/EventDispatcher.java
Patch:
@@ -64,7 +64,7 @@
  */
 public final class EventDispatcher<K, V> {
   static final Logger logger = System.getLogger(EventDispatcher.class.getName());
-  static final ThreadLocal<List<CompletableFuture<Void>>> pending =
+  final ThreadLocal<List<CompletableFuture<Void>>> pending =
       ThreadLocal.withInitial(ArrayList::new);
 
   final ConcurrentMap<Registration<K, V>, ConcurrentMap<K, CompletableFuture<Void>>> dispatchQueues;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/Simulator.java
Patch:
@@ -137,7 +137,7 @@ private ImmutableList<PolicyActor> getPolicyActors(Set<Characteristic> character
   }
 
   /** Throws the underlying cause for the simulation failure. */
-  private void throwError(ImmutableList<PolicyActor> policies, RuntimeException e) {
+  private void throwError(Iterable<PolicyActor> policies, RuntimeException e) {
     if (!Thread.currentThread().isInterrupted()) {
       throw e;
     }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/QdlpPolicy.java
Patch:
@@ -144,19 +144,18 @@ private void evict() {
     int freq = candidate.frequency;
     candidate.frequency = 0;
     candidate.remove();
+    sizeFifo--;
 
     if (freq >= moveToMainThreshold) {
       evictFromMain();
       candidate.appendToTail(headMain);
       candidate.type = QueueType.MAIN;
       sizeMain++;
-      sizeFifo--;
     } else {
       candidate.appendToTail(headGhost);
       candidate.type = QueueType.GHOST;
       candidate.frequency = 0;
       sizeGhost++;
-      sizeFifo--;
 
       if (sizeGhost > maxGhost) {
         var ghost = headGhost.next;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheValidationListener.java
Patch:
@@ -225,7 +225,8 @@ private static void checkNoEvictions(ITestResult testResult, CacheContext contex
   private static void checkLogger(ITestResult testResult) {
     var testMethod = testResult.getMethod().getConstructorOrMethod().getMethod();
     var checkMaxLogLevel = Optional.ofNullable(testMethod.getAnnotation(CheckMaxLogLevel.class))
-        .orElse(testResult.getTestClass().getRealClass().getAnnotation(CheckMaxLogLevel.class));
+        .orElseGet(() -> testResult.getTestClass()
+            .getRealClass().getAnnotation(CheckMaxLogLevel.class));
     if (checkMaxLogLevel != null) {
       var events = TestLoggerFactory.getLoggingEvents().stream()
           .filter(event -> event.getLevel().ordinal() > checkMaxLogLevel.value().ordinal())

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/ConcurrentHashMapV7.java
Patch:
@@ -113,8 +113,9 @@
  * @param <K> the type of keys maintained by this map
  * @param <V> the type of mapped values
  */
-@SuppressWarnings({"all", "CheckReturnValue", "deprecation", "JdkObsolete", "rawtypes", "serial",
-  "unchecked", "UnnecessaryParentheses", "UnusedNestedClass", "UnusedVariable", "YodaCondition"})
+@SuppressWarnings({"all", "CheckReturnValue", "deprecation", "JdkObsolete", "LessThanOrEqualTo",
+    "rawtypes", "serial", "unchecked", "UnnecessaryParentheses", "UnusedNestedClass",
+    "UnusedVariable", "YodaCondition"})
 public class ConcurrentHashMapV7<K, V> extends AbstractMap<K, V>
         implements ConcurrentMap<K, V>, Serializable {
     private static final long serialVersionUID = 7249069246763182397L;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedBuffer.java
Patch:
@@ -91,6 +91,7 @@ public void drainTo(Consumer<E> consumer) {
       }
       do {
         int index = (int) (head & MASK);
+        @SuppressWarnings("unchecked")
         E e = (E) BUFFER.getAcquire(buffer, index);
         if (e == null) {
           // not published yet

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalCacheFactory.java
Patch:
@@ -122,6 +122,7 @@ final class MethodHandleBasedFactory implements LocalCacheFactory {
       this.methodHandle = constructor.asType(
           constructor.type().changeReturnType(BoundedLocalCache.class));
     }
+    @SuppressWarnings("unchecked")
     @Override public <K, V> BoundedLocalCache<K, V> newInstance(Caffeine<K, V> builder,
         @Nullable AsyncCacheLoader<? super K, V> cacheLoader, boolean async) throws Throwable {
       return (BoundedLocalCache<K, V>) methodHandle.invokeExact(builder, cacheLoader, async);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/MpscGrowableArrayQueue.java
Patch:
@@ -230,7 +230,7 @@ public String toString() {
   @Override
   @SuppressWarnings("MissingDefault")
   public boolean offer(final E e) {
-    if (null == e) {
+    if (e == null) {
       throw new NullPointerException();
     }
 
@@ -398,7 +398,7 @@ private E newBufferPoll(E[] nextBuffer, final long index) {
   private E newBufferPeek(E[] nextBuffer, final long index) {
     final long offsetInNew = newBufferAndOffset(nextBuffer, index);
     final E n = lvElement(nextBuffer, offsetInNew);// LoadLoad
-    if (null == n) {
+    if (n == null) {
       throw new IllegalStateException("new buffer must have at least one element");
     }
     return n;
@@ -603,6 +603,7 @@ static <E> void soElement(E[] buffer, long offset, E e) {
    * @param offset computed
    * @return the element at the offset
    */
+  @SuppressWarnings("unchecked")
   static <E> E lvElement(E[] buffer, long offset) {
     return (E) REF_ARRAY.getVolatile(buffer, (int) offset);
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/NodeFactory.java
Patch:
@@ -143,6 +143,7 @@ static <K, V> NodeFactory<K, V> loadFactory(String className) {
     return (NodeFactory<K, V>) factory;
   }
 
+  @SuppressWarnings("unchecked")
   static NodeFactory<Object, Object> newFactory(String className) {
     try {
       var clazz = LOOKUP.findClass(Node.class.getPackageName() + "." + className);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CacheTest.java
Patch:
@@ -459,8 +459,7 @@ public void getAll_exceeds(Cache<Int, Int> cache, CacheContext context) {
   @Test(dataProvider = "caches")
   @CacheSpec(removalListener = { Listener.DISABLED, Listener.REJECTING })
   public void getAll_different(Cache<Int, Int> cache, CacheContext context) {
-    var actual = context.absentKeys().stream()
-        .collect(toImmutableMap(key -> intern(key.negate()), identity()));
+    var actual = Maps.uniqueIndex(context.absentKeys(), key -> intern(key.negate()));
     var result = cache.getAll(context.absentKeys(), keys -> actual);
 
     assertThat(result).isEmpty();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LoadingCacheTest.java
Patch:
@@ -73,6 +73,7 @@
 import com.github.benmanes.caffeine.cache.testing.CheckNoStats;
 import com.github.benmanes.caffeine.testing.Int;
 import com.github.valfirst.slf4jtest.TestLoggerFactory;
+import com.google.common.base.Functions;
 import com.google.common.cache.CacheLoader.InvalidCacheLoadException;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -1026,11 +1027,10 @@ public void refreshAll_absent(LoadingCache<Int, Int> cache, CacheContext context
       removalListener = { Listener.DISABLED, Listener.REJECTING })
   public void refreshAll_present(LoadingCache<Int, Int> cache, CacheContext context) {
     var result = cache.refreshAll(context.original().keySet()).join();
-    int count = context.original().keySet().size();
+    int count = context.original().size();
     assertThat(result).hasSize(count);
 
-    var expected = context.original().keySet().stream()
-        .collect(toImmutableMap(identity(), identity()));
+    var expected = Maps.toMap(context.original().keySet(), Functions.identity());
     assertThat(cache).containsExactlyEntriesIn(expected);
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/MultiThreadedTest.java
Patch:
@@ -98,8 +98,8 @@ public void async_concurrent_bounded(
     Threads.runTest(cache, asyncOperations);
   }
 
-  @SuppressWarnings({"FutureReturnValueIgnored", "MethodReferenceUsage", "rawtypes",
-    "ReturnValueIgnored", "SelfEquals", "SizeGreaterThanOrEqualsZero"})
+  @SuppressWarnings({"CollectionToArray", "FutureReturnValueIgnored", "MethodReferenceUsage",
+    "rawtypes", "ReturnValueIgnored", "SelfEquals", "SizeGreaterThanOrEqualsZero"})
   List<BiConsumer<LoadingCache<Int, Int>, Int>> operations = List.of(
       // LoadingCache
       (cache, key) -> { cache.get(key); },

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheGenerator.java
Patch:
@@ -250,7 +250,7 @@ private static void populate(CacheContext context, Cache<Int, Int> cache) {
 
   /** Returns a cache of integers and their negation. */
   private static ImmutableList<Map.Entry<Int, Int>> makeInts() {
-    int size = Stream.of(CacheSpec.Population.values())
+    int size = Arrays.stream(CacheSpec.Population.values())
         .mapToInt(population -> Math.toIntExact(population.size()))
         .max().getAsInt();
     var builder = new ImmutableList.Builder<Map.Entry<Int, Int>>();

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/mutable/UnifiedMapTestCase.java
Patch:
@@ -43,8 +43,9 @@
 /**
  * Ported from Eclipse Collections 11.0.
  */
-@SuppressWarnings({"all", "CanIgnoreReturnValueSuggester", "deprecation",
-  "EqualsBrokenForNull", "EqualsUnsafeCast", "rawtypes", "unchecked", "UndefinedEquals"})
+@SuppressWarnings({"all", "CanIgnoreReturnValueSuggester", "CollectionToArray", "deprecation",
+    "EqualsBrokenForNull", "EqualsUnsafeCast", "NaturalOrder", "rawtypes", "ReverseOrder",
+    "unchecked", "UndefinedEquals"})
 public abstract class UnifiedMapTestCase extends MutableMapTestCase {
   protected static final Integer COLLISION_1 = 0;
   protected static final Integer COLLISION_2 = 17;

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/CollectionSubject.java
Patch:
@@ -85,6 +85,7 @@ private void checkIterable() {
     check("iterator().hasNext()").that(actual.iterator().hasNext()).isFalse();
   }
 
+  @SuppressWarnings("CollectionToArray")
   private void checkCollection() {
     check("size()").that(actual).hasSize(0);
     check("isEmpty()").that(actual).isEmpty();

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheBuilderGwtTest.java
Patch:
@@ -448,6 +448,7 @@ public void testAsMapValues_contains() {
     assertFalse(cache.asMap().values().contains(20));
   }
 
+  @SuppressWarnings("CollectionAddAllToCollectionBlock")
   public void testAsMapKeySet() {
     Cache<Integer, Integer> cache = CaffeinatedGuava.build(Caffeine.newBuilder()
         .expireAfterWrite(1000, TimeUnit.MILLISECONDS)

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheBuilderTest.java
Patch:
@@ -28,6 +28,7 @@
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 
+import java.util.Collections;
 import java.util.Map;
 import java.util.Random;
 import java.util.Set;
@@ -545,7 +546,7 @@ public void testRemovalNotification_clear_basher() throws InterruptedException {
     // Each of the values added to the map should either still be there, or have seen a removal
     // notification.
     assertEquals(expectedKeys, Sets.union(cache.asMap().keySet(), removalNotifications.keySet()));
-    assertTrue(Sets.intersection(cache.asMap().keySet(), removalNotifications.keySet()).isEmpty());
+    assertTrue(Collections.disjoint(cache.asMap().keySet(), removalNotifications.keySet()));
   }
 
   /**

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheReferencesTest.java
Patch:
@@ -37,6 +37,7 @@
  *
  * @author mike nonemacher
  */
+@SuppressWarnings("MapEntry")
 public class CacheReferencesTest extends TestCase {
 
   private static final CacheLoader<Key,String> KEY_TO_STRING_LOADER =

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheTesting.java
Patch:
@@ -84,6 +84,7 @@ static void checkEmpty(ConcurrentMap<?, ?> map) {
     assertEquals(ImmutableMap.of().toString(), map.toString());
   }
 
+  @SuppressWarnings("CollectionToArray")
   static void checkEmpty(Collection<?> collection) {
     assertTrue(collection.isEmpty());
     assertEquals(0, collection.size());

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/EmptyCachesTest.java
Patch:
@@ -394,6 +394,7 @@ private void warmUp(LoadingCache<Object, Object> cache, int minimum, int maximum
     }
   }
 
+  @SuppressWarnings("MapEntry")
   private Map.Entry<Object, Object> entryOf(Object key, Object value) {
     return Maps.immutableEntry(key, value);
   }

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/PopulatedCachesTest.java
Patch:
@@ -47,6 +47,7 @@
  *
  * @author mike nonemacher
  */
+@SuppressWarnings("CollectionToArray")
 public class PopulatedCachesTest extends TestCase {
   // we use integers as keys; make sure the range covers some values that ARE cached by
   // Integer.valueOf(int), and some that are not cached. (127 is the highest cached value.)
@@ -355,6 +356,7 @@ private List<Map.Entry<Object, Object>> warmUp(
     return entries;
   }
 
+  @SuppressWarnings("MapEntry")
   private Map.Entry<Object, Object> entryOf(Object key, Object value) {
     return Maps.immutableEntry(key, value);
   }
@@ -371,6 +373,7 @@ private void assertMapSize(Map<?, ?> map, int size) {
     assertCollectionSize(map.values(), size);
   }
 
+  @SuppressWarnings("CollectionSize")
   private void assertCollectionSize(Collection<?> collection, int size) {
     assertEquals(size, collection.size());
     if (size > 0) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/lirs/LirsTraceReader.java
Patch:
@@ -32,10 +32,11 @@ public LirsTraceReader(String filePath) {
   }
 
   @Override
+  @SuppressWarnings("StringIsNotEmptyPredicate")
   public LongStream keys() {
     return lines()
-        .filter(line -> !line.isEmpty())
         .filter(line -> !line.equals("*"))
+        .filter(line -> !line.isEmpty())
         .mapToLong(Long::parseLong);
   }
 }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -90,6 +90,7 @@
 import com.github.benmanes.caffeine.cache.Policy.CacheEntry;
 import com.github.benmanes.caffeine.cache.References.InternalReference;
 import com.github.benmanes.caffeine.cache.stats.StatsCounter;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 import com.google.errorprone.annotations.concurrent.GuardedBy;
 
 /**
@@ -4396,6 +4397,7 @@ static final class FixedExpireAfterWrite<K, V> implements Expiry<K, V> {
           K key, V value, long currentTime, long currentDuration) {
         return unit.toNanos(duration);
       }
+      @CanIgnoreReturnValue
       @Override public long expireAfterRead(
           K key, V value, long currentTime, long currentDuration) {
         return currentDuration;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalCacheFactory.java
Patch:
@@ -123,7 +123,7 @@ final class MethodHandleBasedFactory implements LocalCacheFactory {
           constructor.type().changeReturnType(BoundedLocalCache.class));
     }
     @Override public <K, V> BoundedLocalCache<K, V> newInstance(Caffeine<K, V> builder,
-        AsyncCacheLoader<? super K, V> cacheLoader, boolean async) throws Throwable {
+        @Nullable AsyncCacheLoader<? super K, V> cacheLoader, boolean async) throws Throwable {
       return (BoundedLocalCache<K, V>) methodHandle.invokeExact(builder, cacheLoader, async);
     }
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/UnboundedLocalCache.java
Patch:
@@ -53,6 +53,7 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.cache.stats.StatsCounter;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 /**
  * An in-memory cache that has no capabilities for bounding the map. This implementation provides
@@ -109,6 +110,7 @@ public Expiry<K, V> expiry() {
   }
 
   @Override
+  @CanIgnoreReturnValue
   public Object referenceKey(K key) {
     return key;
   }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/RefreshAfterWriteTest.java
Patch:
@@ -70,6 +70,7 @@
 import com.github.valfirst.slf4jtest.TestLoggerFactory;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Maps;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 /**
  * The test cases for caches that support the refresh after write policy.
@@ -207,6 +208,7 @@ public void refreshIfNeeded_noChange(CacheContext context) {
       @Override public Int load(Int key) {
         throw new IllegalStateException();
       }
+      @CanIgnoreReturnValue
       @Override public Int reload(Int key, Int oldValue) {
         return oldValue;
       }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Issue298Test.java
Patch:
@@ -31,6 +31,7 @@
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.cache.Expiry;
 import com.github.benmanes.caffeine.cache.Policy.VarExpiration;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 /**
  * Issue #298: Stale data when using Expiry
@@ -124,10 +125,12 @@ private AsyncLoadingCache<String, String> makeAsyncCache() {
             await().untilTrue(doCreate);
             return EXPIRE_NS;
           }
+          @CanIgnoreReturnValue
           @Override public long expireAfterUpdate(String key, String value,
               long currentTime, long currentDuration) {
             return currentDuration;
           }
+          @CanIgnoreReturnValue
           @Override public long expireAfterRead(String key, String value,
               long currentTime, long currentDuration) {
             startedRead.set(true);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheSpec.java
Patch:
@@ -58,6 +58,7 @@
 import com.github.benmanes.caffeine.testing.Int;
 import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.testing.TestingExecutors;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 /**
  * The cache test specification so that a {@link org.testng.annotations.DataProvider} can construct
@@ -548,6 +549,7 @@ enum Loader implements CacheLoader<Int, Int> {
     },
     /** A bulk loader that tries to modify the keys. */
     BULK_MODIFY_KEYS {
+      @CanIgnoreReturnValue
       @Override public Int load(Int key) {
         return key;
       }

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/acceptance/ConcurrentHashMapAcceptanceTest.java
Patch:
@@ -35,6 +35,7 @@
  *
  * Ported from Eclipse Collections 11.0.
  */
+@SuppressWarnings("CanIgnoreReturnValueSuggester")
 public abstract class ConcurrentHashMapAcceptanceTest {
   private ExecutorService executor;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/mutable/ConcurrentHashMapTest.java
Patch:
@@ -43,7 +43,7 @@
  *
  * Ported from Eclipse Collections 11.0.
  */
-@SuppressWarnings({"all", "IdentityConversion", "unchecked"})
+@SuppressWarnings({"all", "CanIgnoreReturnValueSuggester", "IdentityConversion", "unchecked"})
 public abstract class ConcurrentHashMapTest extends ConcurrentHashMapTestCase {
   public static final MutableMap<Integer, MutableBag<Integer>> SMALL_BAG_MUTABLE_MAP =
       Interval.oneTo(100).groupBy(each -> each % 10).toMap(HashBag::new);

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/mutable/UnifiedMapTestCase.java
Patch:
@@ -43,8 +43,8 @@
 /**
  * Ported from Eclipse Collections 11.0.
  */
-@SuppressWarnings({"all", "deprecation", "EqualsBrokenForNull",
-  "EqualsUnsafeCast", "rawtypes", "unchecked", "UndefinedEquals"})
+@SuppressWarnings({"all", "CanIgnoreReturnValueSuggester", "deprecation",
+  "EqualsBrokenForNull", "EqualsUnsafeCast", "rawtypes", "unchecked", "UndefinedEquals"})
 public abstract class UnifiedMapTestCase extends MutableMapTestCase {
   protected static final Integer COLLISION_1 = 0;
   protected static final Integer COLLISION_2 = 17;

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/JSR166TestCase.java
Patch:
@@ -603,7 +603,7 @@ public static Test suite() {
     }
 
     /** Returns list of junit-style test method names in given class. */
-    public static ArrayList<String> testMethodNames(Class<?> testClass) {
+    public static List<String> testMethodNames(Class<?> testClass) {
         Method[] methods = testClass.getDeclaredMethods();
         ArrayList<String> names = new ArrayList<>(methods.length);
         for (Method method : methods) {

File: guava/src/test/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaTest.java
Patch:
@@ -41,6 +41,7 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.SettableFuture;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 import junit.framework.TestCase;
 
@@ -255,8 +256,8 @@ private static void checkBulkLoader(Exception error,
   enum IdentityLoader implements com.github.benmanes.caffeine.cache.CacheLoader<Object, Object> {
     INSTANCE;
 
-    @Override
-    public Object load(Object key) {
+    @CanIgnoreReturnValue
+    @Override public Object load(Object key) {
       return key;
     }
   }

File: guava/src/test/java/com/github/benmanes/caffeine/guava/PackageSanityTests.java
Patch:
@@ -18,6 +18,7 @@
 import com.github.benmanes.caffeine.cache.CacheLoader;
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.google.common.testing.AbstractPackageSanityTests;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 /**
  * Basic sanity tests for the entire package.
@@ -32,6 +33,7 @@ public PackageSanityTests() {
     setDefault(Caffeine.class, Caffeine.newBuilder());
     setDefault(com.google.common.cache.CacheLoader.class,
         new com.google.common.cache.CacheLoader<Object, Object>() {
+          @CanIgnoreReturnValue
           @Override public Object load(Object key) {
             return key;
           }

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheBuilderTest.java
Patch:
@@ -54,6 +54,7 @@
 import com.google.common.testing.NullPointerTester;
 import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.Uninterruptibles;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 import junit.framework.TestCase;
 
@@ -420,6 +421,7 @@ public void testRemovalNotification_clear() throws InterruptedException {
     final AtomicBoolean shouldWait = new AtomicBoolean(false);
     final CountDownLatch computingLatch = new CountDownLatch(1);
     CacheLoader<String, String> computingFunction = new CacheLoader<String, String>() {
+      @CanIgnoreReturnValue
       @Override public String load(String key) {
         if (shouldWait.get()) {
           assertTrue(Uninterruptibles.awaitUninterruptibly(computingLatch, 300, MINUTES));
@@ -642,6 +644,7 @@ static final class DelayingIdentityLoader<T> extends CacheLoader<T, T> {
       this.delayLatch = delayLatch;
     }
 
+    @CanIgnoreReturnValue
     @Override public T load(T key) {
       if (shouldWait.get()) {
         assertTrue(Uninterruptibles.awaitUninterruptibly(delayLatch, 300, SECONDS));

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/LocalLoadingCacheTest.java
Patch:
@@ -130,7 +130,6 @@ public void testStats() {
     assertEquals(3.0/4, stats.missRate());
     assertEquals(3, stats.loadCount());
     assertTrue(stats.totalLoadTime() >= totalLoadTime);
-    stats.totalLoadTime();
     assertTrue(stats.averageLoadPenalty() >= 0.0);
     assertEquals(1, stats.evictionCount());
   }

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/AbstractJCacheTest.java
Patch:
@@ -35,6 +35,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
 import com.google.common.testing.FakeTicker;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 /**
  * A testing harness for simplifying the unit tests.
@@ -118,6 +119,7 @@ protected CaffeineConfiguration<Integer, Integer> getLoadingConfiguration() {
   /** The cache loader used by the test. */
   protected CacheLoader<Integer, Integer> getCacheLoader() {
     return new CacheLoader<Integer, Integer>() {
+      @CanIgnoreReturnValue
       @Override public Integer load(Integer key) {
         return key;
       }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/Simulate.java
Patch:
@@ -135,6 +135,7 @@ public static void main(String[] args) {
         .execute(args);
   }
 
+  @SuppressWarnings("ImmutableEnumChecker")
   private enum Theme {
     light(ChartStyle.light()),
     dark(ChartStyle.dark());

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurator.java
Patch:
@@ -39,7 +39,6 @@
 import javax.cache.expiry.Duration;
 import javax.cache.expiry.EternalExpiryPolicy;
 import javax.cache.expiry.ExpiryPolicy;
-import javax.inject.Inject;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -50,6 +49,8 @@
 import com.typesafe.config.ConfigParseOptions;
 import com.typesafe.config.ConfigSyntax;
 
+import jakarta.inject.Inject;
+
 /**
  * Static utility methods pertaining to externalized {@link CaffeineConfiguration} entries using the
  * Typesafe Config library.

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/JCacheGuiceTest.java
Patch:
@@ -40,10 +40,11 @@
 import com.google.common.collect.Maps;
 import com.google.inject.AbstractModule;
 import com.google.inject.Guice;
-import com.google.inject.Inject;
 import com.google.inject.Injector;
 import com.google.inject.util.Modules;
 
+import jakarta.inject.Inject;
+
 /**
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalCacheFactory.java
Patch:
@@ -106,7 +106,7 @@ static LocalCacheFactory newFactory(String className) {
         return (LocalCacheFactory) LOOKUP
             .findStaticVarHandle(clazz, "FACTORY", LocalCacheFactory.class).get();
       } catch (NoSuchFieldException e) {
-        // Slow path when native hints are missing the field, but may have the constructor.
+        // Slow path when native hints are missing the field, but may have the constructor
         return new MethodHandleBasedFactory(clazz);
       }
     } catch (ClassNotFoundException | IllegalAccessException | NoSuchMethodException t) {

File: examples/graal-native/src/test/java/com/github/benmanes/caffeine/examples/graalnative/ApplicationTest.java
Patch:
@@ -22,10 +22,10 @@
 /**
  * @author ben.manes@gmail.com (Ben Manes)
  */
-final class ApplicationTest {
+public final class ApplicationTest {
 
   @Test
-  void hitRate() {
+  public void hitRate() {
     var app = new Application(500);
     app.run(1_000_000, 1_000);
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/mutable/SumProcedure.java
Patch:
@@ -23,7 +23,7 @@
  * @deprecated Don't use in new tests
  */
 @Deprecated
-@SuppressWarnings({"all", "unchecked"})
+@SuppressWarnings({"all", "overloads", "unchecked"})
 public class SumProcedure<T>
     implements Procedure<T>, Function2<Sum, T, Sum>, ProcedureFactory<SumProcedure<T>> {
   private static final long serialVersionUID = 1L;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheProxy.java
Patch:
@@ -101,7 +101,7 @@ public class CacheProxy<K, V> implements Cache<K, V> {
 
   private volatile boolean closed;
 
-  @SuppressWarnings("PMD.ExcessiveParameterList")
+  @SuppressWarnings({"PMD.ExcessiveParameterList", "this-escape"})
   public CacheProxy(String name, Executor executor, CacheManager cacheManager,
       CaffeineConfiguration<K, V> configuration,
       com.github.benmanes.caffeine.cache.Cache<K, Expirable<V>> cache,

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Expiry.java
Patch:
@@ -28,7 +28,7 @@ public interface Expiry<K, V> {
   /**
    * Specifies that the entry should be automatically removed from the cache once the duration has
    * elapsed after the entry's creation. To indicate no expiration an entry may be given an
-   * excessively long period, such as {@code Long#MAX_VALUE}.
+   * excessively long period, such as {@link Long#MAX_VALUE}.
    * <p>
    * <b>Note:</b> The {@code currentTime} is supplied by the configured {@link Ticker} and by
    * default does not relate to system or wall-clock time. When calculating the duration based on a
@@ -44,7 +44,7 @@ public interface Expiry<K, V> {
   /**
    * Specifies that the entry should be automatically removed from the cache once the duration has
    * elapsed after the replacement of its value. To indicate no expiration an entry may be given an
-   * excessively long period, such as {@code Long#MAX_VALUE}. The {@code currentDuration} may be
+   * excessively long period, such as {@link Long#MAX_VALUE}. The {@code currentDuration} may be
    * returned to not modify the expiration time.
    * <p>
    * <b>Note:</b> The {@code currentTime} is supplied by the configured {@link Ticker} and by
@@ -62,7 +62,7 @@ public interface Expiry<K, V> {
   /**
    * Specifies that the entry should be automatically removed from the cache once the duration has
    * elapsed after its last read. To indicate no expiration an entry may be given an excessively
-   * long period, such as {@code Long#MAX_VALUE}. The {@code currentDuration} may be returned to not
+   * long period, such as {@link Long#MAX_VALUE}. The {@code currentDuration} may be returned to not
    * modify the expiration time.
    * <p>
    * <b>Note:</b> The {@code currentTime} is supplied by the configured {@link Ticker} and by

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/MpscGrowableArrayQueue.java
Patch:
@@ -417,8 +417,7 @@ private E newBufferPeek(E[] nextBuffer, final long index) {
   private long newBufferAndOffset(E[] nextBuffer, final long index) {
     consumerBuffer = nextBuffer;
     consumerMask = (nextBuffer.length - 2L) << 1;
-    final long offsetInNew = modifiedCalcElementOffset(index, consumerMask);
-    return offsetInNew;
+    return modifiedCalcElementOffset(index, consumerMask);
   }
 
   @Override

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/SerializationProxy.java
Patch:
@@ -23,7 +23,7 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
- * Serializes the configuration of the cache, reconsitituting it as a {@link Cache},
+ * Serializes the configuration of the cache, reconstituting it as a {@link Cache},
  * {@link LoadingCache}, {@link AsyncCache}, or {@link AsyncLoadingCache} using {@link Caffeine}
  * upon deserialization. The data held by the cache is not retained.
  *

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsyncTest.java
Patch:
@@ -164,8 +164,7 @@ public Object[][] providesUnsuccessful() {
 
   private static AsyncExpiry<Integer, Integer> makeAsyncExpiry(
       long create, long update, long read) {
-    @SuppressWarnings("unchecked")
-    Expiry<Integer, Integer> mock = Mockito.mock(Expiry.class);
+    Expiry<Integer, Integer> mock = Mockito.mock();
     when(mock.expireAfterCreate(any(), any(), anyLong())).thenReturn(create);
     when(mock.expireAfterUpdate(any(), any(), anyLong(), anyLong())).thenReturn(update);
     when(mock.expireAfterRead(any(), any(), anyLong(), anyLong())).thenReturn(read);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheSpec.java
Patch:
@@ -270,8 +270,7 @@ enum CacheExpiry {
     },
     MOCKITO {
       @Override public <K, V> Expiry<K, V> createExpiry(Expire expiryTime) {
-        @SuppressWarnings("unchecked")
-        Expiry<K, V> mock = Mockito.mock(Expiry.class);
+        Expiry<K, V> mock = Mockito.mock();
         when(mock.expireAfterCreate(any(), any(), anyLong()))
             .thenReturn(expiryTime.timeNanos());
         when(mock.expireAfterUpdate(any(), any(), anyLong(), anyLong()))

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheValidationListener.java
Patch:
@@ -69,8 +69,8 @@
  */
 public final class CacheValidationListener implements ISuiteListener, IInvokedMethodListener {
   private static final Cache<Object, String> simpleNames = Caffeine.newBuilder().build();
-  private static final ITestContext testngContext = Mockito.mock(ITestContext.class);
   private static final AtomicBoolean detailedParams = new AtomicBoolean(false);
+  private static final ITestContext testngContext = Mockito.mock();
   private static final Object[] EMPTY_PARAMS = {};
 
   private final List<Collection<?>> resultQueues = new CopyOnWriteArrayList<>();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java
Patch:
@@ -673,9 +673,9 @@ static class BulkLoader<K, V> extends SingleLoader<K, V> {
     }
 
     @Override
-    @SuppressWarnings("unchecked")
     public Map<K, V> loadAll(Iterable<? extends K> keys) throws Exception {
       var keysToLoad = (keys instanceof Set) ? (Set<? extends K>) keys : ImmutableSet.copyOf(keys);
+      @SuppressWarnings("unchecked")
       var loaded = (Map<K, V>) delegate.loadAll(keysToLoad);
       return loaded;
     }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/ConfigSource.java
Patch:
@@ -30,7 +30,7 @@ public interface ConfigSource {
   /**
    * Returns a {@link Config} that provides the cache configurations.
    *
-   * @param uri a uri that may assist in resolve to the resource
+   * @param uri a uri that may assist in resolving the resource
    * @param classloader the classloader to load with
    * @return a configuration
    */

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/JCacheExpiryAndMaximumSizeTest.java
Patch:
@@ -50,7 +50,7 @@ public class JCacheExpiryAndMaximumSizeTest extends AbstractJCacheTest {
   private static final long ONE_MINUTE = TimeUnit.MINUTES.toNanos(1);
   private static final int MAXIMUM = 10;
 
-  private final Expiry<Integer, Integer> expiry = Mockito.mock(Expiry.class);
+  private final Expiry<Integer, Integer> expiry = Mockito.mock();
   private final AtomicInteger removed = new AtomicInteger();
 
   @BeforeMethod

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/JCacheExpiryTest.java
Patch:
@@ -42,7 +42,7 @@
 public final class JCacheExpiryTest extends AbstractJCacheTest {
   private static final long ONE_MINUTE = TimeUnit.MINUTES.toNanos(1);
 
-  private final Expiry<Integer, Integer> expiry = Mockito.mock(Expiry.class);
+  private final Expiry<Integer, Integer> expiry = Mockito.mock();
 
   @BeforeMethod
   public void setup() {

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/integration/CacheLoaderTest.java
Patch:
@@ -119,10 +119,9 @@ Object[] providesThrowables() {
     return new Object[] { new IllegalStateException(), new CacheLoaderException() };
   }
 
-  @SuppressWarnings("unchecked")
   @Override protected CaffeineConfiguration<Integer, Integer> getConfiguration() {
-    expiry = Mockito.mock(ExpiryPolicy.class, answer -> Duration.ZERO);
-    cacheLoader = Mockito.mock(CacheLoader.class);
+    expiry = Mockito.mock(answer -> Duration.ZERO);
+    cacheLoader = Mockito.mock();
 
     var configuration = new CaffeineConfiguration<Integer, Integer>();
     configuration.setExpiryPolicyFactory(() -> expiry);

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/integration/CacheWriterTest.java
Patch:
@@ -42,7 +42,7 @@
  */
 @Test(singleThreaded = true)
 public final class CacheWriterTest extends AbstractJCacheTest {
-  private CloseableCacheWriter writer = Mockito.mock(CloseableCacheWriter.class);
+  private CloseableCacheWriter writer = Mockito.mock();
 
   @Override
   protected CaffeineConfiguration<Integer, Integer> getConfiguration() {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/UnboundedLocalCache.java
Patch:
@@ -35,6 +35,7 @@
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
@@ -403,7 +404,7 @@ public void clear() {
       data.clear();
       return;
     }
-    for (K key : data.keySet()) {
+    for (K key : List.copyOf(data.keySet())) {
       remove(key);
     }
   }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Issue859Test.java
Patch:
@@ -45,7 +45,7 @@ public final class Issue859Test {
   private static final int NUMBER_OF_KEYS = 10;
 
   @Test
-  void scheduleIfPendingWrites() {
+  public void scheduleIfPendingWrites() {
     var runs = new ArrayList<TestRun>();
     for (int i = 1; i <= NUMBER_OF_RUNS; i++) {
       runs.add(runTest());

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/profiler/CacheProfiler.java
Patch:
@@ -19,6 +19,7 @@
 
 import com.github.benmanes.caffeine.cache.BasicCache;
 import com.github.benmanes.caffeine.cache.CacheType;
+
 import site.ycsb.generator.NumberGenerator;
 import site.ycsb.generator.ScrambledZipfianGenerator;
 
@@ -68,6 +69,7 @@ protected void profile() {
   }
 
   /** Spins forever reading from the cache. */
+  @SuppressWarnings("CheckReturnValue")
   private void reads() {
     int index = random.nextInt();
     for (;;) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncLoadingCache.java
Patch:
@@ -18,8 +18,6 @@
 import java.util.Map;
 import java.util.concurrent.CompletableFuture;
 
-import com.google.errorprone.annotations.CheckReturnValue;
-
 /**
  * A semi-persistent mapping from keys to values. Values are automatically loaded by the cache
  * asynchronously, and are stored in the cache until either evicted or manually invalidated.
@@ -88,6 +86,5 @@ public interface AsyncLoadingCache<K, V> extends AsyncCache<K, V> {
    * @return a thread-safe synchronous view of this cache
    */
   @Override
-  @CheckReturnValue
   LoadingCache<K, V> synchronous();
 }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheLoader.java
Patch:
@@ -26,8 +26,6 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import com.google.errorprone.annotations.CheckReturnValue;
-
 /**
  * Computes or retrieves values, based on a key, for use in populating a {@link LoadingCache} or
  * {@link AsyncLoadingCache}.
@@ -221,7 +219,6 @@ default CompletableFuture<? extends V> asyncReload(
    * @return a cache loader that delegates to the supplied {@code mappingFunction}
    * @throws NullPointerException if the mappingFunction is null
    */
-  @CheckReturnValue
   @SuppressWarnings("FunctionalInterfaceClash")
   static <K, V> CacheLoader<K, V> bulk(Function<? super Set<? extends K>,
       ? extends Map<? extends K, ? extends V>> mappingFunction) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/package-info.java
Patch:
@@ -34,6 +34,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@CheckReturnValue
 @DefaultQualifier(value = NonNull.class, locations = TypeUseLocation.FIELD)
 @DefaultQualifier(value = NonNull.class, locations = TypeUseLocation.PARAMETER)
 @DefaultQualifier(value = NonNull.class, locations = TypeUseLocation.RETURN)
@@ -42,3 +43,5 @@
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.framework.qual.DefaultQualifier;
 import org.checkerframework.framework.qual.TypeUseLocation;
+
+import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/CacheStats.java
Patch:
@@ -22,7 +22,6 @@
 
 import com.github.benmanes.caffeine.cache.Cache;
 import com.github.benmanes.caffeine.cache.LoadingCache;
-import com.google.errorprone.annotations.CheckReturnValue;
 import com.google.errorprone.annotations.Immutable;
 
 /**
@@ -296,7 +295,6 @@ public static CacheStats empty() {
    * @param other the statistics to subtract with
    * @return the difference between this instance and {@code other}
    */
-  @CheckReturnValue
   public CacheStats minus(CacheStats other) {
     return CacheStats.of(
         Math.max(0L, hitCount - other.hitCount),
@@ -319,7 +317,6 @@ public CacheStats minus(CacheStats other) {
    * @param other the statistics to add with
    * @return the sum of the statistics
    */
-  @CheckReturnValue
   public CacheStats plus(CacheStats other) {
     return CacheStats.of(
         saturatedAdd(hitCount, other.hitCount),

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/package-info.java
Patch:
@@ -19,6 +19,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@CheckReturnValue
 @DefaultQualifier(value = NonNull.class, locations = TypeUseLocation.FIELD)
 @DefaultQualifier(value = NonNull.class, locations = TypeUseLocation.PARAMETER)
 @DefaultQualifier(value = NonNull.class, locations = TypeUseLocation.RETURN)
@@ -27,3 +28,5 @@
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.framework.qual.DefaultQualifier;
 import org.checkerframework.framework.qual.TypeUseLocation;
+
+import com.google.errorprone.annotations.CheckReturnValue;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsyncLoadingCacheTest.java
Patch:
@@ -618,7 +618,6 @@ public void asyncReload() throws Exception {
     assertThat(future).succeedsWith(-1);
   }
 
-  @SuppressWarnings("CheckReturnValue")
   @Test(expectedExceptions = NullPointerException.class)
   public void bulk_function_null() {
     Function<Set<? extends Int>, Map<Int, Int>> f = null;
@@ -642,7 +641,6 @@ public void bulk_function_present() throws Exception {
     assertThat(loader.asyncLoad(Int.valueOf(1), Runnable::run)).succeedsWith(1);
   }
 
-  @SuppressWarnings("CheckReturnValue")
   @Test(expectedExceptions = NullPointerException.class)
   public void bulk_bifunction_null() {
     BiFunction<Set<? extends Int>, Executor, CompletableFuture<Map<Int, Int>>> f = null;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CaffeineTest.java
Patch:
@@ -50,7 +50,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@SuppressWarnings({"CheckReturnValue", "PreferJavaTimeOverload"})
+@SuppressWarnings("PreferJavaTimeOverload")
 public final class CaffeineTest {
   @Mock StatsCounter statsCounter;
   @Mock Expiry<Object, Object> expiry;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LoadingCacheTest.java
Patch:
@@ -1180,7 +1180,6 @@ public void asyncReload() throws Exception {
     assertThat(future).succeedsWith(-1);
   }
 
-  @SuppressWarnings("CheckReturnValue")
   @Test(expectedExceptions = NullPointerException.class)
   public void bulk_null() {
     CacheLoader.bulk(null);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/ExpiryBuilder.java
Patch:
@@ -20,7 +20,6 @@
 import java.io.Serializable;
 
 import com.github.benmanes.caffeine.cache.Expiry;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 /**
  * A builder for unit test convenience.
@@ -46,14 +45,12 @@ public static ExpiryBuilder expiringAfterCreate(long nanos) {
   }
 
   /** Sets the fixed update expiration time. */
-  @CanIgnoreReturnValue
   public ExpiryBuilder expiringAfterUpdate(long nanos) {
     updateNanos = nanos;
     return this;
   }
 
   /** Sets the fixed read expiration time. */
-  @CanIgnoreReturnValue
   public ExpiryBuilder expiringAfterRead(long nanos) {
     readNanos = nanos;
     return this;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java
Patch:
@@ -77,7 +77,6 @@ private GuavaCacheFromContext() {}
   private static final ThreadLocal<Throwable> error = new ThreadLocal<>();
 
   /** Returns a Guava-backed cache. */
-  @SuppressWarnings("CheckReturnValue")
   public static <K, V> Cache<K, V> newGuavaCache(CacheContext context) {
     checkState(!context.isAsync(), "Guava caches are synchronous only");
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/CaffeineMutableMapTestCase.java
Patch:
@@ -25,7 +25,6 @@
 import org.eclipse.collections.impl.map.mutable.MapAdapter;
 
 import com.github.benmanes.caffeine.cache.Cache;
-import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 /**
  * @author ben.manes@gmail.com (Ben Manes)
@@ -91,7 +90,6 @@ public ConcurrentMapAdapter(ConcurrentMap<K, V> delegate) {
     @Override public boolean replace(K key, V oldValue, V newValue) {
       return delegate.replace(key, oldValue, newValue);
     }
-    @CanIgnoreReturnValue
     @SuppressWarnings("FunctionalInterfaceClash")
     @Override public ConcurrentMutableMap<K, V> tap(Procedure<? super V> procedure) {
       each(procedure);

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaLoadingCache.java
Patch:
@@ -123,7 +123,7 @@ public V apply(K key) {
   }
 
   @Override
-  @SuppressWarnings("FutureReturnValueIgnored")
+  @SuppressWarnings({"CheckReturnValue", "FutureReturnValueIgnored"})
   public void refresh(K key) {
     cache.refresh(key);
   }

File: guava/src/main/java/com/github/benmanes/caffeine/guava/package-info.java
Patch:
@@ -19,6 +19,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@CheckReturnValue
 @DefaultQualifier(value = NonNull.class, locations = TypeUseLocation.FIELD)
 @DefaultQualifier(value = NonNull.class, locations = TypeUseLocation.PARAMETER)
 @DefaultQualifier(value = NonNull.class, locations = TypeUseLocation.RETURN)
@@ -27,3 +28,5 @@
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.framework.qual.DefaultQualifier;
 import org.checkerframework.framework.qual.TypeUseLocation;
+
+import com.google.errorprone.annotations.CheckReturnValue;

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheBuilderFactory.java
Patch:
@@ -36,7 +36,7 @@
  *
  * @author mike nonemacher
  */
-@SuppressWarnings("CanIgnoreReturnValueSuggester")
+@SuppressWarnings({"CanIgnoreReturnValueSuggester", "CheckReturnValue"})
 class CacheBuilderFactory {
   // Default values contain only 'null', which means don't call the CacheBuilder method (just give
   // the CacheBuilder default).

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheBuilderTest.java
Patch:
@@ -60,8 +60,8 @@
  * Unit tests for Caffeine.
  */
 @GwtCompatible(emulated = true)
-@SuppressWarnings(
-    {"CacheLoaderNull", "CanonicalDuration", "PreferJavaTimeOverload", "ThreadPriorityCheck"})
+@SuppressWarnings({"CacheLoaderNull", "CanonicalDuration",
+  "CheckReturnValue", "PreferJavaTimeOverload", "ThreadPriorityCheck"})
 public class CacheBuilderTest extends TestCase {
 
   public void testNewBuilder() {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheFactory.java
Patch:
@@ -126,6 +126,7 @@ private static <K, V> CaffeineConfiguration<K, V> resolveConfigurationFor(
   }
 
   /** A one-shot builder for creating a cache instance. */
+  @SuppressWarnings("CheckReturnValue")
   private static final class Builder<K, V> {
     final Ticker ticker;
     final String cacheName;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheProxy.java
Patch:
@@ -279,6 +279,7 @@ public void loadAll(Set<? extends K> keys, boolean replaceExistingValues,
   }
 
   /** Performs the bulk load where the existing entries are replaced. */
+  @SuppressWarnings("CheckReturnValue")
   private void loadAllAndReplaceExisting(Set<? extends K> keys) {
     Map<K, V> loaded = cacheLoader.orElseThrow().loadAll(keys);
     for (var entry : loaded.entrySet()) {
@@ -287,6 +288,7 @@ private void loadAllAndReplaceExisting(Set<? extends K> keys) {
   }
 
   /** Performs the bulk load where the existing entries are retained. */
+  @SuppressWarnings("CheckReturnValue")
   private void loadAllAndKeepExisting(Set<? extends K> keys) {
     List<K> keysToLoad = keys.stream()
         .filter(key -> !cache.asMap().containsKey(key))
@@ -1236,6 +1238,7 @@ public Cache.Entry<K, V> next() {
     }
 
     @Override
+    @SuppressWarnings("CheckReturnValue")
     public void remove() {
       if (current == null) {
         throw new IllegalStateException();

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/LoadingCacheProxy.java
Patch:
@@ -152,7 +152,7 @@ private Map<K, V> getAll(Set<? extends K> keys, boolean updateAccessTime) {
   }
 
   @Override
-  @SuppressWarnings("FutureReturnValueIgnored")
+  @SuppressWarnings({"CheckReturnValue", "FutureReturnValueIgnored"})
   public void loadAll(Set<? extends K> keys, boolean replaceExistingValues,
       CompletionListener completionListener) {
     requireNotClosed();

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurationTest.java
Patch:
@@ -72,6 +72,7 @@ public void illegalPath() {
     assertThat(TypesafeConfigurator.from(ConfigFactory.load(), "#")).isEmpty();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   @Test(expectedExceptions = IllegalStateException.class)
   public void invalidCache() {
     TypesafeConfigurator.from(ConfigFactory.load(), "invalid-cache");

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/copy/JavaSerializationCopierTest.java
Patch:
@@ -44,6 +44,7 @@
 /**
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("CheckReturnValue")
 public final class JavaSerializationCopierTest {
 
   @Test(dataProvider = "nullArgs", expectedExceptions = NullPointerException.class)

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/CountMin4.java
Patch:
@@ -126,6 +126,7 @@ void regularIncrement(long e) {
   }
 
   /** Increments the associated counters that are at the observed minimum. */
+  @SuppressWarnings("CheckReturnValue")
   void conservativeIncrement(long e) {
     int hash = spread(Long.hashCode(e));
     int start = (hash & 3) << 2;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/HashFunctionParser.java
Patch:
@@ -15,6 +15,8 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.admission.tinycache;
 
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+
 /**
  * This is a hash function and parser tp simplify parsing the hash value, it split it to . This
  * class provide hash utilities, and parse the items.
@@ -39,6 +41,7 @@ public HashFunctionParser(int nrSets) {
     fpaux = new HashedItem(fpMask, fpMask, fpMask, 0L);
   }
 
+  @CanIgnoreReturnValue
   public HashedItem createHash(long item) {
     long h = (Seed64 ^ m);
     item *= m;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinyCache.java
Patch:
@@ -17,6 +17,8 @@
 
 import java.util.Random;
 
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+
 /**
  * This is the TinyCache model that takes advantage of random eviction policy with a ghost cache as
  * admission policy. It offers a very dense memory layout combined with (relative) speed at the
@@ -72,6 +74,7 @@ public boolean contains(long item) {
    * Implementing add and remove together in one function means that fewer items are shifted
    * (reduction of 3 times from the trivial implementation).
    */
+  @CanIgnoreReturnValue
   private int replace(HashedItem fpaux, byte victim, int bucketStart, int removedOffset) {
     byte chainId = fpaux.chainId;
     fpaux.chainId = victim;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinyCacheSketch.java
Patch:
@@ -17,6 +17,8 @@
 
 import java.util.Random;
 
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+
 /**
  * This is the TinyCache sketch that is based on TinySet and TinyTable. It is adopted for fast
  * operation and bounded memory footprint. When a set is full, a victim is selected at random from
@@ -74,6 +76,7 @@ public int countItem(long item) {
    * Implementing add and remove together in one function means that fewer items are shifted
    * (reduction of 3 times from the trivial implementation).
    */
+  @CanIgnoreReturnValue
   private int replace(HashedItem fpaux, byte victim, int bucketStart, int removedOffset) {
     byte chainId = fpaux.chainId;
     fpaux.chainId = victim;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinyCacheWithGhostCache.java
Patch:
@@ -17,6 +17,8 @@
 
 import java.util.Random;
 
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+
 /**
  * This is the TinyCache model that takes advantage of random eviction policy with a ghost cache as
  * admission policy. It offers a very dense memory layout combined with (relative) speed at the
@@ -76,6 +78,7 @@ public boolean contains(long item) {
    * Implementing add and remove together in one function means that fewer items are shifted
    * (reduction of 3 times from the trivial implementation).
    */
+  @CanIgnoreReturnValue
   private int replace(HashedItem fpaux, byte victim, int bucketStart, int removedOffset) {
     byte chainId = fpaux.chainId;
     fpaux.chainId = victim;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinySetIndexing.java
Patch:
@@ -15,6 +15,8 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.admission.tinycache;
 
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+
 /**
  * An implementation of TinySet's indexing method. A method to index a succinct hash table that is
  * only 2 bits from theoretical lower bound. This is only the indexing technique, and it helps
@@ -52,6 +54,7 @@ public int rank(long index, int bitNum) {
     return Long.bitCount(index & ~(-1L << bitNum));
   }
 
+  @CanIgnoreReturnValue
   public int getChain(HashedItem fpaux, long[] chainIndex, long[] isLastIndex) {
     int requiredChainNumber = rank(chainIndex[fpaux.set], fpaux.chainId);
     int currentChainNumber = rank(isLastIndex[fpaux.set], requiredChainNumber);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/membership/Membership.java
Patch:
@@ -15,6 +15,8 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.membership;
 
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+
 /**
  * A probabilistic set for testing the membership of an element.
  *
@@ -41,6 +43,7 @@ public interface Membership {
    * @param e the element to add
    * @return if the membership changed as a result of this operation
    */
+  @CanIgnoreReturnValue
   boolean put(long e);
 
   /** Returns an instance that contains nothing. */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/ClockProSimplePolicy.java
Patch:
@@ -197,6 +197,7 @@ private void onNonResidentMiss(Node node) {
     evict();
   }
 
+  @SuppressWarnings("CheckReturnValue")
   private void evict() {
     policyStats.recordEviction();
     while (maxSize < sizeCold + sizeHot) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/CaffeinePolicy.java
Patch:
@@ -40,6 +40,7 @@ public final class CaffeinePolicy implements Policy {
   private final Cache<Long, AccessEvent> cache;
   private final PolicyStats policyStats;
 
+  @SuppressWarnings("CheckReturnValue")
   public CaffeinePolicy(Config config, Set<Characteristic> characteristics) {
     policyStats = new PolicyStats(name());
     BasicSettings settings = new BasicSettings(config);

File: simulator/src/test/java/com/github/benmanes/caffeine/cache/simulator/admission/bloom/MembershipTest.java
Patch:
@@ -81,7 +81,7 @@ public void bloomFilterTest(FilterType filterType) {
   public void caffeine_ensureCapacity(int expectedInsertions, double fpp) {
     BloomFilter filter = new BloomFilter();
     filter.ensureCapacity(expectedInsertions, fpp);
-    filter.put(-1);
+    assertThat(filter.put(-1)).isTrue();
   }
 
   @DataProvider(name = "ensureCapacity")

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncLoadingCache.java
Patch:
@@ -217,7 +217,7 @@ public CompletableFuture<Map<K, V>> refreshAll(Iterable<? extends K> keys) {
       @SuppressWarnings("unchecked")
       var lastRefresh = (CompletableFuture<V>) asyncCache.cache().refreshes().get(keyReference);
       if (lastRefresh != null) {
-        if (Async.isReady(lastRefresh)) {
+        if (Async.isReady(lastRefresh) || asyncCache.cache().isPendingEviction(key)) {
           asyncCache.cache().refreshes().remove(keyReference, lastRefresh);
         } else {
           return lastRefresh;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalLoadingCache.java
Patch:
@@ -106,7 +106,7 @@ default CompletableFuture<V> refresh(K key) {
     Object keyReference = cache().referenceKey(key);
 
     var future = cache().refreshes().compute(keyReference, (k, existing) -> {
-      if ((existing != null) && !Async.isReady(existing)) {
+      if ((existing != null) && !Async.isReady(existing) && !cache().isPendingEviction(key)) {
         return existing;
       }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncCache.java
Patch:
@@ -160,7 +160,7 @@ default CompletableFuture<Map<K, V>> getAll(Iterable<? extends K> keys,
    */
   static <K, V> CompletableFuture<Map<K, V>> composeResult(Map<K, CompletableFuture<V>> futures) {
     if (futures.isEmpty()) {
-      return CompletableFuture.completedFuture(Map.of());
+      return CompletableFuture.completedFuture(Collections.unmodifiableMap(Collections.emptyMap()));
     }
     @SuppressWarnings("rawtypes")
     CompletableFuture<?>[] array = futures.values().toArray(new CompletableFuture[0]);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContext.java
Patch:
@@ -224,7 +224,9 @@ public Int lastKey() {
   }
 
   public ImmutableSet<Int> firstMiddleLastKeys() {
-    return ImmutableSet.of(firstKey(), middleKey(), lastKey());
+    return (firstKey == null)
+        ? ImmutableSet.of()
+        : ImmutableSet.of(firstKey(), middleKey(), lastKey());
   }
 
   public void cleanUp() {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java
Patch:
@@ -470,7 +470,7 @@ final class GuavaPolicy implements Policy<K, V> {
         return new GuavaCacheEntry<>(key, value, snapshotAt);
       }
       @Override public Map<K, CompletableFuture<V>> refreshes() {
-        return Map.of();
+        return Collections.unmodifiableMap(Collections.emptyMap());
       }
       @Override public Optional<Eviction<K, V>> eviction() {
         return Optional.empty();
@@ -568,7 +568,8 @@ public CompletableFuture<Map<K, V>> refreshAll(Iterable<? extends K> keys) {
 
     CompletableFuture<Map<K, V>> composeResult(Map<K, CompletableFuture<V>> futures) {
       if (futures.isEmpty()) {
-        return CompletableFuture.completedFuture(Map.of());
+        return CompletableFuture.completedFuture(
+            Collections.unmodifiableMap(Collections.emptyMap()));
       }
       @SuppressWarnings("rawtypes")
       CompletableFuture<?>[] array = futures.values().toArray(new CompletableFuture[0]);

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/ConcurrentHashMapV7.java
Patch:
@@ -113,8 +113,8 @@
  * @param <K> the type of keys maintained by this map
  * @param <V> the type of mapped values
  */
-@SuppressWarnings({"all", "deprecation", "JdkObsolete", "rawtypes", "serial",
-  "unchecked", "UnnecessaryParentheses", "UnusedNestedClass", "UnusedVariable"})
+@SuppressWarnings({"all", "deprecation", "JdkObsolete", "rawtypes", "serial", "unchecked",
+  "UnnecessaryParentheses", "UnusedNestedClass", "UnusedVariable", "YodaCondition"})
 public class ConcurrentHashMapV7<K, V> extends AbstractMap<K, V>
         implements ConcurrentMap<K, V>, Serializable {
     private static final long serialVersionUID = 7249069246763182397L;

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/mutable/MapIterableTestCase.java
Patch:
@@ -91,7 +91,7 @@
  * Ported from Eclipse Collections 11.0.
  */
 @SuppressWarnings({"all", "deprecation", "IdentityConversion",
-  "IsInstanceIncompatibleType", "PreferredInterfaceType", "unchecked"})
+  "IsInstanceIncompatibleType", "PreferredInterfaceType", "unchecked", "YodaCondition"})
 public abstract class MapIterableTestCase {
   protected abstract <K, V> MapIterable<K, V> newMap();
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/Collection8Test.java
Patch:
@@ -46,9 +46,9 @@
  * Contains tests applicable to all jdk8+ Collection implementations.
  * An extension of CollectionTest.
  */
-@SuppressWarnings({"CatchAndPrintStackTrace", "CollectorMutability", "MethodReferenceUsage",
-  "MissingDefault", "MissingFail", "rawtypes", "ReturnValueIgnored", "try", "unchecked",
-  "UnnecessaryParentheses"})
+@SuppressWarnings({"CatchAndPrintStackTrace", "CollectorMutability", "LabelledBreakTarget",
+  "MethodReferenceUsage", "MissingDefault", "MissingFail", "rawtypes", "ReturnValueIgnored",
+  "try", "unchecked", "UnnecessaryParentheses", "YodaCondition"})
 public class Collection8Test extends JSR166TestCase {
     final CollectionImplementation impl;
 

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaCache.java
Patch:
@@ -46,6 +46,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("serial")
 class CaffeinatedGuavaCache<K, V> implements Cache<K, V>, Serializable {
   private static final long serialVersionUID = 1L;
 
@@ -151,7 +152,6 @@ public void cleanUp() {
     cache.cleanUp();
   }
 
-  @SuppressWarnings("NullAway.Init")
   final class AsMapView extends ForwardingConcurrentMap<K, V> {
     @Nullable EntrySetView entrySet;
     @Nullable KeySetView keySet;

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaLoadingCache.java
Patch:
@@ -42,6 +42,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("serial")
 final class CaffeinatedGuavaLoadingCache<K, V>
     extends CaffeinatedGuavaCache<K, V> implements LoadingCache<K, V> {
   private static final ThreadLocal<Boolean> nullBulkLoad =

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaCache.java
Patch:
@@ -46,7 +46,6 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@SuppressWarnings("serial")
 class CaffeinatedGuavaCache<K, V> implements Cache<K, V>, Serializable {
   private static final long serialVersionUID = 1L;
 
@@ -152,6 +151,7 @@ public void cleanUp() {
     cache.cleanUp();
   }
 
+  @SuppressWarnings("NullAway.Init")
   final class AsMapView extends ForwardingConcurrentMap<K, V> {
     @Nullable EntrySetView entrySet;
     @Nullable KeySetView keySet;

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaLoadingCache.java
Patch:
@@ -42,7 +42,6 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@SuppressWarnings("serial")
 final class CaffeinatedGuavaLoadingCache<K, V>
     extends CaffeinatedGuavaCache<K, V> implements LoadingCache<K, V> {
   private static final ThreadLocal<Boolean> nullBulkLoad =
@@ -129,6 +128,8 @@ public void refresh(K key) {
   }
 
   abstract static class CaffeinatedLoader<K, V> implements CacheLoader<K, V>, Serializable {
+    private static final long serialVersionUID = 1L;
+
     final com.google.common.cache.CacheLoader<K, V> cacheLoader;
 
     CaffeinatedLoader(com.google.common.cache.CacheLoader<K, V> cacheLoader) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalManualCache.java
Patch:
@@ -95,7 +95,6 @@ default Map<K, V> getAll(Iterable<? extends K> keys,
    * Performs a non-blocking bulk load of the missing keys. Any missing entry that materializes
    * during the load are replaced when the loaded entries are inserted into the cache.
    */
-  @SuppressWarnings("CatchingUnchecked")
   default void bulkLoad(Set<K> keysToLoad, Map<K, V> result,
       Function<? super Set<? extends K>, ? extends Map<? extends K, ? extends V>> mappingFunction) {
     boolean success = false;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurator.java
Patch:
@@ -255,7 +255,6 @@ public void addLazyExpiration() {
       boolean eternal = Objects.equals(creation, Duration.ETERNAL)
           && Objects.equals(update, Duration.ETERNAL)
           && Objects.equals(access, Duration.ETERNAL);
-      @SuppressWarnings("NullAway")
       Factory<? extends ExpiryPolicy> factory = eternal
           ? EternalExpiryPolicy.factoryOf()
           : FactoryBuilder.factoryOf(new JCacheExpiryPolicy(creation, update, access));

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/EventTypeAwareListener.java
Patch:
@@ -63,7 +63,7 @@ public boolean isCompatible(EventType eventType) {
   }
 
   /** Processes the event and logs if an exception is thrown. */
-  @SuppressWarnings({"CatchingUnchecked", "PMD.SwitchStmtsShouldHaveDefault"})
+  @SuppressWarnings("PMD.SwitchStmtsShouldHaveDefault")
   public void dispatch(JCacheEntryEvent<K, V> event) {
     try {
       if (event.getSource().isClosed()) {
@@ -84,7 +84,7 @@ public void dispatch(JCacheEntryEvent<K, V> event) {
           return;
       }
       throw new IllegalStateException("Unknown event type: " + event.getEventType());
-    } catch (Exception e) {
+    } catch (RuntimeException e) {
       logger.log(Level.WARNING, "", e);
     } catch (Throwable t) {
       logger.log(Level.ERROR, "", t);

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/integration/JCacheLoaderAdapter.java
Patch:
@@ -124,7 +124,6 @@ public Map<K, Expirable<V>> loadAll(Set<? extends K> keys) {
     }
   }
 
-  @SuppressWarnings("CatchingUnchecked")
   private long expireTimeMS() {
     try {
       Duration duration = expiry.getExpiryForCreation();
@@ -135,7 +134,7 @@ private long expireTimeMS() {
       }
       long millis = TimeUnit.NANOSECONDS.toMillis(ticker.read());
       return duration.getAdjustedTime(millis);
-    } catch (Exception e) {
+    } catch (RuntimeException e) {
       logger.log(Level.WARNING, "Exception thrown by expiry policy", e);
       throw e;
     }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/EvictionTest.java
Patch:
@@ -834,7 +834,7 @@ public void maximumSize_decrease_negative(Cache<Int, Int> cache,
   }
 
   @Test(dataProvider = "caches")
-  @CacheSpec(maximumSize = Maximum.FULL, removalListener = { Listener.DISABLED, Listener.REJECTING })
+  @CacheSpec(maximumSize = Maximum.FULL, removalListener = {Listener.DISABLED, Listener.REJECTING})
   public void maximumSize_increase(Cache<Int, Int> cache,
       CacheContext context, Eviction<Int, Int> eviction) {
     eviction.setMaximum(2 * context.maximumWeightOrSize());

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterVarTest.java
Patch:
@@ -1031,7 +1031,8 @@ public void compute_error(Cache<Int, Int> cache,
   }
 
   @Test(dataProvider = "caches")
-  @CacheSpec(expiry = CacheExpiry.MOCKITO, removalListener = {Listener.DISABLED, Listener.REJECTING})
+  @CacheSpec(expiry = CacheExpiry.MOCKITO,
+      removalListener = {Listener.DISABLED, Listener.REJECTING})
   public void compute_absent_nullValue(Cache<Int, Int> cache,
       CacheContext context, VarExpiration<Int, Int> expireAfterVar) {
     Int result = expireAfterVar.compute(context.absentKey(),

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LoadingCacheTest.java
Patch:
@@ -560,9 +560,8 @@ public void refresh_absent_null(LoadingCache<Int, Int> cache, CacheContext conte
 
   @CheckNoEvictions
   @Test(dataProvider = "caches")
-  @CacheSpec(
-      maximumSize = Maximum.UNREACHABLE,
-      removalListener = { Listener.DISABLED, Listener.REJECTING }, population = Population.SINGLETON)
+  @CacheSpec(population = Population.SINGLETON, maximumSize = Maximum.UNREACHABLE,
+      removalListener = { Listener.DISABLED, Listener.REJECTING })
   public void refresh_absent(LoadingCache<Int, Int> cache, CacheContext context) {
     Int key = context.absentKey();
     var future = cache.refresh(key);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LocalCacheSubject.java
Patch:
@@ -251,7 +251,8 @@ private void checkEvictionDeque(BoundedLocalCache<Object, Object> bounded) {
       var deques = new ImmutableTable.Builder<String, Long, LinkedDeque<Node<Object, Object>>>()
           .put("window", bounded.windowWeightedSize(), bounded.accessOrderWindowDeque())
           .put("probation", mainProbation, bounded.accessOrderProbationDeque())
-          .put("protected", bounded.mainProtectedWeightedSize(), bounded.accessOrderProtectedDeque())
+          .put("protected", bounded.mainProtectedWeightedSize(),
+              bounded.accessOrderProtectedDeque())
           .build();
       checkLinks(bounded, deques);
       check("accessOrderWindowDeque()").about(deque())

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/Stresser.java
Patch:
@@ -133,7 +133,8 @@ private void status() {
         local.readBuffer.size(), pendingWrites);
     System.out.printf(US, "Drain status = %s (%s)%n", STATUS[drainStatus], drainStatus);
     System.out.printf(US, "Evictions = %,d%n", cache.stats().evictionCount());
-    System.out.printf(US, "Size = %,d (max: %,d)%n", local.data.mappingCount(), workload.maxEntries);
+    System.out.printf(US, "Size = %,d (max: %,d)%n",
+        local.data.mappingCount(), workload.maxEntries);
     System.out.printf(US, "Lock = [%s%n", StringUtils.substringAfter(
         local.evictionLock.toString(), "["));
     System.out.printf(US, "Pending reloads = %,d%n", local.refreshes.size());

File: examples/coalescing-bulkloader/src/main/java/com/github/benmanes/caffeine/examples/coalescing/bulkloader/CoalescingBulkloader.java
Patch:
@@ -187,7 +187,8 @@ public CompletableFuture<Value> asyncLoad(Key key, Executor executor) {
   }
 
   private void startWaiting() {
-    ScheduledFuture<?> oldSchedule = schedule.getAndSet(timer.schedule(this::doLoad, maxDelay, MILLISECONDS));
+    ScheduledFuture<?> oldSchedule = schedule.getAndSet(
+        timer.schedule(this::doLoad, maxDelay, MILLISECONDS));
     if (oldSchedule != null) {
       oldSchedule.cancel(false);
     }

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/NodeRule.java
Patch:
@@ -20,6 +20,7 @@
 import static com.github.benmanes.caffeine.cache.Specifications.kTypeVar;
 import static com.github.benmanes.caffeine.cache.Specifications.vTypeVar;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Locale.US;
 import static org.apache.commons.lang3.StringUtils.capitalize;
 
 import java.lang.invoke.VarHandle;
@@ -135,11 +136,11 @@ protected final MethodSpec newGetter(Strength strength, TypeName varType,
         .returns(varType);
     if (strength == Strength.STRONG) {
       if (visibility == Visibility.PLAIN) {
-        var template = String.format("return (%s) $L.get(this)",
+        var template = String.format(US, "return (%s) $L.get(this)",
             varType.isPrimitive() ? "$L" : "$T");
         getter.addStatement(template, varType, varHandleName(varName));
       } else if (visibility == Visibility.OPAQUE) {
-        var template = String.format("return (%s) $L.getOpaque(this)",
+        var template = String.format(US, "return (%s) $L.getOpaque(this)",
             varType.isPrimitive() ? "$L" : "$T");
         getter.addStatement(template, varType, varHandleName(varName));
       } else if (visibility == Visibility.VOLATILE) {

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/profiler/ProfilerHook.java
Patch:
@@ -15,6 +15,8 @@
  */
 package com.github.benmanes.caffeine.profiler;
 
+import static java.util.Locale.US;
+
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.LongAdder;
@@ -50,7 +52,7 @@ private void scheduleStatusTask() {
     Executors.newSingleThreadScheduledExecutor().scheduleWithFixedDelay(() -> {
       long count = calls.longValue();
       long rate = count / stopwatch.elapsed(TimeUnit.SECONDS);
-      System.out.printf("%s - %,d [%,d / sec]%n", stopwatch, count, rate);
+      System.out.printf(US, "%s - %,d [%,d / sec]%n", stopwatch, count, rate);
     }, DISPLAY_DELAY_SEC, DISPLAY_DELAY_SEC, TimeUnit.SECONDS);
   }
 }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -179,7 +179,7 @@ private Caffeine() {}
   @FormatMethod
   static void requireArgument(boolean expression, String template, @Nullable Object... args) {
     if (!expression) {
-      throw new IllegalArgumentException(String.format(template, args));
+      throw new IllegalArgumentException(String.format(US, template, args));
     }
   }
 
@@ -201,7 +201,7 @@ static void requireState(boolean expression) {
   @FormatMethod
   static void requireState(boolean expression, String template, @Nullable Object... args) {
     if (!expression) {
-      throw new IllegalStateException(String.format(template, args));
+      throw new IllegalStateException(String.format(US, template, args));
     }
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Node.java
Patch:
@@ -15,6 +15,8 @@
  */
 package com.github.benmanes.caffeine.cache;
 
+import static java.util.Locale.US;
+
 import java.lang.ref.ReferenceQueue;
 
 import org.checkerframework.checker.index.qual.NonNegative;
@@ -278,7 +280,7 @@ public void setNextInWriteOrder(@Nullable Node<K, V> next) {
   @Override
   @SuppressWarnings("GuardedBy")
   public final String toString() {
-    return String.format("%s=[key=%s, value=%s, weight=%d, queueType=%,d, accessTimeNS=%,d, "
+    return String.format(US, "%s=[key=%s, value=%s, weight=%d, queueType=%,d, accessTimeNS=%,d, "
         + "writeTimeNS=%,d, varTimeNs=%,d, prevInAccess=%s, nextInAccess=%s, prevInWrite=%s, "
         + "nextInWrite=%s]", getClass().getSimpleName(), getKey(), getValue(), getWeight(),
         getQueueType(), getAccessTime(), getWriteTime(), getVariableTime(),

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/TimerWheelTest.java
Patch:
@@ -20,6 +20,7 @@
 import static com.google.common.collect.ImmutableList.toImmutableList;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth.assertWithMessage;
+import static java.util.Locale.US;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.Mockito.doThrow;
@@ -304,7 +305,7 @@ private void checkTimerWheel(long duration) {
       for (int j = 0; j < timerWheel.wheel[i].length; j++) {
         for (long timer : getTimers(timerWheel.wheel[i][j])) {
           if (timer <= duration) {
-            throw new AssertionError(String.format("wheel[%s][%d] by %ss", i, j,
+            throw new AssertionError(String.format(US, "wheel[%s][%d] by %ss", i, j,
                 TimeUnit.NANOSECONDS.toSeconds(duration - timer)));
           }
         }
@@ -570,7 +571,7 @@ private void printTimerWheel() {
       }
       builder.append(" - Wheel #").append(i + 1).append(": ").append(buckets).append('\n');
     }
-    System.err.printf("%nCurrent state:%n%s%n%n", builder.deleteCharAt(builder.length() - 1));
+    System.err.printf(US, "%nCurrent state:%n%s%n%n", builder.deleteCharAt(builder.length() - 1));
   }
 
   private static final class Timer extends Node<Long, Long> {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Issue30Test.java
Patch:
@@ -19,6 +19,7 @@
 import static com.github.benmanes.caffeine.testing.FutureSubject.future;
 import static com.google.common.truth.Truth.assertWithMessage;
 import static java.time.ZoneOffset.UTC;
+import static java.util.Locale.US;
 
 import java.time.Duration;
 import java.time.Instant;
@@ -147,7 +148,8 @@ private static FutureSubject assertThat(String message, CompletableFuture<?> act
   }
 
   static final class Loader implements AsyncCacheLoader<String, String> {
-    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("hh:MM:ss.SSS");
+    private static final DateTimeFormatter FORMATTER =
+        DateTimeFormatter.ofPattern("hh:MM:ss.SSS", US);
 
     final ConcurrentMap<String, String> source;
     final ConcurrentMap<String, Instant> lastLoad;

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/Threads.java
Patch:
@@ -17,6 +17,7 @@
 
 import static com.google.common.collect.ImmutableList.toImmutableList;
 import static com.google.common.truth.Truth.assertThat;
+import static java.util.Locale.US;
 import static org.testng.Assert.fail;
 
 import java.util.ArrayList;
@@ -142,7 +143,7 @@ public void run() {
         try {
           operation.accept(collection, e);
         } catch (Throwable t) {
-          failures.add(String.format("Failed: key %s on operation %s%n%s",
+          failures.add(String.format(US, "Failed: key %s on operation %s%n%s",
               e, operation, Throwables.getStackTraceAsString(t)));
           throw t;
         }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/Expirable.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.github.benmanes.caffeine.jcache;
 
+import static java.util.Locale.US;
 import static java.util.Objects.requireNonNull;
 
 /**
@@ -59,7 +60,7 @@ public boolean isEternal() {
 
   @Override
   public String toString() {
-    return String.format("%s{value=%s, expireTimeMS=%,d}",
+    return String.format(US, "%s{value=%s, expireTimeMS=%,d}",
         getClass().getSimpleName(), value, expireTimeMS);
   }
 }

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/CacheManagerTest.java
Patch:
@@ -16,6 +16,7 @@
 package com.github.benmanes.caffeine.jcache;
 
 import static com.google.common.truth.Truth.assertThat;
+import static java.util.Locale.US;
 
 import java.lang.management.ManagementFactory;
 import java.util.function.Supplier;
@@ -73,7 +74,7 @@ private void checkConfigurationJmx(Supplier<Cache<?, ?>> cacheSupplier)
 
     String name = "javax.cache:Cache=%s,CacheManager=%s,type=CacheStatistics";
     ManagementFactory.getPlatformMBeanServer().getObjectInstance(
-        new ObjectName(String.format(name, cache.getName(), PROVIDER_NAME)));
+        new ObjectName(String.format(US, name, cache.getName(), PROVIDER_NAME)));
   }
 
   @Test

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/JCacheProfiler.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.github.benmanes.caffeine.jcache;
 
+import static java.util.Locale.US;
 import static java.util.Objects.requireNonNull;
 
 import java.util.Random;
@@ -85,7 +86,7 @@ private void scheduleStatusTask() {
     Executors.newSingleThreadScheduledExecutor().scheduleWithFixedDelay(() -> {
       long count = this.count.longValue();
       long rate = count / stopwatch.elapsed(TimeUnit.SECONDS);
-      System.out.printf("%s - %,d [%,d / sec]%n", stopwatch, count, rate);
+      System.out.printf(US, "%s - %,d [%,d / sec]%n", stopwatch, count, rate);
     }, 5, 5, TimeUnit.SECONDS);
   }
 

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/copy/JavaSerializationCopierTest.java
Patch:
@@ -16,6 +16,7 @@
 package com.github.benmanes.caffeine.jcache.copy;
 
 import static com.google.common.truth.Truth.assertThat;
+import static java.util.Locale.US;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -29,6 +30,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.TimeZone;
 import java.util.function.Function;
 
 import javax.cache.CacheException;
@@ -113,7 +115,7 @@ public void deepCopy_date(Copier copier) {
   @Test(dataProvider = "copier")
   @SuppressWarnings({"JavaUtilDate", "JdkObsolete"})
   public void deepCopy_calendar(Copier copier) {
-    Calendar calendar = Calendar.getInstance();
+    Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone("UTC"), US);
     calendar.setTime(new Date());
     assertThat(copy(copier, calendar)).isEqualTo(calendar);
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/BasicSettings.java
Patch:
@@ -58,13 +58,13 @@ public int randomSeed() {
 
   public Set<String> policies() {
     return config().getStringList("policies").stream()
-        .map(String::toLowerCase)
+        .map(policy -> policy.toLowerCase(US))
         .collect(toImmutableSet());
   }
 
   public Set<Admission> admission() {
     return config().getStringList("admission").stream()
-        .map(String::toUpperCase)
+        .map(policy -> policy.toUpperCase(US))
         .map(Admission::valueOf)
         .collect(toImmutableEnumSet());
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/PolicyStats.java
Patch:
@@ -19,6 +19,7 @@
 import static com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats.Metric.MetricType.NUMBER;
 import static com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats.Metric.MetricType.OBJECT;
 import static com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats.Metric.MetricType.PERCENT;
+import static java.util.Locale.US;
 import static java.util.Objects.requireNonNull;
 import static org.apache.commons.lang3.builder.ToStringStyle.MULTI_LINE_STYLE;
 
@@ -62,7 +63,7 @@ public class PolicyStats {
   @SuppressWarnings("AnnotateFormatMethod")
   public PolicyStats(String format, Object... args) {
     this.stopwatch = Stopwatch.createUnstarted();
-    this.name = String.format(format, args);
+    this.name = String.format(US, format, args);
     this.metrics = new LinkedHashMap<>();
 
     addMetric(Metric.of("Policy", (Supplier<String>) this::name, OBJECT, true));

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/feedback/FeedbackWindowTinyLfuPolicy.java
Patch:
@@ -16,6 +16,7 @@
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch.feedback;
 
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Locale.US;
 import static java.util.stream.Collectors.toUnmodifiableSet;
 
 import java.util.List;
@@ -295,7 +296,7 @@ private boolean adapt(Node candidate) {
 
   void printSegmentSizes() {
     if (debug) {
-      System.out.printf("maxWindow=%d, maxProtected=%d, percentWindow=%.1f%n",
+      System.out.printf(US, "maxWindow=%d, maxProtected=%d, percentWindow=%.1f%n",
           maxWindow, maxProtected, (double) (100 * maxWindow) / maximumSize);
     }
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/csv/CombinedCsvReport.java
Patch:
@@ -16,10 +16,10 @@
 package com.github.benmanes.caffeine.cache.simulator.report.csv;
 
 import static com.google.common.collect.ImmutableList.toImmutableList;
+import static java.util.Locale.US;
 
 import java.nio.file.Path;
 import java.text.NumberFormat;
-import java.util.Locale;
 import java.util.Map;
 import java.util.TreeMap;
 import java.util.stream.Stream;
@@ -58,7 +58,7 @@ public final class CombinedCsvReport implements Runnable {
   public void run() {
     normalize();
     writeReport(tabulate());
-    System.out.printf("Wrote combined report to %s%n", outputFile);
+    System.out.printf(US, "Wrote combined report to %s%n", outputFile);
   }
 
   /** Normalizes the input parameters. */
@@ -85,7 +85,7 @@ private void writeReport(Table<String, Long, String> table) {
         .parseAllRecords(inputFiles.values().iterator().next().toFile()).stream()
         .map(record -> record.getString("Policy"))
         .collect(toImmutableList());
-    var formatter = NumberFormat.getInstance(Locale.US);
+    var formatter = NumberFormat.getInstance(US);
     var headers = Stream
         .concat(Stream.of("Policy"), inputFiles.keySet().stream().map(formatter::format))
         .toArray(String[]::new);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/csv/PlotCsv.java
Patch:
@@ -90,7 +90,7 @@ public void run() {
 
     try {
       ChartUtils.saveChartAsPNG(outputFile.toFile(), chart, 1280, 720);
-      System.out.printf("Wrote chart to %s%n", outputFile);
+      System.out.printf(US, "Wrote chart to %s%n", outputFile);
     } catch (IOException e) {
       throw new UncheckedIOException(e);
     }
@@ -225,7 +225,7 @@ static final class ChartStyleConverter implements ITypeConverter<ChartStyle> {
           return ChartStyle.forColors(background, content, grid);
         }
         default:
-          throw new TypeConversionException(String.format(
+          throw new TypeConversionException(String.format(US,
               "expected one of %s (case-insensitive) but was '%s'",
               List.of("light", "dark"), value));
       }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsMapTest.java
Patch:
@@ -34,6 +34,7 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
+import static uk.org.lidalia.slf4jext.Level.WARN;
 
 import java.util.AbstractMap;
 import java.util.Arrays;
@@ -66,6 +67,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Listener;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Population;
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
+import com.github.benmanes.caffeine.cache.testing.CheckMaxLogLevel;
 import com.github.benmanes.caffeine.cache.testing.CheckNoEvictions;
 import com.github.benmanes.caffeine.cache.testing.CheckNoStats;
 import com.github.benmanes.caffeine.testing.ConcurrentTestHarness;
@@ -81,7 +83,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@CheckNoEvictions
+@CheckNoEvictions @CheckMaxLogLevel(WARN)
 @Listeners(CacheValidationListener.class)
 @Test(dataProviderClass = CacheProvider.class)
 public final class AsMapTest {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsyncAsMapTest.java
Patch:
@@ -34,6 +34,7 @@
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
+import static uk.org.lidalia.slf4jext.Level.WARN;
 
 import java.util.AbstractMap;
 import java.util.Arrays;
@@ -64,6 +65,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Listener;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Population;
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
+import com.github.benmanes.caffeine.cache.testing.CheckMaxLogLevel;
 import com.github.benmanes.caffeine.cache.testing.CheckNoEvictions;
 import com.github.benmanes.caffeine.cache.testing.CheckNoStats;
 import com.github.benmanes.caffeine.testing.Int;
@@ -77,7 +79,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@CheckNoEvictions
+@CheckNoEvictions @CheckMaxLogLevel(WARN)
 @Listeners(CacheValidationListener.class)
 @Test(dataProviderClass = CacheProvider.class)
 public final class AsyncAsMapTest {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsyncCacheTest.java
Patch:
@@ -29,6 +29,7 @@
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
+import static uk.org.lidalia.slf4jext.Level.WARN;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -57,6 +58,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Listener;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Population;
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
+import com.github.benmanes.caffeine.cache.testing.CheckMaxLogLevel;
 import com.github.benmanes.caffeine.cache.testing.CheckNoEvictions;
 import com.github.benmanes.caffeine.cache.testing.CheckNoStats;
 import com.github.benmanes.caffeine.testing.Int;
@@ -69,7 +71,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@CheckNoEvictions
+@CheckNoEvictions @CheckMaxLogLevel(WARN)
 @Listeners(CacheValidationListener.class)
 @Test(dataProviderClass = CacheProvider.class)
 @SuppressWarnings("FutureReturnValueIgnored")

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsyncLoadingCacheTest.java
Patch:
@@ -25,6 +25,7 @@
 import static com.google.common.collect.ImmutableMap.toImmutableMap;
 import static com.google.common.truth.Truth.assertThat;
 import static java.util.function.Function.identity;
+import static uk.org.lidalia.slf4jext.Level.WARN;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -56,6 +57,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Loader;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Population;
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
+import com.github.benmanes.caffeine.cache.testing.CheckMaxLogLevel;
 import com.github.benmanes.caffeine.cache.testing.CheckNoEvictions;
 import com.github.benmanes.caffeine.cache.testing.CheckNoStats;
 import com.github.benmanes.caffeine.testing.Int;
@@ -69,7 +71,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@CheckNoEvictions
+@CheckNoEvictions @CheckMaxLogLevel(WARN)
 @Listeners(CacheValidationListener.class)
 @Test(dataProviderClass = CacheProvider.class)
 @SuppressWarnings({"FutureReturnValueIgnored", "PreferJavaTimeOverload"})

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/EvictionTest.java
Patch:
@@ -35,6 +35,7 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
+import static uk.org.lidalia.slf4jext.Level.WARN;
 
 import java.util.ConcurrentModificationException;
 import java.util.HashMap;
@@ -62,6 +63,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Maximum;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Population;
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
+import com.github.benmanes.caffeine.cache.testing.CheckMaxLogLevel;
 import com.github.benmanes.caffeine.cache.testing.CheckNoStats;
 import com.github.benmanes.caffeine.cache.testing.RemovalListeners.RejectingRemovalListener;
 import com.github.benmanes.caffeine.testing.Int;
@@ -74,6 +76,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@CheckMaxLogLevel(WARN)
 @Listeners(CacheValidationListener.class)
 @Test(dataProviderClass = CacheProvider.class)
 public final class EvictionTest {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpirationTest.java
Patch:
@@ -39,6 +39,7 @@
 import static org.mockito.Mockito.verifyNoInteractions;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
+import static uk.org.lidalia.slf4jext.Level.WARN;
 
 import java.time.Duration;
 import java.util.ArrayList;
@@ -68,6 +69,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Maximum;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Population;
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
+import com.github.benmanes.caffeine.cache.testing.CheckMaxLogLevel;
 import com.github.benmanes.caffeine.cache.testing.CheckNoStats;
 import com.github.benmanes.caffeine.testing.Int;
 import com.google.common.base.Splitter;
@@ -80,6 +82,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@CheckMaxLogLevel(WARN)
 @Listeners(CacheValidationListener.class)
 @SuppressWarnings("PreferJavaTimeOverload")
 @Test(dataProviderClass = CacheProvider.class)

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterAccessTest.java
Patch:
@@ -27,6 +27,7 @@
 import static com.google.common.collect.ImmutableMap.toImmutableMap;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth8.assertThat;
+import static uk.org.lidalia.slf4jext.Level.WARN;
 
 import java.time.Duration;
 import java.time.temporal.ChronoUnit;
@@ -51,6 +52,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Loader;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Population;
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
+import com.github.benmanes.caffeine.cache.testing.CheckMaxLogLevel;
 import com.github.benmanes.caffeine.cache.testing.CheckNoStats;
 import com.github.benmanes.caffeine.cache.testing.ExpireAfterAccess;
 import com.github.benmanes.caffeine.testing.Int;
@@ -62,6 +64,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@CheckMaxLogLevel(WARN)
 @Listeners(CacheValidationListener.class)
 @SuppressWarnings("PreferJavaTimeOverload")
 @Test(dataProviderClass = CacheProvider.class)

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterVarTest.java
Patch:
@@ -41,6 +41,7 @@
 import static org.mockito.Mockito.verifyNoInteractions;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 import static org.mockito.Mockito.when;
+import static uk.org.lidalia.slf4jext.Level.WARN;
 
 import java.time.Duration;
 import java.time.temporal.ChronoUnit;
@@ -68,6 +69,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Loader;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Population;
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
+import com.github.benmanes.caffeine.cache.testing.CheckMaxLogLevel;
 import com.github.benmanes.caffeine.cache.testing.CheckNoEvictions;
 import com.github.benmanes.caffeine.cache.testing.CheckNoStats;
 import com.github.benmanes.caffeine.testing.ConcurrentTestHarness;
@@ -79,6 +81,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@CheckMaxLogLevel(WARN)
 @Listeners(CacheValidationListener.class)
 @SuppressWarnings("PreferJavaTimeOverload")
 @Test(dataProviderClass = CacheProvider.class)

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterWriteTest.java
Patch:
@@ -27,6 +27,7 @@
 import static com.google.common.collect.ImmutableMap.toImmutableMap;
 import static com.google.common.truth.Truth.assertThat;
 import static com.google.common.truth.Truth8.assertThat;
+import static uk.org.lidalia.slf4jext.Level.WARN;
 
 import java.time.Duration;
 import java.time.temporal.ChronoUnit;
@@ -50,6 +51,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Loader;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Population;
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
+import com.github.benmanes.caffeine.cache.testing.CheckMaxLogLevel;
 import com.github.benmanes.caffeine.cache.testing.CheckNoStats;
 import com.github.benmanes.caffeine.cache.testing.ExpireAfterWrite;
 import com.github.benmanes.caffeine.testing.Int;
@@ -61,6 +63,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@CheckMaxLogLevel(WARN)
 @Listeners(CacheValidationListener.class)
 @SuppressWarnings("PreferJavaTimeOverload")
 @Test(dataProviderClass = CacheProvider.class)

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/MultiThreadedTest.java
Patch:
@@ -17,6 +17,7 @@
 
 import static com.google.common.base.Preconditions.checkState;
 import static java.util.function.Function.identity;
+import static uk.org.lidalia.slf4jext.Level.WARN;
 
 import java.util.List;
 import java.util.Map;
@@ -38,6 +39,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.ReferenceType;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Stats;
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
+import com.github.benmanes.caffeine.cache.testing.CheckMaxLogLevel;
 import com.github.benmanes.caffeine.testing.Int;
 import com.github.benmanes.caffeine.testing.Threads;
 import com.google.common.testing.SerializableTester;
@@ -47,6 +49,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@CheckMaxLogLevel(WARN)
 @Listeners(CacheValidationListener.class)
 @Test(groups = "isolated", dataProviderClass = CacheProvider.class)
 public final class MultiThreadedTest {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ReferenceTest.java
Patch:
@@ -35,6 +35,7 @@
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
+import static uk.org.lidalia.slf4jext.Level.WARN;
 
 import java.util.AbstractMap;
 import java.util.AbstractMap.SimpleEntry;
@@ -70,6 +71,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.ReferenceType;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Stats;
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
+import com.github.benmanes.caffeine.cache.testing.CheckMaxLogLevel;
 import com.github.benmanes.caffeine.cache.testing.CheckNoStats;
 import com.github.benmanes.caffeine.testing.Int;
 import com.google.common.base.Splitter;
@@ -82,6 +84,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@CheckMaxLogLevel(WARN)
 @Listeners(CacheValidationListener.class)
 @Test(groups = "slow", dataProviderClass = CacheProvider.class)
 public final class ReferenceTest {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/RefreshAfterWriteTest.java
Patch:
@@ -62,6 +62,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Loader;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Population;
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
+import com.github.benmanes.caffeine.cache.testing.CheckMaxLogLevel;
 import com.github.benmanes.caffeine.cache.testing.CheckNoEvictions;
 import com.github.benmanes.caffeine.testing.ConcurrentTestHarness;
 import com.github.benmanes.caffeine.testing.Int;
@@ -74,6 +75,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@CheckMaxLogLevel(WARN)
 @Listeners(CacheValidationListener.class)
 @SuppressWarnings("PreferJavaTimeOverload")
 @Test(dataProviderClass = CacheProvider.class)

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/UnboundedLocalCacheTest.java
Patch:
@@ -16,6 +16,7 @@
 package com.github.benmanes.caffeine.cache;
 
 import static com.google.common.truth.Truth8.assertThat;
+import static uk.org.lidalia.slf4jext.Level.TRACE;
 
 import org.testng.annotations.Listeners;
 import org.testng.annotations.Test;
@@ -29,12 +30,14 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Population;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.ReferenceType;
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
+import com.github.benmanes.caffeine.cache.testing.CheckMaxLogLevel;
 
 /**
  * The test cases for the implementation details of {@link UnboundedLocalCache}.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@CheckMaxLogLevel(TRACE)
 @Listeners(CacheValidationListener.class)
 @Test(dataProviderClass = CacheProvider.class)
 public final class UnboundedLocalCacheTest {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheGenerator.java
Patch:
@@ -179,7 +179,7 @@ private boolean isCompatible(CacheContext context) {
     boolean asyncLoaderIncompatible = context.isAsyncLoader()
         && (!context.isAsync() || !context.isLoading());
     boolean refreshIncompatible = context.refreshes() && !context.isLoading();
-    boolean weigherIncompatible = context.isUnbounded() && context.isWeighted();
+    boolean weigherIncompatible = (context.maximum() == Maximum.DISABLED) && context.isWeighted();
     boolean referenceIncompatible = cacheSpec.requiresWeakOrSoft()
         && context.isStrongKeys() && context.isStrongValues();
     boolean expiryIncompatible = (context.expiryType() != CacheExpiry.DISABLED)

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/local/LocalCacheRule.java
Patch:
@@ -18,6 +18,8 @@
 import java.util.function.Consumer;
 
 /**
+ * A code generation rule for a cache.
+ *
  * @author ben.manes@gmail.com (Ben Manes)
  */
 public abstract class LocalCacheRule implements Consumer<LocalCacheContext> {
@@ -34,7 +36,7 @@ public void accept(LocalCacheContext context) {
     }
   }
 
-  /** @return if the rule should be executed. */
+  /** Returns if the rule should be executed. */
   protected abstract boolean applies();
 
   protected abstract void execute();

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/NodeRule.java
Patch:
@@ -58,7 +58,7 @@ public final void accept(NodeContext context) {
     }
   }
 
-  /** @return if the rule should be executed. */
+  /** Returns if the rule should be executed. */
   protected abstract boolean applies();
 
   protected abstract void execute();

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/BasicCache.java
Patch:
@@ -22,7 +22,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public interface BasicCache<K extends Object, V extends Object> {
+public interface BasicCache<K, V> {
 
   /** Returns the value stored in the cache, or null if not present. */
   @Nullable V get(K key);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncCache.java
Patch:
@@ -39,7 +39,7 @@
  * @param <K> the type of keys maintained by this cache
  * @param <V> the type of mapped values
  */
-public interface AsyncCache<K extends Object, V extends Object> {
+public interface AsyncCache<K, V> {
 
   /**
    * Returns the future associated with {@code key} in this cache, or {@code null} if there is no

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncLoadingCache.java
Patch:
@@ -31,7 +31,7 @@
  * @param <K> the type of keys maintained by this cache
  * @param <V> the type of mapped values
  */
-public interface AsyncLoadingCache<K extends Object, V extends Object> extends AsyncCache<K, V> {
+public interface AsyncLoadingCache<K, V> extends AsyncCache<K, V> {
 
   /**
    * Returns the future associated with {@code key} in this cache, obtaining that value from

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Cache.java
Patch:
@@ -39,7 +39,7 @@
  * @param <K> the type of keys maintained by this cache
  * @param <V> the type of mapped values
  */
-public interface Cache<K extends Object, V extends Object> {
+public interface Cache<K, V> {
 
   /**
    * Returns the value associated with the {@code key} in this cache, or {@code null} if there is no

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheLoader.java
Patch:
@@ -45,7 +45,7 @@
  */
 @FunctionalInterface
 @SuppressWarnings({"FunctionalInterfaceMethodChanged", "PMD.SignatureDeclareThrowsException"})
-public interface CacheLoader<K extends Object, V extends Object> extends AsyncCacheLoader<K, V> {
+public interface CacheLoader<K, V> extends AsyncCacheLoader<K, V> {
 
   /**
    * Computes or retrieves the value corresponding to {@code key}.
@@ -223,8 +223,8 @@ default CompletableFuture<? extends V> asyncReload(
    */
   @CheckReturnValue
   @SuppressWarnings("FunctionalInterfaceClash")
-  static <K extends Object, V extends Object> CacheLoader<K, V> bulk(
-      Function<? super Set<? extends K>, ? extends Map<? extends K, ? extends V>> mappingFunction) {
+  static <K, V> CacheLoader<K, V> bulk(Function<? super Set<? extends K>,
+      ? extends Map<? extends K, ? extends V>> mappingFunction) {
     requireNonNull(mappingFunction);
     return new CacheLoader<K, V>() {
       @Override public @Nullable V load(K key) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -138,7 +138,7 @@
  *     normally {@code Object} unless it is constrained by using a method like {@code
  *     #removalListener}
  */
-public final class Caffeine<K extends Object, V extends Object> {
+public final class Caffeine<K, V> {
   static final Supplier<StatsCounter> ENABLED_STATS_COUNTER_SUPPLIER = ConcurrentStatsCounter::new;
   static final Logger logger = System.getLogger(Caffeine.class.getName());
   static final double DEFAULT_LOAD_FACTOR = 0.75;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Expiry.java
Patch:
@@ -23,7 +23,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public interface Expiry<K extends Object, V extends Object> {
+public interface Expiry<K, V> {
 
   /**
    * Specifies that the entry should be automatically removed from the cache once the duration has

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/FrequencySketch.java
Patch:
@@ -124,7 +124,7 @@ public int frequency(E e) {
     int block = (blockHash & blockMask) << 3;
     for (int i = 0; i < 4; i++) {
       int h = counterHash >>> (i << 3);
-      int index = (h >> 1) & 15;
+      int index = (h >>> 1) & 15;
       int offset = h & 1;
       count[i] = (int) ((table[block + offset + (i << 1)] >>> (index << 2)) & 0xfL);
     }
@@ -150,7 +150,7 @@ public void increment(E e) {
     int block = (blockHash & blockMask) << 3;
     for (int i = 0; i < 4; i++) {
       int h = counterHash >>> (i << 3);
-      index[i] = (h >> 1) & 15;
+      index[i] = (h >>> 1) & 15;
       int offset = h & 1;
       index[i + 4] = block + offset + (i << 1);
     }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Interner.java
Patch:
@@ -35,7 +35,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @FunctionalInterface
-public interface Interner<E extends Object> {
+public interface Interner<E> {
 
   /**
    * Chooses and returns the representative instance for any of a collection of instances that are

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LoadingCache.java
Patch:
@@ -30,7 +30,7 @@
  * @param <K> the type of keys maintained by this cache
  * @param <V> the type of mapped values
  */
-public interface LoadingCache<K extends Object, V extends Object> extends Cache<K, V> {
+public interface LoadingCache<K, V> extends Cache<K, V> {
 
   /**
    * Returns the value associated with the {@code key} in this cache, obtaining that value from

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/RemovalListener.java
Patch:
@@ -33,7 +33,7 @@
  *        {@code Object} if any value is acceptable
  */
 @FunctionalInterface
-public interface RemovalListener<K extends Object, V extends Object> {
+public interface RemovalListener<K, V> {
 
   /**
    * Notifies the listener that a removal occurred at some point in the past.

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Weigher.java
Patch:
@@ -31,7 +31,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @FunctionalInterface
-public interface Weigher<K extends Object, V extends Object> {
+public interface Weigher<K, V> {
 
   /**
    * Returns the weight of a cache entry. There is no unit for entry weights; rather they are simply

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -209,7 +209,7 @@ public void scheduleDrainBuffers() {
       assertThat(cache.drainStatus).isEqualTo(end);
 
       if (!start.equals(end)) {
-        Mockito.verify(executor).execute(any());
+        verify(executor).execute(any());
         Mockito.reset(executor);
       }
     });

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/MultiThreadedTest.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache;
 
+import static com.google.common.base.Preconditions.checkState;
 import static java.util.function.Function.identity;
 
 import java.util.List;
@@ -39,7 +40,6 @@
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
 import com.github.benmanes.caffeine.testing.Int;
 import com.github.benmanes.caffeine.testing.Threads;
-import com.google.common.base.Preconditions;
 import com.google.common.testing.SerializableTester;
 
 /**
@@ -117,15 +117,15 @@ public void async_concurrent_bounded(
           cache.invalidateAll();
         }
       },
-      (cache, key) -> { Preconditions.checkState(cache.estimatedSize() >= 0); },
+      (cache, key) -> { checkState(cache.estimatedSize() >= 0); },
       (cache, key) -> { cache.stats(); },
       (cache, key) -> { cache.cleanUp(); },
 
       // Map
       (cache, key) -> { cache.asMap().containsKey(key); },
       (cache, key) -> { cache.asMap().containsValue(key); },
       (cache, key) -> { cache.asMap().isEmpty(); },
-      (cache, key) -> { Preconditions.checkState(cache.asMap().size() >= 0); },
+      (cache, key) -> { checkState(cache.asMap().size() >= 0); },
       (cache, key) -> { cache.asMap().get(key); },
       (cache, key) -> { cache.asMap().put(key, key); },
       (cache, key) -> { cache.asMap().putAll(Map.of(key, key)); },

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/TimerWheelTest.java
Patch:
@@ -22,6 +22,7 @@
 import static com.google.common.truth.Truth.assertWithMessage;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyLong;
+import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoInteractions;
@@ -45,7 +46,6 @@
 import org.mockito.ArgumentCaptor;
 import org.mockito.Captor;
 import org.mockito.Mock;
-import org.mockito.Mockito;
 import org.mockito.MockitoAnnotations;
 import org.testng.Assert;
 import org.testng.ITestResult;
@@ -165,7 +165,7 @@ public void advance_backwards(long clock) {
 
   @Test
   public void advance_exception() {
-    Mockito.doThrow(new IllegalStateException())
+    doThrow(new IllegalStateException())
         .when(cache).evictEntry(captor.capture(), any(), anyLong());
     var timer = new Timer(timerWheel.nanos + SPANS[1]);
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContextSubject.java
Patch:
@@ -147,7 +147,7 @@ private void checkBasic(CacheEntry<Int, Int> entry) {
     try {
       entry.setValue(entry.getValue());
       failWithActual("setValue", entry);
-    } catch (UnsupportedOperationException expected) {}
+    } catch (UnsupportedOperationException expected) { /* ignored */ }
   }
 
   private void checkWeight(CacheEntry<Int, Int> entry) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/CollectionSubject.java
Patch:
@@ -109,10 +109,10 @@ private void checkQueue(Queue<?> queue) {
     check("peek()").that(queue.peek()).isNull();
     try {
       failWithActual("remove()", queue.remove());
-    } catch (NoSuchElementException expected) {}
+    } catch (NoSuchElementException expected) { /* ignored */ }
     try {
       failWithActual("element()", queue.element());
-    } catch (NoSuchElementException expected) {}
+    } catch (NoSuchElementException expected) { /* ignored */ }
   }
 
   private void checkDeque(Deque<?> deque) {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheProxy.java
Patch:
@@ -764,7 +764,7 @@ public <C extends Configuration<K, V>> C getConfiguration(Class<C> clazz) {
         + " is not supported by this implementation");
   }
 
-  /** @return the cache's configuration */
+  /** Returns the cache's configuration. */
   public CaffeineConfiguration<K, V> getConfiguration() {
     return configuration;
   }
@@ -1142,12 +1142,12 @@ protected final Map<K, V> copyMap(Map<K, Expirable<V>> map) {
         entry -> copier.copy(entry.getValue().get(), classLoader)));
   }
 
-  /** @return the current time in milliseconds */
+  /** Returns the current time in milliseconds. */
   protected final long currentTimeMillis() {
     return nanosToMillis(ticker.read());
   }
 
-  /** @return the nanosecond time in milliseconds */
+  /** Returns the nanosecond time in milliseconds. */
   protected static long nanosToMillis(long nanos) {
     return TimeUnit.NANOSECONDS.toMillis(nanos);
   }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/CaffeineConfiguration.java
Patch:
@@ -179,7 +179,7 @@ public void setCacheLoaderFactory(Factory<? extends CacheLoader<K, V>> factory)
     return delegate.getCacheWriterFactory();
   }
 
-  /** @return a writer created by the configured factory or null if not set. */
+  /** Returns a writer created by the configured factory or null if not set. */
   public @Nullable CacheWriter<K , V> getCacheWriter() {
     if (hasCacheWriter()) {
       @SuppressWarnings("unchecked")
@@ -189,7 +189,7 @@ public void setCacheLoaderFactory(Factory<? extends CacheLoader<K, V>> factory)
     return null;
   }
 
-  /** @return if the cache writer factory is specified. */
+  /** Returns if the cache writer factory is specified. */
   public boolean hasCacheWriter() {
     return getCacheWriterFactory() != null;
   }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/copy/AbstractCopier.java
Patch:
@@ -68,12 +68,12 @@ protected AbstractCopier(Set<Class<?>> immutableClasses,
     this.deepCopyStrategies = requireNonNull(deepCopyStrategies);
   }
 
-  /** @return the set of Java native classes that are immutable */
+  /** Returns the set of Java native classes that are immutable. */
   public static Set<Class<?>> javaImmutableClasses() {
     return JAVA_IMMUTABLE;
   }
 
-  /** @return the set of Java native classes that are deeply copied. */
+  /** Returns the set of Java native classes that are deeply copied. */
   public static Map<Class<?>, Function<Object, Object>> javaDeepCopyStrategies() {
     return JAVA_DEEP_COPY;
   }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/copy/Copier.java
Patch:
@@ -34,7 +34,7 @@ public interface Copier {
    */
   <T> T copy(T object, ClassLoader classLoader);
 
-  /** @return a copy strategy that performs an identity function, for use by store-by-reference */
+  /** Return a copy strategy that performs an identity function, for use by store-by-reference. */
   static Copier identity() {
     return IdentityCopier.INSTANCE;
   }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/Registration.java
Patch:
@@ -39,17 +39,17 @@ public Registration(CacheEntryListenerConfiguration<K, V> configuration,
     this.filter = requireNonNull(filter);
   }
 
-  /** @return the configuration */
+  /** Returns the configuration. */
   public CacheEntryListenerConfiguration<K, V> getConfiguration() {
     return configuration;
   }
 
-  /** @return the registered listener */
+  /** Returns the registered listener. */
   public EventTypeAwareListener<K, V> getCacheEntryListener() {
     return listener;
   }
 
-  /** @return the registered filter */
+  /** Returns the registered filter. */
   public CacheEntryEventFilter<K, V> getCacheEntryFilter() {
     return filter;
   }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/management/JCacheStatisticsMXBean.java
Patch:
@@ -39,7 +39,7 @@ public final class JCacheStatisticsMXBean implements CacheStatisticsMXBean {
 
   private volatile boolean enabled;
 
-  /** @return if statistic collection is enabled. */
+  /** Returns if statistic collection is enabled. */
   public boolean isEnabled() {
     return enabled;
   }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/processor/EntryProcessorEntry.java
Patch:
@@ -90,7 +90,7 @@ public void setValue(V value) {
     this.value = value;
   }
 
-  /** @return the dominant action performed by the processor on the entry. */
+  /** Returns the dominant action performed by the processor on the entry. */
   public Action getAction() {
     return action;
   }

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/event/EventDispatcherTest.java
Patch:
@@ -355,7 +355,7 @@ private void registerAll(EventDispatcher<Integer, Integer> dispatcher) {
   private static final class ConsumingCacheListener implements
       CacheEntryCreatedListener<Integer, Integer>,  CacheEntryUpdatedListener<Integer, Integer>,
       CacheEntryRemovedListener<Integer, Integer>, CacheEntryExpiredListener<Integer, Integer> {
-    Queue<CacheEntryEvent<?, ? >> queue = new ConcurrentLinkedQueue<>();
+    Queue<CacheEntryEvent<?, ?>> queue = new ConcurrentLinkedQueue<>();
 
     @Override
     public void onCreated(Iterable<CacheEntryEvent<? extends Integer, ? extends Integer>> events) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/Indicator.java
Patch:
@@ -82,7 +82,7 @@ public double getIndicator() {
     return (getHint() * (skew < 1 ? 1 - Math.pow(skew, 3) : 0)) / 15.0;
   }
 
-  private static class Hinter {
+  private static final class Hinter {
     int sum;
     int count;
     int[] freq = new int[16];
@@ -103,7 +103,7 @@ public double getAverage() {
     }
   }
 
-  private class EstSkew {
+  private final class EstSkew {
     StreamSummary<Long> stream;
 
     public EstSkew() {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -667,7 +667,7 @@ public void evict_retired_candidate(BoundedLocalCache<Int, Int> cache, CacheCont
       cache.evictEntries();
 
       assertThat(expected.isDead()).isTrue();
-      assertThat(cache).hasSize(cache.maximum());
+      await().untilAsserted(() -> assertThat(cache).hasSize(cache.maximum()));
     } finally {
       cache.evictionLock.unlock();
     }
@@ -691,7 +691,7 @@ public void evict_retired_victim(BoundedLocalCache<Int, Int> cache, CacheContext
       cache.evictEntries();
 
       assertThat(expected.isDead()).isTrue();
-      assertThat(cache).hasSize(cache.maximum());
+      await().untilAsserted(() -> assertThat(cache).hasSize(cache.maximum()));
     } finally {
       cache.evictionLock.unlock();
     }

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/Feature.java
Patch:
@@ -15,8 +15,9 @@
  */
 package com.github.benmanes.caffeine.cache;
 
+import static java.util.stream.Collectors.joining;
+
 import java.util.Set;
-import java.util.stream.Collectors;
 
 import com.google.common.base.CaseFormat;
 import com.google.common.collect.ImmutableSet;
@@ -58,7 +59,7 @@ public static String makeEnumName(String enumName) {
   public static String makeClassName(Iterable<Feature> features) {
     String enumName = Streams.stream(features)
         .map(Feature::name)
-        .collect(Collectors.joining("_"));
+        .collect(joining("_"));
     return CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.UPPER_CAMEL, enumName);
   }
 

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/local/AddFastPath.java
Patch:
@@ -39,7 +39,7 @@ protected void execute() {
     boolean fastpath = Feature.usesFastPath(Sets.union(
         context.parentFeatures, context.generateFeatures));
     context.cache.addMethod(MethodSpec.methodBuilder("fastpath")
-        .addStatement("return " + Boolean.toString(fastpath))
+        .addStatement("return " + fastpath)
         .addModifiers(Modifier.PROTECTED)
         .returns(boolean.class)
         .build());

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/local/Finalize.java
Patch:
@@ -32,7 +32,9 @@ protected boolean applies() {
   @Override
   protected void execute() {
     if (!context.suppressedWarnings.isEmpty()) {
-      var format = "{" + StringUtils.repeat("$S", ", ", context.suppressedWarnings.size()) + "}";
+      var format = (context.suppressedWarnings.size() == 1)
+          ? "$S"
+          : "{" + StringUtils.repeat("$S", ", ", context.suppressedWarnings.size()) + "}";
       context.cache.addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
           .addMember("value", format, context.suppressedWarnings.toArray())
           .build());

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/Finalize.java
Patch:
@@ -38,7 +38,9 @@ protected boolean applies() {
   @Override
   protected void execute() {
     if (!context.suppressedWarnings.isEmpty()) {
-      var format = "{" + StringUtils.repeat("$S", ", ", context.suppressedWarnings.size()) + "}";
+      var format = (context.suppressedWarnings.size() == 1)
+          ? "$S"
+          : "{" + StringUtils.repeat("$S", ", ", context.suppressedWarnings.size()) + "}";
       context.nodeSubtype.addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
           .addMember("value", format, context.suppressedWarnings.toArray())
           .build());

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/ComputeBenchmark.java
Patch:
@@ -38,7 +38,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @State(Scope.Benchmark)
-@SuppressWarnings("PMD.MethodNamingConventions")
+@SuppressWarnings({"LexicographicalAnnotationAttributeListing", "PMD.MethodNamingConventions"})
 public class ComputeBenchmark {
   static final int SIZE = (2 << 14);
   static final int MASK = SIZE - 1;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/EvictionBenchmark.java
Patch:
@@ -34,7 +34,8 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @State(Scope.Benchmark)
-@SuppressWarnings("PMD.JUnit4TestShouldUseAfterAnnotation")
+@SuppressWarnings({"CanonicalAnnotationSyntax", "LexicographicalAnnotationAttributeListing",
+  "PMD.JUnit4TestShouldUseAfterAnnotation"})
 public class EvictionBenchmark {
 
   @Param({

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/FrequencySketchBenchmark.java
Patch:
@@ -35,6 +35,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @State(Scope.Benchmark)
+@SuppressWarnings("LexicographicalAnnotationAttributeListing")
 public class FrequencySketchBenchmark {
   private static final int SIZE = (2 << 14);
   private static final int MASK = SIZE - 1;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/GetPutBenchmark.java
Patch:
@@ -41,7 +41,8 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @State(Scope.Group)
-@SuppressWarnings({"PMD.JUnit4TestShouldUseAfterAnnotation", "PMD.MethodNamingConventions"})
+@SuppressWarnings({"CanonicalAnnotationSyntax", "LexicographicalAnnotationAttributeListing",
+  "PMD.JUnit4TestShouldUseAfterAnnotation", "PMD.MethodNamingConventions"})
 public class GetPutBenchmark {
   private static final int SIZE = (2 << 14);
   private static final int MASK = SIZE - 1;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/PutRemoveBenchmark.java
Patch:
@@ -47,7 +47,8 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @State(Scope.Group)
-@SuppressWarnings({"PMD.JUnit4TestShouldUseAfterAnnotation", "PMD.MethodNamingConventions"})
+@SuppressWarnings({"CanonicalAnnotationSyntax", "LexicographicalAnnotationAttributeListing",
+    "PMD.JUnit4TestShouldUseAfterAnnotation", "PMD.MethodNamingConventions"})
 public class PutRemoveBenchmark {
   private static final int SIZE = (2 << 14);
   private static final int MASK = SIZE - 1;
@@ -59,7 +60,6 @@ public class PutRemoveBenchmark {
     "ConcurrentHashMap",
     "ConcurrentLinkedHashMap",
     "Guava",
-    "Cache2k",
     "Ehcache3",
   })
   CacheType cacheType;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/TimerWheelBenchmark.java
Patch:
@@ -153,7 +153,7 @@ static final class Timer extends Node<Integer, Integer> {
 
   static final class MockCache extends BoundedLocalCache<Integer, Integer> {
 
-    @SuppressWarnings({"unchecked", "rawtypes"})
+    @SuppressWarnings({"rawtypes", "unchecked"})
     MockCache() {
       super((Caffeine) Caffeine.newBuilder(), /* cacheLoader */ null, /* isAsync */ false);
     }

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/ConcurrentHashMapV7.java
Patch:
@@ -113,8 +113,8 @@
  * @param <K> the type of keys maintained by this map
  * @param <V> the type of mapped values
  */
-@SuppressWarnings({"all", "deprecation", "unchecked", "rawtypes", "serial",
-  "JdkObsolete", "UnnecessaryParentheses", "UnusedNestedClass", "UnusedVariable"})
+@SuppressWarnings({"all", "deprecation", "JdkObsolete", "rawtypes", "serial",
+  "unchecked", "UnnecessaryParentheses", "UnusedNestedClass", "UnusedVariable"})
 public class ConcurrentHashMapV7<K, V> extends AbstractMap<K, V>
         implements ConcurrentMap<K, V>, Serializable {
     private static final long serialVersionUID = 7249069246763182397L;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/Ehcache3.java
Patch:
@@ -30,7 +30,7 @@
 public final class Ehcache3<K, V> implements BasicCache<K, V> {
   private final Cache<K, V> cache;
 
-  @SuppressWarnings({"unchecked", "PMD.CloseResource"})
+  @SuppressWarnings({"PMD.CloseResource", "unchecked"})
   public Ehcache3(int maximumSize) {
     CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder().build(true);
     cache = (Cache<K, V>) cacheManager.createCache("benchmark",

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/HazelcastCache.java
Patch:
@@ -68,7 +68,7 @@ public void clear() {
     cache.clear();
   }
 
-  @SuppressWarnings({"rawtypes", "unchecked", "TypeParameterUnusedInFormals"})
+  @SuppressWarnings({"rawtypes", "TypeParameterUnusedInFormals", "unchecked"})
   enum DummySerializationService implements SerializationService {
     INSTANCE;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheLoader.java
Patch:
@@ -44,7 +44,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @FunctionalInterface
-@SuppressWarnings({"PMD.SignatureDeclareThrowsException", "FunctionalInterfaceMethodChanged"})
+@SuppressWarnings({"FunctionalInterfaceMethodChanged", "PMD.SignatureDeclareThrowsException"})
 public interface CacheLoader<K extends Object, V extends Object> extends AsyncCacheLoader<K, V> {
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -501,7 +501,7 @@ long getMaximum() {
     return isWeighted() ? maximumWeight : maximumSize;
   }
 
-  @SuppressWarnings({"unchecked", "rawtypes"})
+  @SuppressWarnings({"rawtypes", "unchecked"})
   <K1 extends K, V1 extends V> Weigher<K1, V1> getWeigher(boolean isAsync) {
     Weigher<K1, V1> delegate = (weigher == null) || (weigher == Weigher.singletonWeigher())
         ? Weigher.singletonWeigher()
@@ -915,7 +915,7 @@ public <K1 extends K, V1 extends V> Caffeine<K1, V1> evictionListener(
     return self;
   }
 
-  @SuppressWarnings({"unchecked", "rawtypes"})
+  @SuppressWarnings({"rawtypes", "unchecked"})
   <K1 extends K, V1 extends V> @Nullable RemovalListener<K1, V1> getEvictionListener(
       boolean async) {
     var castedListener = (RemovalListener<K1, V1>) evictionListener;
@@ -966,7 +966,7 @@ public <K1 extends K, V1 extends V> Caffeine<K1, V1> removalListener(
     return self;
   }
 
-  @SuppressWarnings({"unchecked", "rawtypes"})
+  @SuppressWarnings({"rawtypes", "unchecked"})
   @Nullable <K1 extends K, V1 extends V> RemovalListener<K1, V1> getRemovalListener(boolean async) {
     RemovalListener<K1, V1> castedListener = (RemovalListener<K1, V1>) removalListener;
     return async && (castedListener != null)

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Interner.java
Patch:
@@ -114,7 +114,7 @@ final class WeakInterner<E> implements Interner<E> {
   }
 }
 
-@SuppressWarnings({"unchecked", "NullAway"})
+@SuppressWarnings({"NullAway", "unchecked"})
 final class Interned<K, V> extends Node<K, V> implements NodeFactory<K, V> {
   volatile Reference<?> keyReference;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncLoadingCache.java
Patch:
@@ -252,7 +252,7 @@ public CompletableFuture<Map<K, V>> refreshAll(Iterable<? extends K> keys) {
     private @Nullable CompletableFuture<V> tryComputeRefresh(K key, Object keyReference) {
       long[] startTime = new long[1];
       boolean[] refreshed = new boolean[1];
-      @SuppressWarnings({"unchecked", "rawtypes"})
+      @SuppressWarnings({"rawtypes", "unchecked"})
       CompletableFuture<V>[] oldValueFuture = new CompletableFuture[1];
       var future = asyncCache.cache().refreshes().computeIfAbsent(keyReference, k -> {
         oldValueFuture[0] = asyncCache.cache().getIfPresentQuietly(key);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalLoadingCache.java
Patch:
@@ -101,7 +101,7 @@ default CompletableFuture<V> refresh(K key) {
     long[] startTime = new long[1];
     @SuppressWarnings("unchecked")
     V[] oldValue = (V[]) new Object[1];
-    @SuppressWarnings({"unchecked", "rawtypes"})
+    @SuppressWarnings({"rawtypes", "unchecked"})
     CompletableFuture<? extends V>[] reloading = new CompletableFuture[1];
     Object keyReference = cache().referenceKey(key);
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/MpscGrowableArrayQueue.java
Patch:
@@ -195,7 +195,7 @@ abstract class BaseMpscLinkedArrayQueueColdProducerFields<E>
   protected E[] producerBuffer;
 }
 
-@SuppressWarnings({"PMD", "NullAway"})
+@SuppressWarnings({"NullAway", "PMD"})
 abstract class BaseMpscLinkedArrayQueue<E> extends BaseMpscLinkedArrayQueueColdProducerFields<E> {
   static final VarHandle REF_ARRAY;
   static final VarHandle P_INDEX;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/StripedBuffer.java
Patch:
@@ -199,7 +199,7 @@ final int expandOrRetry(E e, int h, int increment, boolean wasUncontended) {
         boolean init = false;
         try { // Initialize table
           if (table == buffers) {
-            @SuppressWarnings({"unchecked", "rawtypes"})
+            @SuppressWarnings({"rawtypes", "unchecked"})
             Buffer<E>[] rs = new Buffer[1];
             rs[0] = create(e);
             table = rs;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CaffeineSpecGuavaTest.java
Patch:
@@ -32,7 +32,7 @@
  *
  * @author Adam Winer
  */
-@SuppressWarnings({"PreferJavaTimeOverload", "CheckReturnValue"})
+@SuppressWarnings({"CheckReturnValue", "PreferJavaTimeOverload"})
 public class CaffeineSpecGuavaTest extends TestCase {
 
   public void testParse_empty() {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CaffeineTest.java
Patch:
@@ -50,7 +50,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@SuppressWarnings({"PreferJavaTimeOverload", "CheckReturnValue"})
+@SuppressWarnings({"CheckReturnValue", "PreferJavaTimeOverload"})
 public final class CaffeineTest {
   @Mock StatsCounter statsCounter;
   @Mock Expiry<Object, Object> expiry;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LinkedDequeTest.java
Patch:
@@ -826,7 +826,7 @@ public void comparing_uneven(LinkedDeque<LinkedValue> deque) {
   }
 
   private static Comparator<LinkedValue> comparator() {
-    return Comparator.comparing((LinkedValue v) -> v.value);
+    return Comparator.comparingInt((LinkedValue v) -> v.value);
   }
 
   /* --------------- Deque providers --------------- */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LocalCacheSubject.java
Patch:
@@ -68,7 +68,7 @@ private LocalCacheSubject(FailureMetadata metadata, Object subject) {
     return LocalCacheSubject::new;
   }
 
-  @SuppressWarnings({"unchecked", "rawtypes"})
+  @SuppressWarnings({"rawtypes", "unchecked"})
   public void isValid() {
     if (actual instanceof BoundedLocalCache<?, ?>) {
       var bounded = (BoundedLocalCache<Object, Object>) actual;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/RefreshAfterWriteTest.java
Patch:
@@ -320,7 +320,7 @@ public void refreshIfNeeded_timeout_noLog(CacheContext context) {
           Int key, Int oldValue, Executor executor) {
         var future = new CompletableFuture<Int>();
         future.orTimeout(0, TimeUnit.SECONDS);
-        await().until(() -> future.isDone());
+        await().until(future::isDone);
         return future;
       }
     };

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/TicketBuffer.java
Patch:
@@ -36,7 +36,7 @@ final class TicketBuffer<E> extends ReadBuffer<E> {
 
   long readCounter;
 
-  @SuppressWarnings({"unchecked", "rawtypes"})
+  @SuppressWarnings({"rawtypes", "unchecked"})
   TicketBuffer() {
     writeCounter = new AtomicLong();
     buffer = new AtomicReference[BUFFER_SIZE];

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Issue30Test.java
Patch:
@@ -55,7 +55,7 @@
  */
 @Test(groups = "isolated")
 @Listeners(CacheValidationListener.class)
-@SuppressWarnings("PreferJavaTimeOverload")
+@SuppressWarnings({"PreferJavaTimeOverload", "TimeZoneUsage"})
 public final class Issue30Test {
   private static final boolean DEBUG = false;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheGenerator.java
Patch:
@@ -87,6 +87,7 @@ public static void initialize(CacheContext context) {
   }
 
   /** Returns the Cartesian set of the possible cache configurations. */
+  @SuppressWarnings("IdentityConversion")
   private Set<List<Object>> combinations() {
     var asyncLoader = ImmutableSet.of(true, false);
     var loaders = ImmutableSet.copyOf(cacheSpec.loader());

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheSpec.java
Patch:
@@ -21,7 +21,7 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static java.util.Objects.requireNonNull;
 import static java.util.function.Function.identity;
-import static java.util.stream.Collectors.toMap;
+import static java.util.stream.Collectors.toUnmodifiableMap;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.Mockito.when;
@@ -496,7 +496,8 @@ enum Loader implements CacheLoader<Int, Int> {
         throw new UnsupportedOperationException();
       }
       @Override public Map<Int, Int> loadAll(Set<? extends Int> keys) {
-        return keys.stream().collect(toMap(key -> intern(intern(key).negate()), identity()));
+        return keys.stream().collect(toUnmodifiableMap(
+            key -> intern(intern(key).negate()), identity()));
       }
     },
     /** A bulk-only loader that loads more than requested. */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CheckNoEvictions.java
Patch:
@@ -28,5 +28,5 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@Target({TYPE, METHOD}) @Retention(RUNTIME)
+@Target({METHOD, TYPE}) @Retention(RUNTIME)
 public @interface CheckNoEvictions {}

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CheckNoStats.java
Patch:
@@ -28,5 +28,5 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@Target({TYPE, METHOD}) @Retention(RUNTIME)
+@Target({METHOD, TYPE}) @Retention(RUNTIME)
 public @interface CheckNoStats {}

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java
Patch:
@@ -71,7 +71,7 @@
 /**
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@SuppressWarnings({"serial", "PreferJavaTimeOverload"})
+@SuppressWarnings({"PreferJavaTimeOverload", "serial"})
 public final class GuavaCacheFromContext {
   private GuavaCacheFromContext() {}
   private static final ThreadLocal<Throwable> error = new ThreadLocal<>();
@@ -436,7 +436,7 @@ protected ConcurrentMap<K, V> delegate() {
         return cache.asMap();
       }
 
-      @SuppressWarnings({"UnusedVariable", "UnusedMethod"})
+      @SuppressWarnings({"UnusedMethod", "UnusedVariable"})
       private void readObject(ObjectInputStream stream) throws InvalidObjectException {
         statsCounter = new SimpleStatsCounter();
       }

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/acceptance/CollidingInt.java
Patch:
@@ -14,7 +14,7 @@
 /**
  * Ported from Eclipse Collections 11.0.
  */
-@SuppressWarnings("EqualsGetClass")
+@SuppressWarnings({"EqualsGetClass", "IdentityConversion"})
 public class CollidingInt implements Serializable, Comparable<CollidingInt> {
   private static final long serialVersionUID = 1L;
   private final int value;

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/acceptance/UnifiedMapAcceptanceTest.java
Patch:
@@ -32,7 +32,7 @@
 /**
  * Ported from Eclipse Collections 11.0.
  */
-@SuppressWarnings({"deprecation", "rawtypes", "unchecked", "CatchFail", "ThreadPriorityCheck"})
+@SuppressWarnings({"CatchFail", "deprecation", "rawtypes", "ThreadPriorityCheck", "unchecked"})
 public abstract class UnifiedMapAcceptanceTest {
   private static final Logger LOGGER = LoggerFactory.getLogger(UnifiedMapAcceptanceTest.class);
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/mutable/ConcurrentHashMapTest.java
Patch:
@@ -43,7 +43,7 @@
  *
  * Ported from Eclipse Collections 11.0.
  */
-@SuppressWarnings({"all", "unchecked"})
+@SuppressWarnings({"all", "IdentityConversion", "unchecked"})
 public abstract class ConcurrentHashMapTest extends ConcurrentHashMapTestCase {
   public static final MutableMap<Integer, MutableBag<Integer>> SMALL_BAG_MUTABLE_MAP =
       Interval.oneTo(100).groupBy(each -> each % 10).toMap(HashBag::new);

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/mutable/IntegerSum.java
Patch:
@@ -17,7 +17,7 @@
  * @deprecated Don't use in new tests
  */
 @Deprecated
-@SuppressWarnings({"all", "EqualsUnsafeCast", "EqualsBrokenForNull"})
+@SuppressWarnings({"all", "EqualsBrokenForNull", "EqualsUnsafeCast"})
 public final class IntegerSum implements Sum {
   private static final long serialVersionUID = 1L;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/mutable/MapIterableTestCase.java
Patch:
@@ -90,8 +90,8 @@
 /**
  * Ported from Eclipse Collections 11.0.
  */
-@SuppressWarnings({"all", "deprecation", "unchecked",
-  "PreferredInterfaceType", "IsInstanceIncompatibleType"})
+@SuppressWarnings({"all", "deprecation", "IdentityConversion",
+  "IsInstanceIncompatibleType", "PreferredInterfaceType", "unchecked"})
 public abstract class MapIterableTestCase {
   protected abstract <K, V> MapIterable<K, V> newMap();
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/mutable/UnifiedMapTestCase.java
Patch:
@@ -43,8 +43,8 @@
 /**
  * Ported from Eclipse Collections 11.0.
  */
-@SuppressWarnings({"all", "deprecation", "rawtypes", "unchecked",
-  "EqualsUnsafeCast", "EqualsBrokenForNull", "UndefinedEquals"})
+@SuppressWarnings({"all", "deprecation", "EqualsBrokenForNull",
+  "EqualsUnsafeCast", "rawtypes", "unchecked", "UndefinedEquals"})
 public abstract class UnifiedMapTestCase extends MutableMapTestCase {
   protected static final Integer COLLISION_1 = 0;
   protected static final Integer COLLISION_2 = 17;

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/Collection8Test.java
Patch:
@@ -45,8 +45,9 @@
  * Contains tests applicable to all jdk8+ Collection implementations.
  * An extension of CollectionTest.
  */
-@SuppressWarnings({"rawtypes", "try", "unchecked", "CatchAndPrintStackTrace", "MissingDefault",
-  "MissingFail", "ReturnValueIgnored", "UnnecessaryParentheses"})
+@SuppressWarnings({"CatchAndPrintStackTrace", "CollectorMutability", "MethodReferenceUsage",
+  "MissingDefault", "MissingFail", "rawtypes", "ReturnValueIgnored", "try", "unchecked",
+  "UnnecessaryParentheses"})
 public class Collection8Test extends JSR166TestCase {
     final CollectionImplementation impl;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/ConcurrentHashMap8Test.java
Patch:
@@ -30,7 +30,7 @@
 import junit.framework.Test;
 import junit.framework.TestSuite;
 
-@SuppressWarnings({"rawtypes", "try", "unchecked", "PreferredInterfaceType"})
+@SuppressWarnings({"IdentityConversion", "PreferredInterfaceType", "rawtypes", "try", "unchecked"})
 public class ConcurrentHashMap8Test extends JSR166TestCase {
     public static void main(String[] args) {
         main(suite(), args);

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/ConcurrentHashMapTest.java
Patch:
@@ -24,8 +24,8 @@
 
 import junit.framework.Test;
 
-@SuppressWarnings({"rawtypes", "unchecked", "ForEachIterable", "ModifyCollectionInEnhancedForLoop",
-  "PreferredInterfaceType", "ReturnValueIgnored", "UnnecessaryParentheses"})
+@SuppressWarnings({"ForEachIterable", "ModifyCollectionInEnhancedForLoop", "PreferredInterfaceType",
+  "rawtypes", "ReturnValueIgnored", "unchecked", "UnnecessaryParentheses"})
 public class ConcurrentHashMapTest extends JSR166TestCase {
     public static void main(String[] args) {
         main(suite(), args);

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/Item.java
Patch:
@@ -11,7 +11,7 @@
 /**
  * A simple element class for collections etc
  */
-@SuppressWarnings({"serial", "NonOverridingEquals"})
+@SuppressWarnings({"NonOverridingEquals", "serial"})
 public final class Item extends Number implements Comparable<Item>, Serializable {
     public final int value;
     public Item(int v) { value = v; }

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaCache.java
Patch:
@@ -65,7 +65,7 @@ public V getIfPresent(Object key) {
   }
 
   @Override
-  @SuppressWarnings({"PMD.PreserveStackTrace", "PMD.ExceptionAsFlowControl", "NullAway"})
+  @SuppressWarnings({"NullAway", "PMD.ExceptionAsFlowControl", "PMD.PreserveStackTrace"})
   public V get(K key, Callable<? extends V> valueLoader) throws ExecutionException {
     requireNonNull(valueLoader);
     try {
@@ -240,7 +240,7 @@ static final class CacheLoaderException extends RuntimeException {
     CacheLoaderException(Exception e) {
       super(e);
     }
-    @SuppressWarnings({"UnsynchronizedOverridesSynchronized", "lgtm [java/non-sync-override]"})
+    @SuppressWarnings({"lgtm [java/non-sync-override]", "UnsynchronizedOverridesSynchronized"})
     @Override public Throwable fillInStackTrace() {
       return this;
     }

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheBuilderTest.java
Patch:
@@ -61,7 +61,7 @@
  */
 @GwtCompatible(emulated = true)
 @SuppressWarnings(
-    {"CacheLoaderNull", "CanonicalDuration", "ThreadPriorityCheck", "PreferJavaTimeOverload"})
+    {"CacheLoaderNull", "CanonicalDuration", "PreferJavaTimeOverload", "ThreadPriorityCheck"})
 public class CacheBuilderTest extends TestCase {
 
   public void testNewBuilder() {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/LoadingCacheProxy.java
Patch:
@@ -15,14 +15,15 @@
  */
 package com.github.benmanes.caffeine.jcache;
 
+import static java.util.stream.Collectors.toUnmodifiableList;
+
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
-import java.util.stream.Collectors;
 
 import javax.cache.Cache;
 import javax.cache.CacheException;
@@ -132,7 +133,7 @@ private Map<K, V> getAll(Set<? extends K> keys, boolean updateAccessTime) {
       if (entries.size() != keys.size()) {
         List<K> keysToLoad = keys.stream()
             .filter(key -> !entries.containsKey(key))
-            .collect(Collectors.<K>toList());
+            .collect(toUnmodifiableList());
         entries.putAll(cache.getAll(keysToLoad));
       }
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/copy/AbstractCopier.java
Patch:
@@ -45,7 +45,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@SuppressWarnings({"JdkObsolete", "JavaUtilDate"})
+@SuppressWarnings({"JavaUtilDate", "JdkObsolete"})
 public abstract class AbstractCopier<A> implements Copier {
   private static final Map<Class<?>, Function<Object, Object>> JAVA_DEEP_COPY = Map.of(Date.class,
       o -> ((Date) o).clone(), GregorianCalendar.class, o -> ((GregorianCalendar) o).clone());
@@ -132,7 +132,7 @@ private static <T> T arrayCopy(T object) {
 
   /** @return a deep copy of the object. */
   private <T> T deepCopy(T object) {
-    @SuppressWarnings({"unchecked", "NullAway"})
+    @SuppressWarnings({"NullAway", "unchecked"})
     T copy = (T) deepCopyStrategies.get(object.getClass()).apply(object);
     return copy;
   }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/EventTypeAwareListener.java
Patch:
@@ -63,7 +63,7 @@ public boolean isCompatible(EventType eventType) {
   }
 
   /** Processes the event and logs if an exception is thrown. */
-  @SuppressWarnings({"PMD.SwitchStmtsShouldHaveDefault", "CatchingUnchecked"})
+  @SuppressWarnings({"CatchingUnchecked", "PMD.SwitchStmtsShouldHaveDefault"})
   public void dispatch(JCacheEntryEvent<K, V> event) {
     try {
       if (event.getSource().isClosed()) {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/integration/JCacheLoaderAdapter.java
Patch:
@@ -16,13 +16,13 @@
 package com.github.benmanes.caffeine.jcache.integration;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toUnmodifiableMap;
 
 import java.lang.System.Logger;
 import java.lang.System.Logger.Level;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
-import java.util.stream.Collectors;
 
 import javax.cache.expiry.Duration;
 import javax.cache.expiry.ExpiryPolicy;
@@ -106,7 +106,7 @@ public Map<K, Expirable<V>> loadAll(Set<? extends K> keys) {
 
       Map<K, Expirable<V>> result = delegate.loadAll(keys).entrySet().stream()
           .filter(entry -> (entry.getKey() != null) && (entry.getValue() != null))
-          .collect(Collectors.toMap(Map.Entry::getKey,
+          .collect(toUnmodifiableMap(Map.Entry::getKey,
               entry -> new Expirable<>(entry.getValue(), expireTimeMS())));
       for (var entry : result.entrySet()) {
         dispatcher.publishCreated(cache, entry.getKey(), entry.getValue().get());

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/CacheProxyTest.java
Patch:
@@ -61,7 +61,7 @@ protected CaffeineConfiguration<Integer, Integer> getConfiguration() {
   }
 
   @Test
-  @SuppressWarnings({"unchecked", "ObjectToString"})
+  @SuppressWarnings({"ObjectToString", "unchecked"})
   public void getConfiguration_immutable() {
     var config = jcache.getConfiguration(CaffeineConfiguration.class);
     List<Runnable> modifiers = List.of(

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/copy/JavaSerializationCopierTest.java
Patch:
@@ -76,6 +76,7 @@ public void deserializable_badData(JavaSerializationCopier copier) {
     copier.deserialize(new byte[0], Thread.currentThread().getContextClassLoader());
   }
 
+  @SuppressWarnings("TimeZoneUsage")
   @Test(expectedExceptions = CacheException.class)
   public void deserializable_classNotFound() {
     var copier = new JavaSerializationCopier() {
@@ -105,14 +106,14 @@ public void immutable() {
   }
 
   @Test(dataProvider = "copier")
-  @SuppressWarnings({"JdkObsolete", "JavaUtilDate", "UndefinedEquals"})
+  @SuppressWarnings({"JavaUtilDate", "JdkObsolete", "UndefinedEquals"})
   public void deepCopy_date(Copier copier) {
     Date date = new Date();
     assertThat(copy(copier, date)).isEqualTo(date);
   }
 
   @Test(dataProvider = "copier")
-  @SuppressWarnings({"JdkObsolete", "JavaUtilDate"})
+  @SuppressWarnings({"JavaUtilDate", "JdkObsolete"})
   public void deepCopy_calendar(Copier copier) {
     Calendar calendar = Calendar.getInstance();
     calendar.setTime(new Date());

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/JCacheAccessExpiryTest.java
Patch:
@@ -15,8 +15,8 @@
  */
 package com.github.benmanes.caffeine.jcache.expiry;
 
+import static com.google.common.collect.ImmutableMap.toImmutableMap;
 import static com.google.common.truth.Truth.assertThat;
-import static java.util.stream.Collectors.toMap;
 
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
@@ -212,7 +212,7 @@ public void invokeAll_absent() {
   @Test
   public void invokeAll_present() {
     var result = jcache.invokeAll(keys, (entry, args) -> entry.getValue());
-    var unwrapped = result.entrySet().stream().collect(toMap(
+    var unwrapped = result.entrySet().stream().collect(toImmutableMap(
         Map.Entry::getKey, entry -> entry.getValue().get()));
     assertThat(unwrapped).isEqualTo(entries);
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/BasicSettings.java
Patch:
@@ -16,9 +16,9 @@
 package com.github.benmanes.caffeine.cache.simulator;
 
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.ImmutableSet.toImmutableSet;
 import static java.util.Locale.US;
 import static java.util.Objects.requireNonNull;
-import static java.util.stream.Collectors.toSet;
 
 import java.util.List;
 import java.util.Set;
@@ -58,14 +58,14 @@ public int randomSeed() {
   public Set<String> policies() {
     return config().getStringList("policies").stream()
         .map(String::toLowerCase)
-        .collect(toSet());
+        .collect(toImmutableSet());
   }
 
   public Set<Admission> admission() {
     return config().getStringList("admission").stream()
         .map(String::toUpperCase)
         .map(Admission::valueOf)
-        .collect(toSet());
+        .collect(toImmutableSet());
   }
 
   public MembershipSettings membership() {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/Registry.java
Patch:
@@ -17,8 +17,8 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
+import static com.google.common.collect.ImmutableSet.toImmutableSet;
 import static java.util.Locale.US;
-import static java.util.stream.Collectors.toSet;
 import static org.apache.commons.lang3.StringUtils.isNotBlank;
 
 import java.util.HashMap;
@@ -100,12 +100,12 @@ public Registry(BasicSettings settings, Set<Characteristic> characteristics) {
    * Returns all of the policies that have been configured for simulation and that meet a minimal
    * set of supported characteristics.
    */
-  public Set<Policy> policies() {
+  public ImmutableSet<Policy> policies() {
     return settings.policies().stream()
         .map(name -> checkNotNull(factories.get(name.toLowerCase(US)), "%s not found", name))
         .filter(factory -> factory.characteristics().containsAll(characteristics))
         .flatMap(factory -> factory.creator().apply(settings.config()).stream())
-        .collect(toSet());
+        .collect(toImmutableSet());
   }
 
   private void buildRegistry() {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/DClockPolicy.java
Patch:
@@ -17,7 +17,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkState;
-import static java.util.stream.Collectors.toSet;
+import static java.util.stream.Collectors.toUnmodifiableSet;
 
 import java.util.List;
 import java.util.Set;
@@ -84,7 +84,7 @@ public static Set<Policy> policies(Config config) {
     DClockSettings settings = new DClockSettings(config);
     return settings.percentActive().stream()
         .map(percentActive -> new DClockPolicy(settings, percentActive))
-        .collect(toSet());
+        .collect(toUnmodifiableSet());
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/FrequentlyUsedPolicy.java
Patch:
@@ -17,7 +17,7 @@
 
 import static java.util.Locale.US;
 import static java.util.Objects.requireNonNull;
-import static java.util.stream.Collectors.toSet;
+import static java.util.stream.Collectors.toUnmodifiableSet;
 
 import java.util.Set;
 
@@ -65,7 +65,7 @@ public static Set<Policy> policies(Config config, EvictionPolicy policy) {
     BasicSettings settings = new BasicSettings(config);
     return settings.admission().stream().map(admission ->
       new FrequentlyUsedPolicy(admission, policy, config)
-    ).collect(toSet());
+    ).collect(toUnmodifiableSet());
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/LinkedPolicy.java
Patch:
@@ -17,7 +17,7 @@
 
 import static com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic.WEIGHTED;
 import static java.util.Locale.US;
-import static java.util.stream.Collectors.toSet;
+import static java.util.stream.Collectors.toUnmodifiableSet;
 
 import java.util.Set;
 
@@ -73,7 +73,7 @@ public static Set<Policy> policies(Config config,
     BasicSettings settings = new BasicSettings(config);
     return settings.admission().stream().map(admission ->
       new LinkedPolicy(config, characteristics, admission, policy)
-    ).collect(toSet());
+    ).collect(toUnmodifiableSet());
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/S4LruPolicy.java
Patch:
@@ -16,7 +16,7 @@
 package com.github.benmanes.caffeine.cache.simulator.policy.linked;
 
 import static com.google.common.base.Preconditions.checkState;
-import static java.util.stream.Collectors.toSet;
+import static java.util.stream.Collectors.toUnmodifiableSet;
 
 import java.util.Arrays;
 import java.util.Set;
@@ -75,7 +75,7 @@ public static Set<Policy> policies(Config config) {
     BasicSettings settings = new BasicSettings(config);
     return settings.admission().stream().map(admission ->
       new S4LruPolicy(admission, config)
-    ).collect(toSet());
+    ).collect(toUnmodifiableSet());
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/SegmentedLruPolicy.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.policy.linked;
 
-import static java.util.stream.Collectors.toSet;
+import static java.util.stream.Collectors.toUnmodifiableSet;
 
 import java.util.Set;
 
@@ -82,7 +82,7 @@ public static Set<Policy> policies(Config config) {
     BasicSettings settings = new BasicSettings(config);
     return settings.admission().stream().map(admission ->
       new SegmentedLruPolicy(admission, config)
-    ).collect(toSet());
+    ).collect(toUnmodifiableSet());
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/CoherencePolicy.java
Patch:
@@ -16,7 +16,7 @@
 package com.github.benmanes.caffeine.cache.simulator.policy.product;
 
 import static com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic.WEIGHTED;
-import static java.util.stream.Collectors.toSet;
+import static java.util.stream.Collectors.toUnmodifiableSet;
 
 import java.util.EnumSet;
 import java.util.Set;
@@ -68,7 +68,7 @@ public static Set<Policy> policies(Config config) {
     var settings = new CoherenceSettings(config);
     return settings.policy().stream()
         .map(policy -> new CoherencePolicy(settings, policy))
-        .collect(toSet());
+        .collect(toUnmodifiableSet());
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/ExpiringMapPolicy.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.policy.product;
 
-import static java.util.stream.Collectors.toSet;
+import static java.util.stream.Collectors.toUnmodifiableSet;
 
 import java.util.EnumSet;
 import java.util.Set;
@@ -55,7 +55,7 @@ public static Set<Policy> policies(Config config) {
     var settings = new ExpiringMapSettings(config);
     return settings.policy().stream()
         .map(policy -> new ExpiringMapPolicy(settings, policy))
-        .collect(toSet());
+        .collect(toUnmodifiableSet());
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/HazelcastPolicy.java
Patch:
@@ -18,7 +18,7 @@
 import static com.google.common.base.Preconditions.checkState;
 import static com.hazelcast.config.MaxSizePolicy.ENTRY_COUNT;
 import static java.util.Locale.US;
-import static java.util.stream.Collectors.toSet;
+import static java.util.stream.Collectors.toUnmodifiableSet;
 
 import java.util.EnumSet;
 import java.util.Set;
@@ -75,7 +75,7 @@ public static Set<Policy> policies(Config config) {
     var settings = new HazelcastSettings(config);
     return settings.policy().stream()
         .map(policy -> new HazelcastPolicy(settings, policy))
-        .collect(toSet());
+        .collect(toUnmodifiableSet());
   }
 
   @Override
@@ -124,7 +124,7 @@ public Set<EvictionPolicy> policy() {
     }
   }
 
-  @SuppressWarnings({"rawtypes", "unchecked", "TypeParameterUnusedInFormals"})
+  @SuppressWarnings({"rawtypes", "TypeParameterUnusedInFormals", "unchecked"})
   enum DummySerializationService implements SerializationService {
     INSTANCE;
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/OhcPolicy.java
Patch:
@@ -17,7 +17,7 @@
 
 import static com.google.common.base.Preconditions.checkState;
 import static java.util.Locale.US;
-import static java.util.stream.Collectors.toSet;
+import static java.util.stream.Collectors.toUnmodifiableSet;
 
 import java.io.IOException;
 import java.io.UncheckedIOException;
@@ -65,7 +65,7 @@ public static Set<Policy> policies(Config config) {
     OhcSettings settings = new OhcSettings(config);
     return settings.policy().stream()
         .map(policy -> new OhcPolicy(settings, policy))
-        .collect(toSet());
+        .collect(toUnmodifiableSet());
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/TCachePolicy.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.policy.product;
 
-import static java.util.stream.Collectors.toSet;
+import static java.util.stream.Collectors.toUnmodifiableSet;
 
 import java.util.EnumSet;
 import java.util.Set;
@@ -56,7 +56,7 @@ public static Set<Policy> policies(Config config) {
     var settings = new TCacheSettings(config);
     return settings.policy().stream()
         .map(policy -> new TCachePolicy(settings, policy))
-        .collect(toSet());
+        .collect(toUnmodifiableSet());
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/WindowTinyLfuPolicy.java
Patch:
@@ -16,7 +16,7 @@
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch;
 
 import static com.google.common.base.Preconditions.checkState;
-import static java.util.stream.Collectors.toSet;
+import static java.util.stream.Collectors.toUnmodifiableSet;
 
 import java.util.List;
 import java.util.Set;
@@ -88,7 +88,7 @@ public static Set<Policy> policies(Config config) {
     WindowTinyLfuSettings settings = new WindowTinyLfuSettings(config);
     return settings.percentMain().stream()
         .map(percentMain -> new WindowTinyLfuPolicy(percentMain, settings))
-        .collect(toSet());
+        .collect(toUnmodifiableSet());
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/feedback/FeedbackWindowTinyLfuPolicy.java
Patch:
@@ -16,7 +16,7 @@
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch.feedback;
 
 import static com.google.common.base.Preconditions.checkState;
-import static java.util.stream.Collectors.toSet;
+import static java.util.stream.Collectors.toUnmodifiableSet;
 
 import java.util.List;
 import java.util.Map;
@@ -110,7 +110,7 @@ public static Set<Policy> policies(Config config) {
     FeedbackWindowTinyLfuSettings settings = new FeedbackWindowTinyLfuSettings(config);
     return settings.percentMain().stream()
         .map(percentMain -> new FeedbackWindowTinyLfuPolicy(percentMain, settings))
-        .collect(toSet());
+        .collect(toUnmodifiableSet());
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/segment/FullySegmentedWindowTinyLfuPolicy.java
Patch:
@@ -16,7 +16,7 @@
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch.segment;
 
 import static com.google.common.base.Preconditions.checkState;
-import static java.util.stream.Collectors.toSet;
+import static java.util.stream.Collectors.toUnmodifiableSet;
 
 import java.util.List;
 import java.util.Set;
@@ -83,7 +83,7 @@ public static Set<Policy> policies(Config config) {
     FullySegmentedWindowTinyLfuSettings settings = new FullySegmentedWindowTinyLfuSettings(config);
     return settings.percentMain().stream()
         .map(percentMain -> new FullySegmentedWindowTinyLfuPolicy(percentMain, settings))
-        .collect(toSet());
+        .collect(toUnmodifiableSet());
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/segment/LruWindowTinyLfuPolicy.java
Patch:
@@ -16,7 +16,7 @@
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch.segment;
 
 import static com.google.common.base.Preconditions.checkState;
-import static java.util.stream.Collectors.toSet;
+import static java.util.stream.Collectors.toUnmodifiableSet;
 
 import java.util.List;
 import java.util.Set;
@@ -70,7 +70,7 @@ public static Set<Policy> policies(Config config) {
     LruWindowTinyLfuSettings settings = new LruWindowTinyLfuSettings(config);
     return settings.percentMain().stream()
         .map(percentMain -> new LruWindowTinyLfuPolicy(percentMain, settings))
-        .collect(toSet());
+        .collect(toUnmodifiableSet());
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/segment/RandomWindowTinyLfuPolicy.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch.segment;
 
-import static java.util.stream.Collectors.toSet;
+import static java.util.stream.Collectors.toUnmodifiableSet;
 
 import java.util.List;
 import java.util.Random;
@@ -70,7 +70,7 @@ public static Set<Policy> policies(Config config) {
     RandomWindowTinyLfuSettings settings = new RandomWindowTinyLfuSettings(config);
     return settings.percentMain().stream()
         .map(percentMain -> new RandomWindowTinyLfuPolicy(percentMain, settings))
-        .collect(toSet());
+        .collect(toUnmodifiableSet());
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/segment/S4WindowTinyLfuPolicy.java
Patch:
@@ -16,7 +16,7 @@
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch.segment;
 
 import static com.google.common.base.Preconditions.checkState;
-import static java.util.stream.Collectors.toSet;
+import static java.util.stream.Collectors.toUnmodifiableSet;
 
 import java.util.Arrays;
 import java.util.List;
@@ -76,7 +76,7 @@ public static Set<Policy> policies(Config config) {
     S4WindowTinyLfuSettings settings = new S4WindowTinyLfuSettings(config);
     return settings.percentMain().stream()
         .map(percentMain -> new S4WindowTinyLfuPolicy(percentMain, settings))
-        .collect(toSet());
+        .collect(toUnmodifiableSet());
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/csv/CombinedCsvReport.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.report.csv;
 
-import static java.util.stream.Collectors.toList;
+import static com.google.common.collect.ImmutableList.toImmutableList;
 
 import java.nio.file.Path;
 import java.text.NumberFormat;
@@ -84,7 +84,7 @@ private void writeReport(Table<String, Long, String> table) {
     var policies = newCsvParser()
         .parseAllRecords(inputFiles.values().iterator().next().toFile()).stream()
         .map(record -> record.getString("Policy"))
-        .collect(toList());
+        .collect(toImmutableList());
     var formatter = NumberFormat.getInstance(Locale.US);
     var headers = Stream
         .concat(Stream.of("Policy"), inputFiles.keySet().stream().map(formatter::format))

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/ExpiringMapPolicy.java
Patch:
@@ -39,7 +39,7 @@
  */
 @PolicySpec(name = "product.ExpiringMap")
 public final class ExpiringMapPolicy implements KeyOnlyPolicy {
-  private final ExpiringMap<Object, Object> cache;
+  private final ExpiringMap<Long, Boolean> cache;
   private final PolicyStats policyStats;
 
   public ExpiringMapPolicy(ExpiringMapSettings settings, Eviction policy) {
@@ -60,12 +60,12 @@ public static Set<Policy> policies(Config config) {
 
   @Override
   public void record(long key) {
-    Object value = cache.get(key);
+    var value = cache.get(key);
     if (value == null) {
       if (cache.size() == cache.getMaxSize()) {
         policyStats.recordEviction();
       }
-      cache.put(key, key);
+      cache.put(key, Boolean.TRUE);
       policyStats.recordMiss();
     } else {
       policyStats.recordHit();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/HazelcastPolicy.java
Patch:
@@ -50,7 +50,7 @@
  */
 @PolicySpec(name = "product.Hazelcast")
 public final class HazelcastPolicy implements KeyOnlyPolicy {
-  private final NearCache<Long, Long> cache;
+  private final NearCache<Long, Boolean> cache;
   private final PolicyStats policyStats;
   private final int maximumSize;
 
@@ -85,7 +85,7 @@ public void record(long key) {
       if (cache.size() == maximumSize) {
         policyStats.recordEviction();
       }
-      cache.put(key, /* keyData */ null, key, /* valueDate */ null);
+      cache.put(key, /* keyData */ null, Boolean.TRUE, /* valueDate */ null);
       policyStats.recordMiss();
     } else {
       policyStats.recordHit();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/TCachePolicy.java
Patch:
@@ -39,12 +39,12 @@
  */
 @PolicySpec(name = "product.TCache")
 public final class TCachePolicy implements KeyOnlyPolicy {
-  private final Cache<Object, Object> cache;
+  private final Cache<Long, Boolean> cache;
   private final PolicyStats policyStats;
 
   public TCachePolicy(TCacheSettings settings, Eviction policy) {
     policyStats = new PolicyStats(name() + " (%s)", policy);
-    cache = TCacheFactory.standardFactory().builder()
+    cache = TCacheFactory.standardFactory().<Long, Boolean>builder()
         .setMaxElements(Ints.checkedCast(settings.maximumSize()))
         .setEvictionPolicy(policy.type)
         .setStatistics(true)
@@ -64,7 +64,7 @@ public void record(long key) {
     Object value = cache.get(key);
     if (value == null) {
       policyStats.recordMiss();
-      cache.put(key, key);
+      cache.put(key, Boolean.TRUE);
     } else {
       policyStats.recordHit();
     }

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheBuilderFactory.java
Patch:
@@ -36,6 +36,7 @@
  *
  * @author mike nonemacher
  */
+@SuppressWarnings("CanIgnoreReturnValueSuggester")
 class CacheBuilderFactory {
   // Default values contain only 'null', which means don't call the CacheBuilder method (just give
   // the CacheBuilder default).

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddValue.java
Patch:
@@ -95,7 +95,7 @@ private MethodSpec makeSetValue() {
         .addParameter(vRefQueueType, "referenceQueue");
 
     if (isStrongValues()) {
-      setter.addStatement("$L.set(this, $N)", varHandleName("value"), "value");
+      setter.addStatement("$L.setRelease(this, $N)", varHandleName("value"), "value");
     } else {
       setter.addStatement("$1T<V> ref = ($1T<V>) $2L.get(this)",
           Reference.class, varHandleName("value"));

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheFactoryGenerator.java
Patch:
@@ -160,6 +160,7 @@ private Set<List<Object>> combinations() {
     return Sets.cartesianProduct(sets);
   }
 
+  @SuppressWarnings("NullAway")
   private TypeSpec makeLocalCacheSpec(String className, boolean isFinal, Set<Feature> features) {
     TypeName superClass;
     Set<Feature> parentFeatures;

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeFactoryGenerator.java
Patch:
@@ -158,6 +158,7 @@ private Set<Feature> getFeatures(List<Object> combination) {
     return features;
   }
 
+  @SuppressWarnings("NullAway")
   private TypeSpec makeNodeSpec(String className, boolean isFinal, Set<Feature> features) {
     TypeName superClass;
     Set<Feature> parentFeatures;

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/NodeRule.java
Patch:
@@ -67,10 +67,12 @@ protected boolean isBaseClass() {
     return context.superClass.equals(TypeName.OBJECT);
   }
 
+  @SuppressWarnings("NullAway")
   protected Strength keyStrength() {
     return strengthOf(Iterables.get(context.generateFeatures, 0));
   }
 
+  @SuppressWarnings("NullAway")
   protected Strength valueStrength() {
     return strengthOf(Iterables.get(context.generateFeatures, 1));
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncLoadingCache.java
Patch:
@@ -69,8 +69,8 @@ public interface AsyncLoadingCache<K extends Object, V extends Object> extends A
    * ignored.
    *
    * @param keys the keys whose associated values are to be returned
-   * @return the future containing an unmodifiable mapping of keys to values for the specified keys
-   *         in this cache
+   * @return a future containing an unmodifiable mapping of keys to values for the specified keys in
+   *         this cache
    * @throws NullPointerException if the specified collection is null or contains a null element, or
    *         if the future returned by the {@link AsyncCacheLoader} is null
    * @throws RuntimeException or Error if the {@link AsyncCacheLoader} does so, if

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Cache.java
Patch:
@@ -89,7 +89,7 @@ public interface Cache<K extends Object, V extends Object> {
    * ignored.
    *
    * @param keys the keys whose associated values are to be returned
-   * @return the unmodifiable mapping of keys to values for the specified keys found in this cache
+   * @return an unmodifiable mapping of keys to values for the specified keys found in this cache
    * @throws NullPointerException if the specified collection is null or contains a null element
    */
   Map<K, V> getAllPresent(Iterable<? extends K> keys);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LoadingCache.java
Patch:
@@ -77,7 +77,7 @@ public interface LoadingCache<K extends Object, V extends Object> extends Cache<
    * ignored.
    *
    * @param keys the keys whose associated values are to be returned
-   * @return the unmodifiable mapping of keys to values for the specified keys in this cache
+   * @return an unmodifiable mapping of keys to values for the specified keys in this cache
    * @throws NullPointerException if the specified collection is null or contains a null element
    * @throws CompletionException if a checked exception was thrown while loading the value
    * @throws RuntimeException or Error if the {@link CacheLoader} does so, if
@@ -119,7 +119,7 @@ public interface LoadingCache<K extends Object, V extends Object> extends Cache<
    * is asynchronous by delegating to the default executor.
    *
    * @param keys the keys whose associated values are to be returned
-   * @return the future containing an unmodifiable mapping of keys to values for the specified keys
+   * @return a future containing an unmodifiable mapping of keys to values for the specified keys
    *         that are loading the values
    * @throws NullPointerException if the specified collection is null or contains a null element
    */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/TimerWheelTest.java
Patch:
@@ -528,7 +528,7 @@ public void sentinel_unsupported() {
 
   /** Returns a snapshot roughly ordered by the expiration time. */
   private List<Long> snapshot(boolean ascending) {
-    var snapshot = new ArrayList<Long>(cache.size());
+    var snapshot = new ArrayList<Long>();
     int startLevel = ascending ? 0 : timerWheel.wheel.length - 1;
     Function<Node<?, ?>, Node<?, ?>> successor =
         ascending ? Node::getNextInVariableOrder : Node::getPreviousInVariableOrder;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/ExpiryBuilder.java
Patch:
@@ -20,6 +20,7 @@
 import java.io.Serializable;
 
 import com.github.benmanes.caffeine.cache.Expiry;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 /**
  * A builder for unit test convenience.
@@ -45,12 +46,14 @@ public static ExpiryBuilder expiringAfterCreate(long nanos) {
   }
 
   /** Sets the fixed update expiration time. */
+  @CanIgnoreReturnValue
   public ExpiryBuilder expiringAfterUpdate(long nanos) {
     updateNanos = nanos;
     return this;
   }
 
   /** Sets the fixed read expiration time. */
+  @CanIgnoreReturnValue
   public ExpiryBuilder expiringAfterRead(long nanos) {
     readNanos = nanos;
     return this;

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/CaffeineMutableMapTestCase.java
Patch:
@@ -25,6 +25,7 @@
 import org.eclipse.collections.impl.map.mutable.MapAdapter;
 
 import com.github.benmanes.caffeine.cache.Cache;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
 
 /**
  * @author ben.manes@gmail.com (Ben Manes)
@@ -90,6 +91,7 @@ public ConcurrentMapAdapter(ConcurrentMap<K, V> delegate) {
     @Override public boolean replace(K key, V oldValue, V newValue) {
       return delegate.replace(key, oldValue, newValue);
     }
+    @CanIgnoreReturnValue
     @SuppressWarnings("FunctionalInterfaceClash")
     @Override public ConcurrentMutableMap<K, V> tap(Procedure<? super V> procedure) {
       each(procedure);

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaCache.java
Patch:
@@ -157,10 +157,10 @@ final class AsMapView extends ForwardingConcurrentMap<K, V> {
     @Nullable KeySetView keySet;
     @Nullable ValuesView values;
 
-    @Override public boolean containsKey(Object key) {
+    @Override public boolean containsKey(@Nullable Object key) {
       return (key != null) && delegate().containsKey(key);
     }
-    @Override public boolean containsValue(Object value) {
+    @Override public boolean containsValue(@Nullable Object value) {
       return (value != null) && delegate().containsValue(value);
     }
     @Override public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
@@ -211,7 +211,7 @@ final class ValuesView extends ForwardingCollection<V> {
     @Override public boolean removeIf(Predicate<? super V> filter) {
       return delegate().removeIf(filter);
     }
-    @Override public boolean remove(Object o) {
+    @Override public boolean remove(@Nullable Object o) {
       return (o != null) && delegate().remove(o);
     }
     @Override protected Collection<V> delegate() {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/StripedBuffer.java
Patch:
@@ -64,9 +64,10 @@ abstract class StripedBuffer<E> implements Buffer<E> {
    * Contention and/or table collisions are indicated by failed CASes when performing an update
    * operation. Upon a collision, if the table size is less than the capacity, it is doubled in size
    * unless some other thread holds the lock. If a hashed slot is empty, and lock is available, a
-   * new Buffer is created. Otherwise, if the slot exists, a CAS is tried. The Thread id serves as
+   * new Buffer is created. Otherwise, if the slot exists, a CAS is tried. The thread id serves as
    * the base for per-thread hash codes. Retries proceed by "incremental hashing", using the top
-   * half of the seed to increment the bottom half used as the probe to try to find a free slot.
+   * half of the seed to increment the bottom half which is used as a probe to try to find a free
+   * slot.
    *
    * The table size is capped because, when there are more threads than CPUs, supposing that each
    * thread were bound to a CPU, there would exist a perfect hash function mapping threads to slots

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/AbstractJCacheTest.java
Patch:
@@ -54,6 +54,7 @@ public abstract class AbstractJCacheTest {
   protected final ImmutableMap<Integer, Integer> entries = ImmutableMap.of(
       KEY_1, VALUE_1, KEY_2, VALUE_2, KEY_3, VALUE_3);
 
+  protected CaffeineConfiguration<Integer, Integer> jcacheConfiguration;
   protected LoadingCacheProxy<Integer, Integer> jcacheLoading;
   protected CacheProxy<Integer, Integer> jcache;
   protected CacheManager cacheManager;
@@ -68,8 +69,9 @@ public void beforeClass() {
 
   @BeforeMethod(alwaysRun = true)
   public void before() {
+    jcacheConfiguration = getConfiguration();
     ticker = new FakeTicker().advance(START_TIME_MS, TimeUnit.MILLISECONDS);
-    jcache = (CacheProxy<Integer, Integer>) cacheManager.createCache("jcache", getConfiguration());
+    jcache = (CacheProxy<Integer, Integer>) cacheManager.createCache("jcache", jcacheConfiguration);
     jcacheLoading = (LoadingCacheProxy<Integer, Integer>) cacheManager.createCache(
         "jcacheLoading", getLoadingConfiguration());
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1265,7 +1265,7 @@ boolean skipReadBuffer() {
     if (((now - writeTime) > refreshAfterWriteNanos()) && (keyReference != null)
         && ((key = node.getKey()) != null) && ((oldValue = node.getValue()) != null)
         && ((writeTime & 1L) == 0L) && !(refreshes = refreshes()).containsKey(keyReference)
-        && node.casWriteTime(writeTime, refreshWriteTime)) {
+        && node.isAlive() && node.casWriteTime(writeTime, refreshWriteTime)) {
       long[] startTime = new long[1];
       @SuppressWarnings({"unchecked", "rawtypes"})
       CompletableFuture<? extends V>[] refreshFuture = new CompletableFuture[1];

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/References.java
Patch:
@@ -177,7 +177,7 @@ public String toString() {
    * the advent that the key is reclaimed so that the entry can be removed from the cache in
    * constant time.
    */
-  static final class WeakKeyReference<K> extends WeakReference<K> implements InternalReference<K> {
+  static class WeakKeyReference<K> extends WeakReference<K> implements InternalReference<K> {
     private final int hashCode;
 
     public WeakKeyReference(@Nullable K key, @Nullable ReferenceQueue<K> queue) {

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/DelegationBenchmark.java
Patch:
@@ -32,6 +32,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @State(Scope.Benchmark)
+@SuppressWarnings("PMD.MethodNamingConventions")
 public class DelegationBenchmark {
   private static final int SIZE = (2 << 14);
   private static final int MASK = SIZE - 1;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/FactoryBenchmark.java
Patch:
@@ -28,6 +28,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @State(Scope.Benchmark)
+@SuppressWarnings("PMD.MethodNamingConventions")
 public class FactoryBenchmark {
   private final ReflectionFactory reflectionFactory = new ReflectionFactory();
   private final MethodHandleFactory methodHandleFactory = new MethodHandleFactory();

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/SlotLookupBenchmark.java
Patch:
@@ -48,6 +48,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @State(Scope.Benchmark)
+@SuppressWarnings("PMD.MethodNamingConventions")
 public class SlotLookupBenchmark {
   static final int SPARSE_SIZE = 2 << 14;
   static final int ARENA_SIZE = 2 << 6;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/TimeBenchmark.java
Patch:
@@ -21,6 +21,7 @@
 /**
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PMD.MethodNamingConventions")
 public class TimeBenchmark {
 
   @Benchmark @Threads(1)

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/ComputeBenchmark.java
Patch:
@@ -38,6 +38,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @State(Scope.Benchmark)
+@SuppressWarnings("PMD.MethodNamingConventions")
 public class ComputeBenchmark {
   static final int SIZE = (2 << 14);
   static final int MASK = SIZE - 1;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/EvictionBenchmark.java
Patch:
@@ -34,6 +34,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @State(Scope.Benchmark)
+@SuppressWarnings("PMD.JUnit4TestShouldUseAfterAnnotation")
 public class EvictionBenchmark {
 
   @Param({
@@ -50,7 +51,7 @@ public class EvictionBenchmark {
 
   @State(Scope.Thread)
   public static class ThreadState {
-    int key = 0;
+    int key;
   }
 
   @Setup

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/FrequencySketchBenchmark.java
Patch:
@@ -36,7 +36,7 @@ public class FrequencySketchBenchmark {
   private static final int MASK = SIZE - 1;
   private static final int ITEMS = SIZE / 3;
 
-  int index = 0;
+  int index;
   Integer[] ints;
   FrequencySketch<Integer> sketch;
 

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/GetPutBenchmark.java
Patch:
@@ -41,6 +41,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @State(Scope.Group)
+@SuppressWarnings({"PMD.JUnit4TestShouldUseAfterAnnotation", "PMD.MethodNamingConventions"})
 public class GetPutBenchmark {
   private static final int SIZE = (2 << 14);
   private static final int MASK = SIZE - 1;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/MemoryBenchmark.java
Patch:
@@ -44,7 +44,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@SuppressWarnings("PreferJavaTimeOverload")
+@SuppressWarnings({"PreferJavaTimeOverload", "PMD.MethodNamingConventions"})
 public final class MemoryBenchmark {
   // The number of entries added to minimize skew due to non-entry factors
   static final int FUZZY_SIZE = 25_000;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/PutRemoveBenchmark.java
Patch:
@@ -47,6 +47,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @State(Scope.Group)
+@SuppressWarnings({"PMD.JUnit4TestShouldUseAfterAnnotation", "PMD.MethodNamingConventions"})
 public class PutRemoveBenchmark {
   private static final int SIZE = (2 << 14);
   private static final int MASK = SIZE - 1;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/profiler/ProfilerHook.java
Patch:
@@ -28,8 +28,8 @@
  * @author Ben Manes (ben.manes@gmail.com)
  */
 public abstract class ProfilerHook {
-  static int DISPLAY_DELAY_SEC = 5;
-  static int NUM_THREADS = 8;
+  static final int DISPLAY_DELAY_SEC = 5;
+  static final int NUM_THREADS = 8;
 
   protected final LongAdder calls;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CheckNoStats.java
Patch:
@@ -16,6 +16,7 @@
 package com.github.benmanes.caffeine.cache.testing;
 
 import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import java.lang.annotation.Retention;
@@ -27,5 +28,5 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@Target(METHOD) @Retention(RUNTIME)
+@Target({TYPE, METHOD}) @Retention(RUNTIME)
 public @interface CheckNoStats {}

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncLoadingCache.java
Patch:
@@ -318,8 +318,7 @@ public CompletableFuture<Map<K, V>> refreshAll(Iterable<? extends K> keys) {
             // Otherwise, a write invalidated the refresh so discard it and notify the listener
             discard[0] = true;
             return currentValue;
-          }, asyncCache.cache().expiry(), /* recordMiss */ false,
-              /* recordLoad */ false, /* recordLoadFailure */ true);
+          }, asyncCache.cache().expiry(), /* recordLoad */ false, /* recordLoadFailure */ true);
 
           if (discard[0] && (newValue != null)) {
             var cause = (value == null) ? RemovalCause.EXPLICIT : RemovalCause.REPLACED;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalLoadingCache.java
Patch:
@@ -162,8 +162,7 @@ default CompletableFuture<V> refresh(K key) {
           }
           discard[0] = (currentValue != newValue);
           return currentValue;
-        }, cache().expiry(), /* recordMiss */ false,
-            /* recordLoad */ false, /* recordLoadFailure */ true);
+        }, cache().expiry(), /* recordLoad */ false, /* recordLoadFailure */ true);
 
         if (discard[0] && (newValue != null)) {
           var cause = (value == null) ? RemovalCause.EXPLICIT : RemovalCause.REPLACED;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/SerializationProxy.java
Patch:
@@ -24,8 +24,8 @@
 
 /**
  * Serializes the configuration of the cache, reconsitituting it as a {@link Cache},
- * {@link LoadingCache}, or {@link AsyncLoadingCache} using {@link Caffeine} upon
- * deserialization. The data held by the cache is not retained.
+ * {@link LoadingCache}, {@link AsyncCache}, or {@link AsyncLoadingCache} using {@link Caffeine}
+ * upon deserialization. The data held by the cache is not retained.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/MapSubject.java
Patch:
@@ -61,7 +61,7 @@ public void hasSizeLessThan(long other) {
 
   /** Fails if the map's size is not in {@code range}. */
   public void hasSizeIn(Range<Integer> range) {
-    check("size()").that(actual.size()).isIn(range);;
+    check("size()").that(actual.size()).isIn(range);
   }
 
   /** Fails if the map does not contain the given keys, where duplicate keys are ignored. */

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurationTest.java
Patch:
@@ -97,6 +97,7 @@ public void testCache2() {
     assertThat(config2.get().getKeyType()).isAssignableTo(String.class);
     assertThat(config2.get().getValueType()).isAssignableTo(Integer.class);
     assertThat(config2.get().isNativeStatisticsEnabled()).isFalse();
+    assertThat(config2.get().getExpiryPolicyFactory().create().getExpiryForAccess()).isNull();
     assertThat(config2.get().getExpiryFactory().get().create()).isInstanceOf(TestExpiry.class);
     assertThat(config2.get().getExecutorFactory().create()).isEqualTo(ForkJoinPool.commonPool());
     assertThat(config2.get().getCacheWriter()).isNull();

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncLoadingCache.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache;
 
+import static com.github.benmanes.caffeine.cache.Caffeine.calculateHashMapCapacity;
 import static com.github.benmanes.caffeine.cache.LocalAsyncCache.composeResult;
 import static java.util.Objects.requireNonNull;
 
@@ -140,7 +141,7 @@ public CompletableFuture<Map<K, V>> getAll(Iterable<? extends K> keys) {
     }
 
     Function<K, CompletableFuture<V>> mappingFunction = this::get;
-    var result = new LinkedHashMap<K, CompletableFuture<V>>();
+    var result = new LinkedHashMap<K, CompletableFuture<V>>(calculateHashMapCapacity(keys));
     for (K key : keys) {
       var future = result.computeIfAbsent(key, mappingFunction);
       requireNonNull(future);
@@ -200,7 +201,7 @@ public CompletableFuture<V> refresh(K key) {
 
     @Override
     public CompletableFuture<Map<K, V>> refreshAll(Iterable<? extends K> keys) {
-      var result = new LinkedHashMap<K, CompletableFuture<V>>();
+      var result = new LinkedHashMap<K, CompletableFuture<V>>(calculateHashMapCapacity(keys));
       for (K key : keys) {
         result.computeIfAbsent(key, this::refresh);
       }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalLoadingCache.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache;
 
+import static com.github.benmanes.caffeine.cache.Caffeine.calculateHashMapCapacity;
 import static com.github.benmanes.caffeine.cache.LocalAsyncCache.composeResult;
 import static java.util.Objects.requireNonNull;
 
@@ -67,7 +68,7 @@ default Map<K, V> getAll(Iterable<? extends K> keys) {
 
   /** Sequentially loads each missing entry. */
   default Map<K, V> loadSequentially(Iterable<? extends K> keys) {
-    var result = new LinkedHashMap<K, V>();
+    var result = new LinkedHashMap<K, V>(calculateHashMapCapacity(keys));
     for (K key : keys) {
       result.put(key, null);
     }
@@ -183,7 +184,7 @@ default CompletableFuture<V> refresh(K key) {
 
   @Override
   default CompletableFuture<Map<K, V>> refreshAll(Iterable<? extends K> keys) {
-    var result = new LinkedHashMap<K, CompletableFuture<V>>();
+    var result = new LinkedHashMap<K, CompletableFuture<V>>(calculateHashMapCapacity(keys));
     for (K key : keys) {
       result.computeIfAbsent(key, this::refresh);
     }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/UnboundedLocalCache.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache;
 
+import static com.github.benmanes.caffeine.cache.Caffeine.calculateHashMapCapacity;
 import static com.github.benmanes.caffeine.cache.LocalLoadingCache.newBulkMappingFunction;
 import static com.github.benmanes.caffeine.cache.LocalLoadingCache.newMappingFunction;
 import static java.util.Objects.requireNonNull;
@@ -146,7 +147,7 @@ public long estimatedSize() {
 
   @Override
   public Map<K, V> getAllPresent(Iterable<? extends K> keys) {
-    var result = new LinkedHashMap<Object, Object>();
+    var result = new LinkedHashMap<Object, Object>(calculateHashMapCapacity(keys));
     for (Object key : keys) {
       result.put(key, null);
     }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheProxy.java
Patch:
@@ -866,7 +866,7 @@ public CaffeineConfiguration<K, V> getConfiguration() {
   @Override
   public <T> Map<K, EntryProcessorResult<T>> invokeAll(Set<? extends K> keys,
       EntryProcessor<K, V, T> entryProcessor, Object... arguments) {
-    Map<K, EntryProcessorResult<T>> results = new HashMap<>(keys.size());
+    Map<K, EntryProcessorResult<T>> results = new HashMap<>(keys.size(), 1.0f);
     for (K key : keys) {
       try {
         T result = invoke(key, entryProcessor, arguments);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CacheTest.java
Patch:
@@ -285,7 +285,6 @@ public void getAllPresent_ordered(Cache<Int, Int> cache, CacheContext context) {
   @Test(dataProvider = "caches")
   @CacheSpec(population = Population.EMPTY)
   public void getAllPresent_jdk8186171(Cache<Object, Int> cache, CacheContext context) {
-    @SuppressWarnings("HashCodeToString")
     class Key {
       @Override public int hashCode() {
         return 0; // to put keys in one bucket
@@ -512,7 +511,6 @@ public void getAll_present_ordered_exceeds(Cache<Int, Int> cache, CacheContext c
   @Test(dataProvider = "caches")
   @CacheSpec(population = Population.EMPTY)
   public void getAll_jdk8186171(CacheContext context) {
-    @SuppressWarnings("HashCodeToString")
     class Key {
       @Override public int hashCode() {
         return 0; // to put keys in one bucket

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LoadingCacheTest.java
Patch:
@@ -381,7 +381,6 @@ public void getAll_present_ordered_exceeds(LoadingCache<Int, Int> cache, CacheCo
   @Test(dataProvider = "caches")
   @CacheSpec(population = Population.EMPTY)
   public void getAll_jdk8186171(CacheContext context) {
-    @SuppressWarnings("HashCodeToString")
     class Key {
       @Override public int hashCode() {
         return 0; // to put keys in one bucket

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/acceptance/CollidingInt.java
Patch:
@@ -14,7 +14,7 @@
 /**
  * Ported from Eclipse Collections 11.0.
  */
-@SuppressWarnings({"EqualsGetClass", "HashCodeToString"})
+@SuppressWarnings("EqualsGetClass")
 public class CollidingInt implements Serializable, Comparable<CollidingInt> {
   private static final long serialVersionUID = 1L;
   private final int value;

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/acceptance/UnifiedMapAcceptanceTest.java
Patch:
@@ -32,8 +32,7 @@
 /**
  * Ported from Eclipse Collections 11.0.
  */
-@SuppressWarnings({"deprecation", "rawtypes", "unchecked",
-  "CatchFail", "HashCodeToString", "ThreadPriorityCheck"})
+@SuppressWarnings({"deprecation", "rawtypes", "unchecked", "CatchFail", "ThreadPriorityCheck"})
 public abstract class UnifiedMapAcceptanceTest {
   private static final Logger LOGGER = LoggerFactory.getLogger(UnifiedMapAcceptanceTest.class);
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/mutable/IntegerSum.java
Patch:
@@ -15,7 +15,7 @@
  * @deprecated Don't use in new tests
  */
 @Deprecated
-@SuppressWarnings({"all", "EqualsUnsafeCast", "EqualsBrokenForNull", "HashCodeToString"})
+@SuppressWarnings({"all", "EqualsUnsafeCast", "EqualsBrokenForNull"})
 public final class IntegerSum implements Sum {
   private static final long serialVersionUID = 1L;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/mutable/IntegerWithCast.java
Patch:
@@ -12,7 +12,7 @@
 /**
  * Ported from Eclipse Collections 11.0.
  */
-@SuppressWarnings({"all", "EqualsUnsafeCast", "HashCodeToString"})
+@SuppressWarnings({"all", "EqualsUnsafeCast"})
 public final class IntegerWithCast {
   private final int value;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/mutable/UnifiedMapTestCase.java
Patch:
@@ -44,7 +44,7 @@
  * Ported from Eclipse Collections 11.0.
  */
 @SuppressWarnings({"all", "deprecation", "rawtypes", "unchecked",
-  "EqualsUnsafeCast", "EqualsBrokenForNull", "HashCodeToString", "UndefinedEquals"})
+  "EqualsUnsafeCast", "EqualsBrokenForNull", "UndefinedEquals"})
 public abstract class UnifiedMapTestCase extends MutableMapTestCase {
   protected static final Integer COLLISION_1 = 0;
   protected static final Integer COLLISION_2 = 17;

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/ConcurrentHashMapTest.java
Patch:
@@ -24,9 +24,8 @@
 
 import junit.framework.Test;
 
-@SuppressWarnings({"rawtypes", "unchecked", "ForEachIterable", "HashCodeToString",
-  "ModifyCollectionInEnhancedForLoop", "PreferredInterfaceType", "ReturnValueIgnored",
-  "UnnecessaryParentheses"})
+@SuppressWarnings({"rawtypes", "unchecked", "ForEachIterable", "ModifyCollectionInEnhancedForLoop",
+  "PreferredInterfaceType", "ReturnValueIgnored", "UnnecessaryParentheses"})
 public class ConcurrentHashMapTest extends JSR166TestCase {
     public static void main(String[] args) {
         main(suite(), args);

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/MapTest.java
Patch:
@@ -21,7 +21,7 @@
 /**
  * Contains tests applicable to all Map implementations.
  */
-@SuppressWarnings({"rawtypes", "unchecked", "HashCodeToString", "UnnecessaryParentheses"})
+@SuppressWarnings({"rawtypes", "unchecked", "UnnecessaryParentheses"})
 public class MapTest extends JSR166TestCase {
     final MapImplementation impl;
 

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheEvictionTest.java
Patch:
@@ -350,7 +350,6 @@ private void getAll(LoadingCache<Integer, Integer> cache, List<Integer> keys) {
     }
   }
 
-  @SuppressWarnings("HashCodeToString")
   private Object objectWithHash(final int hash) {
     return new Object() {
       @Override public int hashCode() {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/expiry/JCacheExpiryPolicy.java
Patch:
@@ -30,7 +30,6 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@SuppressWarnings("HashCodeToString")
 public final class JCacheExpiryPolicy implements ExpiryPolicy, Serializable {
   private static final long serialVersionUID = 1L;
 

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeFactoryGenerator.java
Patch:
@@ -30,7 +30,7 @@
 import static com.github.benmanes.caffeine.cache.Specifications.keySpec;
 import static com.github.benmanes.caffeine.cache.Specifications.lookupKeyType;
 import static com.github.benmanes.caffeine.cache.Specifications.rawReferenceKeyType;
-import static com.github.benmanes.caffeine.cache.Specifications.referenceKeyType;
+import static com.github.benmanes.caffeine.cache.Specifications.referenceType;
 import static com.github.benmanes.caffeine.cache.Specifications.vTypeVar;
 import static com.github.benmanes.caffeine.cache.Specifications.valueRefQueueSpec;
 import static com.github.benmanes.caffeine.cache.Specifications.valueSpec;
@@ -246,7 +246,7 @@ private MethodSpec newReferenceKeyMethod() {
     return MethodSpec.methodBuilder("newReferenceKey")
         .addJavadoc("Returns a key suitable for inserting into the cache. If the cache holds "
             + "keys strongly then\nthe key is returned. If the cache holds keys weakly "
-            + "then a {@link $T}\nholding the key argument is returned.\n", referenceKeyType)
+            + "then a {@link $T}\nholding the key argument is returned.\n", referenceType)
         .addModifiers(Modifier.PUBLIC, Modifier.DEFAULT)
         .addParameter(kTypeVar, "key")
         .addParameter(kRefQueueType, "referenceQueue")

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeSelectorCode.java
Patch:
@@ -32,6 +32,9 @@ public final class NodeSelectorCode {
 
   private NodeSelectorCode() {
     block = CodeBlock.builder()
+        .beginControlFlow("if (builder.interner)")
+            .addStatement("return new Interned<>()")
+        .endControlFlow()
         .addStatement("$1T sb = new $1T(\"$2N.\")",
             StringBuilder.class, NODE_FACTORY.rawType.packageName());
   }

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/Specifications.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.VarHandle;
+import java.lang.ref.Reference;
 import java.lang.ref.ReferenceQueue;
 
 import com.squareup.javapoet.ClassName;
@@ -46,6 +47,8 @@ public final class Specifications {
   public static final ClassName nodeType = ClassName.get(PACKAGE_NAME, "Node");
   public static final TypeName lookupKeyType =
       ClassName.get(PACKAGE_NAME + ".References", "LookupKeyReference");
+  public static final TypeName referenceType = ParameterizedTypeName.get(
+      ClassName.get(Reference.class), kTypeVar);
   public static final TypeName referenceKeyType = ParameterizedTypeName.get(
       ClassName.get(PACKAGE_NAME + ".References", "WeakKeyReference"), kTypeVar);
   public static final TypeName rawReferenceKeyType = ParameterizedTypeName.get(

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddKey.java
Patch:
@@ -16,7 +16,7 @@
 package com.github.benmanes.caffeine.cache.node;
 
 import static com.github.benmanes.caffeine.cache.Specifications.kTypeVar;
-import static com.github.benmanes.caffeine.cache.Specifications.referenceKeyType;
+import static com.github.benmanes.caffeine.cache.Specifications.referenceType;
 
 import java.util.List;
 
@@ -78,7 +78,7 @@ private void addIfCollectedValue() {
     if (isStrongKeys()) {
       getKey.addStatement("return ($T) valueRef.getKeyReference()", kTypeVar);
     } else {
-      getKey.addStatement("$1T keyRef = ($1T) valueRef.getKeyReference()", referenceKeyType);
+      getKey.addStatement("$1T keyRef = ($1T) valueRef.getKeyReference()", referenceType);
       getKey.addStatement("return keyRef.get()");
     }
     context.nodeSubtype.addMethod(getKey.build());

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Cache.java
Patch:
@@ -46,8 +46,8 @@ public interface Cache<K extends Object, V extends Object> {
    * cached value for the {@code key}.
    *
    * @param key the key whose associated value is to be returned
-   * @return the value to which the specified key is mapped, or {@code null} if this cache contains
-   *         no mapping for the key
+   * @return the value to which the specified key is mapped, or {@code null} if this cache does not
+   *         contain a mapping for the key
    * @throws NullPointerException if the specified key is null
    */
   @Nullable

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LocalCacheSubject.java
Patch:
@@ -30,6 +30,7 @@
 import com.github.benmanes.caffeine.cache.BoundedLocalCache.BoundedLocalAsyncLoadingCache;
 import com.github.benmanes.caffeine.cache.BoundedLocalCache.BoundedLocalManualCache;
 import com.github.benmanes.caffeine.cache.LocalAsyncLoadingCache.LoadingCacheView;
+import com.github.benmanes.caffeine.cache.References.WeakKeyEqualsReference;
 import com.github.benmanes.caffeine.cache.References.WeakKeyReference;
 import com.github.benmanes.caffeine.cache.TimerWheel.Sentinel;
 import com.github.benmanes.caffeine.cache.UnboundedLocalCache.UnboundedLocalAsyncCache;
@@ -341,7 +342,8 @@ private void checkKey(BoundedLocalCache<Object, Object> bounded,
       if ((key != null) && (value != null)) {
         check("bounded").that(bounded).containsKey(key);
       }
-      check("keyReference").that(node.getKeyReference()).isInstanceOf(WeakKeyReference.class);
+      var clazz = node instanceof Interned ? WeakKeyEqualsReference.class : WeakKeyReference.class;
+      check("keyReference").that(node.getKeyReference()).isInstanceOf(clazz);
     } else {
       check("key").that(key).isNotNull();
     }

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaCache.java
Patch:
@@ -239,7 +239,7 @@ static final class CacheLoaderException extends RuntimeException {
     CacheLoaderException(Exception e) {
       super(e);
     }
-    @SuppressWarnings("UnsynchronizedOverridesSynchronized")
+    @SuppressWarnings({"UnsynchronizedOverridesSynchronized", "lgtm [java/non-sync-override]"})
     @Override public Throwable fillInStackTrace() {
       return this;
     }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheLoader.java
Patch:
@@ -97,7 +97,7 @@ public interface CacheLoader<K extends Object, V extends Object> extends AsyncCa
    * @return the future value associated with {@code key}
    */
   @Override
-  default CompletableFuture<? extends V> asyncLoad(K key, Executor executor) {
+  default CompletableFuture<? extends V> asyncLoad(K key, Executor executor) throws Exception {
     requireNonNull(key);
     requireNonNull(executor);
     return CompletableFuture.supplyAsync(() -> {
@@ -133,7 +133,7 @@ default CompletableFuture<? extends V> asyncLoad(K key, Executor executor) {
    */
   @Override
   default CompletableFuture<? extends Map<? extends K, ? extends V>> asyncLoadAll(
-      Set<? extends K> keys, Executor executor) {
+      Set<? extends K> keys, Executor executor) throws Exception {
     requireNonNull(keys);
     requireNonNull(executor);
     return CompletableFuture.supplyAsync(() -> {

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaCache.java
Patch:
@@ -31,7 +31,6 @@
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import com.github.benmanes.caffeine.guava.CaffeinatedGuavaCache.CacheLoaderException;
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheLoader.InvalidCacheLoadException;
 import com.google.common.cache.CacheStats;

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeFactoryGenerator.java
Patch:
@@ -97,8 +97,8 @@
  * </ul>
  * <p>
  * If the cache has either a maximum size or expires after access, then the entry will also contain
- * prev/next references on a access ordered queue. If the cache expires after write, then the entry
- * will also contain prev/next on a write ordered queue.
+ * prev/next references for an access-ordered queue. If the cache expires after write, then the
+ * entry will also contain prev/next for a write-ordered queue.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/CacheType.java
Patch:
@@ -56,8 +56,8 @@ public enum CacheType {
   },
   NonBlockingHashMap {
     @Override public <K, V> BasicCache<K, V> create(int maximumSize) {
-      // Note that writes that update an entry to the same reference are short circuited
-      // and do not mutate the hash table. This makes those writes equal to a read.
+      // Note that writes that update an entry to the same reference are short-circuited
+      // and do not mutate the hash table. This causes those writes to be equivalent to a read.
       return new ConcurrentMapCache<>(new NonBlockingHashMap<>(maximumSize));
     }
   },
@@ -132,7 +132,7 @@ public enum CacheType {
 
   /**
    * Creates the cache with the maximum size. Note that some implementations may evict prior to
-   * this threshold and it is the caller's responsibility to adjust accordingly.
+   * this threshold, and it is the caller's responsibility to adjust accordingly.
    */
   public abstract <K, V> BasicCache<K, V> create(int maximumSize);
 }

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/GetPutBenchmark.java
Patch:
@@ -82,7 +82,7 @@ public void setup() {
     cache.clear();
     cache.cleanUp();
 
-    // Populate with a realistic access distribution
+    // Populate using a realistic access distribution
     NumberGenerator generator = new ScrambledZipfianGenerator(ITEMS);
     for (int i = 0; i < SIZE; i++) {
       ints[i] = generator.nextValue().intValue();

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/MemoryBenchmark.java
Patch:
@@ -36,7 +36,7 @@
 /**
  * A non-JMH benchmark to compare the memory overhead of different cache implementations. Note that
  * the measurements estimate based on the current JVM configuration, e.g. 64-bit with compressed
- * references if the benchmark is executed with a heap under 32GB. This can means that object
+ * references if the benchmark is executed with a heap under 32GB. This can mean that object
  * padding may or may not have a visible effect.
  * <p>
  * This benchmark requires a JavaAgent to evaluate the object sizes and can be executed using

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/PutRemoveBenchmark.java
Patch:
@@ -83,7 +83,7 @@ public void setup() {
     }
     cache.clear();
 
-    // Populate with a realistic access distribution
+    // Populate using a realistic access distribution
     NumberGenerator generator = new ScrambledZipfianGenerator(ITEMS);
     for (int i = 0; i < SIZE; i++) {
       ints[i] = generator.nextValue().intValue();

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedBuffer.java
Patch:
@@ -159,7 +159,7 @@ abstract static class PadWriteCounter extends ReadCounterRef {
     byte p232, p233, p234, p235, p236, p237, p238, p239;
   }
 
-  /** Enforces a memory layout to avoid false sharing by padding the write count. */
+  /** Enforces a memory layout to avoid false sharing by padding the write counter. */
   abstract static class ReadAndWriteCounterRef extends PadWriteCounter {
     static final VarHandle READ, WRITE;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/FrequencySketch.java
Patch:
@@ -124,7 +124,7 @@ public int frequency(E e) {
 
   /**
    * Increments the popularity of the element if it does not exceed the maximum (15). The popularity
-   * of all elements will be periodically down sampled when the observed events exceeds a threshold.
+   * of all elements will be periodically down sampled when the observed events exceed a threshold.
    * This process provides a frequency aging to allow expired long term entries to fade away.
    *
    * @param e the element to add

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalCache.java
Patch:
@@ -52,7 +52,7 @@ interface LocalCache<K, V> extends ConcurrentMap<K, V> {
   /** Returns the map of in-flight refresh operations. */
   ConcurrentMap<Object, CompletableFuture<?>> refreshes();
 
-  /** Returns whether the cache captures the write time of the entry. */
+  /** Returns whether the cache captures the write-time of the entry. */
   boolean hasWriteTime();
 
   /** Returns the {@link Expiry} used by this cache. */
@@ -69,14 +69,14 @@ interface LocalCache<K, V> extends ConcurrentMap<K, V> {
 
   /**
    * See {@link Cache#getIfPresent(K)}. This method differs by accepting a parameter of whether
-   * to record the hit and miss statistics based on the success of this operation.
+   * to record the hit-and-miss statistics based on the success of this operation.
    */
   @Nullable
   V getIfPresent(K key, boolean recordStats);
 
   /**
    * See {@link Cache#getIfPresent(K)}. This method differs by not recording the access with
-   * the statistics nor the eviction policy, and populates the write time if known.
+   * the statistics nor the eviction policy, and populates the write-time if known.
    */
   @Nullable
   V getIfPresentQuietly(K key, long[/* 1 */] writeTime);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/MpscGrowableArrayQueue.java
Patch:
@@ -455,7 +455,7 @@ public final int size() {
   public final boolean isEmpty() {
     // Order matters!
     // Loading consumer before producer allows for producer increments after consumer index is read.
-    // This ensures this method is conservative in it's estimate. Note that as this is an MPMC there
+    // This ensures this method is conservative in its estimate. Note that as this is an MPMC there
     // is nothing we can do to make this an exact method.
     return (lvConsumerIndex(this) == lvProducerIndex(this));
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Node.java
Patch:
@@ -241,13 +241,13 @@ public long getWriteTime() {
   }
 
   /**
-   * Sets the write time in nanoseconds. This update may be set lazily and rely on the memory fence
+   * Sets the write-time in nanoseconds. This update may be set lazily and rely on the memory fence
    * when the lock is released.
    */
   public void setWriteTime(long time) {}
 
   /**
-   * Atomically sets the write time to the given updated value if the current value equals the
+   * Atomically sets the write-time to the given updated value if the current value equals the
    * expected value and returns if the update was successful.
    */
   public boolean casWriteTime(long expect, long update) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/References.java
Patch:
@@ -48,8 +48,8 @@ interface InternalReference<E> {
 
     /**
      * Returns the key that is associated to the cache entry holding this reference. If the cache
-     * holds keys strongly, this is that key instance. Otherwise the cache holds keys weakly and the
-     * {@link WeakKeyReference} is returned.
+     * holds keys strongly, this is that key instance. Otherwise, the cache holds keys weakly and
+     * the {@link WeakKeyReference} is returned.
      *
      * @return the key that is associated to the cached entry
      */

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Scheduler.java
Patch:
@@ -79,7 +79,7 @@ static Scheduler forScheduledExecutorService(ScheduledExecutorService scheduledE
    * {@code scheduler}.
    *
    * @param scheduler the scheduler to delegate to
-   * @return an scheduler that suppresses and logs any exception thrown by the delegate
+   * @return a scheduler that suppresses and logs any exception thrown by the delegate
    */
   static Scheduler guardedScheduler(Scheduler scheduler) {
     return (scheduler instanceof GuardedScheduler) ? scheduler : new GuardedScheduler(scheduler);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -1045,15 +1045,15 @@ public void put_expireTolerance_expiry(BoundedLocalCache<Int, Int> cache, CacheC
     assertThat(cache.readBuffer.writes()).isEqualTo(1);
     assertThat(cache.writeBuffer.producerIndex).isEqualTo(4);
 
-    // If the expire time reduces by more than the tolerance, treat the update as a write
+    // If the expiration time reduces by more than the tolerance, treat the update as a write
     when(context.expiry().expireAfterUpdate(any(), any(), anyLong(), anyLong()))
         .thenReturn(Expire.ONE_MILLISECOND.timeNanos());
     cache.put(Int.valueOf(1), Int.valueOf(4));
     assertThat(cache.readBuffer.reads()).isEqualTo(1);
     assertThat(cache.readBuffer.writes()).isEqualTo(1);
     assertThat(cache.writeBuffer.producerIndex).isEqualTo(6);
 
-    // If the expire time increases by more than the tolerance, treat the update as a write
+    // If the expiration time increases by more than the tolerance, treat the update as a write
     when(context.expiry().expireAfterUpdate(any(), any(), anyLong(), anyLong()))
         .thenReturn(Expire.FOREVER.timeNanos());
     cache.put(Int.valueOf(1), Int.valueOf(4));

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterAccessTest.java
Patch:
@@ -57,7 +57,7 @@
 import com.google.common.collect.Maps;
 
 /**
- * The test cases for caches that support the expire after read (time-to-idle) policy.
+ * The test cases for caches that support the expire-after-read (time-to-idle) policy.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterWriteTest.java
Patch:
@@ -57,7 +57,7 @@
 import com.google.common.collect.Maps;
 
 /**
- * The test cases for caches that support the expire after write (time-to-live) policy.
+ * The test cases for caches that support the expire-after-write (time-to-live) policy.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LinkedDequeTests.java
Patch:
@@ -46,8 +46,8 @@ public final class LinkedDequeTests extends TestCase {
   static final LinkedValue d = new LinkedValue("d");
   static final LinkedValue e = new LinkedValue("e");
 
-  // Due to stateful elements, tests calling resetCollection() for an comparable iterator will
-  // cause unexpected mutations. Instead a different collection type should be used for comparison
+  // Due to stateful elements, tests calling resetCollection() for a comparable iterator will
+  // cause unexpected mutations. Instead, a different collection type should be used for comparison
   static final ThreadLocal<Boolean> useTarget = ThreadLocal.withInitial(() -> false);
 
   public static Test suite() throws Exception {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/MpscGrowableArrayQueueLincheckTest.java
Patch:
@@ -58,7 +58,7 @@ public Integer poll() {
    * This test checks that the concurrent map is linearizable with bounded model checking. Unlike
    * stress testing, this approach can also provide a trace of an incorrect execution. However, it
    * uses sequential consistency model, so it can not find any low-level bugs (e.g., missing
-   * 'volatile'), and thus, it it recommended to have both test modes.
+   * 'volatile'), and thus, it is recommended to have both test modes.
    * <p>
    * This test requires the following JVM arguments,
    * <ul>

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/MpscGrowableQueueSanityTest.java
Patch:
@@ -35,10 +35,10 @@ public MpscGrowableQueueSanityTest(
   @Parameterized.Parameters
   public static List<Object[]> parameters() {
     var list = new ArrayList<Object[]>();
-    // MPSC size 1
+    // MPSC size: 1
     list.add(makeQueue(0, 1, 4, org.jctools.queues.spec.Ordering.FIFO,
         new MpscGrowableArrayQueue<>(2, 4)));
-    // MPSC size SIZE
+    // MPSC size: SIZE
     list.add(makeQueue(0, 1, SIZE, org.jctools.queues.spec.Ordering.FIFO,
         new MpscGrowableArrayQueue<>(8, SIZE)));
     return list;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ReferenceTest.java
Patch:
@@ -888,7 +888,7 @@ public void entrySet_contains_nullValue(Map<Int, Int> map, CacheContext context)
     assertThat(map.entrySet().contains(entry)).isFalse();
   }
 
-  /** Ensures that that all the pending work is performed (Guava limits work per cycle). */
+  /** Ensures that all of the pending work is performed (Guava limits work per cycle). */
   private static void awaitFullCleanup(Cache<?, ?> cache) {
     int attempts = 0;
     for (;;) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/FastFlowBuffer.java
Patch:
@@ -136,7 +136,7 @@ abstract static class PadWriteCounter<E> extends ReadCounterRef<E> {
     long p50, p51, p52, p53, p54, p55, p56, p57;
   }
 
-  /** Enforces a memory layout to avoid false sharing by padding the write count. */
+  /** Enforces a memory layout to avoid false sharing by padding the write counter. */
   abstract static class ReadAndWriteCounterRef<E> extends PadWriteCounter<E> {
     static final long WRITE_OFFSET =
         UnsafeAccess.fieldOffset(ReadAndWriteCounterRef.class, "writeCounter");

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/ManyToOneBuffer.java
Patch:
@@ -113,7 +113,7 @@ abstract static class PadWriteCounter<E> extends ReadCounterRef<E> {
     long p30, p31, p32, p33, p34, p35, p36, p37;
   }
 
-  /** Enforces a memory layout to avoid false sharing by padding the write count. */
+  /** Enforces a memory layout to avoid false sharing by padding the write counter. */
   abstract static class ReadAndWriteCounterRef<E> extends PadWriteCounter<E> {
     static final long WRITE_OFFSET =
         UnsafeAccess.fieldOffset(ReadAndWriteCounterRef.class, "writeCounter");

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/ManyToOneSpacedBuffer.java
Patch:
@@ -117,7 +117,7 @@ abstract static class PadWriteCounter<E> extends ReadCounterRef<E> {
     long p30, p31, p32, p33, p34, p35, p36, p37;
   }
 
-  /** Enforces a memory layout to avoid false sharing by padding the write count. */
+  /** Enforces a memory layout to avoid false sharing by padding the write counter. */
   abstract static class ReadAndWriteCounterRef<E> extends PadWriteCounter<E> {
     static final long WRITE_OFFSET =
         UnsafeAccess.fieldOffset(ReadAndWriteCounterRef.class, "writeCounter");

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/TicketBuffer.java
Patch:
@@ -26,8 +26,8 @@
  * strict sequence and backing off on contention or when full. It uses a PTL scheme where the empty
  * slot is the next write counter value.
  * <p>
- * The negatives of this algorithm is that it uses a boxed instance of the write index to
- * track if the slot is free. This allows the buffer to be non-blocking, whereas PTL is blocking.
+ * The negatives of this algorithm is that it uses a boxed instance of the write index to track if
+ * the slot is free. This allows the buffer to be non-blocking, whereas PTL is blocking.
  *
  * https://blogs.oracle.com/dave/entry/ptlqueue_a_scalable_bounded_capacity
  *

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Issue193Test.java
Patch:
@@ -93,6 +93,6 @@ public void invalidateDuringRefreshRemovalCheck() throws Exception {
     assertThat(cache).doesNotContainKey(key); // Value in cache (bad)
 
     // FIXME: Maybe? This is what I wanted to actually test :)
-    assertThat(removed).containsExactly(0L, 1L).inOrder(); // 1L was sent to removalListener anyways
+    assertThat(removed).containsExactly(0L, 1L).inOrder(); // 1L was sent to removalListener anyway
   }
 }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Issue298Test.java
Patch:
@@ -40,7 +40,7 @@
  * <p>
  * When a future value in an AsyncCache is in-flight, the entry has an infinite expiration time to
  * disable eviction. When it completes, a callback performs a no-op write into the cache to
- * update its metadata (expiration, weight, etc). This may race with a reader who obtains a
+ * update its metadata (expiration, weight, etc.). This may race with a reader who obtains a
  * completed future, reads the current duration as infinite, and tries to set the expiration time
  * accordingly (to indicate no change). If the writer completes before the reader updates, then we
  * encounter an ABA problem where the entry is set to never expire.

File: caffeine/src/test/java/com/github/benmanes/caffeine/lincheck/AbstractLincheckCacheTest.java
Patch:
@@ -51,7 +51,7 @@ public AbstractLincheckCacheTest(Caffeine<Object, Object> builder) {
    * This test checks linearizability with bounded model checking. Unlike stress testing, this
    * approach can also provide a trace of an incorrect execution. However, it uses sequential
    * consistency model, so it can not find any low-level bugs (e.g., missing 'volatile'), and thus,
-   * it it recommended to have both test modes.
+   * it is recommended to have both test modes.
    * <p>
    * This test requires the following JVM arguments,
    * <ul>

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/Threads.java
Patch:
@@ -44,7 +44,7 @@
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 
 /**
- * Shared utilities for multi-threaded tests.
+ * Shared utilities for multithreaded tests.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheLoadingTest.java
Patch:
@@ -2122,7 +2122,7 @@ public String load(String key) {
     assertEquals(refreshKey + suffix, map.get(refreshKey));
   }
 
-  // ConcurrentHashMap does not support this, as it must return back the removed entry
+  // ConcurrentHashMap does not support this, as it returns the removed entry
   public void disabled_testInvalidateDuringLoading() throws InterruptedException {
     // computation starts; invalidate() is called on the key being computed, computation finishes
     final CountDownLatch computationStarted = new CountDownLatch(2);
@@ -2174,7 +2174,7 @@ public String load(String key) {
     assertEquals(2, cache.size());
   }
 
-  // ConcurrentHashMap does not support this, as it must return back the removed entry
+  // ConcurrentHashMap does not support this, as it returns the removed entry
   public void disabled_testInvalidateAndReloadDuringLoading()
       throws InterruptedException, ExecutionException {
     // computation starts; clear() is called, computation finishes

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheFactory.java
Patch:
@@ -54,7 +54,7 @@ final class CacheFactory {
   private CacheFactory() {}
 
   /**
-   * Returns a if the cache definition is found in the external settings file.
+   * Returns if the cache definition is found in the external settings file.
    *
    * @param cacheName the name of the cache
    * @return {@code true} if a definition exists
@@ -239,7 +239,7 @@ private boolean configureMaximumWeight() {
       return config.getMaximumWeight().isPresent();
     }
 
-    /** Configures the write expiration and returns if set. */
+    /** Configures write expiration and returns if set. */
     @SuppressWarnings("PreferJavaTimeOverload")
     private boolean configureExpireAfterWrite() {
       if (config.getExpireAfterWrite().isEmpty()) {
@@ -249,7 +249,7 @@ private boolean configureExpireAfterWrite() {
       return true;
     }
 
-    /** Configures the access expiration and returns if set. */
+    /** Configures access expiration and returns if set. */
     @SuppressWarnings("PreferJavaTimeOverload")
     private boolean configureExpireAfterAccess() {
       if (config.getExpireAfterAccess().isEmpty()) {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheProxy.java
Patch:
@@ -280,7 +280,7 @@ public void loadAll(Set<? extends K> keys, boolean replaceExistingValues,
     future.whenComplete((r, e) -> inFlight.remove(future));
   }
 
-  /** Performs the bulk load where the existing entries are replace. */
+  /** Performs the bulk load where the existing entries are replaced. */
   private void loadAllAndReplaceExisting(Set<? extends K> keys) {
     int[] ignored = { 0 };
     @SuppressWarnings("NullAway")
@@ -809,7 +809,7 @@ public CaffeineConfiguration<K, V> getConfiguration() {
     return castedResult;
   }
 
-  /** Returns the updated expirable value after performing the post processing actions. */
+  /** Returns the updated expirable value after performing the post-processing actions. */
   @SuppressWarnings({"fallthrough", "PMD.MissingBreakInSwitch",
     "PMD.SwitchStmtsShouldHaveDefault", "NullAway"})
   private @Nullable Expirable<V> postProcess(Expirable<V> expirable,
@@ -1178,7 +1178,7 @@ protected final void setAccessExpirationTime(K key, Expirable<?> expirable, long
   /**
    * Returns the time when the entry will expire.
    *
-   * @param created if the write is an insert or update
+   * @param created if the write operation is an insert or an update
    * @return the time when the entry will expire, zero if it should expire immediately,
    *         Long.MIN_VALUE if it should not be changed, or Long.MAX_VALUE if eternal
    */

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurator.java
Patch:
@@ -229,7 +229,7 @@ private void addReadThrough() {
       }
     }
 
-    /** Adds the write through settings. */
+    /** Adds the write-through settings. */
     private void addWriteThrough() {
       configuration.setWriteThrough(merged.getBoolean("write-through.enabled"));
       if (isSet("write-through.writer")) {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/spi/CaffeineCachingProvider.java
Patch:
@@ -44,8 +44,8 @@
 import com.typesafe.config.ConfigFactory;
 
 /**
- * A provider that produces a JCache implementation backed by Caffeine. Typically this provider is
- * instantiated using {@link Caching#getCachingProvider()}, which discovers this implementation
+ * A provider that produces a JCache implementation backed by Caffeine. Typically, this provider is
+ * instantiated using {@link Caching#getCachingProvider()} which discovers this implementation
  * through a {@link java.util.ServiceLoader}.
  * <p>
  * This provider is expected to be used for application life cycle events, like initialization. It

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/Synthetic.java
Patch:
@@ -120,10 +120,10 @@ public static LongStream exponential(double mean, int events) {
 
   /**
    * Returns a sequence of events resembling a hotspot distribution where x% of operations access y%
-   * of data items. The parameters specify the bounds for the numbers, the percentage of the of the
+   * of data items. The parameters specify the bounds for the numbers, the percentage of the
    * interval which comprises the hot set and the percentage of operations that access the hot set.
    * Numbers of the hot set are always smaller than any number in the cold set. Elements from the
-   * hot set and the cold set are chose using a uniform distribution.
+   * hot set and the cold set are chosen using a uniform distribution.
    *
    * @param lowerBound lower bound of the distribution
    * @param upperBound upper bound of the distribution

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/ClimberResetCountMin4.java
Patch:
@@ -100,8 +100,8 @@ protected void tryReset(boolean added) {
 
   @Override
   public void reportMiss() {
-    // Each time there is a miss, TinyLFU invokes the reportMiss function and we can
-    // make decisions
+    // Each time there is a miss, TinyLFU will invoke the reportMiss function to allow us to make a
+    // decision
     misses++;
 
     if (eventsToCount <= 0) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/CountMin4.java
Patch:
@@ -92,7 +92,7 @@ public int frequency(long e) {
 
   /**
    * Increments the popularity of the element if it does not exceed the maximum (15). The popularity
-   * of all elements will be periodically down sampled when the observed events exceeds a threshold.
+   * of all elements will be periodically down sampled when the observed events exceed a threshold.
    * This process provides a frequency aging to allow expired long term entries to fade away.
    *
    * @param e the element to add

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin64/CountMin64.java
Patch:
@@ -40,7 +40,7 @@ public CountMin64(double eps, double confidence, int seed) {
     this.hashA = new long[depth];
 
     // We're using a linear hash functions of the form ((a*x+b) mod p) where a,b are chosen
-    // independently for each hash function. However we can set b = 0 as all it does is shift the
+    // independently for each hash function. However, we can set b = 0 as all it does is shift the
     // results without compromising their uniformity or independence with the other hashes.
     Random r = new Random(seed);
     for (int i = 0; i < depth; ++i) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/perfect/PerfectFrequency.java
Patch:
@@ -24,7 +24,7 @@
 import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
 
 /**
- * A the perfect frequency with aging performed using a periodic reset.
+ * A perfect frequency with aging performed using a periodic reset.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/HashFunctionParser.java
Patch:
@@ -22,7 +22,7 @@
  * @author gilga1983@gmail.com (Gil Einziger)
  */
 public final class HashFunctionParser {
-  // currently chain is bounded to be 64.
+  // currently, chain is bounded to be 64.
   private static final int fpSize = 8; // this implementation assumes byte.
   private static final byte fpMask = (byte) 255; // (all bits in byte are 1, (logical value of -1));
   private static final long chainMask = 63L; // (6 first bit are set to 1).

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinyCache.java
Patch:
@@ -69,8 +69,8 @@ public boolean contains(long item) {
   }
 
   /**
-   * Implementing add and remove together in one function, means that less items are shifted.
-   * (reduction of 3 times from trivial implementation).
+   * Implementing add and remove together in one function means that fewer items are shifted
+   * (reduction of 3 times from the trivial implementation).
    */
   private int replace(HashedItem fpaux, byte victim, int bucketStart, int removedOffset) {
     byte chainId = fpaux.chainId;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinyCacheSketch.java
Patch:
@@ -71,8 +71,8 @@ public int countItem(long item) {
   }
 
   /**
-   * Implementing add and remove together in one function, means that less items are shifted.
-   * (reduction of 3 times from trivial implementation).
+   * Implementing add and remove together in one function means that fewer items are shifted
+   * (reduction of 3 times from the trivial implementation).
    */
   private int replace(HashedItem fpaux, byte victim, int bucketStart, int removedOffset) {
     byte chainId = fpaux.chainId;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinyCacheWithGhostCache.java
Patch:
@@ -73,8 +73,8 @@ public boolean contains(long item) {
   }
 
   /**
-   * Implementing add and remove together in one function, means that less items are shifted.
-   * (reduction of 3 times from trivial implementation).
+   * Implementing add and remove together in one function means that fewer items are shifted
+   * (reduction of 3 times from the trivial implementation).
    */
   private int replace(HashedItem fpaux, byte victim, int bucketStart, int removedOffset) {
     byte chainId = fpaux.chainId;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinySetIndexing.java
Patch:
@@ -17,8 +17,8 @@
 
 /**
  * An implementation of TinySet's indexing method. A method to index a succinct hash table that is
- * only 2 bits from theoretical lower bound. This is only the indexing technique and it helps
- * calculate offsets in array using two indexes. chainIndex - (set bit for non empty chain/unset for
+ * only 2 bits from theoretical lower bound. This is only the indexing technique, and it helps
+ * calculate offsets in array using two indexes. chainIndex - (set bit for non-empty chain/unset for
  * empty) isLastIndex (set bit for last in chain/empty bit for not last in chain). Both indexes are
  * assumed to be 64 bits, (longs) for efficiency and simplicity. The technique update the indexes
  * upon addition/removal.

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/membership/Membership.java
Patch:
@@ -31,7 +31,7 @@ public interface Membership {
    */
   boolean mightContain(long e);
 
-  /** Removes all of the elements from this collection. */
+  /** Removes the elements from this collection. */
   void clear();
 
   /**

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/adaptive/ArcPolicy.java
Patch:
@@ -34,7 +34,7 @@
  * being monitored (B1, B2). The maximum size of the T1 and T2 queues is adjusted dynamically based
  * on the workload patterns and effectiveness of the cache.
  * <p>
- * This implementation is based on the pseudo code provided by the authors in their paper
+ * This implementation is based on the pseudocode provided by the authors in their paper
  * <a href="http://www.cs.cmu.edu/~15-440/READINGS/megiddo-computer2004.pdf">Outperforming LRU with
  * an Adaptive Replacement Cache Algorithm</a> and is further described in their paper,
  * <a href="https://www.usenix.org/event/fast03/tech/full_papers/megiddo/megiddo.pdf">ARC: A

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/adaptive/CarPolicy.java
Patch:
@@ -31,7 +31,8 @@
 /**
  * Clock with Adaptive Replacement policy. This algorithm differs from ARC by replacing the LRU
  * policy with the Clock (Second Chance) policy. This allows cache hits to be performed concurrently
- * at the cost of a global lock on a miss and a worst case O(2n) eviction as the queues are scanned.
+ * at the cost of a global lock on a miss and has the worst case time of O(2n) on eviction due to
+ * queues being scanned.
  * <p>
  * This implementation is based on the pseudo code provided by the authors in their paper <a href=
  * "https://www.usenix.org/legacy/publications/library/proceedings/fast04/tech/full_papers/bansal/bansal.pdf">

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/adaptive/CartPolicy.java
Patch:
@@ -34,7 +34,7 @@
  * and pages that are re-requested outside the window are of long-term utility. The temporal
  * locality window is an adaptable parameter of the algorithm.
  * <p>
- * This implementation is based on the pseudo code provided by the authors in their paper <a href=
+ * This implementation is based on the pseudocode provided by the authors in their paper<a href=
  * "https://www.usenix.org/legacy/publications/library/proceedings/fast04/tech/full_papers/bansal/bansal.pdf">
  * CAR: Clock with Adaptive Replacement</a> and is further described in their paper,
  * <p>
@@ -209,7 +209,7 @@ private static boolean isGhost(Node node) {
   }
 
   private void demote() {
-    // while (the page reference bit of the head page in T2 is 1)) then
+    // while (the page reference bit of the head page in T2 is 1) then
     //   Move the head page in T2 to tail position in T1
     //   Reset the page reference bit
     //   if (|T2|+|B2|+|T1|−nS ≥ c) then

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/FrdPolicy.java
Patch:
@@ -222,8 +222,8 @@ enum Status {
   }
 
   enum StackType {
-    FILTER, // holds all of the resident filter blocks
-    MAIN,   // holds all of the resident and non-resident blocks
+    FILTER, // holds the resident filter blocks
+    MAIN,   // holds the resident and non-resident blocks
   }
 
   final class Node {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/HillClimberFrdPolicy.java
Patch:
@@ -318,8 +318,8 @@ enum Status {
   }
 
   enum StackType {
-    FILTER, // holds all of the resident filter blocks
-    MAIN,   // holds all of the resident and non-resident blocks
+    FILTER, // holds the resident filter blocks
+    MAIN,   // holds the resident and non-resident blocks
   }
 
   final class Node {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/IndicatorFrdPolicy.java
Patch:
@@ -287,8 +287,8 @@ enum Status {
   }
 
   enum StackType {
-    FILTER, // holds all of the resident filter blocks
-    MAIN,   // holds all of the resident and non-resident blocks
+    FILTER, // holds the resident filter blocks
+    MAIN,   // holds the resident and non-resident blocks
   }
 
   final class Node {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/LirsPolicy.java
Patch:
@@ -340,8 +340,8 @@ enum Status {
   }
 
   // S holds three types of blocks, LIR blocks, resident HIR blocks, non-resident HIR blocks
-  // Q holds all of the resident HIR blocks
-  // NR holds all of the non-resident HIR blocks
+  // Q holds the resident HIR blocks
+  // NR holds the non-resident HIR blocks
   enum StackType {
     // We store LIR blocks and HIR blocks with their recencies less than the maximum recency of the
     // LIR blocks in a stack called LIRS stack S. S is similar to the LRU stack in operation but has

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/MultiQueuePolicy.java
Patch:
@@ -41,10 +41,10 @@
  * frequency and be eagerly promoted.
  * <p>
  * This policy is designed for second-level caches where a hit in this cache was a miss at the first
- * level. Thus the first-level cache captures most of the recency information and the second-level
+ * level. Thus, the first-level cache captures most of the recency information and the second-level
  * cache access is dominated by usage frequency.
  * <p>
- * This implementation is based on the pseudo code provided by the authors in their paper
+ * This implementation is based on the pseudocode provided by the authors in their paper
  * <a href="https://www.usenix.org/legacy/event/usenix01/full_papers/zhou/zhou.pdf">The Multi-Queue
  * Replacement Algorithm for Second Level. Buffer Caches</a>.
  *

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/opt/ClairvoyantPolicy.java
Patch:
@@ -116,7 +116,7 @@ private void process(long key, double hitPenalty, double missPenalty) {
     }
   }
 
-  /** Removes the entry whose next access is farthest away into the future. */
+  /** Removes the entry whose next access is the farthest away into the future. */
   private void evict() {
     data.remove(data.lastInt());
     policyStats.recordEviction();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sampled/SampledPolicy.java
Patch:
@@ -44,7 +44,7 @@
 /**
  * A cache that uses a sampled array of entries to implement simple page replacement algorithms.
  * <p>
- * The sampling approach for an approximate of classical policies is described
+ * The sampling approach for an approximation of classical policies is described
  * <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.110.8469">Efficient Randomized Web
  * Cache Replacement Schemes Using Samples from Past Eviction Times</a>. The Hyperbolic algorithm is
  * a newer addition to this family and is described in

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/WindowTinyLfuPolicy.java
Patch:
@@ -152,7 +152,7 @@ private void onProbationHit(Node node) {
     }
   }
 
-  /** Moves the entry to the MRU position, if it falls outside of the fast-path threshold. */
+  /** Moves the entry to the MRU position if it falls outside of the fast-path threshold. */
   private void onProtectedHit(Node node) {
     admittor.record(node.key);
     node.moveToTail(headProtected);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/HillClimberWindowTinyLfuPolicy.java
Patch:
@@ -47,7 +47,7 @@
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 
 /**
- * The Window TinyLfu algorithm where the size of the admission window is adjusted using the a hill
+ * The Window TinyLfu algorithm where the size of the admission window is adjusted using a hill
  * climbing algorithm.
  *
  * @author ben.manes@gmail.com (Ben Manes)
@@ -175,7 +175,7 @@ private void demoteProtected() {
     }
   }
 
-  /** Moves the entry to the MRU position, if it falls outside of the fast-path threshold. */
+  /** Moves the entry to the MRU position if it falls outside of the fast-path threshold. */
   private void onProtectedHit(Node node) {
     node.moveToTail(headProtected);
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/segment/FullySegmentedWindowTinyLfuPolicy.java
Patch:
@@ -163,7 +163,7 @@ private void onMainProbationHit(Node node) {
     }
   }
 
-  /** Moves the entry to the MRU position, if it falls outside of the fast-path threshold. */
+  /** Moves the entry to the MRU position if it falls outside of the fast-path threshold. */
   private void onMainProtectedHit(Node node) {
     node.moveToTail(headMainProtected);
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/TuQueuePolicy.java
Patch:
@@ -43,7 +43,7 @@
  * hand, we have a cache hit on a cold buffer, it turns into a warm buffer and goes to the front of
  * the warm queue. Then as the warm queue lengthens, buffers start slipping from the end onto the
  * cold queue. Both the hot and warm queues are capped at one third of memory each to ensure
- * balance."
+ * balance.
  * <p>
  * Scan resistance is achieved by means of the warm queue. Transient data will pass from hot queue
  * to cold queue and be recycled. Responsiveness is maintained by making the warm queue LRU so that

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/TwoQueuePolicy.java
Patch:
@@ -34,7 +34,7 @@
  * monitored (OUT). The maximum size of the IN and OUT queues must be tuned with the authors
  * recommending 20% and 50% of the maximum size, respectively.
  * <p>
- * This implementation is based on the pseudo code provided by the authors in their paper
+ * This implementation is based on the pseudocode provided by the authors in their paper
  * <a href="http://www.vldb.org/conf/1994/P439.PDF">2Q: A Low Overhead High Performance Buffer
  * Management Replacement Algorithm</a>. For consistency with other policies, this version places
  * the next item to be removed at the head and most recently added at the tail of the queue.

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LoadingCacheTest.java
Patch:
@@ -710,7 +710,7 @@ public void refresh_cancel_noLog(CacheContext context) {
     LoadingCache<Int, Int> cache = context.isAsync()
         ? context.buildAsync(cacheLoader).synchronous()
         : context.build(cacheLoader);
-    TestLoggerFactory.getAllTestLoggers().values().stream()
+    TestLoggerFactory.getAllTestLoggers().values()
         .forEach(logger -> logger.setEnabledLevels(INFO_LEVELS));
 
     cache.refresh(context.absentKey());
@@ -734,7 +734,7 @@ public void refresh_timeout_noLog(CacheContext context) {
     LoadingCache<Int, Int> cache = context.isAsync()
         ? context.buildAsync(cacheLoader).synchronous()
         : context.build(cacheLoader);
-    TestLoggerFactory.getAllTestLoggers().values().stream()
+    TestLoggerFactory.getAllTestLoggers().values()
         .forEach(logger -> logger.setEnabledLevels(INFO_LEVELS));
 
     cache.refresh(context.absentKey());
@@ -749,7 +749,7 @@ public void refresh_error_log(CacheContext context) throws Exception {
     LoadingCache<Int, Int> cache = context.isAsync()
         ? context.buildAsync(cacheLoader).synchronous()
         : context.build(cacheLoader);
-    TestLoggerFactory.getAllTestLoggers().values().stream()
+    TestLoggerFactory.getAllTestLoggers().values()
         .forEach(logger -> logger.setEnabledLevels(INFO_LEVELS));
 
     cache.refresh(context.absentKey());

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/RefreshAfterWriteTest.java
Patch:
@@ -271,7 +271,7 @@ public void refreshIfNeeded_cancel_noLog(CacheContext context) {
         ? context.buildAsync(cacheLoader).synchronous()
         : context.build(cacheLoader);
     cache.put(context.absentKey(), context.absentValue());
-    TestLoggerFactory.getAllTestLoggers().values().stream()
+    TestLoggerFactory.getAllTestLoggers().values()
         .forEach(logger -> logger.setEnabledLevels(INFO_LEVELS));
     context.ticker().advance(2, TimeUnit.MINUTES);
 
@@ -299,7 +299,7 @@ public void refreshIfNeeded_timeout_noLog(CacheContext context) {
         ? context.buildAsync(cacheLoader).synchronous()
         : context.build(cacheLoader);
     cache.put(context.absentKey(), context.absentValue());
-    TestLoggerFactory.getAllTestLoggers().values().stream()
+    TestLoggerFactory.getAllTestLoggers().values()
         .forEach(logger -> logger.setEnabledLevels(INFO_LEVELS));
     context.ticker().advance(2, TimeUnit.MINUTES);
 
@@ -317,7 +317,7 @@ public void refreshIfNeeded_error_log(CacheContext context) {
         ? context.buildAsync(cacheLoader).synchronous()
         : context.build(cacheLoader);
     cache.put(context.absentKey(), context.absentValue());
-    TestLoggerFactory.getAllTestLoggers().values().stream()
+    TestLoggerFactory.getAllTestLoggers().values()
         .forEach(logger -> logger.setEnabledLevels(INFO_LEVELS));
     context.ticker().advance(2, TimeUnit.MINUTES);
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java
Patch:
@@ -47,6 +47,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Expire;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.InitialCapacity;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Listener;
+import com.github.benmanes.caffeine.cache.testing.CacheSpec.Loader;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Maximum;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.ReferenceType;
 import com.github.benmanes.caffeine.testing.Int;
@@ -123,7 +124,7 @@ public static <K, V> Cache<K, V> newGuavaCache(CacheContext context) {
       builder.removalListener(new GuavaRemovalListener<>(
           translateZeroExpire, context.removalListener()));
     }
-    if (context.loader() == null) {
+    if (context.loader() == Loader.DISABLED) {
       context.cache = new GuavaCache<>(builder.<Int, Int>build(), context);
     } else if (context.loader().isBulk()) {
       var loader = new BulkLoader<Int, Int>(context.loader());

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/BoundedConcurrentMapAcceptanceTest.java
Patch:
@@ -24,7 +24,7 @@
 import com.github.benmanes.caffeine.eclipse.acceptance.ConcurrentHashMapAcceptanceTest;
 
 /**
- * Eclipse Collections' map tests for against the {@link Cache#asMap()} view.
+ * Eclipse Collections' map tests for the {@link Cache#asMap()} view.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/BoundedConcurrentMapTest.java
Patch:
@@ -24,7 +24,7 @@
 import com.github.benmanes.caffeine.eclipse.mutable.ConcurrentHashMapTest;
 
 /**
- * Eclipse Collections' map tests for against the {@link Cache#asMap()} view.
+ * Eclipse Collections' map tests for the {@link Cache#asMap()} view.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/BoundedConcurrentMutableMapTest.java
Patch:
@@ -24,7 +24,7 @@
 import com.github.benmanes.caffeine.eclipse.mutable.ConcurrentMutableHashMapTest;
 
 /**
- * Eclipse Collections' map tests for against the {@link Cache#asMap()} view.
+ * Eclipse Collections' map tests for the {@link Cache#asMap()} view.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/BoundedParallelMapIteratePutAcceptanceTest.java
Patch:
@@ -25,7 +25,7 @@
 import com.github.benmanes.caffeine.eclipse.acceptance.ParallelMapIteratePutAcceptanceTest;
 
 /**
- * Eclipse Collections' map tests for against the {@link Cache#asMap()} view.
+ * Eclipse Collections' map tests for the {@link Cache#asMap()} view.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/BoundedUnifiedMapAcceptanceTest.java
Patch:
@@ -24,7 +24,7 @@
 import com.github.benmanes.caffeine.eclipse.acceptance.UnifiedMapAcceptanceTest;
 
 /**
- * Eclipse Collections' map tests for against the {@link Cache#asMap()} view.
+ * Eclipse Collections' map tests for the {@link Cache#asMap()} view.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/BoundedUnifiedMapTest.java
Patch:
@@ -24,7 +24,7 @@
 import com.github.benmanes.caffeine.eclipse.mutable.UnifiedMapTestCase;
 
 /**
- * Eclipse Collections' map tests for against the {@link Cache#asMap()} view.
+ * Eclipse Collections' map tests for the {@link Cache#asMap()} view.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/UnboundedConcurrentMapAcceptanceTest.java
Patch:
@@ -22,7 +22,7 @@
 import com.github.benmanes.caffeine.eclipse.acceptance.ConcurrentHashMapAcceptanceTest;
 
 /**
- * Eclipse Collections' map tests for against the {@link Cache#asMap()} view.
+ * Eclipse Collections' map tests for the {@link Cache#asMap()} view.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/UnboundedConcurrentMapTest.java
Patch:
@@ -22,7 +22,7 @@
 import com.github.benmanes.caffeine.eclipse.mutable.ConcurrentHashMapTest;
 
 /**
- * Eclipse Collections' map tests for against the {@link Cache#asMap()} view.
+ * Eclipse Collections' map tests for the {@link Cache#asMap()} view.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/UnboundedConcurrentMutableMapTest.java
Patch:
@@ -22,7 +22,7 @@
 import com.github.benmanes.caffeine.eclipse.mutable.ConcurrentMutableHashMapTest;
 
 /**
- * Eclipse Collections' map tests for against the {@link Cache#asMap()} view.
+ * Eclipse Collections' map tests for the {@link Cache#asMap()} view.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/UnboundedParallelMapIteratePutAcceptanceTest.java
Patch:
@@ -23,7 +23,7 @@
 import com.github.benmanes.caffeine.eclipse.acceptance.ParallelMapIteratePutAcceptanceTest;
 
 /**
- * Eclipse Collections' map tests for against the {@link Cache#asMap()} view.
+ * Eclipse Collections' map tests for the {@link Cache#asMap()} view.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/UnboundedUnifiedMapAcceptanceTest.java
Patch:
@@ -22,7 +22,7 @@
 import com.github.benmanes.caffeine.eclipse.acceptance.UnifiedMapAcceptanceTest;
 
 /**
- * Eclipse Collections' map tests for against the {@link Cache#asMap()} view.
+ * Eclipse Collections' map tests for the {@link Cache#asMap()} view.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/eclipse/UnboundedUnifiedMapTest.java
Patch:
@@ -22,7 +22,7 @@
 import com.github.benmanes.caffeine.eclipse.mutable.UnifiedMapTestCase;
 
 /**
- * Eclipse Collections' map tests for against the {@link Cache#asMap()} view.
+ * Eclipse Collections' map tests for the {@link Cache#asMap()} view.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncCache.java
Patch:
@@ -889,6 +889,7 @@ public boolean replace(K key, V oldValue, V newValue) {
     @Override
     public @Nullable V compute(K key,
         BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
+      // Keep in sync with BoundedVarExpiration.computeAsync(key, remappingFunction, expiry)
       requireNonNull(remappingFunction);
 
       @SuppressWarnings({"unchecked", "rawtypes"})

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/FrequencySketch.java
Patch:
@@ -177,7 +177,7 @@ void reset() {
       count += Long.bitCount(table[i] & ONE_MASK);
       table[i] = (table[i] >>> 1) & RESET_MASK;
     }
-    size = (size >>> 1) - (count >>> 2);
+    size = (size - (count >>> 2)) >>> 1;
   }
 
   /**

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/PeriodicResetCountMin4.java
Patch:
@@ -86,7 +86,7 @@ protected void tryReset(boolean added) {
       count += Long.bitCount(table[i] & ONE_MASK);
       table[i] = (table[i] >>> 1) & RESET_MASK;
     }
-    additions = (additions >>> 1) - (count >>> 2);
+    additions = (additions - (count >>> 2)) >>> 1;
     doorkeeper.clear();
   }
 }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Async.java
Patch:
@@ -158,9 +158,9 @@ Object writeReplace() {
   static final class AsyncExpiry<K, V> implements Expiry<K, CompletableFuture<V>>, Serializable {
     private static final long serialVersionUID = 1L;
 
-    final Expiry<K, V> delegate;
+    final Expiry<? super K, ? super V> delegate;
 
-    AsyncExpiry(Expiry<K, V> delegate) {
+    AsyncExpiry(Expiry<? super K, ? super V> delegate) {
       this.delegate = requireNonNull(delegate);
     }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncCache.java
Patch:
@@ -641,6 +641,7 @@ public boolean containsValue(Object value) {
     public @Nullable V putIfAbsent(K key, V value) {
       requireNonNull(value);
 
+      // Keep in sync with BoundedVarExpiration.putIfAbsentAsync(key, value, duration, unit)
       for (;;) {
         CompletableFuture<V> priorFuture = delegate.get(key);
         if (priorFuture != null) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalCache.java
Patch:
@@ -96,7 +96,7 @@ interface LocalCache<K, V> extends ConcurrentMap<K, V> {
    * whether to record miss and load statistics based on the success of this operation.
    */
   @Nullable V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction,
-      @Nullable Expiry<K, V> expiry, boolean recordMiss,
+      @Nullable Expiry<? super K, ? super V> expiry, boolean recordMiss,
       boolean recordLoad, boolean recordLoadFailure);
 
   @Override

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheBuilderGwtTest.java
Patch:
@@ -138,7 +138,7 @@ public Integer load(Integer key) throws Exception {
     cache.put(10, 20);
 
     ImmutableSet<Integer> keys = ImmutableSet.of(10, 20, 30, 54, 443, 1);
-    Map<Integer, Integer> map = cache.getAll(keys);
+    ImmutableMap<Integer, Integer> map = cache.getAll(keys);
 
     // Original test depended on order, but that was only expected for the emulated implementation
     assertEquals(keys, map.keySet());

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheLoadingTest.java
Patch:
@@ -447,7 +447,7 @@ public Map<Object, Object> loadAll(Iterable<? extends Object> keys) {
         Caffeine.newBuilder().executor(MoreExecutors.directExecutor()), loader);
 
     Object[] lookupKeys = new Object[] { new Object(), new Object(), new Object() };
-    Map<Object, Object> result = cache.getAll(asList(lookupKeys));
+    ImmutableMap<Object, Object> result = cache.getAll(asList(lookupKeys));
     assertThat(result.keySet()).containsExactlyElementsIn(asList(lookupKeys));
     for (Map.Entry<Object, Object> entry : result.entrySet()) {
       Object key = entry.getKey();
@@ -484,7 +484,7 @@ public Map<Object, Object> loadAll(Iterable<? extends Object> keys) {
     assertSame(extraKey, cache.asMap().get(extraKey));
 
     Object[] lookupKeys = new Object[] { new Object(), new Object(), new Object() };
-    Map<Object, Object> result = cache.getAll(asList(lookupKeys));
+    ImmutableMap<Object, Object> result = cache.getAll(asList(lookupKeys));
     assertThat(result.keySet()).containsExactlyElementsIn(asList(lookupKeys));
     for (Map.Entry<Object, Object> entry : result.entrySet()) {
       Object key = entry.getKey();

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/EmptyCachesTest.java
Patch:
@@ -253,7 +253,7 @@ public void testValues_remove() {
       cache.getUnchecked(1);
       cache.getUnchecked(2);
 
-      Collection<Object> values = cache.asMap().keySet();
+      Set<Object> values = cache.asMap().keySet();
       // We don't know whether these are still in the cache, so we can't assert on the return
       // values of these removes, but the cache should be empty after the removes, regardless.
       values.remove(1);

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/AbstractJCacheTest.java
Patch:
@@ -16,7 +16,6 @@
 package com.github.benmanes.caffeine.jcache;
 
 import java.util.Map;
-import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
 import javax.cache.CacheManager;
@@ -51,8 +50,8 @@ public abstract class AbstractJCacheTest {
   protected static final Integer KEY_2 = 2, VALUE_2 = -2;
   protected static final Integer KEY_3 = 3, VALUE_3 = -3;
 
-  protected final Set<Integer> keys = ImmutableSet.of(KEY_1, KEY_2, KEY_3);
-  protected final Map<Integer, Integer> entries = ImmutableMap.of(
+  protected final ImmutableSet<Integer> keys = ImmutableSet.of(KEY_1, KEY_2, KEY_3);
+  protected final ImmutableMap<Integer, Integer> entries = ImmutableMap.of(
       KEY_1, VALUE_1, KEY_2, VALUE_2, KEY_3, VALUE_3);
 
   protected LoadingCacheProxy<Integer, Integer> jcacheLoading;

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/JCacheGuiceTest.java
Patch:
@@ -17,8 +17,6 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import java.util.Map;
-
 import javax.cache.Cache;
 import javax.cache.CacheManager;
 import javax.cache.Caching;
@@ -37,6 +35,7 @@
 import com.github.benmanes.caffeine.jcache.configuration.FactoryCreator;
 import com.github.benmanes.caffeine.jcache.configuration.TypesafeConfigurator;
 import com.github.benmanes.caffeine.jcache.spi.CaffeineCachingProvider;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
 import com.google.inject.AbstractModule;
@@ -101,7 +100,7 @@ public Integer load(Integer key) {
     }
 
     @Override
-    public Map<Integer, Integer> loadAll(Iterable<? extends Integer> keys) {
+    public ImmutableMap<Integer, Integer> loadAll(Iterable<? extends Integer> keys) {
       return Maps.toMap(ImmutableSet.copyOf(keys), this::load);
     }
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/opt/ClairvoyantPolicy.java
Patch:
@@ -35,7 +35,7 @@
 import it.unimi.dsi.fastutil.longs.LongArrayFIFOQueue;
 
 /**
- * Bélády's optimal page replacement policy. The upper bound of the hit rate is estimated
+ * {@literal Bélády's} optimal page replacement policy. The upper bound of the hit rate is estimated
  * by evicting from the cache the item that will next be used farthest into the future.
  *
  * @author ben.manes@gmail.com (Ben Manes)

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/Feature.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.stream.Collectors;
 
 import com.google.common.base.CaseFormat;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.common.collect.Streams;
 
@@ -46,7 +47,7 @@ public enum Feature {
   LISTENING,
   STATS;
 
-  private static final Set<Feature> fastPathIncompatible = Sets.immutableEnumSet(
+  private static final ImmutableSet<Feature> fastPathIncompatible = Sets.immutableEnumSet(
       Feature.EXPIRE_ACCESS, Feature.WEAK_KEYS, Feature.INFIRM_VALUES,
       Feature.WEAK_VALUES, Feature.SOFT_VALUES);
 

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheFactoryGenerator.java
Patch:
@@ -242,7 +242,7 @@ private TypeSpec makeLocalCacheSpec(String className, boolean isFinal, Set<Featu
     Set<Feature> parentFeatures;
     Set<Feature> generateFeatures;
     if (features.size() == 2) {
-      parentFeatures = ImmutableSet.of();
+      parentFeatures = Set.of();
       generateFeatures = features;
       superClass = BOUNDED_LOCAL_CACHE;
     } else {

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeFactoryGenerator.java
Patch:
@@ -320,7 +320,7 @@ private TypeSpec makeNodeSpec(String className, boolean isFinal, Set<Feature> fe
     Set<Feature> parentFeatures;
     Set<Feature> generateFeatures;
     if (features.size() == 2) {
-      parentFeatures = ImmutableSet.of();
+      parentFeatures = Set.of();
       generateFeatures = features;
       superClass = TypeName.OBJECT;
     } else {

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/local/LocalCacheContext.java
Patch:
@@ -21,6 +21,7 @@
 import javax.lang.model.element.Modifier;
 
 import com.github.benmanes.caffeine.cache.Feature;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeName;
@@ -33,10 +34,10 @@ public final class LocalCacheContext {
   public final boolean isFinal;
   public final TypeName superClass;
   public final TypeSpec.Builder cache;
-  public final Set<Feature> parentFeatures;
-  public final Set<Feature> generateFeatures;
   public final MethodSpec.Builder constructor;
   public final Set<String> suppressedWarnings;
+  public final ImmutableSet<Feature> parentFeatures;
+  public final ImmutableSet<Feature> generateFeatures;
 
   public LocalCacheContext(TypeName superClass, String className, boolean isFinal,
       Set<Feature> parentFeatures, Set<Feature> generateFeatures) {

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/NodeContext.java
Patch:
@@ -26,6 +26,7 @@
 import javax.lang.model.element.Modifier;
 
 import com.github.benmanes.caffeine.cache.Feature;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
@@ -39,9 +40,9 @@ public final class NodeContext {
   public final boolean isFinal;
   public final String className;
   public final TypeName superClass;
-  public final Set<Feature> parentFeatures;
-  public final Set<Feature> generateFeatures;
   public final Set<String> suppressedWarnings;
+  public final ImmutableSet<Feature> parentFeatures;
+  public final ImmutableSet<Feature> generateFeatures;
   public final List<Consumer<CodeBlock.Builder>> varHandles;
 
   public TypeSpec.Builder nodeSubtype;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Ticker.java
Patch:
@@ -21,6 +21,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@FunctionalInterface
 public interface Ticker {
 
   /**

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/MpscGrowableQueueSanityTest.java
Patch:
@@ -14,7 +14,7 @@
 package com.github.benmanes.caffeine.cache;
 
 import java.util.ArrayList;
-import java.util.Collection;
+import java.util.List;
 import java.util.Queue;
 
 import org.junit.runner.RunWith;
@@ -33,7 +33,7 @@ public MpscGrowableQueueSanityTest(
   }
 
   @Parameterized.Parameters
-  public static Collection<Object[]> parameters() {
+  public static List<Object[]> parameters() {
     var list = new ArrayList<Object[]>();
     // MPSC size 1
     list.add(makeQueue(0, 1, 4, org.jctools.queues.spec.Ordering.FIFO,

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContext.java
Patch:
@@ -222,7 +222,7 @@ public Int lastKey() {
     return lastKey;
   }
 
-  public Set<Int> firstMiddleLastKeys() {
+  public ImmutableSet<Int> firstMiddleLastKeys() {
     return ImmutableSet.of(firstKey(), middleKey(), lastKey());
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheGenerator.java
Patch:
@@ -51,7 +51,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 public final class CacheGenerator {
-  private static final List<Map.Entry<Int, Int>> INTS = makeInts();
+  private static final ImmutableList<Map.Entry<Int, Int>> INTS = makeInts();
   private static final int BASE = 1_000;
 
   private final Options options;
@@ -245,7 +245,7 @@ private static void populate(CacheContext context, Cache<Int, Int> cache) {
   }
 
   /** Returns a cache of integers and their negation. */
-  private static List<Map.Entry<Int, Int>> makeInts() {
+  private static ImmutableList<Map.Entry<Int, Int>> makeInts() {
     int size = Stream.of(CacheSpec.Population.values())
         .mapToInt(population -> Math.toIntExact(population.size()))
         .max().getAsInt();

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/ConcurrentHashMap8Test.java
Patch:
@@ -24,7 +24,7 @@
 import junit.framework.Test;
 import junit.framework.TestSuite;
 
-@SuppressWarnings({"rawtypes", "unchecked"})
+@SuppressWarnings({"rawtypes", "unchecked", "PreferredInterfaceType"})
 public class ConcurrentHashMap8Test extends JSR166TestCase {
     public static void main(String[] args) {
         junit.textui.TestRunner.run(suite());

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/Threads.java
Patch:
@@ -117,7 +117,7 @@ private static <T> List<List<T>> shuffle(int samples, Collection<T> baseline) {
       Collections.shuffle(workingSet);
       workingSets.add(ImmutableList.copyOf(workingSet));
     }
-    return ImmutableList.copyOf(workingSets);
+    return List.copyOf(workingSets);
   }
 
   /** Executes operations against the cache to simulate random load. */

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheManagerImpl.java
Patch:
@@ -20,6 +20,7 @@
 import java.lang.ref.WeakReference;
 import java.net.URI;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.Map;
 import java.util.Properties;
@@ -175,7 +176,7 @@ public <K, V> CacheProxy<K, V> getCache(String cacheName) {
   }
 
   @Override
-  public Iterable<String> getCacheNames() {
+  public Collection<String> getCacheNames() {
     requireNotClosed();
     return Collections.unmodifiableCollection(new ArrayList<>(caches.keySet()));
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/AbstractTraceReader.java
Patch:
@@ -39,7 +39,6 @@
 
 import com.google.common.base.Throwables;
 import com.google.common.collect.AbstractIterator;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterators;
 
 /**
@@ -70,7 +69,7 @@ protected BufferedInputStream readInput(InputStream input) {
     BufferedInputStream buffered = null;
     try {
       buffered = new BufferedInputStream(input, BUFFER_SIZE);
-      List<Function<InputStream, InputStream>> extractors = ImmutableList.of(
+      List<Function<InputStream, InputStream>> extractors = List.of(
           this::tryXZ, this::tryCompressed, this::tryArchived);
       for (var extractor : extractors) {
         buffered.mark(100);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/adapt_size/AdaptSizeTraceReader.java
Patch:
@@ -23,7 +23,6 @@
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.policy.AccessEvent;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic;
-import com.google.common.collect.Sets;
 import com.google.common.hash.Hashing;
 
 /**
@@ -43,7 +42,7 @@ public AdaptSizeTraceReader(String filePath) {
 
   @Override
   public Set<Characteristic> characteristics() {
-    return Sets.immutableEnumSet(WEIGHTED);
+    return Set.of(WEIGHTED);
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/address/penalties/AddressPenaltiesTraceReader.java
Patch:
@@ -22,7 +22,6 @@
 import com.github.benmanes.caffeine.cache.simulator.parser.address.AddressTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.policy.AccessEvent;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic;
-import com.google.common.collect.ImmutableSet;
 
 /**
  * An extension to {@link AddressTraceReader} where the trace files were augmented to include hit
@@ -58,7 +57,7 @@ public AddressPenaltiesTraceReader(String filePath) {
 
   @Override
   public Set<Characteristic> characteristics() {
-    return ImmutableSet.of();
+    return Set.of();
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/cache2k/Cache2kTraceReader.java
Patch:
@@ -22,7 +22,6 @@
 import com.github.benmanes.caffeine.cache.simulator.parser.BinaryTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.policy.AccessEvent;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic;
-import com.google.common.collect.ImmutableSet;
 
 /**
  * A reader for the trace files provided by the author of cache2k. See
@@ -38,7 +37,7 @@ public Cache2kTraceReader(String filePath) {
 
   @Override
   public Set<Characteristic> characteristics() {
-    return ImmutableSet.of();
+    return Set.of();
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/cloud_physics/CloudPhysicsTraceReader.java
Patch:
@@ -22,7 +22,6 @@
 import com.github.benmanes.caffeine.cache.simulator.parser.BinaryTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.policy.AccessEvent;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic;
-import com.google.common.collect.ImmutableSet;
 
 /**
  * A reader for the trace files provided by the author of LIRS2. See
@@ -38,7 +37,7 @@ public CloudPhysicsTraceReader(String filePath) {
 
   @Override
   public Set<Characteristic> characteristics() {
-    return ImmutableSet.of();
+    return Set.of();
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/corda/CordaTraceReader.java
Patch:
@@ -22,7 +22,6 @@
 import com.github.benmanes.caffeine.cache.simulator.parser.BinaryTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.policy.AccessEvent;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic;
-import com.google.common.collect.ImmutableSet;
 
 /**
  * A reader for the trace files provided by <a href="https://www.r3.com">R3</a>.
@@ -37,7 +36,7 @@ public CordaTraceReader(String filePath) {
 
   @Override
   public Set<Characteristic> characteristics() {
-    return ImmutableSet.of();
+    return Set.of();
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/lrb/LrbTraceReader.java
Patch:
@@ -23,7 +23,6 @@
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.policy.AccessEvent;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic;
-import com.google.common.collect.Sets;
 
 /**
  * A reader for the trace files provided by the authors of the LRB algorithm. See
@@ -39,7 +38,7 @@ public LrbTraceReader(String filePath) {
 
   @Override
   public Set<Characteristic> characteristics() {
-    return Sets.immutableEnumSet(WEIGHTED);
+    return Set.of(WEIGHTED);
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/scarab/ScarabTraceReader.java
Patch:
@@ -22,7 +22,6 @@
 import com.github.benmanes.caffeine.cache.simulator.parser.BinaryTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.policy.AccessEvent;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic;
-import com.google.common.collect.ImmutableSet;
 
 /**
  * A reader for the trace files provided by
@@ -38,7 +37,7 @@ public ScarabTraceReader(String filePath) {
 
   @Override
   public Set<Characteristic> characteristics() {
-    return ImmutableSet.of();
+    return Set.of();
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/snia/cambridge/CambridgeTraceReader.java
Patch:
@@ -23,7 +23,6 @@
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.policy.AccessEvent;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic;
-import com.google.common.collect.Sets;
 
 /**
  * A reader for the SNIA MSR Cambridge trace files provided by
@@ -39,7 +38,7 @@ public CambridgeTraceReader(String filePath) {
 
   @Override
   public Set<Characteristic> characteristics() {
-    return Sets.immutableEnumSet(WEIGHTED);
+    return Set.of(WEIGHTED);
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/snia/keyvalue/ObjectStoreTraceReader.java
Patch:
@@ -24,7 +24,6 @@
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.policy.AccessEvent;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic;
-import com.google.common.collect.Sets;
 import com.google.common.primitives.Ints;
 
 /**
@@ -41,7 +40,7 @@ public ObjectStoreTraceReader(String filePath) {
 
   @Override
   public Set<Characteristic> characteristics() {
-    return Sets.immutableEnumSet(WEIGHTED);
+    return Set.of(WEIGHTED);
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/snia/parallel/TencentPhotoTraceReader.java
Patch:
@@ -23,7 +23,6 @@
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.policy.AccessEvent;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic;
-import com.google.common.collect.Sets;
 import com.google.common.hash.Hashing;
 import com.google.common.io.BaseEncoding;
 
@@ -43,7 +42,7 @@ public TencentPhotoTraceReader(String filePath) {
 
   @Override
   public Set<Characteristic> characteristics() {
-    return Sets.immutableEnumSet(WEIGHTED);
+    return Set.of(WEIGHTED);
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/tragen/TragenTraceReader.java
Patch:
@@ -23,7 +23,6 @@
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.policy.AccessEvent;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic;
-import com.google.common.collect.Sets;
 
 /**
  * A reader for the trace files provided by the authors of the
@@ -39,7 +38,7 @@ public TragenTraceReader(String filePath) {
 
   @Override
   public Set<Characteristic> characteristics() {
-    return Sets.immutableEnumSet(WEIGHTED);
+    return Set.of(WEIGHTED);
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/twitter/TwitterTraceReader.java
Patch:
@@ -23,7 +23,6 @@
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.policy.AccessEvent;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic;
-import com.google.common.collect.Sets;
 import com.google.common.hash.Hashing;
 
 /**
@@ -40,7 +39,7 @@ public TwitterTraceReader(String filePath) {
 
   @Override
   public Set<Characteristic> characteristics() {
-    return Sets.immutableEnumSet(WEIGHTED);
+    return Set.of(WEIGHTED);
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/feedback/FeedbackTinyLfuPolicy.java
Patch:
@@ -26,7 +26,6 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.PolicySpec;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 import com.typesafe.config.ConfigFactory;
@@ -240,7 +239,7 @@ public double adaptiveFpp() {
       return config().getDouble("feedback-tiny-lfu.adaptive-fpp");
     }
     public Config filterConfig(int sampleSize) {
-      Map<String, Object> properties = ImmutableMap.of(
+      Map<String, Object> properties = Map.of(
           "membership.fpp", adaptiveFpp(),
           "maximum-size", sampleSize);
       return ConfigFactory.parseMap(properties).withFallback(config());

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/feedback/FeedbackWindowTinyLfuPolicy.java
Patch:
@@ -30,7 +30,6 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.PolicySpec;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
-import com.google.common.collect.ImmutableMap;
 import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 import com.typesafe.config.ConfigFactory;
@@ -410,7 +409,7 @@ public double adaptiveFpp() {
       return config().getDouble("feedback-window-tiny-lfu.adaptive-fpp");
     }
     public Config filterConfig(int sampleSize) {
-      Map<String, Object> properties = ImmutableMap.of(
+      Map<String, Object> properties = Map.of(
           "membership.fpp", adaptiveFpp(),
           "maximum-size", sampleSize);
       return ConfigFactory.parseMap(properties).withFallback(config());

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/TextReporter.java
Patch:
@@ -82,10 +82,10 @@ public Collection<PolicyStats> stats() {
   /** Returns the column headers. */
   protected Set<String> headers() {
     if (headers == null) {
-      Set<String> all = results.stream()
+      ImmutableSet<String> all = results.stream()
             .flatMap(policyStats -> policyStats.metrics().keySet().stream())
             .collect(toImmutableSet());
-      Set<String> used = results.stream()
+      ImmutableSet<String> used = results.stream()
           .flatMap(policyStats -> policyStats.metrics().values().stream())
           .filter(metric -> metric.characteristics().isEmpty()
               || metric.characteristics().stream().anyMatch(characteristics::contains))

File: simulator/src/test/java/com/github/benmanes/caffeine/cache/simulator/admission/bloom/MembershipTest.java
Patch:
@@ -32,7 +32,6 @@
 import com.github.benmanes.caffeine.cache.simulator.membership.Membership;
 import com.github.benmanes.caffeine.cache.simulator.membership.bloom.BloomFilter;
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
 import com.jakewharton.fliptables.FlipTable;
 import com.typesafe.config.Config;
 import com.typesafe.config.ConfigFactory;
@@ -118,7 +117,7 @@ private int falsePositives(Membership filter, long[] input) {
   }
 
   private Config getConfig(FilterType filterType, int capacity) {
-    Map<String, Object> properties = ImmutableMap.of(
+    Map<String, Object> properties = Map.of(
         "membership.expected-insertions-multiplier", EXPECTED_INSERTIONS_MULTIPLIER,
         "membership.filter", filterType.name(),
         "maximum-size", capacity,

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncCacheLoader.java
Patch:
@@ -52,7 +52,7 @@ public interface AsyncCacheLoader<K extends Object, V extends Object> {
    * <b>Warning:</b> loading <b>must not</b> attempt to update any mappings of this cache directly.
    *
    * @param key the non-null key whose value should be loaded
-   * @param executor the executor with which the entry is asynchronously loaded
+   * @param executor the executor with which the entry may be asynchronously loaded with
    * @return the future value associated with {@code key}
    * @throws Exception or Error, in which case the mapping is unchanged
    * @throws InterruptedException if this method is interrupted. {@code InterruptedException} is
@@ -77,7 +77,7 @@ public interface AsyncCacheLoader<K extends Object, V extends Object> {
    * <b>Warning:</b> loading <b>must not</b> attempt to update any mappings of this cache directly.
    *
    * @param keys the unique, non-null keys whose values should be loaded
-   * @param executor the executor with which the entries are asynchronously loaded
+   * @param executor the executor with which the entry may be asynchronously loaded with
    * @return a future containing the map from each key in {@code keys} to the value associated with
    *         that key; <b>may not contain null values</b>
    * @throws Exception or Error, in which case the mappings are unchanged
@@ -103,7 +103,7 @@ public interface AsyncCacheLoader<K extends Object, V extends Object> {
    *
    * @param key the non-null key whose value should be loaded
    * @param oldValue the non-null old value corresponding to {@code key}
-   * @param executor the executor with which the entry is asynchronously loaded
+   * @param executor the executor with which the entry may be asynchronously loaded with
    * @return a future containing the new value associated with {@code key}, or containing
    *         {@code null} if the mapping is to be removed
    * @throws Exception or Error, in which case the mapping is unchanged

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncCache.java
Patch:
@@ -275,9 +275,6 @@ private void fillProxies(Map<? extends K, ? extends V> result) {
 
     /** Adds to the cache any extra entries computed that were not requested. */
     private void addNewEntries(Map<? extends K, ? extends V> result) {
-      if (proxies.size() == result.size()) {
-        return;
-      }
       result.forEach((key, value) -> {
         if (!proxies.containsKey(key)) {
           cache.put(key, CompletableFuture.completedFuture(value));

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/GetPutBenchmark.java
Patch:
@@ -51,7 +51,6 @@ public class GetPutBenchmark {
     "Caffeine",
     "ConcurrentLinkedHashMap",
     "Guava",
-    "ElasticSearch",
     "Jackrabbit",
     "Cache2k",
     "Ehcache3",

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -473,7 +473,7 @@ public Expiry<K, V> expiry() {
     return null;
   }
 
-  @Override
+  /** Returns the {@link Ticker} used by this cache for expiration. */
   public Ticker expirationTicker() {
     return Ticker.disabledTicker();
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalCache.java
Patch:
@@ -58,9 +58,6 @@ interface LocalCache<K, V> extends ConcurrentMap<K, V> {
   /** Returns the {@link Expiry} used by this cache. */
   @Nullable Expiry<K, V> expiry();
 
-  /** Returns the {@link Ticker} used by this cache for expiration. */
-  Ticker expirationTicker();
-
   /** Returns the {@link Ticker} used by this cache for statistics. */
   Ticker statsTicker();
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/Registry.java
Patch:
@@ -55,7 +55,6 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.product.Cache2kPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.CaffeinePolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.Ehcache3Policy;
-import com.github.benmanes.caffeine.cache.simulator.policy.product.ElasticSearchPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.ExpiringMapPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.GuavaPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.OhcPolicy;
@@ -233,7 +232,6 @@ private void registerProduct() {
     register(CaffeinePolicy.class, CaffeinePolicy::new);
     register(Ehcache3Policy.class, Ehcache3Policy::new);
     register(ExpiringMapPolicy.class, ExpiringMapPolicy::new);
-    register(ElasticSearchPolicy.class, ElasticSearchPolicy::new);
   }
 
   @AutoValue

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/TextReporter.java
Patch:
@@ -22,7 +22,7 @@
 
 import java.io.IOException;
 import java.nio.file.Files;
-import java.nio.file.Paths;
+import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Comparator;
@@ -69,7 +69,8 @@ public void print() throws IOException {
     if (output.equalsIgnoreCase("console")) {
       System.out.println(report);
     } else {
-      Files.write(Paths.get(output), report.getBytes(UTF_8));
+      Files.createDirectories(Path.of(output).getParent());
+      Files.write(Path.of(output), report.getBytes(UTF_8));
     }
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1455,7 +1455,7 @@ void afterWrite(Runnable task) {
       scheduleDrainBuffers();
     }
 
-    // The maintenance task may be scheduled but not running due. This might occur due to all of the
+    // The maintenance task may be scheduled but not running. This might occur due to all of the
     // executor's threads being busy (perhaps writing into this cache), the write rate greatly
     // exceeds the consuming rate, priority inversion, or if the executor silently discarded the
     // maintenance task. In these scenarios then the writing threads cannot make progress and

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -159,6 +159,7 @@ public void rescheduleDrainBuffers() {
       }
     };
     var cache = asBoundedLocalCache(Caffeine.newBuilder()
+        .executor(CacheExecutor.THREADED.create())
         .evictionListener(evictionListener)
         .maximumSize(0)
         .build());
@@ -169,7 +170,7 @@ public void rescheduleDrainBuffers() {
     assertThat(cache.drainStatus).isEqualTo(PROCESSING_TO_REQUIRED);
 
     done.set(true);
-    await().untilAsserted(() -> assertThat(cache.drainStatus).isEqualTo(IDLE));
+    await().untilAsserted(() -> assertThat(cache.drainStatus).isAnyOf(REQUIRED, IDLE));
   }
 
   @Test(dataProvider = "caches")
@@ -373,9 +374,9 @@ public void evict_update() {
         (k, v, cause) -> removedValues.accumulateAndGet(v, Int::add);
 
     var cache = Caffeine.newBuilder()
+        .executor(CacheExecutor.DIRECT.create())
         .evictionListener(evictionListener)
         .removalListener(removalListener)
-        .executor(Runnable::run)
         .maximumSize(100)
         .build();
     var localCache = asBoundedLocalCache(cache);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Issue193Test.java
Patch:
@@ -30,7 +30,6 @@
 import com.google.common.testing.FakeTicker;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFutureTask;
-import com.google.common.util.concurrent.testing.TestingExecutors;
 
 /**
  * Issue #193: Invalidate before Refresh completes still stores value
@@ -75,8 +74,8 @@ public void invalidateDuringRefreshRemovalCheck() throws Exception {
     var removed = new ArrayList<Long>();
     AsyncLoadingCache<String, Long> cache = Caffeine.newBuilder()
         .removalListener((String key, Long value, RemovalCause reason) -> removed.add(value))
-        .executor(TestingExecutors.sameThreadScheduledExecutor())
         .refreshAfterWrite(10, TimeUnit.NANOSECONDS)
+        .executor(Runnable::run)
         .ticker(ticker::read)
         .buildAsync(loader);
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Issue298Test.java
Patch:
@@ -33,6 +33,7 @@
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.cache.Expiry;
 import com.github.benmanes.caffeine.cache.Policy.VarExpiration;
+import com.github.benmanes.caffeine.testing.ConcurrentTestHarness;
 
 /**
  * Issue #298: Stale data when using Expiry
@@ -116,6 +117,7 @@ public void readDuringCreate() {
 
   private AsyncLoadingCache<String, String> makeAsyncCache() {
     return Caffeine.newBuilder()
+        .executor(ConcurrentTestHarness.executor)
         .expireAfter(new Expiry<String, String>() {
           @Override public long expireAfterCreate(@Nonnull String key,
               @Nonnull String value, long currentTime) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Solr10141Test.java
Patch:
@@ -71,6 +71,7 @@ public void eviction() throws Exception {
     };
 
     Cache<Long, Val> cache = Caffeine.newBuilder()
+        .executor(ConcurrentTestHarness.executor)
         .removalListener(listener)
         .maximumSize(maxEntries)
         .build();

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -202,7 +202,7 @@ abstract class BoundedLocalCache<K, V> extends BLCHeader.DrainStatusRef<K, V>
   static final double HILL_CLIMBER_STEP_PERCENT = 0.0625d;
   /** The rate to decrease the step size to adapt by. */
   static final double HILL_CLIMBER_STEP_DECAY_RATE = 0.98d;
-  /** The maximum number of entries that can be transfered between queues. */
+  /** The maximum number of entries that can be transferred between queues. */
   static final int QUEUE_TRANSFER_THRESHOLD = 1_000;
   /** The maximum time window between entry updates before the expiration must be reordered. */
   static final long EXPIRE_WRITE_TOLERANCE = TimeUnit.SECONDS.toNanos(1);

File: guava/src/test/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaTest.java
Patch:
@@ -19,7 +19,7 @@
 
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.guava.CaffeinatedGuavaCache.CacheLoaderException;
-import com.github.benmanes.caffeine.guava.compatability.TestingCacheLoaders;
+import com.github.benmanes.caffeine.guava.compatibility.TestingCacheLoaders;
 import com.google.common.cache.CacheLoader;
 import com.google.common.cache.LoadingCache;
 import com.google.common.testing.SerializableTester;

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/AbstractCacheTest.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.github.benmanes.caffeine.guava.compatability;
+package com.github.benmanes.caffeine.guava.compatibility;
 
 import com.github.benmanes.caffeine.cache.RemovalCause;
 import com.github.benmanes.caffeine.cache.stats.CacheStats;

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheBuilderFactory.java
Patch:
@@ -12,7 +12,7 @@
  * the License.
  */
 
-package com.github.benmanes.caffeine.guava.compatability;
+package com.github.benmanes.caffeine.guava.compatibility;
 
 import java.util.List;
 import java.util.Set;

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheBuilderGwtTest.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.github.benmanes.caffeine.guava.compatability;
+package com.github.benmanes.caffeine.guava.compatibility;
 
 import java.util.Arrays;
 import java.util.Iterator;

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheManualTest.java
Patch:
@@ -12,7 +12,7 @@
  * the License.
  */
 
-package com.github.benmanes.caffeine.guava.compatability;
+package com.github.benmanes.caffeine.guava.compatibility;
 
 import static java.util.Arrays.asList;
 import junit.framework.TestCase;

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheReferencesTest.java
Patch:
@@ -12,17 +12,17 @@
  * the License.
  */
 
-package com.github.benmanes.caffeine.guava.compatability;
+package com.github.benmanes.caffeine.guava.compatibility;
 
-import static com.github.benmanes.caffeine.guava.compatability.CacheBuilderFactory.Strength.STRONG;
+import static com.github.benmanes.caffeine.guava.compatibility.CacheBuilderFactory.Strength.STRONG;
 import static com.google.common.collect.Maps.immutableEntry;
 import static com.google.common.truth.Truth.assertThat;
 
 import java.lang.ref.WeakReference;
 
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.guava.CaffeinatedGuava;
-import com.github.benmanes.caffeine.guava.compatability.CacheBuilderFactory.Strength;
+import com.github.benmanes.caffeine.guava.compatibility.CacheBuilderFactory.Strength;
 import com.google.common.base.Function;
 import com.google.common.cache.CacheLoader;
 import com.google.common.cache.LoadingCache;

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheRefreshTest.java
Patch:
@@ -12,14 +12,14 @@
  * the License.
  */
 
-package com.github.benmanes.caffeine.guava.compatability;
+package com.github.benmanes.caffeine.guava.compatibility;
 
-import static com.github.benmanes.caffeine.guava.compatability.TestingCacheLoaders.incrementingLoader;
+import static com.github.benmanes.caffeine.guava.compatibility.TestingCacheLoaders.incrementingLoader;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.guava.CaffeinatedGuava;
-import com.github.benmanes.caffeine.guava.compatability.TestingCacheLoaders.IncrementingLoader;
+import com.github.benmanes.caffeine.guava.compatibility.TestingCacheLoaders.IncrementingLoader;
 import com.google.common.cache.LoadingCache;
 import com.google.common.testing.FakeTicker;
 import com.google.common.util.concurrent.MoreExecutors;

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheStatsTest.java
Patch:
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package com.github.benmanes.caffeine.guava.compatability;
+package com.github.benmanes.caffeine.guava.compatibility;
 
 import com.github.benmanes.caffeine.cache.stats.CacheStats;
 

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/CacheTesting.java
Patch:
@@ -12,7 +12,7 @@
  * the License.
  */
 
-package com.github.benmanes.caffeine.guava.compatability;
+package com.github.benmanes.caffeine.guava.compatibility;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static org.junit.Assert.assertEquals;

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/LocalCacheMapComputeTest.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.github.benmanes.caffeine.guava.compatability;
+package com.github.benmanes.caffeine.guava.compatibility;
 
 import static com.google.common.truth.Truth.assertThat;
 

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/LocalLoadingCacheTest.java
Patch:
@@ -14,9 +14,9 @@
  * limitations under the License.
  */
 
-package com.github.benmanes.caffeine.guava.compatability;
+package com.github.benmanes.caffeine.guava.compatibility;
 
-import static com.github.benmanes.caffeine.guava.compatability.TestingCacheLoaders.identityLoader;
+import static com.github.benmanes.caffeine.guava.compatibility.TestingCacheLoaders.identityLoader;
 import static com.google.common.truth.Truth.assertThat;
 
 import java.lang.Thread.UncaughtExceptionHandler;

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/TestingCacheLoaders.java
Patch:
@@ -12,7 +12,7 @@
  * the License.
  */
 
-package com.github.benmanes.caffeine.guava.compatability;
+package com.github.benmanes.caffeine.guava.compatibility;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/TestingRemovalListeners.java
Patch:
@@ -12,7 +12,7 @@
  * the License.
  */
 
-package com.github.benmanes.caffeine.guava.compatability;
+package com.github.benmanes.caffeine.guava.compatibility;
 
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicInteger;

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatibility/TestingWeighers.java
Patch:
@@ -12,7 +12,7 @@
  * the License.
  */
 
-package com.github.benmanes.caffeine.guava.compatability;
+package com.github.benmanes.caffeine.guava.compatibility;
 
 import com.github.benmanes.caffeine.cache.Weigher;
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/address/penalties/AddressPenaltiesTraceReader.java
Patch:
@@ -34,7 +34,7 @@
  * <ul>
  *   <li>Access Type: A single character indicating whether the access is a load (<tt>l</tt>) or a
  *       store (<tt>s</tt>).
- *   <li>Address: A 32-bit integer (in unsigned hexidecimal format) specifying the memory address
+ *   <li>Address: A 32-bit integer (in unsigned hexadecimal format) specifying the memory address
  *       that is being accessed. For example, <tt>0xff32e100</tt> specifies that memory address
  *       <tt>4281524480</tt> is accessed.
  *   <li>Instructions since last memory access: Indicates the number of instructions of any type

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheFactoryGenerator.java
Patch:
@@ -60,7 +60,6 @@
 import com.github.benmanes.caffeine.cache.local.AddRemovalListener;
 import com.github.benmanes.caffeine.cache.local.AddStats;
 import com.github.benmanes.caffeine.cache.local.AddSubtype;
-import com.github.benmanes.caffeine.cache.local.AddWriteBuffer;
 import com.github.benmanes.caffeine.cache.local.Finalize;
 import com.github.benmanes.caffeine.cache.local.LocalCacheContext;
 import com.github.benmanes.caffeine.cache.local.LocalCacheRule;
@@ -102,7 +101,7 @@ public final class LocalCacheFactoryGenerator {
       new AddKeyValueStrength(), new AddRemovalListener(), new AddStats(),
       new AddExpirationTicker(), new AddMaximum(), new AddFastPath(), new AddDeques(),
       new AddExpireAfterAccess(), new AddExpireAfterWrite(), new AddRefreshAfterWrite(),
-      new AddWriteBuffer(), new AddPacer(), new Finalize());
+      new AddPacer(), new Finalize());
   final ZoneId timeZone = ZoneId.of("America/Los_Angeles");
   final Path directory;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -30,7 +30,6 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ForkJoinPool;
-import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
@@ -287,8 +286,8 @@ int getInitialCapacity() {
    * with {@link #removalListener} or utilize asynchronous computations. A test may instead prefer
    * to configure the cache to execute tasks directly on the same thread.
    * <p>
-   * Beware that configuring a cache with an executor that throws {@link RejectedExecutionException}
-   * may experience non-deterministic behavior.
+   * Beware that configuring a cache with an executor that discards tasks and never runs them may
+   * experience non-deterministic behavior.
    *
    * @param executor the executor to use for asynchronous execution
    * @return this {@code Caffeine} instance (for chaining)

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LocalCacheSubject.java
Patch:
@@ -124,7 +124,7 @@ private void drain(BoundedLocalCache<Object, Object> bounded) {
     for (;;) {
       bounded.cleanUp();
 
-      if (bounded.buffersWrites() && (bounded.writeBuffer().size() > 0)) {
+      if (bounded.writeBuffer.size() > 0) {
         continue; // additional writes to drain
       } else if (bounded.evicts() && (bounded.adjustment() != adjustment)) {
         adjustment = bounded.adjustment();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/Stresser.java
Patch:
@@ -115,7 +115,7 @@ private void status() {
     int pendingWrites;
     local.evictionLock.lock();
     try {
-      pendingWrites = local.writeBuffer().size();
+      pendingWrites = local.writeBuffer.size();
       drainStatus = local.drainStatus();
     } finally {
       local.evictionLock.unlock();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheValidationListener.java
Patch:
@@ -168,6 +168,7 @@ private void awaitExecutor(CacheContext context) {
       executor.resume();
 
       if ((context.cacheExecutor != CacheExecutor.DIRECT)
+          && (context.cacheExecutor != CacheExecutor.DISCARDING)
           && (executor.submitted() != executor.completed())) {
         await().pollInSameThread().until(() -> executor.submitted() == executor.completed());
       }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -939,6 +939,9 @@ private long getExpirationDelay(long now) {
   /** Returns if the entry has expired. */
   @SuppressWarnings("ShortCircuitBoolean")
   boolean hasExpired(Node<K, V> node, long now) {
+    if (isComputingAsync(node)) {
+      return false;
+    }
     return (expiresAfterAccess() && (now - node.getAccessTime() >= expiresAfterAccessNanos()))
         | (expiresAfterWrite() && (now - node.getWriteTime() >= expiresAfterWriteNanos()))
         | (expiresVariable() && (now - node.getVariableTime() >= 0));

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheValidationListener.java
Patch:
@@ -69,7 +69,7 @@
 public final class CacheValidationListener implements ISuiteListener, IInvokedMethodListener {
   private static final Cache<Object, String> simpleNames = Caffeine.newBuilder().build();
   private static final ITestContext testngContext = Mockito.mock(ITestContext.class);
-  private static final AtomicBoolean detailedParams = new AtomicBoolean();
+  private static final AtomicBoolean detailedParams = new AtomicBoolean(false);
   private static final Object[] EMPTY_PARAMS = {};
 
   private final List<Collection<?>> resultQueues = new CopyOnWriteArrayList<>();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/BinaryTraceReader.java
Patch:
@@ -16,14 +16,15 @@
 package com.github.benmanes.caffeine.cache.simulator.parser;
 
 import static java.util.Objects.requireNonNull;
+import static java.util.Spliterator.NONNULL;
+import static java.util.Spliterator.ORDERED;
 
 import java.io.DataInputStream;
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.UncheckedIOException;
 import java.util.Iterator;
 import java.util.NoSuchElementException;
-import java.util.Spliterator;
 import java.util.Spliterators;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
@@ -47,7 +48,7 @@ protected BinaryTraceReader(String filePath) {
   public Stream<AccessEvent> events() {
     var input = new DataInputStream(readFile());
     var stream = StreamSupport.stream(Spliterators.spliteratorUnknownSize(
-        new TraceIterator(input), Spliterator.ORDERED), /* parallel */ false);
+        new TraceIterator(input), ORDERED | NONNULL), /* parallel */ false);
     return stream.onClose(() -> Closeables.closeQuietly(input));
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/TextTraceReader.java
Patch:
@@ -39,8 +39,7 @@ protected TextTraceReader(String filePath) {
   @SuppressWarnings("PMD.CloseResource")
   protected Stream<String> lines() {
     InputStream input = readFile();
-    var reader = new InputStreamReader(input, UTF_8);
-    return new BufferedReader(reader).lines().map(String::trim)
-        .onClose(() -> Closeables.closeQuietly(input));
+    var reader = new BufferedReader(new InputStreamReader(input, UTF_8));
+    return reader.lines().map(String::trim).onClose(() -> Closeables.closeQuietly(reader));
   }
 }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsyncTest.java
Patch:
@@ -85,7 +85,7 @@ public void getWhenSuccessful_success_async() {
       result.set(Async.getWhenSuccessful(future));
     });
     await().untilAtomic(result, is(1));
-    future.obtrudeValue(2);
+    future.complete(2);
     await().untilAtomic(result, is(2));
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LoadingCache.java
Patch:
@@ -81,9 +81,8 @@ public interface LoadingCache<K extends Object, V extends Object> extends Cache<
    * @throws NullPointerException if the specified collection is null or contains a null element
    * @throws CompletionException if a checked exception was thrown while loading the value
    * @throws RuntimeException or Error if the {@link CacheLoader} does so, if
-   *         {@link CacheLoader#loadAll} returns {@code null}, returns a map containing null keys or
-   *         values, or fails to return an entry for each requested key. In all cases, the mapping
-   *         is left unestablished
+   *         {@link CacheLoader#loadAll} returns {@code null}, or returns a map containing null keys
+   *         or values. In all cases, the mapping is left unestablished.
    */
   Map<K, V> getAll(Iterable<? extends K> keys);
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/sim/MiniSimClimber.java
Patch:
@@ -38,7 +38,7 @@
  */
 @SuppressWarnings("PMD.SuspiciousConstantFieldName")
 public final class MiniSimClimber implements HillClimber {
-  private static final HashFunction hasher = Hashing.murmur3_32(0x7f3a2142);
+  private static final HashFunction hasher = Hashing.murmur3_32_fixed(0x7f3a2142);
 
   private final WindowTinyLfuPolicy[] minis;
   private final long[] prevMisses;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LoadingCache.java
Patch:
@@ -19,8 +19,6 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
-
 /**
  * A semi-persistent mapping from keys to values. Values are automatically loaded by the cache,
  * and are stored in the cache until either evicted or manually invalidated.
@@ -59,7 +57,6 @@ public interface LoadingCache<K extends Object, V extends Object> extends Cache<
    * @throws RuntimeException or Error if the {@link CacheLoader} does so, in which case the mapping
    *         is left unestablished
    */
-  @Nullable
   V get(K key);
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalLoadingCache.java
Patch:
@@ -50,7 +50,8 @@ interface LocalLoadingCache<K, V> extends LocalManualCache<K, V>, LoadingCache<K
   @Nullable Function<Set<? extends K>, Map<K, V>> bulkMappingFunction();
 
   @Override
-  default @Nullable V get(K key) {
+  @SuppressWarnings("NullAway")
+  default V get(K key) {
     return cache().computeIfAbsent(key, mappingFunction());
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalLoadingCache.java
Patch:
@@ -154,7 +154,7 @@ default CompletableFuture<V> refresh(K key) {
               }
             }
           }
-          discard[0] = true;
+          discard[0] = (currentValue != newValue);
           return currentValue;
         }, cache().expiry(), /* recordMiss */ false,
             /* recordLoad */ false, /* recordLoadFailure */ true);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Policy.java
Patch:
@@ -45,7 +45,7 @@ public interface Policy<K extends Object, V extends Object> {
   /**
    * Returns the value associated with the {@code key} in this cache, or {@code null} if there is no
    * cached value for the {@code key}. Unlike {@link Cache#getIfPresent(Object)}, this method does
-   * not produce any side effects such as updating statistics, the eviction policy, reseting the
+   * not produce any side effects such as updating statistics, the eviction policy, resetting the
    * expiration time, or triggering a refresh.
    *
    * @param key the key whose associated value is to be returned

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -632,7 +632,7 @@ public void evict_resurrect_expireAfterVar(Cache<Int, Int> cache, CacheContext c
       await().untilTrue(started);
       var threadState = EnumSet.of(State.BLOCKED, State.WAITING);
       await().until(() -> threadState.contains(evictor.get().getState()));
-      cache.policy().expireVariably().get().setExpiresAfter(key, Duration.ofDays(1));
+      node.setVariableTime(context.ticker().read() + TimeUnit.DAYS.toNanos(1));
     }
     await().untilTrue(done);
 

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/MemoryBenchmark.java
Patch:
@@ -58,7 +58,7 @@ public final class MemoryBenchmark {
       .ignoreKnownSingletons();
   final PrintStream out = System.out;
 
-  public void run() throws Exception {
+  public void run() {
     if (!MemoryMeter.hasInstrumentation()) {
       out.println("WARNING: Java agent not installed - guessing instead");
     }
@@ -239,7 +239,7 @@ private String[] evaluate(String label, Map<Integer, Integer> map) {
     };
   }
 
-  public static void main(String[] args) throws Exception {
+  public static void main(String[] args) {
     new MemoryBenchmark().run();
   }
 }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheLoader.java
Patch:
@@ -222,6 +222,7 @@ default CompletableFuture<? extends V> asyncReload(
    * @throws NullPointerException if the mappingFunction is null
    */
   @CheckReturnValue
+  @SuppressWarnings("FunctionalInterfaceClash")
   static <K extends Object, V extends Object> CacheLoader<K, V> bulk(
       Function<? super Set<? extends K>, ? extends Map<? extends K, ? extends V>> mappingFunction) {
     requireNonNull(mappingFunction);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalManualCache.java
Patch:
@@ -94,6 +94,7 @@ default Map<K, V> getAll(Iterable<? extends K> keys,
    * Performs a non-blocking bulk load of the missing keys. Any missing entry that materializes
    * during the load are replaced when the loaded entries are inserted into the cache.
    */
+  @SuppressWarnings("CatchingUnchecked")
   default void bulkLoad(Set<K> keysToLoad, Map<K, V> result,
       Function<? super Set<? extends K>, ? extends Map<? extends K, ? extends V>> mappingFunction) {
     boolean success = false;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Scheduler.java
Patch:
@@ -162,6 +162,7 @@ public Future<Void> schedule(Executor executor, Runnable command, long delay, Ti
   }
 }
 
+@SuppressWarnings("CheckedExceptionNotThrown")
 enum DisabledFuture implements Future<Void> {
   INSTANCE;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CacheTest.java
Patch:
@@ -264,6 +264,7 @@ public void getAllPresent_ordered(Cache<Int, Int> cache, CacheContext context) {
   @Test(dataProvider = "caches")
   @CacheSpec(population = Population.EMPTY, keys = ReferenceType.STRONG)
   public void getAllPresent_jdk8186171(Cache<Object, Int> cache, CacheContext context) {
+    @SuppressWarnings("HashCodeToString")
     class Key {
       @Override public int hashCode() {
         return 0; // to put keys in one bucket
@@ -441,6 +442,7 @@ public void getAll_present_ordered_exceeds(Cache<Int, Int> cache, CacheContext c
   @CacheSpec(implementation = Implementation.Caffeine,
       population = Population.EMPTY, keys = ReferenceType.STRONG)
   public void getAll_jdk8186171(CacheContext context) {
+    @SuppressWarnings("HashCodeToString")
     class Key {
       @Override public int hashCode() {
         return 0; // to put keys in one bucket

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LoadingCacheTest.java
Patch:
@@ -304,6 +304,7 @@ public void getAll_present_ordered_exceeds(LoadingCache<Int, Int> cache, CacheCo
   @CacheSpec(implementation = Implementation.Caffeine,
       population = Population.EMPTY, keys = ReferenceType.STRONG)
   public void getAll_jdk8186171(CacheContext context) {
+    @SuppressWarnings("HashCodeToString")
     class Key {
       @Override public int hashCode() {
         return 0; // to put keys in one bucket

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheSpec.java
Patch:
@@ -478,6 +478,7 @@ enum Loader implements CacheLoader<Int, Int> {
       @Override public Int load(Int key) {
         throw new UnsupportedOperationException();
       }
+      @SuppressWarnings("ReturnsNullCollection")
       @Override public Map<Int, Int> loadAll(Set<? extends Int> keys) {
         return null;
       }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/ExpiryBuilder.java
Patch:
@@ -27,9 +27,9 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 public final class ExpiryBuilder {
-  static final int UNSET = -1;
+  private static final int UNSET = -1;
 
-  private long createNanos;
+  private final long createNanos;
   private long updateNanos;
   private long readNanos;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/jsr166/ConcurrentHashMapTest.java
Patch:
@@ -22,7 +22,7 @@
 import junit.framework.Test;
 import junit.framework.TestSuite;
 
-@SuppressWarnings({"rawtypes", "unchecked",
+@SuppressWarnings({"rawtypes", "unchecked", "HashCodeToString",
   "ModifyCollectionInEnhancedForLoop", "ReturnValueIgnored", "UnnecessaryParentheses"})
 public class ConcurrentHashMapTest extends JSR166TestCase {
     public static void main(String[] args) {

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaLoadingCache.java
Patch:
@@ -68,7 +68,8 @@ public V get(K key) throws ExecutionException {
   }
 
   @Override
-  @SuppressWarnings({"PMD.PreserveStackTrace", "PMD.AvoidCatchingNPE", "NullAway"})
+  @SuppressWarnings({"PMD.PreserveStackTrace",
+    "PMD.AvoidCatchingNPE", "NullAway", "CatchingUnchecked"})
   public V getUnchecked(K key) {
     try {
       return cache.get(key);
@@ -84,7 +85,7 @@ public V getUnchecked(K key) {
   }
 
   @Override
-  @SuppressWarnings({"PMD.PreserveStackTrace", "PMD.AvoidCatchingNPE"})
+  @SuppressWarnings({"PMD.PreserveStackTrace", "PMD.AvoidCatchingNPE", "CatchingUnchecked"})
   public ImmutableMap<K, V> getAll(Iterable<? extends K> keys) throws ExecutionException {
     try {
       Map<K, V> result = cache.getAll(keys);

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatability/CacheEvictionTest.java
Patch:
@@ -350,6 +350,7 @@ private void getAll(LoadingCache<Integer, Integer> cache, List<Integer> keys) {
     }
   }
 
+  @SuppressWarnings("HashCodeToString")
   private Object objectWithHash(final int hash) {
     return new Object() {
       @Override public int hashCode() {

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatability/CacheLoadingTest.java
Patch:
@@ -839,6 +839,7 @@ public Object load(Object key) {
           }
 
           @Override
+          @SuppressWarnings("ReturnsNullCollection")
           public Map<Object, Object> loadAll(Iterable<? extends Object> keys) {
             return null;
           }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/LoadingCacheProxy.java
Patch:
@@ -150,6 +150,7 @@ private Map<K, V> getAll(Set<? extends K> keys, boolean updateAccessTime) {
   }
 
   @Override
+  @SuppressWarnings("CatchingUnchecked")
   public void loadAll(Set<? extends K> keys, boolean replaceExistingValues,
       CompletionListener completionListener) {
     requireNotClosed();

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/configuration/TestCacheLoader.java
Patch:
@@ -26,6 +26,7 @@ public final class TestCacheLoader implements CacheLoader<Integer, Integer> {
   @Override public Integer load(Integer key) {
     return null;
   }
+  @SuppressWarnings("ReturnsNullCollection")
   @Override public Map<Integer, Integer> loadAll(Iterable<? extends Integer> keys) {
     return null;
   }

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/JCacheExpiryAndMaximumSizeTest.java
Patch:
@@ -53,7 +53,7 @@ public class JCacheExpiryAndMaximumSizeTest extends AbstractJCacheTest {
   private static final long ONE_MINUTE = TimeUnit.MINUTES.toNanos(1);
   private static final int MAXIMUM = 10;
 
-  private Expiry<Integer, Integer> expiry = Mockito.mock(Expiry.class);
+  private final Expiry<Integer, Integer> expiry = Mockito.mock(Expiry.class);
   private final AtomicInteger removed = new AtomicInteger();
 
   @BeforeMethod

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/JCacheExpiryTest.java
Patch:
@@ -42,7 +42,7 @@
 public final class JCacheExpiryTest extends AbstractJCacheTest {
   private static final long ONE_MINUTE = TimeUnit.MINUTES.toNanos(1);
 
-  private Expiry<Integer, Integer> expiry = Mockito.mock(Expiry.class);
+  private final Expiry<Integer, Integer> expiry = Mockito.mock(Expiry.class);
 
   @BeforeMethod
   public void setup() {

File: simulator/src/jmh/java/com/github/benmanes/caffeine/cache/simulator/TraceBenchmark.java
Patch:
@@ -83,7 +83,7 @@ public Policy makePolicy() {
     return policies.iterator().next();
   }
 
-  private Stream<AccessEvent> readEventStream(BasicSettings settings) throws IOException {
+  private Stream<AccessEvent> readEventStream(BasicSettings settings) {
     if (settings.trace().isSynthetic()) {
       return Synthetic.generate(settings.trace()).events();
     }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinyCache.java
Patch:
@@ -61,7 +61,7 @@ public boolean contains(long item) {
           return true;
         }
         indexing.chainStart++;
-      } catch (Exception e) {
+      } catch (RuntimeException e) {
         System.out.println("length: " + cache.length + " Access: " + indexing.chainStart);
       }
     }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinyCacheSketch.java
Patch:
@@ -63,7 +63,7 @@ public int countItem(long item) {
         }
         indexing.chainStart++;
 
-      } catch (Exception e) {
+      } catch (RuntimeException e) {
         System.out.println("length: " + cache.length + " Access: " + indexing.chainStart);
       }
     }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinyCacheWithGhostCache.java
Patch:
@@ -65,7 +65,7 @@ public boolean contains(long item) {
           return true;
         }
         indexing.chainStart++;
-      } catch (Exception e) {
+      } catch (RuntimeException e) {
         System.out.println("length: " + cache.length + " Access: " + indexing.chainStart);
       }
     }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/Rewriter.java
Patch:
@@ -47,7 +47,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@SuppressWarnings("PMD.ImmutableField")
+@SuppressWarnings({"PMD.ImmutableField", "FieldCanBeFinal"})
 public final class Rewriter implements Runnable {
   @Option(names = "--inputFiles", required = true, description = "The trace input files. To use "
       + "a mix of formats, specify the entry as format:path, e.g. lirs:loop.trace.gz")
@@ -83,7 +83,7 @@ public void run() {
     }
   }
 
-  public static void main(String[] args) throws IOException {
+  public static void main(String[] args) {
     new CommandLine(Rewriter.class)
         .setColorScheme(Help.defaultColorScheme(Help.Ansi.ON))
         .setCommandName(Rewriter.class.getSimpleName())

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/PolicyActor.java
Patch:
@@ -61,7 +61,7 @@ private void process(List<AccessEvent> events) {
           policy.stats().recordMissPenalty(event.missPenalty());
         }
       }
-    } catch (Exception e) {
+    } catch (RuntimeException e) {
       sender().tell(ERROR, self());
       context().system().stop(self());
       context().system().log().error(e, "");
@@ -74,7 +74,7 @@ private void finish() {
     try {
       policy.finished();
       sender().tell(policy.stats(), self());
-    } catch (Exception e) {
+    } catch (RuntimeException e) {
       sender().tell(ERROR, self());
       context().system().stop(self());
       context().system().log().error(e, "");

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/hill/SimpleClimber.java
Patch:
@@ -66,7 +66,7 @@ protected void resetSample(double hitRate) {
     super.resetSample(hitRate);
 
     stepSize *= stepDecayRate;
-    sampleSize *= (int) (sampleSize * sampleDecayRate);
+    sampleSize = (int) (sampleSize * sampleDecayRate);
     if ((stepSize <= 0.01) || (sampleSize <= 1)) {
       sampleSize = Integer.MAX_VALUE;
     }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/sim/MiniSimClimber.java
Patch:
@@ -41,12 +41,12 @@ public final class MiniSimClimber implements HillClimber {
   private static final HashFunction hasher = Hashing.murmur3_32(0x7f3a2142);
 
   private final WindowTinyLfuPolicy[] minis;
+  private final long[] prevMisses;
   private final int cacheSize;
   private final int period;
   private final int R;
 
   private int sample;
-  private long[] prevMisses;
   private double prevPercent;
 
   public MiniSimClimber(Config config) {

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/Feature.java
Patch:
@@ -112,6 +112,6 @@ public static boolean usesMaximum(Set<Feature> features) {
   public static boolean usesFastPath(Set<Feature> features) {
     Set<Feature> incompatible = Sets.immutableEnumSet(Feature.EXPIRE_ACCESS,
         Feature.WEAK_KEYS, Feature.INFIRM_VALUES, Feature.WEAK_VALUES, Feature.SOFT_VALUES);
-    return !features.stream().anyMatch(incompatible::contains) && usesMaximum(features);
+    return features.stream().noneMatch(incompatible::contains) && usesMaximum(features);
   }
 }

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/NodeRule.java
Patch:
@@ -177,7 +177,7 @@ private Strength strengthOf(Feature feature) {
   }
 
   protected enum Strength {
-    STRONG, WEAK, SOFT;
+    STRONG, WEAK, SOFT
   }
 
   protected enum Visibility {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -3737,7 +3737,7 @@ final class BoundedVarExpiration implements VarExpiration<K, V> {
 
         if (!onlyIfAbsent) {
           var oldValueFuture = (CompletableFuture<V>) cache.put(
-              key, asyncValue, expiry, onlyIfAbsent);
+              key, asyncValue, expiry, /* onlyIfAbsent */ false);
           return Async.getWhenSuccessful(oldValueFuture);
         }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncLoadingCache.java
Patch:
@@ -224,7 +224,7 @@ public CompletableFuture<Map<K, V>> refreshAll(Iterable<? extends K> keys) {
       if ((oldValueFuture == null)
           || (oldValueFuture.isDone() && oldValueFuture.isCompletedExceptionally())) {
         if (oldValueFuture != null) {
-          asyncCache.cache().remove(key, asyncCache);
+          asyncCache.cache().remove(key, oldValueFuture);
         }
         var future = asyncCache.get(key, asyncCache.mappingFunction, /* recordStats */ false);
         @SuppressWarnings("unchecked")

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsyncLoadingCacheTest.java
Patch:
@@ -317,7 +317,7 @@ public void getAll_badLoader(CacheContext context) {
   }
 
   @SuppressWarnings("serial")
-  private static final class LoadAllException extends RuntimeException {};
+  private static final class LoadAllException extends RuntimeException {}
 
   /* --------------- put --------------- */
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -726,8 +726,8 @@ private BoundedLocalCache<Int, Int> prepareForAdaption(
     // Fill window and main spaces
     cache.invalidateAll();
     cache.asMap().putAll(context.original());
-    cache.asMap().keySet().stream().forEach(cache::getIfPresent);
-    cache.asMap().keySet().stream().forEach(cache::getIfPresent);
+    cache.asMap().keySet().forEach(cache::getIfPresent);
+    cache.asMap().keySet().forEach(cache::getIfPresent);
     return localCache;
   }
 
@@ -739,7 +739,7 @@ private void adapt(Cache<Int, Int> cache,
     localCache.climb();
 
     // Fill main protected space
-    cache.asMap().keySet().stream().forEach(cache::getIfPresent);
+    cache.asMap().keySet().forEach(cache::getIfPresent);
   }
 
   /* --------------- Expiration --------------- */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/EvictionTest.java
Patch:
@@ -58,8 +58,8 @@
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
 import com.github.benmanes.caffeine.cache.testing.CheckNoStats;
 import com.github.benmanes.caffeine.cache.testing.RemovalListeners.RejectingRemovalListener;
-import com.github.benmanes.caffeine.testing.Int;
 import com.github.benmanes.caffeine.cache.testing.RemovalNotification;
+import com.github.benmanes.caffeine.testing.Int;
 import com.google.common.collect.ImmutableList;
 
 /**
@@ -599,7 +599,7 @@ public void maximumSize_increase_max(Cache<Int, Int> cache,
   @CacheSpec(implementation = Implementation.Caffeine, maximumSize = Maximum.FULL)
   @Test(dataProvider = "caches", expectedExceptions = UnsupportedOperationException.class)
   public void coldest_unmodifiable(CacheContext context, Eviction<Int, Int> eviction) {
-    eviction.coldest(Integer.MAX_VALUE).clear();;
+    eviction.coldest(Integer.MAX_VALUE).clear();
   }
 
   @CacheSpec(implementation = Implementation.Caffeine, maximumSize = Maximum.FULL)

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterAccessTest.java
Patch:
@@ -49,10 +49,10 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Listener;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Loader;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Population;
-import com.github.benmanes.caffeine.testing.Int;
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
 import com.github.benmanes.caffeine.cache.testing.CheckNoStats;
 import com.github.benmanes.caffeine.cache.testing.ExpireAfterAccess;
+import com.github.benmanes.caffeine.testing.Int;
 import com.google.common.collect.ImmutableList;
 
 /**
@@ -292,7 +292,7 @@ public void ageOf_duration(CacheContext context,
   @Test(dataProvider = "caches", expectedExceptions = UnsupportedOperationException.class)
   public void oldest_unmodifiable(CacheContext context,
       @ExpireAfterAccess FixedExpiration<Int, Int> expireAfterAccess) {
-    expireAfterAccess.oldest(Integer.MAX_VALUE).clear();;
+    expireAfterAccess.oldest(Integer.MAX_VALUE).clear();
   }
 
   @CacheSpec(implementation = Implementation.Caffeine, expireAfterAccess = Expire.ONE_MINUTE)
@@ -343,7 +343,7 @@ public void oldest_snapshot(Cache<Int, Int> cache, CacheContext context,
   @Test(dataProvider = "caches", expectedExceptions = UnsupportedOperationException.class)
   public void youngest_unmodifiable(CacheContext context,
       @ExpireAfterAccess FixedExpiration<Int, Int> expireAfterAccess) {
-    expireAfterAccess.youngest(Integer.MAX_VALUE).clear();;
+    expireAfterAccess.youngest(Integer.MAX_VALUE).clear();
   }
 
   @CacheSpec(implementation = Implementation.Caffeine, expireAfterAccess = Expire.ONE_MINUTE)

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterVarTest.java
Patch:
@@ -640,7 +640,7 @@ public void oldest_snapshot(Cache<Int, Int> cache,
   @CacheSpec(implementation = Implementation.Caffeine, expiry = CacheExpiry.ACCESS)
   @Test(dataProvider = "caches", expectedExceptions = UnsupportedOperationException.class)
   public void youngest_unmodifiable(CacheContext context, VarExpiration<Int, Int> expireAfterVar) {
-    expireAfterVar.youngest(Integer.MAX_VALUE).clear();;
+    expireAfterVar.youngest(Integer.MAX_VALUE).clear();
   }
 
   @CacheSpec(implementation = Implementation.Caffeine, expiry = CacheExpiry.ACCESS)

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterWriteTest.java
Patch:
@@ -47,10 +47,10 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Listener;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Loader;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Population;
-import com.github.benmanes.caffeine.testing.Int;
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
 import com.github.benmanes.caffeine.cache.testing.CheckNoStats;
 import com.github.benmanes.caffeine.cache.testing.ExpireAfterWrite;
+import com.github.benmanes.caffeine.testing.Int;
 import com.google.common.collect.ImmutableList;
 
 /**
@@ -335,7 +335,7 @@ public void oldest_snapshot(Cache<Int, Int> cache, CacheContext context,
   @Test(dataProvider = "caches", expectedExceptions = UnsupportedOperationException.class)
   public void youngest_unmodifiable(CacheContext context,
       @ExpireAfterWrite FixedExpiration<Int, Int> expireAfterWrite) {
-    expireAfterWrite.youngest(Integer.MAX_VALUE).clear();;
+    expireAfterWrite.youngest(Integer.MAX_VALUE).clear();
   }
 
   @CacheSpec(implementation = Implementation.Caffeine, expireAfterWrite = Expire.ONE_MINUTE)

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidBoundedLocalCache.java
Patch:
@@ -109,8 +109,8 @@ private Boolean tryDrainBuffers(BoundedLocalCache<K, V> cache) {
   }
 
   private void checkCache(BoundedLocalCache<K, V> cache) {
+    long remainingNanos = TimeUnit.SECONDS.toNanos(5);
     for (;;) {
-      long remainingNanos = TimeUnit.SECONDS.toNanos(5);
       long end = System.nanoTime() + remainingNanos;
       try {
         if (cache.evictionLock.tryLock(remainingNanos, TimeUnit.NANOSECONDS)) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/Stresser.java
Patch:
@@ -59,7 +59,7 @@ private enum Operation {
     private final int maxThreads;
     private final int maxEntries;
 
-    private Operation(int maxThreads, int maxEntries) {
+    Operation(int maxThreads, int maxEntries) {
       this.maxThreads = maxThreads;
       this.maxEntries = maxEntries;
     }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/TimerWheelTest.java
Patch:
@@ -404,7 +404,7 @@ public void snapshot(boolean ascending, int limit, long clock, Function<Long, Lo
     int expected = Math.min(limit, count);
     Comparator<Long> order = ascending ? Comparator.naturalOrder() : Comparator.reverseOrder();
     var times = IntStream.range(0, count).mapToLong(i -> {
-      long time = clock + TimeUnit.SECONDS.toNanos(2 << i);
+      long time = clock + TimeUnit.SECONDS.toNanos(2L << i);
       timerWheel.schedule(new Timer(time));
       return time;
     }).boxed().sorted(order).collect(toList()).subList(0, expected);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/BufferType.java
Patch:
@@ -36,7 +36,7 @@ public enum BufferType {
 
   private final Supplier<ReadBuffer<Boolean>> factory;
 
-  private BufferType(Supplier<ReadBuffer<Boolean>> factory) {
+  BufferType(Supplier<ReadBuffer<Boolean>> factory) {
     this.factory = factory;
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/MpmcArrayBuffer.java
Patch:
@@ -39,7 +39,7 @@ public int offer(E e) {
 
   @Override
   public void drainTo(Consumer<E> consumer) {
-    E e = null;
+    E e;
     while ((e = queue.poll()) != null) {
       consumer.accept(e);
       drained++;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/MpscArrayBuffer.java
Patch:
@@ -39,7 +39,7 @@ public int offer(E e) {
 
   @Override
   public void drainTo(Consumer<E> consumer) {
-    E e = null;
+    E e;
     while ((e = queue.poll()) != null) {
       consumer.accept(e);
       drained++;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/MpscCompoundBuffer.java
Patch:
@@ -39,7 +39,7 @@ public int offer(E e) {
 
   @Override
   public void drainTo(Consumer<E> consumer) {
-    E e = null;
+    E e;
     while ((e = queue.poll()) != null) {
       consumer.accept(e);
       drained++;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheGenerator.java
Patch:
@@ -186,7 +186,7 @@ private boolean isCompatible(CacheContext context) {
             || (context.expireAfterAccess() != Expire.DISABLED)
             || (context.expireAfterWrite() != Expire.DISABLED));
     boolean expirationIncompatible = (cacheSpec.mustExpireWithAnyOf().length > 0)
-        && !Arrays.stream(cacheSpec.mustExpireWithAnyOf()).anyMatch(context::expires);
+        && Arrays.stream(cacheSpec.mustExpireWithAnyOf()).noneMatch(context::expires);
     boolean schedulerIgnored = (context.cacheScheduler != CacheScheduler.DEFAULT)
         && !context.expires();
     boolean evictionListenerIncompatible = (context.evictionListenerType() != Listener.DEFAULT)

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/IsEmptyIterable.java
Patch:
@@ -111,7 +111,7 @@ private void checkNoSuchElementException(String label,
     try {
       method.run();
       builder.expected(label);
-    } catch (NoSuchElementException e) {}
+    } catch (NoSuchElementException expected) {}
   }
 
   public static <E> IsEmptyIterable<E> deeplyEmpty() {

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatability/CacheBuilderTest.java
Patch:
@@ -598,7 +598,7 @@ public void testRemovalNotification_get_basher() throws InterruptedException {
           for (int j = 0; j < getsPerTask; j++) {
             try {
               cache.getUnchecked("key" + random.nextInt(nUniqueKeys));
-            } catch (RuntimeException e) {
+            } catch (RuntimeException expected) {
             }
           }
         }

File: guava/src/test/java/com/github/benmanes/caffeine/guava/compatability/LocalCacheMapComputeTest.java
Patch:
@@ -116,6 +116,6 @@ public void testComputeExceptionally() {
         cache.asMap().compute(key, (k, v) -> { throw new RuntimeException(); });
       });
       fail("Should not get here");
-    } catch (RuntimeException ex) {}
+    } catch (RuntimeException expected) {}
   }
 }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheManagerImpl.java
Patch:
@@ -47,6 +47,7 @@ public final class CacheManagerImpl implements CacheManager {
   private final CachingProvider cacheProvider;
   private final Properties properties;
   private final URI uri;
+
   private final boolean runsAsAnOsgiBundle;
 
   private volatile boolean closed;

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/JCacheProfiler.java
Patch:
@@ -60,7 +60,7 @@ public final class JCacheProfiler {
   }
 
   public void start() {
-    for (Integer i = 0; i < KEYS; i++) {
+    for (int i = 0; i < KEYS; i++) {
       cache.put(i, Boolean.TRUE);
     }
     Runnable task = () -> {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/perfect/PerfectFrequency.java
Patch:
@@ -59,6 +59,6 @@ private void reset() {
     for (Long2IntMap.Entry entry : counts.long2IntEntrySet()) {
       entry.setValue(entry.getIntValue() / 2);
     }
-    size = (size / 2);
+    size /= 2;
   }
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/TraceWriter.java
Patch:
@@ -28,11 +28,11 @@
 public interface TraceWriter extends Closeable {
 
   /** Writes the header for the trace format. */
-  default void writeHeader() throws IOException {};
+  default void writeHeader() throws IOException {}
 
   /** Writes the event in the trace format. */
   void writeEvent(int tick, AccessEvent event) throws IOException;
 
   /** Writes the footer for the trace format. */
-  default void writeFooter() throws IOException {};
+  default void writeFooter() throws IOException {}
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/ClockProPlusPolicy.java
Patch:
@@ -449,7 +449,7 @@ private void coldTargetAdjust(boolean increase) {
       delta = 1;
     }
     if (!increase) {
-      delta = delta * -1;
+      delta *= -1;
     }
     coldTargetAdjust(delta);
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/hill/SimpleClimber.java
Patch:
@@ -66,7 +66,7 @@ protected void resetSample(double hitRate) {
     super.resetSample(hitRate);
 
     stepSize *= stepDecayRate;
-    sampleSize = (int) (sampleSize * sampleDecayRate);
+    sampleSize *= (int) (sampleSize * sampleDecayRate);
     if ((stepSize <= 0.01) || (sampleSize <= 1)) {
       sampleSize = Integer.MAX_VALUE;
     }

File: simulator/src/test/java/com/github/benmanes/caffeine/cache/simulator/admission/bloom/MembershipTest.java
Patch:
@@ -54,7 +54,7 @@ public class MembershipTest {
   @Test(dataProvider = "filterTypes")
   public void bloomFilterTest(FilterType filterType) {
     List<Integer> capacities = new ArrayList<>(ImmutableList.of(0, 1));
-    for (int capacity = 2 << 10; capacity < (2 << 22); capacity = capacity << 2) {
+    for (int capacity = 2 << 10; capacity < (2 << 22); capacity <<= 2) {
       capacities.add(capacity);
     }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedBufferTest.java
Patch:
@@ -20,7 +20,6 @@
 import static org.hamcrest.Matchers.is;
 
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
 import org.testng.annotations.DataProvider;
@@ -66,8 +65,8 @@ public void drain(BoundedBuffer<String> buffer) {
   @Test(dataProvider = "buffer")
   @SuppressWarnings("ThreadPriorityCheck")
   public void offerAndDrain(BoundedBuffer<String> buffer) {
-    Lock lock = new ReentrantLock();
-    AtomicInteger reads = new AtomicInteger();
+    var lock = new ReentrantLock();
+    var reads = new AtomicInteger();
     ConcurrentTestHarness.timeTasks(10, () -> {
       for (int i = 0; i < 1000; i++) {
         boolean shouldDrain = (buffer.offer(DUMMY) == Buffer.FULL);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CaffeineMapTests.java
Patch:
@@ -32,7 +32,7 @@
 public final class CaffeineMapTests extends TestCase {
 
   public static Test suite() {
-    TestSuite suite = new TestSuite();
+    var suite = new TestSuite();
     addUnboundedTests(suite);
     addBoundedTests(suite);
     return suite;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidLinkedDeque.java
Patch:
@@ -45,7 +45,7 @@ public void describeTo(Description description) {
 
   @Override
   protected boolean matchesSafely(LinkedDeque<E> deque, Description description) {
-    DescriptionBuilder desc = new DescriptionBuilder(description);
+    var desc = new DescriptionBuilder(description);
 
     if (deque.isEmpty()) {
       checkEmpty(deque, desc);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidMapView.java
Patch:
@@ -43,13 +43,13 @@ protected boolean matchesSafely(Map<K, V> map, Description description) {
     this.description = description;
 
     if (map instanceof BoundedLocalCache<?, ?>) {
-      BoundedLocalCache<K, V> cache = (BoundedLocalCache<K, V>) map;
+      var cache = (BoundedLocalCache<K, V>) map;
       return IsValidBoundedLocalCache.<K, V>valid().matchesSafely(cache, description);
     } else if (map instanceof UnboundedLocalCache<?, ?>) {
-      UnboundedLocalCache<K, V> cache = (UnboundedLocalCache<K, V>) map;
+      var cache = (UnboundedLocalCache<K, V>) map;
       return IsValidUnboundedLocalCache.<K, V>valid().matchesSafely(cache, description);
     } else if (map instanceof LocalAsyncLoadingCache.AsMapView<?, ?>) {
-      LocalAsyncLoadingCache.AsMapView<K, V> asMap = (LocalAsyncLoadingCache.AsMapView<K, V>) map;
+      var asMap = (LocalAsyncLoadingCache.AsMapView<K, V>) map;
       if (asMap.delegate instanceof BoundedLocalCache<?, ?>) {
         return IsValidBoundedLocalCache.<K, CompletableFuture<V>>valid().matchesSafely(
             (BoundedLocalCache<K, CompletableFuture<V>>) asMap.delegate, description);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidUnboundedLocalCache.java
Patch:
@@ -61,7 +61,7 @@ private void checkMap(UnboundedLocalCache<K, V> map, DescriptionBuilder desc) {
       desc.expectThat("non null value", value, is(not(nullValue())));
 
       if (value instanceof CompletableFuture<?>) {
-        CompletableFuture<?> future = (CompletableFuture<?>) value;
+        var future = (CompletableFuture<?>) value;
         boolean success = future.isDone() && !future.isCompletedExceptionally();
         desc.expectThat("future is done", success, is(true));
         desc.expectThat("not null value", future.getNow(null), is(not(nullValue())));

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/MpscGrowableQueueSanityTest.java
Patch:
@@ -15,7 +15,6 @@
 
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.List;
 import java.util.Queue;
 
 import org.junit.runner.RunWith;
@@ -35,7 +34,7 @@ public MpscGrowableQueueSanityTest(
 
   @Parameterized.Parameters
   public static Collection<Object[]> parameters() {
-    List<Object[]> list = new ArrayList<Object[]>();
+    var list = new ArrayList<Object[]>();
     // MPSC size 1
     list.add(makeQueue(0, 1, 4, org.jctools.queues.spec.Ordering.FIFO,
         new MpscGrowableArrayQueue<>(2, 4)));

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheValidationListener.java
Patch:
@@ -236,7 +236,7 @@ private void cleanUp(ITestResult testResult) {
 
     stringifyParams(testResult, briefParams);
     dedupTestName(testResult, briefParams);
-    CacheSpec.interner.get().clear();
+    CacheContext.interner().clear();
   }
 
   private void dedupTestName(ITestResult testResult, boolean briefParams) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/MpscGrowableArrayQueue.java
Patch:
@@ -336,8 +336,7 @@ public E poll() {
     if (e == null) {
       if (index != lvProducerIndex(this)) {
         // poll() == null iff queue is empty, null element is not strong enough indicator, so we
-        // must
-        // check the producer index. If the queue is indeed not empty we spin until element is
+        // must check the producer index. If the queue is indeed not empty we spin until element is
         // visible.
         do {
           e = lvElement(buffer, offset);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LoadingCacheTest.java
Patch:
@@ -346,8 +346,8 @@ public void refresh_dedupe(LoadingCache<Integer, Integer> cache, CacheContext co
     var future2 = cache.refresh(key);
     assertThat(future1, is(sameInstance(future2)));
 
-    future1.complete(-key);
-    assertThat(cache.getIfPresent(key), is(-key));
+    future1.complete(context.absentValue());
+    assertThat(cache.getIfPresent(key), is(context.absentValue()));
   }
 
   @Test(dataProvider = "caches")

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurator.java
Patch:
@@ -51,7 +51,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@SuppressWarnings("PMD.AvoidDuplicateLiterals")
+@SuppressWarnings({"PMD.AvoidDuplicateLiterals", "PMD.MutableStaticState"})
 public final class TypesafeConfigurator {
   static final Logger logger = Logger.getLogger(TypesafeConfigurator.class.getName());
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/spi/CaffeineCachingProvider.java
Patch:
@@ -269,5 +269,4 @@ private void activate() {
   public boolean isOsgiComponent() {
     return isOsgiComponent;
   }
-
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/AbstractTraceReader.java
Patch:
@@ -126,7 +126,7 @@ protected BufferedInputStream readInput(InputStream input) {
           try {
             return (archive.getNextEntry() == null)
                 ? endOfData()
-                : readInput(new CloseShieldInputStream(archive));
+                : readInput(CloseShieldInputStream.wrap(archive));
           } catch (IOException e) {
             throw new UncheckedIOException(e);
           }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncCache.java
Patch:
@@ -567,7 +567,7 @@ public void invalidateAll() {
 
     @Override
     public long estimatedSize() {
-      return asyncCache().cache().size();
+      return asyncCache().cache().estimatedSize();
     }
 
     @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/greedy_dual/GDWheelPolicy.java
Patch:
@@ -122,7 +122,7 @@ private void migrate(int level) {
     clockHand[level] = hand;
 
     // if C[idx] has advanced a whole round back to 1, call migration(idx+1)
-    if ((hand == 0) && (level < wheel.length)) {
+    if ((hand == 0) && (level + 1 < wheel.length)) {
       migrate(level + 1);
     }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/opt/ClairvoyantPolicy.java
Patch:
@@ -85,7 +85,9 @@ public PolicyStats stats() {
   @Override
   public void finished() {
     policyStats.stopwatch().start();
-    recorder.process();
+    if (recorder != null) {
+      recorder.process();
+    }
     policyStats.stopwatch().stop();
   }
 

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/BasicCache.java
Patch:
@@ -15,15 +15,14 @@
  */
 package com.github.benmanes.caffeine.cache;
 
-import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A facade for benchmark implementations.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public interface BasicCache<K extends @NonNull Object, V extends @NonNull Object> {
+public interface BasicCache<K extends Object, V extends Object> {
 
   /** Returns the value stored in the cache, or null if not present. */
   @Nullable V get(K key);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncCache.java
Patch:
@@ -23,7 +23,6 @@
 import java.util.function.BiFunction;
 import java.util.function.Function;
 
-import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.google.errorprone.annotations.CheckReturnValue;
@@ -40,7 +39,7 @@
  * @param <K> the type of keys maintained by this cache
  * @param <V> the type of mapped values
  */
-public interface AsyncCache<K extends @NonNull Object, V extends @NonNull Object> {
+public interface AsyncCache<K extends Object, V extends Object> {
 
   /**
    * Returns the future associated with {@code key} in this cache, or {@code null} if there is no

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncCacheLoader.java
Patch:
@@ -24,8 +24,6 @@
 import java.util.function.BiFunction;
 import java.util.function.Function;
 
-import org.checkerframework.checker.nullness.qual.NonNull;
-
 import com.google.errorprone.annotations.CheckReturnValue;
 
 /**
@@ -46,7 +44,7 @@
  */
 @FunctionalInterface
 @SuppressWarnings("PMD.SignatureDeclareThrowsException")
-public interface AsyncCacheLoader<K extends @NonNull Object, V extends @NonNull Object> {
+public interface AsyncCacheLoader<K extends Object, V extends Object> {
 
   /**
    * Asynchronously computes or retrieves the value corresponding to {@code key}.

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncLoadingCache.java
Patch:
@@ -18,8 +18,6 @@
 import java.util.Map;
 import java.util.concurrent.CompletableFuture;
 
-import org.checkerframework.checker.nullness.qual.NonNull;
-
 import com.google.errorprone.annotations.CheckReturnValue;
 
 /**
@@ -33,7 +31,7 @@
  * @param <K> the type of keys maintained by this cache
  * @param <V> the type of mapped values
  */
-public interface AsyncLoadingCache<K extends @NonNull Object, V extends @NonNull Object>
+public interface AsyncLoadingCache<K extends Object, V extends Object>
     extends AsyncCache<K, V> {
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Cache.java
Patch:
@@ -21,7 +21,6 @@
 import java.util.function.Function;
 
 import org.checkerframework.checker.index.qual.NonNegative;
-import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.checkerframework.checker.nullness.qual.PolyNull;
 
@@ -40,7 +39,7 @@
  * @param <K> the type of keys maintained by this cache
  * @param <V> the type of mapped values
  */
-public interface Cache<K extends @NonNull Object, V extends @NonNull Object> {
+public interface Cache<K extends Object, V extends Object> {
 
   /**
    * Returns the value associated with the {@code key} in this cache, or {@code null} if there is no

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheLoader.java
Patch:
@@ -24,7 +24,6 @@
 import java.util.concurrent.Executor;
 import java.util.function.Function;
 
-import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.google.errorprone.annotations.CheckReturnValue;
@@ -46,8 +45,7 @@
  */
 @FunctionalInterface
 @SuppressWarnings({"PMD.SignatureDeclareThrowsException", "FunctionalInterfaceMethodChanged"})
-public interface CacheLoader<K extends @NonNull Object, V extends @NonNull Object>
-    extends AsyncCacheLoader<K, V> {
+public interface CacheLoader<K extends Object, V extends Object> extends AsyncCacheLoader<K, V> {
 
   /**
    * Computes or retrieves the value corresponding to {@code key}.

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -36,7 +36,6 @@
 import java.util.function.Supplier;
 
 import org.checkerframework.checker.index.qual.NonNegative;
-import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.cache.Async.AsyncEvictionListener;
@@ -137,7 +136,7 @@
  *     normally {@code Object} unless it is constrained by using a method like {@code
  *     #removalListener}
  */
-public final class Caffeine<K extends @NonNull Object, V extends @NonNull Object> {
+public final class Caffeine<K extends Object, V extends Object> {
   static final Logger logger = System.getLogger(Caffeine.class.getName());
   static final Supplier<StatsCounter> ENABLED_STATS_COUNTER_SUPPLIER = ConcurrentStatsCounter::new;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Expiry.java
Patch:
@@ -16,15 +16,14 @@
 package com.github.benmanes.caffeine.cache;
 
 import org.checkerframework.checker.index.qual.NonNegative;
-import org.checkerframework.checker.nullness.qual.NonNull;
 
 /**
  * Calculates when cache entries expire. A single expiration time is retained so that the lifetime
  * of an entry may be extended or reduced by subsequent evaluations.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public interface Expiry<K extends @NonNull Object, V extends @NonNull Object> {
+public interface Expiry<K extends Object, V extends Object> {
 
   /**
    * Specifies that the entry should be automatically removed from the cache once the duration has

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LoadingCache.java
Patch:
@@ -19,7 +19,6 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 
-import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -33,8 +32,7 @@
  * @param <K> the type of keys maintained by this cache
  * @param <V> the type of mapped values
  */
-public interface LoadingCache<K extends @NonNull Object, V extends @NonNull Object>
-    extends Cache<K, V> {
+public interface LoadingCache<K extends Object, V extends Object> extends Cache<K, V> {
 
   /**
    * Returns the value associated with the {@code key} in this cache, obtaining that value from

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/RemovalListener.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache;
 
-import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -34,7 +33,7 @@
  *        {@code Object} if any value is acceptable
  */
 @FunctionalInterface
-public interface RemovalListener<K extends @NonNull Object, V extends @NonNull Object> {
+public interface RemovalListener<K extends Object, V extends Object> {
 
   /**
    * Notifies the listener that a removal occurred at some point in the past.

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Weigher.java
Patch:
@@ -20,7 +20,6 @@
 import java.io.Serializable;
 
 import org.checkerframework.checker.index.qual.NonNegative;
-import org.checkerframework.checker.nullness.qual.NonNull;
 
 /**
  * Calculates the weights of cache entries. The total weight threshold is used to determine when an
@@ -31,7 +30,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @FunctionalInterface
-public interface Weigher<K extends @NonNull Object, V extends @NonNull Object> {
+public interface Weigher<K extends Object, V extends Object> {
 
   /**
    * Returns the weight of a cache entry. There is no unit for entry weights; rather they are simply

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/StripedBuffer.java
Patch:
@@ -340,7 +340,7 @@ static final class VarHandleProbe implements Probe {
 
   /** Uses a thread local to maintain a random probe value. */
   static final class ThreadLocalProbe implements Probe {
-    static final ThreadLocal<int[]> threadHashCode = new ThreadLocal<>();
+    static final ThreadLocal<int[]> threadHashCode = ThreadLocal.withInitial(() -> new int[1]);
 
     @Override public int get() {
       return threadHashCode.get()[0];
@@ -351,7 +351,7 @@ static final class ThreadLocalProbe implements Probe {
     @Override public void initialize() {
       // Avoid zero to allow xorShift rehash
       int hash = 1 | ThreadLocalRandom.current().nextInt();
-      threadHashCode.set(new int[] { hash });
+      threadHashCode.get()[0] = hash;
     }
   }
 }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/StripedBufferTest.java
Patch:
@@ -49,6 +49,7 @@ public void init(FakeBuffer<Integer> buffer) {
 
   @Test(dataProvider = "probes")
   public void probe(Probe probe) {
+    probe.get();
     probe.initialize();
     assertThat(probe.get(), is(not(0)));
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1630,6 +1630,7 @@ void reorderProbation(Node<K, V> node) {
       // Ignore stale accesses for an entry that is no longer present
       return;
     } else if (node.getPolicyWeight() > mainProtectedMaximum()) {
+      reorder(accessOrderProbationDeque(), node);
       return;
     }
 

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/BasicCache.java
Patch:
@@ -15,14 +15,15 @@
  */
 package com.github.benmanes.caffeine.cache;
 
+import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A facade for benchmark implementations.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public interface BasicCache<K, V> {
+public interface BasicCache<K extends @NonNull Object, V extends @NonNull Object> {
 
   /** Returns the value stored in the cache, or null if not present. */
   @Nullable V get(K key);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1230,7 +1230,7 @@ void refreshIfNeeded(Node<K, V> node, long now) {
         && !refreshes().containsKey(keyReference)) {
       long[] startTime = new long[1];
       @SuppressWarnings({"unchecked", "rawtypes"})
-      CompletableFuture<V>[] refreshFuture = new CompletableFuture[1];
+      CompletableFuture<? extends V>[] refreshFuture = new CompletableFuture[1];
       refreshes().computeIfAbsent(keyReference, k -> {
         try {
           startTime[0] = statsTicker().read();
@@ -4005,7 +4005,7 @@ static final class AsyncLoader<K, V> implements CacheLoader<K, V> {
         V newValue = (V) loader.asyncReload(key, oldValue, executor);
         return newValue;
       }
-      @Override public CompletableFuture<V> asyncReload(
+      @Override public CompletableFuture<? extends V> asyncReload(
           K key, V oldValue, Executor executor) throws Exception {
         return loader.asyncReload(key, oldValue, executor);
       }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheWriter.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.util.Map;
 
+import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -35,7 +36,7 @@
  *             eviction.
  */
 @Deprecated
-public interface CacheWriter<K, V> {
+public interface CacheWriter<K extends @NonNull Object, V extends @NonNull Object> {
 
   /***
    * Writes the value corresponding to the {@code key} to the external resource. The cache will

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CaffeineSpec.java
Patch:
@@ -330,7 +330,7 @@ static TimeUnit parseTimeUnit(String key, @Nullable String value) {
   }
 
   @Override
-  public boolean equals(Object o) {
+  public boolean equals(@Nullable Object o) {
     if (this == o) {
       return true;
     } else if (!(o instanceof CaffeineSpec)) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Expiry.java
Patch:
@@ -16,14 +16,15 @@
 package com.github.benmanes.caffeine.cache;
 
 import org.checkerframework.checker.index.qual.NonNegative;
+import org.checkerframework.checker.nullness.qual.NonNull;
 
 /**
  * Calculates when cache entries expire. A single expiration time is retained so that the lifetime
  * of an entry may be extended or reduced by subsequent evaluations.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public interface Expiry<K, V> {
+public interface Expiry<K extends @NonNull Object, V extends @NonNull Object> {
 
   /**
    * Specifies that the entry should be automatically removed from the cache once the duration has

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LoadingCache.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 
+import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -32,7 +33,8 @@
  * @param <K> the type of keys maintained by this cache
  * @param <V> the type of mapped values
  */
-public interface LoadingCache<K, V> extends Cache<K, V> {
+public interface LoadingCache<K extends @NonNull Object, V extends @NonNull Object>
+    extends Cache<K, V> {
 
   /**
    * Returns the value associated with the {@code key} in this cache, obtaining that value from

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalLoadingCache.java
Patch:
@@ -98,7 +98,7 @@ default CompletableFuture<V> refresh(K key) {
     @SuppressWarnings("unchecked")
     V[] oldValue = (V[]) new Object[1];
     @SuppressWarnings({"unchecked", "rawtypes"})
-    CompletableFuture<V>[] reloading = new CompletableFuture[1];
+    CompletableFuture<? extends V>[] reloading = new CompletableFuture[1];
     Object keyReference = cache().referenceKey(key);
 
     var future = cache().refreshes().compute(keyReference, (k, existing) -> {
@@ -109,7 +109,7 @@ default CompletableFuture<V> refresh(K key) {
       try {
         startTime[0] = cache().statsTicker().read();
         oldValue[0] = cache().getIfPresentQuietly(key, writeTime);
-        CompletableFuture<V> refreshFuture = (oldValue[0] == null)
+        CompletableFuture<? extends V> refreshFuture = (oldValue[0] == null)
             ? cacheLoader().asyncLoad(key, cache().executor())
             : cacheLoader().asyncReload(key, oldValue[0], cache().executor());
         reloading[0] = refreshFuture;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalManualCache.java
Patch:
@@ -69,7 +69,7 @@ default Map<K, V> getAllPresent(Iterable<? extends K> keys) {
 
   @Override
   default Map<K, V> getAll(Iterable<? extends K> keys,
-      Function<Set<? extends K>, Map<K, V>> mappingFunction) {
+      Function<? super Set<? extends K>, ? extends Map<? extends K, ? extends V>> mappingFunction) {
     requireNonNull(mappingFunction);
 
     Set<K> keysToLoad = new LinkedHashSet<>();
@@ -95,11 +95,11 @@ default Map<K, V> getAll(Iterable<? extends K> keys,
    * during the load are replaced when the loaded entries are inserted into the cache.
    */
   default void bulkLoad(Set<K> keysToLoad, Map<K, V> result,
-      Function<Set<? extends K>, Map<K, V>> mappingFunction) {
+      Function<? super Set<? extends K>, ? extends Map<? extends K, ? extends V>> mappingFunction) {
     boolean success = false;
     long startTime = cache().statsTicker().read();
     try {
-      Map<K, V> loaded = mappingFunction.apply(keysToLoad);
+      var loaded = mappingFunction.apply(keysToLoad);
       loaded.forEach((key, value) ->
           cache().put(key, value, /* notifyWriter */ false));
       for (K key : keysToLoad) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Policy.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.concurrent.TimeUnit;
 
 import org.checkerframework.checker.index.qual.NonNegative;
+import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -32,7 +33,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public interface Policy<K, V> {
+public interface Policy<K extends @NonNull Object, V extends @NonNull Object> {
 
   /**
    * Returns whether the cache statistics are being accumulated.

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Weigher.java
Patch:
@@ -20,6 +20,7 @@
 import java.io.Serializable;
 
 import org.checkerframework.checker.index.qual.NonNegative;
+import org.checkerframework.checker.nullness.qual.NonNull;
 
 /**
  * Calculates the weights of cache entries. The total weight threshold is used to determine when an
@@ -30,7 +31,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @FunctionalInterface
-public interface Weigher<K, V> {
+public interface Weigher<K extends @NonNull Object, V extends @NonNull Object> {
 
   /**
    * Returns the weight of a cache entry. There is no unit for entry weights; rather they are simply

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CaffeineSpec.java
Patch:
@@ -24,7 +24,6 @@
 import java.util.Objects;
 import java.util.concurrent.TimeUnit;
 
-import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.cache.Caffeine.Strength;
@@ -142,7 +141,7 @@ Caffeine<Object, Object> toBuilder() {
    * @return the parsed specification
    */
   @SuppressWarnings("StringSplitter")
-  public static @NonNull CaffeineSpec parse(@NonNull String specification) {
+  public static CaffeineSpec parse(String specification) {
     CaffeineSpec spec = new CaffeineSpec(specification);
     for (String option : specification.split(SPLIT_OPTIONS)) {
       spec.parseOption(option.trim());

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/FrequencySketch.java
Patch:
@@ -18,7 +18,6 @@
 import static com.github.benmanes.caffeine.cache.Caffeine.requireArgument;
 
 import org.checkerframework.checker.index.qual.NonNegative;
-import org.checkerframework.checker.nullness.qual.NonNull;
 
 /**
  * A probabilistic multiset for estimating the popularity of an element within a time window. The
@@ -107,7 +106,7 @@ public boolean isNotInitialized() {
    * @return the estimated number of occurrences of the element; possibly zero but never negative
    */
   @NonNegative
-  public int frequency(@NonNull E e) {
+  public int frequency(E e) {
     if (isNotInitialized()) {
       return 0;
     }
@@ -130,7 +129,7 @@ public int frequency(@NonNull E e) {
    *
    * @param e the element to add
    */
-  public void increment(@NonNull E e) {
+  public void increment(E e) {
     if (isNotInitialized()) {
       return;
     }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalManualCache.java
Patch:
@@ -26,7 +26,6 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.function.Function;
 
-import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.cache.stats.CacheStats;
@@ -58,6 +57,7 @@ default void cleanUp() {
   }
 
   @Override
+  @SuppressWarnings("NullAway")
   default @Nullable V get(K key, Function<? super K, ? extends V> mappingFunction) {
     return cache().computeIfAbsent(key, mappingFunction);
   }
@@ -95,7 +95,7 @@ default Map<K, V> getAll(Iterable<? extends K> keys,
    * during the load are replaced when the loaded entries are inserted into the cache.
    */
   default void bulkLoad(Set<K> keysToLoad, Map<K, V> result,
-      Function<Set<? extends @NonNull K>, @NonNull Map<K, V>> mappingFunction) {
+      Function<Set<? extends K>, Map<K, V>> mappingFunction) {
     boolean success = false;
     long startTime = cache().statsTicker().read();
     try {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/RemovalListener.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache;
 
-import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
@@ -46,5 +45,5 @@ public interface RemovalListener<K, V> {
    * @param value the value represented by this entry, or {@code null} if collected
    * @param cause the reason for which the entry was removed
    */
-  void onRemoval(@Nullable K key, @Nullable V value, @NonNull RemovalCause cause);
+  void onRemoval(@Nullable K key, @Nullable V value, RemovalCause cause);
 }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/ConcurrentStatsCounter.java
Patch:
@@ -17,8 +17,6 @@
 
 import java.util.concurrent.atomic.LongAdder;
 
-import org.checkerframework.checker.nullness.qual.NonNull;
-
 import com.github.benmanes.caffeine.cache.Cache;
 import com.github.benmanes.caffeine.cache.RemovalCause;
 
@@ -99,7 +97,7 @@ private static long negativeToMaxValue(long value) {
    *
    * @param other the counter to increment from
    */
-  public void incrementBy(@NonNull StatsCounter other) {
+  public void incrementBy(StatsCounter other) {
     CacheStats otherStats = other.snapshot();
     hitCount.add(otherStats.hitCount());
     missCount.add(otherStats.missCount());

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java
Patch:
@@ -35,8 +35,6 @@
 import java.util.function.BiFunction;
 import java.util.function.Function;
 
-import org.checkerframework.checker.nullness.qual.NonNull;
-
 import com.github.benmanes.caffeine.cache.Cache;
 import com.github.benmanes.caffeine.cache.LoadingCache;
 import com.github.benmanes.caffeine.cache.Policy;
@@ -435,7 +433,7 @@ public Policy<K, V> policy() {
         @Override public boolean isRecordingStats() {
           return isRecordingStats;
         }
-        @Override public V getIfPresentQuietly(@NonNull Object key) {
+        @Override public V getIfPresentQuietly(K key) {
           return cache.asMap().get(key);
         }
         @Override public Optional<Eviction<K, V>> eviction() {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/RemovalNotification.java
Patch:
@@ -19,7 +19,6 @@
 
 import java.util.AbstractMap.SimpleImmutableEntry;
 
-import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.cache.RemovalCause;
@@ -45,15 +44,14 @@ public final class RemovalNotification<K, V> extends SimpleImmutableEntry<K, V>
    * @param value the value represented by this entry
    * @param cause the reason for which the entry was removed
    */
-  public RemovalNotification(@Nullable K key, @Nullable V value, @NonNull RemovalCause cause) {
+  public RemovalNotification(@Nullable K key, @Nullable V value, RemovalCause cause) {
     super(key, value);
     this.cause = requireNonNull(cause);
   }
 
   /**
    * @return the cause for which the entry was removed
    */
-  @NonNull
   public RemovalCause getCause() {
     return cause;
   }

File: examples/coalescing-bulkloader/src/main/java/com/github/benmanes/caffeine/examples/coalescing/bulkloader/CoalescingBulkloader.java
Patch:
@@ -36,7 +36,6 @@
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.stream.Stream;
-import org.checkerframework.checker.nullness.qual.NonNull;
 
 /**
  * An implementation of {@link AsyncCacheLoader} that delays fetching a bit until "enough" keys are collected
@@ -141,7 +140,7 @@ private CoalescingBulkloader(int maxLoadSize, long maxDelay, Consumer<Collection
         this.maxDelay = maxDelay;
     }
 
-    @Override public @NonNull CompletableFuture<Value> asyncLoad(@NonNull Key key, @NonNull Executor executor) {
+    @Override public CompletableFuture<Value> asyncLoad(Key key, Executor executor) {
         final WaitingKey waitingKey = new WaitingKey();
         waitingKey.key = key;
         waitingKey.future = new CompletableFuture<>();

File: examples/coalescing-bulkloader/src/test/java/com/github/benmanes/caffeine/examples/coalescing/bulkloader/CoalescingBulkloaderTest.java
Patch:
@@ -35,7 +35,6 @@
 import java.util.function.Function;
 import java.util.stream.Stream;
 import org.awaitility.Awaitility;
-import org.checkerframework.checker.nullness.qual.NonNull;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
@@ -71,7 +70,7 @@ public static List<Function<Function<Stream<Integer>, Stream<Integer>>, Coalesci
         );
     }
 
-    @NonNull private AsyncLoadingCache<Integer, Integer> createCache(AtomicInteger loaderCalled) {
+    private AsyncLoadingCache<Integer, Integer> createCache(AtomicInteger loaderCalled) {
         return Caffeine.newBuilder().buildAsync(cbl.apply(ints -> {
             loaderCalled.incrementAndGet();
             try {

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaLoadingCache.java
Patch:
@@ -23,8 +23,6 @@
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
 
-import org.checkerframework.checker.nullness.qual.NonNull;
-
 import com.github.benmanes.caffeine.cache.CacheLoader;
 import com.google.common.base.Throwables;
 import com.google.common.cache.CacheLoader.InvalidCacheLoadException;
@@ -113,7 +111,7 @@ public ImmutableMap<K, V> getAll(Iterable<? extends K> keys) throws ExecutionExc
 
   @Override
   @SuppressWarnings("NullAway")
-  public V apply(@NonNull K key) {
+  public V apply(K key) {
     return cache.get(key);
   }
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/FactoryCreator.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.github.benmanes.caffeine.jcache.configuration;
 
-import org.checkerframework.checker.nullness.qual.NonNull;
 import javax.cache.configuration.Factory;
 
 /**
@@ -33,6 +32,5 @@ public interface FactoryCreator {
    * @param <T> the type of the instances being produced
    * @return a {@link Factory} for the specified class
    */
-  @NonNull
   <T> Factory<T> factoryOf(String className);
 }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/EventTypeAwareListener.java
Patch:
@@ -22,7 +22,6 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import org.checkerframework.checker.nullness.qual.NonNull;
 import javax.cache.event.CacheEntryCreatedListener;
 import javax.cache.event.CacheEntryEvent;
 import javax.cache.event.CacheEntryExpiredListener;
@@ -49,7 +48,7 @@ public EventTypeAwareListener(CacheEntryListener<? super K, ? super V> listener)
 
   /** Returns if the backing listener consumes this type of event. */
   @SuppressWarnings("PMD.SwitchStmtsShouldHaveDefault")
-  public boolean isCompatible(@NonNull EventType eventType) {
+  public boolean isCompatible(EventType eventType) {
     switch (eventType) {
       case CREATED:
         return (listener instanceof CacheEntryCreatedListener<?, ?>);
@@ -65,7 +64,7 @@ public boolean isCompatible(@NonNull EventType eventType) {
 
   /** Processes the event and logs if an exception is thrown. */
   @SuppressWarnings("PMD.SwitchStmtsShouldHaveDefault")
-  public void dispatch(@NonNull JCacheEntryEvent<K, V> event) {
+  public void dispatch(JCacheEntryEvent<K, V> event) {
     try {
       if (event.getSource().isClosed()) {
         return;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/expiry/JCacheExpiryPolicy.java
Patch:
@@ -20,11 +20,11 @@
 import java.io.Serializable;
 import java.util.Objects;
 
-import org.checkerframework.checker.nullness.qual.NonNull;
-import org.checkerframework.checker.nullness.qual.Nullable;
 import javax.cache.expiry.Duration;
 import javax.cache.expiry.ExpiryPolicy;
 
+import org.checkerframework.checker.nullness.qual.Nullable;
+
 /**
  * A customized expiration policy.
  *
@@ -37,7 +37,7 @@ public final class JCacheExpiryPolicy implements ExpiryPolicy, Serializable {
   private final @Nullable Duration update;
   private final @Nullable Duration access;
 
-  public JCacheExpiryPolicy(@NonNull Duration creation,
+  public JCacheExpiryPolicy(Duration creation,
       @Nullable Duration update, @Nullable Duration access) {
     this.creation = requireNonNull(creation);
     this.update = update;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncCache.java
Patch:
@@ -26,8 +26,6 @@
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import com.google.errorprone.annotations.CompatibleWith;
-
 /**
  * A semi-persistent mapping from keys to values. Cache entries are manually added using
  * {@link #get(Object, Function)} or {@link #put(Object, CompletableFuture)}, and are stored in the
@@ -52,7 +50,7 @@ public interface AsyncCache<K, V> {
    * @throws NullPointerException if the specified key is null
    */
   @Nullable
-  CompletableFuture<V> getIfPresent(@NonNull @CompatibleWith("K") Object key);
+  CompletableFuture<V> getIfPresent(@NonNull K key);
 
   /**
    * Returns the future associated with {@code key} in this cache, obtaining that value from

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1983,7 +1983,7 @@ public boolean containsValue(Object value) {
   }
 
   @Override
-  public @Nullable V getIfPresentQuietly(Object key, long[/* 1 */] writeTime) {
+  public @Nullable V getIfPresentQuietly(K key, long[/* 1 */] writeTime) {
     V value;
     Node<K, V> node = data.get(nodeFactory.newLookupKey(key));
     if ((node == null) || ((value = node.getValue()) == null)
@@ -1995,7 +1995,7 @@ public boolean containsValue(Object value) {
   }
 
   @Override
-  public Map<K, V> getAllPresent(Iterable<?> keys) {
+  public Map<K, V> getAllPresent(Iterable<? extends K> keys) {
     Map<Object, Object> result = new LinkedHashMap<>();
     for (Object key : keys) {
       result.put(key, null);
@@ -3493,7 +3493,7 @@ static final class BoundedPolicy<K, V> implements Policy<K, V> {
     @Override public boolean isRecordingStats() {
       return cache.isRecordingStats();
     }
-    @Override public @Nullable V getIfPresentQuietly(Object key) {
+    @Override public @Nullable V getIfPresentQuietly(K key) {
       Node<K, V> node = cache.data.get(cache.nodeFactory.newLookupKey(key));
       if ((node == null) || cache.hasExpired(node, cache.expirationTicker().read())) {
         return null;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Cache.java
Patch:
@@ -51,7 +51,7 @@ public interface Cache<K, V> {
    * @throws NullPointerException if the specified key is null
    */
   @Nullable
-  V getIfPresent(@NonNull @CompatibleWith("K") Object key);
+  V getIfPresent(@NonNull K key);
 
   /**
    * Returns the value associated with the {@code key} in this cache, obtaining that value from the
@@ -93,7 +93,7 @@ public interface Cache<K, V> {
    * @throws NullPointerException if the specified collection is null or contains a null element
    */
   @NonNull
-  Map<@NonNull K, @NonNull V> getAllPresent(@NonNull Iterable<@NonNull ?> keys);
+  Map<@NonNull K, @NonNull V> getAllPresent(@NonNull Iterable<? extends K> keys);
 
   /**
    * Returns a map of the values associated with the {@code keys}, creating or retrieving those

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncCache.java
Patch:
@@ -63,7 +63,7 @@ interface LocalAsyncCache<K, V> extends AsyncCache<K, V> {
   Policy<K, V> policy();
 
   @Override
-  default @Nullable CompletableFuture<V> getIfPresent(@NonNull Object key) {
+  default @Nullable CompletableFuture<V> getIfPresent(@NonNull K key) {
     return cache().getIfPresent(key, /* recordStats */ true);
   }
 
@@ -466,13 +466,13 @@ abstract class AbstractCacheView<K, V> implements Cache<K, V>, Serializable {
     abstract LocalAsyncCache<K, V> asyncCache();
 
     @Override
-    public @Nullable V getIfPresent(Object key) {
+    public @Nullable V getIfPresent(K key) {
       CompletableFuture<V> future = asyncCache().cache().getIfPresent(key, /* recordStats */ true);
       return Async.getIfReady(future);
     }
 
     @Override
-    public Map<K, V> getAllPresent(Iterable<?> keys) {
+    public Map<K, V> getAllPresent(Iterable<? extends K> keys) {
       Map<Object, Object> result = new LinkedHashMap<>();
       for (Object key : keys) {
         result.put(key, null);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalManualCache.java
Patch:
@@ -53,7 +53,7 @@ default void cleanUp() {
   }
 
   @Override
-  default @Nullable V getIfPresent(Object key) {
+  default @Nullable V getIfPresent(K key) {
     return cache().getIfPresent(key, /* recordStats */ true);
   }
 
@@ -63,7 +63,7 @@ default void cleanUp() {
   }
 
   @Override
-  default Map<K, V> getAllPresent(Iterable<?> keys) {
+  default Map<K, V> getAllPresent(Iterable<? extends K> keys) {
     return cache().getAllPresent(keys);
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Policy.java
Patch:
@@ -26,8 +26,6 @@
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
-import com.google.errorprone.annotations.CompatibleWith;
-
 /**
  * An access point for inspecting and performing low-level operations based on the cache's runtime
  * characteristics. These operations are optional and dependent on how the cache was constructed
@@ -56,7 +54,7 @@ public interface Policy<K, V> {
    * @throws NullPointerException if the specified key is null
    */
   @Nullable
-  V getIfPresentQuietly(@NonNull @CompatibleWith("K") Object key);
+  V getIfPresentQuietly(@NonNull K key);
 
   /**
    * Returns access to perform operations based on the maximum size or maximum weight eviction

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/UnboundedLocalCache.java
Patch:
@@ -120,7 +120,7 @@ public Object referenceKey(K key) {
   }
 
   @Override
-  public @Nullable V getIfPresentQuietly(Object key, long[/* 1 */] writeTime) {
+  public @Nullable V getIfPresentQuietly(K key, long[/* 1 */] writeTime) {
     return data.get(key);
   }
 
@@ -130,7 +130,7 @@ public long estimatedSize() {
   }
 
   @Override
-  public Map<K, V> getAllPresent(Iterable<?> keys) {
+  public Map<K, V> getAllPresent(Iterable<? extends K> keys) {
     Map<Object, Object> result = new LinkedHashMap<>();
     for (Object key : keys) {
       result.put(key, null);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncCache.java
Patch:
@@ -16,6 +16,7 @@
 package com.github.benmanes.caffeine.cache;
 
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.Executor;
@@ -125,7 +126,7 @@ CompletableFuture<V> get(@NonNull K key,
    */
   @NonNull
   CompletableFuture<Map<K, V>> getAll(@NonNull Iterable<? extends @NonNull K> keys,
-      @NonNull Function<Iterable<? extends @NonNull K>, @NonNull Map<K, V>> mappingFunction);
+      @NonNull Function<Set<? extends @NonNull K>, @NonNull Map<K, V>> mappingFunction);
 
   /**
    * Returns the future of a map of the values associated with {@code keys}, creating or retrieving
@@ -152,7 +153,7 @@ CompletableFuture<Map<K, V>> getAll(@NonNull Iterable<? extends @NonNull K> keys
    */
   @NonNull
   CompletableFuture<Map<K, V>> getAll(@NonNull Iterable<? extends @NonNull K> keys,
-      @NonNull BiFunction<Iterable<? extends @NonNull K>, Executor, CompletableFuture<Map<K, V>>> mappingFunction);
+      @NonNull BiFunction<Set<? extends @NonNull K>, Executor, CompletableFuture<Map<K, V>>> mappingFunction);
 
   /**
    * Associates {@code value} with {@code key} in this cache. If the cache previously contained a

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncCacheLoader.java
Patch:
@@ -16,6 +16,7 @@
 package com.github.benmanes.caffeine.cache;
 
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 
@@ -70,7 +71,7 @@ public interface AsyncCacheLoader<K, V> {
    */
   @NonNull
   default CompletableFuture<Map<@NonNull K, @NonNull V>> asyncLoadAll(
-      @NonNull Iterable<? extends @NonNull K> keys, @NonNull Executor executor) {
+      @NonNull Set<? extends @NonNull K> keys, @NonNull Executor executor) {
     throw new UnsupportedOperationException();
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -3761,7 +3761,7 @@ static final class BoundedLocalLoadingCache<K, V>
     private static final long serialVersionUID = 1;
 
     final Function<K, V> mappingFunction;
-    @Nullable final Function<Iterable<? extends K>, Map<K, V>> bulkMappingFunction;
+    @Nullable final Function<Set<? extends K>, Map<K, V>> bulkMappingFunction;
 
     BoundedLocalLoadingCache(Caffeine<K, V> builder, CacheLoader<? super K, V> loader) {
       super(builder, loader);
@@ -3782,7 +3782,7 @@ public Function<K, V> mappingFunction() {
     }
 
     @Override
-    public @Nullable Function<Iterable<? extends K>, Map<K, V>> bulkMappingFunction() {
+    public @Nullable Function<Set<? extends K>, Map<K, V>> bulkMappingFunction() {
       return bulkMappingFunction;
     }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Cache.java
Patch:
@@ -16,6 +16,7 @@
 package com.github.benmanes.caffeine.cache;
 
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ConcurrentMap;
 import java.util.function.Function;
 
@@ -120,7 +121,7 @@ public interface Cache<K, V> {
    */
   @NonNull
   Map<K, V> getAll(@NonNull Iterable<? extends @NonNull K> keys,
-      @NonNull Function<Iterable<? extends @NonNull K>, @NonNull Map<K, V>> mappingFunction);
+      @NonNull Function<Set<? extends @NonNull K>, @NonNull Map<K, V>> mappingFunction);
 
   /**
    * Associates the {@code value} with the {@code key} in this cache. If the cache previously

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheLoader.java
Patch:
@@ -18,6 +18,7 @@
 import static java.util.Objects.requireNonNull;
 
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.Executor;
@@ -84,7 +85,7 @@ public interface CacheLoader<K, V> extends AsyncCacheLoader<K, V> {
    */
   @NonNull
   default Map<@NonNull K, @NonNull V> loadAll(
-      @NonNull Iterable<? extends @NonNull K> keys) throws Exception {
+      @NonNull Set<? extends @NonNull K> keys) throws Exception {
     throw new UnsupportedOperationException();
   }
 
@@ -130,7 +131,7 @@ default CompletableFuture<V> asyncLoad(@NonNull K key, @NonNull Executor executo
    */
   @Override @NonNull
   default CompletableFuture<Map<@NonNull K, @NonNull V>> asyncLoadAll(
-      @NonNull Iterable<? extends K> keys, @NonNull Executor executor) {
+      @NonNull Set<? extends K> keys, @NonNull Executor executor) {
     requireNonNull(keys);
     requireNonNull(executor);
     return CompletableFuture.supplyAsync(() -> {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncCache.java
Patch:
@@ -99,7 +99,7 @@ default CompletableFuture<V> get(K key,
 
   @Override
   default CompletableFuture<Map<K, V>> getAll(Iterable<? extends @NonNull K> keys,
-      Function<Iterable<? extends K>, Map<K, V>> mappingFunction) {
+      Function<Set<? extends K>, Map<K, V>> mappingFunction) {
     requireNonNull(mappingFunction);
     return getAll(keys, (keysToLoad, executor) ->
         CompletableFuture.supplyAsync(() -> mappingFunction.apply(keysToLoad), executor));
@@ -108,7 +108,7 @@ default CompletableFuture<Map<K, V>> getAll(Iterable<? extends @NonNull K> keys,
   @Override
   @SuppressWarnings("FutureReturnValueIgnored")
   default CompletableFuture<Map<K, V>> getAll(Iterable<? extends @NonNull K> keys,
-      BiFunction<Iterable<? extends K>, Executor, CompletableFuture<Map<K, V>>> mappingFunction) {
+      BiFunction<Set<? extends K>, Executor, CompletableFuture<Map<K, V>>> mappingFunction) {
     requireNonNull(mappingFunction);
     requireNonNull(keys);
 
@@ -505,7 +505,7 @@ public V get(K key, Function<? super K, ? extends V> mappingFunction) {
 
     @Override
     public Map<K, V> getAll(Iterable<? extends K> keys,
-        Function<Iterable<? extends K>, Map<K, V>> mappingFunction) {
+        Function<Set<? extends K>, Map<K, V>> mappingFunction) {
       return resolve(asyncCache().getAll(keys, mappingFunction));
     }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalManualCache.java
Patch:
@@ -69,7 +69,7 @@ default Map<K, V> getAllPresent(Iterable<?> keys) {
 
   @Override
   default Map<K, V> getAll(Iterable<? extends K> keys,
-      Function<Iterable<? extends K>, Map<K, V>> mappingFunction) {
+      Function<Set<? extends K>, Map<K, V>> mappingFunction) {
     requireNonNull(mappingFunction);
 
     Set<K> keysToLoad = new LinkedHashSet<>();
@@ -95,7 +95,7 @@ default Map<K, V> getAll(Iterable<? extends K> keys,
    * during the load are replaced when the loaded entries are inserted into the cache.
    */
   default void bulkLoad(Set<K> keysToLoad, Map<K, V> result,
-      Function<Iterable<? extends @NonNull K>, @NonNull Map<K, V>> mappingFunction) {
+      Function<Set<? extends @NonNull K>, @NonNull Map<K, V>> mappingFunction) {
     boolean success = false;
     long startTime = cache().statsTicker().read();
     try {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/UnboundedLocalCache.java
Patch:
@@ -993,7 +993,7 @@ static final class UnboundedLocalLoadingCache<K, V> extends UnboundedLocalManual
 
     final Function<K, V> mappingFunction;
     final CacheLoader<? super K, V> loader;
-    @Nullable final Function<Iterable<? extends K>, Map<K, V>> bulkMappingFunction;
+    @Nullable final Function<Set<? extends K>, Map<K, V>> bulkMappingFunction;
 
     UnboundedLocalLoadingCache(Caffeine<K, V> builder, CacheLoader<? super K, V> loader) {
       super(builder);
@@ -1013,7 +1013,7 @@ public Function<K, V> mappingFunction() {
     }
 
     @Override
-    public @Nullable Function<Iterable<? extends K>, Map<K, V>>  bulkMappingFunction() {
+    public @Nullable Function<Set<? extends K>, Map<K, V>>  bulkMappingFunction() {
       return bulkMappingFunction;
     }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsyncLoadingCacheTest.java
Patch:
@@ -322,7 +322,7 @@ public void getAll_badLoader(CacheContext context) {
         throw new IllegalStateException();
       }
       @Override public CompletableFuture<Map<Integer, Integer>> asyncLoadAll(
-          Iterable<? extends Integer> keys, Executor executor) {
+          Set<? extends Integer> keys, Executor executor) {
         throw new LoadAllException();
       }
     };
@@ -401,7 +401,7 @@ public void refresh_deadlock(CacheContext context) {
   public void asyncLoadAll() {
     AsyncCacheLoader<Integer, Integer> loader =
         (key, executor) -> CompletableFuture.completedFuture(-key);
-    loader.asyncLoadAll(Collections.emptyList(), Runnable::run).join();
+    loader.asyncLoadAll(Set.of(), Runnable::run).join();
   }
 
   @Test

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaLoadingCache.java
Patch:
@@ -20,6 +20,7 @@
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ExecutionException;
 
 import org.checkerframework.checker.nullness.qual.NonNull;
@@ -175,7 +176,7 @@ static final class BulkLoader<K, V> extends SingleLoader<K, V> {
     }
 
     @Override
-    public Map<K, V> loadAll(Iterable<? extends K> keys) {
+    public Map<K, V> loadAll(Set<? extends K> keys) {
       try {
         Map<K, V> loaded = cacheLoader.loadAll(keys);
         if (loaded == null) {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/integration/JCacheLoaderAdapter.java
Patch:
@@ -18,6 +18,7 @@
 import static java.util.Objects.requireNonNull;
 
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import java.util.stream.Collectors;
 
@@ -94,7 +95,7 @@ public void setCache(CacheProxy<K, V> cache) {
   }
 
   @Override
-  public Map<K, Expirable<V>> loadAll(Iterable<? extends K> keys) {
+  public Map<K, Expirable<V>> loadAll(Set<? extends K> keys) {
     try {
       boolean statsEnabled = statistics.isEnabled();
       long start = statsEnabled ? ticker.read() : 0L;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/UnboundedLocalCache.java
Patch:
@@ -965,6 +965,9 @@ static final class UnboundedPolicy<K, V> implements Policy<K, V> {
     @Override public Optional<FixedExpiration<K, V>> expireAfterWrite() {
       return Optional.empty();
     }
+    @Override public Optional<VarExpiration<K, V>> expireVariably() {
+      return Optional.empty();
+    }
     @Override public Optional<FixedRefresh<K, V>> refreshAfterWrite() {
       return Optional.empty();
     }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpirationTest.java
Patch:
@@ -604,9 +604,9 @@ public void getAll_writerFails(LoadingCache<Integer, Integer> cache, CacheContex
   public void refresh(LoadingCache<Integer, Integer> cache, CacheContext context) {
     context.ticker().advance(1, TimeUnit.MINUTES);
     Integer key = context.firstKey();
-    cache.refresh(key);
+    cache.refresh(key).join();
 
-    long count = (cache.estimatedSize() == 1) ? context.initialSize() : 1;
+    long count = context.initialSize();
     verifyListeners(context, verifier -> verifier.hasOnly(count, RemovalCause.EXPIRED));
     verifyWriter(context, verifier -> {
       verifier.deleted(key, context.original().get(key), RemovalCause.EXPIRED);
@@ -623,7 +623,7 @@ public void refresh(LoadingCache<Integer, Integer> cache, CacheContext context)
       compute = Compute.SYNC, writer = Writer.EXCEPTIONAL, removalListener = Listener.REJECTING)
   public void refresh_writerFails(LoadingCache<Integer, Integer> cache, CacheContext context) {
     context.ticker().advance(1, TimeUnit.HOURS);
-    cache.refresh(context.firstKey());
+    cache.refresh(context.firstKey()).join();
     context.disableRejectingCacheWriter();
     context.ticker().advance(-1, TimeUnit.HOURS);
     assertThat(cache.asMap(), equalTo(context.original()));

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/MultiThreadedTest.java
Patch:
@@ -98,8 +98,8 @@ public void async_concurrent_bounded(
     Threads.runTest(cache, asyncOperations);
   }
 
-  @SuppressWarnings(
-      {"unchecked", "rawtypes", "ReturnValueIgnored", "SizeGreaterThanOrEqualsZero", "SelfEquals"})
+  @SuppressWarnings({"unchecked", "rawtypes", "ReturnValueIgnored",
+    "FutureReturnValueIgnored", "SizeGreaterThanOrEqualsZero", "SelfEquals"})
   List<BiConsumer<LoadingCache<Integer, Integer>, Integer>> operations = ImmutableList.of(
       // LoadingCache
       (cache, key) -> { cache.get(key); },

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ReferenceTest.java
Patch:
@@ -467,7 +467,7 @@ public void refresh(LoadingCache<Integer, Integer> cache, CacheContext context)
 
     GcFinalization.awaitFullGc();
     awaitFullCleanup(cache);
-    cache.refresh(key);
+    cache.refresh(key).join();
     assertThat(cache.estimatedSize(), is(1L));
     assertThat(cache.getIfPresent(key), is(not(value)));
 
@@ -489,7 +489,7 @@ public void refresh_writerFails(LoadingCache<Integer, Integer> cache, CacheConte
     Integer key = context.firstKey();
     context.clear();
     GcFinalization.awaitFullGc();
-    cache.refresh(key);
+    cache.refresh(key).join();
     context.disableRejectingCacheWriter();
     assertThat(cache.asMap().isEmpty(), is(false));
   }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/Stresser.java
Patch:
@@ -90,6 +90,7 @@ public Stresser() {
     status();
   }
 
+  @SuppressWarnings("FutureReturnValueIgnored")
   public void run() throws InterruptedException {
     ConcurrentTestHarness.timeTasks(operation.maxThreads, () -> {
       int index = ThreadLocalRandom.current().nextInt();

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaLoadingCache.java
Patch:
@@ -117,6 +117,7 @@ public V apply(@NonNull K key) {
   }
 
   @Override
+  @SuppressWarnings("FutureReturnValueIgnored")
   public void refresh(K key) {
     cache.refresh(key);
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/UnboundedLocalCache.java
Patch:
@@ -906,13 +906,13 @@ static final class UnboundedPolicy<K, V> implements Policy<K, V> {
     @Override public Optional<Eviction<K, V>> eviction() {
       return Optional.empty();
     }
-    @Override public Optional<Expiration<K, V>> expireAfterAccess() {
+    @Override public Optional<FixedExpiration<K, V>> expireAfterAccess() {
       return Optional.empty();
     }
-    @Override public Optional<Expiration<K, V>> expireAfterWrite() {
+    @Override public Optional<FixedExpiration<K, V>> expireAfterWrite() {
       return Optional.empty();
     }
-    @Override public Optional<Expiration<K, V>> refreshAfterWrite() {
+    @Override public Optional<FixedRefresh<K, V>> refreshAfterWrite() {
       return Optional.empty();
     }
   }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheValidationListener.java
Patch:
@@ -56,7 +56,7 @@
 import com.github.benmanes.caffeine.cache.Cache;
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.cache.Policy.Eviction;
-import com.github.benmanes.caffeine.cache.Policy.Expiration;
+import com.github.benmanes.caffeine.cache.Policy.FixedExpiration;
 import com.github.benmanes.caffeine.cache.Policy.VarExpiration;
 import com.github.benmanes.caffeine.cache.Reset;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.CacheExecutor;
@@ -302,7 +302,7 @@ private void stringifyParams(ITestResult testResult, boolean briefParams) {
       Object param = params[i];
       if ((param instanceof AsyncCache<?, ?>) || (param instanceof Cache<?, ?>)
           || (param instanceof Map<?, ?>) || (param instanceof Eviction<?, ?>)
-          || (param instanceof Expiration<?, ?>) || (param instanceof VarExpiration<?, ?>)
+          || (param instanceof FixedExpiration<?, ?>) || (param instanceof VarExpiration<?, ?>)
           || ((param instanceof CacheContext) && briefParams)) {
         params[i] = simpleNames.get(param.getClass(), key -> ((Class<?>) key).getSimpleName());
       } else if (param instanceof CacheContext) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/ExpireAfterAccess.java
Patch:
@@ -21,10 +21,10 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import com.github.benmanes.caffeine.cache.Policy.Expiration;
+import com.github.benmanes.caffeine.cache.Policy.FixedExpiration;
 
 /**
- * An annotation to qualify the parameterized {@link Expiration}.
+ * An annotation to qualify the parameterized {@link FixedExpiration}.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/ExpireAfterWrite.java
Patch:
@@ -21,10 +21,10 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import com.github.benmanes.caffeine.cache.Policy.Expiration;
+import com.github.benmanes.caffeine.cache.Policy.FixedExpiration;
 
 /**
- * An annotation to qualify the parameterized {@link Expiration}.
+ * An annotation to qualify the parameterized {@link FixedExpiration}.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java
Patch:
@@ -431,13 +431,13 @@ public Policy<K, V> policy() {
         @Override public Optional<Eviction<K, V>> eviction() {
           return Optional.empty();
         }
-        @Override public Optional<Expiration<K, V>> expireAfterAccess() {
+        @Override public Optional<FixedExpiration<K, V>> expireAfterAccess() {
           return Optional.empty();
         }
-        @Override public Optional<Expiration<K, V>> expireAfterWrite() {
+        @Override public Optional<FixedExpiration<K, V>> expireAfterWrite() {
           return Optional.empty();
         }
-        @Override public Optional<Expiration<K, V>> refreshAfterWrite() {
+        @Override public Optional<FixedRefresh<K, V>> refreshAfterWrite() {
           return Optional.empty();
         }
       };

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/RefreshAfterWrite.java
Patch:
@@ -21,10 +21,10 @@
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import com.github.benmanes.caffeine.cache.Policy.Expiration;
+import com.github.benmanes.caffeine.cache.Policy.FixedRefresh;
 
 /**
- * An annotation to qualify the parameterized {@link Expiration}.
+ * An annotation to qualify the parameterized {@link FixedRefresh}.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -19,6 +19,8 @@
 import static java.util.Objects.requireNonNull;
 
 import java.io.Serializable;
+import java.lang.System.Logger;
+import java.lang.System.Logger.Level;
 import java.lang.ref.SoftReference;
 import java.lang.ref.WeakReference;
 import java.time.Duration;
@@ -33,8 +35,6 @@
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.function.Supplier;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 import org.checkerframework.checker.index.qual.NonNegative;
 import org.checkerframework.checker.nullness.qual.NonNull;
@@ -137,7 +137,7 @@
  *     #removalListener}
  */
 public final class Caffeine<K, V> {
-  static final Logger logger = Logger.getLogger(Caffeine.class.getName());
+  static final Logger logger = System.getLogger(Caffeine.class.getName());
   static final Supplier<StatsCounter> ENABLED_STATS_COUNTER_SUPPLIER = ConcurrentStatsCounter::new;
 
   enum Strength { WEAK, SOFT }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LoadingCache.java
Patch:
@@ -96,7 +96,7 @@ public interface LoadingCache<K, V> extends Cache<K, V> {
    * previous value (if any) will continue to be returned by {@code get(key)} unless it is evicted.
    * If the new value is loaded successfully it will replace the previous value in the cache; if an
    * exception is thrown while refreshing the previous value will remain, <i>and the exception will
-   * be logged (using {@link java.util.logging.Logger}) and swallowed</i>.
+   * be logged (using {@link System.Logger}) and swallowed</i>.
    * <p>
    * Caches loaded by a {@link CacheLoader} will call {@link CacheLoader#reload} if the cache
    * currently contains a value for the {@code key}, and {@link CacheLoader#load} otherwise. Loading

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncCache.java
Patch:
@@ -18,6 +18,8 @@
 import static java.util.Objects.requireNonNull;
 
 import java.io.Serializable;
+import java.lang.System.Logger;
+import java.lang.System.Logger.Level;
 import java.util.AbstractCollection;
 import java.util.AbstractMap;
 import java.util.AbstractSet;
@@ -39,8 +41,6 @@
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.function.Function;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
@@ -55,7 +55,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 interface LocalAsyncCache<K, V> extends AsyncCache<K, V> {
-  Logger logger = Logger.getLogger(LocalAsyncCache.class.getName());
+  Logger logger = System.getLogger(LocalAsyncCache.class.getName());
 
   /** Returns the backing {@link LocalCache} data store. */
   LocalCache<K, CompletableFuture<V>> cache();

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncLoadingCache.java
Patch:
@@ -17,14 +17,14 @@
 
 import static java.util.Objects.requireNonNull;
 
+import java.lang.System.Logger;
+import java.lang.System.Logger.Level;
 import java.lang.reflect.Method;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.function.Function;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -36,7 +36,7 @@
  */
 abstract class LocalAsyncLoadingCache<K, V>
     implements LocalAsyncCache<K, V>, AsyncLoadingCache<K, V> {
-  static final Logger logger = Logger.getLogger(LocalAsyncLoadingCache.class.getName());
+  static final Logger logger = System.getLogger(LocalAsyncLoadingCache.class.getName());
 
   final boolean canBulkLoad;
   final AsyncCacheLoader<K, V> loader;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalLoadingCache.java
Patch:
@@ -17,6 +17,8 @@
 
 import static java.util.Objects.requireNonNull;
 
+import java.lang.System.Logger;
+import java.lang.System.Logger.Level;
 import java.lang.reflect.Method;
 import java.util.Collections;
 import java.util.LinkedHashMap;
@@ -26,8 +28,6 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 import java.util.function.Function;
-import java.util.logging.Level;
-import java.util.logging.Logger;
 
 import org.checkerframework.checker.nullness.qual.Nullable;
 
@@ -38,7 +38,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 interface LocalLoadingCache<K, V> extends LocalManualCache<K, V>, LoadingCache<K, V> {
-  Logger logger = Logger.getLogger(LocalLoadingCache.class.getName());
+  Logger logger = System.getLogger(LocalLoadingCache.class.getName());
 
   /** Returns the {@link CacheLoader} used by this cache. */
   CacheLoader<? super K, V> cacheLoader();

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/GuardedStatsCounter.java
Patch:
@@ -17,8 +17,8 @@
 
 import static java.util.Objects.requireNonNull;
 
-import java.util.logging.Level;
-import java.util.logging.Logger;
+import java.lang.System.Logger;
+import java.lang.System.Logger.Level;
 
 import com.github.benmanes.caffeine.cache.RemovalCause;
 
@@ -30,7 +30,7 @@
  */
 @SuppressWarnings("PMD.AvoidDuplicateLiterals")
 final class GuardedStatsCounter implements StatsCounter {
-  static final Logger logger = Logger.getLogger(GuardedStatsCounter.class.getName());
+  static final Logger logger = System.getLogger(GuardedStatsCounter.class.getName());
 
   final StatsCounter delegate;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1100,7 +1100,6 @@ void decreaseWindow() {
       }
 
       quota -= weight;
-      setMainProtectedWeightedSize(mainProtectedWeightedSize() + weight);
       setWindowWeightedSize(windowWeightedSize() - weight);
       accessOrderWindowDeque().remove(candidate);
       accessOrderProbationDeque().add(candidate);
@@ -1735,7 +1734,7 @@ public void run() {
         if (node.inWindow()) {
           setWindowWeightedSize(windowWeightedSize() + weightDifference);
         } else if (node.inMainProtected()) {
-          setMainProtectedWeightedSize(mainProtectedMaximum() + weightDifference);
+          setMainProtectedWeightedSize(mainProtectedWeightedSize() + weightDifference);
         }
         setWeightedSize(weightedSize() + weightDifference);
         node.setPolicyWeight(node.getPolicyWeight() + weightDifference);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -21,8 +21,8 @@
 import static com.github.benmanes.caffeine.cache.BLCHeader.DrainStatusRef.REQUIRED;
 import static com.github.benmanes.caffeine.cache.BoundedLocalCache.EXPIRE_WRITE_TOLERANCE;
 import static com.github.benmanes.caffeine.cache.BoundedLocalCache.PERCENT_MAIN_PROTECTED;
-import static com.github.benmanes.caffeine.cache.testing.HasStats.hasEvictionCount;
 import static com.github.benmanes.caffeine.cache.testing.RemovalListenerVerifier.verifyRemovalListener;
+import static com.github.benmanes.caffeine.cache.testing.StatsVerifier.verifyStats;
 import static com.github.benmanes.caffeine.testing.Awaits.await;
 import static java.util.Arrays.asList;
 import static org.hamcrest.MatcherAssert.assertThat;
@@ -270,7 +270,7 @@ public void evict_wtinylfu(Cache<Integer, Integer> cache, CacheContext context)
     // evict 12, 13, 14
     checkEvict(cache, asList(13, 14, 15), 15, 3, 4, 5, 0, 1, 2, 6, 7, 8);
 
-    assertThat(context, hasEvictionCount(6));
+    verifyStats(context, verifier -> verifier.evictions(6));
   }
 
   private void checkReorder(Cache<Integer, Integer> cache, List<Integer> keys, Integer... expect) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CaffeineTest.java
Patch:
@@ -142,6 +142,7 @@ public void async_nullLoader() {
   }
 
   @Test
+  @SuppressWarnings("UnnecessaryMethodReference")
   public void async_asyncLoader() {
     Caffeine.newBuilder().buildAsync(loader::asyncLoad);
   }

File: guava/src/test/java/jsr166/JSR166TestCase.java
Patch:
@@ -127,8 +127,8 @@
  *
  * </ul>
  */
-@SuppressWarnings({"deprecation", "rawtypes", "serial",
-  "AssertionFailureIgnored", "DeprecatedThreadMethods", "JdkObsolete", "ThreadPriorityCheck"})
+@SuppressWarnings({"deprecation", "rawtypes", "serial", "AssertionFailureIgnored",
+  "DeprecatedThreadMethods", "JdkObsolete", "JavaUtilDate", "ThreadPriorityCheck"})
 public class JSR166TestCase extends TestCase {
     private static final boolean useSecurityManager =
         Boolean.getBoolean("jsr166.useSecurityManager");

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheProxy.java
Patch:
@@ -915,7 +915,7 @@ public void close() {
    * @param outer the outermost error, or null if unset
    * @return the outermost error, or null if unset and successful
    */
-  private static @Nullable Throwable tryClose(Object o, @Nullable Throwable outer) {
+  private static @Nullable Throwable tryClose(@Nullable Object o, @Nullable Throwable outer) {
     if (o instanceof Closeable) {
       try {
         ((Closeable) o).close();

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/copy/AbstractCopier.java
Patch:
@@ -49,7 +49,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@SuppressWarnings("JdkObsolete")
+@SuppressWarnings({"JdkObsolete", "JavaUtilDate"})
 public abstract class AbstractCopier<A> implements Copier {
   private static final Map<Class<?>, Function<Object, Object>> JAVA_DEEP_COPY;
   private static final Set<Class<?>> JAVA_IMMUTABLE;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/copy/JavaSerializationCopier.java
Patch:
@@ -63,6 +63,7 @@ protected byte[] serialize(Object object) {
   }
 
   @Override
+  @SuppressWarnings("BanSerializableRead")
   protected Object deserialize(byte[] data, ClassLoader classLoader) {
     try (InputStream bytes = new ByteArrayInputStream(data);
         ObjectInputStream input = new ClassLoaderAwareObjectInputStream(bytes, classLoader)) {
@@ -89,6 +90,7 @@ protected ClassLoader getClassLoader() {
     }
 
     @Override
+    @SuppressWarnings("BanSerializableRead")
     protected Class<?> resolveClass(ObjectStreamClass desc)
         throws IOException, ClassNotFoundException {
       try {

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/copy/JavaSerializationCopierTest.java
Patch:
@@ -64,14 +64,14 @@ public void immutable() {
   }
 
   @Test
-  @SuppressWarnings("JdkObsolete")
+  @SuppressWarnings({"JdkObsolete", "JavaUtilDate"})
   public void deepCopy_date() {
     Date date = new Date();
     assertThat(copy(date), is(equalTo(date)));
   }
 
   @Test
-  @SuppressWarnings("JdkObsolete")
+  @SuppressWarnings({"JdkObsolete", "JavaUtilDate"})
   public void deepCopy_calendar() {
     Calendar calendar = Calendar.getInstance();
     calendar.setTime(new Date());

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/opt/ClairvoyantPolicy.java
Patch:
@@ -69,10 +69,10 @@ public void record(AccessEvent event) {
 
     tick++;
     recorder.add(event);
-    IntPriorityQueue times = accessTimes.get(event.key().longValue());
+    IntPriorityQueue times = accessTimes.get(event.key());
     if (times == null) {
       times = new IntArrayFIFOQueue();
-      accessTimes.put(event.key().longValue(), times);
+      accessTimes.put(event.key(), times);
     }
     times.enqueue(tick);
   }
@@ -133,7 +133,7 @@ private final class KeyOnlyRecorder implements Recorder {
       future = new LongArrayFIFOQueue(maximumSize);
     }
     @Override public void add(AccessEvent event) {
-      future.enqueue(event.key().longValue());
+      future.enqueue(event.key());
     }
     @Override public void process() {
       while (!future.isEmpty()) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/opt/UnboundedPolicy.java
Patch:
@@ -58,7 +58,7 @@ public PolicyStats stats() {
   @Override
   public void record(AccessEvent event) {
     policyStats.recordOperation();
-    if (data.add(event.key().longValue())) {
+    if (data.add(event.key())) {
       policyStats.recordWeightedMiss(event.weight());
     } else {
       policyStats.recordWeightedHit(event.weight());

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Cache.java
Patch:
@@ -103,7 +103,7 @@ public interface Cache<K, V> {
    * present in the cache. All entries returned by {@code mappingFunction} will be stored in the
    * cache, over-writing any previously cached values. If another call to {@link #get} tries to load
    * the value for a key in {@code keys}, implementations may either have that thread load the entry
-   * or simply wait for this thread to finish and returns the loaded value. In the case of
+   * or simply wait for this thread to finish and return the loaded value. In the case of
    * overlapping non-blocking loads, the last load to complete will replace the existing entry. Note
    * that multiple threads can concurrently load values for distinct keys.
    * <p>
@@ -114,7 +114,7 @@ public interface Cache<K, V> {
    * @param mappingFunction the function to compute the values
    * @return an unmodifiable mapping of keys to values for the specified keys in this cache
    * @throws NullPointerException if the specified collection is null or contains a null element, or
-   *         if the mao returned by the mappingFunction is null
+   *         if the map returned by the mappingFunction is null
    * @throws RuntimeException or Error if the mappingFunction does so, in which case the mapping is
    *         left unestablished
    */

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/LoadingCacheProxy.java
Patch:
@@ -23,14 +23,15 @@
 import java.util.concurrent.Executor;
 import java.util.stream.Collectors;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
 import javax.cache.Cache;
 import javax.cache.CacheException;
 import javax.cache.CacheManager;
 import javax.cache.expiry.ExpiryPolicy;
 import javax.cache.integration.CacheLoader;
 import javax.cache.integration.CompletionListener;
 
+import org.checkerframework.checker.nullness.qual.Nullable;
+
 import com.github.benmanes.caffeine.cache.LoadingCache;
 import com.github.benmanes.caffeine.cache.Ticker;
 import com.github.benmanes.caffeine.jcache.configuration.CaffeineConfiguration;
@@ -104,7 +105,7 @@ public LoadingCacheProxy(String name, Executor executor, CacheManager cacheManag
 
     V value = null;
     if (expirable != null) {
-      setAccessExpirationTime(expirable, millis);
+      setAccessExpirationTime(key, expirable, millis);
       value = copyValue(expirable);
     }
     if (statsEnabled) {

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/AbstractJCacheTest.java
Patch:
@@ -45,7 +45,7 @@
 @Test(singleThreaded = true)
 @SuppressWarnings("PreferJavaTimeOverload")
 public abstract class AbstractJCacheTest {
-  protected static final long START_TIME_MS = System.currentTimeMillis();
+  protected static final long START_TIME_MS = 0L;//System.currentTimeMillis();
   protected static final long EXPIRY_DURATION = TimeUnit.MINUTES.toMillis(1);
 
   protected static final Integer KEY_1 = 1, VALUE_1 = -1;

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurationTest.java
Patch:
@@ -106,6 +106,7 @@ static void checkTestCache(CaffeineConfiguration<?, ?> config) {
     assertThat(config.getKeyType(), is(Object.class));
     assertThat(config.getValueType(), is(Object.class));
     assertThat(config.getExecutorFactory().create(), is(instanceOf(TestExecutor.class)));
+    assertThat(config.getSchedulerFactory().create(), is(instanceOf(TestScheduler.class)));
     assertThat(config.getCacheLoaderFactory().create(), is(instanceOf(TestCacheLoader.class)));
     assertThat(config.getCacheWriter(), is(instanceOf(TestCacheWriter.class)));
     assertThat(config.isNativeStatisticsEnabled(), is(true));

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheSelectorCode.java
Patch:
@@ -99,8 +99,7 @@ private LocalCacheSelectorCode expires() {
   private LocalCacheSelectorCode selector() {
     block
         .beginControlFlow("try")
-            .addStatement("$T<?> clazz = $T.class.getClassLoader().loadClass(sb.toString())",
-                Class.class, LOCAL_CACHE_FACTORY)
+            .addStatement("Class<?> clazz = Class.forName(sb.toString())")
             .addStatement("$T<?> ctor = clazz.getDeclaredConstructor($T.class, $T.class, $T.class)",
                 Constructor.class, BUILDER, CACHE_LOADER.rawType, TypeName.BOOLEAN)
             .add("@SuppressWarnings($S)\n", "unchecked")

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeSelectorCode.java
Patch:
@@ -94,8 +94,7 @@ private NodeSelectorCode maximum() {
   private NodeSelectorCode selector() {
     block
         .beginControlFlow("try")
-            .addStatement("$T<?> clazz = $T.class.getClassLoader().loadClass(sb.toString())",
-                Class.class, NODE_FACTORY.rawType)
+            .addStatement("Class<?> clazz = Class.forName(sb.toString())")
             .add("@SuppressWarnings($S)\n", "unchecked")
             .addStatement("$1T factory = ($1T) clazz.getDeclaredConstructor().newInstance()",
                 NODE_FACTORY)

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/Cache2k.java
Patch:
@@ -28,7 +28,7 @@ public final class Cache2k<K, V> implements BasicCache<K, V> {
 
   @SuppressWarnings("unchecked")
   public Cache2k(int maximumSize) {
-    cache = Cache2kBuilder.forUnknownTypes()
+    cache = (Cache<K, V>) Cache2kBuilder.forUnknownTypes()
         .entryCapacity(maximumSize)
         .eternal(true)
         .build();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/Rewriter.java
Patch:
@@ -61,7 +61,6 @@ public final class Rewriter implements Runnable {
   private OutputFormat outputFormat;
 
   @Override
-  @SuppressWarnings("PMD.ForLoopCanBeForeach")
   public void run() {
     Stopwatch stopwatch = Stopwatch.createStarted();
     try (OutputStream output = new BufferedOutputStream(Files.newOutputStream(outputFile));

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LoadingCacheTest.java
Patch:
@@ -515,7 +515,7 @@ public void refresh_invalidate(CacheContext context) {
     refresh.set(true);
     await().until(() -> cache.getIfPresent(key), is(refreshed));
     await().until(() -> cache, hasRemovalNotifications(context, 1, RemovalCause.EXPLICIT));
-    await().until(() -> context, both(hasLoadSuccessCount(1)).and(hasLoadFailureCount(0)));
+    assertThat(context, both(hasLoadSuccessCount(1)).and(hasLoadFailureCount(0)));
   }
 
   /* --------------- CacheLoader --------------- */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/RefreshAfterWriteTest.java
Patch:
@@ -360,7 +360,7 @@ public void invalidate(CacheContext context) {
 
     await().until(() -> cache.getIfPresent(key), is(refreshed));
     await().until(() -> cache, hasRemovalNotifications(context, 1, RemovalCause.EXPLICIT));
-    await().until(() -> context, both(hasLoadSuccessCount(1)).and(hasLoadFailureCount(0)));
+    assertThat(context, both(hasLoadSuccessCount(1)).and(hasLoadFailureCount(0)));
   }
 
   /* --------------- Policy --------------- */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Issue298Test.java
Patch:
@@ -16,6 +16,7 @@
 package com.github.benmanes.caffeine.cache.issues;
 
 import static com.github.benmanes.caffeine.testing.Awaits.await;
+import static com.github.benmanes.caffeine.testing.ConcurrentTestHarness.executor;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.lessThanOrEqualTo;
@@ -99,7 +100,7 @@ public void readDuringCreate() {
       do {
         cache.get(key);
       } while (!endRead.get());
-    });
+    }, executor);
 
     // Ran expireAfterCreate (expire: infinite -> create)
     doCreate.set(true);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/BinaryTraceReader.java
Patch:
@@ -45,7 +45,7 @@ protected BinaryTraceReader(String filePath) {
 
   @Override
   @SuppressWarnings("PMD.CloseResource")
-  public Stream<AccessEvent> events() throws IOException {
+  public Stream<AccessEvent> events() {
     DataInputStream input = new DataInputStream(new BufferedInputStream(readFile()));
     Stream<AccessEvent> stream = StreamSupport.stream(Spliterators.spliteratorUnknownSize(
         new TraceIterator(input), Spliterator.ORDERED), /* parallel */ false);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/TextTraceReader.java
Patch:
@@ -18,7 +18,6 @@
 import static java.nio.charset.StandardCharsets.UTF_8;
 
 import java.io.BufferedReader;
-import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
@@ -39,7 +38,7 @@ protected TextTraceReader(String filePath) {
 
   /** Returns a stream of each line in the trace file. */
   @SuppressWarnings("PMD.CloseResource")
-  protected Stream<String> lines() throws IOException {
+  protected Stream<String> lines() {
     InputStream input = readFile();
     Reader reader = new InputStreamReader(input, UTF_8);
     return new BufferedReader(reader).lines().map(String::trim)

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/adapt_size/AdaptSizeTraceReader.java
Patch:
@@ -17,7 +17,6 @@
 
 import static com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic.WEIGHTED;
 
-import java.io.IOException;
 import java.util.Set;
 import java.util.stream.Stream;
 
@@ -48,7 +47,7 @@ public Set<Characteristic> characteristics() {
   }
 
   @Override
-  public Stream<AccessEvent> events() throws IOException {
+  public Stream<AccessEvent> events() {
     return lines()
         .map(line -> line.split(" ", 3))
         .map(array -> {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/address/AddressTraceReader.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.parser.address;
 
-import java.io.IOException;
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
@@ -34,7 +33,7 @@ public AddressTraceReader(String filePath) {
   }
 
   @Override
-  public LongStream keys() throws IOException {
+  public LongStream keys() {
     return lines()
         .map(line -> line.split(" ", 3)[1])
         .map(address -> address.substring(2))

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/address/penalties/AddressPenaltiesTraceReader.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.parser.address.penalties;
 
-import java.io.IOException;
 import java.util.Set;
 import java.util.stream.Stream;
 
@@ -63,7 +62,7 @@ public Set<Characteristic> characteristics() {
   }
 
   @Override
-  public Stream<AccessEvent> events() throws IOException {
+  public Stream<AccessEvent> events() {
     return lines()
         .map(line -> line.split(" ", 5))
         .map(split -> AccessEvent.forKeyAndPenalties(

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/arc/ArcTraceReader.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.parser.arc;
 
-import java.io.IOException;
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
@@ -34,7 +33,7 @@ public ArcTraceReader(String filePath) {
   }
 
   @Override
-  public LongStream keys() throws IOException {
+  public LongStream keys() {
     return lines().flatMapToLong(line -> {
       String[] array = line.split(" ", 3);
       long startBlock = Long.parseLong(array[0]);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/camelab/CamelabTraceReader.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.parser.camelab;
 
-import java.io.IOException;
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
@@ -35,7 +34,7 @@ public CamelabTraceReader(String filePath) {
   }
 
   @Override
-  public LongStream keys() throws IOException {
+  public LongStream keys() {
     return lines().flatMapToLong(line -> {
       String[] array = line.split(" ", 5);
       char readWrite = Character.toLowerCase(array[1].charAt(0));

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/climb/ClimbTraceReader.java
Patch:
@@ -17,7 +17,6 @@
 
 import static java.nio.charset.StandardCharsets.UTF_8;
 
-import java.io.IOException;
 import java.io.InputStream;
 import java.util.PrimitiveIterator;
 import java.util.Scanner;
@@ -41,7 +40,7 @@ public ClimbTraceReader(String filePath) {
   }
 
   @Override
-  public LongStream keys() throws IOException {
+  public LongStream keys() {
     TraceIterator iterator = new TraceIterator(readFile());
     return StreamSupport.longStream(Spliterators.spliteratorUnknownSize(
         iterator, Spliterator.ORDERED), /* parallel */ false).onClose(iterator::close);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/gradle/GradleTraceReader.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.parser.gradle;
 
-import java.io.IOException;
 import java.math.BigInteger;
 import java.util.stream.LongStream;
 
@@ -34,7 +33,7 @@ public GradleTraceReader(String filePath) {
   }
 
   @Override
-  public LongStream keys() throws IOException {
+  public LongStream keys() {
     return lines()
         .map(uuid -> new BigInteger(uuid, 16))
         .mapToLong(num -> num.shiftRight(64).longValue() ^ num.longValue());

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/kaggle/OutbrainTraceReader.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.parser.kaggle;
 
-import java.io.IOException;
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
@@ -36,7 +35,7 @@ public OutbrainTraceReader(String filePath) {
   }
 
   @Override
-  public LongStream keys() throws IOException {
+  public LongStream keys() {
     return lines().skip(1)
         .map(line -> line.split(","))
         .mapToLong(array -> Long.parseLong(array[1]));

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/lirs/LirsTraceReader.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.parser.lirs;
 
-import java.io.IOException;
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
@@ -33,7 +32,7 @@ public LirsTraceReader(String filePath) {
   }
 
   @Override
-  public LongStream keys() throws IOException {
+  public LongStream keys() {
     return lines()
         .filter(line -> !line.isEmpty())
         .filter(line -> !line.equals("*"))

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/snia/cambridge/CambridgeTraceReader.java
Patch:
@@ -17,7 +17,6 @@
 
 import static com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic.WEIGHTED;
 
-import java.io.IOException;
 import java.util.Set;
 import java.util.stream.Stream;
 
@@ -44,7 +43,7 @@ public Set<Characteristic> characteristics() {
   }
 
   @Override
-  public Stream<AccessEvent> events() throws IOException {
+  public Stream<AccessEvent> events() {
     return lines()
         .map(line -> line.split(","))
         .map(array -> AccessEvent.forKeyAndWeight(

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/snia/parallel/K5cloudTraceReader.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.parser.snia.parallel;
 
-import java.io.IOException;
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
@@ -35,7 +34,7 @@ public K5cloudTraceReader(String filePath) {
   }
 
   @Override
-  public LongStream keys() throws IOException {
+  public LongStream keys() {
     return lines()
         .map(line -> line.split(","))
         .filter(array -> array[2].charAt(0) == 'R')

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/snia/parallel/TencentBlockTraceReader.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.parser.snia.parallel;
 
-import java.io.IOException;
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
@@ -36,7 +35,7 @@ public TencentBlockTraceReader(String filePath) {
   }
 
   @Override
-  public LongStream keys() throws IOException {
+  public LongStream keys() {
     return lines()
         .map(line -> line.split(","))
         .filter(array -> array[3].charAt(0) == READ)

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/snia/parallel/TencentPhotoTraceReader.java
Patch:
@@ -17,7 +17,6 @@
 
 import static com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic.WEIGHTED;
 
-import java.io.IOException;
 import java.util.Set;
 import java.util.stream.Stream;
 
@@ -48,7 +47,7 @@ public Set<Characteristic> characteristics() {
   }
 
   @Override
-  public Stream<AccessEvent> events() throws IOException {
+  public Stream<AccessEvent> events() {
     return lines()
         .map(line -> line.split(" "))
         .filter(array -> array[2].equals(JPEG_FORMAT) || array[2].equals(WEBP_FORMAT))

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/twitter/TwitterTraceReader.java
Patch:
@@ -17,7 +17,6 @@
 
 import static com.github.benmanes.caffeine.cache.simulator.policy.Policy.Characteristic.WEIGHTED;
 
-import java.io.IOException;
 import java.util.Set;
 import java.util.stream.Stream;
 
@@ -45,7 +44,7 @@ public Set<Characteristic> characteristics() {
   }
 
   @Override
-  public Stream<AccessEvent> events() throws IOException {
+  public Stream<AccessEvent> events() {
     return lines()
         .map(line -> line.split(","))
         .filter(array -> {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/umass/network/YoutubeTraceReader.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.parser.umass.network;
 
-import java.io.IOException;
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
@@ -35,7 +34,7 @@ public YoutubeTraceReader(String filePath) {
   }
 
   @Override
-  public LongStream keys() throws IOException {
+  public LongStream keys() {
     return lines()
         .map(line -> line.split(" "))
         .filter(array -> array[3].equals("GETVIDEO"))

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/umass/storage/StorageTraceReader.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.parser.umass.storage;
 
-import java.io.IOException;
 import java.math.RoundingMode;
 import java.util.stream.LongStream;
 
@@ -37,7 +36,7 @@ public StorageTraceReader(String filePath) {
   }
 
   @Override
-  public LongStream keys() throws IOException {
+  public LongStream keys() {
     return lines().flatMapToLong(line -> {
       String[] array = line.split(",", 5);
       if (array.length <= 4) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/wikipedia/WikipediaTraceReader.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.parser.wikipedia;
 
-import java.io.IOException;
 import java.util.Objects;
 import java.util.stream.LongStream;
 
@@ -45,7 +44,7 @@ public WikipediaTraceReader(String filePath) {
   }
 
   @Override
-  public LongStream keys() throws IOException {
+  public LongStream keys() {
     return lines()
         .map(this::parseRequest)
         .filter(Objects::nonNull)

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/TraceFormat.java
Patch:
@@ -40,6 +40,7 @@
 import com.github.benmanes.caffeine.cache.simulator.parser.snia.parallel.K5cloudTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.parser.snia.parallel.TencentBlockTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.parser.snia.parallel.TencentPhotoTraceReader;
+import com.github.benmanes.caffeine.cache.simulator.parser.twitter.TwitterTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.parser.umass.network.YoutubeTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.parser.umass.storage.StorageTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.parser.wikipedia.WikipediaTraceReader;
@@ -72,6 +73,7 @@ public enum TraceFormat {
   SNIA_K5CLOUD(K5cloudTraceReader::new),
   SNIA_TENCENT_BLOCK(TencentBlockTraceReader::new),
   SNIA_TENCENT_PHOTO(TencentPhotoTraceReader::new),
+  TWITTER(TwitterTraceReader::new),
   UMASS_STORAGE(StorageTraceReader::new),
   UMASS_YOUTUBE(YoutubeTraceReader::new),
   WIKIPEDIA(WikipediaTraceReader::new);

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheSelectorCode.java
Patch:
@@ -90,7 +90,7 @@ private LocalCacheSelectorCode expires() {
         .beginControlFlow("if (builder.expiresAfterWrite())")
             .addStatement("sb.append('W')")
         .endControlFlow()
-        .beginControlFlow("if (builder.refreshes())")
+        .beginControlFlow("if (builder.refreshAfterWrite())")
             .addStatement("sb.append('R')")
         .endControlFlow();
     return this;

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeSelectorCode.java
Patch:
@@ -55,7 +55,7 @@ private NodeSelectorCode values() {
   private NodeSelectorCode expires() {
     block
         .beginControlFlow("if (builder.expiresVariable())")
-            .beginControlFlow("if (builder.refreshes())")
+            .beginControlFlow("if (builder.refreshAfterWrite())")
                 .addStatement("sb.append('A')")
                 .beginControlFlow("if (builder.evicts())")
                     .addStatement("sb.append('W')")
@@ -71,7 +71,7 @@ private NodeSelectorCode expires() {
                 .addStatement("sb.append('W')")
             .endControlFlow()
         .endControlFlow()
-        .beginControlFlow("if (builder.refreshes())")
+        .beginControlFlow("if (builder.refreshAfterWrite())")
             .addStatement("sb.append('R')")
         .endControlFlow();
     return this;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Scheduler.java
Patch:
@@ -49,7 +49,7 @@ public interface Scheduler {
    * @param command the runnable task to schedule
    * @param delay how long to delay, in units of {@code unit}
    * @param unit a {@code TimeUnit} determining how to interpret the {@code delay} parameter
-   * @return a scheduled future representing pending completion of the task
+   * @return a scheduled future representing pending submission of the task
    */
   @NonNull Future<?> schedule(@NonNull Executor executor,
       @NonNull Runnable command, @Positive long delay, @NonNull TimeUnit unit);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpirationTest.java
Patch:
@@ -121,7 +121,7 @@ public void expire_zero(Cache<Integer, Integer> cache, CacheContext context) {
       expiry = { CacheExpiry.DISABLED, CacheExpiry.CREATE, CacheExpiry.WRITE, CacheExpiry.ACCESS },
       expireAfterAccess = {Expire.DISABLED, Expire.ONE_MINUTE}, expiryTime = Expire.ONE_MINUTE,
       expireAfterWrite = {Expire.DISABLED, Expire.ONE_MINUTE}, compute = Compute.SYNC,
-      scheduler = CacheScheduler.MOCK)
+      scheduler = CacheScheduler.MOCKITO)
   public void schedule(Cache<Integer, Integer> cache, CacheContext context) {
     ArgumentCaptor<Long> delay = ArgumentCaptor.forClass(long.class);
     ArgumentCaptor<Runnable> task = ArgumentCaptor.forClass(Runnable.class);
@@ -153,7 +153,7 @@ public void schedule(Cache<Integer, Integer> cache, CacheContext context) {
       expiry = { CacheExpiry.DISABLED, CacheExpiry.CREATE, CacheExpiry.WRITE, CacheExpiry.ACCESS },
       expireAfterAccess = {Expire.DISABLED, Expire.ONE_MINUTE}, expiryTime = Expire.ONE_MINUTE,
       expireAfterWrite = {Expire.DISABLED, Expire.ONE_MINUTE}, compute = Compute.SYNC,
-      scheduler = CacheScheduler.MOCK)
+      scheduler = CacheScheduler.MOCKITO)
   public void schedule_immediate(Cache<Integer, Integer> cache, CacheContext context) {
     doAnswer(invocation -> {
       invocation.getArgument(1, Runnable.class).run();
@@ -170,7 +170,7 @@ public void schedule_immediate(Cache<Integer, Integer> cache, CacheContext conte
       expiry = { CacheExpiry.DISABLED, CacheExpiry.CREATE, CacheExpiry.WRITE, CacheExpiry.ACCESS },
       expireAfterAccess = {Expire.DISABLED, Expire.ONE_MINUTE},
       expireAfterWrite = {Expire.DISABLED, Expire.ONE_MINUTE}, expiryTime = Expire.ONE_MINUTE,
-      scheduler = CacheScheduler.MOCK, removalListener = Listener.MOCK)
+      scheduler = CacheScheduler.MOCKITO, removalListener = Listener.MOCK)
   public void schedule_delay(Cache<Integer, Duration> cache, CacheContext context)
       throws InterruptedException {
     Map<Integer, Duration> actualExpirationPeriods = new HashMap<>();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidBoundedLocalCache.java
Patch:
@@ -85,9 +85,9 @@ private void drain(BoundedLocalCache<K, V> cache) {
   }
 
   private void checkReadBuffer(BoundedLocalCache<K, V> cache) {
-    Buffer<?> buffer = cache.readBuffer;
-    Awaits.await().until(() -> {
+    Awaits.await().pollInSameThread().until(() -> {
       cache.cleanUp();
+      Buffer<?> buffer = cache.readBuffer;
       return (buffer.size() == 0) && buffer.reads() == buffer.writes();
     });
   }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/TimerWheelTest.java
Patch:
@@ -76,7 +76,7 @@ public void beforeMethod() {
     mocks = MockitoAnnotations.openMocks(this);
     timerWheel = new TimerWheel<>(cache);
 
-    RandomSeedEnforcer.setThreadLocalRandom(random.nextInt(), random.nextInt());
+    Reset.setThreadLocalRandom(random.nextInt(), random.nextInt());
   }
 
   @AfterMethod

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Solr10141Test.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache.issues;
 
-import static org.awaitility.Awaitility.await;
+import static com.github.benmanes.caffeine.testing.Awaits.await;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheSpec.java
Patch:
@@ -675,7 +675,7 @@ enum CacheScheduler {
     DEFAULT(() -> null), // disabled
     SYSTEM(Scheduler::systemScheduler),
     THREADED(() -> Scheduler.forScheduledExecutorService(scheduledExecutor)),
-    MOCK(() -> Mockito.mock(Scheduler.class));
+    MOCKITO(() -> Mockito.mock(Scheduler.class));
 
     private final Supplier<Scheduler> scheduler;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CaffeineCacheFromContext.java
Patch:
@@ -20,7 +20,7 @@
 
 import com.github.benmanes.caffeine.cache.Cache;
 import com.github.benmanes.caffeine.cache.Caffeine;
-import com.github.benmanes.caffeine.cache.RandomSeedEnforcer;
+import com.github.benmanes.caffeine.cache.Reset;
 import com.github.benmanes.caffeine.cache.Ticker;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.CacheExecutor;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.CacheExpiry;
@@ -115,7 +115,7 @@ public static <K, V> Cache<K, V> newCaffeineCache(CacheContext context) {
 
     @SuppressWarnings("unchecked")
     Cache<K, V> castedCache = (Cache<K, V>) context.cache;
-    RandomSeedEnforcer.resetThreadLocalRandom();
+    Reset.resetThreadLocalRandom();
     return castedCache;
   }
 }

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/ConcurrentTestHarness.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.List;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ThreadFactory;
@@ -47,7 +47,7 @@ public final class ConcurrentTestHarness {
       .setPriority(Thread.MIN_PRIORITY).setDaemon(true).build();
   public static final ScheduledExecutorService scheduledExecutor =
       Executors.newSingleThreadScheduledExecutor(DAEMON_FACTORY);
-  public static final Executor executor = Executors.newCachedThreadPool(DAEMON_FACTORY);
+  public static final ExecutorService executor = Executors.newCachedThreadPool(DAEMON_FACTORY);
 
   private ConcurrentTestHarness() {}
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurator.java
Patch:
@@ -229,8 +229,9 @@ private void addWriteThrough() {
       }
     }
 
-    /** Adds the JMX monitoring settings. */
+    /** Adds the monitoring settings. */
     private void addMonitoring() {
+      configuration.setNativeStatisticsEnabled(merged.getBoolean("monitoring.native-statistics"));
       configuration.setStatisticsEnabled(merged.getBoolean("monitoring.statistics"));
       configuration.setManagementEnabled(merged.getBoolean("monitoring.management"));
     }

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurationTest.java
Patch:
@@ -83,6 +83,7 @@ public void testCache2() {
 
     assertThat(config2.get().getKeyType(), is(String.class));
     assertThat(config2.get().getValueType(), is(Integer.class));
+    assertThat(config2.get().isNativeStatisticsEnabled(), is(false));
     assertThat(config2.get().getExecutorFactory().create(), is(ForkJoinPool.commonPool()));
   }
 
@@ -107,6 +108,7 @@ static void checkTestCache(CaffeineConfiguration<?, ?> config) {
     assertThat(config.getExecutorFactory().create(), is(instanceOf(TestExecutor.class)));
     assertThat(config.getCacheLoaderFactory().create(), is(instanceOf(TestCacheLoader.class)));
     assertThat(config.getCacheWriter(), is(instanceOf(TestCacheWriter.class)));
+    assertThat(config.isNativeStatisticsEnabled(), is(true));
     assertThat(config.isStatisticsEnabled(), is(true));
     assertThat(config.isManagementEnabled(), is(true));
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/BasicSettings.java
Patch:
@@ -76,8 +76,8 @@ public TinyLfuSettings tinyLfu() {
     return new TinyLfuSettings();
   }
 
-  public int maximumSize() {
-    return config().getInt("maximum-size");
+  public long maximumSize() {
+    return config().getLong("maximum-size");
   }
 
   public boolean isFiles() {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin64/CountMin64TinyLfu.java
Patch:
@@ -17,6 +17,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.Frequency;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 /**
@@ -45,8 +46,8 @@ public CountMin64TinyLfu(Config config) {
     BasicSettings settings = new BasicSettings(config);
     sketch = new CountMin64(settings.tinyLfu().countMin64().eps(),
         settings.tinyLfu().countMin64().confidence(), settings.randomSeed());
+    sampleSize = Ints.checkedCast(10 * settings.maximumSize());
     conservative = settings.tinyLfu().conservative();
-    sampleSize = 10 * settings.maximumSize();
   }
 
   /** Returns the estimated usage frequency of the item. */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/perfect/PerfectFrequency.java
Patch:
@@ -17,6 +17,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.Frequency;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.longs.Long2IntMap;
@@ -34,7 +35,8 @@ public final class PerfectFrequency implements Frequency {
   private int size;
 
   public PerfectFrequency(Config config) {
-    sampleSize = 10 * new BasicSettings(config).maximumSize();
+    BasicSettings settings = new BasicSettings(config);
+    sampleSize = Ints.checkedCast(10 * settings.maximumSize());
     counts = new Long2IntOpenHashMap();
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/table/RandomRemovalFrequencyTable.java
Patch:
@@ -23,6 +23,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.Frequency;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 /**
@@ -49,7 +50,7 @@ public final class RandomRemovalFrequencyTable implements Frequency {
 
   public RandomRemovalFrequencyTable(Config config) {
     BasicSettings settings = new BasicSettings(config);
-    maxSum = sampleFactor * settings.maximumSize();
+    maxSum = Ints.checkedCast(sampleFactor * settings.maximumSize());
     random = new Random(settings.randomSeed());
     table = new HashMap<>(maxSum);
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinyCacheAdapter.java
Patch:
@@ -17,6 +17,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.Frequency;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 /**
@@ -37,7 +38,8 @@ public final class TinyCacheAdapter implements Frequency {
    */
   public TinyCacheAdapter(Config config) {
     BasicSettings settings = new BasicSettings(config);
-    int nrSets = sampleFactor * settings.maximumSize() / 64; // number of (independent sets)
+    // number of (independent sets)
+    int nrSets = Ints.checkedCast(sampleFactor * settings.maximumSize() / 64);
     tcs = new TinyCacheSketch(nrSets, 64,settings.randomSeed());
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/adaptive/ArcPolicy.java
Patch:
@@ -25,6 +25,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
@@ -75,8 +76,8 @@ public final class ArcPolicy implements KeyOnlyPolicy {
 
   public ArcPolicy(Config config) {
     BasicSettings settings = new BasicSettings(config);
+    this.maximumSize = Ints.checkedCast(settings.maximumSize());
     this.policyStats = new PolicyStats("adaptive.Arc");
-    this.maximumSize = settings.maximumSize();
     this.data = new Long2ObjectOpenHashMap<>();
     this.headT1 = new Node();
     this.headT2 = new Node();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/adaptive/CarPolicy.java
Patch:
@@ -25,6 +25,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
@@ -61,9 +62,9 @@ public final class CarPolicy implements KeyOnlyPolicy {
 
   public CarPolicy(Config config) {
     BasicSettings settings = new BasicSettings(config);
+    this.maximumSize = Ints.checkedCast(settings.maximumSize());
     this.policyStats = new PolicyStats("adaptive.Car");
     this.data = new Long2ObjectOpenHashMap<>();
-    this.maximumSize = settings.maximumSize();
     this.headT1 = new Node();
     this.headT2 = new Node();
     this.headB1 = new Node();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/adaptive/CartPolicy.java
Patch:
@@ -25,6 +25,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
@@ -65,9 +66,9 @@ public final class CartPolicy implements KeyOnlyPolicy {
 
   public CartPolicy(Config config) {
     BasicSettings settings = new BasicSettings(config);
+    this.maximumSize = Ints.checkedCast(settings.maximumSize());
     this.policyStats = new PolicyStats("adaptive.Cart");
     this.data = new Long2ObjectOpenHashMap<>();
-    this.maximumSize = settings.maximumSize();
     this.headT1 = new Node();
     this.headT2 = new Node();
     this.headB1 = new Node();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/ClockProPolicy.java
Patch:
@@ -25,6 +25,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
@@ -86,10 +87,10 @@ public final class ClockProPolicy implements KeyOnlyPolicy {
 
   public ClockProPolicy(Config config) {
     BasicSettings settings = new BasicSettings(config);
+    maximumSize = Ints.checkedCast(settings.maximumSize());
     policyStats = new PolicyStats("irr.ClockPro");
-    maximumColdSize = settings.maximumSize();
     data = new Long2ObjectOpenHashMap<>();
-    maximumSize = settings.maximumSize();
+    maximumColdSize = maximumSize;
 
     // All the hands move in the clockwise direction
     handHot = handCold = handTest = null;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/DClockPolicy.java
Patch:
@@ -27,6 +27,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
@@ -66,9 +67,9 @@ public final class DClockPolicy implements KeyOnlyPolicy {
 
   public DClockPolicy(DClockSettings settings, double percentActive) {
     this.policyStats = new PolicyStats("irr.DClock (active: %d%%)", (int) (100 * percentActive));
-    this.maxActive = (int) (percentActive * settings.maximumSize());
+    this.maximumSize = Ints.checkedCast(settings.maximumSize());
+    this.maxActive = (int) (percentActive * maximumSize);
     this.data = new Long2ObjectOpenHashMap<>();
-    this.maximumSize = settings.maximumSize();
     this.headNonResident = new Node();
     this.headInactive = new Node();
     this.headActive = new Node();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/FrequentlyUsedPolicy.java
Patch:
@@ -30,6 +30,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
@@ -50,11 +51,11 @@ public final class FrequentlyUsedPolicy implements KeyOnlyPolicy {
   final int maximumSize;
 
   public FrequentlyUsedPolicy(Admission admission, EvictionPolicy policy, Config config) {
+    BasicSettings settings = new BasicSettings(config);
     this.policyStats = new PolicyStats(admission.format("linked." + policy.label()));
+    this.maximumSize = Ints.checkedCast(settings.maximumSize());
     this.admittor = admission.from(config, policyStats);
-    BasicSettings settings = new BasicSettings(config);
     this.data = new Long2ObjectOpenHashMap<>();
-    this.maximumSize = settings.maximumSize();
     this.policy = requireNonNull(policy);
     this.freq0 = new FrequencyNode();
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/MultiQueuePolicy.java
Patch:
@@ -27,6 +27,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
@@ -65,12 +66,12 @@ public final class MultiQueuePolicy implements KeyOnlyPolicy {
 
   public MultiQueuePolicy(Config config) {
     MultiQueueSettings settings = new MultiQueueSettings(config);
+    maximumSize = Ints.checkedCast(settings.maximumSize());
     policyStats = new PolicyStats("linked.MultiQueue");
     threshold = new long[settings.numberOfQueues()];
     headQ = new Node[settings.numberOfQueues()];
     out = new Long2ObjectLinkedOpenHashMap<>();
     data = new Long2ObjectOpenHashMap<>();
-    maximumSize = settings.maximumSize();
     lifetime = settings.lifetime();
 
     Arrays.setAll(headQ, Node::sentinel);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/S4LruPolicy.java
Patch:
@@ -28,6 +28,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
@@ -55,11 +56,11 @@ public final class S4LruPolicy implements KeyOnlyPolicy {
   private final int levels;
 
   public S4LruPolicy(Admission admission, Config config) {
+    S4LruSettings settings = new S4LruSettings(config);
     this.policyStats = new PolicyStats(admission.format("linked.S4Lru"));
+    this.maximumSize = Ints.checkedCast(settings.maximumSize());
     this.admittor = admission.from(config, policyStats);
-    S4LruSettings settings = new S4LruSettings(config);
     this.data = new Long2ObjectOpenHashMap<>();
-    this.maximumSize = settings.maximumSize();
     this.levels = settings.levels();
     this.headQ = new Node[levels];
     this.sizeQ = new int[levels];

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/SegmentedLruPolicy.java
Patch:
@@ -27,6 +27,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
@@ -70,8 +71,8 @@ public SegmentedLruPolicy(Admission admission, Config config) {
     SegmentedLruSettings settings = new SegmentedLruSettings(config);
     this.headProtected = new Node();
     this.headProbation = new Node();
-    this.maximumSize = settings.maximumSize();
     this.data = new Long2ObjectOpenHashMap<>();
+    this.maximumSize = Ints.checkedCast(settings.maximumSize());
     this.maxProtected = (int) (maximumSize * settings.percentProtected());
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/opt/ClairvoyantPolicy.java
Patch:
@@ -24,6 +24,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.ints.IntArrayFIFOQueue;
@@ -51,10 +52,10 @@ public final class ClairvoyantPolicy implements Policy {
 
   public ClairvoyantPolicy(Config config) {
     BasicSettings settings = new BasicSettings(config);
+    maximumSize = Ints.checkedCast(settings.maximumSize());
     policyStats = new PolicyStats("opt.Clairvoyant");
     accessTimes = new Long2ObjectOpenHashMap<>();
     infiniteTimestamp = Integer.MAX_VALUE;
-    maximumSize = settings.maximumSize();
     future = new ArrayDeque<>(maximumSize);
     data = new IntRBTreeSet();
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/Cache2kPolicy.java
Patch:
@@ -43,7 +43,7 @@ public final class Cache2kPolicy implements Policy {
 
   private final Cache<Long, AccessEvent> cache;
   private final PolicyStats policyStats;
-  private final int maximumSize;
+  private final long maximumSize;
 
   public Cache2kPolicy(Config config) {
     logger.setLevel(Level.WARNING);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/CaffeinePolicy.java
Patch:
@@ -28,6 +28,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 /**
@@ -51,7 +52,7 @@ public CaffeinePolicy(Config config, Set<Characteristic> characteristics) {
       builder.weigher((key, value) -> value.weight());
     } else {
       builder.maximumSize(settings.maximumSize());
-      builder.initialCapacity(settings.maximumSize());
+      builder.initialCapacity(Ints.saturatedCast(settings.maximumSize()));
     }
     cache = builder.build();
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/Ehcache3Policy.java
Patch:
@@ -40,8 +40,9 @@ public final class Ehcache3Policy implements KeyOnlyPolicy {
   private final Cache<Object, Object> cache;
   private final CacheManager cacheManager;
   private final PolicyStats policyStats;
-  private final int maximumSize;
-  private int size;
+  private final long maximumSize;
+
+  private long size;
 
   @SuppressWarnings("PMD.CloseResource")
   public Ehcache3Policy(Config config) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/ExpiringMapPolicy.java
Patch:
@@ -24,6 +24,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 import net.jodah.expiringmap.ExpirationPolicy;
@@ -42,8 +43,8 @@ public ExpiringMapPolicy(Config config) {
     policyStats = new PolicyStats("product.ExpiringMap");
     ExpiringMapSettings settings = new ExpiringMapSettings(config);
     cache = ExpiringMap.builder()
+        .maxSize(Ints.checkedCast(settings.maximumSize()))
         .expirationPolicy(settings.policy())
-        .maxSize(settings.maximumSize())
         .build();
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/GuavaPolicy.java
Patch:
@@ -43,7 +43,6 @@ public GuavaPolicy(Config config) {
     BasicSettings settings = new BasicSettings(config);
     cache = CacheBuilder.newBuilder()
         .maximumWeight(settings.maximumSize())
-        .initialCapacity(settings.maximumSize())
         .weigher((Long key, AccessEvent value) -> value.weight())
         .removalListener(notification -> policyStats.recordEviction())
         .build();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/OhcPolicy.java
Patch:
@@ -55,8 +55,8 @@ public OhcPolicy(OhcSettings settings, Eviction policy) {
         .keySerializer(longSerializer)
         .eviction(policy)
         .build();
-    policyStats = new PolicyStats(String.format("product.OHC (%s)",
-        (policy == Eviction.LRU) ? "Lru" : "W-TinyLfu"));
+    policyStats = new PolicyStats("product.OHC (%s)",
+        (policy == Eviction.LRU) ? "Lru" : "W-TinyLfu");
   }
 
   /** Returns all variations of this policy based on the configuration parameters. */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/TCachePolicy.java
Patch:
@@ -24,6 +24,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.primitives.Ints;
 import com.trivago.triava.tcache.Cache;
 import com.trivago.triava.tcache.TCacheFactory;
 import com.trivago.triava.tcache.eviction.EvictionInterface;
@@ -44,7 +45,7 @@ public TCachePolicy(Config config) {
     TCacheSettings settings = new TCacheSettings(config);
     policyStats = new PolicyStats("product.TCache");
     cache = TCacheFactory.standardFactory().builder()
-        .setMaxElements(settings.maximumSize())
+        .setMaxElements(Ints.checkedCast(settings.maximumSize()))
         .setEvictionClass(settings.policy())
         .setStatistics(true)
         .build();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sampled/SampledPolicy.java
Patch:
@@ -34,6 +34,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
@@ -69,10 +70,10 @@ public SampledPolicy(Admission admission, EvictionPolicy policy, Config config)
     this.admittor = admission.from(config, policyStats);
 
     SampledSettings settings = new SampledSettings(config);
+    this.maximumSize = Ints.checkedCast(settings.maximumSize());
     this.sampleStrategy = settings.sampleStrategy();
     this.random = new Random(settings.randomSeed());
     this.data = new Long2ObjectOpenHashMap<>();
-    this.maximumSize = settings.maximumSize();
     this.sampleSize = settings.sampleSize();
     this.table = new Node[maximumSize + 1];
     this.policy = policy;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/inference/IndicatorClimber.java
Patch:
@@ -18,6 +18,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.Indicator;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.climbing.HillClimber;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.climbing.HillClimberWindowTinyLfuPolicy.HillClimberWindowTinyLfuSettings;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 /**
@@ -33,8 +34,8 @@ public final class IndicatorClimber implements HillClimber {
 
   public IndicatorClimber(Config config) {
     HillClimberWindowTinyLfuSettings settings = new HillClimberWindowTinyLfuSettings(config);
+    this.cacheSize = Ints.checkedCast(settings.maximumSize());
     this.prevPercent = 1 - settings.percentMain().get(0);
-    this.cacheSize = settings.maximumSize();
     this.indicator = new Indicator(config);
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/feedback/FeedbackTinyLfuPolicy.java
Patch:
@@ -29,6 +29,7 @@
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 import com.typesafe.config.ConfigFactory;
 
@@ -66,9 +67,9 @@ public final class FeedbackTinyLfuPolicy implements KeyOnlyPolicy {
   public FeedbackTinyLfuPolicy(Config config) {
     FeedbackTinyLfuSettings settings = new FeedbackTinyLfuSettings(config);
     this.policyStats = new PolicyStats("sketch.FeedbackTinyLfu");
+    this.maximumSize = Ints.checkedCast(settings.maximumSize());
     this.admittor = new TinyLfu(settings.config(), policyStats);
     this.data = new Long2ObjectOpenHashMap<>();
-    this.maximumSize = settings.maximumSize();
     this.head = new Node();
 
     maxGain = Math.min(15, settings.maximumInsertionGain());

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/tinycache/TinyCachePolicy.java
Patch:
@@ -23,6 +23,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 /**
@@ -35,7 +36,8 @@ public final class TinyCachePolicy implements KeyOnlyPolicy {
   public TinyCachePolicy(Config config) {
     BasicSettings settings = new BasicSettings(config);
     this.policyStats = new PolicyStats("sketch.TinyCache");
-    tinyCache = new TinyCache((int) Math.ceil(settings.maximumSize() / 64.0),
+    int maximumSize = Ints.checkedCast(settings.maximumSize());
+    tinyCache = new TinyCache((int) Math.ceil(maximumSize / 64.0),
         64, settings.randomSeed());
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/tinycache/TinyCacheWithGhostCachePolicy.java
Patch:
@@ -23,6 +23,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 /**
@@ -34,8 +35,9 @@ public final class TinyCacheWithGhostCachePolicy implements KeyOnlyPolicy {
 
   public TinyCacheWithGhostCachePolicy(Config config) {
     BasicSettings settings = new BasicSettings(config);
+    int maximumSize = Ints.checkedCast(settings.maximumSize());
     this.policyStats = new PolicyStats("sketch.TinyCache_GhostCache");
-    tinyCache = new TinyCacheWithGhostCache((int) Math.ceil(settings.maximumSize() / 64.0),
+    tinyCache = new TinyCacheWithGhostCache((int) Math.ceil(maximumSize / 64.0),
         64, settings.randomSeed());
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/TuQueuePolicy.java
Patch:
@@ -25,6 +25,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
@@ -75,9 +76,9 @@ public TuQueuePolicy(Config config) {
     this.headHot = new Node();
     this.headWarm = new Node();
     this.headCold = new Node();
-    this.maximumSize = settings.maximumSize();
     this.data = new Long2ObjectOpenHashMap<>();
     this.policyStats = new PolicyStats("two-queue.TuQueue");
+    this.maximumSize = Ints.checkedCast(settings.maximumSize());
     this.maxHot = (int) (maximumSize * settings.percentHot());
     this.maxWarm = (int) (maximumSize * settings.percentWarm());
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/TwoQueuePolicy.java
Patch:
@@ -25,6 +25,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.primitives.Ints;
 import com.typesafe.config.Config;
 
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
@@ -67,10 +68,10 @@ public TwoQueuePolicy(Config config) {
     this.headIn = new Node();
     this.headOut = new Node();
     this.headMain = new Node();
-    this.maximumSize = settings.maximumSize();
     this.data = new Long2ObjectOpenHashMap<>();
-    this.maxIn = (int) (maximumSize * settings.percentIn());
     this.policyStats = new PolicyStats("two-queue.TwoQueue");
+    this.maximumSize = Ints.checkedCast(settings.maximumSize());
+    this.maxIn = (int) (maximumSize * settings.percentIn());
     this.maxOut = (int) (maximumSize * settings.percentOut());
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -2027,7 +2027,7 @@ public Map<K, V> getAllPresent(Iterable<?> keys) {
       int oldWeight;
       boolean expired = false;
       boolean mayUpdate = true;
-      boolean withinTolerance = true;
+      boolean exceedsTolerance = true;
       synchronized (prior) {
         if (!prior.isAlive()) {
           continue;
@@ -2052,7 +2052,7 @@ public Map<K, V> getAllPresent(Iterable<?> keys) {
           writer.write(key, value);
         }
         if (mayUpdate) {
-          withinTolerance = ((now - prior.getWriteTime()) > EXPIRE_WRITE_TOLERANCE);
+          exceedsTolerance = ((now - prior.getWriteTime()) > EXPIRE_WRITE_TOLERANCE);
 
           setWriteTime(prior, now);
           prior.setWeight(newWeight);
@@ -2076,7 +2076,7 @@ public Map<K, V> getAllPresent(Iterable<?> keys) {
       int weightedDifference = mayUpdate ? (newWeight - oldWeight) : 0;
       if ((oldValue == null) || (weightedDifference != 0) || expired) {
         afterWrite(new UpdateTask(prior, weightedDifference));
-      } else if (!onlyIfAbsent && expiresAfterWrite() && withinTolerance) {
+      } else if (!onlyIfAbsent && expiresAfterWrite() && exceedsTolerance) {
         afterWrite(new UpdateTask(prior, weightedDifference));
       } else {
         if (mayUpdate) {

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/local/LocalCacheRule.java
Patch:
@@ -24,7 +24,7 @@ public abstract class LocalCacheRule implements Consumer<LocalCacheContext> {
   protected LocalCacheContext context;
 
   @SuppressWarnings({"NullAway.Init", "PMD.UnnecessaryConstructor"})
-  public LocalCacheRule() {}
+  LocalCacheRule() {}
 
   @Override
   public void accept(LocalCacheContext context) {

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/NodeRule.java
Patch:
@@ -43,7 +43,7 @@ public abstract class NodeRule implements Consumer<NodeContext> {
   protected NodeContext context;
 
   @SuppressWarnings("NullAway.Init")
-  public NodeRule() {}
+  NodeRule() {}
 
   @Override
   public final void accept(NodeContext context) {

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/TimerWheelBenchmark.java
Patch:
@@ -130,7 +130,7 @@ static final class Timer extends Node<Integer, Integer> {
   static final class MockCache extends BoundedLocalCache<Integer, Integer> {
 
     @SuppressWarnings({"unchecked", "rawtypes"})
-    protected MockCache() {
+    MockCache() {
       super((Caffeine) Caffeine.newBuilder(), /* cacheLoader */ null, /* isAsync */ false);
     }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncCache.java
Patch:
@@ -28,7 +28,6 @@
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.Map;
-import java.util.Map.Entry;
 import java.util.NoSuchElementException;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
@@ -235,7 +234,7 @@ public void accept(@Nullable Map<K, V> result, @Nullable Throwable error) {
         if (error == null) {
           error = new NullMapCompletionException();
         }
-        for (Entry<K, CompletableFuture<V>> entry : proxies.entrySet()) {
+        for (Map.Entry<K, CompletableFuture<V>> entry : proxies.entrySet()) {
           cache.remove(entry.getKey(), entry.getValue());
           entry.getValue().obtrudeException(error);
         }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/CacheStats.java
Patch:
@@ -185,7 +185,7 @@ public long missCount() {
    * Note that {@code hitRate + missRate =~ 1.0}. Cache misses include all requests which
    * weren't cache hits, including requests which resulted in either successful or failed loading
    * attempts, and requests which waited for other threads to finish loading. It is thus the case
-   * that {@code missCount &gt;= loadSuccessCount + loadFailureCount}. Multiple
+   * that {@code missCount >= loadSuccessCount + loadFailureCount}. Multiple
    * concurrent misses for the same key will result in a single load operation.
    *
    * @return the ratio of cache requests which were misses

File: caffeine/src/test/java/com/github/benmanes/caffeine/SingleConsumerQueueTest.java
Patch:
@@ -113,6 +113,7 @@ public void contains_whenNotFound(Queue<Integer> queue) {
     assertThat(queue.contains(-1), is(false));
   }
 
+  @SuppressWarnings("ReturnValueIgnored")
   @Test(dataProvider = "empty", expectedExceptions = NullPointerException.class)
   public void containsAll_withNull(Queue<?> queue) {
     queue.containsAll(null);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -37,7 +37,6 @@
 
 import java.util.List;
 import java.util.Map;
-import java.util.Map.Entry;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -193,8 +192,8 @@ public void putWeighted_noOverflow() {
       population = Population.EMPTY, maximumSize = Maximum.ONE)
   public void evict_alreadyRemoved(Cache<Integer, Integer> cache, CacheContext context) {
     BoundedLocalCache<Integer, Integer> localCache = asBoundedLocalCache(cache);
-    Entry<Integer, Integer> oldEntry = Iterables.get(context.absent().entrySet(), 0);
-    Entry<Integer, Integer> newEntry = Iterables.get(context.absent().entrySet(), 1);
+    Map.Entry<Integer, Integer> oldEntry = Iterables.get(context.absent().entrySet(), 0);
+    Map.Entry<Integer, Integer> newEntry = Iterables.get(context.absent().entrySet(), 1);
 
     localCache.put(oldEntry.getKey(), oldEntry.getValue());
     localCache.evictionLock.lock();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidMapView.java
Patch:
@@ -38,6 +38,7 @@ public void describeTo(Description description) {
   }
 
   @Override
+  @SuppressWarnings("NonCanonicalType")
   protected boolean matchesSafely(Map<K, V> map, Description description) {
     this.description = description;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheProvider.java
Patch:
@@ -23,7 +23,6 @@
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.Map;
-import java.util.Map.Entry;
 import java.util.Objects;
 import java.util.concurrent.ConcurrentMap;
 import java.util.logging.LogManager;
@@ -82,7 +81,7 @@ private static CacheGenerator newCacheGenerator(Method testMethod) {
    * {@link Policy.Eviction}, and {@link Policy.Expiration}.
    */
   private static Iterator<Object[]> asTestCases(Method testMethod,
-      Stream<Entry<CacheContext, Cache<Integer, Integer>>> scenarios) {
+      Stream<Map.Entry<CacheContext, Cache<Integer, Integer>>> scenarios) {
     Parameter[] parameters = testMethod.getParameters();
     CacheContext[] stashed = new CacheContext[1];
     return scenarios.map(entry -> {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheWriterVerifier.java
Patch:
@@ -22,7 +22,6 @@
 import static org.mockito.Mockito.verify;
 
 import java.util.Map;
-import java.util.Map.Entry;
 import java.util.function.BiConsumer;
 
 import org.mockito.Mockito;
@@ -76,7 +75,7 @@ public void deletions(long count, RemovalCause cause) {
   }
 
   /** Checks that the entry was deleted for the specified reason. */
-  public void deleted(Entry<Integer, Integer> entry, RemovalCause cause) {
+  public void deleted(Map.Entry<Integer, Integer> entry, RemovalCause cause) {
     deleted(entry.getKey(), entry.getValue(), cause);
   }
 

File: guava/src/test/java/com/github/benmanes/caffeine/cache/LinkedDequeTests.java
Patch:
@@ -59,7 +59,7 @@ public static Test suite() throws Exception {
     return suite;
   }
 
-  protected static Test suite(String name, Supplier<LinkedDeque<LinkedValue>> supplier) {
+  static Test suite(String name, Supplier<LinkedDeque<LinkedValue>> supplier) {
     return QueueTestSuiteBuilder
         .using(new TestLinkedValueGenerator() {
           @Override public Queue<LinkedValue> create(LinkedValue[] elements) {

File: guava/src/test/java/com/github/benmanes/caffeine/cache/QueueSanityTest.java
Patch:
@@ -50,7 +50,7 @@ public abstract class QueueSanityTest {
   private final Queue<Integer> queue;
   private final ConcurrentQueueSpec spec;
 
-  public QueueSanityTest(ConcurrentQueueSpec spec, Queue<Integer> queue) {
+  protected QueueSanityTest(ConcurrentQueueSpec spec, Queue<Integer> queue) {
     this.queue = queue;
     this.spec = spec;
   }

File: guava/src/test/java/com/google/common/cache/CacheBuilderGwtTest.java
Patch:
@@ -19,7 +19,6 @@
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.Map;
-import java.util.Map.Entry;
 import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentMap;
@@ -499,7 +498,7 @@ public void testAsMapEntrySet() {
     fakeTicker.advance(501, TimeUnit.MILLISECONDS);
 
     int sum = 0;
-    for (Entry<Integer, Integer> current : cache.asMap().entrySet()) {
+    for (Map.Entry<Integer, Integer> current : cache.asMap().entrySet()) {
       sum += current.getKey() + current.getValue();
     }
     assertEquals(57, sum);

File: guava/src/test/java/com/google/common/cache/CacheBuilderTest.java
Patch:
@@ -56,7 +56,8 @@
  * Unit tests for Caffeine.
  */
 @GwtCompatible(emulated = true)
-@SuppressWarnings({"CanonicalDuration", "ThreadPriorityCheck", "PreferJavaTimeOverload"})
+@SuppressWarnings(
+    {"CacheLoaderNull", "CanonicalDuration", "ThreadPriorityCheck", "PreferJavaTimeOverload"})
 public class CacheBuilderTest extends TestCase {
 
   public void testNewBuilder() {

File: guava/src/test/java/com/google/common/cache/CacheLoadingTest.java
Patch:
@@ -62,7 +62,7 @@
  *
  * @author mike nonemacher
  */
-@SuppressWarnings({"ThreadPriorityCheck", "PreferJavaTimeOverload"})
+@SuppressWarnings({"CacheLoaderNull", "PreferJavaTimeOverload", "ThreadPriorityCheck"})
 public class CacheLoadingTest extends TestCase {
   Logger logger = Logger.getLogger("com.github.benmanes.caffeine.cache.BoundedLocalCache");
   TestLogHandler logHandler;

File: guava/src/test/java/jsr166/ConcurrentHashMapTest.java
Patch:
@@ -22,7 +22,8 @@
 import junit.framework.Test;
 import junit.framework.TestSuite;
 
-@SuppressWarnings({"rawtypes", "unchecked", "UnnecessaryParentheses"})
+@SuppressWarnings({"rawtypes", "unchecked",
+  "ModifyCollectionInEnhancedForLoop", "ReturnValueIgnored", "UnnecessaryParentheses"})
 public class ConcurrentHashMapTest extends JSR166TestCase {
     public static void main(String[] args) {
         junit.textui.TestRunner.run(suite());

File: guava/src/test/java/jsr166/JSR166TestCase.java
Patch:
@@ -128,7 +128,7 @@
  * </ul>
  */
 @SuppressWarnings({"deprecation", "rawtypes", "serial",
-  "AssertionFailureIgnored", "DeprecatedThreadMethods", "ThreadPriorityCheck"})
+  "AssertionFailureIgnored", "DeprecatedThreadMethods", "JdkObsolete", "ThreadPriorityCheck"})
 public class JSR166TestCase extends TestCase {
     private static final boolean useSecurityManager =
         Boolean.getBoolean("jsr166.useSecurityManager");

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/copy/AbstractCopier.java
Patch:
@@ -49,6 +49,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("JdkObsolete")
 public abstract class AbstractCopier<A> implements Copier {
   private static final Map<Class<?>, Function<Object, Object>> JAVA_DEEP_COPY;
   private static final Set<Class<?>> JAVA_IMMUTABLE;
@@ -69,11 +70,11 @@ public abstract class AbstractCopier<A> implements Copier {
   private final Set<Class<?>> immutableClasses;
   private final Map<Class<?>, Function<Object, Object>> deepCopyStrategies;
 
-  public AbstractCopier() {
+  protected AbstractCopier() {
     this(javaImmutableClasses(), javaDeepCopyStrategies());
   }
 
-  public AbstractCopier(Set<Class<?>> immutableClasses,
+  protected AbstractCopier(Set<Class<?>> immutableClasses,
       Map<Class<?>, Function<Object, Object>> deepCopyStrategies) {
     this.immutableClasses = requireNonNull(immutableClasses);
     this.deepCopyStrategies = requireNonNull(deepCopyStrategies);

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/integration/DisabledCacheWriter.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.Collection;
 
-import javax.cache.Cache.Entry;
+import javax.cache.Cache;
 import javax.cache.integration.CacheWriter;
 
 /**
@@ -41,10 +41,10 @@ public static <K, V> CacheWriter<K, V> get() {
   }
 
   @Override
-  public void write(Entry<?, ?> entry) {}
+  public void write(Cache.Entry<?, ?> entry) {}
 
   @Override
-  public void writeAll(Collection<Entry<?, ?>> entries) {}
+  public void writeAll(Collection<Cache.Entry<?, ?>> entries) {}
 
   @Override
   public void delete(Object key) {}

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/configuration/TestCacheWriter.java
Patch:
@@ -17,16 +17,16 @@
 
 import java.util.Collection;
 
-import javax.cache.Cache.Entry;
+import javax.cache.Cache;
 import javax.cache.integration.CacheWriter;
 
 /**
  * @author ben.manes@gmail.com (Ben Manes)
  */
 public final class TestCacheWriter implements CacheWriter<Integer, Integer> {
-  @Override public void write(Entry<? extends Integer, ? extends Integer> entry) {}
+  @Override public void write(Cache.Entry<? extends Integer, ? extends Integer> entry) {}
   @Override public void writeAll(
-      Collection<Entry<? extends Integer, ? extends Integer>> entries) {}
+      Collection<Cache.Entry<? extends Integer, ? extends Integer>> entries) {}
   @Override public void delete(Object key) {}
   @Override public void deleteAll(Collection<?> keys) {}
 }

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/copy/JavaSerializationCopierTest.java
Patch:
@@ -64,12 +64,14 @@ public void immutable() {
   }
 
   @Test
+  @SuppressWarnings("JdkObsolete")
   public void deepCopy_date() {
     Date date = new Date();
     assertThat(copy(date), is(equalTo(date)));
   }
 
   @Test
+  @SuppressWarnings("JdkObsolete")
   public void deepCopy_calendar() {
     Calendar calendar = Calendar.getInstance();
     calendar.setTime(new Date());

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/JCacheAccessExpiryTest.java
Patch:
@@ -21,7 +21,6 @@
 import static org.hamcrest.Matchers.nullValue;
 
 import java.util.Map;
-import java.util.Map.Entry;
 import java.util.concurrent.TimeUnit;
 import java.util.stream.Collectors;
 
@@ -197,7 +196,7 @@ public void invokeAll_present() {
     Map<Integer, EntryProcessorResult<Integer>> result =
         jcache.invokeAll(keys, (entry, args) -> entry.getValue());
     Map<Integer, Integer> unwrapped = result.entrySet().stream().collect(
-        Collectors.toMap(Entry::getKey, entry -> entry.getValue().get()));
+        Collectors.toMap(Map.Entry::getKey, entry -> entry.getValue().get()));
     assertThat(unwrapped, is(entries));
 
     for (Integer key : keys) {

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/processor/EntryProcessorTest.java
Patch:
@@ -26,7 +26,7 @@
 import java.util.OptionalLong;
 import java.util.concurrent.TimeUnit;
 
-import javax.cache.Cache.Entry;
+import javax.cache.Cache;
 import javax.cache.expiry.CreatedExpiryPolicy;
 import javax.cache.expiry.Duration;
 import javax.cache.integration.CacheLoader;
@@ -110,13 +110,13 @@ private Object process(MutableEntry<Integer, Integer> entry, Object... arguments
   final class MapWriter implements CacheWriter<Integer, Integer> {
 
     @Override
-    public void write(Entry<? extends Integer, ? extends Integer> entry) {
+    public void write(Cache.Entry<? extends Integer, ? extends Integer> entry) {
       writes++;
       map.put(entry.getKey(), entry.getValue());
     }
 
     @Override
-    public void writeAll(Collection<Entry<? extends Integer, ? extends Integer>> entries) {
+    public void writeAll(Collection<Cache.Entry<? extends Integer, ? extends Integer>> entries) {
       entries.forEach(this::write);
     }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/AbstractTraceReader.java
Patch:
@@ -40,7 +40,7 @@ public abstract class AbstractTraceReader implements TraceReader {
 
   protected final String filePath;
 
-  public AbstractTraceReader(String filePath) {
+  protected AbstractTraceReader(String filePath) {
     this.filePath = filePath.trim();
   }
 
@@ -73,7 +73,7 @@ private InputStream openFile() throws IOException {
       return Files.newInputStream(file);
     }
     InputStream input = getClass().getResourceAsStream(filePath);
-    checkArgument(input != null, "Could not find file: " + filePath);
+    checkArgument(input != null, "Could not find file: %s", filePath);
     return input;
   }
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/BinaryTraceReader.java
Patch:
@@ -39,7 +39,7 @@
  */
 public abstract class BinaryTraceReader extends AbstractTraceReader {
 
-  public BinaryTraceReader(String filePath) {
+  protected BinaryTraceReader(String filePath) {
     super(filePath);
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/TextTraceReader.java
Patch:
@@ -33,7 +33,7 @@
  */
 public abstract class TextTraceReader extends AbstractTraceReader implements TraceReader {
 
-  public TextTraceReader(String filePath) {
+  protected TextTraceReader(String filePath) {
     super(filePath);
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/TextTraceWriter.java
Patch:
@@ -30,7 +30,7 @@
 public abstract class TextTraceWriter implements TraceWriter {
   private final BufferedWriter writer;
 
-  public TextTraceWriter(OutputStream output) {
+  protected TextTraceWriter(OutputStream output) {
     this.writer = new BufferedWriter(new OutputStreamWriter(output, UTF_8));
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/Registry.java
Patch:
@@ -22,7 +22,6 @@
 
 import java.util.HashMap;
 import java.util.Map;
-import java.util.Map.Entry;
 import java.util.Set;
 import java.util.function.Function;
 import java.util.stream.Stream;
@@ -90,7 +89,7 @@ private static Map<String, Function<Config, Set<Policy>>> makeRegistry() {
     registerTwoQueue(factories);
     registerAdaptive(factories);
     return factories.entrySet().stream().collect(
-        toMap(entry -> entry.getKey().toLowerCase(US), Entry::getValue));
+        toMap(entry -> entry.getKey().toLowerCase(US), Map.Entry::getValue));
   }
 
   /**

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/TextReporter.java
Patch:
@@ -38,13 +38,13 @@
 public abstract class TextReporter implements Reporter {
   private static final String[] HEADERS = {
       "Policy", "Hit rate", "Hits", "Misses", "Requests", "Evictions",
-      "Admit rate", "Requests Weight", "Weighted Hit Rate", "Average Miss Penalty", 
+      "Admit rate", "Requests Weight", "Weighted Hit Rate", "Average Miss Penalty",
       "Average Penalty", "Steps", "Time"};
 
   private final List<PolicyStats> results;
   private final BasicSettings settings;
 
-  public TextReporter(Config config) {
+  protected TextReporter(Config config) {
     settings = new BasicSettings(config);
     results = new ArrayList<>();
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1878,6 +1878,9 @@ public boolean containsValue(Object value) {
       if (recordStats) {
         statsCounter().recordMisses(1);
       }
+      if (drainStatus() == REQUIRED) {
+        scheduleDrainBuffers();
+      }
       return null;
     }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Cache.java
Patch:
@@ -45,8 +45,8 @@ public interface Cache<K, V> {
    * cached value for the {@code key}.
    *
    * @param key the key whose associated value is to be returned
-   * @return the value to which the specified key is mapped, or {@code null} if this map contains no
-   *         mapping for the key
+   * @return the value to which the specified key is mapped, or {@code null} if this cache contains
+   *         no mapping for the key
    * @throws NullPointerException if the specified key is null
    */
   @Nullable

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Policy.java
Patch:
@@ -51,8 +51,8 @@ public interface Policy<K, V> {
    * expiration time, or triggering a refresh.
    *
    * @param key the key whose associated value is to be returned
-   * @return the value to which the specified key is mapped, or {@code null} if this map contains no
-   *         mapping for the key
+   * @return the value to which the specified key is mapped, or {@code null} if this cache contains
+   *         no mapping for the key
    * @throws NullPointerException if the specified key is null
    */
   @Nullable

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Node.java
Patch:
@@ -117,7 +117,7 @@ public void setPolicyWeight(@NonNegative int weight) {}
 
   /* --------------- Variable order --------------- */
 
-  /** Returns the time that this entry was last accessed, in ns. */
+  /** Returns the variable expiration time, in nanoseconds. */
   public long getVariableTime() {
     return 0L;
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Cache.java
Patch:
@@ -167,7 +167,7 @@ default Map<K, V> getAll(@NonNull Iterable<? extends @NonNull K> keys,
    * @param keys the keys whose associated values are to be removed
    * @throws NullPointerException if the specified collection is null or contains a null element
    */
-  void invalidateAll(@NonNull Iterable<?> keys);
+  void invalidateAll(@NonNull Iterable<@NonNull ?> keys);
 
   /**
    * Discards all entries in the cache. The behavior of this operation is undefined for an entry

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/ConcurrentTestHarness.java
Patch:
@@ -43,7 +43,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 public final class ConcurrentTestHarness {
-  private static final ThreadFactory DAEMON_FACTORY = new ThreadFactoryBuilder()
+  public static final ThreadFactory DAEMON_FACTORY = new ThreadFactoryBuilder()
       .setPriority(Thread.MIN_PRIORITY).setDaemon(true).build();
   public static final ScheduledExecutorService scheduledExecutor =
       Executors.newSingleThreadScheduledExecutor(DAEMON_FACTORY);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -579,7 +579,7 @@ protected void setAdjustment(long amount) {
    */
   @GuardedBy("evictionLock")
   void setMaximumSize(long maximum) {
-    requireArgument(maximum >= 0);
+    requireArgument(maximum >= 0, "maximum must not be negative");
     if (maximum == maximum()) {
       return;
     }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/CaffeineConfiguration.java
Patch:
@@ -366,7 +366,7 @@ public void setExpiryFactory(Optional<Factory<? extends Expiry<K, V>>> factory)
   }
 
   /**
-   * Set the maximum weight.
+   * Set the maximum size.
    *
    * @param maximumSize the maximum size
    */
@@ -377,7 +377,7 @@ public void setMaximumSize(OptionalLong maximumSize) {
   }
 
   /**
-   * Returns the maximum weight to be used for the cache.
+   * Returns the maximum size to be used for the cache.
    *
    * @return the maximum size
    */

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/TimerWheelBenchmark.java
Patch:
@@ -76,8 +76,9 @@ public void expire(ThreadState threadState) {
     long time = times[threadState.index++ & MASK];
     timer.setVariableTime(time);
     timerWheel.nanos = (time - DELTA);
-    timerWheel.advance(time);
+    timerWheel.deschedule(timer);
     timerWheel.schedule(timer);
+    timerWheel.advance(time);
   }
 
   @Benchmark

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/TraceFormat.java
Patch:
@@ -26,6 +26,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.parser.adapt_size.AdaptSizeReader;
 import com.github.benmanes.caffeine.cache.simulator.parser.address.AddressTraceReader;
+import com.github.benmanes.caffeine.cache.simulator.parser.address.penalties.AddressPenaltiesTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.parser.arc.ArcTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.parser.cache2k.Cache2kTraceReader;
 import com.github.benmanes.caffeine.cache.simulator.parser.climb.ClimbTraceReader;
@@ -51,6 +52,7 @@
 @SuppressWarnings("ImmutableEnumChecker")
 public enum TraceFormat {
   ADDRESS(AddressTraceReader::new),
+  ADDRESS_PENALTIES(AddressPenaltiesTraceReader::new),
   ADAPT_SIZE(AdaptSizeReader::new),
   ARC(ArcTraceReader::new),
   CACHE2K(Cache2kTraceReader::new),

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/CsvReporter.java
Patch:
@@ -49,6 +49,8 @@ protected String assemble(List<PolicyStats> results) {
           policyStats.requestCount(),
           policyStats.evictionCount(),
           String.format("%.2f", 100 * policyStats.admissionRate()),
+          String.format("%.2f", policyStats.averageMissPenalty()),
+          String.format("%.2f", policyStats.avergePenalty()),
           (policyStats.operationCount() == 0) ? null : policyStats.operationCount(),
           policyStats.stopwatch().elapsed(TimeUnit.MILLISECONDS)
       };

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/TableReporter.java
Patch:
@@ -47,6 +47,8 @@ protected String assemble(List<PolicyStats> results) {
           String.format("%,d", policyStats.requestCount()),
           String.format("%,d", policyStats.evictionCount()),
           String.format("%.2f %%", 100 * policyStats.admissionRate()),
+          String.format("%.2f", policyStats.averageMissPenalty()),
+          String.format("%.2f", policyStats.avergePenalty()),
           steps(policyStats),
           policyStats.stopwatch().toString()
       };

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/TextReporter.java
Patch:
@@ -37,8 +37,8 @@
  */
 public abstract class TextReporter implements Reporter {
   private static final String[] HEADERS = {
-      "Policy", "Hit rate", "Hits", "Misses", "Requests",
-      "Evictions", "Admit rate", "Steps", "Time"};
+      "Policy", "Hit rate", "Hits", "Misses", "Requests", "Evictions",
+      "Admit rate", "Average Miss Penalty", "Average Penalty", "Steps", "Time"};
 
   private final List<PolicyStats> results;
   private final BasicSettings settings;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/LirsPolicy.java
Patch:
@@ -302,7 +302,7 @@ public void finished() {
     checkState(sizeHot <= maximumHotSize);
     checkState(residentSize <= maximumSize);
     checkState(sizeNR <=  maximumNonResidentSize);
-    checkState(data.size() <= (maximumSize + maximumNonResidentSize));
+    checkState(data.size() <= ((long) maximumSize + maximumNonResidentSize));
     checkState(sizeS == data.values().stream().filter(node -> node.isInS).count());
     checkState(sizeQ == data.values().stream().filter(node -> node.isInQ).count());
 

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/MemoryBenchmark.java
Patch:
@@ -43,6 +43,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PreferJavaTimeOverload")
 public final class MemoryBenchmark {
   // The number of entries added to minimize skew due to non-entry factors
   static final int FUZZY_SIZE = 25_000;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -45,6 +45,7 @@
 import com.github.benmanes.caffeine.cache.stats.CacheStats;
 import com.github.benmanes.caffeine.cache.stats.ConcurrentStatsCounter;
 import com.github.benmanes.caffeine.cache.stats.StatsCounter;
+import com.google.errorprone.annotations.FormatMethod;
 
 /**
  * A builder of {@link Cache}, {@link LoadingCache}, {@link AsyncCache}, and
@@ -171,6 +172,7 @@ enum Strength { WEAK, SOFT }
   private Caffeine() {}
 
   /** Ensures that the argument expression is true. */
+  @FormatMethod
   static void requireArgument(boolean expression, String template, @Nullable Object... args) {
     if (!expression) {
       throw new IllegalArgumentException(String.format(template, args));
@@ -192,6 +194,7 @@ static void requireState(boolean expression) {
   }
 
   /** Ensures that the state expression is true. */
+  @FormatMethod
   static void requireState(boolean expression, String template, @Nullable Object... args) {
     if (!expression) {
       throw new IllegalStateException(String.format(template, args));

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Node.java
Patch:
@@ -94,7 +94,6 @@ public void setPolicyWeight(@NonNegative int weight) {}
   /* --------------- Health --------------- */
 
   /** If the entry is available in the hash-table and page replacement policy. */
-  @GuardedBy("this")
   public abstract boolean isAlive();
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/SerializationProxy.java
Patch:
@@ -51,7 +51,7 @@ final class SerializationProxy<K, V> implements Serializable {
   @Nullable AsyncCacheLoader<?, ?> loader;
   @Nullable RemovalListener<?, ?> removalListener;
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({"unchecked", "PreferJavaTimeOverload"})
   Caffeine<Object, Object> recreateCaffeine() {
     Caffeine<Object, Object> builder = Caffeine.newBuilder();
     if (ticker != null) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/TimerWheel.java
Patch:
@@ -39,6 +39,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("GuardedBy")
 final class TimerWheel<K, V> {
 
   /*

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsyncLoadingCacheTest.java
Patch:
@@ -73,7 +73,7 @@
  */
 @Listeners(CacheValidationListener.class)
 @Test(dataProviderClass = CacheProvider.class)
-@SuppressWarnings("FutureReturnValueIgnored")
+@SuppressWarnings({"FutureReturnValueIgnored", "PreferJavaTimeOverload"})
 public final class AsyncLoadingCacheTest {
 
   /* --------------- get --------------- */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -77,6 +77,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("GuardedBy")
 @Listeners(CacheValidationListener.class)
 @Test(dataProviderClass = CacheProvider.class)
 public final class BoundedLocalCacheTest {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CaffeineTest.java
Patch:
@@ -43,6 +43,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PreferJavaTimeOverload")
 public final class CaffeineTest {
   @Mock StatsCounter statsCounter;
   @Mock Expiry<Object, Object> expiry;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpirationTest.java
Patch:
@@ -81,6 +81,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @Listeners(CacheValidationListener.class)
+@SuppressWarnings("PreferJavaTimeOverload")
 @Test(dataProviderClass = CacheProvider.class)
 public final class ExpirationTest {
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterAccessTest.java
Patch:
@@ -61,6 +61,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @Listeners(CacheValidationListener.class)
+@SuppressWarnings("PreferJavaTimeOverload")
 @Test(dataProviderClass = CacheProvider.class)
 public final class ExpireAfterAccessTest {
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterVarTest.java
Patch:
@@ -73,6 +73,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @Listeners(CacheValidationListener.class)
+@SuppressWarnings("PreferJavaTimeOverload")
 @Test(dataProviderClass = CacheProvider.class)
 public final class ExpireAfterVarTest {
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterWriteTest.java
Patch:
@@ -60,6 +60,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @Listeners(CacheValidationListener.class)
+@SuppressWarnings("PreferJavaTimeOverload")
 @Test(dataProviderClass = CacheProvider.class)
 public final class ExpireAfterWriteTest {
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidBoundedLocalCache.java
Patch:
@@ -48,6 +48,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("GuardedBy")
 public final class IsValidBoundedLocalCache<K, V>
     extends TypeSafeDiagnosingMatcher<BoundedLocalCache<K, V>> {
   DescriptionBuilder desc;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/RefreshAfterWriteTest.java
Patch:
@@ -74,6 +74,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @Listeners(CacheValidationListener.class)
+@SuppressWarnings("PreferJavaTimeOverload")
 @Test(dataProviderClass = CacheProvider.class)
 public final class RefreshAfterWriteTest {
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/StripedBufferTest.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache;
 
-import static java.util.Objects.requireNonNull;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.lessThanOrEqualTo;
@@ -84,7 +83,7 @@ static final class FakeBuffer<E> extends StripedBuffer<E> {
     int drains = 0;
 
     FakeBuffer(int result) {
-      this.result = requireNonNull(result);
+      this.result = result;
     }
 
     @Override protected Buffer<E> create(E e) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/TimerWheelTest.java
Patch:
@@ -60,6 +60,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @Test(singleThreaded = true)
+@SuppressWarnings("GuardedBy")
 public final class TimerWheelTest {
   private static final Random random = new Random();
   private static final long NOW = random.nextLong();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Issue30Test.java
Patch:
@@ -53,6 +53,7 @@
  */
 @Test(groups = "isolated")
 @Listeners(CacheValidationListener.class)
+@SuppressWarnings("PreferJavaTimeOverload")
 public final class Issue30Test {
   private static final boolean DEBUG = false;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContext.java
Patch:
@@ -496,6 +496,7 @@ public String toString() {
   static final class SerializableFakeTicker extends FakeTicker implements Serializable {
     private static final long START_TIME = new Random().nextLong();
 
+    @SuppressWarnings("PreferJavaTimeOverload")
     public SerializableFakeTicker() {
       advance(START_TIME);
     }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheGenerator.java
Patch:
@@ -52,6 +52,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PreferJavaTimeOverload")
 final class CacheGenerator {
   // Integer caches the object identity semantics of autoboxing for values between
   // -128 and 127 (inclusive) as required by JLS (assuming default setting)

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CaffeineCacheFromContext.java
Patch:
@@ -37,6 +37,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PreferJavaTimeOverload")
 public final class CaffeineCacheFromContext {
   interface SerializableTicker extends Ticker, Serializable {}
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java
Patch:
@@ -63,6 +63,7 @@
 /**
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PreferJavaTimeOverload")
 public final class GuavaCacheFromContext {
 
   private GuavaCacheFromContext() {}
@@ -409,7 +410,7 @@ protected ConcurrentMap<K, V> delegate() {
           return cache.asMap();
         }
 
-        @SuppressWarnings("UnusedVariable")
+        @SuppressWarnings({"UnusedVariable", "UnusedMethod"})
         private void readObject(ObjectInputStream stream) throws InvalidObjectException {
           statsCounter = new SimpleStatsCounter();
         }

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/Awaits.java
Patch:
@@ -23,6 +23,7 @@
 /**
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PreferJavaTimeOverload")
 public final class Awaits {
 
   private Awaits() {}

File: guava/src/test/java/com/github/benmanes/caffeine/cache/CaffeineSpecGuavaTest.java
Patch:
@@ -31,6 +31,7 @@
  *
  * @author Adam Winer
  */
+@SuppressWarnings("PreferJavaTimeOverload")
 public class CaffeineSpecGuavaTest extends TestCase {
 
   public void testParse_empty() {

File: guava/src/test/java/com/google/common/cache/CacheBuilderGwtTest.java
Patch:
@@ -47,6 +47,7 @@
  * @author Jon Donovan
  */
 @GwtCompatible
+@SuppressWarnings("PreferJavaTimeOverload")
 public class CacheBuilderGwtTest extends TestCase {
 
   private FakeTicker fakeTicker;

File: guava/src/test/java/com/google/common/cache/CacheBuilderTest.java
Patch:
@@ -56,7 +56,7 @@
  * Unit tests for Caffeine.
  */
 @GwtCompatible(emulated = true)
-@SuppressWarnings({"CanonicalDuration", "ThreadPriorityCheck"})
+@SuppressWarnings({"CanonicalDuration", "ThreadPriorityCheck", "PreferJavaTimeOverload"})
 public class CacheBuilderTest extends TestCase {
 
   public void testNewBuilder() {

File: guava/src/test/java/com/google/common/cache/CacheExpirationTest.java
Patch:
@@ -44,6 +44,7 @@
  *
  * @author mike nonemacher
  */
+@SuppressWarnings("PreferJavaTimeOverload")
 public class CacheExpirationTest extends TestCase {
 
   private static final long EXPIRING_TIME = 1000;

File: guava/src/test/java/com/google/common/cache/CacheLoadingTest.java
Patch:
@@ -62,7 +62,7 @@
  *
  * @author mike nonemacher
  */
-@SuppressWarnings("ThreadPriorityCheck")
+@SuppressWarnings({"ThreadPriorityCheck", "PreferJavaTimeOverload"})
 public class CacheLoadingTest extends TestCase {
   Logger logger = Logger.getLogger("com.github.benmanes.caffeine.cache.BoundedLocalCache");
   TestLogHandler logHandler;

File: guava/src/test/java/com/google/common/cache/CacheRefreshTest.java
Patch:
@@ -30,6 +30,7 @@
  *
  * @author Charles Fry
  */
+@SuppressWarnings("PreferJavaTimeOverload")
 public class CacheRefreshTest extends TestCase {
   public void testAutoRefresh() {
     FakeTicker ticker = new FakeTicker();

File: guava/src/test/java/com/google/common/cache/CacheTesting.java
Patch:
@@ -37,7 +37,7 @@
  *
  * @author mike nonemacher
  */
-@SuppressWarnings("GuardedByChecker")
+@SuppressWarnings({"GuardedByChecker", "PreferJavaTimeOverload"})
 class CacheTesting {
 
   /**

File: guava/src/test/java/com/google/common/cache/LocalCacheMapComputeTest.java
Patch:
@@ -30,6 +30,7 @@
 /**
  * Test Java8 map.compute in concurrent cache context.
  */
+@SuppressWarnings("PreferJavaTimeOverload")
 public class LocalCacheMapComputeTest extends TestCase {
   final int count = 10000;
   final String delimiter = "-";

File: guava/src/test/java/com/google/common/cache/NullCacheTest.java
Patch:
@@ -34,6 +34,7 @@
  *
  * @author mike nonemacher
  */
+@SuppressWarnings("PreferJavaTimeOverload")
 public class NullCacheTest extends TestCase {
   QueuingRemovalListener<Object, Object> listener;
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheFactory.java
Patch:
@@ -226,6 +226,7 @@ private boolean configureMaximumWeight() {
     }
 
     /** Configures the write expiration and returns if set. */
+    @SuppressWarnings("PreferJavaTimeOverload")
     private boolean configureExpireAfterWrite() {
       if (config.getExpireAfterWrite().isPresent()) {
         caffeine.expireAfterWrite(config.getExpireAfterWrite().getAsLong(), TimeUnit.NANOSECONDS);
@@ -234,6 +235,7 @@ private boolean configureExpireAfterWrite() {
     }
 
     /** Configures the access expiration and returns if set. */
+    @SuppressWarnings("PreferJavaTimeOverload")
     private boolean configureExpireAfterAccess() {
       if (config.getExpireAfterAccess().isPresent()) {
         caffeine.expireAfterAccess(config.getExpireAfterAccess().getAsLong(), TimeUnit.NANOSECONDS);
@@ -262,6 +264,7 @@ private boolean configureExpireVariably() {
       return config.getExpireAfterWrite().isPresent();
     }
 
+    @SuppressWarnings("PreferJavaTimeOverload")
     private void configureRefreshAfterWrite() {
       if (config.getRefreshAfterWrite().isPresent()) {
         caffeine.refreshAfterWrite(config.getRefreshAfterWrite().getAsLong(), TimeUnit.NANOSECONDS);

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/AbstractJCacheTest.java
Patch:
@@ -19,12 +19,12 @@
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
 import javax.cache.CacheManager;
 import javax.cache.Caching;
 import javax.cache.integration.CacheLoader;
 import javax.cache.spi.CachingProvider;
 
+import org.checkerframework.checker.nullness.qual.Nullable;
 import org.testng.annotations.AfterMethod;
 import org.testng.annotations.BeforeClass;
 import org.testng.annotations.BeforeMethod;
@@ -43,6 +43,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @Test(singleThreaded = true)
+@SuppressWarnings("PreferJavaTimeOverload")
 public abstract class AbstractJCacheTest {
   protected static final long START_TIME_MS = System.currentTimeMillis();
   protected static final long EXPIRY_DURATION = TimeUnit.MINUTES.toMillis(1);

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/processor/EntryProcessorTest.java
Patch:
@@ -46,6 +46,7 @@
  * @author chrisstockton (Chris Stockton)
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PreferJavaTimeOverload")
 public final class EntryProcessorTest extends AbstractJCacheTest {
   private final Map<Integer, Integer> map = new HashMap<>();
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/address/AddressTraceReader.java
Patch:
@@ -19,21 +19,22 @@
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
+import com.github.benmanes.caffeine.cache.simulator.parser.TraceReader.KeyOnlyTraceReader;
 
 /**
  * A reader for the trace files of application address instructions, provided by
  * <a href="http://cseweb.ucsd.edu/classes/fa07/cse240a/project1.html">UC SD</a>.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class AddressTraceReader extends TextTraceReader {
+public final class AddressTraceReader extends TextTraceReader implements KeyOnlyTraceReader {
 
   public AddressTraceReader(String filePath) {
     super(filePath);
   }
 
   @Override
-  public LongStream events() throws IOException {
+  public LongStream keys() throws IOException {
     return lines()
         .map(line -> line.split(" ", 3)[1])
         .map(address -> address.substring(2))

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/arc/ArcTraceReader.java
Patch:
@@ -19,21 +19,22 @@
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
+import com.github.benmanes.caffeine.cache.simulator.parser.TraceReader.KeyOnlyTraceReader;
 
 /**
  * A reader for the trace files provided by the authors of the ARC algorithm. See
  * <a href="http://researcher.watson.ibm.com/researcher/view_person_subpage.php?id=4700">traces</a>.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class ArcTraceReader extends TextTraceReader {
+public final class ArcTraceReader extends TextTraceReader implements KeyOnlyTraceReader {
 
   public ArcTraceReader(String filePath) {
     super(filePath);
   }
 
   @Override
-  public LongStream events() throws IOException {
+  public LongStream keys() throws IOException {
     return lines().flatMapToLong(line -> {
       String[] array = line.split(" ", 3);
       long startBlock = Long.parseLong(array[0]);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/climb/ClimbTraceReader.java
Patch:
@@ -27,20 +27,21 @@
 import java.util.stream.StreamSupport;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
+import com.github.benmanes.caffeine.cache.simulator.parser.TraceReader.KeyOnlyTraceReader;
 
 /**
  * A reader for the trace files provided by the authors of the AdaptiveClimb algorithm.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class ClimbTraceReader extends TextTraceReader {
+public final class ClimbTraceReader extends TextTraceReader implements KeyOnlyTraceReader {
 
   public ClimbTraceReader(String filePath) {
     super(filePath);
   }
 
   @Override
-  public LongStream events() throws IOException {
+  public LongStream keys() throws IOException {
     TraceIterator iterator = new TraceIterator(readFile());
     return StreamSupport.longStream(Spliterators.spliteratorUnknownSize(
         iterator, Spliterator.ORDERED), /* parallel */ false).onClose(iterator::close);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/gradle/GradleTraceReader.java
Patch:
@@ -20,20 +20,21 @@
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
+import com.github.benmanes.caffeine.cache.simulator.parser.TraceReader.KeyOnlyTraceReader;
 
 /**
  * A reader for the Gradle Build Cache trace files provided by the Gradle team.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class GradleTraceReader extends TextTraceReader {
+public final class GradleTraceReader extends TextTraceReader implements KeyOnlyTraceReader {
 
   public GradleTraceReader(String filePath) {
     super(filePath);
   }
 
   @Override
-  public LongStream events() throws IOException {
+  public LongStream keys() throws IOException {
     return lines()
         .map(uuid -> new BigInteger(uuid, 16))
         .mapToLong(num -> num.shiftRight(64).longValue() ^ num.longValue());

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/lirs/LirsTraceReader.java
Patch:
@@ -19,20 +19,21 @@
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
+import com.github.benmanes.caffeine.cache.simulator.parser.TraceReader.KeyOnlyTraceReader;
 
 /**
  * A reader for the trace files provided by the authors of the LIRS algorithm.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class LirsTraceReader extends TextTraceReader {
+public final class LirsTraceReader extends TextTraceReader implements KeyOnlyTraceReader {
 
   public LirsTraceReader(String filePath) {
     super(filePath);
   }
 
   @Override
-  public LongStream events() throws IOException {
+  public LongStream keys() throws IOException {
     return lines()
         .filter(line -> !line.isEmpty())
         .filter(line -> !line.equals("*"))

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/snia/cambridge/CambridgeTraceReader.java
Patch:
@@ -19,21 +19,22 @@
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
+import com.github.benmanes.caffeine.cache.simulator.parser.TraceReader.KeyOnlyTraceReader;
 
 /**
  * A reader for the SNIA MSR Cambridge trace files provided by
  * <a href="http://iotta.snia.org/traces/388">SNIA</a>.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class CambridgeTraceReader extends TextTraceReader {
+public final class CambridgeTraceReader extends TextTraceReader implements KeyOnlyTraceReader {
 
   public CambridgeTraceReader(String filePath) {
     super(filePath);
   }
 
   @Override
-  public LongStream events() throws IOException {
+  public LongStream keys() throws IOException {
     return lines()
         .map(line -> line.split(",", 6))
         .mapToLong(array -> Long.parseLong(array[4]));

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/umass/network/YoutubeTraceReader.java
Patch:
@@ -19,6 +19,7 @@
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
+import com.github.benmanes.caffeine.cache.simulator.parser.TraceReader.KeyOnlyTraceReader;
 import com.google.common.hash.Hashing;
 
 /**
@@ -27,14 +28,14 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class YoutubeTraceReader extends TextTraceReader {
+public final class YoutubeTraceReader extends TextTraceReader implements KeyOnlyTraceReader {
 
   public YoutubeTraceReader(String filePath) {
     super(filePath);
   }
 
   @Override
-  public LongStream events() throws IOException {
+  public LongStream keys() throws IOException {
     return lines()
         .map(line -> line.split(" "))
         .filter(array -> array[3].equals("GETVIDEO"))

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/umass/storage/StorageTraceReader.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
+import com.github.benmanes.caffeine.cache.simulator.parser.TraceReader.KeyOnlyTraceReader;
 import com.google.common.math.IntMath;
 
 /**
@@ -28,15 +29,15 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class StorageTraceReader extends TextTraceReader {
+public final class StorageTraceReader extends TextTraceReader implements KeyOnlyTraceReader {
   static final int BLOCK_SIZE = 512;
 
   public StorageTraceReader(String filePath) {
     super(filePath);
   }
 
   @Override
-  public LongStream events() throws IOException {
+  public LongStream keys() throws IOException {
     return lines().flatMapToLong(line -> {
       String[] array = line.split(",", 5);
       if (array.length <= 4) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/wikipedia/WikipediaTraceReader.java
Patch:
@@ -23,6 +23,7 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
+import com.github.benmanes.caffeine.cache.simulator.parser.TraceReader.KeyOnlyTraceReader;
 import com.google.common.hash.Hashing;
 
 /**
@@ -31,7 +32,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class WikipediaTraceReader extends TextTraceReader {
+public final class WikipediaTraceReader extends TextTraceReader implements KeyOnlyTraceReader {
   private static final String[] CONTAINS_FILTER = {"?search=", "&search=", "User+talk", "User_talk",
       "User:", "Talk:", "&diff=", "&action=rollback", "Special:Watchlist"};
   private static final String[] STARTS_WITH_FILTER = {"wiki/Special:Search", "w/query.php",
@@ -44,7 +45,7 @@ public WikipediaTraceReader(String filePath) {
   }
 
   @Override
-  public LongStream events() throws IOException {
+  public LongStream keys() throws IOException {
     return lines()
         .map(this::parseRequest)
         .filter(Objects::nonNull)

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/adaptive/ArcPolicy.java
Patch:
@@ -21,6 +21,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableSet;
@@ -46,7 +47,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class ArcPolicy implements Policy {
+public final class ArcPolicy implements KeyOnlyPolicy {
   // In Cache:
   // - T1: Pages that have been accessed at least once
   // - T2: Pages that have been accessed at least twice

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/adaptive/CarPolicy.java
Patch:
@@ -21,6 +21,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableSet;
@@ -42,7 +43,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class CarPolicy implements Policy {
+public final class CarPolicy implements KeyOnlyPolicy {
   private final Long2ObjectMap<Node> data;
   private final PolicyStats policyStats;
   private final int maximumSize;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/adaptive/CartPolicy.java
Patch:
@@ -21,6 +21,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableSet;
@@ -43,7 +44,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class CartPolicy implements Policy {
+public final class CartPolicy implements KeyOnlyPolicy {
   private final Long2ObjectMap<Node> data;
   private final PolicyStats policyStats;
   private final int maximumSize;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/ClockProPolicy.java
Patch:
@@ -22,6 +22,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.collect.ImmutableSet;
 import com.typesafe.config.Config;
@@ -50,7 +51,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class ClockProPolicy implements Policy {
+public final class ClockProPolicy implements KeyOnlyPolicy {
   private final Long2ObjectMap<Node> data;
   private final PolicyStats policyStats;
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/FrdPolicy.java
Patch:
@@ -21,6 +21,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableSet;
@@ -47,7 +48,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class FrdPolicy implements Policy {
+public final class FrdPolicy implements KeyOnlyPolicy {
   final Long2ObjectOpenHashMap<Node> data;
   final PolicyStats policyStats;
   final Node headFilter;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/HillClimberFrdPolicy.java
Patch:
@@ -21,6 +21,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableSet;
@@ -34,7 +35,7 @@
  * @author ohadey@gmail.com (Ohad Eytan)
  */
 @SuppressWarnings("PMD.TooManyFields")
-public final class HillClimberFrdPolicy implements Policy {
+public final class HillClimberFrdPolicy implements KeyOnlyPolicy {
   final Long2ObjectOpenHashMap<Node> data;
   final PolicyStats policyStats;
   final Node headFilter;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/IndicatorFrdPolicy.java
Patch:
@@ -21,6 +21,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.Indicator;
 import com.google.common.base.MoreObjects;
@@ -34,7 +35,7 @@
  *
  * @author ohadey@gmail.com (Ohad Eytan)
  */
-public final class IndicatorFrdPolicy implements Policy {
+public final class IndicatorFrdPolicy implements KeyOnlyPolicy {
   final Long2ObjectOpenHashMap<Node> data;
   final PolicyStats policyStats;
   final Indicator indicator;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/LirsPolicy.java
Patch:
@@ -23,6 +23,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableSet;
@@ -54,7 +55,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @SuppressWarnings("PMD.TooManyFields")
-public final class LirsPolicy implements Policy {
+public final class LirsPolicy implements KeyOnlyPolicy {
   final Long2ObjectMap<Node> data;
   final PolicyStats policyStats;
   final List<Object> evicted;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/FrequentlyUsedPolicy.java
Patch:
@@ -27,6 +27,7 @@
 import com.github.benmanes.caffeine.cache.simulator.admission.Admission;
 import com.github.benmanes.caffeine.cache.simulator.admission.Admittor;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.typesafe.config.Config;
@@ -40,7 +41,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class FrequentlyUsedPolicy implements Policy {
+public final class FrequentlyUsedPolicy implements KeyOnlyPolicy {
   final PolicyStats policyStats;
   final Long2ObjectMap<Node> data;
   final EvictionPolicy policy;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/MultiQueuePolicy.java
Patch:
@@ -23,6 +23,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableSet;
@@ -50,7 +51,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class MultiQueuePolicy implements Policy {
+public final class MultiQueuePolicy implements KeyOnlyPolicy {
   private final Long2ObjectSortedMap<Node> out;
   private final Long2ObjectMap<Node> data;
   private final PolicyStats policyStats;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/S4LruPolicy.java
Patch:
@@ -25,6 +25,7 @@
 import com.github.benmanes.caffeine.cache.simulator.admission.Admission;
 import com.github.benmanes.caffeine.cache.simulator.admission.Admittor;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.typesafe.config.Config;
@@ -44,7 +45,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class S4LruPolicy implements Policy {
+public final class S4LruPolicy implements KeyOnlyPolicy {
   private final Long2ObjectMap<Node> data;
   private final PolicyStats policyStats;
   private final Admittor admittor;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/SegmentedLruPolicy.java
Patch:
@@ -24,6 +24,7 @@
 import com.github.benmanes.caffeine.cache.simulator.admission.Admission;
 import com.github.benmanes.caffeine.cache.simulator.admission.Admittor;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.typesafe.config.Config;
@@ -49,7 +50,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class SegmentedLruPolicy implements Policy {
+public final class SegmentedLruPolicy implements KeyOnlyPolicy {
   static final Node UNLINKED = new Node();
 
   final Long2ObjectMap<Node> data;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/opt/ClairvoyantPolicy.java
Patch:
@@ -19,6 +19,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.collect.ImmutableSet;
 import com.typesafe.config.Config;
@@ -37,7 +38,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class ClairvoyantPolicy implements Policy {
+public final class ClairvoyantPolicy implements KeyOnlyPolicy {
   private final Long2ObjectMap<IntPriorityQueue> accessTimes;
   private final LongArrayFIFOQueue future;
   private final PolicyStats policyStats;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/opt/UnboundedPolicy.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.Set;
 
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.collect.ImmutableSet;
 import com.typesafe.config.Config;
@@ -31,7 +32,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class UnboundedPolicy implements Policy {
+public final class UnboundedPolicy implements KeyOnlyPolicy {
   private final PolicyStats policyStats;
   private final LongOpenHashSet data;
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/CollisionPolicy.java
Patch:
@@ -25,6 +25,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.typesafe.config.Config;
 
@@ -36,7 +37,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class CollisionPolicy implements Policy {
+public final class CollisionPolicy implements KeyOnlyPolicy {
   private final CollisionCache<Object, Object> cache;
   private final PolicyStats policyStats;
   private final int maximumSize;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/Ehcache3Policy.java
Patch:
@@ -26,6 +26,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.collect.ImmutableSet;
 import com.typesafe.config.Config;
@@ -35,7 +36,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class Ehcache3Policy implements Policy {
+public final class Ehcache3Policy implements KeyOnlyPolicy {
   private final Cache<Object, Object> cache;
   private final CacheManager cacheManager;
   private final PolicyStats policyStats;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/ExpiringMapPolicy.java
Patch:
@@ -21,6 +21,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.collect.ImmutableSet;
 import com.typesafe.config.Config;
@@ -33,7 +34,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class ExpiringMapPolicy implements Policy {
+public final class ExpiringMapPolicy implements KeyOnlyPolicy {
   private final ExpiringMap<Object, Object> cache;
   private final PolicyStats policyStats;
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/OhcPolicy.java
Patch:
@@ -32,6 +32,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.typesafe.config.Config;
 
@@ -40,7 +41,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class OhcPolicy implements Policy {
+public final class OhcPolicy implements KeyOnlyPolicy {
   private static final long ENTRY_SIZE = 80;
 
   private final OHCache<Long, Long> cache;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/TCachePolicy.java
Patch:
@@ -21,6 +21,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.collect.ImmutableSet;
 import com.trivago.triava.tcache.Cache;
@@ -35,7 +36,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class TCachePolicy implements Policy {
+public final class TCachePolicy implements KeyOnlyPolicy {
   private final Cache<Object, Object> cache;
   private final PolicyStats policyStats;
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sampled/SampledPolicy.java
Patch:
@@ -31,6 +31,7 @@
 import com.github.benmanes.caffeine.cache.simulator.admission.Admission;
 import com.github.benmanes.caffeine.cache.simulator.admission.Admittor;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.typesafe.config.Config;
@@ -50,7 +51,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class SampledPolicy implements Policy {
+public final class SampledPolicy implements KeyOnlyPolicy {
   final Long2ObjectMap<Node> data;
   final PolicyStats policyStats;
   final EvictionPolicy policy;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/WindowTinyLfuPolicy.java
Patch:
@@ -25,6 +25,7 @@
 import com.github.benmanes.caffeine.cache.simulator.admission.Admittor;
 import com.github.benmanes.caffeine.cache.simulator.admission.TinyLfu;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.typesafe.config.Config;
@@ -49,7 +50,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class WindowTinyLfuPolicy implements Policy {
+public final class WindowTinyLfuPolicy implements KeyOnlyPolicy {
   private final Long2ObjectMap<Node> data;
   private final PolicyStats policyStats;
   private final Admittor admittor;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/HillClimberWindowTinyLfuPolicy.java
Patch:
@@ -34,6 +34,7 @@
 import com.github.benmanes.caffeine.cache.simulator.admission.Admittor;
 import com.github.benmanes.caffeine.cache.simulator.admission.TinyLfu;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.climbing.HillClimber.Adaptation;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.climbing.HillClimber.QueueType;
@@ -50,7 +51,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @SuppressWarnings("PMD.TooManyFields")
-public final class HillClimberWindowTinyLfuPolicy implements Policy {
+public final class HillClimberWindowTinyLfuPolicy implements KeyOnlyPolicy {
   private final double initialPercentMain;
   private final HillClimberType strategy;
   private final Long2ObjectMap<Node> data;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/feedback/FeedbackTinyLfuPolicy.java
Patch:
@@ -24,6 +24,7 @@
 import com.github.benmanes.caffeine.cache.simulator.admission.TinyLfu;
 import com.github.benmanes.caffeine.cache.simulator.membership.Membership;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableMap;
@@ -44,7 +45,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class FeedbackTinyLfuPolicy implements Policy {
+public final class FeedbackTinyLfuPolicy implements KeyOnlyPolicy {
   private final Long2ObjectMap<Node> data;
   private final PolicyStats policyStats;
   private final TinyLfu admittor;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/feedback/FeedbackWindowTinyLfuPolicy.java
Patch:
@@ -26,6 +26,7 @@
 import com.github.benmanes.caffeine.cache.simulator.admission.TinyLfu;
 import com.github.benmanes.caffeine.cache.simulator.membership.Membership;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableMap;
@@ -46,7 +47,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @SuppressWarnings("PMD.TooManyFields")
-public final class FeedbackWindowTinyLfuPolicy implements Policy {
+public final class FeedbackWindowTinyLfuPolicy implements KeyOnlyPolicy {
   private final Long2ObjectMap<Node> data;
   private final PolicyStats policyStats;
   private final TinyLfu admittor;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/segment/FullySegmentedWindowTinyLfuPolicy.java
Patch:
@@ -25,6 +25,7 @@
 import com.github.benmanes.caffeine.cache.simulator.admission.Admittor;
 import com.github.benmanes.caffeine.cache.simulator.admission.TinyLfu;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.github.benmanes.caffeine.cache.simulator.policy.linked.SegmentedLruPolicy;
 import com.google.common.base.MoreObjects;
@@ -40,7 +41,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @SuppressWarnings("PMD.TooManyFields")
-public final class FullySegmentedWindowTinyLfuPolicy implements Policy {
+public final class FullySegmentedWindowTinyLfuPolicy implements KeyOnlyPolicy {
   private final Long2ObjectMap<Node> data;
   private final PolicyStats policyStats;
   private final Admittor admittor;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/segment/LruWindowTinyLfuPolicy.java
Patch:
@@ -25,6 +25,7 @@
 import com.github.benmanes.caffeine.cache.simulator.admission.Admittor;
 import com.github.benmanes.caffeine.cache.simulator.admission.TinyLfu;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.typesafe.config.Config;
@@ -38,7 +39,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class LruWindowTinyLfuPolicy implements Policy {
+public final class LruWindowTinyLfuPolicy implements KeyOnlyPolicy {
   private final Long2ObjectMap<Node> data;
   private final PolicyStats policyStats;
   private final Admittor admittor;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/segment/RandomWindowTinyLfuPolicy.java
Patch:
@@ -25,6 +25,7 @@
 import com.github.benmanes.caffeine.cache.simulator.admission.Admittor;
 import com.github.benmanes.caffeine.cache.simulator.admission.TinyLfu;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.typesafe.config.Config;
@@ -37,7 +38,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class RandomWindowTinyLfuPolicy implements Policy {
+public final class RandomWindowTinyLfuPolicy implements KeyOnlyPolicy {
   final Long2ObjectMap<Node> data;
   final PolicyStats policyStats;
   final Admittor admittor;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/segment/S4WindowTinyLfuPolicy.java
Patch:
@@ -26,6 +26,7 @@
 import com.github.benmanes.caffeine.cache.simulator.admission.Admittor;
 import com.github.benmanes.caffeine.cache.simulator.admission.TinyLfu;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.typesafe.config.Config;
@@ -39,7 +40,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class S4WindowTinyLfuPolicy implements Policy {
+public final class S4WindowTinyLfuPolicy implements KeyOnlyPolicy {
   private final Long2ObjectMap<Node> data;
   private final PolicyStats policyStats;
   private final Admittor admittor;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/tinycache/TinyCachePolicy.java
Patch:
@@ -20,14 +20,15 @@
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.tinycache.TinyCache;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.collect.ImmutableSet;
 import com.typesafe.config.Config;
 
 /**
  * @author gilga1983@gmail.com (Gil Einziger)
  */
-public final class TinyCachePolicy implements Policy {
+public final class TinyCachePolicy implements KeyOnlyPolicy {
   private final PolicyStats policyStats;
   private final TinyCache tinyCache;
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/tinycache/TinyCacheWithGhostCachePolicy.java
Patch:
@@ -20,14 +20,15 @@
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.tinycache.TinyCacheWithGhostCache;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.collect.ImmutableSet;
 import com.typesafe.config.Config;
 
 /**
  * @author gilga1983@gmail.com (Gil Einziger)
  */
-public final class TinyCacheWithGhostCachePolicy implements Policy {
+public final class TinyCacheWithGhostCachePolicy implements KeyOnlyPolicy {
   private final TinyCacheWithGhostCache tinyCache;
   private final PolicyStats policyStats;
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/tinycache/WindowTinyCachePolicy.java
Patch:
@@ -21,14 +21,15 @@
 import com.github.benmanes.caffeine.cache.simulator.admission.tinycache.TinyCache;
 import com.github.benmanes.caffeine.cache.simulator.admission.tinycache.TinyCacheWithGhostCache;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.collect.ImmutableSet;
 import com.typesafe.config.Config;
 
 /**
  * @author gilga1983@gmail.com (Gil Einziger)
  */
-public final class WindowTinyCachePolicy implements Policy {
+public final class WindowTinyCachePolicy implements KeyOnlyPolicy {
   private final TinyCache window;
   private final PolicyStats policyStats;
   private final TinyCacheWithGhostCache tinyCache;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/TuQueuePolicy.java
Patch:
@@ -21,6 +21,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableSet;
@@ -52,7 +53,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public class TuQueuePolicy implements Policy {
+public class TuQueuePolicy implements KeyOnlyPolicy {
   private final Long2ObjectMap<Node> data;
   private final PolicyStats policyStats;
   private final int maximumSize;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/TwoQueuePolicy.java
Patch:
@@ -21,6 +21,7 @@
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
+import com.github.benmanes.caffeine.cache.simulator.policy.Policy.KeyOnlyPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.base.MoreObjects;
 import com.google.common.collect.ImmutableSet;
@@ -42,7 +43,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class TwoQueuePolicy implements Policy {
+public final class TwoQueuePolicy implements KeyOnlyPolicy {
   static final Node UNLINKED = new Node();
 
   final Long2ObjectMap<Node> data;

File: caffeine/src/main/java/com/github/benmanes/caffeine/SingleConsumerQueue.java
Patch:
@@ -303,7 +303,9 @@ void append(@NonNull Node<E> first, @NonNull Node<E> last) {
             return;
           }
           Node<E> next = first.getNextRelaxed();
-          if (next.value == null) {
+          if (next == null) {
+            return;
+          } else if (next.value == null) {
             first.next = null; // reduce nepotism
           }
           first = next;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -783,10 +783,11 @@ void expireEntries() {
     expireAfterWriteEntries(now);
     expireVariableEntries(now);
 
-    if (pacer() != null) {
+    Pacer pacer = pacer();
+    if (pacer != null) {
       long delay = getExpirationDelay(now);
       if (delay != Long.MAX_VALUE) {
-        pacer().schedule(executor, drainBuffersTask, now, delay);
+        pacer.schedule(executor, drainBuffersTask, now, delay);
       }
     }
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalLoadingCache.java
Patch:
@@ -56,9 +56,10 @@ interface LocalLoadingCache<K, V> extends LocalManualCache<K, V>, LoadingCache<K
 
   @Override
   default Map<K, V> getAll(Iterable<? extends K> keys) {
-    return (bulkMappingFunction() == null)
+    Function<Iterable<? extends K>, Map<K, V>> mappingFunction = bulkMappingFunction();
+    return (mappingFunction == null)
         ? loadSequentially(keys)
-        : getAll(keys, bulkMappingFunction());
+        : getAll(keys, mappingFunction);
   }
 
   /** Sequentially loads each missing entry. */

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Scheduler.java
Patch:
@@ -66,13 +66,13 @@ public interface Scheduler {
   /**
    * Returns a scheduler that uses the system-wide scheduling thread if available, or else returns
    * {@link #disabledScheduler()} if not present. This scheduler is provided in Java 9 or above
-   * by using {@code CompletableFuture} {@code delayedExecutor}.
+   * by using {@link CompletableFuture} {@code delayedExecutor}.
    *
    * @return a scheduler that uses the system-wide scheduling thread if available, or else a
    *         disabled scheduler
    */
   static @NonNull Scheduler systemScheduler() {
-    return SystemScheduler.isPresent() ? SystemScheduler.INSTANCE : disabledScheduler() ;
+    return SystemScheduler.isPresent() ? SystemScheduler.INSTANCE : disabledScheduler();
   }
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Cache.java
Patch:
@@ -153,7 +153,7 @@ default Map<K, V> getAll(@NonNull Iterable<? extends @NonNull K> keys,
 
   /**
    * Discards any cached value for the {@code key}. The behavior of this operation is undefined for
-   * an entry that is being loaded and is otherwise not present.
+   * an entry that is being loaded (or reloaded) and is otherwise not present.
    *
    * @param key the key whose mapping is to be removed from the cache
    * @throws NullPointerException if the specified key is null
@@ -162,7 +162,7 @@ default Map<K, V> getAll(@NonNull Iterable<? extends @NonNull K> keys,
 
   /**
    * Discards any cached values for the {@code keys}. The behavior of this operation is undefined
-   * for an entry that is being loaded and is otherwise not present.
+   * for an entry that is being loaded (or reloaded) and is otherwise not present.
    *
    * @param keys the keys whose associated values are to be removed
    * @throws NullPointerException if the specified collection is null or contains a null element
@@ -171,7 +171,7 @@ default Map<K, V> getAll(@NonNull Iterable<? extends @NonNull K> keys,
 
   /**
    * Discards all entries in the cache. The behavior of this operation is undefined for an entry
-   * that is being loaded and is otherwise not present.
+   * that is being loaded (or reloaded) and is otherwise not present.
    */
   void invalidateAll();
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -307,7 +307,7 @@ Executor getExecutor() {
   /**
    * Specifies the scheduler to use when scheduling routine maintenance based on an expiration
    * event. This augments the periodic maintenance that occurs during normal cache operations to
-   * allow for the promptly removal of expired entries regardless of whether any cache activity is
+   * allow for the prompt removal of expired entries regardless of whether any cache activity is
    * occurring at that time. By default, {@link Scheduler#disabledScheduler()} is used.
    * <p>
    * The scheduling between expiration events is paced to exploit batching and to minimize

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Scheduler.java
Patch:
@@ -30,11 +30,12 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import org.checkerframework.checker.index.qual.Positive;
 import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
- * A scheduler that submit a task to an executor after a given delay.
+ * A scheduler that submits a task to an executor after a given delay.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
@@ -51,7 +52,7 @@ public interface Scheduler {
    * @return a scheduled future representing pending completion of the task
    */
   @NonNull Future<?> schedule(@NonNull Executor executor,
-      @NonNull Runnable command, long delay, @NonNull TimeUnit unit);
+      @NonNull Runnable command, @Positive long delay, @NonNull TimeUnit unit);
 
   /**
    * Returns a scheduler that always returns a successfully completed future.

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/TimerWheel.java
Patch:
@@ -248,7 +248,7 @@ public long getExpirationDelay() {
         Node<K, V> next = sentinel.getNextInVariableOrder();
         if (sentinel != next) {
           long delay = ((j - start) * SPANS[i]) - (nanos & spanMask);
-          return (delay > 0) ? delay : (next.getVariableTime() - nanos);
+          return (delay > 0) ? delay : SPANS[i];
         }
       }
     }

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheFactoryGenerator.java
Patch:
@@ -50,6 +50,7 @@
 import com.github.benmanes.caffeine.cache.local.AddMaximum;
 import com.github.benmanes.caffeine.cache.local.AddRefreshAfterWrite;
 import com.github.benmanes.caffeine.cache.local.AddRemovalListener;
+import com.github.benmanes.caffeine.cache.local.AddPacer;
 import com.github.benmanes.caffeine.cache.local.AddStats;
 import com.github.benmanes.caffeine.cache.local.AddSubtype;
 import com.github.benmanes.caffeine.cache.local.AddWriteBuffer;
@@ -83,7 +84,7 @@ public final class LocalCacheFactoryGenerator {
       new AddKeyValueStrength(), new AddRemovalListener(), new AddStats(),
       new AddExpirationTicker(), new AddMaximum(), new AddFastPath(), new AddDeques(),
       new AddExpireAfterAccess(), new AddExpireAfterWrite(), new AddRefreshAfterWrite(),
-      new AddWriteBuffer(), new Finalize());
+      new AddWriteBuffer(), new AddPacer(), new Finalize());
   final ZoneId timeZone = ZoneId.of("America/Los_Angeles");
   final Path directory;
 

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/Specifications.java
Patch:
@@ -88,6 +88,7 @@ public final class Specifications {
   public static final TypeName STATS_COUNTER =
       ClassName.get(PACKAGE_NAME + ".stats", "StatsCounter");
   public static final TypeName TICKER = ClassName.get(PACKAGE_NAME, "Ticker");
+  public static final TypeName PACER = ClassName.get(PACKAGE_NAME, "Pacer");
 
   public static final TypeName ACCESS_ORDER_DEQUE =
       ParameterizedTypeName.get(ClassName.get(PACKAGE_NAME, "AccessOrderDeque"), NODE);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/MpscGrowableArrayQueue.java
Patch:
@@ -14,7 +14,7 @@
 package com.github.benmanes.caffeine.cache;
 
 import static com.github.benmanes.caffeine.base.UnsafeAccess.UNSAFE;
-import static com.github.benmanes.caffeine.cache.BoundedLocalCache.ceilingPowerOfTwo;
+import static com.github.benmanes.caffeine.cache.Caffeine.ceilingPowerOfTwo;
 import static com.github.benmanes.caffeine.cache.UnsafeRefArrayAccess.REF_ARRAY_BASE;
 import static com.github.benmanes.caffeine.cache.UnsafeRefArrayAccess.REF_ELEMENT_SHIFT;
 import static com.github.benmanes.caffeine.cache.UnsafeRefArrayAccess.lvElement;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/Ehcache3.java
Patch:
@@ -30,7 +30,7 @@
 public final class Ehcache3<K, V> implements BasicCache<K, V> {
   private final Cache<K, V> cache;
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({"unchecked", "PMD.CloseResource"})
   public Ehcache3(int maximumSize) {
     CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder().build(true);
     cache = (Cache<K, V>) cacheManager.createCache("benchmark",

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/CacheStats.java
Patch:
@@ -354,6 +354,7 @@ public CacheStats plus(@NonNull CacheStats other) {
    * Returns the difference of {@code a} and {@code b} unless it would overflow or underflow in
    * which case {@code Long.MAX_VALUE} or {@code Long.MIN_VALUE} is returned, respectively.
    */
+  @SuppressWarnings("ShortCircuitBoolean")
   private static long saturatedSubtract(long a, long b) {
     long naiveDifference = a - b;
     if ((a ^ b) >= 0 | (a ^ naiveDifference) >= 0) {
@@ -369,6 +370,7 @@ private static long saturatedSubtract(long a, long b) {
    * Returns the sum of {@code a} and {@code b} unless it would overflow or underflow in which case
    * {@code Long.MAX_VALUE} or {@code Long.MIN_VALUE} is returned, respectively.
    */
+  @SuppressWarnings("ShortCircuitBoolean")
   private static long saturatedAdd(long a, long b) {
     long naiveSum = a + b;
     if ((a ^ b) < 0 | (a ^ naiveSum) >= 0) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsyncAsMapTest.java
Patch:
@@ -358,12 +358,12 @@ public void putAll_replace(AsyncCache<Integer, Integer> cache, CacheContext cont
       removalListener = { Listener.DEFAULT, Listener.CONSUMING })
   public void putAll_mixed(AsyncCache<Integer, Integer> cache, CacheContext context) {
     Map<Integer, CompletableFuture<Integer>> entries = new HashMap<>();
-    Map<Integer, CompletableFuture<Integer>> replaced = new HashMap<>();
+    List<Integer> replaced = new ArrayList<>();
     context.original().forEach((key, value) -> {
       if ((key % 2) == 0) {
         value++;
+        replaced.add(key);
         entries.put(key, CompletableFuture.completedFuture(value));
-        replaced.put(key, CompletableFuture.completedFuture(value));
       } else {
         entries.put(key, cache.asMap().get(key));
       }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheGenerator.java
Patch:
@@ -141,7 +141,7 @@ private static <T> Set<T> filterTypes(Optional<T> type, T[] options) {
           ? ImmutableSet.of(type.get())
           : ImmutableSet.of();
     }
-    return ImmutableSet.copyOf(Arrays.asList(options));
+    return ImmutableSet.copyOf(options);
   }
 
   /** Returns a new cache context based on the combination. */

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheManagerImpl.java
Patch:
@@ -25,13 +25,14 @@
 import java.util.Properties;
 import java.util.concurrent.ConcurrentHashMap;
 
-import org.checkerframework.checker.nullness.qual.Nullable;
 import javax.cache.Cache;
 import javax.cache.CacheException;
 import javax.cache.CacheManager;
 import javax.cache.configuration.Configuration;
 import javax.cache.spi.CachingProvider;
 
+import org.checkerframework.checker.nullness.qual.Nullable;
+
 import com.typesafe.config.Config;
 import com.typesafe.config.ConfigFactory;
 
@@ -40,6 +41,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PMD.CloseResource")
 public final class CacheManagerImpl implements CacheManager {
   private final WeakReference<ClassLoader> classLoaderReference;
   private final Map<String, CacheProxy<?, ?>> caches;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/EventDispatcher.java
Patch:
@@ -76,6 +76,7 @@ public Set<Registration<K, V>> registrations() {
    *
    * @param configuration the listener's configuration.
    */
+  @SuppressWarnings("PMD.CloseResource")
   public void register(CacheEntryListenerConfiguration<K, V> configuration) {
     if (configuration.getCacheEntryListenerFactory() == null) {
       return;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/spi/CaffeineCachingProvider.java
Patch:
@@ -102,6 +102,7 @@ public void close() {
   }
 
   @Override
+  @SuppressWarnings("PMD.CloseResource")
   public void close(ClassLoader classLoader) {
     synchronized (cacheManagers) {
       ClassLoader managerClassLoader = getManagerClassLoader(classLoader);
@@ -115,6 +116,7 @@ public void close(ClassLoader classLoader) {
   }
 
   @Override
+  @SuppressWarnings("PMD.CloseResource")
   public void close(URI uri, ClassLoader classLoader) {
     synchronized (cacheManagers) {
       ClassLoader managerClassLoader = getManagerClassLoader(classLoader);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/BinaryTraceReader.java
Patch:
@@ -43,6 +43,7 @@ public BinaryTraceReader(String filePath) {
   }
 
   @Override
+  @SuppressWarnings("PMD.CloseResource")
   public LongStream events() throws IOException {
     DataInputStream input = new DataInputStream(new BufferedInputStream(readFile()));
     LongStream stream = StreamSupport.longStream(Spliterators.spliteratorUnknownSize(

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/TextTraceReader.java
Patch:
@@ -38,6 +38,7 @@ public TextTraceReader(String filePath) {
   }
 
   /** Returns a stream of each line in the trace file. */
+  @SuppressWarnings("PMD.CloseResource")
   protected Stream<String> lines() throws IOException {
     InputStream input = readFile();
     Reader reader = new InputStreamReader(input, UTF_8);

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/Specifications.java
Patch:
@@ -118,7 +118,8 @@ public static String offsetName(String varName) {
   public static FieldSpec newFieldOffset(String className, String varName) {
     String fieldName = CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, varName);
     return FieldSpec
-        .builder(long.class, offsetName(varName), Modifier.PROTECTED, Modifier.STATIC, Modifier.FINAL)
+        .builder(long.class, offsetName(varName),
+            Modifier.PROTECTED, Modifier.STATIC, Modifier.FINAL)
         .initializer("$T.objectFieldOffset($T.class, $L.$L)", UNSAFE_ACCESS,
             ClassName.bestGuess(className),  LOCAL_CACHE_FACTORY, fieldName)
         .build();

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AccessOrderDeque.java
Patch:
@@ -82,8 +82,8 @@ public void setNext(E e, @Nullable E next) {
   interface AccessOrder<T extends AccessOrder<T>> {
 
     /**
-     * Retrieves the previous element or <tt>null</tt> if either the element is unlinked or the first
-     * element on the deque.
+     * Retrieves the previous element or <tt>null</tt> if either the element is unlinked or the
+     * first element on the deque.
      */
     @Nullable T getPreviousInAccessOrder();
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/WriteOrderDeque.java
Patch:
@@ -82,8 +82,8 @@ public void setNext(E e, @Nullable E next) {
   interface WriteOrder<T extends WriteOrder<T>> {
 
     /**
-     * Retrieves the previous element or <tt>null</tt> if either the element is unlinked or the first
-     * element on the deque.
+     * Retrieves the previous element or <tt>null</tt> if either the element is unlinked or the
+     * first element on the deque.
      */
     @Nullable T getPreviousInWriteOrder();
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterVarTest.java
Patch:
@@ -77,6 +77,7 @@
 public final class ExpireAfterVarTest {
 
   @Test(dataProvider = "caches")
+  @SuppressWarnings("deprecation")
   @CacheSpec(expiryTime = Expire.FOREVER,
       expiry = { CacheExpiry.CREATE, CacheExpiry.WRITE, CacheExpiry.ACCESS })
   public void expiry_bounds(Cache<Integer, Integer> cache, CacheContext context) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsCacheReserializable.java
Patch:
@@ -131,7 +131,8 @@ private static <K, V> void checkIfUnbounded(
     }
   }
 
-  private static <K, V> void checkUnboundedLocalManualCache(UnboundedLocalManualCache<K, V> original,
+  private static <K, V> void checkUnboundedLocalManualCache(
+      UnboundedLocalManualCache<K, V> original,
       UnboundedLocalManualCache<K, V> copy, DescriptionBuilder desc) {
     checkUnboundedLocalCache(original.cache, copy.cache, desc);
   }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/RefreshAfterWriteTest.java
Patch:
@@ -388,7 +388,8 @@ public void ageOf(CacheContext context,
     context.ticker().advance(30, TimeUnit.SECONDS);
     assertThat(refreshAfterWrite.ageOf(context.firstKey(), TimeUnit.SECONDS).getAsLong(), is(30L));
     context.ticker().advance(45, TimeUnit.SECONDS);
-    assertThat(refreshAfterWrite.ageOf(context.firstKey(), TimeUnit.SECONDS).isPresent(), is(false));
+    assertThat(refreshAfterWrite.ageOf(
+        context.firstKey(), TimeUnit.SECONDS).isPresent(), is(false));
   }
 
   /* --------------- Policy: oldest --------------- */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContext.java
Patch:
@@ -190,7 +190,7 @@ public void cleanUp() {
   }
 
   public void clear() {
-    CacheSpec.interner.remove();
+    CacheSpec.interner.get().clear();
     initialSize();
     original.clear();
     absent = null;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheGenerator.java
Patch:
@@ -246,7 +246,7 @@ private void populate(CacheContext context, Cache<Integer, Integer> cache) {
   }
 
   /** Returns a cache of integers and their negation. */
-  @SuppressWarnings("BoxedPrimitiveConstructor")
+  @SuppressWarnings({"BoxedPrimitiveConstructor", "deprecation"})
   private static List<Entry<Integer, Integer>> makeInts() {
     int size = Stream.of(CacheSpec.Population.values())
         .mapToInt(population -> Math.toIntExact(population.size()))

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/DescriptionBuilder.java
Patch:
@@ -40,7 +40,8 @@ public DescriptionBuilder(Description description) {
     this.matches = true;
   }
 
-  public <T> DescriptionBuilder expectThat(Supplier<String> reason, T actual, Matcher<? super T> matcher) {
+  public <T> DescriptionBuilder expectThat(
+      Supplier<String> reason, T actual, Matcher<? super T> matcher) {
     if (!matcher.matches(actual)) {
       addError(reason.get(), actual, matcher);
     }

File: guava/src/test/java/com/github/benmanes/caffeine/guava/OSGiTest.java
Patch:
@@ -49,6 +49,7 @@ public Option[] config() {
         junitBundles(),
         bundle("file:" + System.getProperty("caffeine.osgi.jar")),
         bundle("file:" + System.getProperty("caffeine-guava.osgi.jar")),
+        mavenBundle("com.google.guava", "failureaccess", "1.0.1"),
         mavenBundle("com.google.guava", "guava", System.getProperty("guava.osgi.version")));
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/AbstractClimber.java
Patch:
@@ -53,7 +53,8 @@ public void onHit(long key, QueueType queueType, boolean isFull) {
   }
 
   @Override
-  public Adaptation adapt(double windowSize, double probationSize, double protectedSize, boolean isFull) {
+  public Adaptation adapt(double windowSize, double probationSize,
+      double protectedSize, boolean isFull) {
     if (!isFull) {
       return Adaptation.hold();
     }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1596,10 +1596,10 @@ final class AddTask implements Runnable {
     @SuppressWarnings("FutureReturnValueIgnored")
     public void run() {
       if (evicts()) {
-        node.setPolicyWeight(weight);
         long weightedSize = weightedSize();
         setWeightedSize(weightedSize + weight);
         setWindowWeightedSize(windowWeightedSize() + weight);
+        node.setPolicyWeight(node.getPolicyWeight() + weight);
 
         long maximum = maximum();
         if (weightedSize >= (maximum >>> 1)) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidBoundedLocalCache.java
Patch:
@@ -213,8 +213,9 @@ private long scanLinks(BoundedLocalCache<K, V> cache, Set<Node<K, V>> seen,
     for (Node<K, V> node : deque) {
       Supplier<String> errorMsg = () -> String.format(
           "Loop detected: %s, saw %s in %s", node, seen, cache);
-      desc.expectThat("wrong previous", deque.getPrevious(node), is(prev));
       desc.expectThat(errorMsg, seen.add(node), is(true));
+      desc.expectThat("wrong previous", deque.getPrevious(node), is(prev));
+      desc.expectThat("policyWeight != weight", node.getPolicyWeight(), is(node.getWeight()));
       weightedSize += node.getWeight();
       prev = node;
     }

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheFactoryGenerator.java
Patch:
@@ -76,8 +76,8 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 public final class LocalCacheFactoryGenerator {
-  final Feature[] featureByIndex = new Feature[] {null, null, Feature.LISTENING,
-      Feature.STATS, Feature.MAXIMUM_SIZE, Feature.MAXIMUM_WEIGHT, Feature.EXPIRE_ACCESS,
+  final Feature[] featureByIndex = { null, null, Feature.LISTENING, Feature.STATS,
+      Feature.MAXIMUM_SIZE, Feature.MAXIMUM_WEIGHT, Feature.EXPIRE_ACCESS,
       Feature.EXPIRE_WRITE, Feature.REFRESH_WRITE};
   final List<LocalCacheRule> rules = ImmutableList.of(new AddSubtype(), new AddConstructor(),
       new AddKeyValueStrength(), new AddRemovalListener(), new AddStats(),

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeFactoryGenerator.java
Patch:
@@ -99,9 +99,8 @@ public final class NodeFactoryGenerator {
   final List<NodeRule> rules = ImmutableList.of(new AddSubtype(), new AddConstructors(),
       new AddKey(), new AddValue(), new AddMaximum(), new AddExpiration(), new AddDeques(),
       new AddFactoryMethods(),  new AddHealth(), new Finalize());
-  final Feature[] featureByIndex = new Feature[] { null, null,
-      Feature.EXPIRE_ACCESS, Feature.EXPIRE_WRITE, Feature.REFRESH_WRITE,
-      Feature.MAXIMUM_SIZE, Feature.MAXIMUM_WEIGHT };
+  final Feature[] featureByIndex = { null, null, Feature.EXPIRE_ACCESS, Feature.EXPIRE_WRITE,
+      Feature.REFRESH_WRITE, Feature.MAXIMUM_SIZE, Feature.MAXIMUM_WEIGHT };
   final ZoneId timeZone = ZoneId.of("America/Los_Angeles");
   final Path directory;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Cache.java
Patch:
@@ -24,6 +24,7 @@
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.cache.stats.CacheStats;
+import com.google.errorprone.annotations.CompatibleWith;
 
 /**
  * A semi-persistent mapping from keys to values. Cache entries are manually added using
@@ -49,7 +50,7 @@ public interface Cache<K, V> {
    * @throws NullPointerException if the specified key is null
    */
   @Nullable
-  V getIfPresent(@NonNull Object key);
+  V getIfPresent(@NonNull @CompatibleWith("K") Object key);
 
   /**
    * Returns the value associated with the {@code key} in this cache, obtaining that value from the
@@ -126,7 +127,7 @@ public interface Cache<K, V> {
    * @param key the key whose mapping is to be removed from the cache
    * @throws NullPointerException if the specified key is null
    */
-  void invalidate(@NonNull Object key);
+  void invalidate(@NonNull @CompatibleWith("K") Object key);
 
   /**
    * Discards any cached values for the {@code keys}. The behavior of this operation is undefined

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/FrequencySketch.java
Patch:
@@ -52,7 +52,7 @@ final class FrequencySketch<E> {
    * https://dl.acm.org/citation.cfm?id=3149371
    */
 
-  static final long[] SEED = new long[] { // A mixture of seeds from FNV-1a, CityHash, and Murmur3
+  static final long[] SEED = { // A mixture of seeds from FNV-1a, CityHash, and Murmur3
       0xc3a5c85c97cb3127L, 0xb492b66fbe98f273L, 0x9ae16a3b2f90404fL, 0xcbf29ce484222325L};
   static final long RESET_MASK = 0x7777777777777777L;
   static final long ONE_MASK = 0x1111111111111111L;
@@ -190,7 +190,7 @@ void reset() {
    */
   int indexOf(int item, int i) {
     long hash = SEED[i] * item;
-    hash += hash >> 32;
+    hash += hash >>> 32;
     return ((int) hash) & tableMask;
   }
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheProxy.java
Patch:
@@ -839,7 +839,9 @@ public CaffeineConfiguration<K, V> getConfiguration() {
       case DELETED:
         statistics.recordRemovals(1L);
         publishToCacheWriter(writer::delete, entry::getKey);
-        dispatcher.publishRemoved(this, entry.getKey(), entry.getValue());
+        if (expirable != null) {
+          dispatcher.publishRemoved(this, entry.getKey(), expirable.get());
+        }
         return null;
     }
     throw new IllegalStateException("Unknown state: " + entry.getAction());

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/event/JCacheEntryEventTest.java
Patch:
@@ -34,7 +34,7 @@ public final class JCacheEntryEventTest {
   @SuppressWarnings("unchecked")
   Cache<Integer, Integer> cache = Mockito.mock(Cache.class);
   JCacheEntryEvent<Integer, Integer> event = new JCacheEntryEvent<>(
-      cache, EventType.CREATED, 1, 2, 3);
+      cache, EventType.CREATED, 1, true, 2, 3);
 
   @Test(expectedExceptions = IllegalArgumentException.class)
   public void unwrap_fail() {
@@ -49,7 +49,7 @@ public void unwrap() {
   @Test
   public void isOldValueAvailable_false() {
     JCacheEntryEvent<Integer, Integer> e =
-        new JCacheEntryEvent<>(cache, EventType.CREATED, 1, null, 3);
+        new JCacheEntryEvent<>(cache, EventType.CREATED, 1, false, null, 3);
     assertThat(e.isOldValueAvailable(), is(false));
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/CountMin4.java
Patch:
@@ -29,7 +29,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 public abstract class CountMin4 implements Frequency {
-  static final long[] SEED = new long[] { // A mixture of seeds from FNV-1a, CityHash, and Murmur3
+  static final long[] SEED = { // A mixture of seeds from FNV-1a, CityHash, and Murmur3
       0xc3a5c85c97cb3127L, 0xb492b66fbe98f273L, 0x9ae16a3b2f90404fL, 0xcbf29ce484222325L};
   static final long RESET_MASK = 0x7777777777777777L;
 
@@ -184,7 +184,7 @@ boolean incrementAt(int i, int j, long step) {
    */
   int indexOf(int item, int i) {
     long hash = SEED[i] * item;
-    hash += hash >> 32;
+    hash += hash >>> 32;
     return ((int) hash) & tableMask;
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/AbstractTraceReader.java
Patch:
@@ -45,7 +45,7 @@ public AbstractTraceReader(String filePath) {
   }
 
   /** Returns the input stream of the trace data. */
-  protected InputStream readFiles() throws IOException {
+  protected InputStream readFile() throws IOException {
     BufferedInputStream input = new BufferedInputStream(openFile(), BUFFER_SIZE);
     input.mark(100);
     try {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/BinaryTraceReader.java
Patch:
@@ -44,7 +44,7 @@ public BinaryTraceReader(String filePath) {
 
   @Override
   public LongStream events() throws IOException {
-    DataInputStream input = new DataInputStream(new BufferedInputStream(readFiles()));
+    DataInputStream input = new DataInputStream(new BufferedInputStream(readFile()));
     LongStream stream = StreamSupport.longStream(Spliterators.spliteratorUnknownSize(
         new TraceIterator(input), Spliterator.ORDERED), /* parallel */ false);
     return stream.onClose(() -> Closeables.closeQuietly(input));

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/TextTraceReader.java
Patch:
@@ -39,7 +39,7 @@ public TextTraceReader(String filePath) {
 
   /** Returns a stream of each line in the trace file. */
   protected Stream<String> lines() throws IOException {
-    InputStream input = readFiles();
+    InputStream input = readFile();
     Reader reader = new InputStreamReader(input, UTF_8);
     return new BufferedReader(reader).lines().map(String::trim)
         .onClose(() -> Closeables.closeQuietly(input));

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/CsvReporter.java
Patch:
@@ -41,7 +41,7 @@ protected String assemble(List<PolicyStats> results) {
     CsvWriter writer = new CsvWriter(output, new CsvWriterSettings());
     writer.writeHeaders(headers());
     for (PolicyStats policyStats : results) {
-      Object[] data = new Object[] {
+      Object[] data = {
           policyStats.name(),
           String.format("%.2f", 100 * policyStats.hitRate()),
           policyStats.hitCount(),

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -923,7 +923,7 @@ boolean evictEntry(Node<K, V> node, RemovalCause cause, long now) {
     }
 
     if (removed[0]) {
-      statsCounter().recordEviction(node.getWeight());
+      statsCounter().recordEviction(node.getWeight(), actualCause[0]);
       if (hasRemovalListener()) {
         // Notify the listener only if the entry was evicted. This must be performed as the last
         // step during eviction to safe guard against the executor rejecting the notification task.
@@ -2387,7 +2387,7 @@ public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
       if (hasRemovalListener()) {
         notifyRemoval(nodeKey[0], oldValue[0], cause[0]);
       }
-      statsCounter().recordEviction(weight[0]);
+      statsCounter().recordEviction(weight[0], cause[0]);
     }
     if (newValue[0] == null) {
       if (!isComputingAsync(node)) {
@@ -2556,7 +2556,7 @@ public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
 
     if (cause[0] != null) {
       if (cause[0].wasEvicted()) {
-        statsCounter().recordEviction(weight[0]);
+        statsCounter().recordEviction(weight[0], cause[0]);
       }
       if (hasRemovalListener()) {
         notifyRemoval(nodeKey[0], oldValue[0], cause[0]);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CaffeineTest.java
Patch:
@@ -639,8 +639,8 @@ public void recordStats() {
   public void recordStats_custom() {
     Supplier<StatsCounter> supplier = () -> statsCounter;
     Caffeine<?, ?> builder = Caffeine.newBuilder().recordStats(supplier);
-    builder.statsCounterSupplier.get().recordEviction(1);
-    verify(statsCounter).recordEviction(1);
+    builder.statsCounterSupplier.get().recordEviction(1, RemovalCause.SIZE);
+    verify(statsCounter).recordEviction(1, RemovalCause.SIZE);
     builder.build();
   }
 

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/ConcurrentHashMapV7.java
Patch:
@@ -114,7 +114,7 @@
  * @param <V> the type of mapped values
  */
 @SuppressWarnings({"all", "unchecked", "rawtypes", "serial",
-  "JdkObsolete", "UnnecessaryParentheses"})
+  "JdkObsolete", "UnnecessaryParentheses", "UnusedNestedClass", "UnusedVariable"})
 public class ConcurrentHashMapV7<K, V> extends AbstractMap<K, V>
         implements ConcurrentMap<K, V>, Serializable {
     private static final long serialVersionUID = 7249069246763182397L;

File: caffeine/src/main/java/com/github/benmanes/caffeine/SingleConsumerQueue.java
Patch:
@@ -442,6 +442,7 @@ Object writeReplace() {
     return new SerializationProxy<>(this);
   }
 
+  @SuppressWarnings("UnusedVariable")
   private void readObject(ObjectInputStream stream) throws InvalidObjectException {
     throw new InvalidObjectException("Proxy required");
   }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ReferenceTest.java
Patch:
@@ -604,6 +604,7 @@ public void containsKey(Map<Integer, Integer> map, CacheContext context) {
   }
 
   @Test(dataProvider = "caches")
+  @SuppressWarnings("UnusedVariable")
   @CacheSpec(requiresWeakOrSoft = true, expireAfterAccess = Expire.DISABLED,
       expireAfterWrite = Expire.DISABLED, maximumSize = Maximum.DISABLED,
       weigher = CacheWeigher.DEFAULT, population = Population.FULL, stats = Stats.ENABLED,

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/HashClashTest.java
Patch:
@@ -50,7 +50,7 @@ public final class HashClashTest {
 
   @Test(dataProvider = "caches")
   @CacheSpec(population = Population.EMPTY, maximumSize = Maximum.ONE_FIFTY, stats = Stats.ENABLED)
-  private void testCache(Cache<Long, Long> cache, CacheContext context) {
+  public void testCache(Cache<Long, Long> cache, CacheContext context) {
     for (long j = 0; j < 300; ++j) {
       cache.get(1L, Function.identity());
       cache.get(j, Function.identity());

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/issues/Issue298Test.java
Patch:
@@ -86,6 +86,7 @@ public void after() {
   }
 
   @Test
+  @SuppressWarnings("FutureReturnValueIgnored")
   public void readDuringCreate() {
     // Loaded value and waiting at expireAfterCreate (expire: infinite)
     cache.get(key);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/stats/CacheStatsTest.java
Patch:
@@ -100,6 +100,7 @@ private static void checkStats(CacheStats stats, long requestCount, long hitCoun
     assertThat(stats.loadSuccessCount(), is(loadSuccessCount));
     assertThat(stats.loadFailureCount(), is(loadFailureCount));
     assertThat(stats.loadFailureRate(), is(loadExceptionRate));
+    assertThat(stats.loadCount(), is(loadCount));
     assertThat(stats.totalLoadTime(), is(totalLoadTime));
     assertThat(stats.averageLoadPenalty(), is(averageLoadPenalty));
     assertThat(stats.evictionCount(), is(evictionCount));

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java
Patch:
@@ -369,6 +369,7 @@ protected ConcurrentMap<K, V> delegate() {
           return cache.asMap();
         }
 
+        @SuppressWarnings("UnusedVariable")
         private void readObject(ObjectInputStream stream) throws InvalidObjectException {
           statsCounter = new SimpleStatsCounter();
         }

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/IsEmptyIterable.java
Patch:
@@ -110,7 +110,7 @@ private void checkNoSuchElementException(String label,
       DescriptionBuilder builder, Runnable method) {
     try {
       method.run();
-      builder.expected("element");
+      builder.expected(label);
     } catch (NoSuchElementException e) {}
   }
 

File: guava/src/test/java/com/google/common/cache/CacheLoadingTest.java
Patch:
@@ -86,6 +86,7 @@ private void checkNothingLogged() {
     assertTrue(logHandler.getStoredLogRecords().isEmpty());
   }
 
+  @SuppressWarnings("UnusedVariable")
   private void checkLoggedCause(Throwable t) {
     //assertSame(t, popLoggedThrowable().getCause());
   }

File: guava/src/test/java/com/google/common/cache/LocalLoadingCacheTest.java
Patch:
@@ -127,7 +127,7 @@ public void testStats() {
     assertEquals(3.0/4, stats.missRate());
     assertEquals(3, stats.loadCount());
     assertTrue(stats.totalLoadTime() >= totalLoadTime);
-    totalLoadTime = stats.totalLoadTime();
+    stats.totalLoadTime();
     assertTrue(stats.averageLoadPenalty() >= 0.0);
     assertEquals(1, stats.evictionCount());
   }

File: simulator/src/test/java/com/github/benmanes/caffeine/cache/simulator/admission/bloom/MembershipTest.java
Patch:
@@ -54,7 +54,7 @@ public void bloomFilterTest(FilterType filterType) {
       Membership filter = filterType.create(expectedInsertions, FPP, CONFIG);
       int falsePositives = falsePositives(filter, input);
       double falsePositiveRate = ((double) falsePositives / expectedInsertions);
-      assertThat(filterType.toString(), falsePositiveRate, is(lessThan(FPP + 0.01)));
+      assertThat(filterType.toString(), falsePositiveRate, is(lessThan(FPP + 0.2)));
       rows.add(row(filterType, expectedInsertions, falsePositives, falsePositiveRate));
 
       if (display) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncLoadingCache.java
Patch:
@@ -318,7 +318,7 @@ public void refresh(K key) {
             }
             discard[0] = true;
             return currentValue;
-          }, /* recordMiss */ false, /* recordLoad */ false);
+          }, /* recordMiss */ false, /* recordLoad */ false, /* recordLoadFailure */ true);
 
           if (discard[0] && asyncCache.cache().hasRemovalListener()) {
             asyncCache.cache().notifyRemoval(key, refreshFuture, RemovalCause.REPLACED);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalLoadingCache.java
Patch:
@@ -186,7 +186,7 @@ default void refresh(K key) {
         }
         discard[0] = true;
         return currentValue;
-      }, /* recordMiss */ false, /* recordLoad */ false);
+      }, /* recordMiss */ false, /* recordLoad */ false, /* recordLoadFailure */ true);
 
       if (discard[0] && cache().hasRemovalListener()) {
         cache().notifyRemoval(key, newValue, RemovalCause.REPLACED);

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheProxy.java
Patch:
@@ -767,7 +767,7 @@ public CaffeineConfiguration<K, V> getConfiguration() {
         statistics.recordMisses(1L);
         value = null;
       } else {
-        value = expirable.get();
+        value = copyValue(expirable);
         statistics.recordHits(1L);
       }
       EntryProcessorEntry<K, V> entry = new EntryProcessorEntry<>(key, value,

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/FrequencySketch.java
Patch:
@@ -47,7 +47,7 @@ final class FrequencySketch<E> {
    * inexpensive bit manipulations per array location.
    *
    * [1] An Improved Data Stream Summary: The Count-Min Sketch and its Applications
-   * https://dimacs.rutgers.edu/~graham/pubs/papers/cm-full.pdf
+   * http://dimacs.rutgers.edu/~graham/pubs/papers/cm-full.pdf
    * [2] TinyLFU: A Highly Efficient Cache Admission Policy
    * https://dl.acm.org/citation.cfm?id=3149371
    */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/BasicSettings.java
Patch:
@@ -183,8 +183,7 @@ public List<String> paths() {
       return config().getStringList("files.paths");
     }
     public TraceFormat format() {
-      String format = config().getString("files.format").replace('-', '_').toUpperCase(US);
-      return TraceFormat.valueOf(format);
+      return TraceFormat.named(config().getString("files.format"));
     }
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/BinaryTraceReader.java
Patch:
@@ -22,7 +22,6 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.UncheckedIOException;
-import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.PrimitiveIterator;
 import java.util.Spliterator;
@@ -39,8 +38,8 @@
  */
 public abstract class BinaryTraceReader extends AbstractTraceReader {
 
-  public BinaryTraceReader(List<String> filePaths) {
-    super(filePaths);
+  public BinaryTraceReader(String filePath) {
+    super(filePath);
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/TextTraceReader.java
Patch:
@@ -22,7 +22,6 @@
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
-import java.util.List;
 import java.util.stream.Stream;
 
 import com.google.common.io.Closeables;
@@ -34,8 +33,8 @@
  */
 public abstract class TextTraceReader extends AbstractTraceReader implements TraceReader {
 
-  public TextTraceReader(List<String> filePaths) {
-    super(filePaths);
+  public TextTraceReader(String filePath) {
+    super(filePath);
   }
 
   /** Returns a stream of each line in the trace file. */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/address/AddressTraceReader.java
Patch:
@@ -16,7 +16,6 @@
 package com.github.benmanes.caffeine.cache.simulator.parser.address;
 
 import java.io.IOException;
-import java.util.List;
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
@@ -29,8 +28,8 @@
  */
 public final class AddressTraceReader extends TextTraceReader {
 
-  public AddressTraceReader(List<String> filePaths) {
-    super(filePaths);
+  public AddressTraceReader(String filePath) {
+    super(filePath);
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/arc/ArcTraceReader.java
Patch:
@@ -16,7 +16,6 @@
 package com.github.benmanes.caffeine.cache.simulator.parser.arc;
 
 import java.io.IOException;
-import java.util.List;
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
@@ -29,8 +28,8 @@
  */
 public final class ArcTraceReader extends TextTraceReader {
 
-  public ArcTraceReader(List<String> filePaths) {
-    super(filePaths);
+  public ArcTraceReader(String filePath) {
+    super(filePath);
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/cache2k/Cache2kTraceReader.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.io.DataInputStream;
 import java.io.IOException;
-import java.util.List;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.BinaryTraceReader;
 
@@ -29,8 +28,8 @@
  */
 public final class Cache2kTraceReader extends BinaryTraceReader {
 
-  public Cache2kTraceReader(List<String> filePaths) {
-    super(filePaths);
+  public Cache2kTraceReader(String filePath) {
+    super(filePath);
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/gradle/GradleTraceReader.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.io.IOException;
 import java.math.BigInteger;
-import java.util.List;
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
@@ -29,8 +28,8 @@
  */
 public final class GradleTraceReader extends TextTraceReader {
 
-  public GradleTraceReader(List<String> filePaths) {
-    super(filePaths);
+  public GradleTraceReader(String filePath) {
+    super(filePath);
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/lirs/LirsTraceReader.java
Patch:
@@ -16,7 +16,6 @@
 package com.github.benmanes.caffeine.cache.simulator.parser.lirs;
 
 import java.io.IOException;
-import java.util.List;
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
@@ -28,8 +27,8 @@
  */
 public final class LirsTraceReader extends TextTraceReader {
 
-  public LirsTraceReader(List<String> filePaths) {
-    super(filePaths);
+  public LirsTraceReader(String filePath) {
+    super(filePath);
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/scarab/ScarabTraceReader.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.io.DataInputStream;
 import java.io.IOException;
-import java.util.List;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.BinaryTraceReader;
 
@@ -29,8 +28,8 @@
  */
 public final class ScarabTraceReader extends BinaryTraceReader {
 
-  public ScarabTraceReader(List<String> filePaths) {
-    super(filePaths);
+  public ScarabTraceReader(String filePath) {
+    super(filePath);
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/umass/network/YoutubeTraceReader.java
Patch:
@@ -16,7 +16,6 @@
 package com.github.benmanes.caffeine.cache.simulator.parser.umass.network;
 
 import java.io.IOException;
-import java.util.List;
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
@@ -30,8 +29,8 @@
  */
 public final class YoutubeTraceReader extends TextTraceReader {
 
-  public YoutubeTraceReader(List<String> filePaths) {
-    super(filePaths);
+  public YoutubeTraceReader(String filePath) {
+    super(filePath);
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/umass/storage/StorageTraceReader.java
Patch:
@@ -17,7 +17,6 @@
 
 import java.io.IOException;
 import java.math.RoundingMode;
-import java.util.List;
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
@@ -32,8 +31,8 @@
 public final class StorageTraceReader extends TextTraceReader {
   static final int BLOCK_SIZE = 512;
 
-  public StorageTraceReader(List<String> filePaths) {
-    super(filePaths);
+  public StorageTraceReader(String filePath) {
+    super(filePath);
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/AbstractClimber.java
Patch:
@@ -69,7 +69,7 @@ public Adaptation adapt(double windowSize, double probationSize, double protecte
     resetSample(hitRate);
 
     if (debug) {
-      System.out.printf("%.2f\t%.2f%n", windowSize, 100 * hitRate);
+      System.out.printf("%.2f\t%.2f%n", 100 * hitRate, windowSize);
     }
     return adaption;
   }

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheFactoryGenerator.java
Patch:
@@ -89,6 +89,7 @@ public final class LocalCacheFactoryGenerator {
 
   private final List<TypeSpec> factoryTypes;
 
+  @SuppressWarnings("NullAway.Init")
   public LocalCacheFactoryGenerator(Path directory) {
     this.directory = requireNonNull(directory);
     this.factoryTypes = new ArrayList<>();

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeFactoryGenerator.java
Patch:
@@ -107,6 +107,7 @@ public final class NodeFactoryGenerator {
 
   private final List<TypeSpec> nodeTypes;
 
+  @SuppressWarnings("NullAway.Init")
   public NodeFactoryGenerator(Path directory) {
     this.directory = requireNonNull(directory);
     this.nodeTypes = new ArrayList<>();

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/local/LocalCacheRule.java
Patch:
@@ -23,6 +23,9 @@
 public abstract class LocalCacheRule implements Consumer<LocalCacheContext> {
   protected LocalCacheContext context;
 
+  @SuppressWarnings({"NullAway.Init", "PMD.UnnecessaryConstructor"})
+  public LocalCacheRule() {}
+
   @Override
   public void accept(LocalCacheContext context) {
     this.context = context;

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/NodeContext.java
Patch:
@@ -41,6 +41,7 @@ public final class NodeContext {
   public MethodSpec.Builder constructorByKeyRef;
   public MethodSpec. Builder constructorDefault;
 
+  @SuppressWarnings("NullAway.Init")
   public NodeContext(TypeName superClass, String className, boolean isFinal,
       Set<Feature> parentFeatures, Set<Feature> generateFeatures) {
     this.isFinal = isFinal;

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/NodeRule.java
Patch:
@@ -42,6 +42,9 @@
 public abstract class NodeRule implements Consumer<NodeContext> {
   protected NodeContext context;
 
+  @SuppressWarnings("NullAway.Init")
+  public NodeRule() {}
+
   @Override
   public final void accept(NodeContext context) {
     this.context = context;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/gradient/Adam.java
Patch:
@@ -18,6 +18,7 @@
 import java.util.List;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
+import com.github.benmanes.caffeine.cache.simulator.policy.sketch.climbing.AbstractClimber;
 import com.typesafe.config.Config;
 
 /**
@@ -27,7 +28,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class Adam extends GradientDescent {
+public final class Adam extends AbstractClimber {
   private final int stepSize;
   private final double beta1;
   private final double beta2;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/gradient/Stochastic.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.List;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
+import com.github.benmanes.caffeine.cache.simulator.policy.sketch.climbing.AbstractClimber;
 import com.typesafe.config.Config;
 
 /**
@@ -42,7 +43,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class Stochastic extends GradientDescent {
+public final class Stochastic extends AbstractClimber {
   private final Acceleration acceleration;
   private final int stepSize;
   private final double beta;
@@ -72,7 +73,7 @@ protected double adjust(double hitRate) {
       case NESTEROV:
         // http://cs231n.github.io/neural-networks-3/#sgd
         double previousVelocity = velocity;
-        velocity = (beta * velocity) + (1 - beta) * gradient;
+        velocity = (beta * velocity) + stepSize * gradient;
         return -(beta * previousVelocity) + ((1 + beta) * velocity);
     }
     throw new IllegalStateException("Unknown acceleration type: " + acceleration);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/Indicator.java
Patch:
@@ -16,7 +16,6 @@
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch;
 
 import java.util.Arrays;
-import java.util.List;
 import java.util.stream.IntStream;
 
 import org.apache.commons.math3.stat.regression.SimpleRegression;
@@ -144,12 +143,13 @@ public IndicatorSettings(Config config) {
       super(config);
     }
 
+    @SuppressWarnings("PMD.ShortMethodName")
     public int k() {
       return config().getInt("indicator.k");
     }
 
     public int ssSize() {
       return config().getInt("indicator.ss-size");
-    }  
+    }
   }
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/MiniSimClimber.java
Patch:
@@ -15,13 +15,11 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.policy.sketch.climbing;
 
-import java.nio.charset.Charset;
 import java.util.List;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.WindowTinyLfuPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.WindowTinyLfuPolicy.WindowTinyLfuSettings;
-import com.github.benmanes.caffeine.cache.simulator.policy.sketch.climbing.HillClimberWindowTinyLfuPolicy.HillClimberWindowTinyLfuSettings;
 import com.google.common.hash.Hashing;
 import com.typesafe.config.Config;
 import com.typesafe.config.ConfigFactory;
@@ -101,7 +99,7 @@ public Adaptation adapt(int windowSize, int protectedSize) {
     }
     return Adaptation.HOLD;
   }
-  
+
   static final class MiniSimSettings extends BasicSettings {
     public MiniSimSettings(Config config) {
       super(config);

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/DelegationBenchmark.java
Patch:
@@ -37,7 +37,7 @@ public class DelegationBenchmark {
   private static final int MASK = SIZE - 1;
 
   final Map<Integer, Integer> inherit = new InheritMap();
-  final Map<Integer, Integer> delegate = new DelgateMap();
+  final Map<Integer, Integer> delegate = new DelegateMap();
 
   @Setup
   public void setup() {
@@ -72,7 +72,7 @@ public Integer get(Object key) {
     }
   }
 
-  static final class DelgateMap extends ForwardingMap<Integer, Integer> {
+  static final class DelegateMap extends ForwardingMap<Integer, Integer> {
     final Map<Integer, Integer> delegate = new ConcurrentHashMap<>();
 
     @Override

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedBuffer.java
Patch:
@@ -30,7 +30,7 @@
  */
 final class BoundedBuffer<E> extends StripedBuffer<E> {
   /*
-   * A circular ring buffer stores the elements being transfered by the producers to the consumer.
+   * A circular ring buffer stores the elements being transferred by the producers to the consumer.
    * The monotonically increasing count of reads and writes allow indexing sequentially to the next
    * element location based upon a power-of-two sizing.
    *

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterVarTest.java
Patch:
@@ -301,7 +301,7 @@ public void put_insert_expiryFails(Cache<Integer, Integer> cache, CacheContext c
   @CacheSpec(implementation = Implementation.Caffeine, expiryTime = Expire.ONE_MINUTE,
       population = Population.FULL, expiry = CacheExpiry.MOCKITO)
   @Test(dataProvider = "caches", expectedExceptions = ExpirationException.class)
-  public void put_insert_replaceExpred_expiryFails(Cache<Integer, Integer> cache,
+  public void put_insert_replaceExpired_expiryFails(Cache<Integer, Integer> cache,
       CacheContext context, VarExpiration<Integer, Integer> expireVariably) {
     OptionalLong duration = expireVariably.getExpiresAfter(context.firstKey(), NANOSECONDS);
     try {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/FrequencySketchTest.java
Patch:
@@ -33,7 +33,7 @@ public final class FrequencySketchTest {
   final Integer item = ThreadLocalRandom.current().nextInt();
 
   @Test
-  public void construc() {
+  public void construct() {
     FrequencySketch<Integer> sketch = new FrequencySketch<>();
     assertThat(sketch.table, is(nullValue()));
   }

File: guava/src/test/java/com/google/common/cache/CacheBuilderGwtTest.java
Patch:
@@ -104,7 +104,7 @@ public void testSizeConstraint() {
     cache.put(5, 50);
 
     assertEquals(null, cache.getIfPresent(10));
-    // Order required to remove dependence on acces order / write order constraint.
+    // Order required to remove dependence on access order / write order constraint.
     assertEquals(Integer.valueOf(10), cache.getIfPresent(1));
     assertEquals(Integer.valueOf(20), cache.getIfPresent(2));
     assertEquals(Integer.valueOf(30), cache.getIfPresent(3));

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/HashedItem.java
Patch:
@@ -18,7 +18,7 @@
 /**
  * This is a wrapper class that represents a parsed hashed item. It contains set - a subtable for
  * the item. chain - a logical index within the set. fingerprint - a value to be stored in the set
- * and chain. This implementation assues fingerprints of 1 byte. .
+ * and chain. This implementation assumes fingerprints of 1 byte. .
  *
  * @author gilga1983@gmail.com (Gil Einziger)
  */
@@ -28,11 +28,11 @@ final class HashedItem {
   byte fingerprint;
   long value;
 
-  public HashedItem(int set, byte chainId, byte fingerprit, long value) {
+  public HashedItem(int set, byte chainId, byte fingerprint, long value) {
     this.set = set;
     this.value = value;
     this.chainId = chainId;
-    this.fingerprint = fingerprit;
+    this.fingerprint = fingerprint;
   }
 
   @Override

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/CollisionPolicy.java
Patch:
@@ -112,7 +112,7 @@ public boolean strictCapacity() {
     }
     public Stream<Density> density() {
       return config().getStringList("collision.density").stream()
-          .map(denity -> Density.valueOf(denity.toUpperCase(US)));
+          .map(density -> Density.valueOf(density.toUpperCase(US)));
     }
   }
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sampled/SampledPolicy.java
Patch:
@@ -42,7 +42,7 @@
  * A cache that uses a sampled array of entries to implement simple page replacement algorithms.
  * <p>
  * The sampling approach for an approximate of classical policies is described
- * <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.110.8469">Effient Randomized Web
+ * <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.110.8469">Efficient Randomized Web
  * Cache Replacement Schemes Using Samples from Past Eviction Times</a>. The Hyperbolic algorithm is
  * a newer addition to this family and is described in
  * <a href="https://www.usenix.org/system/files/conference/atc17/atc17-blankstein.pdf">Hyperbolic

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/HillClimberWindowTinyLfuPolicy.java
Patch:
@@ -366,5 +366,6 @@ public Set<HillClimberType> strategy() {
           .map(HillClimberType::valueOf)
           .collect(toSet());
     }
+
   }
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/HillClimberFrdPolicy.java
Patch:
@@ -1,5 +1,5 @@
 /*
- * Copyright 2017 Ben Manes. All Rights Reserved.
+ * Copyright 2018 Ben Manes and Ohad Eytan. All Rights Reserved.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -66,7 +66,7 @@ public HillClimberFrdPolicy(Config config) {
     this.headFilter = new Node();
     this.headMain = new Node();
 
-    this.sampleSize = (int) (10 * settings.maximumSize());
+    this.sampleSize = 10 * settings.maximumSize();
     this.pivot = (int) (0.05 * settings.maximumSize());
     this.tolerance = 100d * 0;
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/IndicatorClimber.java
Patch:
@@ -50,6 +50,6 @@ public Adaptation adapt(int windowSize, int protectedSize) {
       }
       return new Adaptation(Adaptation.Type.DECREASE_WINDOW, (int) ((oldPercent - newPercent) * cacheSize));
     }
-    return new Adaptation(Adaptation.Type.HOLD, 0);
+    return Adaptation.HOLD;
   }
 }
\ No newline at end of file

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/SimpleClimber.java
Patch:
@@ -100,7 +100,7 @@ public double percentSample() {
       return config().getDouble(BASE_PATH + "percent-sample");
     }
     public double tolerance() {
-      return config().getInt(BASE_PATH + "tolerance");
+      return config().getDouble(BASE_PATH + "tolerance");
     }
   }
 }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -553,7 +553,7 @@ public Caffeine<K, V> expireAfterWrite(@NonNull Duration duration) {
   public Caffeine<K, V> expireAfterWrite(@NonNegative long duration, @NonNull TimeUnit unit) {
     requireState(expireAfterWriteNanos == UNSET_INT,
         "expireAfterWrite was already set to %s ns", expireAfterWriteNanos);
-    requireState(expiry == null, "expireAfterAccess may not be used with variable expiration");
+    requireState(expiry == null, "expireAfterWrite may not be used with variable expiration");
     requireArgument(duration >= 0, "duration cannot be negative: %s %s", duration, unit);
     this.expireAfterWriteNanos = unit.toNanos(duration);
     return this;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncCacheLoader.java
Patch:
@@ -69,8 +69,8 @@ public interface AsyncCacheLoader<K, V> {
    *         that key; <b>may not contain null values</b>
    */
   @NonNull
-  default CompletableFuture<Map<K, V>> asyncLoadAll(
-      @NonNull Iterable<? extends K> keys, @NonNull Executor executor) {
+  default CompletableFuture<Map<@NonNull K, @NonNull V>> asyncLoadAll(
+      @NonNull Iterable<? extends @NonNull K> keys, @NonNull Executor executor) {
     throw new UnsupportedOperationException();
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncLoadingCache.java
Patch:
@@ -79,7 +79,7 @@ public interface AsyncLoadingCache<K, V> extends AsyncCache<K, V> {
    *         future, in which case the mapping is left unestablished
    */
   @NonNull
-  CompletableFuture<Map<K, V>> getAll(@NonNull Iterable<? extends K> keys);
+  CompletableFuture<Map<K, V>> getAll(@NonNull Iterable<? extends @NonNull K> keys);
 
   /**
    * Returns a view of the entries stored in this cache as a synchronous {@link LoadingCache}. A

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheLoader.java
Patch:
@@ -83,7 +83,8 @@ public interface CacheLoader<K, V> extends AsyncCacheLoader<K, V> {
    *         caught, the thread's interrupt status is set
    */
   @NonNull
-  default Map<K, V> loadAll(@NonNull Iterable<? extends K> keys) throws Exception {
+  default Map<@NonNull K, @NonNull V> loadAll(
+      @NonNull Iterable<? extends @NonNull K> keys) throws Exception {
     throw new UnsupportedOperationException();
   }
 
@@ -128,7 +129,7 @@ default CompletableFuture<V> asyncLoad(@NonNull K key, @NonNull Executor executo
    *         that key; <b>may not contain null values</b>
    */
   @Override @NonNull
-  default CompletableFuture<Map<K, V>> asyncLoadAll(
+  default CompletableFuture<Map<@NonNull K, @NonNull V>> asyncLoadAll(
       @NonNull Iterable<? extends K> keys, @NonNull Executor executor) {
     requireNonNull(keys);
     requireNonNull(executor);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CaffeineSpec.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.Objects;
 import java.util.concurrent.TimeUnit;
 
+import org.checkerframework.checker.nullness.qual.NonNull;
 import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.cache.Caffeine.Strength;
@@ -145,7 +146,7 @@ Caffeine<Object, Object> toBuilder() {
    * @return the parsed specification
    */
   @SuppressWarnings("StringSplitter")
-  public static CaffeineSpec parse(String specification) {
+  public static @NonNull CaffeineSpec parse(@NonNull String specification) {
     CaffeineSpec spec = new CaffeineSpec(specification);
     for (String option : specification.split(SPLIT_OPTIONS)) {
       spec.parseOption(option.trim());

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/FrequencySketch.java
Patch:
@@ -19,6 +19,7 @@
 
 import java.util.concurrent.ThreadLocalRandom;
 
+import org.checkerframework.checker.index.qual.NonNegative;
 import org.checkerframework.checker.nullness.qual.NonNull;
 
 /**
@@ -87,7 +88,7 @@ public FrequencySketch() {
    *
    * @param maximumSize the maximum size of the cache
    */
-  public void ensureCapacity(long maximumSize) {
+  public void ensureCapacity(@NonNegative long maximumSize) {
     requireArgument(maximumSize >= 0);
     int maximum = (int) Math.min(maximumSize, Integer.MAX_VALUE >>> 1);
     if ((table != null) && (table.length >= maximum)) {
@@ -117,6 +118,7 @@ public boolean isNotInitialized() {
    * @param e the element to count occurrences of
    * @return the estimated number of occurrences of the element; possibly zero but never negative
    */
+  @NonNegative
   public int frequency(@NonNull E e) {
     if (isNotInitialized()) {
       return 0;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LoadingCache.java
Patch:
@@ -89,7 +89,7 @@ public interface LoadingCache<K, V> extends Cache<K, V> {
    *         is left unestablished
    */
   @NonNull
-  Map<K, V> getAll(@NonNull Iterable<? extends K> keys);
+  Map<@NonNull K, @NonNull V> getAll(@NonNull Iterable<? extends @NonNull K> keys);
 
   /**
    * Loads a new value for the {@code key}, asynchronously. While the new value is loading the

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Weigher.java
Patch:
@@ -19,6 +19,7 @@
 
 import java.io.Serializable;
 
+import org.checkerframework.checker.index.qual.NonNegative;
 import org.checkerframework.checker.nullness.qual.NonNull;
 
 /**
@@ -40,6 +41,7 @@ public interface Weigher<K, V> {
    * @param value the value to weigh
    * @return the weight of the entry; must be non-negative
    */
+  @NonNegative
   int weigh(@NonNull K key, @NonNull V value);
 
   /**

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheFactoryGenerator.java
Patch:
@@ -35,9 +35,10 @@
 import java.util.Set;
 import java.util.TreeMap;
 
-import javax.annotation.Nullable;
 import javax.lang.model.element.Modifier;
 
+import org.checkerframework.checker.nullness.qual.Nullable;
+
 import com.github.benmanes.caffeine.cache.local.AddConstructor;
 import com.github.benmanes.caffeine.cache.local.AddDeques;
 import com.github.benmanes.caffeine.cache.local.AddExpirationTicker;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/GetPutBenchmark.java
Patch:
@@ -59,7 +59,6 @@ public class GetPutBenchmark {
     "ExpiringMap_Lru",
     "TCache_Lfu",
     "TCache_Lru",
-    "Rapidoid",
   })
   CacheType cacheType;
 

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/TimerWheelBenchmark.java
Patch:
@@ -19,8 +19,7 @@
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.TimeUnit;
 
-import javax.annotation.Nullable;
-
+import org.checkerframework.checker.nullness.qual.Nullable;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.Scope;
 import org.openjdk.jmh.annotations.Setup;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/LinkedHashMapCache.java
Patch:
@@ -18,8 +18,6 @@
 import java.util.LinkedHashMap;
 import java.util.Map;
 
-import javax.annotation.concurrent.NotThreadSafe;
-
 import com.github.benmanes.caffeine.cache.BasicCache;
 
 /**
@@ -53,7 +51,6 @@ public void clear() {
     }
   }
 
-  @NotThreadSafe
   static final class BoundedLinkedHashMap<K, V> extends LinkedHashMap<K, V> {
     private static final long serialVersionUID = 1L;
     private final int maximumSize;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AbstractLinkedDeque.java
Patch:
@@ -19,8 +19,7 @@
 import java.util.Collection;
 import java.util.NoSuchElementException;
 
-import javax.annotation.Nullable;
-import javax.annotation.concurrent.NotThreadSafe;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class provides a skeletal implementation of the {@link LinkedDeque} interface to minimize
@@ -29,7 +28,6 @@
  * @author ben.manes@gmail.com (Ben Manes)
  * @param <E> the type of elements held in this collection
  */
-@NotThreadSafe
 abstract class AbstractLinkedDeque<E> extends AbstractCollection<E> implements LinkedDeque<E> {
 
   // This class provides a doubly-linked list that is optimized for the virtual machine. The first

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AccessOrderDeque.java
Patch:
@@ -17,8 +17,7 @@
 
 import java.util.Deque;
 
-import javax.annotation.Nullable;
-import javax.annotation.concurrent.NotThreadSafe;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.cache.AccessOrderDeque.AccessOrder;
 
@@ -28,7 +27,6 @@
  * @author ben.manes@gmail.com (Ben Manes)
  * @param <E> the type of elements held in this collection
  */
-@NotThreadSafe
 final class AccessOrderDeque<E extends AccessOrder<E>> extends AbstractLinkedDeque<E> {
 
   @Override

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Async.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Static utility methods and classes pertaining to asynchronous operations.

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Buffer.java
Patch:
@@ -17,7 +17,7 @@
 
 import java.util.function.Consumer;
 
-import javax.annotation.Nonnull;
+import org.checkerframework.checker.nullness.qual.NonNull;
 
 /**
  * A multiple-producer / single-consumer buffer that rejects new elements if it is full or
@@ -50,15 +50,15 @@ static <E> Buffer<E> disabled() {
    * @param e the element to add
    * @return {@code 1} if the buffer is full, {@code -1} if the CAS failed, or {@code 0} if added
    */
-  int offer(@Nonnull E e);
+  int offer(@NonNull E e);
 
   /**
    * Drains the buffer, sending each element to the consumer for processing. The caller must ensure
    * that a consumer has exclusive read access to the buffer.
    *
    * @param consumer the action to perform on each element
    */
-  void drainTo(@Nonnull Consumer<E> consumer);
+  void drainTo(@NonNull Consumer<E> consumer);
 
   /**
    * Returns the number of elements residing in the buffer.

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CaffeineSpec.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.Objects;
 import java.util.concurrent.TimeUnit;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.cache.Caffeine.Strength;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LinkedDeque.java
Patch:
@@ -20,8 +20,7 @@
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 
-import javax.annotation.Nullable;
-import javax.annotation.concurrent.NotThreadSafe;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A linked list extension of the {@link Deque} interface where the link pointers are tightly
@@ -45,7 +44,6 @@
  * @author ben.manes@gmail.com (Ben Manes)
  * @param <E> the type of elements held in this collection
  */
-@NotThreadSafe
 interface LinkedDeque<E> extends Deque<E> {
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncLoadingCache.java
Patch:
@@ -32,7 +32,7 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class provides a skeletal implementation of the {@link AsyncLoadingCache} interface to

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalLoadingCache.java
Patch:
@@ -29,7 +29,7 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * This class provides a skeletal implementation of the {@link LoadingCache} interface to minimize

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalManualCache.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.function.Function;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.cache.stats.CacheStats;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/SerializationProxy.java
Patch:
@@ -20,7 +20,7 @@
 import java.io.Serializable;
 import java.util.concurrent.TimeUnit;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * Serializes the configuration of the cache, reconsitituting it as a {@link Cache},

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/StripedBuffer.java
Patch:
@@ -24,7 +24,7 @@
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.function.Consumer;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.base.UnsafeAccess;
 
@@ -97,7 +97,7 @@ abstract class StripedBuffer<E> implements Buffer<E> {
   static final int ATTEMPTS = 3;
 
   /** Table of buffers. When non-null, size is a power of 2. */
-  transient volatile @Nullable Buffer<E>[] table;
+  transient volatile Buffer<E> @Nullable[] table;
 
   /** Spinlock (locked via CAS) used when resizing and/or creating Buffers. */
   transient volatile int tableBusy;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/TimerWheel.java
Patch:
@@ -28,8 +28,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.function.Function;
 
-import javax.annotation.Nullable;
-import javax.annotation.concurrent.NotThreadSafe;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 /**
  * A hierarchical timer wheel to add, remove, and fire expiration events in amortized O(1) time. The
@@ -38,7 +37,6 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@NotThreadSafe
 final class TimerWheel<K, V> {
 
   /*

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/UnboundedLocalCache.java
Patch:
@@ -41,7 +41,7 @@
 import java.util.function.Function;
 import java.util.function.Predicate;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.cache.stats.StatsCounter;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/WriteOrderDeque.java
Patch:
@@ -17,8 +17,7 @@
 
 import java.util.Deque;
 
-import javax.annotation.Nullable;
-import javax.annotation.concurrent.NotThreadSafe;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.cache.WriteOrderDeque.WriteOrder;
 
@@ -28,7 +27,6 @@
  * @author ben.manes@gmail.com (Ben Manes)
  * @param <E> the type of elements held in this collection
  */
-@NotThreadSafe
 final class WriteOrderDeque<E extends WriteOrder<E>> extends AbstractLinkedDeque<E> {
 
   @Override

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/RandomSeedEnforcer.java
Patch:
@@ -18,7 +18,7 @@
 import java.lang.reflect.Field;
 import java.util.concurrent.ConcurrentMap;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.base.UnsafeAccess;
 import com.google.common.base.Throwables;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/TimerWheelTest.java
Patch:
@@ -39,8 +39,7 @@
 import java.util.function.Function;
 import java.util.stream.IntStream;
 
-import javax.annotation.Nullable;
-
+import org.checkerframework.checker.nullness.qual.Nullable;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Captor;
 import org.mockito.Mock;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContext.java
Patch:
@@ -32,7 +32,7 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.ThreadLocalRandom;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.cache.AsyncCache;
 import com.github.benmanes.caffeine.cache.AsyncCacheLoader;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/HasRemovalNotifications.java
Patch:
@@ -25,8 +25,7 @@
 import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.TimeUnit;
 
-import javax.annotation.Nullable;
-
+import org.checkerframework.checker.nullness.qual.Nullable;
 import org.hamcrest.Description;
 import org.hamcrest.TypeSafeDiagnosingMatcher;
 

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaCache.java
Patch:
@@ -28,7 +28,7 @@
 import java.util.function.Function;
 import java.util.function.Predicate;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheLoader.InvalidCacheLoadException;

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaLoadingCache.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.Map;
 import java.util.concurrent.ExecutionException;
 
-import javax.annotation.Nonnull;
+import org.checkerframework.checker.nullness.qual.NonNull;
 
 import com.github.benmanes.caffeine.cache.CacheLoader;
 import com.google.common.base.Throwables;
@@ -112,7 +112,7 @@ public ImmutableMap<K, V> getAll(Iterable<? extends K> keys) throws ExecutionExc
 
   @Override
   @SuppressWarnings("NullAway")
-  public V apply(@Nonnull K key) {
+  public V apply(@NonNull K key) {
     return cache.get(key);
   }
 

File: guava/src/test/java/com/google/common/cache/CacheBuilderFactory.java
Patch:
@@ -18,7 +18,7 @@
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.google.common.base.Function;

File: guava/src/test/java/com/google/common/cache/TestingCacheLoaders.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheFactory.java
Patch:
@@ -21,7 +21,7 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 import javax.cache.CacheManager;
 import javax.cache.configuration.CompleteConfiguration;
 import javax.cache.configuration.Configuration;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheManagerImpl.java
Patch:
@@ -25,7 +25,7 @@
 import java.util.Properties;
 import java.util.concurrent.ConcurrentHashMap;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 import javax.cache.Cache;
 import javax.cache.CacheException;
 import javax.cache.CacheManager;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/LoadingCacheProxy.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.concurrent.Executor;
 import java.util.stream.Collectors;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 import javax.cache.Cache;
 import javax.cache.CacheException;
 import javax.cache.CacheManager;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/CaffeineConfiguration.java
Patch:
@@ -23,7 +23,7 @@
 import java.util.concurrent.Executor;
 import java.util.concurrent.ForkJoinPool;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 import javax.cache.configuration.CacheEntryListenerConfiguration;
 import javax.cache.configuration.CompleteConfiguration;
 import javax.cache.configuration.Factory;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/FactoryCreator.java
Patch:
@@ -15,7 +15,7 @@
  */
 package com.github.benmanes.caffeine.jcache.configuration;
 
-import javax.annotation.Nonnull;
+import org.checkerframework.checker.nullness.qual.NonNull;
 import javax.cache.configuration.Factory;
 
 /**
@@ -33,6 +33,6 @@ public interface FactoryCreator {
    * @param <T> the type of the instances being produced
    * @return a {@link Factory} for the specified class
    */
-  @Nonnull
+  @NonNull
   <T> Factory<T> factoryOf(String className);
 }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurator.java
Patch:
@@ -27,7 +27,7 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 import javax.cache.configuration.Factory;
 import javax.cache.configuration.FactoryBuilder;
 import javax.cache.configuration.MutableCacheEntryListenerConfiguration;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/EventDispatcher.java
Patch:
@@ -29,7 +29,7 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 import javax.cache.Cache;
 import javax.cache.configuration.CacheEntryListenerConfiguration;
 import javax.cache.event.CacheEntryEventFilter;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/EventTypeAwareListener.java
Patch:
@@ -22,7 +22,7 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import javax.annotation.Nonnull;
+import org.checkerframework.checker.nullness.qual.NonNull;
 import javax.cache.event.CacheEntryCreatedListener;
 import javax.cache.event.CacheEntryEvent;
 import javax.cache.event.CacheEntryExpiredListener;
@@ -49,7 +49,7 @@ public EventTypeAwareListener(CacheEntryListener<? super K, ? super V> listener)
 
   /** Returns if the backing listener consumes this type of event. */
   @SuppressWarnings("PMD.SwitchStmtsShouldHaveDefault")
-  public boolean isCompatible(@Nonnull EventType eventType) {
+  public boolean isCompatible(@NonNull EventType eventType) {
     switch (eventType) {
       case CREATED:
         return (listener instanceof CacheEntryCreatedListener<?, ?>);
@@ -65,7 +65,7 @@ public boolean isCompatible(@Nonnull EventType eventType) {
 
   /** Processes the event and logs if an exception is thrown. */
   @SuppressWarnings("PMD.SwitchStmtsShouldHaveDefault")
-  public void dispatch(@Nonnull JCacheEntryEvent<K, V> event) {
+  public void dispatch(@NonNull JCacheEntryEvent<K, V> event) {
     try {
       if (event.getSource().isClosed()) {
         return;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/JCacheEntryEvent.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.Iterator;
 import java.util.NoSuchElementException;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 import javax.cache.Cache;
 import javax.cache.event.CacheEntryEvent;
 import javax.cache.event.EventType;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/JCacheEvictionListener.java
Patch:
@@ -17,7 +17,7 @@
 
 import static java.util.Objects.requireNonNull;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 import javax.cache.Cache;
 
 import com.github.benmanes.caffeine.cache.CacheWriter;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/expiry/JCacheExpiryPolicy.java
Patch:
@@ -20,8 +20,8 @@
 import java.io.Serializable;
 import java.util.Objects;
 
-import javax.annotation.Nonnull;
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
 import javax.cache.expiry.Duration;
 import javax.cache.expiry.ExpiryPolicy;
 
@@ -37,7 +37,7 @@ public final class JCacheExpiryPolicy implements ExpiryPolicy, Serializable {
   private final @Nullable Duration update;
   private final @Nullable Duration access;
 
-  public JCacheExpiryPolicy(@Nonnull Duration creation,
+  public JCacheExpiryPolicy(@NonNull Duration creation,
       @Nullable Duration update, @Nullable Duration access) {
     this.creation = requireNonNull(creation);
     this.update = update;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/integration/JCacheLoaderAdapter.java
Patch:
@@ -21,12 +21,13 @@
 import java.util.concurrent.TimeUnit;
 import java.util.stream.Collectors;
 
-import javax.annotation.Nullable;
 import javax.cache.expiry.Duration;
 import javax.cache.expiry.ExpiryPolicy;
 import javax.cache.integration.CacheLoader;
 import javax.cache.integration.CacheLoaderException;
 
+import org.checkerframework.checker.nullness.qual.Nullable;
+
 import com.github.benmanes.caffeine.cache.Ticker;
 import com.github.benmanes.caffeine.jcache.CacheProxy;
 import com.github.benmanes.caffeine.jcache.Expirable;
@@ -68,6 +69,7 @@ public void setCache(CacheProxy<K, V> cache) {
   }
 
   @Override
+  @SuppressWarnings("NullAway")
   public @Nullable Expirable<V> load(K key) {
     try {
       boolean statsEnabled = statistics.isEnabled();

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/processor/EntryProcessorEntry.java
Patch:
@@ -19,7 +19,7 @@
 
 import java.util.Optional;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 import javax.cache.integration.CacheLoader;
 import javax.cache.processor.EntryProcessor;
 import javax.cache.processor.MutableEntry;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/spi/CaffeineCachingProvider.java
Patch:
@@ -24,13 +24,13 @@
 import java.util.Properties;
 import java.util.WeakHashMap;
 
-import javax.annotation.concurrent.GuardedBy;
 import javax.cache.CacheManager;
 import javax.cache.Caching;
 import javax.cache.configuration.OptionalFeature;
 import javax.cache.spi.CachingProvider;
 
 import com.github.benmanes.caffeine.jcache.CacheManagerImpl;
+import com.google.errorprone.annotations.concurrent.GuardedBy;
 
 /**
  * A provider that produces a JCache implementation backed by Caffeine. Typically this provider is

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/AbstractJCacheTest.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 import javax.cache.CacheManager;
 import javax.cache.Caching;
 import javax.cache.integration.CacheLoader;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/AdaptiveResetCountMin4.java
Patch:
@@ -15,8 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.admission.countmin4;
 
-import javax.annotation.Nonnegative;
-
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings.TinyLfuSettings.DoorkeeperSettings;
 import com.github.benmanes.caffeine.cache.simulator.membership.FilterType;
@@ -57,7 +55,7 @@ public AdaptiveResetCountMin4(Config config) {
   }
 
   @Override
-  protected void ensureCapacity(@Nonnegative long maximumSize) {
+  protected void ensureCapacity(long maximumSize) {
     super.ensureCapacity(maximumSize);
     period = (maximumSize == 0) ? 10 : (10 * table.length);
     if (period <= 0) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/PeriodicResetCountMin4.java
Patch:
@@ -15,8 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.admission.countmin4;
 
-import javax.annotation.Nonnegative;
-
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings.TinyLfuSettings.DoorkeeperSettings;
 import com.github.benmanes.caffeine.cache.simulator.membership.FilterType;
@@ -52,7 +50,7 @@ public PeriodicResetCountMin4(Config config) {
   }
 
   @Override
-  protected void ensureCapacity(@Nonnegative long maximumSize) {
+  protected void ensureCapacity(long maximumSize) {
     super.ensureCapacity(maximumSize);
     period = (maximumSize == 0) ? 10 : (10 * table.length);
     if (period <= 0) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/wikipedia/WikipediaTraceReader.java
Patch:
@@ -20,7 +20,7 @@
 import java.util.Objects;
 import java.util.stream.LongStream;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 import org.apache.commons.lang3.StringUtils;
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/Policy.java
Patch:
@@ -15,14 +15,11 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.policy;
 
-import javax.annotation.concurrent.NotThreadSafe;
-
 /**
  * A cache that implements a page replacement policy.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@NotThreadSafe
 public interface Policy {
 
   /** Records that the entry was accessed. */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/Registry.java
Patch:
@@ -49,7 +49,6 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.product.ExpiringMapPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.GuavaPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.OhcPolicy;
-import com.github.benmanes.caffeine.cache.simulator.policy.product.RapidoidPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.TCachePolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.sampled.SampledPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.WindowTinyLfuPolicy;
@@ -173,7 +172,6 @@ private static void registerProduct(Map<String, Function<Config, Set<Policy>>> f
     factories.put("product.Cache2k", Cache2kPolicy::policies);
     factories.put("product.Ehcache3", Ehcache3Policy::policies);
     factories.put("product.Caffeine", CaffeinePolicy::policies);
-    factories.put("product.Rapidoid", RapidoidPolicy::policies);
     factories.put("product.Collision", CollisionPolicy::policies);
     factories.put("product.ExpiringMap", ExpiringMapPolicy::policies);
     factories.put("product.Elasticsearch", ElasticSearchPolicy::policies);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/HillClimberWindowTinyLfuPolicy.java
Patch:
@@ -28,7 +28,7 @@
 import java.util.List;
 import java.util.Set;
 
-import javax.annotation.Nullable;
+import org.checkerframework.checker.nullness.qual.Nullable;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.admission.Admittor;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalLoadingCache.java
Patch:
@@ -37,8 +37,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-interface LocalLoadingCache<C extends LocalCache<K, V>, K, V>
-    extends LocalManualCache<C, K, V>, LoadingCache<K, V> {
+interface LocalLoadingCache<K, V> extends LocalManualCache<K, V>, LoadingCache<K, V> {
   Logger logger = Logger.getLogger(LocalLoadingCache.class.getName());
 
   /** Returns the {@link CacheLoader} used by this cache. */

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalManualCache.java
Patch:
@@ -29,10 +29,10 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-interface LocalManualCache<C extends LocalCache<K, V>, K, V> extends Cache<K, V> {
+interface LocalManualCache<K, V> extends Cache<K, V> {
 
   /** Returns the backing {@link LocalCache} data store. */
-  C cache();
+  LocalCache<K, V> cache();
 
   @Override
   default long estimatedSize() {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContext.java
Patch:
@@ -34,6 +34,7 @@
 
 import javax.annotation.Nullable;
 
+import com.github.benmanes.caffeine.cache.AsyncCache;
 import com.github.benmanes.caffeine.cache.AsyncCacheLoader;
 import com.github.benmanes.caffeine.cache.AsyncLoadingCache;
 import com.github.benmanes.caffeine.cache.Cache;
@@ -103,9 +104,9 @@ public final class CacheContext {
   final boolean isAsyncLoading;
 
   Cache<?, ?> cache;
+  AsyncCache<?, ?> asyncCache;
   Caffeine<Object, Object> caffeine;
   CacheBuilder<Object, Object> guava;
-  AsyncLoadingCache<?, ?> asyncCache;
 
   @Nullable Integer firstKey;
   @Nullable Integer middleKey;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -873,6 +873,7 @@ void refreshIfNeeded(Node<K, V> node, long now) {
         && node.casWriteTime(oldWriteTime, refreshWriteTime)) {
       try {
         CompletableFuture<V> refreshFuture;
+        long startTime = statsTicker().read();
         if (isAsync) {
           @SuppressWarnings("unchecked")
           CompletableFuture<V> future = (CompletableFuture<V>) oldValue;
@@ -892,7 +893,7 @@ void refreshIfNeeded(Node<K, V> node, long now) {
           refreshFuture = refresh;
         }
         refreshFuture.whenComplete((newValue, error) -> {
-          long loadTime = statsTicker().read() - now;
+          long loadTime = statsTicker().read() - startTime;
           if (error != null) {
             logger.log(Level.WARNING, "Exception thrown during refresh", error);
             node.casWriteTime(refreshWriteTime, oldWriteTime);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncLoadingCache.java
Patch:
@@ -298,7 +298,7 @@ public void accept(@Nullable Map<K, V> result, @Nullable Throwable error) {
       } else {
         fillProxies(result);
         addNewEntries(result);
-        cache.statsCounter().recordLoadSuccess(result.size());
+        cache.statsCounter().recordLoadSuccess(loadTime);
       }
     }
 

File: examples/stats-metrics/src/test/java/com/github/benmanes/caffeine/examples/stats/metrics/MetricsStatsCounterTest.java
Patch:
@@ -48,6 +48,6 @@ public void metrics() {
 
     // Statistics can be queried and reported on
     assertThat(cache.stats().hitCount(), is(3L));
-    assertThat(registry.meter("example.hits").getCount(), is(3L));
+    assertThat(registry.counter("example.hits").getCount(), is(3L));
   }
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/HashFunctionParser.java
Patch:
@@ -32,8 +32,8 @@ public final class HashFunctionParser {
   private final static long m = 0xc6a4a7935bd1e995L;
   private final static int r = 47;
 
-  public HashFunctionParser(int nrsets) {
-    this.nrSets = nrsets;
+  public HashFunctionParser(int nrSets) {
+    this.nrSets = nrSets;
     fpaux = new HashedItem(fpMask, fpMask, fpMask, 0L);
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/HashedItem.java
Patch:
@@ -28,10 +28,10 @@ final class HashedItem {
   byte fingerprint;
   long value;
 
-  public HashedItem(int set, byte chainid, byte fingerprit, long value) {
+  public HashedItem(int set, byte chainId, byte fingerprit, long value) {
     this.set = set;
     this.value = value;
-    this.chainId = chainid;
+    this.chainId = chainId;
     this.fingerprint = fingerprit;
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/address/AddressTraceReader.java
Patch:
@@ -36,7 +36,7 @@ public AddressTraceReader(List<String> filePaths) {
   @Override
   public LongStream events() throws IOException {
     return lines()
-        .map(line -> line.split(" ")[1])
+        .map(line -> line.split(" ", 3)[1])
         .map(address -> address.substring(2))
         .mapToLong(address -> Long.parseLong(address, 16));
   }

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/EvictionBenchmark.java
Patch:
@@ -39,7 +39,6 @@ public class EvictionBenchmark {
   @Param({
     "LinkedHashMap_Lru",
     "Caffeine",
-    "Ehcache2_Lru",
     "Ehcache3",
   })
   CacheType cacheType;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/GetPutBenchmark.java
Patch:
@@ -54,7 +54,6 @@ public class GetPutBenchmark {
     "ElasticSearch",
     "Jackrabbit",
     "Cache2k",
-    "Ehcache2_Lru",
     "Ehcache3",
     "ExpiringMap_Fifo",
     "ExpiringMap_Lru",

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/BasicSettings.java
Patch:
@@ -247,6 +247,9 @@ public final class ZipfianSettings {
       public int items() {
         return config().getInt("synthetic.zipfian.items");
       }
+      public double constant() {
+        return config().getDouble("synthetic.zipfian.constant");
+      }
     }
   }
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/Registry.java
Patch:
@@ -44,7 +44,6 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.product.Cache2kPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.CaffeinePolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.CollisionPolicy;
-import com.github.benmanes.caffeine.cache.simulator.policy.product.Ehcache2Policy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.Ehcache3Policy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.ElasticSearchPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.ExpiringMapPolicy;
@@ -166,7 +165,6 @@ private static void registerProduct(Map<String, Function<Config, Set<Policy>>> f
     factories.put("product.Guava", GuavaPolicy::policies);
     factories.put("product.Tcache", TCachePolicy::policies);
     factories.put("product.Cache2k", Cache2kPolicy::policies);
-    factories.put("product.Ehcache2", Ehcache2Policy::policies);
     factories.put("product.Ehcache3", Ehcache3Policy::policies);
     factories.put("product.Caffeine", CaffeinePolicy::policies);
     factories.put("product.Rapidoid", RapidoidPolicy::policies);

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/FactoryBenchmark.java
Patch:
@@ -53,7 +53,7 @@ public Alpha methodHandle_invokeExact(ThreadState state) {
   }
 
   @Benchmark
-  public Alpha reflectionFactory(ThreadState state) {
+  public Alpha reflection(ThreadState state) {
     return reflectionFactory.newInstance(state.i++);
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -3248,6 +3248,7 @@ final class BoundedVarExpiration implements VarExpiration<K, V> {
       @Override public void setExpiresAfter(K key, long duration, TimeUnit unit) {
         requireNonNull(key);
         requireNonNull(unit);
+        requireArgument(duration >= 0);
         Object lookupKey = cache.nodeFactory.newLookupKey(key);
         Node<K, V> node = cache.data.get(lookupKey);
         if (node != null) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1229,7 +1229,7 @@ void reorderProbation(Node<K, V> node) {
       }
       demoted.makeMainProbation();
       accessOrderProbationDeque().add(demoted);
-      mainProtectedWeightedSize -= node.getPolicyWeight();
+      mainProtectedWeightedSize -= demoted.getPolicyWeight();
     }
 
     lazySetMainProtectedWeightedSize(mainProtectedWeightedSize);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -139,7 +139,7 @@ public final class Caffeine<K, V> {
   enum Strength { WEAK, SOFT }
   static final int UNSET_INT = -1;
 
-  static final int DEFAULT_INITIAL_CAPACITY = 64;
+  static final int DEFAULT_INITIAL_CAPACITY = 16;
   static final int DEFAULT_EXPIRATION_NANOS = 0;
   static final int DEFAULT_REFRESH_NANOS = 0;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -139,7 +139,7 @@ public final class Caffeine<K, V> {
   enum Strength { WEAK, SOFT }
   static final int UNSET_INT = -1;
 
-  static final int DEFAULT_INITIAL_CAPACITY = 0;
+  static final int DEFAULT_INITIAL_CAPACITY = 64;
   static final int DEFAULT_EXPIRATION_NANOS = 0;
   static final int DEFAULT_REFRESH_NANOS = 0;
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/FrdPolicy.java
Patch:
@@ -129,7 +129,6 @@ private void onFullMiss(Node node) {
 
     Node victim = headFilter.prevFilter;
     victim.removeFrom(StackType.FILTER);
-    victim.moveToTop(StackType.MAIN);
     if (victim.isInMain) {
       victim.status = Status.NON_RESIDENT;
     } else {

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheFactoryGenerator.java
Patch:
@@ -39,6 +39,7 @@
 import java.util.Set;
 import java.util.TreeMap;
 
+import javax.annotation.Nullable;
 import javax.lang.model.element.Modifier;
 
 import com.github.benmanes.caffeine.cache.local.AddConstructor;
@@ -122,7 +123,7 @@ private void addFactoryMethods() {
         .addModifiers(Modifier.STATIC)
         .addCode(LocalCacheSelectorCode.get())
         .addParameter(BUILDER_PARAM)
-        .addParameter(CACHE_LOADER_PARAM)
+        .addParameter(CACHE_LOADER_PARAM.toBuilder().addAnnotation(Nullable.class).build())
         .addParameter(boolean.class, "async")
         .addJavadoc("Returns a cache optimized for this configuration.\n")
         .build());

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/local/AddSubtype.java
Patch:
@@ -40,7 +40,7 @@ protected boolean applies() {
   protected void execute() {
     context.cache.superclass(context.superClass)
         .addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
-            .addMember("value", "{$S, $S}", "unchecked", "MissingOverride")
+            .addMember("value", "{$S, $S, $S}", "unchecked", "MissingOverride", "NullAway")
             .build())
         .addJavadoc(getJavaDoc())
         .addTypeVariable(kTypeVar)

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddSubtype.java
Patch:
@@ -43,8 +43,8 @@ protected boolean applies() {
   protected void execute() {
     context.nodeSubtype = TypeSpec.classBuilder(context.className)
         .addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
-            .addMember("value", "{$S, $S, $S}",
-                "unchecked", "PMD.UnusedFormalParameter", "MissingOverride")
+            .addMember("value", "{$S, $S, $S, $S}",
+                "unchecked", "PMD.UnusedFormalParameter", "MissingOverride", "NullAway")
             .build())
         .addJavadoc(getJavaDoc())
         .addTypeVariable(kTypeVar)

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncLoadingCache.java
Patch:
@@ -21,8 +21,8 @@
 import java.util.function.BiFunction;
 import java.util.function.Function;
 
-import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import javax.annotation.concurrent.ThreadSafe;
 
 /**
@@ -48,7 +48,7 @@ public interface AsyncLoadingCache<K, V> {
    *         or {@code null} if this map contains no mapping for the key
    * @throws NullPointerException if the specified key is null
    */
-  @CheckForNull
+  @Nullable
   CompletableFuture<V> getIfPresent(@Nonnull Object key);
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Cache.java
Patch:
@@ -19,9 +19,9 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.function.Function;
 
-import javax.annotation.CheckForNull;
 import javax.annotation.Nonnegative;
 import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import javax.annotation.concurrent.ThreadSafe;
 
 import com.github.benmanes.caffeine.cache.stats.CacheStats;
@@ -50,7 +50,7 @@ public interface Cache<K, V> {
    *         mapping for the key
    * @throws NullPointerException if the specified key is null
    */
-  @CheckForNull
+  @Nullable
   V getIfPresent(@Nonnull Object key);
 
   /**
@@ -78,7 +78,7 @@ public interface Cache<K, V> {
    * @throws RuntimeException or Error if the mappingFunction does so, in which case the mapping is
    *         left unestablished
    */
-  @CheckForNull
+  @Nullable
   V get(@Nonnull K key, @Nonnull Function<? super K, ? extends V> mappingFunction);
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheLoader.java
Patch:
@@ -22,8 +22,8 @@
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.Executor;
 
-import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import javax.annotation.concurrent.ThreadSafe;
 
 /**
@@ -58,7 +58,7 @@ public interface CacheLoader<K, V> extends AsyncCacheLoader<K, V> {
    *         treated like any other {@code Exception} in all respects except that, when it is
    *         caught, the thread's interrupt status is set
    */
-  @CheckForNull
+  @Nullable
   V load(@Nonnull K key) throws Exception;
 
   /**
@@ -162,7 +162,7 @@ default CompletableFuture<Map<K, V>> asyncLoadAll(
    *         treated like any other {@code Exception} in all respects except that, when it is
    *         caught, the thread's interrupt status is set
    */
-  @CheckForNull
+  @Nullable
   default V reload(@Nonnull K key, @Nonnull V oldValue) throws Exception {
     return load(key);
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheWriter.java
Patch:
@@ -76,5 +76,5 @@ enum DisabledWriter implements CacheWriter<Object, Object> {
   public void write(Object key, Object value) {}
 
   @Override
-  public void delete(Object key, Object value, RemovalCause cause) {}
+  public void delete(Object key, @Nullable Object value, RemovalCause cause) {}
 }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LoadingCache.java
Patch:
@@ -18,8 +18,8 @@
 import java.util.Map;
 import java.util.concurrent.CompletionException;
 
-import javax.annotation.CheckForNull;
 import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import javax.annotation.concurrent.ThreadSafe;
 
 /**
@@ -61,7 +61,7 @@ public interface LoadingCache<K, V> extends Cache<K, V> {
    * @throws RuntimeException or Error if the {@link CacheLoader} does so, in which case the mapping
    *         is left unestablished
    */
-  @CheckForNull
+  @Nullable
   V get(@Nonnull K key);
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalLoadingCache.java
Patch:
@@ -29,6 +29,8 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import javax.annotation.Nullable;
+
 /**
  * This class provides a skeletal implementation of the {@link LoadingCache} interface to minimize
  * the effort required to implement a {@link LocalCache}.
@@ -61,7 +63,7 @@ default boolean hasLoadAll(CacheLoader<? super K, V> loader) {
   }
 
   @Override
-  default V get(K key) {
+  default @Nullable V get(K key) {
     return cache().computeIfAbsent(key, mappingFunction());
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalManualCache.java
Patch:
@@ -50,7 +50,7 @@ default void cleanUp() {
   }
 
   @Override
-  default V get(K key, Function<? super K, ? extends V> mappingFunction) {
+  default @Nullable V get(K key, Function<? super K, ? extends V> mappingFunction) {
     return cache().computeIfAbsent(key, mappingFunction);
   }
 

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaCache.java
Patch:
@@ -60,7 +60,7 @@ public V getIfPresent(Object key) {
   }
 
   @Override
-  @SuppressWarnings({"PMD.PreserveStackTrace", "PMD.ExceptionAsFlowControl"})
+  @SuppressWarnings({"PMD.PreserveStackTrace", "PMD.ExceptionAsFlowControl", "NullAway"})
   public V get(K key, Callable<? extends V> valueLoader) throws ExecutionException {
     requireNonNull(valueLoader);
     try {

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaLoadingCache.java
Patch:
@@ -52,7 +52,7 @@ final class CaffeinatedGuavaLoadingCache<K, V> extends CaffeinatedGuavaCache<K,
   }
 
   @Override
-  @SuppressWarnings("PMD.PreserveStackTrace")
+  @SuppressWarnings({"PMD.PreserveStackTrace", "NullAway"})
   public V get(K key) throws ExecutionException {
     requireNonNull(key);
     try {
@@ -69,7 +69,7 @@ public V get(K key) throws ExecutionException {
   }
 
   @Override
-  @SuppressWarnings({"PMD.PreserveStackTrace", "PMD.AvoidCatchingNPE"})
+  @SuppressWarnings({"PMD.PreserveStackTrace", "PMD.AvoidCatchingNPE", "NullAway"})
   public V getUnchecked(K key) {
     try {
       return cache.get(key);
@@ -111,6 +111,7 @@ public ImmutableMap<K, V> getAll(Iterable<? extends K> keys) throws ExecutionExc
   }
 
   @Override
+  @SuppressWarnings("NullAway")
   public V apply(@Nonnull K key) {
     return cache.get(key);
   }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/LoadingCacheProxy.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.concurrent.Executor;
 import java.util.stream.Collectors;
 
+import javax.annotation.Nullable;
 import javax.cache.Cache;
 import javax.cache.CacheException;
 import javax.cache.CacheManager;
@@ -57,7 +58,7 @@ public LoadingCacheProxy(String name, Executor executor, CacheManager cacheManag
 
   @Override
   @SuppressWarnings("PMD.AvoidCatchingNPE")
-  public V get(K key) {
+  public @Nullable V get(K key) {
     requireNotClosed();
     try {
       return getOrLoad(key);
@@ -72,7 +73,7 @@ public V get(K key) {
 
   /** Retrieves the value from the cache, loading it if necessary. */
   @SuppressWarnings("PMD.AvoidDeeplyNestedIfStmts")
-  private V getOrLoad(K key) {
+  private @Nullable V getOrLoad(K key) {
     boolean statsEnabled = statistics.isEnabled();
     long start = statsEnabled ? ticker.read() : 0L;
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurator.java
Patch:
@@ -208,6 +208,7 @@ private void addMonitoring() {
     }
 
     /** Adds the JCache specification's lazy expiration settings. */
+    @SuppressWarnings("NullAway")
     public void addLazyExpiration() {
       Duration creation = getDurationFor("policy.lazy-expiration.creation");
       Duration update = getDurationFor("policy.lazy-expiration.update");

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/copy/AbstractCopier.java
Patch:
@@ -143,7 +143,7 @@ private static <T> T arrayCopy(T object) {
 
   /** @return a deep copy of the object. */
   private <T> T deepCopy(T object) {
-    @SuppressWarnings("unchecked")
+    @SuppressWarnings({"unchecked", "NullAway"})
     T copy = (T) deepCopyStrategies.get(object.getClass()).apply(object);
     return copy;
   }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/EventDispatcher.java
Patch:
@@ -29,6 +29,7 @@
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
+import javax.annotation.Nullable;
 import javax.cache.Cache;
 import javax.cache.configuration.CacheEntryListenerConfiguration;
 import javax.cache.event.CacheEntryEventFilter;
@@ -199,7 +200,7 @@ public void ignoreSynchronous() {
 
   /** Broadcasts the event to all of the interested listener's dispatch queues. */
   private void publish(Cache<K, V> cache, EventType eventType,
-      K key, V oldValue, V newValue, boolean quiet) {
+      K key, @Nullable V oldValue, @Nullable V newValue, boolean quiet) {
     if (dispatchQueues.isEmpty()) {
       return;
     }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/integration/JCacheLoaderAdapter.java
Patch:
@@ -21,6 +21,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.stream.Collectors;
 
+import javax.annotation.Nullable;
 import javax.cache.expiry.Duration;
 import javax.cache.expiry.ExpiryPolicy;
 import javax.cache.integration.CacheLoader;
@@ -47,6 +48,7 @@ public final class JCacheLoaderAdapter<K, V>
 
   private CacheProxy<K, V> cache;
 
+  @SuppressWarnings("NullAway")
   public JCacheLoaderAdapter(CacheLoader<K, V> delegate, EventDispatcher<K, V> dispatcher,
       ExpiryPolicy expiry, Ticker ticker, JCacheStatisticsMXBean statistics) {
     this.dispatcher = requireNonNull(dispatcher);
@@ -66,7 +68,7 @@ public void setCache(CacheProxy<K, V> cache) {
   }
 
   @Override
-  public Expirable<V> load(K key) {
+  public @Nullable Expirable<V> load(K key) {
     try {
       boolean statsEnabled = statistics.isEnabled();
       long start = statsEnabled ? ticker.read() : 0L;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1864,7 +1864,7 @@ public V replace(K key, V value) {
     K[] nodeKey = (K[]) new Object[1];
     @SuppressWarnings("unchecked")
     V[] oldValue = (V[]) new Object[1];
-    long now[] = new long[1];
+    long[] now = new long[1];
     int weight = weigher.weigh(key, value);
     Node<K, V> node = data.computeIfPresent(nodeFactory.newLookupKey(key), (k, n) -> {
       synchronized (n) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache;
 
+import static java.util.Locale.US;
 import static java.util.Objects.requireNonNull;
 
 import java.lang.ref.SoftReference;
@@ -979,10 +980,10 @@ public String toString() {
       s.append("refreshNanos=").append(refreshNanos).append("ns, ");
     }
     if (keyStrength != null) {
-      s.append("keyStrength=").append(keyStrength.toString().toLowerCase()).append(", ");
+      s.append("keyStrength=").append(keyStrength.toString().toLowerCase(US)).append(", ");
     }
     if (valueStrength != null) {
-      s.append("valueStrength=").append(valueStrength.toString().toLowerCase()).append(", ");
+      s.append("valueStrength=").append(valueStrength.toString().toLowerCase(US)).append(", ");
     }
     if (removalListener != null) {
       s.append("removalListener, ");

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/MpscGrowableArrayQueue.java
Patch:
@@ -210,6 +210,7 @@ public String toString() {
   }
 
   @Override
+  @SuppressWarnings("MissingDefault")
   public boolean offer(final E e) {
     if (null == e) {
       throw new NullPointerException();
@@ -371,7 +372,7 @@ private E[] getNextBuffer(final E[] buffer, final long mask) {
     return nextBuffer;
   }
 
-  private long nextArrayOffset(final long mask) {
+  private static long nextArrayOffset(final long mask) {
     return modifiedCalcElementOffset(mask + 2, Long.MAX_VALUE);
   }
 

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaCache.java
Patch:
@@ -48,7 +48,7 @@
 class CaffeinatedGuavaCache<K, V> implements Cache<K, V>, Serializable {
   static final long serialVersionUID = 1L;
 
-  private final com.github.benmanes.caffeine.cache.Cache<K, V> cache;
+  final com.github.benmanes.caffeine.cache.Cache<K, V> cache;
 
   CaffeinatedGuavaCache(com.github.benmanes.caffeine.cache.Cache<K, V> cache) {
     this.cache = requireNonNull(cache);

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheProxy.java
Patch:
@@ -793,7 +793,7 @@ public <T> T invoke(K key, EntryProcessor<K, V, T> entryProcessor, Object... arg
   }
 
   /** Returns the updated expirable value after performing the post processing actions. */
-  @SuppressWarnings({"fallthrough", "PMD.MissingBreakInSwitch"})
+  @SuppressWarnings({"fallthrough", "PMD.MissingBreakInSwitch", "PMD.SwitchStmtsShouldHaveDefault"})
   private Expirable<V> postProcess(Expirable<V> expirable,
       EntryProcessorEntry<K, V> entry, long currentTimeMS) {
     switch (entry.getAction()) {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/copy/AbstractCopier.java
Patch:
@@ -133,7 +133,7 @@ private boolean isArrayOfImmutableTypes(Class<?> clazz) {
   }
 
   /** @return a shallow copy of the array. */
-  private <T> T arrayCopy(T object) {
+  private static <T> T arrayCopy(T object) {
     int length = Array.getLength(object);
     @SuppressWarnings("unchecked")
     T copy = (T) Array.newInstance(object.getClass().getComponentType(), length);

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/EventTypeAwareListener.java
Patch:
@@ -48,6 +48,7 @@ public EventTypeAwareListener(CacheEntryListener<? super K, ? super V> listener)
   }
 
   /** Returns if the backing listener consumes this type of event. */
+  @SuppressWarnings("PMD.SwitchStmtsShouldHaveDefault")
   public boolean isCompatible(@Nonnull EventType eventType) {
     switch (eventType) {
       case CREATED:
@@ -63,6 +64,7 @@ public boolean isCompatible(@Nonnull EventType eventType) {
   }
 
   /** Processes the event and logs if an exception is thrown. */
+  @SuppressWarnings("PMD.SwitchStmtsShouldHaveDefault")
   public void dispatch(@Nonnull JCacheEntryEvent<K, V> event) {
     try {
       if (event.getSource().isClosed()) {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/EventTypeFilter.java
Patch:
@@ -49,6 +49,7 @@ public boolean evaluate(CacheEntryEvent<? extends K, ? extends V> event) {
     return isCompatible(event) && filter.evaluate(event);
   }
 
+  @SuppressWarnings("PMD.SwitchStmtsShouldHaveDefault")
   private boolean isCompatible(CacheEntryEvent<? extends K, ? extends V> event) {
     switch (event.getEventType()) {
       case CREATED:

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/processor/EntryProcessorEntry.java
Patch:
@@ -84,7 +84,7 @@ public void remove() {
   public void setValue(V value) {
     requireNonNull(value);
     if (action != Action.CREATED) {
-      action = (exists() && hasEntry) ? Action.UPDATED : Action.CREATED;
+      action = (hasEntry && exists()) ? Action.UPDATED : Action.CREATED;
     }
     this.value = value;
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/Synthetic.java
Patch:
@@ -15,6 +15,8 @@
  */
 package com.github.benmanes.caffeine.cache.simulator;
 
+import static java.util.Locale.US;
+
 import java.util.stream.LongStream;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings.SyntheticSettings.HotspotSettings;
@@ -40,7 +42,7 @@ private Synthetic() {}
   /** Returns a sequence of events based on the setting's distribution. */
   public static LongStream generate(BasicSettings settings) {
     int events = settings.synthetic().events();
-    switch (settings.synthetic().distribution().toLowerCase()) {
+    switch (settings.synthetic().distribution().toLowerCase(US)) {
       case "counter":
         return counter(settings.synthetic().counter().start(), events);
       case "exponential":

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/TextTraceReader.java
Patch:
@@ -15,12 +15,13 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.parser;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
-import java.nio.charset.StandardCharsets;
 import java.util.List;
 import java.util.stream.Stream;
 
@@ -40,7 +41,7 @@ public TextTraceReader(List<String> filePaths) {
   /** Returns a stream of each line in the trace file. */
   protected Stream<String> lines() throws IOException {
     InputStream input = readFiles();
-    Reader reader = new InputStreamReader(input, StandardCharsets.UTF_8);
+    Reader reader = new InputStreamReader(input, UTF_8);
     return new BufferedReader(reader).lines().map(String::trim)
         .onClose(() -> Closeables.closeQuietly(input));
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/Registry.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.policy;
 
+import static java.util.Locale.US;
 import static java.util.Objects.requireNonNull;
 import static java.util.stream.Collectors.toMap;
 import static java.util.stream.Collectors.toSet;
@@ -87,7 +88,7 @@ private static Map<String, Function<Config, Set<Policy>>> makeRegistry() {
     registerTwoQueue(factories);
     registerAdaptive(factories);
     return factories.entrySet().stream().collect(
-        toMap(entry -> entry.getKey().toLowerCase(), Entry::getValue));
+        toMap(entry -> entry.getKey().toLowerCase(US), Entry::getValue));
   }
 
   /** Returns all of the policies that have been configured for simulation. */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/FrequentlyUsedPolicy.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.policy.linked;
 
+import static java.util.Locale.US;
 import static java.util.Objects.requireNonNull;
 import static java.util.stream.Collectors.toSet;
 
@@ -158,7 +159,7 @@ public enum EvictionPolicy {
     LFU, MFU;
 
     public String label() {
-      return StringUtils.capitalize(name().toLowerCase());
+      return StringUtils.capitalize(name().toLowerCase(US));
     }
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/LinkedPolicy.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.policy.linked;
 
+import static java.util.Locale.US;
 import static java.util.Objects.requireNonNull;
 import static java.util.stream.Collectors.toSet;
 
@@ -172,7 +173,7 @@ public enum EvictionPolicy {
     };
 
     public String label() {
-      return StringUtils.capitalize(name().toLowerCase());
+      return StringUtils.capitalize(name().toLowerCase(US));
     }
 
     /** Performs any operations required by the policy after a node was successfully retrieved. */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/CollisionPolicy.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.policy.product;
 
+import static java.util.Locale.US;
 import static java.util.stream.Collectors.toSet;
 
 import java.util.Set;
@@ -44,7 +45,7 @@ public final class CollisionPolicy implements Policy {
 
   public CollisionPolicy(CollisionSettings settings, Density density) {
     policyStats = new PolicyStats(String.format("product.Collision (%s)",
-        StringUtils.capitalize(density.name().toLowerCase())));
+        StringUtils.capitalize(density.name().toLowerCase(US))));
     maximumSize = settings.maximumSize();
 
     CollisionBuilder<Object> builder = CollisionCache
@@ -111,7 +112,7 @@ public boolean strictCapacity() {
     }
     public Stream<Density> density() {
       return config().getStringList("collision.density").stream()
-          .map(denity -> Density.valueOf(denity.toUpperCase()));
+          .map(denity -> Density.valueOf(denity.toUpperCase(US)));
     }
   }
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/ExpiringMapPolicy.java
Patch:
@@ -15,6 +15,8 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.policy.product;
 
+import static java.util.Locale.US;
+
 import java.util.Set;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
@@ -73,7 +75,7 @@ public ExpiringMapSettings(Config config) {
       super(config);
     }
     public ExpirationPolicy policy() {
-      String policy = config().getString("expiring-map.policy").toLowerCase();
+      String policy = config().getString("expiring-map.policy").toLowerCase(US);
       switch (policy) {
         case "fifo":
           return ExpirationPolicy.CREATED;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/OhcPolicy.java
Patch:
@@ -16,6 +16,7 @@
 package com.github.benmanes.caffeine.cache.simulator.policy.product;
 
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Locale.US;
 import static java.util.stream.Collectors.toSet;
 
 import java.io.IOException;
@@ -104,7 +105,7 @@ public double percentEden() {
     public Set<Eviction> policy() {
       Set<Eviction> policies = new HashSet<>();
       for (String policy : config().getStringList("ohc.policy")) {
-        String name = policy.toLowerCase().replaceAll("[^a-z]", "");
+        String name = policy.toLowerCase(US).replaceAll("[^a-z]", "");
         if (name.equals("lru")) {
           policies.add(Eviction.LRU);
         } else if (name.equals("wtinylfu")) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/TCachePolicy.java
Patch:
@@ -15,6 +15,8 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.policy.product;
 
+import static java.util.Locale.US;
+
 import java.util.Set;
 
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
@@ -79,7 +81,7 @@ public TCacheSettings(Config config) {
       super(config);
     }
     public <K, V> EvictionInterface<K, V> policy() {
-      String policy = config().getString("tcache.policy").toLowerCase();
+      String policy = config().getString("tcache.policy").toLowerCase(US);
       switch (policy) {
         case "lfu":
           return new LFUEviction<>();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sampled/SampledPolicy.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.policy.sampled;
 
+import static java.util.Locale.US;
 import static java.util.stream.Collectors.toSet;
 
 import java.util.ArrayList;
@@ -251,7 +252,7 @@ public enum EvictionPolicy {
     };
 
     public String label() {
-      return StringUtils.capitalize(name().toLowerCase());
+      return StringUtils.capitalize(name().toLowerCase(US));
     }
 
     /** Determines which node to evict. */
@@ -290,7 +291,7 @@ public int sampleSize() {
       return config().getInt("sampled.size");
     }
     public Sample sampleStrategy() {
-      return Sample.valueOf(config().getString("sampled.strategy").toUpperCase());
+      return Sample.valueOf(config().getString("sampled.strategy").toUpperCase(US));
     }
   }
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/HillClimberWindowTinyLfuPolicy.java
Patch:
@@ -21,6 +21,7 @@
 import static com.github.benmanes.caffeine.cache.simulator.policy.sketch.climbing.HillClimber.QueueType.PROTECTED;
 import static com.github.benmanes.caffeine.cache.simulator.policy.sketch.climbing.HillClimber.QueueType.WINDOW;
 import static com.google.common.base.Preconditions.checkState;
+import static java.util.Locale.US;
 import static java.util.stream.Collectors.toSet;
 
 import java.util.HashSet;
@@ -72,7 +73,7 @@ public final class HillClimberWindowTinyLfuPolicy implements Policy {
   public HillClimberWindowTinyLfuPolicy(HillClimberType strategy, double percentMain,
       HillClimberWindowTinyLfuSettings settings) {
     String name = String.format("sketch.HillClimberWindowTinyLfu (%s %.0f%%)",
-        strategy.name().toLowerCase(), 100 * (1.0 - percentMain));
+        strategy.name().toLowerCase(US), 100 * (1.0 - percentMain));
 
     this.policyStats = new PolicyStats(name);
     this.admittor = new TinyLfu(settings.config(), policyStats);
@@ -359,7 +360,7 @@ public double percentMainProtected() {
     }
     public Set<HillClimberType> strategy() {
       return config().getStringList("hill-climber-window-tiny-lfu.strategy").stream()
-          .map(strategy -> strategy.replace('-', '_').toUpperCase())
+          .map(strategy -> strategy.replace('-', '_').toUpperCase(US))
           .map(HillClimberType::valueOf)
           .collect(toSet());
     }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/TwoQueuePolicy.java
Patch:
@@ -79,7 +79,7 @@ public static Set<Policy> policies(Config config) {
   }
 
   @Override
-  @SuppressWarnings("PMD.ConfusingTernary")
+  @SuppressWarnings({"PMD.ConfusingTernary", "PMD.SwitchStmtsShouldHaveDefault"})
   public void record(long key) {
     // On accessing a page X :
     //   if X is in Am then

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/TextReporter.java
Patch:
@@ -16,6 +16,7 @@
 package com.github.benmanes.caffeine.cache.simulator.report;
 
 import static java.nio.charset.StandardCharsets.UTF_8;
+import static java.util.Locale.US;
 
 import java.io.IOException;
 import java.nio.file.Files;
@@ -81,7 +82,7 @@ private Comparator<PolicyStats> comparator() {
   }
 
   private Comparator<PolicyStats> makeComparator() {
-    switch (settings.report().sortBy().toLowerCase()) {
+    switch (settings.report().sortBy().toLowerCase(US)) {
       case "policy":
         return Comparator.comparing(PolicyStats::name);
       case "hit rate":

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/ConcurrentHashMapV7.java
Patch:
@@ -113,7 +113,7 @@
  * @param <K> the type of keys maintained by this map
  * @param <V> the type of mapped values
  */
-@SuppressWarnings({"all", "unchecked", "rawtypes", "serial"})
+@SuppressWarnings({"all", "unchecked", "rawtypes", "serial", "JdkObsolete"})
 public class ConcurrentHashMapV7<K, V> extends AbstractMap<K, V>
         implements ConcurrentMap<K, V>, Serializable {
     private static final long serialVersionUID = 7249069246763182397L;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ReadBuffer.java
Patch:
@@ -16,6 +16,7 @@
 package com.github.benmanes.caffeine.cache;
 
 import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.Consumer;
 
 /**
@@ -28,7 +29,7 @@ public abstract class ReadBuffer<E> implements Buffer<E> {
   public static final int BUFFER_MASK = BUFFER_SIZE - 1;
 
   final Consumer<E> consumer = any -> {};
-  final Lock evictionLock = new NonReentrantLock();
+  final Lock evictionLock = new ReentrantLock();
 
   /**
    * Attempts to record an event.

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheProxy.java
Patch:
@@ -413,6 +413,9 @@ public boolean putIfAbsent(K key, V value) {
     if (statsEnabled) {
       if (added) {
         statistics.recordPuts(1L);
+        statistics.recordMisses(1L);
+      } else {
+        statistics.recordHits(1L);
       }
       statistics.recordPutTime(ticker.read() - start);
     }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/AdaptiveResetCountMin4.java
Patch:
@@ -49,7 +49,7 @@ public AdaptiveResetCountMin4(Config config) {
     if (doorkeeperSettings.enabled()) {
       FilterType filterType = settings.membershipFilter();
       double expectedInsertionsMultiplier = doorkeeperSettings.expectedInsertionsMultiplier();
-      long expectedInsertions = (long) expectedInsertionsMultiplier * settings.maximumSize();
+      long expectedInsertions = (long) (expectedInsertionsMultiplier * settings.maximumSize());
       doorkeeper = filterType.create(expectedInsertions, doorkeeperSettings.fpp(), config);
     } else {
       doorkeeper = Membership.disabled();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/PeriodicResetCountMin4.java
Patch:
@@ -44,7 +44,7 @@ public PeriodicResetCountMin4(Config config) {
     if (doorkeeperSettings.enabled()) {
       FilterType filterType = settings.membershipFilter();
       double expectedInsertionsMultiplier = doorkeeperSettings.expectedInsertionsMultiplier();
-      long expectedInsertions = (long) expectedInsertionsMultiplier * settings.maximumSize();
+      long expectedInsertions = (long) (expectedInsertionsMultiplier * settings.maximumSize());
       doorkeeper = filterType.create(expectedInsertions, doorkeeperSettings.fpp(), config);
     } else {
       doorkeeper = Membership.disabled();

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Async.java
Patch:
@@ -38,7 +38,9 @@ private Async() {}
 
   /** Returns if the future has successfully completed. */
   static boolean isReady(@Nullable CompletableFuture<?> future) {
-    return (future != null) && future.isDone() && !future.isCompletedExceptionally();
+    return (future != null) && future.isDone()
+        && !future.isCompletedExceptionally()
+        && (future.join() != null);
   }
 
   /** Returns the current value or null if either not done or failed. */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsyncTest.java
Patch:
@@ -159,6 +159,7 @@ public Object[][] providesUnsuccessful() {
     return new Object[][] {
         { null },
         { new CompletableFuture<Integer>() },
+        { CompletableFuture.completedFuture(null) },
         { newFailedFuture(new InterruptedException()) },
         { newFailedFuture(new IllegalStateException()) },
     };

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheGenerator.java
Patch:
@@ -186,8 +186,8 @@ private boolean isCompatible(CacheContext context) {
         && ((context.implementation() != Implementation.Caffeine)
             || (context.expireAfterAccess() != Expire.DISABLED)
             || (context.expireAfterWrite() != Expire.DISABLED));
-    boolean expirationIncompatible = (cacheSpec.mustExpiresWithAnyOf().length > 0)
-        && !Arrays.stream(cacheSpec.mustExpiresWithAnyOf()).anyMatch(context::expires);
+    boolean expirationIncompatible = (cacheSpec.mustExpireWithAnyOf().length > 0)
+        && !Arrays.stream(cacheSpec.mustExpireWithAnyOf()).anyMatch(context::expires);
 
     boolean skip = asyncIncompatible || asyncLoaderIncompatible
         || refreshIncompatible || weigherIncompatible

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddExpiration.java
Patch:
@@ -128,7 +128,7 @@ private void addRefreshExpiration() {
       return;
     }
     context.nodeSubtype.addMethod(MethodSpec.methodBuilder("casWriteTime")
-        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
+        .addModifiers(context.publicFinalModifiers())
         .addParameter(long.class, "expect")
         .addParameter(long.class, "update")
         .returns(boolean.class)

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddValue.java
Patch:
@@ -63,7 +63,7 @@ private FieldSpec newValueField() {
   /** Creates the setValue method. */
   private MethodSpec makeSetValue() {
     MethodSpec.Builder setter = MethodSpec.methodBuilder("setValue")
-        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
+        .addModifiers(context.publicFinalModifiers())
         .addParameter(vTypeVar, "value")
         .addParameter(vRefQueueType, "referenceQueue");
 
@@ -81,7 +81,7 @@ private MethodSpec makeSetValue() {
 
   private MethodSpec makeContainsValue() {
     MethodSpec.Builder containsValue = MethodSpec.methodBuilder("containsValue")
-        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
+        .addModifiers(context.publicFinalModifiers())
         .addParameter(Object.class, "value")
         .returns(boolean.class);
     if (isStrongValues()) {

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/NodeContext.java
Patch:
@@ -39,7 +39,7 @@ public final class NodeContext {
   public MethodSpec.Builder constructorByKeyRef;
   public MethodSpec. Builder constructorDefault;
 
-    public NodeContext(TypeName superClass, String className, boolean isFinal,
+  public NodeContext(TypeName superClass, String className, boolean isFinal,
       Set<Feature> parentFeatures, Set<Feature> generateFeatures) {
     this.isFinal = isFinal;
     this.className = requireNonNull(className);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -164,7 +164,7 @@ abstract class BoundedLocalCache<K, V> extends BLCHeader.DrainStatusRef<K, V>
   final CacheLoader<K, V> cacheLoader;
   final Buffer<Node<K, V>> readBuffer;
   final CacheWriter<K, V> writer;
-  final NodeFactory nodeFactory;
+  final NodeFactory<K, V> nodeFactory;
   final Weigher<K, V> weigher;
   final Lock evictionLock;
   final Executor executor;
@@ -184,7 +184,7 @@ protected BoundedLocalCache(Caffeine<K, V> builder,
     writer = builder.getCacheWriter();
     weigher = builder.getWeigher(isAsync);
     drainBuffersTask = new PerformCleanupTask();
-    nodeFactory = NodeFactory.getFactory(builder, isAsync);
+    nodeFactory = NodeFactory.newFactory(builder, isAsync);
     data = new ConcurrentHashMap<>(builder.getInitialCapacity());
     evictionLock = (builder.getExecutor() instanceof ForkJoinPool)
         ? new NonReentrantLock()

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/Finalize.java
Patch:
@@ -30,6 +30,7 @@ protected boolean applies() {
   @Override
   protected void execute() {
     context.nodeSubtype
+        .addMethod(context.constructorDefault.build())
         .addMethod(context.constructorByKey.build())
         .addMethod(context.constructorByKeyRef.build());
   }

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/NodeContext.java
Patch:
@@ -37,8 +37,9 @@ public final class NodeContext {
   public TypeSpec.Builder nodeSubtype;
   public MethodSpec.Builder constructorByKey;
   public MethodSpec.Builder constructorByKeyRef;
+  public MethodSpec. Builder constructorDefault;
 
-  public NodeContext(TypeName superClass, String className, boolean isFinal,
+    public NodeContext(TypeName superClass, String className, boolean isFinal,
       Set<Feature> parentFeatures, Set<Feature> generateFeatures) {
     this.isFinal = isFinal;
     this.className = requireNonNull(className);

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/Registration.java
Patch:
@@ -26,7 +26,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-final class Registration<K, V> {
+public final class Registration<K, V> {
   private final CacheEntryListenerConfiguration<K, V> configuration;
   private final EventTypeAwareListener<K, V> listener;
   private final CacheEntryEventFilter<K, V> filter;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterVarTest.java
Patch:
@@ -429,7 +429,7 @@ public void putIfAbsent_present(Cache<Integer, Integer> cache, CacheContext cont
     assertThat(cache.estimatedSize(), is(0L));
   }
 
-  /* ---------------- Policy: putIfAbsent -------------- */
+  /* ---------------- Policy: put -------------- */
 
   @CheckNoWriter @CheckNoStats
   @Test(dataProvider = "caches", expectedExceptions = NullPointerException.class)

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/Synthetic.java
Patch:
@@ -25,7 +25,7 @@
 import com.yahoo.ycsb.generator.NumberGenerator;
 import com.yahoo.ycsb.generator.ScrambledZipfianGenerator;
 import com.yahoo.ycsb.generator.SkewedLatestGenerator;
-import com.yahoo.ycsb.generator.UniformIntegerGenerator;
+import com.yahoo.ycsb.generator.UniformLongGenerator;
 import com.yahoo.ycsb.generator.ZipfianGenerator;
 
 /**
@@ -149,7 +149,7 @@ public static LongStream zipfian(int items, int events) {
    * @return a stream of cache events
    */
   public static LongStream uniform(int lowerBound, int upperBound, int events) {
-    return generate(new UniformIntegerGenerator(lowerBound, upperBound), events);
+    return generate(new UniformLongGenerator(lowerBound, upperBound), events);
   }
 
   /** Returns a sequence of items constructed by the generator. */

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/ComputeBenchmark.java
Patch:
@@ -69,6 +69,7 @@ public ComputeBenchmark() {
   }
 
   @Setup
+  @SuppressWarnings("ReturnValueIgnored")
   public void setup() {
     if (computeType.equals("ConcurrentHashMap")) {
       setupConcurrentHashMap();

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/MpscGrowableArrayQueue.java
Patch:
@@ -189,7 +189,7 @@ public BaseMpscLinkedArrayQueue(final int initialCapacity) {
 
     int p2capacity = ceilingPowerOfTwo(initialCapacity);
     // leave lower bit of mask clear
-    long mask = (p2capacity - 1) << 1;
+    long mask = (p2capacity - 1L) << 1;
     // need extra element to point at next array
     E[] buffer = allocate(p2capacity + 1);
     producerBuffer = buffer;
@@ -397,7 +397,7 @@ private E newBufferPeek(E[] nextBuffer, final long index) {
 
   private long newBufferAndOffset(E[] nextBuffer, final long index) {
     consumerBuffer = nextBuffer;
-    consumerMask = (nextBuffer.length - 2) << 1;
+    consumerMask = (nextBuffer.length - 2L) << 1;
     final long offsetInNew = modifiedCalcElementOffset(index, consumerMask);
     return offsetInNew;
   }

File: guava/src/test/java/jsr166/JSR166TestCase.java
Patch:
@@ -127,7 +127,7 @@
  *
  * </ul>
  */
-@SuppressWarnings({"deprecation", "rawtypes", "serial"})
+@SuppressWarnings({"deprecation", "rawtypes", "serial", "AssertionFailureIgnored"})
 public class JSR166TestCase extends TestCase {
     private static final boolean useSecurityManager =
         Boolean.getBoolean("jsr166.useSecurityManager");

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ReferenceTest.java
Patch:
@@ -76,13 +76,15 @@ public final class ReferenceTest {
   @Test(dataProvider = "caches")
   @CacheSpec(keys = ReferenceType.WEAK, population = Population.FULL)
   public void identity_keys(Cache<Integer, Integer> cache, CacheContext context) {
+    @SuppressWarnings("deprecation")
     Integer key = new Integer(context.firstKey());
     assertThat(cache.getIfPresent(key), is(nullValue()));
   }
 
   @Test(dataProvider = "caches")
   @CacheSpec(values = {ReferenceType.WEAK, ReferenceType.SOFT}, population = Population.FULL)
   public void identity_values(Cache<Integer, Integer> cache, CacheContext context) {
+    @SuppressWarnings("deprecation")
     Integer value = new Integer(context.original().get(context.firstKey()));
     assertThat(cache.asMap().containsValue(value), is(false));
   }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheGenerator.java
Patch:
@@ -208,7 +208,7 @@ public static <K, V> Cache<K, V> newCache(CacheContext context) {
   }
 
   /** Fills the cache up to the population size. */
-  @SuppressWarnings({"unchecked", "BoxedPrimitiveConstructor"})
+  @SuppressWarnings({"deprecation", "unchecked", "BoxedPrimitiveConstructor"})
   private void populate(CacheContext context, Cache<Integer, Integer> cache) {
     if (context.population.size() == 0) {
       return;

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheSelectorCode.java
Patch:
@@ -22,6 +22,7 @@
 /**
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PMD.AvoidDuplicateLiterals")
 public final class LocalCacheSelectorCode {
   private final CodeBlock.Builder block;
 

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeFactoryGenerator.java
Patch:
@@ -91,6 +91,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PMD.AvoidDuplicateLiterals")
 public final class NodeFactoryGenerator {
   final Path directory;
   final NavigableMap<String, ImmutableSet<Feature>> classNameToFeatures;

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeSelectorCode.java
Patch:
@@ -20,6 +20,7 @@
 /**
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PMD.AvoidDuplicateLiterals")
 public final class NodeSelectorCode {
   private final CodeBlock.Builder block;
 

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddConstructors.java
Patch:
@@ -30,6 +30,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PMD.AvoidDuplicateLiterals")
 public final class AddConstructors extends NodeRule {
 
   @Override

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddExpiration.java
Patch:
@@ -32,6 +32,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PMD.AvoidDuplicateLiterals")
 public final class AddExpiration extends NodeRule {
 
   @Override

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddKey.java
Patch:
@@ -27,6 +27,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PMD.AvoidDuplicateLiterals")
 public final class AddKey extends NodeRule {
 
   @Override

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddMaximum.java
Patch:
@@ -26,6 +26,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PMD.AvoidDuplicateLiterals")
 public final class AddMaximum extends NodeRule {
 
   @Override

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddValue.java
Patch:
@@ -34,6 +34,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PMD.AvoidDuplicateLiterals")
 public final class AddValue extends NodeRule {
 
   @Override

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1371,7 +1371,7 @@ public void run() {
     }
   }
 
-  /** Updates the weighted size and evicts an entry on overflow. */
+  /** Updates the weighted size. */
   final class UpdateTask implements Runnable {
     final int weightDifference;
     final Node<K, V> node;

File: caffeine/src/test/java/com/github/benmanes/caffeine/SingleConsumerQueueTest.java
Patch:
@@ -349,7 +349,7 @@ public void iterator_whenEmpty(Queue<Integer> queue) {
   public void iterator_whenPopulated(Queue<Integer> queue) {
     List<Integer> copy = new ArrayList<>();
     populate(copy, queue.size());
-    assertThat(String.format("\nExpected: %s%n     but: %s", queue, copy),
+    assertThat(String.format("%nExpected: %s%n     but: %s", queue, copy),
         elementsEqual(queue.iterator(), copy.iterator()));
   }
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/processor/EntryProcessorEntry.java
Patch:
@@ -81,7 +81,7 @@ public void remove() {
   @Override
   public void setValue(V value) {
     requireNonNull(value);
-    if (action != Action.CREATED) {
+    if ((action != Action.CREATED) && (action != Action.LOADED)) {
       action = exists() ? Action.UPDATED : Action.CREATED;
     }
     this.value = value;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/Cache2kPolicy.java
Patch:
@@ -41,7 +41,6 @@ public final class Cache2kPolicy implements Policy {
   private final PolicyStats policyStats;
   private final int maximumSize;
 
-  @SuppressWarnings("deprecation")
   public Cache2kPolicy(Config config) {
     Logger logger = LogManager.getLogManager().getLogger("");
     Level level = logger.getLevel();

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/management/JCacheStatisticsMXBean.java
Patch:
@@ -27,11 +27,10 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 public final class JCacheStatisticsMXBean implements CacheStatisticsMXBean {
-  private final LongAdder removals = new LongAdder();
-  private final LongAdder expiries = new LongAdder();
   private final LongAdder puts = new LongAdder();
   private final LongAdder hits = new LongAdder();
   private final LongAdder misses = new LongAdder();
+  private final LongAdder removals = new LongAdder();
   private final LongAdder evictions = new LongAdder();
   private final LongAdder putTimeNanos = new LongAdder();
   private final LongAdder getTimeNanos = new LongAdder();
@@ -58,7 +57,6 @@ public void clear() {
     puts.reset();
     misses.reset();
     removals.reset();
-    expiries.reset();
     hits.reset();
     evictions.reset();
     getTimeNanos.reset();

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/spi/CaffeineCachingProvider.java
Patch:
@@ -38,7 +38,7 @@
  * through a {@link java.util.ServiceLoader}.
  * <p>
  * This provider is expected to be used for application life cycle events, like initialization. It
- * is not expected that all requests flow through the provider in obtain the cache manager and cache
+ * is not expected that all requests flow through the provider to obtain the cache manager and cache
  * instances for request operations. Internally, this implementation is synchronized to avoid using
  * excess memory due to its infrequent usage.
  *

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -739,6 +739,7 @@ boolean hasExpired(Node<K, V> node, long now) {
    * @param node the entry to evict
    * @param cause the reason to evict
    * @param now the current time, used only if expiring
+   * @return if the entry was evicted
    */
   @GuardedBy("evictionLock")
   @SuppressWarnings({"PMD.CollapsibleIfStatements", "GuardedByChecker"})
@@ -864,7 +865,7 @@ void refreshIfNeeded(Node<K, V> node, long now) {
     K key;
     V oldValue;
     long oldWriteTime = node.getWriteTime();
-    long refreshWriteTime = isAsync ? (now + Async.MAXIMUM_EXPIRY) : now;
+    long refreshWriteTime = (now + Async.MAXIMUM_EXPIRY);
     if (((now - oldWriteTime) > refreshAfterWriteNanos())
         && ((key = node.getKey()) != null) && ((oldValue = node.getValue()) != null)
         && node.casWriteTime(oldWriteTime, refreshWriteTime)) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsyncTest.java
Patch:
@@ -28,7 +28,6 @@
 
 import java.lang.reflect.Constructor;
 import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -38,6 +37,7 @@
 
 import com.github.benmanes.caffeine.cache.Async.AsyncExpiry;
 import com.github.benmanes.caffeine.testing.Awaits;
+import com.github.benmanes.caffeine.testing.ConcurrentTestHarness;
 
 /**
  * @author ben.manes@gmail.com (Ben Manes)
@@ -81,7 +81,7 @@ public void getWhenSuccessful_success(CompletableFuture<?> future) {
   public void getWhenSuccessful_success_async() {
     CompletableFuture<Integer> future = new CompletableFuture<Integer>();
     AtomicInteger result = new AtomicInteger();
-    ForkJoinPool.commonPool().execute(() -> {
+    ConcurrentTestHarness.execute(() -> {
       result.set(1);
       result.set(Async.getWhenSuccessful(future));
     });
@@ -94,7 +94,7 @@ public void getWhenSuccessful_success_async() {
   public void getWhenSuccessful_fails(CompletableFuture<?> future) {
     if ((future != null) && !future.isDone()) {
       AtomicInteger result = new AtomicInteger();
-      ForkJoinPool.commonPool().execute(() -> {
+      ConcurrentTestHarness.execute(() -> {
         result.set(1);
         Object value = Async.getWhenSuccessful(future);
         result.set((value == null) ? 2 : 3);

File: guava/src/test/java/jsr166/JSR166TestCase.java
Patch:
@@ -44,6 +44,7 @@
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.regex.Pattern;
@@ -1062,7 +1063,7 @@ public Callable<String> latchAwaitingStringTask(final CountDownLatch latch) {
             @Override
             protected String realCall() {
                 try {
-                    latch.await();
+                  assertTrue(latch.await(300, TimeUnit.SECONDS));
                 } catch (InterruptedException quittingTime) {}
                 return TEST_STRING;
             }};

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheGenerator.java
Patch:
@@ -181,7 +181,7 @@ private boolean isCompatible(CacheContext context) {
     boolean refreshIncompatible = context.refreshes() && !context.isLoading();
     boolean weigherIncompatible = context.isUnbounded() && context.isWeighted();
     boolean referenceIncompatible = cacheSpec.requiresWeakOrSoft()
-        && (context.isWeakKeys() || context.isWeakValues() || context.isSoftValues());
+        && context.isStrongKeys() && context.isStrongValues();
     boolean expiryIncompatible = (context.expiryType() != CacheExpiry.DISABLED)
         && ((context.implementation() != Implementation.Caffeine)
             || (context.expireAfterAccess() != Expire.DISABLED)

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheManagerImpl.java
Patch:
@@ -94,6 +94,8 @@ public <K, V, C extends Configuration<K, V>> Cache<K, V> createCache(String cach
     CacheProxy<?, ?> cache = caches.compute(cacheName, (name, existing) -> {
       if ((existing != null) && !existing.isClosed()) {
         throw new CacheException("Cache " + cacheName + " already exists");
+      } else if (cacheFactory.isDefinedExternally(cacheName)) {
+        throw new CacheException("Cache " + cacheName + " is configured externally");
       }
       return cacheFactory.createCache(cacheName, configuration);
     });

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/MpscGrowableArrayQueue.java
Patch:
@@ -64,6 +64,7 @@ protected long getCurrentBufferCapacity(long mask) {
   }
 }
 
+@SuppressWarnings("OvershadowingSubclassFields")
 abstract class MpscChunkedArrayQueue<E> extends MpscChunkedArrayQueueColdProducerFields<E> {
   long p0, p1, p2, p3, p4, p5, p6, p7;
   long p10, p11, p12, p13, p14, p15, p16, p17;
@@ -120,6 +121,7 @@ abstract class BaseMpscLinkedArrayQueueProducerFields<E> extends BaseMpscLinkedA
   protected long producerIndex;
 }
 
+@SuppressWarnings("OvershadowingSubclassFields")
 abstract class BaseMpscLinkedArrayQueuePad2<E> extends BaseMpscLinkedArrayQueueProducerFields<E> {
   long p01, p02, p03, p04, p05, p06, p07;
   long p10, p11, p12, p13, p14, p15, p16, p17;
@@ -131,6 +133,7 @@ abstract class BaseMpscLinkedArrayQueueConsumerFields<E> extends BaseMpscLinkedA
   protected long consumerIndex;
 }
 
+@SuppressWarnings("OvershadowingSubclassFields")
 abstract class BaseMpscLinkedArrayQueuePad3<E> extends BaseMpscLinkedArrayQueueConsumerFields<E> {
   long p0, p1, p2, p3, p4, p5, p6, p7;
   long p10, p11, p12, p13, p14, p15, p16, p17;

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaLoadingCache.java
Patch:
@@ -38,7 +38,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-@SuppressWarnings("deprecation")
+@SuppressWarnings({"deprecation", "OvershadowingSubclassFields"})
 final class CaffeinatedGuavaLoadingCache<K, V> extends CaffeinatedGuavaCache<K, V>
     implements LoadingCache<K, V> {
   static final ThreadLocal<Boolean> nullBulkLoad = ThreadLocal.withInitial(() -> Boolean.FALSE);

File: guava/src/test/java/com/google/common/cache/CacheTesting.java
Patch:
@@ -172,9 +172,9 @@ static void drainReferenceQueue(LocalCache.Segment<?, ?> segment) {
     }
   }
 
-  static int getTotalSegmentSize(Cache<?, ?> cache) {
+  static long getTotalSegmentSize(Cache<?, ?> cache) {
     LocalCache<?, ?> map = toLocalCache(cache);
-    int totalSize = 0;
+    long totalSize = 0;
     for (Segment<?, ?> segment : map.segments) {
       totalSize += segment.maxSegmentWeight;
     }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/LoadingCacheProxy.java
Patch:
@@ -41,8 +41,9 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("OvershadowingSubclassFields")
 public final class LoadingCacheProxy<K, V> extends CacheProxy<K, V> {
-  private final LoadingCache<K, Expirable<V>> cache;
+  final LoadingCache<K, Expirable<V>> cache;
 
   @SuppressWarnings("PMD.ExcessiveParameterList")
   public LoadingCacheProxy(String name, Executor executor, CacheManager cacheManager,

File: simulator/src/main/java/com/clearspring/analytics/stream/frequency/CountMin64TinyLfu.java
Patch:
@@ -73,7 +73,7 @@ private void resetIfNeeded() {
       size /= 2;
       for (int i = 0; i < sketch.depth; i++) {
         for (int j = 0; j < sketch.width; j++) {
-          size -= sketch.table[i][j] & 1;
+          size -= ((int) sketch.table[i][j]) & 1;
           sketch.table[i][j] >>>= 1;
         }
       }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinyCacheSketch.java
Patch:
@@ -57,8 +57,9 @@ public int countItem(long item) {
     // time. As far as I understand it is working right now.
     while (TinySetIndexing.chainStart <= TinySetIndexing.chainEnd) {
       try {
-        $ += (cache[TinySetIndexing.chainStart % cache.length] == hashFunc.fpaux.fingerprint) ? 1L
-            : 0L;
+        $ += (cache[TinySetIndexing.chainStart % cache.length] == hashFunc.fpaux.fingerprint)
+            ? 1
+            : 0;
         TinySetIndexing.chainStart++;
 
       } catch (Exception e) {

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/ReadBufferBenchmark.java
Patch:
@@ -73,6 +73,8 @@ public void record(RecordCounter counters) {
       case ReadBuffer.FULL:
         counters.recordFull++;
         break;
+      default:
+        throw new IllegalStateException();
     }
   }
 

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/profiler/ProfilerHook.java
Patch:
@@ -28,8 +28,8 @@
  * @author Ben Manes (ben.manes@gmail.com)
  */
 public abstract class ProfilerHook {
-  protected static int NUM_THREADS = 8;
-  protected static int DISPLAY_DELAY_SEC = 5;
+  static int DISPLAY_DELAY_SEC = 5;
+  static int NUM_THREADS = 8;
 
   protected final LongAdder calls;
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/EntryProxy.java
Patch:
@@ -20,7 +20,7 @@
 import javax.cache.Cache;
 
 /**
- * An implementation of JSR-107 {@link Cache.Entry}.
+ * An implementation of JSR-107 {@link javax.cache.Cache.Entry}.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/TimerWheelTest.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache;
 
+import static com.github.benmanes.caffeine.cache.TimerWheel.SPANS;
 import static java.util.stream.Collectors.toList;
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
@@ -118,7 +119,7 @@ public void schedule_fuzzy(long clock, long nanos, long[] times) {
   public Object[][] providesFuzzySchedule() {
     long[] times = new long[5_000];
     long clock = ThreadLocalRandom.current().nextLong();
-    long bound = clock + TimeUnit.DAYS.toNanos(10);
+    long bound = clock + TimeUnit.DAYS.toNanos(1) + SPANS[SPANS.length - 1];
     for (int i = 0; i < times.length; i++) {
       times[i] = ThreadLocalRandom.current().nextLong(clock + 1, bound);
     }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/Expirable.java
Patch:
@@ -49,7 +49,7 @@ public void setExpireTimeMS(long expireTimeMS) {
 
   /** Returns if the value has expired and is eligible for eviction. */
   public boolean hasExpired(long currentTimeMS) {
-    return (expireTimeMS <= currentTimeMS);
+    return (currentTimeMS - expireTimeMS) >= 0;
   }
 
   /** Returns if the value will never expire. */

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/event/EventTypeFilterTest.java
Patch:
@@ -53,6 +53,6 @@ public void equals() {
 
   @Test
   public void hash() {
-    filter.hashCode();
+    assertThat(filter.hashCode(), is(filter.hashCode()));
   }
 }

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/JCacheUpdateExpiryTest.java
Patch:
@@ -129,7 +129,7 @@ public void replaceConditionally_failed() {
 
     assertThat(jcache.replace(KEY_1, VALUE_2, VALUE_3), is(false));
     Expirable<Integer> expirable = getExpirable(jcache, KEY_1);
-    assertThat(expirable.getExpireTimeMS(), is(EXPIRY_DURATION));
+    assertThat(expirable.getExpireTimeMS(), is(START_TIME_MS + EXPIRY_DURATION));
   }
 
   @Test

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeFactoryGenerator.java
Patch:
@@ -219,7 +219,7 @@ private void addGetFactoryMethods() {
         .build());
   }
 
-  private void generatedNodes() throws IOException {
+  private void generatedNodes() {
     fillClassNameToFeatures();
     classNameToFeatures.forEach((className, features) -> {
       String higherKey = classNameToFeatures.higherKey(className);

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/NodeRule.java
Patch:
@@ -140,14 +140,15 @@ private Strength strengthOf(Feature feature) {
   }
 
   protected enum Strength {
-    STRONG, WEAK, SOFT;
+    STRONG, WEAK, SOFT,
   }
 
   protected enum Visibility {
     IMMEDIATE(false), LAZY(true);
 
     final boolean isRelaxed;
-    private Visibility(boolean mode) {
+
+    Visibility(boolean mode) {
       this.isRelaxed = mode;
     }
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/SingleConsumerQueue.java
Patch:
@@ -146,7 +146,7 @@ private SingleConsumerQueue(Function<E, Node<E>> factory) {
     for (int i = 0; i < ARENA_LENGTH; i++) {
       arena[i] = new AtomicReference<>();
     }
-    Node<E> node = new Node<E>(null);
+    Node<E> node = new Node<>(null);
     this.factory = factory;
     lazySetTail(node);
     head = node;
@@ -275,7 +275,7 @@ public boolean addAll(Collection<? extends E> c) {
         first = factory.apply(e);
         last = first;
       } else {
-        Node<E> newLast = new Node<E>(e);
+        Node<E> newLast = new Node<>(e);
         last.lazySetNext(newLast);
         last = newLast;
       }
@@ -438,7 +438,7 @@ Node<E> awaitNext() {
   static final long serialVersionUID = 1;
 
   Object writeReplace() {
-    return new SerializationProxy<E>(this);
+    return new SerializationProxy<>(this);
   }
 
   private void readObject(ObjectInputStream stream) throws InvalidObjectException {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncLoadingCache.java
Patch:
@@ -106,7 +106,7 @@ public CompletableFuture<V> getIfPresent(@Nonnull Object key) {
   public CompletableFuture<V> get(@Nonnull K key,
       @Nonnull Function<? super K, ? extends V> mappingFunction) {
     requireNonNull(mappingFunction);
-    return get(key, (k1, executor) -> CompletableFuture.<V>supplyAsync(
+    return get(key, (k1, executor) -> CompletableFuture.supplyAsync(
         () -> mappingFunction.apply(key), executor));
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/UnboundedLocalCache.java
Patch:
@@ -576,7 +576,7 @@ public boolean remove(Object obj) {
 
     @Override
     public Iterator<K> iterator() {
-      return new KeyIterator<K>(cache);
+      return new KeyIterator<>(cache);
     }
 
     @Override

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -432,10 +432,9 @@ public void exceedsMaximumBufferSize_onRead(Cache<Integer, Integer> cache, Cache
       population = Population.EMPTY, maximumSize = Maximum.FULL)
   public void exceedsMaximumBufferSize_onWrite(Cache<Integer, Integer> cache, CacheContext context) {
     BoundedLocalCache<Integer, Integer> localCache = asBoundedLocalCache(cache);
-    Node<Integer, Integer> dummy = localCache.nodeFactory.newNode(null, null, null, 1, 0);
 
     boolean[] ran = new boolean[1];
-    localCache.afterWrite(dummy, () -> ran[0] = true, 0);
+    localCache.afterWrite(() -> ran[0] = true, 0);
     assertThat(ran[0], is(true));
 
     assertThat(localCache.writeBuffer().size(), is(0));
@@ -481,7 +480,7 @@ public void afterWrite_drainFullWriteBuffer(Cache<Integer, Integer> cache, Cache
 
     int[] triggered = { 0 };
     Runnable triggerTask = () -> triggered[0] = 1 + expectedCount[0];
-    localCache.afterWrite(null, triggerTask, 0L);
+    localCache.afterWrite(triggerTask, 0L);
 
     assertThat(processed[0], is(expectedCount[0]));
     assertThat(triggered[0], is(expectedCount[0] + 1));

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheFactory.java
Patch:
@@ -216,11 +216,10 @@ private boolean configureExpireVariably() {
       return config.getExpireAfterWrite().isPresent();
     }
 
-    private boolean configureRefreshAfterWrite() {
+    private void configureRefreshAfterWrite() {
       if (config.getRefreshAfterWrite().isPresent()) {
         caffeine.refreshAfterWrite(config.getRefreshAfterWrite().getAsLong(), TimeUnit.NANOSECONDS);
       }
-      return config.getRefreshAfterWrite().isPresent();
     }
 
     /** Configures the removal listener. */

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/integration/DisabledCacheWriter.java
Patch:
@@ -41,10 +41,10 @@ public static <K, V> CacheWriter<K, V> get() {
   }
 
   @Override
-  public void write(Entry<? extends Object, ? extends Object> entry) {}
+  public void write(Entry<?, ?> entry) {}
 
   @Override
-  public void writeAll(Collection<Entry<? extends Object, ? extends Object>> entries) {}
+  public void writeAll(Collection<Entry<?, ?>> entries) {}
 
   @Override
   public void delete(Object key) {}

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/processor/Action.java
Patch:
@@ -37,5 +37,5 @@ public enum Action {
   LOADED,
 
   /** The entry existed and was deleted. */
-  DELETED;
+  DELETED,
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/Simulator.java
Patch:
@@ -99,7 +99,7 @@ public Receive createReceive() {
   }
 
   /** Broadcast the trace events to all of the policy actors. */
-  private void broadcast() throws IOException {
+  private void broadcast() {
     try (LongStream events = eventStream()) {
       LongArrayList batch = new LongArrayList(batchSize);
       for (PrimitiveIterator.OfLong i = events.iterator(); i.hasNext();) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/Admission.java
Patch:
@@ -34,8 +34,7 @@ public enum Admission {
   private final BiFunction<Config, PolicyStats, Admittor> factory;
   private final Function<String, String> formatter;
 
-  private Admission(BiFunction<Config, PolicyStats, Admittor> factory,
-      Function<String, String> formatter) {
+  Admission(BiFunction<Config, PolicyStats, Admittor> factory, Function<String, String> formatter) {
     this.formatter = formatter;
     this.factory = factory;
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/CountMin4.java
Patch:
@@ -35,9 +35,9 @@ public abstract class CountMin4 implements Frequency {
       0xc3a5c85c97cb3127L, 0xb492b66fbe98f273L, 0x9ae16a3b2f90404fL, 0xcbf29ce484222325L};
   static final long RESET_MASK = 0x7777777777777777L;
 
+  protected final boolean conservative;
   protected final int randomSeed;
 
-  protected boolean conservative;
   protected int tableMask;
   protected long[] table;
   protected int step = 1;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinyCacheAdapter.java
Patch:
@@ -26,7 +26,7 @@
  */
 public final class TinyCacheAdapter implements Frequency {
   // the actual data structure.
-  TinyCacheSketch tcs;
+  final TinyCacheSketch tcs;
   // size between cache and sample.
   static final int sampleFactor = 10;
   // max frequency estimation of an item.

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/TraceFormat.java
Patch:
@@ -47,7 +47,7 @@ public enum TraceFormat {
 
   private final Function<List<String>, TraceReader> factory;
 
-  private TraceFormat(Function<List<String>, TraceReader> factory) {
+  TraceFormat(Function<List<String>, TraceReader> factory) {
     this.factory = factory;
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/wikipedia/WikipediaTraceReader.java
Patch:
@@ -102,10 +102,9 @@ private String getPath(String url) {
     if (index == -1) {
       return url;
     }
-    String path = url.substring(index + 1);
 
     // Replace the html entities that we want to search for inside paths
-    String cleansed = path;
+    String cleansed = url.substring(index + 1);
     for (int i = 0; i < SEARCH_LIST.length; i++) {
       cleansed = StringUtils.replace(cleansed, SEARCH_LIST[i], REPLACEMENT_LIST[i]);
     }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/adaptive/ArcPolicy.java
Patch:
@@ -235,7 +235,7 @@ public void finished() {
 
   private enum QueueType {
     T1, B1,
-    T2, B2;
+    T2, B2,
   }
 
   static final class Node {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/adaptive/CarPolicy.java
Patch:
@@ -253,7 +253,7 @@ public void finished() {
 
   private enum QueueType {
     T1, B1,
-    T2, B2;
+    T2, B2,
   }
 
   static final class Node {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/adaptive/CartPolicy.java
Patch:
@@ -318,12 +318,12 @@ public void finished() {
 
   private enum QueueType {
     T1, B1,
-    T2, B2;
+    T2, B2,
   }
 
   private enum FilterType {
     ShortTerm,
-    LongTerm;
+    LongTerm,
   }
 
   static final class Node {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/ClockProPolicy.java
Patch:
@@ -307,7 +307,7 @@ public void finished() {
   }
 
   enum Status {
-    HOT, COLD, TEST;
+    HOT, COLD, TEST,
   }
 
   private static final class Node {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/LirsPolicy.java
Patch:
@@ -342,7 +342,7 @@ private void printLirs() {
   enum Status {
     LIR,
     HIR_RESIDENT,
-    HIR_NON_RESIDENT;
+    HIR_NON_RESIDENT,
   }
 
   // S holds three types of blocks, LIR blocks, resident HIR blocks, non-resident HIR blocks
@@ -357,7 +357,7 @@ enum StackType {
     // stack, Q, with its size of Lhirs.
     Q,
     // Adaption to facilitate the search of the non-resident HIR blocks
-    NR;
+    NR,
   }
 
   // Each entry in the stack records the LIR/HIR status of a block and its residence status,

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/FrequentlyUsedPolicy.java
Patch:
@@ -54,7 +54,7 @@ public FrequentlyUsedPolicy(Admission admission, EvictionPolicy policy, Config c
     this.data = new Long2ObjectOpenHashMap<>();
     this.maximumSize = settings.maximumSize();
     this.policy = requireNonNull(policy);
-    this.freq0 = new FrequencyNode(0);
+    this.freq0 = new FrequencyNode();
   }
 
   /** Returns all variations of this policy based on the configuration parameters. */
@@ -170,11 +170,11 @@ static final class FrequencyNode {
     FrequencyNode prev;
     FrequencyNode next;
 
-    public FrequencyNode(int count) {
+    public FrequencyNode() {
       nextNode = new Node(this);
-      this.count = count;
       this.prev = this;
       this.next = this;
+      this.count = 0;
     }
 
     public FrequencyNode(int count, FrequencyNode prev) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/SegmentedLruPolicy.java
Patch:
@@ -150,7 +150,7 @@ public PolicyStats stats() {
 
   enum QueueType {
     PROTECTED,
-    PROBATION;
+    PROBATION,
   }
 
   static final class Node {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/opt/ClairvoyantPolicy.java
Patch:
@@ -113,7 +113,7 @@ private void process(long key) {
 
   /** Removes the entry whose next access is farthest away into the future. */
   private void evict() {
-    data.rem(data.lastInt());
+    data.remove(data.lastInt());
     policyStats.recordEviction();
   }
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sampled/SampledPolicy.java
Patch:
@@ -134,7 +134,7 @@ public enum Sample {
     GUESS {
       @Override public <E> List<E> sample(E[] elements, E candidate,
           int sampleSize, Random random, PolicyStats policyStats) {
-        List<E> sample = new ArrayList<E>(sampleSize);
+        List<E> sample = new ArrayList<>(sampleSize);
         policyStats.addOperations(sampleSize);
         for (int i = 0; i < sampleSize; i++) {
           int index = random.nextInt(elements.length);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/HillClimberType.java
Patch:
@@ -33,7 +33,7 @@ enum HillClimberType {
 
   private final Function<Config, HillClimber> factory;
 
-  private HillClimberType(Function<Config, HillClimber> factory) {
+  HillClimberType(Function<Config, HillClimber> factory) {
     this.factory = requireNonNull(factory);
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/HillClimberWindowTinyLfuPolicy.java
Patch:
@@ -360,7 +360,7 @@ public double percentMainProtected() {
     public Set<HillClimberType> strategy() {
       return config().getStringList("hill-climber-window-tiny-lfu.strategy").stream()
           .map(strategy -> strategy.replace('-', '_').toUpperCase())
-          .map(strategy -> HillClimberType.valueOf(strategy))
+          .map(HillClimberType::valueOf)
           .collect(toSet());
     }
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/tinycache/TinyCachePolicy.java
Patch:
@@ -46,11 +46,9 @@ public static Set<Policy> policies(Config config) {
   @Override
   public void record(long key) {
     if (tinyCache.contains(key)) {
-      tinyCache.recordItem(key);
       policyStats.recordHit();
     } else {
       boolean evicted = tinyCache.addItem(key);
-      tinyCache.recordItem(key);
       policyStats.recordMiss();
       if (evicted) {
         policyStats.recordEviction();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/TuQueuePolicy.java
Patch:
@@ -171,7 +171,7 @@ public void finished() {
   enum QueueType {
     HOT,
     WARM,
-    COLD;
+    COLD,
   }
 
   static final class Node {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/TwoQueuePolicy.java
Patch:
@@ -186,7 +186,7 @@ public PolicyStats stats() {
   enum QueueType {
     MAIN,
     IN,
-    OUT;
+    OUT,
   }
 
   static final class Node {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/ReportFormat.java
Patch:
@@ -33,7 +33,7 @@ public enum ReportFormat {
 
   private final Function<Config, Reporter> factory;
 
-  private ReportFormat(Function<Config, Reporter> factory) {
+  ReportFormat(Function<Config, Reporter> factory) {
     this.factory = requireNonNull(factory);
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/TimerWheel.java
Patch:
@@ -125,7 +125,7 @@ void expire(int index, long previousTicks, long currentTicks,
     Node<K, V>[] timerWheel = wheel[index];
 
     int start, end;
-    if ((currentTimeNanos - previousTimeNanos) > SPANS[index + 1]) {
+    if ((currentTimeNanos - previousTimeNanos) >= SPANS[index + 1]) {
       end = timerWheel.length;
       start = 0;
     } else {

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/local/AddExpireAfterAccess.java
Patch:
@@ -67,7 +67,7 @@ private void variableExpiration() {
         .returns(boolean.class)
         .build());
 
-    context.constructor.addStatement("this.expiry = builder.getExpiry()");
+    context.constructor.addStatement("this.expiry = builder.getExpiry(isAsync)");
     context.cache.addField(FieldSpec.builder(EXPIRY, "expiry", privateFinalModifiers).build());
     context.cache.addMethod(MethodSpec.methodBuilder("expiry")
         .addModifiers(protectedFinalModifiers)

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddDeques.java
Patch:
@@ -17,8 +17,6 @@
 
 import static com.github.benmanes.caffeine.cache.Specifications.NODE;
 
-import javax.lang.model.element.Modifier;
-
 import com.github.benmanes.caffeine.cache.Feature;
 
 /**
@@ -49,7 +47,7 @@ protected void execute() {
 
   /** Adds a simple field, accessor, and mutator for the variable. */
   private void addFieldAndGetter(String varName) {
-    context.nodeSubtype.addField(NODE, varName, Modifier.PRIVATE)
+    context.nodeSubtype.addField(NODE, varName)
         .addMethod(newGetter(Strength.STRONG, NODE, varName, Visibility.IMMEDIATE))
         .addMethod(newSetter(NODE, varName, Visibility.IMMEDIATE));
   }

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddKey.java
Patch:
@@ -55,10 +55,9 @@ protected void execute() {
   }
 
   private FieldSpec newKeyField() {
-    Modifier[] modifiers = { Modifier.PRIVATE, Modifier.VOLATILE };
     FieldSpec.Builder fieldSpec = isStrongKeys()
-        ? FieldSpec.builder(kTypeVar, "key", modifiers)
-        : FieldSpec.builder(keyReferenceType(), "key", modifiers);
+        ? FieldSpec.builder(kTypeVar, "key", Modifier.VOLATILE)
+        : FieldSpec.builder(keyReferenceType(), "key", Modifier.VOLATILE);
     return fieldSpec.build();
   }
 

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddMaximum.java
Patch:
@@ -40,7 +40,7 @@ protected void execute() {
   }
 
   private void addQueueFlag() {
-    context.nodeSubtype.addField(int.class, "queueType", Modifier.PRIVATE);
+    context.nodeSubtype.addField(int.class, "queueType");
     context.nodeSubtype.addMethod(MethodSpec.methodBuilder("getQueueType")
         .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
         .returns(int.class)
@@ -57,13 +57,13 @@ private void addWeight() {
     if (!context.generateFeatures.contains(Feature.MAXIMUM_WEIGHT)) {
       return;
     }
-    context.nodeSubtype.addField(int.class, "weight", Modifier.PRIVATE)
+    context.nodeSubtype.addField(int.class, "weight")
         .addMethod(newGetter(Strength.STRONG, TypeName.INT, "weight", Visibility.IMMEDIATE))
         .addMethod(newSetter(TypeName.INT, "weight", Visibility.IMMEDIATE));
     context.constructorByKey.addStatement("this.$N = $N", "weight", "weight");
     context.constructorByKeyRef.addStatement("this.$N = $N", "weight", "weight");
 
-    context.nodeSubtype.addField(int.class, "policyWeight", Modifier.PRIVATE)
+    context.nodeSubtype.addField(int.class, "policyWeight")
         .addMethod(newGetter(Strength.STRONG, TypeName.INT, "policyWeight", Visibility.IMMEDIATE))
         .addMethod(newSetter(TypeName.INT, "policyWeight", Visibility.IMMEDIATE));
   }

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddValue.java
Patch:
@@ -61,10 +61,9 @@ protected void execute() {
   }
 
   private FieldSpec newValueField() {
-    Modifier[] modifiers = { Modifier.PRIVATE, Modifier.VOLATILE };
     FieldSpec.Builder fieldSpec = isStrongValues()
-        ? FieldSpec.builder(vTypeVar, "value", modifiers)
-        : FieldSpec.builder(valueReferenceType(), "value", modifiers);
+        ? FieldSpec.builder(vTypeVar, "value", Modifier.VOLATILE)
+        : FieldSpec.builder(valueReferenceType(), "value", Modifier.VOLATILE);
     return fieldSpec.build();
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -51,6 +51,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheProvider;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.CacheExecutor;
+import com.github.benmanes.caffeine.cache.testing.CacheSpec.CacheExpiry;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.CacheWeigher;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Compute;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.ExecutorFailure;
@@ -136,7 +137,7 @@ public void scheduleDrainBuffers_rejected(Cache<Integer, Integer> cache, CacheCo
   @Test
   public void putWeighted_noOverflow() {
     Cache<Integer, Integer> cache = Caffeine.newBuilder()
-        .executor(CacheExecutor.DIRECT.get())
+        .executor(CacheExecutor.DIRECT.create())
         .weigher(CacheWeigher.MAX_VALUE)
         .maximumWeight(Long.MAX_VALUE)
         .build();
@@ -444,7 +445,7 @@ public void exceedsMaximumBufferSize_onWrite(Cache<Integer, Integer> cache, Cach
   @CacheSpec(compute = Compute.SYNC, implementation = Implementation.Caffeine,
       population = Population.EMPTY, maximumSize = Maximum.FULL, weigher = CacheWeigher.DEFAULT,
       expireAfterAccess = Expire.DISABLED, expireAfterWrite = Expire.DISABLED,
-      keys = ReferenceType.STRONG, values = ReferenceType.STRONG)
+      expiry = CacheExpiry.DISABLED, keys = ReferenceType.STRONG, values = ReferenceType.STRONG)
   public void fastpath(Cache<Integer, Integer> cache, CacheContext context) {
     BoundedLocalCache<Integer, Integer> localCache = asBoundedLocalCache(cache);
     assertThat(localCache.skipReadBuffer(), is(true));

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/copy/JavaSerializationCopier.java
Patch:
@@ -57,7 +57,7 @@ protected byte[] serialize(Object object) {
     try (ObjectOutputStream output = new ObjectOutputStream(bytes)) {
       output.writeObject(object);
     } catch (IOException e) {
-      throw new UncheckedIOException("Failed to serialize " + e.getClass(), e);
+      throw new UncheckedIOException("Failed to serialize " + object.getClass(), e);
     }
     return bytes.toByteArray();
   }

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheSelectorCode.java
Patch:
@@ -75,7 +75,7 @@ private LocalCacheSelectorCode maximum() {
   }
 
   private LocalCacheSelectorCode expires() {
-    block.beginControlFlow("if (builder.expiresAfterAccess())")
+    block.beginControlFlow("if (builder.expiresAfterAccess() || builder.expiresVariable())")
             .addStatement("sb.append('A')")
         .endControlFlow()
         .beginControlFlow("if (builder.expiresAfterWrite())")

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/RemovalCause.java
Patch:
@@ -86,7 +86,8 @@ public enum RemovalCause {
 
   /**
    * The entry's expiration timestamp has passed. This can occur when using
-   * {@link Caffeine#expireAfterWrite} or {@link Caffeine#expireAfterAccess}.
+   * {@link Caffeine#expireAfterWrite}, {@link Caffeine#expireAfterAccess},
+   * or {@link Caffeine#expireAfter(Expiry)}.
    */
   EXPIRED {
     @Override public boolean wasEvicted() {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/perfect/PerfectFrequency.java
Patch:
@@ -55,7 +55,7 @@ public void increment(long e) {
 
   private void reset() {
     for (Long2IntMap.Entry entry : counts.long2IntEntrySet()) {
-      entry.setValue(entry.getValue() / 2);
+      entry.setValue(entry.getIntValue() / 2);
     }
     size = (size / 2);
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/climbing/HillClimberWindowTinyLfuPolicy.java
Patch:
@@ -230,7 +230,7 @@ private void increaseWindow(int amount) {
       maxProtected--;
 
       demoteProtected();
-      Node candidate = headProbation.next.next;
+      Node candidate = headProbation.next;
       candidate.remove();
       candidate.queue = WINDOW;
       candidate.appendToTail(headWindow);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/Frequency.java
Patch:
@@ -28,5 +28,6 @@ public interface Frequency {
   /** Increments the popularity of the element. */
   void increment(long e);
 
-void reportMiss();
+  /** Feedback to allow for adaptability. */
+  default void reportMiss() {}
 }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -245,7 +245,7 @@ private void checkContainsInOrder(Cache<Integer, Integer> cache, Integer... expe
     assertThat(evictionList, is(equalTo(asList(expect))));
   }
 
-  @Test
+  @Test(groups = "slow")
   public void evict_update() {
     Integer key = 0;
     Integer oldValue = 1;
@@ -292,7 +292,7 @@ public void evict_update() {
     await().untilAtomic(removedValues, is(oldValue + newValue));
   }
 
-  @Test
+  @Test(groups = "slow")
   public void clear_update() {
     Integer key = 0;
     Integer oldValue = 1;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/UnboundedLocalCache.java
Patch:
@@ -363,7 +363,6 @@ public V put(K key, V value) {
     return put(key, value, /* notifyWriter */ true);
   }
 
-
   @Override
   public V put(K key, V value, boolean notifyWriter) {
     requireNonNull(value);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/EvictionTest.java
Patch:
@@ -347,6 +347,7 @@ public void put_changeWeight(Cache<String, List<Integer>> cache,
   @CacheSpec(implementation = Implementation.Caffeine, maximumSize = Maximum.FULL,
       weigher = CacheWeigher.COLLECTION, population = Population.EMPTY,
       keys = ReferenceType.STRONG, values = ReferenceType.STRONG)
+  @SuppressWarnings("FutureReturnValueIgnored")
   public void put_asyncWeight(AsyncLoadingCache<Integer, List<Integer>> cache,
       CacheContext context, Eviction<?, ?> eviction) {
     AtomicBoolean ready = new AtomicBoolean();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheGenerator.java
Patch:
@@ -193,9 +193,8 @@ public static <K, V> Cache<K, V> newCache(CacheContext context) {
         return CaffeineCacheFromContext.newCaffeineCache(context);
       case Guava:
         return GuavaCacheFromContext.newGuavaCache(context);
-      default:
-        throw new IllegalStateException();
     }
+    throw new IllegalStateException();
   }
 
   /** Fills the cache up to the population size. */

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/Collision.java
Patch:
@@ -15,9 +15,10 @@
  */
 package com.github.benmanes.caffeine.cache.impl;
 
-import com.fabahaba.collision.cache.CollisionCache;
 import com.github.benmanes.caffeine.cache.BasicCache;
 
+import systems.comodal.collision.cache.CollisionCache;
+
 /**
  * Requires JDK9.
  *

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/TCache.java
Patch:
@@ -30,7 +30,7 @@ public final class TCache<K, V> implements BasicCache<K, V> {
   public TCache(int maximumSize, EvictionPolicy policy) {
     cache = TCacheFactory.standardFactory().<K, V>builder()
         .setConcurrencyLevel(CacheType.CONCURRENCY_LEVEL)
-        .setExpectedMapSize(maximumSize)
+        .setMaxElements(maximumSize)
         .setEvictionPolicy(policy)
         .build();
   }

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/profiler/ProfilerHook.java
Patch:
@@ -44,6 +44,7 @@ public final void run() {
 
   protected abstract void profile();
 
+  @SuppressWarnings("FutureReturnValueIgnored")
   private void scheduleStatusTask() {
     Stopwatch stopwatch = Stopwatch.createStarted();
     Executors.newSingleThreadScheduledExecutor().scheduleWithFixedDelay(() -> {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Async.java
Patch:
@@ -74,6 +74,7 @@ static final class AsyncRemovalListener<K, V>
     }
 
     @Override
+    @SuppressWarnings("FutureReturnValueIgnored")
     public void onRemoval(K key, @Nonnull CompletableFuture<V> future, RemovalCause cause) {
       future.thenAcceptAsync(value -> {
         delegate.onRemoval(key, value, cause);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalLoadingCache.java
Patch:
@@ -149,6 +149,7 @@ default void bulkLoad(Set<K> keysToLoad, Map<K, V> result) {
   }
 
   @Override
+  @SuppressWarnings("FutureReturnValueIgnored")
   default void refresh(K key) {
     requireNonNull(key);
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/ConcurrentStatsCounter.java
Patch:
@@ -72,6 +72,7 @@ public void recordLoadFailure(@Nonnegative long loadTime) {
   }
 
   @Override
+  @SuppressWarnings("deprecation")
   public void recordEviction() {
     evictionCount.increment();
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/DisabledStatsCounter.java
Patch:
@@ -36,6 +36,7 @@ public void recordLoadSuccess(long loadTime) {}
   public void recordLoadFailure(long loadTime) {}
 
   @Override
+  @SuppressWarnings("deprecation")
   public void recordEviction() {}
 
   @Override

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsyncLoadingCacheTest.java
Patch:
@@ -77,6 +77,7 @@
  */
 @Listeners(CacheValidationListener.class)
 @Test(dataProviderClass = CacheProvider.class)
+@SuppressWarnings("FutureReturnValueIgnored")
 public final class AsyncLoadingCacheTest {
 
   /* ---------------- getIfPresent -------------- */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/EvictionTest.java
Patch:
@@ -205,6 +205,7 @@ public void evict_weighted_entryTooBig(Cache<Integer, Integer> cache, CacheConte
       weigher = CacheWeigher.VALUE, population = Population.EMPTY,
       keys = ReferenceType.STRONG, values = ReferenceType.STRONG,
       removalListener = Listener.CONSUMING)
+  @SuppressWarnings("FutureReturnValueIgnored")
   public void evict_weighted_async(AsyncLoadingCache<Integer, Integer> cache,
       CacheContext context, Eviction<?, ?> eviction) {
     AtomicBoolean ready = new AtomicBoolean();
@@ -236,6 +237,7 @@ public void evict_weighted_async(AsyncLoadingCache<Integer, Integer> cache,
   @CacheSpec(implementation = Implementation.Caffeine, maximumSize = Maximum.ZERO,
       weigher = CacheWeigher.COLLECTION, population = Population.EMPTY,
       keys = ReferenceType.STRONG, values = ReferenceType.STRONG)
+  @SuppressWarnings("FutureReturnValueIgnored")
   public void evict_zero_async(AsyncLoadingCache<Integer, List<Integer>> cache,
       CacheContext context, Eviction<?, ?> eviction) {
     AtomicBoolean ready = new AtomicBoolean();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpirationTest.java
Patch:
@@ -435,6 +435,7 @@ public void refresh_writerFails(LoadingCache<Integer, Integer> cache, CacheConte
       removalListener = Listener.CONSUMING, requiresExpiration = true,
       expireAfterAccess = {Expire.DISABLED, Expire.ONE_MINUTE},
       expireAfterWrite = {Expire.DISABLED, Expire.ONE_MINUTE})
+  @SuppressWarnings("FutureReturnValueIgnored")
   public void get(AsyncLoadingCache<Integer, Integer> cache, CacheContext context) {
     context.ticker().advance(2, TimeUnit.MINUTES);
 
@@ -451,6 +452,7 @@ public void get(AsyncLoadingCache<Integer, Integer> cache, CacheContext context)
   @CacheSpec(population = Population.EMPTY, removalListener = Listener.CONSUMING,
       requiresExpiration = true, expireAfterAccess = {Expire.DISABLED, Expire.ONE_MINUTE},
       expireAfterWrite = {Expire.DISABLED, Expire.ONE_MINUTE})
+  @SuppressWarnings("FutureReturnValueIgnored")
   public void get_async(AsyncLoadingCache<Integer, Integer> cache, CacheContext context) {
     CompletableFuture<Integer> future = new CompletableFuture<Integer>();
     cache.get(context.absentKey(), (k, e) -> future);
@@ -476,6 +478,7 @@ public void get_async(AsyncLoadingCache<Integer, Integer> cache, CacheContext co
       expireAfterAccess = {Expire.DISABLED, Expire.ONE_MINUTE},
       expireAfterWrite = {Expire.DISABLED, Expire.ONE_MINUTE},
       loader = {Loader.IDENTITY, Loader.BULK_IDENTITY})
+  @SuppressWarnings("FutureReturnValueIgnored")
   public void getAll(AsyncLoadingCache<Integer, Integer> cache, CacheContext context) {
     Set<Integer> keys = context.firstMiddleLastKeys();
     context.ticker().advance(1, TimeUnit.MINUTES);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterAccessTest.java
Patch:
@@ -170,6 +170,7 @@ public void getAll(LoadingCache<Integer, Integer> cache, CacheContext context) {
   @Test(dataProvider = "caches")
   @CacheSpec(expireAfterAccess = Expire.ONE_MINUTE,
       population = { Population.PARTIAL, Population.FULL })
+  @SuppressWarnings("FutureReturnValueIgnored")
   public void getIfPresent(AsyncLoadingCache<Integer, Integer> cache, CacheContext context) {
     context.ticker().advance(30, TimeUnit.SECONDS);
     cache.getIfPresent(context.firstKey());

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterWriteTest.java
Patch:
@@ -157,6 +157,7 @@ public void getAll(LoadingCache<Integer, Integer> cache, CacheContext context) {
   @Test(dataProvider = "caches")
   @CacheSpec(expireAfterWrite = Expire.ONE_MINUTE,
       population = { Population.PARTIAL, Population.FULL })
+  @SuppressWarnings("FutureReturnValueIgnored")
   public void getIfPresent(AsyncLoadingCache<Integer, Integer> cache, CacheContext context) {
     context.ticker().advance(30, TimeUnit.SECONDS);
     cache.getIfPresent(context.firstKey());

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/RefreshAfterWriteTest.java
Patch:
@@ -140,6 +140,7 @@ public void getFunc(LoadingCache<Integer, Integer> cache, CacheContext context)
   @Test(dataProvider = "caches")
   @CacheSpec(refreshAfterWrite = Expire.ONE_MINUTE,
       population = { Population.PARTIAL, Population.FULL })
+  @SuppressWarnings("FutureReturnValueIgnored")
   public void getFunc(AsyncLoadingCache<Integer, Integer> cache, CacheContext context) {
     Function<Integer, Integer> mappingFunction = context.original()::get;
     context.ticker().advance(30, TimeUnit.SECONDS);
@@ -171,6 +172,7 @@ public void get(LoadingCache<Integer, Integer> cache, CacheContext context) {
   @Test(dataProvider = "caches")
   @CacheSpec(refreshAfterWrite = Expire.ONE_MINUTE,
       population = { Population.PARTIAL, Population.FULL })
+  @SuppressWarnings("FutureReturnValueIgnored")
   public void get(AsyncLoadingCache<Integer, Integer> cache, CacheContext context) {
     context.ticker().advance(30, TimeUnit.SECONDS);
     cache.get(context.firstKey());
@@ -239,6 +241,7 @@ public void getAll(LoadingCache<Integer, Integer> cache, CacheContext context) {
   @Test(dataProvider = "caches")
   @CacheSpec(refreshAfterWrite = Expire.ONE_MINUTE, loader = Loader.IDENTITY,
       population = { Population.PARTIAL, Population.FULL })
+  @SuppressWarnings("FutureReturnValueIgnored")
   public void getAll(AsyncLoadingCache<Integer, Integer> cache, CacheContext context) {
     List<Integer> keys = ImmutableList.of(context.firstKey(), context.absentKey());
     context.ticker().advance(30, TimeUnit.SECONDS);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/Stresser.java
Patch:
@@ -67,6 +67,7 @@ private Operation(int maxThreads, int maxEntries) {
 
   private static final Operation operation = Operation.REFRESH;
 
+  @SuppressWarnings("FutureReturnValueIgnored")
   public Stresser() {
     ThreadFactory threadFactory = new ThreadFactoryBuilder()
         .setPriority(Thread.MAX_PRIORITY)

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/EventTypeFilter.java
Patch:
@@ -59,9 +59,8 @@ private boolean isCompatible(CacheEntryEvent<? extends K, ? extends V> event) {
         return (listener instanceof CacheEntryRemovedListener<?, ?>);
       case EXPIRED:
         return (listener instanceof CacheEntryExpiredListener<?, ?>);
-      default:
-        throw new CacheEntryListenerException("Unknown event type: " + event.getEventType());
     }
+    throw new CacheEntryListenerException("Unknown event type: " + event.getEventType());
   }
 
   @Override

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/spi/CaffeineCachingProvider.java
Patch:
@@ -136,9 +136,8 @@ public boolean isSupported(OptionalFeature optionalFeature) {
     switch (optionalFeature) {
       case STORE_BY_REFERENCE:
         return true;
-      default:
-        return false;
     }
+    return false;
   }
 
   private URI getManagerUri(URI uri) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/CollisionPolicy.java
Patch:
@@ -22,13 +22,14 @@
 
 import org.apache.commons.lang3.StringUtils;
 
-import com.fabahaba.collision.cache.CollisionBuilder;
-import com.fabahaba.collision.cache.CollisionCache;
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.typesafe.config.Config;
 
+import systems.comodal.collision.cache.CollisionBuilder;
+import systems.comodal.collision.cache.CollisionCache;
+
 /**
  * Collision cache implementation.
  *

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/TCachePolicy.java
Patch:
@@ -41,7 +41,7 @@ public TCachePolicy(Config config) {
     TCacheSettings settings = new TCacheSettings(config);
     policyStats = new PolicyStats("product.TCache");
     cache = TCacheFactory.standardFactory().builder()
-        .setExpectedMapSize(settings.maximumSize())
+        .setMaxElements(settings.maximumSize())
         .setEvictionClass(settings.policy())
         .setStatistics(true)
         .build();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/TwoQueuePolicy.java
Patch:
@@ -118,8 +118,6 @@ public void record(long key) {
           // do nothing
           policyStats.recordHit();
           return;
-        default:
-          throw new IllegalStateException();
       }
     } else {
       node = new Node(key);

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/TCache.java
Patch:
@@ -17,9 +17,9 @@
 
 import com.github.benmanes.caffeine.cache.BasicCache;
 import com.github.benmanes.caffeine.cache.CacheType;
+import com.trivago.triava.tcache.Cache;
 import com.trivago.triava.tcache.EvictionPolicy;
 import com.trivago.triava.tcache.TCacheFactory;
-import com.trivago.triava.tcache.eviction.Cache;
 
 /**
  * @author ben.manes@gmail.com (Ben Manes)

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/TCachePolicy.java
Patch:
@@ -21,9 +21,9 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.Policy;
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.google.common.collect.ImmutableSet;
+import com.trivago.triava.tcache.Cache;
 import com.trivago.triava.tcache.TCacheFactory;
-import com.trivago.triava.tcache.core.EvictionInterface;
-import com.trivago.triava.tcache.eviction.Cache;
+import com.trivago.triava.tcache.eviction.EvictionInterface;
 import com.trivago.triava.tcache.eviction.LFUEviction;
 import com.trivago.triava.tcache.eviction.LRUEviction;
 import com.typesafe.config.Config;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsMapTest.java
Patch:
@@ -2050,7 +2050,7 @@ public void entrySpliterator_forEachRemaining(
       Map<Integer, Integer> map, CacheContext context) {
     int[] count = new int[1];
     map.entrySet().spliterator().forEachRemaining(entry -> {
-      if (!context.isGuava()) {
+      if (context.isCaffeine()) {
         assertThat(entry, is(instanceOf(WriteThroughEntry.class)));
       }
       count[0]++;
@@ -2075,7 +2075,7 @@ public void entrySpliterator_tryAdvance(Map<Integer, Integer> map, CacheContext
     boolean advanced;
     do {
       advanced = spliterator.tryAdvance(entry -> {
-        if (!context.isGuava()) {
+        if (context.isCaffeine()) {
           assertThat(entry, is(instanceOf(WriteThroughEntry.class)));
         }
         count[0]++;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/Cache2kPolicy.java
Patch:
@@ -68,12 +68,11 @@ public static Set<Policy> policies(Config config) {
   }
 
   @Override
-  @SuppressWarnings("deprecation")
   public void record(long key) {
     Object value = cache.peek(key);
     if (value == null) {
       policyStats.recordMiss();
-      if (cache.getTotalEntryCount() == maximumSize) {
+      if (cache.asMap().size() == maximumSize) {
         policyStats.recordEviction();
       }
       cache.put(key, key);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/TCachePolicy.java
Patch:
@@ -70,7 +70,7 @@ public PolicyStats stats() {
 
   @Override
   public void finished() {
-    cache.shutdown();
+    cache.close();
     policyStats.addEvictions(cache.statistics().getEvictionCount());
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/segment/RandomWindowTinyLfuPolicy.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.github.benmanes.caffeine.cache.simulator.policy.sketch;
+package com.github.benmanes.caffeine.cache.simulator.policy.sketch.segment;
 
 import static java.util.stream.Collectors.toSet;
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/segment/S4WindowTinyLfuPolicy.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.github.benmanes.caffeine.cache.simulator.policy.sketch;
+package com.github.benmanes.caffeine.cache.simulator.policy.sketch.segment;
 
 import static com.google.common.base.Preconditions.checkState;
 import static java.util.stream.Collectors.toSet;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/QueueType.java
Patch:
@@ -31,6 +31,7 @@
 /**
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("ImmutableEnumChecker")
 public enum QueueType {
   MpscLinkedQueue(MpscLinkedQueue8::new),
   SingleConsumerQueue_optimistic(SingleConsumerQueue::optimistic),

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/BufferType.java
Patch:
@@ -24,6 +24,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("ImmutableEnumChecker")
 public enum BufferType {
   Ticket(TicketBuffer::new),
   FastFlow(FastFlowBuffer::new),

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheSpec.java
Patch:
@@ -58,6 +58,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("ImmutableEnumChecker")
 @Target(METHOD) @Retention(RUNTIME)
 public @interface CacheSpec {
 
@@ -206,7 +207,7 @@ enum CacheWeigher implements Weigher<Object, Object> {
       }
     };
 
-    private int units;
+    private final int units;
 
     private CacheWeigher(int multiplier) {
       this.units = multiplier;

File: examples/write-behind-rxjava/src/main/java/com/github/benmanes/caffeine/examples/writebehind/rxjava/WriteBehindCacheWriter.java
Patch:
@@ -28,7 +28,7 @@
 import com.github.benmanes.caffeine.cache.CacheWriter;
 import com.github.benmanes.caffeine.cache.RemovalCause;
 
-import rx.subjects.PublishSubject;
+import io.reactivex.subjects.PublishSubject;
 
 /**
  * This class implements the {@link CacheWriter} interface to allow a cache to have "write-behind"
@@ -47,7 +47,7 @@
  * @author wim.deblauwe@gmail.com (Wim Deblauwe)
  */
 public final class WriteBehindCacheWriter<K, V> implements CacheWriter<K, V> {
-  private final PublishSubject<SimpleImmutableEntry<K, V>> subject;
+  private final PublishSubject<Entry<K, V>> subject;
 
   private WriteBehindCacheWriter(Builder<K, V> builder) {
     subject = PublishSubject.create();

File: guava/src/test/java/com/github/benmanes/caffeine/cache/QueueSanityTest.java
Patch:
@@ -144,7 +144,7 @@ public void whenOfferItemAndPollItemThenSameInstanceReturnedAndQueueIsEmpty() {
     assertThat(queue, emptyAndZeroSize());
 
     // Act
-    final Integer e = new Integer(1876876);
+    final Integer e = 1876876;
     queue.offer(e);
     assertFalse(queue.isEmpty());
     assertEquals(1, queue.size());

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/Admission.java
Patch:
@@ -26,6 +26,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("ImmutableEnumChecker")
 public enum Admission {
   ALWAYS((config, policyStats) -> Admittor.always(), Function.identity()),
   TINYLFU(TinyLfu::new, name -> name + "_TinyLfu");

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/TraceFormat.java
Patch:
@@ -32,6 +32,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("ImmutableEnumChecker")
 public enum TraceFormat {
   ADDRESS(AddressTraceReader::new),
   ARC(ArcTraceReader::new),

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/ReportFormat.java
Patch:
@@ -26,6 +26,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("ImmutableEnumChecker")
 public enum ReportFormat {
   TABLE(TableReporter::new),
   CSV(CsvReporter::new);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/Registry.java
Patch:
@@ -44,6 +44,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.product.ElasticSearchPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.GuavaPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.InfinispanPolicy;
+import com.github.benmanes.caffeine.cache.simulator.policy.product.OhcPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.TCachePolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.sampled.SamplingPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.AdaptiveTinyLfuPolicy;
@@ -150,6 +151,7 @@ private static void registerAdaptive(Map<String, Function<Config, Set<Policy>>>
   }
 
   private static void registerProduct(Map<String, Function<Config, Set<Policy>>> factories) {
+    factories.put("product.ohc", OhcPolicy::policies);
     factories.put("product.guava", GuavaPolicy::policies);
     factories.put("product.tcache", TCachePolicy::policies);
     factories.put("product.cache2k", Cache2kPolicy::policies);

File: caffeine/src/main/java/com/github/benmanes/caffeine/base/UnsafeAccess.java
Patch:
@@ -63,7 +63,7 @@ public static long objectFieldOffset(Class<?> clazz, String fieldName) {
   static Unsafe load(String openJdk, String android) throws NoSuchMethodException,
       SecurityException, InstantiationException, IllegalAccessException,
       IllegalArgumentException, InvocationTargetException {
-    Field field = null;
+    Field field;
     try {
       // try OpenJDK field name
       field = Unsafe.class.getDeclaredField(openJdk);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CaffeineTest.java
Patch:
@@ -34,7 +34,7 @@
 import com.github.benmanes.caffeine.cache.Policy.Eviction;
 import com.github.benmanes.caffeine.cache.Policy.Expiration;
 import com.github.benmanes.caffeine.cache.stats.StatsCounter;
-import com.github.benmanes.caffeine.cache.testing.FakeTicker;
+import com.google.common.testing.FakeTicker;
 import com.google.common.util.concurrent.MoreExecutors;
 
 /**
@@ -449,7 +449,7 @@ public void ticker_twice() {
 
   @Test
   public void ticker() {
-    Ticker ticker = new FakeTicker();
+    Ticker ticker = new FakeTicker()::read;
     Caffeine<?, ?> builder = Caffeine.newBuilder().ticker(ticker);
     assertThat(builder.ticker, is(ticker));
     builder.build();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java
Patch:
@@ -35,14 +35,14 @@
 import com.github.benmanes.caffeine.cache.LoadingCache;
 import com.github.benmanes.caffeine.cache.Policy;
 import com.github.benmanes.caffeine.cache.RemovalCause;
-import com.github.benmanes.caffeine.cache.Ticker;
 import com.github.benmanes.caffeine.cache.stats.CacheStats;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.CacheWeigher;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Expire;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.InitialCapacity;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Listener;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Maximum;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.ReferenceType;
+import com.google.common.base.Ticker;
 import com.google.common.cache.AbstractCache.SimpleStatsCounter;
 import com.google.common.cache.AbstractCache.StatsCounter;
 import com.google.common.cache.CacheBuilder;
@@ -113,7 +113,7 @@ public static <K, V> Cache<K, V> newGuavaCache(CacheContext context) {
       builder.removalListener(new GuavaRemovalListener<>(
           translateZeroExpire, context.removalListener));
     }
-    Ticker ticker = (context.ticker == null) ? Ticker.systemTicker() : context.ticker;
+    Ticker ticker = (context.ticker == null) ? Ticker.systemTicker() : context.ticker();
     if (context.loader == null) {
       context.cache = new GuavaCache<>(builder.<Integer, Integer>build(),
           ticker, context.isRecordingStats());

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuava.java
Patch:
@@ -42,7 +42,7 @@ private CaffeinatedGuava() {}
    * @return a cache exposed under the Guava APIs
    */
   @Nonnull
-  public static <K1 extends K, K, V1 extends V, V> Cache<K1, V1> build(
+  public static <K, V, K1 extends K, V1 extends V> Cache<K1, V1> build(
       @Nonnull Caffeine<K, V> builder) {
     return new CaffeinatedGuavaCache<>(builder.build());
   }
@@ -55,7 +55,7 @@ public static <K1 extends K, K, V1 extends V, V> Cache<K1, V1> build(
    * @return a cache exposed under the Guava APIs
    */
   @Nonnull
-  public static <K1 extends K, K, V1 extends V, V> LoadingCache<K1, V1> build(
+  public static <K, V, K1 extends K, V1 extends V> LoadingCache<K1, V1> build(
       @Nonnull Caffeine<K, V> builder, @Nonnull CacheLoader<? super K1, V1> loader) {
     @SuppressWarnings("unchecked")
     CacheLoader<K1, V1> castedLoader = (CacheLoader<K1, V1>) loader;
@@ -72,7 +72,7 @@ public static <K1 extends K, K, V1 extends V, V> LoadingCache<K1, V1> build(
    * @return a cache exposed under the Guava APIs
    */
   @Nonnull
-  public static <K1 extends K, K, V1 extends V, V> LoadingCache<K1, V1> build(
+  public static <K, V, K1 extends K, V1 extends V> LoadingCache<K1, V1> build(
       @Nonnull Caffeine<K, V> builder,
       @Nonnull com.github.benmanes.caffeine.cache.CacheLoader<? super K1, V1> loader) {
     return new CaffeinatedGuavaLoadingCache<>(builder.build(loader));

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1634,7 +1634,7 @@ V putSlow(K key, V value, int newWeight, boolean notifyWriter, boolean onlyIfAbs
         nodeKey[0] = n.getKey();
         oldValue[0] = n.getValue();
         oldWeight[0] = n.getWeight();
-        if ((nodeKey == null) || (oldValue[0] == null)) {
+        if ((nodeKey[0] == null) || (oldValue[0] == null)) {
           cause[0] = RemovalCause.COLLECTED;
         } else if (hasExpired(n, now)) {
           cause[0] = RemovalCause.EXPIRED;
@@ -1994,7 +1994,7 @@ V doComputeIfAbsent(K key, Object keyRef,
         nodeKey[0] = n.getKey();
         weight[0] = n.getWeight();
         oldValue[0] = n.getValue();
-        if ((nodeKey == null) || (oldValue[0] == null)) {
+        if ((nodeKey[0] == null) || (oldValue[0] == null)) {
           cause[0] = RemovalCause.COLLECTED;
         } else if (hasExpired(n, now)) {
           cause[0] = RemovalCause.EXPIRED;
@@ -2141,7 +2141,7 @@ V remap(K key, Object keyRef, BiFunction<? super K, ? super V, ? extends V> rema
       synchronized (n) {
         nodeKey[0] = n.getKey();
         oldValue[0] = n.getValue();
-        if ((nodeKey == null) || (oldValue[0] == null)) {
+        if ((nodeKey[0] == null) || (oldValue[0] == null)) {
           cause[0] = RemovalCause.COLLECTED;
         } else if (hasExpired(n, now)) {
           cause[0] = RemovalCause.EXPIRED;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/table/RandomRemovalFrequencyTable.java
Patch:
@@ -81,7 +81,7 @@ public void increment(long e) {
     // just a model.
     if (currSum == maxSum) {
       List<Long> array = new ArrayList<>(table.keySet());
-      long itemToRemove = array.get(random.nextInt(array.size()));
+      Long itemToRemove = array.get(random.nextInt(array.size()));
       value = table.remove(itemToRemove);
 
       if (value > 1) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/HashFunctionParser.java
Patch:
@@ -50,7 +50,7 @@ public HashedItem createHash(long item) {
     h ^= item;
     h *= m;
 
-    fpaux.fingerprint = (byte) (h & fpMask);
+    fpaux.fingerprint = (byte) h;
     // the next line is a dirty fix as I do not want the value of 0 as a fingerprint.
     // It can be eliminated if we want very short fingerprints.
     fpaux.fingerprint = (fpaux.fingerprint == 0L) ? 1 : fpaux.fingerprint;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinyCacheAdapter.java
Patch:
@@ -27,8 +27,6 @@
 public final class TinyCacheAdapter implements Frequency {
   // the actual data structure.
   TinyCacheSketch tcs;
-  // number of (independent sets)
-  int nrSets;
   // size between cache and sample.
   static final int sampleFactor = 10;
   // max frequency estimation of an item.
@@ -39,7 +37,7 @@ public final class TinyCacheAdapter implements Frequency {
    */
   public TinyCacheAdapter(Config config) {
     BasicSettings settings = new BasicSettings(config);
-    nrSets = sampleFactor * settings.maximumSize() / 64;
+    int nrSets = sampleFactor * settings.maximumSize() / 64; // number of (independent sets)
     tcs = new TinyCacheSketch(nrSets, 64,settings.randomSeed());
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinycache/TinyCacheWithGhostCache.java
Patch:
@@ -26,13 +26,14 @@
  */
 @SuppressWarnings("PMD.AvoidDollarSigns")
 public final class TinyCacheWithGhostCache {
+  private static final int sampleSize = 10;
+
   public final long[] chainIndex;
   public final long[] isLastIndex;
   private final HashFunctionParser hashFunc;
   private final int itemsPerSet;
   private final long[] cache;
   private final Random rnd;
-  private final int sampleSize;
   private final TinyCacheSketch ghostCache;
 
   public TinyCacheWithGhostCache(int nrSets, int itemsPerSet, int randomSeed) {
@@ -41,7 +42,6 @@ public TinyCacheWithGhostCache(int nrSets, int itemsPerSet, int randomSeed) {
     hashFunc = new HashFunctionParser(nrSets);
     this.itemsPerSet = itemsPerSet;
     cache = new long[nrSets * itemsPerSet];
-    sampleSize = 10;
     ghostCache = new TinyCacheSketch(nrSets * sampleSize, itemsPerSet, randomSeed + 1);
     rnd = new Random(randomSeed);
   }

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/ComputeBenchmark.java
Patch:
@@ -20,6 +20,7 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ExecutionException;
 import java.util.function.Function;
 
 import org.openjdk.jmh.annotations.Benchmark;
@@ -29,7 +30,6 @@
 import org.openjdk.jmh.annotations.State;
 import org.openjdk.jmh.annotations.Threads;
 
-import com.google.common.base.Throwables;
 import com.google.common.cache.CacheBuilder;
 import com.yahoo.ycsb.generator.NumberGenerator;
 import com.yahoo.ycsb.generator.ScrambledZipfianGenerator;
@@ -106,8 +106,8 @@ private void setupGuava() {
     benchmarkFunction = key -> {
       try {
         return cache.get(key, valueLoader);
-      } catch (Exception e) {
-        throw Throwables.propagate(e);
+      } catch (ExecutionException e) {
+        throw new RuntimeException(e);
       }
     };
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/umass/network/YoutubeTraceReader.java
Patch:
@@ -15,8 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.parser.umass.network;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-
 import java.io.IOException;
 import java.util.List;
 import java.util.stream.LongStream;
@@ -41,6 +39,6 @@ public LongStream events() throws IOException {
     return lines()
         .map(line -> line.split(" "))
         .filter(array -> array[3].equals("GETVIDEO"))
-        .mapToLong(array -> Hashing.murmur3_128().hashString(array[4], UTF_8).asLong());
+        .mapToLong(array -> Hashing.murmur3_128().hashUnencodedChars(array[4]).asLong());
   }
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/wikipedia/WikipediaTraceReader.java
Patch:
@@ -16,7 +16,6 @@
 package com.github.benmanes.caffeine.cache.simulator.parser.wikipedia;
 
 import java.io.IOException;
-import java.nio.charset.StandardCharsets;
 import java.util.List;
 import java.util.Objects;
 import java.util.stream.LongStream;
@@ -51,7 +50,7 @@ public LongStream events() throws IOException {
     return lines()
         .map(this::parseRequest)
         .filter(Objects::nonNull)
-        .mapToLong(path -> Hashing.murmur3_128().hashString(path, StandardCharsets.UTF_8).asLong());
+        .mapToLong(path -> Hashing.murmur3_128().hashUnencodedChars(path).asLong());
   }
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheLoader.java
Patch:
@@ -43,7 +43,7 @@
  */
 @ThreadSafe
 @FunctionalInterface
-@SuppressWarnings("PMD.SignatureDeclareThrowsException")
+@SuppressWarnings({"PMD.SignatureDeclareThrowsException", "FunctionalInterfaceMethodChanged"})
 public interface CacheLoader<K, V> extends AsyncCacheLoader<K, V> {
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalCache.java
Patch:
@@ -110,15 +110,15 @@ V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction
 
   @Override
   default V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {
-    return computeIfAbsent(key, mappingFunction, /* recordMiss */ true, /* recordLoad */ true);
+    return computeIfAbsent(key, mappingFunction, /* recordStats */ true, /* recordLoad */ true);
   }
 
   /**
    * See {@link ConcurrentMap#computeIfAbsent}. This method differs by accepting parameters
-   * indicating whether the operation was called by an asynchronous cache.
+   * indicating how to record statistics.
    */
   V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction,
-      boolean recordMiss, boolean recordLoad);
+      boolean recordStats, boolean recordLoad);
 
   /** See {@link Cache#invalidateAll(Iterable)}. */
   default void invalidateAll(Iterable<?> keys) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/RandomSeedEnforcer.java
Patch:
@@ -48,7 +48,8 @@ public static void ensureRandomSeed(FrequencySketch<?> sketch) {
       field.setAccessible(true);
       field.setInt(sketch, RANDOM_SEED);
     } catch (Exception e) {
-      throw Throwables.propagate(e);
+      Throwables.throwIfUnchecked(e);
+      throw new RuntimeException(e);
     }
   }
 }

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaLoadingCache.java
Patch:
@@ -159,7 +159,8 @@ public V reload(K key, V oldValue) {
         Thread.currentThread().interrupt();
         throw new CacheLoaderException(e);
       } catch (Exception e) {
-        throw Throwables.propagate(e);
+        Throwables.throwIfUnchecked(e);
+        throw new RuntimeException(e);
       }
     }
   }

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/Specifications.java
Patch:
@@ -99,7 +99,8 @@ public final class Specifications {
   public static final TypeName WRITE_ORDER_DEQUE = ParameterizedTypeName.get(
       ClassName.get(PACKAGE_NAME, "WriteOrderDeque"), NODE);
 
-  public static final ClassName WRITE_QUEUE_TYPE = ClassName.get(PACKAGE_NAME, "WriteBuffer");
+  public static final ClassName WRITE_QUEUE_TYPE =
+      ClassName.get(PACKAGE_NAME, "MpscGrowableArrayQueue");
   public static final TypeName WRITE_QUEUE = ParameterizedTypeName.get(
       WRITE_QUEUE_TYPE, ClassName.get(Runnable.class));
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/base/UnsafeAccess.java
Patch:
@@ -29,6 +29,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("restriction")
 public final class UnsafeAccess {
   static final String ANDROID = "THE_ONE";
   static final String OPEN_JDK = "theUnsafe";

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -235,7 +235,7 @@ protected boolean buffersWrites() {
     return false;
   }
 
-  protected WriteBuffer<Runnable> writeBuffer() {
+  protected MpscGrowableArrayQueue<Runnable> writeBuffer() {
     throw new UnsupportedOperationException();
   }
 
@@ -634,6 +634,7 @@ void evictFromMain(int candidates) {
    * @param victimKey the key for the entry chosen by the eviction policy for replacement
    * @return if the candidate should be admitted and the victim ejected
    */
+  @GuardedBy("evictionLock")
   boolean admit(K candidateKey, K victimKey) {
     int victimFreq = frequencySketch().frequency(victimKey);
     int candidateFreq = frequencySketch().frequency(candidateKey);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/EvictionTest.java
Patch:
@@ -656,7 +656,7 @@ public void coldest_snapshot(Cache<Integer, Integer> cache, CacheContext context
   @CacheSpec(implementation = Implementation.Caffeine, maximumSize = Maximum.FULL)
   @Test(dataProvider = "caches", expectedExceptions = UnsupportedOperationException.class)
   public void hottest_unmodifiable(CacheContext context, Eviction<Integer, Integer> eviction) {
-    eviction.hottest(Integer.MAX_VALUE).clear();;
+    eviction.hottest(Integer.MAX_VALUE).clear();
   }
 
   @CacheSpec(implementation = Implementation.Caffeine, maximumSize = Maximum.FULL)

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/Registry.java
Patch:
@@ -38,6 +38,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.opt.UnboundedPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.Cache2kPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.CaffeinePolicy;
+import com.github.benmanes.caffeine.cache.simulator.policy.product.CollisionPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.Ehcache2Policy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.Ehcache3Policy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.ElasticSearchPolicy;
@@ -155,6 +156,7 @@ private static void registerProduct(Map<String, Function<Config, Set<Policy>>> f
     factories.put("product.ehcache2", Ehcache2Policy::policies);
     factories.put("product.ehcache3", Ehcache3Policy::policies);
     factories.put("product.caffeine", CaffeinePolicy::policies);
+    factories.put("product.collision", CollisionPolicy::policies);
     factories.put("product.infinispan", InfinispanPolicy::policies);
     factories.put("product.elasticsearch", ElasticSearchPolicy::policies);
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LoadingCache.java
Patch:
@@ -67,7 +67,7 @@ public interface LoadingCache<K, V> extends Cache<K, V> {
   /**
    * Returns a map of the values associated with the {@code keys}, creating or retrieving those
    * values if necessary. The returned map contains entries that were already cached, combined with
-   * newly loaded entries; it will never contain null keys or values.
+   * the newly loaded entries; it will never contain null keys or values.
    * <p>
    * Caches loaded by a {@link CacheLoader} will issue a single request to
    * {@link CacheLoader#loadAll} for all keys which are not already present in the cache. All

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Policy.java
Patch:
@@ -134,6 +134,7 @@ default OptionalInt weightOf(@Nonnull K key) {
      *
      * @return the maximum size bounding, which may be either weighted or unweighted
      */
+    @Nonnegative
     long getMaximum();
 
     /**

File: caffeine/src/test/java/com/github/benmanes/caffeine/SingleConsumerQueueTest.java
Patch:
@@ -119,6 +119,7 @@ public void containsAll_withNull(Queue<?> queue) {
   }
 
   @Test(dataProvider = "populated")
+  @SuppressWarnings("ModifyingCollectionWithItself")
   public void containsAll_whenFound(Queue<Integer> queue) {
     assertThat(queue.containsAll(
         ImmutableList.of(0, POPULATED_SIZE / 2, POPULATED_SIZE - 1)), is(true));

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CaffeineTest.java
Patch:
@@ -118,12 +118,12 @@ public void loading_nullLoader() {
   @Test
   public void async_nullLoader() {
     try {
-      Caffeine.newBuilder().buildAsync((CacheLoader<?, ?>) null);
+      Caffeine.newBuilder().buildAsync((CacheLoader<Object, Object>) null);
       Assert.fail();
     } catch (NullPointerException expected) {}
 
     try {
-      Caffeine.newBuilder().buildAsync((AsyncCacheLoader<?, ?>) null);
+      Caffeine.newBuilder().buildAsync((AsyncCacheLoader<Object, Object>) null);
       Assert.fail();
     } catch (NullPointerException expected) {}
   }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LinkedDequeTest.java
Patch:
@@ -424,6 +424,7 @@ public void addAll_withPopulated(LinkedDeque<LinkedValue> deque) {
   }
 
   @Test(dataProvider = "full")
+  @SuppressWarnings("ModifyingCollectionWithItself")
   public void addAll_withSelf(LinkedDeque<LinkedValue> deque) {
     assertThat(deque.addAll(deque), is(false));
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -101,7 +101,7 @@ abstract class BoundedLocalCache<K, V> extends BLCHeader.DrainStatusRef<K, V>
    * draining process is required. Due to the concurrent nature of the read and write operations a
    * strict policy ordering is not possible, but is observably strict when single threaded. The
    * buffers are drained asynchronously to minimize the request latency and uses a state machine to
-   * determine when to scheduling a task on an executor.
+   * determine when to schedule a task on an executor.
    *
    * Due to a lack of a strict ordering guarantee, a task can be executed out-of-order, such as a
    * removal followed by its addition. The state of the entry is encoded using the key field to
@@ -528,7 +528,6 @@ int evictFromEden() {
    * when there are no more candidates the victim is evicted.
    *
    * @param candidates the number of candidate entries evicted from the eden space
-   * @return if an eviction occurred
    */
   @GuardedBy("evictionLock")
   void evictFromMain(int candidates) {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/TypesafeConfigurator.java
Patch:
@@ -93,7 +93,7 @@ public static <K, V> Optional<CaffeineConfiguration<K, V>> from(Config config, S
    * @param factoryCreator the strategy for creating a factory
    */
   @Inject
-  public static void setFactoryBuilder(FactoryCreator factoryCreator) {
+  public static void setFactoryCreator(FactoryCreator factoryCreator) {
     TypesafeConfigurator.factoryCreator = requireNonNull(factoryCreator);
   }
 

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/JCacheGuiceTest.java
Patch:
@@ -64,7 +64,7 @@ public void beforeMethod() {
 
   @AfterClass
   public void afterClass() {
-    TypesafeConfigurator.setFactoryBuilder(FactoryBuilder::factoryOf);
+    TypesafeConfigurator.setFactoryCreator(FactoryBuilder::factoryOf);
   }
 
   @Test

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/management/JCacheMBeanServerBuilder.java
Patch:
@@ -26,8 +26,6 @@
 import javax.management.NotificationFilter;
 import javax.management.NotificationListener;
 
-import com.sun.jmx.mbeanserver.JmxMBeanServer;
-
 /**
  * An MBeanServer for the TCK that sets the mbean server id to the value of the
  * <code>org.jsr107.tck.management.agentId</code> system property.
@@ -40,7 +38,7 @@ public final class JCacheMBeanServerBuilder extends MBeanServerBuilder {
   public MBeanServer newMBeanServer(String defaultDomain,
       MBeanServer outer, MBeanServerDelegate delegate) {
     MBeanServerDelegate jcacheDelegate = new JCacheMBeanServerDelegate(delegate);
-    return JmxMBeanServer.newMBeanServer(defaultDomain, outer, jcacheDelegate, false);
+    return new MBeanServerBuilder().newMBeanServer(defaultDomain, outer, jcacheDelegate);
   }
 
   private static final class JCacheMBeanServerDelegate extends MBeanServerDelegate {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/EvictionTest.java
Patch:
@@ -522,7 +522,8 @@ public void maximumSize_decrease(Cache<Integer, Integer> cache,
   }
 
   @Test(dataProvider = "caches")
-  @CacheSpec(implementation = Implementation.Caffeine, maximumSize = Maximum.FULL,
+  @CacheSpec(implementation = Implementation.Caffeine,
+      maximumSize = Maximum.FULL, weigher = { CacheWeigher.DEFAULT, CacheWeigher.TEN },
       removalListener = { Listener.DEFAULT, Listener.CONSUMING })
   public void maximumSize_decrease_min(Cache<Integer, Integer> cache,
       CacheContext context, Eviction<Integer, Integer> eviction) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncLoadingCache.java
Patch:
@@ -139,7 +139,7 @@ CompletableFuture<V> get(K key,
         long loadTime = cache.statsTicker().read() - startTime;
         if (value == null) {
           if (error != null) {
-            logger.log(Level.WARNING, "Exception thrown during asynchonous load", error);
+            logger.log(Level.WARNING, "Exception thrown during asynchronous load", error);
           }
           cache.statsCounter().recordLoadFailure(loadTime);
           cache.remove(key, result[0]);
@@ -241,7 +241,7 @@ public void put(K key, CompletableFuture<V> valueFuture) {
       long loadTime = cache.statsTicker().read() - startTime;
       if (value == null) {
         if (error != null) {
-          logger.log(Level.WARNING, "Exception thrown during asynchonous load", error);
+          logger.log(Level.WARNING, "Exception thrown during asynchronous load", error);
         }
         cache.remove(key, valueFuture);
         cache.statsCounter().recordLoadFailure(loadTime);
@@ -281,7 +281,7 @@ public void accept(Map<K, V> result, Throwable error) {
           entry.getValue().obtrudeException(error);
         }
         cache.statsCounter().recordLoadFailure(loadTime);
-        logger.log(Level.WARNING, "Exception thrown during asynchonous load", error);
+        logger.log(Level.WARNING, "Exception thrown during asynchronous load", error);
       } else {
         fillProxies(result);
         addNewEntries(result);

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheFactoryGenerator.java
Patch:
@@ -92,7 +92,7 @@ void generate() throws IOException {
     factory = TypeSpec.classBuilder("LocalCacheFactory")
         .addModifiers(Modifier.FINAL)
         .addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
-        .addMember("value", "{$S, $S, $S}", "unchecked", "unused", "PMD")
+        .addMember("value", "{$S, $S, $S, $S}", "unchecked", "unused", "PMD", "MissingOverride")
         .build());
     addClassJavaDoc();
     generateLocalCaches();

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeFactoryGenerator.java
Patch:
@@ -105,7 +105,8 @@ public NodeFactoryGenerator(Path directory) {
   void generate() throws IOException {
     nodeFactory = TypeSpec.enumBuilder("NodeFactory")
         .addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
-            .addMember("value", "{$S, $S, $S}", "unchecked", "GuardedByChecker", "PMD")
+            .addMember("value", "{$S, $S, $S, $S}", "unchecked", "PMD",
+                "GuardedByChecker", "MissingOverride")
             .build());
     addClassJavaDoc();
     addNodeStateStatics();

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/NodeRule.java
Patch:
@@ -81,7 +81,7 @@ protected final MethodSpec newGetter(Strength strength, TypeName varType,
         .returns(varType);
     String type;
     if (varType.isPrimitive()) {
-      type = (varType == TypeName.INT) ? "Int" : "Long";
+      type = varType.equals(TypeName.INT) ? "Int" : "Long";
     } else {
       type = "Object";
     }
@@ -113,7 +113,7 @@ protected final MethodSpec newSetter(TypeName varType, String varName, Visibilit
     String methodName = "set" + Character.toUpperCase(varName.charAt(0)) + varName.substring(1);
     String type;
     if (varType.isPrimitive()) {
-      type = (varType == TypeName.INT) ? "Int" : "Long";
+      type = varType.equals(TypeName.INT) ? "Int" : "Long";
     } else {
       type = "Object";
     }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/CacheStats.java
Patch:
@@ -46,7 +46,6 @@
  *   <li>When an entry is evicted from the cache, {@code evictionCount} is incremented and the
  *       weight added to {@code evictionWeight}.
  *   <li>No stats are modified when a cache entry is invalidated or manually removed.
- *   <li>No stats are modified on a query to {@link Cache#getIfPresent}.
  *   <li>No stats are modified by non-computing operations invoked on the
  *       {@linkplain Cache#asMap asMap} view of the cache.
  * </ul>

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsMapTest.java
Patch:
@@ -1373,6 +1373,7 @@ public void equals_null(Map<Integer, Integer> map, CacheContext context) {
 
   @CheckNoWriter @CheckNoStats
   @Test(dataProvider = "caches")
+  @SuppressWarnings("SelfEquals")
   @CacheSpec(removalListener = { Listener.DEFAULT, Listener.REJECTING })
   public void equals_self(Map<Integer, Integer> map, CacheContext context) {
     assertThat(map.equals(map), is(true));

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -28,6 +28,7 @@
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.not;
 import static org.hamcrest.Matchers.nullValue;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
@@ -40,7 +41,6 @@
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 
-import org.mockito.Matchers;
 import org.mockito.Mockito;
 import org.testng.annotations.Listeners;
 import org.testng.annotations.Test;
@@ -117,8 +117,8 @@ public void scheduleDrainBuffers() {
       cache.scheduleDrainBuffers();
       assertThat(cache.drainStatus, is(end));
 
-      if (start != end) {
-        Mockito.verify(executor).execute(Matchers.any());
+      if (!start.equals(end)) {
+        Mockito.verify(executor).execute(any());
         Mockito.reset(executor);
       }
     });

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/MultiThreadedTest.java
Patch:
@@ -94,7 +94,7 @@ public void async_concurrent_bounded(
     Threads.runTest(cache, asyncOperations);
   }
 
-  @SuppressWarnings({"unchecked", "rawtypes", "SizeGreaterThanOrEqualsZero"})
+  @SuppressWarnings({"unchecked", "rawtypes", "SizeGreaterThanOrEqualsZero", "SelfEquals"})
   List<BiConsumer<LoadingCache<Integer, Integer>, Integer>> operations = ImmutableList.of(
       // LoadingCache
       (cache, key) -> cache.get(key),
@@ -142,7 +142,7 @@ public void async_concurrent_bounded(
       (cache, key) -> cache.asMap().values().toArray(new Object[cache.asMap().size()]),
       (cache, key) -> cache.asMap().entrySet().toArray(new Entry[cache.asMap().size()]),
       (cache, key) -> cache.hashCode(),
-      (cache, key) -> cache.equals(cache),
+      (cache, key) -> { cache.equals(cache); },
       (cache, key) -> cache.toString(),
       (cache, key) -> { // expensive so do it less frequently
         int random = ThreadLocalRandom.current().nextInt();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ReferenceTest.java
Patch:
@@ -61,6 +61,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 @Listeners(CacheValidationListener.class)
+@SuppressWarnings("BoxedPrimitiveConstructor")
 @Test(groups = "slow", dataProviderClass = CacheProvider.class)
 public final class ReferenceTest {
   // These tests require that the JVM uses -XX:SoftRefLRUPolicyMSPerMB=0 so that soft references

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/stats/StatsCounterTest.java
Patch:
@@ -17,8 +17,8 @@
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
-import static org.mockito.Matchers.anyInt;
-import static org.mockito.Matchers.anyLong;
+import static org.mockito.ArgumentMatchers.anyInt;
+import static org.mockito.ArgumentMatchers.anyLong;
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContext.java
Patch:
@@ -377,7 +377,7 @@ public <K, V> LoadingCache<K, V> build(CacheLoader<K, V> loader) {
       cache = new GuavaLoadingCache<>(guava.build(
           com.google.common.cache.CacheLoader.asyncReloading(
               new SingleLoader<>(loader), executor.delegate())),
-          ticker(), isRecordingStats());
+          ticker, isRecordingStats());
     }
     this.cache = cache;
     return cache;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheGenerator.java
Patch:
@@ -193,7 +193,7 @@ public static <K, V> Cache<K, V> newCache(CacheContext context) {
   }
 
   /** Fills the cache up to the population size. */
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({"unchecked", "BoxedPrimitiveConstructor"})
   private void populate(CacheContext context, Cache<Integer, Integer> cache) {
     if (context.population.size() == 0) {
       return;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheWriterVerifier.java
Patch:
@@ -16,8 +16,8 @@
 package com.github.benmanes.caffeine.cache.testing;
 
 import static java.util.Objects.requireNonNull;
-import static org.mockito.Matchers.any;
-import static org.mockito.Matchers.eq;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 

File: guava/src/test/java/com/google/common/cache/CacheStatsTest.java
Patch:
@@ -25,6 +25,7 @@
  *
  * @author Charles Fry
  */
+@SuppressWarnings("JUnit3FloatingPointComparisonWithoutDelta")
 public class CacheStatsTest extends TestCase {
 
   public void testEmpty() {

File: guava/src/test/java/com/google/common/cache/LocalLoadingCacheTest.java
Patch:
@@ -40,6 +40,7 @@
 /**
  * @author Charles Fry
  */
+@SuppressWarnings("JUnit3FloatingPointComparisonWithoutDelta")
 public class LocalLoadingCacheTest extends TestCase {
 
   private static <K, V> LoadingCache<K, V> makeCache(

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/event/EventDispatcherTest.java
Patch:
@@ -19,7 +19,7 @@
 import static org.hamcrest.Matchers.empty;
 import static org.hamcrest.Matchers.hasSize;
 import static org.hamcrest.Matchers.is;
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/event/JCacheEvictionListenerTest.java
Patch:
@@ -17,7 +17,7 @@
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.is;
-import static org.mockito.Matchers.any;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.verify;
 

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/JCacheAccessExpiryTest.java
Patch:
@@ -68,7 +68,7 @@ protected CaffeineConfiguration<Integer, Integer> getConfiguration() {
     CaffeineConfiguration<Integer, Integer> configuration = new CaffeineConfiguration<>();
     configuration.setExpiryPolicyFactory(() -> new AccessedExpiryPolicy(
         new Duration(TimeUnit.MILLISECONDS, EXPIRY_DURATION)));
-    configuration.setTickerFactory(() -> ticker);
+    configuration.setTickerFactory(() -> ticker::read);
     return configuration;
   }
 

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/JCacheCreationExpiryTest.java
Patch:
@@ -56,7 +56,7 @@ protected CaffeineConfiguration<Integer, Integer> getConfiguration() {
     CaffeineConfiguration<Integer, Integer> configuration = new CaffeineConfiguration<>();
     configuration.setExpiryPolicyFactory(() -> new CreatedExpiryPolicy(
         new Duration(TimeUnit.MILLISECONDS, EXPIRY_DURATION)));
-    configuration.setTickerFactory(() -> ticker);
+    configuration.setTickerFactory(() -> ticker::read);
     return configuration;
   }
 

File: jcache/src/test/java/com/github/benmanes/caffeine/jcache/expiry/JCacheUpdateExpiryTest.java
Patch:
@@ -56,7 +56,7 @@ protected CaffeineConfiguration<Integer, Integer> getConfiguration() {
     CaffeineConfiguration<Integer, Integer> configuration = new CaffeineConfiguration<>();
     configuration.setExpiryPolicyFactory(() -> new ModifiedExpiryPolicy(
         new Duration(TimeUnit.MILLISECONDS, EXPIRY_DURATION)));
-    configuration.setTickerFactory(() -> ticker);
+    configuration.setTickerFactory(() -> ticker::read);
     return configuration;
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/WriteBuffer.java
Patch:
@@ -65,7 +65,7 @@ public WriteBuffer(int initialCapacity, int maxCapacity) {
     producerMask = mask;
     consumerBuffer = buffer;
     consumerMask = mask;
-    maxQueueCapacity = ceilingPowerOfTwo(maxCapacity) << 1;
+    maxQueueCapacity = ((long) ceilingPowerOfTwo(maxCapacity)) << 1;
     soProducerLimit(mask); // we know it's all empty to start with
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/Awaits.java
Patch:
@@ -17,8 +17,8 @@
 
 import java.util.concurrent.TimeUnit;
 
-import com.jayway.awaitility.Awaitility;
-import com.jayway.awaitility.core.ConditionFactory;
+import org.awaitility.Awaitility;
+import org.awaitility.core.ConditionFactory;
 
 /**
  * @author ben.manes@gmail.com (Ben Manes)

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/RemovalListener.java
Patch:
@@ -44,8 +44,8 @@ public interface RemovalListener<K, V> {
    * This does not always signify that the key is now absent from the cache, as it may have already
    * been re-added.
    *
-   * @param key the key represented by this entry
-   * @param value the value represented by this entry
+   * @param key the key represented by this entry, or {@code null} if collected
+   * @param value the value represented by this entry, or {@code null} if collected
    * @param cause the reason for which the entry was removed
    */
   void onRemoval(@Nullable K key, @Nullable V value, @Nonnull RemovalCause cause);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/membership/bloom/BloomFilter.java
Patch:
@@ -91,7 +91,7 @@ public boolean mightContain(long e) {
     int item = spread(Long.hashCode(e));
     for (int i = 0; i < 4; i++) {
       int hash = seeded(item, i);
-      int index = (hash >>> tableShift);
+      int index = hash >>> tableShift;
       if ((table[index] & bitmask(hash)) == 0L) {
         return false;
       }
@@ -121,7 +121,7 @@ public void put(long e) {
    */
   void setAt(int item, int seedIndex) {
     int hash = seeded(item, seedIndex);
-    int index = (hash >>> tableShift);
+    int index = hash >>> tableShift;
     table[index] |= bitmask(hash);
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/FrequencySketch.java
Patch:
@@ -78,13 +78,13 @@ final class FrequencySketch<E> {
    */
   public FrequencySketch() {
     int seed = ThreadLocalRandom.current().nextInt();
-    randomSeed = (seed == 0) ? ThreadLocalRandom.current().nextInt(1, Integer.MAX_VALUE) : seed;
+    this.randomSeed = ((seed & 1) == 0) ? seed + 1 : seed;
   }
 
   /**
    * Initializes and increases the capacity of this <tt>FrequencySketch</tt> instance, if necessary,
    * to ensure that it can accurately estimate the popularity of elements given the maximum size of
-   * the cache.
+   * the cache. This operation forgets all previous counts when resizing.
    *
    * @param maximumSize the maximum size of the cache
    */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/CountMin4.java
Patch:
@@ -56,11 +56,12 @@ protected CountMin4(Config config) {
 
   /**
    * Increases the capacity of this <tt>FrequencySketch</tt> instance, if necessary, to ensure that
-   * it can accurately estimate the popularity of elements given the maximum size of the cache.
+   * it can accurately estimate the popularity of elements given the maximum size of the cache. This
+   * operation forgets all previous counts when resizing.
    *
    * @param maximumSize the maximum size of the cache
    */
-  public void ensureCapacity(@Nonnegative long maximumSize) {
+  protected void ensureCapacity(@Nonnegative long maximumSize) {
     checkArgument(maximumSize >= 0);
     int maximum = (int) Math.min(maximumSize, Integer.MAX_VALUE >>> 1);
     if ((table != null) && (table.length >= maximum)) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/PeriodicResetCountMin4.java
Patch:
@@ -35,7 +35,7 @@ public PeriodicResetCountMin4(Config config) {
   }
 
   @Override
-  public void ensureCapacity(@Nonnegative long maximumSize) {
+  protected void ensureCapacity(@Nonnegative long maximumSize) {
     super.ensureCapacity(maximumSize);
     period = (maximumSize == 0) ? 10 : (10 * table.length);
     if (period <= 0) {

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/CacheType.java
Patch:
@@ -18,11 +18,11 @@
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.apache.jackrabbit.oak.cache.CacheLIRS;
-import org.cliffc.high_scale_lib.NonBlockingHashMap;
 import org.infinispan.commons.equivalence.AnyEquivalence;
 import org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8;
 import org.infinispan.commons.util.concurrent.jdk8backported.BoundedEquivalentConcurrentHashMapV8.Eviction;
 import org.infinispan.util.concurrent.BoundedConcurrentHashMap;
+import org.jctools.maps.NonBlockingHashMap;
 
 import com.github.benmanes.caffeine.cache.impl.Cache2k;
 import com.github.benmanes.caffeine.cache.impl.CaffeineCache;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/Cache2kPolicy.java
Patch:
@@ -68,6 +68,7 @@ public static Set<Policy> policies(Config config) {
   }
 
   @Override
+  @SuppressWarnings("deprecation")
   public void record(long key) {
     Object value = cache.peek(key);
     if (value == null) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/bloom/BloomFilter.java
Patch:
@@ -75,7 +75,7 @@ public void ensureCapacity(@Nonnegative long expectedInsertions) {
     if ((table != null) && (table.length >= optimalSize)) {
       return;
     } else if (optimalSize == 0) {
-      table = new long[0];
+      table = new long[1];
       tableMask = 0;
     } else {
       table = new long[ceilingPowerOfTwo(optimalSize)];

File: caffeine/src/main/java/com/github/benmanes/caffeine/SingleConsumerQueue.java
Patch:
@@ -110,7 +110,7 @@ public final class SingleConsumerQueue<E> extends SCQHeader.HeadAndTailRef<E>
   static final int NCPU = Runtime.getRuntime().availableProcessors();
 
   /** The number of slots in the elimination array. */
-  static final int ARENA_LENGTH = ceilingNextPowerOfTwo((NCPU + 1) / 2);
+  static final int ARENA_LENGTH = ceilingPowerOfTwo((NCPU + 1) / 2);
 
   /** The mask value for indexing into the arena. */
   static final int ARENA_MASK = ARENA_LENGTH - 1;
@@ -132,9 +132,9 @@ public final class SingleConsumerQueue<E> extends SCQHeader.HeadAndTailRef<E>
   /** The offset to the thread-specific probe field. */
   static final long PROBE = UnsafeAccess.objectFieldOffset(Thread.class, "threadLocalRandomProbe");
 
-  static int ceilingNextPowerOfTwo(int x) {
+  static int ceilingPowerOfTwo(int x) {
     // From Hacker's Delight, Chapter 3, Harry S. Warren Jr.
-    return 1 << (Integer.SIZE - Integer.numberOfLeadingZeros(x - 1));
+    return 1 << -Integer.numberOfLeadingZeros(x - 1);
   }
 
   final AtomicReference<Node<E>>[] arena;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -138,7 +138,7 @@ abstract class BoundedLocalCache<K, V> extends BLCHeader.DrainStatusRef<K, V>
   /** The initial capacity of the write buffer. */
   static final int WRITE_BUFFER_MIN = 4;
   /** The maximum capacity of the write buffer. */
-  static final int WRITE_BUFFER_MAX = 128 * ceilingNextPowerOfTwo(NCPU);
+  static final int WRITE_BUFFER_MAX = 128 * ceilingPowerOfTwo(NCPU);
   /** The number of attempts to insert into the write buffer before yielding. */
   static final int WRITE_BUFFER_RETRIES = 100;
   /** The maximum weighted capacity of the map. */
@@ -194,9 +194,9 @@ protected BoundedLocalCache(Caffeine<K, V> builder,
     }
   }
 
-  static int ceilingNextPowerOfTwo(int x) {
+  static int ceilingPowerOfTwo(int x) {
     // From Hacker's Delight, Chapter 3, Harry S. Warren Jr.
-    return 1 << (Integer.SIZE - Integer.numberOfLeadingZeros(x - 1));
+    return 1 << -Integer.numberOfLeadingZeros(x - 1);
   }
 
   /* ---------------- Shared -------------- */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/CountMin4.java
Patch:
@@ -198,6 +198,6 @@ int spread(int x) {
 
   static int ceilingNextPowerOfTwo(int x) {
     // From Hacker's Delight, Chapter 3, Harry S. Warren Jr.
-    return 1 << (Integer.SIZE - Integer.numberOfLeadingZeros(x - 1));
+    return 1 << -Integer.numberOfLeadingZeros(x - 1);
   }
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/IncrementalResetCountMin4.java
Patch:
@@ -37,7 +37,7 @@ public IncrementalResetCountMin4(Config config) {
   }
 
   @Override
-  void tryReset(boolean added) {
+  protected void tryReset(boolean added) {
     if (!added) {
       return;
     }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/countmin4/PeriodicResetCountMin4.java
Patch:
@@ -48,7 +48,7 @@ public void ensureCapacity(@Nonnegative long maximumSize) {
    * is reduced by the number of counters with an odd value.
    */
   @Override
-  void tryReset(boolean added) {
+  protected void tryReset(boolean added) {
     if (!added) {
       return;
     }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1704,12 +1704,12 @@ V removeNoWriter(Object key) {
       cause = RemovalCause.EXPLICIT;
     }
 
-    afterWrite(node, new RemovalTask(node), 0L);
     if (hasRemovalListener()) {
       @SuppressWarnings("unchecked")
       K castKey = (K) key;
       notifyRemoval(castKey, oldValue, cause);
     }
+    afterWrite(node, new RemovalTask(node), 0L);
     return (cause == RemovalCause.EXPLICIT) ? oldValue : null;
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalCache.java
Patch:
@@ -80,7 +80,7 @@ interface LocalCache<K, V> extends ConcurrentMap<K, V> {
 
   /**
    * See {@link Cache#getIfPresent(Object)}. This method differs by not recording the access with
-   * the statistics nor the eviction policy, and populates the write time is known.
+   * the statistics nor the eviction policy, and populates the write time if known.
    */
   @Nullable
   V getIfPresentQuietly(@Nonnull Object key, @Nonnull long[/* 1 */] writeTime);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/Registry.java
Patch:
@@ -45,6 +45,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.product.InfinispanPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.TCachePolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.sampled.SamplingPolicy;
+import com.github.benmanes.caffeine.cache.simulator.policy.sketch.AdaptiveWindowTinyLfuPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.FullySegmentedWindowTinyLfuPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.RandomWindowTinyLfuPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.S4WindowTinyLfuPolicy;
@@ -127,6 +128,7 @@ private static void registerSketch(Map<String, Function<Config, Set<Policy>>> fa
     factories.put("sketch.randomwindowtinylfu", RandomWindowTinyLfuPolicy::policies);
     factories.put("sketch.fullysegmentedwindowtinylfu",
         FullySegmentedWindowTinyLfuPolicy::policies);
+    factories.put("sketch.adaptivewindowtinylfu", AdaptiveWindowTinyLfuPolicy::policies);
 
     factories.put("sketch.tinycache", TinyCachePolicy::policies);
     factories.put("sketch.windowtinycache", WindowTinyCachePolicy::policies);

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/GetPutBenchmark.java
Patch:
@@ -51,6 +51,7 @@ public class GetPutBenchmark {
     "Caffeine",
     "ConcurrentLinkedHashMap",
     "Guava",
+    "ElasticSearch",
     "Jackrabbit",
     "Cache2k",
     "Ehcache2_Lru",

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddKey.java
Patch:
@@ -50,8 +50,8 @@ protected void execute() {
         .addField(newKeyField())
         .addMethod(newGetter(keyStrength(), kTypeVar, "key", Visibility.LAZY))
         .addMethod(newGetRef("key"));
-    addKeyConstructorAssignment(context.constructorByKey, false);
-    addKeyConstructorAssignment(context.constructorByKeyRef, true);
+    addKeyConstructorAssignment(context.constructorByKey, /* isReference */ false);
+    addKeyConstructorAssignment(context.constructorByKeyRef, /* isReference */ true);
   }
 
   private FieldSpec newKeyField() {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalManualCache.java
Patch:
@@ -46,7 +46,7 @@ default void cleanUp() {
 
   @Override
   default @Nullable V getIfPresent(Object key) {
-    return cache().getIfPresent(key, true);
+    return cache().getIfPresent(key, /* recordStats */ true);
   }
 
   @Override

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -329,7 +329,7 @@ public void exceedsMaximumBufferSize_onRead(Cache<Integer, Integer> cache, Cache
     }
     assertThat(buffer.offer(dummy), is(Buffer.FULL));
 
-    localCache.afterRead(dummy, 0, true);
+    localCache.afterRead(dummy, 0, /* recordHit */ true);
     assertThat(buffer.offer(dummy), is(not(Buffer.FULL)));
   }
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheProxy.java
Patch:
@@ -267,7 +267,7 @@ private void loadAllAndReplaceExisting(Set<? extends K> keys) {
     int[] ignored = { 0 };
     Map<K, V> loaded = cacheLoader.get().loadAll(keys);
     for (Map.Entry<? extends K, ? extends V> entry : loaded.entrySet()) {
-      putNoCopyOrAwait(entry.getKey(), entry.getValue(), false, ignored);
+      putNoCopyOrAwait(entry.getKey(), entry.getValue(), /* publishToWriter */ false, ignored);
     }
   }
 
@@ -279,7 +279,7 @@ private void loadAllAndKeepExisting(Set<? extends K> keys) {
     Map<K, V> result = cacheLoader.get().loadAll(keysToLoad);
     for (Map.Entry<K, V> entry : result.entrySet()) {
       if ((entry.getKey() != null) && (entry.getValue() != null)) {
-        putIfAbsentNoAwait(entry.getKey(), entry.getValue(), false);
+        putIfAbsentNoAwait(entry.getKey(), entry.getValue(), /* publishToWriter */ false);
       }
     }
   }
@@ -386,7 +386,7 @@ public void putAll(Map<? extends K, ? extends V> map) {
     int[] puts = { 0 };
     CacheWriterException e = writeAllToCacheWriter(map);
     for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {
-      putNoCopyOrAwait(entry.getKey(), entry.getValue(), false, puts);
+      putNoCopyOrAwait(entry.getKey(), entry.getValue(), /* publishToWriter */ false, puts);
     }
     dispatcher.awaitSynchronous();
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/LoadingCacheProxy.java
Patch:
@@ -161,10 +161,11 @@ public void loadAll(Set<? extends K> keys, boolean replaceExistingValues,
           int[] ignored = { 0 };
           Map<K, V> loaded = cacheLoader.get().loadAll(keys);
           for (Map.Entry<? extends K, ? extends V> entry : loaded.entrySet()) {
-            putNoCopyOrAwait(entry.getKey(), entry.getValue(), false, ignored);
+            putNoCopyOrAwait(entry.getKey(), entry.getValue(),
+                /* publishToWriter */ false, ignored);
           }
         } else {
-          getAll(keys, false);
+          getAll(keys, /* updateAccessTime */ false);
         }
         listener.onCompletion();
       } catch (Exception e) {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/copy/JavaSerializationCopier.java
Patch:
@@ -92,7 +92,7 @@ protected ClassLoader getClassLoader() {
     protected Class<?> resolveClass(ObjectStreamClass desc)
         throws IOException, ClassNotFoundException {
       try {
-        return Class.forName(desc.getName(), false, getClassLoader());
+        return Class.forName(desc.getName(), /* initialize */ false, getClassLoader());
       } catch (ClassNotFoundException ex) {
         return super.resolveClass(desc);
       }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1559,7 +1559,7 @@ V putFast(K key, V value, int newWeight, boolean notifyWriter, boolean onlyIfAbs
       int weightedDifference = mayUpdate ? (newWeight - oldWeight) : 0;
       if ((oldValue == null) || (weightedDifference != 0) || expired) {
         afterWrite(prior, new UpdateTask(prior, weightedDifference), now);
-      } else if (!onlyIfAbsent && (oldValue != null) && expiresAfterWrite()
+      } else if (!onlyIfAbsent && expiresAfterWrite()
           && ((now - prior.getWriteTime()) > EXPIRE_WRITE_TOLERANCE)) {
         afterWrite(prior, new UpdateTask(prior, weightedDifference), now);
       } else {

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/local/AddRemovalListener.java
Patch:
@@ -42,7 +42,7 @@ protected void execute() {
         .returns(REMOVAL_LISTENER)
         .build());
     context.cache.addMethod(MethodSpec.methodBuilder("hasRemovalListener")
-        .addModifiers(protectedFinalModifiers)
+        .addModifiers(publicFinalModifiers)
         .addStatement("return true")
         .returns(boolean.class)
         .build());

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/RemovalCause.java
Patch:
@@ -57,6 +57,7 @@ public enum RemovalCause {
    * <ul>
    *   <li>{@link Cache#put}</li>
    *   <li>{@link Cache#putAll}</li>
+   *   <li>{@link LoadingCache#getAll}</li>
    *   <li>{@link LoadingCache#refresh}</li>
    *   <li>{@link java.util.Map#put}</li>
    *   <li>{@link java.util.Map#putAll}</li>

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/CacheStats.java
Patch:
@@ -119,10 +119,11 @@ public CacheStats(@Nonnegative long hitCount, @Nonnegative long missCount,
   }
 
   /**
-   * Returns a statistics instance where cache events have been recorded.
+   * Returns a statistics instance where no cache events have been recorded.
    *
    * @return an empty statistics instance
    */
+  @Nonnull
   public static CacheStats empty() {
     return EMPTY_STATS;
   }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheProvider.java
Patch:
@@ -97,7 +97,7 @@ private static Iterator<Object[]> asTestCases(Method testMethod,
         if (clazz.isAssignableFrom(CacheContext.class)) {
           params[i] = context;
         } else if (clazz.isAssignableFrom(Caffeine.class)) {
-          params[i] = context.builder;
+          params[i] = context.caffeine;
         } else if (clazz.isAssignableFrom(cache.getClass())) {
           params[i] = cache;
         } else if (clazz.isAssignableFrom(AsyncLoadingCache.class)) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CaffeineCacheFromContext.java
Patch:
@@ -39,7 +39,7 @@ private CaffeineCacheFromContext() {}
 
   public static <K, V> Cache<K, V> newCaffeineCache(CacheContext context) {
     Caffeine<Object, Object> builder = Caffeine.newBuilder();
-    context.builder = builder;
+    context.caffeine = builder;
 
     if (context.initialCapacity != InitialCapacity.DEFAULT) {
       builder.initialCapacity(context.initialCapacity.size());

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java
Patch:
@@ -68,8 +68,9 @@ public static <K, V> Cache<K, V> newGuavaCache(CacheContext context) {
     checkState(!context.isAsync(), "Guava caches are synchronous only");
 
     CacheBuilder<Object, Object> builder = CacheBuilder.newBuilder();
-    builder.concurrencyLevel(1);
+    context.guava = builder;
 
+    builder.concurrencyLevel(1);
     if (context.initialCapacity != InitialCapacity.DEFAULT) {
       builder.initialCapacity(context.initialCapacity.size());
     }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/WriteBuffer.java
Patch:
@@ -167,6 +167,7 @@ else if (casProducerIndex(producerIndex, producerIndex + 1)) {
     return result;
   }
 
+  @SuppressWarnings("PMD.ConfusingTernary")
   public E poll() {
     E[] buffer = consumerBuffer;
     long index = consumerIndex;
@@ -257,6 +258,7 @@ private long newBufferAndOffset(E[] nextBuffer, long index) {
     return offsetInNew;
   }
 
+  @SuppressWarnings("unchecked")
   public static <E> E lvElement(E[] buffer, long offset) {
     return (E) UnsafeAccess.UNSAFE.getObjectVolatile(buffer, offset);
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/DisabledStatsCounter.java
Patch:
@@ -23,8 +23,6 @@
 enum DisabledStatsCounter implements StatsCounter {
   INSTANCE;
 
-  static final CacheStats EMPTY_STATS = new CacheStats(0, 0, 0, 0, 0, 0);
-
   @Override
   public void recordHits(int count) {}
 
@@ -42,7 +40,7 @@ public void recordEviction() {}
 
   @Override
   public CacheStats snapshot() {
-    return EMPTY_STATS;
+    return CacheStats.empty();
   }
 
   @Override

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CacheTest.java
Patch:
@@ -572,9 +572,9 @@ public void cleanup(Cache<Integer, Integer> cache, CacheContext context) {
   @Test(dataProvider = "caches")
   public void stats(Cache<Integer, Integer> cache, CacheContext context) {
     CacheStats stats = cache.stats()
-        .plus(new CacheStats(1, 2, 3, 4, 5, 6)
-        .minus(new CacheStats(6, 5, 4, 3, 2, 1)));
-    assertThat(stats, is(new CacheStats(0, 0, 0, 1, 3, 5)));
+        .plus(new CacheStats(1, 2, 3, 4, 5, 6, 7)
+        .minus(new CacheStats(6, 5, 4, 3, 2, 1, 0)));
+    assertThat(stats, is(new CacheStats(0, 0, 0, 1, 3, 5, 7)));
     assertThat(cache.policy().isRecordingStats(), is(context.isRecordingStats()));
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CaffeineTest.java
Patch:
@@ -490,8 +490,8 @@ public void recordStats() {
   public void recordStats_custom() {
     Supplier<StatsCounter> supplier = () -> statsCounter;
     Caffeine<?, ?> builder = Caffeine.newBuilder().recordStats(supplier);
-    builder.statsCounterSupplier.get().recordEviction();
-    verify(statsCounter).recordEviction();
+    builder.statsCounterSupplier.get().recordEviction(1);
+    verify(statsCounter).recordEviction(1);
     builder.build();
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheWriterVerifier.java
Patch:
@@ -29,7 +29,6 @@
 
 import com.github.benmanes.caffeine.cache.CacheWriter;
 import com.github.benmanes.caffeine.cache.RemovalCause;
-import com.github.benmanes.caffeine.cache.testing.CacheSpec.Implementation;
 
 /**
  * A utility for verifying that the {@link CacheWriter} mock was operated on correctly.
@@ -95,7 +94,7 @@ public void deletedAll(Map<Integer, Integer> map, RemovalCause cause) {
   /** Runs the verification block iff the cache writer is enabled. */
   public static void verifyWriter(CacheContext context,
       BiConsumer<CacheWriterVerifier, CacheWriter<Integer, Integer>> consumer) {
-    boolean mayVerify = (context.implementation() == Implementation.Caffeine)
+    boolean mayVerify = context.isCaffeine()
         && context.isStrongKeys()
         && !context.isAsync();
     if (mayVerify) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java
Patch:
@@ -218,7 +218,7 @@ public long estimatedSize() {
     public CacheStats stats() {
       com.google.common.cache.CacheStats stats = statsCounter.snapshot().plus(cache.stats());
       return new CacheStats(stats.hitCount(), stats.missCount(), stats.loadSuccessCount(),
-          stats.loadExceptionCount(), stats.totalLoadTime(), stats.evictionCount());
+          stats.loadExceptionCount(), stats.totalLoadTime(), stats.evictionCount(), 0L);
     }
 
     @Override

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheFactoryGenerator.java
Patch:
@@ -47,7 +47,7 @@
 import com.github.benmanes.caffeine.cache.local.AddRemovalListener;
 import com.github.benmanes.caffeine.cache.local.AddStats;
 import com.github.benmanes.caffeine.cache.local.AddSubtype;
-import com.github.benmanes.caffeine.cache.local.AddWriteQueue;
+import com.github.benmanes.caffeine.cache.local.AddWriteBuffer;
 import com.github.benmanes.caffeine.cache.local.Finalize;
 import com.github.benmanes.caffeine.cache.local.LocalCacheContext;
 import com.github.benmanes.caffeine.cache.local.LocalCacheRule;
@@ -77,7 +77,7 @@ public final class LocalCacheFactoryGenerator {
       new AddKeyValueStrength(), new AddRemovalListener(), new AddStats(),
       new AddExpirationTicker(), new AddMaximum(), new AddFastPath(), new AddDeques(),
       new AddExpireAfterAccess(), new AddExpireAfterWrite(), new AddRefreshAfterWrite(),
-      new AddWriteQueue(), new Finalize());
+      new AddWriteBuffer(), new Finalize());
   final NavigableMap<String, ImmutableSet<Feature>> classNameToFeatures;
   final Path directory;
 

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/CaffeineCache.java
Patch:
@@ -16,7 +16,6 @@
 package com.github.benmanes.caffeine.cache.impl;
 
 import java.util.Map;
-import java.util.concurrent.Executors;
 
 import com.github.benmanes.caffeine.cache.BasicCache;
 import com.github.benmanes.caffeine.cache.Cache;
@@ -31,7 +30,6 @@ public final class CaffeineCache<K, V> implements BasicCache<K, V> {
 
   public CaffeineCache(int maximumSize) {
     cache = Caffeine.newBuilder()
-        .executor(Executors.newWorkStealingPool(1))
         .initialCapacity(maximumSize)
         .maximumSize(maximumSize)
         .build();

File: caffeine/src/main/java/com/github/benmanes/caffeine/SingleConsumerQueue.java
Patch:
@@ -531,7 +531,7 @@ boolean isDone() {
 final class SCQHeader {
   abstract static class PadHead<E> extends AbstractQueue<E> {
     long p00, p01, p02, p03, p04, p05, p06, p07;
-    long p10, p11, p12, p13, p14, p15, p16, p17;
+    long p10, p11, p12, p13, p14, p15, p16;
   }
 
   /** Enforces a memory layout to avoid false sharing by padding the head node. */
@@ -541,7 +541,7 @@ abstract static class HeadRef<E> extends PadHead<E> {
 
   abstract static class PadHeadAndTail<E> extends HeadRef<E> {
     long p20, p21, p22, p23, p24, p25, p26, p27;
-    long p30, p31, p32, p33, p34, p35, p36, p37;
+    long p30, p31, p32, p33, p34, p35, p36;
   }
 
   /** Enforces a memory layout to avoid false sharing by padding the tail node. */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -25,7 +25,6 @@
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.containsInAnyOrder;
 import static org.hamcrest.Matchers.equalTo;
-import static org.hamcrest.Matchers.hasSize;
 import static org.hamcrest.Matchers.is;
 import static org.hamcrest.Matchers.not;
 import static org.hamcrest.Matchers.nullValue;
@@ -345,7 +344,7 @@ public void exceedsMaximumBufferSize_onWrite(Cache<Integer, Integer> cache, Cach
     localCache.afterWrite(dummy, () -> ran[0] = true, 0);
     assertThat(ran[0], is(true));
 
-    assertThat(localCache.writeQueue(), hasSize(0));
+    assertThat(localCache.writeBuffer().size(), is(0));
   }
 
   @Test(dataProvider = "caches")
@@ -399,7 +398,7 @@ public void drain_onWrite(Cache<Integer, Integer> cache, CacheContext context) {
 
     int size = localCache.accessOrderEdenDeque().size()
         + localCache.accessOrderProbationDeque().size();
-    assertThat(localCache.writeQueue(), hasSize(0));
+    assertThat(localCache.writeBuffer().size(), is(0));
     assertThat(size, is(1));
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidBoundedLocalCache.java
Patch:
@@ -73,7 +73,7 @@ protected boolean matchesSafely(BoundedLocalCache<K, V> cache, Description descr
   private void drain(BoundedLocalCache<K, V> cache) {
     do {
       cache.cleanUp();
-    } while (cache.buffersWrites() && !cache.writeQueue().isEmpty());
+    } while (cache.buffersWrites() && cache.writeBuffer().size() > 0);
   }
 
   private void checkReadBuffer(BoundedLocalCache<K, V> cache) {
@@ -141,7 +141,7 @@ private void checkLinks(BoundedLocalCache<K, V> cache,
     }
 
     Supplier<String> errorMsg = () -> String.format(
-        "Size != list length; pending=%s, additional: %s", cache.writeQueue().size(),
+        "Size != list length; pending=%s, additional: %s", cache.writeBuffer().size(),
         Sets.difference(seen, ImmutableSet.copyOf(cache.data.values())));
     desc.expectThat(errorMsg, cache.size(), is(seen.size()));
 

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/Specifications.java
Patch:
@@ -103,8 +103,7 @@ public final class Specifications {
   public static final TypeName WRITE_QUEUE = ParameterizedTypeName.get(
       WRITE_QUEUE_TYPE, ClassName.get(Runnable.class));
 
-  public static final TypeName FREQUENCY_SKETCH = ParameterizedTypeName.get(
-      ClassName.get("com.github.benmanes.caffeine.cache", "FrequencySketch"), kTypeVar);
+  public static final TypeName FREQUENCY_SKETCH = ClassName.get(PACKAGE_NAME, "FrequencySketch");
 
   private Specifications() {}
 

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/FrequencySketchBenchmark.java
Patch:
@@ -38,12 +38,12 @@ public class FrequencySketchBenchmark {
 
   int index = 0;
   Integer[] ints;
-  FrequencySketch<Integer> sketch;
+  FrequencySketch sketch;
 
   @Setup
   public void setup() {
     ints = new Integer[SIZE];
-    sketch = new FrequencySketch<>();
+    sketch = new FrequencySketch();
     sketch.ensureCapacity(ITEMS);
 
     NumberGenerator generator = new ScrambledZipfianGenerator(ITEMS);

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/Cache2k.java
Patch:
@@ -26,11 +26,11 @@
 public final class Cache2k<K, V> implements BasicCache<K, V> {
   private final Cache<K, V> cache;
 
-  @SuppressWarnings("unchecked")
+  @SuppressWarnings({"unchecked", "deprecation"})
   public Cache2k(Class<?> implementation, int maximumSize) {
     cache = (Cache<K, V>) CacheBuilder.newCache(Object.class, Object.class)
         .implementation(implementation)
-        .maxSize(maximumSize)
+        .entryCapacity(maximumSize)
         .eternal(true)
         .build();
   }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/RandomSeedEnforcer.java
Patch:
@@ -42,7 +42,7 @@ public static void ensureRandomSeed(Cache<?, ?> cache) {
   }
 
   /** Force the random seed to a predictable value. */
-  public static void ensureRandomSeed(FrequencySketch<?> sketch) {
+  public static void ensureRandomSeed(FrequencySketch sketch) {
     try {
       Field field = FrequencySketch.class.getDeclaredField("randomSeed");
       field.setAccessible(true);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/Cache2kPolicy.java
Patch:
@@ -46,6 +46,7 @@ public final class Cache2kPolicy implements Policy {
   private final PolicyStats policyStats;
   private final int maximumSize;
 
+  @SuppressWarnings("deprecation")
   public Cache2kPolicy(Config config) {
     Logger logger = LogManager.getLogManager().getLogger("");
     Level level = logger.getLevel();
@@ -57,7 +58,7 @@ public Cache2kPolicy(Config config) {
       Cache2kSettings settings = new Cache2kSettings(config);
       cache = CacheBuilder.newCache(Object.class, Object.class)
           .implementation(settings.implementation())
-          .maxSize(settings.maximumSize())
+          .entryCapacity(settings.maximumSize())
           .eternal(true)
           .build();
       maximumSize = settings.maximumSize();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/Registry.java
Patch:
@@ -45,6 +45,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.product.TCachePolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.sampled.SamplingPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.FullySegmentedWindowTinyLfuPolicy;
+import com.github.benmanes.caffeine.cache.simulator.policy.sketch.RandomWindowTinyLfuPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.S4WindowTinyLfuPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.SimpleWindowTinyLfuPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.WindowTinyLfuPolicy;
@@ -122,8 +123,10 @@ private static void registerSketch(Map<String, Function<Config, Set<Policy>>> fa
     factories.put("sketch.windowtinylfu", WindowTinyLfuPolicy::policies);
     factories.put("sketch.s4windowtinylfu", S4WindowTinyLfuPolicy::policies);
     factories.put("sketch.simplewindowtinylfu", SimpleWindowTinyLfuPolicy::policies);
+    factories.put("sketch.randomwindowtinylfu", RandomWindowTinyLfuPolicy::policies);
     factories.put("sketch.fullysegmentedwindowtinylfu",
         FullySegmentedWindowTinyLfuPolicy::policies);
+
     factories.put("sketch.tinycache", TinyCachePolicy::policies);
     factories.put("sketch.windowtinycache", WindowTinyCachePolicy::policies);
     factories.put("sketch.tinycache_ghostcache", TinyCacheWithGhostCachePolicy::policies);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncLoadingCache.java
Patch:
@@ -133,6 +133,7 @@ public CompletableFuture<V> get(K key,
         }
         long loadTime = cache.statsTicker().read() - startTime;
         if (value == null) {
+          logger.log(Level.WARNING, "Exception thrown during asynchonous load", error);
           cache.statsCounter().recordLoadFailure(loadTime);
           cache.remove(key, result[0]);
         } else {
@@ -238,6 +239,7 @@ public void put(K key, CompletableFuture<V> valueFuture) {
         // update the weight and expiration timestamps
         cache.replace(key, valueFuture, valueFuture);
         cache.statsCounter().recordLoadSuccess(loadTime);
+        logger.log(Level.WARNING, "Exception thrown during asynchonous load", error);
       }
     });
   }
@@ -270,6 +272,7 @@ public void accept(Map<K, V> result, Throwable error) {
           entry.getValue().obtrudeException(error);
         }
         cache.statsCounter().recordLoadFailure(loadTime);
+        logger.log(Level.WARNING, "Exception thrown during asynchonous load", error);
       } else {
         fillProxies(result);
         addNewEntries(result);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Policy.java
Patch:
@@ -131,8 +131,8 @@ interface Eviction<K, V> {
      * Note that some implementations may have an internal inherent bound on the maximum total size.
      * If the value specified exceeds that bound, then the value is set to the internal maximum.
      *
-     * @param maximum the maximum, interpreted as weighted or unweighted size depending on the
-     *        whether how this cache was constructed
+     * @param maximum the maximum, interpreted as weighted or unweighted size depending on how this
+     *        cache was constructed
      * @throws IllegalArgumentException if the maximum size specified is negative
      */
     void setMaximum(@Nonnegative long maximum);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/Stresser.java
Patch:
@@ -75,6 +75,7 @@ public Stresser() {
       cache.put(key, key);
       return key;
     });
+    cache.cleanUp();
     stopwatch = Stopwatch.createStarted();
     status();
   }

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuava.java
Patch:
@@ -44,7 +44,7 @@ private CaffeinatedGuava() {}
   @Nonnull
   public static <K1 extends K, K, V1 extends V, V> Cache<K1, V1> build(
       @Nonnull Caffeine<K, V> builder) {
-    return new CaffeinatedGuavaCache<K1, V1>(builder.build());
+    return new CaffeinatedGuavaCache<>(builder.build());
   }
 
   /**
@@ -75,7 +75,7 @@ public static <K1 extends K, K, V1 extends V, V> LoadingCache<K1, V1> build(
   public static <K1 extends K, K, V1 extends V, V> LoadingCache<K1, V1> build(
       @Nonnull Caffeine<K, V> builder,
       @Nonnull com.github.benmanes.caffeine.cache.CacheLoader<? super K1, V1> loader) {
-    return new CaffeinatedGuavaLoadingCache<K1, V1>(builder.build(loader));
+    return new CaffeinatedGuavaLoadingCache<>(builder.build(loader));
   }
 
   static boolean hasLoadAll(CacheLoader<?, ?> cacheLoader) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/Stresser.java
Patch:
@@ -39,7 +39,8 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 public final class Stresser {
-  private static final String[] STATUS = { "Idle", "Required", "Processing" };
+  private static final String[] STATUS =
+    { "Idle", "Required", "Processing -> Idle", "Processing -> Required" };
   private static final int THREADS = 2 * Runtime.getRuntime().availableProcessors();
   private static final int WRITE_MAX_SIZE = (1 << 12);
   private static final int TOTAL_KEYS = (1 << 20);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -196,6 +196,7 @@ public static Caffeine<Object, Object> newBuilder() {
   /**
    * Constructs a new {@code Caffeine} instance with the settings specified in {@code spec}.
    *
+   * @param spec the specification to build from
    * @return a new instance with the specification's settings
    */
   @Nonnull

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CaffeineSpec.java
Patch:
@@ -142,6 +142,7 @@ Caffeine<Object, Object> toBuilder() {
    * Creates a CaffeineSpec from a string.
    *
    * @param specification the string form
+   * @return the parsed specification
    */
   public static CaffeineSpec parse(String specification) {
     CaffeineSpec spec = new CaffeineSpec(specification);
@@ -360,6 +361,8 @@ static long durationInNanos(long duration, @Nullable TimeUnit unit) {
    * Returns a string that can be used to parse an equivalent {@code CaffeineSpec}. The order and
    * form of this representation is not guaranteed, except that parsing its output will produce a
    * {@code CaffeineSpec} equal to this instance.
+   *
+   * @return a string representation of this specification
    */
   public String toParsableString() {
     return specification;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/StatsCounter.java
Patch:
@@ -98,6 +98,7 @@ public interface StatsCounter {
    * Returns an accumulator that suppresses and logs any exception thrown by the delegate
    * <tt>statsCounter</tt>.
    *
+   * @param statsCounter the accumulator to delegate to
    * @return an accumulator that suppresses and logs any exception thrown by the delegate
    */
   static @Nonnull StatsCounter guardedStatsCounter(@Nonnull StatsCounter statsCounter) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/UnboundedLocalCache.java
Patch:
@@ -53,6 +53,8 @@
 final class UnboundedLocalCache<K, V> implements LocalCache<K, V> {
   @Nullable final RemovalListener<K, V> removalListener;
   final ConcurrentHashMap<K, V> data;
+  final StatsCounter statsCounter;
+  final boolean isRecordingStats;
   final CacheWriter<K, V> writer;
   final Executor executor;
   final Ticker ticker;
@@ -61,9 +63,6 @@ final class UnboundedLocalCache<K, V> implements LocalCache<K, V> {
   transient Collection<V> values;
   transient Set<Entry<K, V>> entrySet;
 
-  boolean isRecordingStats;
-  StatsCounter statsCounter;
-
   UnboundedLocalCache(Caffeine<? super K, ? super V> builder, boolean async) {
     this.data = new ConcurrentHashMap<>(builder.getInitialCapacity());
     this.statsCounter = builder.getStatsCounterSupplier().get();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContext.java
Patch:
@@ -33,6 +33,7 @@
 import com.github.benmanes.caffeine.cache.AsyncLoadingCache;
 import com.github.benmanes.caffeine.cache.Cache;
 import com.github.benmanes.caffeine.cache.CacheWriter;
+import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.cache.RemovalListener;
 import com.github.benmanes.caffeine.cache.stats.CacheStats;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Advance;
@@ -85,6 +86,7 @@ public final class CacheContext {
   final boolean isAsyncLoading;
 
   Cache<?, ?> cache;
+  Caffeine<Object, Object> builder;
   AsyncLoadingCache<?, ?> asyncCache;
 
   @Nullable Integer firstKey;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CaffeineCacheFromContext.java
Patch:
@@ -39,6 +39,8 @@ private CaffeineCacheFromContext() {}
 
   public static <K, V> Cache<K, V> newCaffeineCache(CacheContext context) {
     Caffeine<Object, Object> builder = Caffeine.newBuilder();
+    context.builder = builder;
+
     if (context.initialCapacity != InitialCapacity.DEFAULT) {
       builder.initialCapacity(context.initialCapacity.size());
     }

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheFactoryGenerator.java
Patch:
@@ -130,11 +130,10 @@ private void writeJavaFile() throws IOException {
 
   private void generateLocalCaches() {
     fillClassNameToFeatures();
-    classNameToFeatures.entrySet().stream().forEach(entry -> {
-      String className = entry.getKey();
+    classNameToFeatures.forEach((className, features) -> {
       String higherKey = classNameToFeatures.higherKey(className);
       boolean isLeaf = (higherKey == null) || !higherKey.startsWith(className);
-      addLocalCacheSpec(entry.getKey(), isLeaf, entry.getValue());
+      addLocalCacheSpec(className, isLeaf, features);
     });
   }
 

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeFactoryGenerator.java
Patch:
@@ -222,11 +222,10 @@ private void addGetFactoryMethods() {
 
   private void generatedNodes() throws IOException {
     fillClassNameToFeatures();
-    classNameToFeatures.entrySet().stream().forEach(entry -> {
-      String className = entry.getKey();
+    classNameToFeatures.forEach((className, features) -> {
       String higherKey = classNameToFeatures.higherKey(className);
       boolean isLeaf = (higherKey == null) || !higherKey.startsWith(className);
-      addNodeSpec(entry.getKey(), isLeaf, entry.getValue());
+      addNodeSpec(className, isLeaf, features);
     });
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidBoundedLocalCache.java
Patch:
@@ -77,9 +77,6 @@ private void drain(BoundedLocalCache<K, V> cache) {
   }
 
   private void checkReadBuffer(BoundedLocalCache<K, V> cache) {
-    if (!cache.evicts() && !cache.expiresAfterAccess()) {
-      return;
-    }
     Buffer<?> buffer = cache.readBuffer;
     desc.expectThat("buffer is empty", buffer.size(), is(0));
     desc.expectThat("buffer reads = writes", buffer.reads(), is(buffer.writes()));

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncCacheLoader.java
Patch:
@@ -33,7 +33,7 @@
  * <pre>{@code
  *   AsyncCacheLoader<Key, Graph> loader = (key, executor) ->
  *       createExpensiveGraphAsync(key, executor);
- *   AsyncLoadingCache<Key, Graph> cache = Caffeine.newBuilder().build(loader);
+ *   AsyncLoadingCache<Key, Graph> cache = Caffeine.newBuilder().buildAsync(loader);
  * }</pre>
  *
  * @author ben.manes@gmail.com (Ben Manes)

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/Feature.java
Patch:
@@ -44,7 +44,6 @@ public enum Feature {
   MAXIMUM_WEIGHT,
 
   LISTENING,
-  LOADING,
   STATS;
 
   public static String makeEnumName(Iterable<Feature> features) {

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/local/AddConstructor.java
Patch:
@@ -36,8 +36,6 @@ protected void execute() {
         .addParameter(BUILDER_PARAM)
         .addParameter(CACHE_LOADER_PARAM)
         .addParameter(boolean.class, "async")
-        .addStatement(context.parentFeatures.isEmpty()
-            ? "super(builder, async)"
-            : "super(builder, cacheLoader, async)");
+        .addStatement("super(builder, (CacheLoader<K, V>) cacheLoader, async)");
   }
 }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsCacheReserializable.java
Patch:
@@ -196,7 +196,7 @@ private static <K, V> void checkBoundedLocalManualCache(
   private static <K, V> void checkBoundedLocalLoadingCache(
       BoundedLocalCache.BoundedLocalLoadingCache<K, V> original,
       BoundedLocalCache.BoundedLocalLoadingCache<K, V> copy, DescriptionBuilder desc) {
-    desc.expectThat("same cacheLoader", copy.cache.cacheLoader(), is(original.cache.cacheLoader()));
+    desc.expectThat("same cacheLoader", copy.cache.cacheLoader, is(original.cache.cacheLoader));
   }
 
   private static <K, V> void checkBoundedAsyncLocalLoadingCache(

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/ComputeBenchmark.java
Patch:
@@ -31,7 +31,7 @@
 
 import com.google.common.base.Throwables;
 import com.google.common.cache.CacheBuilder;
-import com.yahoo.ycsb.generator.IntegerGenerator;
+import com.yahoo.ycsb.generator.NumberGenerator;
 import com.yahoo.ycsb.generator.ScrambledZipfianGenerator;
 
 /**
@@ -60,9 +60,9 @@ public static class ThreadState {
 
   public ComputeBenchmark() {
     ints = new Integer[SIZE];
-    IntegerGenerator generator = new ScrambledZipfianGenerator(ITEMS);
+    NumberGenerator generator = new ScrambledZipfianGenerator(ITEMS);
     for (int i = 0; i < SIZE; i++) {
-      ints[i] = generator.nextInt();
+      ints[i] = generator.nextValue().intValue();
     }
   }
 

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/FrequencySketchBenchmark.java
Patch:
@@ -20,7 +20,7 @@
 import org.openjdk.jmh.annotations.Setup;
 import org.openjdk.jmh.annotations.State;
 
-import com.yahoo.ycsb.generator.IntegerGenerator;
+import com.yahoo.ycsb.generator.NumberGenerator;
 import com.yahoo.ycsb.generator.ScrambledZipfianGenerator;
 
 /**
@@ -46,9 +46,9 @@ public void setup() {
     sketch = new FrequencySketch<>();
     sketch.ensureCapacity(ITEMS);
 
-    IntegerGenerator generator = new ScrambledZipfianGenerator(ITEMS);
+    NumberGenerator generator = new ScrambledZipfianGenerator(ITEMS);
     for (int i = 0; i < SIZE; i++) {
-      ints[i] = generator.nextInt();
+      ints[i] = generator.nextValue().intValue();
       sketch.increment(i);
     }
   }

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/GetPutBenchmark.java
Patch:
@@ -27,7 +27,7 @@
 import org.openjdk.jmh.annotations.State;
 import org.openjdk.jmh.annotations.TearDown;
 
-import com.yahoo.ycsb.generator.IntegerGenerator;
+import com.yahoo.ycsb.generator.NumberGenerator;
 import com.yahoo.ycsb.generator.ScrambledZipfianGenerator;
 
 /**
@@ -85,9 +85,9 @@ public void setup() {
     cache.cleanUp();
 
     // Populate with a realistic access distribution
-    IntegerGenerator generator = new ScrambledZipfianGenerator(ITEMS);
+    NumberGenerator generator = new ScrambledZipfianGenerator(ITEMS);
     for (int i = 0; i < SIZE; i++) {
-      ints[i] = generator.nextInt();
+      ints[i] = generator.nextValue().intValue();
       cache.put(ints[i], Boolean.TRUE);
     }
   }

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/profiler/CacheProfiler.java
Patch:
@@ -19,7 +19,7 @@
 
 import com.github.benmanes.caffeine.cache.BasicCache;
 import com.github.benmanes.caffeine.cache.CacheType;
-import com.yahoo.ycsb.generator.IntegerGenerator;
+import com.yahoo.ycsb.generator.NumberGenerator;
 import com.yahoo.ycsb.generator.ScrambledZipfianGenerator;
 
 /**
@@ -42,9 +42,9 @@ public final class CacheProfiler extends ProfilerHook {
   CacheProfiler() {
     ints = new Integer[SIZE];
     cache = cacheType.create(2 * SIZE);
-    IntegerGenerator generator = new ScrambledZipfianGenerator(ITEMS);
+    NumberGenerator generator = new ScrambledZipfianGenerator(ITEMS);
     for (int i = 0; i < SIZE; i++) {
-      ints[i] = generator.nextInt();
+      ints[i] = generator.nextValue().intValue();
       cache.put(ints[i], Boolean.TRUE);
     }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncLoadingCache.java
Patch:
@@ -93,7 +93,7 @@ CompletableFuture<V> get(@Nonnull K key,
    * @throws RuntimeException or Error if the mappingFunction does when constructing the future,
    *         in which case the mapping is left unestablished
    */
-  @CheckForNull
+  @Nonnull
   CompletableFuture<V> get(@Nonnull K key,
       @Nonnull BiFunction<? super K, Executor, CompletableFuture<V>> mappingFunction);
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -2675,14 +2675,14 @@ static final class BoundedLocalAsyncLoadingCache<K, V>
     Policy<K, V> policy;
 
     @SuppressWarnings("unchecked")
-    BoundedLocalAsyncLoadingCache(Caffeine<K, V> builder, CacheLoader<? super K, V> loader) {
+    BoundedLocalAsyncLoadingCache(Caffeine<K, V> builder, AsyncCacheLoader<? super K, V> loader) {
       super(LocalCacheFactory.newBoundedLocalCache((Caffeine<K, CompletableFuture<V>>) builder,
           asyncLoader(loader, builder), true), loader);
       isWeighted = builder.isWeighted();
     }
 
     private static <K, V> CacheLoader<? super K, CompletableFuture<V>> asyncLoader(
-        CacheLoader<? super K, V> loader, Caffeine<?, ?> builder) {
+        AsyncCacheLoader<? super K, V> loader, Caffeine<?, ?> builder) {
       Executor executor = builder.getExecutor();
       return key -> loader.asyncLoad(key, executor);
     }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalCache.java
Patch:
@@ -179,7 +179,7 @@ default void invalidateAll(Iterable<?> keys) {
   }
 
   @SuppressWarnings({"unchecked", "TypeParameterUnusedInFormals"})
-  static <T extends Exception, V> V throwUnchecked(Exception e) throws T {
-    throw (T) e;
+  static <T extends Throwable, V> V throwUnchecked(Throwable t) throws T {
+    throw (T) t;
   }
 }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/UnboundedLocalCache.java
Patch:
@@ -889,7 +889,7 @@ static final class UnboundedLocalAsyncLoadingCache<K, V>
     Policy<K, V> policy;
 
     @SuppressWarnings("unchecked")
-    UnboundedLocalAsyncLoadingCache(Caffeine<K, V> builder, CacheLoader<? super K, V> loader) {
+    UnboundedLocalAsyncLoadingCache(Caffeine<K, V> builder, AsyncCacheLoader<? super K, V> loader) {
       super(new UnboundedLocalCache<>((Caffeine<K, CompletableFuture<V>>) builder, true), loader);
     }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheValidationListener.java
Patch:
@@ -71,6 +71,8 @@ public void afterInvocation(IInvokedMethod method, ITestResult testResult) {
         checkWriter(testResult, context);
         checkNoStats(testResult, context);
         checkExecutor(testResult, context);
+      } else {
+        testResult.setThrowable(new AssertionError(getTestName(method), testResult.getThrowable()));
       }
     } catch (Throwable caught) {
       testResult.setStatus(ITestResult.FAILURE);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CaffeineCacheFromContext.java
Patch:
@@ -85,7 +85,8 @@ public static <K, V> Cache<K, V> newCaffeineCache(CacheContext context) {
       builder.writer(context.cacheWriter());
     }
     if (context.isAsync()) {
-      context.asyncCache = builder.buildAsync(context.loader);
+      context.asyncCache = builder.buildAsync(
+          context.isAsyncLoading ? context.loader.async() : context.loader);
       context.cache = context.asyncCache.synchronous();
     } else if (context.loader == null) {
       context.cache = builder.build();

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/Synthetic.java
Patch:
@@ -22,7 +22,7 @@
 import com.yahoo.ycsb.generator.CounterGenerator;
 import com.yahoo.ycsb.generator.ExponentialGenerator;
 import com.yahoo.ycsb.generator.HotspotIntegerGenerator;
-import com.yahoo.ycsb.generator.IntegerGenerator;
+import com.yahoo.ycsb.generator.NumberGenerator;
 import com.yahoo.ycsb.generator.ScrambledZipfianGenerator;
 import com.yahoo.ycsb.generator.SkewedLatestGenerator;
 import com.yahoo.ycsb.generator.UniformIntegerGenerator;
@@ -150,7 +150,7 @@ public static LongStream uniform(int lowerBound, int upperBound, int items) {
   }
 
   /** Returns a sequence of items constructed by the generator. */
-  private static LongStream generate(IntegerGenerator generator, long count) {
-    return LongStream.range(0, count).map(ignored -> generator.nextInt());
+  private static LongStream generate(NumberGenerator generator, long count) {
+    return LongStream.range(0, count).map(ignored -> generator.nextValue().intValue());
   }
 }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -602,9 +602,9 @@ void expireAfterAccessEntries(long now) {
   void expireAfterAccessEntries(AccessOrderDeque<Node<K, V>> accessOrderDeque,
       long expirationTime, long now) {
     for (;;) {
-      final Node<K, V> node = accessOrderDeque.peekFirst();
+      Node<K, V> node = accessOrderDeque.peekFirst();
       if ((node == null) || (node.getAccessTime() > expirationTime)) {
-        break;
+        return;
       }
       evictEntry(node, RemovalCause.EXPIRED, now);
     }
@@ -925,7 +925,7 @@ void onAccess(Node<K, V> node) {
     }
   }
 
-  /** Updates the node's location in the probation queue. */
+  /** Promote the node from probation to protected on an access. */
   @GuardedBy("evictionLock")
   void reorderProbation(Node<K, V> node) {
     if (!accessOrderProbationDeque().contains(node)) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/UnboundedLocalCacheTest.java
Patch:
@@ -29,7 +29,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.CacheWeigher;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Expire;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Implementation;
-import com.github.benmanes.caffeine.cache.testing.CacheSpec.MaximumSize;
+import com.github.benmanes.caffeine.cache.testing.CacheSpec.Maximum;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Population;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.ReferenceType;
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
@@ -44,7 +44,7 @@
 public final class UnboundedLocalCacheTest {
 
   @CacheSpec(implementation = Implementation.Caffeine, population = Population.EMPTY,
-      maximumSize = MaximumSize.DISABLED, weigher = CacheWeigher.DEFAULT,
+      maximumSize = Maximum.DISABLED, weigher = CacheWeigher.DEFAULT,
       expireAfterAccess = Expire.DISABLED, expireAfterWrite = Expire.DISABLED,
       refreshAfterWrite = Expire.DISABLED, keys = ReferenceType.STRONG,
       values = ReferenceType.STRONG)
@@ -57,7 +57,7 @@ public void noPolicy(Cache<Integer, Integer> cache, CacheContext context) {
   }
 
   @CacheSpec(implementation = Implementation.Caffeine, population = Population.EMPTY,
-      maximumSize = MaximumSize.DISABLED, weigher = CacheWeigher.DEFAULT,
+      maximumSize = Maximum.DISABLED, weigher = CacheWeigher.DEFAULT,
       expireAfterAccess = Expire.DISABLED, expireAfterWrite = Expire.DISABLED,
       refreshAfterWrite = Expire.DISABLED, keys = ReferenceType.STRONG,
       values = ReferenceType.STRONG)

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheGenerator.java
Patch:
@@ -35,7 +35,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.InitialCapacity;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Listener;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Loader;
-import com.github.benmanes.caffeine.cache.testing.CacheSpec.MaximumSize;
+import com.github.benmanes.caffeine.cache.testing.CacheSpec.Maximum;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Population;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.ReferenceType;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Stats;
@@ -138,7 +138,7 @@ private CacheContext newCacheContext(List<Object> combination) {
         (InitialCapacity) combination.get(index++),
         (Stats) combination.get(index++),
         (CacheWeigher) combination.get(index++),
-        (MaximumSize) combination.get(index++),
+        (Maximum) combination.get(index++),
         (Expire) combination.get(index++),
         (Expire) combination.get(index++),
         (Expire) combination.get(index++),

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CaffeineCacheFromContext.java
Patch:
@@ -25,7 +25,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Expire;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.InitialCapacity;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Listener;
-import com.github.benmanes.caffeine.cache.testing.CacheSpec.MaximumSize;
+import com.github.benmanes.caffeine.cache.testing.CacheSpec.Maximum;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.ReferenceType;
 
 /**
@@ -45,7 +45,7 @@ public static <K, V> Cache<K, V> newCaffeineCache(CacheContext context) {
     if (context.isRecordingStats()) {
       builder.recordStats();
     }
-    if (context.maximumSize != MaximumSize.DISABLED) {
+    if (context.maximumSize != Maximum.DISABLED) {
       if (context.weigher == CacheWeigher.DEFAULT) {
         builder.maximumSize(context.maximumSize.max());
       } else {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java
Patch:
@@ -41,7 +41,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Expire;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.InitialCapacity;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Listener;
-import com.github.benmanes.caffeine.cache.testing.CacheSpec.MaximumSize;
+import com.github.benmanes.caffeine.cache.testing.CacheSpec.Maximum;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.ReferenceType;
 import com.google.common.cache.AbstractCache.SimpleStatsCounter;
 import com.google.common.cache.AbstractCache.StatsCounter;
@@ -76,7 +76,7 @@ public static <K, V> Cache<K, V> newGuavaCache(CacheContext context) {
     if (context.isRecordingStats()) {
       builder.recordStats();
     }
-    if (context.maximumSize != MaximumSize.DISABLED) {
+    if (context.maximumSize != Maximum.DISABLED) {
       if (context.weigher == CacheWeigher.DEFAULT) {
         builder.maximumSize(context.maximumSize.max());
       } else {

File: guava/src/test/java/com/github/benmanes/caffeine/cache/PackageSanityTests.java
Patch:
@@ -29,6 +29,7 @@ public PackageSanityTests() {
     setDefault(CacheLoader.class, key -> key);
     setDefault(Caffeine.class, Caffeine.newBuilder());
     ignoreClasses(clazz ->
+        clazz == CaffeineSpec.class ||
         clazz.getSimpleName().startsWith("Is") ||
         clazz.getSimpleName().endsWith("Test") ||
         clazz.getSimpleName().contains("Stresser") ||

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/ReadBufferBenchmark.java
Patch:
@@ -53,8 +53,8 @@ public void setup() {
   }
 
   @Benchmark @Group @GroupThreads(8)
-  public void record() {
-    buffer.offer(Boolean.TRUE);
+  public int record() {
+    return buffer.offer(Boolean.TRUE);
   }
 
   @Benchmark @Group @GroupThreads(1)

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CacheTest.java
Patch:
@@ -151,6 +151,8 @@ public void get_throwsException(Cache<Integer, Integer> cache, CacheContext cont
   @Test(dataProvider = "caches")
   public void get_absent_null(LoadingCache<Integer, Integer> cache, CacheContext context) {
     assertThat(cache.get(context.absentKey(), k -> null), is(nullValue()));
+    assertThat(context, both(hasMissCount(1)).and(hasHitCount(0)));
+    assertThat(context, both(hasLoadSuccessCount(0)).and(hasLoadFailureCount(1)));
   }
 
   @CacheSpec

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpirationTest.java
Patch:
@@ -87,7 +87,7 @@ public void expire_zero(Cache<Integer, Integer> cache, CacheContext context) {
   @Test(dataProvider = "caches", expectedExceptions = DeleteException.class)
   @CacheSpec(implementation = Implementation.Caffeine, keys = ReferenceType.STRONG,
       population = Population.FULL, writer = Writer.EXCEPTIONAL, requiresExpiration = true,
-      expireAfterAccess = {Expire.DISABLED, Expire.ONE_MINUTE},
+      expireAfterAccess = {Expire.DISABLED, Expire.ONE_MINUTE}, executorMayFail = true,
       expireAfterWrite = {Expire.DISABLED, Expire.ONE_MINUTE},
       compute = Compute.SYNC, removalListener = Listener.REJECTING)
   public void getIfPresent_writerFails(Cache<Integer, Integer> cache, CacheContext context) {
@@ -837,7 +837,7 @@ public void computeIfPresent(Map<Integer, Integer> map, CacheContext context) {
 
   @Test(dataProvider = "caches", expectedExceptions = DeleteException.class)
   @CacheSpec(implementation = Implementation.Caffeine, keys = ReferenceType.STRONG,
-      population = Population.FULL, requiresExpiration = true,
+      population = Population.FULL, requiresExpiration = true, executorMayFail = true,
       expireAfterAccess = {Expire.DISABLED, Expire.ONE_MINUTE},
       expireAfterWrite = {Expire.DISABLED, Expire.ONE_MINUTE},
       compute = Compute.SYNC, writer = Writer.EXCEPTIONAL, removalListener = Listener.REJECTING)

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LoadingCacheTest.java
Patch:
@@ -71,6 +71,8 @@ public void get_null(LoadingCache<Integer, Integer> cache, CacheContext context)
   @CacheSpec(loader = Loader.NULL)
   public void get_absent_null(LoadingCache<Integer, Integer> cache, CacheContext context) {
     assertThat(cache.get(context.absentKey()), is(nullValue()));
+    assertThat(context, both(hasMissCount(1)).and(hasHitCount(0)));
+    assertThat(context, both(hasLoadSuccessCount(0)).and(hasLoadFailureCount(1)));
   }
 
   @CheckNoWriter

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/UnboundedLocalCacheTest.java
Patch:
@@ -23,6 +23,7 @@
 import org.testng.annotations.Listeners;
 import org.testng.annotations.Test;
 
+import com.github.benmanes.caffeine.cache.testing.CacheContext;
 import com.github.benmanes.caffeine.cache.testing.CacheProvider;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.CacheWeigher;
@@ -48,7 +49,7 @@ public final class UnboundedLocalCacheTest {
       refreshAfterWrite = Expire.DISABLED, keys = ReferenceType.STRONG,
       values = ReferenceType.STRONG)
   @Test(dataProvider = "caches")
-  public void noPolicy(Cache<Integer, Integer> cache) {
+  public void noPolicy(Cache<Integer, Integer> cache, CacheContext context) {
     assertThat(cache.policy().eviction(), is(Optional.empty()));
     assertThat(cache.policy().expireAfterWrite(), is(Optional.empty()));
     assertThat(cache.policy().expireAfterAccess(), is(Optional.empty()));
@@ -61,7 +62,7 @@ public void noPolicy(Cache<Integer, Integer> cache) {
       refreshAfterWrite = Expire.DISABLED, keys = ReferenceType.STRONG,
       values = ReferenceType.STRONG)
   @Test(dataProvider = "caches")
-  public void noPolicy_async(AsyncLoadingCache<Integer, Integer> cache) {
+  public void noPolicy_async(AsyncLoadingCache<Integer, Integer> cache, CacheContext context) {
     assertThat(cache.synchronous().policy().eviction(), is(Optional.empty()));
     assertThat(cache.synchronous().policy().expireAfterWrite(), is(Optional.empty()));
     assertThat(cache.synchronous().policy().expireAfterAccess(), is(Optional.empty()));

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContext.java
Patch:
@@ -26,7 +26,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.Executor;
 import java.util.concurrent.ThreadLocalRandom;
 
 import javax.annotation.Nullable;
@@ -66,12 +65,12 @@ public final class CacheContext {
   final CacheExecutor cacheExecutor;
   final ReferenceType valueStrength;
   final ReferenceType keyStrength;
+  final TrackingExecutor executor;
   final MaximumSize maximumSize;
   final Population population;
   final CacheWeigher weigher;
   final Expire afterAccess;
   final Expire afterWrite;
-  final Executor executor;
   final Compute compute;
   final Advance advance;
   final Expire refresh;
@@ -354,7 +353,7 @@ public CacheExecutor executorType() {
     return cacheExecutor;
   }
 
-  public Executor executor() {
+  public TrackingExecutor executor() {
     return executor;
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java
Patch:
@@ -329,6 +329,7 @@ public V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingF
                 statsCounter.recordLoadException(ticker.read() - now);
                 return null;
               } else {
+                statsCounter.recordLoadException(ticker.read() - now);
                 return null;
               }
             } else {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/Ehcache2Policy.java
Patch:
@@ -45,7 +45,7 @@ public final class Ehcache2Policy implements Policy {
   public Ehcache2Policy(Config config) {
     Ehcache2Settings settings = new Ehcache2Settings(config);
     maximumSize = settings.maximumSize();
-    policyStats = new PolicyStats("product.ehcache2");
+    policyStats = new PolicyStats("product.Ehcache2");
 
     CacheConfiguration configuration = new CacheConfiguration("ehcache2", maximumSize);
     configuration.setMemoryStoreEvictionPolicyFromObject(settings.policy());

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/wikipedia/WikipediaTraceReader.java
Patch:
@@ -38,7 +38,7 @@ public final class WikipediaTraceReader extends TextTraceReader {
   private static final String[] CONTAINS_FILTER = {"?search=", "&search=", "User+talk", "User_talk",
       "User:", "Talk:", "&diff=", "&action=rollback", "Special:Watchlist"};
   private static final String[] STARTS_WITH_FILTER = {"wiki/Special:Search", "w/query.php",
-      "wiki/Talk:", "wiki/Special:AutoLogin", "Special:UserLogin", "w/api.php"};
+      "wiki/Talk:", "wiki/Special:AutoLogin", "Special:UserLogin", "w/api.php", "error:"};
   private static final String[] SEARCH_LIST = { "%2F", "%20", "&amp;", "%3A" };
   private static final String[] REPLACEMENT_LIST = { "/", " ", "&", ":" };
 
@@ -101,7 +101,7 @@ private String getRequestUrl(String line) {
   private String getPath(String url) {
     int index = url.indexOf('/', 7);
     if (index == -1) {
-      return "";
+      return url;
     }
     String path = url.substring(index + 1);
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/S4WindowTinyLfuPolicy.java
Patch:
@@ -98,12 +98,12 @@ private void onMiss(long key) {
     evict();
   }
 
-  /** Moves the entry to the LRU position in the admission window. */
+  /** Moves the entry to the MRU position in the admission window. */
   private void onEdenHit(Node node) {
     node.moveToTail(headEden);
   }
 
-  /** Promotes the entry to the protected region's LRU position, demoting an entry if necessary. */
+  /** Promotes the entry to the protected region's MRU position, demoting an entry if necessary. */
   private void onMainHit(Node node) {
     node.remove();
     sizeMainQ[node.level]--;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/WindowTinyLfuPolicy.java
Patch:
@@ -115,13 +115,13 @@ private void onMiss(long key) {
     evict();
   }
 
-  /** Moves the entry to the LRU position in the admission window. */
+  /** Moves the entry to the MRU position in the admission window. */
   private void onEdenHit(Node node) {
     admittor.record(node.key);
     node.moveToTail(headEden);
   }
 
-  /** Promotes the entry to the protected region's LRU position, demoting an entry if necessary. */
+  /** Promotes the entry to the protected region's MRU position, demoting an entry if necessary. */
   private void onProbationHit(Node node) {
     admittor.record(node.key);
 
@@ -140,7 +140,7 @@ private void onProbationHit(Node node) {
     }
   }
 
-  /** Moves the entry to the LRU position, if it falls outside of the fast-path threshold. */
+  /** Moves the entry to the MRU position, if it falls outside of the fast-path threshold. */
   private void onProtectedHit(Node node) {
     // Fast path skips the hottest entries, useful for concurrent caches
     if (node.recencyMove <= (mainRecencyCounter - recencyMoveDistance)) {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/tinycache/TinyCachePolicy.java
Patch:
@@ -21,6 +21,9 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.typesafe.config.Config;
 
+/**
+ * @author gilga1983@gmail.com (Gil Einziger)
+ */
 public final class TinyCachePolicy implements Policy {
   private final PolicyStats policyStats;
   private final TinyCache tinyCache;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/tinycache/TinyCachePolicywithGhostCache.java
Patch:
@@ -21,6 +21,9 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.typesafe.config.Config;
 
+/**
+ * @author gilga1983@gmail.com (Gil Einziger)
+ */
 public final class TinyCachePolicywithGhostCache implements Policy {
   private final TinyCacheWithGhostCache tinyCache;
   private final PolicyStats policyStats;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/tinycache/WindowTinyCachePolicy.java
Patch:
@@ -22,6 +22,9 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.PolicyStats;
 import com.typesafe.config.Config;
 
+/**
+ * @author gilga1983@gmail.com (Gil Einziger)
+ */
 public final class WindowTinyCachePolicy implements Policy {
   private final TinyCache window;
   private final PolicyStats policyStats;

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/LocalCacheSelectorCode.java
Patch:
@@ -102,7 +102,8 @@ private LocalCacheSelectorCode expires() {
 
   private LocalCacheSelectorCode fastpath() {
     block.beginControlFlow("if (fastpath)")
-            .addStatement("sb.append('F')")
+            .addStatement("// disabled due to unfavorable benchmarks")
+            .addStatement("// sb.append('F')")
         .endControlFlow();
     return this;
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -787,7 +787,9 @@ void afterRead(Node<K, V> node, long now, boolean recordHit) {
     }
     node.setAccessTime(now);
 
-    boolean delayable = canFastpath(node) || (readBuffer.offer(node) != Buffer.FULL);
+    // fastpath is disabled due to unfavorable benchmarks
+    // boolean delayable = canFastpath(node) || (readBuffer.offer(node) != Buffer.FULL);
+    boolean delayable = (readBuffer.offer(node) != Buffer.FULL);
     if (shouldDrainBuffers(delayable)) {
       scheduleDrainBuffers();
     }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -294,7 +294,7 @@ public void exceedsMaximumBufferSize_onWrite(Cache<Integer, Integer> cache) {
     assertThat(localCache.writeQueue(), hasSize(0));
   }
 
-  @Test(dataProvider = "caches")
+  @Test(enabled = false, dataProvider = "caches")
   @CacheSpec(compute = Compute.SYNC, implementation = Implementation.Caffeine,
       population = Population.PARTIAL, maximumSize = MaximumSize.FULL,
       weigher = {CacheWeigher.DEFAULT, CacheWeigher.TEN},
@@ -330,7 +330,7 @@ public void fastpath(Cache<Integer, Integer> cache, CacheContext context) {
     assertThat(middle.getMoveCount(), is(initialMoveCount + 1));
   }
 
-  @Test(dataProvider = "caches")
+  @Test(enabled = false, dataProvider = "caches")
   @CacheSpec(compute = Compute.SYNC, implementation = Implementation.Caffeine,
       population = Population.FULL, maximumSize = MaximumSize.FULL, weigher = CacheWeigher.DEFAULT,
       expireAfterAccess = Expire.DISABLED, expireAfterWrite = Expire.DISABLED,

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Async.java
Patch:
@@ -23,6 +23,7 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
 /**
@@ -73,7 +74,7 @@ static final class AsyncRemovalListener<K, V>
     }
 
     @Override
-    public void onRemoval(K key, CompletableFuture<V> future, RemovalCause cause) {
+    public void onRemoval(K key, @Nonnull CompletableFuture<V> future, RemovalCause cause) {
       future.thenAcceptAsync(value -> {
         delegate.onRemoval(key, value, cause);
       }, executor);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheLoader.java
Patch:
@@ -43,6 +43,7 @@
  */
 @ThreadSafe
 @FunctionalInterface
+@SuppressWarnings("PMD.SignatureDeclareThrowsException")
 public interface CacheLoader<K, V> {
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncLoadingCache.java
Patch:
@@ -440,10 +440,10 @@ public void refresh(K key) {
               V oldValue = (oldValueFuture == null) ? null : oldValueFuture.join();
               V newValue = (oldValue == null) ? loader.load(key) : loader.reload(key, oldValue);
               return (newValue == null) ? null : CompletableFuture.completedFuture(newValue);
+            } catch (InterruptedException e) {
+              Thread.currentThread().interrupt();
+              return LocalCache.throwUnchecked(e);
             } catch (Exception e) {
-              if (e instanceof InterruptedException) {
-                Thread.currentThread().interrupt();
-              }
               return LocalCache.throwUnchecked(e);
             }
           };

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalLoadingCache.java
Patch:
@@ -161,10 +161,10 @@ default void refresh(K key) {
           return (oldValue == null)
               ? cacheLoader().load(key)
               : cacheLoader().reload(key, oldValue);
+        } catch (InterruptedException e) {
+          Thread.currentThread().interrupt();
+          return LocalCache.throwUnchecked(e);
         } catch (Exception e) {
-          if (e instanceof InterruptedException) {
-            Thread.currentThread().interrupt();
-          }
           return LocalCache.throwUnchecked(e);
         }
       };

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Node.java
Patch:
@@ -151,10 +151,10 @@ default int getMoveCount() {
   }
 
   /**
-   * Set entry's move count in the Main access queue. The value zero indicates that the entry
-   * resides in the Eden queue.
+   * Set entry's move count in the Main access queue. The value indicates that the entry resides in
+   * the Eden queue if zero, Probation queue if negative, or Protected if positive.
    */
-  default void setMoveCount(@Nonnegative int move) {
+  default void setMoveCount(int move) {
     throw new UnsupportedOperationException();
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/UnboundedLocalCache.java
Patch:
@@ -823,10 +823,10 @@ static final class UnboundedLocalLoadingCache<K, V> extends UnboundedLocalManual
           return loader.load(key);
         } catch (RuntimeException e) {
           throw e;
+        } catch (InterruptedException e) {
+          Thread.currentThread().interrupt();
+          throw new CompletionException(e);
         } catch (Exception e) {
-          if (e instanceof InterruptedException) {
-            Thread.currentThread().interrupt();
-          }
           throw new CompletionException(e);
         }
       };

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaCache.java
Patch:
@@ -45,7 +45,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 class CaffeinatedGuavaCache<K, V> implements Cache<K, V>, Serializable {
-  private static final long serialVersionUID = 1L;
+  static final long serialVersionUID = 1L;
 
   final com.github.benmanes.caffeine.cache.Cache<K, V> cache;
 

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaLoadingCache.java
Patch:
@@ -23,6 +23,8 @@
 import java.util.Map.Entry;
 import java.util.concurrent.ExecutionException;
 
+import javax.annotation.Nonnull;
+
 import com.github.benmanes.caffeine.cache.CacheLoader;
 import com.google.common.base.Throwables;
 import com.google.common.cache.CacheLoader.InvalidCacheLoadException;
@@ -110,7 +112,7 @@ public ImmutableMap<K, V> getAll(Iterable<? extends K> keys) throws ExecutionExc
   }
 
   @Override
-  public V apply(K key) {
+  public V apply(@Nonnull K key) {
     return cache.get(key);
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/RandomRemovalFrequencyTable.java
Patch:
@@ -39,9 +39,9 @@ public final class RandomRemovalFrequencyTable implements Frequency {
   /** sum of total items */
   private final int maxSum;
   /** total sum of stored items **/
-  private int currSum = 0;
+  private int currSum;
   /** controls both the max count and how many items are remembered (the sum) */
-  private final int sampleFactor = 8;
+  private static final int sampleFactor = 8;
   /** used to dropped items at random */
   private final Random random;
   /** a place holder for TinyTable */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/TinyCacheAdapter.java
Patch:
@@ -31,9 +31,9 @@ public final class TinyCacheAdapter implements Frequency {
   // number of (independent sets)
   int nrSets;
   // size between cache and sample.
-  final int sampleFactor = 10;
+  static final int sampleFactor = 10;
   // max frequency estimation of an item.
-  final int maxcount = 10;
+  static final int maxcount = 10;
 
   /**
    * Note that in this implementation there are always 64 items per set.

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/TraceReader.java
Patch:
@@ -15,7 +15,6 @@
 
 import java.io.IOException;
 import java.util.stream.LongStream;
-import java.util.stream.Stream;
 
 /**
  * A reader to an access trace.
@@ -28,8 +27,8 @@ public interface TraceReader<E extends Comparable<E>> {
    * Creates a {@link LongStream} that lazily reads the trace source.
    * <p>
    * If timely disposal of underlying resources is required, the try-with-resources construct should
-   * be used to ensure that the stream's {@link Stream#close close} method is invoked after the
-   * stream operations are completed.
+   * be used to ensure that the stream's {@link java.util.stream.Stream#close close} method is
+   * invoked after the stream operations are completed.
    *
    * @return a lazy stream of cache events
    */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/LirsPolicy.java
Patch:
@@ -51,6 +51,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PMD.TooManyFields")
 public final class LirsPolicy implements Policy {
   private final Long2ObjectMap<Node> data;
   private final PolicyStats policyStats;
@@ -72,7 +73,7 @@ public final class LirsPolicy implements Policy {
   private int stackCounter;
 
   // Enable to print out the internal state
-  private final boolean debug = false;
+  private static final boolean debug = false;
 
   public LirsPolicy(String name, Config config) {
     LirsSettings settings = new LirsSettings(config);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/linked/MultiQueuePolicy.java
Patch:
@@ -216,7 +216,8 @@ public int lifetime() {
     }
     public int numberOfQueues() {
       int queues = config().getInt("multi-queue.num-queues");
-      checkArgument(queues <= 62);
+      checkArgument(queues > 0, "Must have one or more queues");
+      checkArgument(queues <= 62, "May not have more than 62 queues");
       return queues;
     }
     public double percentOut() {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/sketch/FullySegmentedWindowTinyLfuPolicy.java
Patch:
@@ -34,6 +34,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("PMD.TooManyFields")
 public final class FullySegmentedWindowTinyLfuPolicy implements Policy {
   private final Long2ObjectMap<Node> data;
   private final PolicyStats policyStats;
@@ -48,8 +49,6 @@ public final class FullySegmentedWindowTinyLfuPolicy implements Policy {
 
   private final int maxEden;
   private final int maxEdenProtected;
-
-  private final int maxMain;
   private final int maxMainProtected;
 
   private int sizeEden;
@@ -59,7 +58,7 @@ public final class FullySegmentedWindowTinyLfuPolicy implements Policy {
 
   public FullySegmentedWindowTinyLfuPolicy(String name, Config config) {
     FullySegmentedWindowTinyLfuSettings settings = new FullySegmentedWindowTinyLfuSettings(config);
-    this.maxMain = (int) (settings.maximumSize() * settings.percentMain());
+    int maxMain = (int) (settings.maximumSize() * settings.percentMain());
     this.maxEden = settings.maximumSize() - maxMain;
     this.maxMainProtected = (int) (maxMain * settings.percentMainProtected());
     this.maxEdenProtected = (int) (maxEden * settings.percentEdenProtected());

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/TuQueuePolicy.java
Patch:
@@ -54,12 +54,12 @@ public class TuQueuePolicy implements Policy {
   private final PolicyStats policyStats;
   private final int maximumSize;
 
-  private int maxHot;
   private int sizeHot;
+  private final int maxHot;
   private final Node headHot;
 
-  private int maxWarm;
   private int sizeWarm;
+  private final int maxWarm;
   private final Node headWarm;
 
   private int sizeCold;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/report/TableReporter.java
Patch:
@@ -34,6 +34,7 @@ public TableReporter(Config config) {
 
   /** Assembles an aggregated report. */
   @Override
+  @SuppressWarnings("PMD.AvoidDuplicateLiterals")
   protected String assemble(List<PolicyStats> results) {
     String[][] data = new String[results.size()][headers().length];
     for (int i = 0; i < results.size(); i++) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheSpec.java
Patch:
@@ -165,6 +165,7 @@ public long max() {
   /** The weigher, each resulting in a new combination. */
   CacheWeigher[] weigher() default {
     CacheWeigher.DEFAULT,
+    CacheWeigher.ZERO,
     CacheWeigher.TEN
   };
 

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/TCache.java
Patch:
@@ -16,6 +16,7 @@
 package com.github.benmanes.caffeine.cache.impl;
 
 import com.github.benmanes.caffeine.cache.BasicCache;
+import com.github.benmanes.caffeine.cache.CacheType;
 import com.trivago.triava.tcache.EvictionPolicy;
 import com.trivago.triava.tcache.TCacheFactory;
 import com.trivago.triava.tcache.eviction.Cache;
@@ -28,6 +29,7 @@ public final class TCache<K, V> implements BasicCache<K, V> {
 
   public TCache(int maximumSize, EvictionPolicy policy) {
     cache = TCacheFactory.standardFactory().<K, V>builder()
+        .setConcurrencyLevel(CacheType.CONCURRENCY_LEVEL)
         .setExpectedMapSize(maximumSize)
         .setEvictionPolicy(policy)
         .build();

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/FrequencySketch.java
Patch:
@@ -42,8 +42,7 @@ final class FrequencySketch<E> {
    * fixed depth of four balances the accuracy and cost, resulting in a width of four times the
    * length of the array. To retain an accurate estimation the array's length equals the maximum
    * number of entries in the cache, increased to the closest power-of-two to exploit more efficient
-   * bit masking. This configuration results in a confidence of 93.75% and error bound of
-   * epsilon / width.
+   * bit masking. This configuration results in a confidence of 93.75% and error bound of e / width.
    *
    * The frequency of all entries is aged periodically using a sampling window based on the maximum
    * number of entries in the cache. This is referred to as the reset operation by TinyLfu and keeps

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/GetPutBenchmark.java
Patch:
@@ -58,6 +58,8 @@ public class GetPutBenchmark {
     "Ehcache3_Lru",
     "Infinispan_Old_Lru",
     "Infinispan_New_Lru",
+    "TCache_Lfu",
+    "TCache_Lru",
   })
   CacheType cacheType;
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/PolicyBuilder.java
Patch:
@@ -38,6 +38,7 @@
 import com.github.benmanes.caffeine.cache.simulator.policy.product.Ehcache3Policy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.GuavaPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.product.InfinispanPolicy;
+import com.github.benmanes.caffeine.cache.simulator.policy.product.TCachePolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.sampled.SamplingPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.WindowTinyLfuPolicy;
 import com.github.benmanes.caffeine.cache.simulator.policy.sketch.tinycache.TinyCachePolicy;
@@ -148,6 +149,8 @@ public Policy build() {
           return new CaffeinePolicy(type, config);
         } else if (strategy.equalsIgnoreCase("Infinispan")) {
           return new InfinispanPolicy(type, config);
+        } else if (strategy.equalsIgnoreCase("TCache")) {
+          return new TCachePolicy(type, config);
         }
         break;
       default:

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/CacheType.java
Patch:
@@ -89,6 +89,7 @@ public enum CacheType {
       return new ConcurrentMapCache<>(
           new ConcurrentLinkedHashMap.Builder<K, V>()
             .maximumWeightedCapacity(maximumSize)
+            .initialCapacity(maximumSize)
             .build());
     }
   },

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/CaffeineCache.java
Patch:
@@ -30,6 +30,7 @@ public final class CaffeineCache<K, V> implements BasicCache<K, V> {
   public CaffeineCache(int maximumSize) {
     cache = Caffeine.newBuilder()
         .executor(Executors.newWorkStealingPool(1))
+        .initialCapacity(maximumSize)
         .maximumSize(maximumSize)
         .build();
   }

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/GuavaCache.java
Patch:
@@ -31,6 +31,7 @@ public final class GuavaCache<K, V> implements BasicCache<K, V> {
   public GuavaCache(int maximumSize) {
     cache = CacheBuilder.newBuilder()
         .concurrencyLevel(CONCURRENCY_LEVEL)
+        .initialCapacity(maximumSize)
         .maximumSize(maximumSize)
         .build();
   }

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/profiler/CacheProfiler.java
Patch:
@@ -48,7 +48,7 @@ public final class CacheProfiler extends ProfilerHook {
       cache.put(ints[i], Boolean.TRUE);
     }
 
-    reads = true;
+    reads = false;
   }
 
   @Override

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -800,10 +800,10 @@ void afterWrite(@Nullable Node<K, V> node, Runnable task, long now) {
    */
   void scheduleDrainBuffers() {
     if (evictionLock.tryLock()) {
-      if (drainStatus() == PROCESSING) {
-        return;
-      }
       try {
+        if (drainStatus() == PROCESSING) {
+          return;
+        }
         lazySetDrainStatus(PROCESSING);
         executor().execute(drainBuffersTask);
       } catch (Throwable t) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -240,7 +240,7 @@ void notifyRemoval(@Nullable K key, @Nullable V value, RemovalCause cause) {
     try {
       executor().execute(() -> {
         try {
-          removalListener().onRemoval(new RemovalNotification<K, V>(key, value, cause));
+          removalListener().onRemoval(key, value, cause);
         } catch (Throwable t) {
           logger.log(Level.WARNING, "Exception thrown by removal listener", t);
         }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CaffeineTest.java
Patch:
@@ -60,7 +60,7 @@ public void configured() {
     Caffeine<Object, Object> configured = Caffeine.newBuilder()
         .initialCapacity(1).weakKeys().softValues()
         .expireAfterAccess(1, TimeUnit.SECONDS).expireAfterWrite(1, TimeUnit.SECONDS)
-        .removalListener(x -> {}).recordStats();
+        .removalListener((k, v, c) -> {}).recordStats();
     assertThat(configured.build(), is(not(nullValue())));
     assertThat(configured.build(loader), is(not(nullValue())));
     assertThat(Caffeine.newBuilder().buildAsync(loader), is(not(nullValue())));
@@ -415,12 +415,12 @@ public void removalListener_null() {
 
   @Test(expectedExceptions = IllegalStateException.class)
   public void removalListener_twice() {
-    Caffeine.newBuilder().removalListener(notif -> {}).removalListener(notif -> {});
+    Caffeine.newBuilder().removalListener((k, v, c) -> {}).removalListener((k, v, c) -> {});
   }
 
   @Test
   public void removalListener() {
-    RemovalListener<Object, Object> removalListener = notif -> {};
+    RemovalListener<Object, Object> removalListener = (k, v, c) -> {};
     Caffeine<?, ?> builder = Caffeine.newBuilder().removalListener(removalListener);
     assertThat(builder.getRemovalListener(false), is(removalListener));
     builder.build();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/Stresser.java
Patch:
@@ -57,7 +57,7 @@ public Stresser() {
     statusExecutor = Executors.newSingleThreadScheduledExecutor(threadFactory);
     statusExecutor.scheduleAtFixedRate(newStatusTask(), THREADS, STATUS_INTERVAL, SECONDS);
     cache = Caffeine.newBuilder()
-        .removalListener(notif -> evictions.increment())
+        .removalListener((k, v, c) -> evictions.increment())
         .executor(MoreExecutors.directExecutor())
         .maximumSize(SIZE)
         .build();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaCacheFromContext.java
Patch:
@@ -494,8 +494,7 @@ public void onRemoval(RemovalNotification<K, V> notification) {
         // Guava internally uses sizing logic for null cache case
         cause = RemovalCause.EXPIRED;
       }
-      delegate.onRemoval(new com.github.benmanes.caffeine.cache.RemovalNotification<K, V>(
-          notification.getKey(), notification.getValue(), cause));
+      delegate.onRemoval(notification.getKey(), notification.getValue(), cause);
     }
   }
 

File: guava/src/test/java/com/google/common/cache/CacheBuilderGwtTest.java
Patch:
@@ -26,8 +26,8 @@
 import java.util.concurrent.TimeUnit;
 
 import com.github.benmanes.caffeine.cache.Caffeine;
+import com.github.benmanes.caffeine.cache.RemovalCause;
 import com.github.benmanes.caffeine.cache.RemovalListener;
-import com.github.benmanes.caffeine.cache.RemovalNotification;
 import com.github.benmanes.caffeine.guava.CaffeinatedGuava;
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableList;
@@ -258,8 +258,8 @@ public void testRemovalListener() {
 
     RemovalListener<Integer, Integer> countingListener = new RemovalListener<Integer, Integer>() {
       @Override
-      public void onRemoval(RemovalNotification<Integer, Integer> notification) {
-        switch (notification.getCause()) {
+      public void onRemoval(Integer key, Integer value, RemovalCause cause) {
+        switch (cause) {
           case EXPIRED:
             stats[0]++;
             break;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/CaffeinePolicy.java
Patch:
@@ -38,7 +38,7 @@ public CaffeinePolicy(String name, Config config) {
         .executor(Runnable::run)
         .maximumSize(settings.maximumSize())
         .initialCapacity(settings.maximumSize())
-        .removalListener(notification -> policyStats.recordEviction())
+        .removalListener((k, v, c) -> policyStats.recordEviction())
         .build();
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/FrequencySketch.java
Patch:
@@ -60,7 +60,7 @@ public final class FrequencySketch<E> {
    * [2] TinyLFU: A Highly Efficient Cache Admission Policy
    * http://www.cs.technion.ac.il/~gilga/TinyLFU_PDP2014.pdf
    * [3] Denial of Service via Algorithmic Complexity Attack
-   * http://www.cs.virginia.edu/~cs216/Fall2005/notes/CrosbyWallach_UsenixSec2003.pdf
+   * https://www.usenix.org/legacy/events/sec03/tech/full_papers/crosby/crosby.pdf
    */
 
   static final long[] SEED = new long[] { // A mixture of seeds from FNV-1a, CityHash, and Murmur3
@@ -107,7 +107,7 @@ public void ensureCapacity(@Nonnegative long maximumSize) {
 
     table = new long[(maximum == 0) ? 1 : ceilingNextPowerOfTwo(maximum)];
     tableMask = Math.max(0, table.length - 1);
-    sampleSize = (10 * maximum);
+    sampleSize = (maximumSize == 0) ? 10 : (10 * maximum);
     if (sampleSize <= 0) {
       sampleSize = Integer.MAX_VALUE;
     }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinyCache/HashFunctionParser.java
Patch:
@@ -34,7 +34,7 @@ public final class HashFunctionParser {
 
   public HashFunctionParser(int nrsets) {
     this.nrSets = nrsets;
-    fpaux = new HashedItem(fpMask, fpMask, fpMask,0l);
+    fpaux = new HashedItem(fpMask, fpMask, fpMask,0L);
   }
 
   public HashedItem createHash(Object item) {
@@ -58,8 +58,8 @@ public HashedItem createHash(long item) {
     fpaux.chainId = (byte) (h & chainMask);
     h >>>= 6;
     fpaux.set = (int) ((h & Long.MAX_VALUE) % nrSets);
-    
-    fpaux.value = (item<<1)|1; 
+
+    fpaux.value = (item<<1)|1;
     if(item== 0)
     {
     	fpaux.value=1;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/TwoQueuePolicy.java
Patch:
@@ -35,7 +35,7 @@
  * This implementation is based on the pseudo code provided by the authors in their paper
  * <a href="http://www.vldb.org/conf/1994/P439.PDF">2Q: A Low Overhead High Performance Buffer
  * Management Replacement Algorithm</a>. For consistency with other policies, this version places
- * the next item to be removed at the tail and most recently added at the head of the queue.
+ * the next item to be removed at the head and most recently added at the tail of the queue.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/TinyCache.java
Patch:
@@ -31,7 +31,7 @@ public final class TinyCache<E> implements Frequency<E> {
   // number of (independent sets)
   int nrSets;
   // size between cache and sample.
-  final int sampleFactor = 8;
+  final int sampleFactor = 10;
   // max frequency estimation of an item.
   final int maxcount = 10;
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/tinyCache/TinySetIndexing.java
Patch:
@@ -85,6 +85,7 @@ public static int getChain(HashedItem fpaux, long[] chainIndex, long[] isLastInd
       tempisLastIndex >>>= 1;
 
     }
+    TinySetIndexing.ChainEnd = currentOffset;
     TinySetIndexing.ChainStart = currentOffset;
     while ((tempisLastIndex & 1L) == 0) {
       currentOffset++;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/RandomRemovalFrequencyTable.java
Patch:
@@ -25,7 +25,6 @@
 import com.github.benmanes.caffeine.cache.simulator.admission.Frequency;
 import com.typesafe.config.Config;
 
-
 /**
  * A probabilistic multiset for estimating the popularity of an element within a time window. The
  * maximum frequency of an element. The size of the sample in relation to the cache size can be

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/TinyLfu.java
Patch:
@@ -18,7 +18,7 @@
 import com.clearspring.analytics.stream.frequency.CountMin64TinyLfu;
 import com.github.benmanes.caffeine.cache.CountMin4TinyLfu;
 import com.github.benmanes.caffeine.cache.RandomRemovalFrequencyTable;
-import com.github.benmanes.caffeine.cache.TinyCacheWrapper;
+import com.github.benmanes.caffeine.cache.TinyCache;
 import com.github.benmanes.caffeine.cache.simulator.BasicSettings;
 import com.typesafe.config.Config;
 
@@ -40,7 +40,7 @@ public TinyLfu(Config config) {
     } else if (type.equalsIgnoreCase("random-table")) {
       sketch = new RandomRemovalFrequencyTable<>(config);
     } else if (type.equalsIgnoreCase("tiny-table")) {
-        sketch = new TinyCacheWrapper<>(config);
+        sketch = new TinyCache<>(config);
     } else {
       throw new IllegalStateException("Unknown sketch type: " + type);
     }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/MultiThreadedTest.java
Patch:
@@ -63,7 +63,7 @@ public void concurrent_unbounded(LoadingCache<Integer, Integer> cache, CacheCont
   }
 
   @Test(dataProvider = "caches")
-  @CacheSpec(maximumSize = MaximumSize.FULL, weigher = CacheWeigher.DEFAULT,
+  @CacheSpec(maximumSize = MaximumSize.FULL, weigher = {CacheWeigher.DEFAULT, CacheWeigher.RANDOM},
       stats = Stats.DISABLED, population = Population.EMPTY, expireAfterAccess = Expire.FOREVER,
       expireAfterWrite = Expire.FOREVER, refreshAfterWrite = Expire.DISABLED,
       removalListener = Listener.DEFAULT, keys = ReferenceType.STRONG,
@@ -84,7 +84,7 @@ public void async_concurrent_unbounded(
   }
 
   @Test(dataProvider = "caches")
-  @CacheSpec(maximumSize = MaximumSize.FULL, weigher = CacheWeigher.DEFAULT,
+  @CacheSpec(maximumSize = MaximumSize.FULL, weigher = {CacheWeigher.DEFAULT, CacheWeigher.RANDOM},
       stats = Stats.DISABLED, population = Population.EMPTY, expireAfterAccess = Expire.FOREVER,
       expireAfterWrite = Expire.FOREVER, refreshAfterWrite = Expire.DISABLED,
       removalListener = Listener.DEFAULT, keys = ReferenceType.STRONG,

File: guava/src/test/java/com/google/common/cache/CacheEvictionTest.java
Patch:
@@ -289,7 +289,7 @@ public void testEviction_overweight() {
     // add an at-the-maximum-weight entry
     getAll(cache, asList(45));
     CacheTesting.drainRecencyQueues(cache);
-    assertThat(keySet).containsExactly(0, 45);
+    assertThat(keySet).containsExactly(0, 8, 9);
 
     // add an over-the-maximum-weight entry
     getAll(cache, asList(46));

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/BasicSettings.java
Patch:
@@ -41,7 +41,7 @@ public ReportSettings report() {
   }
 
   public int randomSeed() {
-    return 1033096058;
+    return config().getInt("random-seed");
   }
 
   public int batchSize() {

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/Ehcache2Policy.java
Patch:
@@ -48,7 +48,7 @@ public Ehcache2Policy(String name, Config config) {
     policyStats = new PolicyStats(name);
 
     CacheConfiguration configuration = new CacheConfiguration(
-        "cache-" + counter.incrementAndGet(), maximumSize);
+        name + "-" + counter.incrementAndGet(), maximumSize);
     configuration.setMemoryStoreEvictionPolicyFromObject(settings.policy());
     cache = new Cache(configuration);
     cacheManager.addCache(cache);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/product/Ehcache3Policy.java
Patch:
@@ -44,7 +44,7 @@ public Ehcache3Policy(String name, Config config) {
     policyStats = new PolicyStats(name);
     Ehcache3Settings settings = new Ehcache3Settings(config);
     CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder().build(true);
-    cache = cacheManager.createCache("benchmark",
+    cache = cacheManager.createCache(name,
         CacheConfigurationBuilder.newCacheConfigurationBuilder()
             .withResourcePools(ResourcePoolsBuilder.newResourcePoolsBuilder()
                 .heap(settings.maximumSize(), EntryUnit.ENTRIES)
@@ -79,7 +79,7 @@ public Ehcache3Settings(Config config) {
       super(config);
     }
     public EvictionPrioritizer<Object, Object> prioritizer() {
-      return Prioritizer.valueOf(config().getString("ehcache3.prioritizer").toUpperCase());
+      return Prioritizer.valueOf(config().getString("ehcache3.policy").toUpperCase());
     }
   }
 }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -143,7 +143,7 @@ static void checkStatus(Node<Integer, Integer> node, Status expected) {
     }
   }
 
-  @Test(dataProvider = "caches")
+  @Test(enabled = false, dataProvider = "caches")
   @CacheSpec(compute = Compute.SYNC, implementation = Implementation.Caffeine,
       population = Population.EMPTY, maximumSize = MaximumSize.TEN, weigher = CacheWeigher.DEFAULT)
   public void evict_wtinylfu(Cache<Integer, Integer> cache, CacheContext context) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/EvictionTest.java
Patch:
@@ -168,7 +168,7 @@ public void evict_lru(Cache<Integer, Integer> cache, CacheContext context) {
     verifyWriter(context, (verifier, writer) -> verifier.deletions(evicted[0], RemovalCause.SIZE));
   }
 
-  @Test(dataProvider = "caches")
+  @Test(enabled = false, dataProvider = "caches")
   @CacheSpec(implementation = Implementation.Caffeine, maximumSize = MaximumSize.TEN,
       weigher = CacheWeigher.COLLECTION, population = Population.EMPTY,
       keys = ReferenceType.STRONG, values = ReferenceType.STRONG)
@@ -591,7 +591,7 @@ public void coldest_partial(CacheContext context, Eviction<Integer, Integer> evi
     assertThat(eviction.coldest(count).size(), is(count));
   }
 
-  @Test(dataProvider = "caches")
+  @Test(enabled = false, dataProvider = "caches")
   @CacheSpec(population = Population.FULL,
       implementation = Implementation.Caffeine, maximumSize = MaximumSize.FULL,
       removalListener = { Listener.DEFAULT, Listener.REJECTING })

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -451,6 +451,7 @@ void evictFromEden() {
         return;
       }
 
+      Node<K, V> next = node.getNextInAccessOrder();
       if (node.getWeight() != 0) {
         node.setMoveCount(incrementAndGetMoveCount());
         accessOrderEdenDeque().remove(node);
@@ -459,8 +460,7 @@ void evictFromEden() {
         int weight = node.getWeight();
         lazySetEdenWeightedSize(edenWeightedSize() - weight);
       }
-
-      node = node.getNextInAccessOrder();
+      node = next;
     }
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/FrequencySketch.java
Patch:
@@ -42,7 +42,8 @@ final class FrequencySketch<E> {
    * fixed depth of four balances the accuracy and cost, resulting in a width of four times the
    * length of the array. To retain an accurate estimation the array's length equals the maximum
    * number of entries in the cache, increased to the closest power-of-two to exploit more efficient
-   * bit masking. This configuration results in a confidence of 93.75% and error bound of ℇ / width.
+   * bit masking. This configuration results in a confidence of 93.75% and error bound of
+   * epsilon / width.
    *
    * The frequency of all entries is aged periodically using a sampling window based on the maximum
    * number of entries in the cache. This is referred to as the reset operation by TinyLfu and keeps

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsCacheReserializable.java
Patch:
@@ -214,8 +214,8 @@ private static <K, V> void checkBoundedLocalCache(BoundedLocalCache<K, V> origin
         unwrapWeigher(original.weigher).getClass())));
     desc.expectThat("same nodeFactory", copy.nodeFactory, is(original.nodeFactory));
     if (original.evicts()) {
+      desc.expectThat("same maximumWeight", copy.maximum(), is(original.maximum()));
       desc.expectThat("same maximumEdenWeight", copy.edenMaximum(), is(original.edenMaximum()));
-      desc.expectThat("same maximumMainWeight", copy.mainMaximum(), is(original.mainMaximum()));
     }
 
     if (original.expiresAfterAccess()) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidBoundedLocalCache.java
Patch:
@@ -87,7 +87,7 @@ private void checkReadBuffer(BoundedLocalCache<K, V> cache) {
   private void checkCache(BoundedLocalCache<K, V> cache, DescriptionBuilder desc) {
     desc.expectThat("Inconsistent size", cache.data.size(), is(cache.size()));
     if (cache.evicts()) {
-      desc.expectThat("overflow", cache.mainMaximum(),
+      desc.expectThat("overflow", cache.maximum(),
           is(greaterThanOrEqualTo(cache.adjustedWeightedSize())));
     }
 

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/Feature.java
Patch:
@@ -72,13 +72,13 @@ public static boolean usesWriteOrderDeque(Set<Feature> features) {
 
   public static boolean usesAccessOrderEdenDeque(Set<Feature> features) {
     return features.contains(Feature.MAXIMUM_SIZE)
-        || features.contains(Feature.MAXIMUM_WEIGHT);
+        || features.contains(Feature.MAXIMUM_WEIGHT)
+        || features.contains(Feature.EXPIRE_ACCESS);
   }
 
   public static boolean usesAccessOrderMainDeque(Set<Feature> features) {
     return features.contains(Feature.MAXIMUM_SIZE)
-        || features.contains(Feature.MAXIMUM_WEIGHT)
-        || features.contains(Feature.EXPIRE_ACCESS);
+        || features.contains(Feature.MAXIMUM_WEIGHT);
   }
 
   public static boolean usesWriteQueue(Set<Feature> features) {

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/node/AddDeques.java
Patch:
@@ -35,8 +35,8 @@ protected boolean applies() {
 
   @Override
   protected void execute() {
-    if (!Feature.usesAccessOrderMainDeque(context.parentFeatures)
-        && Feature.usesAccessOrderMainDeque(context.generateFeatures)) {
+    if (!Feature.usesAccessOrderEdenDeque(context.parentFeatures)
+        && Feature.usesAccessOrderEdenDeque(context.generateFeatures)) {
       addFieldAndGetter("previousInAccessOrder");
       addFieldAndGetter("nextInAccessOrder");
     }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -127,7 +127,7 @@ public final class Caffeine<K, V> {
   enum Strength { STRONG, WEAK, SOFT }
   static final int UNSET_INT = -1;
 
-  static final int DEFAULT_INITIAL_CAPACITY = 16;
+  static final int DEFAULT_INITIAL_CAPACITY = 0;
   static final int DEFAULT_EXPIRATION_NANOS = 0;
   static final int DEFAULT_REFRESH_NANOS = 0;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Node.java
Patch:
@@ -126,7 +126,7 @@ default int getMoveCount() {
    * Set entry's move count in the Main access queue. The value zero indicates that the entry
    * resides in the Eden queue.
    */
-  default void setMoveCountMain(@Nonnegative int move) {
+  default void setMoveCount(@Nonnegative int move) {
     throw new UnsupportedOperationException();
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsCacheReserializable.java
Patch:
@@ -214,7 +214,8 @@ private static <K, V> void checkBoundedLocalCache(BoundedLocalCache<K, V> origin
         unwrapWeigher(original.weigher).getClass())));
     desc.expectThat("same nodeFactory", copy.nodeFactory, is(original.nodeFactory));
     if (original.evicts()) {
-      desc.expectThat("same maximumWeight", copy.maximum(), is(original.maximum()));
+      desc.expectThat("same maximumEdenWeight", copy.edenMaximum(), is(original.edenMaximum()));
+      desc.expectThat("same maximumMainWeight", copy.mainMaximum(), is(original.mainMaximum()));
     }
 
     if (original.expiresAfterAccess()) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Ticker.java
Patch:
@@ -15,7 +15,6 @@
  */
 package com.github.benmanes.caffeine.cache;
 
-import javax.annotation.Nonnegative;
 import javax.annotation.Nonnull;
 import javax.annotation.concurrent.ThreadSafe;
 
@@ -29,7 +28,6 @@
 public interface Ticker {
 
   /** @return the number of nanoseconds elapsed since this ticker's fixed point of reference */
-  @Nonnegative
   long read();
 
   /** @return a ticker that reads the current time using {@link System#nanoTime} */

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/CountMin4TinyLfu.java
Patch:
@@ -25,11 +25,13 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 public final class CountMin4TinyLfu<E> implements Frequency<E> {
+  private static final int RANDOM_SEED = 1033096058;
+
   private final FrequencySketch<E> sketch;
 
   public CountMin4TinyLfu(Config config) {
     BasicSettings settings = new BasicSettings(config);
-    sketch = new FrequencySketch<>(settings.maximumSize());
+    sketch = new FrequencySketch<>(settings.maximumSize(), RANDOM_SEED);
   }
 
   @Override

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1005,7 +1005,7 @@ V put(K key, V value, boolean notifyWriter, boolean onlyIfAbsent) {
         afterRead(prior, now, false);
       }
 
-      return oldValue;
+      return expired ? null : oldValue;
     }
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpirationTest.java
Patch:
@@ -601,7 +601,7 @@ public void putIfAbsent_writerFails(Map<Integer, Integer> map, CacheContext cont
       expireAfterWrite = {Expire.DISABLED, Expire.ONE_MINUTE})
   public void put_insert(Map<Integer, Integer> map, CacheContext context) {
     context.ticker().advance(1, TimeUnit.MINUTES);
-    map.put(context.firstKey(), context.absentValue());
+    assertThat(map.put(context.firstKey(), context.absentValue()), is(nullValue()));
 
     long count = context.initialSize();
     assertThat(map.size(), is(1));
@@ -616,8 +616,8 @@ public void put_insert(Map<Integer, Integer> map, CacheContext context) {
   public void put_replace(Map<Integer, Integer> map, CacheContext context) {
     context.ticker().advance(30, TimeUnit.SECONDS);
 
-    map.put(context.firstKey(), context.absentValue());
-    map.put(context.absentKey(), context.absentValue());
+    assertThat(map.put(context.firstKey(), context.absentValue()), is(not(nullValue())));
+    assertThat(map.put(context.absentKey(), context.absentValue()), is(nullValue()));
     context.consumedNotifications().clear(); // Ignore replacement notification
 
     context.ticker().advance(45, TimeUnit.SECONDS);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterAccessTest.java
Patch:
@@ -192,7 +192,7 @@ public void putIfAbsent(Map<Integer, Integer> map, CacheContext context) {
     assertThat(map.putIfAbsent(context.firstKey(), context.absentValue()), is(not(nullValue())));
 
     context.ticker().advance(30, TimeUnit.SECONDS);
-    map.putIfAbsent(context.lastKey(), context.absentValue());
+    assertThat(map.putIfAbsent(context.lastKey(), context.absentValue()), is(nullValue()));
 
     long count = context.initialSize() - 1;
     assertThat(map.size(), is(2));

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterWriteTest.java
Patch:
@@ -177,7 +177,7 @@ public void putIfAbsent(Map<Integer, Integer> map, CacheContext context) {
     assertThat(map.putIfAbsent(context.firstKey(), context.absentValue()), is(not(nullValue())));
 
     context.ticker().advance(30, TimeUnit.SECONDS);
-    map.putIfAbsent(context.lastKey(), context.absentValue());
+    assertThat(map.putIfAbsent(context.lastKey(), context.absentValue()), is(nullValue()));
 
     long count = context.initialSize();
     assertThat(map.size(), is(1));

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/TuQueuePolicy.java
Patch:
@@ -116,7 +116,7 @@ private void onHit(Node node) {
       sizeWarm++;
 
       if (sizeWarm > maxWarm) {
-        Node demoted = admittor.admit(node.key, headWarm.next) ? headWarm.next : node;
+        Node demoted = admittor.admit(node.key, headWarm.next.key) ? headWarm.next : node;
         demoted.remove();
         sizeWarm--;
         demoted.type = QueueType.COLD;
@@ -137,7 +137,7 @@ private void onMiss(Object key) {
     sizeHot++;
 
     if (sizeHot > maxHot) {
-      Node demoted = admittor.admit(node.key, headHot.next) ? headHot.next : node;
+      Node demoted = admittor.admit(node.key, headHot.next.key) ? headHot.next : node;
       demoted.remove();
       sizeHot--;
       demoted.appendToTail(headCold);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/two_queue/TwoQueuePolicy.java
Patch:
@@ -32,7 +32,7 @@
  * monitored (OUT). The maximum size of the IN and OUT queues must be tuned with the authors
  * recommending 20% and 50% of the maximum size, respectively.
  * <p>
- * This implementation is based on the psuedo code provided by the authors in their paper
+ * This implementation is based on the pseudo code provided by the authors in their paper
  * <a href="http://www.vldb.org/conf/1994/P439.PDF">2Q: A Low Overhead High Performance Buffer
  * Management Replacement Algorithm</a>. For consistency with other policies, this version places
  * the next item to be removed at the tail and most recently added at the head of the queue.

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -971,7 +971,7 @@ V put(K key, V value, boolean notifyWriter, boolean onlyIfAbsent) {
         oldValue = prior.getValue();
         oldWeight = prior.getWeight();
         if (oldValue == null) {
-          writer.delete(key, oldValue, RemovalCause.COLLECTED);
+          writer.delete(key, null, RemovalCause.COLLECTED);
         } else if (hasExpired(prior, now)) {
           writer.delete(key, oldValue, RemovalCause.EXPIRED);
           expired = true;
@@ -1168,7 +1168,7 @@ public boolean replace(K key, V oldValue, V newValue) {
       oldKey = node.getKey();
       prevValue = node.getValue();
       oldWeight = node.getWeight();
-      if ((oldKey == null) || (oldValue == null) || hasExpired(node, now)
+      if ((oldKey == null) || (prevValue == null) || hasExpired(node, now)
           || !node.containsValue(oldValue)) {
         return false;
       }
@@ -1268,7 +1268,7 @@ V doComputeIfAbsent(K key, Object keyRef, Function<? super K, ? extends V> mappi
     });
 
     if (node == null) {
-      afterWrite(node, new RemovalTask(removed[0]), now);
+      afterWrite(null, new RemovalTask(removed[0]), now);
       return null;
     }
     if (cause[0] != null) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheLoader.java
Patch:
@@ -82,9 +82,9 @@ default Map<K, V> loadAll(@Nonnull Iterable<? extends K> keys) {
    *
    * @param key the non-null key whose value should be loaded
    * @param executor the executor that asynchronously loads the entry
-   * @return the future value associated with {@code key} or {@code null} if not computable
+   * @return the future value associated with {@code key}
    */
-  @CheckForNull
+  @Nonnull
   default CompletableFuture<V> asyncLoad(@Nonnull K key, @Nonnull Executor executor) {
     requireNonNull(key);
     requireNonNull(executor);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncLoadingCache.java
Patch:
@@ -135,7 +135,8 @@ public CompletableFuture<V> get(K key,
 
   @Override
   public CompletableFuture<V> get(K key) {
-    return get(key, loader::asyncLoad);
+    CompletableFuture<V> future = get(key, loader::asyncLoad);
+    return requireNonNull(future);
   }
 
   @Override

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/References.java
Patch:
@@ -116,7 +116,7 @@ public int hashCode() {
   static class WeakKeyReference<K> extends WeakReference<K> implements InternalReference<K> {
     private final int hashCode;
 
-    public WeakKeyReference(@Nullable K key, @Nonnull ReferenceQueue<K> queue) {
+    public WeakKeyReference(@Nullable K key, @Nullable ReferenceQueue<K> queue) {
       super(key, queue);
       hashCode = System.identityHashCode(key);
     }
@@ -147,7 +147,7 @@ static final class WeakValueReference<V> extends WeakReference<V>
     private final Object keyReference;
 
     public WeakValueReference(@Nonnull Object keyReference,
-        @Nonnull V value, @Nonnull ReferenceQueue<V> queue) {
+        @Nullable V value, @Nullable ReferenceQueue<V> queue) {
       super(value, queue);
       this.keyReference = keyReference;
     }
@@ -178,7 +178,7 @@ static final class SoftValueReference<V> extends SoftReference<V>
     private final Object keyReference;
 
     public SoftValueReference(@Nonnull Object keyReference,
-        @Nonnull V value, @Nonnull ReferenceQueue<V> queue) {
+        @Nullable V value, @Nullable ReferenceQueue<V> queue) {
       super(value, queue);
       this.keyReference = keyReference;
     }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/adaptive/CartPolicy.java
Patch:
@@ -267,7 +267,7 @@ private void demote() {
         sizeT1--;
         sizeT2++;
 
-        q = Math.max(q - q, maximumSize - sizeT1);
+        q = Math.max(q - 1, maximumSize - sizeT1);
       }
     }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/ClockProPolicy.java
Patch:
@@ -296,7 +296,7 @@ enum Status {
     HOT, COLD, TEST;
   }
 
-  private final class Node {
+  private static final class Node {
     final Object key;
     boolean marked;
     Status status;

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/irr/LirsPolicy.java
Patch:
@@ -266,8 +266,8 @@ enum StackType {
   final class Node {
     final Object key;
 
-    int irr;
     Status type;
+
     Node prevS;
     Node nextS;
     Node prevQ;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/impl/Ehcache3.java
Patch:
@@ -33,7 +33,7 @@ public final class Ehcache3<K, V> implements BasicCache<K, V> {
 
   @SuppressWarnings("unchecked")
   public Ehcache3(Prioritizer evictionPolicy, int maximumSize) {
-    CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder().build();
+    CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder().build(true);
     cache = (Cache<K, V>) cacheManager.createCache("benchmark",
         CacheConfigurationBuilder.newCacheConfigurationBuilder()
             .withResourcePools(ResourcePoolsBuilder.newResourcePoolsBuilder()

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/admission/TinyLfu.java
Patch:
@@ -42,8 +42,8 @@ public void record(Object key) {
 
   @Override
   public boolean admit(Object candidateKey, Object victimKey) {
-    long candidateCount = sketch.estimateCount(candidateKey.hashCode());
-    long victimCount = sketch.estimateCount(victimKey.hashCode());
-    return candidateCount >= victimCount;
+    long candidateFreq = sketch.frequency(candidateKey.hashCode());
+    long victimFreq = sketch.frequency(victimKey.hashCode());
+    return candidateFreq >= victimFreq;
   }
 }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheSpec.java
Patch:
@@ -399,7 +399,7 @@ enum Loader implements CacheLoader<Integer, Integer> {
       }
       @Override public Map<Integer, Integer> loadAll(Iterable<? extends Integer> keys) {
         Map<Integer, Integer> result = new HashMap<>();
-        keys.forEach(key -> result.put(key, -key));
+        keys.forEach(key -> result.put(key, interner.get().intern(-key)));
         return result;
       }
     },

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/Simulator.java
Patch:
@@ -16,7 +16,6 @@
 package com.github.benmanes.caffeine.cache.simulator;
 
 import java.io.IOException;
-import java.nio.file.Path;
 import java.util.List;
 import java.util.Map;
 import java.util.TreeMap;
@@ -120,7 +119,7 @@ private Stream<?> eventStream() throws IOException {
     if (settings.isSynthetic()) {
       return Synthetic.generate(settings).boxed();
     }
-    Path filePath = settings.traceFile().path();
+    String filePath = settings.traceFile().path();
     TraceFormat format = settings.traceFile().format();
     return format.readFile(filePath).events();
   }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/address/AddressTraceReader.java
Patch:
@@ -16,7 +16,6 @@
 package com.github.benmanes.caffeine.cache.simulator.parser.address;
 
 import java.io.IOException;
-import java.nio.file.Path;
 import java.util.stream.Stream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
@@ -29,7 +28,7 @@
  */
 public final class AddressTraceReader extends TextTraceReader<Long> {
 
-  public AddressTraceReader(Path filePath) {
+  public AddressTraceReader(String filePath) {
     super(filePath);
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/lirs/LirsTraceReader.java
Patch:
@@ -16,7 +16,6 @@
 package com.github.benmanes.caffeine.cache.simulator.parser.lirs;
 
 import java.io.IOException;
-import java.nio.file.Path;
 import java.util.stream.Stream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
@@ -28,7 +27,7 @@
  */
 public final class LirsTraceReader extends TextTraceReader<Long> {
 
-  public LirsTraceReader(Path filePath) {
+  public LirsTraceReader(String filePath) {
     super(filePath);
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/wikipedia/WikipediaTraceReader.java
Patch:
@@ -16,7 +16,6 @@
 package com.github.benmanes.caffeine.cache.simulator.parser.wikipedia;
 
 import java.io.IOException;
-import java.nio.file.Path;
 import java.util.stream.Stream;
 
 import com.github.benmanes.caffeine.cache.simulator.parser.TextTraceReader;
@@ -29,7 +28,7 @@
  */
 public final class WikipediaTraceReader extends TextTraceReader<Long> {
 
-  public WikipediaTraceReader(Path filePath) {
+  public WikipediaTraceReader(String filePath) {
     super(filePath);
   }
 

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/TextTraceReader.java
Patch:
@@ -15,6 +15,7 @@
  */
 package com.github.benmanes.caffeine.cache.simulator.parser;
 
+import static com.google.common.base.Preconditions.checkArgument;
 import static java.util.Objects.requireNonNull;
 
 import java.io.BufferedReader;
@@ -61,7 +62,7 @@ protected Path resolve(Path filePath) {
       return filePath;
     }
     URL url = getClass().getResource(filePath.getFileName().toFile().getName());
-    requireNonNull(url, "Could not find file: " + filePath);
+    checkArgument(url != null, "Could not find file: " + filePath);
     return Paths.get(url.getFile());
   }
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/policy/PolicyActor.java
Patch:
@@ -49,6 +49,8 @@ public void onReceive(Object msg) {
       policy.finished();
       getSender().tell(policy.stats(), ActorRef.noSender());
       getContext().stop(getSelf());
+    } else if (msg == Message.ERROR) {
+      getContext().stop(getSelf());
     } else {
       context().system().log().error("Invalid message: " + msg);
     }
@@ -60,6 +62,7 @@ private void process(Comparable<Object> o) {
       policy.record(o);
     } catch (Exception e) {
       context().system().log().error(e, "");
+      getSender().tell(Message.ERROR, ActorRef.noSender());
     } finally {
       policy.stats().stopwatch().stop();
     }

File: tracing/async/src/test/java/com/github/benmanes/caffeine/cache/tracing/async/AsyncTracerTest.java
Patch:
@@ -43,7 +43,7 @@
  * @author ben.manes@gmail.com (Ben Manes)
  */
 public final class AsyncTracerTest {
-  Path badPath = Jimfs.newFileSystem().getPath("\\a/b");
+  Path badPath = Jimfs.newFileSystem().getPath("a/b");
   ExecutorService executor;
   Path filePath;
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -835,7 +835,8 @@ void removeNode(Node<K, V> node, long now) {
   @Override
   public boolean containsKey(Object key) {
     Node<K, V> node = data.get(nodeFactory.newLookupKey(key));
-    return (node != null) && !hasExpired(node, expirationTicker().read());
+    return (node != null) && (node.getValue() != null)
+        && !hasExpired(node, expirationTicker().read());
   }
 
   @Override

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeGenerator.java
Patch:
@@ -450,7 +450,7 @@ private MethodSpec newSetter(TypeName varType, String varName, Visibility visibi
         .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
         .addParameter(varType, varName);
     if (visibility.isRelaxed) {
-      setter.addStatement("$T.UNSAFE.putOrdered$L(this, $N, $N)",
+      setter.addStatement("$T.UNSAFE.put$L(this, $N, $N)",
           UNSAFE_ACCESS, type, offsetName(varName), varName);
     } else {
       setter.addStatement("this.$N = $N", varName, varName);

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/profiler/ProfilerHook.java
Patch:
@@ -19,7 +19,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.LongAdder;
 
-import com.github.benmanes.caffeine.ConcurrentTestHarness;
+import com.github.benmanes.caffeine.testing.ConcurrentTestHarness;
 import com.google.common.base.Stopwatch;
 
 /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -666,7 +666,7 @@ <K1 extends K, V1 extends V> RemovalListener<K1, V1> getRemovalListener(boolean
    * <b>Warning:</b> any exception thrown by {@code writer} will be propagated to the {@code Cache}
    * user.
    * <p>
-   * This feature cannot be used in conjunction with {@link #buildAsync}.
+   * This feature cannot be used in conjunction with {@link #weakKeys()} or {@link #buildAsync}.
    *
    * @param writer a writer instance that caches should notify each time an entry is explicitly
    *        created or modified, or removed for any reason

File: caffeine/src/test/java/com/github/benmanes/caffeine/ConcurrentLinkedStackTest.java
Patch:
@@ -51,6 +51,7 @@
 import com.github.benmanes.caffeine.ConcurrentLinkedStackTest.ValidatingStackListener;
 import com.github.benmanes.caffeine.base.UnsafeAccess;
 import com.github.benmanes.caffeine.testing.Awaits;
+import com.github.benmanes.caffeine.testing.ConcurrentTestHarness;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Iterators;
 import com.google.common.testing.SerializableTester;

File: caffeine/src/test/java/com/github/benmanes/caffeine/SingleConsumerQueueTest.java
Patch:
@@ -47,6 +47,7 @@
 import com.github.benmanes.caffeine.SingleConsumerQueue.LinearizableNode;
 import com.github.benmanes.caffeine.SingleConsumerQueueTest.ValidatingQueueListener;
 import com.github.benmanes.caffeine.testing.Awaits;
+import com.github.benmanes.caffeine.testing.ConcurrentTestHarness;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.testing.SerializableTester;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedBufferTest.java
Patch:
@@ -26,7 +26,7 @@
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
-import com.github.benmanes.caffeine.ConcurrentTestHarness;
+import com.github.benmanes.caffeine.testing.ConcurrentTestHarness;
 
 /**
  * The tests cases for the {@link BoundedBuffer}.

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -37,7 +37,6 @@
 import org.testng.annotations.Listeners;
 import org.testng.annotations.Test;
 
-import com.github.benmanes.caffeine.ConcurrentTestHarness;
 import com.github.benmanes.caffeine.cache.Policy.Eviction;
 import com.github.benmanes.caffeine.cache.testing.CacheContext;
 import com.github.benmanes.caffeine.cache.testing.CacheProvider;
@@ -52,6 +51,7 @@
 import com.github.benmanes.caffeine.cache.testing.CacheValidationListener;
 import com.github.benmanes.caffeine.locks.NonReentrantLock;
 import com.github.benmanes.caffeine.testing.Awaits;
+import com.github.benmanes.caffeine.testing.ConcurrentTestHarness;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/Stresser.java
Patch:
@@ -25,9 +25,9 @@
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.atomic.LongAdder;
 
-import com.github.benmanes.caffeine.ConcurrentTestHarness;
 import com.github.benmanes.caffeine.cache.simulator.generator.IntegerGenerator;
 import com.github.benmanes.caffeine.cache.simulator.generator.ScrambledZipfianGenerator;
+import com.github.benmanes.caffeine.testing.ConcurrentTestHarness;
 import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/StripedBufferTest.java
Patch:
@@ -26,7 +26,7 @@
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
-import com.github.benmanes.caffeine.ConcurrentTestHarness;
+import com.github.benmanes.caffeine.testing.ConcurrentTestHarness;
 import com.google.common.base.MoreObjects;
 
 /**

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/BufferTest.java
Patch:
@@ -24,8 +24,8 @@
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
-import com.github.benmanes.caffeine.ConcurrentTestHarness;
 import com.github.benmanes.caffeine.cache.ReadBuffer;
+import com.github.benmanes.caffeine.testing.ConcurrentTestHarness;
 
 /**
  * The tests cases for a read buffer strategy. This validates an implementation approach which can

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/stats/StatsCounterTest.java
Patch:
@@ -20,7 +20,7 @@
 
 import org.testng.annotations.Test;
 
-import com.github.benmanes.caffeine.ConcurrentTestHarness;
+import com.github.benmanes.caffeine.testing.ConcurrentTestHarness;
 
 /**
  * @author ben.manes@gmail.com (Ben Manes)

File: caffeine/src/test/java/com/github/benmanes/caffeine/locks/NonReentrantLockTest.java
Patch:
@@ -28,8 +28,8 @@
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
-import com.github.benmanes.caffeine.ConcurrentTestHarness;
 import com.github.benmanes.caffeine.testing.Awaits;
+import com.github.benmanes.caffeine.testing.ConcurrentTestHarness;
 import com.google.common.testing.SerializableTester;
 
 /**

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/ConcurrentTestHarness.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.github.benmanes.caffeine;
+package com.github.benmanes.caffeine.testing;
 
 import java.util.ArrayList;
 import java.util.List;

File: caffeine/src/test/java/com/github/benmanes/caffeine/testing/Threads.java
Patch:
@@ -41,7 +41,6 @@
 
 import org.testng.log4testng.Logger;
 
-import com.github.benmanes.caffeine.ConcurrentTestHarness;
 import com.google.common.base.Throwables;
 import com.google.common.collect.ImmutableList;
 import com.google.common.util.concurrent.MoreExecutors;

File: guava/src/test/java/com/google/common/cache/CacheBuilderGwtTest.java
Patch:
@@ -28,7 +28,6 @@
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.cache.RemovalListener;
 import com.github.benmanes.caffeine.cache.RemovalNotification;
-import com.github.benmanes.caffeine.cache.testing.FakeTicker;
 import com.github.benmanes.caffeine.guava.CaffeinatedGuava;
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableList;

File: guava/src/test/java/com/google/common/cache/CacheBuilderTest.java
Patch:
@@ -32,11 +32,11 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
+import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import com.github.benmanes.caffeine.ConcurrentTestHarness;
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.cache.RemovalListener;
 import com.github.benmanes.caffeine.cache.RemovalNotification;
@@ -357,7 +357,7 @@ public void testRemovalNotification_clear() throws InterruptedException {
 
     final CountDownLatch computationStarted = new CountDownLatch(1);
     final CountDownLatch computationComplete = new CountDownLatch(1);
-    ConcurrentTestHarness.execute(() -> {
+    ForkJoinPool.commonPool().execute(() -> {
       computationStarted.countDown();
       cache.getUnchecked("b");
       computationComplete.countDown();

File: guava/src/test/java/com/google/common/cache/CacheExpirationTest.java
Patch:
@@ -25,19 +25,18 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import junit.framework.TestCase;
-
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.cache.RemovalListener;
 import com.github.benmanes.caffeine.cache.RemovalNotification;
-import com.github.benmanes.caffeine.cache.testing.FakeTicker;
 import com.github.benmanes.caffeine.guava.CaffeinatedGuava;
 import com.google.common.cache.TestingCacheLoaders.IdentityLoader;
 import com.google.common.cache.TestingRemovalListeners.CountingRemovalListener;
 import com.google.common.collect.Iterators;
 import com.google.common.util.concurrent.Callables;
 import com.google.common.util.concurrent.MoreExecutors;
 
+import junit.framework.TestCase;
+
 /**
  * Tests relating to cache expiration: make sure entries expire at the right times, make sure
  * expired entries don't show up, etc.

File: guava/src/test/java/com/google/common/cache/CacheRefreshTest.java
Patch:
@@ -19,7 +19,6 @@
 import junit.framework.TestCase;
 
 import com.github.benmanes.caffeine.cache.Caffeine;
-import com.github.benmanes.caffeine.cache.testing.FakeTicker;
 import com.github.benmanes.caffeine.guava.CaffeinatedGuava;
 import com.google.common.cache.TestingCacheLoaders.IncrementingLoader;
 import com.google.common.util.concurrent.MoreExecutors;

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/JCacheEvictionListener.java
Patch:
@@ -58,11 +58,10 @@ public void write(K key, Expirable<V> value) {}
   public void delete(K key, Expirable<V> value, RemovalCause cause) {
     if (cause.wasEvicted()) {
       if (cause == RemovalCause.EXPIRED) {
-        dispatcher.publishExpired(cache, key, value.get());
+        dispatcher.publishExpiredQuietly(cache, key, value.get());
       } else {
-        dispatcher.publishRemoved(cache, key, value.get());
+        dispatcher.publishRemovedQuietly(cache, key, value.get());
       }
-      dispatcher.ignoreSynchronous();
       statistics.recordEvictions(1L);
     }
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -984,7 +984,8 @@ V put(K key, V value, boolean onlyIfAbsent) {
       }
 
       int weightedDifference = mayUpdate ? (weight - oldWeight) : 0;
-      if ((oldValue == null) || expired || expiresAfterWrite() || (weightedDifference != 0)) {
+      if ((oldValue == null) || (weightedDifference != 0) || expired
+          || (!onlyIfAbsent && (oldValue != null) && expiresAfterWrite())) {
         afterWrite(prior, new UpdateTask(prior, weightedDifference), now);
       } else {
         afterRead(prior, now, false);

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeGenerator.java
Patch:
@@ -450,7 +450,7 @@ private MethodSpec newSetter(TypeName varType, String varName, Visibility visibi
         .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
         .addParameter(varType, varName);
     if (visibility.isRelaxed) {
-      setter.addStatement("$T.UNSAFE.put$L(this, $N, $N)",
+      setter.addStatement("$T.UNSAFE.putOrdered$L(this, $N, $N)",
           UNSAFE_ACCESS, type, offsetName(varName), varName);
     } else {
       setter.addStatement("this.$N = $N", varName, varName);

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Cache.java
Patch:
@@ -138,8 +138,8 @@ public interface Cache<K, V> {
   /**
    * Returns the approximate number of entries in this cache. The value returned is an estimate; the
    * actual count may differ if there are concurrent insertions or removals, or if some entries are
-   * pending removal due to expiration or soft/weak reference collection. In the case of stale
-   * entries, this inaccuracy can be mitigated by performing a {@link #cleanUp()} first.
+   * pending removal due to expiration or weak/soft reference collection. In the case of stale
+   * entries this inaccuracy can be mitigated by performing a {@link #cleanUp()} first.
    *
    * @return the estimated number of mappings
    */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheWriterVerifier.java
Patch:
@@ -67,8 +67,8 @@ public void wroteAll(Map<Integer, Integer> map) {
   }
 
   /** Checks that the expected number of delete operations occurred. */
-  public void deletions(int count) {
-    verify(context.cacheWriter(), times(count)).delete(any(), any(), any());
+  public void deletions(long count) {
+    verify(context.cacheWriter(), times((int) count)).delete(any(), any(), any());
   }
 
   /** Checks that the expected number of delete operations occurred. */

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalLoadingCache.java
Patch:
@@ -119,7 +119,7 @@ default Map<K, V> loadInBulk(Iterable<? extends K> keys) {
    */
   default void bulkLoad(List<K> keysToLoad, Map<K, V> result) {
     boolean success = false;
-    long startTime = cache().ticker().read();
+    long startTime = cache().statsTicker().read();
     try {
       @SuppressWarnings("unchecked")
       Map<K, V> loaded = (Map<K, V>) cacheLoader().loadAll(keysToLoad);
@@ -132,7 +132,7 @@ default void bulkLoad(List<K> keysToLoad, Map<K, V> result) {
       }
       success = !loaded.isEmpty();
     } finally {
-      long loadTime = cache().ticker().read() - startTime;
+      long loadTime = cache().statsTicker().read() - startTime;
       if (success) {
         cache().statsCounter().recordLoadSuccess(loadTime);
       } else {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -262,7 +262,7 @@ public void exceedsMaximumBufferSize_onRead(Cache<Integer, Integer> cache) {
     }
     assertThat(buffer.offer(dummy), is(Buffer.FULL));
 
-    localCache.afterRead(dummy, true);
+    localCache.afterRead(dummy, 0, true);
     assertThat(buffer.offer(dummy), is(not(Buffer.FULL)));
   }
 
@@ -274,7 +274,7 @@ public void exceedsMaximumBufferSize_onWrite(Cache<Integer, Integer> cache) {
     Node<Integer, Integer> dummy = localCache.nodeFactory.newNode(null, null, null, 1, 0);
 
     boolean[] ran = new boolean[1];
-    localCache.afterWrite(dummy, () -> ran[0] = true);
+    localCache.afterWrite(dummy, () -> ran[0] = true, 0);
     assertThat(ran[0], is(true));
 
     assertThat(localCache.writeQueue(), hasSize(0));

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/CaffeineTest.java
Patch:
@@ -399,7 +399,7 @@ public void ticker_twice() {
   public void ticker() {
     Ticker ticker = new FakeTicker();
     Caffeine<?, ?> builder = Caffeine.newBuilder().ticker(ticker);
-    assertThat(builder.getTicker(), is(ticker));
+    assertThat(builder.ticker, is(ticker));
     builder.build();
   }
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -812,8 +812,9 @@ void removeNode(Node<K, V> node) {
       if (hasRemovalListener()) {
         notifyRemoval(key, value, cause);
       }
-      makeDead(node);
     }
+
+    makeDead(node);
   }
 
   @Override

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LoadingCache.java
Patch:
@@ -99,8 +99,7 @@ public interface LoadingCache<K, V> extends Cache<K, V> {
    * <p>
    * Caches loaded by a {@link CacheLoader} will call {@link CacheLoader#reload} if the cache
    * currently contains a value for {@code key}, and {@link CacheLoader#load} otherwise. Loading is
-   * asynchronous only if {@link CacheLoader#reload} was overridden with an asynchronous
-   * implementation.
+   * asynchronous by delegating to the default executor.
    *
    * @param key key with which a value may be associated
    * @throws NullPointerException if the specified key is null

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/NodeFactoryGenerator.java
Patch:
@@ -90,7 +90,7 @@ public NodeFactoryGenerator(Path directory) {
   void generate() throws IOException {
     nodeFactory = TypeSpec.enumBuilder("NodeFactory")
         .addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)
-            .addMember("value", "$S", "unchecked")
+            .addMember("value", "{$S, $S}", "unchecked", "GuardedByChecker")
             .build());
     addClassJavaDoc();
     addNodeStateStatics();

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -552,6 +552,7 @@ void maintenance() {
   }
 
   /** Drains the weak key references queue. */
+  @GuardedBy("evictionLock")
   void drainKeyReferences() {
     if (!collectKeys()) {
       return;
@@ -566,6 +567,7 @@ void drainKeyReferences() {
   }
 
   /** Drains the weak / soft value references queue. */
+  @GuardedBy("evictionLock")
   void drainValueReferences() {
     if (!collectValues()) {
       return;
@@ -588,7 +590,6 @@ void drainReadBuffer() {
   }
 
   /** Updates the node's location in the page replacement policy. */
-  @GuardedBy("evictionLock")
   static <K, V> void reorder(LinkedDeque<Node<K, V>> deque, Node<K, V> node) {
     // An entry may be scheduled for reordering despite having been removed. This can occur when the
     // entry was concurrently read while a writer was removing it. If the entry is no longer linked

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Node.java
Patch:
@@ -31,6 +31,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings({"GuardedByChecker", "GuardedByValidator"})
 interface Node<K, V> extends AccessOrder<Node<K, V>>, WriteOrder<Node<K, V>> {
 
   /** Return the key or {@code null} if it has been reclaimed by the garbage collector. */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/MultiThreadedTest.java
Patch:
@@ -94,7 +94,7 @@ public void async_concurrent_bounded(
     Threads.runTest(cache, asyncOperations);
   }
 
-  @SuppressWarnings({"unchecked", "rawtypes"})
+  @SuppressWarnings({"unchecked", "rawtypes", "SizeGreaterThanOrEqualsZero"})
   List<BiConsumer<LoadingCache<Integer, Integer>, Integer>> operations = ImmutableList.of(
       // LoadingCache
       (cache, key) -> cache.get(key),

File: caffeine/src/test/java/com/github/benmanes/caffeine/locks/NonReentrantLockTest.java
Patch:
@@ -112,6 +112,7 @@ public void lock_error(NonReentrantLock lock) {
   }
 
   @Test(dataProvider = "lock")
+  @SuppressWarnings("WaitNotInLoop")
   public void condition(NonReentrantLock lock) {
     Condition condition = lock.newCondition();
     AtomicBoolean ready = new AtomicBoolean();

File: guava/src/test/java/com/google/common/cache/CacheTesting.java
Patch:
@@ -53,6 +53,7 @@
  *
  * @author mike nonemacher
  */
+@SuppressWarnings("GuardedByChecker")
 class CacheTesting {
 
   /**

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/StripedBuffer.java
Patch:
@@ -23,7 +23,7 @@
 /**
  * A base class providing the mechanics for supporting dynamic striping of bounded buffers. This
  * implementation is an adaption of the numeric 64-bit {@link java.util.concurrent.atomic.Striped64}
- * class, which is used to by atomic counters. The approach was modified to lazily grow an array of
+ * class, which is used by atomic counters. The approach was modified to lazily grow an array of
  * buffers in order to minimize memory usage for caches that are not heavily contended on.
  *
  * @author dl@cs.oswego.edu (Doug Lea)

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/Stresser.java
Patch:
@@ -99,8 +99,8 @@ public void run() {
         System.out.printf("Pending reads = %s%n", pendingReads);
         System.out.printf("Pending write = %s%n", pendingWrites);
         System.out.printf("Drain status = %s%n", local.drainStatus.get());
-        System.out.printf("Lock status = %s%n", local.evictionLock.isLocked());
         System.out.printf("Evictions = %,d%n", evictions.intValue());
+        System.out.printf("Lock = %s%n", local.evictionLock);
       }
     };
   }

File: guava/src/test/java/com/google/common/cache/CacheBuilderFactory.java
Patch:
@@ -30,6 +30,7 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.MoreExecutors;
 
 /**
  * Helper class for creating {@link CacheBuilder} instances with all combinations of several sets of
@@ -179,6 +180,7 @@ private Caffeine<Object, Object> createCacheBuilder(
     } else if (valueStrength == Strength.SOFT) {
       builder.softValues();
     }
+    builder.executor(MoreExecutors.directExecutor());
     return builder;
   }
 

File: guava/src/test/java/com/google/common/cache/CacheBuilderTest.java
Patch:
@@ -36,8 +36,6 @@
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import junit.framework.TestCase;
-
 import com.github.benmanes.caffeine.ConcurrentTestHarness;
 import com.github.benmanes.caffeine.cache.Caffeine;
 import com.github.benmanes.caffeine.cache.RemovalListener;
@@ -54,6 +52,8 @@
 import com.google.common.util.concurrent.MoreExecutors;
 import com.google.common.util.concurrent.Uninterruptibles;
 
+import junit.framework.TestCase;
+
 /**
  * Unit tests for Caffeine.
  */
@@ -145,6 +145,7 @@ public void testMaximumWeight_setTwice() {
   @GwtIncompatible("maximumWeight")
   public void testMaximumWeight_withoutWeigher() {
     Caffeine<Object, Object> builder = Caffeine.newBuilder()
+        .executor(MoreExecutors.directExecutor())
         .maximumWeight(1);
     try {
       CaffeinatedGuava.build(builder, identityLoader());

File: caffeine/src/test/java/com/github/benmanes/caffeine/ConcurrentLinkedLazyQueueTest.java
Patch:
@@ -526,7 +526,8 @@ public void manyProducers_oneConsumer(Queue<Integer> queue) {
     assertThat(queue, is(deeplyEmpty()));
   }
 
-  @Test(dataProvider = "empty")
+  // FIXME: Observed livelock as all threads stuck in fixup()
+  @Test(enabled = false, dataProvider = "empty")
   public void manyProducers_manyConsumers(Queue<Integer> queue) {
     AtomicInteger finished = new AtomicInteger();
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedBuffer.java
Patch:
@@ -23,8 +23,8 @@
 /**
  * A striped, non-blocking, bounded buffer.
  *
- * @param <E> the type of elements maintained by this buffer
  * @author ben.manes@gmail.com (Ben Manes)
+ * @param <E> the type of elements maintained by this buffer
  */
 final class BoundedBuffer<E> extends StripedBuffer<E> {
   /*

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/LogReader.java
Patch:
@@ -32,6 +32,7 @@
 import java.util.stream.StreamSupport;
 
 import com.github.benmanes.caffeine.cache.tracing.TraceEvent;
+import com.github.benmanes.caffeine.cache.tracing.TraceEventFormats;
 import com.univocity.parsers.csv.CsvFormat;
 import com.univocity.parsers.csv.CsvParser;
 import com.univocity.parsers.csv.CsvParserSettings;
@@ -102,7 +103,7 @@ public TraceEvent next() {
         throw new NoSuchElementException();
       }
       try {
-        return TraceEvent.fromBinaryRecord(input);
+        return TraceEventFormats.readBinaryRecord(input);
       } catch (IOException e) {
         throw new UncheckedIOException(e);
       }
@@ -136,7 +137,7 @@ public boolean hasNext() {
         parser.stopParsing();
         return false;
       }
-      next = TraceEvent.fromTextRecord(record);
+      next = TraceEventFormats.readTextRecord(record);
       return true;
     }
 

File: tracing/async/src/main/java/com/github/benmanes/caffeine/cache/tracing/async/BinaryLogEventHandler.java
Patch:
@@ -25,6 +25,7 @@
 import javax.annotation.concurrent.ThreadSafe;
 
 import com.github.benmanes.caffeine.cache.tracing.TraceEvent;
+import com.github.benmanes.caffeine.cache.tracing.TraceEventFormats;
 
 /**
  * A handler that records events to a log file in the binary format.
@@ -45,7 +46,7 @@ public BinaryLogEventHandler(Path filePath) {
 
   @Override
   public void onEvent(TraceEvent event, long sequence, boolean endOfBatch) throws IOException {
-    event.appendBinaryRecord(output);
+    TraceEventFormats.writeBinaryRecord(event, output);
     if (endOfBatch) {
       output.flush();
     }

File: tracing/async/src/main/java/com/github/benmanes/caffeine/cache/tracing/async/TextLogEventHandler.java
Patch:
@@ -24,6 +24,7 @@
 import javax.annotation.concurrent.ThreadSafe;
 
 import com.github.benmanes.caffeine.cache.tracing.TraceEvent;
+import com.github.benmanes.caffeine.cache.tracing.TraceEventFormats;
 
 /**
  * A handler that records events to a log file in the plain text format.
@@ -44,7 +45,7 @@ public TextLogEventHandler(Path filePath) {
 
   @Override
   public void onEvent(TraceEvent event, long sequence, boolean endOfBatch) throws IOException {
-    event.appendTextRecord(writer);
+    TraceEventFormats.writeTextRecord(event, writer);
     writer.write(System.lineSeparator());
     if (endOfBatch) {
       writer.flush();

File: guava/src/test/java/com/github/benmanes/caffeine/PackageSanityTests.java
Patch:
@@ -31,6 +31,7 @@ public PackageSanityTests() {
         clazz == Awaits.class ||
         clazz == SingleConsumerQueue.class ||
         clazz == ConcurrentLinkedStack.class ||
+        clazz == ConcurrentLinkedLazyQueue.class ||
         clazz.getSimpleName().startsWith("Is") ||
         clazz.getSimpleName().contains("Test") ||
         clazz.getSimpleName().contains("Stresser") ||

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/ReadBufferBenchmark.java
Patch:
@@ -23,7 +23,7 @@
 import org.openjdk.jmh.annotations.Setup;
 import org.openjdk.jmh.annotations.State;
 
-import com.github.benmanes.caffeine.cache.buffer.Buffer;
+import com.github.benmanes.caffeine.cache.buffer.ReadBuffer;
 import com.github.benmanes.caffeine.cache.buffer.BufferType;
 
 /**
@@ -46,7 +46,7 @@
 public class ReadBufferBenchmark {
 
   @Param BufferType bufferType;
-  Buffer buffer;
+  ReadBuffer buffer;
 
   @Setup
   public void setup() {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidBoundedLocalCache.java
Patch:
@@ -72,7 +72,7 @@ private void checkReadBuffer(BoundedLocalCache<K, V> cache) {
     if (!cache.evicts() && !cache.expiresAfterAccess()) {
       return;
     }
-    BoundedBuffer<?> buffer = cache.readBuffer;
+    Buffer<?> buffer = cache.readBuffer;
     desc.expectThat("buffer is empty", buffer.size(), is(0));
     desc.expectThat("buffer reads = writes", buffer.reads(), is(buffer.writes()));
   }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/BufferType.java
Patch:
@@ -30,14 +30,14 @@ public enum BufferType {
   MpmcArray(MpmcArrayBuffer::new),
   MpscCompound(MpscCompoundBuffer::new);
 
-  private final Supplier<Buffer> factory;
+  private final Supplier<ReadBuffer> factory;
 
-  private BufferType(Supplier<Buffer> factory) {
+  private BufferType(Supplier<ReadBuffer> factory) {
     this.factory = factory;
   }
 
   /** Returns a new buffer instance. */
-  public Buffer create() {
+  public ReadBuffer create() {
     return factory.get();
   }
 }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/FastFlowBuffer.java
Patch:
@@ -33,7 +33,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-final class FastFlowBuffer implements Buffer {
+final class FastFlowBuffer implements ReadBuffer {
   final Lock evictionLock;
 
   final AtomicLong readCache;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/ManyToOneBuffer.java
Patch:
@@ -29,7 +29,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-final class ManyToOneBuffer implements Buffer {
+final class ManyToOneBuffer implements ReadBuffer {
   final Lock evictionLock;
   final AtomicLong readCounter;
   final AtomicLong writeCounter;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/MpmcArrayBuffer.java
Patch:
@@ -24,7 +24,7 @@
 /**
  * @author ben.manes@gmail.com (Ben Manes)
  */
-final class MpmcArrayBuffer implements Buffer {
+final class MpmcArrayBuffer implements ReadBuffer {
   final MpmcArrayQueue<Boolean> queue;
   final Lock evictionLock;
   long drained;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/MpscArrayBuffer.java
Patch:
@@ -24,7 +24,7 @@
 /**
  * @author ben.manes@gmail.com (Ben Manes)
  */
-final class MpscArrayBuffer implements Buffer {
+final class MpscArrayBuffer implements ReadBuffer {
   final MpscArrayQueue<Boolean> queue;
   final Lock evictionLock;
   long drained;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/MpscCompoundBuffer.java
Patch:
@@ -24,7 +24,7 @@
 /**
  * @author ben.manes@gmail.com (Ben Manes)
  */
-final class MpscCompoundBuffer implements Buffer {
+final class MpscCompoundBuffer implements ReadBuffer {
   final MpscCompoundQueue<Boolean> queue;
   final Lock evictionLock;
   long drained;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/ReadBuffer.java
Patch:
@@ -21,7 +21,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public interface Buffer {
+public interface ReadBuffer {
   static final int MAX_SIZE = 32; // power of 2
   static final int MAX_SIZE_MASK = MAX_SIZE - 1;
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/TicketBuffer.java
Patch:
@@ -33,7 +33,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-final class TicketBuffer implements Buffer {
+final class TicketBuffer implements ReadBuffer {
   final Lock evictionLock;
   final AtomicLong writeCounter;
   final AtomicReference<Object>[] buffer;

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/profiler/CacheProfiler.java
Patch:
@@ -38,7 +38,7 @@ public final class CacheProfiler extends ProfilerHook {
   CacheProfiler() {
     System.setProperty(Tracer.TRACING_ENABLED, "false");
     map = type.create(MAX_SIZE, NUM_THREADS);
-    reads = false;
+    reads = true;
   }
 
   @Override

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedBuffer.java
Patch:
@@ -97,7 +97,7 @@ public BoundedBuffer() {
    * threads insert concurrently.
    *
    * @param e the element to add
-   * @return {@code true} if the element was or could have been added to; {@code false} if full
+   * @return {@code true} if the element was or could have been added; {@code false} if full
    */
   public boolean submit(E e) {
     final int segmentIndex = segmentIndex();

File: guava/src/test/java/com/google/common/cache/CacheLoadingTest.java
Patch:
@@ -2082,7 +2082,7 @@ public String load(String key) {
     };
 
     final LoadingCache<String, String> cache = CaffeinatedGuava.build(
-        Caffeine.newBuilder(), computeFunction);
+        Caffeine.newBuilder().executor(MoreExecutors.directExecutor()), computeFunction);
     ConcurrentMap<String,String> map = cache.asMap();
     map.put(refreshKey, refreshKey);
     assertEquals(1, map.size());

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/CacheFactory.java
Patch:
@@ -18,6 +18,7 @@
 import static java.util.Objects.requireNonNull;
 
 import java.util.Optional;
+import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.TimeUnit;
 
 import javax.annotation.Nullable;
@@ -113,9 +114,9 @@ private final class Builder<K, V> {
       this.cacheName = cacheName;
       this.ticker = Ticker.systemTicker();
       this.caffeine = Caffeine.newBuilder();
-      this.dispatcher = new EventDispatcher<>();
       this.statistics = new JCacheStatisticsMXBean();
       this.expiry = config.getExpiryPolicyFactory().create();
+      this.dispatcher = new EventDispatcher<>(ForkJoinPool.commonPool());
 
       caffeine.name(cacheName::toString);
       if (config.getCacheLoaderFactory() != null) {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/event/EventTypeAwareListener.java
Patch:
@@ -49,23 +49,23 @@ public void onCreated(Iterable<CacheEntryEvent<? extends K, ? extends V>> events
   @Override
   @SuppressWarnings("unchecked")
   public void onUpdated(Iterable<CacheEntryEvent<? extends K, ? extends V>> events) {
-    if (listener instanceof CacheEntryCreatedListener<?, ?>) {
+    if (listener instanceof CacheEntryUpdatedListener<?, ?>) {
       ((CacheEntryUpdatedListener<K, V>) listener).onUpdated(events);
     }
   }
 
   @Override
   @SuppressWarnings("unchecked")
   public void onRemoved(Iterable<CacheEntryEvent<? extends K, ? extends V>> events) {
-    if (listener instanceof CacheEntryCreatedListener<?, ?>) {
+    if (listener instanceof CacheEntryRemovedListener<?, ?>) {
       ((CacheEntryRemovedListener<K, V>) listener).onRemoved(events);
     }
   }
 
   @Override
   @SuppressWarnings("unchecked")
   public void onExpired(Iterable<CacheEntryEvent<? extends K, ? extends V>> events) {
-    if (listener instanceof CacheEntryCreatedListener<?, ?>) {
+    if (listener instanceof CacheEntryExpiredListener<?, ?>) {
       ((CacheEntryExpiredListener<K, V>) listener).onExpired(events);
     }
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncLoadingCache.java
Patch:
@@ -26,8 +26,8 @@
 import javax.annotation.concurrent.ThreadSafe;
 
 /**
- * A semi-persistent mapping from keys to values. Values are automatically loaded by the cache,
- * and are stored in the cache until either evicted or manually invalidated.
+ * A semi-persistent mapping from keys to values. Values are automatically loaded by the cache
+ * asynchronously, and are stored in the cache until either evicted or manually invalidated.
  * <p>
  * Implementations of this interface are expected to be thread-safe, and can be safely accessed
  * by multiple concurrent threads.

File: caffeine/src/javaPoet/java/com/github/benmanes/caffeine/cache/CacheSelectorCode.java
Patch:
@@ -108,8 +108,8 @@ private CacheSelectorCode selector(Set<String> classNames) {
       switchBuilder.addStatement(
           "case $S: return new $N<>(builder, cacheLoader, async)", className, className);
     }
+    switchBuilder.addStatement("default: throw new $T(sb.toString())", IllegalStateException.class);
     switchBuilder.endControlFlow();
-    switchBuilder.addStatement("throw new $T()", IllegalStateException.class);
     name.add(switchBuilder.build());
     return this;
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -139,8 +139,8 @@ enum Strength { STRONG, WEAK, SOFT }
   long expireAfterAccessNanos = UNSET_INT;
 
   RemovalListener<? super K, ? super V> removalListener;
-  Weigher<? super K, ? super V> weigher;
   Supplier<StatsCounter> statsCounterSupplier;
+  Weigher<? super K, ? super V> weigher;
   Supplier<String> nameSupplier;
   Executor executor;
   Ticker ticker;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsCacheReserializable.java
Patch:
@@ -209,8 +209,8 @@ private static <K, V> void checkBoundedLocalCache(BoundedLocalCache<K, V> origin
       BoundedLocalCache<K, V> copy, DescriptionBuilder desc) {
     desc.expectThat("empty", copy.estimatedSize(), is(0L));
     desc.expectThat("same weigher",
-        unwrapWeigher(copy.weigher()).getClass(), is(equalTo(
-        unwrapWeigher(original.weigher()).getClass())));
+        unwrapWeigher(copy.weigher).getClass(), is(equalTo(
+        unwrapWeigher(original.weigher).getClass())));
     desc.expectThat("same nodeFactory", copy.nodeFactory, is(original.nodeFactory));
     if (original.evicts()) {
       desc.expectThat("same maximumWeight", copy.maximum(), is(original.maximum()));

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidBoundedLocalCache.java
Patch:
@@ -146,7 +146,7 @@ private long scanLinks(BoundedLocalCache<K, V> cache, Set<Node<K, V>> seen,
   }
 
   private void checkNode(BoundedLocalCache<K, V> cache, Node<K, V> node, DescriptionBuilder desc) {
-    Weigher<? super K, ? super V> weigher = cache.weigher();
+    Weigher<? super K, ? super V> weigher = cache.weigher;
     V value = node.getValue();
     K key = node.getKey();
 

File: caffeine/src/main/java/com/github/benmanes/caffeine/SingleConsumerQueue.java
Patch:
@@ -57,7 +57,7 @@
  * java.util.ConcurrentModificationException}, and may proceed concurrently with other operations.
  * Elements contained in the queue since the creation of the iterator will be returned exactly once.
  * <p>
- * Beware that it is the responsibility of the caller to ensure that a consumer has exclusive
+ * Beware that it is the responsibility of the caller to ensure that a consumer has exclusive read
  * access to the queue. This implementation does <em>not</em> include fail-fast behavior to guard
  * against incorrect consumer usage.
  * <p>

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/buffer/BufferTest.java
Patch:
@@ -32,7 +32,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
-public final class ReadBufferTest {
+public final class BufferTest {
 
   @DataProvider
   public Iterator<Object[]> buffers() {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidBoundedLocalCache.java
Patch:
@@ -152,11 +152,14 @@ private void checkLinks(BoundedLocalCache<K, V> cache,
   private long scanLinks(BoundedLocalCache<K, V> cache, Set<Node<K, V>> seen,
       LinkedDeque<Node<K, V>> deque, DescriptionBuilder desc) {
     long weightedSize = 0;
+    Node<?, ?> prev = null;
     for (Node<K, V> node : deque) {
       Supplier<String> errorMsg = () -> String.format(
           "Loop detected: %s, saw %s in %s", node, seen, cache);
+      desc.expectThat("wrong previous", deque.getPrevious(node), is(prev));
       desc.expectThat(errorMsg, seen.add(node), is(true));
       weightedSize += node.getWeight();
+      prev = node;
     }
     return weightedSize;
   }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Cache.java
Patch:
@@ -45,10 +45,10 @@ public interface Cache<K, V> {
    * Returns the value associated with {@code key} in this cache, or {@code null} if there is no
    * cached value for {@code key}.
    *
-   * @param key the key whose associated value is to be returned
-   * @throws NullPointerException if the specified key is null
+   * @param key key whose associated value is to be returned
    * @return the value to which the specified key is mapped, or {@code null} if this map contains no
    *         mapping for the key
+   * @throws NullPointerException if the specified key is null
    */
   @CheckForNull
   V getIfPresent(@Nonnull Object key);

File: guava/src/test/java/com/github/benmanes/caffeine/EliminationStackTests.java
Patch:
@@ -40,7 +40,7 @@ public static Test suite() throws NoSuchMethodException, SecurityException {
               return new EliminationStack<>(MinimalCollection.of(elements)).asLifoQueue();
             }
           })
-        .named("EliminationStack")
+        .named(EliminationStack.class.getSimpleName())
         .withFeatures(
             CollectionFeature.GENERAL_PURPOSE,
             CollectionSize.ANY)

File: guava/src/test/java/com/github/benmanes/caffeine/SingleConsumerQueueTests.java
Patch:
@@ -40,7 +40,7 @@ public static Test suite() throws NoSuchMethodException, SecurityException {
               return new SingleConsumerQueue<>(MinimalCollection.of(elements));
             }
           })
-        .named("SingleConsumerQueue")
+        .named(SingleConsumerQueue.class.getSimpleName())
         .withFeatures(
             CollectionFeature.GENERAL_PURPOSE,
             CollectionFeature.KNOWN_ORDER,

File: guava/src/test/java/com/github/benmanes/caffeine/cache/MapTestFactory.java
Patch:
@@ -66,7 +66,6 @@ protected static Test suite(String name, Caffeine<Object, Object> builder)
             // Suppressed due to entrySet() view supporting additions, while the keySet() and
             // values() views do not. The Guava tests are unable to understand this rational.
             CollectionAddTester.class.getMethod("testAdd_unsupportedNotPresent"),
-            CollectionAddTester.class.getMethod("testAdd_supportedNotPresent"),
             CollectionAddAllTester.class.getMethod("testAddAll_unsupportedNonePresent"),
             CollectionAddAllTester.class.getMethod("testAddAll_unsupportedSomePresent"),
 

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/integration/JCacheLoaderAdapter.java
Patch:
@@ -76,11 +76,10 @@ public Expirable<V> load(K key) {
   @Override
   public Map<K, Expirable<V>> loadAll(Iterable<? extends K> keys) {
     try {
-      long expireTimeMS = expireTimeMS();
       Map<K, Expirable<V>> result = delegate.loadAll(keys).entrySet().stream()
           .filter(entry -> (entry.getKey() != null) && (entry.getValue() != null))
           .collect(Collectors.toMap(entry -> entry.getKey(),
-              entry -> new Expirable<>(entry.getValue(), expireTimeMS)));
+              entry -> new Expirable<>(entry.getValue(), expireTimeMS())));
       for (Map.Entry<K, Expirable<V>> entry : result.entrySet()) {
         dispatcher.publishCreated(cache, entry.getKey(), entry.getValue().get());
       }

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/configuration/CaffeineConfiguration.java
Patch:
@@ -46,6 +46,8 @@ public CaffeineConfiguration(CompleteConfiguration<K, V> configuration) {
    * Retrieves the cache's settings from the configuration resource.
    *
    * @param config the configuration resource
+   * @param <K> the type of keys maintained the cache
+   * @param <V> the type of cached values
    * @return the configuration for the cache
    */
   public static <K, V> CaffeineConfiguration<K, V> from(Config config) {

File: jcache/src/main/java/com/github/benmanes/caffeine/jcache/copy/CopyStrategy.java
Patch:
@@ -33,6 +33,7 @@ public interface CopyStrategy {
    *
    * @param object the object to copy
    * @param classLoader the classloader to instantiate with
+   * @param <T> the type of object being copied
    * @return a copy of the object
    */
   @Nonnull

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -782,7 +782,7 @@ public void clear() {
     try {
       // Apply all pending writes
       Runnable task;
-      while ((task = writeQueue().poll()) != null) {
+      while (buffersWrites() && (task = writeQueue().poll()) != null) {
         task.run();
       }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidBoundedLocalCache.java
Patch:
@@ -62,7 +62,7 @@ protected boolean matchesSafely(BoundedLocalCache<K, V> cache, Description descr
   }
 
   private void drain(BoundedLocalCache<K, V> cache) {
-    while (!cache.writeQueue().isEmpty()) {
+    while (cache.buffersWrites() && !cache.writeQueue().isEmpty()) {
       cache.cleanUp();
     }
 
@@ -74,7 +74,7 @@ private void drain(BoundedLocalCache<K, V> cache) {
       for (;;) {
         cache.drainBuffers();
 
-        boolean fullyDrained = cache.writeQueue().isEmpty();
+        boolean fullyDrained = cache.buffersWrites() && cache.writeQueue().isEmpty();
         for (int j = 0; j < cache.replacement.readBuffers().length; j++) {
           fullyDrained &= (cache.replacement.readBuffers()[i][j].get() == null);
         }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/LocalAsyncLoadingCache.java
Patch:
@@ -123,7 +123,7 @@ public CompletableFuture<V> get(K key,
 
   @Override
   public CompletableFuture<V> get(K key) {
-    return get(key, (k, executor) -> loader.asyncLoad(key, executor));
+    return get(key, loader::asyncLoad);
   }
 
   @Override

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsyncLoadingCacheTest.java
Patch:
@@ -172,6 +172,8 @@ public void getFunc_absent_failure_async(AsyncLoadingCache<Integer, Integer> cac
 
     ready.set(true);
     Awaits.await().untilTrue(done);
+    Awaits.await().until(() -> valueFuture.getNumberOfDependents(), is(0));
+
     MoreExecutors.shutdownAndAwaitTermination(
         (ExecutorService) context.executor(), 1, TimeUnit.SECONDS);
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidBoundedLocalCache.java
Patch:
@@ -133,7 +133,8 @@ private void checkLinks(BoundedLocalCache<K, V> cache,
       seen.clear();
       weightedSize = scanLinks(cache, seen, deque, desc);
 
-      Supplier<String> errorMsg = () -> String.format("Size != list length; additional: ",
+      Supplier<String> errorMsg = () -> String.format(
+          "Size != list length; pending=%s, additional: ", cache.replacement.writeBuffer().size(),
           Sets.difference(seen, ImmutableSet.copyOf(cache.data.values())));
       desc.expectThat(errorMsg, cache.size(), is(seen.size()));
     }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContext.java
Patch:
@@ -296,6 +296,7 @@ public String toString() {
     return MoreObjects.toStringHelper(this)
         .add("population", population)
         .add("maximumSize", maximumSize)
+        .add("weigher", weigher)
         .add("afterAccess", afterAccess)
         .add("afterWrite", afterWrite)
         .add("refreshAfterWrite", refresh)

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/AsyncLoadingCacheTest.java
Patch:
@@ -133,7 +133,7 @@ public void getFunc_absent_null_async(AsyncLoadingCache<Integer, Integer> cache,
     ready.set(true);
     Awaits.await().untilTrue(done);
     MoreExecutors.shutdownAndAwaitTermination(
-        (ExecutorService) context.executor(), 1, TimeUnit.SECONDS);
+        (ExecutorService) context.executor(), 5, TimeUnit.SECONDS);
 
     assertThat(context, both(hasMissCount(1)).and(hasHitCount(0)));
     assertThat(context, both(hasLoadSuccessCount(0)).and(hasLoadFailureCount(1)));

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheSpec.java
Patch:
@@ -461,9 +461,9 @@ enum CacheExecutor implements Supplier<Executor> {
 
   /**
    * The number of entries to populate the cache with. The keys and values are integers starting
-   * from 0, with the value being the negated key. The cache will never be populated to exceed the
-   * maximum size, if defined, thereby ensuring that no evictions occur prior to the test. Each
-   * configuration results in a new combination.
+   * from above the integer cache limit, with the value being the negated key. The cache will never
+   * be populated to exceed the maximum size, if defined, thereby ensuring that no evictions occur
+   * prior to the test. Each configuration results in a new combination.
    */
   Population[] population() default {
     Population.EMPTY,

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/CacheLoader.java
Patch:
@@ -77,6 +77,7 @@ default Map<K, V> loadAll(@Nonnull Iterable<? extends K> keys) {
    * Asynchronously computes or retrieves the value corresponding to {@code key}.
    *
    * @param key the non-null key whose value should be loaded
+   * @param executor the executor that asynchronously loads the entry
    * @return the future value associated with {@code key}
    */
   @Nonnull
@@ -100,6 +101,7 @@ default CompletableFuture<V> asyncLoad(@Nonnull K key, @Nonnull Executor executo
    * to {@link AsyncLoadingCache#get} if this method is not overridden.
    *
    * @param keys the unique, non-null keys whose values should be loaded
+   * @param executor the executor that with asynchronously loads the entries
    * @return a future containing the map from each key in {@code keys} to the value associated with
    *         that key; <b>may not contain null values</b>
    * @throws UnsupportedOperationException if bulk loading is not implemented

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/RemovalListener.java
Patch:
@@ -42,6 +42,8 @@ public interface RemovalListener<K, V> {
    * <p>
    * This does not always signify that the key is now absent from the cache, as it may have already
    * been re-added.
+   *
+   * @param notification information regarding the removed entry
    */
   void onRemoval(@Nonnull RemovalNotification<K, V> notification);
 }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/StatsCounter.java
Patch:
@@ -79,6 +79,8 @@ public interface StatsCounter {
   /**
    * Returns a snapshot of this counter's values. Note that this may be an inconsistent view, as it
    * may be interleaved with update operations.
+   *
+   * @return a snapshot of this counter's values
    */
   @Nonnull
   CacheStats snapshot();

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuava.java
Patch:
@@ -39,7 +39,7 @@ private CaffeinatedGuava() {}
    * @param builder the configured cache builder
    * @return a cache exposed under the Guava APIs
    */
-  public static <K1 extends K, K, V1 extends V, V>Cache<K1, V1> build(Caffeine<K, V> builder) {
+  public static <K1 extends K, K, V1 extends V, V> Cache<K1, V1> build(Caffeine<K, V> builder) {
     return new CaffeinatedGuavaCache<K1, V1>(builder.build());
   }
 

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaLoadingCache.java
Patch:
@@ -37,6 +37,7 @@
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */
+@SuppressWarnings("deprecation")
 final class CaffeinatedGuavaLoadingCache<K, V> extends CaffeinatedGuavaCache<K, V>
     implements LoadingCache<K, V> {
   static final ThreadLocal<Boolean> nullBulkLoad = ThreadLocal.withInitial(() -> Boolean.FALSE);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/Synthetic.java
Patch:
@@ -146,7 +146,7 @@ public static Stream<CacheEvent> zipfian(int items) {
    * @param lowerBound lower bound of the distribution
    * @param upperBound upper bound of the distribution
    * @param items the number of items in the distribution
-   * @return
+   * @return a stream of cache events
    */
   public static Stream<CacheEvent> uniform(int lowerBound, int upperBound, int items) {
     return generate(new UniformIntegerGenerator(lowerBound, upperBound), items);

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/generator/ExponentialGenerator.java
Patch:
@@ -62,7 +62,7 @@ public ExponentialGenerator(double percentile, double range)
 	/**
 	 * Generate the next item. this distribution will be skewed toward lower integers; e.g. 0 will
 	 * be the most popular, 1 the next most popular, etc.
-	 * @param itemcount The number of items in the distribution.
+	 *
 	 * @return The next item in the sequence.
 	 */
 	@Override
@@ -74,7 +74,6 @@ public int nextInt()
 	/**
 	 * Generate the next item as a long.
 	 *
-	 * @param itemcount The number of items in the distribution.
 	 * @return The next item in the sequence.
 	 */
 	public long nextLong()

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/generator/ZipfianGenerator.java
Patch:
@@ -312,11 +312,9 @@ public static void main(String[] args)
 		new ZipfianGenerator(ScrambledZipfianGenerator.ITEM_COUNT);
 	}
 
-	/**
-	 * @todo Implement ZipfianGenerator.mean()
-	 */
 	@Override
 	public double mean() {
+	  // TODO Implement ZipfianGenerator.mean()
 		throw new UnsupportedOperationException("@todo implement ZipfianGenerator.mean()");
 	}
 }

File: simulator/src/main/java/com/github/benmanes/caffeine/cache/simulator/parser/LogReader.java
Patch:
@@ -48,7 +48,7 @@ private LogReader() {}
   /**
    * Creates a {@link Stream} that lazily reads the log file in the binary format.
    *
-   * @param reader the input source to read the log file
+   * @param filePath the path to the log file
    * @return a lazy stream of cache events
    */
   public static Stream<CacheEvent> binaryLogStream(Path filePath) throws IOException {
@@ -62,7 +62,7 @@ public static Stream<CacheEvent> binaryLogStream(Path filePath) throws IOExcepti
   /**
    * Creates a {@link Stream} that lazily reads the log file in the text format.
    *
-   * @param reader the input source to read the log file
+   * @param filePath the path to the log file
    * @return a lazy stream of cache events
    */
   public static Stream<CacheEvent> textLogStream(Path filePath) throws IOException {

File: tracing/api/src/main/java/com/github/benmanes/caffeine/cache/tracing/Tracer.java
Patch:
@@ -34,7 +34,7 @@ public interface Tracer {
 
   void recordDelete(@Nonnull Object o);
 
-  /** Returns a tracer implementation that does not record any events. */
+  /** @return a tracer implementation that does not record any events. */
   public static Tracer disabled() {
     return DisabledTracer.INSTANCE;
   }
@@ -43,6 +43,8 @@ public static Tracer disabled() {
    * Returns the tracer implementation loaded from a {@link ServiceLoader} or a disabled instance
    * if either not found or the system property <tt>caffeine.tracing.enabled</tt> is set to
    * <tt>false</tt>.
+   *
+   * @return the tracer implementation that was loaded or a disabled instance otherwise
    */
   public static Tracer getDefault() {
     return TracerHolder.INSTANCE;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/EvictionTest.java
Patch:
@@ -71,7 +71,8 @@ public final class EvictionTest {
   @CacheSpec(population = Population.FULL, maximumSize = MaximumSize.FULL,
       removalListener = Listener.REJECTING)
   public void removalListener_fails(Cache<Integer, Integer> cache, CacheContext context) {
-    RejectingRemovalListener<Integer, Integer> removalListener = context.removalListener();
+    RejectingRemovalListener<Integer, Integer> removalListener =
+        (RejectingRemovalListener<Integer, Integer>) context.removalListener();
     // Guava-style caches reject before the max size is reached & are unpredictable
     removalListener.rejected = 0;
     long size = cache.estimatedSize();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContext.java
Patch:
@@ -245,9 +245,8 @@ public Listener removalListenerType() {
     return removalListenerType;
   }
 
-  @SuppressWarnings("unchecked")
-  public <T extends RemovalListener<Integer, Integer>> T removalListener() {
-    return (T) requireNonNull(removalListener);
+  public RemovalListener<Integer, Integer> removalListener() {
+    return requireNonNull(removalListener);
   }
 
   public List<RemovalNotification<Integer, Integer>> consumedNotifications() {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaLocalCache.java
Patch:
@@ -62,6 +62,7 @@ public final class GuavaLocalCache {
   private GuavaLocalCache() {}
 
   /** Returns a Guava-backed cache. */
+  @SuppressWarnings("CheckReturnValue")
   public static <K, V> Cache<K, V> newGuavaCache(CacheContext context) {
     CacheBuilder<Object, Object> builder = CacheBuilder.newBuilder();
     if (context.initialCapacity != InitialCapacity.DEFAULT) {
@@ -104,7 +105,7 @@ public static <K, V> Cache<K, V> newGuavaCache(CacheContext context) {
       boolean translateZeroExpire = (context.afterAccess == Expire.IMMEDIATELY) ||
           (context.afterWrite == Expire.IMMEDIATELY);
       builder.removalListener(new GuavaRemovalListener<>(
-          translateZeroExpire, context.removalListener()));
+          translateZeroExpire, context.removalListener));
     }
     Ticker ticker = (context.ticker == null) ? Ticker.systemTicker() : context.ticker;
     if (context.loader == null) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -426,7 +426,7 @@ void expire() {
       long expirationTime = now - expireAfterAccessNanos;
       for (;;) {
         final Node<K, V> node = accessOrderDeque.peekFirst();
-        if ((node == null) || (node.getAccessTime() >= expirationTime)) {
+        if ((node == null) || (node.getAccessTime() > expirationTime)) {
           break;
         }
         accessOrderDeque.pollFirst();
@@ -438,7 +438,7 @@ void expire() {
       long expirationTime = now - expireAfterWriteNanos;
       for (;;) {
         final Node<K, V> node = writeOrderDeque.peekFirst();
-        if ((node == null) || (node.getWriteTime() >= expirationTime)) {
+        if ((node == null) || (node.getWriteTime() > expirationTime)) {
           break;
         }
         writeOrderDeque.pollFirst();

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -124,7 +124,7 @@ static void checkStatus(BoundedLocalCache<Integer, Integer> localCache,
     assertThat(node.isDead(), is(expected == Status.DEAD));
 
     if (node.isDead()) {
-      localCache.makeRetired(node);
+      node.makeRetired();
       assertThat(node.isRetired(), is(false));
     }
   }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContext.java
Patch:
@@ -113,7 +113,7 @@ public CacheContext(InitialCapacity initialCapacity, Stats stats, CacheWeigher w
     this.removalListener = removalListenerType.create();
     this.population = requireNonNull(population);
     this.loader = isLoading ? requireNonNull(loader) : null;
-    this.ticker = expires() ? new FakeTicker() : null;
+    this.ticker = new FakeTicker();
     this.implementation = requireNonNull(implementation);
     this.original = new LinkedHashMap<>();
     this.initialSize = -1;
@@ -274,7 +274,7 @@ public Expire expireAfterWrite() {
   }
 
   public FakeTicker ticker() {
-    return requireNonNull(ticker);
+    return ticker;
   }
 
   public Implementation implementation() {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/CacheFromContext.java
Patch:
@@ -83,7 +83,7 @@ private static <K, V> Cache<K, V> newCaffeineCache(CacheContext context) {
     if (context.refresh != Expire.DISABLED) {
       builder.refreshAfterWrite(context.refresh.timeNanos(), TimeUnit.NANOSECONDS);
     }
-    if (context.expires()) {
+    if (context.expires() || context.refreshes()) {
       builder.ticker(context.ticker());
     }
     if (context.keyStrength == ReferenceType.WEAK) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/testing/GuavaLocalCache.java
Patch:
@@ -87,7 +87,7 @@ public static <K, V> Cache<K, V> newGuavaCache(CacheContext context) {
     if (context.refresh != Expire.DISABLED) {
       builder.refreshAfterWrite(context.refresh.timeNanos(), TimeUnit.NANOSECONDS);
     }
-    if (context.expires()) {
+    if (context.expires() || context.refreshes()) {
       builder.ticker(context.ticker());
     }
     if (context.keyStrength == ReferenceType.WEAK) {

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsCacheReserializable.java
Patch:
@@ -212,9 +212,7 @@ private static <K, V> void checkBoundedLocalCache(BoundedLocalCache<K, V> origin
     desc.expectThat("same weigher",
         unwrapWeigher(copy.weigher).getClass(), is(equalTo(
         unwrapWeigher(original.weigher).getClass())));
-    desc.expectThat("same keyStrategy", copy.keyStrategy, is(original.keyStrategy));
-    desc.expectThat("same valueStrategy",
-        copy.valueStrategy, is(original.valueStrategy));
+    desc.expectThat("same nodeFactory", copy.nodeFactory, is(original.nodeFactory));
     if (copy.maximumWeightedSize == null) {
       desc.expectThat("null maximumWeight", copy.maximumWeightedSize, is(nullValue()));
     } else {

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/SlotLookupBenchmark.java
Patch:
@@ -27,6 +27,8 @@
 import org.openjdk.jmh.annotations.Setup;
 import org.openjdk.jmh.annotations.State;
 
+import com.github.benmanes.caffeine.base.UnsafeAccess;
+
 /**
  * A comparison of different lookup approaches for indexes for a slot in a fixed-sized shared array.
  * This approach is used for elimination (threads backoff and rendezvous) and striping (reduced

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/SynchronizedBenchmark.java
Patch:
@@ -25,6 +25,7 @@
 import org.openjdk.jmh.annotations.State;
 import org.openjdk.jmh.annotations.Threads;
 
+import com.github.benmanes.caffeine.base.UnsafeAccess;
 import com.github.benmanes.caffeine.locks.NonReentrantLock;
 
 /**

File: caffeine/src/jmh/java/com/github/benmanes/caffeine/cache/map/ConcurrentHashMapV7.java
Patch:
@@ -53,7 +53,7 @@
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.concurrent.locks.ReentrantLock;
 
-import com.github.benmanes.caffeine.UnsafeAccess;
+import com.github.benmanes.caffeine.base.UnsafeAccess;
 
 /**
  * A hash table supporting full concurrency of retrievals and

File: caffeine/src/main/java/com/github/benmanes/caffeine/SingleConsumerQueue.java
Patch:
@@ -28,6 +28,8 @@
 
 import javax.annotation.Nullable;
 
+import com.github.benmanes.caffeine.base.UnsafeAccess;
+
 /**
  * A lock-free unbounded queue based on linked nodes that supports concurrent producers and is
  * restricted to a single consumer. This queue orders elements FIFO (first-in-first-out). The

File: caffeine/src/main/java/com/github/benmanes/caffeine/base/UnsafeAccess.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.github.benmanes.caffeine;
+package com.github.benmanes.caffeine.base;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AbstractLinkedDeque.java
Patch:
@@ -43,14 +43,14 @@ abstract class AbstractLinkedDeque<E> extends AbstractCollection<E> implements L
    * Invariant: (first == null && last == null) ||
    *            (first.prev == null)
    */
-  protected E first;
+  E first;
 
   /**
    * Pointer to last node.
    * Invariant: (first == null && last == null) ||
    *            (last.next == null)
    */
-  protected E last;
+  E last;
 
   /**
    * Links the element to the front of the deque so that it becomes the first element.

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Policy.java
Patch:
@@ -17,6 +17,7 @@
 
 import java.util.Map;
 import java.util.Optional;
+import java.util.OptionalLong;
 import java.util.concurrent.TimeUnit;
 
 import javax.annotation.Nonnegative;
@@ -89,7 +90,7 @@ interface Eviction<K, V> {
      * @return the combined weight of the values in this cache
      */
     @Nonnull
-    Optional<Long> weightedSize();
+    OptionalLong weightedSize();
 
     /**
      * Returns the maximum total weighted or unweighted size of this cache, depending on how the
@@ -165,7 +166,7 @@ interface Expiration<K, V> {
      * @return the age if the entry is present in the cache
      */
     @Nonnull
-    Optional<Long> ageOf(@Nonnull K key, @Nonnull TimeUnit unit);
+    OptionalLong ageOf(@Nonnull K key, @Nonnull TimeUnit unit);
 
     /**
      * Returns the fixed duration used to determine if an entry should be automatically removed due

File: caffeine/src/test/java/com/github/benmanes/caffeine/base/UnsafeAccessTest.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.github.benmanes.caffeine;
+package com.github.benmanes.caffeine.base;
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.Matchers.greaterThan;
@@ -22,6 +22,8 @@
 
 import org.testng.annotations.Test;
 
+import com.github.benmanes.caffeine.base.UnsafeAccess;
+
 /**
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterAccessTest.java
Patch:
@@ -231,9 +231,9 @@ public void setExpiresAfter_access(Cache<Integer, Integer> cache, CacheContext c
       population = { Population.SINGLETON, Population.PARTIAL, Population.FULL })
   public void ageOf_access(CacheContext context,
       @ExpireAfterAccess Expiration<Integer, Integer> expireAfterAccess) {
-    assertThat(expireAfterAccess.ageOf(context.firstKey(), TimeUnit.SECONDS).get(), is(0L));
+    assertThat(expireAfterAccess.ageOf(context.firstKey(), TimeUnit.SECONDS).getAsLong(), is(0L));
     context.ticker().advance(30, TimeUnit.SECONDS);
-    assertThat(expireAfterAccess.ageOf(context.firstKey(), TimeUnit.SECONDS).get(), is(30L));
+    assertThat(expireAfterAccess.ageOf(context.firstKey(), TimeUnit.SECONDS).getAsLong(), is(30L));
     context.ticker().advance(45, TimeUnit.SECONDS);
     Assert.assertFalse(expireAfterAccess.ageOf(context.firstKey(), TimeUnit.SECONDS).isPresent());
   }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterWriteTest.java
Patch:
@@ -218,9 +218,9 @@ public void setExpiresAfter_write(Cache<Integer, Integer> cache, CacheContext co
       population = { Population.SINGLETON, Population.PARTIAL, Population.FULL })
   public void ageOf_write(CacheContext context,
       @ExpireAfterWrite Expiration<Integer, Integer> expireAfterWrite) {
-    assertThat(expireAfterWrite.ageOf(context.firstKey(), TimeUnit.SECONDS).get(), is(0L));
+    assertThat(expireAfterWrite.ageOf(context.firstKey(), TimeUnit.SECONDS).getAsLong(), is(0L));
     context.ticker().advance(30, TimeUnit.SECONDS);
-    assertThat(expireAfterWrite.ageOf(context.firstKey(), TimeUnit.SECONDS).get(), is(30L));
+    assertThat(expireAfterWrite.ageOf(context.firstKey(), TimeUnit.SECONDS).getAsLong(), is(30L));
     context.ticker().advance(45, TimeUnit.SECONDS);
     assertThat(expireAfterWrite.ageOf(context.firstKey(), TimeUnit.SECONDS).isPresent(), is(false));
   }

File: guava/src/test/java/com/google/common/cache/CacheBuilderFactory.java
Patch:
@@ -91,7 +91,6 @@ CacheBuilderFactory withValueStrengths(Set<Strength> valueStrengths) {
   }
 
   Iterable<Caffeine<Object, Object>> buildAllPermutations() {
-    @SuppressWarnings("unchecked")
     Iterable<List<Object>> combinations = buildCartesianProduct(concurrencyLevels,
         initialCapacities, maximumSizes, expireAfterWrites, expireAfterAccesses, refreshes,
         keyStrengths, valueStrengths);

File: guava/src/test/java/com/google/common/cache/CacheBuilderGwtTest.java
Patch:
@@ -109,6 +109,7 @@ public void testSizeConstraint() {
     assertEquals(null, cache.getIfPresent(2));
   }
 
+  @SuppressWarnings("deprecation")
   public void testLoadingCache() throws ExecutionException {
     CacheLoader<Integer, Integer> loader = new CacheLoader<Integer, Integer>() {
       int i = 0;

File: guava/src/test/java/com/google/common/cache/CacheBuilderTest.java
Patch:
@@ -164,13 +164,13 @@ public void testWeigher_withoutMaximumWeight() {
   @GwtIncompatible("weigher")
   public void testWeigher_withMaximumSize() {
     try {
-      Caffeine<Object, Object> builder = Caffeine.newBuilder()
+      Caffeine.newBuilder()
           .weigher(constantWeigher(42))
           .maximumSize(1);
       fail();
     } catch (IllegalStateException expected) {}
     try {
-      Caffeine<Object, Object> builder = Caffeine.newBuilder()
+      Caffeine.newBuilder()
           .maximumSize(1)
           .weigher(constantWeigher(42));
       fail();

File: guava/src/test/java/com/google/common/cache/LocalLoadingCacheTest.java
Patch:
@@ -59,7 +59,7 @@ public Object load(Object from) {
         return new Object();
       }
     };
-    LoadingCache<Object, Object> cache = makeCache(createCacheBuilder(), loader);
+    makeCache(createCacheBuilder(), loader);
   }
 
   // null parameters test

File: guava/src/test/java/com/google/common/cache/PopulatedCachesTest.java
Patch:
@@ -58,6 +58,7 @@ public class PopulatedCachesTest extends TestCase {
   public void testSize_populated() {
     for (LoadingCache<Object, Object> cache : caches()) {
       // don't let the entries get GCed
+      @SuppressWarnings("unused")
       List<Entry<Object, Object>> warmed = warmUp(cache);
       assertEquals(WARMUP_SIZE, cache.size());
       assertMapSize(cache.asMap(), WARMUP_SIZE);
@@ -128,6 +129,7 @@ public void testPutIfAbsent_populated() {
   public void testPutAll_populated() {
     for (LoadingCache<Object, Object> cache : caches()) {
       // don't let the entries get GCed
+      @SuppressWarnings("unused")
       List<Entry<Object, Object>> warmed = warmUp(cache);
       Object newKey = new Object();
       Object newValue = new Object();
@@ -241,8 +243,6 @@ public void testValues_populated() {
     }
   }
 
-  @SuppressWarnings("unchecked") // generic array creation
-
   public void testEntrySet_populated() {
     for (LoadingCache<Object, Object> cache : caches()) {
       Set<Entry<Object, Object>> entries = cache.asMap().entrySet();

File: guava/src/test/java/com/google/common/cache/TestingCacheLoaders.java
Patch:
@@ -22,7 +22,7 @@
 
 import javax.annotation.Nullable;
 
-import com.github.benmanes.caffeine.UnsafeAccess;
+import com.github.benmanes.caffeine.base.UnsafeAccess;
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.annotations.GwtIncompatible;
 import com.google.common.collect.Maps;

File: guava/src/test/java/com/google/common/cache/TestingRemovalListeners.java
Patch:
@@ -58,6 +58,7 @@ static <K, V> CountingRemovalListener<K, V> countingRemovalListener() {
   @GwtIncompatible("ConcurrentLinkedQueue")
   static class QueuingRemovalListener<K, V>
       extends ConcurrentLinkedQueue<RemovalNotification<K, V>> implements RemovalListener<K, V> {
+    private static final long serialVersionUID = 1L;
 
     @Override
     public void onRemoval(RemovalNotification<K, V> notification) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/AsyncLoadingCache.java
Patch:
@@ -40,7 +40,7 @@ public interface AsyncLoadingCache<K, V> {
 
   /**
    * Returns the future associated with {@code key} in this cache, obtaining that value from
-   * {@link CacheLoader#asyncLoad} if necessary. This method provides a simple substitute for the
+   * {@code mappingFunction} if necessary. This method provides a simple substitute for the
    * conventional "if cached, return; otherwise create, cache and return" pattern.
    * <p>
    * If the specified key is not already associated with a value, attempts to compute its value
@@ -59,7 +59,7 @@ CompletableFuture<V> get(@Nonnull K key,
 
   /**
    * Returns the future associated with {@code key} in this cache, obtaining that value from
-   * {@link CacheLoader#asyncLoad} if necessary. This method provides a simple substitute for the
+   * {@code mappingFunction} if necessary. This method provides a simple substitute for the
    * conventional "if cached, return; otherwise create, cache and return" pattern.
    * <p>
    * If the specified key is not already associated with a value, attempts to compute its value

File: guava/src/test/java/com/google/common/cache/TestingCacheLoaders.java
Patch:
@@ -41,7 +41,7 @@ public class TestingCacheLoaders {
    * Returns a {@link CacheLoader} that implements a naive {@link CacheLoader#loadAll}, delegating
    * {@link CacheLoader#load} calls to {@code loader}.
    */
-  static <K, V> CacheLoader<K, V> bulkLoader(final CacheLoader<K, V> loader) {
+  public static <K, V> CacheLoader<K, V> bulkLoader(final CacheLoader<K, V> loader) {
     checkNotNull(loader);
     return new CacheLoader<K, V>() {
       @Override

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidBoundedLocalCache.java
Patch:
@@ -62,6 +62,8 @@ protected boolean matchesSafely(BoundedLocalCache<K, V> map, Description descrip
   }
 
   private void drain(BoundedLocalCache<K, V> map) {
+    map.cleanUp();
+
     if (!map.evicts() && !map.expiresAfterAccess()) {
       return;
     }

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/LoadingCacheTest.java
Patch:
@@ -64,9 +64,9 @@ public void get_null(LoadingCache<Integer, Integer> cache) {
   }
 
   @CacheSpec(loader = Loader.NULL)
-  @Test(enabled = false, dataProvider = "caches")
+  @Test(dataProvider = "caches")
   public void get_absent_null(LoadingCache<Integer, Integer> cache, CacheContext context) {
-    cache.get(context.absentKey());
+    assertThat(cache.get(context.absentKey()), is(nullValue()));
   }
 
   @CacheSpec(loader = Loader.EXCEPTIONAL)

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -113,7 +113,7 @@
  * {@linkplain #weakValues weakValues}, or {@linkplain #softValues softValues} perform periodic
  * maintenance.
  * <p>
- * The caches produced by {@code CacheBuilder} are serializable, and the deserialized caches
+ * The caches produced by {@code Caffeine} are serializable, and the deserialized caches
  * retain all the configuration properties of the original cache. Note that the serialized form does
  * <i>not</i> include cache contents, but only configuration.
  *

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -1166,6 +1166,7 @@ public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction
           if (hasRemovalListener()) {
             notifyRemoval(key, node.getValue(valueStrategy), RemovalCause.EXPIRED);
           }
+          statsCounter.recordEviction();
         }
       } else {
         afterRead(node, true);

File: guava/src/test/java/com/google/common/cache/CacheLoadingTest.java
Patch:
@@ -800,7 +800,7 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
     assertEquals(1, stats.loadExceptionCount());
     assertEquals(2, stats.hitCount());
 
-    ticker.advance(1, MILLISECONDS);
+    ticker.advance(2, MILLISECONDS);
     assertSame(one, cache.getUnchecked(key));
     stats = cache.stats();
     assertEquals(1, stats.missCount());
@@ -1081,7 +1081,7 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
     assertEquals(1, stats.loadExceptionCount());
     assertEquals(2, stats.hitCount());
 
-    ticker.advance(1, MILLISECONDS);
+    ticker.advance(2, MILLISECONDS);
     assertSame(one, cache.getUnchecked(key));
     stats = cache.stats();
     assertEquals(1, stats.missCount());
@@ -1680,7 +1680,7 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
     assertEquals(1, stats.loadExceptionCount());
     assertEquals(2, stats.hitCount());
 
-    ticker.advance(1, MILLISECONDS);
+    ticker.advance(2, MILLISECONDS);
     assertSame(one, cache.getUnchecked(key));
     stats = cache.stats();
     assertEquals(1, stats.missCount());

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -2607,7 +2607,7 @@ private void bulkLoad(List<K> keysToLoad, Map<K, V> result) {
             result.put(key, value);
           }
         }
-        success = true;
+        success = !loaded.isEmpty();
       } finally {
         long loadTime = cache.ticker.read() - startTime;
         if (success) {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/UnboundedLocalCache.java
Patch:
@@ -913,7 +913,7 @@ private void bulkLoad(List<K> keysToLoad, Map<K, V> result) {
             result.put(key, value);
           }
         }
-        success = true;
+        success = !loaded.isEmpty();
       } finally {
         long loadTime = cache.ticker.read() - startTime;
         if (success) {

File: guava/src/test/java/com/google/common/cache/CacheLoadingTest.java
Patch:
@@ -813,7 +813,7 @@ public ListenableFuture<Object> reload(Object key, Object oldValue) {
 
   public void testBulkLoadNull() throws ExecutionException {
     LoadingCache<Object, Object> cache = CaffeinatedGuava.build(Caffeine.newBuilder()
-        .recordStats(), bulkLoader(constantLoader(null)));
+        .recordStats().executor(MoreExecutors.directExecutor()), bulkLoader(constantLoader(null)));
     CacheStats stats = cache.stats();
     assertEquals(0, stats.missCount());
     assertEquals(0, stats.loadSuccessCount());

File: guava/src/test/java/com/google/common/cache/CacheBuilderGwtTest.java
Patch:
@@ -304,6 +304,7 @@ public void onRemoval(RemovalNotification<Integer, Integer> notification) {
 
     cache.invalidateAll();
 
+    CacheTesting.processPendingNotifications();
     assertEquals(2, stats[0]);
     assertEquals(2, stats[1]);
     assertEquals(4, stats[2]);

File: guava/src/test/java/com/google/common/cache/CacheBuilderTest.java
Patch:
@@ -320,7 +320,7 @@ public void testNullCache() {
     assertEquals(0, nullCache.size());
     Object key = new Object();
     assertSame(key, nullCache.getUnchecked(key));
-    CacheTesting.processPendingNotifications(nullCache);
+    CacheTesting.processPendingNotifications();
     assertEquals(1, listener.getCount());
     assertEquals(0, nullCache.size());
     CacheTesting.checkEmpty(nullCache.asMap());

File: guava/src/test/java/com/google/common/cache/CacheEvictionTest.java
Patch:
@@ -80,7 +80,7 @@ public void testEviction_maxSize() {
     }
 
     assertEquals(MAX_SIZE, cache.size());
-    CacheTesting.processPendingNotifications(cache);
+    CacheTesting.processPendingNotifications();
     assertEquals(MAX_SIZE, removalListener.getCount());
     CacheTesting.checkValidState(cache);
   }
@@ -98,7 +98,7 @@ public void testEviction_maxWeight() {
     }
 
     assertEquals(MAX_SIZE, cache.size());
-    CacheTesting.processPendingNotifications(cache);
+    CacheTesting.processPendingNotifications();
     assertEquals(MAX_SIZE, removalListener.getCount());
     CacheTesting.checkValidState(cache);
   }
@@ -112,7 +112,7 @@ public void testEviction_overflow() {
         .removalListener(removalListener), loader);
     cache.getUnchecked(objectWithHash(0));
     cache.getUnchecked(objectWithHash(0));
-    CacheTesting.processPendingNotifications(cache);
+    CacheTesting.processPendingNotifications();
     assertEquals(1, removalListener.getCount());
   }
 

File: guava/src/test/java/com/google/common/cache/CacheReferencesTest.java
Patch:
@@ -148,7 +148,7 @@ private void assertCleanup(LoadingCache<Integer, String> cache,
       } catch (OutOfMemoryError e) {}
     }
 
-    CacheTesting.processPendingNotifications(cache);
+    CacheTesting.processPendingNotifications();
     assertEquals(1, cache.size());
     assertEquals(1, removalListener.getCount());
   }

File: guava/src/test/java/com/google/common/cache/CacheTesting.java
Patch:
@@ -361,7 +361,7 @@ static int expirationQueueSize(Cache<?, ?> cache) {
     return Math.max(accessQueueSize(cache), writeQueueSize(cache));
   }
 
-  static void processPendingNotifications(Cache<?, ?> cache) {
+  static void processPendingNotifications() {
     ForkJoinPool.commonPool().awaitQuiescence(10, TimeUnit.SECONDS);
   }
 

File: guava/src/test/java/com/google/common/cache/NullCacheTest.java
Patch:
@@ -51,7 +51,7 @@ public void testGet() {
 
     Object key = new Object();
     assertSame(computed, cache.getUnchecked(key));
-    CacheTesting.processPendingNotifications(cache);
+    CacheTesting.processPendingNotifications();
     RemovalNotification<Object, Object> notification = listener.remove();
     assertSame(key, notification.getKey());
     assertSame(computed, notification.getValue());
@@ -69,7 +69,7 @@ public void testGet_expireAfterWrite() {
 
     Object key = new Object();
     assertSame(computed, cache.getUnchecked(key));
-    CacheTesting.processPendingNotifications(cache);
+    CacheTesting.processPendingNotifications();
     RemovalNotification<Object, Object> notification = listener.remove();
     assertSame(key, notification.getKey());
     assertSame(computed, notification.getValue());
@@ -87,7 +87,7 @@ public void testGet_expireAfterAccess() {
 
     Object key = new Object();
     assertSame(computed, cache.getUnchecked(key));
-    CacheTesting.processPendingNotifications(cache);
+    CacheTesting.processPendingNotifications();
     RemovalNotification<Object, Object> notification = listener.remove();
     assertSame(key, notification.getKey());
     assertSame(computed, notification.getValue());

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -878,7 +878,7 @@ public void clear() {
 
   @Override
   public boolean containsKey(Object key) {
-    Node<K, V> node = data.get(key);
+    Node<K, V> node = data.get(keyStrategy.getKeyRef(key));
     return (node != null) && (!hasExpired(node, ticker.read()));
   }
 

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/IsValidBoundedLocalCache.java
Patch:
@@ -132,13 +132,13 @@ private void checkLinks(BoundedLocalCache<K, V> map,
   private void checkNode(BoundedLocalCache<K, V> map, Node<K, V> node, DescriptionBuilder desc) {
     Weigher<? super K, ? super V> weigher = map.weigher;
     V value = node.getValue(map.valueStrategy);
-
     K key = node.getKey(map.keyStrategy);
+
     desc.expectThat("not null weighted value", node.get(), is(not(nullValue())));
     desc.expectThat("weight", node.get().weight, is(weigher.weigh(key, value)));
 
     if (map.collectKeys()) {
-      if (key != null) {
+      if ((key != null) && (value != null)) {
         desc.expectThat("inconsistent", map.containsKey(key), is(true));
       }
     } else {

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaCache.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.github.benmanes.caffeine;
+package com.github.benmanes.caffeine.guava;
 
 import static java.util.Objects.requireNonNull;
 

File: guava/src/main/java/com/github/benmanes/caffeine/guava/CaffeinatedGuavaLoadingCache.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.github.benmanes.caffeine;
+package com.github.benmanes.caffeine.guava;
 
 import static java.util.Objects.requireNonNull;
 

File: guava/src/test/java/com/google/common/cache/CacheReferencesTest.java
Patch:
@@ -22,8 +22,8 @@
 
 import junit.framework.TestCase;
 
-import com.github.benmanes.caffeine.CaffeinatedGuava;
 import com.github.benmanes.caffeine.cache.Caffeine;
+import com.github.benmanes.caffeine.guava.CaffeinatedGuava;
 import com.google.common.base.Function;
 import com.google.common.cache.LocalCache.Strength;
 import com.google.common.cache.TestingRemovalListeners.CountingRemovalListener;

File: guava/src/test/java/com/google/common/cache/EmptyCachesTest.java
Patch:
@@ -27,8 +27,8 @@
 
 import junit.framework.TestCase;
 
-import com.github.benmanes.caffeine.CaffeinatedGuava;
 import com.github.benmanes.caffeine.cache.Caffeine;
+import com.github.benmanes.caffeine.guava.CaffeinatedGuava;
 import com.google.common.base.Function;
 import com.google.common.cache.CacheBuilderFactory.DurationSpec;
 import com.google.common.cache.LocalCache.Strength;

File: guava/src/test/java/com/google/common/cache/PopulatedCachesTest.java
Patch:
@@ -29,8 +29,8 @@
 
 import junit.framework.TestCase;
 
-import com.github.benmanes.caffeine.CaffeinatedGuava;
 import com.github.benmanes.caffeine.cache.Caffeine;
+import com.github.benmanes.caffeine.guava.CaffeinatedGuava;
 import com.google.common.base.Function;
 import com.google.common.cache.CacheBuilderFactory.DurationSpec;
 import com.google.common.cache.LocalCache.Strength;

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterAccessTest.java
Patch:
@@ -78,7 +78,7 @@ public void getIfPresent(Cache<Integer, Integer> cache, CacheContext context) {
   @CacheSpec(expireAfterAccess = Expire.ONE_MINUTE,
       population = { Population.PARTIAL, Population.FULL })
   public void get(Cache<Integer, Integer> cache, CacheContext context) {
-    Function<Integer, Integer> mappingFunction = key -> -key;
+    Function<Integer, Integer> mappingFunction = key -> context.original().get(key);
     context.ticker().advance(30, TimeUnit.SECONDS);
     cache.get(context.firstKey(), mappingFunction);
     context.ticker().advance(45, TimeUnit.SECONDS);

File: caffeine/src/test/java/com/github/benmanes/caffeine/cache/ExpireAfterWriteTest.java
Patch:
@@ -68,7 +68,7 @@ public void getIfPresent(Cache<Integer, Integer> cache, CacheContext context) {
   @CacheSpec(expireAfterWrite = Expire.ONE_MINUTE,
       population = { Population.PARTIAL, Population.FULL })
   public void get(Cache<Integer, Integer> cache, CacheContext context) {
-    Function<Integer, Integer> mappingFunction = key -> -key;
+    Function<Integer, Integer> mappingFunction = key -> context.original().get(key);
     context.ticker().advance(30, TimeUnit.SECONDS);
     cache.get(context.firstKey(), mappingFunction);
     context.ticker().advance(45, TimeUnit.SECONDS);

File: caffeine/src/main/java/com/github/benmanes/caffeine/EliminationStack.java
Patch:
@@ -61,7 +61,7 @@
  * results if this collection is modified during traversal.
  *
  * @author ben.manes@gmail.com (Ben Manes)
- * @see https://github.com/ben-manes/caffeine
+ * @see <a href="https://github.com/ben-manes/caffeine">Caffeine</a>
  * @param <E> the type of elements held in this collection
  */
 @ThreadSafe

File: caffeine/src/main/java/com/github/benmanes/caffeine/SingleConsumerQueue.java
Patch:
@@ -63,7 +63,7 @@
  * results if this collection is modified during traversal.
  *
  * @author ben.manes@gmail.com (Ben Manes)
- * @see https://github.com/ben-manes/caffeine
+ * @see <a href="https://github.com/ben-manes/caffeine">Caffeine</a>
  * @param <E> the type of elements held in this collection
  */
 public final class SingleConsumerQueue<E> implements Queue<E>, Serializable {

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -2608,7 +2608,7 @@ public void refresh(K key) {
       requireNonNull(key);
       cache.executor.execute(() -> {
         try {
-          cache.compute(key, loader::refresh, false);
+          cache.compute(key, loader::reload, false);
         } catch (Throwable t) {
           logger.log(Level.WARNING, "Exception thrown during refresh", t);
         }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/UnboundedLocalCache.java
Patch:
@@ -929,7 +929,7 @@ public void refresh(K key) {
       requireNonNull(key);
       cache.executor.execute(() -> {
         try {
-          cache.compute(key, loader::refresh, false);
+          cache.compute(key, loader::reload, false);
         } catch (Throwable t) {
           logger.log(Level.WARNING, "Exception thrown during refresh", t);
         }

File: caffeine/src/main/java/com/github/benmanes/caffeine/cache/stats/CacheStats.java
Patch:
@@ -16,7 +16,6 @@
 package com.github.benmanes.caffeine.cache.stats;
 
 import java.util.Objects;
-import java.util.concurrent.Callable;
 
 import javax.annotation.Nonnegative;
 import javax.annotation.Nonnull;
@@ -52,8 +51,8 @@
  * </ul>
  * <p>
  * A lookup is specifically defined as an invocation of one of the methods
- * {@link LoadingCache#get(Object)}, {@link LoadingCache#getUnchecked(Object)},
- * {@link Cache#get(Object, Callable)}, or {@link LoadingCache#getAll(Iterable)}.
+ * {@link LoadingCache#get(Object)}, {@link Cache#get(Object, java.util.function.Function)}, or
+ * {@link LoadingCache#getAll(Iterable)}.
  *
  * @author ben.manes@gmail.com (Ben Manes)
  */

File: src/main/java/com/github/benmanes/caffeine/EliminationStack.java
Patch:
@@ -38,7 +38,7 @@
 
 /**
  * An unbounded thread-safe stack based on linked nodes. This stack orders elements LIFO
- * (last-in-last-out). The <em>top</em> of the stack is that element that has been on the stack
+ * (last-in-first-out). The <em>top</em> of the stack is that element that has been on the stack
  * the shortest time. New elements are inserted at and retrieved from the top of the stack. A
  * {@code EliminationStack} is an appropriate choice when many threads will exchange elements
  * through shared access to a common collection. Like most other concurrent collection

File: src/test/java/com/github/benmanes/caffeine/cache/LoadingCacheTest.java
Patch:
@@ -224,7 +224,8 @@ public void refresh_absent(LoadingCache<Integer, Integer> cache, CacheContext co
   @Test(dataProvider = "caches")
   @CacheSpec(executor = CacheExecutor.DIRECT,
   population = { Population.SINGLETON, Population.PARTIAL, Population.FULL })
-  public void refresh_present_sameValue(LoadingCache<Integer, Integer> cache, CacheContext context) {
+  public void refresh_present_sameValue(
+      LoadingCache<Integer, Integer> cache, CacheContext context) {
     for (Integer key : context.firstMiddleLastKeys()) {
       cache.refresh(key);
     }
@@ -233,7 +234,7 @@ public void refresh_present_sameValue(LoadingCache<Integer, Integer> cache, Cach
     assertThat(context, both(hasLoadSuccessCount(count)).and(hasLoadFailureCount(0)));
 
     for (Integer key : context.firstMiddleLastKeys()) {
-      assertThat(cache.get(key), is(-key));
+      assertThat(cache.get(key), is(context.original().get(key)));
     }
     assertThat(cache.estimatedSize(), is(context.initialSize()));
     assertThat(cache, hasRemovalNotifications(context, count, RemovalCause.REPLACED));

File: src/test/java/com/github/benmanes/caffeine/cache/testing/CacheValidationListener.java
Patch:
@@ -80,5 +80,6 @@ private void cleanUp(ITestResult testResult) {
     for (int i = 0; i < testResult.getParameters().length; i++) {
       testResult.getParameters()[i] = testResult.getParameters()[i].toString();
     }
+    CacheSpec.interner.remove();
   }
 }

File: src/test/java/com/github/benmanes/caffeine/cache/AsMapTest.java
Patch:
@@ -396,8 +396,8 @@ public void putIfAbsent_present(Map<Integer, Integer> map, CacheContext context)
   @Test(dataProvider = "caches")
   @CacheSpec(removalListener = { Listener.DEFAULT, Listener.REJECTING })
   public void putIfAbsent_insert(Map<Integer, Integer> map, CacheContext context) {
-    assertThat(map.putIfAbsent(context.absentKey(), -context.absentKey()), is(nullValue()));
-    assertThat(map.get(context.absentKey()), is(-context.absentKey()));
+    assertThat(map.putIfAbsent(context.absentKey(), context.absentValue()), is(nullValue()));
+    assertThat(map.get(context.absentKey()), is(context.absentValue()));
     assertThat(map.size(), is(context.original().size() + 1));
   }
 

File: src/test/java/com/github/benmanes/caffeine/cache/BoundedLocalCacheTest.java
Patch:
@@ -76,7 +76,8 @@ public void evict_alreadyRemoved(Cache<Integer, Integer> cache, CacheContext con
     localCache.put(oldKey, -oldKey);
     localCache.evictionLock.lock();
     try {
-      Node<Integer, Integer> node = localCache.data.get(oldKey);
+      Object keyRef = localCache.keyStrategy.getKeyRef(oldKey);
+      Node<Integer, Integer> node = localCache.data.get(keyRef);
       checkStatus(localCache, node, Status.ALIVE);
       new Thread(() -> {
         localCache.put(newKey, -newKey);

File: src/test/java/com/github/benmanes/caffeine/cache/CacheTest.java
Patch:
@@ -373,7 +373,7 @@ public void invalidateAll_partial(Cache<Integer, Integer> cache, CacheContext co
   @Test(dataProvider = "caches")
   @CacheSpec(population = { Population.SINGLETON, Population.PARTIAL, Population.FULL })
   public void invalidateAll_full(Cache<Integer, Integer> cache, CacheContext context) {
-    cache.invalidateAll(cache.asMap().keySet());
+    cache.invalidateAll(context.original().keySet());
     assertThat(cache.size(), is(0L));
     assertThat(cache, hasRemovalNotifications(context,
         context.original().size(), RemovalCause.EXPLICIT));

File: src/test/java/com/github/benmanes/caffeine/cache/testing/HasRemovalNotifications.java
Patch:
@@ -67,7 +67,7 @@ protected boolean matchesSafely(Object ignored, Description description) {
     List<RemovalNotification<Integer, Integer>> notifications = context.consumedNotifications();
     if (!notifications.isEmpty()) {
       ForkJoinPool.commonPool().awaitQuiescence(10, TimeUnit.SECONDS);
-      desc.expectThat(notifications, hasSize(count));
+      desc.expectThat("notification size", notifications, hasSize(count));
 
       for (RemovalNotification<?, ?> notification : notifications) {
         checkNotification(notification);

File: src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -874,7 +874,7 @@ public void clear() {
 
   @Override
   public boolean containsKey(Object key) {
-    return data.containsKey(key);
+    return data.containsKey(keyStrategy.getKeyRef(key));
   }
 
   @Override

File: src/test/java/com/github/benmanes/caffeine/cache/IsValidBoundedLocalCache.java
Patch:
@@ -141,7 +141,7 @@ private void checkNode(BoundedLocalCache<K, V> map,
     builder.expectThat("weight", node.get().weight, is(weigher.weigh(key, value)));
 
     builder.expectThat("inconsistent", map.containsKey(key), is(true));
-    builder.expectThat("found wrong node", map.data.get(key), is(node));
+    builder.expectThat("found wrong node", map.data.get(node.keyRef), is(node));
 
     if (!map.collectValues()) {
       builder.expectThat(value, is(not(nullValue())));

File: src/test/java/com/github/benmanes/caffeine/cache/testing/CacheSpec.java
Patch:
@@ -215,8 +215,8 @@ ReferenceType[] keys() default {
   /** The reference type of that the cache holds a value with (strong, soft, or weak). */
   ReferenceType[] values() default {
     ReferenceType.STRONG,
-    //ReferenceType.WEAK,
-    //ReferenceType.SOFT
+    ReferenceType.WEAK,
+    ReferenceType.SOFT
   };
 
   /** The reference type of cache keys and/or values. */

File: src/jmh/java/com/github/benmanes/caffeine/cache/GetPutBenchmark.java
Patch:
@@ -38,8 +38,8 @@ public class GetPutBenchmark {
   private static final int MASK = SIZE - 1;
 
   @Param({
-    "LinkedHashMap_Lru",
-    "ConcurrentHashMap",
+//    "LinkedHashMap_Lru",
+//    "ConcurrentHashMap",
     "ConcurrentLinkedHashMap",
     "Caffeine",
     "Guava",

File: src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -399,6 +399,8 @@ void evict(Node<K, V> node, RemovalCause cause) {
     if (data.remove(node.key, node) && hasRemovalListener()) {
       notifyRemoval(node.key, node.getValue(), cause);
     }
+
+    writeOrderDeque.remove(node);
   }
 
   @GuardedBy("evictionLock")

File: src/test/java/com/github/benmanes/caffeine/cache/testing/CacheSpec.java
Patch:
@@ -141,7 +141,7 @@ Expire[] expireAfterAccess() default {
   /** The expiration time-to-live setting, each resulting in a new combination. */
   Expire[] expireAfterWrite() default {
     Expire.DISABLED,
-    //Expire.FOREVER
+    Expire.FOREVER
   };
 
   enum Expire {

File: src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -2019,7 +2019,7 @@ Object readResolve() {
   /* ---------------- Manual Cache -------------- */
 
   static class LocalManualCache<K, V> implements Cache<K, V> {
-    BoundedLocalCache<K, V> cache;
+    final BoundedLocalCache<K, V> cache;
     transient Advanced<K, V> advanced;
 
     LocalManualCache(Caffeine<K, V> builder) {

File: src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -2236,7 +2236,6 @@ public Map<K, V> getAll(Iterable<? extends K> keys) {
           result.put(key, value);
         }
       }
-      cache.statsCounter.recordHits(result.size());
       if (keysToLoad.isEmpty()) {
         return result;
       }

File: src/main/java/com/github/benmanes/caffeine/cache/BoundedLocalCache.java
Patch:
@@ -48,7 +48,6 @@
 import java.util.concurrent.locks.AbstractQueuedSynchronizer;
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.BiFunction;
 import java.util.function.Function;
 import java.util.logging.Level;
@@ -234,7 +233,7 @@ private BoundedLocalCache(Caffeine<K, V> builder) {
     capacity = new PaddedAtomicLong(Math.min(builder.getMaximumWeight(), MAXIMUM_CAPACITY));
 
     // The eviction support
-    evictionLock = new ReentrantLock();
+    evictionLock = new Sync();
     weigher = builder.getWeigher();
     weightedSize = new PaddedAtomicLong();
     evictionDeque = new LinkedDeque<Node<K, V>>();

File: src/test/java/com/github/benmanes/caffeine/cache/testing/HasStats.java
Patch:
@@ -64,7 +64,7 @@ protected boolean matchesSafely(CacheContext context, Description description) {
       case LOAD_SUCCESS:
         return desc.expectThat(context.stats().loadSuccessCount(), is(count)).matches();
       case LOAD_FAILURE:
-        return desc.expectThat(context.stats().loadExceptionCount(), is(count)).matches();
+        return desc.expectThat(context.stats().loadFailureCount(), is(count)).matches();
       default:
         throw new AssertionError("Unknown stats type");
     }

File: src/main/java/com/github/benmanes/caffeine/cache/stats/ConcurrentStatsCounter.java
Patch:
@@ -61,7 +61,7 @@ public void recordLoadSuccess(long loadTime) {
   }
 
   @Override
-  public void recordLoadException(long loadTime) {
+  public void recordLoadFailure(long loadTime) {
     loadExceptionCount.increment();
     totalLoadTime.add(loadTime);
   }

File: src/main/java/com/github/benmanes/caffeine/cache/stats/DisabledStatsCounter.java
Patch:
@@ -35,7 +35,7 @@ public void recordMisses(int count) {}
   public void recordLoadSuccess(long loadTime) {}
 
   @Override
-  public void recordLoadException(long loadTime) {}
+  public void recordLoadFailure(long loadTime) {}
 
   @Override
   public void recordEviction() {}

File: src/test/java/com/github/benmanes/caffeine/cache/LoadingCacheTest.java
Patch:
@@ -199,11 +199,11 @@ public void refresh_failure(LoadingCache<Integer, Integer> cache, CacheContext c
 
   @Test(dataProvider = "caches")
   @CacheSpec(executor = CacheExecutor.DIRECT,
-  removalListener = { Listener.DEFAULT, Listener.REJECTING })
+      removalListener = { Listener.DEFAULT, Listener.REJECTING })
   public void refresh_absent(LoadingCache<Integer, Integer> cache, CacheContext context) {
     cache.refresh(context.absentKey());
     assertThat(cache.size(), is(1 + context.initialSize()));
-    assertThat(context, both(hasMissCount(0)).and(hasHitCount(0)));
+    assertThat(context, both(hasMissCount(1)).and(hasHitCount(0)));
     assertThat(context, both(hasLoadSuccessCount(1)).and(hasLoadFailureCount(0)));
 
     // records a hit

File: src/test/java/com/github/benmanes/caffeine/cache/testing/CacheSpec.java
Patch:
@@ -214,6 +214,7 @@ enum Loader implements CacheLoader<Integer, Integer> {
 
   /** The executors retrieved from a supplier, each resulting in a new combination. */
   CacheExecutor[] executor() default {
+    //CacheExecutor.DEFAULT,
     CacheExecutor.DIRECT,
   };
 

File: src/test/java/com/github/benmanes/caffeine/cache/testing/CacheContext.java
Patch:
@@ -26,6 +26,7 @@
 import javax.annotation.Nullable;
 
 import com.github.benmanes.caffeine.cache.RemovalListener;
+import com.github.benmanes.caffeine.cache.testing.CacheSpec.InitialCapacity;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Listener;
 import com.github.benmanes.caffeine.cache.testing.CacheSpec.Population;
 import com.google.common.base.MoreObjects;
@@ -40,7 +41,7 @@ public final class CacheContext {
   Listener removalListenerType;
   Population population;
 
-  Integer initialCapacity;
+  InitialCapacity initialCapacity;
   Executor executor;
 
   @Nullable Integer maximumSize;
@@ -98,6 +99,7 @@ public CacheContext copy() {
     CacheContext context = new CacheContext();
     context.removalListenerType = removalListenerType;
     context.removalListener = (removalListenerType == null) ? null : removalListenerType.create();
+    context.initialCapacity = initialCapacity;
     context.maximumSize = maximumSize;
     context.firstKey = firstKey;
     context.midKey = midKey;

File: src/main/java/com/github/benmanes/caffeine/cache/Caffeine.java
Patch:
@@ -72,7 +72,7 @@ public void initialCapacity(int initialCapacity) {
   }
 
   public Caffeine<K, V> executor(Executor executor) {
-    executor = requireNonNull(executor);
+    this.executor = requireNonNull(executor);
     return this;
   }
 

File: src/main/java/com/github/benmanes/caffeine/cache/RemovalNotification.java
Patch:
@@ -22,6 +22,8 @@
  */
 public final class RemovalNotification<K, V> implements Entry<K, V> {
 
+  public RemovalNotification(RemovalCause cause, K key, V value) {}
+
   @Override
   public K getKey() {
     return null;

File: src/jmh/java/com/github/benmanes/caffeine/cache/CacheType.java
Patch:
@@ -21,6 +21,8 @@
 
 import org.cliffc.high_scale_lib.NonBlockingHashMap;
 
+import com.github.benmanes.caffeine.cache.map.BoundedLinkedHashMap;
+import com.github.benmanes.caffeine.cache.map.ConcurrentHashMapV7;
 import com.google.common.cache.CacheBuilder;
 import com.googlecode.concurrentlinkedhashmap.ConcurrentLinkedHashMap;
 

File: src/jmh/java/com/github/benmanes/caffeine/cache/map/BoundedLinkedHashMap.java
Patch:
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.github.benmanes.caffeine.cache;
+package com.github.benmanes.caffeine.cache.map;
 
 import java.util.LinkedHashMap;
 import java.util.Map;

File: src/jmh/java/com/github/benmanes/caffeine/cache/map/ConcurrentHashMapV7.java
Patch:
@@ -32,7 +32,7 @@
  * Expert Group and released to the public domain, as explained at
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
-package com.github.benmanes.caffeine.cache;
+package com.github.benmanes.caffeine.cache.map;
 
 import java.io.IOException;
 import java.io.ObjectInputStream;

File: src/main/java/com/github/benmanes/caffeine/cache/Cache.java
Patch:
@@ -22,7 +22,6 @@
 
 import javax.annotation.Nullable;
 
-import com.google.common.cache.CacheStats;
 import com.google.common.util.concurrent.ExecutionError;
 import com.google.common.util.concurrent.UncheckedExecutionException;
 
@@ -46,7 +45,7 @@ public interface Cache<K, V> {
 
   void put(K key, V value);
 
-  void putAll(Map<? extends K,? extends V> m);
+  void putAll(Map<? extends K,? extends V> map);
 
   void invalidate(Object key);
 
@@ -56,7 +55,7 @@ public interface Cache<K, V> {
 
   long size();
 
-  /* TODO */ CacheStats stats();
+  /* TODO(ben): CacheStats stats(); */
 
   ConcurrentMap<K, V> asMap();
 

File: src/main/java/com/github/benmanes/caffeine/SingleConsumerQueue.java
Patch:
@@ -454,6 +454,9 @@ Object readResolve() {
   static final class Node<E> {
     final static long NEXT_OFFSET = UnsafeAccess.objectFieldOffset(Node.class, "next");
 
+    // Improve likelihood of isolation on <= 64 byte cache lines (volatile to avoid reordering)
+    transient volatile long q0, q1, q2, q3, q4, q5, q6, q7, q8, q9, qa, qb, qc, qd, qe;
+
     volatile Node<E> next;
     E value;
 

File: src/main/java/com/github/benmanes/caffeine/EliminationStack.java
Patch:
@@ -24,6 +24,7 @@
 import java.util.AbstractQueue;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Queue;
@@ -35,7 +36,6 @@
 import com.github.benmanes.caffeine.atomic.PaddedAtomicReference;
 import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.ForwardingIterator;
-import com.google.common.collect.Lists;
 
 /**
  * An unbounded thread-safe stack based on linked nodes. This stack orders elements LIFO
@@ -543,7 +543,8 @@ static final class SerializationProxy<E> implements Serializable {
     }
 
     Object readResolve() {
-      return new EliminationStack<>(Lists.reverse(elements));
+      Collections.reverse(elements);
+      return new EliminationStack<>(elements);
     }
 
     static final long serialVersionUID = 1;

File: src/test/java/com/github/benmanes/caffeine/EliminationStackTest.java
Patch:
@@ -341,12 +341,12 @@ public void serialize_whenPopulated(EliminationStack<Integer> stack) {
 
   /* ---------------- Stack providers -------------- */
 
-  @DataProvider
+  @DataProvider(name = "empty")
   public Object[][] emptyStack() {
     return new Object[][] {{ new EliminationStack<Integer>() }};
   }
 
-  @DataProvider
+  @DataProvider(name = "populated")
   public Object[][] populatedStack() {
     return new Object[][] {{ newPopulatedStack() }};
   }

File: src/test/java/com/github/benmanes/caffeine/SingleConsumerQueueTest.java
Patch:
@@ -344,7 +344,8 @@ public void iterator_whenEmpty(Queue<Integer> queue) {
   public void iterator_whenPopulated(Queue<Integer> queue) {
     List<Integer> copy = new ArrayList<>();
     populate(copy, queue.size());
-    assertThat(elementsEqual(queue.iterator(), copy.iterator()), is(true));
+    assertThat(String.format("\nExpected: %s%n     but: %s", queue, copy),
+        elementsEqual(queue.iterator(), copy.iterator()));
   }
 
   @Test(dataProvider = "populated", expectedExceptions = IllegalStateException.class)

File: src/test/java/com/github/benmanes/caffeine/ConcurrentTestHarness.java
Patch:
@@ -15,8 +15,6 @@
  */
 package com.github.benmanes.caffeine;
 
-import static com.google.common.collect.Lists.newArrayListWithCapacity;
-
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.Callable;
@@ -67,7 +65,7 @@ public static <T> TestResult<T> timeTasks(int nThreads, Callable<T> task) {
     CountDownLatch endGate = new CountDownLatch(nThreads);
     AtomicReferenceArray<T> results = new AtomicReferenceArray<T>(nThreads);
 
-    List<Thread> threads = newArrayListWithCapacity(nThreads);
+    List<Thread> threads = new ArrayList<>(nThreads);
     for (int i = 0; i < nThreads; i++) {
       final int index = i;
       Thread thread = new Thread(() -> {

File: src/test/java/com/github/benmanes/caffeine/SingleConsumerQueueTest.java
Patch:
@@ -241,7 +241,7 @@ public void removeAll_withPopulated(Queue<Integer> queue) {
     assertThat(queue.contains(first), is(false));
   }
 
-  @Test(enabled = false, dataProvider = "populated")
+  @Test(dataProvider = "populated")
   public void removeAll_toEmpty(Queue<Integer> queue) {
     assertThat(queue.removeAll(ImmutableList.copyOf(queue)), is(true));
     assertThat(queue, is(emptyCollection()));
@@ -255,15 +255,15 @@ public void retainAll_withEmpty(Queue<Integer> queue) {
     assertThat(queue, is(emptyCollection()));
   }
 
-  @Test(enabled = false, dataProvider = "populated")
+  @Test(dataProvider = "populated")
   public void retainAll_withPopulated(Queue<Integer> queue) {
     Integer first = queue.peek();
     assertThat(queue.retainAll(ImmutableList.of(first)), is(true));
     assertThat(queue, hasSize(1));
     assertThat(queue.contains(first), is(true));
   }
 
-  @Test(enabled = false, dataProvider = "populated")
+  @Test(dataProvider = "populated")
   public void retainAll_toEmpty(Queue<Integer> queue) {
     assertThat(queue.retainAll(ImmutableList.of()), is(true));
     assertThat(queue, is(emptyCollection()));

File: src/main/java/com/github/benmanes/caffeine/SingleConsumerQueue.java
Patch:
@@ -105,12 +105,12 @@ public final class SingleConsumerQueue<E> implements Queue<E>, Serializable {
   final static long TAIL_OFFSET =
       UnsafeAccess.objectFieldOffset(SingleConsumerQueue.class, "tail");
 
-  volatile Node<E> head;
+  transient volatile Node<E> head;
 
   // Improve likelihood of isolation on <= 64 byte cache lines (volatile to avoid reordering)
-  volatile long q0, q1, q2, q3, q4, q5, q6, q7, q8, q9, qa, qb, qc, qd, qe;
+  transient volatile long q0, q1, q2, q3, q4, q5, q6, q7, q8, q9, qa, qb, qc, qd, qe;
 
-  volatile Node<E> tail;
+  transient volatile Node<E> tail;
 
   public SingleConsumerQueue(Collection<E> c) {
     this();

